[
  {
    "head": "org.springframework.util.CollectionUtilsTests#changesValueByReference()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid changesValueByReference() {\r\n    Map<String, List<String>> wrapped = new HashMap<>();\r\n    MultiValueMap<String, String> asMultiValueMap = CollectionUtils.toMultiValueMap(wrapped);\r\n    assertThat(asMultiValueMap).doesNotContainKeys(\"key\");\r\n    wrapped.put(\"key\", new ArrayList<>());\r\n    assertThat(asMultiValueMap).containsKey(\"key\");\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.CollectionUtilsTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.CollectionUtilsTests#changesValueByReference()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.CollectionUtilsTests#changesValueByReference()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.CollectionUtilsTests#compositeMap()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid compositeMap() {\r\n    Map<String, String> first = new HashMap<>();\r\n    first.put(\"key1\", \"value1\");\r\n    first.put(\"key2\", \"value2\");\r\n    Map<String, String> second = new HashMap<>();\r\n    second.put(\"key3\", \"value3\");\r\n    second.put(\"key4\", \"value4\");\r\n    Map<String, String> compositeMap = CollectionUtils.compositeMap(first, second);\r\n    assertThat(compositeMap).containsKeys(\"key1\", \"key2\", \"key3\", \"key4\");\r\n    assertThat(compositeMap).containsValues(\"value1\", \"value2\", \"value3\", \"value4\");\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.CollectionUtilsTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.CollectionUtilsTests#compositeMap()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.CollectionUtilsTests#compositeMap()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.Instance",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.Instance",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport java.util.Vector;\n\nimport org.jspecify.annotations.Nullable;\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Tests for {@link CollectionUtils}.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @author Rick Evans\n */\nclass CollectionUtilsTests {\n\n\t@Test\n\tvoid isEmpty() {\n\t\tassertThat(CollectionUtils.isEmpty((Set<Object>) null)).isTrue();\n\t\tassertThat(CollectionUtils.isEmpty((Map<String, String>) null)).isTrue();\n\t\tassertThat(CollectionUtils.isEmpty(new HashMap<>())).isTrue();\n\t\tassertThat(CollectionUtils.isEmpty(new HashSet<>())).isTrue();\n\n\t\tList<Object> list = new ArrayList<>();\n\t\tlist.add(new Object());\n\t\tassertThat(CollectionUtils.isEmpty(list)).isFalse();\n\n\t\tMap<String, String> map = new HashMap<>();\n\t\tmap.put(\"foo\", \"bar\");\n\t\tassertThat(CollectionUtils.isEmpty(map)).isFalse();\n\t}\n\n\t@Test\n\tvoid mergeArrayIntoCollection() {\n\t\tObject[] arr = new Object[] {\"value1\", \"value2\"};\n\t\tList<Comparable<?>> list = new ArrayList<>();\n\t\tlist.add(\"value3\");\n\n\t\tCollectionUtils.mergeArrayIntoCollection(arr, list);\n\t\tassertThat(list).containsExactly(\"value3\", \"value1\", \"value2\");\n\t}\n\n\t@Test\n\tvoid mergePrimitiveArrayIntoCollection() {\n\t\tint[] arr = new int[] {1, 2};\n\t\tList<Comparable<?>> list = new ArrayList<>();\n\t\tlist.add(3);\n\n\t\tCollectionUtils.mergeArrayIntoCollection(arr, list);\n\t\tassertThat(list).containsExactly(3, 1, 2);\n\t}\n\n\t@Test\n\tvoid mergePropertiesIntoMap() {\n\t\tProperties defaults = new Properties();\n\t\tdefaults.setProperty(\"prop1\", \"value1\");\n\t\tProperties props = new Properties(defaults);\n\t\tprops.setProperty(\"prop2\", \"value2\");\n\t\tprops.put(\"prop3\", 3);\n\n\t\tMap<String, Object> map = new HashMap<>();\n\t\tmap.put(\"prop4\", \"value4\");\n\n\t\tCollectionUtils.mergePropertiesIntoMap(props, map);\n\t\tassertThat(map.get(\"prop1\")).isEqualTo(\"value1\");\n\t\tassertThat(map.get(\"prop2\")).isEqualTo(\"value2\");\n\t\tassertThat(map.get(\"prop3\")).isEqualTo(3);\n\t\tassertThat(map.get(\"prop4\")).isEqualTo(\"value4\");\n\t}\n\n\t@Test\n\tvoid contains() {\n\t\tassertThat(CollectionUtils.contains((Iterator<String>) null, \"myElement\")).isFalse();\n\t\tassertThat(CollectionUtils.contains((Enumeration<String>) null, \"myElement\")).isFalse();\n\t\tassertThat(CollectionUtils.contains(new ArrayList<String>().iterator(), \"myElement\")).isFalse();\n\t\tassertThat(CollectionUtils.contains(new Hashtable<String, Object>().keys(), \"myElement\")).isFalse();\n\n\t\tList<String> list = new ArrayList<>();\n\t\tlist.add(\"myElement\");\n\t\tassertThat(CollectionUtils.contains(list.iterator(), \"myElement\")).isTrue();\n\n\t\tHashtable<String, String> ht = new Hashtable<>();\n\t\tht.put(\"myElement\", \"myValue\");\n\t\tassertThat(CollectionUtils.contains(ht.keys(), \"myElement\")).isTrue();\n\t}\n\n\t@Test\n\tvoid containsAny() {\n\t\tList<String> source = new ArrayList<>();\n\t\tsource.add(\"abc\");\n\t\tsource.add(\"def\");\n\t\tsource.add(\"ghi\");\n\n\t\tList<String> candidates = new ArrayList<>();\n\t\tcandidates.add(\"xyz\");\n\t\tcandidates.add(\"def\");\n\t\tcandidates.add(\"abc\");\n\n\t\tassertThat(CollectionUtils.containsAny(source, candidates)).isTrue();\n\t\tcandidates.remove(\"def\");\n\t\tassertThat(CollectionUtils.containsAny(source, candidates)).isTrue();\n\t\tcandidates.remove(\"abc\");\n\t\tassertThat(CollectionUtils.containsAny(source, candidates)).isFalse();\n\t}\n\n\t@Test\n\tvoid containsInstanceWithNullCollection() {\n\t\tassertThat(CollectionUtils.containsInstance(null, this)).as(\"Must return false if supplied Collection argument is null\").isFalse();\n\t}\n\n\t@Test\n\tvoid containsInstanceWithInstancesThatAreEqualButDistinct() {\n\t\tList<Instance> list = new ArrayList<>();\n\t\tlist.add(new Instance(\"fiona\"));\n\t\tassertThat(CollectionUtils.containsInstance(list, new Instance(\"fiona\"))).as(\"Must return false if instance is not in the supplied Collection argument\").isFalse();\n\t}\n\n\t@Test\n\tvoid containsInstanceWithSameInstance() {\n\t\tList<Instance> list = new ArrayList<>();\n\t\tlist.add(new Instance(\"apple\"));\n\t\tInstance instance = new Instance(\"fiona\");\n\t\tlist.add(instance);\n\t\tassertThat(CollectionUtils.containsInstance(list, instance)).as(\"Must return true if instance is in the supplied Collection argument\").isTrue();\n\t}\n\n\t@Test\n\tvoid containsInstanceWithNullInstance() {\n\t\tList<Instance> list = new ArrayList<>();\n\t\tlist.add(new Instance(\"apple\"));\n\t\tlist.add(new Instance(\"fiona\"));\n\t\tassertThat(CollectionUtils.containsInstance(list, null)).as(\"Must return false if null instance is supplied\").isFalse();\n\t}\n\n\t@Test\n\tvoid findFirstMatch() {\n\t\tList<String> source = new ArrayList<>();\n\t\tsource.add(\"abc\");\n\t\tsource.add(\"def\");\n\t\tsource.add(\"ghi\");\n\n\t\tList<String> candidates = new ArrayList<>();\n\t\tcandidates.add(\"xyz\");\n\t\tcandidates.add(\"def\");\n\t\tcandidates.add(\"abc\");\n\n\t\tassertThat(CollectionUtils.findFirstMatch(source, candidates)).isEqualTo(\"def\");\n\t}\n\n\t@Test\n\tvoid findValueOfType() {\n\t\tList<Integer> integerList = new ArrayList<>();\n\t\tintegerList.add(1);\n\t\tassertThat(CollectionUtils.findValueOfType(integerList, Integer.class)).isEqualTo(1);\n\n\t\tSet<Integer> integerSet = new HashSet<>();\n\t\tintegerSet.add(2);\n\t\tassertThat(CollectionUtils.findValueOfType(integerSet, Integer.class)).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid findValueOfTypeWithEmptyCollection() {\n\t\tList<Integer> emptyList = new ArrayList<>();\n\t\tassertThat(CollectionUtils.findValueOfType(emptyList, Integer.class)).isNull();\n\t}\n\n\t@Test\n\tvoid findValueOfTypeWithMoreThanOneValue() {\n\t\tList<Integer> integerList = new ArrayList<>();\n\t\tintegerList.add(1);\n\t\tintegerList.add(2);\n\t\tassertThat(CollectionUtils.findValueOfType(integerList, Integer.class)).isNull();\n\t}\n\n\t@Test\n\tvoid hasUniqueObject() {\n\t\tList<String> list = new ArrayList<>();\n\t\tlist.add(\"myElement\");\n\t\tlist.add(\"myOtherElement\");\n\t\tassertThat(CollectionUtils.hasUniqueObject(list)).isFalse();\n\n\t\tlist = new ArrayList<>();\n\t\tlist.add(\"myElement\");\n\t\tassertThat(CollectionUtils.hasUniqueObject(list)).isTrue();\n\n\t\tlist = new ArrayList<>();\n\t\tlist.add(\"myElement\");\n\t\tlist.add(null);\n\t\tassertThat(CollectionUtils.hasUniqueObject(list)).isFalse();\n\n\t\tlist = new ArrayList<>();\n\t\tlist.add(null);\n\t\tlist.add(\"myElement\");\n\t\tassertThat(CollectionUtils.hasUniqueObject(list)).isFalse();\n\n\t\tlist = new ArrayList<>();\n\t\tlist.add(null);\n\t\tlist.add(null);\n\t\tassertThat(CollectionUtils.hasUniqueObject(list)).isTrue();\n\n\t\tlist = new ArrayList<>();\n\t\tlist.add(null);\n\t\tassertThat(CollectionUtils.hasUniqueObject(list)).isTrue();\n\n\t\tlist = new ArrayList<>();\n\t\tassertThat(CollectionUtils.hasUniqueObject(list)).isFalse();\n\t}\n\n\t@Test\n\tvoid findCommonElementType() {\n\t\tList<Integer> integerList = new ArrayList<>();\n\t\tintegerList.add(1);\n\t\tintegerList.add(2);\n\n\t\tassertThat(CollectionUtils.findCommonElementType(integerList)).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid findCommonElementTypeWithEmptyCollection() {\n\t\tList<Integer> emptyList = new ArrayList<>();\n\t\tassertThat(CollectionUtils.findCommonElementType(emptyList)).isNull();\n\t}\n\n\t@Test\n\tvoid findCommonElementTypeWithDifferentElementType() {\n\t\tList<Object> list = new ArrayList<>();\n\t\tlist.add(1);\n\t\tlist.add(\"foo\");\n\t\tassertThat(CollectionUtils.findCommonElementType(list)).isNull();\n\t}\n\n\t@Test\n\tvoid firstElementWithSet() {\n\t\tSet<Integer> set = new HashSet<>();\n\t\tset.add(17);\n\t\tset.add(3);\n\t\tset.add(2);\n\t\tset.add(1);\n\t\tassertThat(CollectionUtils.firstElement(set)).isEqualTo(17);\n\t}\n\n\t@Test\n\tvoid firstElementWithSortedSet() {\n\t\tSortedSet<Integer> sortedSet = new TreeSet<>();\n\t\tsortedSet.add(17);\n\t\tsortedSet.add(3);\n\t\tsortedSet.add(2);\n\t\tsortedSet.add(1);\n\t\tassertThat(CollectionUtils.firstElement(sortedSet)).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid firstElementWithList() {\n\t\tList<Integer> list = new ArrayList<>();\n\t\tlist.add(1);\n\t\tlist.add(2);\n\t\tlist.add(3);\n\t\tassertThat(CollectionUtils.firstElement(list)).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid lastElementWithSet() {\n\t\tSet<Integer> set = new HashSet<>();\n\t\tset.add(17);\n\t\tset.add(3);\n\t\tset.add(2);\n\t\tset.add(1);\n\t\tassertThat(CollectionUtils.lastElement(set)).isEqualTo(3);\n\t}\n\n\t@Test\n\tvoid lastElementWithSortedSet() {\n\t\tSortedSet<Integer> sortedSet = new TreeSet<>();\n\t\tsortedSet.add(17);\n\t\tsortedSet.add(3);\n\t\tsortedSet.add(2);\n\t\tsortedSet.add(1);\n\t\tassertThat(CollectionUtils.lastElement(sortedSet)).isEqualTo(17);\n\t}\n\n\t@Test\n\tvoid lastElementWithList() {\n\t\tList<Integer> list = new ArrayList<>();\n\t\tlist.add(1);\n\t\tlist.add(2);\n\t\tlist.add(3);\n\t\tassertThat(CollectionUtils.lastElement(list)).isEqualTo(3);\n\t}\n\n\t@Test\n\tvoid toArray() {\n\t\tVector<String> vector = new Vector<>();\n\t\tvector.add(\"foo\");\n\t\tvector.add(\"bar\");\n\t\tEnumeration<String> enumeration = vector.elements();\n\t\tassertThat(CollectionUtils.toArray(enumeration, new String[]{})).containsExactly(\"foo\", \"bar\");\n\t}\n\n\t@Test\n\tvoid conversionOfEmptyMap() {\n\t\tMultiValueMap<String, String> asMultiValueMap = CollectionUtils.toMultiValueMap(new HashMap<>());\n\t\tassertThat(asMultiValueMap).isEmpty();\n\t\tassertThat(asMultiValueMap).isEmpty();\n\t}\n\n\t@Test\n\tvoid conversionOfNonEmptyMap() {\n\t\tMap<String, List<String>> wrapped = new HashMap<>();\n\t\twrapped.put(\"key\", Arrays.asList(\"first\", \"second\"));\n\t\tMultiValueMap<String, String> asMultiValueMap = CollectionUtils.toMultiValueMap(wrapped);\n\t\tassertThat(asMultiValueMap).containsAllEntriesOf(wrapped);\n\t}\n\n\t@Test\n\tvoid changesValueByReference() {\n\t\tMap<String, List<String>> wrapped = new HashMap<>();\n\t\tMultiValueMap<String, String> asMultiValueMap = CollectionUtils.toMultiValueMap(wrapped);\n\t\tassertThat(asMultiValueMap).doesNotContainKeys(\"key\");\n\t\twrapped.put(\"key\", new ArrayList<>());\n\t\tassertThat(asMultiValueMap).containsKey(\"key\");\n\t}\n\n\t@Test\n\tvoid compositeMap() {\n\t\tMap<String, String> first = new HashMap<>();\n\t\tfirst.put(\"key1\", \"value1\");\n\t\tfirst.put(\"key2\", \"value2\");\n\n\t\tMap<String, String> second = new HashMap<>();\n\t\tsecond.put(\"key3\", \"value3\");\n\t\tsecond.put(\"key4\", \"value4\");\n\n\t\tMap<String, String> compositeMap = CollectionUtils.compositeMap(first, second);\n\n\t\tassertThat(compositeMap).containsKeys(\"key1\", \"key2\", \"key3\", \"key4\");\n\t\tassertThat(compositeMap).containsValues(\"value1\", \"value2\", \"value3\", \"value4\");\n\t}\n\n\n\tprivate static final class Instance {\n\n\t\tprivate final String name;\n\n\t\tpublic Instance(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(@Nullable Object rhs) {\n\t\t\tif (this == rhs) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (rhs == null || this.getClass() != rhs.getClass()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tInstance instance = (Instance) rhs;\n\t\t\treturn this.name.equals(instance.name);\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn this.name.hashCode();\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.Instance",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.Instance#name",
    "tailType": "field"
  },
  {
    "head": "org.springframework.util.Instance#name",
    "headType": "field",
    "relation": "haveType",
    "tail": "String",
    "tailType": "type"
  },
  {
    "head": "org.springframework.util.Instance#equals(Object)",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic boolean equals(@Nullable Object rhs) {\r\n    if (this == rhs) {\r\n        return true;\r\n    }\r\n    if (rhs == null || this.getClass() != rhs.getClass()) {\r\n        return false;\r\n    }\r\n    Instance instance = (Instance) rhs;\r\n    return this.name.equals(instance.name);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.Instance",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.Instance#equals(Object)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.Instance#equals(Object)",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.Instance#hashCode()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic int hashCode() {\r\n    return this.name.hashCode();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.Instance",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.Instance#hashCode()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.Instance#hashCode()",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.aot.hint.predicate",
    "tailType": "package"
  },
  {
    "head": "org.springframework.aot.hint.predicate",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.aot.hint.predicate.ReflectionHintsPredicates",
    "tailType": "class"
  },
  {
    "head": "org.springframework.aot.hint.predicate.ReflectionHintsPredicates",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.aot.hint.predicate;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Executable;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.function.Predicate;\n\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.aot.hint.ExecutableHint;\nimport org.springframework.aot.hint.ExecutableMode;\nimport org.springframework.aot.hint.MemberCategory;\nimport org.springframework.aot.hint.ReflectionHints;\nimport org.springframework.aot.hint.RuntimeHints;\nimport org.springframework.aot.hint.TypeHint;\nimport org.springframework.aot.hint.TypeReference;\nimport org.springframework.core.MethodIntrospector;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ReflectionUtils;\n\n/**\n * Generator of {@link ReflectionHints} predicates, testing whether the given hints\n * match the expected behavior for reflection.\n *\n * @author Brian Clozel\n * @author Stephane Nicoll\n * @since 6.0\n */\npublic class ReflectionHintsPredicates {\n\n\tReflectionHintsPredicates() {\n\t}\n\n\n\t/**\n\t * Return a predicate that checks whether a reflection hint is registered for the given type.\n\t * <p>The returned type exposes additional methods that refine the predicate behavior.\n\t * @param typeReference the type\n\t * @return the {@link RuntimeHints} predicate\n\t */\n\tpublic TypeHintPredicate onType(TypeReference typeReference) {\n\t\tAssert.notNull(typeReference, \"'typeReference' must not be null\");\n\t\treturn new TypeHintPredicate(typeReference);\n\t}\n\n\t/**\n\t * Return a predicate that checks whether a reflection hint is registered for the given type.\n\t * <p>The returned type exposes additional methods that refine the predicate behavior.\n\t * @param type the type\n\t * @return the {@link RuntimeHints} predicate\n\t */\n\tpublic TypeHintPredicate onType(Class<?> type) {\n\t\tAssert.notNull(type, \"'type' must not be null\");\n\t\treturn new TypeHintPredicate(TypeReference.of(type));\n\t}\n\n\t/**\n\t * Return a predicate that checks whether a reflection hint is registered for the given constructor.\n\t * By default, both introspection and invocation hints match.\n\t * <p>The returned type exposes additional methods that refine the predicate behavior.\n\t * @param constructor the constructor\n\t * @return the {@link RuntimeHints} predicate\n\t * @deprecated since 7.0 in favor of {@link #onConstructorInvocation(Constructor)}\n\t * or {@link #onType(Class)}.\n\t */\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\tpublic ConstructorHintPredicate onConstructor(Constructor<?> constructor) {\n\t\tAssert.notNull(constructor, \"'constructor' must not be null\");\n\t\treturn new ConstructorHintPredicate(constructor);\n\t}\n\n\t/**\n\t * Return a predicate that checks whether an invocation hint is registered for the given constructor.\n\t * @param constructor the constructor\n\t * @return the {@link RuntimeHints} predicate\n\t * @since 7.0\n\t */\n\tpublic Predicate<RuntimeHints> onConstructorInvocation(Constructor<?> constructor) {\n\t\tAssert.notNull(constructor, \"'constructor' must not be null\");\n\t\treturn new ConstructorHintPredicate(constructor).invoke();\n\t}\n\n\t/**\n\t * Return a predicate that checks whether a reflection hint is registered for the given method.\n\t * By default, both introspection and invocation hints match.\n\t * <p>The returned type exposes additional methods that refine the predicate behavior.\n\t * @param method the method\n\t * @return the {@link RuntimeHints} predicate\n\t * @deprecated since 7.0 in favor of {@link #onMethodInvocation(Method)}\n\t * or {@link #onType(Class)}.\n\t */\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\tpublic MethodHintPredicate onMethod(Method method) {\n\t\tAssert.notNull(method, \"'method' must not be null\");\n\t\treturn new MethodHintPredicate(method);\n\t}\n\n\t/**\n\t * Return a predicate that checks whether an invocation hint is registered for the given method.\n\t * @param method the method\n\t * @return the {@link RuntimeHints} predicate\n\t * @since 7.0\n\t */\n\tpublic Predicate<RuntimeHints> onMethodInvocation(Method method) {\n\t\tAssert.notNull(method, \"'method' must not be null\");\n\t\treturn new MethodHintPredicate(method).invoke();\n\t}\n\n\t/**\n\t * Return a predicate that checks whether a reflection hint is registered for the method that matches the given selector.\n\t * This looks up a method on the given type with the expected name, if unique.\n\t * By default, both introspection and invocation hints match.\n\t * <p>The returned type exposes additional methods that refine the predicate behavior.\n\t * @param type the type holding the method\n\t * @param methodName the method name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws IllegalArgumentException if the method cannot be found or if multiple methods are found with the same name.\n\t * @deprecated since 7.0 in favor of {@link #onMethodInvocation(Class, String)}\n\t * or {@link #onType(Class)}.\n\t */\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\tpublic MethodHintPredicate onMethod(Class<?> type, String methodName) {\n\t\tAssert.notNull(type, \"'type' must not be null\");\n\t\tAssert.hasText(methodName, \"'methodName' must not be empty\");\n\t\treturn new MethodHintPredicate(getMethod(type, methodName));\n\t}\n\n\t/**\n\t * Return a predicate that checks whether an invocation hint is registered for the method that matches the given selector.\n\t * This looks up a method on the given type with the expected name, if unique.\n\t * @param type the type holding the method\n\t * @param methodName the method name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws IllegalArgumentException if the method cannot be found or if multiple methods are found with the same name.\n\t * @since 7.0\n\t */\n\tpublic Predicate<RuntimeHints> onMethodInvocation(Class<?> type, String methodName) {\n\t\tAssert.notNull(type, \"'type' must not be null\");\n\t\tAssert.hasText(methodName, \"'methodName' must not be empty\");\n\t\treturn new MethodHintPredicate(getMethod(type, methodName)).invoke();\n\t}\n\n\t/**\n\t * Return a predicate that checks whether a reflection hint is registered for the method that matches the given selector.\n\t * This looks up a method on the given type with the expected name, if unique.\n\t * By default, both introspection and invocation hints match.\n\t * <p>The returned type exposes additional methods that refine the predicate behavior.\n\t * @param className the name of the class holding the method\n\t * @param methodName the method name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws ClassNotFoundException if the class cannot be resolved.\n\t * @throws IllegalArgumentException if the method cannot be found or if multiple methods are found with the same name.\n\t * @deprecated since 7.0 in favor of {@link #onMethodInvocation(String, String)}\n\t * or {@link #onType(Class)}.\n\t */\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\tpublic MethodHintPredicate onMethod(String className, String methodName) throws ClassNotFoundException {\n\t\tAssert.hasText(className, \"'className' must not be empty\");\n\t\tAssert.hasText(methodName, \"'methodName' must not be empty\");\n\t\treturn onMethod(Class.forName(className), methodName);\n\t}\n\n\t/**\n\t * Return a predicate that checks whether an invocation hint is registered for the method that matches the given selector.\n\t * This looks up a method on the given type with the expected name, if unique.\n\t * @param className the name of the class holding the method\n\t * @param methodName the method name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws ClassNotFoundException if the class cannot be resolved.\n\t * @throws IllegalArgumentException if the method cannot be found or if multiple methods are found with the same name.\n\t * @since 7.0\n\t */\n\tpublic Predicate<RuntimeHints> onMethodInvocation(String className, String methodName) throws ClassNotFoundException {\n\t\tAssert.hasText(className, \"'className' must not be empty\");\n\t\tAssert.hasText(methodName, \"'methodName' must not be empty\");\n\t\treturn onMethod(Class.forName(className), methodName).invoke();\n\t}\n\n\tprivate Method getMethod(Class<?> type, String methodName) {\n\t\tReflectionUtils.MethodFilter selector = method -> methodName.equals(method.getName());\n\t\tSet<Method> methods = MethodIntrospector.selectMethods(type, selector);\n\t\tif (methods.size() == 1) {\n\t\t\treturn methods.iterator().next();\n\t\t}\n\t\telse if (methods.size() > 1) {\n\t\t\tthrow new IllegalArgumentException(\"Found multiple methods named '%s' on class %s\".formatted(methodName, type.getName()));\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"No method named '%s' on class %s\".formatted(methodName, type.getName()));\n\t\t}\n\t}\n\n\t/**\n\t * Return a predicate that checks whether a reflective field access hint is registered for the field.\n\t * This looks up a field on the given type with the expected name, if present.\n\t * @param type the type holding the field\n\t * @param fieldName the field name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws IllegalArgumentException if a field cannot be found with the given name.\n\t * @deprecated since 7.0 in favor of {@link #onFieldAccess(Class, String)} with similar semantics.\n\t */\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\tpublic Predicate<RuntimeHints> onField(Class<?> type, String fieldName) {\n\t\treturn onFieldAccess(type, fieldName);\n\t}\n\n\t/**\n\t * Return a predicate that checks whether a reflective field access hint is registered for the field.\n\t * This looks up a field on the given type with the expected name, if present.\n\t * @param type the type holding the field\n\t * @param fieldName the field name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws IllegalArgumentException if a field cannot be found with the given name.\n\t * @since 7.0\n\t */\n\tpublic Predicate<RuntimeHints> onFieldAccess(Class<?> type, String fieldName) {\n\t\tAssert.notNull(type, \"'type' must not be null\");\n\t\tAssert.hasText(fieldName, \"'fieldName' must not be empty\");\n\t\tField field = ReflectionUtils.findField(type, fieldName);\n\t\tif (field == null) {\n\t\t\tthrow new IllegalArgumentException(\"No field named '%s' on class %s\".formatted(fieldName, type.getName()));\n\t\t}\n\t\treturn new FieldHintPredicate(field);\n\t}\n\n\t/**\n\t * Return a predicate that checks whether a reflective field access hint is registered for the field.\n\t * This looks up a field on the given type with the expected name, if present.\n\t * @param className the name of the class holding the field\n\t * @param fieldName the field name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws ClassNotFoundException if the class cannot be resolved.\n\t * @throws IllegalArgumentException if a field cannot be found with the given name.\n\t * @deprecated since 7.0 in favor of {@link #onFieldAccess(String, String)} with similar semantics.\n\t */\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\tpublic Predicate<RuntimeHints> onField(String className, String fieldName) throws ClassNotFoundException {\n\t\treturn onFieldAccess(className, fieldName);\n\t}\n\n\t/**\n\t * Return a predicate that checks whether an invocation hint is registered for the field.\n\t * This looks up a field on the given type with the expected name, if present.\n\t * @param className the name of the class holding the field\n\t * @param fieldName the field name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws ClassNotFoundException if the class cannot be resolved.\n\t * @throws IllegalArgumentException if a field cannot be found with the given name.\n\t * @since 7.0\n\t */\n\tpublic Predicate<RuntimeHints> onFieldAccess(String className, String fieldName) throws ClassNotFoundException {\n\t\tAssert.hasText(className, \"'className' must not be empty\");\n\t\tAssert.hasText(fieldName, \"'fieldName' must not be empty\");\n\t\treturn onFieldAccess(Class.forName(className), fieldName);\n\t}\n\n\t/**\n\t * Return a predicate that checks whether a reflective field access hint is registered for the given field.\n\t * @param field the field\n\t * @return the {@link RuntimeHints} predicate\n\t * @deprecated since 7.0 in favor of {@link #onFieldAccess(Field)} with similar semantics.\n\t */\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\tpublic Predicate<RuntimeHints> onField(Field field) {\n\t\treturn onFieldAccess(field);\n\t}\n\n\t/**\n\t * Return a predicate that checks whether an invocation hint is registered for the given field.\n\t * @param field the field\n\t * @return the {@link RuntimeHints} predicate\n\t * @since 7.0\n\t */\n\tpublic Predicate<RuntimeHints> onFieldAccess(Field field) {\n\t\tAssert.notNull(field, \"'field' must not be null\");\n\t\treturn new FieldHintPredicate(field);\n\t}\n\n\n\tpublic static class TypeHintPredicate implements Predicate<RuntimeHints> {\n\n\t\tprivate final TypeReference type;\n\n\t\tTypeHintPredicate(TypeReference type) {\n\t\t\tthis.type = type;\n\t\t}\n\n\t\tprivate @Nullable TypeHint getTypeHint(RuntimeHints hints) {\n\t\t\treturn hints.reflection().getTypeHint(this.type);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(RuntimeHints hints) {\n\t\t\treturn getTypeHint(hints) != null;\n\t\t}\n\n\t\t/**\n\t\t * Refine the current predicate to only match if the given {@link MemberCategory} is present.\n\t\t * @param memberCategory the member category\n\t\t * @return the refined {@link RuntimeHints} predicate\n\t\t */\n\t\tpublic Predicate<RuntimeHints> withMemberCategory(MemberCategory memberCategory) {\n\t\t\tAssert.notNull(memberCategory, \"'memberCategory' must not be null\");\n\t\t\treturn and(hints -> {\n\t\t\t\tTypeHint hint = getTypeHint(hints);\n\t\t\t\treturn (hint != null && hint.getMemberCategories().contains(memberCategory));\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Refine the current predicate to only match if the given {@link MemberCategory categories} are present.\n\t\t * @param memberCategories the member categories\n\t\t * @return the refined {@link RuntimeHints} predicate\n\t\t */\n\t\tpublic Predicate<RuntimeHints> withMemberCategories(MemberCategory... memberCategories) {\n\t\t\tAssert.notEmpty(memberCategories, \"'memberCategories' must not be empty\");\n\t\t\treturn and(hints -> {\n\t\t\t\tTypeHint hint = getTypeHint(hints);\n\t\t\t\treturn (hint != null && hint.getMemberCategories().containsAll(Arrays.asList(memberCategories)));\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Refine the current predicate to match if any of the given {@link MemberCategory categories} is present.\n\t\t * @param memberCategories the member categories\n\t\t * @return the refined {@link RuntimeHints} predicate\n\t\t */\n\t\tpublic Predicate<RuntimeHints> withAnyMemberCategory(MemberCategory... memberCategories) {\n\t\t\tAssert.notEmpty(memberCategories, \"'memberCategories' must not be empty\");\n\t\t\treturn and(hints -> {\n\t\t\t\tTypeHint hint = getTypeHint(hints);\n\t\t\t\treturn (hint != null && Arrays.stream(memberCategories)\n\t\t\t\t\t\t.anyMatch(memberCategory -> hint.getMemberCategories().contains(memberCategory)));\n\t\t\t});\n\t\t}\n\t}\n\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\t@SuppressWarnings(\"removal\")\n\tpublic abstract static class ExecutableHintPredicate<T extends Executable> implements Predicate<RuntimeHints> {\n\n\t\tprotected final T executable;\n\n\t\tprotected ExecutableMode executableMode = ExecutableMode.INTROSPECT;\n\n\t\tExecutableHintPredicate(T executable) {\n\t\t\tthis.executable = executable;\n\t\t}\n\n\t\t/**\n\t\t * Refine the current predicate to match for reflection introspection on the current type.\n\t\t * @return the refined {@link RuntimeHints} predicate\n\t\t */\n\t\tpublic ExecutableHintPredicate<T> introspect() {\n\t\t\tthis.executableMode = ExecutableMode.INTROSPECT;\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Refine the current predicate to match for reflection invocation on the current type.\n\t\t * @return the refined {@link RuntimeHints} predicate\n\t\t */\n\t\tpublic ExecutableHintPredicate<T> invoke() {\n\t\t\tthis.executableMode = ExecutableMode.INVOKE;\n\t\t\treturn this;\n\t\t}\n\n\t\tabstract Predicate<RuntimeHints> exactMatch();\n\n\t\t/**\n\t\t * Indicate whether the specified {@code ExecutableHint} covers the\n\t\t * reflection needs of the specified executable definition.\n\t\t * @return {@code true} if the member matches (same type, name, and parameters),\n\t\t * and the configured {@code ExecutableMode} is compatible\n\t\t */\n\t\tstatic boolean includes(ExecutableHint hint, String name,\n\t\t\t\tList<TypeReference> parameterTypes, ExecutableMode executableModes) {\n\t\t\treturn hint.getName().equals(name) && hint.getParameterTypes().equals(parameterTypes) &&\n\t\t\t\t\t(hint.getMode().equals(ExecutableMode.INVOKE) || !executableModes.equals(ExecutableMode.INVOKE));\n\t\t}\n\t}\n\n\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\t@SuppressWarnings(\"removal\")\n\tpublic static class ConstructorHintPredicate extends ExecutableHintPredicate<Constructor<?>> {\n\n\t\tConstructorHintPredicate(Constructor<?> constructor) {\n\t\t\tsuper(constructor);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(RuntimeHints runtimeHints) {\n\t\t\treturn (new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass()))\n\t\t\t\t\t.and(hints -> this.executableMode == ExecutableMode.INTROSPECT))\n\t\t\t\t\t.or(new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass()))\n\t\t\t\t\t\t\t.withMemberCategory(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS)\n\t\t\t\t\t\t\t.and(hints -> Modifier.isPublic(this.executable.getModifiers()))\n\t\t\t\t\t\t\t.and(hints -> this.executableMode == ExecutableMode.INVOKE))\n\t\t\t\t\t.or(new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass()))\n\t\t\t\t\t\t\t.withMemberCategory(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)\n\t\t\t\t\t\t\t.and(hints -> this.executableMode == ExecutableMode.INVOKE))\n\t\t\t\t\t.or(exactMatch()).test(runtimeHints);\n\t\t}\n\n\t\t@Override\n\t\tPredicate<RuntimeHints> exactMatch() {\n\t\t\treturn hints -> {\n\t\t\t\tTypeHint hint = hints.reflection().getTypeHint(this.executable.getDeclaringClass());\n\t\t\t\treturn (hint != null && hint.constructors().anyMatch(executableHint -> {\n\t\t\t\t\tList<TypeReference> parameters = TypeReference.listOf(this.executable.getParameterTypes());\n\t\t\t\t\treturn includes(executableHint, \"<init>\", parameters, this.executableMode);\n\t\t\t\t}));\n\t\t\t};\n\t\t}\n\t}\n\n\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\t@SuppressWarnings(\"removal\")\n\tpublic static class MethodHintPredicate extends ExecutableHintPredicate<Method> {\n\n\t\tMethodHintPredicate(Method method) {\n\t\t\tsuper(method);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(RuntimeHints runtimeHints) {\n\t\t\treturn (new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass()))\n\t\t\t\t\t.and(hints -> this.executableMode == ExecutableMode.INTROSPECT))\n\t\t\t\t\t.or((new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass()))\n\t\t\t\t\t\t\t.withMemberCategory(MemberCategory.INVOKE_PUBLIC_METHODS)\n\t\t\t\t\t\t\t.and(hints -> Modifier.isPublic(this.executable.getModifiers()))\n\t\t\t\t\t\t\t.and(hints -> this.executableMode == ExecutableMode.INVOKE)))\n\t\t\t\t\t.or((new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass()))\n\t\t\t\t\t\t\t.withMemberCategory(MemberCategory.INVOKE_DECLARED_METHODS)\n\t\t\t\t\t\t\t.and(hints -> !Modifier.isPublic(this.executable.getModifiers()))\n\t\t\t\t\t\t\t.and(hints -> this.executableMode == ExecutableMode.INVOKE)))\n\t\t\t\t\t.or(exactMatch()).test(runtimeHints);\n\t\t}\n\n\t\t@Override\n\t\tPredicate<RuntimeHints> exactMatch() {\n\t\t\treturn hints -> {\n\t\t\t\tTypeHint hint = hints.reflection().getTypeHint(this.executable.getDeclaringClass());\n\t\t\t\treturn (hint != null && hint.methods().anyMatch(executableHint -> {\n\t\t\t\t\tList<TypeReference> parameters = TypeReference.listOf(this.executable.getParameterTypes());\n\t\t\t\t\treturn includes(executableHint, this.executable.getName(), parameters, this.executableMode);\n\t\t\t\t}));\n\t\t\t};\n\t\t}\n\t}\n\n\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\tpublic static class FieldHintPredicate implements Predicate<RuntimeHints> {\n\n\t\tprivate final Field field;\n\n\t\tFieldHintPredicate(Field field) {\n\t\t\tthis.field = field;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(RuntimeHints runtimeHints) {\n\t\t\tTypeHint typeHint = runtimeHints.reflection().getTypeHint(this.field.getDeclaringClass());\n\t\t\tif (typeHint == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn memberCategoryMatch(typeHint) || exactMatch(typeHint);\n\t\t}\n\n\t\t@SuppressWarnings(\"removal\")\n\t\tprivate boolean memberCategoryMatch(TypeHint typeHint) {\n\t\t\tif (Modifier.isPublic(this.field.getModifiers())) {\n\t\t\t\treturn typeHint.getMemberCategories().contains(MemberCategory.ACCESS_PUBLIC_FIELDS)\n\t\t\t\t\t\t|| typeHint.getMemberCategories().contains(MemberCategory.PUBLIC_FIELDS);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn typeHint.getMemberCategories().contains(MemberCategory.ACCESS_DECLARED_FIELDS)\n\t\t\t\t\t\t|| typeHint.getMemberCategories().contains(MemberCategory.DECLARED_FIELDS);\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean exactMatch(TypeHint typeHint) {\n\t\t\treturn typeHint.fields().anyMatch(fieldHint ->\n\t\t\t\t\tthis.field.getName().equals(fieldHint.getName()));\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.aot.hint.predicate.ReflectionHintsPredicates#onType(TypeReference)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Return a predicate that checks whether a reflection hint is registered for the given type.\r\n * <p>The returned type exposes additional methods that refine the predicate behavior.\r\n * @param typeReference the type\r\n * @return the {@link RuntimeHints} predicate\r\n */\r\npublic TypeHintPredicate onType(TypeReference typeReference) {\r\n    Assert.notNull(typeReference, \"'typeReference' must not be null\");\r\n    return new TypeHintPredicate(typeReference);\r\n}",
    "tailType": "method_code"
  }
]