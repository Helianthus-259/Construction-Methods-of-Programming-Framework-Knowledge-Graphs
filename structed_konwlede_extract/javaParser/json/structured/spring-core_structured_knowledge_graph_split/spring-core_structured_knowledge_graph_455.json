[
  {
    "head": "org.springframework.asm.MethodWriter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.MethodWriter#visitAbstractType(int,int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.MethodWriter#visitFrameEnd()",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Ends the visit of {@link #currentFrame} by writing it in the StackMapTable entries and by\r\n * updating the StackMapTable number_of_entries (except if the current frame is the first one,\r\n * which is implicit in StackMapTable). Then resets {@link #currentFrame} to {@literal null}.\r\n */\r\nvoid visitFrameEnd() {\r\n    if (previousFrame != null) {\r\n        if (stackMapTableEntries == null) {\r\n            stackMapTableEntries = new ByteVector();\r\n        }\r\n        putFrame();\r\n        ++stackMapTableNumberOfEntries;\r\n    }\r\n    previousFrame = currentFrame;\r\n    currentFrame = null;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.MethodWriter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.MethodWriter#visitFrameEnd()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.MethodWriter#putFrame()",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Compresses and writes {@link #currentFrame} in a new StackMapTable entry.\r\n */\r\nprivate void putFrame() {\r\n    final int numLocal = currentFrame[1];\r\n    final int numStack = currentFrame[2];\r\n    if (symbolTable.getMajorVersion() < Opcodes.V1_6) {\r\n        // Generate a StackMap attribute entry, which are always uncompressed.\r\n        stackMapTableEntries.putShort(currentFrame[0]).putShort(numLocal);\r\n        putAbstractTypes(3, 3 + numLocal);\r\n        stackMapTableEntries.putShort(numStack);\r\n        putAbstractTypes(3 + numLocal, 3 + numLocal + numStack);\r\n        return;\r\n    }\r\n    final int offsetDelta = stackMapTableNumberOfEntries == 0 ? currentFrame[0] : currentFrame[0] - previousFrame[0] - 1;\r\n    final int previousNumlocal = previousFrame[1];\r\n    final int numLocalDelta = numLocal - previousNumlocal;\r\n    int type = Frame.FULL_FRAME;\r\n    if (numStack == 0) {\r\n        switch(numLocalDelta) {\r\n            case -3:\r\n            case -2:\r\n            case -1:\r\n                type = Frame.CHOP_FRAME;\r\n                break;\r\n            case 0:\r\n                type = offsetDelta < 64 ? Frame.SAME_FRAME : Frame.SAME_FRAME_EXTENDED;\r\n                break;\r\n            case 1:\r\n            case 2:\r\n            case 3:\r\n                type = Frame.APPEND_FRAME;\r\n                break;\r\n            default:\r\n                // Keep the FULL_FRAME type.\r\n                break;\r\n        }\r\n    } else if (numLocalDelta == 0 && numStack == 1) {\r\n        type = offsetDelta < 63 ? Frame.SAME_LOCALS_1_STACK_ITEM_FRAME : Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;\r\n    }\r\n    if (type != Frame.FULL_FRAME) {\r\n        // Verify if locals are the same as in the previous frame.\r\n        int frameIndex = 3;\r\n        for (int i = 0; i < previousNumlocal && i < numLocal; i++) {\r\n            if (currentFrame[frameIndex] != previousFrame[frameIndex]) {\r\n                type = Frame.FULL_FRAME;\r\n                break;\r\n            }\r\n            frameIndex++;\r\n        }\r\n    }\r\n    switch(type) {\r\n        case Frame.SAME_FRAME:\r\n            stackMapTableEntries.putByte(offsetDelta);\r\n            break;\r\n        case Frame.SAME_LOCALS_1_STACK_ITEM_FRAME:\r\n            stackMapTableEntries.putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME + offsetDelta);\r\n            putAbstractTypes(3 + numLocal, 4 + numLocal);\r\n            break;\r\n        case Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED:\r\n            stackMapTableEntries.putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED).putShort(offsetDelta);\r\n            putAbstractTypes(3 + numLocal, 4 + numLocal);\r\n            break;\r\n        case Frame.SAME_FRAME_EXTENDED:\r\n            stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED).putShort(offsetDelta);\r\n            break;\r\n        case Frame.CHOP_FRAME:\r\n            stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED + numLocalDelta).putShort(offsetDelta);\r\n            break;\r\n        case Frame.APPEND_FRAME:\r\n            stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED + numLocalDelta).putShort(offsetDelta);\r\n            putAbstractTypes(3 + previousNumlocal, 3 + numLocal);\r\n            break;\r\n        case Frame.FULL_FRAME:\r\n        default:\r\n            stackMapTableEntries.putByte(Frame.FULL_FRAME).putShort(offsetDelta).putShort(numLocal);\r\n            putAbstractTypes(3, 3 + numLocal);\r\n            stackMapTableEntries.putShort(numStack);\r\n            putAbstractTypes(3 + numLocal, 3 + numLocal + numStack);\r\n            break;\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.MethodWriter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.MethodWriter#putFrame()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.MethodWriter#putAbstractTypes(int,int)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Puts some abstract types of {@link #currentFrame} in {@link #stackMapTableEntries} , using the\r\n * JVMS verification_type_info format used in StackMapTable attributes.\r\n *\r\n * @param start index of the first type in {@link #currentFrame} to write.\r\n * @param end index of last type in {@link #currentFrame} to write (exclusive).\r\n */\r\nprivate void putAbstractTypes(final int start, final int end) {\r\n    for (int i = start; i < end; ++i) {\r\n        Frame.putAbstractType(symbolTable, currentFrame[i], stackMapTableEntries);\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.MethodWriter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.MethodWriter#putAbstractTypes(int,int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.MethodWriter#putFrameType(Object)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Puts the given public API frame element type in {@link #stackMapTableEntries} , using the JVMS\r\n * verification_type_info format used in StackMapTable attributes.\r\n *\r\n * @param type a frame element type described using the same format as in {@link\r\n *     MethodVisitor#visitFrame}, i.e. either {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link\r\n *     Opcodes#FLOAT}, {@link Opcodes#LONG}, {@link Opcodes#DOUBLE}, {@link Opcodes#NULL}, or\r\n *     {@link Opcodes#UNINITIALIZED_THIS}, or the internal name of a class, or a Label designating\r\n *     a NEW instruction (for uninitialized types).\r\n */\r\nprivate void putFrameType(final Object type) {\r\n    if (type instanceof Integer) {\r\n        stackMapTableEntries.putByte(((Integer) type).intValue());\r\n    } else if (type instanceof String) {\r\n        stackMapTableEntries.putByte(Frame.ITEM_OBJECT).putShort(symbolTable.addConstantClass((String) type).index);\r\n    } else {\r\n        stackMapTableEntries.putByte(Frame.ITEM_UNINITIALIZED);\r\n        ((Label) type).put(stackMapTableEntries);\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.MethodWriter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.MethodWriter#putFrameType(Object)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.MethodWriter#canCopyMethodAttributes(ClassReader,boolean,boolean,int,int,int)",
    "headType": "method",
    "relation": "provide",
    "tail": "// -----------------------------------------------------------------------------------------------\r\n// Utility methods\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns whether the attributes of this method can be copied from the attributes of the given\r\n * method (assuming there is no method visitor between the given ClassReader and this\r\n * MethodWriter). This method should only be called just after this MethodWriter has been created,\r\n * and before any content is visited. It returns true if the attributes corresponding to the\r\n * constructor arguments (at most a Signature, an Exception, a Deprecated and a Synthetic\r\n * attribute) are the same as the corresponding attributes in the given method.\r\n *\r\n * @param source the source ClassReader from which the attributes of this method might be copied.\r\n * @param hasSyntheticAttribute whether the method_info JVMS structure from which the attributes\r\n *     of this method might be copied contains a Synthetic attribute.\r\n * @param hasDeprecatedAttribute whether the method_info JVMS structure from which the attributes\r\n *     of this method might be copied contains a Deprecated attribute.\r\n * @param descriptorIndex the descriptor_index field of the method_info JVMS structure from which\r\n *     the attributes of this method might be copied.\r\n * @param signatureIndex the constant pool index contained in the Signature attribute of the\r\n *     method_info JVMS structure from which the attributes of this method might be copied, or 0.\r\n * @param exceptionsOffset the offset in 'source.b' of the Exceptions attribute of the method_info\r\n *     JVMS structure from which the attributes of this method might be copied, or 0.\r\n * @return whether the attributes of this method can be copied from the attributes of the\r\n *     method_info JVMS structure in 'source.b', between 'methodInfoOffset' and 'methodInfoOffset'\r\n *     + 'methodInfoLength'.\r\n */\r\nboolean canCopyMethodAttributes(final ClassReader source, final boolean hasSyntheticAttribute, final boolean hasDeprecatedAttribute, final int descriptorIndex, final int signatureIndex, final int exceptionsOffset) {\r\n    // If the method descriptor has changed, with more locals than the max_locals field of the\r\n    // original Code attribute, if any, then the original method attributes can't be copied. A\r\n    // conservative check on the descriptor changes alone ensures this (being more precise is not\r\n    // worth the additional complexity, because these cases should be rare -- if a transform changes\r\n    // a method descriptor, most of the time it needs to change the method's code too).\r\n    if (source != symbolTable.getSource() || descriptorIndex != this.descriptorIndex || signatureIndex != this.signatureIndex || hasDeprecatedAttribute != ((accessFlags & Opcodes.ACC_DEPRECATED) != 0)) {\r\n        return false;\r\n    }\r\n    boolean needSyntheticAttribute = symbolTable.getMajorVersion() < Opcodes.V1_5 && (accessFlags & Opcodes.ACC_SYNTHETIC) != 0;\r\n    if (hasSyntheticAttribute != needSyntheticAttribute) {\r\n        return false;\r\n    }\r\n    if (exceptionsOffset == 0) {\r\n        if (numberOfExceptions != 0) {\r\n            return false;\r\n        }\r\n    } else if (source.readUnsignedShort(exceptionsOffset) == numberOfExceptions) {\r\n        int currentExceptionOffset = exceptionsOffset + 2;\r\n        for (int i = 0; i < numberOfExceptions; ++i) {\r\n            if (source.readUnsignedShort(currentExceptionOffset) != exceptionIndexTable[i]) {\r\n                return false;\r\n            }\r\n            currentExceptionOffset += 2;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.MethodWriter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.MethodWriter#canCopyMethodAttributes(ClassReader,boolean,boolean,int,int,int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.MethodWriter#setMethodAttributesSource(int,int)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Sets the source from which the attributes of this method will be copied.\r\n *\r\n * @param methodInfoOffset the offset in 'symbolTable.getSource()' of the method_info JVMS\r\n *     structure from which the attributes of this method will be copied.\r\n * @param methodInfoLength the length in 'symbolTable.getSource()' of the method_info JVMS\r\n *     structure from which the attributes of this method will be copied.\r\n */\r\nvoid setMethodAttributesSource(final int methodInfoOffset, final int methodInfoLength) {\r\n    // Don't copy the attributes yet, instead store their location in the source class reader so\r\n    // they can be copied later, in {@link #putMethodInfo}. Note that we skip the 6 header bytes\r\n    // of the method_info JVMS structure.\r\n    this.sourceOffset = methodInfoOffset + 6;\r\n    this.sourceLength = methodInfoLength - 6;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.MethodWriter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.MethodWriter#setMethodAttributesSource(int,int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.MethodWriter#computeMethodInfoSize()",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Returns the size of the method_info JVMS structure generated by this MethodWriter. Also add the\r\n * names of the attributes of this method in the constant pool.\r\n *\r\n * @return the size in bytes of the method_info JVMS structure.\r\n */\r\nint computeMethodInfoSize() {\r\n    // If this method_info must be copied from an existing one, the size computation is trivial.\r\n    if (sourceOffset != 0) {\r\n        // sourceLength excludes the first 6 bytes for access_flags, name_index and descriptor_index.\r\n        return 6 + sourceLength;\r\n    }\r\n    // 2 bytes each for access_flags, name_index, descriptor_index and attributes_count.\r\n    int size = 8;\r\n    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\r\n    if (code.length > 0) {\r\n        if (code.length > 65535) {\r\n            throw new MethodTooLargeException(symbolTable.getClassName(), name, descriptor, code.length);\r\n        }\r\n        symbolTable.addConstantUtf8(Constants.CODE);\r\n        // The Code attribute has 6 header bytes, plus 2, 2, 4 and 2 bytes respectively for max_stack,\r\n        // max_locals, code_length and attributes_count, plus the bytecode and the exception table.\r\n        size += 16 + code.length + Handler.getExceptionTableSize(firstHandler);\r\n        if (stackMapTableEntries != null) {\r\n            boolean useStackMapTable = symbolTable.getMajorVersion() >= Opcodes.V1_6;\r\n            symbolTable.addConstantUtf8(useStackMapTable ? Constants.STACK_MAP_TABLE : \"StackMap\");\r\n            // 6 header bytes and 2 bytes for number_of_entries.\r\n            size += 8 + stackMapTableEntries.length;\r\n        }\r\n        if (lineNumberTable != null) {\r\n            symbolTable.addConstantUtf8(Constants.LINE_NUMBER_TABLE);\r\n            // 6 header bytes and 2 bytes for line_number_table_length.\r\n            size += 8 + lineNumberTable.length;\r\n        }\r\n        if (localVariableTable != null) {\r\n            symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TABLE);\r\n            // 6 header bytes and 2 bytes for local_variable_table_length.\r\n            size += 8 + localVariableTable.length;\r\n        }\r\n        if (localVariableTypeTable != null) {\r\n            symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TYPE_TABLE);\r\n            // 6 header bytes and 2 bytes for local_variable_type_table_length.\r\n            size += 8 + localVariableTypeTable.length;\r\n        }\r\n        if (lastCodeRuntimeVisibleTypeAnnotation != null) {\r\n            size += lastCodeRuntimeVisibleTypeAnnotation.computeAnnotationsSize(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\r\n        }\r\n        if (lastCodeRuntimeInvisibleTypeAnnotation != null) {\r\n            size += lastCodeRuntimeInvisibleTypeAnnotation.computeAnnotationsSize(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\r\n        }\r\n        if (firstCodeAttribute != null) {\r\n            size += firstCodeAttribute.computeAttributesSize(symbolTable, code.data, code.length, maxStack, maxLocals);\r\n        }\r\n    }\r\n    if (numberOfExceptions > 0) {\r\n        symbolTable.addConstantUtf8(Constants.EXCEPTIONS);\r\n        size += 8 + 2 * numberOfExceptions;\r\n    }\r\n    size += Attribute.computeAttributesSize(symbolTable, accessFlags, signatureIndex);\r\n    size += AnnotationWriter.computeAnnotationsSize(lastRuntimeVisibleAnnotation, lastRuntimeInvisibleAnnotation, lastRuntimeVisibleTypeAnnotation, lastRuntimeInvisibleTypeAnnotation);\r\n    if (lastRuntimeVisibleParameterAnnotations != null) {\r\n        size += AnnotationWriter.computeParameterAnnotationsSize(Constants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS, lastRuntimeVisibleParameterAnnotations, visibleAnnotableParameterCount == 0 ? lastRuntimeVisibleParameterAnnotations.length : visibleAnnotableParameterCount);\r\n    }\r\n    if (lastRuntimeInvisibleParameterAnnotations != null) {\r\n        size += AnnotationWriter.computeParameterAnnotationsSize(Constants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS, lastRuntimeInvisibleParameterAnnotations, invisibleAnnotableParameterCount == 0 ? lastRuntimeInvisibleParameterAnnotations.length : invisibleAnnotableParameterCount);\r\n    }\r\n    if (defaultValue != null) {\r\n        symbolTable.addConstantUtf8(Constants.ANNOTATION_DEFAULT);\r\n        size += 6 + defaultValue.length;\r\n    }\r\n    if (parameters != null) {\r\n        symbolTable.addConstantUtf8(Constants.METHOD_PARAMETERS);\r\n        // 6 header bytes and 1 byte for parameters_count.\r\n        size += 7 + parameters.length;\r\n    }\r\n    if (firstAttribute != null) {\r\n        size += firstAttribute.computeAttributesSize(symbolTable);\r\n    }\r\n    return size;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.MethodWriter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.MethodWriter#computeMethodInfoSize()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.MethodWriter#putMethodInfo(ByteVector)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Puts the content of the method_info JVMS structure generated by this MethodWriter into the\r\n * given ByteVector.\r\n *\r\n * @param output where the method_info structure must be put.\r\n */\r\nvoid putMethodInfo(final ByteVector output) {\r\n    boolean useSyntheticAttribute = symbolTable.getMajorVersion() < Opcodes.V1_5;\r\n    int mask = useSyntheticAttribute ? Opcodes.ACC_SYNTHETIC : 0;\r\n    output.putShort(accessFlags & ~mask).putShort(nameIndex).putShort(descriptorIndex);\r\n    // If this method_info must be copied from an existing one, copy it now and return early.\r\n    if (sourceOffset != 0) {\r\n        output.putByteArray(symbolTable.getSource().classFileBuffer, sourceOffset, sourceLength);\r\n        return;\r\n    }\r\n    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\r\n    int attributeCount = 0;\r\n    if (code.length > 0) {\r\n        ++attributeCount;\r\n    }\r\n    if (numberOfExceptions > 0) {\r\n        ++attributeCount;\r\n    }\r\n    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && useSyntheticAttribute) {\r\n        ++attributeCount;\r\n    }\r\n    if (signatureIndex != 0) {\r\n        ++attributeCount;\r\n    }\r\n    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {\r\n        ++attributeCount;\r\n    }\r\n    if (lastRuntimeVisibleAnnotation != null) {\r\n        ++attributeCount;\r\n    }\r\n    if (lastRuntimeInvisibleAnnotation != null) {\r\n        ++attributeCount;\r\n    }\r\n    if (lastRuntimeVisibleParameterAnnotations != null) {\r\n        ++attributeCount;\r\n    }\r\n    if (lastRuntimeInvisibleParameterAnnotations != null) {\r\n        ++attributeCount;\r\n    }\r\n    if (lastRuntimeVisibleTypeAnnotation != null) {\r\n        ++attributeCount;\r\n    }\r\n    if (lastRuntimeInvisibleTypeAnnotation != null) {\r\n        ++attributeCount;\r\n    }\r\n    if (defaultValue != null) {\r\n        ++attributeCount;\r\n    }\r\n    if (parameters != null) {\r\n        ++attributeCount;\r\n    }\r\n    if (firstAttribute != null) {\r\n        attributeCount += firstAttribute.getAttributeCount();\r\n    }\r\n    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\r\n    output.putShort(attributeCount);\r\n    if (code.length > 0) {\r\n        // 2, 2, 4 and 2 bytes respectively for max_stack, max_locals, code_length and\r\n        // attributes_count, plus the bytecode and the exception table.\r\n        int size = 10 + code.length + Handler.getExceptionTableSize(firstHandler);\r\n        int codeAttributeCount = 0;\r\n        if (stackMapTableEntries != null) {\r\n            // 6 header bytes and 2 bytes for number_of_entries.\r\n            size += 8 + stackMapTableEntries.length;\r\n            ++codeAttributeCount;\r\n        }\r\n        if (lineNumberTable != null) {\r\n            // 6 header bytes and 2 bytes for line_number_table_length.\r\n            size += 8 + lineNumberTable.length;\r\n            ++codeAttributeCount;\r\n        }\r\n        if (localVariableTable != null) {\r\n            // 6 header bytes and 2 bytes for local_variable_table_length.\r\n            size += 8 + localVariableTable.length;\r\n            ++codeAttributeCount;\r\n        }\r\n        if (localVariableTypeTable != null) {\r\n            // 6 header bytes and 2 bytes for local_variable_type_table_length.\r\n            size += 8 + localVariableTypeTable.length;\r\n            ++codeAttributeCount;\r\n        }\r\n        if (lastCodeRuntimeVisibleTypeAnnotation != null) {\r\n            size += lastCodeRuntimeVisibleTypeAnnotation.computeAnnotationsSize(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\r\n            ++codeAttributeCount;\r\n        }\r\n        if (lastCodeRuntimeInvisibleTypeAnnotation != null) {\r\n            size += lastCodeRuntimeInvisibleTypeAnnotation.computeAnnotationsSize(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\r\n            ++codeAttributeCount;\r\n        }\r\n        if (firstCodeAttribute != null) {\r\n            size += firstCodeAttribute.computeAttributesSize(symbolTable, code.data, code.length, maxStack, maxLocals);\r\n            codeAttributeCount += firstCodeAttribute.getAttributeCount();\r\n        }\r\n        output.putShort(symbolTable.addConstantUtf8(Constants.CODE)).putInt(size).putShort(maxStack).putShort(maxLocals).putInt(code.length).putByteArray(code.data, 0, code.length);\r\n        Handler.putExceptionTable(firstHandler, output);\r\n        output.putShort(codeAttributeCount);\r\n        if (stackMapTableEntries != null) {\r\n            boolean useStackMapTable = symbolTable.getMajorVersion() >= Opcodes.V1_6;\r\n            output.putShort(symbolTable.addConstantUtf8(useStackMapTable ? Constants.STACK_MAP_TABLE : \"StackMap\")).putInt(2 + stackMapTableEntries.length).putShort(stackMapTableNumberOfEntries).putByteArray(stackMapTableEntries.data, 0, stackMapTableEntries.length);\r\n        }\r\n        if (lineNumberTable != null) {\r\n            output.putShort(symbolTable.addConstantUtf8(Constants.LINE_NUMBER_TABLE)).putInt(2 + lineNumberTable.length).putShort(lineNumberTableLength).putByteArray(lineNumberTable.data, 0, lineNumberTable.length);\r\n        }\r\n        if (localVariableTable != null) {\r\n            output.putShort(symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TABLE)).putInt(2 + localVariableTable.length).putShort(localVariableTableLength).putByteArray(localVariableTable.data, 0, localVariableTable.length);\r\n        }\r\n        if (localVariableTypeTable != null) {\r\n            output.putShort(symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TYPE_TABLE)).putInt(2 + localVariableTypeTable.length).putShort(localVariableTypeTableLength).putByteArray(localVariableTypeTable.data, 0, localVariableTypeTable.length);\r\n        }\r\n        if (lastCodeRuntimeVisibleTypeAnnotation != null) {\r\n            lastCodeRuntimeVisibleTypeAnnotation.putAnnotations(symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS), output);\r\n        }\r\n        if (lastCodeRuntimeInvisibleTypeAnnotation != null) {\r\n            lastCodeRuntimeInvisibleTypeAnnotation.putAnnotations(symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS), output);\r\n        }\r\n        if (firstCodeAttribute != null) {\r\n            firstCodeAttribute.putAttributes(symbolTable, code.data, code.length, maxStack, maxLocals, output);\r\n        }\r\n    }\r\n    if (numberOfExceptions > 0) {\r\n        output.putShort(symbolTable.addConstantUtf8(Constants.EXCEPTIONS)).putInt(2 + 2 * numberOfExceptions).putShort(numberOfExceptions);\r\n        for (int exceptionIndex : exceptionIndexTable) {\r\n            output.putShort(exceptionIndex);\r\n        }\r\n    }\r\n    Attribute.putAttributes(symbolTable, accessFlags, signatureIndex, output);\r\n    AnnotationWriter.putAnnotations(symbolTable, lastRuntimeVisibleAnnotation, lastRuntimeInvisibleAnnotation, lastRuntimeVisibleTypeAnnotation, lastRuntimeInvisibleTypeAnnotation, output);\r\n    if (lastRuntimeVisibleParameterAnnotations != null) {\r\n        AnnotationWriter.putParameterAnnotations(symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS), lastRuntimeVisibleParameterAnnotations, visibleAnnotableParameterCount == 0 ? lastRuntimeVisibleParameterAnnotations.length : visibleAnnotableParameterCount, output);\r\n    }\r\n    if (lastRuntimeInvisibleParameterAnnotations != null) {\r\n        AnnotationWriter.putParameterAnnotations(symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS), lastRuntimeInvisibleParameterAnnotations, invisibleAnnotableParameterCount == 0 ? lastRuntimeInvisibleParameterAnnotations.length : invisibleAnnotableParameterCount, output);\r\n    }\r\n    if (defaultValue != null) {\r\n        output.putShort(symbolTable.addConstantUtf8(Constants.ANNOTATION_DEFAULT)).putInt(defaultValue.length).putByteArray(defaultValue.data, 0, defaultValue.length);\r\n    }\r\n    if (parameters != null) {\r\n        output.putShort(symbolTable.addConstantUtf8(Constants.METHOD_PARAMETERS)).putInt(1 + parameters.length).putByte(parametersCount).putByteArray(parameters.data, 0, parameters.length);\r\n    }\r\n    if (firstAttribute != null) {\r\n        firstAttribute.putAttributes(symbolTable, output);\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.MethodWriter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.MethodWriter#putMethodInfo(ByteVector)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.MethodWriter#collectAttributePrototypes(Attribute.Set)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Collects the attributes of this method into the given set of attribute prototypes.\r\n *\r\n * @param attributePrototypes a set of attribute prototypes.\r\n */\r\nfinal void collectAttributePrototypes(final Attribute.Set attributePrototypes) {\r\n    attributePrototypes.addAttributes(firstAttribute);\r\n    attributePrototypes.addAttributes(firstCodeAttribute);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.MethodWriter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.MethodWriter#collectAttributePrototypes(Attribute.Set)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.MethodWriter",
    "headType": "class",
    "relation": "extend",
    "tail": "MethodVisitor",
    "tailType": "class"
  }
]