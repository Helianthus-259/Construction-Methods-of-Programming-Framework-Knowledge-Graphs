[
  {
    "head": "org.springframework.asm.ClassReader#readStringish(int,char[])",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Reads a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType, CONSTANT_Module or\r\n * CONSTANT_Package constant pool entry in {@link #classFileBuffer}. <i>This method is intended\r\n * for {@link Attribute} sub classes, and is normally not needed by class generators or\r\n * adapters.</i>\r\n *\r\n * @param offset the start offset of an unsigned short value in {@link #classFileBuffer}, whose\r\n *     value is the index of a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,\r\n *     CONSTANT_Module or CONSTANT_Package entry in class's constant pool table.\r\n * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\r\n *     large. It is not automatically resized.\r\n * @return the String corresponding to the specified constant pool entry.\r\n */\r\nprivate String readStringish(final int offset, final char[] charBuffer) {\r\n    // Get the start offset of the cp_info structure (plus one), and read the CONSTANT_Utf8 entry\r\n    // designated by the first two bytes of this cp_info.\r\n    return readUTF8(cpInfoOffsets[readUnsignedShort(offset)], charBuffer);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ClassReader#readStringish(int,char[])",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ClassReader#readClass(int,char[])",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Reads a CONSTANT_Class constant pool entry in this {@link ClassReader}. <i>This method is\r\n * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\r\n * adapters.</i>\r\n *\r\n * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\r\n *     value is the index of a CONSTANT_Class entry in class's constant pool table.\r\n * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\r\n *     large. It is not automatically resized.\r\n * @return the String corresponding to the specified CONSTANT_Class entry.\r\n */\r\npublic String readClass(final int offset, final char[] charBuffer) {\r\n    return readStringish(offset, charBuffer);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ClassReader#readClass(int,char[])",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ClassReader#readModule(int,char[])",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Reads a CONSTANT_Module constant pool entry in this {@link ClassReader}. <i>This method is\r\n * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\r\n * adapters.</i>\r\n *\r\n * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\r\n *     value is the index of a CONSTANT_Module entry in class's constant pool table.\r\n * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\r\n *     large. It is not automatically resized.\r\n * @return the String corresponding to the specified CONSTANT_Module entry.\r\n */\r\npublic String readModule(final int offset, final char[] charBuffer) {\r\n    return readStringish(offset, charBuffer);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ClassReader#readModule(int,char[])",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ClassReader#readPackage(int,char[])",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Reads a CONSTANT_Package constant pool entry in this {@link ClassReader}. <i>This method is\r\n * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\r\n * adapters.</i>\r\n *\r\n * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\r\n *     value is the index of a CONSTANT_Package entry in class's constant pool table.\r\n * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\r\n *     large. It is not automatically resized.\r\n * @return the String corresponding to the specified CONSTANT_Package entry.\r\n */\r\npublic String readPackage(final int offset, final char[] charBuffer) {\r\n    return readStringish(offset, charBuffer);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ClassReader#readPackage(int,char[])",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ClassReader#readConstantDynamic(int,char[])",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Reads a CONSTANT_Dynamic constant pool entry in {@link #classFileBuffer}.\r\n *\r\n * @param constantPoolEntryIndex the index of a CONSTANT_Dynamic entry in the class's constant\r\n *     pool table.\r\n * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently\r\n *     large. It is not automatically resized.\r\n * @return the ConstantDynamic corresponding to the specified CONSTANT_Dynamic entry.\r\n */\r\nprivate ConstantDynamic readConstantDynamic(final int constantPoolEntryIndex, final char[] charBuffer) {\r\n    ConstantDynamic constantDynamic = constantDynamicValues[constantPoolEntryIndex];\r\n    if (constantDynamic != null) {\r\n        return constantDynamic;\r\n    }\r\n    int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];\r\n    int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];\r\n    String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);\r\n    String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);\r\n    int bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];\r\n    Handle handle = (Handle) readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);\r\n    Object[] bootstrapMethodArguments = new Object[readUnsignedShort(bootstrapMethodOffset + 2)];\r\n    bootstrapMethodOffset += 4;\r\n    for (int i = 0; i < bootstrapMethodArguments.length; i++) {\r\n        bootstrapMethodArguments[i] = readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);\r\n        bootstrapMethodOffset += 2;\r\n    }\r\n    return constantDynamicValues[constantPoolEntryIndex] = new ConstantDynamic(name, descriptor, handle, bootstrapMethodArguments);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ClassReader#readConstantDynamic(int,char[])",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ClassReader#readConst(int,char[])",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Reads a numeric or string constant pool entry in this {@link ClassReader}. <i>This method is\r\n * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\r\n * adapters.</i>\r\n *\r\n * @param constantPoolEntryIndex the index of a CONSTANT_Integer, CONSTANT_Float, CONSTANT_Long,\r\n *     CONSTANT_Double, CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,\r\n *     CONSTANT_MethodHandle or CONSTANT_Dynamic entry in the class's constant pool.\r\n * @param charBuffer the buffer to be used to read strings. This buffer must be sufficiently\r\n *     large. It is not automatically resized.\r\n * @return the {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String},\r\n *     {@link Type}, {@link Handle} or {@link ConstantDynamic} corresponding to the specified\r\n *     constant pool entry.\r\n */\r\npublic Object readConst(final int constantPoolEntryIndex, final char[] charBuffer) {\r\n    int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];\r\n    switch(classFileBuffer[cpInfoOffset - 1]) {\r\n        case Symbol.CONSTANT_INTEGER_TAG:\r\n            return readInt(cpInfoOffset);\r\n        case Symbol.CONSTANT_FLOAT_TAG:\r\n            return Float.intBitsToFloat(readInt(cpInfoOffset));\r\n        case Symbol.CONSTANT_LONG_TAG:\r\n            return readLong(cpInfoOffset);\r\n        case Symbol.CONSTANT_DOUBLE_TAG:\r\n            return Double.longBitsToDouble(readLong(cpInfoOffset));\r\n        case Symbol.CONSTANT_CLASS_TAG:\r\n            return Type.getObjectType(readUTF8(cpInfoOffset, charBuffer));\r\n        case Symbol.CONSTANT_STRING_TAG:\r\n            return readUTF8(cpInfoOffset, charBuffer);\r\n        case Symbol.CONSTANT_METHOD_TYPE_TAG:\r\n            return Type.getMethodType(readUTF8(cpInfoOffset, charBuffer));\r\n        case Symbol.CONSTANT_METHOD_HANDLE_TAG:\r\n            int referenceKind = readByte(cpInfoOffset);\r\n            int referenceCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 1)];\r\n            int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(referenceCpInfoOffset + 2)];\r\n            String owner = readClass(referenceCpInfoOffset, charBuffer);\r\n            String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);\r\n            String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);\r\n            boolean isInterface = classFileBuffer[referenceCpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;\r\n            return new Handle(referenceKind, owner, name, descriptor, isInterface);\r\n        case Symbol.CONSTANT_DYNAMIC_TAG:\r\n            return readConstantDynamic(constantPoolEntryIndex, charBuffer);\r\n        default:\r\n            throw new IllegalArgumentException();\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ClassReader#readConst(int,char[])",
    "tailType": "method"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.util",
    "tailType": "package"
  },
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.StringUtilsTests",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.StringUtilsTests",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Locale;\nimport java.util.Properties;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\nimport org.junit.jupiter.params.provider.NullAndEmptySource;\nimport org.junit.jupiter.params.provider.ValueSource;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n\n/**\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Rick Evans\n * @author Sam Brannen\n */\nclass StringUtilsTests {\n\n\t@ParameterizedTest\n\t@ValueSource(strings = {\"text\", \"  text  \", \"  \", \"\\t\", \"\\n text\"})\n\tvoid hasLengthForValidValues(String value) {\n\t\tassertThat(StringUtils.hasLength(value)).isTrue();\n\t}\n\n\t@ParameterizedTest\n\t@NullAndEmptySource\n\tvoid hasLengthForInvalidValues(String value) {\n\t\tassertThat(StringUtils.hasLength(value)).isFalse();\n\t}\n\n\t@ParameterizedTest\n\t@ValueSource(strings = {\"text\", \"  text  \", \"\\n text\"})\n\tvoid hasTextForValidValues(String value) {\n\t\tassertThat(StringUtils.hasText(value)).isTrue();\n\t}\n\n\t@ParameterizedTest\n\t@NullAndEmptySource\n\t@ValueSource(strings = {\"  \", \"\\t\"})\n\tvoid hasTextForInvalidValues(String value) {\n\t\tassertThat(StringUtils.hasText(value)).isFalse();\n\t}\n\n\t@Test\n\tvoid containsWhitespace() {\n\t\tassertThat(StringUtils.containsWhitespace(null)).isFalse();\n\t\tassertThat(StringUtils.containsWhitespace(\"\")).isFalse();\n\t\tassertThat(StringUtils.containsWhitespace(\"a\")).isFalse();\n\t\tassertThat(StringUtils.containsWhitespace(\"abc\")).isFalse();\n\t\tassertThat(StringUtils.containsWhitespace(\" \")).isTrue();\n\t\tassertThat(StringUtils.containsWhitespace(\"\\t\")).isTrue();\n\t\tassertThat(StringUtils.containsWhitespace(\"\\n\")).isTrue();\n\t\tassertThat(StringUtils.containsWhitespace(\" a\")).isTrue();\n\t\tassertThat(StringUtils.containsWhitespace(\"abc \")).isTrue();\n\t\tassertThat(StringUtils.containsWhitespace(\"a b\")).isTrue();\n\t\tassertThat(StringUtils.containsWhitespace(\"a  b\")).isTrue();\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid trimWhitespace() {\n\t\tassertThat(StringUtils.trimWhitespace(null)).isNull();\n\t\tassertThat(StringUtils.trimWhitespace(\"\")).isEmpty();\n\t\tassertThat(StringUtils.trimWhitespace(\" \")).isEmpty();\n\t\tassertThat(StringUtils.trimWhitespace(\"\\t\")).isEmpty();\n\t\tassertThat(StringUtils.trimWhitespace(\"\\n\")).isEmpty();\n\t\tassertThat(StringUtils.trimWhitespace(\" \\t\\n\")).isEmpty();\n\t\tassertThat(StringUtils.trimWhitespace(\" a\")).isEqualTo(\"a\");\n\t\tassertThat(StringUtils.trimWhitespace(\"a \")).isEqualTo(\"a\");\n\t\tassertThat(StringUtils.trimWhitespace(\" a \")).isEqualTo(\"a\");\n\t\tassertThat(StringUtils.trimWhitespace(\" a b \")).isEqualTo(\"a b\");\n\t\tassertThat(StringUtils.trimWhitespace(\" a b  c \")).isEqualTo(\"a b  c\");\n\t}\n\n\t@Test\n\tvoid trimAllWhitespace() {\n\t\tassertThat(StringUtils.trimAllWhitespace(null)).isNull();\n\t\tassertThat(StringUtils.trimAllWhitespace(\"\")).isEmpty();\n\t\tassertThat(StringUtils.trimAllWhitespace(\" \")).isEmpty();\n\t\tassertThat(StringUtils.trimAllWhitespace(\"\\t\")).isEmpty();\n\t\tassertThat(StringUtils.trimAllWhitespace(\"\\n\")).isEmpty();\n\t\tassertThat(StringUtils.trimAllWhitespace(\" \\t\\n\")).isEmpty();\n\t\tassertThat(StringUtils.trimAllWhitespace(\" a\")).isEqualTo(\"a\");\n\t\tassertThat(StringUtils.trimAllWhitespace(\"a \")).isEqualTo(\"a\");\n\t\tassertThat(StringUtils.trimAllWhitespace(\" a \")).isEqualTo(\"a\");\n\t\tassertThat(StringUtils.trimAllWhitespace(\" a b \")).isEqualTo(\"ab\");\n\t\tassertThat(StringUtils.trimAllWhitespace(\" a b  c \")).isEqualTo(\"abc\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid trimLeadingWhitespace() {\n\t\tassertThat(StringUtils.trimLeadingWhitespace(null)).isNull();\n\t\tassertThat(StringUtils.trimLeadingWhitespace(\"\")).isEmpty();\n\t\tassertThat(StringUtils.trimLeadingWhitespace(\" \")).isEmpty();\n\t\tassertThat(StringUtils.trimLeadingWhitespace(\"\\t\")).isEmpty();\n\t\tassertThat(StringUtils.trimLeadingWhitespace(\"\\n\")).isEmpty();\n\t\tassertThat(StringUtils.trimLeadingWhitespace(\" \\t\\n\")).isEmpty();\n\t\tassertThat(StringUtils.trimLeadingWhitespace(\" a\")).isEqualTo(\"a\");\n\t\tassertThat(StringUtils.trimLeadingWhitespace(\"a \")).isEqualTo(\"a \");\n\t\tassertThat(StringUtils.trimLeadingWhitespace(\" a \")).isEqualTo(\"a \");\n\t\tassertThat(StringUtils.trimLeadingWhitespace(\" a b \")).isEqualTo(\"a b \");\n\t\tassertThat(StringUtils.trimLeadingWhitespace(\" a b  c \")).isEqualTo(\"a b  c \");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid trimTrailingWhitespace() {\n\t\tassertThat(StringUtils.trimTrailingWhitespace(null)).isNull();\n\t\tassertThat(StringUtils.trimTrailingWhitespace(\"\")).isEmpty();\n\t\tassertThat(StringUtils.trimTrailingWhitespace(\" \")).isEmpty();\n\t\tassertThat(StringUtils.trimTrailingWhitespace(\"\\t\")).isEmpty();\n\t\tassertThat(StringUtils.trimTrailingWhitespace(\"\\n\")).isEmpty();\n\t\tassertThat(StringUtils.trimTrailingWhitespace(\" \\t\\n\")).isEmpty();\n\t\tassertThat(StringUtils.trimTrailingWhitespace(\"a \")).isEqualTo(\"a\");\n\t\tassertThat(StringUtils.trimTrailingWhitespace(\" a\")).isEqualTo(\" a\");\n\t\tassertThat(StringUtils.trimTrailingWhitespace(\" a \")).isEqualTo(\" a\");\n\t\tassertThat(StringUtils.trimTrailingWhitespace(\" a b \")).isEqualTo(\" a b\");\n\t\tassertThat(StringUtils.trimTrailingWhitespace(\" a b  c \")).isEqualTo(\" a b  c\");\n\t}\n\n\t@Test\n\tvoid trimLeadingCharacter() {\n\t\tassertThat(StringUtils.trimLeadingCharacter(null, ' ')).isNull();\n\t\tassertThat(StringUtils.trimLeadingCharacter(\"\", ' ')).isEmpty();\n\t\tassertThat(StringUtils.trimLeadingCharacter(\" \", ' ')).isEmpty();\n\t\tassertThat(StringUtils.trimLeadingCharacter(\"\\t\", ' ')).isEqualTo(\"\\t\");\n\t\tassertThat(StringUtils.trimLeadingCharacter(\" a\", ' ')).isEqualTo(\"a\");\n\t\tassertThat(StringUtils.trimLeadingCharacter(\"a \", ' ')).isEqualTo(\"a \");\n\t\tassertThat(StringUtils.trimLeadingCharacter(\" a \", ' ')).isEqualTo(\"a \");\n\t\tassertThat(StringUtils.trimLeadingCharacter(\" a b \", ' ')).isEqualTo(\"a b \");\n\t\tassertThat(StringUtils.trimLeadingCharacter(\" a b  c \", ' ')).isEqualTo(\"a b  c \");\n\t}\n\n\t@Test\n\tvoid trimTrailingCharacter() {\n\t\tassertThat(StringUtils.trimTrailingCharacter(null, ' ')).isNull();\n\t\tassertThat(StringUtils.trimTrailingCharacter(\"\", ' ')).isEmpty();\n\t\tassertThat(StringUtils.trimTrailingCharacter(\" \", ' ')).isEmpty();\n\t\tassertThat(StringUtils.trimTrailingCharacter(\"\\t\", ' ')).isEqualTo(\"\\t\");\n\t\tassertThat(StringUtils.trimTrailingCharacter(\"a \", ' ')).isEqualTo(\"a\");\n\t\tassertThat(StringUtils.trimTrailingCharacter(\" a\", ' ')).isEqualTo(\" a\");\n\t\tassertThat(StringUtils.trimTrailingCharacter(\" a \", ' ')).isEqualTo(\" a\");\n\t\tassertThat(StringUtils.trimTrailingCharacter(\" a b \", ' ')).isEqualTo(\" a b\");\n\t\tassertThat(StringUtils.trimTrailingCharacter(\" a b  c \", ' ')).isEqualTo(\" a b  c\");\n\t}\n\n\t@Test\n\tvoid matchesCharacter() {\n\t\tassertThat(StringUtils.matchesCharacter(null, '/')).isFalse();\n\t\tassertThat(StringUtils.matchesCharacter(\"/a\", '/')).isFalse();\n\t\tassertThat(StringUtils.matchesCharacter(\"a\", '/')).isFalse();\n\t\tassertThat(StringUtils.matchesCharacter(\"/\", '/')).isTrue();\n\t}\n\n\t@Test\n\tvoid startsWithIgnoreCase() {\n\t\tString prefix = \"fOo\";\n\t\tassertThat(StringUtils.startsWithIgnoreCase(\"foo\", prefix)).isTrue();\n\t\tassertThat(StringUtils.startsWithIgnoreCase(\"Foo\", prefix)).isTrue();\n\t\tassertThat(StringUtils.startsWithIgnoreCase(\"foobar\", prefix)).isTrue();\n\t\tassertThat(StringUtils.startsWithIgnoreCase(\"foobarbar\", prefix)).isTrue();\n\t\tassertThat(StringUtils.startsWithIgnoreCase(\"Foobar\", prefix)).isTrue();\n\t\tassertThat(StringUtils.startsWithIgnoreCase(\"FoobarBar\", prefix)).isTrue();\n\t\tassertThat(StringUtils.startsWithIgnoreCase(\"foObar\", prefix)).isTrue();\n\t\tassertThat(StringUtils.startsWithIgnoreCase(\"FOObar\", prefix)).isTrue();\n\t\tassertThat(StringUtils.startsWithIgnoreCase(\"fOobar\", prefix)).isTrue();\n\t\tassertThat(StringUtils.startsWithIgnoreCase(null, prefix)).isFalse();\n\t\tassertThat(StringUtils.startsWithIgnoreCase(\"fOobar\", null)).isFalse();\n\t\tassertThat(StringUtils.startsWithIgnoreCase(\"b\", prefix)).isFalse();\n\t\tassertThat(StringUtils.startsWithIgnoreCase(\"barfoo\", prefix)).isFalse();\n\t\tassertThat(StringUtils.startsWithIgnoreCase(\"barfoobar\", prefix)).isFalse();\n\t}\n\n\t@Test\n\tvoid endsWithIgnoreCase() {\n\t\tString suffix = \"fOo\";\n\t\tassertThat(StringUtils.endsWithIgnoreCase(\"foo\", suffix)).isTrue();\n\t\tassertThat(StringUtils.endsWithIgnoreCase(\"Foo\", suffix)).isTrue();\n\t\tassertThat(StringUtils.endsWithIgnoreCase(\"barfoo\", suffix)).isTrue();\n\t\tassertThat(StringUtils.endsWithIgnoreCase(\"barbarfoo\", suffix)).isTrue();\n\t\tassertThat(StringUtils.endsWithIgnoreCase(\"barFoo\", suffix)).isTrue();\n\t\tassertThat(StringUtils.endsWithIgnoreCase(\"barBarFoo\", suffix)).isTrue();\n\t\tassertThat(StringUtils.endsWithIgnoreCase(\"barfoO\", suffix)).isTrue();\n\t\tassertThat(StringUtils.endsWithIgnoreCase(\"barFOO\", suffix)).isTrue();\n\t\tassertThat(StringUtils.endsWithIgnoreCase(\"barfOo\", suffix)).isTrue();\n\t\tassertThat(StringUtils.endsWithIgnoreCase(null, suffix)).isFalse();\n\t\tassertThat(StringUtils.endsWithIgnoreCase(\"barfOo\", null)).isFalse();\n\t\tassertThat(StringUtils.endsWithIgnoreCase(\"b\", suffix)).isFalse();\n\t\tassertThat(StringUtils.endsWithIgnoreCase(\"foobar\", suffix)).isFalse();\n\t\tassertThat(StringUtils.endsWithIgnoreCase(\"barfoobar\", suffix)).isFalse();\n\t}\n\n\t@Test\n\tvoid substringMatch() {\n\t\tassertThat(StringUtils.substringMatch(\"foo\", 0, \"foo\")).isTrue();\n\t\tassertThat(StringUtils.substringMatch(\"foo\", 1, \"oo\")).isTrue();\n\t\tassertThat(StringUtils.substringMatch(\"foo\", 2, \"o\")).isTrue();\n\t\tassertThat(StringUtils.substringMatch(\"foo\", 0, \"fOo\")).isFalse();\n\t\tassertThat(StringUtils.substringMatch(\"foo\", 1, \"fOo\")).isFalse();\n\t\tassertThat(StringUtils.substringMatch(\"foo\", 2, \"fOo\")).isFalse();\n\t\tassertThat(StringUtils.substringMatch(\"foo\", 3, \"fOo\")).isFalse();\n\t\tassertThat(StringUtils.substringMatch(\"foo\", 1, \"Oo\")).isFalse();\n\t\tassertThat(StringUtils.substringMatch(\"foo\", 2, \"Oo\")).isFalse();\n\t\tassertThat(StringUtils.substringMatch(\"foo\", 3, \"Oo\")).isFalse();\n\t\tassertThat(StringUtils.substringMatch(\"foo\", 2, \"O\")).isFalse();\n\t\tassertThat(StringUtils.substringMatch(\"foo\", 3, \"O\")).isFalse();\n\t}\n\n\t@Test\n\tvoid countOccurrencesOf() {\n\t\tassertThat(StringUtils.countOccurrencesOf(null, null)).as(\"nullx2 = 0\").isEqualTo(0);\n\t\tassertThat(StringUtils.countOccurrencesOf(\"s\", null)).as(\"null string = 0\").isEqualTo(0);\n\t\tassertThat(StringUtils.countOccurrencesOf(null, \"s\")).as(\"null substring = 0\").isEqualTo(0);\n\t\tString s = \"erowoiueoiur\";\n\t\tassertThat(StringUtils.countOccurrencesOf(s, \"WERWER\")).as(\"not found = 0\").isEqualTo(0);\n\t\tassertThat(StringUtils.countOccurrencesOf(s, \"x\")).as(\"not found char = 0\").isEqualTo(0);\n\t\tassertThat(StringUtils.countOccurrencesOf(s, \" \")).as(\"not found ws = 0\").isEqualTo(0);\n\t\tassertThat(StringUtils.countOccurrencesOf(s, \"\")).as(\"not found empty string = 0\").isEqualTo(0);\n\t\tassertThat(StringUtils.countOccurrencesOf(s, \"e\")).as(\"found char=2\").isEqualTo(2);\n\t\tassertThat(StringUtils.countOccurrencesOf(s, \"oi\")).as(\"found substring=2\").isEqualTo(2);\n\t\tassertThat(StringUtils.countOccurrencesOf(s, \"oiu\")).as(\"found substring=2\").isEqualTo(2);\n\t\tassertThat(StringUtils.countOccurrencesOf(s, \"oiur\")).as(\"found substring=3\").isEqualTo(1);\n\t\tassertThat(StringUtils.countOccurrencesOf(s, \"r\")).as(\"test last\").isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid replace() {\n\t\tString inString = \"a6AazAaa77abaa\";\n\t\tString oldPattern = \"aa\";\n\t\tString newPattern = \"foo\";\n\n\t\t// Simple replace\n\t\tString s = StringUtils.replace(inString, oldPattern, newPattern);\n\t\tassertThat(s).as(\"Replace 1 worked\").isEqualTo(\"a6AazAfoo77abfoo\");\n\n\t\t// Non match: no change\n\t\ts = StringUtils.replace(inString, \"qwoeiruqopwieurpoqwieur\", newPattern);\n\t\tassertThat(s).as(\"Replace non-matched is returned as-is\").isSameAs(inString);\n\n\t\t// Null new pattern: should ignore\n\t\ts = StringUtils.replace(inString, oldPattern, null);\n\t\tassertThat(s).as(\"Replace non-matched is returned as-is\").isSameAs(inString);\n\n\t\t// Null old pattern: should ignore\n\t\ts = StringUtils.replace(inString, null, newPattern);\n\t\tassertThat(s).as(\"Replace non-matched is returned as-is\").isSameAs(inString);\n\t}\n\n\t@Test\n\tvoid delete() {\n\t\tString inString = \"The quick brown fox jumped over the lazy dog\";\n\n\t\tString noThe = StringUtils.delete(inString, \"the\");\n\t\tassertThat(noThe).as(\"Result has no the [\" + noThe + \"]\")\n\t\t\t\t.isEqualTo(\"The quick brown fox jumped over  lazy dog\");\n\n\t\tString nohe = StringUtils.delete(inString, \"he\");\n\t\tassertThat(nohe).as(\"Result has no he [\" + nohe + \"]\").isEqualTo(\"T quick brown fox jumped over t lazy dog\");\n\n\t\tString nosp = StringUtils.delete(inString, \" \");\n\t\tassertThat(nosp).as(\"Result has no spaces\").isEqualTo(\"Thequickbrownfoxjumpedoverthelazydog\");\n\n\t\tString killEnd = StringUtils.delete(inString, \"dog\");\n\t\tassertThat(killEnd).as(\"Result has no dog\").isEqualTo(\"The quick brown fox jumped over the lazy \");\n\n\t\tString mismatch = StringUtils.delete(inString, \"dxxcxcxog\");\n\t\tassertThat(mismatch).as(\"Result is unchanged\").isEqualTo(inString);\n\n\t\tString nochange = StringUtils.delete(inString, \"\");\n\t\tassertThat(nochange).as(\"Result is unchanged\").isEqualTo(inString);\n\t}\n\n\t@Test\n\tvoid deleteAny() {\n\t\tString inString = \"Able was I ere I saw Elba\";\n\n\t\tString res = StringUtils.deleteAny(inString, \"I\");\n\t\tassertThat(res).as(\"Result has no 'I'\").isEqualTo(\"Able was  ere  saw Elba\");\n\n\t\tres = StringUtils.deleteAny(inString, \"AeEba!\");\n\t\tassertThat(res).as(\"Result has no 'AeEba!'\").isEqualTo(\"l ws I r I sw l\");\n\n\t\tres = StringUtils.deleteAny(inString, \"#@$#$^\");\n\t\tassertThat(res).as(\"Result is unchanged\").isEqualTo(inString);\n\t}\n\n\t@Test\n\tvoid deleteAnyWhitespace() {\n\t\tString whitespace = \"This is\\n\\n\\n    \\t   a messagy string with whitespace\\n\";\n\t\tassertThat(whitespace).as(\"Has CR\").contains(\"\\n\");\n\t\tassertThat(whitespace).as(\"Has tab\").contains(\"\\t\");\n\t\tassertThat(whitespace).as(\"Has space\").contains(\" \");\n\n\t\tString cleaned = StringUtils.deleteAny(whitespace, \"\\n\\t \");\n\t\tassertThat(cleaned).as(\"Has no CR\").doesNotContain(\"\\n\");\n\t\tassertThat(cleaned).as(\"Has no tab\").doesNotContain(\"\\t\");\n\t\tassertThat(cleaned).as(\"Has no space\").doesNotContain(\" \");\n\t\tassertThat(cleaned.length()).as(\"Still has chars\").isGreaterThan(10);\n\t}\n\n\t@Test\n\tvoid quote() {\n\t\tassertThat(StringUtils.quote(\"myString\")).isEqualTo(\"'myString'\");\n\t\tassertThat(StringUtils.quote(\"\")).isEqualTo(\"''\");\n\t\tassertThat(StringUtils.quote(null)).isNull();\n\t}\n\n\t@Test\n\tvoid quoteIfString() {\n\t\tassertThat(StringUtils.quoteIfString(\"myString\")).isEqualTo(\"'myString'\");\n\t\tassertThat(StringUtils.quoteIfString(\"\")).isEqualTo(\"''\");\n\t\tassertThat(StringUtils.quoteIfString(5)).isEqualTo(5);\n\t\tassertThat(StringUtils.quoteIfString(null)).isNull();\n\t}\n\n\t@Test\n\tvoid unqualify() {\n\t\tString qualified = \"i.am.not.unqualified\";\n\t\tassertThat(StringUtils.unqualify(qualified)).isEqualTo(\"unqualified\");\n\t}\n\n\t@Test\n\tvoid capitalize() {\n\t\tString capitalized = \"i am not capitalized\";\n\t\tassertThat(StringUtils.capitalize(capitalized)).isEqualTo(\"I am not capitalized\");\n\t}\n\n\t@Test\n\tvoid uncapitalize() {\n\t\tString capitalized = \"I am capitalized\";\n\t\tassertThat(StringUtils.uncapitalize(capitalized)).isEqualTo(\"i am capitalized\");\n\t}\n\n\t@Test\n\tvoid getFilename() {\n\t\tassertThat(StringUtils.getFilename(null)).isNull();\n\t\tassertThat(StringUtils.getFilename(\"\")).isEmpty();\n\t\tassertThat(StringUtils.getFilename(\"myfile\")).isEqualTo(\"myfile\");\n\t\tassertThat(StringUtils.getFilename(\"mypath/myfile\")).isEqualTo(\"myfile\");\n\t\tassertThat(StringUtils.getFilename(\"myfile.\")).isEqualTo(\"myfile.\");\n\t\tassertThat(StringUtils.getFilename(\"mypath/myfile.\")).isEqualTo(\"myfile.\");\n\t\tassertThat(StringUtils.getFilename(\"myfile.txt\")).isEqualTo(\"myfile.txt\");\n\t\tassertThat(StringUtils.getFilename(\"mypath/myfile.txt\")).isEqualTo(\"myfile.txt\");\n\t}\n\n\t@Test\n\tvoid getFilenameExtension() {\n\t\tassertThat(StringUtils.getFilenameExtension(null)).isNull();\n\t\tassertThat(StringUtils.getFilenameExtension(\"\")).isNull();\n\t\tassertThat(StringUtils.getFilenameExtension(\"myfile\")).isNull();\n\t\tassertThat(StringUtils.getFilenameExtension(\"myPath/myfile\")).isNull();\n\t\tassertThat(StringUtils.getFilenameExtension(\"/home/user/.m2/settings/myfile\")).isNull();\n\t\tassertThat(StringUtils.getFilenameExtension(\"myfile.\")).isEmpty();\n\t\tassertThat(StringUtils.getFilenameExtension(\"myPath/myfile.\")).isEmpty();\n\t\tassertThat(StringUtils.getFilenameExtension(\"myfile.txt\")).isEqualTo(\"txt\");\n\t\tassertThat(StringUtils.getFilenameExtension(\"mypath/myfile.txt\")).isEqualTo(\"txt\");\n\t\tassertThat(StringUtils.getFilenameExtension(\"/home/user/.m2/settings/myfile.txt\")).isEqualTo(\"txt\");\n\t}\n\n\t@Test\n\tvoid stripFilenameExtension() {\n\t\tassertThat(StringUtils.stripFilenameExtension(\"\")).isEmpty();\n\t\tassertThat(StringUtils.stripFilenameExtension(\"myfile\")).isEqualTo(\"myfile\");\n\t\tassertThat(StringUtils.stripFilenameExtension(\"myfile.\")).isEqualTo(\"myfile\");\n\t\tassertThat(StringUtils.stripFilenameExtension(\"myfile.txt\")).isEqualTo(\"myfile\");\n\t\tassertThat(StringUtils.stripFilenameExtension(\"mypath/myfile\")).isEqualTo(\"mypath/myfile\");\n\t\tassertThat(StringUtils.stripFilenameExtension(\"mypath/myfile.\")).isEqualTo(\"mypath/myfile\");\n\t\tassertThat(StringUtils.stripFilenameExtension(\"mypath/myfile.txt\")).isEqualTo(\"mypath/myfile\");\n\t\tassertThat(StringUtils.stripFilenameExtension(\"/home/user/.m2/settings/myfile\")).isEqualTo(\"/home/user/.m2/settings/myfile\");\n\t\tassertThat(StringUtils.stripFilenameExtension(\"/home/user/.m2/settings/myfile.\")).isEqualTo(\"/home/user/.m2/settings/myfile\");\n\t\tassertThat(StringUtils.stripFilenameExtension(\"/home/user/.m2/settings/myfile.txt\")).isEqualTo(\"/home/user/.m2/settings/myfile\");\n\t}\n\n\t@Test\n\tvoid cleanPath() {\n\t\tassertThat(StringUtils.cleanPath(\"mypath/myfile\")).isEqualTo(\"mypath/myfile\");\n\t\tassertThat(StringUtils.cleanPath(\"mypath\\\\myfile\")).isEqualTo(\"mypath/myfile\");\n\t\tassertThat(StringUtils.cleanPath(\"mypath/../mypath/myfile\")).isEqualTo(\"mypath/myfile\");\n\t\tassertThat(StringUtils.cleanPath(\"mypath/myfile/../../mypath/myfile\")).isEqualTo(\"mypath/myfile\");\n\t\tassertThat(StringUtils.cleanPath(\"../mypath/myfile\")).isEqualTo(\"../mypath/myfile\");\n\t\tassertThat(StringUtils.cleanPath(\"../mypath/../mypath/myfile\")).isEqualTo(\"../mypath/myfile\");\n\t\tassertThat(StringUtils.cleanPath(\"mypath/../../mypath/myfile\")).isEqualTo(\"../mypath/myfile\");\n\t\tassertThat(StringUtils.cleanPath(\"/../mypath/myfile\")).isEqualTo(\"/../mypath/myfile\");\n\t\tassertThat(StringUtils.cleanPath(\"/a/:b/../../mypath/myfile\")).isEqualTo(\"/mypath/myfile\");\n\t\tassertThat(StringUtils.cleanPath(\"/\")).isEqualTo(\"/\");\n\t\tassertThat(StringUtils.cleanPath(\"/mypath/../\")).isEqualTo(\"/\");\n\t\tassertThat(StringUtils.cleanPath(\"mypath/..\")).isEmpty();\n\t\tassertThat(StringUtils.cleanPath(\"mypath/../.\")).isEmpty();\n\t\tassertThat(StringUtils.cleanPath(\"mypath/../\")).isEqualTo(\"./\");\n\t\tassertThat(StringUtils.cleanPath(\"././\")).isEqualTo(\"./\");\n\t\tassertThat(StringUtils.cleanPath(\"./\")).isEqualTo(\"./\");\n\t\tassertThat(StringUtils.cleanPath(\"../\")).isEqualTo(\"../\");\n\t\tassertThat(StringUtils.cleanPath(\"./../\")).isEqualTo(\"../\");\n\t\tassertThat(StringUtils.cleanPath(\".././\")).isEqualTo(\"../\");\n\t\tassertThat(StringUtils.cleanPath(\"file:/\")).isEqualTo(\"file:/\");\n\t\tassertThat(StringUtils.cleanPath(\"file:/mypath/../\")).isEqualTo(\"file:/\");\n\t\tassertThat(StringUtils.cleanPath(\"file:mypath/..\")).isEqualTo(\"file:\");\n\t\tassertThat(StringUtils.cleanPath(\"file:mypath/../.\")).isEqualTo(\"file:\");\n\t\tassertThat(StringUtils.cleanPath(\"file:mypath/../\")).isEqualTo(\"file:./\");\n\t\tassertThat(StringUtils.cleanPath(\"file:././\")).isEqualTo(\"file:./\");\n\t\tassertThat(StringUtils.cleanPath(\"file:./\")).isEqualTo(\"file:./\");\n\t\tassertThat(StringUtils.cleanPath(\"file:../\")).isEqualTo(\"file:../\");\n\t\tassertThat(StringUtils.cleanPath(\"file:./../\")).isEqualTo(\"file:../\");\n\t\tassertThat(StringUtils.cleanPath(\"file:.././\")).isEqualTo(\"file:../\");\n\t\tassertThat(StringUtils.cleanPath(\"file:/mypath/spring.factories\")).isEqualTo(\"file:/mypath/spring.factories\");\n\t\tassertThat(StringUtils.cleanPath(\"file:///c:/some/../path/the%20file.txt\")).isEqualTo(\"file:///c:/path/the%20file.txt\");\n\t\tassertThat(StringUtils.cleanPath(\"jar:file:///c:\\\\some\\\\..\\\\path\\\\.\\\\the%20file.txt\")).isEqualTo(\"jar:file:///c:/path/the%20file.txt\");\n\t\tassertThat(StringUtils.cleanPath(\"jar:file:///c:/some/../path/./the%20file.txt\")).isEqualTo(\"jar:file:///c:/path/the%20file.txt\");\n\t\tassertThat(StringUtils.cleanPath(\"jar:file:///c:\\\\\\\\some\\\\\\\\..\\\\\\\\path\\\\\\\\.\\\\\\\\the%20file.txt\")).isEqualTo(\"jar:file:///c:/path/the%20file.txt\");\n\t}\n\n\t@Test\n\tvoid pathEquals() {\n\t\tassertThat(StringUtils.pathEquals(\"/dummy1/dummy2/dummy3\", \"/dummy1/dummy2/dummy3\")).as(\"Must be true for the same strings\").isTrue();\n\t\tassertThat(StringUtils.pathEquals(\"C:\\\\dummy1\\\\dummy2\\\\dummy3\", \"C:\\\\dummy1\\\\dummy2\\\\dummy3\")).as(\"Must be true for the same win strings\").isTrue();\n\t\tassertThat(StringUtils.pathEquals(\"/dummy1/bin/../dummy2/dummy3\", \"/dummy1/dummy2/dummy3\")).as(\"Must be true for one top path on 1\").isTrue();\n\t\tassertThat(StringUtils.pathEquals(\"C:\\\\dummy1\\\\dummy2\\\\dummy3\", \"C:\\\\dummy1\\\\bin\\\\..\\\\dummy2\\\\dummy3\")).as(\"Must be true for one win top path on 2\").isTrue();\n\t\tassertThat(StringUtils.pathEquals(\"/dummy1/bin/../dummy2/bin/../dummy3\", \"/dummy1/dummy2/dummy3\")).as(\"Must be true for two top paths on 1\").isTrue();\n\t\tassertThat(StringUtils.pathEquals(\"C:\\\\dummy1\\\\dummy2\\\\dummy3\", \"C:\\\\dummy1\\\\bin\\\\..\\\\dummy2\\\\bin\\\\..\\\\dummy3\")).as(\"Must be true for two win top paths on 2\").isTrue();\n\t\tassertThat(StringUtils.pathEquals(\"/dummy1/bin/tmp/../../dummy2/dummy3\", \"/dummy1/dummy2/dummy3\")).as(\"Must be true for double top paths on 1\").isTrue();\n\t\tassertThat(StringUtils.pathEquals(\"/dummy1/dummy2/dummy3\", \"/dummy1/dum/dum/../../dummy2/dummy3\")).as(\"Must be true for double top paths on 2 with similarity\").isTrue();\n\t\tassertThat(StringUtils.pathEquals(\"./dummy1/dummy2/dummy3\", \"dummy1/dum/./dum/../../dummy2/dummy3\")).as(\"Must be true for current paths\").isTrue();\n\t\tassertThat(StringUtils.pathEquals(\"./dummy1/dummy2/dummy3\", \"/dummy1/dum/./dum/../../dummy2/dummy3\")).as(\"Must be false for relative/absolute paths\").isFalse();\n\t\tassertThat(StringUtils.pathEquals(\"/dummy1/dummy2/dummy3\", \"/dummy1/dummy4/dummy3\")).as(\"Must be false for different strings\").isFalse();\n\t\tassertThat(StringUtils.pathEquals(\"/dummy1/bin/tmp/../dummy2/dummy3\", \"/dummy1/dummy2/dummy3\")).as(\"Must be false for one false path on 1\").isFalse();\n\t\tassertThat(StringUtils.pathEquals(\"C:\\\\dummy1\\\\dummy2\\\\dummy3\", \"C:\\\\dummy1\\\\bin\\\\tmp\\\\..\\\\dummy2\\\\dummy3\")).as(\"Must be false for one false win top path on 2\").isFalse();\n\t\tassertThat(StringUtils.pathEquals(\"/dummy1/bin/../dummy2/dummy3\", \"/dummy1/dummy2/dummy4\")).as(\"Must be false for top path on 1 + difference\").isFalse();\n\t}\n\n\t@Test\n\tvoid concatenateStringArrays() {\n\t\tString[] input1 = new String[] {\"myString2\"};\n\t\tString[] input2 = new String[] {\"myString1\", \"myString2\"};\n\t\tString[] result = StringUtils.concatenateStringArrays(input1, input2);\n\t\tassertThat(result).hasSize(3);\n\t\tassertThat(result[0]).isEqualTo(\"myString2\");\n\t\tassertThat(result[1]).isEqualTo(\"myString1\");\n\t\tassertThat(result[2]).isEqualTo(\"myString2\");\n\n\t\tassertThat(StringUtils.concatenateStringArrays(input1, null)).isEqualTo(input1);\n\t\tassertThat(StringUtils.concatenateStringArrays(null, input2)).isEqualTo(input2);\n\t\tassertThat(StringUtils.concatenateStringArrays(null, null)).isNull();\n\t}\n\n\t@Test\n\tvoid sortStringArray() {\n\t\tString[] input = new String[] {\"myString2\"};\n\t\tinput = StringUtils.addStringToArray(input, \"myString1\");\n\t\tassertThat(input[0]).isEqualTo(\"myString2\");\n\t\tassertThat(input[1]).isEqualTo(\"myString1\");\n\n\t\tStringUtils.sortStringArray(input);\n\t\tassertThat(input[0]).isEqualTo(\"myString1\");\n\t\tassertThat(input[1]).isEqualTo(\"myString2\");\n\t}\n\n\t@Test\n\tvoid trimArrayElements() {\n\t\tassertThat(StringUtils.trimArrayElements(null)).isNull();\n\t\tassertThat(StringUtils.trimArrayElements(new String[] {})).isEmpty();\n\t\tassertThat(StringUtils.trimArrayElements(new String[] { \"\", \" \", \"  \", \"   \" })).containsExactly(\"\", \"\", \"\", \"\");\n\t\tassertThat(StringUtils.trimArrayElements(new String[] { \"\\n\", \"\\t \", \"\\n\\t\" })).containsExactly(\"\", \"\", \"\");\n\t\tassertThat(StringUtils.trimArrayElements(new String[] { \"a\", \"b\", \"c\" })).containsExactly(\"a\", \"b\", \"c\");\n\t\tassertThat(StringUtils.trimArrayElements(new String[] { \"  a  \", \"  b b \", \"  cc  \" })).containsExactly(\"a\", \"b b\", \"cc\");\n\t\tassertThat(StringUtils.trimArrayElements(new String[] { \"  a  \", \"b\", \"  c  \" })).containsExactly(\"a\", \"b\", \"c\");\n\t\tassertThat(StringUtils.trimArrayElements(new String[] { null, \"  a  \", null })).containsExactly(null, \"a\", null);\n\t}\n\n\t@Test\n\tvoid removeDuplicateStrings() {\n\t\tString[] input = new String[] {\"myString2\", \"myString1\", \"myString2\"};\n\t\tinput = StringUtils.removeDuplicateStrings(input);\n\t\tassertThat(input[0]).isEqualTo(\"myString2\");\n\t\tassertThat(input[1]).isEqualTo(\"myString1\");\n\t}\n\n\t@Test\n\tvoid splitArrayElementsIntoProperties() {\n\t\tString[] input = new String[] {\"key1=value1 \", \"key2 =\\\"value2\\\"\"};\n\t\tProperties result = StringUtils.splitArrayElementsIntoProperties(input, \"=\");\n\t\tassertThat(result.getProperty(\"key1\")).isEqualTo(\"value1\");\n\t\tassertThat(result.getProperty(\"key2\")).isEqualTo(\"\\\"value2\\\"\");\n\t}\n\n\t@Test\n\tvoid splitArrayElementsIntoPropertiesAndDeletedChars() {\n\t\tString[] input = new String[] {\"key1=value1 \", \"key2 =\\\"value2\\\"\"};\n\t\tProperties result = StringUtils.splitArrayElementsIntoProperties(input, \"=\", \"\\\"\");\n\t\tassertThat(result.getProperty(\"key1\")).isEqualTo(\"value1\");\n\t\tassertThat(result.getProperty(\"key2\")).isEqualTo(\"value2\");\n\t}\n\n\t@Test\n\tvoid tokenizeToStringArray() {\n\t\tString[] sa = StringUtils.tokenizeToStringArray(\"a,b , ,c\", \",\");\n\t\tassertThat(sa).hasSize(3);\n\t\tassertThat(sa[0].equals(\"a\") && sa[1].equals(\"b\") && sa[2].equals(\"c\")).as(\"components are correct\").isTrue();\n\t}\n\n\t@Test\n\tvoid tokenizeToStringArrayWithNotIgnoreEmptyTokens() {\n\t\tString[] sa = StringUtils.tokenizeToStringArray(\"a,b , ,c\", \",\", true, false);\n\t\tassertThat(sa).hasSize(4);\n\t\tassertThat(sa[0].equals(\"a\") && sa[1].equals(\"b\") && sa[2].isEmpty() && sa[3].equals(\"c\")).as(\"components are correct\").isTrue();\n\t}\n\n\t@Test\n\tvoid tokenizeToStringArrayWithNotTrimTokens() {\n\t\tString[] sa = StringUtils.tokenizeToStringArray(\"a,b ,c\", \",\", false, true);\n\t\tassertThat(sa).hasSize(3);\n\t\tassertThat(sa[0].equals(\"a\") && sa[1].equals(\"b \") && sa[2].equals(\"c\")).as(\"components are correct\").isTrue();\n\t}\n\n\t@Test\n\tvoid commaDelimitedListToStringArrayWithNullProducesEmptyArray() {\n\t\tString[] sa = StringUtils.commaDelimitedListToStringArray(null);\n\t\tassertThat(sa).as(\"String array isn't null with null input\").isNotNull();\n\t\tassertThat(sa.length).as(\"String array length == 0 with null input\").isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid commaDelimitedListToStringArrayWithEmptyStringProducesEmptyArray() {\n\t\tString[] sa = StringUtils.commaDelimitedListToStringArray(\"\");\n\t\tassertThat(sa).as(\"String array isn't null with null input\").isNotNull();\n\t\tassertThat(sa.length).as(\"String array length == 0 with null input\").isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid delimitedListToStringArrayWithComma() {\n\t\tString[] sa = StringUtils.delimitedListToStringArray(\"a,b\", \",\");\n\t\tassertThat(sa).hasSize(2);\n\t\tassertThat(sa[0]).isEqualTo(\"a\");\n\t\tassertThat(sa[1]).isEqualTo(\"b\");\n\t}\n\n\t@Test\n\tvoid delimitedListToStringArrayWithSemicolon() {\n\t\tString[] sa = StringUtils.delimitedListToStringArray(\"a;b\", \";\");\n\t\tassertThat(sa).hasSize(2);\n\t\tassertThat(sa[0]).isEqualTo(\"a\");\n\t\tassertThat(sa[1]).isEqualTo(\"b\");\n\t}\n\n\t@Test\n\tvoid delimitedListToStringArrayWithEmptyDelimiter() {\n\t\tString[] sa = StringUtils.delimitedListToStringArray(\"a,b\", \"\");\n\t\tassertThat(sa).hasSize(3);\n\t\tassertThat(sa[0]).isEqualTo(\"a\");\n\t\tassertThat(sa[1]).isEqualTo(\",\");\n\t\tassertThat(sa[2]).isEqualTo(\"b\");\n\t}\n\n\t@Test\n\tvoid delimitedListToStringArrayWithNullDelimiter() {\n\t\tString[] sa = StringUtils.delimitedListToStringArray(\"a,b\", null);\n\t\tassertThat(sa).hasSize(1);\n\t\tassertThat(sa[0]).isEqualTo(\"a,b\");\n\t}\n\n\t@Test\n\tvoid delimitedListToStringArrayWithCharacterToDelete() {\n\t\tString[] sa = StringUtils.delimitedListToStringArray(\"a,b,c\", \",\", \"a\");\n\t\tassertThat(sa).containsExactly(\"\", \"b\", \"c\");\n\t}\n\n\t@Test\n\tvoid delimitedListToStringArrayWithCharacterToDeleteEqualsToDelimiter() {\n\t\tString[] sa = StringUtils.delimitedListToStringArray(\"a,b,c\", \",\", \",\");\n\t\tassertThat(sa).containsExactly(\"a\", \"b\", \"c\");\n\t}\n\n\t@Test\n\tvoid commaDelimitedListToStringArrayMatchWords() {\n\t\t// Could read these from files\n\t\tString[] sa = new String[] {\"foo\", \"bar\", \"big\"};\n\t\tdoTestCommaDelimitedListToStringArrayLegalMatch(sa);\n\t\tdoTestStringArrayReverseTransformationMatches(sa);\n\n\t\tsa = new String[] {\"a\", \"b\", \"c\"};\n\t\tdoTestCommaDelimitedListToStringArrayLegalMatch(sa);\n\t\tdoTestStringArrayReverseTransformationMatches(sa);\n\n\t\t// Test same words\n\t\tsa = new String[] {\"AA\", \"AA\", \"AA\", \"AA\", \"AA\"};\n\t\tdoTestCommaDelimitedListToStringArrayLegalMatch(sa);\n\t\tdoTestStringArrayReverseTransformationMatches(sa);\n\t}\n\n\tprivate void doTestStringArrayReverseTransformationMatches(String[] sa) {\n\t\tString[] reverse =\n\t\t\t\tStringUtils.commaDelimitedListToStringArray(StringUtils.arrayToCommaDelimitedString(sa));\n\t\tassertThat(Arrays.asList(reverse)).as(\"Reverse transformation is equal\").isEqualTo(Arrays.asList(sa));\n\t}\n\n\t@Test\n\tvoid commaDelimitedListToStringArraySingleString() {\n\t\t// Could read these from files\n\t\tString s = \"woeirqupoiewuropqiewuorpqiwueopriquwopeiurqopwieur\";\n\t\tString[] sa = StringUtils.commaDelimitedListToStringArray(s);\n\t\tassertThat(sa.length).as(\"Found one String with no delimiters\").isEqualTo(1);\n\t\tassertThat(sa[0]).as(\"Single array entry matches input String with no delimiters\").isEqualTo(s);\n\t}\n\n\t@Test\n\tvoid commaDelimitedListToStringArrayWithOtherPunctuation() {\n\t\t// Could read these from files\n\t\tString[] sa = new String[] {\"xcvwert4456346&*.\", \"///\", \".!\", \".\", \";\"};\n\t\tdoTestCommaDelimitedListToStringArrayLegalMatch(sa);\n\t}\n\n\t/**\n\t * We expect to see the empty Strings in the output.\n\t */\n\t@Test\n\tvoid commaDelimitedListToStringArrayEmptyStrings() {\n\t\t// Could read these from files\n\t\tString[] sa = StringUtils.commaDelimitedListToStringArray(\"a,,b\");\n\t\tassertThat(sa.length).as(\"a,,b produces array length 3\").isEqualTo(3);\n\t\tassertThat(sa[0].equals(\"a\") && sa[1].isEmpty() && sa[2].equals(\"b\")).as(\"components are correct\").isTrue();\n\n\t\tsa = new String[] {\"\", \"\", \"a\", \"\"};\n\t\tdoTestCommaDelimitedListToStringArrayLegalMatch(sa);\n\t}\n\n\tprivate void doTestCommaDelimitedListToStringArrayLegalMatch(String[] components) {\n\t\tString sb = String.join(String.valueOf(','), components);\n\t\tString[] sa = StringUtils.commaDelimitedListToStringArray(sb);\n\t\tassertThat(sa).as(\"String array isn't null with legal match\").isNotNull();\n\t\tassertThat(sa.length).as(\"String array length is correct with legal match\").isEqualTo(components.length);\n\t\tassertThat(Arrays.equals(sa, components)).as(\"Output equals input\").isTrue();\n\t}\n\n\n\t@Test\n\tvoid parseLocaleStringSunnyDay() {\n\t\tLocale expectedLocale = Locale.UK;\n\t\tLocale locale = StringUtils.parseLocaleString(expectedLocale.toString());\n\t\tassertThat(locale).as(\"When given a bona-fide Locale string, must not return null.\").isNotNull();\n\t\tassertThat(locale).isEqualTo(expectedLocale);\n\t}\n\n\t@Test\n\tvoid parseLocaleStringWithEmptyLocaleStringYieldsNullLocale() {\n\t\tLocale locale = StringUtils.parseLocaleString(\"\");\n\t\tassertThat(locale).as(\"When given an empty Locale string, must return null.\").isNull();\n\t}\n\n\t@Test  // SPR-8637\n\tvoid parseLocaleWithMultiSpecialCharactersInVariant() {\n\t\tString variant = \"proper-northern\";\n\t\tString localeString = \"en_GB_\" + variant;\n\t\tLocale locale = StringUtils.parseLocaleString(localeString);\n\t\tassertThat(locale.getVariant()).as(\"Multi-valued variant portion of the Locale not extracted correctly.\").isEqualTo(variant);\n\t}\n\n\t@Test  // SPR-3671\n\tvoid parseLocaleWithMultiValuedVariant() {\n\t\tString variant = \"proper_northern\";\n\t\tString localeString = \"en_GB_\" + variant;\n\t\tLocale locale = StringUtils.parseLocaleString(localeString);\n\t\tassertThat(locale.getVariant()).as(\"Multi-valued variant portion of the Locale not extracted correctly.\").isEqualTo(variant);\n\t}\n\n\t@Test  // SPR-3671\n\tvoid parseLocaleWithMultiValuedVariantUsingSpacesAsSeparators() {\n\t\tString variant = \"proper northern\";\n\t\tString localeString = \"en GB \" + variant;\n\t\tLocale locale = StringUtils.parseLocaleString(localeString);\n\t\tassertThat(locale.getVariant()).as(\"Multi-valued variant portion of the Locale not extracted correctly.\").isEqualTo(variant);\n\t}\n\n\t@Test  // SPR-3671\n\tvoid parseLocaleWithMultiValuedVariantUsingMixtureOfUnderscoresAndSpacesAsSeparators() {\n\t\tString variant = \"proper northern\";\n\t\tString localeString = \"en_GB_\" + variant;\n\t\tLocale locale = StringUtils.parseLocaleString(localeString);\n\t\tassertThat(locale.getVariant()).as(\"Multi-valued variant portion of the Locale not extracted correctly.\").isEqualTo(variant);\n\t}\n\n\t@Test  // SPR-7779\n\tvoid parseLocaleWithInvalidCharacters() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tStringUtils.parseLocaleString(\"%0D%0AContent-length:30%0D%0A%0D%0A%3Cscript%3Ealert%28123%29%3C/script%3E\"));\n\t}\n\n\t@Test  // SPR-9420\n\tvoid parseLocaleWithSameLowercaseTokenForLanguageAndCountry() {\n\t\tassertThat(StringUtils.parseLocaleString(\"tr_tr\").toString()).isEqualTo(\"tr_TR\");\n\t\tassertThat(StringUtils.parseLocaleString(\"bg_bg_vnt\").toString()).isEqualTo(\"bg_BG_vnt\");\n\t}\n\n\t@Test  // SPR-11806\n\tvoid parseLocaleWithVariantContainingCountryCode() {\n\t\tString variant = \"GBtest\";\n\t\tString localeString = \"en_GB_\" + variant;\n\t\tLocale locale = StringUtils.parseLocaleString(localeString);\n\t\tassertThat(locale.getVariant()).as(\"Variant containing country code not extracted correctly\").isEqualTo(variant);\n\t}\n\n\t@Test  // SPR-14718, SPR-7598\n\tvoid parseJava7Variant() {\n\t\tassertThat(StringUtils.parseLocaleString(\"sr__#LATN\").toString()).isEqualTo(\"sr__#LATN\");\n\t}\n\n\t@Test  // SPR-16651\n\tvoid availableLocalesWithLocaleString() {\n\t\tfor (Locale locale : Locale.getAvailableLocales()) {\n\t\t\tLocale parsedLocale = StringUtils.parseLocaleString(locale.toString());\n\t\t\tif (parsedLocale == null) {\n\t\t\t\tassertThat(locale.getLanguage()).isEmpty();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassertThat(locale.toString()).isEqualTo(parsedLocale.toString());\n\t\t\t}\n\t\t}\n\t}\n\n\t@Test  // SPR-16651\n\tvoid availableLocalesWithLanguageTag() {\n\t\tfor (Locale locale : Locale.getAvailableLocales()) {\n\t\t\tLocale parsedLocale = StringUtils.parseLocale(locale.toLanguageTag());\n\t\t\tif (parsedLocale == null) {\n\t\t\t\tassertThat(locale.getLanguage()).isEmpty();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassertThat(locale.toLanguageTag()).isEqualTo(parsedLocale.toLanguageTag());\n\t\t\t}\n\t\t}\n\t}\n\n\t@Test\n\tvoid invalidLocaleWithLocaleString() {\n\t\tassertThat(StringUtils.parseLocaleString(\"invalid\")).isEqualTo(new Locale(\"invalid\"));\n\t\tassertThat(StringUtils.parseLocaleString(\"invalidvalue\")).isEqualTo(new Locale(\"invalidvalue\"));\n\t\tassertThat(StringUtils.parseLocaleString(\"invalidvalue_foo\")).isEqualTo(new Locale(\"invalidvalue\", \"foo\"));\n\t\tassertThat(StringUtils.parseLocaleString(\"\")).isNull();\n\t}\n\n\t@Test\n\tvoid invalidLocaleWithLanguageTag() {\n\t\tassertThat(StringUtils.parseLocale(\"invalid\")).isEqualTo(new Locale(\"invalid\"));\n\t\tassertThat(StringUtils.parseLocale(\"invalidvalue\")).isEqualTo(new Locale(\"invalidvalue\"));\n\t\tassertThat(StringUtils.parseLocale(\"invalidvalue_foo\")).isEqualTo(new Locale(\"invalidvalue\", \"foo\"));\n\t\tassertThat(StringUtils.parseLocale(\"\")).isNull();\n\t}\n\n\t@Test\n\tvoid parseLocaleStringWithEmptyCountryAndVariant() {\n\t\tassertThat(StringUtils.parseLocale(\"be__TARASK\").toString()).isEqualTo(\"be__TARASK\");\n\t}\n\n\t@Test\n\tvoid split() {\n\t\tassertThat(StringUtils.split(\"Hello, world\", \",\")).containsExactly(\"Hello\", \" world\");\n\t\tassertThat(StringUtils.split(\",Hello world\", \",\")).containsExactly(\"\", \"Hello world\");\n\t\tassertThat(StringUtils.split(\"Hello world,\", \",\")).containsExactly(\"Hello world\", \"\");\n\t\tassertThat(StringUtils.split(\"Hello, world,\", \",\")).containsExactly(\"Hello\", \" world,\");\n\t}\n\n\t@Test\n\tvoid splitWithEmptyStringOrNull() {\n\t\tassertThat(StringUtils.split(\"Hello, world\", \"\")).isNull();\n\t\tassertThat(StringUtils.split(\"\", \",\")).isNull();\n\t\tassertThat(StringUtils.split(null, \",\")).isNull();\n\t\tassertThat(StringUtils.split(\"Hello, world\", null)).isNull();\n\t\tassertThat(StringUtils.split(null, null)).isNull();\n\t}\n\n\t@Test\n\tvoid collectionToDelimitedStringWithNullValuesShouldNotFail() {\n\t\tassertThat(StringUtils.collectionToCommaDelimitedString(Collections.singletonList(null))).isEqualTo(\"null\");\n\t}\n\n\t@Test\n\tvoid truncatePreconditions() {\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> StringUtils.truncate(\"foo\", 0))\n\t\t\t\t.withMessage(\"Truncation threshold must be a positive number: 0\");\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> StringUtils.truncate(\"foo\", -99))\n\t\t\t\t.withMessage(\"Truncation threshold must be a positive number: -99\");\n\t}\n\n\t@ParameterizedTest\n\t@CsvSource(delimiterString = \"-->\", textBlock = \"\"\"\n\t\t\t''                  --> ''\n\t\t\taardvark            --> aardvark\n\t\t\taardvark12          --> aardvark12\n\t\t\taardvark123         --> aardvark12 (truncated)...\n\t\t\taardvark, bird, cat --> aardvark,  (truncated)...\n\t\t\t\"\"\"\n\t)\n\tvoid truncate(String text, String truncated) {\n\t\tassertThat(StringUtils.truncate(text, 10)).isEqualTo(truncated);\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.StringUtilsTests#hasLengthForValidValues(String)",
    "headType": "method",
    "relation": "provide",
    "tail": "@ParameterizedTest\r\n@ValueSource(strings = { \"text\", \"  text  \", \"  \", \"\\t\", \"\\n text\" })\r\nvoid hasLengthForValidValues(String value) {\r\n    assertThat(StringUtils.hasLength(value)).isTrue();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.StringUtilsTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.StringUtilsTests#hasLengthForValidValues(String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.StringUtilsTests#hasLengthForValidValues(String)",
    "headType": "method",
    "relation": "use",
    "tail": "@ParameterizedTest",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.StringUtilsTests#hasLengthForValidValues(String)",
    "headType": "method",
    "relation": "use",
    "tail": "@ValueSource",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.StringUtilsTests#hasLengthForInvalidValues(String)",
    "headType": "method",
    "relation": "provide",
    "tail": "@ParameterizedTest\r\n@NullAndEmptySource\r\nvoid hasLengthForInvalidValues(String value) {\r\n    assertThat(StringUtils.hasLength(value)).isFalse();\r\n}",
    "tailType": "method_code"
  }
]