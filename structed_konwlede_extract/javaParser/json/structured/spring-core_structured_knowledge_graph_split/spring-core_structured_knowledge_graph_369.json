[
  {
    "head": "org.springframework.util.unit.DataSizeTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.unit.DataSizeTests#toStringWithNegativeBytes()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.unit.DataSizeTests#toStringWithNegativeBytes()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.unit.DataSizeTests#parseWithUnsupportedUnit()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid parseWithUnsupportedUnit() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> DataSize.parse(\"3WB\")).withMessage(\"'3WB' is not a valid data size\");\r\n    assertThatIllegalArgumentException().isThrownBy(() -> DataSize.parse(\"3 WB\")).withMessage(\"'3 WB' is not a valid data size\");\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.unit.DataSizeTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.unit.DataSizeTests#parseWithUnsupportedUnit()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.unit.DataSizeTests#parseWithUnsupportedUnit()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.asm.ClassWriter",
    "headType": "class",
    "relation": "provide",
    "tail": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage org.springframework.asm;\n\n/**\n * A {@link ClassVisitor} that generates a corresponding ClassFile structure, as defined in the Java\n * Virtual Machine Specification (JVMS). It can be used alone, to generate a Java class \"from\n * scratch\", or with one or more {@link ClassReader} and adapter {@link ClassVisitor} to generate a\n * modified class from one or more existing Java classes.\n *\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html\">JVMS 4</a>\n * @author Eric Bruneton\n */\npublic class ClassWriter extends ClassVisitor {\n\n  /**\n   * A flag to automatically compute the maximum stack size and the maximum number of local\n   * variables of methods. If this flag is set, then the arguments of the {@link\n   * MethodVisitor#visitMaxs} method of the {@link MethodVisitor} returned by the {@link\n   * #visitMethod} method will be ignored, and computed automatically from the signature and the\n   * bytecode of each method.\n   *\n   * <p><b>Note:</b> for classes whose version is {@link Opcodes#V1_7} of more, this option requires\n   * valid stack map frames. The maximum stack size is then computed from these frames, and from the\n   * bytecode instructions in between. If stack map frames are not present or must be recomputed,\n   * used {@link #COMPUTE_FRAMES} instead.\n   *\n   * @see #ClassWriter(int)\n   */\n  public static final int COMPUTE_MAXS = 1;\n\n  /**\n   * A flag to automatically compute the stack map frames of methods from scratch. If this flag is\n   * set, then the calls to the {@link MethodVisitor#visitFrame} method are ignored, and the stack\n   * map frames are recomputed from the methods bytecode. The arguments of the {@link\n   * MethodVisitor#visitMaxs} method are also ignored and recomputed from the bytecode. In other\n   * words, {@link #COMPUTE_FRAMES} implies {@link #COMPUTE_MAXS}.\n   *\n   * @see #ClassWriter(int)\n   */\n  public static final int COMPUTE_FRAMES = 2;\n\n  /**\n   * The flags passed to the constructor. Must be zero or more of {@link #COMPUTE_MAXS} and {@link\n   * #COMPUTE_FRAMES}.\n   */\n  private final int flags;\n\n  // Note: fields are ordered as in the ClassFile structure, and those related to attributes are\n  // ordered as in Section 4.7 of the JVMS.\n\n  /**\n   * The minor_version and major_version fields of the JVMS ClassFile structure. minor_version is\n   * stored in the 16 most significant bits, and major_version in the 16 least significant bits.\n   */\n  private int version;\n\n  /** The symbol table for this class (contains the constant_pool and the BootstrapMethods). */\n  private final SymbolTable symbolTable;\n\n  /**\n   * The access_flags field of the JVMS ClassFile structure. This field can contain ASM specific\n   * access flags, such as {@link Opcodes#ACC_DEPRECATED} or {@link Opcodes#ACC_RECORD}, which are\n   * removed when generating the ClassFile structure.\n   */\n  private int accessFlags;\n\n  /** The this_class field of the JVMS ClassFile structure. */\n  private int thisClass;\n\n  /** The super_class field of the JVMS ClassFile structure. */\n  private int superClass;\n\n  /** The interface_count field of the JVMS ClassFile structure. */\n  private int interfaceCount;\n\n  /** The 'interfaces' array of the JVMS ClassFile structure. */\n  private int[] interfaces;\n\n  /**\n   * The fields of this class, stored in a linked list of {@link FieldWriter} linked via their\n   * {@link FieldWriter#fv} field. This field stores the first element of this list.\n   */\n  private FieldWriter firstField;\n\n  /**\n   * The fields of this class, stored in a linked list of {@link FieldWriter} linked via their\n   * {@link FieldWriter#fv} field. This field stores the last element of this list.\n   */\n  private FieldWriter lastField;\n\n  /**\n   * The methods of this class, stored in a linked list of {@link MethodWriter} linked via their\n   * {@link MethodWriter#mv} field. This field stores the first element of this list.\n   */\n  private MethodWriter firstMethod;\n\n  /**\n   * The methods of this class, stored in a linked list of {@link MethodWriter} linked via their\n   * {@link MethodWriter#mv} field. This field stores the last element of this list.\n   */\n  private MethodWriter lastMethod;\n\n  /** The number_of_classes field of the InnerClasses attribute, or 0. */\n  private int numberOfInnerClasses;\n\n  /** The 'classes' array of the InnerClasses attribute, or {@literal null}. */\n  private ByteVector innerClasses;\n\n  /** The class_index field of the EnclosingMethod attribute, or 0. */\n  private int enclosingClassIndex;\n\n  /** The method_index field of the EnclosingMethod attribute. */\n  private int enclosingMethodIndex;\n\n  /** The signature_index field of the Signature attribute, or 0. */\n  private int signatureIndex;\n\n  /** The source_file_index field of the SourceFile attribute, or 0. */\n  private int sourceFileIndex;\n\n  /** The debug_extension field of the SourceDebugExtension attribute, or {@literal null}. */\n  private ByteVector debugExtension;\n\n  /**\n   * The last runtime visible annotation of this class. The previous ones can be accessed with the\n   * {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\n   */\n  private AnnotationWriter lastRuntimeVisibleAnnotation;\n\n  /**\n   * The last runtime invisible annotation of this class. The previous ones can be accessed with the\n   * {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\n   */\n  private AnnotationWriter lastRuntimeInvisibleAnnotation;\n\n  /**\n   * The last runtime visible type annotation of this class. The previous ones can be accessed with\n   * the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\n   */\n  private AnnotationWriter lastRuntimeVisibleTypeAnnotation;\n\n  /**\n   * The last runtime invisible type annotation of this class. The previous ones can be accessed\n   * with the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\n   */\n  private AnnotationWriter lastRuntimeInvisibleTypeAnnotation;\n\n  /** The Module attribute of this class, or {@literal null}. */\n  private ModuleWriter moduleWriter;\n\n  /** The host_class_index field of the NestHost attribute, or 0. */\n  private int nestHostClassIndex;\n\n  /** The number_of_classes field of the NestMembers attribute, or 0. */\n  private int numberOfNestMemberClasses;\n\n  /** The 'classes' array of the NestMembers attribute, or {@literal null}. */\n  private ByteVector nestMemberClasses;\n\n  /** The number_of_classes field of the PermittedSubclasses attribute, or 0. */\n  private int numberOfPermittedSubclasses;\n\n  /** The 'classes' array of the PermittedSubclasses attribute, or {@literal null}. */\n  private ByteVector permittedSubclasses;\n\n  /**\n   * The record components of this class, stored in a linked list of {@link RecordComponentWriter}\n   * linked via their {@link RecordComponentWriter#delegate} field. This field stores the first\n   * element of this list.\n   */\n  private RecordComponentWriter firstRecordComponent;\n\n  /**\n   * The record components of this class, stored in a linked list of {@link RecordComponentWriter}\n   * linked via their {@link RecordComponentWriter#delegate} field. This field stores the last\n   * element of this list.\n   */\n  private RecordComponentWriter lastRecordComponent;\n\n  /**\n   * The first non standard attribute of this class. The next ones can be accessed with the {@link\n   * Attribute#nextAttribute} field. May be {@literal null}.\n   *\n   * <p><b>WARNING</b>: this list stores the attributes in the <i>reverse</i> order of their visit.\n   * firstAttribute is actually the last attribute visited in {@link #visitAttribute}. The {@link\n   * #toByteArray} method writes the attributes in the order defined by this list, i.e. in the\n   * reverse order specified by the user.\n   */\n  private Attribute firstAttribute;\n\n  /**\n   * Indicates what must be automatically computed in {@link MethodWriter}. Must be one of {@link\n   * MethodWriter#COMPUTE_NOTHING}, {@link MethodWriter#COMPUTE_MAX_STACK_AND_LOCAL}, {@link\n   * MethodWriter#COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES}, {@link\n   * MethodWriter#COMPUTE_INSERTED_FRAMES}, or {@link MethodWriter#COMPUTE_ALL_FRAMES}.\n   */\n  private int compute;\n\n  // -----------------------------------------------------------------------------------------------\n  // Constructor\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Constructs a new {@link ClassWriter} object.\n   *\n   * @param flags option flags that can be used to modify the default behavior of this class. Must\n   *     be zero or more of {@link #COMPUTE_MAXS} and {@link #COMPUTE_FRAMES}.\n   */\n  public ClassWriter(final int flags) {\n    this(null, flags);\n  }\n\n  /**\n   * Constructs a new {@link ClassWriter} object and enables optimizations for \"mostly add\" bytecode\n   * transformations. These optimizations are the following:\n   *\n   * <ul>\n   *   <li>The constant pool and bootstrap methods from the original class are copied as is in the\n   *       new class, which saves time. New constant pool entries and new bootstrap methods will be\n   *       added at the end if necessary, but unused constant pool entries or bootstrap methods\n   *       <i>won't be removed</i>.\n   *   <li>Methods that are not transformed are copied as is in the new class, directly from the\n   *       original class bytecode (i.e. without emitting visit events for all the method\n   *       instructions), which saves a <i>lot</i> of time. Untransformed methods are detected by\n   *       the fact that the {@link ClassReader} receives {@link MethodVisitor} objects that come\n   *       from a {@link ClassWriter} (and not from any other {@link ClassVisitor} instance).\n   * </ul>\n   *\n   * @param classReader the {@link ClassReader} used to read the original class. It will be used to\n   *     copy the entire constant pool and bootstrap methods from the original class and also to\n   *     copy other fragments of original bytecode where applicable.\n   * @param flags option flags that can be used to modify the default behavior of this class. Must\n   *     be zero or more of {@link #COMPUTE_MAXS} and {@link #COMPUTE_FRAMES}. <i>These option flags\n   *     do not affect methods that are copied as is in the new class. This means that neither the\n   *     maximum stack size nor the stack frames will be computed for these methods</i>.\n   */\n  public ClassWriter(final ClassReader classReader, final int flags) {\n    super(/* latest api = */ Opcodes.ASM9);\n    this.flags = flags;\n    symbolTable = classReader == null ? new SymbolTable(this) : new SymbolTable(this, classReader);\n    setFlags(flags);\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Accessors\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Returns true if all the given flags were passed to the constructor.\n   *\n   * @param flags some option flags. Must be zero or more of {@link #COMPUTE_MAXS} and {@link\n   *     #COMPUTE_FRAMES}.\n   * @return true if all the given flags, or more, were passed to the constructor.\n   */\n  public boolean hasFlags(final int flags) {\n    return (this.flags & flags) == flags;\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Implementation of the ClassVisitor abstract class\n  // -----------------------------------------------------------------------------------------------\n\n  @Override\n  public final void visit(\n      final int version,\n      final int access,\n      final String name,\n      final String signature,\n      final String superName,\n      final String[] interfaces) {\n    this.version = version;\n    this.accessFlags = access;\n    this.thisClass = symbolTable.setMajorVersionAndClassName(version & 0xFFFF, name);\n    if (signature != null) {\n      this.signatureIndex = symbolTable.addConstantUtf8(signature);\n    }\n    this.superClass = superName == null ? 0 : symbolTable.addConstantClass(superName).index;\n    if (interfaces != null && interfaces.length > 0) {\n      interfaceCount = interfaces.length;\n      this.interfaces = new int[interfaceCount];\n      for (int i = 0; i < interfaceCount; ++i) {\n        this.interfaces[i] = symbolTable.addConstantClass(interfaces[i]).index;\n      }\n    }\n    if (compute == MethodWriter.COMPUTE_MAX_STACK_AND_LOCAL && (version & 0xFFFF) >= Opcodes.V1_7) {\n      compute = MethodWriter.COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES;\n    }\n  }\n\n  @Override\n  public final void visitSource(final String file, final String debug) {\n    if (file != null) {\n      sourceFileIndex = symbolTable.addConstantUtf8(file);\n    }\n    if (debug != null) {\n      debugExtension = new ByteVector().encodeUtf8(debug, 0, Integer.MAX_VALUE);\n    }\n  }\n\n  @Override\n  public final ModuleVisitor visitModule(\n      final String name, final int access, final String version) {\n    return moduleWriter =\n        new ModuleWriter(\n            symbolTable,\n            symbolTable.addConstantModule(name).index,\n            access,\n            version == null ? 0 : symbolTable.addConstantUtf8(version));\n  }\n\n  @Override\n  public final void visitNestHost(final String nestHost) {\n    nestHostClassIndex = symbolTable.addConstantClass(nestHost).index;\n  }\n\n  @Override\n  public final void visitOuterClass(\n      final String owner, final String name, final String descriptor) {\n    enclosingClassIndex = symbolTable.addConstantClass(owner).index;\n    if (name != null && descriptor != null) {\n      enclosingMethodIndex = symbolTable.addConstantNameAndType(name, descriptor);\n    }\n  }\n\n  @Override\n  public final AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\n    if (visible) {\n      return lastRuntimeVisibleAnnotation =\n          AnnotationWriter.create(symbolTable, descriptor, lastRuntimeVisibleAnnotation);\n    } else {\n      return lastRuntimeInvisibleAnnotation =\n          AnnotationWriter.create(symbolTable, descriptor, lastRuntimeInvisibleAnnotation);\n    }\n  }\n\n  @Override\n  public final AnnotationVisitor visitTypeAnnotation(\n      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\n    if (visible) {\n      return lastRuntimeVisibleTypeAnnotation =\n          AnnotationWriter.create(\n              symbolTable, typeRef, typePath, descriptor, lastRuntimeVisibleTypeAnnotation);\n    } else {\n      return lastRuntimeInvisibleTypeAnnotation =\n          AnnotationWriter.create(\n              symbolTable, typeRef, typePath, descriptor, lastRuntimeInvisibleTypeAnnotation);\n    }\n  }\n\n  @Override\n  public final void visitAttribute(final Attribute attribute) {\n    // Store the attributes in the <i>reverse</i> order of their visit by this method.\n    attribute.nextAttribute = firstAttribute;\n    firstAttribute = attribute;\n  }\n\n  @Override\n  public final void visitNestMember(final String nestMember) {\n    if (nestMemberClasses == null) {\n      nestMemberClasses = new ByteVector();\n    }\n    ++numberOfNestMemberClasses;\n    nestMemberClasses.putShort(symbolTable.addConstantClass(nestMember).index);\n  }\n\n  @Override\n  public final void visitPermittedSubclass(final String permittedSubclass) {\n    if (permittedSubclasses == null) {\n      permittedSubclasses = new ByteVector();\n    }\n    ++numberOfPermittedSubclasses;\n    permittedSubclasses.putShort(symbolTable.addConstantClass(permittedSubclass).index);\n  }\n\n  @Override\n  public final void visitInnerClass(\n      final String name, final String outerName, final String innerName, final int access) {\n    if (innerClasses == null) {\n      innerClasses = new ByteVector();\n    }\n    // Section 4.7.6 of the JVMS states \"Every CONSTANT_Class_info entry in the constant_pool table\n    // which represents a class or interface C that is not a package member must have exactly one\n    // corresponding entry in the classes array\". To avoid duplicates we keep track in the info\n    // field of the Symbol of each CONSTANT_Class_info entry C whether an inner class entry has\n    // already been added for C. If so, we store the index of this inner class entry (plus one) in\n    // the info field. This trick allows duplicate detection in O(1) time.\n    Symbol nameSymbol = symbolTable.addConstantClass(name);\n    if (nameSymbol.info == 0) {\n      ++numberOfInnerClasses;\n      innerClasses.putShort(nameSymbol.index);\n      innerClasses.putShort(outerName == null ? 0 : symbolTable.addConstantClass(outerName).index);\n      innerClasses.putShort(innerName == null ? 0 : symbolTable.addConstantUtf8(innerName));\n      innerClasses.putShort(access);\n      nameSymbol.info = numberOfInnerClasses;\n    }\n    // Else, compare the inner classes entry nameSymbol.info - 1 with the arguments of this method\n    // and throw an exception if there is a difference?\n  }\n\n  @Override\n  public final RecordComponentVisitor visitRecordComponent(\n      final String name, final String descriptor, final String signature) {\n    RecordComponentWriter recordComponentWriter =\n        new RecordComponentWriter(symbolTable, name, descriptor, signature);\n    if (firstRecordComponent == null) {\n      firstRecordComponent = recordComponentWriter;\n    } else {\n      lastRecordComponent.delegate = recordComponentWriter;\n    }\n    return lastRecordComponent = recordComponentWriter;\n  }\n\n  @Override\n  public final FieldVisitor visitField(\n      final int access,\n      final String name,\n      final String descriptor,\n      final String signature,\n      final Object value) {\n    FieldWriter fieldWriter =\n        new FieldWriter(symbolTable, access, name, descriptor, signature, value);\n    if (firstField == null) {\n      firstField = fieldWriter;\n    } else {\n      lastField.fv = fieldWriter;\n    }\n    return lastField = fieldWriter;\n  }\n\n  @Override\n  public final MethodVisitor visitMethod(\n      final int access,\n      final String name,\n      final String descriptor,\n      final String signature,\n      final String[] exceptions) {\n    MethodWriter methodWriter =\n        new MethodWriter(symbolTable, access, name, descriptor, signature, exceptions, compute);\n    if (firstMethod == null) {\n      firstMethod = methodWriter;\n    } else {\n      lastMethod.mv = methodWriter;\n    }\n    return lastMethod = methodWriter;\n  }\n\n  @Override\n  public final void visitEnd() {\n    // Nothing to do.\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Other public methods\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Returns the content of the class file that was built by this ClassWriter.\n   *\n   * @return the binary content of the JVMS ClassFile structure that was built by this ClassWriter.\n   * @throws ClassTooLargeException if the constant pool of the class is too large.\n   * @throws MethodTooLargeException if the Code attribute of a method is too large.\n   */\n  public byte[] toByteArray() {\n    // First step: compute the size in bytes of the ClassFile structure.\n    // The magic field uses 4 bytes, 10 mandatory fields (minor_version, major_version,\n    // constant_pool_count, access_flags, this_class, super_class, interfaces_count, fields_count,\n    // methods_count and attributes_count) use 2 bytes each, and each interface uses 2 bytes too.\n    int size = 24 + 2 * interfaceCount;\n    int fieldsCount = 0;\n    FieldWriter fieldWriter = firstField;\n    while (fieldWriter != null) {\n      ++fieldsCount;\n      size += fieldWriter.computeFieldInfoSize();\n      fieldWriter = (FieldWriter) fieldWriter.fv;\n    }\n    int methodsCount = 0;\n    MethodWriter methodWriter = firstMethod;\n    while (methodWriter != null) {\n      ++methodsCount;\n      size += methodWriter.computeMethodInfoSize();\n      methodWriter = (MethodWriter) methodWriter.mv;\n    }\n\n    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\n    int attributesCount = 0;\n    if (innerClasses != null) {\n      ++attributesCount;\n      size += 8 + innerClasses.length;\n      symbolTable.addConstantUtf8(Constants.INNER_CLASSES);\n    }\n    if (enclosingClassIndex != 0) {\n      ++attributesCount;\n      size += 10;\n      symbolTable.addConstantUtf8(Constants.ENCLOSING_METHOD);\n    }\n    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xFFFF) < Opcodes.V1_5) {\n      ++attributesCount;\n      size += 6;\n      symbolTable.addConstantUtf8(Constants.SYNTHETIC);\n    }\n    if (signatureIndex != 0) {\n      ++attributesCount;\n      size += 8;\n      symbolTable.addConstantUtf8(Constants.SIGNATURE);\n    }\n    if (sourceFileIndex != 0) {\n      ++attributesCount;\n      size += 8;\n      symbolTable.addConstantUtf8(Constants.SOURCE_FILE);\n    }\n    if (debugExtension != null) {\n      ++attributesCount;\n      size += 6 + debugExtension.length;\n      symbolTable.addConstantUtf8(Constants.SOURCE_DEBUG_EXTENSION);\n    }\n    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {\n      ++attributesCount;\n      size += 6;\n      symbolTable.addConstantUtf8(Constants.DEPRECATED);\n    }\n    if (lastRuntimeVisibleAnnotation != null) {\n      ++attributesCount;\n      size +=\n          lastRuntimeVisibleAnnotation.computeAnnotationsSize(\n              Constants.RUNTIME_VISIBLE_ANNOTATIONS);\n    }\n    if (lastRuntimeInvisibleAnnotation != null) {\n      ++attributesCount;\n      size +=\n          lastRuntimeInvisibleAnnotation.computeAnnotationsSize(\n              Constants.RUNTIME_INVISIBLE_ANNOTATIONS);\n    }\n    if (lastRuntimeVisibleTypeAnnotation != null) {\n      ++attributesCount;\n      size +=\n          lastRuntimeVisibleTypeAnnotation.computeAnnotationsSize(\n              Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\n    }\n    if (lastRuntimeInvisibleTypeAnnotation != null) {\n      ++attributesCount;\n      size +=\n          lastRuntimeInvisibleTypeAnnotation.computeAnnotationsSize(\n              Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\n    }\n    if (symbolTable.computeBootstrapMethodsSize() > 0) {\n      ++attributesCount;\n      size += symbolTable.computeBootstrapMethodsSize();\n    }\n    if (moduleWriter != null) {\n      attributesCount += moduleWriter.getAttributeCount();\n      size += moduleWriter.computeAttributesSize();\n    }\n    if (nestHostClassIndex != 0) {\n      ++attributesCount;\n      size += 8;\n      symbolTable.addConstantUtf8(Constants.NEST_HOST);\n    }\n    if (nestMemberClasses != null) {\n      ++attributesCount;\n      size += 8 + nestMemberClasses.length;\n      symbolTable.addConstantUtf8(Constants.NEST_MEMBERS);\n    }\n    if (permittedSubclasses != null) {\n      ++attributesCount;\n      size += 8 + permittedSubclasses.length;\n      symbolTable.addConstantUtf8(Constants.PERMITTED_SUBCLASSES);\n    }\n    int recordComponentCount = 0;\n    int recordSize = 0;\n    if ((accessFlags & Opcodes.ACC_RECORD) != 0 || firstRecordComponent != null) {\n      RecordComponentWriter recordComponentWriter = firstRecordComponent;\n      while (recordComponentWriter != null) {\n        ++recordComponentCount;\n        recordSize += recordComponentWriter.computeRecordComponentInfoSize();\n        recordComponentWriter = (RecordComponentWriter) recordComponentWriter.delegate;\n      }\n      ++attributesCount;\n      size += 8 + recordSize;\n      symbolTable.addConstantUtf8(Constants.RECORD);\n    }\n    if (firstAttribute != null) {\n      attributesCount += firstAttribute.getAttributeCount();\n      size += firstAttribute.computeAttributesSize(symbolTable);\n    }\n    // IMPORTANT: this must be the last part of the ClassFile size computation, because the previous\n    // statements can add attribute names to the constant pool, thereby changing its size!\n    size += symbolTable.getConstantPoolLength();\n    int constantPoolCount = symbolTable.getConstantPoolCount();\n    if (constantPoolCount > 0xFFFF) {\n      throw new ClassTooLargeException(symbolTable.getClassName(), constantPoolCount);\n    }\n\n    // Second step: allocate a ByteVector of the correct size (in order to avoid any array copy in\n    // dynamic resizes) and fill it with the ClassFile content.\n    ByteVector result = new ByteVector(size);\n    result.putInt(0xCAFEBABE).putInt(version);\n    symbolTable.putConstantPool(result);\n    int mask = (version & 0xFFFF) < Opcodes.V1_5 ? Opcodes.ACC_SYNTHETIC : 0;\n    result.putShort(accessFlags & ~mask).putShort(thisClass).putShort(superClass);\n    result.putShort(interfaceCount);\n    for (int i = 0; i < interfaceCount; ++i) {\n      result.putShort(interfaces[i]);\n    }\n    result.putShort(fieldsCount);\n    fieldWriter = firstField;\n    while (fieldWriter != null) {\n      fieldWriter.putFieldInfo(result);\n      fieldWriter = (FieldWriter) fieldWriter.fv;\n    }\n    result.putShort(methodsCount);\n    boolean hasFrames = false;\n    boolean hasAsmInstructions = false;\n    methodWriter = firstMethod;\n    while (methodWriter != null) {\n      hasFrames |= methodWriter.hasFrames();\n      hasAsmInstructions |= methodWriter.hasAsmInstructions();\n      methodWriter.putMethodInfo(result);\n      methodWriter = (MethodWriter) methodWriter.mv;\n    }\n    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\n    result.putShort(attributesCount);\n    if (innerClasses != null) {\n      result\n          .putShort(symbolTable.addConstantUtf8(Constants.INNER_CLASSES))\n          .putInt(innerClasses.length + 2)\n          .putShort(numberOfInnerClasses)\n          .putByteArray(innerClasses.data, 0, innerClasses.length);\n    }\n    if (enclosingClassIndex != 0) {\n      result\n          .putShort(symbolTable.addConstantUtf8(Constants.ENCLOSING_METHOD))\n          .putInt(4)\n          .putShort(enclosingClassIndex)\n          .putShort(enclosingMethodIndex);\n    }\n    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xFFFF) < Opcodes.V1_5) {\n      result.putShort(symbolTable.addConstantUtf8(Constants.SYNTHETIC)).putInt(0);\n    }\n    if (signatureIndex != 0) {\n      result\n          .putShort(symbolTable.addConstantUtf8(Constants.SIGNATURE))\n          .putInt(2)\n          .putShort(signatureIndex);\n    }\n    if (sourceFileIndex != 0) {\n      result\n          .putShort(symbolTable.addConstantUtf8(Constants.SOURCE_FILE))\n          .putInt(2)\n          .putShort(sourceFileIndex);\n    }\n    if (debugExtension != null) {\n      int length = debugExtension.length;\n      result\n          .putShort(symbolTable.addConstantUtf8(Constants.SOURCE_DEBUG_EXTENSION))\n          .putInt(length)\n          .putByteArray(debugExtension.data, 0, length);\n    }\n    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {\n      result.putShort(symbolTable.addConstantUtf8(Constants.DEPRECATED)).putInt(0);\n    }\n    AnnotationWriter.putAnnotations(\n        symbolTable,\n        lastRuntimeVisibleAnnotation,\n        lastRuntimeInvisibleAnnotation,\n        lastRuntimeVisibleTypeAnnotation,\n        lastRuntimeInvisibleTypeAnnotation,\n        result);\n    symbolTable.putBootstrapMethods(result);\n    if (moduleWriter != null) {\n      moduleWriter.putAttributes(result);\n    }\n    if (nestHostClassIndex != 0) {\n      result\n          .putShort(symbolTable.addConstantUtf8(Constants.NEST_HOST))\n          .putInt(2)\n          .putShort(nestHostClassIndex);\n    }\n    if (nestMemberClasses != null) {\n      result\n          .putShort(symbolTable.addConstantUtf8(Constants.NEST_MEMBERS))\n          .putInt(nestMemberClasses.length + 2)\n          .putShort(numberOfNestMemberClasses)\n          .putByteArray(nestMemberClasses.data, 0, nestMemberClasses.length);\n    }\n    if (permittedSubclasses != null) {\n      result\n          .putShort(symbolTable.addConstantUtf8(Constants.PERMITTED_SUBCLASSES))\n          .putInt(permittedSubclasses.length + 2)\n          .putShort(numberOfPermittedSubclasses)\n          .putByteArray(permittedSubclasses.data, 0, permittedSubclasses.length);\n    }\n    if ((accessFlags & Opcodes.ACC_RECORD) != 0 || firstRecordComponent != null) {\n      result\n          .putShort(symbolTable.addConstantUtf8(Constants.RECORD))\n          .putInt(recordSize + 2)\n          .putShort(recordComponentCount);\n      RecordComponentWriter recordComponentWriter = firstRecordComponent;\n      while (recordComponentWriter != null) {\n        recordComponentWriter.putRecordComponentInfo(result);\n        recordComponentWriter = (RecordComponentWriter) recordComponentWriter.delegate;\n      }\n    }\n    if (firstAttribute != null) {\n      firstAttribute.putAttributes(symbolTable, result);\n    }\n\n    // Third step: replace the ASM specific instructions, if any.\n    if (hasAsmInstructions) {\n      return replaceAsmInstructions(result.data, hasFrames);\n    } else {\n      return result.data;\n    }\n  }\n\n  /**\n   * Returns the equivalent of the given class file, with the ASM specific instructions replaced\n   * with standard ones. This is done with a ClassReader -&gt; ClassWriter round trip.\n   *\n   * @param classFile a class file containing ASM specific instructions, generated by this\n   *     ClassWriter.\n   * @param hasFrames whether there is at least one stack map frames in 'classFile'.\n   * @return an equivalent of 'classFile', with the ASM specific instructions replaced with standard\n   *     ones.\n   */\n  private byte[] replaceAsmInstructions(final byte[] classFile, final boolean hasFrames) {\n    final Attribute[] attributes = getAttributePrototypes();\n    firstField = null;\n    lastField = null;\n    firstMethod = null;\n    lastMethod = null;\n    lastRuntimeVisibleAnnotation = null;\n    lastRuntimeInvisibleAnnotation = null;\n    lastRuntimeVisibleTypeAnnotation = null;\n    lastRuntimeInvisibleTypeAnnotation = null;\n    moduleWriter = null;\n    nestHostClassIndex = 0;\n    numberOfNestMemberClasses = 0;\n    nestMemberClasses = null;\n    numberOfPermittedSubclasses = 0;\n    permittedSubclasses = null;\n    firstRecordComponent = null;\n    lastRecordComponent = null;\n    firstAttribute = null;\n    compute = hasFrames ? MethodWriter.COMPUTE_INSERTED_FRAMES : MethodWriter.COMPUTE_NOTHING;\n    new ClassReader(classFile, 0, /* checkClassVersion= */ false)\n        .accept(\n            this,\n            attributes,\n            (hasFrames ? ClassReader.EXPAND_FRAMES : 0) | ClassReader.EXPAND_ASM_INSNS);\n    return toByteArray();\n  }\n\n  /**\n   * Returns the prototypes of the attributes used by this class, its fields and its methods.\n   *\n   * @return the prototypes of the attributes used by this class, its fields and its methods.\n   */\n  private Attribute[] getAttributePrototypes() {\n    Attribute.Set attributePrototypes = new Attribute.Set();\n    attributePrototypes.addAttributes(firstAttribute);\n    FieldWriter fieldWriter = firstField;\n    while (fieldWriter != null) {\n      fieldWriter.collectAttributePrototypes(attributePrototypes);\n      fieldWriter = (FieldWriter) fieldWriter.fv;\n    }\n    MethodWriter methodWriter = firstMethod;\n    while (methodWriter != null) {\n      methodWriter.collectAttributePrototypes(attributePrototypes);\n      methodWriter = (MethodWriter) methodWriter.mv;\n    }\n    RecordComponentWriter recordComponentWriter = firstRecordComponent;\n    while (recordComponentWriter != null) {\n      recordComponentWriter.collectAttributePrototypes(attributePrototypes);\n      recordComponentWriter = (RecordComponentWriter) recordComponentWriter.delegate;\n    }\n    return attributePrototypes.toArray();\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Utility methods: constant pool management for Attribute sub classes\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Adds a number or string constant to the constant pool of the class being build. Does nothing if\n   * the constant pool already contains a similar item. <i>This method is intended for {@link\n   * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param value the value of the constant to be added to the constant pool. This parameter must be\n   *     an {@link Integer}, a {@link Float}, a {@link Long}, a {@link Double} or a {@link String}.\n   * @return the index of a new or already existing constant item with the given value.\n   */\n  public int newConst(final Object value) {\n    return symbolTable.addConstant(value).index;\n  }\n\n  /**\n   * Adds an UTF8 string to the constant pool of the class being build. Does nothing if the constant\n   * pool already contains a similar item. <i>This method is intended for {@link Attribute} sub\n   * classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param value the String value.\n   * @return the index of a new or already existing UTF8 item.\n   */\n  // DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).\n  public int newUTF8(final String value) {\n    return symbolTable.addConstantUtf8(value);\n  }\n\n  /**\n   * Adds a class reference to the constant pool of the class being build. Does nothing if the\n   * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}\n   * sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param value the internal name of the class (see {@link Type#getInternalName()}).\n   * @return the index of a new or already existing class reference item.\n   */\n  public int newClass(final String value) {\n    return symbolTable.addConstantClass(value).index;\n  }\n\n  /**\n   * Adds a method type reference to the constant pool of the class being build. Does nothing if the\n   * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}\n   * sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param methodDescriptor method descriptor of the method type.\n   * @return the index of a new or already existing method type reference item.\n   */\n  public int newMethodType(final String methodDescriptor) {\n    return symbolTable.addConstantMethodType(methodDescriptor).index;\n  }\n\n  /**\n   * Adds a module reference to the constant pool of the class being build. Does nothing if the\n   * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}\n   * sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param moduleName name of the module.\n   * @return the index of a new or already existing module reference item.\n   */\n  public int newModule(final String moduleName) {\n    return symbolTable.addConstantModule(moduleName).index;\n  }\n\n  /**\n   * Adds a package reference to the constant pool of the class being build. Does nothing if the\n   * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}\n   * sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param packageName name of the package in its internal form.\n   * @return the index of a new or already existing module reference item.\n   */\n  public int newPackage(final String packageName) {\n    return symbolTable.addConstantPackage(packageName).index;\n  }\n\n  /**\n   * Adds a handle to the constant pool of the class being build. Does nothing if the constant pool\n   * already contains a similar item. <i>This method is intended for {@link Attribute} sub classes,\n   * and is normally not needed by class generators or adapters.</i>\n   *\n   * @param tag the kind of this handle. Must be {@link Opcodes#H_GETFIELD}, {@link\n   *     Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link\n   *     Opcodes#H_INVOKEVIRTUAL}, {@link Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL},\n   *     {@link Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n   * @param owner the internal name of the field or method owner class (see {@link\n   *     Type#getInternalName()}).\n   * @param name the name of the field or method.\n   * @param descriptor the descriptor of the field or method.\n   * @return the index of a new or already existing method type reference item.\n   * @deprecated this method is superseded by {@link #newHandle(int, String, String, String,\n   *     boolean)}.\n   */\n  @Deprecated\n  public int newHandle(\n      final int tag, final String owner, final String name, final String descriptor) {\n    return newHandle(tag, owner, name, descriptor, tag == Opcodes.H_INVOKEINTERFACE);\n  }\n\n  /**\n   * Adds a handle to the constant pool of the class being build. Does nothing if the constant pool\n   * already contains a similar item. <i>This method is intended for {@link Attribute} sub classes,\n   * and is normally not needed by class generators or adapters.</i>\n   *\n   * @param tag the kind of this handle. Must be {@link Opcodes#H_GETFIELD}, {@link\n   *     Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link\n   *     Opcodes#H_INVOKEVIRTUAL}, {@link Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL},\n   *     {@link Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n   * @param owner the internal name of the field or method owner class (see {@link\n   *     Type#getInternalName()}).\n   * @param name the name of the field or method.\n   * @param descriptor the descriptor of the field or method.\n   * @param isInterface true if the owner is an interface.\n   * @return the index of a new or already existing method type reference item.\n   */\n  public int newHandle(\n      final int tag,\n      final String owner,\n      final String name,\n      final String descriptor,\n      final boolean isInterface) {\n    return symbolTable.addConstantMethodHandle(tag, owner, name, descriptor, isInterface).index;\n  }\n\n  /**\n   * Adds a dynamic constant reference to the constant pool of the class being build. Does nothing\n   * if the constant pool already contains a similar item. <i>This method is intended for {@link\n   * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param name name of the invoked method.\n   * @param descriptor field descriptor of the constant type.\n   * @param bootstrapMethodHandle the bootstrap method.\n   * @param bootstrapMethodArguments the bootstrap method constant arguments.\n   * @return the index of a new or already existing dynamic constant reference item.\n   */\n  public int newConstantDynamic(\n      final String name,\n      final String descriptor,\n      final Handle bootstrapMethodHandle,\n      final Object... bootstrapMethodArguments) {\n    return symbolTable.addConstantDynamic(\n            name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments)\n        .index;\n  }\n\n  /**\n   * Adds an invokedynamic reference to the constant pool of the class being build. Does nothing if\n   * the constant pool already contains a similar item. <i>This method is intended for {@link\n   * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param name name of the invoked method.\n   * @param descriptor descriptor of the invoke method.\n   * @param bootstrapMethodHandle the bootstrap method.\n   * @param bootstrapMethodArguments the bootstrap method constant arguments.\n   * @return the index of a new or already existing invokedynamic reference item.\n   */\n  public int newInvokeDynamic(\n      final String name,\n      final String descriptor,\n      final Handle bootstrapMethodHandle,\n      final Object... bootstrapMethodArguments) {\n    return symbolTable.addConstantInvokeDynamic(\n            name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments)\n        .index;\n  }\n\n  /**\n   * Adds a field reference to the constant pool of the class being build. Does nothing if the\n   * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}\n   * sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param owner the internal name of the field's owner class (see {@link Type#getInternalName()}).\n   * @param name the field's name.\n   * @param descriptor the field's descriptor.\n   * @return the index of a new or already existing field reference item.\n   */\n  public int newField(final String owner, final String name, final String descriptor) {\n    return symbolTable.addConstantFieldref(owner, name, descriptor).index;\n  }\n\n  /**\n   * Adds a method reference to the constant pool of the class being build. Does nothing if the\n   * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}\n   * sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param owner the internal name of the method's owner class (see {@link\n   *     Type#getInternalName()}).\n   * @param name the method's name.\n   * @param descriptor the method's descriptor.\n   * @param isInterface {@literal true} if {@code owner} is an interface.\n   * @return the index of a new or already existing method reference item.\n   */\n  public int newMethod(\n      final String owner, final String name, final String descriptor, final boolean isInterface) {\n    return symbolTable.addConstantMethodref(owner, name, descriptor, isInterface).index;\n  }\n\n  /**\n   * Adds a name and type to the constant pool of the class being build. Does nothing if the\n   * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}\n   * sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param name a name.\n   * @param descriptor a type descriptor.\n   * @return the index of a new or already existing name and type item.\n   */\n  public int newNameType(final String name, final String descriptor) {\n    return symbolTable.addConstantNameAndType(name, descriptor);\n  }\n\n  /**\n   * Changes the computation strategy of method properties like max stack size, max number of local\n   * variables, and frames.\n   *\n   * <p><b>WARNING</b>: {@link #setFlags(int)} method changes the behavior of new method visitors\n   * returned from {@link #visitMethod(int, String, String, String, String[])}. The behavior will be\n   * changed only after the next method visitor is returned. All the previously returned method\n   * visitors keep their previous behavior.\n   *\n   * @param flags option flags that can be used to modify the default behavior of this class. Must\n   *     be zero or more of {@link #COMPUTE_MAXS} and {@link #COMPUTE_FRAMES}.\n   */\n  public final void setFlags(final int flags) {\n    if ((flags & ClassWriter.COMPUTE_FRAMES) != 0) {\n      compute = MethodWriter.COMPUTE_ALL_FRAMES;\n    } else if ((flags & ClassWriter.COMPUTE_MAXS) != 0) {\n      compute = MethodWriter.COMPUTE_MAX_STACK_AND_LOCAL;\n    } else {\n      compute = MethodWriter.COMPUTE_NOTHING;\n    }\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Default method to compute common super classes when computing stack map frames\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Returns the common super type of the two given types. The default implementation of this method\n   * <i>loads</i> the two given classes and uses the java.lang.Class methods to find the common\n   * super class. It can be overridden to compute this common super type in other ways, in\n   * particular without actually loading any class, or to take into account the class that is\n   * currently being generated by this ClassWriter, which can of course not be loaded since it is\n   * under construction.\n   *\n   * @param type1 the internal name of a class (see {@link Type#getInternalName()}).\n   * @param type2 the internal name of another class (see {@link Type#getInternalName()}).\n   * @return the internal name of the common super class of the two given classes (see {@link\n   *     Type#getInternalName()}).\n   */\n  protected String getCommonSuperClass(final String type1, final String type2) {\n    ClassLoader classLoader = getClassLoader();\n    Class<?> class1;\n    try {\n      class1 = Class.forName(type1.replace('/', '.'), false, classLoader);\n    } catch (ClassNotFoundException e) {\n      throw new TypeNotPresentException(type1, e);\n    }\n    Class<?> class2;\n    try {\n      class2 = Class.forName(type2.replace('/', '.'), false, classLoader);\n    } catch (ClassNotFoundException e) {\n      throw new TypeNotPresentException(type2, e);\n    }\n    if (class1.isAssignableFrom(class2)) {\n      return type1;\n    }\n    if (class2.isAssignableFrom(class1)) {\n      return type2;\n    }\n    if (class1.isInterface() || class2.isInterface()) {\n      return \"java/lang/Object\";\n    } else {\n      do {\n        class1 = class1.getSuperclass();\n      } while (!class1.isAssignableFrom(class2));\n      return class1.getName().replace('.', '/');\n    }\n  }\n\n  /**\n   * Returns the {@link ClassLoader} to be used by the default implementation of {@link\n   * #getCommonSuperClass(String, String)}, that of this {@link ClassWriter}'s runtime type by\n   * default.\n   *\n   * @return ClassLoader\n   */\n  protected ClassLoader getClassLoader() {\n    // SPRING PATCH: prefer thread context ClassLoader for application classes\n    ClassLoader classLoader = null;\n    try {\n      classLoader = Thread.currentThread().getContextClassLoader();\n    } catch (Throwable ex) {\n      // Cannot access thread context ClassLoader - falling back...\n    }\n    return (classLoader != null ? classLoader : getClass().getClassLoader());\n  }\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.asm.ClassWriter",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.ClassWriter#COMPUTE_MAXS",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.ClassWriter#COMPUTE_MAXS",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.ClassWriter",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.ClassWriter#COMPUTE_FRAMES",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.ClassWriter#COMPUTE_FRAMES",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.ClassWriter",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.ClassWriter#flags",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.ClassWriter#flags",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.ClassWriter",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.ClassWriter#version",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.ClassWriter#version",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.ClassWriter",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.ClassWriter#symbolTable",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.ClassWriter#symbolTable",
    "headType": "field",
    "relation": "haveType",
    "tail": "SymbolTable",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.ClassWriter",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.ClassWriter#accessFlags",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.ClassWriter#accessFlags",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.ClassWriter",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.ClassWriter#thisClass",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.ClassWriter#thisClass",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  }
]