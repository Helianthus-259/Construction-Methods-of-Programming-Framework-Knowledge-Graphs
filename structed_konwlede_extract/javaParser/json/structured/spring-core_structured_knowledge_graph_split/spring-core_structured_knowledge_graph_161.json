[
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.OverloadedMethodsClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.OverloadedMethodsClass",
    "headType": "class",
    "relation": "use",
    "tail": "@SuppressWarnings",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.OverloadedMethodsClass",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.io.Externalizable;\nimport java.io.Serializable;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Proxy;\nimport java.time.ZoneId;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.function.Supplier;\n\nimport a.ClassHavingNestedClass;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.TestInfo;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\nimport org.junit.jupiter.params.provider.ValueSource;\n\nimport org.springframework.tests.sample.objects.DerivedTestObject;\nimport org.springframework.tests.sample.objects.ITestInterface;\nimport org.springframework.tests.sample.objects.ITestObject;\nimport org.springframework.tests.sample.objects.TestObject;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Tests for {@link ClassUtils}.\n *\n * @author Colin Sampaleanu\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Rick Evans\n * @author Sam Brannen\n */\nclass ClassUtilsTests {\n\n\tprivate final ClassLoader classLoader = getClass().getClassLoader();\n\n\n\t@Test\n\tvoid isPresent() {\n\t\tassertThat(ClassUtils.isPresent(\"java.lang.String\", classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isPresent(\"java.lang.MySpecialString\", classLoader)).isFalse();\n\t}\n\n\t@Test\n\tvoid forName() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"java.lang.String\", classLoader)).isEqualTo(String.class);\n\t\tassertThat(ClassUtils.forName(\"java.lang.String[]\", classLoader)).isEqualTo(String[].class);\n\t\tassertThat(ClassUtils.forName(String[].class.getName(), classLoader)).isEqualTo(String[].class);\n\t\tassertThat(ClassUtils.forName(String[][].class.getName(), classLoader)).isEqualTo(String[][].class);\n\t\tassertThat(ClassUtils.forName(String[][][].class.getName(), classLoader)).isEqualTo(String[][][].class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject\", classLoader)).isEqualTo(TestObject.class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject[]\", classLoader)).isEqualTo(TestObject[].class);\n\t\tassertThat(ClassUtils.forName(TestObject[].class.getName(), classLoader)).isEqualTo(TestObject[].class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject[][]\", classLoader)).isEqualTo(TestObject[][].class);\n\t\tassertThat(ClassUtils.forName(TestObject[][].class.getName(), classLoader)).isEqualTo(TestObject[][].class);\n\t\tassertThat(ClassUtils.forName(\"[[[S\", classLoader)).isEqualTo(short[][][].class);\n\t}\n\n\t@Test\n\tvoid forNameWithNestedType() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"org.springframework.util.ClassUtilsTests$NestedClass\", classLoader)).isEqualTo(NestedClass.class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.util.ClassUtilsTests.NestedClass\", classLoader)).isEqualTo(NestedClass.class);\n\n\t\t// Precondition: package name must have length == 1.\n\t\tassertThat(ClassHavingNestedClass.class.getPackageName().length()).isEqualTo(1);\n\t\tassertThat(ClassUtils.forName(\"a.ClassHavingNestedClass$NestedClass\", classLoader)).isEqualTo(ClassHavingNestedClass.NestedClass.class);\n\t\tassertThat(ClassUtils.forName(\"a.ClassHavingNestedClass.NestedClass\", classLoader)).isEqualTo(ClassHavingNestedClass.NestedClass.class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveClasses() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"boolean\", classLoader)).isEqualTo(boolean.class);\n\t\tassertThat(ClassUtils.forName(\"byte\", classLoader)).isEqualTo(byte.class);\n\t\tassertThat(ClassUtils.forName(\"char\", classLoader)).isEqualTo(char.class);\n\t\tassertThat(ClassUtils.forName(\"short\", classLoader)).isEqualTo(short.class);\n\t\tassertThat(ClassUtils.forName(\"int\", classLoader)).isEqualTo(int.class);\n\t\tassertThat(ClassUtils.forName(\"long\", classLoader)).isEqualTo(long.class);\n\t\tassertThat(ClassUtils.forName(\"float\", classLoader)).isEqualTo(float.class);\n\t\tassertThat(ClassUtils.forName(\"double\", classLoader)).isEqualTo(double.class);\n\t\tassertThat(ClassUtils.forName(\"void\", classLoader)).isEqualTo(void.class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveArrays() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"boolean[]\", classLoader)).isEqualTo(boolean[].class);\n\t\tassertThat(ClassUtils.forName(\"byte[]\", classLoader)).isEqualTo(byte[].class);\n\t\tassertThat(ClassUtils.forName(\"char[]\", classLoader)).isEqualTo(char[].class);\n\t\tassertThat(ClassUtils.forName(\"short[]\", classLoader)).isEqualTo(short[].class);\n\t\tassertThat(ClassUtils.forName(\"int[]\", classLoader)).isEqualTo(int[].class);\n\t\tassertThat(ClassUtils.forName(\"long[]\", classLoader)).isEqualTo(long[].class);\n\t\tassertThat(ClassUtils.forName(\"float[]\", classLoader)).isEqualTo(float[].class);\n\t\tassertThat(ClassUtils.forName(\"double[]\", classLoader)).isEqualTo(double[].class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveArraysInternalName() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(boolean[].class.getName(), classLoader)).isEqualTo(boolean[].class);\n\t\tassertThat(ClassUtils.forName(byte[].class.getName(), classLoader)).isEqualTo(byte[].class);\n\t\tassertThat(ClassUtils.forName(char[].class.getName(), classLoader)).isEqualTo(char[].class);\n\t\tassertThat(ClassUtils.forName(short[].class.getName(), classLoader)).isEqualTo(short[].class);\n\t\tassertThat(ClassUtils.forName(int[].class.getName(), classLoader)).isEqualTo(int[].class);\n\t\tassertThat(ClassUtils.forName(long[].class.getName(), classLoader)).isEqualTo(long[].class);\n\t\tassertThat(ClassUtils.forName(float[].class.getName(), classLoader)).isEqualTo(float[].class);\n\t\tassertThat(ClassUtils.forName(double[].class.getName(), classLoader)).isEqualTo(double[].class);\n\t}\n\n\t@Test\n\tvoid isCacheSafe() {\n\t\tClassLoader childLoader1 = new ClassLoader(classLoader) {};\n\t\tClassLoader childLoader2 = new ClassLoader(classLoader) {};\n\t\tClassLoader childLoader3 = new ClassLoader(classLoader) {\n\t\t\t@Override\n\t\t\tpublic Class<?> loadClass(String name) throws ClassNotFoundException {\n\t\t\t\treturn childLoader1.loadClass(name);\n\t\t\t}\n\t\t};\n\t\tClass<?> composite = ClassUtils.createCompositeInterface(\n\t\t\t\tnew Class<?>[] {Serializable.class, Externalizable.class}, childLoader1);\n\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, null)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader2)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader3)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, null)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader2)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader3)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, null)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, classLoader)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader2)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader3)).isTrue();\n\t}\n\n\t@ParameterizedTest(name = \"''{0}'' -> {1}\")\n\t@CsvSource(textBlock = \"\"\"\n\t\tboolean, boolean\n\t\tbyte, byte\n\t\tchar, char\n\t\tshort, short\n\t\tint, int\n\t\tlong, long\n\t\tfloat, float\n\t\tdouble, double\n\t\t[Z, boolean[]\n\t\t[B, byte[]\n\t\t[C, char[]\n\t\t[S, short[]\n\t\t[I, int[]\n\t\t[J, long[]\n\t\t[F, float[]\n\t\t[D, double[]\n\t\t\"\"\")\n\tvoid resolvePrimitiveClassName(String input, Class<?> output) {\n\t\tassertThat(ClassUtils.resolvePrimitiveClassName(input)).isEqualTo(output);\n\t}\n\n\t@Test\n\tvoid getShortName() {\n\t\tString className = ClassUtils.getShortName(getClass());\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"ClassUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getShortNameForObjectArrayClass() {\n\t\tString className = ClassUtils.getShortName(Object[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"Object[]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForMultiDimensionalObjectArrayClass() {\n\t\tString className = ClassUtils.getShortName(Object[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"Object[][]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getShortName(byte[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForMultiDimensionalPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getShortName(byte[][][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[][][]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForNestedClass() {\n\t\tString className = ClassUtils.getShortName(NestedClass.class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"ClassUtilsTests.NestedClass\");\n\t}\n\n\t@Test\n\tvoid getShortNameAsProperty() {\n\t\tString shortName = ClassUtils.getShortNameAsProperty(this.getClass());\n\t\tassertThat(shortName).as(\"Class name did not match\").isEqualTo(\"classUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getClassFileName() {\n\t\tassertThat(ClassUtils.getClassFileName(String.class)).isEqualTo(\"String.class\");\n\t\tassertThat(ClassUtils.getClassFileName(getClass())).isEqualTo(\"ClassUtilsTests.class\");\n\t}\n\n\t@Test\n\tvoid getPackageName() {\n\t\tassertThat(ClassUtils.getPackageName(String.class)).isEqualTo(\"java.lang\");\n\t\tassertThat(ClassUtils.getPackageName(getClass())).isEqualTo(getClass().getPackage().getName());\n\t}\n\n\t@Test\n\tvoid getQualifiedName() {\n\t\tString className = ClassUtils.getQualifiedName(getClass());\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"org.springframework.util.ClassUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForObjectArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(Object[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"java.lang.Object[]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForMultiDimensionalObjectArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(Object[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"java.lang.Object[][]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(byte[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForMultiDimensionalPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(byte[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[][]\");\n\t}\n\n\t@Test\n\tvoid hasMethod() {\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"size\")).isTrue();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"remove\", Object.class)).isTrue();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"remove\")).isFalse();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"someOtherMethod\")).isFalse();\n\t}\n\n\t@Test\n\tvoid getMethodIfAvailable() {\n\t\tMethod method = ClassUtils.getMethodIfAvailable(Collection.class, \"size\");\n\t\tassertThat(method).isNotNull();\n\t\tassertThat(method.getName()).isEqualTo(\"size\");\n\n\t\tmethod = ClassUtils.getMethodIfAvailable(Collection.class, \"remove\", Object.class);\n\t\tassertThat(method).isNotNull();\n\t\tassertThat(method.getName()).isEqualTo(\"remove\");\n\n\t\tassertThat(ClassUtils.getMethodIfAvailable(Collection.class, \"remove\")).isNull();\n\t\tassertThat(ClassUtils.getMethodIfAvailable(Collection.class, \"someOtherMethod\")).isNull();\n\t}\n\n\t@Test\n\tvoid getMethodCountForName() {\n\t\tassertThat(ClassUtils.getMethodCountForName(OverloadedMethodsClass.class, \"print\")).as(\"Verifying number of overloaded 'print' methods for OverloadedMethodsClass.\").isEqualTo(2);\n\t\tassertThat(ClassUtils.getMethodCountForName(SubOverloadedMethodsClass.class, \"print\")).as(\"Verifying number of overloaded 'print' methods for SubOverloadedMethodsClass.\").isEqualTo(4);\n\t}\n\n\t@Test\n\tvoid countOverloadedMethods() {\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"foobar\")).isFalse();\n\t\t// no args\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"hashCode\")).isTrue();\n\t\t// matches although it takes an arg\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"setAge\")).isTrue();\n\t}\n\n\t@Test\n\tvoid isAssignable() {\n\t\tassertThat(ClassUtils.isAssignable(Object.class, Object.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(String.class, String.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Object.class, String.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Object.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Number.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Number.class, int.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, int.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(int.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(String.class, Object.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, Number.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, double.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(double.class, Integer.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid classPackageAsResourcePath() {\n\t\tString result = ClassUtils.classPackageAsResourcePath(Proxy.class);\n\t\tassertThat(result).isEqualTo(\"java/lang/reflect\");\n\t}\n\n\t@Test\n\tvoid addResourcePathToPackagePath() {\n\t\tString result = \"java/lang/reflect/xyzabc.xml\";\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"xyzabc.xml\")).isEqualTo(result);\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"/xyzabc.xml\")).isEqualTo(result);\n\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"a/b/c/d.xml\")).isEqualTo(\"java/lang/reflect/a/b/c/d.xml\");\n\t}\n\n\t@Test\n\tvoid getAllInterfaces() {\n\t\tDerivedTestObject testBean = new DerivedTestObject();\n\t\tList<Class<?>> ifcs = Arrays.asList(ClassUtils.getAllInterfaces(testBean));\n\t\tassertThat(ifcs).as(\"Correct number of interfaces\").hasSize(4);\n\t\tassertThat(ifcs.contains(Serializable.class)).as(\"Contains Serializable\").isTrue();\n\t\tassertThat(ifcs.contains(ITestObject.class)).as(\"Contains ITestBean\").isTrue();\n\t\tassertThat(ifcs.contains(ITestInterface.class)).as(\"Contains IOther\").isTrue();\n\t}\n\n\t@Test\n\tvoid classNamesToString() {\n\t\tList<Class<?>> ifcs = new ArrayList<>();\n\t\tifcs.add(Serializable.class);\n\t\tifcs.add(Runnable.class);\n\t\tassertThat(ifcs.toString()).isEqualTo(\"[interface java.io.Serializable, interface java.lang.Runnable]\");\n\t\tassertThat(ClassUtils.classNamesToString(ifcs)).isEqualTo(\"[java.io.Serializable, java.lang.Runnable]\");\n\n\t\tList<Class<?>> classes = new ArrayList<>();\n\t\tclasses.add(ArrayList.class);\n\t\tclasses.add(Integer.class);\n\t\tassertThat(classes.toString()).isEqualTo(\"[class java.util.ArrayList, class java.lang.Integer]\");\n\t\tassertThat(ClassUtils.classNamesToString(classes)).isEqualTo(\"[java.util.ArrayList, java.lang.Integer]\");\n\n\t\tassertThat(Collections.singletonList(List.class).toString()).isEqualTo(\"[interface java.util.List]\");\n\t\tassertThat(ClassUtils.classNamesToString(List.class)).isEqualTo(\"[java.util.List]\");\n\n\t\tassertThat(Collections.EMPTY_LIST.toString()).isEqualTo(\"[]\");\n\t\tassertThat(ClassUtils.classNamesToString(Collections.emptyList())).isEqualTo(\"[]\");\n\t}\n\n\t@Test\n\tvoid determineCommonAncestor() {\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Number.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Number.class, Integer.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Number.class, null)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(null, Integer.class)).isEqualTo(Integer.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Integer.class)).isEqualTo(Integer.class);\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Float.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Float.class, Integer.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, String.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(String.class, Integer.class)).isNull();\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Collection.class)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Collection.class, List.class)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Collection.class, null)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(null, List.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, List.class)).isEqualTo(List.class);\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Set.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(Set.class, List.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Runnable.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(Runnable.class, List.class)).isNull();\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, ArrayList.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(ArrayList.class, List.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, String.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(String.class, List.class)).isNull();\n\t}\n\n\t@Test\n\tvoid getMostSpecificMethod() throws NoSuchMethodException {\n\t\tMethod defaultPrintMethod = ClassUtils.getMethod(MethodsInterface.class, \"defaultPrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(defaultPrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(defaultPrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(defaultPrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(defaultPrintMethod);\n\n\t\tMethod printMethod = ClassUtils.getMethod(MethodsInterface.class, \"print\", String.class);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isNotEqualTo(printMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(MethodsInterfaceImplementation.class, \"print\", String.class));\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(MethodsInterfaceImplementation.class, \"print\", String.class));\n\n\t\tMethod protectedPrintMethod = MethodsInterfaceImplementation.class.getDeclaredMethod(\"protectedPrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(protectedPrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(protectedPrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(protectedPrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(SubMethodsInterfaceImplementation.class.getDeclaredMethod(\"protectedPrint\"));\n\n\t\tMethod packageAccessiblePrintMethod = MethodsInterfaceImplementation.class.getDeclaredMethod(\"packageAccessiblePrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(packageAccessiblePrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(packageAccessiblePrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(packageAccessiblePrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(SubMethodsInterfaceImplementation.class, \"packageAccessiblePrint\"));\n\t}\n\n\t@ParameterizedTest\n\t@WrapperTypes\n\tvoid isPrimitiveWrapper(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveWrapper(type)).isTrue();\n\t}\n\n\t@ParameterizedTest\n\t@PrimitiveTypes\n\tvoid isPrimitiveOrWrapperWithPrimitive(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(type)).isTrue();\n\t}\n\n\t@ParameterizedTest\n\t@WrapperTypes\n\tvoid isPrimitiveOrWrapperWithWrapper(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(type)).isTrue();\n\t}\n\n\t@Test\n\tvoid isLambda() {\n\t\tassertIsLambda(ClassUtilsTests.staticLambdaExpression);\n\t\tassertIsLambda(ClassUtilsTests::staticStringFactory);\n\n\t\tassertIsLambda(this.instanceLambdaExpression);\n\t\tassertIsLambda(this::instanceStringFactory);\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"Convert2Lambda\")\n\tvoid isNotLambda() {\n\t\tassertIsNotLambda(new EnigmaSupplier());\n\n\t\tassertIsNotLambda(new Supplier<>() {\n\t\t\t@Override\n\t\t\tpublic String get() {\n\t\t\t\treturn \"anonymous inner class\";\n\t\t\t}\n\t\t});\n\n\t\tassertIsNotLambda(new Fake$$LambdaSupplier());\n\t}\n\n\n\t@Nested\n\tclass GetStaticMethodTests {\n\n\t\t@BeforeEach\n\t\tvoid clearStatics() {\n\t\t\tNestedClass.noArgCalled = false;\n\t\t\tNestedClass.argCalled = false;\n\t\t\tNestedClass.overloadedCalled = false;\n\t\t}\n\n\t\t@Test\n\t\tvoid noArgsStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"staticMethod\");\n\t\t\tmethod.invoke(null, (Object[]) null);\n\t\t\tassertThat(NestedClass.noArgCalled).as(\"no argument method was not invoked.\").isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid argsStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"argStaticMethod\", String.class);\n\t\t\tmethod.invoke(null, \"test\");\n\t\t\tassertThat(NestedClass.argCalled).as(\"argument method was not invoked.\").isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid overloadedStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"staticMethod\", String.class);\n\t\t\tmethod.invoke(null, \"test\");\n\t\t\tassertThat(NestedClass.overloadedCalled).as(\"argument method was not invoked.\").isTrue();\n\t\t}\n\n\t}\n\n\n\t@Nested  // gh-33216\n\tclass GetInterfaceMethodTests {\n\n\t\t@Test\n\t\tvoid publicMethodInPublicClass() throws Exception {\n\t\t\tClass<?> originalType = String.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"getBytes\");\n\n\t\t\tMethod interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(interfaceMethod.getDeclaringClass()).isEqualTo(originalType);\n\t\t\tassertThat(interfaceMethod).isSameAs(originalMethod);\n\t\t\tassertNotInterfaceMethod(interfaceMethod);\n\t\t\tassertPubliclyAccessible(interfaceMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInNonPublicInterface() throws Exception {\n\t\t\tClass<?> originalType = PrivateInterface.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"getMessage\");\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertPublic(originalMethod);\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(interfaceMethod).isSameAs(originalMethod);\n\t\t\tassertInterfaceMethod(interfaceMethod);\n\t\t\tassertNotPubliclyAccessible(interfaceMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicInterfaceMethodInPublicClass() throws Exception {\n\t\t\tClass<?> originalType = ArrayList.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"size\");\n\n\t\t\tMethod interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(interfaceMethod.getDeclaringClass()).isEqualTo(List.class);\n\t\t\tassertThat(interfaceMethod.getName()).isEqualTo(\"size\");\n\t\t\tassertThat(interfaceMethod.getParameterTypes()).isEmpty();\n\t\t\tassertInterfaceMethod(interfaceMethod);\n\t\t\tassertPubliclyAccessible(interfaceMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicInterfaceMethodDeclaredInNonPublicClassWithLateBindingOfClassMethodToSubclassDeclaredInterface() throws Exception {\n\t\t\tHashMap<String, String> hashMap = new HashMap<>();\n\t\t\t// Returns a package-private java.util.HashMap.KeyIterator which extends java.util.HashMap.HashIterator\n\t\t\t// which declares hasNext(), even though HashIterator does not implement Iterator. Rather, KeyIterator\n\t\t\t// implements HashIterator.\n\t\t\tIterator<String> iterator = hashMap.keySet().iterator();\n\t\t\tClass<?> targetClass = iterator.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"hasNext\");\n\n\t\t\tMethod interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, targetClass);\n\t\t\tassertThat(interfaceMethod.getDeclaringClass()).isEqualTo(Iterator.class);\n\t\t\tassertThat(interfaceMethod.getName()).isEqualTo(\"hasNext\");\n\t\t\tassertThat(interfaceMethod.getParameterTypes()).isEmpty();\n\t\t\tassertInterfaceMethod(interfaceMethod);\n\t\t\tassertPubliclyAccessible(interfaceMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPublicInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getText\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(interfaceMethod.getDeclaringClass()).isEqualTo(PublicInterface.class);\n\t\t\tassertThat(interfaceMethod.getName()).isEqualTo(\"getText\");\n\t\t\tassertThat(interfaceMethod.getParameterTypes()).isEmpty();\n\t\t\tassertInterfaceMethod(interfaceMethod);\n\t\t\tassertPubliclyAccessible(interfaceMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPrivateInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getMessage\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(interfaceMethod.getDeclaringClass()).isEqualTo(PrivateInterface.class);\n\t\t\tassertThat(interfaceMethod.getName()).isEqualTo(\"getMessage\");\n\t\t\tassertThat(interfaceMethod.getParameterTypes()).isEmpty();\n\t\t\tassertInterfaceMethod(interfaceMethod);\n\t\t\tassertNotPubliclyAccessible(interfaceMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid packagePrivateSubclassOverridesMethodInPublicInterface() throws Exception {\n\t\t\tList<String> unmodifiableList = Collections.unmodifiableList(Arrays.asList(\"foo\", \"bar\"));\n\t\t\tClass<?> targetClass = unmodifiableList.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"contains\", Object.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(interfaceMethod.getDeclaringClass()).isEqualTo(Collection.class);\n\t\t\tassertThat(interfaceMethod.getName()).isEqualTo(\"contains\");\n\t\t\tassertThat(interfaceMethod.getParameterTypes()).containsExactly(Object.class);\n\t\t\tassertInterfaceMethod(interfaceMethod);\n\t\t\tassertPubliclyAccessible(interfaceMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesMethodInPrivateInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getMethod(\"greet\", String.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(interfaceMethod.getDeclaringClass()).isEqualTo(PrivateInterface.class);\n\t\t\tassertThat(interfaceMethod.getName()).isEqualTo(\"greet\");\n\t\t\tassertThat(interfaceMethod.getParameterTypes()).containsExactly(String.class);\n\t\t\tassertInterfaceMethod(interfaceMethod);\n\t\t\tassertNotPubliclyAccessible(interfaceMethod);\n\t\t}\n\n\t}\n\n\n\t@Nested  // gh-33216\n\tclass GetPubliclyAccessibleMethodTests {\n\n\t\t@Test\n\t\tvoid nonPublicMethod(TestInfo testInfo) {\n\t\t\tMethod originalMethod = testInfo.getTestMethod().get();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(originalMethod);\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertNotPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\t// This method is intentionally public.\n\t\tpublic void publicMethodInNonPublicClass(TestInfo testInfo) {\n\t\t\tMethod originalMethod = testInfo.getTestMethod().get();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertPublic(originalMethod);\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertNotPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInNonPublicInterface() throws Exception {\n\t\t\tClass<?> originalType = PrivateInterface.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"getMessage\");\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertPublic(originalMethod);\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertNotPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInPublicClass() throws Exception {\n\t\t\tClass<?> originalType = String.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"toString\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(originalType);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicInterfaceMethodInPublicClass() throws Exception {\n\t\t\tClass<?> originalType = ArrayList.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"size\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\t// Should not find the interface method in List.\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(originalType);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInJavaLangObjectDeclaredInNonPublicClass() throws Exception {\n\t\t\tList<String> unmodifiableList = Collections.unmodifiableList(Arrays.asList(\"foo\", \"bar\"));\n\t\t\tClass<?> targetClass = unmodifiableList.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"toString\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Object.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"toString\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInJavaTimeZoneIdDeclaredInNonPublicSubclass() throws Exception {\n\t\t\t// Returns a package-private java.time.ZoneRegion.\n\t\t\tZoneId zoneId = ZoneId.of(\"CET\");\n\t\t\tClass<?> targetClass = zoneId.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getDeclaredMethod(\"getId\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(ZoneId.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getId\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicInterfaceMethodDeclaredInNonPublicClassWithLateBindingOfClassMethodToSubclassDeclaredInterface() throws Exception {\n\t\t\tHashMap<String, String> hashMap = new HashMap<>();\n\t\t\t// Returns a package-private java.util.HashMap.KeyIterator which extends java.util.HashMap.HashIterator\n\t\t\t// which declares hasNext(), even though HashIterator does not implement Iterator. Rather, KeyIterator\n\t\t\t// implements HashIterator.\n\t\t\tIterator<String> iterator = hashMap.keySet().iterator();\n\t\t\tClass<?> targetClass = iterator.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"hasNext\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, targetClass);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Iterator.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"hasNext\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPublicInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getText\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicInterface.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getText\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPrivateInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getMessage\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\t// Should not find the interface method in PrivateInterface.\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getMessage\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPublicSuperclass() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getNumber\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getNumber\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid packagePrivateSubclassOverridesMethodInPublicInterface() throws Exception {\n\t\t\tList<String> unmodifiableList = Collections.unmodifiableList(Arrays.asList(\"foo\", \"bar\"));\n\t\t\tClass<?> targetClass = unmodifiableList.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"contains\", Object.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Collection.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"contains\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(Object.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesMethodInPrivateInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getMethod(\"greet\", String.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"greet\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(String.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesMethodInPublicSuperclass() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getMethod(\"process\", int.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"process\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(int.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t}\n\n\n\tprivate static void assertInterfaceMethod(Method method) {\n\t\tassertThat(method.getDeclaringClass()).as(\"%s must be an interface method\", method).isInterface();\n\t}\n\n\tprivate static void assertNotInterfaceMethod(Method method) {\n\t\tassertThat(method.getDeclaringClass()).as(\"%s must not be an interface method\", method).isNotInterface();\n\t}\n\n\tprivate static void assertPubliclyAccessible(Method method) {\n\t\tassertPublic(method);\n\t\tassertPublic(method.getDeclaringClass());\n\t}\n\n\tprivate static void assertNotPubliclyAccessible(Method method) {\n\t\tassertThat(!isPublic(method) || !isPublic(method.getDeclaringClass()))\n\t\t\t\t.as(\"%s must not be publicly accessible\", method)\n\t\t\t\t.isTrue();\n\t}\n\n\tprivate static void assertPublic(Member member) {\n\t\tassertThat(isPublic(member)).as(\"%s must be public\", member).isTrue();\n\t}\n\n\tprivate static void assertPublic(Class<?> clazz) {\n\t\tassertThat(isPublic(clazz)).as(\"%s must be public\", clazz).isTrue();\n\t}\n\n\tprivate static void assertNotPublic(Member member) {\n\t\tassertThat(!isPublic(member)).as(\"%s must be not be public\", member).isTrue();\n\t}\n\n\tprivate static void assertNotPublic(Class<?> clazz) {\n\t\tassertThat(!isPublic(clazz)).as(\"%s must be not be public\", clazz).isTrue();\n\t}\n\n\tprivate static boolean isPublic(Class<?> clazz) {\n\t\treturn Modifier.isPublic(clazz.getModifiers());\n\t}\n\n\tprivate static boolean isPublic(Member member) {\n\t\treturn Modifier.isPublic(member.getModifiers());\n\t}\n\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueSource(classes = { Boolean.class, Character.class, Byte.class, Short.class,\n\t\tInteger.class, Long.class, Float.class, Double.class, Void.class })\n\t@interface WrapperTypes {\n\t}\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueSource(classes = { boolean.class, char.class, byte.class, short.class,\n\t\tint.class, long.class, float.class, double.class, void.class })\n\t@interface PrimitiveTypes {\n\t}\n\n\tpublic static class NestedClass {\n\n\t\tstatic boolean noArgCalled;\n\t\tstatic boolean argCalled;\n\t\tstatic boolean overloadedCalled;\n\n\t\tpublic static void staticMethod() {\n\t\t\tnoArgCalled = true;\n\t\t}\n\n\t\tpublic static void staticMethod(String anArg) {\n\t\t\toverloadedCalled = true;\n\t\t}\n\n\t\tpublic static void argStaticMethod(String anArg) {\n\t\t\targCalled = true;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class OverloadedMethodsClass {\n\n\t\tpublic void print(String messages) {\n\t\t\t/* no-op */\n\t\t}\n\n\t\tpublic void print(String[] messages) {\n\t\t\t/* no-op */\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class SubOverloadedMethodsClass extends OverloadedMethodsClass {\n\n\t\tpublic void print(String header, String[] messages) {\n\t\t\t/* no-op */\n\t\t}\n\n\t\tvoid print(String header, String[] messages, String footer) {\n\t\t\t/* no-op */\n\t\t}\n\t}\n\n\tprivate static void assertIsLambda(Supplier<String> supplier) {\n\t\tassertThat(ClassUtils.isLambdaClass(supplier.getClass())).isTrue();\n\t}\n\n\tprivate static void assertIsNotLambda(Supplier<String> supplier) {\n\t\tassertThat(ClassUtils.isLambdaClass(supplier.getClass())).isFalse();\n\t}\n\n\tprivate static final Supplier<String> staticLambdaExpression = () -> \"static lambda expression\";\n\n\tprivate final Supplier<String> instanceLambdaExpression = () -> \"instance lambda expressions\";\n\n\tprivate static String staticStringFactory() {\n\t\treturn \"static string factory\";\n\t}\n\n\tprivate String instanceStringFactory() {\n\t\treturn \"instance string factory\";\n\t}\n\n\tprivate static class EnigmaSupplier implements Supplier<String> {\n\t\t@Override\n\t\tpublic String get() {\n\t\t\treturn \"enigma\";\n\t\t}\n\t}\n\n\tprivate static class Fake$$LambdaSupplier implements Supplier<String> {\n\t\t@Override\n\t\tpublic String get() {\n\t\t\treturn \"fake lambda\";\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate interface MethodsInterface {\n\n\t\tdefault void defaultPrint() {\n\t\t}\n\n\t\tvoid print(String messages);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate class MethodsInterfaceImplementation implements MethodsInterface {\n\n\t\t@Override\n\t\tpublic void print(String message) {\n\t\t}\n\n\t\tprotected void protectedPrint() {\n\t\t}\n\n\t\tvoid packageAccessiblePrint() {\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate class SubMethodsInterfaceImplementation extends MethodsInterfaceImplementation {\n\n\t\t@Override\n\t\tprotected void protectedPrint() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void packageAccessiblePrint() {\n\t\t}\n\t}\n\n\tprivate interface PrivateInterface {\n\n\t\tString getMessage();\n\n\t\tString greet(String name);\n\t}\n\n\tprivate static class PrivateSubclass extends PublicSuperclass implements PublicInterface, PrivateInterface {\n\n\t\t@Override\n\t\tpublic int getNumber() {\n\t\t\treturn 2;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getMessage() {\n\t\t\treturn \"hello\";\n\t\t}\n\n\t\t@Override\n\t\tpublic String greet(String name) {\n\t\t\treturn \"Hello, \" + name;\n\t\t}\n\n\t\t@Override\n\t\tpublic int process(int num) {\n\t\t\treturn num * 2;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getText() {\n\t\t\treturn \"enigma\";\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.OverloadedMethodsClass#print(String)",
    "headType": "method",
    "relation": "provide",
    "tail": "public void print(String messages) {\r\n    /* no-op */\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.OverloadedMethodsClass",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.OverloadedMethodsClass#print(String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.OverloadedMethodsClass#print(String[])",
    "headType": "method",
    "relation": "provide",
    "tail": "public void print(String[] messages) {\r\n    /* no-op */\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.OverloadedMethodsClass",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.OverloadedMethodsClass#print(String[])",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.SubOverloadedMethodsClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.SubOverloadedMethodsClass",
    "headType": "class",
    "relation": "use",
    "tail": "@SuppressWarnings",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.SubOverloadedMethodsClass",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.io.Externalizable;\nimport java.io.Serializable;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Proxy;\nimport java.time.ZoneId;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.function.Supplier;\n\nimport a.ClassHavingNestedClass;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.TestInfo;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\nimport org.junit.jupiter.params.provider.ValueSource;\n\nimport org.springframework.tests.sample.objects.DerivedTestObject;\nimport org.springframework.tests.sample.objects.ITestInterface;\nimport org.springframework.tests.sample.objects.ITestObject;\nimport org.springframework.tests.sample.objects.TestObject;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Tests for {@link ClassUtils}.\n *\n * @author Colin Sampaleanu\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Rick Evans\n * @author Sam Brannen\n */\nclass ClassUtilsTests {\n\n\tprivate final ClassLoader classLoader = getClass().getClassLoader();\n\n\n\t@Test\n\tvoid isPresent() {\n\t\tassertThat(ClassUtils.isPresent(\"java.lang.String\", classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isPresent(\"java.lang.MySpecialString\", classLoader)).isFalse();\n\t}\n\n\t@Test\n\tvoid forName() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"java.lang.String\", classLoader)).isEqualTo(String.class);\n\t\tassertThat(ClassUtils.forName(\"java.lang.String[]\", classLoader)).isEqualTo(String[].class);\n\t\tassertThat(ClassUtils.forName(String[].class.getName(), classLoader)).isEqualTo(String[].class);\n\t\tassertThat(ClassUtils.forName(String[][].class.getName(), classLoader)).isEqualTo(String[][].class);\n\t\tassertThat(ClassUtils.forName(String[][][].class.getName(), classLoader)).isEqualTo(String[][][].class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject\", classLoader)).isEqualTo(TestObject.class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject[]\", classLoader)).isEqualTo(TestObject[].class);\n\t\tassertThat(ClassUtils.forName(TestObject[].class.getName(), classLoader)).isEqualTo(TestObject[].class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject[][]\", classLoader)).isEqualTo(TestObject[][].class);\n\t\tassertThat(ClassUtils.forName(TestObject[][].class.getName(), classLoader)).isEqualTo(TestObject[][].class);\n\t\tassertThat(ClassUtils.forName(\"[[[S\", classLoader)).isEqualTo(short[][][].class);\n\t}\n\n\t@Test\n\tvoid forNameWithNestedType() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"org.springframework.util.ClassUtilsTests$NestedClass\", classLoader)).isEqualTo(NestedClass.class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.util.ClassUtilsTests.NestedClass\", classLoader)).isEqualTo(NestedClass.class);\n\n\t\t// Precondition: package name must have length == 1.\n\t\tassertThat(ClassHavingNestedClass.class.getPackageName().length()).isEqualTo(1);\n\t\tassertThat(ClassUtils.forName(\"a.ClassHavingNestedClass$NestedClass\", classLoader)).isEqualTo(ClassHavingNestedClass.NestedClass.class);\n\t\tassertThat(ClassUtils.forName(\"a.ClassHavingNestedClass.NestedClass\", classLoader)).isEqualTo(ClassHavingNestedClass.NestedClass.class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveClasses() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"boolean\", classLoader)).isEqualTo(boolean.class);\n\t\tassertThat(ClassUtils.forName(\"byte\", classLoader)).isEqualTo(byte.class);\n\t\tassertThat(ClassUtils.forName(\"char\", classLoader)).isEqualTo(char.class);\n\t\tassertThat(ClassUtils.forName(\"short\", classLoader)).isEqualTo(short.class);\n\t\tassertThat(ClassUtils.forName(\"int\", classLoader)).isEqualTo(int.class);\n\t\tassertThat(ClassUtils.forName(\"long\", classLoader)).isEqualTo(long.class);\n\t\tassertThat(ClassUtils.forName(\"float\", classLoader)).isEqualTo(float.class);\n\t\tassertThat(ClassUtils.forName(\"double\", classLoader)).isEqualTo(double.class);\n\t\tassertThat(ClassUtils.forName(\"void\", classLoader)).isEqualTo(void.class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveArrays() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"boolean[]\", classLoader)).isEqualTo(boolean[].class);\n\t\tassertThat(ClassUtils.forName(\"byte[]\", classLoader)).isEqualTo(byte[].class);\n\t\tassertThat(ClassUtils.forName(\"char[]\", classLoader)).isEqualTo(char[].class);\n\t\tassertThat(ClassUtils.forName(\"short[]\", classLoader)).isEqualTo(short[].class);\n\t\tassertThat(ClassUtils.forName(\"int[]\", classLoader)).isEqualTo(int[].class);\n\t\tassertThat(ClassUtils.forName(\"long[]\", classLoader)).isEqualTo(long[].class);\n\t\tassertThat(ClassUtils.forName(\"float[]\", classLoader)).isEqualTo(float[].class);\n\t\tassertThat(ClassUtils.forName(\"double[]\", classLoader)).isEqualTo(double[].class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveArraysInternalName() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(boolean[].class.getName(), classLoader)).isEqualTo(boolean[].class);\n\t\tassertThat(ClassUtils.forName(byte[].class.getName(), classLoader)).isEqualTo(byte[].class);\n\t\tassertThat(ClassUtils.forName(char[].class.getName(), classLoader)).isEqualTo(char[].class);\n\t\tassertThat(ClassUtils.forName(short[].class.getName(), classLoader)).isEqualTo(short[].class);\n\t\tassertThat(ClassUtils.forName(int[].class.getName(), classLoader)).isEqualTo(int[].class);\n\t\tassertThat(ClassUtils.forName(long[].class.getName(), classLoader)).isEqualTo(long[].class);\n\t\tassertThat(ClassUtils.forName(float[].class.getName(), classLoader)).isEqualTo(float[].class);\n\t\tassertThat(ClassUtils.forName(double[].class.getName(), classLoader)).isEqualTo(double[].class);\n\t}\n\n\t@Test\n\tvoid isCacheSafe() {\n\t\tClassLoader childLoader1 = new ClassLoader(classLoader) {};\n\t\tClassLoader childLoader2 = new ClassLoader(classLoader) {};\n\t\tClassLoader childLoader3 = new ClassLoader(classLoader) {\n\t\t\t@Override\n\t\t\tpublic Class<?> loadClass(String name) throws ClassNotFoundException {\n\t\t\t\treturn childLoader1.loadClass(name);\n\t\t\t}\n\t\t};\n\t\tClass<?> composite = ClassUtils.createCompositeInterface(\n\t\t\t\tnew Class<?>[] {Serializable.class, Externalizable.class}, childLoader1);\n\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, null)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader2)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader3)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, null)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader2)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader3)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, null)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, classLoader)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader2)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader3)).isTrue();\n\t}\n\n\t@ParameterizedTest(name = \"''{0}'' -> {1}\")\n\t@CsvSource(textBlock = \"\"\"\n\t\tboolean, boolean\n\t\tbyte, byte\n\t\tchar, char\n\t\tshort, short\n\t\tint, int\n\t\tlong, long\n\t\tfloat, float\n\t\tdouble, double\n\t\t[Z, boolean[]\n\t\t[B, byte[]\n\t\t[C, char[]\n\t\t[S, short[]\n\t\t[I, int[]\n\t\t[J, long[]\n\t\t[F, float[]\n\t\t[D, double[]\n\t\t\"\"\")\n\tvoid resolvePrimitiveClassName(String input, Class<?> output) {\n\t\tassertThat(ClassUtils.resolvePrimitiveClassName(input)).isEqualTo(output);\n\t}\n\n\t@Test\n\tvoid getShortName() {\n\t\tString className = ClassUtils.getShortName(getClass());\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"ClassUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getShortNameForObjectArrayClass() {\n\t\tString className = ClassUtils.getShortName(Object[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"Object[]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForMultiDimensionalObjectArrayClass() {\n\t\tString className = ClassUtils.getShortName(Object[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"Object[][]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getShortName(byte[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForMultiDimensionalPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getShortName(byte[][][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[][][]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForNestedClass() {\n\t\tString className = ClassUtils.getShortName(NestedClass.class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"ClassUtilsTests.NestedClass\");\n\t}\n\n\t@Test\n\tvoid getShortNameAsProperty() {\n\t\tString shortName = ClassUtils.getShortNameAsProperty(this.getClass());\n\t\tassertThat(shortName).as(\"Class name did not match\").isEqualTo(\"classUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getClassFileName() {\n\t\tassertThat(ClassUtils.getClassFileName(String.class)).isEqualTo(\"String.class\");\n\t\tassertThat(ClassUtils.getClassFileName(getClass())).isEqualTo(\"ClassUtilsTests.class\");\n\t}\n\n\t@Test\n\tvoid getPackageName() {\n\t\tassertThat(ClassUtils.getPackageName(String.class)).isEqualTo(\"java.lang\");\n\t\tassertThat(ClassUtils.getPackageName(getClass())).isEqualTo(getClass().getPackage().getName());\n\t}\n\n\t@Test\n\tvoid getQualifiedName() {\n\t\tString className = ClassUtils.getQualifiedName(getClass());\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"org.springframework.util.ClassUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForObjectArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(Object[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"java.lang.Object[]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForMultiDimensionalObjectArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(Object[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"java.lang.Object[][]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(byte[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForMultiDimensionalPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(byte[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[][]\");\n\t}\n\n\t@Test\n\tvoid hasMethod() {\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"size\")).isTrue();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"remove\", Object.class)).isTrue();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"remove\")).isFalse();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"someOtherMethod\")).isFalse();\n\t}\n\n\t@Test\n\tvoid getMethodIfAvailable() {\n\t\tMethod method = ClassUtils.getMethodIfAvailable(Collection.class, \"size\");\n\t\tassertThat(method).isNotNull();\n\t\tassertThat(method.getName()).isEqualTo(\"size\");\n\n\t\tmethod = ClassUtils.getMethodIfAvailable(Collection.class, \"remove\", Object.class);\n\t\tassertThat(method).isNotNull();\n\t\tassertThat(method.getName()).isEqualTo(\"remove\");\n\n\t\tassertThat(ClassUtils.getMethodIfAvailable(Collection.class, \"remove\")).isNull();\n\t\tassertThat(ClassUtils.getMethodIfAvailable(Collection.class, \"someOtherMethod\")).isNull();\n\t}\n\n\t@Test\n\tvoid getMethodCountForName() {\n\t\tassertThat(ClassUtils.getMethodCountForName(OverloadedMethodsClass.class, \"print\")).as(\"Verifying number of overloaded 'print' methods for OverloadedMethodsClass.\").isEqualTo(2);\n\t\tassertThat(ClassUtils.getMethodCountForName(SubOverloadedMethodsClass.class, \"print\")).as(\"Verifying number of overloaded 'print' methods for SubOverloadedMethodsClass.\").isEqualTo(4);\n\t}\n\n\t@Test\n\tvoid countOverloadedMethods() {\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"foobar\")).isFalse();\n\t\t// no args\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"hashCode\")).isTrue();\n\t\t// matches although it takes an arg\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"setAge\")).isTrue();\n\t}\n\n\t@Test\n\tvoid isAssignable() {\n\t\tassertThat(ClassUtils.isAssignable(Object.class, Object.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(String.class, String.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Object.class, String.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Object.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Number.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Number.class, int.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, int.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(int.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(String.class, Object.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, Number.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, double.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(double.class, Integer.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid classPackageAsResourcePath() {\n\t\tString result = ClassUtils.classPackageAsResourcePath(Proxy.class);\n\t\tassertThat(result).isEqualTo(\"java/lang/reflect\");\n\t}\n\n\t@Test\n\tvoid addResourcePathToPackagePath() {\n\t\tString result = \"java/lang/reflect/xyzabc.xml\";\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"xyzabc.xml\")).isEqualTo(result);\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"/xyzabc.xml\")).isEqualTo(result);\n\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"a/b/c/d.xml\")).isEqualTo(\"java/lang/reflect/a/b/c/d.xml\");\n\t}\n\n\t@Test\n\tvoid getAllInterfaces() {\n\t\tDerivedTestObject testBean = new DerivedTestObject();\n\t\tList<Class<?>> ifcs = Arrays.asList(ClassUtils.getAllInterfaces(testBean));\n\t\tassertThat(ifcs).as(\"Correct number of interfaces\").hasSize(4);\n\t\tassertThat(ifcs.contains(Serializable.class)).as(\"Contains Serializable\").isTrue();\n\t\tassertThat(ifcs.contains(ITestObject.class)).as(\"Contains ITestBean\").isTrue();\n\t\tassertThat(ifcs.contains(ITestInterface.class)).as(\"Contains IOther\").isTrue();\n\t}\n\n\t@Test\n\tvoid classNamesToString() {\n\t\tList<Class<?>> ifcs = new ArrayList<>();\n\t\tifcs.add(Serializable.class);\n\t\tifcs.add(Runnable.class);\n\t\tassertThat(ifcs.toString()).isEqualTo(\"[interface java.io.Serializable, interface java.lang.Runnable]\");\n\t\tassertThat(ClassUtils.classNamesToString(ifcs)).isEqualTo(\"[java.io.Serializable, java.lang.Runnable]\");\n\n\t\tList<Class<?>> classes = new ArrayList<>();\n\t\tclasses.add(ArrayList.class);\n\t\tclasses.add(Integer.class);\n\t\tassertThat(classes.toString()).isEqualTo(\"[class java.util.ArrayList, class java.lang.Integer]\");\n\t\tassertThat(ClassUtils.classNamesToString(classes)).isEqualTo(\"[java.util.ArrayList, java.lang.Integer]\");\n\n\t\tassertThat(Collections.singletonList(List.class).toString()).isEqualTo(\"[interface java.util.List]\");\n\t\tassertThat(ClassUtils.classNamesToString(List.class)).isEqualTo(\"[java.util.List]\");\n\n\t\tassertThat(Collections.EMPTY_LIST.toString()).isEqualTo(\"[]\");\n\t\tassertThat(ClassUtils.classNamesToString(Collections.emptyList())).isEqualTo(\"[]\");\n\t}\n\n\t@Test\n\tvoid determineCommonAncestor() {\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Number.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Number.class, Integer.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Number.class, null)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(null, Integer.class)).isEqualTo(Integer.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Integer.class)).isEqualTo(Integer.class);\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Float.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Float.class, Integer.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, String.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(String.class, Integer.class)).isNull();\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Collection.class)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Collection.class, List.class)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Collection.class, null)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(null, List.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, List.class)).isEqualTo(List.class);\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Set.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(Set.class, List.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Runnable.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(Runnable.class, List.class)).isNull();\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, ArrayList.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(ArrayList.class, List.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, String.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(String.class, List.class)).isNull();\n\t}\n\n\t@Test\n\tvoid getMostSpecificMethod() throws NoSuchMethodException {\n\t\tMethod defaultPrintMethod = ClassUtils.getMethod(MethodsInterface.class, \"defaultPrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(defaultPrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(defaultPrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(defaultPrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(defaultPrintMethod);\n\n\t\tMethod printMethod = ClassUtils.getMethod(MethodsInterface.class, \"print\", String.class);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isNotEqualTo(printMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(MethodsInterfaceImplementation.class, \"print\", String.class));\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(MethodsInterfaceImplementation.class, \"print\", String.class));\n\n\t\tMethod protectedPrintMethod = MethodsInterfaceImplementation.class.getDeclaredMethod(\"protectedPrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(protectedPrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(protectedPrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(protectedPrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(SubMethodsInterfaceImplementation.class.getDeclaredMethod(\"protectedPrint\"));\n\n\t\tMethod packageAccessiblePrintMethod = MethodsInterfaceImplementation.class.getDeclaredMethod(\"packageAccessiblePrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(packageAccessiblePrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(packageAccessiblePrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(packageAccessiblePrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(SubMethodsInterfaceImplementation.class, \"packageAccessiblePrint\"));\n\t}\n\n\t@ParameterizedTest\n\t@WrapperTypes\n\tvoid isPrimitiveWrapper(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveWrapper(type)).isTrue();\n\t}\n\n\t@ParameterizedTest\n\t@PrimitiveTypes\n\tvoid isPrimitiveOrWrapperWithPrimitive(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(type)).isTrue();\n\t}\n\n\t@ParameterizedTest\n\t@WrapperTypes\n\tvoid isPrimitiveOrWrapperWithWrapper(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(type)).isTrue();\n\t}\n\n\t@Test\n\tvoid isLambda() {\n\t\tassertIsLambda(ClassUtilsTests.staticLambdaExpression);\n\t\tassertIsLambda(ClassUtilsTests::staticStringFactory);\n\n\t\tassertIsLambda(this.instanceLambdaExpression);\n\t\tassertIsLambda(this::instanceStringFactory);\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"Convert2Lambda\")\n\tvoid isNotLambda() {\n\t\tassertIsNotLambda(new EnigmaSupplier());\n\n\t\tassertIsNotLambda(new Supplier<>() {\n\t\t\t@Override\n\t\t\tpublic String get() {\n\t\t\t\treturn \"anonymous inner class\";\n\t\t\t}\n\t\t});\n\n\t\tassertIsNotLambda(new Fake$$LambdaSupplier());\n\t}\n\n\n\t@Nested\n\tclass GetStaticMethodTests {\n\n\t\t@BeforeEach\n\t\tvoid clearStatics() {\n\t\t\tNestedClass.noArgCalled = false;\n\t\t\tNestedClass.argCalled = false;\n\t\t\tNestedClass.overloadedCalled = false;\n\t\t}\n\n\t\t@Test\n\t\tvoid noArgsStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"staticMethod\");\n\t\t\tmethod.invoke(null, (Object[]) null);\n\t\t\tassertThat(NestedClass.noArgCalled).as(\"no argument method was not invoked.\").isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid argsStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"argStaticMethod\", String.class);\n\t\t\tmethod.invoke(null, \"test\");\n\t\t\tassertThat(NestedClass.argCalled).as(\"argument method was not invoked.\").isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid overloadedStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"staticMethod\", String.class);\n\t\t\tmethod.invoke(null, \"test\");\n\t\t\tassertThat(NestedClass.overloadedCalled).as(\"argument method was not invoked.\").isTrue();\n\t\t}\n\n\t}\n\n\n\t@Nested  // gh-33216\n\tclass GetInterfaceMethodTests {\n\n\t\t@Test\n\t\tvoid publicMethodInPublicClass() throws Exception {\n\t\t\tClass<?> originalType = String.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"getBytes\");\n\n\t\t\tMethod interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(interfaceMethod.getDeclaringClass()).isEqualTo(originalType);\n\t\t\tassertThat(interfaceMethod).isSameAs(originalMethod);\n\t\t\tassertNotInterfaceMethod(interfaceMethod);\n\t\t\tassertPubliclyAccessible(interfaceMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInNonPublicInterface() throws Exception {\n\t\t\tClass<?> originalType = PrivateInterface.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"getMessage\");\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertPublic(originalMethod);\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(interfaceMethod).isSameAs(originalMethod);\n\t\t\tassertInterfaceMethod(interfaceMethod);\n\t\t\tassertNotPubliclyAccessible(interfaceMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicInterfaceMethodInPublicClass() throws Exception {\n\t\t\tClass<?> originalType = ArrayList.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"size\");\n\n\t\t\tMethod interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(interfaceMethod.getDeclaringClass()).isEqualTo(List.class);\n\t\t\tassertThat(interfaceMethod.getName()).isEqualTo(\"size\");\n\t\t\tassertThat(interfaceMethod.getParameterTypes()).isEmpty();\n\t\t\tassertInterfaceMethod(interfaceMethod);\n\t\t\tassertPubliclyAccessible(interfaceMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicInterfaceMethodDeclaredInNonPublicClassWithLateBindingOfClassMethodToSubclassDeclaredInterface() throws Exception {\n\t\t\tHashMap<String, String> hashMap = new HashMap<>();\n\t\t\t// Returns a package-private java.util.HashMap.KeyIterator which extends java.util.HashMap.HashIterator\n\t\t\t// which declares hasNext(), even though HashIterator does not implement Iterator. Rather, KeyIterator\n\t\t\t// implements HashIterator.\n\t\t\tIterator<String> iterator = hashMap.keySet().iterator();\n\t\t\tClass<?> targetClass = iterator.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"hasNext\");\n\n\t\t\tMethod interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, targetClass);\n\t\t\tassertThat(interfaceMethod.getDeclaringClass()).isEqualTo(Iterator.class);\n\t\t\tassertThat(interfaceMethod.getName()).isEqualTo(\"hasNext\");\n\t\t\tassertThat(interfaceMethod.getParameterTypes()).isEmpty();\n\t\t\tassertInterfaceMethod(interfaceMethod);\n\t\t\tassertPubliclyAccessible(interfaceMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPublicInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getText\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(interfaceMethod.getDeclaringClass()).isEqualTo(PublicInterface.class);\n\t\t\tassertThat(interfaceMethod.getName()).isEqualTo(\"getText\");\n\t\t\tassertThat(interfaceMethod.getParameterTypes()).isEmpty();\n\t\t\tassertInterfaceMethod(interfaceMethod);\n\t\t\tassertPubliclyAccessible(interfaceMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPrivateInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getMessage\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(interfaceMethod.getDeclaringClass()).isEqualTo(PrivateInterface.class);\n\t\t\tassertThat(interfaceMethod.getName()).isEqualTo(\"getMessage\");\n\t\t\tassertThat(interfaceMethod.getParameterTypes()).isEmpty();\n\t\t\tassertInterfaceMethod(interfaceMethod);\n\t\t\tassertNotPubliclyAccessible(interfaceMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid packagePrivateSubclassOverridesMethodInPublicInterface() throws Exception {\n\t\t\tList<String> unmodifiableList = Collections.unmodifiableList(Arrays.asList(\"foo\", \"bar\"));\n\t\t\tClass<?> targetClass = unmodifiableList.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"contains\", Object.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(interfaceMethod.getDeclaringClass()).isEqualTo(Collection.class);\n\t\t\tassertThat(interfaceMethod.getName()).isEqualTo(\"contains\");\n\t\t\tassertThat(interfaceMethod.getParameterTypes()).containsExactly(Object.class);\n\t\t\tassertInterfaceMethod(interfaceMethod);\n\t\t\tassertPubliclyAccessible(interfaceMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesMethodInPrivateInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getMethod(\"greet\", String.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(interfaceMethod.getDeclaringClass()).isEqualTo(PrivateInterface.class);\n\t\t\tassertThat(interfaceMethod.getName()).isEqualTo(\"greet\");\n\t\t\tassertThat(interfaceMethod.getParameterTypes()).containsExactly(String.class);\n\t\t\tassertInterfaceMethod(interfaceMethod);\n\t\t\tassertNotPubliclyAccessible(interfaceMethod);\n\t\t}\n\n\t}\n\n\n\t@Nested  // gh-33216\n\tclass GetPubliclyAccessibleMethodTests {\n\n\t\t@Test\n\t\tvoid nonPublicMethod(TestInfo testInfo) {\n\t\t\tMethod originalMethod = testInfo.getTestMethod().get();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(originalMethod);\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertNotPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\t// This method is intentionally public.\n\t\tpublic void publicMethodInNonPublicClass(TestInfo testInfo) {\n\t\t\tMethod originalMethod = testInfo.getTestMethod().get();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertPublic(originalMethod);\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertNotPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInNonPublicInterface() throws Exception {\n\t\t\tClass<?> originalType = PrivateInterface.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"getMessage\");\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertPublic(originalMethod);\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertNotPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInPublicClass() throws Exception {\n\t\t\tClass<?> originalType = String.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"toString\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(originalType);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicInterfaceMethodInPublicClass() throws Exception {\n\t\t\tClass<?> originalType = ArrayList.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"size\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\t// Should not find the interface method in List.\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(originalType);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInJavaLangObjectDeclaredInNonPublicClass() throws Exception {\n\t\t\tList<String> unmodifiableList = Collections.unmodifiableList(Arrays.asList(\"foo\", \"bar\"));\n\t\t\tClass<?> targetClass = unmodifiableList.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"toString\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Object.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"toString\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInJavaTimeZoneIdDeclaredInNonPublicSubclass() throws Exception {\n\t\t\t// Returns a package-private java.time.ZoneRegion.\n\t\t\tZoneId zoneId = ZoneId.of(\"CET\");\n\t\t\tClass<?> targetClass = zoneId.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getDeclaredMethod(\"getId\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(ZoneId.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getId\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicInterfaceMethodDeclaredInNonPublicClassWithLateBindingOfClassMethodToSubclassDeclaredInterface() throws Exception {\n\t\t\tHashMap<String, String> hashMap = new HashMap<>();\n\t\t\t// Returns a package-private java.util.HashMap.KeyIterator which extends java.util.HashMap.HashIterator\n\t\t\t// which declares hasNext(), even though HashIterator does not implement Iterator. Rather, KeyIterator\n\t\t\t// implements HashIterator.\n\t\t\tIterator<String> iterator = hashMap.keySet().iterator();\n\t\t\tClass<?> targetClass = iterator.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"hasNext\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, targetClass);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Iterator.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"hasNext\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPublicInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getText\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicInterface.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getText\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPrivateInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getMessage\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\t// Should not find the interface method in PrivateInterface.\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getMessage\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPublicSuperclass() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getNumber\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getNumber\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid packagePrivateSubclassOverridesMethodInPublicInterface() throws Exception {\n\t\t\tList<String> unmodifiableList = Collections.unmodifiableList(Arrays.asList(\"foo\", \"bar\"));\n\t\t\tClass<?> targetClass = unmodifiableList.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"contains\", Object.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Collection.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"contains\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(Object.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesMethodInPrivateInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getMethod(\"greet\", String.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"greet\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(String.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesMethodInPublicSuperclass() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getMethod(\"process\", int.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"process\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(int.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t}\n\n\n\tprivate static void assertInterfaceMethod(Method method) {\n\t\tassertThat(method.getDeclaringClass()).as(\"%s must be an interface method\", method).isInterface();\n\t}\n\n\tprivate static void assertNotInterfaceMethod(Method method) {\n\t\tassertThat(method.getDeclaringClass()).as(\"%s must not be an interface method\", method).isNotInterface();\n\t}\n\n\tprivate static void assertPubliclyAccessible(Method method) {\n\t\tassertPublic(method);\n\t\tassertPublic(method.getDeclaringClass());\n\t}\n\n\tprivate static void assertNotPubliclyAccessible(Method method) {\n\t\tassertThat(!isPublic(method) || !isPublic(method.getDeclaringClass()))\n\t\t\t\t.as(\"%s must not be publicly accessible\", method)\n\t\t\t\t.isTrue();\n\t}\n\n\tprivate static void assertPublic(Member member) {\n\t\tassertThat(isPublic(member)).as(\"%s must be public\", member).isTrue();\n\t}\n\n\tprivate static void assertPublic(Class<?> clazz) {\n\t\tassertThat(isPublic(clazz)).as(\"%s must be public\", clazz).isTrue();\n\t}\n\n\tprivate static void assertNotPublic(Member member) {\n\t\tassertThat(!isPublic(member)).as(\"%s must be not be public\", member).isTrue();\n\t}\n\n\tprivate static void assertNotPublic(Class<?> clazz) {\n\t\tassertThat(!isPublic(clazz)).as(\"%s must be not be public\", clazz).isTrue();\n\t}\n\n\tprivate static boolean isPublic(Class<?> clazz) {\n\t\treturn Modifier.isPublic(clazz.getModifiers());\n\t}\n\n\tprivate static boolean isPublic(Member member) {\n\t\treturn Modifier.isPublic(member.getModifiers());\n\t}\n\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueSource(classes = { Boolean.class, Character.class, Byte.class, Short.class,\n\t\tInteger.class, Long.class, Float.class, Double.class, Void.class })\n\t@interface WrapperTypes {\n\t}\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueSource(classes = { boolean.class, char.class, byte.class, short.class,\n\t\tint.class, long.class, float.class, double.class, void.class })\n\t@interface PrimitiveTypes {\n\t}\n\n\tpublic static class NestedClass {\n\n\t\tstatic boolean noArgCalled;\n\t\tstatic boolean argCalled;\n\t\tstatic boolean overloadedCalled;\n\n\t\tpublic static void staticMethod() {\n\t\t\tnoArgCalled = true;\n\t\t}\n\n\t\tpublic static void staticMethod(String anArg) {\n\t\t\toverloadedCalled = true;\n\t\t}\n\n\t\tpublic static void argStaticMethod(String anArg) {\n\t\t\targCalled = true;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class OverloadedMethodsClass {\n\n\t\tpublic void print(String messages) {\n\t\t\t/* no-op */\n\t\t}\n\n\t\tpublic void print(String[] messages) {\n\t\t\t/* no-op */\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class SubOverloadedMethodsClass extends OverloadedMethodsClass {\n\n\t\tpublic void print(String header, String[] messages) {\n\t\t\t/* no-op */\n\t\t}\n\n\t\tvoid print(String header, String[] messages, String footer) {\n\t\t\t/* no-op */\n\t\t}\n\t}\n\n\tprivate static void assertIsLambda(Supplier<String> supplier) {\n\t\tassertThat(ClassUtils.isLambdaClass(supplier.getClass())).isTrue();\n\t}\n\n\tprivate static void assertIsNotLambda(Supplier<String> supplier) {\n\t\tassertThat(ClassUtils.isLambdaClass(supplier.getClass())).isFalse();\n\t}\n\n\tprivate static final Supplier<String> staticLambdaExpression = () -> \"static lambda expression\";\n\n\tprivate final Supplier<String> instanceLambdaExpression = () -> \"instance lambda expressions\";\n\n\tprivate static String staticStringFactory() {\n\t\treturn \"static string factory\";\n\t}\n\n\tprivate String instanceStringFactory() {\n\t\treturn \"instance string factory\";\n\t}\n\n\tprivate static class EnigmaSupplier implements Supplier<String> {\n\t\t@Override\n\t\tpublic String get() {\n\t\t\treturn \"enigma\";\n\t\t}\n\t}\n\n\tprivate static class Fake$$LambdaSupplier implements Supplier<String> {\n\t\t@Override\n\t\tpublic String get() {\n\t\t\treturn \"fake lambda\";\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate interface MethodsInterface {\n\n\t\tdefault void defaultPrint() {\n\t\t}\n\n\t\tvoid print(String messages);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate class MethodsInterfaceImplementation implements MethodsInterface {\n\n\t\t@Override\n\t\tpublic void print(String message) {\n\t\t}\n\n\t\tprotected void protectedPrint() {\n\t\t}\n\n\t\tvoid packageAccessiblePrint() {\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate class SubMethodsInterfaceImplementation extends MethodsInterfaceImplementation {\n\n\t\t@Override\n\t\tprotected void protectedPrint() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void packageAccessiblePrint() {\n\t\t}\n\t}\n\n\tprivate interface PrivateInterface {\n\n\t\tString getMessage();\n\n\t\tString greet(String name);\n\t}\n\n\tprivate static class PrivateSubclass extends PublicSuperclass implements PublicInterface, PrivateInterface {\n\n\t\t@Override\n\t\tpublic int getNumber() {\n\t\t\treturn 2;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getMessage() {\n\t\t\treturn \"hello\";\n\t\t}\n\n\t\t@Override\n\t\tpublic String greet(String name) {\n\t\t\treturn \"Hello, \" + name;\n\t\t}\n\n\t\t@Override\n\t\tpublic int process(int num) {\n\t\t\treturn num * 2;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getText() {\n\t\t\treturn \"enigma\";\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.SubOverloadedMethodsClass#print(String,String[])",
    "headType": "method",
    "relation": "provide",
    "tail": "public void print(String header, String[] messages) {\r\n    /* no-op */\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.SubOverloadedMethodsClass",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.SubOverloadedMethodsClass#print(String,String[])",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.SubOverloadedMethodsClass#print(String,String[],String)",
    "headType": "method",
    "relation": "provide",
    "tail": "void print(String header, String[] messages, String footer) {\r\n    /* no-op */\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.SubOverloadedMethodsClass",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.SubOverloadedMethodsClass#print(String,String[],String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.SubOverloadedMethodsClass",
    "headType": "class",
    "relation": "extend",
    "tail": "OverloadedMethodsClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.EnigmaSupplier",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.EnigmaSupplier",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.io.Externalizable;\nimport java.io.Serializable;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Proxy;\nimport java.time.ZoneId;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.function.Supplier;\n\nimport a.ClassHavingNestedClass;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.TestInfo;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\nimport org.junit.jupiter.params.provider.ValueSource;\n\nimport org.springframework.tests.sample.objects.DerivedTestObject;\nimport org.springframework.tests.sample.objects.ITestInterface;\nimport org.springframework.tests.sample.objects.ITestObject;\nimport org.springframework.tests.sample.objects.TestObject;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Tests for {@link ClassUtils}.\n *\n * @author Colin Sampaleanu\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Rick Evans\n * @author Sam Brannen\n */\nclass ClassUtilsTests {\n\n\tprivate final ClassLoader classLoader = getClass().getClassLoader();\n\n\n\t@Test\n\tvoid isPresent() {\n\t\tassertThat(ClassUtils.isPresent(\"java.lang.String\", classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isPresent(\"java.lang.MySpecialString\", classLoader)).isFalse();\n\t}\n\n\t@Test\n\tvoid forName() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"java.lang.String\", classLoader)).isEqualTo(String.class);\n\t\tassertThat(ClassUtils.forName(\"java.lang.String[]\", classLoader)).isEqualTo(String[].class);\n\t\tassertThat(ClassUtils.forName(String[].class.getName(), classLoader)).isEqualTo(String[].class);\n\t\tassertThat(ClassUtils.forName(String[][].class.getName(), classLoader)).isEqualTo(String[][].class);\n\t\tassertThat(ClassUtils.forName(String[][][].class.getName(), classLoader)).isEqualTo(String[][][].class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject\", classLoader)).isEqualTo(TestObject.class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject[]\", classLoader)).isEqualTo(TestObject[].class);\n\t\tassertThat(ClassUtils.forName(TestObject[].class.getName(), classLoader)).isEqualTo(TestObject[].class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject[][]\", classLoader)).isEqualTo(TestObject[][].class);\n\t\tassertThat(ClassUtils.forName(TestObject[][].class.getName(), classLoader)).isEqualTo(TestObject[][].class);\n\t\tassertThat(ClassUtils.forName(\"[[[S\", classLoader)).isEqualTo(short[][][].class);\n\t}\n\n\t@Test\n\tvoid forNameWithNestedType() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"org.springframework.util.ClassUtilsTests$NestedClass\", classLoader)).isEqualTo(NestedClass.class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.util.ClassUtilsTests.NestedClass\", classLoader)).isEqualTo(NestedClass.class);\n\n\t\t// Precondition: package name must have length == 1.\n\t\tassertThat(ClassHavingNestedClass.class.getPackageName().length()).isEqualTo(1);\n\t\tassertThat(ClassUtils.forName(\"a.ClassHavingNestedClass$NestedClass\", classLoader)).isEqualTo(ClassHavingNestedClass.NestedClass.class);\n\t\tassertThat(ClassUtils.forName(\"a.ClassHavingNestedClass.NestedClass\", classLoader)).isEqualTo(ClassHavingNestedClass.NestedClass.class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveClasses() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"boolean\", classLoader)).isEqualTo(boolean.class);\n\t\tassertThat(ClassUtils.forName(\"byte\", classLoader)).isEqualTo(byte.class);\n\t\tassertThat(ClassUtils.forName(\"char\", classLoader)).isEqualTo(char.class);\n\t\tassertThat(ClassUtils.forName(\"short\", classLoader)).isEqualTo(short.class);\n\t\tassertThat(ClassUtils.forName(\"int\", classLoader)).isEqualTo(int.class);\n\t\tassertThat(ClassUtils.forName(\"long\", classLoader)).isEqualTo(long.class);\n\t\tassertThat(ClassUtils.forName(\"float\", classLoader)).isEqualTo(float.class);\n\t\tassertThat(ClassUtils.forName(\"double\", classLoader)).isEqualTo(double.class);\n\t\tassertThat(ClassUtils.forName(\"void\", classLoader)).isEqualTo(void.class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveArrays() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"boolean[]\", classLoader)).isEqualTo(boolean[].class);\n\t\tassertThat(ClassUtils.forName(\"byte[]\", classLoader)).isEqualTo(byte[].class);\n\t\tassertThat(ClassUtils.forName(\"char[]\", classLoader)).isEqualTo(char[].class);\n\t\tassertThat(ClassUtils.forName(\"short[]\", classLoader)).isEqualTo(short[].class);\n\t\tassertThat(ClassUtils.forName(\"int[]\", classLoader)).isEqualTo(int[].class);\n\t\tassertThat(ClassUtils.forName(\"long[]\", classLoader)).isEqualTo(long[].class);\n\t\tassertThat(ClassUtils.forName(\"float[]\", classLoader)).isEqualTo(float[].class);\n\t\tassertThat(ClassUtils.forName(\"double[]\", classLoader)).isEqualTo(double[].class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveArraysInternalName() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(boolean[].class.getName(), classLoader)).isEqualTo(boolean[].class);\n\t\tassertThat(ClassUtils.forName(byte[].class.getName(), classLoader)).isEqualTo(byte[].class);\n\t\tassertThat(ClassUtils.forName(char[].class.getName(), classLoader)).isEqualTo(char[].class);\n\t\tassertThat(ClassUtils.forName(short[].class.getName(), classLoader)).isEqualTo(short[].class);\n\t\tassertThat(ClassUtils.forName(int[].class.getName(), classLoader)).isEqualTo(int[].class);\n\t\tassertThat(ClassUtils.forName(long[].class.getName(), classLoader)).isEqualTo(long[].class);\n\t\tassertThat(ClassUtils.forName(float[].class.getName(), classLoader)).isEqualTo(float[].class);\n\t\tassertThat(ClassUtils.forName(double[].class.getName(), classLoader)).isEqualTo(double[].class);\n\t}\n\n\t@Test\n\tvoid isCacheSafe() {\n\t\tClassLoader childLoader1 = new ClassLoader(classLoader) {};\n\t\tClassLoader childLoader2 = new ClassLoader(classLoader) {};\n\t\tClassLoader childLoader3 = new ClassLoader(classLoader) {\n\t\t\t@Override\n\t\t\tpublic Class<?> loadClass(String name) throws ClassNotFoundException {\n\t\t\t\treturn childLoader1.loadClass(name);\n\t\t\t}\n\t\t};\n\t\tClass<?> composite = ClassUtils.createCompositeInterface(\n\t\t\t\tnew Class<?>[] {Serializable.class, Externalizable.class}, childLoader1);\n\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, null)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader2)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader3)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, null)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader2)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader3)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, null)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, classLoader)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader2)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader3)).isTrue();\n\t}\n\n\t@ParameterizedTest(name = \"''{0}'' -> {1}\")\n\t@CsvSource(textBlock = \"\"\"\n\t\tboolean, boolean\n\t\tbyte, byte\n\t\tchar, char\n\t\tshort, short\n\t\tint, int\n\t\tlong, long\n\t\tfloat, float\n\t\tdouble, double\n\t\t[Z, boolean[]\n\t\t[B, byte[]\n\t\t[C, char[]\n\t\t[S, short[]\n\t\t[I, int[]\n\t\t[J, long[]\n\t\t[F, float[]\n\t\t[D, double[]\n\t\t\"\"\")\n\tvoid resolvePrimitiveClassName(String input, Class<?> output) {\n\t\tassertThat(ClassUtils.resolvePrimitiveClassName(input)).isEqualTo(output);\n\t}\n\n\t@Test\n\tvoid getShortName() {\n\t\tString className = ClassUtils.getShortName(getClass());\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"ClassUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getShortNameForObjectArrayClass() {\n\t\tString className = ClassUtils.getShortName(Object[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"Object[]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForMultiDimensionalObjectArrayClass() {\n\t\tString className = ClassUtils.getShortName(Object[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"Object[][]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getShortName(byte[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForMultiDimensionalPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getShortName(byte[][][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[][][]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForNestedClass() {\n\t\tString className = ClassUtils.getShortName(NestedClass.class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"ClassUtilsTests.NestedClass\");\n\t}\n\n\t@Test\n\tvoid getShortNameAsProperty() {\n\t\tString shortName = ClassUtils.getShortNameAsProperty(this.getClass());\n\t\tassertThat(shortName).as(\"Class name did not match\").isEqualTo(\"classUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getClassFileName() {\n\t\tassertThat(ClassUtils.getClassFileName(String.class)).isEqualTo(\"String.class\");\n\t\tassertThat(ClassUtils.getClassFileName(getClass())).isEqualTo(\"ClassUtilsTests.class\");\n\t}\n\n\t@Test\n\tvoid getPackageName() {\n\t\tassertThat(ClassUtils.getPackageName(String.class)).isEqualTo(\"java.lang\");\n\t\tassertThat(ClassUtils.getPackageName(getClass())).isEqualTo(getClass().getPackage().getName());\n\t}\n\n\t@Test\n\tvoid getQualifiedName() {\n\t\tString className = ClassUtils.getQualifiedName(getClass());\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"org.springframework.util.ClassUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForObjectArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(Object[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"java.lang.Object[]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForMultiDimensionalObjectArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(Object[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"java.lang.Object[][]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(byte[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForMultiDimensionalPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(byte[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[][]\");\n\t}\n\n\t@Test\n\tvoid hasMethod() {\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"size\")).isTrue();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"remove\", Object.class)).isTrue();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"remove\")).isFalse();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"someOtherMethod\")).isFalse();\n\t}\n\n\t@Test\n\tvoid getMethodIfAvailable() {\n\t\tMethod method = ClassUtils.getMethodIfAvailable(Collection.class, \"size\");\n\t\tassertThat(method).isNotNull();\n\t\tassertThat(method.getName()).isEqualTo(\"size\");\n\n\t\tmethod = ClassUtils.getMethodIfAvailable(Collection.class, \"remove\", Object.class);\n\t\tassertThat(method).isNotNull();\n\t\tassertThat(method.getName()).isEqualTo(\"remove\");\n\n\t\tassertThat(ClassUtils.getMethodIfAvailable(Collection.class, \"remove\")).isNull();\n\t\tassertThat(ClassUtils.getMethodIfAvailable(Collection.class, \"someOtherMethod\")).isNull();\n\t}\n\n\t@Test\n\tvoid getMethodCountForName() {\n\t\tassertThat(ClassUtils.getMethodCountForName(OverloadedMethodsClass.class, \"print\")).as(\"Verifying number of overloaded 'print' methods for OverloadedMethodsClass.\").isEqualTo(2);\n\t\tassertThat(ClassUtils.getMethodCountForName(SubOverloadedMethodsClass.class, \"print\")).as(\"Verifying number of overloaded 'print' methods for SubOverloadedMethodsClass.\").isEqualTo(4);\n\t}\n\n\t@Test\n\tvoid countOverloadedMethods() {\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"foobar\")).isFalse();\n\t\t// no args\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"hashCode\")).isTrue();\n\t\t// matches although it takes an arg\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"setAge\")).isTrue();\n\t}\n\n\t@Test\n\tvoid isAssignable() {\n\t\tassertThat(ClassUtils.isAssignable(Object.class, Object.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(String.class, String.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Object.class, String.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Object.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Number.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Number.class, int.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, int.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(int.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(String.class, Object.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, Number.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, double.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(double.class, Integer.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid classPackageAsResourcePath() {\n\t\tString result = ClassUtils.classPackageAsResourcePath(Proxy.class);\n\t\tassertThat(result).isEqualTo(\"java/lang/reflect\");\n\t}\n\n\t@Test\n\tvoid addResourcePathToPackagePath() {\n\t\tString result = \"java/lang/reflect/xyzabc.xml\";\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"xyzabc.xml\")).isEqualTo(result);\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"/xyzabc.xml\")).isEqualTo(result);\n\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"a/b/c/d.xml\")).isEqualTo(\"java/lang/reflect/a/b/c/d.xml\");\n\t}\n\n\t@Test\n\tvoid getAllInterfaces() {\n\t\tDerivedTestObject testBean = new DerivedTestObject();\n\t\tList<Class<?>> ifcs = Arrays.asList(ClassUtils.getAllInterfaces(testBean));\n\t\tassertThat(ifcs).as(\"Correct number of interfaces\").hasSize(4);\n\t\tassertThat(ifcs.contains(Serializable.class)).as(\"Contains Serializable\").isTrue();\n\t\tassertThat(ifcs.contains(ITestObject.class)).as(\"Contains ITestBean\").isTrue();\n\t\tassertThat(ifcs.contains(ITestInterface.class)).as(\"Contains IOther\").isTrue();\n\t}\n\n\t@Test\n\tvoid classNamesToString() {\n\t\tList<Class<?>> ifcs = new ArrayList<>();\n\t\tifcs.add(Serializable.class);\n\t\tifcs.add(Runnable.class);\n\t\tassertThat(ifcs.toString()).isEqualTo(\"[interface java.io.Serializable, interface java.lang.Runnable]\");\n\t\tassertThat(ClassUtils.classNamesToString(ifcs)).isEqualTo(\"[java.io.Serializable, java.lang.Runnable]\");\n\n\t\tList<Class<?>> classes = new ArrayList<>();\n\t\tclasses.add(ArrayList.class);\n\t\tclasses.add(Integer.class);\n\t\tassertThat(classes.toString()).isEqualTo(\"[class java.util.ArrayList, class java.lang.Integer]\");\n\t\tassertThat(ClassUtils.classNamesToString(classes)).isEqualTo(\"[java.util.ArrayList, java.lang.Integer]\");\n\n\t\tassertThat(Collections.singletonList(List.class).toString()).isEqualTo(\"[interface java.util.List]\");\n\t\tassertThat(ClassUtils.classNamesToString(List.class)).isEqualTo(\"[java.util.List]\");\n\n\t\tassertThat(Collections.EMPTY_LIST.toString()).isEqualTo(\"[]\");\n\t\tassertThat(ClassUtils.classNamesToString(Collections.emptyList())).isEqualTo(\"[]\");\n\t}\n\n\t@Test\n\tvoid determineCommonAncestor() {\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Number.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Number.class, Integer.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Number.class, null)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(null, Integer.class)).isEqualTo(Integer.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Integer.class)).isEqualTo(Integer.class);\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Float.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Float.class, Integer.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, String.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(String.class, Integer.class)).isNull();\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Collection.class)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Collection.class, List.class)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Collection.class, null)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(null, List.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, List.class)).isEqualTo(List.class);\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Set.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(Set.class, List.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Runnable.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(Runnable.class, List.class)).isNull();\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, ArrayList.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(ArrayList.class, List.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, String.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(String.class, List.class)).isNull();\n\t}\n\n\t@Test\n\tvoid getMostSpecificMethod() throws NoSuchMethodException {\n\t\tMethod defaultPrintMethod = ClassUtils.getMethod(MethodsInterface.class, \"defaultPrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(defaultPrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(defaultPrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(defaultPrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(defaultPrintMethod);\n\n\t\tMethod printMethod = ClassUtils.getMethod(MethodsInterface.class, \"print\", String.class);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isNotEqualTo(printMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(MethodsInterfaceImplementation.class, \"print\", String.class));\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(MethodsInterfaceImplementation.class, \"print\", String.class));\n\n\t\tMethod protectedPrintMethod = MethodsInterfaceImplementation.class.getDeclaredMethod(\"protectedPrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(protectedPrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(protectedPrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(protectedPrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(SubMethodsInterfaceImplementation.class.getDeclaredMethod(\"protectedPrint\"));\n\n\t\tMethod packageAccessiblePrintMethod = MethodsInterfaceImplementation.class.getDeclaredMethod(\"packageAccessiblePrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(packageAccessiblePrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(packageAccessiblePrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(packageAccessiblePrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(SubMethodsInterfaceImplementation.class, \"packageAccessiblePrint\"));\n\t}\n\n\t@ParameterizedTest\n\t@WrapperTypes\n\tvoid isPrimitiveWrapper(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveWrapper(type)).isTrue();\n\t}\n\n\t@ParameterizedTest\n\t@PrimitiveTypes\n\tvoid isPrimitiveOrWrapperWithPrimitive(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(type)).isTrue();\n\t}\n\n\t@ParameterizedTest\n\t@WrapperTypes\n\tvoid isPrimitiveOrWrapperWithWrapper(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(type)).isTrue();\n\t}\n\n\t@Test\n\tvoid isLambda() {\n\t\tassertIsLambda(ClassUtilsTests.staticLambdaExpression);\n\t\tassertIsLambda(ClassUtilsTests::staticStringFactory);\n\n\t\tassertIsLambda(this.instanceLambdaExpression);\n\t\tassertIsLambda(this::instanceStringFactory);\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"Convert2Lambda\")\n\tvoid isNotLambda() {\n\t\tassertIsNotLambda(new EnigmaSupplier());\n\n\t\tassertIsNotLambda(new Supplier<>() {\n\t\t\t@Override\n\t\t\tpublic String get() {\n\t\t\t\treturn \"anonymous inner class\";\n\t\t\t}\n\t\t});\n\n\t\tassertIsNotLambda(new Fake$$LambdaSupplier());\n\t}\n\n\n\t@Nested\n\tclass GetStaticMethodTests {\n\n\t\t@BeforeEach\n\t\tvoid clearStatics() {\n\t\t\tNestedClass.noArgCalled = false;\n\t\t\tNestedClass.argCalled = false;\n\t\t\tNestedClass.overloadedCalled = false;\n\t\t}\n\n\t\t@Test\n\t\tvoid noArgsStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"staticMethod\");\n\t\t\tmethod.invoke(null, (Object[]) null);\n\t\t\tassertThat(NestedClass.noArgCalled).as(\"no argument method was not invoked.\").isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid argsStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"argStaticMethod\", String.class);\n\t\t\tmethod.invoke(null, \"test\");\n\t\t\tassertThat(NestedClass.argCalled).as(\"argument method was not invoked.\").isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid overloadedStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"staticMethod\", String.class);\n\t\t\tmethod.invoke(null, \"test\");\n\t\t\tassertThat(NestedClass.overloadedCalled).as(\"argument method was not invoked.\").isTrue();\n\t\t}\n\n\t}\n\n\n\t@Nested  // gh-33216\n\tclass GetInterfaceMethodTests {\n\n\t\t@Test\n\t\tvoid publicMethodInPublicClass() throws Exception {\n\t\t\tClass<?> originalType = String.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"getBytes\");\n\n\t\t\tMethod interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(interfaceMethod.getDeclaringClass()).isEqualTo(originalType);\n\t\t\tassertThat(interfaceMethod).isSameAs(originalMethod);\n\t\t\tassertNotInterfaceMethod(interfaceMethod);\n\t\t\tassertPubliclyAccessible(interfaceMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInNonPublicInterface() throws Exception {\n\t\t\tClass<?> originalType = PrivateInterface.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"getMessage\");\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertPublic(originalMethod);\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(interfaceMethod).isSameAs(originalMethod);\n\t\t\tassertInterfaceMethod(interfaceMethod);\n\t\t\tassertNotPubliclyAccessible(interfaceMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicInterfaceMethodInPublicClass() throws Exception {\n\t\t\tClass<?> originalType = ArrayList.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"size\");\n\n\t\t\tMethod interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(interfaceMethod.getDeclaringClass()).isEqualTo(List.class);\n\t\t\tassertThat(interfaceMethod.getName()).isEqualTo(\"size\");\n\t\t\tassertThat(interfaceMethod.getParameterTypes()).isEmpty();\n\t\t\tassertInterfaceMethod(interfaceMethod);\n\t\t\tassertPubliclyAccessible(interfaceMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicInterfaceMethodDeclaredInNonPublicClassWithLateBindingOfClassMethodToSubclassDeclaredInterface() throws Exception {\n\t\t\tHashMap<String, String> hashMap = new HashMap<>();\n\t\t\t// Returns a package-private java.util.HashMap.KeyIterator which extends java.util.HashMap.HashIterator\n\t\t\t// which declares hasNext(), even though HashIterator does not implement Iterator. Rather, KeyIterator\n\t\t\t// implements HashIterator.\n\t\t\tIterator<String> iterator = hashMap.keySet().iterator();\n\t\t\tClass<?> targetClass = iterator.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"hasNext\");\n\n\t\t\tMethod interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, targetClass);\n\t\t\tassertThat(interfaceMethod.getDeclaringClass()).isEqualTo(Iterator.class);\n\t\t\tassertThat(interfaceMethod.getName()).isEqualTo(\"hasNext\");\n\t\t\tassertThat(interfaceMethod.getParameterTypes()).isEmpty();\n\t\t\tassertInterfaceMethod(interfaceMethod);\n\t\t\tassertPubliclyAccessible(interfaceMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPublicInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getText\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(interfaceMethod.getDeclaringClass()).isEqualTo(PublicInterface.class);\n\t\t\tassertThat(interfaceMethod.getName()).isEqualTo(\"getText\");\n\t\t\tassertThat(interfaceMethod.getParameterTypes()).isEmpty();\n\t\t\tassertInterfaceMethod(interfaceMethod);\n\t\t\tassertPubliclyAccessible(interfaceMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPrivateInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getMessage\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(interfaceMethod.getDeclaringClass()).isEqualTo(PrivateInterface.class);\n\t\t\tassertThat(interfaceMethod.getName()).isEqualTo(\"getMessage\");\n\t\t\tassertThat(interfaceMethod.getParameterTypes()).isEmpty();\n\t\t\tassertInterfaceMethod(interfaceMethod);\n\t\t\tassertNotPubliclyAccessible(interfaceMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid packagePrivateSubclassOverridesMethodInPublicInterface() throws Exception {\n\t\t\tList<String> unmodifiableList = Collections.unmodifiableList(Arrays.asList(\"foo\", \"bar\"));\n\t\t\tClass<?> targetClass = unmodifiableList.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"contains\", Object.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(interfaceMethod.getDeclaringClass()).isEqualTo(Collection.class);\n\t\t\tassertThat(interfaceMethod.getName()).isEqualTo(\"contains\");\n\t\t\tassertThat(interfaceMethod.getParameterTypes()).containsExactly(Object.class);\n\t\t\tassertInterfaceMethod(interfaceMethod);\n\t\t\tassertPubliclyAccessible(interfaceMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesMethodInPrivateInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getMethod(\"greet\", String.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(interfaceMethod.getDeclaringClass()).isEqualTo(PrivateInterface.class);\n\t\t\tassertThat(interfaceMethod.getName()).isEqualTo(\"greet\");\n\t\t\tassertThat(interfaceMethod.getParameterTypes()).containsExactly(String.class);\n\t\t\tassertInterfaceMethod(interfaceMethod);\n\t\t\tassertNotPubliclyAccessible(interfaceMethod);\n\t\t}\n\n\t}\n\n\n\t@Nested  // gh-33216\n\tclass GetPubliclyAccessibleMethodTests {\n\n\t\t@Test\n\t\tvoid nonPublicMethod(TestInfo testInfo) {\n\t\t\tMethod originalMethod = testInfo.getTestMethod().get();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(originalMethod);\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertNotPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\t// This method is intentionally public.\n\t\tpublic void publicMethodInNonPublicClass(TestInfo testInfo) {\n\t\t\tMethod originalMethod = testInfo.getTestMethod().get();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertPublic(originalMethod);\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertNotPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInNonPublicInterface() throws Exception {\n\t\t\tClass<?> originalType = PrivateInterface.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"getMessage\");\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertPublic(originalMethod);\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertNotPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInPublicClass() throws Exception {\n\t\t\tClass<?> originalType = String.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"toString\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(originalType);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicInterfaceMethodInPublicClass() throws Exception {\n\t\t\tClass<?> originalType = ArrayList.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"size\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\t// Should not find the interface method in List.\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(originalType);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInJavaLangObjectDeclaredInNonPublicClass() throws Exception {\n\t\t\tList<String> unmodifiableList = Collections.unmodifiableList(Arrays.asList(\"foo\", \"bar\"));\n\t\t\tClass<?> targetClass = unmodifiableList.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"toString\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Object.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"toString\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInJavaTimeZoneIdDeclaredInNonPublicSubclass() throws Exception {\n\t\t\t// Returns a package-private java.time.ZoneRegion.\n\t\t\tZoneId zoneId = ZoneId.of(\"CET\");\n\t\t\tClass<?> targetClass = zoneId.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getDeclaredMethod(\"getId\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(ZoneId.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getId\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicInterfaceMethodDeclaredInNonPublicClassWithLateBindingOfClassMethodToSubclassDeclaredInterface() throws Exception {\n\t\t\tHashMap<String, String> hashMap = new HashMap<>();\n\t\t\t// Returns a package-private java.util.HashMap.KeyIterator which extends java.util.HashMap.HashIterator\n\t\t\t// which declares hasNext(), even though HashIterator does not implement Iterator. Rather, KeyIterator\n\t\t\t// implements HashIterator.\n\t\t\tIterator<String> iterator = hashMap.keySet().iterator();\n\t\t\tClass<?> targetClass = iterator.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"hasNext\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, targetClass);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Iterator.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"hasNext\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPublicInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getText\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicInterface.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getText\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPrivateInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getMessage\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\t// Should not find the interface method in PrivateInterface.\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getMessage\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPublicSuperclass() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getNumber\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getNumber\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid packagePrivateSubclassOverridesMethodInPublicInterface() throws Exception {\n\t\t\tList<String> unmodifiableList = Collections.unmodifiableList(Arrays.asList(\"foo\", \"bar\"));\n\t\t\tClass<?> targetClass = unmodifiableList.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"contains\", Object.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Collection.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"contains\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(Object.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesMethodInPrivateInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getMethod(\"greet\", String.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"greet\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(String.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesMethodInPublicSuperclass() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getMethod(\"process\", int.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"process\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(int.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t}\n\n\n\tprivate static void assertInterfaceMethod(Method method) {\n\t\tassertThat(method.getDeclaringClass()).as(\"%s must be an interface method\", method).isInterface();\n\t}\n\n\tprivate static void assertNotInterfaceMethod(Method method) {\n\t\tassertThat(method.getDeclaringClass()).as(\"%s must not be an interface method\", method).isNotInterface();\n\t}\n\n\tprivate static void assertPubliclyAccessible(Method method) {\n\t\tassertPublic(method);\n\t\tassertPublic(method.getDeclaringClass());\n\t}\n\n\tprivate static void assertNotPubliclyAccessible(Method method) {\n\t\tassertThat(!isPublic(method) || !isPublic(method.getDeclaringClass()))\n\t\t\t\t.as(\"%s must not be publicly accessible\", method)\n\t\t\t\t.isTrue();\n\t}\n\n\tprivate static void assertPublic(Member member) {\n\t\tassertThat(isPublic(member)).as(\"%s must be public\", member).isTrue();\n\t}\n\n\tprivate static void assertPublic(Class<?> clazz) {\n\t\tassertThat(isPublic(clazz)).as(\"%s must be public\", clazz).isTrue();\n\t}\n\n\tprivate static void assertNotPublic(Member member) {\n\t\tassertThat(!isPublic(member)).as(\"%s must be not be public\", member).isTrue();\n\t}\n\n\tprivate static void assertNotPublic(Class<?> clazz) {\n\t\tassertThat(!isPublic(clazz)).as(\"%s must be not be public\", clazz).isTrue();\n\t}\n\n\tprivate static boolean isPublic(Class<?> clazz) {\n\t\treturn Modifier.isPublic(clazz.getModifiers());\n\t}\n\n\tprivate static boolean isPublic(Member member) {\n\t\treturn Modifier.isPublic(member.getModifiers());\n\t}\n\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueSource(classes = { Boolean.class, Character.class, Byte.class, Short.class,\n\t\tInteger.class, Long.class, Float.class, Double.class, Void.class })\n\t@interface WrapperTypes {\n\t}\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueSource(classes = { boolean.class, char.class, byte.class, short.class,\n\t\tint.class, long.class, float.class, double.class, void.class })\n\t@interface PrimitiveTypes {\n\t}\n\n\tpublic static class NestedClass {\n\n\t\tstatic boolean noArgCalled;\n\t\tstatic boolean argCalled;\n\t\tstatic boolean overloadedCalled;\n\n\t\tpublic static void staticMethod() {\n\t\t\tnoArgCalled = true;\n\t\t}\n\n\t\tpublic static void staticMethod(String anArg) {\n\t\t\toverloadedCalled = true;\n\t\t}\n\n\t\tpublic static void argStaticMethod(String anArg) {\n\t\t\targCalled = true;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class OverloadedMethodsClass {\n\n\t\tpublic void print(String messages) {\n\t\t\t/* no-op */\n\t\t}\n\n\t\tpublic void print(String[] messages) {\n\t\t\t/* no-op */\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class SubOverloadedMethodsClass extends OverloadedMethodsClass {\n\n\t\tpublic void print(String header, String[] messages) {\n\t\t\t/* no-op */\n\t\t}\n\n\t\tvoid print(String header, String[] messages, String footer) {\n\t\t\t/* no-op */\n\t\t}\n\t}\n\n\tprivate static void assertIsLambda(Supplier<String> supplier) {\n\t\tassertThat(ClassUtils.isLambdaClass(supplier.getClass())).isTrue();\n\t}\n\n\tprivate static void assertIsNotLambda(Supplier<String> supplier) {\n\t\tassertThat(ClassUtils.isLambdaClass(supplier.getClass())).isFalse();\n\t}\n\n\tprivate static final Supplier<String> staticLambdaExpression = () -> \"static lambda expression\";\n\n\tprivate final Supplier<String> instanceLambdaExpression = () -> \"instance lambda expressions\";\n\n\tprivate static String staticStringFactory() {\n\t\treturn \"static string factory\";\n\t}\n\n\tprivate String instanceStringFactory() {\n\t\treturn \"instance string factory\";\n\t}\n\n\tprivate static class EnigmaSupplier implements Supplier<String> {\n\t\t@Override\n\t\tpublic String get() {\n\t\t\treturn \"enigma\";\n\t\t}\n\t}\n\n\tprivate static class Fake$$LambdaSupplier implements Supplier<String> {\n\t\t@Override\n\t\tpublic String get() {\n\t\t\treturn \"fake lambda\";\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate interface MethodsInterface {\n\n\t\tdefault void defaultPrint() {\n\t\t}\n\n\t\tvoid print(String messages);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate class MethodsInterfaceImplementation implements MethodsInterface {\n\n\t\t@Override\n\t\tpublic void print(String message) {\n\t\t}\n\n\t\tprotected void protectedPrint() {\n\t\t}\n\n\t\tvoid packageAccessiblePrint() {\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate class SubMethodsInterfaceImplementation extends MethodsInterfaceImplementation {\n\n\t\t@Override\n\t\tprotected void protectedPrint() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void packageAccessiblePrint() {\n\t\t}\n\t}\n\n\tprivate interface PrivateInterface {\n\n\t\tString getMessage();\n\n\t\tString greet(String name);\n\t}\n\n\tprivate static class PrivateSubclass extends PublicSuperclass implements PublicInterface, PrivateInterface {\n\n\t\t@Override\n\t\tpublic int getNumber() {\n\t\t\treturn 2;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getMessage() {\n\t\t\treturn \"hello\";\n\t\t}\n\n\t\t@Override\n\t\tpublic String greet(String name) {\n\t\t\treturn \"Hello, \" + name;\n\t\t}\n\n\t\t@Override\n\t\tpublic int process(int num) {\n\t\t\treturn num * 2;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getText() {\n\t\t\treturn \"enigma\";\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.EnigmaSupplier#get()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic String get() {\r\n    return \"enigma\";\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.EnigmaSupplier",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.EnigmaSupplier#get()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.EnigmaSupplier#get()",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  }
]