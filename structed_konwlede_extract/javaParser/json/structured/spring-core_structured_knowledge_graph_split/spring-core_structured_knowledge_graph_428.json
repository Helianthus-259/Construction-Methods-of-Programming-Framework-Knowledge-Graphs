[
  {
    "head": "org.springframework.util.xml.StubTransformer#getErrorListener()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic ErrorListener getErrorListener() {\r\n    throw new UnsupportedOperationException();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.xml.StubTransformer",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.xml.StubTransformer#getErrorListener()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.xml.StubTransformer#getErrorListener()",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.xml.StubTransformer",
    "headType": "class",
    "relation": "extend",
    "tail": "Transformer",
    "tailType": "class"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.asm",
    "tailType": "package"
  },
  {
    "head": "org.springframework.asm",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.asm.Label",
    "tailType": "class"
  },
  {
    "head": "org.springframework.asm.Label",
    "headType": "class",
    "relation": "provide",
    "tail": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage org.springframework.asm;\n\n/**\n * A position in the bytecode of a method. Labels are used for jump, goto, and switch instructions,\n * and for try catch blocks. A label designates the <i>instruction</i> that is just after. Note\n * however that there can be other elements between a label and the instruction it designates (such\n * as other labels, stack map frames, line numbers, etc.).\n *\n * @author Eric Bruneton\n */\npublic class Label {\n\n  /**\n   * A flag indicating that a label is only used for debug attributes. Such a label is not the start\n   * of a basic block, the target of a jump instruction, or an exception handler. It can be safely\n   * ignored in control flow graph analysis algorithms (for optimization purposes).\n   */\n  static final int FLAG_DEBUG_ONLY = 1;\n\n  /**\n   * A flag indicating that a label is the target of a jump instruction, or the start of an\n   * exception handler.\n   */\n  static final int FLAG_JUMP_TARGET = 2;\n\n  /** A flag indicating that the bytecode offset of a label is known. */\n  static final int FLAG_RESOLVED = 4;\n\n  /** A flag indicating that a label corresponds to a reachable basic block. */\n  static final int FLAG_REACHABLE = 8;\n\n  /**\n   * A flag indicating that the basic block corresponding to a label ends with a subroutine call. By\n   * construction in {@link MethodWriter#visitJumpInsn}, labels with this flag set have at least two\n   * outgoing edges:\n   *\n   * <ul>\n   *   <li>the first one corresponds to the instruction that follows the jsr instruction in the\n   *       bytecode, i.e. where execution continues when it returns from the jsr call. This is a\n   *       virtual control flow edge, since execution never goes directly from the jsr to the next\n   *       instruction. Instead, it goes to the subroutine and eventually returns to the instruction\n   *       following the jsr. This virtual edge is used to compute the real outgoing edges of the\n   *       basic blocks ending with a ret instruction, in {@link #addSubroutineRetSuccessors}.\n   *   <li>the second one corresponds to the target of the jsr instruction,\n   * </ul>\n   */\n  static final int FLAG_SUBROUTINE_CALLER = 16;\n\n  /**\n   * A flag indicating that the basic block corresponding to a label is the start of a subroutine.\n   */\n  static final int FLAG_SUBROUTINE_START = 32;\n\n  /** A flag indicating that the basic block corresponding to a label is the end of a subroutine. */\n  static final int FLAG_SUBROUTINE_END = 64;\n\n  /** A flag indicating that this label has at least one associated line number. */\n  static final int FLAG_LINE_NUMBER = 128;\n\n  /**\n   * The number of elements to add to the {@link #otherLineNumbers} array when it needs to be\n   * resized to store a new source line number.\n   */\n  static final int LINE_NUMBERS_CAPACITY_INCREMENT = 4;\n\n  /**\n   * The number of elements to add to the {@link #forwardReferences} array when it needs to be\n   * resized to store a new forward reference.\n   */\n  static final int FORWARD_REFERENCES_CAPACITY_INCREMENT = 6;\n\n  /**\n   * The bit mask to extract the type of a forward reference to this label. The extracted type is\n   * either {@link #FORWARD_REFERENCE_TYPE_SHORT} or {@link #FORWARD_REFERENCE_TYPE_WIDE}.\n   *\n   * @see #forwardReferences\n   */\n  static final int FORWARD_REFERENCE_TYPE_MASK = 0xF0000000;\n\n  /**\n   * The type of forward references stored with two bytes in the bytecode. This is the case, for\n   * instance, of a forward reference from an ifnull instruction.\n   */\n  static final int FORWARD_REFERENCE_TYPE_SHORT = 0x10000000;\n\n  /**\n   * The type of forward references stored in four bytes in the bytecode. This is the case, for\n   * instance, of a forward reference from a lookupswitch instruction.\n   */\n  static final int FORWARD_REFERENCE_TYPE_WIDE = 0x20000000;\n\n  /**\n   * The type of forward references stored in two bytes in the <i>stack map table</i>. This is the\n   * case of the labels of {@link Frame#ITEM_UNINITIALIZED} stack map frame elements, when the NEW\n   * instruction is after the &lt;init&gt; constructor call (in bytecode offset order).\n   */\n  static final int FORWARD_REFERENCE_TYPE_STACK_MAP = 0x30000000;\n\n  /**\n   * The bit mask to extract the 'handle' of a forward reference to this label. The extracted handle\n   * is the bytecode offset where the forward reference value is stored (using either 2 or 4 bytes,\n   * as indicated by the {@link #FORWARD_REFERENCE_TYPE_MASK}).\n   *\n   * @see #forwardReferences\n   */\n  static final int FORWARD_REFERENCE_HANDLE_MASK = 0x0FFFFFFF;\n\n  /**\n   * A sentinel element used to indicate the end of a list of labels.\n   *\n   * @see #nextListElement\n   */\n  static final Label EMPTY_LIST = new Label();\n\n  /**\n   * A user managed state associated with this label. Warning: this field is used by the ASM tree\n   * package. In order to use it with the ASM tree package you must override the getLabelNode method\n   * in MethodNode.\n   */\n  public Object info;\n\n  /**\n   * The type and status of this label or its corresponding basic block. Must be zero or more of\n   * {@link #FLAG_DEBUG_ONLY}, {@link #FLAG_JUMP_TARGET}, {@link #FLAG_RESOLVED}, {@link\n   * #FLAG_REACHABLE}, {@link #FLAG_SUBROUTINE_CALLER}, {@link #FLAG_SUBROUTINE_START}, {@link\n   * #FLAG_SUBROUTINE_END}.\n   */\n  short flags;\n\n  /**\n   * The source line number corresponding to this label, if {@link #FLAG_LINE_NUMBER} is set. If\n   * there are several source line numbers corresponding to this label, the first one is stored in\n   * this field, and the remaining ones are stored in {@link #otherLineNumbers}.\n   */\n  private short lineNumber;\n\n  /**\n   * The source line numbers corresponding to this label, in addition to {@link #lineNumber}, or\n   * null. The first element of this array is the number n of source line numbers it contains, which\n   * are stored between indices 1 and n (inclusive).\n   */\n  private int[] otherLineNumbers;\n\n  /**\n   * The offset of this label in the bytecode of its method, in bytes. This value is set if and only\n   * if the {@link #FLAG_RESOLVED} flag is set.\n   */\n  int bytecodeOffset;\n\n  /**\n   * The forward references to this label. The first element is the number of forward references,\n   * times 2 (this corresponds to the index of the last element actually used in this array). Then,\n   * each forward reference is described with two consecutive integers noted\n   * 'sourceInsnBytecodeOffset' and 'reference':\n   *\n   * <ul>\n   *   <li>'sourceInsnBytecodeOffset' is the bytecode offset of the instruction that contains the\n   *       forward reference,\n   *   <li>'reference' contains the type and the offset in the bytecode where the forward reference\n   *       value must be stored, which can be extracted with {@link #FORWARD_REFERENCE_TYPE_MASK}\n   *       and {@link #FORWARD_REFERENCE_HANDLE_MASK}.\n   * </ul>\n   *\n   * <p>For instance, for an ifnull instruction at bytecode offset x, 'sourceInsnBytecodeOffset' is\n   * equal to x, and 'reference' is of type {@link #FORWARD_REFERENCE_TYPE_SHORT} with value x + 1\n   * (because the ifnull instruction uses a 2 bytes bytecode offset operand stored one byte after\n   * the start of the instruction itself). For the default case of a lookupswitch instruction at\n   * bytecode offset x, 'sourceInsnBytecodeOffset' is equal to x, and 'reference' is of type {@link\n   * #FORWARD_REFERENCE_TYPE_WIDE} with value between x + 1 and x + 4 (because the lookupswitch\n   * instruction uses a 4 bytes bytecode offset operand stored one to four bytes after the start of\n   * the instruction itself).\n   */\n  private int[] forwardReferences;\n\n  // -----------------------------------------------------------------------------------------------\n\n  // Fields for the control flow and data flow graph analysis algorithms (used to compute the\n  // maximum stack size or the stack map frames). A control flow graph contains one node per \"basic\n  // block\", and one edge per \"jump\" from one basic block to another. Each node (i.e., each basic\n  // block) is represented with the Label object that corresponds to the first instruction of this\n  // basic block. Each node also stores the list of its successors in the graph, as a linked list of\n  // Edge objects.\n  //\n  // The control flow analysis algorithms used to compute the maximum stack size or the stack map\n  // frames are similar and use two steps. The first step, during the visit of each instruction,\n  // builds information about the state of the local variables and the operand stack at the end of\n  // each basic block, called the \"output frame\", <i>relatively</i> to the frame state at the\n  // beginning of the basic block, which is called the \"input frame\", and which is <i>unknown</i>\n  // during this step. The second step, in {@link MethodWriter#computeAllFrames} and {@link\n  // MethodWriter#computeMaxStackAndLocal}, is a fix point algorithm\n  // that computes information about the input frame of each basic block, from the input state of\n  // the first basic block (known from the method signature), and by the using the previously\n  // computed relative output frames.\n  //\n  // The algorithm used to compute the maximum stack size only computes the relative output and\n  // absolute input stack heights, while the algorithm used to compute stack map frames computes\n  // relative output frames and absolute input frames.\n\n  /**\n   * The number of elements in the input stack of the basic block corresponding to this label. This\n   * field is computed in {@link MethodWriter#computeMaxStackAndLocal}.\n   */\n  short inputStackSize;\n\n  /**\n   * The number of elements in the output stack, at the end of the basic block corresponding to this\n   * label. This field is only computed for basic blocks that end with a RET instruction.\n   */\n  short outputStackSize;\n\n  /**\n   * The maximum height reached by the output stack, relatively to the top of the input stack, in\n   * the basic block corresponding to this label. This maximum is always positive or {@literal\n   * null}.\n   */\n  short outputStackMax;\n\n  /**\n   * The id of the subroutine to which this basic block belongs, or 0. If the basic block belongs to\n   * several subroutines, this is the id of the \"oldest\" subroutine that contains it (with the\n   * convention that a subroutine calling another one is \"older\" than the callee). This field is\n   * computed in {@link MethodWriter#computeMaxStackAndLocal}, if the method contains JSR\n   * instructions.\n   */\n  short subroutineId;\n\n  /**\n   * The input and output stack map frames of the basic block corresponding to this label. This\n   * field is only used when the {@link MethodWriter#COMPUTE_ALL_FRAMES} or {@link\n   * MethodWriter#COMPUTE_INSERTED_FRAMES} option is used.\n   */\n  Frame frame;\n\n  /**\n   * The successor of this label, in the order they are visited in {@link MethodVisitor#visitLabel}.\n   * This linked list does not include labels used for debug info only. If the {@link\n   * MethodWriter#COMPUTE_ALL_FRAMES} or {@link MethodWriter#COMPUTE_INSERTED_FRAMES} option is used\n   * then it does not contain either successive labels that denote the same bytecode offset (in this\n   * case only the first label appears in this list).\n   */\n  Label nextBasicBlock;\n\n  /**\n   * The outgoing edges of the basic block corresponding to this label, in the control flow graph of\n   * its method. These edges are stored in a linked list of {@link Edge} objects, linked to each\n   * other by their {@link Edge#nextEdge} field.\n   */\n  Edge outgoingEdges;\n\n  /**\n   * The next element in the list of labels to which this label belongs, or {@literal null} if it\n   * does not belong to any list. All lists of labels must end with the {@link #EMPTY_LIST}\n   * sentinel, in order to ensure that this field is null if and only if this label does not belong\n   * to a list of labels. Note that there can be several lists of labels at the same time, but that\n   * a label can belong to at most one list at a time (unless some lists share a common tail, but\n   * this is not used in practice).\n   *\n   * <p>List of labels are used in {@link MethodWriter#computeAllFrames} and {@link\n   * MethodWriter#computeMaxStackAndLocal} to compute stack map frames and the maximum stack size,\n   * respectively, as well as in {@link #markSubroutine} and {@link #addSubroutineRetSuccessors} to\n   * compute the basic blocks belonging to subroutines and their outgoing edges. Outside of these\n   * methods, this field should be null (this property is a precondition and a postcondition of\n   * these methods).\n   */\n  Label nextListElement;\n\n  // -----------------------------------------------------------------------------------------------\n  // Constructor and accessors\n  // -----------------------------------------------------------------------------------------------\n\n  /** Constructs a new label. */\n  public Label() {\n    // Nothing to do.\n  }\n\n  /**\n   * Returns the bytecode offset corresponding to this label. This offset is computed from the start\n   * of the method's bytecode. <i>This method is intended for {@link Attribute} sub classes, and is\n   * normally not needed by class generators or adapters.</i>\n   *\n   * @return the bytecode offset corresponding to this label.\n   * @throws IllegalStateException if this label is not resolved yet.\n   */\n  public int getOffset() {\n    if ((flags & FLAG_RESOLVED) == 0) {\n      throw new IllegalStateException(\"Label offset position has not been resolved yet\");\n    }\n    return bytecodeOffset;\n  }\n\n  /**\n   * Returns the \"canonical\" {@link Label} instance corresponding to this label's bytecode offset,\n   * if known, otherwise the label itself. The canonical instance is the first label (in the order\n   * of their visit by {@link MethodVisitor#visitLabel}) corresponding to this bytecode offset. It\n   * cannot be known for labels which have not been visited yet.\n   *\n   * <p><i>This method should only be used when the {@link MethodWriter#COMPUTE_ALL_FRAMES} option\n   * is used.</i>\n   *\n   * @return the label itself if {@link #frame} is null, otherwise the Label's frame owner. This\n   *     corresponds to the \"canonical\" label instance described above thanks to the way the label\n   *     frame is set in {@link MethodWriter#visitLabel}.\n   */\n  final Label getCanonicalInstance() {\n    return frame == null ? this : frame.owner;\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Methods to manage line numbers\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Adds a source line number corresponding to this label.\n   *\n   * @param lineNumber a source line number (which should be strictly positive).\n   */\n  final void addLineNumber(final int lineNumber) {\n    if ((flags & FLAG_LINE_NUMBER) == 0) {\n      flags |= FLAG_LINE_NUMBER;\n      this.lineNumber = (short) lineNumber;\n    } else {\n      if (otherLineNumbers == null) {\n        otherLineNumbers = new int[LINE_NUMBERS_CAPACITY_INCREMENT];\n      }\n      int otherLineNumberIndex = ++otherLineNumbers[0];\n      if (otherLineNumberIndex >= otherLineNumbers.length) {\n        int[] newLineNumbers = new int[otherLineNumbers.length + LINE_NUMBERS_CAPACITY_INCREMENT];\n        System.arraycopy(otherLineNumbers, 0, newLineNumbers, 0, otherLineNumbers.length);\n        otherLineNumbers = newLineNumbers;\n      }\n      otherLineNumbers[otherLineNumberIndex] = lineNumber;\n    }\n  }\n\n  /**\n   * Makes the given visitor visit this label and its source line numbers, if applicable.\n   *\n   * @param methodVisitor a method visitor.\n   * @param visitLineNumbers whether to visit of the label's source line numbers, if any.\n   */\n  final void accept(final MethodVisitor methodVisitor, final boolean visitLineNumbers) {\n    methodVisitor.visitLabel(this);\n    if (visitLineNumbers && (flags & FLAG_LINE_NUMBER) != 0) {\n      methodVisitor.visitLineNumber(lineNumber & 0xFFFF, this);\n      if (otherLineNumbers != null) {\n        for (int i = 1; i <= otherLineNumbers[0]; ++i) {\n          methodVisitor.visitLineNumber(otherLineNumbers[i], this);\n        }\n      }\n    }\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Methods to compute offsets and to manage forward references\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Puts a reference to this label in the bytecode of a method. If the bytecode offset of the label\n   * is known, the relative bytecode offset between the label and the instruction referencing it is\n   * computed and written directly. Otherwise, a null relative offset is written and a new forward\n   * reference is declared for this label.\n   *\n   * @param code the bytecode of the method. This is where the reference is appended.\n   * @param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the\n   *     reference to be appended.\n   * @param wideReference whether the reference must be stored in 4 bytes (instead of 2 bytes).\n   */\n  final void put(\n      final ByteVector code, final int sourceInsnBytecodeOffset, final boolean wideReference) {\n    if ((flags & FLAG_RESOLVED) == 0) {\n      if (wideReference) {\n        addForwardReference(sourceInsnBytecodeOffset, FORWARD_REFERENCE_TYPE_WIDE, code.length);\n        code.putInt(-1);\n      } else {\n        addForwardReference(sourceInsnBytecodeOffset, FORWARD_REFERENCE_TYPE_SHORT, code.length);\n        code.putShort(-1);\n      }\n    } else {\n      if (wideReference) {\n        code.putInt(bytecodeOffset - sourceInsnBytecodeOffset);\n      } else {\n        code.putShort(bytecodeOffset - sourceInsnBytecodeOffset);\n      }\n    }\n  }\n\n  /**\n   * Puts a reference to this label in the <i>stack map table</i> of a method. If the bytecode\n   * offset of the label is known, it is written directly. Otherwise, a null relative offset is\n   * written and a new forward reference is declared for this label.\n   *\n   * @param stackMapTableEntries the stack map table where the label offset must be added.\n   */\n  final void put(final ByteVector stackMapTableEntries) {\n    if ((flags & FLAG_RESOLVED) == 0) {\n      addForwardReference(0, FORWARD_REFERENCE_TYPE_STACK_MAP, stackMapTableEntries.length);\n    }\n    stackMapTableEntries.putShort(bytecodeOffset);\n  }\n\n  /**\n   * Adds a forward reference to this label. This method must be called only for a true forward\n   * reference, i.e. only if this label is not resolved yet. For backward references, the relative\n   * bytecode offset of the reference can be, and must be, computed and stored directly.\n   *\n   * @param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the\n   *     reference stored at referenceHandle.\n   * @param referenceType either {@link #FORWARD_REFERENCE_TYPE_SHORT} or {@link\n   *     #FORWARD_REFERENCE_TYPE_WIDE}.\n   * @param referenceHandle the offset in the bytecode where the forward reference value must be\n   *     stored.\n   */\n  private void addForwardReference(\n      final int sourceInsnBytecodeOffset, final int referenceType, final int referenceHandle) {\n    if (forwardReferences == null) {\n      forwardReferences = new int[FORWARD_REFERENCES_CAPACITY_INCREMENT];\n    }\n    int lastElementIndex = forwardReferences[0];\n    if (lastElementIndex + 2 >= forwardReferences.length) {\n      int[] newValues = new int[forwardReferences.length + FORWARD_REFERENCES_CAPACITY_INCREMENT];\n      System.arraycopy(forwardReferences, 0, newValues, 0, forwardReferences.length);\n      forwardReferences = newValues;\n    }\n    forwardReferences[++lastElementIndex] = sourceInsnBytecodeOffset;\n    forwardReferences[++lastElementIndex] = referenceType | referenceHandle;\n    forwardReferences[0] = lastElementIndex;\n  }\n\n  /**\n   * Sets the bytecode offset of this label to the given value and resolves the forward references\n   * to this label, if any. This method must be called when this label is added to the bytecode of\n   * the method, i.e. when its bytecode offset becomes known. This method fills in the blanks that\n   * where left in the bytecode (and optionally in the stack map table) by each forward reference\n   * previously added to this label.\n   *\n   * @param code the bytecode of the method.\n   * @param stackMapTableEntries the 'entries' array of the StackMapTable code attribute of the\n   *     method. Maybe {@literal null}.\n   * @param bytecodeOffset the bytecode offset of this label.\n   * @return {@literal true} if a blank that was left for this label was too small to store the\n   *     offset. In such a case the corresponding jump instruction is replaced with an equivalent\n   *     ASM specific instruction using an unsigned two bytes offset. These ASM specific\n   *     instructions are later replaced with standard bytecode instructions with wider offsets (4\n   *     bytes instead of 2), in ClassReader.\n   */\n  final boolean resolve(\n      final byte[] code, final ByteVector stackMapTableEntries, final int bytecodeOffset) {\n    this.flags |= FLAG_RESOLVED;\n    this.bytecodeOffset = bytecodeOffset;\n    if (forwardReferences == null) {\n      return false;\n    }\n    boolean hasAsmInstructions = false;\n    for (int i = forwardReferences[0]; i > 0; i -= 2) {\n      final int sourceInsnBytecodeOffset = forwardReferences[i - 1];\n      final int reference = forwardReferences[i];\n      final int relativeOffset = bytecodeOffset - sourceInsnBytecodeOffset;\n      int handle = reference & FORWARD_REFERENCE_HANDLE_MASK;\n      if ((reference & FORWARD_REFERENCE_TYPE_MASK) == FORWARD_REFERENCE_TYPE_SHORT) {\n        if (relativeOffset < Short.MIN_VALUE || relativeOffset > Short.MAX_VALUE) {\n          // Change the opcode of the jump instruction, in order to be able to find it later in\n          // ClassReader. These ASM specific opcodes are similar to jump instruction opcodes, except\n          // that the 2 bytes offset is unsigned (and can therefore represent values from 0 to\n          // 65535, which is sufficient since the size of a method is limited to 65535 bytes).\n          int opcode = code[sourceInsnBytecodeOffset] & 0xFF;\n          if (opcode < Opcodes.IFNULL) {\n            // Change IFEQ ... JSR to ASM_IFEQ ... ASM_JSR.\n            code[sourceInsnBytecodeOffset] = (byte) (opcode + Constants.ASM_OPCODE_DELTA);\n          } else {\n            // Change IFNULL and IFNONNULL to ASM_IFNULL and ASM_IFNONNULL.\n            code[sourceInsnBytecodeOffset] = (byte) (opcode + Constants.ASM_IFNULL_OPCODE_DELTA);\n          }\n          hasAsmInstructions = true;\n        }\n        code[handle++] = (byte) (relativeOffset >>> 8);\n        code[handle] = (byte) relativeOffset;\n      } else if ((reference & FORWARD_REFERENCE_TYPE_MASK) == FORWARD_REFERENCE_TYPE_WIDE) {\n        code[handle++] = (byte) (relativeOffset >>> 24);\n        code[handle++] = (byte) (relativeOffset >>> 16);\n        code[handle++] = (byte) (relativeOffset >>> 8);\n        code[handle] = (byte) relativeOffset;\n      } else {\n        stackMapTableEntries.data[handle++] = (byte) (bytecodeOffset >>> 8);\n        stackMapTableEntries.data[handle] = (byte) bytecodeOffset;\n      }\n    }\n    return hasAsmInstructions;\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Methods related to subroutines\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Finds the basic blocks that belong to the subroutine starting with the basic block\n   * corresponding to this label, and marks these blocks as belonging to this subroutine. This\n   * method follows the control flow graph to find all the blocks that are reachable from the\n   * current basic block WITHOUT following any jsr target.\n   *\n   * <p>Note: a precondition and postcondition of this method is that all labels must have a null\n   * {@link #nextListElement}.\n   *\n   * @param subroutineId the id of the subroutine starting with the basic block corresponding to\n   *     this label.\n   */\n  final void markSubroutine(final short subroutineId) {\n    // Data flow algorithm: put this basic block in a list of blocks to process (which are blocks\n    // belonging to subroutine subroutineId) and, while there are blocks to process, remove one from\n    // the list, mark it as belonging to the subroutine, and add its successor basic blocks in the\n    // control flow graph to the list of blocks to process (if not already done).\n    Label listOfBlocksToProcess = this;\n    listOfBlocksToProcess.nextListElement = EMPTY_LIST;\n    while (listOfBlocksToProcess != EMPTY_LIST) {\n      // Remove a basic block from the list of blocks to process.\n      Label basicBlock = listOfBlocksToProcess;\n      listOfBlocksToProcess = listOfBlocksToProcess.nextListElement;\n      basicBlock.nextListElement = null;\n\n      // If it is not already marked as belonging to a subroutine, mark it as belonging to\n      // subroutineId and add its successors to the list of blocks to process (unless already done).\n      if (basicBlock.subroutineId == 0) {\n        basicBlock.subroutineId = subroutineId;\n        listOfBlocksToProcess = basicBlock.pushSuccessors(listOfBlocksToProcess);\n      }\n    }\n  }\n\n  /**\n   * Finds the basic blocks that end a subroutine starting with the basic block corresponding to\n   * this label and, for each one of them, adds an outgoing edge to the basic block following the\n   * given subroutine call. In other words, completes the control flow graph by adding the edges\n   * corresponding to the return from this subroutine, when called from the given caller basic\n   * block.\n   *\n   * <p>Note: a precondition and postcondition of this method is that all labels must have a null\n   * {@link #nextListElement}.\n   *\n   * @param subroutineCaller a basic block that ends with a jsr to the basic block corresponding to\n   *     this label. This label is supposed to correspond to the start of a subroutine.\n   */\n  final void addSubroutineRetSuccessors(final Label subroutineCaller) {\n    // Data flow algorithm: put this basic block in a list blocks to process (which are blocks\n    // belonging to a subroutine starting with this label) and, while there are blocks to process,\n    // remove one from the list, put it in a list of blocks that have been processed, add a return\n    // edge to the successor of subroutineCaller if applicable, and add its successor basic blocks\n    // in the control flow graph to the list of blocks to process (if not already done).\n    Label listOfProcessedBlocks = EMPTY_LIST;\n    Label listOfBlocksToProcess = this;\n    listOfBlocksToProcess.nextListElement = EMPTY_LIST;\n    while (listOfBlocksToProcess != EMPTY_LIST) {\n      // Move a basic block from the list of blocks to process to the list of processed blocks.\n      Label basicBlock = listOfBlocksToProcess;\n      listOfBlocksToProcess = basicBlock.nextListElement;\n      basicBlock.nextListElement = listOfProcessedBlocks;\n      listOfProcessedBlocks = basicBlock;\n\n      // Add an edge from this block to the successor of the caller basic block, if this block is\n      // the end of a subroutine and if this block and subroutineCaller do not belong to the same\n      // subroutine.\n      if ((basicBlock.flags & FLAG_SUBROUTINE_END) != 0\n          && basicBlock.subroutineId != subroutineCaller.subroutineId) {\n        basicBlock.outgoingEdges =\n            new Edge(\n                basicBlock.outputStackSize,\n                // By construction, the first outgoing edge of a basic block that ends with a jsr\n                // instruction leads to the jsr continuation block, i.e. where execution continues\n                // when ret is called (see {@link #FLAG_SUBROUTINE_CALLER}).\n                subroutineCaller.outgoingEdges.successor,\n                basicBlock.outgoingEdges);\n      }\n      // Add its successors to the list of blocks to process. Note that {@link #pushSuccessors} does\n      // not push basic blocks which are already in a list. Here this means either in the list of\n      // blocks to process, or in the list of already processed blocks. This second list is\n      // important to make sure we don't reprocess an already processed block.\n      listOfBlocksToProcess = basicBlock.pushSuccessors(listOfBlocksToProcess);\n    }\n    // Reset the {@link #nextListElement} of all the basic blocks that have been processed to null,\n    // so that this method can be called again with a different subroutine or subroutine caller.\n    while (listOfProcessedBlocks != EMPTY_LIST) {\n      Label newListOfProcessedBlocks = listOfProcessedBlocks.nextListElement;\n      listOfProcessedBlocks.nextListElement = null;\n      listOfProcessedBlocks = newListOfProcessedBlocks;\n    }\n  }\n\n  /**\n   * Adds the successors of this label in the method's control flow graph (except those\n   * corresponding to a jsr target, and those already in a list of labels) to the given list of\n   * blocks to process, and returns the new list.\n   *\n   * @param listOfLabelsToProcess a list of basic blocks to process, linked together with their\n   *     {@link #nextListElement} field.\n   * @return the new list of blocks to process.\n   */\n  private Label pushSuccessors(final Label listOfLabelsToProcess) {\n    Label newListOfLabelsToProcess = listOfLabelsToProcess;\n    Edge outgoingEdge = outgoingEdges;\n    while (outgoingEdge != null) {\n      // By construction, the second outgoing edge of a basic block that ends with a jsr instruction\n      // leads to the jsr target (see {@link #FLAG_SUBROUTINE_CALLER}).\n      boolean isJsrTarget =\n          (flags & Label.FLAG_SUBROUTINE_CALLER) != 0 && outgoingEdge == outgoingEdges.nextEdge;\n      if (!isJsrTarget && outgoingEdge.successor.nextListElement == null) {\n        // Add this successor to the list of blocks to process, if it does not already belong to a\n        // list of labels.\n        outgoingEdge.successor.nextListElement = newListOfLabelsToProcess;\n        newListOfLabelsToProcess = outgoingEdge.successor;\n      }\n      outgoingEdge = outgoingEdge.nextEdge;\n    }\n    return newListOfLabelsToProcess;\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Overridden Object methods\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Returns a string representation of this label.\n   *\n   * @return a string representation of this label.\n   */\n  @Override\n  public String toString() {\n    return \"L\" + System.identityHashCode(this);\n  }\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.asm.Label",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.Label#FLAG_DEBUG_ONLY",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.Label#FLAG_DEBUG_ONLY",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.Label",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.Label#FLAG_JUMP_TARGET",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.Label#FLAG_JUMP_TARGET",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.Label",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.Label#FLAG_RESOLVED",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.Label#FLAG_RESOLVED",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.Label",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.Label#FLAG_REACHABLE",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.Label#FLAG_REACHABLE",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.Label",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.Label#FLAG_SUBROUTINE_CALLER",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.Label#FLAG_SUBROUTINE_CALLER",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.Label",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.Label#FLAG_SUBROUTINE_START",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.Label#FLAG_SUBROUTINE_START",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.Label",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.Label#FLAG_SUBROUTINE_END",
    "tailType": "field"
  }
]