[
  {
    "head": "org.springframework.core.Constants",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.Constants#getValuesForSuffix(String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.Constants#toCode(Object,String)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Look up the given value within the given group of constants.\r\n * <p>Will return the first match.\r\n * @param value constant value to look up\r\n * @param namePrefix prefix of the constant names to search (may be {@code null})\r\n * @return the name of the constant field\r\n * @throws ConstantException if the value wasn't found\r\n */\r\npublic String toCode(Object value, @Nullable String namePrefix) throws ConstantException {\r\n    String prefixToUse = (namePrefix != null ? namePrefix.trim().toUpperCase(Locale.ENGLISH) : \"\");\r\n    for (Map.Entry<String, Object> entry : this.fieldCache.entrySet()) {\r\n        if (entry.getKey().startsWith(prefixToUse) && entry.getValue().equals(value)) {\r\n            return entry.getKey();\r\n        }\r\n    }\r\n    throw new ConstantException(this.className, prefixToUse, value);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.Constants",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.Constants#toCode(Object,String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.Constants#toCodeForProperty(Object,String)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Look up the given value within the group of constants for\r\n * the given bean property name. Will return the first match.\r\n * @param value constant value to look up\r\n * @param propertyName the name of the bean property\r\n * @return the name of the constant field\r\n * @throws ConstantException if the value wasn't found\r\n * @see #propertyToConstantNamePrefix\r\n */\r\npublic String toCodeForProperty(Object value, String propertyName) throws ConstantException {\r\n    return toCode(value, propertyToConstantNamePrefix(propertyName));\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.Constants",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.Constants#toCodeForProperty(Object,String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.Constants#toCodeForSuffix(Object,String)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Look up the given value within the given group of constants.\r\n * <p>Will return the first match.\r\n * @param value constant value to look up\r\n * @param nameSuffix suffix of the constant names to search (may be {@code null})\r\n * @return the name of the constant field\r\n * @throws ConstantException if the value wasn't found\r\n */\r\npublic String toCodeForSuffix(Object value, @Nullable String nameSuffix) throws ConstantException {\r\n    String suffixToUse = (nameSuffix != null ? nameSuffix.trim().toUpperCase(Locale.ENGLISH) : \"\");\r\n    for (Map.Entry<String, Object> entry : this.fieldCache.entrySet()) {\r\n        if (entry.getKey().endsWith(suffixToUse) && entry.getValue().equals(value)) {\r\n            return entry.getKey();\r\n        }\r\n    }\r\n    throw new ConstantException(this.className, suffixToUse, value);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.Constants",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.Constants#toCodeForSuffix(Object,String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.Constants#propertyToConstantNamePrefix(String)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Convert the given bean property name to a constant name prefix.\r\n * <p>Uses a common naming idiom: turning all lower case characters to\r\n * upper case, and prepending upper case characters with an underscore.\r\n * <p>Example: \"imageSize\" &rarr; \"IMAGE_SIZE\"<br>\r\n * Example: \"imagesize\" &rarr; \"IMAGESIZE\".<br>\r\n * Example: \"ImageSize\" &rarr; \"_IMAGE_SIZE\".<br>\r\n * Example: \"IMAGESIZE\" &rarr; \"_I_M_A_G_E_S_I_Z_E\"\r\n * @param propertyName the name of the bean property\r\n * @return the corresponding constant name prefix\r\n * @see #getValuesForProperty\r\n * @see #toCodeForProperty\r\n */\r\npublic String propertyToConstantNamePrefix(String propertyName) {\r\n    StringBuilder parsedPrefix = new StringBuilder();\r\n    for (int i = 0; i < propertyName.length(); i++) {\r\n        char c = propertyName.charAt(i);\r\n        if (Character.isUpperCase(c)) {\r\n            parsedPrefix.append('_');\r\n            parsedPrefix.append(c);\r\n        } else {\r\n            parsedPrefix.append(Character.toUpperCase(c));\r\n        }\r\n    }\r\n    return parsedPrefix.toString();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.Constants",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.Constants#propertyToConstantNamePrefix(String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.ConstantException",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.ConstantException",
    "headType": "class",
    "relation": "use",
    "tail": "@SuppressWarnings",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.ConstantException",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.lang.reflect.Field;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.util.Assert;\nimport org.springframework.util.ReflectionUtils;\n\n/**\n * This class can be used to parse other classes containing constant definitions\n * in public static final members. The {@code asXXXX} methods of this class\n * allow these constant values to be accessed via their string names.\n *\n * <p>Consider class Foo containing {@code public static final int CONSTANT1 = 66;}\n * An instance of this class wrapping {@code Foo.class} will return the constant value\n * of 66 from its {@code asNumber} method given the argument {@code \"CONSTANT1\"}.\n *\n * <p>This class is ideal for use in PropertyEditors, enabling them to\n * recognize the same names as the constants themselves, and freeing them\n * from maintaining their own mapping.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 16.03.2003\n * @deprecated since 6.1 with no replacement; use an enum, map, or similar custom\n * solution instead\n */\n@Deprecated(since = \"6.1\")\npublic class Constants {\n\n\t/** The name of the introspected class. */\n\tprivate final String className;\n\n\t/** Map from String field name to object value. */\n\tprivate final Map<String, Object> fieldCache = new HashMap<>();\n\n\n\t/**\n\t * Create a new Constants converter class wrapping the given class.\n\t * <p>All <b>public</b> static final variables will be exposed, whatever their type.\n\t * @param clazz the class to analyze\n\t * @throws IllegalArgumentException if the supplied {@code clazz} is {@code null}\n\t */\n\tpublic Constants(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tthis.className = clazz.getName();\n\t\tField[] fields = clazz.getFields();\n\t\tfor (Field field : fields) {\n\t\t\tif (ReflectionUtils.isPublicStaticFinal(field)) {\n\t\t\t\tString name = field.getName();\n\t\t\t\ttry {\n\t\t\t\t\tObject value = field.get(null);\n\t\t\t\t\tthis.fieldCache.put(name, value);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\t\t// just leave this field and continue\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Return the name of the analyzed class.\n\t */\n\tpublic final String getClassName() {\n\t\treturn this.className;\n\t}\n\n\t/**\n\t * Return the number of constants exposed.\n\t */\n\tpublic final int getSize() {\n\t\treturn this.fieldCache.size();\n\t}\n\n\t/**\n\t * Exposes the field cache to subclasses:\n\t * a Map from String field name to object value.\n\t */\n\tprotected final Map<String, Object> getFieldCache() {\n\t\treturn this.fieldCache;\n\t}\n\n\n\t/**\n\t * Return a constant value cast to a Number.\n\t * @param code the name of the field (never {@code null})\n\t * @return the Number value\n\t * @throws ConstantException if the field name wasn't found\n\t * or if the type wasn't compatible with Number\n\t * @see #asObject\n\t */\n\tpublic Number asNumber(String code) throws ConstantException {\n\t\tObject obj = asObject(code);\n\t\tif (!(obj instanceof Number number)) {\n\t\t\tthrow new ConstantException(this.className, code, \"not a Number\");\n\t\t}\n\t\treturn number;\n\t}\n\n\t/**\n\t * Return a constant value as a String.\n\t * @param code the name of the field (never {@code null})\n\t * @return the String value\n\t * Works even if it's not a string (invokes {@code toString()}).\n\t * @throws ConstantException if the field name wasn't found\n\t * @see #asObject\n\t */\n\tpublic String asString(String code) throws ConstantException {\n\t\treturn asObject(code).toString();\n\t}\n\n\t/**\n\t * Parse the given String (upper or lower case accepted) and return\n\t * the appropriate value if it's the name of a constant field in the\n\t * class that we're analyzing.\n\t * @param code the name of the field (never {@code null})\n\t * @return the Object value\n\t * @throws ConstantException if there's no such field\n\t */\n\tpublic Object asObject(String code) throws ConstantException {\n\t\tAssert.notNull(code, \"Code must not be null\");\n\t\tString codeToUse = code.toUpperCase(Locale.ENGLISH);\n\t\tObject val = this.fieldCache.get(codeToUse);\n\t\tif (val == null) {\n\t\t\tthrow new ConstantException(this.className, codeToUse, \"not found\");\n\t\t}\n\t\treturn val;\n\t}\n\n\n\t/**\n\t * Return all names of the given group of constants.\n\t * <p>Note that this method assumes that constants are named\n\t * in accordance with the standard Java convention for constant\n\t * values (i.e. all uppercase). The supplied {@code namePrefix}\n\t * will be uppercased (in a locale-insensitive fashion) prior to\n\t * the main logic of this method kicking in.\n\t * @param namePrefix prefix of the constant names to search (may be {@code null})\n\t * @return the set of constant names\n\t */\n\tpublic Set<String> getNames(@Nullable String namePrefix) {\n\t\tString prefixToUse = (namePrefix != null ? namePrefix.trim().toUpperCase(Locale.ENGLISH) : \"\");\n\t\tSet<String> names = new HashSet<>();\n\t\tfor (String code : this.fieldCache.keySet()) {\n\t\t\tif (code.startsWith(prefixToUse)) {\n\t\t\t\tnames.add(code);\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n\t/**\n\t * Return all names of the group of constants for the\n\t * given bean property name.\n\t * @param propertyName the name of the bean property\n\t * @return the set of values\n\t * @see #propertyToConstantNamePrefix\n\t */\n\tpublic Set<String> getNamesForProperty(String propertyName) {\n\t\treturn getNames(propertyToConstantNamePrefix(propertyName));\n\t}\n\n\t/**\n\t * Return all names of the given group of constants.\n\t * <p>Note that this method assumes that constants are named\n\t * in accordance with the standard Java convention for constant\n\t * values (i.e. all uppercase). The supplied {@code nameSuffix}\n\t * will be uppercased (in a locale-insensitive fashion) prior to\n\t * the main logic of this method kicking in.\n\t * @param nameSuffix suffix of the constant names to search (may be {@code null})\n\t * @return the set of constant names\n\t */\n\tpublic Set<String> getNamesForSuffix(@Nullable String nameSuffix) {\n\t\tString suffixToUse = (nameSuffix != null ? nameSuffix.trim().toUpperCase(Locale.ENGLISH) : \"\");\n\t\tSet<String> names = new HashSet<>();\n\t\tfor (String code : this.fieldCache.keySet()) {\n\t\t\tif (code.endsWith(suffixToUse)) {\n\t\t\t\tnames.add(code);\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n\n\t/**\n\t * Return all values of the given group of constants.\n\t * <p>Note that this method assumes that constants are named\n\t * in accordance with the standard Java convention for constant\n\t * values (i.e. all uppercase). The supplied {@code namePrefix}\n\t * will be uppercased (in a locale-insensitive fashion) prior to\n\t * the main logic of this method kicking in.\n\t * @param namePrefix prefix of the constant names to search (may be {@code null})\n\t * @return the set of values\n\t */\n\tpublic Set<Object> getValues(@Nullable String namePrefix) {\n\t\tString prefixToUse = (namePrefix != null ? namePrefix.trim().toUpperCase(Locale.ENGLISH) : \"\");\n\t\tSet<Object> values = new HashSet<>();\n\t\tthis.fieldCache.forEach((code, value) -> {\n\t\t\tif (code.startsWith(prefixToUse)) {\n\t\t\t\tvalues.add(value);\n\t\t\t}\n\t\t});\n\t\treturn values;\n\t}\n\n\t/**\n\t * Return all values of the group of constants for the\n\t * given bean property name.\n\t * @param propertyName the name of the bean property\n\t * @return the set of values\n\t * @see #propertyToConstantNamePrefix\n\t */\n\tpublic Set<Object> getValuesForProperty(String propertyName) {\n\t\treturn getValues(propertyToConstantNamePrefix(propertyName));\n\t}\n\n\t/**\n\t * Return all values of the given group of constants.\n\t * <p>Note that this method assumes that constants are named\n\t * in accordance with the standard Java convention for constant\n\t * values (i.e. all uppercase). The supplied {@code nameSuffix}\n\t * will be uppercased (in a locale-insensitive fashion) prior to\n\t * the main logic of this method kicking in.\n\t * @param nameSuffix suffix of the constant names to search (may be {@code null})\n\t * @return the set of values\n\t */\n\tpublic Set<Object> getValuesForSuffix(@Nullable String nameSuffix) {\n\t\tString suffixToUse = (nameSuffix != null ? nameSuffix.trim().toUpperCase(Locale.ENGLISH) : \"\");\n\t\tSet<Object> values = new HashSet<>();\n\t\tthis.fieldCache.forEach((code, value) -> {\n\t\t\tif (code.endsWith(suffixToUse)) {\n\t\t\t\tvalues.add(value);\n\t\t\t}\n\t\t});\n\t\treturn values;\n\t}\n\n\n\t/**\n\t * Look up the given value within the given group of constants.\n\t * <p>Will return the first match.\n\t * @param value constant value to look up\n\t * @param namePrefix prefix of the constant names to search (may be {@code null})\n\t * @return the name of the constant field\n\t * @throws ConstantException if the value wasn't found\n\t */\n\tpublic String toCode(Object value, @Nullable String namePrefix) throws ConstantException {\n\t\tString prefixToUse = (namePrefix != null ? namePrefix.trim().toUpperCase(Locale.ENGLISH) : \"\");\n\t\tfor (Map.Entry<String, Object> entry : this.fieldCache.entrySet()) {\n\t\t\tif (entry.getKey().startsWith(prefixToUse) && entry.getValue().equals(value)) {\n\t\t\t\treturn entry.getKey();\n\t\t\t}\n\t\t}\n\t\tthrow new ConstantException(this.className, prefixToUse, value);\n\t}\n\n\t/**\n\t * Look up the given value within the group of constants for\n\t * the given bean property name. Will return the first match.\n\t * @param value constant value to look up\n\t * @param propertyName the name of the bean property\n\t * @return the name of the constant field\n\t * @throws ConstantException if the value wasn't found\n\t * @see #propertyToConstantNamePrefix\n\t */\n\tpublic String toCodeForProperty(Object value, String propertyName) throws ConstantException {\n\t\treturn toCode(value, propertyToConstantNamePrefix(propertyName));\n\t}\n\n\t/**\n\t * Look up the given value within the given group of constants.\n\t * <p>Will return the first match.\n\t * @param value constant value to look up\n\t * @param nameSuffix suffix of the constant names to search (may be {@code null})\n\t * @return the name of the constant field\n\t * @throws ConstantException if the value wasn't found\n\t */\n\tpublic String toCodeForSuffix(Object value, @Nullable String nameSuffix) throws ConstantException {\n\t\tString suffixToUse = (nameSuffix != null ? nameSuffix.trim().toUpperCase(Locale.ENGLISH) : \"\");\n\t\tfor (Map.Entry<String, Object> entry : this.fieldCache.entrySet()) {\n\t\t\tif (entry.getKey().endsWith(suffixToUse) && entry.getValue().equals(value)) {\n\t\t\t\treturn entry.getKey();\n\t\t\t}\n\t\t}\n\t\tthrow new ConstantException(this.className, suffixToUse, value);\n\t}\n\n\n\t/**\n\t * Convert the given bean property name to a constant name prefix.\n\t * <p>Uses a common naming idiom: turning all lower case characters to\n\t * upper case, and prepending upper case characters with an underscore.\n\t * <p>Example: \"imageSize\" &rarr; \"IMAGE_SIZE\"<br>\n\t * Example: \"imagesize\" &rarr; \"IMAGESIZE\".<br>\n\t * Example: \"ImageSize\" &rarr; \"_IMAGE_SIZE\".<br>\n\t * Example: \"IMAGESIZE\" &rarr; \"_I_M_A_G_E_S_I_Z_E\"\n\t * @param propertyName the name of the bean property\n\t * @return the corresponding constant name prefix\n\t * @see #getValuesForProperty\n\t * @see #toCodeForProperty\n\t */\n\tpublic String propertyToConstantNamePrefix(String propertyName) {\n\t\tStringBuilder parsedPrefix = new StringBuilder();\n\t\tfor (int i = 0; i < propertyName.length(); i++) {\n\t\t\tchar c = propertyName.charAt(i);\n\t\t\tif (Character.isUpperCase(c)) {\n\t\t\t\tparsedPrefix.append('_');\n\t\t\t\tparsedPrefix.append(c);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparsedPrefix.append(Character.toUpperCase(c));\n\t\t\t}\n\t\t}\n\t\treturn parsedPrefix.toString();\n\t}\n\n\n\t/**\n\t * Exception thrown when the {@link Constants} class is asked for\n\t * an invalid constant name.\n\t */\n\t@SuppressWarnings(\"serial\")\n\tpublic static class ConstantException extends IllegalArgumentException {\n\n\t\t/**\n\t\t * Thrown when an invalid constant name is requested.\n\t\t * @param className name of the class containing the constant definitions\n\t\t * @param field invalid constant name\n\t\t * @param message description of the problem\n\t\t */\n\t\tpublic ConstantException(String className, String field, String message) {\n\t\t\tsuper(\"Field '\" + field + \"' \" + message + \" in class [\" + className + \"]\");\n\t\t}\n\n\t\t/**\n\t\t * Thrown when an invalid constant value is looked up.\n\t\t * @param className name of the class containing the constant definitions\n\t\t * @param namePrefix prefix of the searched constant names\n\t\t * @param value the looked up constant value\n\t\t */\n\t\tpublic ConstantException(String className, String namePrefix, Object value) {\n\t\t\tsuper(\"No '\" + namePrefix + \"' field with value '\" + value + \"' found in class [\" + className + \"]\");\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.ConstantException",
    "headType": "class",
    "relation": "extend",
    "tail": "IllegalArgumentException",
    "tailType": "class"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.Conventions",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.Conventions",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.util.Collection;\nimport java.util.Iterator;\n\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\n\n/**\n * Provides methods to support various naming and other conventions used\n * throughout the framework. Mainly for internal use within the framework.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @author Rossen Stoyanchev\n * @since 2.0\n */\npublic final class Conventions {\n\n\t/**\n\t * Suffix added to names when using arrays.\n\t */\n\tprivate static final String PLURAL_SUFFIX = \"List\";\n\n\n\tprivate Conventions() {\n\t}\n\n\n\t/**\n\t * Determine the conventional variable name for the supplied {@code Object}\n\t * based on its concrete type. The convention used is to return the\n\t * un-capitalized short name of the {@code Class}, according to JavaBeans\n\t * property naming rules.\n\t * <p>For example:<br>\n\t * {@code com.myapp.Product} becomes {@code \"product\"}<br>\n\t * {@code com.myapp.MyProduct} becomes {@code \"myProduct\"}<br>\n\t * {@code com.myapp.UKProduct} becomes {@code \"UKProduct\"}<br>\n\t * <p>For arrays the pluralized version of the array component type is used.\n\t * For {@code Collection}s an attempt is made to 'peek ahead' to determine\n\t * the component type and return its pluralized version.\n\t * @param value the value to generate a variable name for\n\t * @return the generated variable name\n\t */\n\tpublic static String getVariableName(Object value) {\n\t\tAssert.notNull(value, \"Value must not be null\");\n\t\tClass<?> valueClass;\n\t\tboolean pluralize = false;\n\n\t\tif (value.getClass().isArray()) {\n\t\t\tvalueClass = value.getClass().componentType();\n\t\t\tpluralize = true;\n\t\t}\n\t\telse if (value instanceof Collection<?> collection) {\n\t\t\tif (collection.isEmpty()) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Cannot generate variable name for an empty Collection\");\n\t\t\t}\n\t\t\tObject valueToCheck = peekAhead(collection);\n\t\t\tvalueClass = getClassForValue(valueToCheck);\n\t\t\tpluralize = true;\n\t\t}\n\t\telse {\n\t\t\tvalueClass = getClassForValue(value);\n\t\t}\n\n\t\tString name = ClassUtils.getShortNameAsProperty(valueClass);\n\t\treturn (pluralize ? pluralize(name) : name);\n\t}\n\n\t/**\n\t * Determine the conventional variable name for the given parameter taking\n\t * the generic collection type, if any, into account.\n\t * <p>As of 5.0 this method supports reactive types:<br>\n\t * {@code Mono<com.myapp.Product>} becomes {@code \"productMono\"}<br>\n\t * {@code Flux<com.myapp.MyProduct>} becomes {@code \"myProductFlux\"}<br>\n\t * {@code Observable<com.myapp.MyProduct>} becomes {@code \"myProductObservable\"}<br>\n\t * @param parameter the method or constructor parameter\n\t * @return the generated variable name\n\t */\n\tpublic static String getVariableNameForParameter(MethodParameter parameter) {\n\t\tAssert.notNull(parameter, \"MethodParameter must not be null\");\n\t\tClass<?> valueClass;\n\t\tboolean pluralize = false;\n\t\tString reactiveSuffix = \"\";\n\n\t\tif (parameter.getParameterType().isArray()) {\n\t\t\tvalueClass = parameter.getParameterType().componentType();\n\t\t\tpluralize = true;\n\t\t}\n\t\telse if (Collection.class.isAssignableFrom(parameter.getParameterType())) {\n\t\t\tvalueClass = ResolvableType.forMethodParameter(parameter).asCollection().resolveGeneric();\n\t\t\tif (valueClass == null) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Cannot generate variable name for non-typed Collection parameter type\");\n\t\t\t}\n\t\t\tpluralize = true;\n\t\t}\n\t\telse {\n\t\t\tvalueClass = parameter.getParameterType();\n\t\t\tReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(valueClass);\n\t\t\tif (adapter != null && !adapter.getDescriptor().isNoValue()) {\n\t\t\t\treactiveSuffix = ClassUtils.getShortName(valueClass);\n\t\t\t\tvalueClass = parameter.nested().getNestedParameterType();\n\t\t\t}\n\t\t}\n\n\t\tString name = ClassUtils.getShortNameAsProperty(valueClass);\n\t\treturn (pluralize ? pluralize(name) : name + reactiveSuffix);\n\t}\n\n\t/**\n\t * Determine the conventional variable name for the return type of the\n\t * given method, taking the generic collection type, if any, into account.\n\t * @param method the method to generate a variable name for\n\t * @return the generated variable name\n\t */\n\tpublic static String getVariableNameForReturnType(Method method) {\n\t\treturn getVariableNameForReturnType(method, method.getReturnType(), null);\n\t}\n\n\t/**\n\t * Determine the conventional variable name for the return type of the given\n\t * method, taking the generic collection type, if any, into account, falling\n\t * back on the given actual return value if the method declaration is not\n\t * specific enough, for example, {@code Object} return type or untyped collection.\n\t * @param method the method to generate a variable name for\n\t * @param value the return value (may be {@code null} if not available)\n\t * @return the generated variable name\n\t */\n\tpublic static String getVariableNameForReturnType(Method method, @Nullable Object value) {\n\t\treturn getVariableNameForReturnType(method, method.getReturnType(), value);\n\t}\n\n\t/**\n\t * Determine the conventional variable name for the return type of the given\n\t * method, taking the generic collection type, if any, into account, falling\n\t * back on the given return value if the method declaration is not specific\n\t * enough, for example, {@code Object} return type or untyped collection.\n\t * <p>As of 5.0 this method supports reactive types:<br>\n\t * {@code Mono<com.myapp.Product>} becomes {@code \"productMono\"}<br>\n\t * {@code Flux<com.myapp.MyProduct>} becomes {@code \"myProductFlux\"}<br>\n\t * {@code Observable<com.myapp.MyProduct>} becomes {@code \"myProductObservable\"}<br>\n\t * @param method the method to generate a variable name for\n\t * @param resolvedType the resolved return type of the method\n\t * @param value the return value (may be {@code null} if not available)\n\t * @return the generated variable name\n\t */\n\tpublic static String getVariableNameForReturnType(Method method, Class<?> resolvedType, @Nullable Object value) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\n\t\tif (Object.class == resolvedType) {\n\t\t\tAssert.notNull(value, \"Cannot generate variable name for an Object return type with null value\");\n\t\t\treturn getVariableName(value);\n\t\t}\n\n\t\tClass<?> valueClass;\n\t\tboolean pluralize = false;\n\t\tString reactiveSuffix = \"\";\n\n\t\tif (resolvedType.isArray()) {\n\t\t\tvalueClass = resolvedType.componentType();\n\t\t\tpluralize = true;\n\t\t}\n\t\telse if (Collection.class.isAssignableFrom(resolvedType)) {\n\t\t\tvalueClass = ResolvableType.forMethodReturnType(method).asCollection().resolveGeneric();\n\t\t\tif (valueClass == null) {\n\t\t\t\tif (!(value instanceof Collection<?> collection)) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Cannot generate variable name \" +\n\t\t\t\t\t\t\t\"for non-typed Collection return type and a non-Collection value\");\n\t\t\t\t}\n\t\t\t\tif (collection.isEmpty()) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Cannot generate variable name \" +\n\t\t\t\t\t\t\t\"for non-typed Collection return type and an empty Collection value\");\n\t\t\t\t}\n\t\t\t\tObject valueToCheck = peekAhead(collection);\n\t\t\t\tvalueClass = getClassForValue(valueToCheck);\n\t\t\t}\n\t\t\tpluralize = true;\n\t\t}\n\t\telse {\n\t\t\tvalueClass = resolvedType;\n\t\t\tReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(valueClass);\n\t\t\tif (adapter != null && !adapter.getDescriptor().isNoValue()) {\n\t\t\t\treactiveSuffix = ClassUtils.getShortName(valueClass);\n\t\t\t\tvalueClass = ResolvableType.forMethodReturnType(method).getGeneric().toClass();\n\t\t\t}\n\t\t}\n\n\t\tString name = ClassUtils.getShortNameAsProperty(valueClass);\n\t\treturn (pluralize ? pluralize(name) : name + reactiveSuffix);\n\t}\n\n\t/**\n\t * Convert {@code String}s in attribute name format (for example, lowercase, hyphens\n\t * separating words) into property name format (camel-case). For example\n\t * {@code transaction-manager} becomes {@code \"transactionManager\"}.\n\t */\n\tpublic static String attributeNameToPropertyName(String attributeName) {\n\t\tAssert.notNull(attributeName, \"'attributeName' must not be null\");\n\t\tif (!attributeName.contains(\"-\")) {\n\t\t\treturn attributeName;\n\t\t}\n\t\tchar[] result = new char[attributeName.length() -1]; // not completely accurate but good guess\n\t\tint currPos = 0;\n\t\tboolean upperCaseNext = false;\n\t\tfor (int i = 0; i < attributeName.length(); i++ ) {\n\t\t\tchar c = attributeName.charAt(i);\n\t\t\tif (c == '-') {\n\t\t\t\tupperCaseNext = true;\n\t\t\t}\n\t\t\telse if (upperCaseNext) {\n\t\t\t\tresult[currPos++] = Character.toUpperCase(c);\n\t\t\t\tupperCaseNext = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult[currPos++] = c;\n\t\t\t}\n\t\t}\n\t\treturn new String(result, 0, currPos);\n\t}\n\n\t/**\n\t * Return an attribute name qualified by the given enclosing {@link Class}.\n\t * For example the attribute name '{@code foo}' qualified by {@link Class}\n\t * '{@code com.myapp.SomeClass}' would be '{@code com.myapp.SomeClass.foo}'\n\t */\n\tpublic static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName) {\n\t\tAssert.notNull(enclosingClass, \"'enclosingClass' must not be null\");\n\t\tAssert.notNull(attributeName, \"'attributeName' must not be null\");\n\t\treturn enclosingClass.getName() + '.' + attributeName;\n\t}\n\n\n\t/**\n\t * Determine the class to use for naming a variable containing the given value.\n\t * <p>Will return the class of the given value, except when encountering a\n\t * JDK proxy, in which case it will determine the 'primary' interface\n\t * implemented by that proxy.\n\t * @param value the value to check\n\t * @return the class to use for naming a variable\n\t */\n\tprivate static Class<?> getClassForValue(Object value) {\n\t\tClass<?> valueClass = value.getClass();\n\t\tif (Proxy.isProxyClass(valueClass)) {\n\t\t\tClass<?>[] ifcs = valueClass.getInterfaces();\n\t\t\tfor (Class<?> ifc : ifcs) {\n\t\t\t\tif (!ClassUtils.isJavaLanguageInterface(ifc)) {\n\t\t\t\t\treturn ifc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (valueClass.getName().lastIndexOf('$') != -1 && valueClass.getDeclaringClass() == null) {\n\t\t\t// '$' in the class name but no inner class -\n\t\t\t// assuming it's a special subclass (for example, by OpenJPA)\n\t\t\tvalueClass = valueClass.getSuperclass();\n\t\t}\n\t\treturn valueClass;\n\t}\n\n\t/**\n\t * Pluralize the given name.\n\t */\n\tprivate static String pluralize(String name) {\n\t\treturn name + PLURAL_SUFFIX;\n\t}\n\n\t/**\n\t * Retrieve the {@code Class} of an element in the {@code Collection}.\n\t * The exact element for which the {@code Class} is retrieved will depend\n\t * on the concrete {@code Collection} implementation.\n\t */\n\tprivate static <E> E peekAhead(Collection<E> collection) {\n\t\tIterator<E> it = collection.iterator();\n\t\tif (!it.hasNext()) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Unable to peek ahead in non-empty collection - no element found\");\n\t\t}\n\t\tE value = it.next();\n\t\tif (value == null) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Unable to peek ahead in non-empty collection - only null element found\");\n\t\t}\n\t\treturn value;\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.Conventions",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.Conventions#PLURAL_SUFFIX",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.Conventions#PLURAL_SUFFIX",
    "headType": "field",
    "relation": "haveType",
    "tail": "String",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.Conventions#getVariableName(Object)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Determine the conventional variable name for the supplied {@code Object}\r\n * based on its concrete type. The convention used is to return the\r\n * un-capitalized short name of the {@code Class}, according to JavaBeans\r\n * property naming rules.\r\n * <p>For example:<br>\r\n * {@code com.myapp.Product} becomes {@code \"product\"}<br>\r\n * {@code com.myapp.MyProduct} becomes {@code \"myProduct\"}<br>\r\n * {@code com.myapp.UKProduct} becomes {@code \"UKProduct\"}<br>\r\n * <p>For arrays the pluralized version of the array component type is used.\r\n * For {@code Collection}s an attempt is made to 'peek ahead' to determine\r\n * the component type and return its pluralized version.\r\n * @param value the value to generate a variable name for\r\n * @return the generated variable name\r\n */\r\npublic static String getVariableName(Object value) {\r\n    Assert.notNull(value, \"Value must not be null\");\r\n    Class<?> valueClass;\r\n    boolean pluralize = false;\r\n    if (value.getClass().isArray()) {\r\n        valueClass = value.getClass().componentType();\r\n        pluralize = true;\r\n    } else if (value instanceof Collection<?> collection) {\r\n        if (collection.isEmpty()) {\r\n            throw new IllegalArgumentException(\"Cannot generate variable name for an empty Collection\");\r\n        }\r\n        Object valueToCheck = peekAhead(collection);\r\n        valueClass = getClassForValue(valueToCheck);\r\n        pluralize = true;\r\n    } else {\r\n        valueClass = getClassForValue(value);\r\n    }\r\n    String name = ClassUtils.getShortNameAsProperty(valueClass);\r\n    return (pluralize ? pluralize(name) : name);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.Conventions",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.Conventions#getVariableName(Object)",
    "tailType": "method"
  }
]