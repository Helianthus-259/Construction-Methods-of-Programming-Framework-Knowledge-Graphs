[
  {
    "head": "org.springframework.core.annotation.AnnotationUtils",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotationUtils#findAnnotation(AnnotatedElement,Class<A>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils#findAnnotation(AnnotatedElement,Class<A>)",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils#findAnnotation(Method,Class<A>)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Find a single {@link Annotation} of {@code annotationType} on the supplied\r\n * {@link Method}, traversing its super methods (i.e. from superclasses and\r\n * interfaces) if the annotation is not <em>directly present</em> on the given\r\n * method itself.\r\n * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.\r\n * <p>Meta-annotations will be searched if the annotation is not\r\n * <em>directly present</em> on the method.\r\n * <p>Annotations on methods are not inherited by default, so we need to handle\r\n * this explicitly.\r\n * @param method the method to look for annotations on\r\n * @param annotationType the annotation type to look for\r\n * @return the first matching annotation, or {@code null} if not found\r\n * @see #getAnnotation(Method, Class)\r\n */\r\n@Nullable\r\npublic static <A extends Annotation> A findAnnotation(Method method, @Nullable Class<A> annotationType) {\r\n    if (annotationType == null) {\r\n        return null;\r\n    }\r\n    // Shortcut: directly present on the element, with no merging needed?\r\n    if (AnnotationFilter.PLAIN.matches(annotationType) || AnnotationsScanner.hasPlainJavaAnnotationsOnly(method)) {\r\n        return method.getDeclaredAnnotation(annotationType);\r\n    }\r\n    // Exhaustive retrieval of merged annotations...\r\n    return MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none()).get(annotationType).withNonMergedAttributes().synthesize(MergedAnnotation::isPresent).orElse(null);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotationUtils#findAnnotation(Method,Class<A>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils#findAnnotation(Method,Class<A>)",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils#findAnnotation(Class<?>,Class<A>)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Find a single {@link Annotation} of {@code annotationType} on the\r\n * supplied {@link Class}, traversing its interfaces, annotations, and\r\n * superclasses if the annotation is not <em>directly present</em> on\r\n * the given class itself.\r\n * <p>This method explicitly handles class-level annotations which are not\r\n * declared as {@link java.lang.annotation.Inherited inherited} <em>as well\r\n * as meta-annotations and annotations on interfaces</em>.\r\n * <p>The algorithm operates as follows:\r\n * <ol>\r\n * <li>Search for the annotation on the given class and return it if found.\r\n * <li>Recursively search through all annotations that the given class declares.\r\n * <li>Recursively search through all interfaces that the given class declares.\r\n * <li>Recursively search through the superclass hierarchy of the given class.\r\n * </ol>\r\n * <p>Note: in this context, the term <em>recursively</em> means that the search\r\n * process continues by returning to step #1 with the current interface,\r\n * annotation, or superclass as the class to look for annotations on.\r\n * @param clazz the class to look for annotations on\r\n * @param annotationType the type of annotation to look for\r\n * @return the first matching annotation, or {@code null} if not found\r\n */\r\n@Nullable\r\npublic static <A extends Annotation> A findAnnotation(Class<?> clazz, @Nullable Class<A> annotationType) {\r\n    if (annotationType == null) {\r\n        return null;\r\n    }\r\n    // Shortcut: directly present on the element, with no merging needed?\r\n    if (AnnotationFilter.PLAIN.matches(annotationType) || AnnotationsScanner.hasPlainJavaAnnotationsOnly(clazz)) {\r\n        A annotation = clazz.getDeclaredAnnotation(annotationType);\r\n        if (annotation != null) {\r\n            return annotation;\r\n        }\r\n        // For backwards compatibility, perform a superclass search with plain annotations\r\n        // even if not marked as @Inherited: for example, a findAnnotation search for @Deprecated\r\n        Class<?> superclass = clazz.getSuperclass();\r\n        if (superclass == null || superclass == Object.class) {\r\n            return null;\r\n        }\r\n        return findAnnotation(superclass, annotationType);\r\n    }\r\n    // Exhaustive retrieval of merged annotations...\r\n    return MergedAnnotations.from(clazz, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none()).get(annotationType).withNonMergedAttributes().synthesize(MergedAnnotation::isPresent).orElse(null);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotationUtils#findAnnotation(Class<?>,Class<A>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils#findAnnotation(Class<?>,Class<A>)",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils#findAnnotationDeclaringClass(Class<? extends Annotation>,Class<?>)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Find the first {@link Class} in the inheritance hierarchy of the\r\n * specified {@code clazz} (including the specified {@code clazz} itself)\r\n * on which an annotation of the specified {@code annotationType} is\r\n * <em>directly present</em>.\r\n * <p>If the supplied {@code clazz} is an interface, only the interface\r\n * itself will be checked; the inheritance hierarchy for interfaces will\r\n * not be traversed.\r\n * <p>Meta-annotations will <em>not</em> be searched.\r\n * <p>The standard {@link Class} API does not provide a mechanism for\r\n * determining which class in an inheritance hierarchy actually declares\r\n * an {@link Annotation}, so we need to handle this explicitly.\r\n * @param annotationType the annotation type to look for\r\n * @param clazz the class to check for the annotation on (may be {@code null})\r\n * @return the first {@link Class} in the inheritance hierarchy that\r\n * declares an annotation of the specified {@code annotationType},\r\n * or {@code null} if not found\r\n * @see Class#isAnnotationPresent(Class)\r\n * @see Class#getDeclaredAnnotations()\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\n@Nullable\r\npublic static Class<?> findAnnotationDeclaringClass(Class<? extends Annotation> annotationType, @Nullable Class<?> clazz) {\r\n    if (clazz == null) {\r\n        return null;\r\n    }\r\n    return (Class<?>) MergedAnnotations.from(clazz, SearchStrategy.SUPERCLASS).get(annotationType, MergedAnnotation::isDirectlyPresent).getSource();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotationUtils#findAnnotationDeclaringClass(Class<? extends Annotation>,Class<?>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils#findAnnotationDeclaringClass(Class<? extends Annotation>,Class<?>)",
    "headType": "method",
    "relation": "use",
    "tail": "@Deprecated",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils#findAnnotationDeclaringClass(Class<? extends Annotation>,Class<?>)",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils#findAnnotationDeclaringClassForTypes(List<Class<? extends Annotation>>,Class<?>)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Find the first {@link Class} in the inheritance hierarchy of the\r\n * specified {@code clazz} (including the specified {@code clazz} itself)\r\n * on which at least one of the specified {@code annotationTypes} is\r\n * <em>directly present</em>.\r\n * <p>If the supplied {@code clazz} is an interface, only the interface\r\n * itself will be checked; the inheritance hierarchy for interfaces will\r\n * not be traversed.\r\n * <p>Meta-annotations will <em>not</em> be searched.\r\n * <p>The standard {@link Class} API does not provide a mechanism for\r\n * determining which class in an inheritance hierarchy actually declares\r\n * one of several candidate {@linkplain Annotation annotations}, so we\r\n * need to handle this explicitly.\r\n * @param annotationTypes the annotation types to look for\r\n * @param clazz the class to check for the annotation on (may be {@code null})\r\n * @return the first {@link Class} in the inheritance hierarchy that\r\n * declares an annotation of at least one of the specified\r\n * {@code annotationTypes}, or {@code null} if not found\r\n * @since 3.2.2\r\n * @see Class#isAnnotationPresent(Class)\r\n * @see Class#getDeclaredAnnotations()\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\n@Nullable\r\npublic static Class<?> findAnnotationDeclaringClassForTypes(List<Class<? extends Annotation>> annotationTypes, @Nullable Class<?> clazz) {\r\n    if (clazz == null) {\r\n        return null;\r\n    }\r\n    MergedAnnotation<?> merged = MergedAnnotations.from(clazz, SearchStrategy.SUPERCLASS).stream().filter(MergedAnnotationPredicates.typeIn(annotationTypes).and(MergedAnnotation::isDirectlyPresent)).findFirst().orElse(null);\r\n    return (merged != null && merged.getSource() instanceof Class<?> sourceClass ? sourceClass : null);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotationUtils#findAnnotationDeclaringClassForTypes(List<Class<? extends Annotation>>,Class<?>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils#findAnnotationDeclaringClassForTypes(List<Class<? extends Annotation>>,Class<?>)",
    "headType": "method",
    "relation": "use",
    "tail": "@Deprecated",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils#findAnnotationDeclaringClassForTypes(List<Class<? extends Annotation>>,Class<?>)",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils#isAnnotationDeclaredLocally(Class<? extends Annotation>,Class<?>)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Determine whether an annotation of the specified {@code annotationType}\r\n * is declared locally (i.e. <em>directly present</em>) on the supplied\r\n * {@code clazz}.\r\n * <p>The supplied {@link Class} may represent any type.\r\n * <p>Meta-annotations will <em>not</em> be searched.\r\n * <p>Note: This method does <strong>not</strong> determine if the annotation\r\n * is {@linkplain java.lang.annotation.Inherited inherited}.\r\n * @param annotationType the annotation type to look for\r\n * @param clazz the class to check for the annotation on\r\n * @return {@code true} if an annotation of the specified {@code annotationType}\r\n * is <em>directly present</em>\r\n * @see java.lang.Class#getDeclaredAnnotations()\r\n * @see java.lang.Class#getDeclaredAnnotation(Class)\r\n */\r\npublic static boolean isAnnotationDeclaredLocally(Class<? extends Annotation> annotationType, Class<?> clazz) {\r\n    return MergedAnnotations.from(clazz).get(annotationType).isDirectlyPresent();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotationUtils#isAnnotationDeclaredLocally(Class<? extends Annotation>,Class<?>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils#isAnnotationInherited(Class<? extends Annotation>,Class<?>)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Determine whether an annotation of the specified {@code annotationType}\r\n * is <em>present</em> on the supplied {@code clazz} and is\r\n * {@linkplain java.lang.annotation.Inherited inherited}\r\n * (i.e. not <em>directly present</em>).\r\n * <p>Meta-annotations will <em>not</em> be searched.\r\n * <p>If the supplied {@code clazz} is an interface, only the interface\r\n * itself will be checked. In accordance with standard meta-annotation\r\n * semantics in Java, the inheritance hierarchy for interfaces will not\r\n * be traversed. See the {@linkplain java.lang.annotation.Inherited javadoc}\r\n * for the {@code @Inherited} meta-annotation for further details regarding\r\n * annotation inheritance.\r\n * @param annotationType the annotation type to look for\r\n * @param clazz the class to check for the annotation on\r\n * @return {@code true} if an annotation of the specified {@code annotationType}\r\n * is <em>present</em> and <em>inherited</em>\r\n * @see Class#isAnnotationPresent(Class)\r\n * @see #isAnnotationDeclaredLocally(Class, Class)\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\npublic static boolean isAnnotationInherited(Class<? extends Annotation> annotationType, Class<?> clazz) {\r\n    return MergedAnnotations.from(clazz, SearchStrategy.INHERITED_ANNOTATIONS).stream(annotationType).filter(MergedAnnotation::isDirectlyPresent).findFirst().orElseGet(MergedAnnotation::missing).getAggregateIndex() > 0;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotationUtils#isAnnotationInherited(Class<? extends Annotation>,Class<?>)",
    "tailType": "method"
  }
]