[
  {
    "head": "org.springframework.util.backoff.FixedBackOff#start()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic BackOffExecution start() {\r\n    return new FixedBackOffExecution();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.backoff.FixedBackOff",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.backoff.FixedBackOff#start()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.backoff.FixedBackOff#start()",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.backoff",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.backoff.FixedBackOffExecution",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.backoff.FixedBackOffExecution",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2018 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util.backoff;\n\n/**\n * A simple {@link BackOff} implementation that provides a fixed interval\n * between two attempts and a maximum number of retries.\n *\n * @author Stephane Nicoll\n * @since 4.1\n */\npublic class FixedBackOff implements BackOff {\n\n\t/**\n\t * The default recovery interval: 5000 ms = 5 seconds.\n\t */\n\tpublic static final long DEFAULT_INTERVAL = 5000;\n\n\t/**\n\t * Constant value indicating an unlimited number of attempts.\n\t */\n\tpublic static final long UNLIMITED_ATTEMPTS = Long.MAX_VALUE;\n\n\tprivate long interval = DEFAULT_INTERVAL;\n\n\tprivate long maxAttempts = UNLIMITED_ATTEMPTS;\n\n\n\t/**\n\t * Create an instance with an interval of {@value #DEFAULT_INTERVAL}\n\t * ms and an unlimited number of attempts.\n\t */\n\tpublic FixedBackOff() {\n\t}\n\n\t/**\n\t * Create an instance.\n\t * @param interval the interval between two attempts\n\t * @param maxAttempts the maximum number of attempts\n\t */\n\tpublic FixedBackOff(long interval, long maxAttempts) {\n\t\tthis.interval = interval;\n\t\tthis.maxAttempts = maxAttempts;\n\t}\n\n\n\t/**\n\t * Set the interval between two attempts in milliseconds.\n\t */\n\tpublic void setInterval(long interval) {\n\t\tthis.interval = interval;\n\t}\n\n\t/**\n\t * Return the interval between two attempts in milliseconds.\n\t */\n\tpublic long getInterval() {\n\t\treturn this.interval;\n\t}\n\n\t/**\n\t * Set the maximum number of attempts in milliseconds.\n\t */\n\tpublic void setMaxAttempts(long maxAttempts) {\n\t\tthis.maxAttempts = maxAttempts;\n\t}\n\n\t/**\n\t * Return the maximum number of attempts in milliseconds.\n\t */\n\tpublic long getMaxAttempts() {\n\t\treturn this.maxAttempts;\n\t}\n\n\t@Override\n\tpublic BackOffExecution start() {\n\t\treturn new FixedBackOffExecution();\n\t}\n\n\n\tprivate class FixedBackOffExecution implements BackOffExecution {\n\n\t\tprivate long currentAttempts = 0;\n\n\t\t@Override\n\t\tpublic long nextBackOff() {\n\t\t\tthis.currentAttempts++;\n\t\t\tif (this.currentAttempts <= getMaxAttempts()) {\n\t\t\t\treturn getInterval();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn STOP;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tString attemptValue = (FixedBackOff.this.maxAttempts == Long.MAX_VALUE ?\n\t\t\t\t\t\"unlimited\" : String.valueOf(FixedBackOff.this.maxAttempts));\n\t\t\treturn \"FixedBackOff{interval=\" + FixedBackOff.this.interval +\n\t\t\t\t\t\", currentAttempts=\" + this.currentAttempts +\n\t\t\t\t\t\", maxAttempts=\" + attemptValue +\n\t\t\t\t\t'}';\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.backoff.FixedBackOffExecution",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.backoff.FixedBackOffExecution#currentAttempts",
    "tailType": "field"
  },
  {
    "head": "org.springframework.util.backoff.FixedBackOffExecution#currentAttempts",
    "headType": "field",
    "relation": "haveType",
    "tail": "long",
    "tailType": "type"
  },
  {
    "head": "org.springframework.util.backoff.FixedBackOffExecution#nextBackOff()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic long nextBackOff() {\r\n    this.currentAttempts++;\r\n    if (this.currentAttempts <= getMaxAttempts()) {\r\n        return getInterval();\r\n    } else {\r\n        return STOP;\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.backoff.FixedBackOffExecution",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.backoff.FixedBackOffExecution#nextBackOff()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.backoff.FixedBackOffExecution#nextBackOff()",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.backoff.FixedBackOffExecution#toString()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic String toString() {\r\n    String attemptValue = (FixedBackOff.this.maxAttempts == Long.MAX_VALUE ? \"unlimited\" : String.valueOf(FixedBackOff.this.maxAttempts));\r\n    return \"FixedBackOff{interval=\" + FixedBackOff.this.interval + \", currentAttempts=\" + this.currentAttempts + \", maxAttempts=\" + attemptValue + '}';\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.backoff.FixedBackOffExecution",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.backoff.FixedBackOffExecution#toString()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.backoff.FixedBackOffExecution#toString()",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.util.backoff",
    "tailType": "package"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.util",
    "tailType": "package"
  },
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.ClassUtils",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.ClassUtils",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.io.Closeable;\nimport java.io.Externalizable;\nimport java.io.File;\nimport java.io.Serializable;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Proxy;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.Path;\nimport java.time.ZoneId;\nimport java.time.temporal.Temporal;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.StringJoiner;\nimport java.util.TimeZone;\nimport java.util.UUID;\nimport java.util.regex.Pattern;\n\nimport org.jspecify.annotations.Nullable;\n\n/**\n * Miscellaneous {@code java.lang.Class} utility methods.\n *\n * <p>Mainly for internal use within the framework.\n *\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @author Sam Brannen\n * @author Sebastien Deleuze\n * @author Sungbin Yang\n * @since 1.1\n * @see TypeUtils\n * @see ReflectionUtils\n */\npublic abstract class ClassUtils {\n\n\t/** Suffix for array class names: {@code \"[]\"}. */\n\tpublic static final String ARRAY_SUFFIX = \"[]\";\n\n\t/** A reusable empty class array constant. */\n\tprivate static final Class<?>[] EMPTY_CLASS_ARRAY = {};\n\n\t/** The package separator character: {@code '.'}. */\n\tprivate static final char PACKAGE_SEPARATOR = '.';\n\n\t/** The path separator character: {@code '/'}. */\n\tprivate static final char PATH_SEPARATOR = '/';\n\n\t/** The nested class separator character: {@code '$'}. */\n\tprivate static final char NESTED_CLASS_SEPARATOR = '$';\n\n\t/** The CGLIB class separator: {@code \"$$\"}. */\n\tpublic static final String CGLIB_CLASS_SEPARATOR = \"$$\";\n\n\t/** The \".class\" file suffix. */\n\tpublic static final String CLASS_FILE_SUFFIX = \".class\";\n\n\t/** Precomputed value for the combination of private, static and final modifiers. */\n\tprivate static final int NON_OVERRIDABLE_MODIFIER = Modifier.PRIVATE | Modifier.STATIC | Modifier.FINAL;\n\n\t/** Precomputed value for the combination of public and protected modifiers. */\n\tprivate static final int OVERRIDABLE_MODIFIER = Modifier.PUBLIC | Modifier.PROTECTED;\n\n\n\t/**\n\t * Map with primitive wrapper type as key and corresponding primitive\n\t * type as value, for example: {@code Integer.class -> int.class}.\n\t */\n\tprivate static final Map<Class<?>, Class<?>> primitiveWrapperTypeMap = new IdentityHashMap<>(9);\n\n\t/**\n\t * Map with primitive type as key and corresponding wrapper\n\t * type as value, for example: {@code int.class -> Integer.class}.\n\t */\n\tprivate static final Map<Class<?>, Class<?>> primitiveTypeToWrapperMap = new IdentityHashMap<>(9);\n\n\t/**\n\t * Map with primitive type name as key and corresponding primitive\n\t * type as value, for example: {@code \"int\" -> int.class}.\n\t */\n\tprivate static final Map<String, Class<?>> primitiveTypeNameMap = new HashMap<>(32);\n\n\t/**\n\t * Map with common Java language class name as key and corresponding Class as value.\n\t * Primarily for efficient deserialization of remote invocations.\n\t */\n\tprivate static final Map<String, Class<?>> commonClassCache = new HashMap<>(64);\n\n\t/**\n\t * Common Java language interfaces which are supposed to be ignored\n\t * when searching for 'primary' user-level interfaces.\n\t */\n\tprivate static final Set<Class<?>> javaLanguageInterfaces;\n\n\t/**\n\t * Cache for equivalent methods on a interface implemented by the declaring class.\n\t * <p>A {@code null} value signals that no interface method was found for the key.\n\t */\n\tprivate static final Map<Method, Method> interfaceMethodCache = new ConcurrentReferenceHashMap<>(256);\n\n\t/**\n\t * Cache for equivalent methods on a public interface implemented by the declaring class.\n\t * <p>A {@code null} value signals that no public interface method was found for the key.\n\t * @since 6.2\n\t */\n\tprivate static final Map<Method, Method> publicInterfaceMethodCache = new ConcurrentReferenceHashMap<>(256);\n\n\t/**\n\t * Cache for equivalent public methods in a public declaring type within the type hierarchy\n\t * of the method's declaring class.\n\t * <p>A {@code null} value signals that no publicly accessible method was found for the key.\n\t * @since 6.2\n\t */\n\tprivate static final Map<Method, Method> publiclyAccessibleMethodCache = new ConcurrentReferenceHashMap<>(256);\n\n\n\tstatic {\n\t\tprimitiveWrapperTypeMap.put(Boolean.class, boolean.class);\n\t\tprimitiveWrapperTypeMap.put(Byte.class, byte.class);\n\t\tprimitiveWrapperTypeMap.put(Character.class, char.class);\n\t\tprimitiveWrapperTypeMap.put(Double.class, double.class);\n\t\tprimitiveWrapperTypeMap.put(Float.class, float.class);\n\t\tprimitiveWrapperTypeMap.put(Integer.class, int.class);\n\t\tprimitiveWrapperTypeMap.put(Long.class, long.class);\n\t\tprimitiveWrapperTypeMap.put(Short.class, short.class);\n\t\tprimitiveWrapperTypeMap.put(Void.class, void.class);\n\n\t\t// Map entry iteration is less expensive to initialize than forEach with lambdas\n\t\tfor (Map.Entry<Class<?>, Class<?>> entry : primitiveWrapperTypeMap.entrySet()) {\n\t\t\tprimitiveTypeToWrapperMap.put(entry.getValue(), entry.getKey());\n\t\t\tregisterCommonClasses(entry.getKey());\n\t\t}\n\n\t\tSet<Class<?>> primitiveTypes = new HashSet<>(32);\n\t\tprimitiveTypes.addAll(primitiveWrapperTypeMap.values());\n\t\tCollections.addAll(primitiveTypes, boolean[].class, byte[].class, char[].class,\n\t\t\t\tdouble[].class, float[].class, int[].class, long[].class, short[].class);\n\t\tfor (Class<?> primitiveType : primitiveTypes) {\n\t\t\tprimitiveTypeNameMap.put(primitiveType.getName(), primitiveType);\n\t\t}\n\n\t\tregisterCommonClasses(Boolean[].class, Byte[].class, Character[].class, Double[].class,\n\t\t\t\tFloat[].class, Integer[].class, Long[].class, Short[].class);\n\t\tregisterCommonClasses(Number.class, Number[].class, String.class, String[].class,\n\t\t\t\tClass.class, Class[].class, Object.class, Object[].class);\n\t\tregisterCommonClasses(Throwable.class, Exception.class, RuntimeException.class,\n\t\t\t\tError.class, StackTraceElement.class, StackTraceElement[].class);\n\t\tregisterCommonClasses(Enum.class, Iterable.class, Iterator.class, Enumeration.class,\n\t\t\t\tCollection.class, List.class, Set.class, Map.class, Map.Entry.class, Optional.class);\n\n\t\tClass<?>[] javaLanguageInterfaceArray = {Serializable.class, Externalizable.class,\n\t\t\t\tCloseable.class, AutoCloseable.class, Cloneable.class, Comparable.class};\n\t\tregisterCommonClasses(javaLanguageInterfaceArray);\n\t\tjavaLanguageInterfaces = Set.of(javaLanguageInterfaceArray);\n\t}\n\n\n\t/**\n\t * Register the given common classes with the ClassUtils cache.\n\t */\n\tprivate static void registerCommonClasses(Class<?>... commonClasses) {\n\t\tfor (Class<?> clazz : commonClasses) {\n\t\t\tcommonClassCache.put(clazz.getName(), clazz);\n\t\t}\n\t}\n\n\t/**\n\t * Return the default ClassLoader to use: typically the thread context\n\t * ClassLoader, if available; the ClassLoader that loaded the ClassUtils\n\t * class will be used as fallback.\n\t * <p>Call this method if you intend to use the thread context ClassLoader\n\t * in a scenario where you clearly prefer a non-null ClassLoader reference:\n\t * for example, for class path resource loading (but not necessarily for\n\t * {@code Class.forName}, which accepts a {@code null} ClassLoader\n\t * reference as well).\n\t * @return the default ClassLoader (only {@code null} if even the system\n\t * ClassLoader isn't accessible)\n\t * @see Thread#getContextClassLoader()\n\t * @see ClassLoader#getSystemClassLoader()\n\t */\n\tpublic static @Nullable ClassLoader getDefaultClassLoader() {\n\t\tClassLoader cl = null;\n\t\ttry {\n\t\t\tcl = Thread.currentThread().getContextClassLoader();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\t// Cannot access thread context ClassLoader - falling back...\n\t\t}\n\t\tif (cl == null) {\n\t\t\t// No thread context class loader -> use class loader of this class.\n\t\t\tcl = ClassUtils.class.getClassLoader();\n\t\t\tif (cl == null) {\n\t\t\t\t// getClassLoader() returning null indicates the bootstrap ClassLoader\n\t\t\t\ttry {\n\t\t\t\t\tcl = ClassLoader.getSystemClassLoader();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t// Cannot access system ClassLoader - oh well, maybe the caller can live with null...\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cl;\n\t}\n\n\t/**\n\t * Override the thread context ClassLoader with the environment's bean ClassLoader\n\t * if necessary, i.e. if the bean ClassLoader is not equivalent to the thread\n\t * context ClassLoader already.\n\t * @param classLoaderToUse the actual ClassLoader to use for the thread context\n\t * @return the original thread context ClassLoader, or {@code null} if not overridden\n\t */\n\tpublic static @Nullable ClassLoader overrideThreadContextClassLoader(@Nullable ClassLoader classLoaderToUse) {\n\t\tThread currentThread = Thread.currentThread();\n\t\tClassLoader threadContextClassLoader = currentThread.getContextClassLoader();\n\t\tif (classLoaderToUse != null && !classLoaderToUse.equals(threadContextClassLoader)) {\n\t\t\tcurrentThread.setContextClassLoader(classLoaderToUse);\n\t\t\treturn threadContextClassLoader;\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Replacement for {@code Class.forName()} that also returns Class instances\n\t * for primitives (for example, \"int\") and array class names (for example, \"String[]\").\n\t * Furthermore, it is also capable of resolving nested class names in Java source\n\t * style (for example, \"java.lang.Thread.State\" instead of \"java.lang.Thread$State\").\n\t * @param name the name of the Class\n\t * @param classLoader the class loader to use\n\t * (can be {@code null}, which indicates the default class loader)\n\t * @return a class instance for the supplied name\n\t * @throws ClassNotFoundException if the class was not found\n\t * @throws LinkageError if the class file could not be loaded\n\t * @see Class#forName(String, boolean, ClassLoader)\n\t */\n\tpublic static Class<?> forName(String name, @Nullable ClassLoader classLoader)\n\t\t\tthrows ClassNotFoundException, LinkageError {\n\n\t\tAssert.notNull(name, \"Name must not be null\");\n\n\t\tClass<?> clazz = resolvePrimitiveClassName(name);\n\t\tif (clazz == null) {\n\t\t\tclazz = commonClassCache.get(name);\n\t\t}\n\t\tif (clazz != null) {\n\t\t\treturn clazz;\n\t\t}\n\n\t\t// \"java.lang.String[]\" style arrays\n\t\tif (name.endsWith(ARRAY_SUFFIX)) {\n\t\t\tString elementClassName = name.substring(0, name.length() - ARRAY_SUFFIX.length());\n\t\t\tClass<?> elementClass = forName(elementClassName, classLoader);\n\t\t\treturn elementClass.arrayType();\n\t\t}\n\n\t\tClassLoader clToUse = classLoader;\n\t\tif (clToUse == null) {\n\t\t\tclToUse = getDefaultClassLoader();\n\t\t}\n\t\ttry {\n\t\t\treturn Class.forName(name, false, clToUse);\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\tint lastDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR);\n\t\t\tint previousDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR, lastDotIndex - 1);\n\t\t\tif (lastDotIndex != -1 && previousDotIndex != -1 && Character.isUpperCase(name.charAt(previousDotIndex + 1))) {\n\t\t\t\tString nestedClassName =\n\t\t\t\t\t\tname.substring(0, lastDotIndex) + NESTED_CLASS_SEPARATOR + name.substring(lastDotIndex + 1);\n\t\t\t\ttry {\n\t\t\t\t\treturn Class.forName(nestedClassName, false, clToUse);\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException ex2) {\n\t\t\t\t\t// Swallow - let original exception get through\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\t/**\n\t * Resolve the given class name into a Class instance. Supports\n\t * primitives (like \"int\") and array class names (like \"String[]\").\n\t * <p>This is effectively equivalent to the {@code forName}\n\t * method with the same arguments, with the only difference being\n\t * the exceptions thrown in case of class loading failure.\n\t * @param className the name of the Class\n\t * @param classLoader the class loader to use\n\t * (can be {@code null}, which indicates the default class loader)\n\t * @return a class instance for the supplied name\n\t * @throws IllegalArgumentException if the class name was not resolvable\n\t * (that is, the class could not be found or the class file could not be loaded)\n\t * @throws IllegalStateException if the corresponding class is resolvable but there\n\t * was a readability mismatch in the inheritance hierarchy of the class (typically a\n\t * missing dependency declaration in a Java Module System module definition for a\n\t * superclass or interface implemented by the class to be loaded here)\n\t * @see #forName(String, ClassLoader)\n\t */\n\tpublic static Class<?> resolveClassName(String className, @Nullable ClassLoader classLoader)\n\t\t\tthrows IllegalArgumentException {\n\n\t\ttry {\n\t\t\treturn forName(className, classLoader);\n\t\t}\n\t\tcatch (IllegalAccessError err) {\n\t\t\tthrow new IllegalStateException(\"Readability mismatch in inheritance hierarchy of class [\" +\n\t\t\t\t\tclassName + \"]: \" + err.getMessage(), err);\n\t\t}\n\t\tcatch (LinkageError err) {\n\t\t\tthrow new IllegalArgumentException(\"Unresolvable class definition for class [\" + className + \"]\", err);\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\tthrow new IllegalArgumentException(\"Could not find class [\" + className + \"]\", ex);\n\t\t}\n\t}\n\n\t/**\n\t * Determine whether the {@link Class} identified by the supplied name is present\n\t * and can be loaded. Will return {@code false} if either the class or\n\t * one of its dependencies is not present or cannot be loaded.\n\t * @param className the name of the class to check\n\t * @param classLoader the class loader to use\n\t * (can be {@code null} which indicates the default class loader)\n\t * @return whether the specified class is present (including all of its\n\t * superclasses and interfaces)\n\t * @throws IllegalStateException if the corresponding class is resolvable but there\n\t * was a readability mismatch in the inheritance hierarchy of the class (typically a\n\t * missing dependency declaration in a Java Module System module definition for a\n\t * superclass or interface implemented by the class to be checked here)\n\t */\n\tpublic static boolean isPresent(String className, @Nullable ClassLoader classLoader) {\n\t\ttry {\n\t\t\tforName(className, classLoader);\n\t\t\treturn true;\n\t\t}\n\t\tcatch (IllegalAccessError err) {\n\t\t\tthrow new IllegalStateException(\"Readability mismatch in inheritance hierarchy of class [\" +\n\t\t\t\t\tclassName + \"]: \" + err.getMessage(), err);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\t// Typically ClassNotFoundException or NoClassDefFoundError...\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Check whether the given class is visible in the given ClassLoader.\n\t * @param clazz the class to check (typically an interface)\n\t * @param classLoader the ClassLoader to check against\n\t * (can be {@code null} in which case this method will always return {@code true})\n\t */\n\tpublic static boolean isVisible(Class<?> clazz, @Nullable ClassLoader classLoader) {\n\t\tif (classLoader == null) {\n\t\t\treturn true;\n\t\t}\n\t\ttry {\n\t\t\tif (clazz.getClassLoader() == classLoader) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (SecurityException ex) {\n\t\t\t// Fall through to loadable check below\n\t\t}\n\n\t\t// Visible if same Class can be loaded from given ClassLoader\n\t\treturn isLoadable(clazz, classLoader);\n\t}\n\n\t/**\n\t * Check whether the given class is cache-safe in the given context,\n\t * i.e. whether it is loaded by the given ClassLoader or a parent of it.\n\t * @param clazz the class to analyze\n\t * @param classLoader the ClassLoader to potentially cache metadata in\n\t * (can be {@code null} which indicates the system class loader)\n\t */\n\tpublic static boolean isCacheSafe(Class<?> clazz, @Nullable ClassLoader classLoader) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\ttry {\n\t\t\tClassLoader target = clazz.getClassLoader();\n\t\t\t// Common cases\n\t\t\tif (target == classLoader || target == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (classLoader == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// Check for match in ancestors -> positive\n\t\t\tClassLoader current = classLoader;\n\t\t\twhile (current != null) {\n\t\t\t\tcurrent = current.getParent();\n\t\t\t\tif (current == target) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check for match in children -> negative\n\t\t\twhile (target != null) {\n\t\t\t\ttarget = target.getParent();\n\t\t\t\tif (target == classLoader) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (SecurityException ex) {\n\t\t\t// Fall through to loadable check below\n\t\t}\n\n\t\t// Fallback for ClassLoaders without parent/child relationship:\n\t\t// safe if same Class can be loaded from given ClassLoader\n\t\treturn (classLoader != null && isLoadable(clazz, classLoader));\n\t}\n\n\t/**\n\t * Check whether the given class is loadable in the given ClassLoader.\n\t * @param clazz the class to check (typically an interface)\n\t * @param classLoader the ClassLoader to check against\n\t * @since 5.0.6\n\t */\n\tprivate static boolean isLoadable(Class<?> clazz, ClassLoader classLoader) {\n\t\ttry {\n\t\t\treturn (clazz == classLoader.loadClass(clazz.getName()));\n\t\t\t// Else: different class with same name found\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\t// No corresponding class found at all\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Resolve the given class name as primitive class, if appropriate,\n\t * according to the JVM's naming rules for primitive classes.\n\t * <p>Also supports the JVM's internal class names for primitive arrays.\n\t * Does <i>not</i> support the \"[]\" suffix notation for primitive arrays;\n\t * this is only supported by {@link #forName(String, ClassLoader)}.\n\t * @param name the name of the potentially primitive class\n\t * @return the primitive class, or {@code null} if the name does not denote\n\t * a primitive class or primitive array class\n\t */\n\tpublic static @Nullable Class<?> resolvePrimitiveClassName(@Nullable String name) {\n\t\tClass<?> result = null;\n\t\t// Most class names will be quite long, considering that they\n\t\t// SHOULD sit in a package, so a length check is worthwhile.\n\t\tif (name != null && name.length() <= 7) {\n\t\t\t// Could be a primitive - likely.\n\t\t\tresult = primitiveTypeNameMap.get(name);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Check if the given class represents a primitive wrapper,\n\t * i.e. Boolean, Byte, Character, Short, Integer, Long, Float, Double, or\n\t * Void.\n\t * @param clazz the class to check\n\t * @return whether the given class is a primitive wrapper class\n\t */\n\tpublic static boolean isPrimitiveWrapper(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\treturn primitiveWrapperTypeMap.containsKey(clazz);\n\t}\n\n\t/**\n\t * Check if the given class represents a primitive (i.e. boolean, byte,\n\t * char, short, int, long, float, or double), {@code void}, or a wrapper for\n\t * those types (i.e. Boolean, Byte, Character, Short, Integer, Long, Float,\n\t * Double, or Void).\n\t * @param clazz the class to check\n\t * @return {@code true} if the given class represents a primitive, void, or\n\t * a wrapper class\n\t */\n\tpublic static boolean isPrimitiveOrWrapper(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\treturn (clazz.isPrimitive() || isPrimitiveWrapper(clazz));\n\t}\n\n\t/**\n\t * Check if the given class represents an array of primitives,\n\t * i.e. boolean, byte, char, short, int, long, float, or double.\n\t * @param clazz the class to check\n\t * @return whether the given class is a primitive array class\n\t */\n\tpublic static boolean isPrimitiveArray(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\treturn (clazz.isArray() && clazz.componentType().isPrimitive());\n\t}\n\n\t/**\n\t * Check if the given class represents an array of primitive wrappers,\n\t * i.e. Boolean, Byte, Character, Short, Integer, Long, Float, or Double.\n\t * @param clazz the class to check\n\t * @return whether the given class is a primitive wrapper array class\n\t */\n\tpublic static boolean isPrimitiveWrapperArray(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\treturn (clazz.isArray() && isPrimitiveWrapper(clazz.componentType()));\n\t}\n\n\t/**\n\t * Resolve the given class if it is a primitive class,\n\t * returning the corresponding primitive wrapper type instead.\n\t * @param clazz the class to check\n\t * @return the original class, or a primitive wrapper for the original primitive type\n\t */\n\t@SuppressWarnings(\"NullAway\") // Dataflow analysis limitation\n\tpublic static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\treturn (clazz.isPrimitive() && clazz != void.class ? primitiveTypeToWrapperMap.get(clazz) : clazz);\n\t}\n\n\t/**\n\t * Determine if the given type represents either {@code Void} or {@code void}.\n\t * @param type the type to check\n\t * @return {@code true} if the type represents {@code Void} or {@code void}\n\t * @since 6.1.4\n\t * @see Void\n\t * @see Void#TYPE\n\t */\n\tpublic static boolean isVoidType(@Nullable Class<?> type) {\n\t\treturn (type == void.class || type == Void.class);\n\t}\n\n\t/**\n\t * Delegate for {@link org.springframework.beans.BeanUtils#isSimpleValueType}.\n\t * Also used by {@link ObjectUtils#nullSafeConciseToString}.\n\t * <p>Check if the given type represents a common \"simple\" value type:\n\t * primitive or primitive wrapper, {@link Enum}, {@link String} or other\n\t * {@link CharSequence}, {@link Number}, {@link Date}, {@link Temporal},\n\t * {@link ZoneId}, {@link TimeZone}, {@link File}, {@link Path}, {@link URI},\n\t * {@link URL}, {@link InetAddress}, {@link Charset}, {@link Currency},\n\t * {@link Locale}, {@link UUID}, {@link Pattern}, or {@link Class}.\n\t * <p>{@code Void} and {@code void} are not considered simple value types.\n\t * @param type the type to check\n\t * @return whether the given type represents a \"simple\" value type,\n\t * suggesting value-based data binding and {@code toString} output\n\t * @since 6.1\n\t */\n\tpublic static boolean isSimpleValueType(Class<?> type) {\n\t\treturn (!isVoidType(type) &&\n\t\t\t\t(isPrimitiveOrWrapper(type) ||\n\t\t\t\tEnum.class.isAssignableFrom(type) ||\n\t\t\t\tCharSequence.class.isAssignableFrom(type) ||\n\t\t\t\tNumber.class.isAssignableFrom(type) ||\n\t\t\t\tDate.class.isAssignableFrom(type) ||\n\t\t\t\tTemporal.class.isAssignableFrom(type) ||\n\t\t\t\tZoneId.class.isAssignableFrom(type) ||\n\t\t\t\tTimeZone.class.isAssignableFrom(type) ||\n\t\t\t\tFile.class.isAssignableFrom(type) ||\n\t\t\t\tPath.class.isAssignableFrom(type) ||\n\t\t\t\tCharset.class.isAssignableFrom(type) ||\n\t\t\t\tCurrency.class.isAssignableFrom(type) ||\n\t\t\t\tInetAddress.class.isAssignableFrom(type) ||\n\t\t\t\tURI.class == type ||\n\t\t\t\tURL.class == type ||\n\t\t\t\tUUID.class == type ||\n\t\t\t\tLocale.class == type ||\n\t\t\t\tPattern.class == type ||\n\t\t\t\tClass.class == type));\n\t}\n\n\t/**\n\t * Check if the right-hand side type may be assigned to the left-hand side\n\t * type, assuming setting by reflection. Considers primitive wrapper\n\t * classes as assignable to the corresponding primitive types.\n\t * @param lhsType the target type (left-hand side (LHS) type)\n\t * @param rhsType the value type (right-hand side (RHS) type) that should\n\t * be assigned to the target type\n\t * @return {@code true} if {@code rhsType} is assignable to {@code lhsType}\n\t * @see TypeUtils#isAssignable(java.lang.reflect.Type, java.lang.reflect.Type)\n\t */\n\tpublic static boolean isAssignable(Class<?> lhsType, Class<?> rhsType) {\n\t\tAssert.notNull(lhsType, \"Left-hand side type must not be null\");\n\t\tAssert.notNull(rhsType, \"Right-hand side type must not be null\");\n\t\tif (lhsType.isAssignableFrom(rhsType)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (lhsType.isPrimitive()) {\n\t\t\tClass<?> resolvedPrimitive = primitiveWrapperTypeMap.get(rhsType);\n\t\t\treturn (lhsType == resolvedPrimitive);\n\t\t}\n\t\telse {\n\t\t\tClass<?> resolvedWrapper = primitiveTypeToWrapperMap.get(rhsType);\n\t\t\treturn (resolvedWrapper != null && lhsType.isAssignableFrom(resolvedWrapper));\n\t\t}\n\t}\n\n\t/**\n\t * Determine if the given type is assignable from the given value,\n\t * assuming setting by reflection. Considers primitive wrapper classes\n\t * as assignable to the corresponding primitive types.\n\t * @param type the target type\n\t * @param value the value that should be assigned to the type\n\t * @return if the type is assignable from the value\n\t */\n\tpublic static boolean isAssignableValue(Class<?> type, @Nullable Object value) {\n\t\tAssert.notNull(type, \"Type must not be null\");\n\t\treturn (value != null ? isAssignable(type, value.getClass()) : !type.isPrimitive());\n\t}\n\n\t/**\n\t * Convert a \"/\"-based resource path to a \".\"-based fully qualified class name.\n\t * @param resourcePath the resource path pointing to a class\n\t * @return the corresponding fully qualified class name\n\t */\n\tpublic static String convertResourcePathToClassName(String resourcePath) {\n\t\tAssert.notNull(resourcePath, \"Resource path must not be null\");\n\t\treturn resourcePath.replace(PATH_SEPARATOR, PACKAGE_SEPARATOR);\n\t}\n\n\t/**\n\t * Convert a \".\"-based fully qualified class name to a \"/\"-based resource path.\n\t * @param className the fully qualified class name\n\t * @return the corresponding resource path, pointing to the class\n\t */\n\tpublic static String convertClassNameToResourcePath(String className) {\n\t\tAssert.notNull(className, \"Class name must not be null\");\n\t\treturn className.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n\t}\n\n\t/**\n\t * Return a path suitable for use with {@code ClassLoader.getResource}\n\t * (also suitable for use with {@code Class.getResource} by prepending a\n\t * slash ('/') to the return value). Built by taking the package of the specified\n\t * class file, converting all dots ('.') to slashes ('/'), adding a trailing slash\n\t * if necessary, and concatenating the specified resource name to this.\n\t * <br/>As such, this function may be used to build a path suitable for\n\t * loading a resource file that is in the same package as a class file,\n\t * although {@link org.springframework.core.io.ClassPathResource} is usually\n\t * even more convenient.\n\t * @param clazz the Class whose package will be used as the base\n\t * @param resourceName the resource name to append. A leading slash is optional.\n\t * @return the built-up resource path\n\t * @see ClassLoader#getResource\n\t * @see Class#getResource\n\t */\n\tpublic static String addResourcePathToPackagePath(Class<?> clazz, String resourceName) {\n\t\tAssert.notNull(resourceName, \"Resource name must not be null\");\n\t\tif (!resourceName.startsWith(\"/\")) {\n\t\t\treturn classPackageAsResourcePath(clazz) + PATH_SEPARATOR + resourceName;\n\t\t}\n\t\treturn classPackageAsResourcePath(clazz) + resourceName;\n\t}\n\n\t/**\n\t * Given an input class object, return a string which consists of the\n\t * class's package name as a pathname, i.e., all dots ('.') are replaced by\n\t * slashes ('/'). Neither a leading nor trailing slash is added. The result\n\t * could be concatenated with a slash and the name of a resource and fed\n\t * directly to {@code ClassLoader.getResource()}. For it to be fed to\n\t * {@code Class.getResource} instead, a leading slash would also have\n\t * to be prepended to the returned value.\n\t * @param clazz the input class. A {@code null} value or the default\n\t * (empty) package will result in an empty string (\"\") being returned.\n\t * @return a path which represents the package name\n\t * @see ClassLoader#getResource\n\t * @see Class#getResource\n\t */\n\tpublic static String classPackageAsResourcePath(@Nullable Class<?> clazz) {\n\t\tif (clazz == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\tString className = clazz.getName();\n\t\tint packageEndIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n\t\tif (packageEndIndex == -1) {\n\t\t\treturn \"\";\n\t\t}\n\t\tString packageName = className.substring(0, packageEndIndex);\n\t\treturn packageName.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n\t}\n\n\t/**\n\t * Build a String that consists of the names of the classes/interfaces\n\t * in the given array.\n\t * <p>Basically like {@code AbstractCollection.toString()}, but stripping\n\t * the \"class \"/\"interface \" prefix before every class name.\n\t * @param classes an array of Class objects\n\t * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n\t * @see java.util.AbstractCollection#toString()\n\t */\n\tpublic static String classNamesToString(Class<?>... classes) {\n\t\treturn classNamesToString(Arrays.asList(classes));\n\t}\n\n\t/**\n\t * Build a String that consists of the names of the classes/interfaces\n\t * in the given collection.\n\t * <p>Basically like {@code AbstractCollection.toString()}, but stripping\n\t * the \"class \"/\"interface \" prefix before every class name.\n\t * @param classes a Collection of Class objects (can be {@code null})\n\t * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n\t * @see java.util.AbstractCollection#toString()\n\t */\n\tpublic static String classNamesToString(@Nullable Collection<Class<?>> classes) {\n\t\tif (CollectionUtils.isEmpty(classes)) {\n\t\t\treturn \"[]\";\n\t\t}\n\t\tStringJoiner stringJoiner = new StringJoiner(\", \", \"[\", \"]\");\n\t\tfor (Class<?> clazz : classes) {\n\t\t\tstringJoiner.add(clazz.getName());\n\t\t}\n\t\treturn stringJoiner.toString();\n\t}\n\n\t/**\n\t * Copy the given {@code Collection} into a {@code Class} array.\n\t * <p>The {@code Collection} must contain {@code Class} elements only.\n\t * @param collection the {@code Collection} to copy\n\t * @return the {@code Class} array\n\t * @since 3.1\n\t * @see StringUtils#toStringArray\n\t */\n\tpublic static Class<?>[] toClassArray(@Nullable Collection<Class<?>> collection) {\n\t\treturn (!CollectionUtils.isEmpty(collection) ? collection.toArray(EMPTY_CLASS_ARRAY) : EMPTY_CLASS_ARRAY);\n\t}\n\n\t/**\n\t * Return all interfaces that the given instance implements as an array,\n\t * including ones implemented by superclasses.\n\t * @param instance the instance to analyze for interfaces\n\t * @return all interfaces that the given instance implements as an array\n\t */\n\tpublic static Class<?>[] getAllInterfaces(Object instance) {\n\t\tAssert.notNull(instance, \"Instance must not be null\");\n\t\treturn getAllInterfacesForClass(instance.getClass());\n\t}\n\n\t/**\n\t * Return all interfaces that the given class implements as an array,\n\t * including ones implemented by superclasses.\n\t * <p>If the class itself is an interface, it gets returned as sole interface.\n\t * @param clazz the class to analyze for interfaces\n\t * @return all interfaces that the given object implements as an array\n\t */\n\tpublic static Class<?>[] getAllInterfacesForClass(Class<?> clazz) {\n\t\treturn getAllInterfacesForClass(clazz, null);\n\t}\n\n\t/**\n\t * Return all interfaces that the given class implements as an array,\n\t * including ones implemented by superclasses.\n\t * <p>If the class itself is an interface, it gets returned as sole interface.\n\t * @param clazz the class to analyze for interfaces\n\t * @param classLoader the ClassLoader that the interfaces need to be visible in\n\t * (can be {@code null} when accepting all declared interfaces)\n\t * @return all interfaces that the given object implements as an array\n\t */\n\tpublic static Class<?>[] getAllInterfacesForClass(Class<?> clazz, @Nullable ClassLoader classLoader) {\n\t\treturn toClassArray(getAllInterfacesForClassAsSet(clazz, classLoader));\n\t}\n\n\t/**\n\t * Return all interfaces that the given instance implements as a Set,\n\t * including ones implemented by superclasses.\n\t * @param instance the instance to analyze for interfaces\n\t * @return all interfaces that the given instance implements as a Set\n\t */\n\tpublic static Set<Class<?>> getAllInterfacesAsSet(Object instance) {\n\t\tAssert.notNull(instance, \"Instance must not be null\");\n\t\treturn getAllInterfacesForClassAsSet(instance.getClass());\n\t}\n\n\t/**\n\t * Return all interfaces that the given class implements as a Set,\n\t * including ones implemented by superclasses.\n\t * <p>If the class itself is an interface, it gets returned as sole interface.\n\t * @param clazz the class to analyze for interfaces\n\t * @return all interfaces that the given object implements as a Set\n\t */\n\tpublic static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz) {\n\t\treturn getAllInterfacesForClassAsSet(clazz, null);\n\t}\n\n\t/**\n\t * Return all interfaces that the given class implements as a Set,\n\t * including ones implemented by superclasses.\n\t * <p>If the class itself is an interface, it gets returned as sole interface.\n\t * @param clazz the class to analyze for interfaces\n\t * @param classLoader the ClassLoader that the interfaces need to be visible in\n\t * (can be {@code null} when accepting all declared interfaces)\n\t * @return all interfaces that the given object implements as a Set\n\t */\n\tpublic static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, @Nullable ClassLoader classLoader) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tif (clazz.isInterface() && isVisible(clazz, classLoader)) {\n\t\t\treturn Collections.singleton(clazz);\n\t\t}\n\t\tSet<Class<?>> interfaces = new LinkedHashSet<>();\n\t\tClass<?> current = clazz;\n\t\twhile (current != null) {\n\t\t\tClass<?>[] ifcs = current.getInterfaces();\n\t\t\tfor (Class<?> ifc : ifcs) {\n\t\t\t\tif (isVisible(ifc, classLoader)) {\n\t\t\t\t\tinterfaces.add(ifc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current.getSuperclass();\n\t\t}\n\t\treturn interfaces;\n\t}\n\n\t/**\n\t * Create a composite interface Class for the given interfaces,\n\t * implementing the given interfaces in one single Class.\n\t * <p>This implementation builds a JDK proxy class for the given interfaces.\n\t * @param interfaces the interfaces to merge\n\t * @param classLoader the ClassLoader to create the composite Class in\n\t * @return the merged interface as Class\n\t * @throws IllegalArgumentException if the specified interfaces expose\n\t * conflicting method signatures (or a similar constraint is violated)\n\t * @see java.lang.reflect.Proxy#getProxyClass\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tpublic static Class<?> createCompositeInterface(Class<?>[] interfaces, @Nullable ClassLoader classLoader) {\n\t\tAssert.notEmpty(interfaces, \"Interface array must not be empty\");\n\t\treturn Proxy.getProxyClass(classLoader, interfaces);\n\t}\n\n\t/**\n\t * Determine the common ancestor of the given classes, if any.\n\t * @param clazz1 the class to introspect\n\t * @param clazz2 the other class to introspect\n\t * @return the common ancestor (i.e. common superclass, one interface\n\t * extending the other), or {@code null} if none found. If any of the\n\t * given classes is {@code null}, the other class will be returned.\n\t * @since 3.2.6\n\t */\n\tpublic static @Nullable Class<?> determineCommonAncestor(@Nullable Class<?> clazz1, @Nullable Class<?> clazz2) {\n\t\tif (clazz1 == null) {\n\t\t\treturn clazz2;\n\t\t}\n\t\tif (clazz2 == null) {\n\t\t\treturn clazz1;\n\t\t}\n\t\tif (clazz1.isAssignableFrom(clazz2)) {\n\t\t\treturn clazz1;\n\t\t}\n\t\tif (clazz2.isAssignableFrom(clazz1)) {\n\t\t\treturn clazz2;\n\t\t}\n\t\tClass<?> ancestor = clazz1;\n\t\tdo {\n\t\t\tancestor = ancestor.getSuperclass();\n\t\t\tif (ancestor == null || Object.class == ancestor) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\twhile (!ancestor.isAssignableFrom(clazz2));\n\t\treturn ancestor;\n\t}\n\n\t/**\n\t * Determine whether the given interface is a common Java language interface:\n\t * {@link Serializable}, {@link Externalizable}, {@link Closeable}, {@link AutoCloseable},\n\t * {@link Cloneable}, {@link Comparable} - all of which can be ignored when looking\n\t * for 'primary' user-level interfaces. Common characteristics: no service-level\n\t * operations, no bean property methods, no default methods.\n\t * @param ifc the interface to check\n\t * @since 5.0.3\n\t */\n\tpublic static boolean isJavaLanguageInterface(Class<?> ifc) {\n\t\treturn javaLanguageInterfaces.contains(ifc);\n\t}\n\n\t/**\n\t * Determine if the supplied class is a static class.\n\t * @return {@code true} if the supplied class is a static class\n\t * @since 6.0\n\t * @see Modifier#isStatic(int)\n\t * @see #isInnerClass(Class)\n\t */\n\tpublic static boolean isStaticClass(Class<?> clazz) {\n\t\treturn Modifier.isStatic(clazz.getModifiers());\n\t}\n\n\t/**\n\t * Determine if the supplied class is an <em>inner class</em>,\n\t * i.e. a non-static member of an enclosing class.\n\t * @return {@code true} if the supplied class is an inner class\n\t * @since 5.0.5\n\t * @see Class#isMemberClass()\n\t * @see #isStaticClass(Class)\n\t */\n\tpublic static boolean isInnerClass(Class<?> clazz) {\n\t\treturn (clazz.isMemberClass() && !isStaticClass(clazz));\n\t}\n\n\t/**\n\t * Determine if the supplied {@link Class} is a JVM-generated implementation\n\t * class for a lambda expression or method reference.\n\t * <p>This method makes a best-effort attempt at determining this, based on\n\t * checks that work on modern, mainstream JVMs.\n\t * @param clazz the class to check\n\t * @return {@code true} if the class is a lambda implementation class\n\t * @since 5.3.19\n\t */\n\tpublic static boolean isLambdaClass(Class<?> clazz) {\n\t\treturn (clazz.isSynthetic() && (clazz.getSuperclass() == Object.class) &&\n\t\t\t\t(clazz.getInterfaces().length > 0) && clazz.getName().contains(\"$$Lambda\"));\n\t}\n\n\t/**\n\t * Check whether the given object is a CGLIB proxy.\n\t * @param object the object to check\n\t * @see org.springframework.aop.support.AopUtils#isCglibProxy(Object)\n\t * @deprecated as of 5.2, in favor of custom (possibly narrower) checks\n\t * such as for a Spring AOP proxy\n\t */\n\t@Deprecated\n\tpublic static boolean isCglibProxy(Object object) {\n\t\treturn isCglibProxyClass(object.getClass());\n\t}\n\n\t/**\n\t * Check whether the specified class is a CGLIB-generated class.\n\t * @param clazz the class to check\n\t * @see #getUserClass(Class)\n\t * @deprecated as of 5.2, in favor of custom (possibly narrower) checks\n\t * or simply a check for containing {@link #CGLIB_CLASS_SEPARATOR}\n\t */\n\t@Deprecated\n\tpublic static boolean isCglibProxyClass(@Nullable Class<?> clazz) {\n\t\treturn (clazz != null && isCglibProxyClassName(clazz.getName()));\n\t}\n\n\t/**\n\t * Check whether the specified class name is a CGLIB-generated class.\n\t * @param className the class name to check\n\t * @see #CGLIB_CLASS_SEPARATOR\n\t * @deprecated as of 5.2, in favor of custom (possibly narrower) checks\n\t * or simply a check for containing {@link #CGLIB_CLASS_SEPARATOR}\n\t */\n\t@Deprecated\n\tpublic static boolean isCglibProxyClassName(@Nullable String className) {\n\t\treturn (className != null && className.contains(CGLIB_CLASS_SEPARATOR));\n\t}\n\n\t/**\n\t * Return the user-defined class for the given instance: usually simply\n\t * the class of the given instance, but the original class in case of a\n\t * CGLIB-generated subclass.\n\t * @param instance the instance to check\n\t * @return the user-defined class\n\t */\n\tpublic static Class<?> getUserClass(Object instance) {\n\t\tAssert.notNull(instance, \"Instance must not be null\");\n\t\treturn getUserClass(instance.getClass());\n\t}\n\n\t/**\n\t * Return the user-defined class for the given class: usually simply the given\n\t * class, but the original class in case of a CGLIB-generated subclass.\n\t * @param clazz the class to check\n\t * @return the user-defined class\n\t * @see #CGLIB_CLASS_SEPARATOR\n\t */\n\tpublic static Class<?> getUserClass(Class<?> clazz) {\n\t\tif (clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) {\n\t\t\tClass<?> superclass = clazz.getSuperclass();\n\t\t\tif (superclass != null && superclass != Object.class) {\n\t\t\t\treturn superclass;\n\t\t\t}\n\t\t}\n\t\treturn clazz;\n\t}\n\n\t/**\n\t * Return a descriptive name for the given object's type: usually simply\n\t * the class name, but component type class name + \"[]\" for arrays,\n\t * and an appended list of implemented interfaces for JDK proxies.\n\t * @param value the value to introspect\n\t * @return the qualified name of the class\n\t */\n\tpublic static @Nullable String getDescriptiveType(@Nullable Object value) {\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\t\tClass<?> clazz = value.getClass();\n\t\tif (Proxy.isProxyClass(clazz)) {\n\t\t\tString prefix = clazz.getTypeName() + \" implementing \";\n\t\t\tStringJoiner result = new StringJoiner(\",\", prefix, \"\");\n\t\t\tfor (Class<?> ifc : clazz.getInterfaces()) {\n\t\t\t\tresult.add(ifc.getTypeName());\n\t\t\t}\n\t\t\treturn result.toString();\n\t\t}\n\t\telse {\n\t\t\treturn clazz.getTypeName();\n\t\t}\n\t}\n\n\t/**\n\t * Check whether the given class matches the user-specified type name.\n\t * @param clazz the class to check\n\t * @param typeName the type name to match\n\t */\n\tpublic static boolean matchesTypeName(Class<?> clazz, @Nullable String typeName) {\n\t\treturn (typeName != null &&\n\t\t\t\t(typeName.equals(clazz.getTypeName()) || typeName.equals(clazz.getSimpleName())));\n\t}\n\n\t/**\n\t * Get the class name without the qualified package name.\n\t * @param className the className to get the short name for\n\t * @return the class name of the class without the package name\n\t * @throws IllegalArgumentException if the className is empty\n\t */\n\tpublic static String getShortName(String className) {\n\t\tAssert.hasLength(className, \"Class name must not be empty\");\n\t\tint lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n\t\tint nameEndIndex = className.indexOf(CGLIB_CLASS_SEPARATOR);\n\t\tif (nameEndIndex == -1) {\n\t\t\tnameEndIndex = className.length();\n\t\t}\n\t\tString shortName = className.substring(lastDotIndex + 1, nameEndIndex);\n\t\tshortName = shortName.replace(NESTED_CLASS_SEPARATOR, PACKAGE_SEPARATOR);\n\t\treturn shortName;\n\t}\n\n\t/**\n\t * Get the class name without the qualified package name.\n\t * @param clazz the class to get the short name for\n\t * @return the class name of the class without the package name\n\t */\n\tpublic static String getShortName(Class<?> clazz) {\n\t\treturn getShortName(getQualifiedName(clazz));\n\t}\n\n\t/**\n\t * Return the short string name of a Java class in uncapitalized JavaBeans\n\t * property format. Strips the outer class name in case of a nested class.\n\t * @param clazz the class\n\t * @return the short name rendered in a standard JavaBeans property format\n\t * @see StringUtils#uncapitalizeAsProperty(String)\n\t */\n\tpublic static String getShortNameAsProperty(Class<?> clazz) {\n\t\tString shortName = getShortName(clazz);\n\t\tint dotIndex = shortName.lastIndexOf(PACKAGE_SEPARATOR);\n\t\tshortName = (dotIndex != -1 ? shortName.substring(dotIndex + 1) : shortName);\n\t\treturn StringUtils.uncapitalizeAsProperty(shortName);\n\t}\n\n\t/**\n\t * Determine the name of the class file, relative to the containing\n\t * package: for example, \"String.class\".\n\t * @param clazz the class\n\t * @return the file name of the \".class\" file\n\t */\n\tpublic static String getClassFileName(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tString className = clazz.getName();\n\t\tint lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n\t\treturn className.substring(lastDotIndex + 1) + CLASS_FILE_SUFFIX;\n\t}\n\n\t/**\n\t * Determine the name of the package of the given class,\n\t * for example, \"java.lang\" for the {@code java.lang.String} class.\n\t * @param clazz the class\n\t * @return the package name, or the empty String if the class\n\t * is defined in the default package\n\t */\n\tpublic static String getPackageName(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\treturn getPackageName(clazz.getName());\n\t}\n\n\t/**\n\t * Determine the name of the package of the given fully-qualified class name,\n\t * for example, \"java.lang\" for the {@code java.lang.String} class name.\n\t * @param fqClassName the fully-qualified class name\n\t * @return the package name, or the empty String if the class\n\t * is defined in the default package\n\t */\n\tpublic static String getPackageName(String fqClassName) {\n\t\tAssert.notNull(fqClassName, \"Class name must not be null\");\n\t\tint lastDotIndex = fqClassName.lastIndexOf(PACKAGE_SEPARATOR);\n\t\treturn (lastDotIndex != -1 ? fqClassName.substring(0, lastDotIndex) : \"\");\n\t}\n\n\t/**\n\t * Return the qualified name of the given class: usually simply\n\t * the class name, but component type class name + \"[]\" for arrays.\n\t * @param clazz the class\n\t * @return the qualified name of the class\n\t */\n\tpublic static String getQualifiedName(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\treturn clazz.getTypeName();\n\t}\n\n\t/**\n\t * Return the qualified name of the given method, consisting of\n\t * fully qualified interface/class name + \".\" + method name.\n\t * @param method the method\n\t * @return the qualified name of the method\n\t */\n\tpublic static String getQualifiedMethodName(Method method) {\n\t\treturn getQualifiedMethodName(method, null);\n\t}\n\n\t/**\n\t * Return the qualified name of the given method, consisting of\n\t * fully qualified interface/class name + \".\" + method name.\n\t * @param method the method\n\t * @param clazz the clazz that the method is being invoked on\n\t * (can be {@code null} to indicate the method's declaring class)\n\t * @return the qualified name of the method\n\t * @since 4.3.4\n\t */\n\tpublic static String getQualifiedMethodName(Method method, @Nullable Class<?> clazz) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\treturn (clazz != null ? clazz : method.getDeclaringClass()).getName() + '.' + method.getName();\n\t}\n\n\t/**\n\t * Determine whether the given class has a public constructor with the given signature.\n\t * <p>Essentially translates {@code NoSuchMethodException} to \"false\".\n\t * @param clazz the clazz to analyze\n\t * @param paramTypes the parameter types of the method\n\t * @return whether the class has a corresponding constructor\n\t * @see Class#getConstructor\n\t */\n\tpublic static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes) {\n\t\treturn (getConstructorIfAvailable(clazz, paramTypes) != null);\n\t}\n\n\t/**\n\t * Determine whether the given class has a public constructor with the given signature,\n\t * and return it if available (else return {@code null}).\n\t * <p>Essentially translates {@code NoSuchMethodException} to {@code null}.\n\t * @param clazz the clazz to analyze\n\t * @param paramTypes the parameter types of the method\n\t * @return the constructor, or {@code null} if not found\n\t * @see Class#getConstructor\n\t */\n\tpublic static <T> @Nullable Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\ttry {\n\t\t\treturn clazz.getConstructor(paramTypes);\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Determine whether the given class has a public method with the given signature.\n\t * @param clazz the clazz to analyze\n\t * @param method the method to look for\n\t * @return whether the class has a corresponding method\n\t * @since 5.2.3\n\t */\n\tpublic static boolean hasMethod(Class<?> clazz, Method method) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\tif (clazz == method.getDeclaringClass()) {\n\t\t\treturn true;\n\t\t}\n\t\tString methodName = method.getName();\n\t\tClass<?>[] paramTypes = method.getParameterTypes();\n\t\treturn getMethodOrNull(clazz, methodName, paramTypes) != null;\n\t}\n\n\t/**\n\t * Determine whether the given class has a public method with the given signature.\n\t * <p>Essentially translates {@code NoSuchMethodException} to \"false\".\n\t * @param clazz the clazz to analyze\n\t * @param methodName the name of the method\n\t * @param paramTypes the parameter types of the method\n\t * @return whether the class has a corresponding method\n\t * @see Class#getMethod\n\t */\n\tpublic static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n\t\treturn (getMethodIfAvailable(clazz, methodName, paramTypes) != null);\n\t}\n\n\t/**\n\t * Determine whether the given class has a public method with the given signature,\n\t * and return it if available (else throws an {@code IllegalStateException}).\n\t * <p>In case of any signature specified, only returns the method if there is a\n\t * unique candidate, i.e. a single public method with the specified name.\n\t * <p>Essentially translates {@code NoSuchMethodException} to {@code IllegalStateException}.\n\t * @param clazz the clazz to analyze\n\t * @param methodName the name of the method\n\t * @param paramTypes the parameter types of the method\n\t * (can be {@code null} to indicate any signature)\n\t * @return the method (never {@code null})\n\t * @throws IllegalStateException if the method has not been found\n\t * @see Class#getMethod\n\t */\n\tpublic static Method getMethod(Class<?> clazz, String methodName, @Nullable Class<?>... paramTypes) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(methodName, \"Method name must not be null\");\n\t\tif (paramTypes != null) {\n\t\t\ttry {\n\t\t\t\treturn clazz.getMethod(methodName, paramTypes);\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Expected method not found: \" + ex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tSet<Method> candidates = findMethodCandidatesByName(clazz, methodName);\n\t\t\tif (candidates.size() == 1) {\n\t\t\t\treturn candidates.iterator().next();\n\t\t\t}\n\t\t\telse if (candidates.isEmpty()) {\n\t\t\t\tthrow new IllegalStateException(\"Expected method not found: \" + clazz.getName() + '.' + methodName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(\"No unique method found: \" + clazz.getName() + '.' + methodName);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Determine whether the given class has a public method with the given signature,\n\t * and return it if available (else return {@code null}).\n\t * <p>In case of any signature specified, only returns the method if there is a\n\t * unique candidate, i.e. a single public method with the specified name.\n\t * <p>Essentially translates {@code NoSuchMethodException} to {@code null}.\n\t * @param clazz the clazz to analyze\n\t * @param methodName the name of the method\n\t * @param paramTypes the parameter types of the method\n\t * (can be {@code null} to indicate any signature)\n\t * @return the method, or {@code null} if not found\n\t * @see Class#getMethod\n\t */\n\tpublic static @Nullable Method getMethodIfAvailable(Class<?> clazz, String methodName, @Nullable Class<?> @Nullable ... paramTypes) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(methodName, \"Method name must not be null\");\n\t\tif (paramTypes != null) {\n\t\t\treturn getMethodOrNull(clazz, methodName, paramTypes);\n\t\t}\n\t\telse {\n\t\t\tSet<Method> candidates = findMethodCandidatesByName(clazz, methodName);\n\t\t\tif (candidates.size() == 1) {\n\t\t\t\treturn candidates.iterator().next();\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Return the number of methods with a given name (with any argument types),\n\t * for the given class and/or its superclasses. Includes non-public methods.\n\t * @param clazz\tthe clazz to check\n\t * @param methodName the name of the method\n\t * @return the number of methods with the given name\n\t */\n\tpublic static int getMethodCountForName(Class<?> clazz, String methodName) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(methodName, \"Method name must not be null\");\n\t\tint count = 0;\n\t\tMethod[] declaredMethods = clazz.getDeclaredMethods();\n\t\tfor (Method method : declaredMethods) {\n\t\t\tif (methodName.equals(method.getName())) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tClass<?>[] ifcs = clazz.getInterfaces();\n\t\tfor (Class<?> ifc : ifcs) {\n\t\t\tcount += getMethodCountForName(ifc, methodName);\n\t\t}\n\t\tif (clazz.getSuperclass() != null) {\n\t\t\tcount += getMethodCountForName(clazz.getSuperclass(), methodName);\n\t\t}\n\t\treturn count;\n\t}\n\n\t/**\n\t * Does the given class or one of its superclasses at least have one or more\n\t * methods with the supplied name (with any argument types)?\n\t * Includes non-public methods.\n\t * @param clazz\tthe clazz to check\n\t * @param methodName the name of the method\n\t * @return whether there is at least one method with the given name\n\t */\n\tpublic static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(methodName, \"Method name must not be null\");\n\t\tMethod[] declaredMethods = clazz.getDeclaredMethods();\n\t\tfor (Method method : declaredMethods) {\n\t\t\tif (method.getName().equals(methodName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tClass<?>[] ifcs = clazz.getInterfaces();\n\t\tfor (Class<?> ifc : ifcs) {\n\t\t\tif (hasAtLeastOneMethodWithName(ifc, methodName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn (clazz.getSuperclass() != null && hasAtLeastOneMethodWithName(clazz.getSuperclass(), methodName));\n\t}\n\n\t/**\n\t * Given a method, which may come from an interface, and a target class used\n\t * in the current reflective invocation, find the corresponding target method\n\t * if there is one &mdash; for example, the method may be {@code IFoo.bar()},\n\t * and the target class may be {@code DefaultFoo}. In this case, the method may be\n\t * {@code DefaultFoo.bar()}. This enables attributes on that method to be found.\n\t * <p><b>NOTE:</b> In contrast to {@link org.springframework.aop.support.AopUtils#getMostSpecificMethod},\n\t * this method does <i>not</i> resolve bridge methods automatically.\n\t * Call {@link org.springframework.core.BridgeMethodResolver#findBridgedMethod}\n\t * if bridge method resolution is desirable &mdash; for example, to obtain\n\t * metadata from the original method definition.\n\t * <p><b>NOTE:</b> If Java security settings disallow reflective access &mdash;\n\t * for example, calls to {@code Class#getDeclaredMethods}, etc. &mdash; this\n\t * implementation will fall back to returning the originally provided method.\n\t * @param method the method to be invoked, which may come from an interface\n\t * @param targetClass the target class for the current invocation\n\t * (can be {@code null} or may not even implement the method)\n\t * @return the specific target method, or the original method if the\n\t * {@code targetClass} does not implement it\n\t * @see #getInterfaceMethodIfPossible(Method, Class)\n\t */\n\tpublic static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass) {\n\t\tif (targetClass != null && targetClass != method.getDeclaringClass() &&\n\t\t\t\t(isOverridable(method, targetClass) || !method.getDeclaringClass().isAssignableFrom(targetClass))) {\n\t\t\ttry {\n\t\t\t\tif (Modifier.isPublic(method.getModifiers())) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn targetClass.getMethod(method.getName(), method.getParameterTypes());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\treturn method;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tMethod specificMethod =\n\t\t\t\t\t\t\tReflectionUtils.findMethod(targetClass, method.getName(), method.getParameterTypes());\n\t\t\t\t\treturn (specificMethod != null ? specificMethod : method);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (SecurityException ex) {\n\t\t\t\t// Security settings are disallowing reflective access; fall back to 'method' below.\n\t\t\t}\n\t\t}\n\t\treturn method;\n\t}\n\n\t/**\n\t * Determine a corresponding interface method for the given method handle, if possible.\n\t * <p>This is particularly useful for arriving at a public exported type on the Java\n\t * Module System which allows the method to be invoked via reflection without an illegal\n\t * access warning.\n\t * @param method the method to be invoked, potentially from an implementation class\n\t * @return the corresponding interface method, or the original method if none found\n\t * @since 5.1\n\t * @see #getPubliclyAccessibleMethodIfPossible(Method, Class)\n\t * @deprecated in favor of {@link #getInterfaceMethodIfPossible(Method, Class)}\n\t */\n\t@Deprecated\n\tpublic static Method getInterfaceMethodIfPossible(Method method) {\n\t\treturn getInterfaceMethodIfPossible(method, null);\n\t}\n\n\t/**\n\t * Determine a corresponding interface method for the given method handle, if possible.\n\t * <p>This is particularly useful for arriving at a public exported type on the Java\n\t * Module System which allows the method to be invoked via reflection without an illegal\n\t * access warning.\n\t * @param method the method to be invoked, potentially from an implementation class\n\t * @param targetClass the target class to invoke the method on, or {@code null} if unknown\n\t * @return the corresponding interface method, or the original method if none found\n\t * @since 5.3.16\n\t * @see #getPubliclyAccessibleMethodIfPossible(Method, Class)\n\t * @see #getMostSpecificMethod\n\t */\n\tpublic static Method getInterfaceMethodIfPossible(Method method, @Nullable Class<?> targetClass) {\n\t\treturn getInterfaceMethodIfPossible(method, targetClass, false);\n\t}\n\n\tprivate static Method getInterfaceMethodIfPossible(Method method, @Nullable Class<?> targetClass,\n\t\t\tboolean requirePublicInterface) {\n\n\t\tClass<?> declaringClass = method.getDeclaringClass();\n\t\tif (!Modifier.isPublic(method.getModifiers()) || (declaringClass.isInterface() &&\n\t\t\t\t(!requirePublicInterface || Modifier.isPublic(declaringClass.getModifiers())))) {\n\t\t\treturn method;\n\t\t}\n\t\tString methodName = method.getName();\n\t\tClass<?>[] parameterTypes = method.getParameterTypes();\n\n\t\tMap<Method, Method> methodCache = (requirePublicInterface ? publicInterfaceMethodCache : interfaceMethodCache);\n\t\t// Try cached version of method in its declaring class\n\t\tMethod result = methodCache.computeIfAbsent(method, key -> findInterfaceMethodIfPossible(\n\t\t\t\tmethodName, parameterTypes, declaringClass, Object.class, requirePublicInterface));\n\t\tif (result == null && targetClass != null) {\n\t\t\t// No interface method found yet -> try given target class (possibly a subclass of the\n\t\t\t// declaring class, late-binding a base class method to a subclass-declared interface:\n\t\t\t// see, for example, HashMap.HashIterator.hasNext)\n\t\t\tresult = findInterfaceMethodIfPossible(\n\t\t\t\t\tmethodName, parameterTypes, targetClass, declaringClass, requirePublicInterface);\n\t\t}\n\t\treturn (result != null ? result : method);\n\t}\n\n\tprivate static @Nullable Method findInterfaceMethodIfPossible(String methodName, Class<?>[] parameterTypes,\n\t\t\tClass<?> startClass, Class<?> endClass, boolean requirePublicInterface) {\n\n\t\tClass<?> current = startClass;\n\t\twhile (current != null && current != endClass) {\n\t\t\tfor (Class<?> ifc : current.getInterfaces()) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!requirePublicInterface || Modifier.isPublic(ifc.getModifiers())) {\n\t\t\t\t\t\treturn ifc.getMethod(methodName, parameterTypes);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current.getSuperclass();\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Get the first publicly accessible method in the supplied method's type hierarchy that\n\t * has a method signature equivalent to the supplied method, if possible.\n\t * <p>If the supplied method is {@code public} and declared in a {@code public} type,\n\t * the supplied method will be returned.\n\t * <p>Otherwise, this method recursively searches the class hierarchy and implemented\n\t * interfaces for an equivalent method that is {@code public} and declared in a\n\t * {@code public} type.\n\t * <p>If a publicly accessible equivalent method cannot be found, the supplied method\n\t * will be returned, indicating that no such equivalent method exists. Consequently,\n\t * callers of this method must manually validate the accessibility of the returned method\n\t * if public access is a requirement.\n\t * <p>This is particularly useful for arriving at a public exported type on the Java\n\t * Module System which allows the method to be invoked via reflection without an illegal\n\t * access warning. This is also useful for invoking methods via a public API in bytecode\n\t * &mdash; for example, for use with the Spring Expression Language (SpEL) compiler.\n\t * For example, if a non-public class overrides {@code toString()}, this method will\n\t * traverse up the type hierarchy to find the first public type that declares the method\n\t * (if there is one). For {@code toString()}, it may traverse as far as {@link Object}.\n\t * @param method the method to be invoked, potentially from an implementation class\n\t * @param targetClass the target class to invoke the method on, or {@code null} if unknown\n\t * @return the corresponding publicly accessible method, or the original method if none found\n\t * @since 6.2\n\t * @see #getInterfaceMethodIfPossible(Method, Class)\n\t * @see #getMostSpecificMethod(Method, Class)\n\t */\n\tpublic static Method getPubliclyAccessibleMethodIfPossible(Method method, @Nullable Class<?> targetClass) {\n\t\tClass<?> declaringClass = method.getDeclaringClass();\n\t\t// If the method is not public, we can abort the search immediately; or if the method's\n\t\t// declaring class is public, the method is already publicly accessible.\n\t\tif (!Modifier.isPublic(method.getModifiers()) || Modifier.isPublic(declaringClass.getModifiers())) {\n\t\t\treturn method;\n\t\t}\n\n\t\tMethod interfaceMethod = getInterfaceMethodIfPossible(method, targetClass, true);\n\t\t// If we found a method in a public interface, return the interface method.\n\t\tif (!interfaceMethod.equals(method)) {\n\t\t\treturn interfaceMethod;\n\t\t}\n\n\t\tMethod result = publiclyAccessibleMethodCache.computeIfAbsent(method,\n\t\t\t\tkey -> findPubliclyAccessibleMethodIfPossible(key.getName(), key.getParameterTypes(), declaringClass));\n\t\treturn (result != null ? result : method);\n\t}\n\n\tprivate static @Nullable Method findPubliclyAccessibleMethodIfPossible(\n\t\t\tString methodName, Class<?>[] parameterTypes, Class<?> declaringClass) {\n\n\t\tClass<?> current = declaringClass.getSuperclass();\n\t\twhile (current != null) {\n\t\t\tif (Modifier.isPublic(current.getModifiers())) {\n\t\t\t\ttry {\n\t\t\t\t\treturn current.getDeclaredMethod(methodName, parameterTypes);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current.getSuperclass();\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Determine whether the given method is declared by the user or at least pointing to\n\t * a user-declared method.\n\t * <p>Checks {@link Method#isSynthetic()} (for implementation methods) as well as the\n\t * {@code GroovyObject} interface (for interface methods; on an implementation class,\n\t * implementations of the {@code GroovyObject} methods will be marked as synthetic anyway).\n\t * Note that, despite being synthetic, bridge methods ({@link Method#isBridge()}) are considered\n\t * as user-level methods since they are eventually pointing to a user-declared generic method.\n\t * @param method the method to check\n\t * @return {@code true} if the method can be considered as user-declared; {@code false} otherwise\n\t */\n\tpublic static boolean isUserLevelMethod(Method method) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\treturn (method.isBridge() || (!method.isSynthetic() && !isGroovyObjectMethod(method)));\n\t}\n\n\tprivate static boolean isGroovyObjectMethod(Method method) {\n\t\treturn method.getDeclaringClass().getName().equals(\"groovy.lang.GroovyObject\");\n\t}\n\n\t/**\n\t * Determine whether the given method is overridable in the given target class.\n\t * @param method the method to check\n\t * @param targetClass the target class to check against\n\t */\n\tprivate static boolean isOverridable(Method method, @Nullable Class<?> targetClass) {\n\t\tif ((method.getModifiers() & NON_OVERRIDABLE_MODIFIER) != 0) {\n\t\t\treturn false;\n\t\t}\n\t\tif ((method.getModifiers() & OVERRIDABLE_MODIFIER) != 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn (targetClass == null ||\n\t\t\t\tgetPackageName(method.getDeclaringClass()).equals(getPackageName(targetClass)));\n\t}\n\n\t/**\n\t * Return a public static method of a class.\n\t * @param clazz the class which defines the method\n\t * @param methodName the static method name\n\t * @param args the parameter types to the method\n\t * @return the static method, or {@code null} if no static method was found\n\t * @throws IllegalArgumentException if the method name is blank or the clazz is null\n\t */\n\tpublic static @Nullable Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(methodName, \"Method name must not be null\");\n\t\ttry {\n\t\t\tMethod method = clazz.getMethod(methodName, args);\n\t\t\treturn (Modifier.isStatic(method.getModifiers()) ? method : null);\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\tprivate static @Nullable Method getMethodOrNull(Class<?> clazz, String methodName, @Nullable Class<?> @Nullable [] paramTypes) {\n\t\ttry {\n\t\t\treturn clazz.getMethod(methodName, paramTypes);\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate static Set<Method> findMethodCandidatesByName(Class<?> clazz, String methodName) {\n\t\tSet<Method> candidates = new HashSet<>(1);\n\t\tMethod[] methods = clazz.getMethods();\n\t\tfor (Method method : methods) {\n\t\t\tif (methodName.equals(method.getName())) {\n\t\t\t\tcandidates.add(method);\n\t\t\t}\n\t\t}\n\t\treturn candidates;\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.ClassUtils",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.ClassUtils#ARRAY_SUFFIX",
    "tailType": "field"
  },
  {
    "head": "org.springframework.util.ClassUtils#ARRAY_SUFFIX",
    "headType": "field",
    "relation": "haveType",
    "tail": "String",
    "tailType": "type"
  },
  {
    "head": "org.springframework.util.ClassUtils",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.ClassUtils#EMPTY_CLASS_ARRAY",
    "tailType": "field"
  }
]