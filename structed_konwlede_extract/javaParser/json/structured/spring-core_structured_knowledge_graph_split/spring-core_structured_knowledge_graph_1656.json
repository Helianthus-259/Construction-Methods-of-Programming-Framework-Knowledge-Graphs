[
  {
    "head": "org.springframework.core.annotation.AnnotationTypeMappingsTests#getAliasMapping(AnnotationTypeMapping,int)",
    "headType": "method",
    "relation": "provide",
    "tail": "@Nullable\r\nprivate Method getAliasMapping(AnnotationTypeMapping mapping, int attributeIndex) {\r\n    int mapped = mapping.getAliasMapping(attributeIndex);\r\n    return mapped != -1 ? mapping.getRoot().getAttributes().get(mapped) : null;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationTypeMappingsTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotationTypeMappingsTests#getAliasMapping(AnnotationTypeMapping,int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationTypeMappingsTests#getAliasMapping(AnnotationTypeMapping,int)",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationTypeMappingsTests#getConventionMapping(AnnotationTypeMapping,int)",
    "headType": "method",
    "relation": "provide",
    "tail": "@Nullable\r\nprivate Method getConventionMapping(AnnotationTypeMapping mapping, int attributeIndex) {\r\n    int mapped = mapping.getConventionMapping(attributeIndex);\r\n    return mapped != -1 ? mapping.getRoot().getAttributes().get(mapped) : null;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationTypeMappingsTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotationTypeMappingsTests#getConventionMapping(AnnotationTypeMapping,int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationTypeMappingsTests#getConventionMapping(AnnotationTypeMapping,int)",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationTypeMappingsTests#getMapping(AnnotationTypeMappings,Class<? extends Annotation>)",
    "headType": "method",
    "relation": "provide",
    "tail": "private AnnotationTypeMapping getMapping(AnnotationTypeMappings mappings, Class<? extends Annotation> annotationType) {\r\n    for (AnnotationTypeMapping candidate : getAll(mappings)) {\r\n        if (candidate.getAnnotationType() == annotationType) {\r\n            return candidate;\r\n        }\r\n    }\r\n    return null;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationTypeMappingsTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotationTypeMappingsTests#getMapping(AnnotationTypeMappings,Class<? extends Annotation>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationTypeMappingsTests#getAll(AnnotationTypeMappings)",
    "headType": "method",
    "relation": "provide",
    "tail": "private List<AnnotationTypeMapping> getAll(AnnotationTypeMappings mappings) {\r\n    // AnnotationTypeMappings does not implement Iterable so we don't create\r\n    // too many garbage Iterators\r\n    return IntStream.range(0, mappings.size()).mapToObj(mappings::get).collect(toList());\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationTypeMappingsTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotationTypeMappingsTests#getAll(AnnotationTypeMappings)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationTypeMappingsTests#getNames(MirrorSet)",
    "headType": "method",
    "relation": "provide",
    "tail": "private List<String> getNames(MirrorSet mirrorSet) {\r\n    List<String> names = new ArrayList<>(mirrorSet.size());\r\n    for (int i = 0; i < mirrorSet.size(); i++) {\r\n        names.add(mirrorSet.get(i).getName());\r\n    }\r\n    return names;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationTypeMappingsTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotationTypeMappingsTests#getNames(MirrorSet)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.WithAliasPairA",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.WithAliasPairA",
    "headType": "class",
    "relation": "use",
    "tail": "@AliasPair",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.WithAliasPairA",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.IntStream;\n\nimport javax.annotation.Nullable;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.AnnotationTypeMapping.MirrorSets;\nimport org.springframework.core.annotation.AnnotationTypeMapping.MirrorSets.MirrorSet;\nimport org.springframework.util.ReflectionUtils;\n\nimport static java.util.stream.Collectors.toList;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n\n/**\n * Tests for {@link AnnotationTypeMappings} and {@link AnnotationTypeMapping}.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n */\nclass AnnotationTypeMappingsTests {\n\n\t@Test\n\tvoid forAnnotationTypeWhenNoMetaAnnotationsReturnsMappings() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(SimpleAnnotation.class);\n\t\tassertThat(mappings.size()).isEqualTo(1);\n\t\tassertThat(mappings.get(0).getAnnotationType()).isEqualTo(SimpleAnnotation.class);\n\t\tassertThat(getAll(mappings)).flatExtracting(\n\t\t\t\tAnnotationTypeMapping::getAnnotationType).containsExactly(SimpleAnnotation.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenMetaAnnotationsReturnsMappings() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(MetaAnnotated.class);\n\t\tassertThat(mappings.size()).isEqualTo(6);\n\t\tassertThat(getAll(mappings)).flatExtracting(\n\t\t\t\tAnnotationTypeMapping::getAnnotationType).containsExactly(\n\t\t\t\t\t\tMetaAnnotated.class, A.class, B.class, AA.class, AB.class,\n\t\t\t\t\t\tABC.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenHasRepeatingMetaAnnotationReturnsMapping() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(WithRepeatedMetaAnnotations.class);\n\t\tassertThat(mappings.size()).isEqualTo(3);\n\t\tassertThat(getAll(mappings)).flatExtracting(\n\t\t\t\tAnnotationTypeMapping::getAnnotationType).containsExactly(\n\t\t\t\t\t\tWithRepeatedMetaAnnotations.class, Repeating.class, Repeating.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenRepeatableMetaAnnotationIsFiltered() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(WithRepeatedMetaAnnotations.class,\n\t\t\t\tRepeatableContainers.standardRepeatables(), Repeating.class.getName()::equals);\n\t\tassertThat(getAll(mappings)).flatExtracting(AnnotationTypeMapping::getAnnotationType)\n\t\t\t\t.containsExactly(WithRepeatedMetaAnnotations.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenSelfAnnotatedReturnsMapping() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(SelfAnnotated.class);\n\t\tassertThat(mappings.size()).isEqualTo(1);\n\t\tassertThat(getAll(mappings)).flatExtracting(\n\t\t\t\tAnnotationTypeMapping::getAnnotationType).containsExactly(SelfAnnotated.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenFormsLoopReturnsMapping() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(LoopA.class);\n\t\tassertThat(mappings.size()).isEqualTo(2);\n\t\tassertThat(getAll(mappings)).flatExtracting(\n\t\t\t\tAnnotationTypeMapping::getAnnotationType).containsExactly(LoopA.class, LoopB.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenHasAliasForWithBothValueAndAttributeThrowsException() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForWithBothValueAndAttribute.class))\n\t\t\t.withMessage(\"In @AliasFor declared on attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForWithBothValueAndAttribute.class.getName()\n\t\t\t\t\t\t\t\t+ \"], attribute 'attribute' and its alias 'value' are present with values of 'foo' and 'bar', but only one is permitted.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForToSelfNonExistingAttribute() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForToSelfNonExistingAttribute.class))\n\t\t\t.withMessage(\"@AliasFor declaration on attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForToSelfNonExistingAttribute.class.getName()\n\t\t\t\t\t\t\t\t+ \"] declares an alias for 'missing' which is not present.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForToOtherNonExistingAttribute() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForToOtherNonExistingAttribute.class))\n\t\t\t.withMessage(\"Attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForToOtherNonExistingAttribute.class.getName()\n\t\t\t\t\t\t\t\t+ \"] is declared as an @AliasFor nonexistent \"\n\t\t\t\t\t\t\t\t+ \"attribute 'missing' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForToOtherNonExistingAttributeTarget.class.getName()\n\t\t\t\t\t\t\t\t+ \"].\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForToSelf() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForToSelf.class))\n\t\t\t.withMessage(\"@AliasFor declaration on attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForToSelf.class.getName()\n\t\t\t\t\t\t\t\t+ \"] points to itself. Specify 'annotation' to point to \"\n\t\t\t\t\t\t\t\t+ \"a same-named attribute on a meta-annotation.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForWithArrayCompatibleReturnTypes() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(\n\t\t\t\tAliasForWithArrayCompatibleReturnTypes.class);\n\t\tAnnotationTypeMapping mapping = getMapping(mappings,\n\t\t\t\tAliasForWithArrayCompatibleReturnTypesTarget.class);\n\t\tassertThat(getAliasMapping(mapping, 0).getName()).isEqualTo(\"test\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForWithIncompatibleReturnTypes() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForWithIncompatibleReturnTypes.class))\n\t\t\t.withMessage(\"Misconfigured aliases: attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForWithIncompatibleReturnTypes.class.getName()\n\t\t\t\t\t\t\t\t+ \"] and attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForWithIncompatibleReturnTypesTarget.class.getName()\n\t\t\t\t\t\t\t\t+ \"] must declare the same return type.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForToSelfAnnotatedToOtherAttribute() {\n\t\tString annotationType = AliasForToSelfAnnotatedToOtherAttribute.class.getName();\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> AnnotationTypeMappings.forAnnotationType(AliasForToSelfAnnotatedToOtherAttribute.class))\n\t\t\t\t.withMessage(\"Attribute 'b' in annotation [\" + annotationType\n\t\t\t\t\t\t+ \"] must be declared as an @AliasFor attribute 'a' in annotation [\" + annotationType\n\t\t\t\t\t\t+ \"], not attribute 'c' in annotation [\" + annotationType + \"].\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForHasMixedImplicitAndExplicitAliases() {\n\t\tassertMixedImplicitAndExplicitAliases(AliasForWithMixedImplicitAndExplicitAliasesV1.class, \"b\");\n\t\tassertMixedImplicitAndExplicitAliases(AliasForWithMixedImplicitAndExplicitAliasesV2.class, \"a\");\n\t}\n\n\tprivate void assertMixedImplicitAndExplicitAliases(Class<? extends Annotation> annotationType, String overriddenAttribute) {\n\t\tString annotationName = annotationType.getName();\n\t\tString metaAnnotationName = AliasPair.class.getName();\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> AnnotationTypeMappings.forAnnotationType(annotationType))\n\t\t\t\t.withMessage(\"Attribute 'b' in annotation [\" + annotationName\n\t\t\t\t\t\t+ \"] must be declared as an @AliasFor attribute 'a' in annotation [\" + annotationName\n\t\t\t\t\t\t+ \"], not attribute '\" + overriddenAttribute + \"' in annotation [\" + metaAnnotationName + \"].\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForNonMetaAnnotated() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForNonMetaAnnotated.class))\n\t\t\t.withMessage(\"@AliasFor declaration on attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForNonMetaAnnotated.class.getName()\n\t\t\t\t\t\t\t\t+ \"] declares an alias for attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForNonMetaAnnotatedTarget.class.getName()\n\t\t\t\t\t\t\t\t+ \"] which is not meta-present.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForSelfWithDifferentDefaults() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForSelfWithDifferentDefaults.class))\n\t\t\t.withMessage(\"Misconfigured aliases: attribute 'a' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForSelfWithDifferentDefaults.class.getName()\n\t\t\t\t\t\t\t\t+ \"] and attribute 'b' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForSelfWithDifferentDefaults.class.getName()\n\t\t\t\t\t\t\t\t+ \"] must declare the same default value.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForSelfWithMissingDefault() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForSelfWithMissingDefault.class))\n\t\t\t.withMessage(\"Misconfigured aliases: attribute 'a' in annotation [\"\n\t\t\t\t\t\t\t\t\t+ AliasForSelfWithMissingDefault.class.getName()\n\t\t\t\t\t\t\t\t\t+ \"] and attribute 'b' in annotation [\"\n\t\t\t\t\t\t\t\t\t+ AliasForSelfWithMissingDefault.class.getName()\n\t\t\t\t\t\t\t\t\t+ \"] must declare default values.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasWithExplicitMirrorAndDifferentDefaults() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasWithExplicitMirrorAndDifferentDefaults.class))\n\t\t\t.withMessage(\"Misconfigured aliases: attribute 'a' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasWithExplicitMirrorAndDifferentDefaults.class.getName()\n\t\t\t\t\t\t\t\t+ \"] and attribute 'c' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasWithExplicitMirrorAndDifferentDefaults.class.getName()\n\t\t\t\t\t\t\t\t+ \"] must declare the same default value.\");\n\t}\n\n\t@Test\n\tvoid getDistanceReturnsDistance() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(Mapped.class);\n\t\tassertThat(mappings.get(0).getDistance()).isEqualTo(0);\n\t\tassertThat(mappings.get(1).getDistance()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getAnnotationTypeReturnsAnnotationType() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(Mapped.class);\n\t\tassertThat(mappings.get(0).getAnnotationType()).isEqualTo(Mapped.class);\n\t\tassertThat(mappings.get(1).getAnnotationType()).isEqualTo(MappedTarget.class);\n\t}\n\n\t@Test\n\tvoid getMetaTypeReturnsTypes() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(ThreeDeepA.class);\n\t\tAnnotationTypeMapping mappingC = mappings.get(2);\n\t\tassertThat(mappingC.getMetaTypes()).containsExactly(ThreeDeepA.class, ThreeDeepB.class, ThreeDeepC.class);\n\t}\n\n\t@Test\n\tvoid getAnnotationWhenRootReturnsNull() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(Mapped.class);\n\t\tassertThat(mappings.get(0).getAnnotation()).isNull();\n\t}\n\n\t@Test\n\tvoid getAnnotationWhenMetaAnnotationReturnsAnnotation() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(Mapped.class);\n\t\tassertThat(mappings.get(1).getAnnotation()).isEqualTo(Mapped.class.getAnnotation(MappedTarget.class));\n\t}\n\n\t@Test\n\tvoid getAttributesReturnsAttributes() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(Mapped.class).get(0);\n\t\tAttributeMethods attributes = mapping.getAttributes();\n\t\tassertThat(attributes.size()).isEqualTo(2);\n\t\tassertThat(attributes.get(0).getName()).isEqualTo(\"alias\");\n\t\tassertThat(attributes.get(1).getName()).isEqualTo(\"convention\");\n\t}\n\n\t@Test\n\tvoid getAliasMappingReturnsAttributes() throws Exception {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(Mapped.class).get(1);\n\t\tassertThat(getAliasMapping(mapping, 0)).isEqualTo(Mapped.class.getDeclaredMethod(\"alias\"));\n\t}\n\n\t@Test\n\tvoid getConventionMappingReturnsAttributes() throws Exception {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(Mapped.class).get(1);\n\t\tassertThat(getConventionMapping(mapping, 1)).isEqualTo(Mapped.class.getDeclaredMethod(\"convention\"));\n\t}\n\n\t@Test\n\tvoid getMirrorSetWhenAliasPairReturnsMirrors() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\n\t\tMirrorSets mirrorSets = mapping.getMirrorSets();\n\t\tassertThat(mirrorSets.size()).isEqualTo(1);\n\t\tassertThat(mirrorSets.get(0).size()).isEqualTo(2);\n\t\tassertThat(mirrorSets.get(0).get(0).getName()).isEqualTo(\"a\");\n\t\tassertThat(mirrorSets.get(0).get(1).getName()).isEqualTo(\"b\");\n\t}\n\n\t@Test\n\tvoid getMirrorSetWhenImplicitMirrorsReturnsMirrors() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ImplicitMirrors.class).get(0);\n\t\tMirrorSets mirrorSets = mapping.getMirrorSets();\n\t\tassertThat(mirrorSets.size()).isEqualTo(1);\n\t\tassertThat(mirrorSets.get(0).size()).isEqualTo(2);\n\t\tassertThat(mirrorSets.get(0).get(0).getName()).isEqualTo(\"a\");\n\t\tassertThat(mirrorSets.get(0).get(1).getName()).isEqualTo(\"b\");\n\t}\n\n\t@Test\n\tvoid getMirrorSetWhenThreeDeepReturnsMirrors() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(ThreeDeepA.class);\n\t\tAnnotationTypeMapping mappingA = mappings.get(0);\n\t\tMirrorSets mirrorSetsA = mappingA.getMirrorSets();\n\t\tassertThat(mirrorSetsA.size()).isEqualTo(2);\n\t\tassertThat(getNames(mirrorSetsA.get(0))).containsExactly(\"a1\", \"a2\", \"a3\");\n\t\tAnnotationTypeMapping mappingB = mappings.get(1);\n\t\tMirrorSets mirrorSetsB = mappingB.getMirrorSets();\n\t\tassertThat(mirrorSetsB.size()).isEqualTo(1);\n\t\tassertThat(getNames(mirrorSetsB.get(0))).containsExactly(\"b1\", \"b2\");\n\t\tAnnotationTypeMapping mappingC = mappings.get(2);\n\t\tMirrorSets mirrorSetsC = mappingC.getMirrorSets();\n\t\tassertThat(mirrorSetsC.size()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getAliasMappingWhenThreeDeepReturnsMappedAttributes() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(ThreeDeepA.class);\n\t\tAnnotationTypeMapping mappingA = mappings.get(0);\n\t\tassertThat(getAliasMapping(mappingA, 0)).isNull();\n\t\tassertThat(getAliasMapping(mappingA, 1)).isNull();\n\t\tassertThat(getAliasMapping(mappingA, 2)).isNull();\n\t\tassertThat(getAliasMapping(mappingA, 3)).isNull();\n\t\tassertThat(getAliasMapping(mappingA, 4)).isNull();\n\t\tAnnotationTypeMapping mappingB = mappings.get(1);\n\t\tassertThat(getAliasMapping(mappingB, 0).getName()).isEqualTo(\"a1\");\n\t\tassertThat(getAliasMapping(mappingB, 1).getName()).isEqualTo(\"a1\");\n\t\tAnnotationTypeMapping mappingC = mappings.get(2);\n\t\tassertThat(getAliasMapping(mappingC, 0).getName()).isEqualTo(\"a1\");\n\t\tassertThat(getAliasMapping(mappingC, 1).getName()).isEqualTo(\"a4\");\n\t}\n\n\t@Test\n\tvoid getAliasMappingsWhenHasDefinedAttributesReturnsMappedAttributes() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(DefinedAttributes.class).get(1);\n\t\tassertThat(getAliasMapping(mapping, 0)).isNull();\n\t\tassertThat(getAliasMapping(mapping, 1).getName()).isEqualTo(\"value\");\n\t}\n\n\t@Test\n\tvoid resolveMirrorsWhenAliasPairResolves() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\n\t\tMethod[] resolvedA = resolveMirrorSets(mapping, WithAliasPairA.class, AliasPair.class);\n\t\tassertThat(resolvedA[0].getName()).isEqualTo(\"a\");\n\t\tassertThat(resolvedA[1].getName()).isEqualTo(\"a\");\n\t\tMethod[] resolvedB = resolveMirrorSets(mapping, WithAliasPairB.class, AliasPair.class);\n\t\tassertThat(resolvedB[0].getName()).isEqualTo(\"b\");\n\t\tassertThat(resolvedB[1].getName()).isEqualTo(\"b\");\n\t}\n\n\t@Test\n\tvoid resolveMirrorsWhenHasSameValuesUsesFirst() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\n\t\tMethod[] resolved = resolveMirrorSets(mapping, WithSameValueAliasPair.class, AliasPair.class);\n\t\tassertThat(resolved[0].getName()).isEqualTo(\"a\");\n\t\tassertThat(resolved[1].getName()).isEqualTo(\"a\");\n\t}\n\n\t@Test\n\tvoid resolveMirrorsWhenOnlyHasDefaultValuesUsesFirst() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\n\t\tMethod[] resolved = resolveMirrorSets(mapping, WithDefaultValueAliasPair.class, AliasPair.class);\n\t\tassertThat(resolved[0].getName()).isEqualTo(\"a\");\n\t\tassertThat(resolved[1].getName()).isEqualTo(\"a\");\n\t}\n\n\t@Test\n\tvoid resolveMirrorsWhenHasDifferentValuesThrowsException() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tresolveMirrorSets(mapping, WithDifferentValueAliasPair.class, AliasPair.class))\n\t\t\t.withMessage(\"Different @AliasFor mirror values for annotation [\"\n\t\t\t\t\t\t\t\t+ AliasPair.class.getName() + \"] declared on \"\n\t\t\t\t\t\t\t\t+ WithDifferentValueAliasPair.class.getName()\n\t\t\t\t\t\t\t\t+ \"; attribute 'a' and its alias 'b' are declared with values of [test1] and [test2].\");\n\t}\n\n\t@Test\n\tvoid resolveMirrorsWhenHasWithMultipleRoutesToAliasReturnsMirrors() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(\n\t\t\t\tMultipleRoutesToAliasA.class);\n\t\tAnnotationTypeMapping mappingsA = getMapping(mappings, MultipleRoutesToAliasA.class);\n\t\tassertThat(mappingsA.getMirrorSets().size()).isZero();\n\t\tAnnotationTypeMapping mappingsB = getMapping(mappings, MultipleRoutesToAliasB.class);\n\t\tassertThat(getNames(mappingsB.getMirrorSets().get(0))).containsExactly(\"b1\", \"b2\", \"b3\");\n\t\tAnnotationTypeMapping mappingsC = getMapping(mappings, MultipleRoutesToAliasC.class);\n\t\tassertThat(getNames(mappingsC.getMirrorSets().get(0))).containsExactly(\"c1\", \"c2\");\n\t}\n\n\t@Test\n\tvoid getAliasMappingWhenHasWithMultipleRoutesToAliasReturnsMappedAttributes() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(\n\t\t\t\tMultipleRoutesToAliasA.class);\n\t\tAnnotationTypeMapping mappingsA = getMapping(mappings, MultipleRoutesToAliasA.class);\n\t\tassertThat(getAliasMapping(mappingsA, 0)).isNull();\n\t\tAnnotationTypeMapping mappingsB = getMapping(mappings, MultipleRoutesToAliasB.class);\n\t\tassertThat(getAliasMapping(mappingsB, 0).getName()).isEqualTo(\"a1\");\n\t\tassertThat(getAliasMapping(mappingsB, 1).getName()).isEqualTo(\"a1\");\n\t\tassertThat(getAliasMapping(mappingsB, 2).getName()).isEqualTo(\"a1\");\n\t\tAnnotationTypeMapping mappingsC = getMapping(mappings, MultipleRoutesToAliasC.class);\n\t\tassertThat(getAliasMapping(mappingsC, 0).getName()).isEqualTo(\"a1\");\n\t\tassertThat(getAliasMapping(mappingsC, 1).getName()).isEqualTo(\"a1\");\n\t}\n\n\t@Test\n\tvoid getConventionMappingWhenConventionToExplicitAliasesReturnsMappedAttributes() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(ConventionToExplicitAliases.class);\n\t\tAnnotationTypeMapping mapping = getMapping(mappings, ConventionToExplicitAliasesTarget.class);\n\t\tassertThat(mapping.getConventionMapping(0)).isEqualTo(0);\n\t\tassertThat(mapping.getConventionMapping(1)).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenValueAndDefaultAreNullReturnsTrue() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassValue.class).get(0);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, null, ReflectionUtils::invokeMethod)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenValueAndDefaultMatchReturnsTrue() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassValueWithDefault.class).get(0);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, InputStream.class, ReflectionUtils::invokeMethod)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenClassAndStringNamesMatchReturnsTrue() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassValueWithDefault.class).get(0);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, \"java.io.InputStream\", ReflectionUtils::invokeMethod)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenClassArrayAndStringArrayNamesMatchReturnsTrue() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassArrayValueWithDefault.class).get(0);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0,\n\t\t\t\tnew String[] { \"java.io.InputStream\", \"java.io.OutputStream\" },\n\t\t\t\tReflectionUtils::invokeMethod)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenNestedAnnotationAndExtractedValuesMatchReturnsTrueAndValueSuppliedAsMap() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(NestedValue.class).get(0);\n\t\tMap<String, Object> value = Collections.singletonMap(\"value\", \"java.io.InputStream\");\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, value, TypeMappedAnnotation::extractFromMap)).isTrue();\n\t}\n\n\t@Test // gh-24375\n\tvoid isEquivalentToDefaultValueWhenNestedAnnotationAndExtractedValuesMatchReturnsTrueAndValueSuppliedAsTypeMappedAnnotation() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(NestedValue.class).get(0);\n\t\tMap<String, String> attributes = Collections.singletonMap(\"value\", \"java.io.InputStream\");\n\t\tMergedAnnotation<ClassValue> value = TypeMappedAnnotation.of(getClass().getClassLoader(), null, ClassValue.class, attributes);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, value, TypeMappedAnnotation::extractFromMap)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenNotMatchingReturnsFalse() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassValueWithDefault.class).get(0);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, OutputStream.class, ReflectionUtils::invokeMethod)).isFalse();\n\t}\n\n\tprivate Method[] resolveMirrorSets(AnnotationTypeMapping mapping, Class<?> element,\n\t\t\tClass<? extends Annotation> annotationClass) {\n\t\tAnnotation annotation = element.getAnnotation(annotationClass);\n\t\tint[] resolved = mapping.getMirrorSets().resolve(element.getName(), annotation, ReflectionUtils::invokeMethod);\n\t\tMethod[] result = new Method[resolved.length];\n\t\tfor (int i = 0; i < resolved.length; i++) {\n\t\t\tresult[i] = resolved[i] != -1 ? mapping.getAttributes().get(resolved[i]) : null;\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate @Nullable Method getAliasMapping(AnnotationTypeMapping mapping, int attributeIndex) {\n\t\tint mapped = mapping.getAliasMapping(attributeIndex);\n\t\treturn mapped != -1 ? mapping.getRoot().getAttributes().get(mapped) : null;\n\t}\n\n\tprivate @Nullable Method getConventionMapping(AnnotationTypeMapping mapping, int attributeIndex) {\n\t\tint mapped = mapping.getConventionMapping(attributeIndex);\n\t\treturn mapped != -1 ? mapping.getRoot().getAttributes().get(mapped) : null;\n\t}\n\n\tprivate AnnotationTypeMapping getMapping(AnnotationTypeMappings mappings,\n\t\t\tClass<? extends Annotation> annotationType) {\n\n\t\tfor (AnnotationTypeMapping candidate : getAll(mappings)) {\n\t\t\tif (candidate.getAnnotationType() == annotationType) {\n\t\t\t\treturn candidate;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate List<AnnotationTypeMapping> getAll(AnnotationTypeMappings mappings) {\n\t\t// AnnotationTypeMappings does not implement Iterable so we don't create\n\t\t// too many garbage Iterators\n\t\treturn IntStream.range(0, mappings.size()).mapToObj(mappings::get).collect(toList());\n\t}\n\n\tprivate List<String> getNames(MirrorSet mirrorSet) {\n\t\tList<String> names = new ArrayList<>(mirrorSet.size());\n\t\tfor (int i = 0; i < mirrorSet.size(); i++) {\n\t\t\tnames.add(mirrorSet.get(i).getName());\n\t\t}\n\t\treturn names;\n\t}\n\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SimpleAnnotation {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AA {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ABC {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ABC\n\t@interface AB {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AA\n\t@AB\n\t@interface A {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface B {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@A\n\t@B\n\t@interface MetaAnnotated {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Repeatings {\n\n\t\tRepeating[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(Repeatings.class)\n\t@interface Repeating {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeating\n\t@Repeating\n\t@interface WithRepeatedMetaAnnotations {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@SelfAnnotated\n\t@interface SelfAnnotated {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@LoopB\n\t@interface LoopA {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@LoopA\n\t@interface LoopB {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithBothValueAndAttribute {\n\n\t\t@AliasFor(value = \"bar\", attribute = \"foo\")\n\t\tString test();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForToSelfNonExistingAttribute {\n\n\t\t@AliasFor(\"missing\")\n\t\tString test() default \"\";\n\n\t\tString other() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForToOtherNonExistingAttributeTarget {\n\n\t\tString other() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasForToOtherNonExistingAttributeTarget\n\t@interface AliasForToOtherNonExistingAttribute {\n\n\t\t@AliasFor(annotation = AliasForToOtherNonExistingAttributeTarget.class, attribute = \"missing\")\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForToSelf {\n\n\t\t@AliasFor(\"test\")\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithArrayCompatibleReturnTypesTarget {\n\n\t\tString[] test() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasForWithArrayCompatibleReturnTypesTarget\n\t@interface AliasForWithArrayCompatibleReturnTypes {\n\n\t\t@AliasFor(annotation = AliasForWithArrayCompatibleReturnTypesTarget.class)\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithIncompatibleReturnTypesTarget {\n\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithIncompatibleReturnTypes {\n\n\t\t@AliasFor(annotation = AliasForWithIncompatibleReturnTypesTarget.class)\n\t\tString[] test() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForToSelfAnnotatedToOtherAttribute {\n\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"\";\n\n\t\t@AliasFor(\"c\")\n\t\tString b() default \"\";\n\n\t\t@AliasFor(\"a\")\n\t\tString c() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasPair {\n\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"\";\n\n\t\t@AliasFor(\"a\")\n\t\tString b() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasPair\n\t@interface AliasForWithMixedImplicitAndExplicitAliasesV1 {\n\n\t\t// attempted implicit alias via attribute override\n\t\t@AliasFor(annotation = AliasPair.class, attribute = \"b\")\n\t\tString b() default \"\";\n\n\t\t// explicit local alias\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasPair\n\t@interface AliasForWithMixedImplicitAndExplicitAliasesV2 {\n\n\t\t// attempted implicit alias via attribute override\n\t\t@AliasFor(annotation = AliasPair.class, attribute = \"a\")\n\t\tString b() default \"\";\n\n\t\t// explicit local alias\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForNonMetaAnnotated {\n\n\t\t@AliasFor(annotation = AliasForNonMetaAnnotatedTarget.class)\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForNonMetaAnnotatedTarget {\n\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForSelfWithDifferentDefaults {\n\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"a\";\n\n\t\t@AliasFor(\"a\")\n\t\tString b() default \"b\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForSelfWithMissingDefault {\n\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"a\";\n\n\t\t@AliasFor(\"a\")\n\t\tString b();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasWithExplicitMirrorAndDifferentDefaultsTarget {\n\n\t\tString a() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasWithExplicitMirrorAndDifferentDefaultsTarget\n\t@interface AliasWithExplicitMirrorAndDifferentDefaults {\n\n\t\t@AliasFor(annotation = AliasWithExplicitMirrorAndDifferentDefaultsTarget.class, attribute = \"a\")\n\t\tString a() default \"x\";\n\n\t\t@AliasFor(annotation = AliasWithExplicitMirrorAndDifferentDefaultsTarget.class, attribute = \"a\")\n\t\tString b() default \"x\";\n\n\t\t@AliasFor(annotation = AliasWithExplicitMirrorAndDifferentDefaultsTarget.class, attribute = \"a\")\n\t\tString c() default \"y\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MappedTarget {\n\n\t\tString convention() default \"\";\n\n\t\tString aliasTarget() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@MappedTarget\n\t@interface Mapped {\n\n\t\tString convention() default \"\";\n\n\t\t@AliasFor(annotation = MappedTarget.class, attribute = \"aliasTarget\")\n\t\tString alias() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitMirrorsTarget {\n\n\t\t@AliasFor(\"d\")\n\t\tString c() default \"\";\n\n\t\t@AliasFor(\"c\")\n\t\tString d() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ImplicitMirrorsTarget\n\t@interface ImplicitMirrors {\n\n\t\t@AliasFor(annotation = ImplicitMirrorsTarget.class, attribute = \"c\")\n\t\tString a() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitMirrorsTarget.class, attribute = \"c\")\n\t\tString b() default \"\";\n\t}\n\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ThreeDeepC {\n\n\t\tString c1() default \"\";\n\n\t\tString c2() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ThreeDeepC\n\t@interface ThreeDeepB {\n\n\t\t@AliasFor(annotation = ThreeDeepC.class, attribute = \"c1\")\n\t\tString b1() default \"\";\n\n\t\t@AliasFor(annotation = ThreeDeepC.class, attribute = \"c1\")\n\t\tString b2() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ThreeDeepB\n\t@interface ThreeDeepA {\n\n\t\t@AliasFor(annotation = ThreeDeepB.class, attribute = \"b1\")\n\t\tString a1() default \"\";\n\n\t\t@AliasFor(annotation = ThreeDeepB.class, attribute = \"b2\")\n\t\tString a2() default \"\";\n\n\t\t@AliasFor(annotation = ThreeDeepC.class, attribute = \"c1\")\n\t\tString a3() default \"\";\n\n\t\t@AliasFor(annotation = ThreeDeepC.class, attribute = \"c2\")\n\t\tString a4() default \"\";\n\n\t\t@AliasFor(annotation = ThreeDeepC.class, attribute = \"c2\")\n\t\tString a5() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface DefinedAttributesTarget {\n\n\t\tString a();\n\n\t\tString b() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefinedAttributesTarget(a = \"test\")\n\t@interface DefinedAttributes {\n\n\t\t@AliasFor(annotation = DefinedAttributesTarget.class, attribute = \"b\")\n\t\tString value();\n\t}\n\n\t@AliasPair(a = \"test\")\n\tstatic class WithAliasPairA {\n\t}\n\n\t@AliasPair(b = \"test\")\n\tstatic class WithAliasPairB {\n\t}\n\n\t@AliasPair(a = \"test\", b = \"test\")\n\tstatic class WithSameValueAliasPair {\n\t}\n\n\t@AliasPair(a = \"test1\", b = \"test2\")\n\tstatic class WithDifferentValueAliasPair {\n\t}\n\n\t@AliasPair\n\tstatic class WithDefaultValueAliasPair {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MultipleRoutesToAliasC {\n\n\t\t@AliasFor(\"c2\")\n\t\tString c1() default \"\";\n\n\t\t@AliasFor(\"c1\")\n\t\tString c2() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@MultipleRoutesToAliasC\n\t@interface MultipleRoutesToAliasB {\n\n\t\t@AliasFor(annotation = MultipleRoutesToAliasC.class, attribute = \"c2\")\n\t\tString b1() default \"\";\n\n\t\t@AliasFor(annotation = MultipleRoutesToAliasC.class, attribute = \"c2\")\n\t\tString b2() default \"\";\n\n\t\t@AliasFor(annotation = MultipleRoutesToAliasC.class, attribute = \"c1\")\n\t\tString b3() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@MultipleRoutesToAliasB\n\t@interface MultipleRoutesToAliasA {\n\n\t\t@AliasFor(annotation = MultipleRoutesToAliasB.class, attribute = \"b2\")\n\t\tString a1() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionToExplicitAliasesTarget {\n\n\t\t@AliasFor(\"test\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ConventionToExplicitAliasesTarget\n\t@interface ConventionToExplicitAliases {\n\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ClassValue {\n\n\t\tClass<?> value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ClassValueWithDefault {\n\n\t\tClass<?> value() default InputStream.class;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ClassArrayValueWithDefault {\n\n\t\tClass<?>[] value() default { InputStream.class, OutputStream.class };\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface NestedValue {\n\n\t\tClassValue value() default @ClassValue(InputStream.class);\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.WithAliasPairB",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.WithAliasPairB",
    "headType": "class",
    "relation": "use",
    "tail": "@AliasPair",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.WithAliasPairB",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.IntStream;\n\nimport javax.annotation.Nullable;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.AnnotationTypeMapping.MirrorSets;\nimport org.springframework.core.annotation.AnnotationTypeMapping.MirrorSets.MirrorSet;\nimport org.springframework.util.ReflectionUtils;\n\nimport static java.util.stream.Collectors.toList;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n\n/**\n * Tests for {@link AnnotationTypeMappings} and {@link AnnotationTypeMapping}.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n */\nclass AnnotationTypeMappingsTests {\n\n\t@Test\n\tvoid forAnnotationTypeWhenNoMetaAnnotationsReturnsMappings() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(SimpleAnnotation.class);\n\t\tassertThat(mappings.size()).isEqualTo(1);\n\t\tassertThat(mappings.get(0).getAnnotationType()).isEqualTo(SimpleAnnotation.class);\n\t\tassertThat(getAll(mappings)).flatExtracting(\n\t\t\t\tAnnotationTypeMapping::getAnnotationType).containsExactly(SimpleAnnotation.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenMetaAnnotationsReturnsMappings() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(MetaAnnotated.class);\n\t\tassertThat(mappings.size()).isEqualTo(6);\n\t\tassertThat(getAll(mappings)).flatExtracting(\n\t\t\t\tAnnotationTypeMapping::getAnnotationType).containsExactly(\n\t\t\t\t\t\tMetaAnnotated.class, A.class, B.class, AA.class, AB.class,\n\t\t\t\t\t\tABC.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenHasRepeatingMetaAnnotationReturnsMapping() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(WithRepeatedMetaAnnotations.class);\n\t\tassertThat(mappings.size()).isEqualTo(3);\n\t\tassertThat(getAll(mappings)).flatExtracting(\n\t\t\t\tAnnotationTypeMapping::getAnnotationType).containsExactly(\n\t\t\t\t\t\tWithRepeatedMetaAnnotations.class, Repeating.class, Repeating.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenRepeatableMetaAnnotationIsFiltered() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(WithRepeatedMetaAnnotations.class,\n\t\t\t\tRepeatableContainers.standardRepeatables(), Repeating.class.getName()::equals);\n\t\tassertThat(getAll(mappings)).flatExtracting(AnnotationTypeMapping::getAnnotationType)\n\t\t\t\t.containsExactly(WithRepeatedMetaAnnotations.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenSelfAnnotatedReturnsMapping() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(SelfAnnotated.class);\n\t\tassertThat(mappings.size()).isEqualTo(1);\n\t\tassertThat(getAll(mappings)).flatExtracting(\n\t\t\t\tAnnotationTypeMapping::getAnnotationType).containsExactly(SelfAnnotated.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenFormsLoopReturnsMapping() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(LoopA.class);\n\t\tassertThat(mappings.size()).isEqualTo(2);\n\t\tassertThat(getAll(mappings)).flatExtracting(\n\t\t\t\tAnnotationTypeMapping::getAnnotationType).containsExactly(LoopA.class, LoopB.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenHasAliasForWithBothValueAndAttributeThrowsException() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForWithBothValueAndAttribute.class))\n\t\t\t.withMessage(\"In @AliasFor declared on attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForWithBothValueAndAttribute.class.getName()\n\t\t\t\t\t\t\t\t+ \"], attribute 'attribute' and its alias 'value' are present with values of 'foo' and 'bar', but only one is permitted.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForToSelfNonExistingAttribute() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForToSelfNonExistingAttribute.class))\n\t\t\t.withMessage(\"@AliasFor declaration on attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForToSelfNonExistingAttribute.class.getName()\n\t\t\t\t\t\t\t\t+ \"] declares an alias for 'missing' which is not present.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForToOtherNonExistingAttribute() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForToOtherNonExistingAttribute.class))\n\t\t\t.withMessage(\"Attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForToOtherNonExistingAttribute.class.getName()\n\t\t\t\t\t\t\t\t+ \"] is declared as an @AliasFor nonexistent \"\n\t\t\t\t\t\t\t\t+ \"attribute 'missing' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForToOtherNonExistingAttributeTarget.class.getName()\n\t\t\t\t\t\t\t\t+ \"].\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForToSelf() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForToSelf.class))\n\t\t\t.withMessage(\"@AliasFor declaration on attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForToSelf.class.getName()\n\t\t\t\t\t\t\t\t+ \"] points to itself. Specify 'annotation' to point to \"\n\t\t\t\t\t\t\t\t+ \"a same-named attribute on a meta-annotation.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForWithArrayCompatibleReturnTypes() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(\n\t\t\t\tAliasForWithArrayCompatibleReturnTypes.class);\n\t\tAnnotationTypeMapping mapping = getMapping(mappings,\n\t\t\t\tAliasForWithArrayCompatibleReturnTypesTarget.class);\n\t\tassertThat(getAliasMapping(mapping, 0).getName()).isEqualTo(\"test\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForWithIncompatibleReturnTypes() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForWithIncompatibleReturnTypes.class))\n\t\t\t.withMessage(\"Misconfigured aliases: attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForWithIncompatibleReturnTypes.class.getName()\n\t\t\t\t\t\t\t\t+ \"] and attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForWithIncompatibleReturnTypesTarget.class.getName()\n\t\t\t\t\t\t\t\t+ \"] must declare the same return type.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForToSelfAnnotatedToOtherAttribute() {\n\t\tString annotationType = AliasForToSelfAnnotatedToOtherAttribute.class.getName();\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> AnnotationTypeMappings.forAnnotationType(AliasForToSelfAnnotatedToOtherAttribute.class))\n\t\t\t\t.withMessage(\"Attribute 'b' in annotation [\" + annotationType\n\t\t\t\t\t\t+ \"] must be declared as an @AliasFor attribute 'a' in annotation [\" + annotationType\n\t\t\t\t\t\t+ \"], not attribute 'c' in annotation [\" + annotationType + \"].\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForHasMixedImplicitAndExplicitAliases() {\n\t\tassertMixedImplicitAndExplicitAliases(AliasForWithMixedImplicitAndExplicitAliasesV1.class, \"b\");\n\t\tassertMixedImplicitAndExplicitAliases(AliasForWithMixedImplicitAndExplicitAliasesV2.class, \"a\");\n\t}\n\n\tprivate void assertMixedImplicitAndExplicitAliases(Class<? extends Annotation> annotationType, String overriddenAttribute) {\n\t\tString annotationName = annotationType.getName();\n\t\tString metaAnnotationName = AliasPair.class.getName();\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> AnnotationTypeMappings.forAnnotationType(annotationType))\n\t\t\t\t.withMessage(\"Attribute 'b' in annotation [\" + annotationName\n\t\t\t\t\t\t+ \"] must be declared as an @AliasFor attribute 'a' in annotation [\" + annotationName\n\t\t\t\t\t\t+ \"], not attribute '\" + overriddenAttribute + \"' in annotation [\" + metaAnnotationName + \"].\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForNonMetaAnnotated() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForNonMetaAnnotated.class))\n\t\t\t.withMessage(\"@AliasFor declaration on attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForNonMetaAnnotated.class.getName()\n\t\t\t\t\t\t\t\t+ \"] declares an alias for attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForNonMetaAnnotatedTarget.class.getName()\n\t\t\t\t\t\t\t\t+ \"] which is not meta-present.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForSelfWithDifferentDefaults() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForSelfWithDifferentDefaults.class))\n\t\t\t.withMessage(\"Misconfigured aliases: attribute 'a' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForSelfWithDifferentDefaults.class.getName()\n\t\t\t\t\t\t\t\t+ \"] and attribute 'b' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForSelfWithDifferentDefaults.class.getName()\n\t\t\t\t\t\t\t\t+ \"] must declare the same default value.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForSelfWithMissingDefault() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForSelfWithMissingDefault.class))\n\t\t\t.withMessage(\"Misconfigured aliases: attribute 'a' in annotation [\"\n\t\t\t\t\t\t\t\t\t+ AliasForSelfWithMissingDefault.class.getName()\n\t\t\t\t\t\t\t\t\t+ \"] and attribute 'b' in annotation [\"\n\t\t\t\t\t\t\t\t\t+ AliasForSelfWithMissingDefault.class.getName()\n\t\t\t\t\t\t\t\t\t+ \"] must declare default values.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasWithExplicitMirrorAndDifferentDefaults() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasWithExplicitMirrorAndDifferentDefaults.class))\n\t\t\t.withMessage(\"Misconfigured aliases: attribute 'a' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasWithExplicitMirrorAndDifferentDefaults.class.getName()\n\t\t\t\t\t\t\t\t+ \"] and attribute 'c' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasWithExplicitMirrorAndDifferentDefaults.class.getName()\n\t\t\t\t\t\t\t\t+ \"] must declare the same default value.\");\n\t}\n\n\t@Test\n\tvoid getDistanceReturnsDistance() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(Mapped.class);\n\t\tassertThat(mappings.get(0).getDistance()).isEqualTo(0);\n\t\tassertThat(mappings.get(1).getDistance()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getAnnotationTypeReturnsAnnotationType() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(Mapped.class);\n\t\tassertThat(mappings.get(0).getAnnotationType()).isEqualTo(Mapped.class);\n\t\tassertThat(mappings.get(1).getAnnotationType()).isEqualTo(MappedTarget.class);\n\t}\n\n\t@Test\n\tvoid getMetaTypeReturnsTypes() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(ThreeDeepA.class);\n\t\tAnnotationTypeMapping mappingC = mappings.get(2);\n\t\tassertThat(mappingC.getMetaTypes()).containsExactly(ThreeDeepA.class, ThreeDeepB.class, ThreeDeepC.class);\n\t}\n\n\t@Test\n\tvoid getAnnotationWhenRootReturnsNull() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(Mapped.class);\n\t\tassertThat(mappings.get(0).getAnnotation()).isNull();\n\t}\n\n\t@Test\n\tvoid getAnnotationWhenMetaAnnotationReturnsAnnotation() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(Mapped.class);\n\t\tassertThat(mappings.get(1).getAnnotation()).isEqualTo(Mapped.class.getAnnotation(MappedTarget.class));\n\t}\n\n\t@Test\n\tvoid getAttributesReturnsAttributes() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(Mapped.class).get(0);\n\t\tAttributeMethods attributes = mapping.getAttributes();\n\t\tassertThat(attributes.size()).isEqualTo(2);\n\t\tassertThat(attributes.get(0).getName()).isEqualTo(\"alias\");\n\t\tassertThat(attributes.get(1).getName()).isEqualTo(\"convention\");\n\t}\n\n\t@Test\n\tvoid getAliasMappingReturnsAttributes() throws Exception {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(Mapped.class).get(1);\n\t\tassertThat(getAliasMapping(mapping, 0)).isEqualTo(Mapped.class.getDeclaredMethod(\"alias\"));\n\t}\n\n\t@Test\n\tvoid getConventionMappingReturnsAttributes() throws Exception {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(Mapped.class).get(1);\n\t\tassertThat(getConventionMapping(mapping, 1)).isEqualTo(Mapped.class.getDeclaredMethod(\"convention\"));\n\t}\n\n\t@Test\n\tvoid getMirrorSetWhenAliasPairReturnsMirrors() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\n\t\tMirrorSets mirrorSets = mapping.getMirrorSets();\n\t\tassertThat(mirrorSets.size()).isEqualTo(1);\n\t\tassertThat(mirrorSets.get(0).size()).isEqualTo(2);\n\t\tassertThat(mirrorSets.get(0).get(0).getName()).isEqualTo(\"a\");\n\t\tassertThat(mirrorSets.get(0).get(1).getName()).isEqualTo(\"b\");\n\t}\n\n\t@Test\n\tvoid getMirrorSetWhenImplicitMirrorsReturnsMirrors() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ImplicitMirrors.class).get(0);\n\t\tMirrorSets mirrorSets = mapping.getMirrorSets();\n\t\tassertThat(mirrorSets.size()).isEqualTo(1);\n\t\tassertThat(mirrorSets.get(0).size()).isEqualTo(2);\n\t\tassertThat(mirrorSets.get(0).get(0).getName()).isEqualTo(\"a\");\n\t\tassertThat(mirrorSets.get(0).get(1).getName()).isEqualTo(\"b\");\n\t}\n\n\t@Test\n\tvoid getMirrorSetWhenThreeDeepReturnsMirrors() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(ThreeDeepA.class);\n\t\tAnnotationTypeMapping mappingA = mappings.get(0);\n\t\tMirrorSets mirrorSetsA = mappingA.getMirrorSets();\n\t\tassertThat(mirrorSetsA.size()).isEqualTo(2);\n\t\tassertThat(getNames(mirrorSetsA.get(0))).containsExactly(\"a1\", \"a2\", \"a3\");\n\t\tAnnotationTypeMapping mappingB = mappings.get(1);\n\t\tMirrorSets mirrorSetsB = mappingB.getMirrorSets();\n\t\tassertThat(mirrorSetsB.size()).isEqualTo(1);\n\t\tassertThat(getNames(mirrorSetsB.get(0))).containsExactly(\"b1\", \"b2\");\n\t\tAnnotationTypeMapping mappingC = mappings.get(2);\n\t\tMirrorSets mirrorSetsC = mappingC.getMirrorSets();\n\t\tassertThat(mirrorSetsC.size()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getAliasMappingWhenThreeDeepReturnsMappedAttributes() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(ThreeDeepA.class);\n\t\tAnnotationTypeMapping mappingA = mappings.get(0);\n\t\tassertThat(getAliasMapping(mappingA, 0)).isNull();\n\t\tassertThat(getAliasMapping(mappingA, 1)).isNull();\n\t\tassertThat(getAliasMapping(mappingA, 2)).isNull();\n\t\tassertThat(getAliasMapping(mappingA, 3)).isNull();\n\t\tassertThat(getAliasMapping(mappingA, 4)).isNull();\n\t\tAnnotationTypeMapping mappingB = mappings.get(1);\n\t\tassertThat(getAliasMapping(mappingB, 0).getName()).isEqualTo(\"a1\");\n\t\tassertThat(getAliasMapping(mappingB, 1).getName()).isEqualTo(\"a1\");\n\t\tAnnotationTypeMapping mappingC = mappings.get(2);\n\t\tassertThat(getAliasMapping(mappingC, 0).getName()).isEqualTo(\"a1\");\n\t\tassertThat(getAliasMapping(mappingC, 1).getName()).isEqualTo(\"a4\");\n\t}\n\n\t@Test\n\tvoid getAliasMappingsWhenHasDefinedAttributesReturnsMappedAttributes() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(DefinedAttributes.class).get(1);\n\t\tassertThat(getAliasMapping(mapping, 0)).isNull();\n\t\tassertThat(getAliasMapping(mapping, 1).getName()).isEqualTo(\"value\");\n\t}\n\n\t@Test\n\tvoid resolveMirrorsWhenAliasPairResolves() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\n\t\tMethod[] resolvedA = resolveMirrorSets(mapping, WithAliasPairA.class, AliasPair.class);\n\t\tassertThat(resolvedA[0].getName()).isEqualTo(\"a\");\n\t\tassertThat(resolvedA[1].getName()).isEqualTo(\"a\");\n\t\tMethod[] resolvedB = resolveMirrorSets(mapping, WithAliasPairB.class, AliasPair.class);\n\t\tassertThat(resolvedB[0].getName()).isEqualTo(\"b\");\n\t\tassertThat(resolvedB[1].getName()).isEqualTo(\"b\");\n\t}\n\n\t@Test\n\tvoid resolveMirrorsWhenHasSameValuesUsesFirst() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\n\t\tMethod[] resolved = resolveMirrorSets(mapping, WithSameValueAliasPair.class, AliasPair.class);\n\t\tassertThat(resolved[0].getName()).isEqualTo(\"a\");\n\t\tassertThat(resolved[1].getName()).isEqualTo(\"a\");\n\t}\n\n\t@Test\n\tvoid resolveMirrorsWhenOnlyHasDefaultValuesUsesFirst() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\n\t\tMethod[] resolved = resolveMirrorSets(mapping, WithDefaultValueAliasPair.class, AliasPair.class);\n\t\tassertThat(resolved[0].getName()).isEqualTo(\"a\");\n\t\tassertThat(resolved[1].getName()).isEqualTo(\"a\");\n\t}\n\n\t@Test\n\tvoid resolveMirrorsWhenHasDifferentValuesThrowsException() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tresolveMirrorSets(mapping, WithDifferentValueAliasPair.class, AliasPair.class))\n\t\t\t.withMessage(\"Different @AliasFor mirror values for annotation [\"\n\t\t\t\t\t\t\t\t+ AliasPair.class.getName() + \"] declared on \"\n\t\t\t\t\t\t\t\t+ WithDifferentValueAliasPair.class.getName()\n\t\t\t\t\t\t\t\t+ \"; attribute 'a' and its alias 'b' are declared with values of [test1] and [test2].\");\n\t}\n\n\t@Test\n\tvoid resolveMirrorsWhenHasWithMultipleRoutesToAliasReturnsMirrors() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(\n\t\t\t\tMultipleRoutesToAliasA.class);\n\t\tAnnotationTypeMapping mappingsA = getMapping(mappings, MultipleRoutesToAliasA.class);\n\t\tassertThat(mappingsA.getMirrorSets().size()).isZero();\n\t\tAnnotationTypeMapping mappingsB = getMapping(mappings, MultipleRoutesToAliasB.class);\n\t\tassertThat(getNames(mappingsB.getMirrorSets().get(0))).containsExactly(\"b1\", \"b2\", \"b3\");\n\t\tAnnotationTypeMapping mappingsC = getMapping(mappings, MultipleRoutesToAliasC.class);\n\t\tassertThat(getNames(mappingsC.getMirrorSets().get(0))).containsExactly(\"c1\", \"c2\");\n\t}\n\n\t@Test\n\tvoid getAliasMappingWhenHasWithMultipleRoutesToAliasReturnsMappedAttributes() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(\n\t\t\t\tMultipleRoutesToAliasA.class);\n\t\tAnnotationTypeMapping mappingsA = getMapping(mappings, MultipleRoutesToAliasA.class);\n\t\tassertThat(getAliasMapping(mappingsA, 0)).isNull();\n\t\tAnnotationTypeMapping mappingsB = getMapping(mappings, MultipleRoutesToAliasB.class);\n\t\tassertThat(getAliasMapping(mappingsB, 0).getName()).isEqualTo(\"a1\");\n\t\tassertThat(getAliasMapping(mappingsB, 1).getName()).isEqualTo(\"a1\");\n\t\tassertThat(getAliasMapping(mappingsB, 2).getName()).isEqualTo(\"a1\");\n\t\tAnnotationTypeMapping mappingsC = getMapping(mappings, MultipleRoutesToAliasC.class);\n\t\tassertThat(getAliasMapping(mappingsC, 0).getName()).isEqualTo(\"a1\");\n\t\tassertThat(getAliasMapping(mappingsC, 1).getName()).isEqualTo(\"a1\");\n\t}\n\n\t@Test\n\tvoid getConventionMappingWhenConventionToExplicitAliasesReturnsMappedAttributes() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(ConventionToExplicitAliases.class);\n\t\tAnnotationTypeMapping mapping = getMapping(mappings, ConventionToExplicitAliasesTarget.class);\n\t\tassertThat(mapping.getConventionMapping(0)).isEqualTo(0);\n\t\tassertThat(mapping.getConventionMapping(1)).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenValueAndDefaultAreNullReturnsTrue() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassValue.class).get(0);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, null, ReflectionUtils::invokeMethod)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenValueAndDefaultMatchReturnsTrue() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassValueWithDefault.class).get(0);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, InputStream.class, ReflectionUtils::invokeMethod)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenClassAndStringNamesMatchReturnsTrue() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassValueWithDefault.class).get(0);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, \"java.io.InputStream\", ReflectionUtils::invokeMethod)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenClassArrayAndStringArrayNamesMatchReturnsTrue() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassArrayValueWithDefault.class).get(0);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0,\n\t\t\t\tnew String[] { \"java.io.InputStream\", \"java.io.OutputStream\" },\n\t\t\t\tReflectionUtils::invokeMethod)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenNestedAnnotationAndExtractedValuesMatchReturnsTrueAndValueSuppliedAsMap() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(NestedValue.class).get(0);\n\t\tMap<String, Object> value = Collections.singletonMap(\"value\", \"java.io.InputStream\");\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, value, TypeMappedAnnotation::extractFromMap)).isTrue();\n\t}\n\n\t@Test // gh-24375\n\tvoid isEquivalentToDefaultValueWhenNestedAnnotationAndExtractedValuesMatchReturnsTrueAndValueSuppliedAsTypeMappedAnnotation() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(NestedValue.class).get(0);\n\t\tMap<String, String> attributes = Collections.singletonMap(\"value\", \"java.io.InputStream\");\n\t\tMergedAnnotation<ClassValue> value = TypeMappedAnnotation.of(getClass().getClassLoader(), null, ClassValue.class, attributes);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, value, TypeMappedAnnotation::extractFromMap)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenNotMatchingReturnsFalse() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassValueWithDefault.class).get(0);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, OutputStream.class, ReflectionUtils::invokeMethod)).isFalse();\n\t}\n\n\tprivate Method[] resolveMirrorSets(AnnotationTypeMapping mapping, Class<?> element,\n\t\t\tClass<? extends Annotation> annotationClass) {\n\t\tAnnotation annotation = element.getAnnotation(annotationClass);\n\t\tint[] resolved = mapping.getMirrorSets().resolve(element.getName(), annotation, ReflectionUtils::invokeMethod);\n\t\tMethod[] result = new Method[resolved.length];\n\t\tfor (int i = 0; i < resolved.length; i++) {\n\t\t\tresult[i] = resolved[i] != -1 ? mapping.getAttributes().get(resolved[i]) : null;\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate @Nullable Method getAliasMapping(AnnotationTypeMapping mapping, int attributeIndex) {\n\t\tint mapped = mapping.getAliasMapping(attributeIndex);\n\t\treturn mapped != -1 ? mapping.getRoot().getAttributes().get(mapped) : null;\n\t}\n\n\tprivate @Nullable Method getConventionMapping(AnnotationTypeMapping mapping, int attributeIndex) {\n\t\tint mapped = mapping.getConventionMapping(attributeIndex);\n\t\treturn mapped != -1 ? mapping.getRoot().getAttributes().get(mapped) : null;\n\t}\n\n\tprivate AnnotationTypeMapping getMapping(AnnotationTypeMappings mappings,\n\t\t\tClass<? extends Annotation> annotationType) {\n\n\t\tfor (AnnotationTypeMapping candidate : getAll(mappings)) {\n\t\t\tif (candidate.getAnnotationType() == annotationType) {\n\t\t\t\treturn candidate;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate List<AnnotationTypeMapping> getAll(AnnotationTypeMappings mappings) {\n\t\t// AnnotationTypeMappings does not implement Iterable so we don't create\n\t\t// too many garbage Iterators\n\t\treturn IntStream.range(0, mappings.size()).mapToObj(mappings::get).collect(toList());\n\t}\n\n\tprivate List<String> getNames(MirrorSet mirrorSet) {\n\t\tList<String> names = new ArrayList<>(mirrorSet.size());\n\t\tfor (int i = 0; i < mirrorSet.size(); i++) {\n\t\t\tnames.add(mirrorSet.get(i).getName());\n\t\t}\n\t\treturn names;\n\t}\n\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SimpleAnnotation {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AA {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ABC {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ABC\n\t@interface AB {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AA\n\t@AB\n\t@interface A {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface B {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@A\n\t@B\n\t@interface MetaAnnotated {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Repeatings {\n\n\t\tRepeating[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(Repeatings.class)\n\t@interface Repeating {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeating\n\t@Repeating\n\t@interface WithRepeatedMetaAnnotations {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@SelfAnnotated\n\t@interface SelfAnnotated {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@LoopB\n\t@interface LoopA {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@LoopA\n\t@interface LoopB {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithBothValueAndAttribute {\n\n\t\t@AliasFor(value = \"bar\", attribute = \"foo\")\n\t\tString test();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForToSelfNonExistingAttribute {\n\n\t\t@AliasFor(\"missing\")\n\t\tString test() default \"\";\n\n\t\tString other() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForToOtherNonExistingAttributeTarget {\n\n\t\tString other() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasForToOtherNonExistingAttributeTarget\n\t@interface AliasForToOtherNonExistingAttribute {\n\n\t\t@AliasFor(annotation = AliasForToOtherNonExistingAttributeTarget.class, attribute = \"missing\")\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForToSelf {\n\n\t\t@AliasFor(\"test\")\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithArrayCompatibleReturnTypesTarget {\n\n\t\tString[] test() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasForWithArrayCompatibleReturnTypesTarget\n\t@interface AliasForWithArrayCompatibleReturnTypes {\n\n\t\t@AliasFor(annotation = AliasForWithArrayCompatibleReturnTypesTarget.class)\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithIncompatibleReturnTypesTarget {\n\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithIncompatibleReturnTypes {\n\n\t\t@AliasFor(annotation = AliasForWithIncompatibleReturnTypesTarget.class)\n\t\tString[] test() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForToSelfAnnotatedToOtherAttribute {\n\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"\";\n\n\t\t@AliasFor(\"c\")\n\t\tString b() default \"\";\n\n\t\t@AliasFor(\"a\")\n\t\tString c() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasPair {\n\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"\";\n\n\t\t@AliasFor(\"a\")\n\t\tString b() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasPair\n\t@interface AliasForWithMixedImplicitAndExplicitAliasesV1 {\n\n\t\t// attempted implicit alias via attribute override\n\t\t@AliasFor(annotation = AliasPair.class, attribute = \"b\")\n\t\tString b() default \"\";\n\n\t\t// explicit local alias\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasPair\n\t@interface AliasForWithMixedImplicitAndExplicitAliasesV2 {\n\n\t\t// attempted implicit alias via attribute override\n\t\t@AliasFor(annotation = AliasPair.class, attribute = \"a\")\n\t\tString b() default \"\";\n\n\t\t// explicit local alias\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForNonMetaAnnotated {\n\n\t\t@AliasFor(annotation = AliasForNonMetaAnnotatedTarget.class)\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForNonMetaAnnotatedTarget {\n\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForSelfWithDifferentDefaults {\n\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"a\";\n\n\t\t@AliasFor(\"a\")\n\t\tString b() default \"b\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForSelfWithMissingDefault {\n\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"a\";\n\n\t\t@AliasFor(\"a\")\n\t\tString b();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasWithExplicitMirrorAndDifferentDefaultsTarget {\n\n\t\tString a() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasWithExplicitMirrorAndDifferentDefaultsTarget\n\t@interface AliasWithExplicitMirrorAndDifferentDefaults {\n\n\t\t@AliasFor(annotation = AliasWithExplicitMirrorAndDifferentDefaultsTarget.class, attribute = \"a\")\n\t\tString a() default \"x\";\n\n\t\t@AliasFor(annotation = AliasWithExplicitMirrorAndDifferentDefaultsTarget.class, attribute = \"a\")\n\t\tString b() default \"x\";\n\n\t\t@AliasFor(annotation = AliasWithExplicitMirrorAndDifferentDefaultsTarget.class, attribute = \"a\")\n\t\tString c() default \"y\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MappedTarget {\n\n\t\tString convention() default \"\";\n\n\t\tString aliasTarget() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@MappedTarget\n\t@interface Mapped {\n\n\t\tString convention() default \"\";\n\n\t\t@AliasFor(annotation = MappedTarget.class, attribute = \"aliasTarget\")\n\t\tString alias() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitMirrorsTarget {\n\n\t\t@AliasFor(\"d\")\n\t\tString c() default \"\";\n\n\t\t@AliasFor(\"c\")\n\t\tString d() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ImplicitMirrorsTarget\n\t@interface ImplicitMirrors {\n\n\t\t@AliasFor(annotation = ImplicitMirrorsTarget.class, attribute = \"c\")\n\t\tString a() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitMirrorsTarget.class, attribute = \"c\")\n\t\tString b() default \"\";\n\t}\n\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ThreeDeepC {\n\n\t\tString c1() default \"\";\n\n\t\tString c2() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ThreeDeepC\n\t@interface ThreeDeepB {\n\n\t\t@AliasFor(annotation = ThreeDeepC.class, attribute = \"c1\")\n\t\tString b1() default \"\";\n\n\t\t@AliasFor(annotation = ThreeDeepC.class, attribute = \"c1\")\n\t\tString b2() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ThreeDeepB\n\t@interface ThreeDeepA {\n\n\t\t@AliasFor(annotation = ThreeDeepB.class, attribute = \"b1\")\n\t\tString a1() default \"\";\n\n\t\t@AliasFor(annotation = ThreeDeepB.class, attribute = \"b2\")\n\t\tString a2() default \"\";\n\n\t\t@AliasFor(annotation = ThreeDeepC.class, attribute = \"c1\")\n\t\tString a3() default \"\";\n\n\t\t@AliasFor(annotation = ThreeDeepC.class, attribute = \"c2\")\n\t\tString a4() default \"\";\n\n\t\t@AliasFor(annotation = ThreeDeepC.class, attribute = \"c2\")\n\t\tString a5() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface DefinedAttributesTarget {\n\n\t\tString a();\n\n\t\tString b() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefinedAttributesTarget(a = \"test\")\n\t@interface DefinedAttributes {\n\n\t\t@AliasFor(annotation = DefinedAttributesTarget.class, attribute = \"b\")\n\t\tString value();\n\t}\n\n\t@AliasPair(a = \"test\")\n\tstatic class WithAliasPairA {\n\t}\n\n\t@AliasPair(b = \"test\")\n\tstatic class WithAliasPairB {\n\t}\n\n\t@AliasPair(a = \"test\", b = \"test\")\n\tstatic class WithSameValueAliasPair {\n\t}\n\n\t@AliasPair(a = \"test1\", b = \"test2\")\n\tstatic class WithDifferentValueAliasPair {\n\t}\n\n\t@AliasPair\n\tstatic class WithDefaultValueAliasPair {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MultipleRoutesToAliasC {\n\n\t\t@AliasFor(\"c2\")\n\t\tString c1() default \"\";\n\n\t\t@AliasFor(\"c1\")\n\t\tString c2() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@MultipleRoutesToAliasC\n\t@interface MultipleRoutesToAliasB {\n\n\t\t@AliasFor(annotation = MultipleRoutesToAliasC.class, attribute = \"c2\")\n\t\tString b1() default \"\";\n\n\t\t@AliasFor(annotation = MultipleRoutesToAliasC.class, attribute = \"c2\")\n\t\tString b2() default \"\";\n\n\t\t@AliasFor(annotation = MultipleRoutesToAliasC.class, attribute = \"c1\")\n\t\tString b3() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@MultipleRoutesToAliasB\n\t@interface MultipleRoutesToAliasA {\n\n\t\t@AliasFor(annotation = MultipleRoutesToAliasB.class, attribute = \"b2\")\n\t\tString a1() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionToExplicitAliasesTarget {\n\n\t\t@AliasFor(\"test\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ConventionToExplicitAliasesTarget\n\t@interface ConventionToExplicitAliases {\n\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ClassValue {\n\n\t\tClass<?> value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ClassValueWithDefault {\n\n\t\tClass<?> value() default InputStream.class;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ClassArrayValueWithDefault {\n\n\t\tClass<?>[] value() default { InputStream.class, OutputStream.class };\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface NestedValue {\n\n\t\tClassValue value() default @ClassValue(InputStream.class);\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.WithSameValueAliasPair",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.WithSameValueAliasPair",
    "headType": "class",
    "relation": "use",
    "tail": "@AliasPair",
    "tailType": "annotation"
  }
]