[
  {
    "head": "org.springframework.core.io.support",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.io.support.ResourceRegion",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.io.support.ResourceRegion",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2022 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.io.support;\n\nimport org.springframework.core.io.Resource;\nimport org.springframework.util.Assert;\n\n/**\n * Region of a {@link Resource} implementation, materialized by a {@code position}\n * within the {@link Resource} and a byte {@code count} for the length of that region.\n *\n * @author Arjen Poutsma\n * @since 4.3\n */\npublic class ResourceRegion {\n\n\tprivate final Resource resource;\n\n\tprivate final long position;\n\n\tprivate final long count;\n\n\n\t/**\n\t * Create a new {@code ResourceRegion} from a given {@link Resource}.\n\t * This region of a resource is represented by a start {@code position}\n\t * and a byte {@code count} within the given {@code Resource}.\n\t * @param resource a Resource\n\t * @param position the start position of the region in that resource\n\t * @param count the byte count of the region in that resource\n\t */\n\tpublic ResourceRegion(Resource resource, long position, long count) {\n\t\tAssert.notNull(resource, \"Resource must not be null\");\n\t\tAssert.isTrue(position >= 0, \"'position' must be greater than or equal to 0\");\n\t\tAssert.isTrue(count >= 0, \"'count' must be greater than or equal to 0\");\n\t\tthis.resource = resource;\n\t\tthis.position = position;\n\t\tthis.count = count;\n\t}\n\n\n\t/**\n\t * Return the underlying {@link Resource} for this {@code ResourceRegion}.\n\t */\n\tpublic Resource getResource() {\n\t\treturn this.resource;\n\t}\n\n\t/**\n\t * Return the start position of this region in the underlying {@link Resource}.\n\t */\n\tpublic long getPosition() {\n\t\treturn this.position;\n\t}\n\n\t/**\n\t * Return the byte count of this region in the underlying {@link Resource}.\n\t */\n\tpublic long getCount() {\n\t\treturn this.count;\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.io.support.ResourceRegion",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.io.support.ResourceRegion#resource",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.io.support.ResourceRegion#resource",
    "headType": "field",
    "relation": "haveType",
    "tail": "Resource",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.io.support.ResourceRegion",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.io.support.ResourceRegion#position",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.io.support.ResourceRegion#position",
    "headType": "field",
    "relation": "haveType",
    "tail": "long",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.io.support.ResourceRegion",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.io.support.ResourceRegion#count",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.io.support.ResourceRegion#count",
    "headType": "field",
    "relation": "haveType",
    "tail": "long",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.io.support.ResourceRegion#getResource()",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Return the underlying {@link Resource} for this {@code ResourceRegion}.\r\n */\r\npublic Resource getResource() {\r\n    return this.resource;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.io.support.ResourceRegion",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.io.support.ResourceRegion#getResource()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.io.support.ResourceRegion#getPosition()",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Return the start position of this region in the underlying {@link Resource}.\r\n */\r\npublic long getPosition() {\r\n    return this.position;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.io.support.ResourceRegion",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.io.support.ResourceRegion#getPosition()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.io.support.ResourceRegion#getCount()",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Return the byte count of this region in the underlying {@link Resource}.\r\n */\r\npublic long getCount() {\r\n    return this.count;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.io.support.ResourceRegion",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.io.support.ResourceRegion#getCount()",
    "tailType": "method"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.io.support",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core.io.support",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.io.support.SpringFactoriesLoader",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.io.support.SpringFactoriesLoader",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.io.support;\n\nimport java.io.IOException;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Modifier;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Enumeration;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\nimport kotlin.jvm.JvmClassMappingKt;\nimport kotlin.reflect.KFunction;\nimport kotlin.reflect.KParameter;\nimport kotlin.reflect.full.KClasses;\nimport kotlin.reflect.jvm.KCallablesJvm;\nimport kotlin.reflect.jvm.ReflectJvmMapping;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.core.KotlinDetector;\nimport org.springframework.core.annotation.AnnotationAwareOrderComparator;\nimport org.springframework.core.io.UrlResource;\nimport org.springframework.core.log.LogMessage;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.CollectionUtils;\nimport org.springframework.util.ConcurrentReferenceHashMap;\nimport org.springframework.util.ReflectionUtils;\nimport org.springframework.util.StringUtils;\n\n/**\n * General purpose factory loading mechanism for internal use within the framework.\n *\n * <p>{@code SpringFactoriesLoader} {@linkplain #loadFactories loads} and instantiates\n * factories of a given type from {@value #FACTORIES_RESOURCE_LOCATION} files which\n * may be present in multiple JAR files in the classpath. The {@code spring.factories}\n * file must be in {@link Properties} format, where the key is the fully qualified\n * name of the interface or abstract class, and the value is a comma-separated list of\n * implementation class names. For example:\n *\n * <pre class=\"code\">example.MyService=example.MyServiceImpl1,example.MyServiceImpl2</pre>\n *\n * where {@code example.MyService} is the name of the interface, and {@code MyServiceImpl1}\n * and {@code MyServiceImpl2} are two implementations.\n *\n * <p>Implementation classes <b>must</b> have a single resolvable constructor that will\n * be used to create the instance, either:\n * <ul>\n * <li>a primary or single constructor</li>\n * <li>a single public constructor</li>\n * <li>the default constructor</li>\n * </ul>\n *\n * <p>If the resolvable constructor has arguments, a suitable {@link ArgumentResolver\n * ArgumentResolver} should be provided. To customize how instantiation failures\n * are handled, consider providing a {@link FailureHandler FailureHandler}.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Andy Wilkinson\n * @author Madhura Bhave\n * @author Phillip Webb\n * @since 3.2\n */\npublic class SpringFactoriesLoader {\n\n\t/**\n\t * The location to look for factories.\n\t * <p>Can be present in multiple JAR files.\n\t */\n\tpublic static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\";\n\n\tprivate static final FailureHandler THROWING_FAILURE_HANDLER = FailureHandler.throwing();\n\n\tprivate static final Log logger = LogFactory.getLog(SpringFactoriesLoader.class);\n\n\tstatic final Map<ClassLoader, Map<String, SpringFactoriesLoader>> cache = new ConcurrentReferenceHashMap<>();\n\n\n\tprivate final @Nullable ClassLoader classLoader;\n\n\tprivate final Map<String, List<String>> factories;\n\n\n\t/**\n\t * Create a new {@link SpringFactoriesLoader} instance.\n\t * @param classLoader the classloader used to instantiate the factories\n\t * @param factories a map of factory class name to implementation class names\n\t * @since 6.0\n\t */\n\tprotected SpringFactoriesLoader(@Nullable ClassLoader classLoader, Map<String, List<String>> factories) {\n\t\tthis.classLoader = classLoader;\n\t\tthis.factories = factories;\n\t}\n\n\n\t/**\n\t * Load and instantiate the factory implementations of the given type from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader\n\t * and a default argument resolver that expects a no-arg constructor.\n\t * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\n\t * <p>If a custom instantiation strategy is required, use {@code load(...)}\n\t * with a custom {@link ArgumentResolver ArgumentResolver} and/or\n\t * {@link FailureHandler FailureHandler}.\n\t * <p>As of Spring Framework 5.3, if duplicate implementation class names are\n\t * discovered for a given factory type, only one instance of the duplicated\n\t * implementation type will be instantiated.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @throws IllegalArgumentException if any factory implementation class cannot\n\t * be loaded or if an error occurs while instantiating any factory\n\t * @since 6.0\n\t */\n\tpublic <T> List<T> load(Class<T> factoryType) {\n\t\treturn load(factoryType, null, null);\n\t}\n\n\t/**\n\t * Load and instantiate the factory implementations of the given type from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader\n\t * and the given argument resolver.\n\t * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\n\t * <p>As of Spring Framework 5.3, if duplicate implementation class names are\n\t * discovered for a given factory type, only one instance of the duplicated\n\t * implementation type will be instantiated.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @param argumentResolver strategy used to resolve constructor arguments by their type\n\t * @throws IllegalArgumentException if any factory implementation class cannot\n\t * be loaded or if an error occurs while instantiating any factory\n\t * @since 6.0\n\t */\n\tpublic <T> List<T> load(Class<T> factoryType, @Nullable ArgumentResolver argumentResolver) {\n\t\treturn load(factoryType, argumentResolver, null);\n\t}\n\n\t/**\n\t * Load and instantiate the factory implementations of the given type from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader\n\t * with custom failure handling provided by the given failure handler.\n\t * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\n\t * <p>As of Spring Framework 5.3, if duplicate implementation class names are\n\t * discovered for a given factory type, only one instance of the duplicated\n\t * implementation type will be instantiated.\n\t * <p>For any factory implementation class that cannot be loaded or error that\n\t * occurs while instantiating it, the given failure handler is called.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @param failureHandler strategy used to handle factory instantiation failures\n\t * @since 6.0\n\t */\n\tpublic <T> List<T> load(Class<T> factoryType, @Nullable FailureHandler failureHandler) {\n\t\treturn load(factoryType, null, failureHandler);\n\t}\n\n\t/**\n\t * Load and instantiate the factory implementations of the given type from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader,\n\t * the given argument resolver, and custom failure handling provided by the given\n\t * failure handler.\n\t * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\n\t * <p>As of Spring Framework 5.3, if duplicate implementation class names are\n\t * discovered for a given factory type, only one instance of the duplicated\n\t * implementation type will be instantiated.\n\t * <p>For any factory implementation class that cannot be loaded or error that\n\t * occurs while instantiating it, the given failure handler is called.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @param argumentResolver strategy used to resolve constructor arguments by their type\n\t * @param failureHandler strategy used to handle factory instantiation failures\n\t * @since 6.0\n\t */\n\tpublic <T> List<T> load(Class<T> factoryType, @Nullable ArgumentResolver argumentResolver,\n\t\t\t@Nullable FailureHandler failureHandler) {\n\n\t\tAssert.notNull(factoryType, \"'factoryType' must not be null\");\n\t\tList<String> implementationNames = loadFactoryNames(factoryType);\n\t\tlogger.trace(LogMessage.format(\"Loaded [%s] names: %s\", factoryType.getName(), implementationNames));\n\t\tList<T> result = new ArrayList<>(implementationNames.size());\n\t\tFailureHandler failureHandlerToUse = (failureHandler != null) ? failureHandler : THROWING_FAILURE_HANDLER;\n\t\tfor (String implementationName : implementationNames) {\n\t\t\tT factory = instantiateFactory(implementationName, factoryType, argumentResolver, failureHandlerToUse);\n\t\t\tif (factory != null) {\n\t\t\t\tresult.add(factory);\n\t\t\t}\n\t\t}\n\t\tAnnotationAwareOrderComparator.sort(result);\n\t\treturn result;\n\t}\n\n\tprivate List<String> loadFactoryNames(Class<?> factoryType) {\n\t\treturn this.factories.getOrDefault(factoryType.getName(), Collections.emptyList());\n\t}\n\n\tprotected <T> @Nullable T instantiateFactory(String implementationName, Class<T> type,\n\t\t\t@Nullable ArgumentResolver argumentResolver, FailureHandler failureHandler) {\n\n\t\ttry {\n\t\t\tClass<?> factoryImplementationClass = ClassUtils.forName(implementationName, this.classLoader);\n\t\t\tAssert.isTrue(type.isAssignableFrom(factoryImplementationClass), () ->\n\t\t\t\t\t\"Class [%s] is not assignable to factory type [%s]\".formatted(implementationName, type.getName()));\n\t\t\tFactoryInstantiator<T> factoryInstantiator = FactoryInstantiator.forClass(factoryImplementationClass);\n\t\t\treturn factoryInstantiator.instantiate(argumentResolver);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tfailureHandler.handleFailure(type, implementationName, ex);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t/**\n\t * Load and instantiate the factory implementations of the given type from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the given class loader.\n\t * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\n\t * <p>As of Spring Framework 5.3, if duplicate implementation class names are\n\t * discovered for a given factory type, only one instance of the duplicated\n\t * implementation type will be instantiated.\n\t * <p>For more advanced factory loading with {@link ArgumentResolver} or\n\t * {@link FailureHandler} support use {@link #forDefaultResourceLocation(ClassLoader)}\n\t * to obtain a {@link SpringFactoriesLoader} instance.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @param classLoader the ClassLoader to use for loading (can be {@code null}\n\t * to use the default)\n\t * @throws IllegalArgumentException if any factory implementation class cannot\n\t * be loaded or if an error occurs while instantiating any factory\n\t */\n\tpublic static <T> List<T> loadFactories(Class<T> factoryType, @Nullable ClassLoader classLoader) {\n\t\treturn forDefaultResourceLocation(classLoader).load(factoryType);\n\t}\n\n\t/**\n\t * Load the fully qualified class names of factory implementations of the\n\t * given type from {@value #FACTORIES_RESOURCE_LOCATION}, using the given\n\t * class loader.\n\t * <p>As of Spring Framework 5.3, if a particular implementation class name\n\t * is discovered more than once for the given factory type, duplicates will\n\t * be ignored.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @param classLoader the ClassLoader to use for loading resources; can be\n\t * {@code null} to use the default\n\t * @throws IllegalArgumentException if an error occurs while loading factory names\n\t * @see #loadFactories\n\t * @deprecated as of 6.0 in favor of {@link #load(Class, ArgumentResolver, FailureHandler)}\n\t */\n\t@Deprecated(since = \"6.0\")\n\tpublic static List<String> loadFactoryNames(Class<?> factoryType, @Nullable ClassLoader classLoader) {\n\t\treturn forDefaultResourceLocation(classLoader).loadFactoryNames(factoryType);\n\t}\n\n\t/**\n\t * Create a {@link SpringFactoriesLoader} instance that will load and\n\t * instantiate the factory implementations from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the default class loader.\n\t * @return a {@link SpringFactoriesLoader} instance\n\t * @since 6.0\n\t * @see #forDefaultResourceLocation(ClassLoader)\n\t */\n\tpublic static SpringFactoriesLoader forDefaultResourceLocation() {\n\t\treturn forDefaultResourceLocation(null);\n\t}\n\n\t/**\n\t * Create a {@link SpringFactoriesLoader} instance that will load and\n\t * instantiate the factory implementations from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the given class loader.\n\t * @param classLoader the ClassLoader to use for loading resources; can be\n\t * {@code null} to use the default\n\t * @return a {@link SpringFactoriesLoader} instance\n\t * @since 6.0\n\t * @see #forDefaultResourceLocation()\n\t */\n\tpublic static SpringFactoriesLoader forDefaultResourceLocation(@Nullable ClassLoader classLoader) {\n\t\treturn forResourceLocation(FACTORIES_RESOURCE_LOCATION, classLoader);\n\t}\n\n\t/**\n\t * Create a {@link SpringFactoriesLoader} instance that will load and\n\t * instantiate the factory implementations from the given location,\n\t * using the default class loader.\n\t * @param resourceLocation the resource location to look for factories\n\t * @return a {@link SpringFactoriesLoader} instance\n\t * @since 6.0\n\t * @see #forResourceLocation(String, ClassLoader)\n\t */\n\tpublic static SpringFactoriesLoader forResourceLocation(String resourceLocation) {\n\t\treturn forResourceLocation(resourceLocation, null);\n\t}\n\n\t/**\n\t * Create a {@link SpringFactoriesLoader} instance that will load and\n\t * instantiate the factory implementations from the given location,\n\t * using the given class loader.\n\t * @param resourceLocation the resource location to look for factories\n\t * @param classLoader the ClassLoader to use for loading resources;\n\t * can be {@code null} to use the default\n\t * @return a {@link SpringFactoriesLoader} instance\n\t * @since 6.0\n\t * @see #forResourceLocation(String)\n\t */\n\tpublic static SpringFactoriesLoader forResourceLocation(String resourceLocation, @Nullable ClassLoader classLoader) {\n\t\tAssert.hasText(resourceLocation, \"'resourceLocation' must not be empty\");\n\t\tClassLoader resourceClassLoader = (classLoader != null ? classLoader :\n\t\t\t\tSpringFactoriesLoader.class.getClassLoader());\n\t\tMap<String, SpringFactoriesLoader> loaders = cache.computeIfAbsent(\n\t\t\t\tresourceClassLoader, key -> new ConcurrentReferenceHashMap<>());\n\t\treturn loaders.computeIfAbsent(resourceLocation, key ->\n\t\t\t\tnew SpringFactoriesLoader(classLoader, loadFactoriesResource(resourceClassLoader, resourceLocation)));\n\t}\n\n\tprotected static Map<String, List<String>> loadFactoriesResource(ClassLoader classLoader, String resourceLocation) {\n\t\tMap<String, List<String>> result = new LinkedHashMap<>();\n\t\ttry {\n\t\t\tEnumeration<URL> urls = classLoader.getResources(resourceLocation);\n\t\t\twhile (urls.hasMoreElements()) {\n\t\t\t\tUrlResource resource = new UrlResource(urls.nextElement());\n\t\t\t\tProperties properties = PropertiesLoaderUtils.loadProperties(resource);\n\t\t\t\tproperties.forEach((name, value) -> {\n\t\t\t\t\tString[] factoryImplementationNames = StringUtils.commaDelimitedListToStringArray((String) value);\n\t\t\t\t\tList<String> implementations = result.computeIfAbsent(((String) name).trim(),\n\t\t\t\t\t\t\tkey -> new ArrayList<>(factoryImplementationNames.length));\n\t\t\t\t\tArrays.stream(factoryImplementationNames).map(String::trim).forEach(implementations::add);\n\t\t\t\t});\n\t\t\t}\n\t\t\tresult.replaceAll(SpringFactoriesLoader::toDistinctUnmodifiableList);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalArgumentException(\"Unable to load factories from location [\" + resourceLocation + \"]\", ex);\n\t\t}\n\t\treturn Collections.unmodifiableMap(result);\n\t}\n\n\tprivate static List<String> toDistinctUnmodifiableList(String factoryType, List<String> implementations) {\n\t\treturn implementations.stream().distinct().toList();\n\t}\n\n\n\t/**\n\t * Internal instantiator used to create the factory instance.\n\t * @since 6.0\n\t * @param <T> the instance implementation type\n\t */\n\tstatic final class FactoryInstantiator<T> {\n\n\t\tprivate final Constructor<T> constructor;\n\n\t\tprivate FactoryInstantiator(Constructor<T> constructor) {\n\t\t\tReflectionUtils.makeAccessible(constructor);\n\t\t\tthis.constructor = constructor;\n\t\t}\n\n\t\tT instantiate(@Nullable ArgumentResolver argumentResolver) throws Exception {\n\t\t\tObject[] args = resolveArgs(argumentResolver);\n\t\t\tif (KotlinDetector.isKotlinType(this.constructor.getDeclaringClass())) {\n\t\t\t\treturn KotlinDelegate.instantiate(this.constructor, args);\n\t\t\t}\n\t\t\treturn this.constructor.newInstance(args);\n\t\t}\n\n\t\tprivate Object[] resolveArgs(@Nullable ArgumentResolver argumentResolver) {\n\t\t\tClass<?>[] types = this.constructor.getParameterTypes();\n\t\t\treturn (argumentResolver != null ?\n\t\t\t\t\tArrays.stream(types).map(argumentResolver::resolve).toArray() :\n\t\t\t\t\tnew Object[types.length]);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tstatic <T> FactoryInstantiator<T> forClass(Class<?> factoryImplementationClass) {\n\t\t\tConstructor<?> constructor = findConstructor(factoryImplementationClass);\n\t\t\tAssert.state(constructor != null, () ->\n\t\t\t\t\t\"Class [%s] has no suitable constructor\".formatted(factoryImplementationClass.getName()));\n\t\t\treturn new FactoryInstantiator<>((Constructor<T>) constructor);\n\t\t}\n\n\t\tprivate static @Nullable Constructor<?> findConstructor(Class<?> factoryImplementationClass) {\n\t\t\t// Same algorithm as BeanUtils.getResolvableConstructor\n\t\t\tConstructor<?> constructor = findPrimaryKotlinConstructor(factoryImplementationClass);\n\t\t\tconstructor = (constructor != null ? constructor :\n\t\t\t\t\tfindSingleConstructor(factoryImplementationClass.getConstructors()));\n\t\t\tconstructor = (constructor != null ? constructor :\n\t\t\t\t\tfindSingleConstructor(factoryImplementationClass.getDeclaredConstructors()));\n\t\t\tconstructor = (constructor != null ? constructor :\n\t\t\t\t\tfindDeclaredConstructor(factoryImplementationClass));\n\t\t\treturn constructor;\n\t\t}\n\n\t\tprivate static @Nullable Constructor<?> findPrimaryKotlinConstructor(Class<?> factoryImplementationClass) {\n\t\t\treturn (KotlinDetector.isKotlinType(factoryImplementationClass) ?\n\t\t\t\t\tKotlinDelegate.findPrimaryConstructor(factoryImplementationClass) : null);\n\t\t}\n\n\t\tprivate static @Nullable Constructor<?> findSingleConstructor(Constructor<?>[] constructors) {\n\t\t\treturn (constructors.length == 1 ? constructors[0] : null);\n\t\t}\n\n\t\tprivate static @Nullable Constructor<?> findDeclaredConstructor(Class<?> factoryImplementationClass) {\n\t\t\ttry {\n\t\t\t\treturn factoryImplementationClass.getDeclaredConstructor();\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Nested class to avoid a hard dependency on Kotlin at runtime.\n\t * @since 6.0\n\t */\n\tprivate static class KotlinDelegate {\n\n\t\tstatic <T> @Nullable Constructor<T> findPrimaryConstructor(Class<T> clazz) {\n\t\t\ttry {\n\t\t\t\tKFunction<T> primaryConstructor = KClasses.getPrimaryConstructor(JvmClassMappingKt.getKotlinClass(clazz));\n\t\t\t\tif (primaryConstructor != null) {\n\t\t\t\t\tConstructor<T> constructor = ReflectJvmMapping.getJavaConstructor(\n\t\t\t\t\t\t\tprimaryConstructor);\n\t\t\t\t\tAssert.state(constructor != null, () ->\n\t\t\t\t\t\t\t\"Failed to find Java constructor for Kotlin primary constructor: \" + clazz.getName());\n\t\t\t\t\treturn constructor;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (UnsupportedOperationException ex) {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tstatic <T> T instantiate(Constructor<T> constructor, Object[] args) throws Exception {\n\t\t\tKFunction<T> kotlinConstructor = ReflectJvmMapping.getKotlinFunction(constructor);\n\t\t\tif (kotlinConstructor == null) {\n\t\t\t\treturn constructor.newInstance(args);\n\t\t\t}\n\t\t\tmakeAccessible(constructor, kotlinConstructor);\n\t\t\treturn instantiate(kotlinConstructor, convertArgs(args, kotlinConstructor.getParameters()));\n\t\t}\n\n\t\tprivate static <T> void makeAccessible(Constructor<T> constructor,\n\t\t\t\tKFunction<T> kotlinConstructor) {\n\t\t\tif ((!Modifier.isPublic(constructor.getModifiers())\n\t\t\t\t\t|| !Modifier.isPublic(constructor.getDeclaringClass().getModifiers()))) {\n\t\t\t\tKCallablesJvm.setAccessible(kotlinConstructor, true);\n\t\t\t}\n\t\t}\n\n\t\tprivate static Map<KParameter, Object> convertArgs(Object[] args, List<KParameter> parameters) {\n\t\t\tMap<KParameter, Object> result = CollectionUtils.newHashMap(parameters.size());\n\t\t\tAssert.isTrue(args.length <= parameters.size(),\n\t\t\t\t\t\"Number of provided arguments should be less than or equal to the number of constructor parameters\");\n\t\t\tfor (int i = 0; i < args.length; i++) {\n\t\t\t\tif (!parameters.get(i).isOptional() || args[i] != null) {\n\t\t\t\t\tresult.put(parameters.get(i), args[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tprivate static <T> T instantiate(KFunction<T> kotlinConstructor, Map<KParameter, Object> args) {\n\t\t\treturn kotlinConstructor.callBy(args);\n\t\t}\n\t}\n\n\n\t/**\n\t * Strategy for resolving constructor arguments based on their type.\n\t * @since 6.0\n\t * @see ArgumentResolver#of(Class, Object)\n\t * @see ArgumentResolver#ofSupplied(Class, Supplier)\n\t * @see ArgumentResolver#from(Function)\n\t */\n\t@FunctionalInterface\n\tpublic interface ArgumentResolver {\n\n\t\t/**\n\t\t * Resolve the given argument if possible.\n\t\t * @param <T> the argument type\n\t\t * @param type the argument type\n\t\t * @return the resolved argument value or {@code null}\n\t\t */\n\t\t<T> @Nullable T resolve(Class<T> type);\n\n\t\t/**\n\t\t * Create a new composed {@link ArgumentResolver} by combining this resolver\n\t\t * with the given type and value.\n\t\t * @param <T> the argument type\n\t\t * @param type the argument type\n\t\t * @param value the argument value\n\t\t * @return a new composite {@link ArgumentResolver} instance\n\t\t */\n\t\tdefault <T> ArgumentResolver and(Class<T> type, T value) {\n\t\t\treturn and(ArgumentResolver.of(type, value));\n\t\t}\n\n\t\t/**\n\t\t * Create a new composed {@link ArgumentResolver} by combining this resolver\n\t\t * with the given type and value.\n\t\t * @param <T> the argument type\n\t\t * @param type the argument type\n\t\t * @param valueSupplier the argument value supplier\n\t\t * @return a new composite {@link ArgumentResolver} instance\n\t\t */\n\t\tdefault <T> ArgumentResolver andSupplied(Class<T> type, Supplier<T> valueSupplier) {\n\t\t\treturn and(ArgumentResolver.ofSupplied(type, valueSupplier));\n\t\t}\n\n\t\t/**\n\t\t * Create a new composed {@link ArgumentResolver} by combining this resolver\n\t\t * with the given resolver.\n\t\t * @param argumentResolver the argument resolver to add\n\t\t * @return a new composite {@link ArgumentResolver} instance\n\t\t */\n\t\tdefault ArgumentResolver and(ArgumentResolver argumentResolver) {\n\t\t\treturn from(type -> {\n\t\t\t\tObject resolved = resolve(type);\n\t\t\t\treturn (resolved != null ? resolved : argumentResolver.resolve(type));\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Factory method that returns an {@link ArgumentResolver} that always\n\t\t * returns {@code null}.\n\t\t * @return a new {@link ArgumentResolver} instance\n\t\t */\n\t\tstatic ArgumentResolver none() {\n\t\t\treturn from(type -> null);\n\t\t}\n\n\t\t/**\n\t\t * Factory method that can be used to create an {@link ArgumentResolver}\n\t\t * that resolves only the given type.\n\t\t * @param <T> the argument type\n\t\t * @param type the argument type\n\t\t * @param value the argument value\n\t\t * @return a new {@link ArgumentResolver} instance\n\t\t */\n\t\tstatic <T> ArgumentResolver of(Class<T> type, T value) {\n\t\t\treturn ofSupplied(type, () -> value);\n\t\t}\n\n\t\t/**\n\t\t * Factory method that can be used to create an {@link ArgumentResolver}\n\t\t * that resolves only the given type.\n\t\t * @param <T> the argument type\n\t\t * @param type the argument type\n\t\t * @param valueSupplier the argument value supplier\n\t\t * @return a new {@link ArgumentResolver} instance\n\t\t */\n\t\tstatic <T> ArgumentResolver ofSupplied(Class<T> type, Supplier<T> valueSupplier) {\n\t\t\treturn from(candidateType -> (candidateType.equals(type) ? valueSupplier.get() : null));\n\t\t}\n\n\t\t/**\n\t\t * Factory method that creates a new {@link ArgumentResolver} from a\n\t\t * lambda friendly function. The given function is provided with the\n\t\t * argument type and must provide an instance of that type or {@code null}.\n\t\t * @param function the resolver function\n\t\t * @return a new {@link ArgumentResolver} instance backed by the function\n\t\t */\n\t\tstatic ArgumentResolver from(Function<Class<?>, @Nullable Object> function) {\n\t\t\treturn new ArgumentResolver() {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t@Override\n\t\t\t\tpublic <T> @Nullable T resolve(Class<T> type) {\n\t\t\t\t\treturn (T) function.apply(type);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\n\t/**\n\t * Strategy for handling a failure that occurs when instantiating a factory.\n\t * @since 6.0\n\t * @see FailureHandler#throwing()\n\t * @see FailureHandler#logging(Log)\n\t */\n\t@FunctionalInterface\n\tpublic interface FailureHandler {\n\n\t\t/**\n\t\t * Handle the {@code failure} that occurred when instantiating the\n\t\t * {@code factoryImplementationName} that was expected to be of the\n\t\t * given {@code factoryType}.\n\t\t * @param factoryType the type of the factory\n\t\t * @param factoryImplementationName the name of the factory implementation\n\t\t * @param failure the failure that occurred\n\t\t * @see #throwing()\n\t\t * @see #logging\n\t\t */\n\t\tvoid handleFailure(Class<?> factoryType, String factoryImplementationName, Throwable failure);\n\n\n\t\t/**\n\t\t * Create a new {@link FailureHandler} that handles errors by throwing an\n\t\t * {@link IllegalArgumentException}.\n\t\t * @return a new {@link FailureHandler} instance\n\t\t * @see #throwing(BiFunction)\n\t\t */\n\t\tstatic FailureHandler throwing() {\n\t\t\treturn throwing(IllegalArgumentException::new);\n\t\t}\n\n\t\t/**\n\t\t * Create a new {@link FailureHandler} that handles errors by throwing an\n\t\t * exception.\n\t\t * @param exceptionFactory factory used to create the exception\n\t\t * @return a new {@link FailureHandler} instance\n\t\t */\n\t\tstatic FailureHandler throwing(BiFunction<String, Throwable, ? extends RuntimeException> exceptionFactory) {\n\t\t\treturn handleMessage((messageSupplier, failure) -> {\n\t\t\t\tthrow exceptionFactory.apply(messageSupplier.get(), failure);\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Create a new {@link FailureHandler} that handles errors by logging trace\n\t\t * messages.\n\t\t * @param logger the logger used to log messages\n\t\t * @return a new {@link FailureHandler} instance\n\t\t */\n\t\tstatic FailureHandler logging(Log logger) {\n\t\t\treturn handleMessage((messageSupplier, failure) -> logger.trace(LogMessage.of(messageSupplier), failure));\n\t\t}\n\n\t\t/**\n\t\t * Create a new {@link FailureHandler} that handles errors using a standard\n\t\t * formatted message.\n\t\t * @param messageHandler the message handler used to handle the problem\n\t\t * @return a new {@link FailureHandler} instance\n\t\t */\n\t\tstatic FailureHandler handleMessage(BiConsumer<Supplier<String>, Throwable> messageHandler) {\n\t\t\treturn (factoryType, factoryImplementationName, failure) -> {\n\t\t\t\tSupplier<String> messageSupplier = () -> \"Unable to instantiate factory class [%s] for factory type [%s]\"\n\t\t\t\t\t\t.formatted(factoryImplementationName, factoryType.getName());\n\t\t\t\tmessageHandler.accept(messageSupplier, failure);\n\t\t\t};\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.io.support.SpringFactoriesLoader",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.io.support.SpringFactoriesLoader#FACTORIES_RESOURCE_LOCATION",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.io.support.SpringFactoriesLoader#FACTORIES_RESOURCE_LOCATION",
    "headType": "field",
    "relation": "haveType",
    "tail": "String",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.io.support.SpringFactoriesLoader",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.io.support.SpringFactoriesLoader#THROWING_FAILURE_HANDLER",
    "tailType": "field"
  }
]