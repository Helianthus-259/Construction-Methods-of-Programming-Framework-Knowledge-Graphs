[
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.AddTask",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.AddTask",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLongArray;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.function.Function;\n\nimport org.jspecify.annotations.Nullable;\n\n/**\n * Simple LRU (Least Recently Used) cache, bounded by a specified cache capacity.\n * <p>This is a simplified, opinionated implementation of an LRU cache for internal\n * use in Spring Framework. It is inspired from\n * <a href=\"https://github.com/ben-manes/concurrentlinkedhashmap\">ConcurrentLinkedHashMap</a>.\n * <p>Read and write operations are internally recorded in dedicated buffers,\n * then drained at chosen times to avoid contention.\n *\n * @author Brian Clozel\n * @author Ben Manes\n * @since 5.3\n * @param <K> the type of the key used for cache retrieval\n * @param <V> the type of the cached values, does not allow null values\n * @see #get(Object)\n */\n@SuppressWarnings({\"unchecked\", \"NullAway\"})\npublic final class ConcurrentLruCache<K, V> {\n\n\tprivate final int capacity;\n\n\tprivate final AtomicInteger currentSize = new AtomicInteger();\n\n\tprivate final ConcurrentMap<K, Node<K, V>> cache;\n\n\tprivate final Function<K, V> generator;\n\n\tprivate final ReadOperations<K, V> readOperations;\n\n\tprivate final WriteOperations writeOperations;\n\n\tprivate final Lock evictionLock = new ReentrantLock();\n\n\t/*\n\t * Queue that contains all ACTIVE cache entries, ordered with least recently used entries first.\n\t * Read and write operations are buffered and periodically processed to reorder the queue.\n\t */\n\tprivate final EvictionQueue<K, V> evictionQueue = new EvictionQueue<>();\n\n\tprivate final AtomicReference<DrainStatus> drainStatus = new AtomicReference<>(DrainStatus.IDLE);\n\n\t/**\n\t * Create a new cache instance with the given capacity and generator function.\n\t * @param capacity the maximum number of entries in the cache\n\t * (0 indicates no caching, always generating a new value)\n\t * @param generator a function to generate a new value for a given key\n\t */\n\tpublic ConcurrentLruCache(int capacity, Function<K, V> generator) {\n\t\tthis(capacity, generator, 16);\n\t}\n\n\tprivate ConcurrentLruCache(int capacity, Function<K, V> generator, int concurrencyLevel) {\n\t\tAssert.isTrue(capacity >= 0, \"Capacity must be >= 0\");\n\t\tthis.capacity = capacity;\n\t\tthis.cache = new ConcurrentHashMap<>(16, 0.75f, concurrencyLevel);\n\t\tthis.generator = generator;\n\t\tthis.readOperations = new ReadOperations<>(this.evictionQueue);\n\t\tthis.writeOperations = new WriteOperations();\n\t}\n\n\t/**\n\t * Retrieve an entry from the cache, potentially triggering generation of the value.\n\t * @param key the key to retrieve the entry for\n\t * @return the cached or newly generated value\n\t */\n\tpublic V get(K key) {\n\t\tif (this.capacity == 0) {\n\t\t\treturn this.generator.apply(key);\n\t\t}\n\t\tfinal Node<K, V> node = this.cache.get(key);\n\t\tif (node == null) {\n\t\t\tV value = this.generator.apply(key);\n\t\t\tput(key, value);\n\t\t\treturn value;\n\t\t}\n\t\tprocessRead(node);\n\t\treturn node.getValue();\n\t}\n\n\tprivate void put(K key, V value) {\n\t\tAssert.notNull(key, \"key must not be null\");\n\t\tAssert.notNull(value, \"value must not be null\");\n\t\tfinal CacheEntry<V> cacheEntry = new CacheEntry<>(value, CacheEntryState.ACTIVE);\n\t\tfinal Node<K, V> node = new Node<>(key, cacheEntry);\n\t\tfinal Node<K, V> prior = this.cache.putIfAbsent(node.key, node);\n\t\tif (prior == null) {\n\t\t\tprocessWrite(new AddTask(node));\n\t\t}\n\t\telse {\n\t\t\tprocessRead(prior);\n\t\t}\n\t}\n\n\tprivate void processRead(Node<K, V> node) {\n\t\tboolean drainRequested = this.readOperations.recordRead(node);\n\t\tfinal DrainStatus status = this.drainStatus.get();\n\t\tif (status.shouldDrainBuffers(drainRequested)) {\n\t\t\tdrainOperations();\n\t\t}\n\t}\n\n\tprivate void processWrite(Runnable task) {\n\t\tthis.writeOperations.add(task);\n\t\tthis.drainStatus.lazySet(DrainStatus.REQUIRED);\n\t\tdrainOperations();\n\t}\n\n\tprivate void drainOperations() {\n\t\tif (this.evictionLock.tryLock()) {\n\t\t\ttry {\n\t\t\t\tthis.drainStatus.lazySet(DrainStatus.PROCESSING);\n\t\t\t\tthis.readOperations.drain();\n\t\t\t\tthis.writeOperations.drain();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.drainStatus.compareAndSet(DrainStatus.PROCESSING, DrainStatus.IDLE);\n\t\t\t\tthis.evictionLock.unlock();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Return the maximum number of entries in the cache.\n\t * @see #size()\n\t */\n\tpublic int capacity() {\n\t\treturn this.capacity;\n\t}\n\n\t/**\n\t * Return the maximum number of entries in the cache.\n\t * @deprecated in favor of {@link #capacity()} as of 6.0.\n\t */\n\t@Deprecated(since = \"6.0\")\n\tpublic int sizeLimit() {\n\t\treturn this.capacity;\n\t}\n\n\t/**\n\t * Return the current size of the cache.\n\t * @see #capacity()\n\t */\n\tpublic int size() {\n\t\treturn this.cache.size();\n\t}\n\n\t/**\n\t * Immediately remove all entries from this cache.\n\t */\n\tpublic void clear() {\n\t\tthis.evictionLock.lock();\n\t\ttry {\n\t\t\tNode<K, V> node;\n\t\t\twhile ((node = this.evictionQueue.poll()) != null) {\n\t\t\t\tthis.cache.remove(node.key, node);\n\t\t\t\tmarkAsRemoved(node);\n\t\t\t}\n\t\t\tthis.readOperations.clear();\n\t\t\tthis.writeOperations.drainAll();\n\t\t}\n\t\tfinally {\n\t\t\tthis.evictionLock.unlock();\n\t\t}\n\t}\n\n\t/*\n\t * Transition the node to the {@code removed} state and decrement the current size of the cache.\n\t */\n\tprivate void markAsRemoved(Node<K, V> node) {\n\t\tfor (; ; ) {\n\t\t\tCacheEntry<V> current = node.get();\n\t\t\tCacheEntry<V> removed = new CacheEntry<>(current.value, CacheEntryState.REMOVED);\n\t\t\tif (node.compareAndSet(current, removed)) {\n\t\t\t\tthis.currentSize.lazySet(this.currentSize.get() - 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Determine whether the given key is present in this cache.\n\t * @param key the key to check for\n\t * @return {@code true} if the key is present, {@code false} if there was no matching key\n\t */\n\tpublic boolean contains(K key) {\n\t\treturn this.cache.containsKey(key);\n\t}\n\n\t/**\n\t * Immediately remove the given key and any associated value.\n\t * @param key the key to evict the entry for\n\t * @return {@code true} if the key was present before,\n\t * {@code false} if there was no matching key\n\t */\n\tpublic boolean remove(K key) {\n\t\tfinal Node<K, V> node = this.cache.remove(key);\n\t\tif (node == null) {\n\t\t\treturn false;\n\t\t}\n\t\tmarkForRemoval(node);\n\t\tprocessWrite(new RemovalTask(node));\n\t\treturn true;\n\t}\n\n\t/*\n\t * Transition the node from the {@code active} state to the {@code pending removal} state,\n\t * if the transition is valid.\n\t */\n\tprivate void markForRemoval(Node<K, V> node) {\n\t\tfor (; ; ) {\n\t\t\tfinal CacheEntry<V> current = node.get();\n\t\t\tif (!current.isActive()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfinal CacheEntry<V> pendingRemoval = new CacheEntry<>(current.value, CacheEntryState.PENDING_REMOVAL);\n\t\t\tif (node.compareAndSet(current, pendingRemoval)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Write operation recorded when a new entry is added to the cache.\n\t */\n\tprivate final class AddTask implements Runnable {\n\t\tfinal Node<K, V> node;\n\n\t\tAddTask(Node<K, V> node) {\n\t\t\tthis.node = node;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tcurrentSize.lazySet(currentSize.get() + 1);\n\t\t\tif (this.node.get().isActive()) {\n\t\t\t\tevictionQueue.add(this.node);\n\t\t\t\tevictEntries();\n\t\t\t}\n\t\t}\n\n\t\tprivate void evictEntries() {\n\t\t\twhile (currentSize.get() > capacity) {\n\t\t\t\tfinal Node<K, V> node = evictionQueue.poll();\n\t\t\t\tif (node == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcache.remove(node.key, node);\n\t\t\t\tmarkAsRemoved(node);\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\t/**\n\t * Write operation recorded when an entry is removed to the cache.\n\t */\n\tprivate final class RemovalTask implements Runnable {\n\t\tfinal Node<K, V> node;\n\n\t\tRemovalTask(Node<K, V> node) {\n\t\t\tthis.node = node;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tevictionQueue.remove(this.node);\n\t\t\tmarkAsRemoved(this.node);\n\t\t}\n\t}\n\n\n\t/*\n\t * Draining status for the read/write buffers.\n\t */\n\tprivate enum DrainStatus {\n\n\t\t/*\n\t\t * No drain operation currently running.\n\t\t */\n\t\tIDLE {\n\t\t\t@Override\n\t\t\tboolean shouldDrainBuffers(boolean delayable) {\n\t\t\t\treturn !delayable;\n\t\t\t}\n\t\t},\n\n\t\t/*\n\t\t * A drain operation is required due to a pending write modification.\n\t\t */\n\t\tREQUIRED {\n\t\t\t@Override\n\t\t\tboolean shouldDrainBuffers(boolean delayable) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\n\t\t/*\n\t\t * A drain operation is in progress.\n\t\t */\n\t\tPROCESSING {\n\t\t\t@Override\n\t\t\tboolean shouldDrainBuffers(boolean delayable) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Determine whether the buffers should be drained.\n\t\t * @param delayable if a drain should be delayed until required\n\t\t * @return if a drain should be attempted\n\t\t */\n\t\tabstract boolean shouldDrainBuffers(boolean delayable);\n\t}\n\n\tprivate enum CacheEntryState {\n\t\tACTIVE, PENDING_REMOVAL, REMOVED\n\t}\n\n\tprivate record CacheEntry<V>(V value, CacheEntryState state) {\n\n\t\tboolean isActive() {\n\t\t\treturn this.state == CacheEntryState.ACTIVE;\n\t\t}\n\t}\n\n\tprivate static final class ReadOperations<K, V> {\n\n\t\tprivate static final int BUFFER_COUNT = detectNumberOfBuffers();\n\n\t\tprivate static int detectNumberOfBuffers() {\n\t\t\tint availableProcessors = Runtime.getRuntime().availableProcessors();\n\t\t\tint nextPowerOfTwo = 1 << (Integer.SIZE - Integer.numberOfLeadingZeros(availableProcessors - 1));\n\t\t\treturn Math.min(4, nextPowerOfTwo);\n\t\t}\n\n\t\tprivate static final int BUFFERS_MASK = BUFFER_COUNT - 1;\n\n\t\tprivate static final int MAX_PENDING_OPERATIONS = 32;\n\n\t\tprivate static final int MAX_DRAIN_COUNT = 2 * MAX_PENDING_OPERATIONS;\n\n\t\tprivate static final int BUFFER_SIZE = 2 * MAX_DRAIN_COUNT;\n\n\t\tprivate static final int BUFFER_INDEX_MASK = BUFFER_SIZE - 1;\n\n\t\t/*\n\t\t * Number of operations recorded, for each buffer\n\t\t */\n\t\tprivate final AtomicLongArray recordedCount = new AtomicLongArray(BUFFER_COUNT);\n\n\t\t/*\n\t\t * Number of operations read, for each buffer\n\t\t */\n\t\tprivate final long[] readCount = new long[BUFFER_COUNT];\n\n\t\t/*\n\t\t * Number of operations processed, for each buffer\n\t\t */\n\t\tprivate final AtomicLongArray processedCount = new AtomicLongArray(BUFFER_COUNT);\n\n\t\t@SuppressWarnings(\"rawtypes\")\n\t\tprivate final AtomicReferenceArray<Node<K, V>>[] buffers = new AtomicReferenceArray[BUFFER_COUNT];\n\n\t\tprivate final EvictionQueue<K, V> evictionQueue;\n\n\t\tReadOperations(EvictionQueue<K, V> evictionQueue) {\n\t\t\tthis.evictionQueue = evictionQueue;\n\t\t\tfor (int i = 0; i < BUFFER_COUNT; i++) {\n\t\t\t\tthis.buffers[i] = new AtomicReferenceArray<>(BUFFER_SIZE);\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"deprecation\")  // for Thread.getId() on JDK 19\n\t\tprivate static int getBufferIndex() {\n\t\t\treturn ((int) Thread.currentThread().getId()) & BUFFERS_MASK;\n\t\t}\n\n\t\tboolean recordRead(Node<K, V> node) {\n\t\t\tint bufferIndex = getBufferIndex();\n\t\t\tfinal long writeCount = this.recordedCount.get(bufferIndex);\n\t\t\tthis.recordedCount.lazySet(bufferIndex, writeCount + 1);\n\t\t\tfinal int index = (int) (writeCount & BUFFER_INDEX_MASK);\n\t\t\tthis.buffers[bufferIndex].lazySet(index, node);\n\t\t\tfinal long pending = (writeCount - this.processedCount.get(bufferIndex));\n\t\t\treturn (pending < MAX_PENDING_OPERATIONS);\n\t\t}\n\n\t\t@SuppressWarnings(\"deprecation\")  // for Thread.getId() on JDK 19\n\t\tvoid drain() {\n\t\t\tfinal int start = (int) Thread.currentThread().getId();\n\t\t\tfinal int end = start + BUFFER_COUNT;\n\t\t\tfor (int i = start; i < end; i++) {\n\t\t\t\tdrainReadBuffer(i & BUFFERS_MASK);\n\t\t\t}\n\t\t}\n\n\t\tvoid clear() {\n\t\t\tfor (int i = 0; i < BUFFER_COUNT; i++) {\n\t\t\t\tAtomicReferenceArray<Node<K, V>> buffer = this.buffers[i];\n\t\t\t\tfor (int j = 0; j < BUFFER_SIZE; j++) {\n\t\t\t\t\tbuffer.lazySet(j, null);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void drainReadBuffer(int bufferIndex) {\n\t\t\tfinal long writeCount = this.recordedCount.get(bufferIndex);\n\t\t\tfor (int i = 0; i < MAX_DRAIN_COUNT; i++) {\n\t\t\t\tfinal int index = (int) (this.readCount[bufferIndex] & BUFFER_INDEX_MASK);\n\t\t\t\tfinal AtomicReferenceArray<Node<K, V>> buffer = this.buffers[bufferIndex];\n\t\t\t\tfinal Node<K, V> node = buffer.get(index);\n\t\t\t\tif (node == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbuffer.lazySet(index, null);\n\t\t\t\tthis.evictionQueue.moveToBack(node);\n\t\t\t\tthis.readCount[bufferIndex]++;\n\t\t\t}\n\t\t\tthis.processedCount.lazySet(bufferIndex, writeCount);\n\t\t}\n\t}\n\n\tprivate static final class WriteOperations {\n\n\t\tprivate static final int DRAIN_THRESHOLD = 16;\n\n\t\tprivate final Queue<Runnable> operations = new ConcurrentLinkedQueue<>();\n\n\t\tpublic void add(Runnable task) {\n\t\t\tthis.operations.add(task);\n\t\t}\n\n\t\tpublic void drain() {\n\t\t\tfor (int i = 0; i < DRAIN_THRESHOLD; i++) {\n\t\t\t\tfinal Runnable task = this.operations.poll();\n\t\t\t\tif (task == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttask.run();\n\t\t\t}\n\t\t}\n\n\t\tpublic void drainAll() {\n\t\t\tRunnable task;\n\t\t\twhile ((task = this.operations.poll()) != null) {\n\t\t\t\ttask.run();\n\t\t\t}\n\t\t}\n\n\t}\n\n\t@SuppressWarnings(\"serial\")\n\tprivate static final class Node<K, V> extends AtomicReference<CacheEntry<V>> {\n\t\tfinal K key;\n\n\t\t@Nullable Node<K, V> prev;\n\n\t\t@Nullable Node<K, V> next;\n\n\t\tNode(K key, CacheEntry<V> cacheEntry) {\n\t\t\tsuper(cacheEntry);\n\t\t\tthis.key = key;\n\t\t}\n\n\t\tpublic @Nullable Node<K, V> getPrevious() {\n\t\t\treturn this.prev;\n\t\t}\n\n\t\tpublic void setPrevious(@Nullable Node<K, V> prev) {\n\t\t\tthis.prev = prev;\n\t\t}\n\n\t\tpublic @Nullable Node<K, V> getNext() {\n\t\t\treturn this.next;\n\t\t}\n\n\t\tpublic void setNext(@Nullable Node<K, V> next) {\n\t\t\tthis.next = next;\n\t\t}\n\n\t\tV getValue() {\n\t\t\treturn get().value;\n\t\t}\n\t}\n\n\n\tprivate static final class EvictionQueue<K, V> {\n\n\t\t@Nullable Node<K, V> first;\n\n\t\t@Nullable Node<K, V> last;\n\n\n\t\t@Nullable Node<K, V> poll() {\n\t\t\tif (this.first == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfinal Node<K, V> f = this.first;\n\t\t\tfinal Node<K, V> next = f.getNext();\n\t\t\tf.setNext(null);\n\n\t\t\tthis.first = next;\n\t\t\tif (next == null) {\n\t\t\t\tthis.last = null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnext.setPrevious(null);\n\t\t\t}\n\t\t\treturn f;\n\t\t}\n\n\t\tvoid add(Node<K, V> e) {\n\t\t\tif (contains(e)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlinkLast(e);\n\t\t}\n\n\t\tprivate boolean contains(Node<K, V> e) {\n\t\t\treturn (e.getPrevious() != null)\n\t\t\t\t\t|| (e.getNext() != null)\n\t\t\t\t\t|| (e == this.first);\n\t\t}\n\n\t\tprivate void linkLast(final Node<K, V> e) {\n\t\t\tfinal Node<K, V> l = this.last;\n\t\t\tthis.last = e;\n\n\t\t\tif (l == null) {\n\t\t\t\tthis.first = e;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tl.setNext(e);\n\t\t\t\te.setPrevious(l);\n\t\t\t}\n\t\t}\n\n\t\tprivate void unlink(Node<K, V> e) {\n\t\t\tfinal Node<K, V> prev = e.getPrevious();\n\t\t\tfinal Node<K, V> next = e.getNext();\n\t\t\tif (prev == null) {\n\t\t\t\tthis.first = next;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprev.setNext(next);\n\t\t\t\te.setPrevious(null);\n\t\t\t}\n\t\t\tif (next == null) {\n\t\t\t\tthis.last = prev;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnext.setPrevious(prev);\n\t\t\t\te.setNext(null);\n\t\t\t}\n\t\t}\n\n\t\tvoid moveToBack(Node<K, V> e) {\n\t\t\tif (contains(e) && e != this.last) {\n\t\t\t\tunlink(e);\n\t\t\t\tlinkLast(e);\n\t\t\t}\n\t\t}\n\n\t\tvoid remove(Node<K, V> e) {\n\t\t\tif (contains(e)) {\n\t\t\t\tunlink(e);\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.AddTask",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.AddTask#node",
    "tailType": "field"
  },
  {
    "head": "org.springframework.util.AddTask#node",
    "headType": "field",
    "relation": "haveType",
    "tail": "Node<K, V>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.util.AddTask#run()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic void run() {\r\n    currentSize.lazySet(currentSize.get() + 1);\r\n    if (this.node.get().isActive()) {\r\n        evictionQueue.add(this.node);\r\n        evictEntries();\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.AddTask",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.AddTask#run()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.AddTask#run()",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.AddTask#evictEntries()",
    "headType": "method",
    "relation": "provide",
    "tail": "private void evictEntries() {\r\n    while (currentSize.get() > capacity) {\r\n        final Node<K, V> node = evictionQueue.poll();\r\n        if (node == null) {\r\n            return;\r\n        }\r\n        cache.remove(node.key, node);\r\n        markAsRemoved(node);\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.AddTask",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.AddTask#evictEntries()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.RemovalTask",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.RemovalTask",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLongArray;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.function.Function;\n\nimport org.jspecify.annotations.Nullable;\n\n/**\n * Simple LRU (Least Recently Used) cache, bounded by a specified cache capacity.\n * <p>This is a simplified, opinionated implementation of an LRU cache for internal\n * use in Spring Framework. It is inspired from\n * <a href=\"https://github.com/ben-manes/concurrentlinkedhashmap\">ConcurrentLinkedHashMap</a>.\n * <p>Read and write operations are internally recorded in dedicated buffers,\n * then drained at chosen times to avoid contention.\n *\n * @author Brian Clozel\n * @author Ben Manes\n * @since 5.3\n * @param <K> the type of the key used for cache retrieval\n * @param <V> the type of the cached values, does not allow null values\n * @see #get(Object)\n */\n@SuppressWarnings({\"unchecked\", \"NullAway\"})\npublic final class ConcurrentLruCache<K, V> {\n\n\tprivate final int capacity;\n\n\tprivate final AtomicInteger currentSize = new AtomicInteger();\n\n\tprivate final ConcurrentMap<K, Node<K, V>> cache;\n\n\tprivate final Function<K, V> generator;\n\n\tprivate final ReadOperations<K, V> readOperations;\n\n\tprivate final WriteOperations writeOperations;\n\n\tprivate final Lock evictionLock = new ReentrantLock();\n\n\t/*\n\t * Queue that contains all ACTIVE cache entries, ordered with least recently used entries first.\n\t * Read and write operations are buffered and periodically processed to reorder the queue.\n\t */\n\tprivate final EvictionQueue<K, V> evictionQueue = new EvictionQueue<>();\n\n\tprivate final AtomicReference<DrainStatus> drainStatus = new AtomicReference<>(DrainStatus.IDLE);\n\n\t/**\n\t * Create a new cache instance with the given capacity and generator function.\n\t * @param capacity the maximum number of entries in the cache\n\t * (0 indicates no caching, always generating a new value)\n\t * @param generator a function to generate a new value for a given key\n\t */\n\tpublic ConcurrentLruCache(int capacity, Function<K, V> generator) {\n\t\tthis(capacity, generator, 16);\n\t}\n\n\tprivate ConcurrentLruCache(int capacity, Function<K, V> generator, int concurrencyLevel) {\n\t\tAssert.isTrue(capacity >= 0, \"Capacity must be >= 0\");\n\t\tthis.capacity = capacity;\n\t\tthis.cache = new ConcurrentHashMap<>(16, 0.75f, concurrencyLevel);\n\t\tthis.generator = generator;\n\t\tthis.readOperations = new ReadOperations<>(this.evictionQueue);\n\t\tthis.writeOperations = new WriteOperations();\n\t}\n\n\t/**\n\t * Retrieve an entry from the cache, potentially triggering generation of the value.\n\t * @param key the key to retrieve the entry for\n\t * @return the cached or newly generated value\n\t */\n\tpublic V get(K key) {\n\t\tif (this.capacity == 0) {\n\t\t\treturn this.generator.apply(key);\n\t\t}\n\t\tfinal Node<K, V> node = this.cache.get(key);\n\t\tif (node == null) {\n\t\t\tV value = this.generator.apply(key);\n\t\t\tput(key, value);\n\t\t\treturn value;\n\t\t}\n\t\tprocessRead(node);\n\t\treturn node.getValue();\n\t}\n\n\tprivate void put(K key, V value) {\n\t\tAssert.notNull(key, \"key must not be null\");\n\t\tAssert.notNull(value, \"value must not be null\");\n\t\tfinal CacheEntry<V> cacheEntry = new CacheEntry<>(value, CacheEntryState.ACTIVE);\n\t\tfinal Node<K, V> node = new Node<>(key, cacheEntry);\n\t\tfinal Node<K, V> prior = this.cache.putIfAbsent(node.key, node);\n\t\tif (prior == null) {\n\t\t\tprocessWrite(new AddTask(node));\n\t\t}\n\t\telse {\n\t\t\tprocessRead(prior);\n\t\t}\n\t}\n\n\tprivate void processRead(Node<K, V> node) {\n\t\tboolean drainRequested = this.readOperations.recordRead(node);\n\t\tfinal DrainStatus status = this.drainStatus.get();\n\t\tif (status.shouldDrainBuffers(drainRequested)) {\n\t\t\tdrainOperations();\n\t\t}\n\t}\n\n\tprivate void processWrite(Runnable task) {\n\t\tthis.writeOperations.add(task);\n\t\tthis.drainStatus.lazySet(DrainStatus.REQUIRED);\n\t\tdrainOperations();\n\t}\n\n\tprivate void drainOperations() {\n\t\tif (this.evictionLock.tryLock()) {\n\t\t\ttry {\n\t\t\t\tthis.drainStatus.lazySet(DrainStatus.PROCESSING);\n\t\t\t\tthis.readOperations.drain();\n\t\t\t\tthis.writeOperations.drain();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.drainStatus.compareAndSet(DrainStatus.PROCESSING, DrainStatus.IDLE);\n\t\t\t\tthis.evictionLock.unlock();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Return the maximum number of entries in the cache.\n\t * @see #size()\n\t */\n\tpublic int capacity() {\n\t\treturn this.capacity;\n\t}\n\n\t/**\n\t * Return the maximum number of entries in the cache.\n\t * @deprecated in favor of {@link #capacity()} as of 6.0.\n\t */\n\t@Deprecated(since = \"6.0\")\n\tpublic int sizeLimit() {\n\t\treturn this.capacity;\n\t}\n\n\t/**\n\t * Return the current size of the cache.\n\t * @see #capacity()\n\t */\n\tpublic int size() {\n\t\treturn this.cache.size();\n\t}\n\n\t/**\n\t * Immediately remove all entries from this cache.\n\t */\n\tpublic void clear() {\n\t\tthis.evictionLock.lock();\n\t\ttry {\n\t\t\tNode<K, V> node;\n\t\t\twhile ((node = this.evictionQueue.poll()) != null) {\n\t\t\t\tthis.cache.remove(node.key, node);\n\t\t\t\tmarkAsRemoved(node);\n\t\t\t}\n\t\t\tthis.readOperations.clear();\n\t\t\tthis.writeOperations.drainAll();\n\t\t}\n\t\tfinally {\n\t\t\tthis.evictionLock.unlock();\n\t\t}\n\t}\n\n\t/*\n\t * Transition the node to the {@code removed} state and decrement the current size of the cache.\n\t */\n\tprivate void markAsRemoved(Node<K, V> node) {\n\t\tfor (; ; ) {\n\t\t\tCacheEntry<V> current = node.get();\n\t\t\tCacheEntry<V> removed = new CacheEntry<>(current.value, CacheEntryState.REMOVED);\n\t\t\tif (node.compareAndSet(current, removed)) {\n\t\t\t\tthis.currentSize.lazySet(this.currentSize.get() - 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Determine whether the given key is present in this cache.\n\t * @param key the key to check for\n\t * @return {@code true} if the key is present, {@code false} if there was no matching key\n\t */\n\tpublic boolean contains(K key) {\n\t\treturn this.cache.containsKey(key);\n\t}\n\n\t/**\n\t * Immediately remove the given key and any associated value.\n\t * @param key the key to evict the entry for\n\t * @return {@code true} if the key was present before,\n\t * {@code false} if there was no matching key\n\t */\n\tpublic boolean remove(K key) {\n\t\tfinal Node<K, V> node = this.cache.remove(key);\n\t\tif (node == null) {\n\t\t\treturn false;\n\t\t}\n\t\tmarkForRemoval(node);\n\t\tprocessWrite(new RemovalTask(node));\n\t\treturn true;\n\t}\n\n\t/*\n\t * Transition the node from the {@code active} state to the {@code pending removal} state,\n\t * if the transition is valid.\n\t */\n\tprivate void markForRemoval(Node<K, V> node) {\n\t\tfor (; ; ) {\n\t\t\tfinal CacheEntry<V> current = node.get();\n\t\t\tif (!current.isActive()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfinal CacheEntry<V> pendingRemoval = new CacheEntry<>(current.value, CacheEntryState.PENDING_REMOVAL);\n\t\t\tif (node.compareAndSet(current, pendingRemoval)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Write operation recorded when a new entry is added to the cache.\n\t */\n\tprivate final class AddTask implements Runnable {\n\t\tfinal Node<K, V> node;\n\n\t\tAddTask(Node<K, V> node) {\n\t\t\tthis.node = node;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tcurrentSize.lazySet(currentSize.get() + 1);\n\t\t\tif (this.node.get().isActive()) {\n\t\t\t\tevictionQueue.add(this.node);\n\t\t\t\tevictEntries();\n\t\t\t}\n\t\t}\n\n\t\tprivate void evictEntries() {\n\t\t\twhile (currentSize.get() > capacity) {\n\t\t\t\tfinal Node<K, V> node = evictionQueue.poll();\n\t\t\t\tif (node == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcache.remove(node.key, node);\n\t\t\t\tmarkAsRemoved(node);\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\t/**\n\t * Write operation recorded when an entry is removed to the cache.\n\t */\n\tprivate final class RemovalTask implements Runnable {\n\t\tfinal Node<K, V> node;\n\n\t\tRemovalTask(Node<K, V> node) {\n\t\t\tthis.node = node;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tevictionQueue.remove(this.node);\n\t\t\tmarkAsRemoved(this.node);\n\t\t}\n\t}\n\n\n\t/*\n\t * Draining status for the read/write buffers.\n\t */\n\tprivate enum DrainStatus {\n\n\t\t/*\n\t\t * No drain operation currently running.\n\t\t */\n\t\tIDLE {\n\t\t\t@Override\n\t\t\tboolean shouldDrainBuffers(boolean delayable) {\n\t\t\t\treturn !delayable;\n\t\t\t}\n\t\t},\n\n\t\t/*\n\t\t * A drain operation is required due to a pending write modification.\n\t\t */\n\t\tREQUIRED {\n\t\t\t@Override\n\t\t\tboolean shouldDrainBuffers(boolean delayable) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\n\t\t/*\n\t\t * A drain operation is in progress.\n\t\t */\n\t\tPROCESSING {\n\t\t\t@Override\n\t\t\tboolean shouldDrainBuffers(boolean delayable) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Determine whether the buffers should be drained.\n\t\t * @param delayable if a drain should be delayed until required\n\t\t * @return if a drain should be attempted\n\t\t */\n\t\tabstract boolean shouldDrainBuffers(boolean delayable);\n\t}\n\n\tprivate enum CacheEntryState {\n\t\tACTIVE, PENDING_REMOVAL, REMOVED\n\t}\n\n\tprivate record CacheEntry<V>(V value, CacheEntryState state) {\n\n\t\tboolean isActive() {\n\t\t\treturn this.state == CacheEntryState.ACTIVE;\n\t\t}\n\t}\n\n\tprivate static final class ReadOperations<K, V> {\n\n\t\tprivate static final int BUFFER_COUNT = detectNumberOfBuffers();\n\n\t\tprivate static int detectNumberOfBuffers() {\n\t\t\tint availableProcessors = Runtime.getRuntime().availableProcessors();\n\t\t\tint nextPowerOfTwo = 1 << (Integer.SIZE - Integer.numberOfLeadingZeros(availableProcessors - 1));\n\t\t\treturn Math.min(4, nextPowerOfTwo);\n\t\t}\n\n\t\tprivate static final int BUFFERS_MASK = BUFFER_COUNT - 1;\n\n\t\tprivate static final int MAX_PENDING_OPERATIONS = 32;\n\n\t\tprivate static final int MAX_DRAIN_COUNT = 2 * MAX_PENDING_OPERATIONS;\n\n\t\tprivate static final int BUFFER_SIZE = 2 * MAX_DRAIN_COUNT;\n\n\t\tprivate static final int BUFFER_INDEX_MASK = BUFFER_SIZE - 1;\n\n\t\t/*\n\t\t * Number of operations recorded, for each buffer\n\t\t */\n\t\tprivate final AtomicLongArray recordedCount = new AtomicLongArray(BUFFER_COUNT);\n\n\t\t/*\n\t\t * Number of operations read, for each buffer\n\t\t */\n\t\tprivate final long[] readCount = new long[BUFFER_COUNT];\n\n\t\t/*\n\t\t * Number of operations processed, for each buffer\n\t\t */\n\t\tprivate final AtomicLongArray processedCount = new AtomicLongArray(BUFFER_COUNT);\n\n\t\t@SuppressWarnings(\"rawtypes\")\n\t\tprivate final AtomicReferenceArray<Node<K, V>>[] buffers = new AtomicReferenceArray[BUFFER_COUNT];\n\n\t\tprivate final EvictionQueue<K, V> evictionQueue;\n\n\t\tReadOperations(EvictionQueue<K, V> evictionQueue) {\n\t\t\tthis.evictionQueue = evictionQueue;\n\t\t\tfor (int i = 0; i < BUFFER_COUNT; i++) {\n\t\t\t\tthis.buffers[i] = new AtomicReferenceArray<>(BUFFER_SIZE);\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"deprecation\")  // for Thread.getId() on JDK 19\n\t\tprivate static int getBufferIndex() {\n\t\t\treturn ((int) Thread.currentThread().getId()) & BUFFERS_MASK;\n\t\t}\n\n\t\tboolean recordRead(Node<K, V> node) {\n\t\t\tint bufferIndex = getBufferIndex();\n\t\t\tfinal long writeCount = this.recordedCount.get(bufferIndex);\n\t\t\tthis.recordedCount.lazySet(bufferIndex, writeCount + 1);\n\t\t\tfinal int index = (int) (writeCount & BUFFER_INDEX_MASK);\n\t\t\tthis.buffers[bufferIndex].lazySet(index, node);\n\t\t\tfinal long pending = (writeCount - this.processedCount.get(bufferIndex));\n\t\t\treturn (pending < MAX_PENDING_OPERATIONS);\n\t\t}\n\n\t\t@SuppressWarnings(\"deprecation\")  // for Thread.getId() on JDK 19\n\t\tvoid drain() {\n\t\t\tfinal int start = (int) Thread.currentThread().getId();\n\t\t\tfinal int end = start + BUFFER_COUNT;\n\t\t\tfor (int i = start; i < end; i++) {\n\t\t\t\tdrainReadBuffer(i & BUFFERS_MASK);\n\t\t\t}\n\t\t}\n\n\t\tvoid clear() {\n\t\t\tfor (int i = 0; i < BUFFER_COUNT; i++) {\n\t\t\t\tAtomicReferenceArray<Node<K, V>> buffer = this.buffers[i];\n\t\t\t\tfor (int j = 0; j < BUFFER_SIZE; j++) {\n\t\t\t\t\tbuffer.lazySet(j, null);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void drainReadBuffer(int bufferIndex) {\n\t\t\tfinal long writeCount = this.recordedCount.get(bufferIndex);\n\t\t\tfor (int i = 0; i < MAX_DRAIN_COUNT; i++) {\n\t\t\t\tfinal int index = (int) (this.readCount[bufferIndex] & BUFFER_INDEX_MASK);\n\t\t\t\tfinal AtomicReferenceArray<Node<K, V>> buffer = this.buffers[bufferIndex];\n\t\t\t\tfinal Node<K, V> node = buffer.get(index);\n\t\t\t\tif (node == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbuffer.lazySet(index, null);\n\t\t\t\tthis.evictionQueue.moveToBack(node);\n\t\t\t\tthis.readCount[bufferIndex]++;\n\t\t\t}\n\t\t\tthis.processedCount.lazySet(bufferIndex, writeCount);\n\t\t}\n\t}\n\n\tprivate static final class WriteOperations {\n\n\t\tprivate static final int DRAIN_THRESHOLD = 16;\n\n\t\tprivate final Queue<Runnable> operations = new ConcurrentLinkedQueue<>();\n\n\t\tpublic void add(Runnable task) {\n\t\t\tthis.operations.add(task);\n\t\t}\n\n\t\tpublic void drain() {\n\t\t\tfor (int i = 0; i < DRAIN_THRESHOLD; i++) {\n\t\t\t\tfinal Runnable task = this.operations.poll();\n\t\t\t\tif (task == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttask.run();\n\t\t\t}\n\t\t}\n\n\t\tpublic void drainAll() {\n\t\t\tRunnable task;\n\t\t\twhile ((task = this.operations.poll()) != null) {\n\t\t\t\ttask.run();\n\t\t\t}\n\t\t}\n\n\t}\n\n\t@SuppressWarnings(\"serial\")\n\tprivate static final class Node<K, V> extends AtomicReference<CacheEntry<V>> {\n\t\tfinal K key;\n\n\t\t@Nullable Node<K, V> prev;\n\n\t\t@Nullable Node<K, V> next;\n\n\t\tNode(K key, CacheEntry<V> cacheEntry) {\n\t\t\tsuper(cacheEntry);\n\t\t\tthis.key = key;\n\t\t}\n\n\t\tpublic @Nullable Node<K, V> getPrevious() {\n\t\t\treturn this.prev;\n\t\t}\n\n\t\tpublic void setPrevious(@Nullable Node<K, V> prev) {\n\t\t\tthis.prev = prev;\n\t\t}\n\n\t\tpublic @Nullable Node<K, V> getNext() {\n\t\t\treturn this.next;\n\t\t}\n\n\t\tpublic void setNext(@Nullable Node<K, V> next) {\n\t\t\tthis.next = next;\n\t\t}\n\n\t\tV getValue() {\n\t\t\treturn get().value;\n\t\t}\n\t}\n\n\n\tprivate static final class EvictionQueue<K, V> {\n\n\t\t@Nullable Node<K, V> first;\n\n\t\t@Nullable Node<K, V> last;\n\n\n\t\t@Nullable Node<K, V> poll() {\n\t\t\tif (this.first == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfinal Node<K, V> f = this.first;\n\t\t\tfinal Node<K, V> next = f.getNext();\n\t\t\tf.setNext(null);\n\n\t\t\tthis.first = next;\n\t\t\tif (next == null) {\n\t\t\t\tthis.last = null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnext.setPrevious(null);\n\t\t\t}\n\t\t\treturn f;\n\t\t}\n\n\t\tvoid add(Node<K, V> e) {\n\t\t\tif (contains(e)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlinkLast(e);\n\t\t}\n\n\t\tprivate boolean contains(Node<K, V> e) {\n\t\t\treturn (e.getPrevious() != null)\n\t\t\t\t\t|| (e.getNext() != null)\n\t\t\t\t\t|| (e == this.first);\n\t\t}\n\n\t\tprivate void linkLast(final Node<K, V> e) {\n\t\t\tfinal Node<K, V> l = this.last;\n\t\t\tthis.last = e;\n\n\t\t\tif (l == null) {\n\t\t\t\tthis.first = e;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tl.setNext(e);\n\t\t\t\te.setPrevious(l);\n\t\t\t}\n\t\t}\n\n\t\tprivate void unlink(Node<K, V> e) {\n\t\t\tfinal Node<K, V> prev = e.getPrevious();\n\t\t\tfinal Node<K, V> next = e.getNext();\n\t\t\tif (prev == null) {\n\t\t\t\tthis.first = next;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprev.setNext(next);\n\t\t\t\te.setPrevious(null);\n\t\t\t}\n\t\t\tif (next == null) {\n\t\t\t\tthis.last = prev;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnext.setPrevious(prev);\n\t\t\t\te.setNext(null);\n\t\t\t}\n\t\t}\n\n\t\tvoid moveToBack(Node<K, V> e) {\n\t\t\tif (contains(e) && e != this.last) {\n\t\t\t\tunlink(e);\n\t\t\t\tlinkLast(e);\n\t\t\t}\n\t\t}\n\n\t\tvoid remove(Node<K, V> e) {\n\t\t\tif (contains(e)) {\n\t\t\t\tunlink(e);\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.RemovalTask",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.RemovalTask#node",
    "tailType": "field"
  },
  {
    "head": "org.springframework.util.RemovalTask#node",
    "headType": "field",
    "relation": "haveType",
    "tail": "Node<K, V>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.util.RemovalTask#run()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic void run() {\r\n    evictionQueue.remove(this.node);\r\n    markAsRemoved(this.node);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.RemovalTask",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.RemovalTask#run()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.RemovalTask#run()",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.ReadOperations",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.ReadOperations",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLongArray;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.function.Function;\n\nimport org.jspecify.annotations.Nullable;\n\n/**\n * Simple LRU (Least Recently Used) cache, bounded by a specified cache capacity.\n * <p>This is a simplified, opinionated implementation of an LRU cache for internal\n * use in Spring Framework. It is inspired from\n * <a href=\"https://github.com/ben-manes/concurrentlinkedhashmap\">ConcurrentLinkedHashMap</a>.\n * <p>Read and write operations are internally recorded in dedicated buffers,\n * then drained at chosen times to avoid contention.\n *\n * @author Brian Clozel\n * @author Ben Manes\n * @since 5.3\n * @param <K> the type of the key used for cache retrieval\n * @param <V> the type of the cached values, does not allow null values\n * @see #get(Object)\n */\n@SuppressWarnings({\"unchecked\", \"NullAway\"})\npublic final class ConcurrentLruCache<K, V> {\n\n\tprivate final int capacity;\n\n\tprivate final AtomicInteger currentSize = new AtomicInteger();\n\n\tprivate final ConcurrentMap<K, Node<K, V>> cache;\n\n\tprivate final Function<K, V> generator;\n\n\tprivate final ReadOperations<K, V> readOperations;\n\n\tprivate final WriteOperations writeOperations;\n\n\tprivate final Lock evictionLock = new ReentrantLock();\n\n\t/*\n\t * Queue that contains all ACTIVE cache entries, ordered with least recently used entries first.\n\t * Read and write operations are buffered and periodically processed to reorder the queue.\n\t */\n\tprivate final EvictionQueue<K, V> evictionQueue = new EvictionQueue<>();\n\n\tprivate final AtomicReference<DrainStatus> drainStatus = new AtomicReference<>(DrainStatus.IDLE);\n\n\t/**\n\t * Create a new cache instance with the given capacity and generator function.\n\t * @param capacity the maximum number of entries in the cache\n\t * (0 indicates no caching, always generating a new value)\n\t * @param generator a function to generate a new value for a given key\n\t */\n\tpublic ConcurrentLruCache(int capacity, Function<K, V> generator) {\n\t\tthis(capacity, generator, 16);\n\t}\n\n\tprivate ConcurrentLruCache(int capacity, Function<K, V> generator, int concurrencyLevel) {\n\t\tAssert.isTrue(capacity >= 0, \"Capacity must be >= 0\");\n\t\tthis.capacity = capacity;\n\t\tthis.cache = new ConcurrentHashMap<>(16, 0.75f, concurrencyLevel);\n\t\tthis.generator = generator;\n\t\tthis.readOperations = new ReadOperations<>(this.evictionQueue);\n\t\tthis.writeOperations = new WriteOperations();\n\t}\n\n\t/**\n\t * Retrieve an entry from the cache, potentially triggering generation of the value.\n\t * @param key the key to retrieve the entry for\n\t * @return the cached or newly generated value\n\t */\n\tpublic V get(K key) {\n\t\tif (this.capacity == 0) {\n\t\t\treturn this.generator.apply(key);\n\t\t}\n\t\tfinal Node<K, V> node = this.cache.get(key);\n\t\tif (node == null) {\n\t\t\tV value = this.generator.apply(key);\n\t\t\tput(key, value);\n\t\t\treturn value;\n\t\t}\n\t\tprocessRead(node);\n\t\treturn node.getValue();\n\t}\n\n\tprivate void put(K key, V value) {\n\t\tAssert.notNull(key, \"key must not be null\");\n\t\tAssert.notNull(value, \"value must not be null\");\n\t\tfinal CacheEntry<V> cacheEntry = new CacheEntry<>(value, CacheEntryState.ACTIVE);\n\t\tfinal Node<K, V> node = new Node<>(key, cacheEntry);\n\t\tfinal Node<K, V> prior = this.cache.putIfAbsent(node.key, node);\n\t\tif (prior == null) {\n\t\t\tprocessWrite(new AddTask(node));\n\t\t}\n\t\telse {\n\t\t\tprocessRead(prior);\n\t\t}\n\t}\n\n\tprivate void processRead(Node<K, V> node) {\n\t\tboolean drainRequested = this.readOperations.recordRead(node);\n\t\tfinal DrainStatus status = this.drainStatus.get();\n\t\tif (status.shouldDrainBuffers(drainRequested)) {\n\t\t\tdrainOperations();\n\t\t}\n\t}\n\n\tprivate void processWrite(Runnable task) {\n\t\tthis.writeOperations.add(task);\n\t\tthis.drainStatus.lazySet(DrainStatus.REQUIRED);\n\t\tdrainOperations();\n\t}\n\n\tprivate void drainOperations() {\n\t\tif (this.evictionLock.tryLock()) {\n\t\t\ttry {\n\t\t\t\tthis.drainStatus.lazySet(DrainStatus.PROCESSING);\n\t\t\t\tthis.readOperations.drain();\n\t\t\t\tthis.writeOperations.drain();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tthis.drainStatus.compareAndSet(DrainStatus.PROCESSING, DrainStatus.IDLE);\n\t\t\t\tthis.evictionLock.unlock();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Return the maximum number of entries in the cache.\n\t * @see #size()\n\t */\n\tpublic int capacity() {\n\t\treturn this.capacity;\n\t}\n\n\t/**\n\t * Return the maximum number of entries in the cache.\n\t * @deprecated in favor of {@link #capacity()} as of 6.0.\n\t */\n\t@Deprecated(since = \"6.0\")\n\tpublic int sizeLimit() {\n\t\treturn this.capacity;\n\t}\n\n\t/**\n\t * Return the current size of the cache.\n\t * @see #capacity()\n\t */\n\tpublic int size() {\n\t\treturn this.cache.size();\n\t}\n\n\t/**\n\t * Immediately remove all entries from this cache.\n\t */\n\tpublic void clear() {\n\t\tthis.evictionLock.lock();\n\t\ttry {\n\t\t\tNode<K, V> node;\n\t\t\twhile ((node = this.evictionQueue.poll()) != null) {\n\t\t\t\tthis.cache.remove(node.key, node);\n\t\t\t\tmarkAsRemoved(node);\n\t\t\t}\n\t\t\tthis.readOperations.clear();\n\t\t\tthis.writeOperations.drainAll();\n\t\t}\n\t\tfinally {\n\t\t\tthis.evictionLock.unlock();\n\t\t}\n\t}\n\n\t/*\n\t * Transition the node to the {@code removed} state and decrement the current size of the cache.\n\t */\n\tprivate void markAsRemoved(Node<K, V> node) {\n\t\tfor (; ; ) {\n\t\t\tCacheEntry<V> current = node.get();\n\t\t\tCacheEntry<V> removed = new CacheEntry<>(current.value, CacheEntryState.REMOVED);\n\t\t\tif (node.compareAndSet(current, removed)) {\n\t\t\t\tthis.currentSize.lazySet(this.currentSize.get() - 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Determine whether the given key is present in this cache.\n\t * @param key the key to check for\n\t * @return {@code true} if the key is present, {@code false} if there was no matching key\n\t */\n\tpublic boolean contains(K key) {\n\t\treturn this.cache.containsKey(key);\n\t}\n\n\t/**\n\t * Immediately remove the given key and any associated value.\n\t * @param key the key to evict the entry for\n\t * @return {@code true} if the key was present before,\n\t * {@code false} if there was no matching key\n\t */\n\tpublic boolean remove(K key) {\n\t\tfinal Node<K, V> node = this.cache.remove(key);\n\t\tif (node == null) {\n\t\t\treturn false;\n\t\t}\n\t\tmarkForRemoval(node);\n\t\tprocessWrite(new RemovalTask(node));\n\t\treturn true;\n\t}\n\n\t/*\n\t * Transition the node from the {@code active} state to the {@code pending removal} state,\n\t * if the transition is valid.\n\t */\n\tprivate void markForRemoval(Node<K, V> node) {\n\t\tfor (; ; ) {\n\t\t\tfinal CacheEntry<V> current = node.get();\n\t\t\tif (!current.isActive()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfinal CacheEntry<V> pendingRemoval = new CacheEntry<>(current.value, CacheEntryState.PENDING_REMOVAL);\n\t\t\tif (node.compareAndSet(current, pendingRemoval)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Write operation recorded when a new entry is added to the cache.\n\t */\n\tprivate final class AddTask implements Runnable {\n\t\tfinal Node<K, V> node;\n\n\t\tAddTask(Node<K, V> node) {\n\t\t\tthis.node = node;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tcurrentSize.lazySet(currentSize.get() + 1);\n\t\t\tif (this.node.get().isActive()) {\n\t\t\t\tevictionQueue.add(this.node);\n\t\t\t\tevictEntries();\n\t\t\t}\n\t\t}\n\n\t\tprivate void evictEntries() {\n\t\t\twhile (currentSize.get() > capacity) {\n\t\t\t\tfinal Node<K, V> node = evictionQueue.poll();\n\t\t\t\tif (node == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcache.remove(node.key, node);\n\t\t\t\tmarkAsRemoved(node);\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\t/**\n\t * Write operation recorded when an entry is removed to the cache.\n\t */\n\tprivate final class RemovalTask implements Runnable {\n\t\tfinal Node<K, V> node;\n\n\t\tRemovalTask(Node<K, V> node) {\n\t\t\tthis.node = node;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tevictionQueue.remove(this.node);\n\t\t\tmarkAsRemoved(this.node);\n\t\t}\n\t}\n\n\n\t/*\n\t * Draining status for the read/write buffers.\n\t */\n\tprivate enum DrainStatus {\n\n\t\t/*\n\t\t * No drain operation currently running.\n\t\t */\n\t\tIDLE {\n\t\t\t@Override\n\t\t\tboolean shouldDrainBuffers(boolean delayable) {\n\t\t\t\treturn !delayable;\n\t\t\t}\n\t\t},\n\n\t\t/*\n\t\t * A drain operation is required due to a pending write modification.\n\t\t */\n\t\tREQUIRED {\n\t\t\t@Override\n\t\t\tboolean shouldDrainBuffers(boolean delayable) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\n\t\t/*\n\t\t * A drain operation is in progress.\n\t\t */\n\t\tPROCESSING {\n\t\t\t@Override\n\t\t\tboolean shouldDrainBuffers(boolean delayable) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Determine whether the buffers should be drained.\n\t\t * @param delayable if a drain should be delayed until required\n\t\t * @return if a drain should be attempted\n\t\t */\n\t\tabstract boolean shouldDrainBuffers(boolean delayable);\n\t}\n\n\tprivate enum CacheEntryState {\n\t\tACTIVE, PENDING_REMOVAL, REMOVED\n\t}\n\n\tprivate record CacheEntry<V>(V value, CacheEntryState state) {\n\n\t\tboolean isActive() {\n\t\t\treturn this.state == CacheEntryState.ACTIVE;\n\t\t}\n\t}\n\n\tprivate static final class ReadOperations<K, V> {\n\n\t\tprivate static final int BUFFER_COUNT = detectNumberOfBuffers();\n\n\t\tprivate static int detectNumberOfBuffers() {\n\t\t\tint availableProcessors = Runtime.getRuntime().availableProcessors();\n\t\t\tint nextPowerOfTwo = 1 << (Integer.SIZE - Integer.numberOfLeadingZeros(availableProcessors - 1));\n\t\t\treturn Math.min(4, nextPowerOfTwo);\n\t\t}\n\n\t\tprivate static final int BUFFERS_MASK = BUFFER_COUNT - 1;\n\n\t\tprivate static final int MAX_PENDING_OPERATIONS = 32;\n\n\t\tprivate static final int MAX_DRAIN_COUNT = 2 * MAX_PENDING_OPERATIONS;\n\n\t\tprivate static final int BUFFER_SIZE = 2 * MAX_DRAIN_COUNT;\n\n\t\tprivate static final int BUFFER_INDEX_MASK = BUFFER_SIZE - 1;\n\n\t\t/*\n\t\t * Number of operations recorded, for each buffer\n\t\t */\n\t\tprivate final AtomicLongArray recordedCount = new AtomicLongArray(BUFFER_COUNT);\n\n\t\t/*\n\t\t * Number of operations read, for each buffer\n\t\t */\n\t\tprivate final long[] readCount = new long[BUFFER_COUNT];\n\n\t\t/*\n\t\t * Number of operations processed, for each buffer\n\t\t */\n\t\tprivate final AtomicLongArray processedCount = new AtomicLongArray(BUFFER_COUNT);\n\n\t\t@SuppressWarnings(\"rawtypes\")\n\t\tprivate final AtomicReferenceArray<Node<K, V>>[] buffers = new AtomicReferenceArray[BUFFER_COUNT];\n\n\t\tprivate final EvictionQueue<K, V> evictionQueue;\n\n\t\tReadOperations(EvictionQueue<K, V> evictionQueue) {\n\t\t\tthis.evictionQueue = evictionQueue;\n\t\t\tfor (int i = 0; i < BUFFER_COUNT; i++) {\n\t\t\t\tthis.buffers[i] = new AtomicReferenceArray<>(BUFFER_SIZE);\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"deprecation\")  // for Thread.getId() on JDK 19\n\t\tprivate static int getBufferIndex() {\n\t\t\treturn ((int) Thread.currentThread().getId()) & BUFFERS_MASK;\n\t\t}\n\n\t\tboolean recordRead(Node<K, V> node) {\n\t\t\tint bufferIndex = getBufferIndex();\n\t\t\tfinal long writeCount = this.recordedCount.get(bufferIndex);\n\t\t\tthis.recordedCount.lazySet(bufferIndex, writeCount + 1);\n\t\t\tfinal int index = (int) (writeCount & BUFFER_INDEX_MASK);\n\t\t\tthis.buffers[bufferIndex].lazySet(index, node);\n\t\t\tfinal long pending = (writeCount - this.processedCount.get(bufferIndex));\n\t\t\treturn (pending < MAX_PENDING_OPERATIONS);\n\t\t}\n\n\t\t@SuppressWarnings(\"deprecation\")  // for Thread.getId() on JDK 19\n\t\tvoid drain() {\n\t\t\tfinal int start = (int) Thread.currentThread().getId();\n\t\t\tfinal int end = start + BUFFER_COUNT;\n\t\t\tfor (int i = start; i < end; i++) {\n\t\t\t\tdrainReadBuffer(i & BUFFERS_MASK);\n\t\t\t}\n\t\t}\n\n\t\tvoid clear() {\n\t\t\tfor (int i = 0; i < BUFFER_COUNT; i++) {\n\t\t\t\tAtomicReferenceArray<Node<K, V>> buffer = this.buffers[i];\n\t\t\t\tfor (int j = 0; j < BUFFER_SIZE; j++) {\n\t\t\t\t\tbuffer.lazySet(j, null);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void drainReadBuffer(int bufferIndex) {\n\t\t\tfinal long writeCount = this.recordedCount.get(bufferIndex);\n\t\t\tfor (int i = 0; i < MAX_DRAIN_COUNT; i++) {\n\t\t\t\tfinal int index = (int) (this.readCount[bufferIndex] & BUFFER_INDEX_MASK);\n\t\t\t\tfinal AtomicReferenceArray<Node<K, V>> buffer = this.buffers[bufferIndex];\n\t\t\t\tfinal Node<K, V> node = buffer.get(index);\n\t\t\t\tif (node == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbuffer.lazySet(index, null);\n\t\t\t\tthis.evictionQueue.moveToBack(node);\n\t\t\t\tthis.readCount[bufferIndex]++;\n\t\t\t}\n\t\t\tthis.processedCount.lazySet(bufferIndex, writeCount);\n\t\t}\n\t}\n\n\tprivate static final class WriteOperations {\n\n\t\tprivate static final int DRAIN_THRESHOLD = 16;\n\n\t\tprivate final Queue<Runnable> operations = new ConcurrentLinkedQueue<>();\n\n\t\tpublic void add(Runnable task) {\n\t\t\tthis.operations.add(task);\n\t\t}\n\n\t\tpublic void drain() {\n\t\t\tfor (int i = 0; i < DRAIN_THRESHOLD; i++) {\n\t\t\t\tfinal Runnable task = this.operations.poll();\n\t\t\t\tif (task == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttask.run();\n\t\t\t}\n\t\t}\n\n\t\tpublic void drainAll() {\n\t\t\tRunnable task;\n\t\t\twhile ((task = this.operations.poll()) != null) {\n\t\t\t\ttask.run();\n\t\t\t}\n\t\t}\n\n\t}\n\n\t@SuppressWarnings(\"serial\")\n\tprivate static final class Node<K, V> extends AtomicReference<CacheEntry<V>> {\n\t\tfinal K key;\n\n\t\t@Nullable Node<K, V> prev;\n\n\t\t@Nullable Node<K, V> next;\n\n\t\tNode(K key, CacheEntry<V> cacheEntry) {\n\t\t\tsuper(cacheEntry);\n\t\t\tthis.key = key;\n\t\t}\n\n\t\tpublic @Nullable Node<K, V> getPrevious() {\n\t\t\treturn this.prev;\n\t\t}\n\n\t\tpublic void setPrevious(@Nullable Node<K, V> prev) {\n\t\t\tthis.prev = prev;\n\t\t}\n\n\t\tpublic @Nullable Node<K, V> getNext() {\n\t\t\treturn this.next;\n\t\t}\n\n\t\tpublic void setNext(@Nullable Node<K, V> next) {\n\t\t\tthis.next = next;\n\t\t}\n\n\t\tV getValue() {\n\t\t\treturn get().value;\n\t\t}\n\t}\n\n\n\tprivate static final class EvictionQueue<K, V> {\n\n\t\t@Nullable Node<K, V> first;\n\n\t\t@Nullable Node<K, V> last;\n\n\n\t\t@Nullable Node<K, V> poll() {\n\t\t\tif (this.first == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfinal Node<K, V> f = this.first;\n\t\t\tfinal Node<K, V> next = f.getNext();\n\t\t\tf.setNext(null);\n\n\t\t\tthis.first = next;\n\t\t\tif (next == null) {\n\t\t\t\tthis.last = null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnext.setPrevious(null);\n\t\t\t}\n\t\t\treturn f;\n\t\t}\n\n\t\tvoid add(Node<K, V> e) {\n\t\t\tif (contains(e)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlinkLast(e);\n\t\t}\n\n\t\tprivate boolean contains(Node<K, V> e) {\n\t\t\treturn (e.getPrevious() != null)\n\t\t\t\t\t|| (e.getNext() != null)\n\t\t\t\t\t|| (e == this.first);\n\t\t}\n\n\t\tprivate void linkLast(final Node<K, V> e) {\n\t\t\tfinal Node<K, V> l = this.last;\n\t\t\tthis.last = e;\n\n\t\t\tif (l == null) {\n\t\t\t\tthis.first = e;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tl.setNext(e);\n\t\t\t\te.setPrevious(l);\n\t\t\t}\n\t\t}\n\n\t\tprivate void unlink(Node<K, V> e) {\n\t\t\tfinal Node<K, V> prev = e.getPrevious();\n\t\t\tfinal Node<K, V> next = e.getNext();\n\t\t\tif (prev == null) {\n\t\t\t\tthis.first = next;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprev.setNext(next);\n\t\t\t\te.setPrevious(null);\n\t\t\t}\n\t\t\tif (next == null) {\n\t\t\t\tthis.last = prev;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnext.setPrevious(prev);\n\t\t\t\te.setNext(null);\n\t\t\t}\n\t\t}\n\n\t\tvoid moveToBack(Node<K, V> e) {\n\t\t\tif (contains(e) && e != this.last) {\n\t\t\t\tunlink(e);\n\t\t\t\tlinkLast(e);\n\t\t\t}\n\t\t}\n\n\t\tvoid remove(Node<K, V> e) {\n\t\t\tif (contains(e)) {\n\t\t\t\tunlink(e);\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.ReadOperations",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.ReadOperations#BUFFER_COUNT",
    "tailType": "field"
  },
  {
    "head": "org.springframework.util.ReadOperations#BUFFER_COUNT",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  }
]