[
  {
    "head": "org.springframework.core.convert.support.StringToUUIDConverter#convert(String)",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.convert.support.StringToUUIDConverter#convert(String)",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.convert.support",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core.convert.support",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.convert.support.ZonedDateTimeToCalendarConverter",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.convert.support.ZonedDateTimeToCalendarConverter",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2016 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.convert.support;\n\nimport java.time.ZonedDateTime;\nimport java.util.Calendar;\nimport java.util.GregorianCalendar;\n\nimport org.springframework.core.convert.converter.Converter;\n\n/**\n * Simple converter from Java 8's {@link java.time.ZonedDateTime} to {@link java.util.Calendar}.\n *\n * <p>Note that Spring's default ConversionService setup understands the 'from'/'to' convention\n * that the JSR-310 {@code java.time} package consistently uses. That convention is implemented\n * reflectively in {@link ObjectToObjectConverter}, not in specific JSR-310 converters.\n * It covers {@link java.util.GregorianCalendar#toZonedDateTime()} as well, and also\n * {@link java.util.Date#from(java.time.Instant)} and {@link java.util.Date#toInstant()}.\n *\n * @author Juergen Hoeller\n * @since 4.0.1\n * @see java.util.GregorianCalendar#from(java.time.ZonedDateTime)\n */\nfinal class ZonedDateTimeToCalendarConverter implements Converter<ZonedDateTime, Calendar> {\n\n\t@Override\n\tpublic Calendar convert(ZonedDateTime source) {\n\t\treturn GregorianCalendar.from(source);\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.convert.support.ZonedDateTimeToCalendarConverter#convert(ZonedDateTime)",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic Calendar convert(ZonedDateTime source) {\r\n    return GregorianCalendar.from(source);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.convert.support.ZonedDateTimeToCalendarConverter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.convert.support.ZonedDateTimeToCalendarConverter#convert(ZonedDateTime)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.convert.support.ZonedDateTimeToCalendarConverter#convert(ZonedDateTime)",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.convert.support",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core.convert.support",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.convert.support.ZoneIdToTimeZoneConverter",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.convert.support.ZoneIdToTimeZoneConverter",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2016 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.convert.support;\n\nimport java.time.ZoneId;\nimport java.util.TimeZone;\n\nimport org.springframework.core.convert.converter.Converter;\n\n/**\n * Simple converter from Java 8's {@link java.time.ZoneId} to {@link java.util.TimeZone}.\n *\n * <p>Note that Spring's default ConversionService setup understands the 'from'/'to' convention\n * that the JSR-310 {@code java.time} package consistently uses. That convention is implemented\n * reflectively in {@link ObjectToObjectConverter}, not in specific JSR-310 converters.\n * It covers {@link java.util.TimeZone#toZoneId()} as well, and also\n * {@link java.util.Date#from(java.time.Instant)} and {@link java.util.Date#toInstant()}.\n *\n * @author Juergen Hoeller\n * @since 4.0\n * @see TimeZone#getTimeZone(java.time.ZoneId)\n */\nfinal class ZoneIdToTimeZoneConverter implements Converter<ZoneId, TimeZone> {\n\n\t@Override\n\tpublic TimeZone convert(ZoneId source) {\n\t\treturn TimeZone.getTimeZone(source);\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.convert.support.ZoneIdToTimeZoneConverter#convert(ZoneId)",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic TimeZone convert(ZoneId source) {\r\n    return TimeZone.getTimeZone(source);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.convert.support.ZoneIdToTimeZoneConverter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.convert.support.ZoneIdToTimeZoneConverter#convert(ZoneId)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.convert.support.ZoneIdToTimeZoneConverter#convert(ZoneId)",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.convert",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core.convert",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.convert.TypeDescriptor",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.convert.TypeDescriptor",
    "headType": "class",
    "relation": "use",
    "tail": "@SuppressWarnings",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.convert.TypeDescriptor",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.convert;\n\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Type;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.stream.Stream;\n\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.core.MethodParameter;\nimport org.springframework.core.ResolvableType;\nimport org.springframework.core.annotation.AnnotatedElementUtils;\nimport org.springframework.lang.Contract;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\n\n/**\n * Contextual descriptor about a type to convert from or to.\n * <p>Capable of representing arrays and generic collection types.\n *\n * @author Keith Donald\n * @author Andy Clement\n * @author Juergen Hoeller\n * @author Phillip Webb\n * @author Sam Brannen\n * @author Stephane Nicoll\n * @since 3.0\n * @see ConversionService#canConvert(TypeDescriptor, TypeDescriptor)\n * @see ConversionService#convert(Object, TypeDescriptor, TypeDescriptor)\n */\n@SuppressWarnings(\"serial\")\npublic class TypeDescriptor implements Serializable {\n\n\tprivate static final Map<Class<?>, TypeDescriptor> commonTypesCache = new HashMap<>(32);\n\n\tprivate static final Class<?>[] CACHED_COMMON_TYPES = {\n\t\t\tboolean.class, Boolean.class, byte.class, Byte.class, char.class, Character.class,\n\t\t\tdouble.class, Double.class, float.class, Float.class, int.class, Integer.class,\n\t\t\tlong.class, Long.class, short.class, Short.class, String.class, Object.class};\n\n\tstatic {\n\t\tfor (Class<?> preCachedClass : CACHED_COMMON_TYPES) {\n\t\t\tcommonTypesCache.put(preCachedClass, valueOf(preCachedClass));\n\t\t}\n\t}\n\n\n\tprivate final Class<?> type;\n\n\tprivate final ResolvableType resolvableType;\n\n\tprivate final AnnotatedElementAdapter annotatedElement;\n\n\n\t/**\n\t * Create a new type descriptor from a {@link MethodParameter}.\n\t * <p>Use this constructor when a source or target conversion point is a\n\t * constructor parameter, method parameter, or method return value.\n\t * @param methodParameter the method parameter\n\t */\n\tpublic TypeDescriptor(MethodParameter methodParameter) {\n\t\tthis.resolvableType = ResolvableType.forMethodParameter(methodParameter);\n\t\tthis.type = this.resolvableType.resolve(methodParameter.getNestedParameterType());\n\t\tthis.annotatedElement = AnnotatedElementAdapter.from(methodParameter.getParameterIndex() == -1 ?\n\t\t\t\tmethodParameter.getMethodAnnotations() : methodParameter.getParameterAnnotations());\n\t}\n\n\t/**\n\t * Create a new type descriptor from a {@link Field}.\n\t * <p>Use this constructor when a source or target conversion point is a field.\n\t * @param field the field\n\t */\n\tpublic TypeDescriptor(Field field) {\n\t\tthis.resolvableType = ResolvableType.forField(field);\n\t\tthis.type = this.resolvableType.resolve(field.getType());\n\t\tthis.annotatedElement = AnnotatedElementAdapter.from(field.getAnnotations());\n\t}\n\n\t/**\n\t * Create a new type descriptor from a {@link Property}.\n\t * <p>Use this constructor when a source or target conversion point is a\n\t * property on a Java class.\n\t * @param property the property\n\t */\n\tpublic TypeDescriptor(Property property) {\n\t\tAssert.notNull(property, \"Property must not be null\");\n\t\tthis.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter());\n\t\tthis.type = this.resolvableType.resolve(property.getType());\n\t\tthis.annotatedElement = AnnotatedElementAdapter.from(property.getAnnotations());\n\t}\n\n\t/**\n\t * Create a new type descriptor from a {@link ResolvableType}.\n\t * <p>This constructor is used internally and may also be used by subclasses\n\t * that support non-Java languages with extended type systems. It is public\n\t * as of 5.1.4 whereas it was protected before.\n\t * @param resolvableType the resolvable type\n\t * @param type the backing type (or {@code null} if it should get resolved)\n\t * @param annotations the type annotations\n\t * @since 4.0\n\t */\n\tpublic TypeDescriptor(ResolvableType resolvableType, @Nullable Class<?> type, Annotation @Nullable [] annotations) {\n\t\tthis.resolvableType = resolvableType;\n\t\tthis.type = (type != null ? type : resolvableType.toClass());\n\t\tthis.annotatedElement = AnnotatedElementAdapter.from(annotations);\n\t}\n\n\n\t/**\n\t * Variation of {@link #getType()} that accounts for a primitive type by\n\t * returning its object wrapper type.\n\t * <p>This is useful for conversion service implementations that wish to\n\t * normalize to object-based types and not work with primitive types directly.\n\t */\n\tpublic Class<?> getObjectType() {\n\t\treturn ClassUtils.resolvePrimitiveIfNecessary(getType());\n\t}\n\n\t/**\n\t * The type of the backing class, method parameter, field, or property\n\t * described by this TypeDescriptor.\n\t * <p>Returns primitive types as-is. See {@link #getObjectType()} for a\n\t * variation of this operation that resolves primitive types to their\n\t * corresponding Object types if necessary.\n\t * @see #getObjectType()\n\t */\n\tpublic Class<?> getType() {\n\t\treturn this.type;\n\t}\n\n\t/**\n\t * Return the underlying {@link ResolvableType}.\n\t * @since 4.0\n\t */\n\tpublic ResolvableType getResolvableType() {\n\t\treturn this.resolvableType;\n\t}\n\n\t/**\n\t * Return the underlying source of the descriptor. Will return a {@link Field},\n\t * {@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}\n\t * was constructed. This method is primarily to provide access to additional\n\t * type information or meta-data that alternative JVM languages may provide.\n\t * @since 4.0\n\t */\n\tpublic Object getSource() {\n\t\treturn this.resolvableType.getSource();\n\t}\n\n\n\t/**\n\t * Create a type descriptor for a nested type declared within this descriptor.\n\t * @param nestingLevel the nesting level of the collection/array element or\n\t * map key/value declaration within the property\n\t * @return the nested type descriptor at the specified nesting level, or\n\t * {@code null} if it could not be obtained\n\t * @since 6.1\n\t */\n\tpublic @Nullable TypeDescriptor nested(int nestingLevel) {\n\t\tResolvableType nested = this.resolvableType;\n\t\tfor (int i = 0; i < nestingLevel; i++) {\n\t\t\tif (Object.class == nested.getType()) {\n\t\t\t\t// Could be a collection type but we don't know about its element type,\n\t\t\t\t// so let's just assume there is an element type of type Object...\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnested = nested.getNested(2);\n\t\t\t}\n\t\t}\n\t\tif (nested == ResolvableType.NONE) {\n\t\t\treturn null;\n\t\t}\n\t\treturn getRelatedIfResolvable(nested);\n\t}\n\n\t/**\n\t * Narrows this {@link TypeDescriptor} by setting its type to the class of the\n\t * provided value.\n\t * <p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor\n\t * is returned unchanged.\n\t * <p>Designed to be called by binding frameworks when they read property, field,\n\t * or method return values. Allows such frameworks to narrow a TypeDescriptor built\n\t * from a declared property, field, or method return value type. For example, a field\n\t * declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}\n\t * if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor\n\t * can then be used to convert the HashMap to some other type. Annotation and nested\n\t * type context is preserved by the narrowed copy.\n\t * @param value the value to use for narrowing this type descriptor\n\t * @return this TypeDescriptor narrowed (returns a copy with its type updated to the\n\t * class of the provided value)\n\t */\n\tpublic TypeDescriptor narrow(@Nullable Object value) {\n\t\tif (value == null) {\n\t\t\treturn this;\n\t\t}\n\t\tResolvableType narrowed = ResolvableType.forType(value.getClass(), getResolvableType());\n\t\treturn new TypeDescriptor(narrowed, value.getClass(), getAnnotations());\n\t}\n\n\t/**\n\t * Cast this {@link TypeDescriptor} to a superclass or implemented interface\n\t * preserving annotations and nested type context.\n\t * @param superType the supertype to cast to (can be {@code null})\n\t * @return a new TypeDescriptor for the up-cast type\n\t * @throws IllegalArgumentException if this type is not assignable to the super-type\n\t * @since 3.2\n\t */\n\tpublic @Nullable TypeDescriptor upcast(@Nullable Class<?> superType) {\n\t\tif (superType == null) {\n\t\t\treturn null;\n\t\t}\n\t\tAssert.isAssignable(superType, getType());\n\t\treturn new TypeDescriptor(getResolvableType().as(superType), superType, getAnnotations());\n\t}\n\n\t/**\n\t * Return the name of this type: the fully qualified class name.\n\t */\n\tpublic String getName() {\n\t\treturn ClassUtils.getQualifiedName(getType());\n\t}\n\n\t/**\n\t * Is this type a primitive type?\n\t */\n\tpublic boolean isPrimitive() {\n\t\treturn getType().isPrimitive();\n\t}\n\n\t/**\n\t * Return the annotations associated with this type descriptor, if any.\n\t * @return the annotations, or an empty array if none\n\t */\n\tpublic Annotation[] getAnnotations() {\n\t\treturn this.annotatedElement.getAnnotations();\n\t}\n\n\t/**\n\t * Determine if this type descriptor has the specified annotation.\n\t * <p>As of Spring Framework 4.2, this method supports arbitrary levels\n\t * of meta-annotations.\n\t * @param annotationType the annotation type\n\t * @return {@code true} if the annotation is present\n\t */\n\tpublic boolean hasAnnotation(Class<? extends Annotation> annotationType) {\n\t\tif (this.annotatedElement.isEmpty()) {\n\t\t\t// Shortcut: AnnotatedElementUtils would have to expect AnnotatedElement.getAnnotations()\n\t\t\t// to return a copy of the array, whereas we can do it more efficiently here.\n\t\t\treturn false;\n\t\t}\n\t\treturn AnnotatedElementUtils.isAnnotated(this.annotatedElement, annotationType);\n\t}\n\n\t/**\n\t * Obtain the annotation of the specified {@code annotationType} that is on this type descriptor.\n\t * <p>As of Spring Framework 4.2, this method supports arbitrary levels of meta-annotations.\n\t * @param annotationType the annotation type\n\t * @return the annotation, or {@code null} if no such annotation exists on this type descriptor\n\t */\n\tpublic <T extends Annotation> @Nullable T getAnnotation(Class<T> annotationType) {\n\t\tif (this.annotatedElement.isEmpty()) {\n\t\t\t// Shortcut: AnnotatedElementUtils would have to expect AnnotatedElement.getAnnotations()\n\t\t\t// to return a copy of the array, whereas we can do it more efficiently here.\n\t\t\treturn null;\n\t\t}\n\t\treturn AnnotatedElementUtils.getMergedAnnotation(this.annotatedElement, annotationType);\n\t}\n\n\t/**\n\t * Returns true if an object of this type descriptor can be assigned to the location\n\t * described by the given type descriptor.\n\t * <p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}\n\t * returns {@code true} because a String value can be assigned to a CharSequence variable.\n\t * On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}\n\t * returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers.\n\t * <p>For arrays, collections, and maps, element and key/value types are checked if declared.\n\t * For example, a {@code List<String>} field value is assignable to a {@code Collection<CharSequence>}\n\t * field, but {@code List<Number>} is not assignable to {@code List<Integer>}.\n\t * @return {@code true} if this type is assignable to the type represented by the provided\n\t * type descriptor\n\t * @see #getObjectType()\n\t */\n\tpublic boolean isAssignableTo(TypeDescriptor typeDescriptor) {\n\t\tboolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType());\n\t\tif (!typesAssignable) {\n\t\t\treturn false;\n\t\t}\n\t\tif (isArray() && typeDescriptor.isArray()) {\n\t\t\treturn isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor());\n\t\t}\n\t\telse if (isCollection() && typeDescriptor.isCollection()) {\n\t\t\treturn isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor());\n\t\t}\n\t\telse if (isMap() && typeDescriptor.isMap()) {\n\t\t\treturn isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&\n\t\t\t\tisNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor());\n\t\t}\n\t\telse {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate boolean isNestedAssignable(@Nullable TypeDescriptor nestedTypeDescriptor,\n\t\t\t@Nullable TypeDescriptor otherNestedTypeDescriptor) {\n\n\t\treturn (nestedTypeDescriptor == null || otherNestedTypeDescriptor == null ||\n\t\t\t\tnestedTypeDescriptor.isAssignableTo(otherNestedTypeDescriptor));\n\t}\n\n\t/**\n\t * Is this type a {@link Collection} type?\n\t */\n\tpublic boolean isCollection() {\n\t\treturn Collection.class.isAssignableFrom(getType());\n\t}\n\n\t/**\n\t * Is this type an array type?\n\t */\n\tpublic boolean isArray() {\n\t\treturn getType().isArray();\n\t}\n\n\t/**\n\t * If this type is an array, returns the array's component type.\n\t * If this type is a {@code Stream}, returns the stream's component type.\n\t * If this type is a {@link Collection} and it is parameterized, returns the Collection's element type.\n\t * If the Collection is not parameterized, returns {@code null} indicating the element type is not declared.\n\t * @return the array component type or Collection element type, or {@code null} if this type is not\n\t * an array type or a {@code java.util.Collection} or if its element type is not parameterized\n\t * @see #elementTypeDescriptor(Object)\n\t */\n\tpublic @Nullable TypeDescriptor getElementTypeDescriptor() {\n\t\tif (getResolvableType().isArray()) {\n\t\t\treturn new TypeDescriptor(getResolvableType().getComponentType(), null, getAnnotations());\n\t\t}\n\t\tif (Stream.class.isAssignableFrom(getType())) {\n\t\t\treturn getRelatedIfResolvable(getResolvableType().as(Stream.class).getGeneric(0));\n\t\t}\n\t\treturn getRelatedIfResolvable(getResolvableType().asCollection().getGeneric(0));\n\t}\n\n\t/**\n\t * If this type is a {@link Collection} or an array, creates an element TypeDescriptor\n\t * from the provided collection or array element.\n\t * <p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class\n\t * of the provided collection or array element. For example, if this describes a\n\t * {@code java.util.List<java.lang.Number>} and the element argument is a\n\t * {@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}.\n\t * If this describes a {@code java.util.List<?>} and the element argument is a\n\t * {@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}\n\t * as well.\n\t * <p>Annotation and nested type context will be preserved in the narrowed\n\t * TypeDescriptor that is returned.\n\t * @param element the collection or array element\n\t * @return an element type descriptor, narrowed to the type of the provided element\n\t * @see #getElementTypeDescriptor()\n\t * @see #narrow(Object)\n\t */\n\tpublic @Nullable TypeDescriptor elementTypeDescriptor(Object element) {\n\t\treturn narrow(element, getElementTypeDescriptor());\n\t}\n\n\t/**\n\t * Is this type a {@link Map} type?\n\t */\n\tpublic boolean isMap() {\n\t\treturn Map.class.isAssignableFrom(getType());\n\t}\n\n\t/**\n\t * If this type is a {@link Map} and its key type is parameterized,\n\t * returns the map's key type. If the Map's key type is not parameterized,\n\t * returns {@code null} indicating the key type is not declared.\n\t * @return the Map key type, or {@code null} if this type is a Map\n\t * but its key type is not parameterized\n\t * @throws IllegalStateException if this type is not a {@code java.util.Map}\n\t */\n\tpublic @Nullable TypeDescriptor getMapKeyTypeDescriptor() {\n\t\tAssert.state(isMap(), \"Not a [java.util.Map]\");\n\t\treturn getRelatedIfResolvable(getResolvableType().asMap().getGeneric(0));\n\t}\n\n\t/**\n\t * If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}\n\t * from the provided map key.\n\t * <p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property\n\t * to the class of the provided map key. For example, if this describes a\n\t * {@code java.util.Map<java.lang.Number, java.lang.String>} and the key\n\t * argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be\n\t * {@code java.lang.Integer}. If this describes a {@code java.util.Map<?, ?>}\n\t * and the key argument is a {@code java.lang.Integer}, the returned\n\t * TypeDescriptor will be {@code java.lang.Integer} as well.\n\t * <p>Annotation and nested type context will be preserved in the narrowed\n\t * TypeDescriptor that is returned.\n\t * @param mapKey the map key\n\t * @return the map key type descriptor\n\t * @throws IllegalStateException if this type is not a {@code java.util.Map}\n\t * @see #narrow(Object)\n\t */\n\tpublic @Nullable TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {\n\t\treturn narrow(mapKey, getMapKeyTypeDescriptor());\n\t}\n\n\t/**\n\t * If this type is a {@link Map} and its value type is parameterized,\n\t * returns the map's value type.\n\t * <p>If the Map's value type is not parameterized, returns {@code null}\n\t * indicating the value type is not declared.\n\t * @return the Map value type, or {@code null} if this type is a Map\n\t * but its value type is not parameterized\n\t * @throws IllegalStateException if this type is not a {@code java.util.Map}\n\t */\n\tpublic @Nullable TypeDescriptor getMapValueTypeDescriptor() {\n\t\tAssert.state(isMap(), \"Not a [java.util.Map]\");\n\t\treturn getRelatedIfResolvable(getResolvableType().asMap().getGeneric(1));\n\t}\n\n\t/**\n\t * If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}\n\t * from the provided map value.\n\t * <p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property\n\t * to the class of the provided map value. For example, if this describes a\n\t * {@code java.util.Map<java.lang.String, java.lang.Number>} and the value\n\t * argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be\n\t * {@code java.lang.Integer}. If this describes a {@code java.util.Map<?, ?>}\n\t * and the value argument is a {@code java.lang.Integer}, the returned\n\t * TypeDescriptor will be {@code java.lang.Integer} as well.\n\t * <p>Annotation and nested type context will be preserved in the narrowed\n\t * TypeDescriptor that is returned.\n\t * @param mapValue the map value\n\t * @return the map value type descriptor\n\t * @throws IllegalStateException if this type is not a {@code java.util.Map}\n\t * @see #narrow(Object)\n\t */\n\tpublic @Nullable TypeDescriptor getMapValueTypeDescriptor(@Nullable Object mapValue) {\n\t\treturn narrow(mapValue, getMapValueTypeDescriptor());\n\t}\n\n\tprivate @Nullable TypeDescriptor getRelatedIfResolvable(ResolvableType type) {\n\t\tif (type.resolve() == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new TypeDescriptor(type, null, getAnnotations());\n\t}\n\n\tprivate @Nullable TypeDescriptor narrow(@Nullable Object value, @Nullable TypeDescriptor typeDescriptor) {\n\t\tif (typeDescriptor != null) {\n\t\t\treturn typeDescriptor.narrow(value);\n\t\t}\n\t\tif (value != null) {\n\t\t\treturn narrow(value);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!(other instanceof TypeDescriptor otherDesc)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (getType() != otherDesc.getType()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!annotationsMatch(otherDesc)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn Arrays.equals(getResolvableType().getGenerics(), otherDesc.getResolvableType().getGenerics());\n\t}\n\n\tprivate boolean annotationsMatch(TypeDescriptor otherDesc) {\n\t\tAnnotation[] anns = getAnnotations();\n\t\tAnnotation[] otherAnns = otherDesc.getAnnotations();\n\t\tif (anns == otherAnns) {\n\t\t\treturn true;\n\t\t}\n\t\tif (anns.length != otherAnns.length) {\n\t\t\treturn false;\n\t\t}\n\t\tif (anns.length > 0) {\n\t\t\tfor (int i = 0; i < anns.length; i++) {\n\t\t\t\tif (!annotationEquals(anns[i], otherAnns[i])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate boolean annotationEquals(Annotation ann, Annotation otherAnn) {\n\t\t// Annotation.equals is reflective and pretty slow, so let's check identity and proxy type first.\n\t\treturn (ann == otherAnn || (ann.getClass() == otherAnn.getClass() && ann.equals(otherAnn)));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn getType().hashCode();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder builder = new StringBuilder();\n\t\tfor (Annotation ann : getAnnotations()) {\n\t\t\tbuilder.append('@').append(getName(ann.annotationType())).append(' ');\n\t\t}\n\t\tbuilder.append(getResolvableType());\n\t\treturn builder.toString();\n\t}\n\n\n\t/**\n\t * Create a new type descriptor for an object.\n\t * <p>Use this factory method to introspect a source object before asking the\n\t * conversion system to convert it to some other type.\n\t * <p>If the provided object is {@code null}, returns {@code null}, else calls\n\t * {@link #valueOf(Class)} to build a TypeDescriptor from the object's class.\n\t * @param source the source object\n\t * @return the type descriptor\n\t */\n\t@Contract(\"!null -> !null; null -> null\")\n\tpublic static @Nullable TypeDescriptor forObject(@Nullable Object source) {\n\t\treturn (source != null ? valueOf(source.getClass()) : null);\n\t}\n\n\t/**\n\t * Create a new type descriptor from the given type.\n\t * <p>Use this to instruct the conversion system to convert an object to a\n\t * specific target type, when no type location such as a method parameter or\n\t * field is available to provide additional conversion context.\n\t * <p>Generally prefer use of {@link #forObject(Object)} for constructing type\n\t * descriptors from source objects, as it handles the {@code null} object case.\n\t * @param type the class (may be {@code null} to indicate {@code Object.class})\n\t * @return the corresponding type descriptor\n\t */\n\tpublic static TypeDescriptor valueOf(@Nullable Class<?> type) {\n\t\tif (type == null) {\n\t\t\ttype = Object.class;\n\t\t}\n\t\tTypeDescriptor desc = commonTypesCache.get(type);\n\t\treturn (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null));\n\t}\n\n\t/**\n\t * Create a new type descriptor from a {@link java.util.Collection} type.\n\t * <p>Useful for converting to typed Collections.\n\t * <p>For example, a {@code List<String>} could be converted to a\n\t * {@code List<EmailAddress>} by converting to a targetType built with this method.\n\t * The method call to construct such a {@code TypeDescriptor} would look something\n\t * like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class));}\n\t * @param collectionType the collection type, which must implement {@link Collection}.\n\t * @param elementTypeDescriptor a descriptor for the collection's element type,\n\t * used to convert collection elements\n\t * @return the collection type descriptor\n\t */\n\tpublic static TypeDescriptor collection(Class<?> collectionType, @Nullable TypeDescriptor elementTypeDescriptor) {\n\t\tAssert.notNull(collectionType, \"Collection type must not be null\");\n\t\tif (!Collection.class.isAssignableFrom(collectionType)) {\n\t\t\tthrow new IllegalArgumentException(\"Collection type must be a [java.util.Collection]\");\n\t\t}\n\t\tResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null);\n\t\treturn new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null);\n\t}\n\n\t/**\n\t * Create a new type descriptor from a {@link java.util.Map} type.\n\t * <p>Useful for converting to typed Maps.\n\t * <p>For example, a {@code Map<String, String>} could be converted to a {@code Map<Id, EmailAddress>}\n\t * by converting to a targetType built with this method:\n\t * The method call to construct such a TypeDescriptor would look something like:\n\t * <pre class=\"code\">\n\t * map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class));\n\t * </pre>\n\t * @param mapType the map type, which must implement {@link Map}\n\t * @param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys\n\t * @param valueTypeDescriptor the map's value type, used to convert map values\n\t * @return the map type descriptor\n\t */\n\tpublic static TypeDescriptor map(Class<?> mapType, @Nullable TypeDescriptor keyTypeDescriptor,\n\t\t\t@Nullable TypeDescriptor valueTypeDescriptor) {\n\n\t\tAssert.notNull(mapType, \"Map type must not be null\");\n\t\tif (!Map.class.isAssignableFrom(mapType)) {\n\t\t\tthrow new IllegalArgumentException(\"Map type must be a [java.util.Map]\");\n\t\t}\n\t\tResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null);\n\t\tResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null);\n\t\treturn new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null);\n\t}\n\n\t/**\n\t * Create a new type descriptor as an array of the specified type.\n\t * <p>For example to create a {@code Map<String,String>[]} use:\n\t * <pre class=\"code\">\n\t * TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)));\n\t * </pre>\n\t * @param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}\n\t * @return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}\n\t * @since 3.2.1\n\t */\n\t@Contract(\"!null -> !null; null -> null\")\n\tpublic static @Nullable TypeDescriptor array(@Nullable TypeDescriptor elementTypeDescriptor) {\n\t\tif (elementTypeDescriptor == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),\n\t\t\t\tnull, elementTypeDescriptor.getAnnotations());\n\t}\n\n\t/**\n\t * Create a type descriptor for a nested type declared within the method parameter.\n\t * <p>For example, if the methodParameter is a {@code List<String>} and the\n\t * nesting level is 1, the nested type descriptor will be String.class.\n\t * <p>If the methodParameter is a {@code List<List<String>>} and the nesting\n\t * level is 2, the nested type descriptor will also be a String.class.\n\t * <p>If the methodParameter is a {@code Map<Integer, String>} and the nesting\n\t * level is 1, the nested type descriptor will be String, derived from the map value.\n\t * <p>If the methodParameter is a {@code List<Map<Integer, String>>} and the\n\t * nesting level is 2, the nested type descriptor will be String, derived from the map value.\n\t * <p>Returns {@code null} if a nested type cannot be obtained because it was not declared.\n\t * For example, if the method parameter is a {@code List<?>}, the nested type\n\t * descriptor returned will be {@code null}.\n\t * @param methodParameter the method parameter with a nestingLevel of 1\n\t * @param nestingLevel the nesting level of the collection/array element or\n\t * map key/value declaration within the method parameter\n\t * @return the nested type descriptor at the specified nesting level,\n\t * or {@code null} if it could not be obtained\n\t * @throws IllegalArgumentException if the nesting level of the input\n\t * {@link MethodParameter} argument is not 1, or if the types up to the\n\t * specified nesting level are not of collection, array, or map types\n\t */\n\tpublic static @Nullable TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {\n\t\tif (methodParameter.getNestingLevel() != 1) {\n\t\t\tthrow new IllegalArgumentException(\"MethodParameter nesting level must be 1: \" +\n\t\t\t\t\t\"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal\");\n\t\t}\n\t\treturn new TypeDescriptor(methodParameter).nested(nestingLevel);\n\t}\n\n\t/**\n\t * Create a type descriptor for a nested type declared within the field.\n\t * <p>For example, if the field is a {@code List<String>} and the nesting\n\t * level is 1, the nested type descriptor will be {@code String.class}.\n\t * <p>If the field is a {@code List<List<String>>} and the nesting level is\n\t * 2, the nested type descriptor will also be a {@code String.class}.\n\t * <p>If the field is a {@code Map<Integer, String>} and the nesting level\n\t * is 1, the nested type descriptor will be String, derived from the map value.\n\t * <p>If the field is a {@code List<Map<Integer, String>>} and the nesting\n\t * level is 2, the nested type descriptor will be String, derived from the map value.\n\t * <p>Returns {@code null} if a nested type cannot be obtained because it was not\n\t * declared. For example, if the field is a {@code List<?>}, the nested type\n\t * descriptor returned will be {@code null}.\n\t * @param field the field\n\t * @param nestingLevel the nesting level of the collection/array element or\n\t * map key/value declaration within the field\n\t * @return the nested type descriptor at the specified nesting level,\n\t * or {@code null} if it could not be obtained\n\t * @throws IllegalArgumentException if the types up to the specified nesting\n\t * level are not of collection, array, or map types\n\t */\n\tpublic static @Nullable TypeDescriptor nested(Field field, int nestingLevel) {\n\t\treturn new TypeDescriptor(field).nested(nestingLevel);\n\t}\n\n\t/**\n\t * Create a type descriptor for a nested type declared within the property.\n\t * <p>For example, if the property is a {@code List<String>} and the nesting\n\t * level is 1, the nested type descriptor will be {@code String.class}.\n\t * <p>If the property is a {@code List<List<String>>} and the nesting level\n\t * is 2, the nested type descriptor will also be a {@code String.class}.\n\t * <p>If the property is a {@code Map<Integer, String>} and the nesting level\n\t * is 1, the nested type descriptor will be String, derived from the map value.\n\t * <p>If the property is a {@code List<Map<Integer, String>>} and the nesting\n\t * level is 2, the nested type descriptor will be String, derived from the map value.\n\t * <p>Returns {@code null} if a nested type cannot be obtained because it was not\n\t * declared. For example, if the property is a {@code List<?>}, the nested type\n\t * descriptor returned will be {@code null}.\n\t * @param property the property\n\t * @param nestingLevel the nesting level of the collection/array element or\n\t * map key/value declaration within the property\n\t * @return the nested type descriptor at the specified nesting level, or\n\t * {@code null} if it could not be obtained\n\t * @throws IllegalArgumentException if the types up to the specified nesting\n\t * level are not of collection, array, or map types\n\t */\n\tpublic static @Nullable TypeDescriptor nested(Property property, int nestingLevel) {\n\t\treturn new TypeDescriptor(property).nested(nestingLevel);\n\t}\n\n\tprivate static String getName(Class<?> clazz) {\n\t\tString canonicalName = clazz.getCanonicalName();\n\t\treturn (canonicalName != null ? canonicalName : clazz.getName());\n\t}\n\n\n\t/**\n\t * Adapter class for exposing a {@code TypeDescriptor}'s annotations as an\n\t * {@link AnnotatedElement}, in particular to {@link AnnotatedElementUtils}.\n\t * @see AnnotatedElementUtils#isAnnotated(AnnotatedElement, Class)\n\t * @see AnnotatedElementUtils#getMergedAnnotation(AnnotatedElement, Class)\n\t */\n\tprivate static final class AnnotatedElementAdapter implements AnnotatedElement, Serializable {\n\n\t\tprivate static final AnnotatedElementAdapter EMPTY = new AnnotatedElementAdapter(new Annotation[0]);\n\n\t\tprivate final Annotation[] annotations;\n\n\t\tprivate AnnotatedElementAdapter(Annotation[] annotations) {\n\t\t\tthis.annotations = annotations;\n\t\t}\n\n\t\tprivate static AnnotatedElementAdapter from(Annotation @Nullable [] annotations) {\n\t\t\tif (annotations == null || annotations.length == 0) {\n\t\t\t\treturn EMPTY;\n\t\t\t}\n\t\t\treturn new AnnotatedElementAdapter(annotations);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) {\n\t\t\tfor (Annotation annotation : this.annotations) {\n\t\t\t\tif (annotation.annotationType() == annotationClass) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic <T extends Annotation> @Nullable T getAnnotation(Class<T> annotationClass) {\n\t\t\tfor (Annotation annotation : this.annotations) {\n\t\t\t\tif (annotation.annotationType() == annotationClass) {\n\t\t\t\t\treturn (T) annotation;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Annotation[] getAnnotations() {\n\t\t\treturn (isEmpty() ? this.annotations : this.annotations.clone());\n\t\t}\n\n\t\t@Override\n\t\tpublic Annotation[] getDeclaredAnnotations() {\n\t\t\treturn getAnnotations();\n\t\t}\n\n\t\tpublic boolean isEmpty() {\n\t\t\treturn (this.annotations.length == 0);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || (other instanceof AnnotatedElementAdapter that &&\n\t\t\t\t\tArrays.equals(this.annotations, that.annotations)));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(this.annotations);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn Arrays.toString(this.annotations);\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.convert.TypeDescriptor",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.convert.TypeDescriptor#commonTypesCache",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.convert.TypeDescriptor#commonTypesCache",
    "headType": "field",
    "relation": "haveType",
    "tail": "Map<Class<?>, TypeDescriptor>",
    "tailType": "type"
  }
]