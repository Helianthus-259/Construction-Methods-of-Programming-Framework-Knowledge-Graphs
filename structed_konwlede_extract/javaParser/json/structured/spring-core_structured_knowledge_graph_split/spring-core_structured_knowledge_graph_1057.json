[
  {
    "head": "org.springframework.core.io.support.EncodedResource#toString()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic String toString() {\r\n    return this.resource.toString();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.io.support.EncodedResource",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.io.support.EncodedResource#toString()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.io.support.EncodedResource#toString()",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.io.support",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core.io.support",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.io.support.LocalizedResourceHelper",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.io.support.LocalizedResourceHelper",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2018 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.io.support;\n\nimport java.util.Locale;\n\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.core.io.DefaultResourceLoader;\nimport org.springframework.core.io.Resource;\nimport org.springframework.core.io.ResourceLoader;\nimport org.springframework.util.Assert;\n\n/**\n * Helper class for loading a localized resource,\n * specified through name, extension and current locale.\n *\n * @author Juergen Hoeller\n * @since 1.2.5\n */\npublic class LocalizedResourceHelper {\n\n\t/** The default separator to use in-between file name parts: an underscore. */\n\tpublic static final String DEFAULT_SEPARATOR = \"_\";\n\n\n\tprivate final ResourceLoader resourceLoader;\n\n\tprivate String separator = DEFAULT_SEPARATOR;\n\n\n\t/**\n\t * Create a new LocalizedResourceHelper with a DefaultResourceLoader.\n\t * @see org.springframework.core.io.DefaultResourceLoader\n\t */\n\tpublic LocalizedResourceHelper() {\n\t\tthis.resourceLoader = new DefaultResourceLoader();\n\t}\n\n\t/**\n\t * Create a new LocalizedResourceHelper with the given ResourceLoader.\n\t * @param resourceLoader the ResourceLoader to use\n\t */\n\tpublic LocalizedResourceHelper(ResourceLoader resourceLoader) {\n\t\tAssert.notNull(resourceLoader, \"ResourceLoader must not be null\");\n\t\tthis.resourceLoader = resourceLoader;\n\t}\n\n\t/**\n\t * Set the separator to use in-between file name parts.\n\t * Default is an underscore (\"_\").\n\t */\n\tpublic void setSeparator(@Nullable String separator) {\n\t\tthis.separator = (separator != null ? separator : DEFAULT_SEPARATOR);\n\t}\n\n\n\t/**\n\t * Find the most specific localized resource for the given name,\n\t * extension and locale:\n\t * <p>The file will be searched with locations in the following order,\n\t * similar to {@code java.util.ResourceBundle}'s search order:\n\t * <ul>\n\t * <li>[name]_[language]_[country]_[variant][extension]\n\t * <li>[name]_[language]_[country][extension]\n\t * <li>[name]_[language][extension]\n\t * <li>[name][extension]\n\t * </ul>\n\t * <p>If none of the specific files can be found, a resource\n\t * descriptor for the default location will be returned.\n\t * @param name the name of the file, without localization part nor extension\n\t * @param extension the file extension (for example, \".xls\")\n\t * @param locale the current locale (may be {@code null})\n\t * @return the most specific localized resource found\n\t * @see java.util.ResourceBundle\n\t */\n\tpublic Resource findLocalizedResource(String name, String extension, @Nullable Locale locale) {\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tAssert.notNull(extension, \"Extension must not be null\");\n\n\t\tResource resource = null;\n\n\t\tif (locale != null) {\n\t\t\tString lang = locale.getLanguage();\n\t\t\tString country = locale.getCountry();\n\t\t\tString variant = locale.getVariant();\n\n\t\t\t// Check for file with language, country and variant localization.\n\t\t\tif (variant.length() > 0) {\n\t\t\t\tString location =\n\t\t\t\t\t\tname + this.separator + lang + this.separator + country + this.separator + variant + extension;\n\t\t\t\tresource = this.resourceLoader.getResource(location);\n\t\t\t}\n\n\t\t\t// Check for file with language and country localization.\n\t\t\tif ((resource == null || !resource.exists()) && country.length() > 0) {\n\t\t\t\tString location = name + this.separator + lang + this.separator + country + extension;\n\t\t\t\tresource = this.resourceLoader.getResource(location);\n\t\t\t}\n\n\t\t\t// Check for document with language localization.\n\t\t\tif ((resource == null || !resource.exists()) && lang.length() > 0) {\n\t\t\t\tString location = name + this.separator + lang + extension;\n\t\t\t\tresource = this.resourceLoader.getResource(location);\n\t\t\t}\n\t\t}\n\n\t\t// Check for document without localization.\n\t\tif (resource == null || !resource.exists()) {\n\t\t\tString location = name + extension;\n\t\t\tresource = this.resourceLoader.getResource(location);\n\t\t}\n\n\t\treturn resource;\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.io.support.LocalizedResourceHelper",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.io.support.LocalizedResourceHelper#DEFAULT_SEPARATOR",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.io.support.LocalizedResourceHelper#DEFAULT_SEPARATOR",
    "headType": "field",
    "relation": "haveType",
    "tail": "String",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.io.support.LocalizedResourceHelper",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.io.support.LocalizedResourceHelper#resourceLoader",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.io.support.LocalizedResourceHelper#resourceLoader",
    "headType": "field",
    "relation": "haveType",
    "tail": "ResourceLoader",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.io.support.LocalizedResourceHelper",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.io.support.LocalizedResourceHelper#separator",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.io.support.LocalizedResourceHelper#separator",
    "headType": "field",
    "relation": "haveType",
    "tail": "String",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.io.support.LocalizedResourceHelper#setSeparator(String)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Set the separator to use in-between file name parts.\r\n * Default is an underscore (\"_\").\r\n */\r\npublic void setSeparator(@Nullable String separator) {\r\n    this.separator = (separator != null ? separator : DEFAULT_SEPARATOR);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.io.support.LocalizedResourceHelper",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.io.support.LocalizedResourceHelper#setSeparator(String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.io.support.LocalizedResourceHelper#findLocalizedResource(String,String,Locale)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Find the most specific localized resource for the given name,\r\n * extension and locale:\r\n * <p>The file will be searched with locations in the following order,\r\n * similar to {@code java.util.ResourceBundle}'s search order:\r\n * <ul>\r\n * <li>[name]_[language]_[country]_[variant][extension]\r\n * <li>[name]_[language]_[country][extension]\r\n * <li>[name]_[language][extension]\r\n * <li>[name][extension]\r\n * </ul>\r\n * <p>If none of the specific files can be found, a resource\r\n * descriptor for the default location will be returned.\r\n * @param name the name of the file, without localization part nor extension\r\n * @param extension the file extension (for example, \".xls\")\r\n * @param locale the current locale (may be {@code null})\r\n * @return the most specific localized resource found\r\n * @see java.util.ResourceBundle\r\n */\r\npublic Resource findLocalizedResource(String name, String extension, @Nullable Locale locale) {\r\n    Assert.notNull(name, \"Name must not be null\");\r\n    Assert.notNull(extension, \"Extension must not be null\");\r\n    Resource resource = null;\r\n    if (locale != null) {\r\n        String lang = locale.getLanguage();\r\n        String country = locale.getCountry();\r\n        String variant = locale.getVariant();\r\n        // Check for file with language, country and variant localization.\r\n        if (variant.length() > 0) {\r\n            String location = name + this.separator + lang + this.separator + country + this.separator + variant + extension;\r\n            resource = this.resourceLoader.getResource(location);\r\n        }\r\n        // Check for file with language and country localization.\r\n        if ((resource == null || !resource.exists()) && country.length() > 0) {\r\n            String location = name + this.separator + lang + this.separator + country + extension;\r\n            resource = this.resourceLoader.getResource(location);\r\n        }\r\n        // Check for document with language localization.\r\n        if ((resource == null || !resource.exists()) && lang.length() > 0) {\r\n            String location = name + this.separator + lang + extension;\r\n            resource = this.resourceLoader.getResource(location);\r\n        }\r\n    }\r\n    // Check for document without localization.\r\n    if (resource == null || !resource.exists()) {\r\n        String location = name + extension;\r\n        resource = this.resourceLoader.getResource(location);\r\n    }\r\n    return resource;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.io.support.LocalizedResourceHelper",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.io.support.LocalizedResourceHelper#findLocalizedResource(String,String,Locale)",
    "tailType": "method"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.io.support",
    "tailType": "package"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.io.support",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core.io.support",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.io.support.PathMatchingResourcePatternResolver",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.io.support.PathMatchingResourcePatternResolver",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.io.support;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.lang.module.ModuleFinder;\nimport java.lang.module.ModuleReader;\nimport java.lang.module.ResolvedModule;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.net.JarURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.net.URLConnection;\nimport java.nio.file.FileSystemNotFoundException;\nimport java.nio.file.FileSystems;\nimport java.nio.file.FileVisitOption;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Collections;\nimport java.util.Enumeration;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.NavigableSet;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.Predicate;\nimport java.util.jar.Attributes;\nimport java.util.jar.Attributes.Name;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarFile;\nimport java.util.jar.Manifest;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport java.util.zip.ZipException;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.core.NativeDetector;\nimport org.springframework.core.io.DefaultResourceLoader;\nimport org.springframework.core.io.FileSystemResource;\nimport org.springframework.core.io.Resource;\nimport org.springframework.core.io.ResourceLoader;\nimport org.springframework.core.io.UrlResource;\nimport org.springframework.core.io.VfsResource;\nimport org.springframework.util.AntPathMatcher;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.PathMatcher;\nimport org.springframework.util.ReflectionUtils;\nimport org.springframework.util.ResourceUtils;\nimport org.springframework.util.StringUtils;\n\n/**\n * A {@link ResourcePatternResolver} implementation that is able to resolve a\n * specified resource location path into one or more matching Resources.\n *\n * <p>The source path may be a simple path which has a one-to-one mapping to a\n * target {@link org.springframework.core.io.Resource}, or alternatively may\n * contain the special \"{@code classpath*:}\" prefix and/or internal Ant-style\n * path patterns (matched using Spring's {@link AntPathMatcher} utility). Both\n * of the latter are effectively wildcards.\n *\n * <h3>No Wildcards</h3>\n *\n * <p>In the simple case, if the specified location path does not start with the\n * {@code \"classpath*:}\" prefix and does not contain a {@link PathMatcher}\n * pattern, this resolver will simply return a single resource via a\n * {@code getResource()} call on the underlying {@code ResourceLoader}.\n * Examples are real URLs such as \"{@code file:C:/context.xml}\", pseudo-URLs\n * such as \"{@code classpath:/context.xml}\", and simple unprefixed paths\n * such as \"{@code /WEB-INF/context.xml}\". The latter will resolve in a\n * fashion specific to the underlying {@code ResourceLoader} (for example,\n * {@code ServletContextResource} for a {@code WebApplicationContext}).\n *\n * <h3>Ant-style Patterns</h3>\n *\n * <p>When the path location contains an Ant-style pattern, for example:\n * <pre class=\"code\">\n * /WEB-INF/*-context.xml\n * com/example/**&#47;applicationContext.xml\n * file:C:/some/path/*-context.xml\n * classpath:com/example/**&#47;applicationContext.xml</pre>\n * the resolver follows a more complex but defined procedure to try to resolve\n * the wildcard. It produces a {@code Resource} for the path up to the last\n * non-wildcard segment and obtains a {@code URL} from it. If this URL is not a\n * \"{@code jar:}\" URL or container-specific variant (for example, \"{@code zip:}\" in WebLogic,\n * \"{@code wsjar}\" in WebSphere\", etc.), then the root directory of the filesystem\n * associated with the URL is obtained and used to resolve the wildcards by walking\n * the filesystem. In the case of a jar URL, the resolver either gets a\n * {@code java.net.JarURLConnection} from it, or manually parses the jar URL, and\n * then traverses the contents of the jar file, to resolve the wildcards.\n *\n * <h3>Implications on Portability</h3>\n *\n * <p>If the specified path is already a file URL (either explicitly, or\n * implicitly because the base {@code ResourceLoader} is a filesystem one),\n * then wildcarding is guaranteed to work in a completely portable fashion.\n *\n * <p>If the specified path is a class path location, then the resolver must\n * obtain the last non-wildcard path segment URL via a\n * {@code Classloader.getResource()} call. Since this is just a\n * node of the path (not the file at the end) it is actually undefined\n * (in the ClassLoader Javadocs) exactly what sort of URL is returned in\n * this case. In practice, it is usually a {@code java.io.File} representing\n * the directory, where the class path resource resolves to a filesystem\n * location, or a jar URL of some sort, where the class path resource resolves\n * to a jar location. Still, there is a portability concern on this operation.\n *\n * <p>If a jar URL is obtained for the last non-wildcard segment, the resolver\n * must be able to get a {@code java.net.JarURLConnection} from it, or\n * manually parse the jar URL, to be able to walk the contents of the jar\n * and resolve the wildcard. This will work in most environments but will\n * fail in others, and it is strongly recommended that the wildcard\n * resolution of resources coming from jars be thoroughly tested in your\n * specific environment before you rely on it.\n *\n * <h3>{@code classpath*:} Prefix</h3>\n *\n * <p>There is special support for retrieving multiple class path resources with\n * the same name, via the \"{@code classpath*:}\" prefix. For example,\n * \"{@code classpath*:META-INF/beans.xml}\" will find all \"META-INF/beans.xml\"\n * files in the class path, be it in \"classes\" directories or in JAR files.\n * This is particularly useful for autodetecting config files of the same name\n * at the same location within each jar file. Internally, this happens via a\n * {@code ClassLoader.getResources()} call, and is completely portable.\n *\n * <p>The \"{@code classpath*:}\" prefix can also be combined with a {@code PathMatcher}\n * pattern in the rest of the location path &mdash; for example,\n * \"{@code classpath*:META-INF/*-beans.xml\"}. In this case, the resolution strategy\n * is fairly simple: a {@code ClassLoader.getResources()} call is used on the last\n * non-wildcard path segment to get all the matching resources in the class loader\n * hierarchy, and then off each resource the same {@code PathMatcher} resolution\n * strategy described above is used for the wildcard sub pattern.\n *\n * <h3>Other Notes</h3>\n *\n * <p>As of Spring Framework 6.0, if {@link #getResources(String)} is invoked with\n * a location pattern using the \"{@code classpath*:}\" prefix it will first search\n * all modules in the {@linkplain ModuleLayer#boot() boot layer}, excluding\n * {@linkplain ModuleFinder#ofSystem() system modules}. It will then search the\n * class path using {@link ClassLoader} APIs as described previously and return the\n * combined results. Consequently, some of the limitations of class path searches\n * may not apply when applications are deployed as modules.\n *\n * <p><b>WARNING:</b> Note that \"{@code classpath*:}\" when combined with\n * Ant-style patterns will only work reliably with at least one root directory\n * before the pattern starts, unless the actual target files reside in the file\n * system. This means that a pattern like \"{@code classpath*:*.xml}\" will\n * <i>not</i> retrieve files from the root of jar files but rather only from the\n * root of expanded directories. This originates from a limitation in the JDK's\n * {@code ClassLoader.getResources()} method which only returns file system\n * locations for a passed-in empty String (indicating potential roots to search).\n * This {@code ResourcePatternResolver} implementation tries to mitigate the\n * jar root lookup limitation through {@link URLClassLoader} introspection and\n * \"{@code java.class.path}\" manifest evaluation; however, without portability\n * guarantees.\n *\n * <p><b>WARNING:</b> Ant-style patterns with \"{@code classpath:}\" resources are not\n * guaranteed to find matching resources if the base package to search is available\n * in multiple class path locations. This is because a resource such as\n * <pre class=\"code\">\n *   com/example/package1/service-context.xml</pre>\n * may exist in only one class path location, but when a location pattern such as\n * <pre class=\"code\">\n *   classpath:com/example/**&#47;service-context.xml</pre>\n * is used to try to resolve it, the resolver will work off the (first) URL\n * returned by {@code getResource(\"com/example\")}. If the {@code com/example} base\n * package node exists in multiple class path locations, the actual desired resource\n * may not be present under the {@code com/example} base package in the first URL.\n * Therefore, preferably, use \"{@code classpath*:}\" with the same Ant-style pattern\n * in such a case, which will search <i>all</i> class path locations that contain\n * the base package.\n *\n * @author Juergen Hoeller\n * @author Colin Sampaleanu\n * @author Marius Bogoevici\n * @author Costin Leau\n * @author Phillip Webb\n * @author Sam Brannen\n * @author Sebastien Deleuze\n * @author Dave Syer\n * @since 1.0.2\n * @see #CLASSPATH_ALL_URL_PREFIX\n * @see org.springframework.util.AntPathMatcher\n * @see org.springframework.core.io.ResourceLoader#getResource(String)\n * @see ClassLoader#getResources(String)\n */\npublic class PathMatchingResourcePatternResolver implements ResourcePatternResolver {\n\n\tprivate static final Log logger = LogFactory.getLog(PathMatchingResourcePatternResolver.class);\n\n\t/**\n\t * {@link Set} of {@linkplain ModuleFinder#ofSystem() system module} names.\n\t * @since 6.0\n\t * @see #isNotSystemModule\n\t */\n\tprivate static final Set<String> systemModuleNames = NativeDetector.inNativeImage() ? Collections.emptySet() :\n\t\t\tModuleFinder.ofSystem().findAll().stream()\n\t\t\t\t\t.map(moduleReference -> moduleReference.descriptor().name())\n\t\t\t\t\t.collect(Collectors.toSet());\n\n\t/**\n\t * {@link Predicate} that tests whether the supplied {@link ResolvedModule}\n\t * is not a {@linkplain ModuleFinder#ofSystem() system module}.\n\t * @since 6.0\n\t * @see #systemModuleNames\n\t */\n\tprivate static final Predicate<ResolvedModule> isNotSystemModule =\n\t\t\tresolvedModule -> !systemModuleNames.contains(resolvedModule.name());\n\n\tprivate static @Nullable Method equinoxResolveMethod;\n\n\tstatic {\n\t\ttry {\n\t\t\t// Detect Equinox OSGi (for example, on WebSphere 6.1)\n\t\t\tClass<?> fileLocatorClass = ClassUtils.forName(\"org.eclipse.core.runtime.FileLocator\",\n\t\t\t\t\tPathMatchingResourcePatternResolver.class.getClassLoader());\n\t\t\tequinoxResolveMethod = fileLocatorClass.getMethod(\"resolve\", URL.class);\n\t\t\tlogger.trace(\"Found Equinox FileLocator for OSGi bundle URL resolution\");\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tequinoxResolveMethod = null;\n\t\t}\n\t}\n\n\n\tprivate final ResourceLoader resourceLoader;\n\n\tprivate PathMatcher pathMatcher = new AntPathMatcher();\n\n\tprivate final Map<String, Resource[]> rootDirCache = new ConcurrentHashMap<>();\n\n\tprivate final Map<String, NavigableSet<String>> jarEntriesCache = new ConcurrentHashMap<>();\n\n\tprivate volatile @Nullable Set<ClassPathManifestEntry> manifestEntriesCache;\n\n\n\t/**\n\t * Create a {@code PathMatchingResourcePatternResolver} with a\n\t * {@link DefaultResourceLoader}.\n\t * <p>ClassLoader access will happen via the thread context class loader.\n\t * @see DefaultResourceLoader\n\t */\n\tpublic PathMatchingResourcePatternResolver() {\n\t\tthis.resourceLoader = new DefaultResourceLoader();\n\t}\n\n\t/**\n\t * Create a {@code PathMatchingResourcePatternResolver} with the supplied\n\t * {@link ResourceLoader}.\n\t * <p>ClassLoader access will happen via the thread context class loader.\n\t * @param resourceLoader the {@code ResourceLoader} to load root directories\n\t * and actual resources with\n\t */\n\tpublic PathMatchingResourcePatternResolver(ResourceLoader resourceLoader) {\n\t\tAssert.notNull(resourceLoader, \"ResourceLoader must not be null\");\n\t\tthis.resourceLoader = resourceLoader;\n\t}\n\n\t/**\n\t * Create a {@code PathMatchingResourcePatternResolver} with a\n\t * {@link DefaultResourceLoader} and the supplied {@link ClassLoader}.\n\t * @param classLoader the ClassLoader to load class path resources with,\n\t * or {@code null} for using the thread context class loader\n\t * at the time of actual resource access\n\t * @see org.springframework.core.io.DefaultResourceLoader\n\t */\n\tpublic PathMatchingResourcePatternResolver(@Nullable ClassLoader classLoader) {\n\t\tthis.resourceLoader = new DefaultResourceLoader(classLoader);\n\t}\n\n\n\t/**\n\t * Return the {@link ResourceLoader} that this pattern resolver works with.\n\t */\n\tpublic ResourceLoader getResourceLoader() {\n\t\treturn this.resourceLoader;\n\t}\n\n\t@Override\n\tpublic @Nullable ClassLoader getClassLoader() {\n\t\treturn getResourceLoader().getClassLoader();\n\t}\n\n\t/**\n\t * Set the {@link PathMatcher} implementation to use for this\n\t * resource pattern resolver.\n\t * <p>Default is {@link AntPathMatcher}.\n\t * @see AntPathMatcher\n\t */\n\tpublic void setPathMatcher(PathMatcher pathMatcher) {\n\t\tAssert.notNull(pathMatcher, \"PathMatcher must not be null\");\n\t\tthis.pathMatcher = pathMatcher;\n\t}\n\n\t/**\n\t * Return the {@link PathMatcher} that this resource pattern resolver uses.\n\t */\n\tpublic PathMatcher getPathMatcher() {\n\t\treturn this.pathMatcher;\n\t}\n\n\n\t@Override\n\tpublic Resource getResource(String location) {\n\t\treturn getResourceLoader().getResource(location);\n\t}\n\n\t@Override\n\tpublic Resource[] getResources(String locationPattern) throws IOException {\n\t\tAssert.notNull(locationPattern, \"Location pattern must not be null\");\n\t\tif (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) {\n\t\t\t// a class path resource (multiple resources for same name possible)\n\t\t\tString locationPatternWithoutPrefix = locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length());\n\t\t\t// Search the module path first.\n\t\t\tSet<Resource> resources = findAllModulePathResources(locationPatternWithoutPrefix);\n\t\t\t// Search the class path next.\n\t\t\tif (getPathMatcher().isPattern(locationPatternWithoutPrefix)) {\n\t\t\t\t// a class path resource pattern\n\t\t\t\tCollections.addAll(resources, findPathMatchingResources(locationPattern));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// all class path resources with the given name\n\t\t\t\tCollections.addAll(resources, findAllClassPathResources(locationPatternWithoutPrefix));\n\t\t\t}\n\t\t\treturn resources.toArray(new Resource[0]);\n\t\t}\n\t\telse {\n\t\t\t// Generally only look for a pattern after a prefix here,\n\t\t\t// and on Tomcat only after the \"*/\" separator for its \"war:\" protocol.\n\t\t\tint prefixEnd = (locationPattern.startsWith(\"war:\") ? locationPattern.indexOf(\"*/\") + 1 :\n\t\t\t\t\tlocationPattern.indexOf(':') + 1);\n\t\t\tif (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) {\n\t\t\t\t// a file pattern\n\t\t\t\treturn findPathMatchingResources(locationPattern);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// a single resource with the given name\n\t\t\t\treturn new Resource[] {getResourceLoader().getResource(locationPattern)};\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Clear the local resource cache, removing all cached classpath/jar structures.\n\t * @since 6.2\n\t */\n\tpublic void clearCache() {\n\t\tthis.rootDirCache.clear();\n\t\tthis.jarEntriesCache.clear();\n\t\tthis.manifestEntriesCache = null;\n\t}\n\n\n\t/**\n\t * Find all class location resources with the given location via the ClassLoader.\n\t * <p>Delegates to {@link #doFindAllClassPathResources(String)}.\n\t * @param location the absolute path within the class path\n\t * @return the result as Resource array\n\t * @throws IOException in case of I/O errors\n\t * @see java.lang.ClassLoader#getResources\n\t * @see #convertClassLoaderURL\n\t */\n\tprotected Resource[] findAllClassPathResources(String location) throws IOException {\n\t\tString path = stripLeadingSlash(location);\n\t\tSet<Resource> result = doFindAllClassPathResources(path);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Resolved class path location [\" + path + \"] to resources \" + result);\n\t\t}\n\t\treturn result.toArray(new Resource[0]);\n\t}\n\n\t/**\n\t * Find all class path resources with the given path via the configured\n\t * {@link #getClassLoader() ClassLoader}.\n\t * <p>Called by {@link #findAllClassPathResources(String)}.\n\t * @param path the absolute path within the class path (never a leading slash)\n\t * @return a mutable Set of matching Resource instances\n\t * @since 4.1.1\n\t */\n\tprotected Set<Resource> doFindAllClassPathResources(String path) throws IOException {\n\t\tSet<Resource> result = new LinkedHashSet<>(16);\n\t\tClassLoader cl = getClassLoader();\n\t\tEnumeration<URL> resourceUrls = (cl != null ? cl.getResources(path) : ClassLoader.getSystemResources(path));\n\t\twhile (resourceUrls.hasMoreElements()) {\n\t\t\tURL url = resourceUrls.nextElement();\n\t\t\tresult.add(convertClassLoaderURL(url));\n\t\t}\n\t\tif (!StringUtils.hasLength(path)) {\n\t\t\t// The above result is likely to be incomplete, i.e. only containing file system references.\n\t\t\t// We need to have pointers to each of the jar files on the class path as well...\n\t\t\taddAllClassLoaderJarRoots(cl, result);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Convert the given URL as returned from the configured\n\t * {@link #getClassLoader() ClassLoader} into a {@link Resource}, applying\n\t * to path lookups without a pattern (see {@link #findAllClassPathResources}).\n\t * <p>As of 6.0.5, the default implementation creates a {@link FileSystemResource}\n\t * in case of the \"file\" protocol or a {@link UrlResource} otherwise, matching\n\t * the outcome of pattern-based class path traversal in the same resource layout,\n\t * as well as matching the outcome of module path searches.\n\t * @param url a URL as returned from the configured ClassLoader\n\t * @return the corresponding Resource object\n\t * @see java.lang.ClassLoader#getResources\n\t * @see #doFindAllClassPathResources\n\t * @see #doFindPathMatchingFileResources\n\t */\n\t@SuppressWarnings(\"deprecation\")  // on JDK 20 (deprecated URL constructor)\n\tprotected Resource convertClassLoaderURL(URL url) {\n\t\tif (ResourceUtils.URL_PROTOCOL_FILE.equals(url.getProtocol())) {\n\t\t\ttry {\n\t\t\t\t// URI decoding for special characters such as spaces.\n\t\t\t\treturn new FileSystemResource(ResourceUtils.toURI(url).getSchemeSpecificPart());\n\t\t\t}\n\t\t\tcatch (URISyntaxException ex) {\n\t\t\t\t// Fallback for URLs that are not valid URIs (should hardly ever happen).\n\t\t\t\treturn new FileSystemResource(url.getFile());\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tString urlString = url.toString();\n\t\t\tString cleanedPath = StringUtils.cleanPath(urlString);\n\t\t\tif (!cleanedPath.equals(urlString)) {\n\t\t\t\t// Prefer cleaned URL, aligned with UrlResource#createRelative(String)\n\t\t\t\ttry {\n\t\t\t\t\t// Retain original URL instance, potentially including custom URLStreamHandler.\n\t\t\t\t\treturn new UrlResource(new URL(url, cleanedPath));\n\t\t\t\t}\n\t\t\t\tcatch (MalformedURLException ex) {\n\t\t\t\t\t// Fallback to regular URL construction below...\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Retain original URL instance, potentially including custom URLStreamHandler.\n\t\t\treturn new UrlResource(url);\n\t\t}\n\t}\n\n\t/**\n\t * Search all {@link URLClassLoader} URLs for jar file references and add each to the\n\t * given set of resources in the form of a pointer to the root of the jar file content.\n\t * @param classLoader the ClassLoader to search (including its ancestors)\n\t * @param result the set of resources to add jar roots to\n\t * @since 4.1.1\n\t */\n\tprotected void addAllClassLoaderJarRoots(@Nullable ClassLoader classLoader, Set<Resource> result) {\n\t\tif (classLoader instanceof URLClassLoader urlClassLoader) {\n\t\t\ttry {\n\t\t\t\tfor (URL url : urlClassLoader.getURLs()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tUrlResource jarResource = (ResourceUtils.URL_PROTOCOL_JAR.equals(url.getProtocol()) ?\n\t\t\t\t\t\t\t\tnew UrlResource(url) :\n\t\t\t\t\t\t\t\tnew UrlResource(ResourceUtils.JAR_URL_PREFIX + url + ResourceUtils.JAR_URL_SEPARATOR));\n\t\t\t\t\t\tif (jarResource.exists()) {\n\t\t\t\t\t\t\tresult.add(jarResource);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (MalformedURLException ex) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Cannot search for matching files underneath [\" + url +\n\t\t\t\t\t\t\t\t\t\"] because it cannot be converted to a valid 'jar:' URL: \" + ex.getMessage());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Cannot introspect jar files since ClassLoader [\" + classLoader +\n\t\t\t\t\t\t\t\"] does not support 'getURLs()': \" + ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (classLoader == ClassLoader.getSystemClassLoader()) {\n\t\t\t// JAR \"Class-Path\" manifest header evaluation...\n\t\t\taddClassPathManifestEntries(result);\n\t\t}\n\n\t\tif (classLoader != null) {\n\t\t\ttry {\n\t\t\t\t// Hierarchy traversal...\n\t\t\t\taddAllClassLoaderJarRoots(classLoader.getParent(), result);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Cannot introspect jar files in parent ClassLoader since [\" + classLoader +\n\t\t\t\t\t\t\t\"] does not support 'getParent()': \" + ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Determine jar file references from {@code Class-Path} manifest entries (which\n\t * are added to the {@code java.class.path} JVM system property by the system\n\t * class loader) and add each to the given set of resources in the form of\n\t * a pointer to the root of the jar file content.\n\t * @param result the set of resources to add jar roots to\n\t * @since 4.3\n\t */\n\tprotected void addClassPathManifestEntries(Set<Resource> result) {\n\t\tSet<ClassPathManifestEntry> entries = this.manifestEntriesCache;\n\t\tif (entries == null) {\n\t\t\tentries = getClassPathManifestEntries();\n\t\t\tthis.manifestEntriesCache = entries;\n\t\t}\n\t\tfor (ClassPathManifestEntry entry : entries) {\n\t\t\tif (!result.contains(entry.resource()) &&\n\t\t\t\t\t(entry.alternative() != null && !result.contains(entry.alternative()))) {\n\t\t\t\tresult.add(entry.resource());\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate Set<ClassPathManifestEntry> getClassPathManifestEntries() {\n\t\tSet<ClassPathManifestEntry> manifestEntries = new LinkedHashSet<>();\n\t\tSet<File> seen = new HashSet<>();\n\t\ttry {\n\t\t\tString paths = System.getProperty(\"java.class.path\");\n\t\t\tfor (String path : StringUtils.delimitedListToStringArray(paths, File.pathSeparator)) {\n\t\t\t\ttry {\n\t\t\t\t\tFile jar = new File(path).getAbsoluteFile();\n\t\t\t\t\tif (jar.isFile() && seen.add(jar)) {\n\t\t\t\t\t\tmanifestEntries.add(ClassPathManifestEntry.of(jar));\n\t\t\t\t\t\tmanifestEntries.addAll(getClassPathManifestEntriesFromJar(jar));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (MalformedURLException ex) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Cannot search for matching files underneath [\" + path +\n\t\t\t\t\t\t\t\t\"] because it cannot be converted to a valid 'jar:' URL: \" + ex.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Collections.unmodifiableSet(manifestEntries);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Failed to evaluate 'java.class.path' manifest entries: \" + ex);\n\t\t\t}\n\t\t\treturn Collections.emptySet();\n\t\t}\n\t}\n\n\tprivate Set<ClassPathManifestEntry> getClassPathManifestEntriesFromJar(File jar) throws IOException {\n\t\tURL base = jar.toURI().toURL();\n\t\tFile parent = jar.getAbsoluteFile().getParentFile();\n\t\ttry (JarFile jarFile = new JarFile(jar)) {\n\t\t\tManifest manifest = jarFile.getManifest();\n\t\t\tAttributes attributes = (manifest != null ? manifest.getMainAttributes() : null);\n\t\t\tString classPath = (attributes != null ? attributes.getValue(Name.CLASS_PATH) : null);\n\t\t\tSet<ClassPathManifestEntry> manifestEntries = new LinkedHashSet<>();\n\t\t\tif (StringUtils.hasLength(classPath)) {\n\t\t\t\tStringTokenizer tokenizer = new StringTokenizer(classPath);\n\t\t\t\twhile (tokenizer.hasMoreTokens()) {\n\t\t\t\t\tString path = tokenizer.nextToken();\n\t\t\t\t\tif (path.indexOf(':') >= 0 && !\"file\".equalsIgnoreCase(new URL(base, path).getProtocol())) {\n\t\t\t\t\t\t// See jdk.internal.loader.URLClassPath.JarLoader.tryResolveFile(URL, String)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tFile candidate = new File(parent, path);\n\t\t\t\t\tif (candidate.isFile() && candidate.getCanonicalPath().contains(parent.getCanonicalPath())) {\n\t\t\t\t\t\tmanifestEntries.add(ClassPathManifestEntry.of(candidate));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Collections.unmodifiableSet(manifestEntries);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Failed to load manifest entries from jar file '\" + jar + \"': \" + ex);\n\t\t\t}\n\t\t\treturn Collections.emptySet();\n\t\t}\n\t}\n\n\t/**\n\t * Find all resources that match the given location pattern via the Ant-style\n\t * {@link #getPathMatcher() PathMatcher}.\n\t * <p>Supports resources in OSGi bundles, JBoss VFS, jar files, zip files,\n\t * and file systems.\n\t * @param locationPattern the location pattern to match\n\t * @return the result as Resource array\n\t * @throws IOException in case of I/O errors\n\t * @see #determineRootDir(String)\n\t * @see #resolveRootDirResource(Resource)\n\t * @see #isJarResource(Resource)\n\t * @see #doFindPathMatchingJarResources(Resource, URL, String)\n\t * @see #doFindPathMatchingFileResources(Resource, String)\n\t * @see org.springframework.util.PathMatcher\n\t */\n\tprotected Resource[] findPathMatchingResources(String locationPattern) throws IOException {\n\t\tString rootDirPath = determineRootDir(locationPattern);\n\t\tString subPattern = locationPattern.substring(rootDirPath.length());\n\n\t\t// Look for pre-cached root dir resources, either a direct match or\n\t\t// a match for a parent directory in the same classpath locations.\n\t\tResource[] rootDirResources = this.rootDirCache.get(rootDirPath);\n\t\tString actualRootPath = null;\n\t\tif (rootDirResources == null) {\n\t\t\t// No direct match -> search for a common parent directory match\n\t\t\t// (cached based on repeated searches in the same base location,\n\t\t\t// in particular for different root directories in the same jar).\n\t\t\tString commonPrefix = null;\n\t\t\tString existingPath = null;\n\t\t\tboolean commonUnique = true;\n\t\t\tfor (String path : this.rootDirCache.keySet()) {\n\t\t\t\tString currentPrefix = null;\n\t\t\t\tfor (int i = 0; i < path.length(); i++) {\n\t\t\t\t\tif (i == rootDirPath.length() || path.charAt(i) != rootDirPath.charAt(i)) {\n\t\t\t\t\t\tcurrentPrefix = path.substring(0, path.lastIndexOf('/', i - 1) + 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentPrefix != null) {\n\t\t\t\t\tif (checkPathWithinPackage(path.substring(currentPrefix.length()))) {\n\t\t\t\t\t\t// A prefix match found, potentially to be turned into a common parent cache entry.\n\t\t\t\t\t\tif (commonPrefix == null || !commonUnique || currentPrefix.length() > commonPrefix.length()) {\n\t\t\t\t\t\t\tcommonPrefix = currentPrefix;\n\t\t\t\t\t\t\texistingPath = path;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (currentPrefix.equals(commonPrefix)) {\n\t\t\t\t\t\t\tcommonUnique = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (actualRootPath == null || path.length() > actualRootPath.length()) {\n\t\t\t\t\t// A direct match found for a parent directory -> use it.\n\t\t\t\t\trootDirResources = this.rootDirCache.get(path);\n\t\t\t\t\tactualRootPath = path;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rootDirResources == null && StringUtils.hasLength(commonPrefix)) {\n\t\t\t\t// Try common parent directory as long as it points to the same classpath locations.\n\t\t\t\trootDirResources = getResources(commonPrefix);\n\t\t\t\tResource[] existingResources = this.rootDirCache.get(existingPath);\n\t\t\t\tif (existingResources != null && rootDirResources.length == existingResources.length) {\n\t\t\t\t\t// Replace existing subdirectory cache entry with common parent directory,\n\t\t\t\t\t// avoiding repeated determination of root directories in the same jar.\n\t\t\t\t\tthis.rootDirCache.remove(existingPath);\n\t\t\t\t\tthis.rootDirCache.put(commonPrefix, rootDirResources);\n\t\t\t\t\tactualRootPath = commonPrefix;\n\t\t\t\t}\n\t\t\t\telse if (commonPrefix.equals(rootDirPath)) {\n\t\t\t\t\t// The identified common directory is equal to the currently requested path ->\n\t\t\t\t\t// worth caching specifically, even if it cannot replace the existing sub-entry.\n\t\t\t\t\tthis.rootDirCache.put(rootDirPath, rootDirResources);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Mismatch: parent directory points to more classpath locations.\n\t\t\t\t\trootDirResources = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rootDirResources == null) {\n\t\t\t\t// Lookup for specific directory, creating a cache entry for it.\n\t\t\t\trootDirResources = getResources(rootDirPath);\n\t\t\t\tthis.rootDirCache.put(rootDirPath, rootDirResources);\n\t\t\t}\n\t\t}\n\n\t\tSet<Resource> result = new LinkedHashSet<>(64);\n\t\tfor (Resource rootDirResource : rootDirResources) {\n\t\t\tif (actualRootPath != null && actualRootPath.length() < rootDirPath.length()) {\n\t\t\t\t// Create sub-resource for requested sub-location from cached common root directory.\n\t\t\t\trootDirResource = rootDirResource.createRelative(rootDirPath.substring(actualRootPath.length()));\n\t\t\t}\n\t\t\trootDirResource = resolveRootDirResource(rootDirResource);\n\t\t\tURL rootDirUrl = rootDirResource.getURL();\n\t\t\tif (equinoxResolveMethod != null && rootDirUrl.getProtocol().startsWith(\"bundle\")) {\n\t\t\t\tURL resolvedUrl = (URL) ReflectionUtils.invokeMethod(equinoxResolveMethod, null, rootDirUrl);\n\t\t\t\tif (resolvedUrl != null) {\n\t\t\t\t\trootDirUrl = resolvedUrl;\n\t\t\t\t}\n\t\t\t\trootDirResource = new UrlResource(rootDirUrl);\n\t\t\t}\n\t\t\tif (rootDirUrl.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {\n\t\t\t\tresult.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirUrl, subPattern, getPathMatcher()));\n\t\t\t}\n\t\t\telse if (ResourceUtils.isJarURL(rootDirUrl) || isJarResource(rootDirResource)) {\n\t\t\t\tresult.addAll(doFindPathMatchingJarResources(rootDirResource, rootDirUrl, subPattern));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern));\n\t\t\t}\n\t\t}\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Resolved location pattern [\" + locationPattern + \"] to resources \" + result);\n\t\t}\n\t\treturn result.toArray(new Resource[0]);\n\t}\n\n\t/**\n\t * Determine the root directory for the given location.\n\t * <p>Used for determining the starting point for file matching, resolving the\n\t * root directory location to be passed into {@link #getResources(String)},\n\t * with the remainder of the location to be used as the sub pattern.\n\t * <p>Will return \"/WEB-INF/\" for the location \"/WEB-INF/*.xml\", for example.\n\t * @param location the location to check\n\t * @return the part of the location that denotes the root directory\n\t * @see #findPathMatchingResources(String)\n\t */\n\tprotected String determineRootDir(String location) {\n\t\tint prefixEnd = location.indexOf(':') + 1;\n\t\tint rootDirEnd = location.length();\n\t\twhile (rootDirEnd > prefixEnd && getPathMatcher().isPattern(location.substring(prefixEnd, rootDirEnd))) {\n\t\t\trootDirEnd = location.lastIndexOf('/', rootDirEnd - 2) + 1;\n\t\t}\n\t\tif (rootDirEnd == 0) {\n\t\t\trootDirEnd = prefixEnd;\n\t\t}\n\t\treturn location.substring(0, rootDirEnd);\n\t}\n\n\t/**\n\t * Resolve the supplied root directory resource for path matching.\n\t * <p>By default, {@link #findPathMatchingResources(String)} resolves Equinox\n\t * OSGi \"bundleresource:\" and \"bundleentry:\" URLs into standard jar file URLs\n\t * that will be traversed using Spring's standard jar file traversal algorithm.\n\t * <p>For any custom resolution, override this template method and replace the\n\t * supplied resource handle accordingly.\n\t * <p>The default implementation of this method returns the supplied resource\n\t * unmodified.\n\t * @param original the resource to resolve\n\t * @return the resolved resource (may be identical to the supplied resource)\n\t * @throws IOException in case of resolution failure\n\t * @see #findPathMatchingResources(String)\n\t */\n\tprotected Resource resolveRootDirResource(Resource original) throws IOException {\n\t\treturn original;\n\t}\n\n\t/**\n\t * Determine if the given resource handle indicates a jar resource that the\n\t * {@link #doFindPathMatchingJarResources} method can handle.\n\t * <p>{@link #findPathMatchingResources(String)} delegates to\n\t * {@link ResourceUtils#isJarURL(URL)} to determine whether the given URL\n\t * points to a resource in a jar file, and only invokes this method as a fallback.\n\t * <p>This template method therefore allows for detecting further kinds of\n\t * jar-like resources &mdash; for example, via {@code instanceof} checks on\n\t * the resource handle type.\n\t * <p>The default implementation of this method returns {@code false}.\n\t * @param resource the resource handle to check (usually the root directory\n\t * to start path matching from)\n\t * @return {@code true} if the given resource handle indicates a jar resource\n\t * @throws IOException in case of I/O errors\n\t * @see #findPathMatchingResources(String)\n\t * @see #doFindPathMatchingJarResources(Resource, URL, String)\n\t * @see org.springframework.util.ResourceUtils#isJarURL\n\t */\n\tprotected boolean isJarResource(Resource resource) throws IOException {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Find all resources in jar files that match the given location pattern\n\t * via the Ant-style {@link #getPathMatcher() PathMatcher}.\n\t * @param rootDirResource the root directory as Resource\n\t * @param rootDirUrl the pre-resolved root directory URL\n\t * @param subPattern the sub pattern to match (below the root directory)\n\t * @return a mutable Set of matching Resource instances\n\t * @throws IOException in case of I/O errors\n\t * @since 4.3\n\t * @see java.net.JarURLConnection\n\t * @see org.springframework.util.PathMatcher\n\t */\n\tprotected Set<Resource> doFindPathMatchingJarResources(Resource rootDirResource, URL rootDirUrl, String subPattern)\n\t\t\tthrows IOException {\n\n\t\tString jarFileUrl = null;\n\t\tString rootEntryPath = \"\";\n\n\t\tString urlFile = rootDirUrl.getFile();\n\t\tint separatorIndex = urlFile.indexOf(ResourceUtils.WAR_URL_SEPARATOR);\n\t\tif (separatorIndex == -1) {\n\t\t\tseparatorIndex = urlFile.indexOf(ResourceUtils.JAR_URL_SEPARATOR);\n\t\t}\n\t\tif (separatorIndex >= 0) {\n\t\t\tjarFileUrl = urlFile.substring(0, separatorIndex);\n\t\t\trootEntryPath = urlFile.substring(separatorIndex + 2);  // both separators are 2 chars\n\t\t\tNavigableSet<String> entriesCache = this.jarEntriesCache.get(jarFileUrl);\n\t\t\tif (entriesCache != null) {\n\t\t\t\tSet<Resource> result = new LinkedHashSet<>(64);\n\t\t\t\t// Search sorted entries from first entry with rootEntryPath prefix\n\t\t\t\tfor (String entryPath : entriesCache.tailSet(rootEntryPath, false)) {\n\t\t\t\t\tif (!entryPath.startsWith(rootEntryPath)) {\n\t\t\t\t\t\t// We are beyond the potential matches in the current TreeSet.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tString relativePath = entryPath.substring(rootEntryPath.length());\n\t\t\t\t\tif (getPathMatcher().match(subPattern, relativePath)) {\n\t\t\t\t\t\tresult.add(rootDirResource.createRelative(relativePath));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tURLConnection con = rootDirUrl.openConnection();\n\t\tJarFile jarFile;\n\t\tboolean closeJarFile;\n\n\t\tif (con instanceof JarURLConnection jarCon) {\n\t\t\t// Should usually be the case for traditional JAR files.\n\t\t\ttry {\n\t\t\t\tjarFile = jarCon.getJarFile();\n\t\t\t\tjarFileUrl = jarCon.getJarFileURL().toExternalForm();\n\t\t\t\tJarEntry jarEntry = jarCon.getJarEntry();\n\t\t\t\trootEntryPath = (jarEntry != null ? jarEntry.getName() : \"\");\n\t\t\t\tcloseJarFile = !jarCon.getUseCaches();\n\t\t\t}\n\t\t\tcatch (FileNotFoundException ex) {\n\t\t\t\t// Happens in case of cached root directory without specific subdirectory present.\n\t\t\t\treturn Collections.emptySet();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// No JarURLConnection -> need to resort to URL file parsing.\n\t\t\t// We'll assume URLs of the format \"jar:path!/entry\", with the protocol\n\t\t\t// being arbitrary as long as following the entry format.\n\t\t\t// We'll also handle paths with and without leading \"file:\" prefix.\n\t\t\ttry {\n\t\t\t\tif (jarFileUrl != null) {\n\t\t\t\t\tjarFile = getJarFile(jarFileUrl);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tjarFile = new JarFile(urlFile);\n\t\t\t\t\tjarFileUrl = urlFile;\n\t\t\t\t\trootEntryPath = \"\";\n\t\t\t\t}\n\t\t\t\tcloseJarFile = true;\n\t\t\t}\n\t\t\tcatch (ZipException ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Skipping invalid jar class path entry [\" + urlFile + \"]\");\n\t\t\t\t}\n\t\t\t\treturn Collections.emptySet();\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Looking for matching resources in jar file [\" + jarFileUrl + \"]\");\n\t\t\t}\n\t\t\tif (StringUtils.hasLength(rootEntryPath) && !rootEntryPath.endsWith(\"/\")) {\n\t\t\t\t// Root entry path must end with slash to allow for proper matching.\n\t\t\t\t// The Sun JRE does not return a slash here, but BEA JRockit does.\n\t\t\t\trootEntryPath = rootEntryPath + \"/\";\n\t\t\t}\n\t\t\tSet<Resource> result = new LinkedHashSet<>(64);\n\t\t\tNavigableSet<String> entriesCache = new TreeSet<>();\n\t\t\tIterator<String> entryIterator = jarFile.stream().map(JarEntry::getName).sorted().iterator();\n\t\t\twhile (entryIterator.hasNext()) {\n\t\t\t\tString entryPath = entryIterator.next();\n\t\t\t\tint entrySeparatorIndex = entryPath.indexOf(ResourceUtils.JAR_URL_SEPARATOR);\n\t\t\t\tif (entrySeparatorIndex >= 0) {\n\t\t\t\t\tentryPath = entryPath.substring(entrySeparatorIndex + ResourceUtils.JAR_URL_SEPARATOR.length());\n\t\t\t\t}\n\t\t\t\tentriesCache.add(entryPath);\n\t\t\t\tif (entryPath.startsWith(rootEntryPath)) {\n\t\t\t\t\tString relativePath = entryPath.substring(rootEntryPath.length());\n\t\t\t\t\tif (getPathMatcher().match(subPattern, relativePath)) {\n\t\t\t\t\t\tresult.add(rootDirResource.createRelative(relativePath));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Cache jar entries in TreeSet for efficient searching on re-encounter.\n\t\t\tthis.jarEntriesCache.put(jarFileUrl, entriesCache);\n\t\t\treturn result;\n\t\t}\n\t\tfinally {\n\t\t\tif (closeJarFile) {\n\t\t\t\tjarFile.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Resolve the given jar file URL into a JarFile object.\n\t */\n\tprotected JarFile getJarFile(String jarFileUrl) throws IOException {\n\t\tif (jarFileUrl.startsWith(ResourceUtils.FILE_URL_PREFIX)) {\n\t\t\ttry {\n\t\t\t\treturn new JarFile(ResourceUtils.toURI(jarFileUrl).getSchemeSpecificPart());\n\t\t\t}\n\t\t\tcatch (URISyntaxException ex) {\n\t\t\t\t// Fallback for URLs that are not valid URIs (should hardly ever happen).\n\t\t\t\treturn new JarFile(jarFileUrl.substring(ResourceUtils.FILE_URL_PREFIX.length()));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn new JarFile(jarFileUrl);\n\t\t}\n\t}\n\n\t/**\n\t * Find all resources in the file system of the supplied root directory that\n\t * match the given location sub pattern via the Ant-style {@link #getPathMatcher()\n\t * PathMatcher}.\n\t * @param rootDirResource the root directory as a Resource\n\t * @param subPattern the sub pattern to match (below the root directory)\n\t * @return a mutable Set of matching Resource instances\n\t * @throws IOException in case of I/O errors\n\t * @see org.springframework.util.PathMatcher\n\t */\n\tprotected Set<Resource> doFindPathMatchingFileResources(Resource rootDirResource, String subPattern)\n\t\t\tthrows IOException {\n\n\t\tSet<Resource> result = new LinkedHashSet<>(64);\n\t\tURI rootDirUri;\n\t\ttry {\n\t\t\trootDirUri = rootDirResource.getURI();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Failed to resolve directory [%s] as URI: %s\".formatted(rootDirResource, ex));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tPath rootPath = null;\n\t\tif (rootDirUri.isAbsolute() && !rootDirUri.isOpaque()) {\n\t\t\t// Prefer Path resolution from URI if possible\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\trootPath = Path.of(rootDirUri);\n\t\t\t\t}\n\t\t\t\tcatch (FileSystemNotFoundException ex) {\n\t\t\t\t\t// If the file system was not found, assume it's a custom file system that needs to be installed.\n\t\t\t\t\tFileSystems.newFileSystem(rootDirUri, Map.of(), ClassUtils.getDefaultClassLoader());\n\t\t\t\t\trootPath = Path.of(rootDirUri);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Failed to resolve %s in file system: %s\".formatted(rootDirUri, ex));\n\t\t\t\t}\n\t\t\t\t// Fallback via Resource.getFile() below\n\t\t\t}\n\t\t}\n\n\t\tif (rootPath == null) {\n\t\t\t// Resource.getFile() resolution as a fallback -\n\t\t\t// for custom URI formats and custom Resource implementations\n\t\t\ttry {\n\t\t\t\trootPath = Path.of(rootDirResource.getFile().getAbsolutePath());\n\t\t\t}\n\t\t\tcatch (FileNotFoundException ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Cannot search for matching files underneath \" + rootDirResource +\n\t\t\t\t\t\t\t\" in the file system: \" + ex.getMessage());\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\tlogger.info(\"Failed to resolve \" + rootDirResource + \" in the file system: \" + ex);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tif (!Files.exists(rootPath)) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Skipping search for files matching pattern [%s]: directory [%s] does not exist\"\n\t\t\t\t\t\t.formatted(subPattern, rootPath.toAbsolutePath()));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tString rootDir = StringUtils.cleanPath(rootPath.toString());\n\t\tif (!rootDir.endsWith(\"/\")) {\n\t\t\trootDir += \"/\";\n\t\t}\n\n\t\tPath rootPathForPattern = rootPath;\n\t\tString resourcePattern = rootDir + StringUtils.cleanPath(subPattern);\n\t\tPredicate<Path> isMatchingFile = path -> (!path.equals(rootPathForPattern) &&\n\t\t\t\tgetPathMatcher().match(resourcePattern, StringUtils.cleanPath(path.toString())));\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Searching directory [%s] for files matching pattern [%s]\"\n\t\t\t\t\t.formatted(rootPath.toAbsolutePath(), subPattern));\n\t\t}\n\n\t\ttry (Stream<Path> files = Files.walk(rootPath, FileVisitOption.FOLLOW_LINKS)) {\n\t\t\tfiles.filter(isMatchingFile).sorted().map(FileSystemResource::new).forEach(result::add);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Failed to search in directory [%s] for files matching pattern [%s]: %s\"\n\t\t\t\t\t\t.formatted(rootPath.toAbsolutePath(), subPattern, ex));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Resolve the given location pattern into {@code Resource} objects for all\n\t * matching resources found in the module path.\n\t * <p>The location pattern may be an explicit resource path such as\n\t * {@code \"com/example/config.xml\"} or a pattern such as\n\t * <code>\"com/example/**&#47;config-*.xml\"</code> to be matched using the\n\t * configured {@link #getPathMatcher() PathMatcher}.\n\t * <p>The default implementation scans all modules in the {@linkplain ModuleLayer#boot()\n\t * boot layer}, excluding {@linkplain ModuleFinder#ofSystem() system modules}.\n\t * @param locationPattern the location pattern to resolve\n\t * @return a modifiable {@code Set} containing the corresponding {@code Resource}\n\t * objects\n\t * @throws IOException in case of I/O errors\n\t * @since 6.0\n\t * @see ModuleLayer#boot()\n\t * @see ModuleFinder#ofSystem()\n\t * @see ModuleReader\n\t * @see PathMatcher#match(String, String)\n\t */\n\tprotected Set<Resource> findAllModulePathResources(String locationPattern) throws IOException {\n\t\tSet<Resource> result = new LinkedHashSet<>(64);\n\n\t\t// Skip scanning the module path when running in a native image.\n\t\tif (NativeDetector.inNativeImage()) {\n\t\t\treturn result;\n\t\t}\n\n\t\tString resourcePattern = stripLeadingSlash(locationPattern);\n\t\tPredicate<String> resourcePatternMatches = (getPathMatcher().isPattern(resourcePattern) ?\n\t\t\t\tpath -> getPathMatcher().match(resourcePattern, path) :\n\t\t\t\tresourcePattern::equals);\n\n\t\ttry {\n\t\t\tModuleLayer.boot().configuration().modules().stream()\n\t\t\t\t\t.filter(isNotSystemModule)\n\t\t\t\t\t.forEach(resolvedModule -> {\n\t\t\t\t\t\t// NOTE: a ModuleReader and a Stream returned from ModuleReader.list() must be closed.\n\t\t\t\t\t\ttry (ModuleReader moduleReader = resolvedModule.reference().open();\n\t\t\t\t\t\t\t\tStream<String> names = moduleReader.list()) {\n\t\t\t\t\t\t\tnames.filter(resourcePatternMatches)\n\t\t\t\t\t\t\t\t\t.map(name -> findResource(moduleReader, name))\n\t\t\t\t\t\t\t\t\t.filter(Objects::nonNull)\n\t\t\t\t\t\t\t\t\t.forEach(result::add);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Failed to read contents of module [%s]\".formatted(resolvedModule), ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthrow new UncheckedIOException(ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t}\n\t\tcatch (UncheckedIOException ex) {\n\t\t\t// Unwrap IOException to conform to this method's contract.\n\t\t\tthrow ex.getCause();\n\t\t}\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Resolved module-path location pattern [%s] to resources %s\".formatted(resourcePattern, result));\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate @Nullable Resource findResource(ModuleReader moduleReader, String name) {\n\t\ttry {\n\t\t\treturn moduleReader.find(name)\n\t\t\t\t\t.map(this::convertModuleSystemURI)\n\t\t\t\t\t.orElse(null);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Failed to find resource [%s] in module path\".formatted(name), ex);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * If it's a \"file:\" URI, use {@link FileSystemResource} to avoid duplicates\n\t * for the same path discovered via class path scanning.\n\t */\n\tprivate Resource convertModuleSystemURI(URI uri) {\n\t\treturn (ResourceUtils.URL_PROTOCOL_FILE.equals(uri.getScheme()) ?\n\t\t\t\tnew FileSystemResource(uri.getPath()) : UrlResource.from(uri));\n\t}\n\n\tprivate static String stripLeadingSlash(String path) {\n\t\treturn (path.startsWith(\"/\") ? path.substring(1) : path);\n\t}\n\n\tprivate static boolean checkPathWithinPackage(String path) {\n\t\treturn (path.contains(\"/\") && !path.contains(ResourceUtils.JAR_URL_SEPARATOR));\n\t}\n\n\n\t/**\n\t * Inner delegate class, avoiding a hard JBoss VFS API dependency at runtime.\n\t */\n\tprivate static class VfsResourceMatchingDelegate {\n\n\t\tpublic static Set<Resource> findMatchingResources(\n\t\t\t\tURL rootDirUrl, String locationPattern, PathMatcher pathMatcher) throws IOException {\n\n\t\t\tObject root = VfsPatternUtils.findRoot(rootDirUrl);\n\t\t\tPatternVirtualFileVisitor visitor =\n\t\t\t\t\tnew PatternVirtualFileVisitor(VfsPatternUtils.getPath(root), locationPattern, pathMatcher);\n\t\t\tVfsPatternUtils.visit(root, visitor);\n\t\t\treturn visitor.getResources();\n\t\t}\n\t}\n\n\n\t/**\n\t * VFS visitor for path matching purposes.\n\t */\n\t@SuppressWarnings(\"unused\")\n\tprivate static class PatternVirtualFileVisitor implements InvocationHandler {\n\n\t\tprivate final String subPattern;\n\n\t\tprivate final PathMatcher pathMatcher;\n\n\t\tprivate final String rootPath;\n\n\t\tprivate final Set<Resource> resources = new LinkedHashSet<>(64);\n\n\t\tpublic PatternVirtualFileVisitor(String rootPath, String subPattern, PathMatcher pathMatcher) {\n\t\t\tthis.subPattern = subPattern;\n\t\t\tthis.pathMatcher = pathMatcher;\n\t\t\tthis.rootPath = (rootPath.isEmpty() || rootPath.endsWith(\"/\") ? rootPath : rootPath + \"/\");\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\tString methodName = method.getName();\n\t\t\tif (Object.class == method.getDeclaringClass()) {\n\t\t\t\tswitch (methodName) {\n\t\t\t\t\tcase \"equals\" -> {\n\t\t\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\t\t\treturn (proxy == args[0]);\n\t\t\t\t\t}\n\t\t\t\t\tcase \"hashCode\" -> {\n\t\t\t\t\t\treturn System.identityHashCode(proxy);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn switch (methodName) {\n\t\t\t\tcase \"getAttributes\" -> getAttributes();\n\t\t\t\tcase \"visit\" -> {\n\t\t\t\t\tvisit(args[0]);\n\t\t\t\t\tyield null;\n\t\t\t\t}\n\t\t\t\tcase \"toString\" -> toString();\n\t\t\t\tdefault -> throw new IllegalStateException(\"Unexpected method invocation: \" + method);\n\t\t\t};\n\t\t}\n\n\t\tpublic void visit(Object vfsResource) {\n\t\t\tif (this.pathMatcher.match(this.subPattern,\n\t\t\t\t\tVfsPatternUtils.getPath(vfsResource).substring(this.rootPath.length()))) {\n\t\t\t\tthis.resources.add(new VfsResource(vfsResource));\n\t\t\t}\n\t\t}\n\n\t\tpublic @Nullable Object getAttributes() {\n\t\t\treturn VfsPatternUtils.getVisitorAttributes();\n\t\t}\n\n\t\tpublic Set<Resource> getResources() {\n\t\t\treturn this.resources;\n\t\t}\n\n\t\tpublic int size() {\n\t\t\treturn this.resources.size();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"sub-pattern: \" + this.subPattern + \", resources: \" + this.resources;\n\t\t}\n\t}\n\n\n\t/**\n\t * A single {@code Class-Path} manifest entry.\n\t */\n\tprivate record ClassPathManifestEntry(Resource resource, @Nullable Resource alternative) {\n\n\t\tprivate static final String JARFILE_URL_PREFIX = ResourceUtils.JAR_URL_PREFIX + ResourceUtils.FILE_URL_PREFIX;\n\n\t\tstatic ClassPathManifestEntry of(File file) throws MalformedURLException {\n\t\t\tString path = fixPath(file.getAbsolutePath());\n\t\t\tResource resource = asJarFileResource(path);\n\t\t\tResource alternative = createAlternative(path);\n\t\t\treturn new ClassPathManifestEntry(resource, alternative);\n\t\t}\n\n\t\tprivate static String fixPath(String path) {\n\t\t\tint prefixIndex = path.indexOf(':');\n\t\t\tif (prefixIndex == 1) {\n\t\t\t\t// Possibly a drive prefix on Windows (for example, \"c:\"), so we prepend a slash\n\t\t\t\t// and convert the drive letter to uppercase for consistent duplicate detection.\n\t\t\t\tpath = \"/\" + StringUtils.capitalize(path);\n\t\t\t}\n\t\t\t// Since '#' can appear in directories/filenames, java.net.URL should not treat it as a fragment\n\t\t\treturn StringUtils.replace(path, \"#\", \"%23\");\n\t\t}\n\n\t\t/**\n\t\t * Return a alternative form of the resource, i.e. with or without a leading slash.\n\t\t * @param path the file path (with or without a leading slash)\n\t\t * @return the alternative form or {@code null}\n\t\t */\n\t\tprivate static @Nullable Resource createAlternative(String path) {\n\t\t\ttry {\n\t\t\t\tString alternativePath = path.startsWith(\"/\") ? path.substring(1) : \"/\" + path;\n\t\t\t\treturn asJarFileResource(alternativePath);\n\t\t\t}\n\t\t\tcatch (MalformedURLException ex) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tprivate static Resource asJarFileResource(String path) throws MalformedURLException {\n\t\t\treturn new UrlResource(JARFILE_URL_PREFIX + path + ResourceUtils.JAR_URL_SEPARATOR);\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  }
]