[
  {
    "head": "org.springframework.core.annotation.AnnotatedMethodParameter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotatedMethodParameter#clone()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotatedMethodParameter#clone()",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AnnotatedMethodParameter",
    "headType": "class",
    "relation": "extend",
    "tail": "SynthesizingMethodParameter",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.ReturnValueMethodParameter",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.ReturnValueMethodParameter",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.core.BridgeMethodResolver;\nimport org.springframework.core.MethodParameter;\nimport org.springframework.core.ResolvableType;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ObjectUtils;\nimport org.springframework.util.ReflectionUtils;\nimport org.springframework.util.StringUtils;\n\n/**\n * A convenient wrapper for a {@link Method} handle, providing deep annotation\n * introspection on methods and method parameters, including the exposure of\n * interface-declared parameter annotations from the concrete target method.\n *\n * @author Juergen Hoeller\n * @since 6.1\n * @see #getMethodAnnotation(Class)\n * @see #getMethodParameters()\n * @see AnnotatedElementUtils\n * @see SynthesizingMethodParameter\n */\npublic class AnnotatedMethod {\n\n\tprivate final Method method;\n\n\tprivate final Method bridgedMethod;\n\n\tprivate final MethodParameter[] parameters;\n\n\tprivate volatile @Nullable List<Annotation[][]> inheritedParameterAnnotations;\n\n\n\t/**\n\t * Create an instance that wraps the given {@link Method}.\n\t * @param method the {@code Method} handle to wrap\n\t */\n\tpublic AnnotatedMethod(Method method) {\n\t\tAssert.notNull(method, \"Method is required\");\n\t\tthis.method = method;\n\t\tthis.bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);\n\t\tReflectionUtils.makeAccessible(this.bridgedMethod);\n\t\tthis.parameters = initMethodParameters();\n\t}\n\n\t/**\n\t * Copy constructor for use in subclasses.\n\t */\n\tprotected AnnotatedMethod(AnnotatedMethod annotatedMethod) {\n\t\tAssert.notNull(annotatedMethod, \"AnnotatedMethod is required\");\n\t\tthis.method = annotatedMethod.method;\n\t\tthis.bridgedMethod = annotatedMethod.bridgedMethod;\n\t\tthis.parameters = annotatedMethod.parameters;\n\t\tthis.inheritedParameterAnnotations = annotatedMethod.inheritedParameterAnnotations;\n\t}\n\n\n\t/**\n\t * Return the annotated method.\n\t */\n\tpublic final Method getMethod() {\n\t\treturn this.method;\n\t}\n\n\t/**\n\t * If the annotated method is a bridge method, this method returns the bridged\n\t * (user-defined) method. Otherwise, it returns the same method as {@link #getMethod()}.\n\t */\n\tprotected final Method getBridgedMethod() {\n\t\treturn this.bridgedMethod;\n\t}\n\n\t/**\n\t * Expose the containing class for method parameters.\n\t * @see MethodParameter#getContainingClass()\n\t */\n\tprotected Class<?> getContainingClass() {\n\t\treturn this.method.getDeclaringClass();\n\t}\n\n\t/**\n\t * Return the method parameters for this {@code AnnotatedMethod}.\n\t */\n\tpublic final MethodParameter[] getMethodParameters() {\n\t\treturn this.parameters;\n\t}\n\n\tprivate MethodParameter[] initMethodParameters() {\n\t\tint count = this.bridgedMethod.getParameterCount();\n\t\tMethodParameter[] result = new MethodParameter[count];\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tresult[i] = new AnnotatedMethodParameter(i);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Return a {@link MethodParameter} for the declared return type.\n\t */\n\tpublic MethodParameter getReturnType() {\n\t\treturn new AnnotatedMethodParameter(-1);\n\t}\n\n\t/**\n\t * Return a {@link MethodParameter} for the actual return value type.\n\t */\n\tpublic MethodParameter getReturnValueType(@Nullable Object returnValue) {\n\t\treturn new ReturnValueMethodParameter(returnValue);\n\t}\n\n\t/**\n\t * Return {@code true} if the method's return type is void, {@code false} otherwise.\n\t */\n\tpublic boolean isVoid() {\n\t\treturn (getReturnType().getParameterType() == void.class);\n\t}\n\n\t/**\n\t * Return a single annotation on the underlying method, traversing its super methods\n\t * if no annotation can be found on the given method itself.\n\t * <p>Supports <em>merged</em> composed annotations with attribute overrides.\n\t * @param annotationType the annotation type to look for\n\t * @return the annotation, or {@code null} if none found\n\t * @see AnnotatedElementUtils#findMergedAnnotation\n\t */\n\tpublic <A extends Annotation> @Nullable A getMethodAnnotation(Class<A> annotationType) {\n\t\treturn AnnotatedElementUtils.findMergedAnnotation(this.method, annotationType);\n\t}\n\n\t/**\n\t * Determine if an annotation of the given type is <em>present</em> or\n\t * <em>meta-present</em> on the method.\n\t * @param annotationType the annotation type to look for\n\t * @see AnnotatedElementUtils#hasAnnotation\n\t */\n\tpublic <A extends Annotation> boolean hasMethodAnnotation(Class<A> annotationType) {\n\t\treturn AnnotatedElementUtils.hasAnnotation(this.method, annotationType);\n\t}\n\n\tprivate List<Annotation[][]> getInheritedParameterAnnotations() {\n\t\tList<Annotation[][]> parameterAnnotations = this.inheritedParameterAnnotations;\n\t\tif (parameterAnnotations == null) {\n\t\t\tparameterAnnotations = new ArrayList<>();\n\t\t\tClass<?> clazz = this.method.getDeclaringClass();\n\t\t\twhile (clazz != null) {\n\t\t\t\tfor (Class<?> ifc : clazz.getInterfaces()) {\n\t\t\t\t\tfor (Method candidate : ifc.getMethods()) {\n\t\t\t\t\t\tif (isOverrideFor(candidate)) {\n\t\t\t\t\t\t\tparameterAnnotations.add(candidate.getParameterAnnotations());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tclazz = clazz.getSuperclass();\n\t\t\t\tif (clazz == Object.class) {\n\t\t\t\t\tclazz = null;\n\t\t\t\t}\n\t\t\t\tif (clazz != null) {\n\t\t\t\t\tfor (Method candidate : clazz.getMethods()) {\n\t\t\t\t\t\tif (isOverrideFor(candidate)) {\n\t\t\t\t\t\t\tparameterAnnotations.add(candidate.getParameterAnnotations());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.inheritedParameterAnnotations = parameterAnnotations;\n\t\t}\n\t\treturn parameterAnnotations;\n\t}\n\n\tprivate boolean isOverrideFor(Method candidate) {\n\t\tif (!candidate.getName().equals(this.method.getName()) ||\n\t\t\t\tcandidate.getParameterCount() != this.method.getParameterCount()) {\n\t\t\treturn false;\n\t\t}\n\t\tClass<?>[] paramTypes = this.method.getParameterTypes();\n\t\tif (Arrays.equals(candidate.getParameterTypes(), paramTypes)) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (int i = 0; i < paramTypes.length; i++) {\n\t\t\tif (paramTypes[i] !=\n\t\t\t\t\tResolvableType.forMethodParameter(candidate, i, this.method.getDeclaringClass()).resolve()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other != null && getClass() == other.getClass() &&\n\t\t\t\tthis.method.equals(((AnnotatedMethod) other).method)));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.method.hashCode();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn this.method.toGenericString();\n\t}\n\n\n\t// Support methods for use in subclass variants\n\n\tprotected static @Nullable Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs) {\n\t\tif (!ObjectUtils.isEmpty(providedArgs)) {\n\t\t\tfor (Object providedArg : providedArgs) {\n\t\t\t\tif (parameter.getParameterType().isInstance(providedArg)) {\n\t\t\t\t\treturn providedArg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected static String formatArgumentError(MethodParameter param, String message) {\n\t\treturn \"Could not resolve parameter [\" + param.getParameterIndex() + \"] in \" +\n\t\t\t\tparam.getExecutable().toGenericString() + (StringUtils.hasText(message) ? \": \" + message : \"\");\n\t}\n\n\n\t/**\n\t * A MethodParameter with AnnotatedMethod-specific behavior.\n\t */\n\tprotected class AnnotatedMethodParameter extends SynthesizingMethodParameter {\n\n\t\tprivate volatile Annotation @Nullable [] combinedAnnotations;\n\n\t\tpublic AnnotatedMethodParameter(int index) {\n\t\t\tsuper(AnnotatedMethod.this.getBridgedMethod(), index);\n\t\t}\n\n\t\tprotected AnnotatedMethodParameter(AnnotatedMethodParameter original) {\n\t\t\tsuper(original);\n\t\t\tthis.combinedAnnotations = original.combinedAnnotations;\n\t\t}\n\n\t\t@Override\n\t\tpublic Method getMethod() {\n\t\t\treturn AnnotatedMethod.this.getBridgedMethod();\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> getContainingClass() {\n\t\t\treturn AnnotatedMethod.this.getContainingClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic <T extends Annotation> @Nullable T getMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn AnnotatedMethod.this.getMethodAnnotation(annotationType);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T extends Annotation> boolean hasMethodAnnotation(Class<T> annotationType) {\n\t\t\treturn AnnotatedMethod.this.hasMethodAnnotation(annotationType);\n\t\t}\n\n\t\t@Override\n\t\tpublic Annotation[] getParameterAnnotations() {\n\t\t\tAnnotation[] anns = this.combinedAnnotations;\n\t\t\tif (anns == null) {\n\t\t\t\tanns = super.getParameterAnnotations();\n\t\t\t\tint index = getParameterIndex();\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tfor (Annotation[][] ifcAnns : getInheritedParameterAnnotations()) {\n\t\t\t\t\t\tif (index < ifcAnns.length) {\n\t\t\t\t\t\t\tAnnotation[] paramAnns = ifcAnns[index];\n\t\t\t\t\t\t\tif (paramAnns.length > 0) {\n\t\t\t\t\t\t\t\tList<Annotation> merged = new ArrayList<>(anns.length + paramAnns.length);\n\t\t\t\t\t\t\t\tmerged.addAll(Arrays.asList(anns));\n\t\t\t\t\t\t\t\tfor (Annotation paramAnn : paramAnns) {\n\t\t\t\t\t\t\t\t\tboolean existingType = false;\n\t\t\t\t\t\t\t\t\tfor (Annotation ann : anns) {\n\t\t\t\t\t\t\t\t\t\tif (ann.annotationType() == paramAnn.annotationType()) {\n\t\t\t\t\t\t\t\t\t\t\texistingType = true;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!existingType) {\n\t\t\t\t\t\t\t\t\t\tmerged.add(adaptAnnotation(paramAnn));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tanns = merged.toArray(new Annotation[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.combinedAnnotations = anns;\n\t\t\t}\n\t\t\treturn anns;\n\t\t}\n\n\t\t@Override\n\t\tpublic AnnotatedMethodParameter clone() {\n\t\t\treturn new AnnotatedMethodParameter(this);\n\t\t}\n\t}\n\n\n\t/**\n\t * A MethodParameter for an AnnotatedMethod return type based on an actual return value.\n\t */\n\tprivate class ReturnValueMethodParameter extends AnnotatedMethodParameter {\n\n\t\tprivate final @Nullable Class<?> returnValueType;\n\n\t\tpublic ReturnValueMethodParameter(@Nullable Object returnValue) {\n\t\t\tsuper(-1);\n\t\t\tthis.returnValueType = (returnValue != null ? returnValue.getClass() : null);\n\t\t}\n\n\t\tprotected ReturnValueMethodParameter(ReturnValueMethodParameter original) {\n\t\t\tsuper(original);\n\t\t\tthis.returnValueType = original.returnValueType;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> getParameterType() {\n\t\t\treturn (this.returnValueType != null ? this.returnValueType : super.getParameterType());\n\t\t}\n\n\t\t@Override\n\t\tpublic ReturnValueMethodParameter clone() {\n\t\t\treturn new ReturnValueMethodParameter(this);\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation.ReturnValueMethodParameter",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.ReturnValueMethodParameter#returnValueType",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.ReturnValueMethodParameter#returnValueType",
    "headType": "field",
    "relation": "haveType",
    "tail": "Class<?>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.ReturnValueMethodParameter#getParameterType()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic Class<?> getParameterType() {\r\n    return (this.returnValueType != null ? this.returnValueType : super.getParameterType());\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.ReturnValueMethodParameter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.ReturnValueMethodParameter#getParameterType()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.ReturnValueMethodParameter#getParameterType()",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.ReturnValueMethodParameter#clone()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic ReturnValueMethodParameter clone() {\r\n    return new ReturnValueMethodParameter(this);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.ReturnValueMethodParameter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.ReturnValueMethodParameter#clone()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.ReturnValueMethodParameter#clone()",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.ReturnValueMethodParameter",
    "headType": "class",
    "relation": "extend",
    "tail": "AnnotatedMethodParameter",
    "tailType": "class"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.annotation",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.AnnotationAttributes",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationAttributes",
    "headType": "class",
    "relation": "use",
    "tail": "@SuppressWarnings",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationAttributes",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Array;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.util.Assert;\nimport org.springframework.util.StringUtils;\n\n/**\n * {@link LinkedHashMap} subclass representing annotation attribute\n * <em>key-value</em> pairs as read by {@link AnnotationUtils},\n * {@link AnnotatedElementUtils}, and Spring's reflection- and ASM-based\n * {@link org.springframework.core.type.AnnotationMetadata} implementations.\n *\n * <p>Provides 'pseudo-reification' to avoid noisy Map generics in the calling\n * code as well as convenience methods for looking up annotation attributes\n * in a type-safe fashion.\n *\n * @author Chris Beams\n * @author Sam Brannen\n * @author Juergen Hoeller\n * @since 3.1.1\n * @see AnnotationUtils#getAnnotationAttributes\n * @see AnnotatedElementUtils\n */\n@SuppressWarnings(\"serial\")\npublic class AnnotationAttributes extends LinkedHashMap<String, @Nullable Object> {\n\n\tprivate static final String UNKNOWN = \"unknown\";\n\n\tprivate final @Nullable Class<? extends Annotation> annotationType;\n\n\tfinal String displayName;\n\n\tfinal boolean validated;\n\n\n\t/**\n\t * Create a new, empty {@link AnnotationAttributes} instance.\n\t */\n\tpublic AnnotationAttributes() {\n\t\tthis.annotationType = null;\n\t\tthis.displayName = UNKNOWN;\n\t\tthis.validated = false;\n\t}\n\n\t/**\n\t * Create a new, empty {@link AnnotationAttributes} instance with the\n\t * given initial capacity to optimize performance.\n\t * @param initialCapacity initial size of the underlying map\n\t */\n\tpublic AnnotationAttributes(int initialCapacity) {\n\t\tsuper(initialCapacity);\n\t\tthis.annotationType = null;\n\t\tthis.displayName = UNKNOWN;\n\t\tthis.validated = false;\n\t}\n\n\t/**\n\t * Create a new {@link AnnotationAttributes} instance, wrapping the provided\n\t * map and all its <em>key-value</em> pairs.\n\t * @param map original source of annotation attribute <em>key-value</em> pairs\n\t * @see #fromMap(Map)\n\t */\n\tpublic AnnotationAttributes(Map<String, @Nullable Object> map) {\n\t\tsuper(map);\n\t\tthis.annotationType = null;\n\t\tthis.displayName = UNKNOWN;\n\t\tthis.validated = false;\n\t}\n\n\t/**\n\t * Create a new {@link AnnotationAttributes} instance, wrapping the provided\n\t * map and all its <em>key-value</em> pairs.\n\t * @param other original source of annotation attribute <em>key-value</em> pairs\n\t * @see #fromMap(Map)\n\t */\n\tpublic AnnotationAttributes(AnnotationAttributes other) {\n\t\tsuper(other);\n\t\tthis.annotationType = other.annotationType;\n\t\tthis.displayName = other.displayName;\n\t\tthis.validated = other.validated;\n\t}\n\n\t/**\n\t * Create a new, empty {@link AnnotationAttributes} instance for the\n\t * specified {@code annotationType}.\n\t * @param annotationType the type of annotation represented by this\n\t * {@code AnnotationAttributes} instance; never {@code null}\n\t * @since 4.2\n\t */\n\tpublic AnnotationAttributes(Class<? extends Annotation> annotationType) {\n\t\tthis(annotationType, false);\n\t}\n\n\t/**\n\t * Create a possibly already validated new, empty\n\t * {@link AnnotationAttributes} instance for the specified\n\t * {@code annotationType}.\n\t * @param annotationType the type of annotation represented by this\n\t * {@code AnnotationAttributes} instance; never {@code null}\n\t * @param validated if the attributes are considered already validated\n\t * @since 5.2\n\t */\n\tAnnotationAttributes(Class<? extends Annotation> annotationType, boolean validated) {\n\t\tAssert.notNull(annotationType, \"'annotationType' must not be null\");\n\t\tthis.annotationType = annotationType;\n\t\tthis.displayName = annotationType.getName();\n\t\tthis.validated = validated;\n\t}\n\n\t/**\n\t * Create a new, empty {@link AnnotationAttributes} instance for the\n\t * specified {@code annotationType}.\n\t * @param annotationType the annotation type name represented by this\n\t * {@code AnnotationAttributes} instance; never {@code null}\n\t * @param classLoader the ClassLoader to try to load the annotation type on,\n\t * or {@code null} to just store the annotation type name\n\t * @since 4.3.2\n\t */\n\tpublic AnnotationAttributes(String annotationType, @Nullable ClassLoader classLoader) {\n\t\tAssert.notNull(annotationType, \"'annotationType' must not be null\");\n\t\tthis.annotationType = getAnnotationType(annotationType, classLoader);\n\t\tthis.displayName = annotationType;\n\t\tthis.validated = false;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate static @Nullable Class<? extends Annotation> getAnnotationType(String annotationType, @Nullable ClassLoader classLoader) {\n\t\tif (classLoader != null) {\n\t\t\ttry {\n\t\t\t\treturn (Class<? extends Annotation>) classLoader.loadClass(annotationType);\n\t\t\t}\n\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t// Annotation Class not resolvable\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t/**\n\t * Get the type of annotation represented by this {@code AnnotationAttributes}.\n\t * @return the annotation type, or {@code null} if unknown\n\t * @since 4.2\n\t */\n\tpublic @Nullable Class<? extends Annotation> annotationType() {\n\t\treturn this.annotationType;\n\t}\n\n\t/**\n\t * Get the value stored under the specified {@code attributeName} as a string.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @return the value\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t */\n\tpublic String getString(String attributeName) {\n\t\treturn getRequiredAttribute(attributeName, String.class);\n\t}\n\n\t/**\n\t * Get the value stored under the specified {@code attributeName} as an\n\t * array of strings.\n\t * <p>If the value stored under the specified {@code attributeName} is\n\t * a string, it will be wrapped in a single-element array before\n\t * returning it.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @return the value\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t */\n\tpublic String[] getStringArray(String attributeName) {\n\t\treturn getRequiredAttribute(attributeName, String[].class);\n\t}\n\n\t/**\n\t * Get the value stored under the specified {@code attributeName} as a boolean.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @return the value\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t */\n\tpublic boolean getBoolean(String attributeName) {\n\t\treturn getRequiredAttribute(attributeName, Boolean.class);\n\t}\n\n\t/**\n\t * Get the value stored under the specified {@code attributeName} as a number.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @return the value\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <N extends Number> N getNumber(String attributeName) {\n\t\treturn (N) getRequiredAttribute(attributeName, Number.class);\n\t}\n\n\t/**\n\t * Get the value stored under the specified {@code attributeName} as an enum.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @return the value\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <E extends Enum<?>> E getEnum(String attributeName) {\n\t\treturn (E) getRequiredAttribute(attributeName, Enum.class);\n\t}\n\n\t/**\n\t * Get the value stored under the specified {@code attributeName} as a class.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @return the value\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> Class<? extends T> getClass(String attributeName) {\n\t\treturn getRequiredAttribute(attributeName, Class.class);\n\t}\n\n\t/**\n\t * Get the value stored under the specified {@code attributeName} as an\n\t * array of classes.\n\t * <p>If the value stored under the specified {@code attributeName} is a class,\n\t * it will be wrapped in a single-element array before returning it.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @return the value\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t */\n\tpublic Class<?>[] getClassArray(String attributeName) {\n\t\treturn getRequiredAttribute(attributeName, Class[].class);\n\t}\n\n\t/**\n\t * Get the {@link AnnotationAttributes} stored under the specified\n\t * {@code attributeName}.\n\t * <p>Note: if you expect an actual annotation, invoke\n\t * {@link #getAnnotation(String, Class)} instead.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @return the {@code AnnotationAttributes}\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t */\n\tpublic AnnotationAttributes getAnnotation(String attributeName) {\n\t\treturn getRequiredAttribute(attributeName, AnnotationAttributes.class);\n\t}\n\n\t/**\n\t * Get the annotation of type {@code annotationType} stored under the\n\t * specified {@code attributeName}.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @param annotationType the expected annotation type; never {@code null}\n\t * @return the annotation\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t * @since 4.2\n\t */\n\tpublic <A extends Annotation> A getAnnotation(String attributeName, Class<A> annotationType) {\n\t\treturn getRequiredAttribute(attributeName, annotationType);\n\t}\n\n\t/**\n\t * Get the array of {@link AnnotationAttributes} stored under the specified\n\t * {@code attributeName}.\n\t * <p>If the value stored under the specified {@code attributeName} is\n\t * an instance of {@code AnnotationAttributes}, it will be wrapped in\n\t * a single-element array before returning it.\n\t * <p>Note: if you expect an actual array of annotations, invoke\n\t * {@link #getAnnotationArray(String, Class)} instead.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @return the array of {@code AnnotationAttributes}\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t */\n\tpublic AnnotationAttributes[] getAnnotationArray(String attributeName) {\n\t\treturn getRequiredAttribute(attributeName, AnnotationAttributes[].class);\n\t}\n\n\t/**\n\t * Get the array of type {@code annotationType} stored under the specified\n\t * {@code attributeName}.\n\t * <p>If the value stored under the specified {@code attributeName} is\n\t * an {@code Annotation}, it will be wrapped in a single-element array\n\t * before returning it.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @param annotationType the expected annotation type; never {@code null}\n\t * @return the annotation array\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t * @since 4.2\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <A extends Annotation> A[] getAnnotationArray(String attributeName, Class<A> annotationType) {\n\t\treturn (A[]) getRequiredAttribute(attributeName, annotationType.arrayType());\n\t}\n\n\t/**\n\t * Get the value stored under the specified {@code attributeName},\n\t * ensuring that the value is of the {@code expectedType}.\n\t * <p>If the {@code expectedType} is an array and the value stored\n\t * under the specified {@code attributeName} is a single element of the\n\t * component type of the expected array type, the single element will be\n\t * wrapped in a single-element array of the appropriate type before\n\t * returning it.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @param expectedType the expected type; never {@code null}\n\t * @return the value\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprivate <T> T getRequiredAttribute(String attributeName, Class<T> expectedType) {\n\t\tAssert.hasText(attributeName, \"'attributeName' must not be null or empty\");\n\t\tObject value = get(attributeName);\n\t\tif (value == null) {\n\t\t\tthrow new IllegalArgumentException(String.format(\n\t\t\t\t\t\"Attribute '%s' not found in attributes for annotation [%s]\",\n\t\t\t\t\tattributeName, this.displayName));\n\t\t}\n\t\tif (value instanceof Throwable throwable) {\n\t\t\tthrow new IllegalArgumentException(String.format(\n\t\t\t\t\t\"Attribute '%s' for annotation [%s] was not resolvable due to exception [%s]\",\n\t\t\t\t\tattributeName, this.displayName, value), throwable);\n\t\t}\n\t\tif (!expectedType.isInstance(value) && expectedType.isArray() &&\n\t\t\t\texpectedType.componentType().isInstance(value)) {\n\t\t\tObject array = Array.newInstance(expectedType.componentType(), 1);\n\t\t\tArray.set(array, 0, value);\n\t\t\tvalue = array;\n\t\t}\n\t\tif (!expectedType.isInstance(value)) {\n\t\t\tthrow new IllegalArgumentException(String.format(\n\t\t\t\t\t\"Attribute '%s' is of type %s, but %s was expected in attributes for annotation [%s]\",\n\t\t\t\t\tattributeName, value.getClass().getSimpleName(), expectedType.getSimpleName(),\n\t\t\t\t\tthis.displayName));\n\t\t}\n\t\treturn (T) value;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tIterator<Map.Entry<String, @Nullable Object>> entries = entrySet().iterator();\n\t\tStringBuilder sb = new StringBuilder(\"{\");\n\t\twhile (entries.hasNext()) {\n\t\t\tMap.Entry<String, @Nullable Object> entry = entries.next();\n\t\t\tsb.append(entry.getKey());\n\t\t\tsb.append('=');\n\t\t\tsb.append(valueToString(entry.getValue()));\n\t\t\tif (entries.hasNext()) {\n\t\t\t\tsb.append(\", \");\n\t\t\t}\n\t\t}\n\t\tsb.append('}');\n\t\treturn sb.toString();\n\t}\n\n\tprivate String valueToString(@Nullable Object value) {\n\t\tif (value == this) {\n\t\t\treturn \"(this Map)\";\n\t\t}\n\t\tif (value instanceof Object[] objects) {\n\t\t\treturn \"[\" + StringUtils.arrayToDelimitedString(objects, \", \") + \"]\";\n\t\t}\n\t\treturn String.valueOf(value);\n\t}\n\n\n\t/**\n\t * Return an {@link AnnotationAttributes} instance based on the given map.\n\t * <p>If the map is already an {@code AnnotationAttributes} instance, it\n\t * will be cast and returned immediately without creating a new instance.\n\t * Otherwise a new instance will be created by passing the supplied map\n\t * to the {@link #AnnotationAttributes(Map)} constructor.\n\t * @param map original source of annotation attribute <em>key-value</em> pairs\n\t */\n\tpublic static @Nullable AnnotationAttributes fromMap(@Nullable Map<String, @Nullable Object> map) {\n\t\tif (map == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (map instanceof AnnotationAttributes annotationAttributes) {\n\t\t\treturn annotationAttributes;\n\t\t}\n\t\treturn new AnnotationAttributes(map);\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationAttributes",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.AnnotationAttributes#UNKNOWN",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationAttributes#UNKNOWN",
    "headType": "field",
    "relation": "haveType",
    "tail": "String",
    "tailType": "type"
  }
]