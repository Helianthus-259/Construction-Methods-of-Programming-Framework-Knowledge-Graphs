[
  {
    "head": "org.springframework.util.CollectionUtils",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\n\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.lang.Contract;\n\n/**\n * Miscellaneous collection utility methods.\n * Mainly for internal use within the framework.\n *\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Arjen Poutsma\n * @since 1.1.3\n */\npublic abstract class CollectionUtils {\n\n\t/**\n\t * Default load factor for {@link HashMap}/{@link LinkedHashMap} variants.\n\t * @see #newHashMap(int)\n\t * @see #newLinkedHashMap(int)\n\t */\n\tstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n\n\t/**\n\t * Return {@code true} if the supplied Collection is {@code null} or empty.\n\t * Otherwise, return {@code false}.\n\t * @param collection the Collection to check\n\t * @return whether the given Collection is empty\n\t */\n\t@Contract(\"null -> true\")\n\tpublic static boolean isEmpty(@Nullable Collection<? extends @Nullable Object> collection) {\n\t\treturn (collection == null || collection.isEmpty());\n\t}\n\n\t/**\n\t * Return {@code true} if the supplied Map is {@code null} or empty.\n\t * Otherwise, return {@code false}.\n\t * @param map the Map to check\n\t * @return whether the given Map is empty\n\t */\n\t@Contract(\"null -> true\")\n\tpublic static boolean isEmpty(@Nullable Map<?, ? extends @Nullable Object> map) {\n\t\treturn (map == null || map.isEmpty());\n\t}\n\n\t/**\n\t * Instantiate a new {@link HashMap} with an initial capacity\n\t * that can accommodate the specified number of elements without\n\t * any immediate resize/rehash operations to be expected.\n\t * <p>This differs from the regular {@link HashMap} constructor\n\t * which takes an initial capacity relative to a load factor\n\t * but is effectively aligned with the JDK's\n\t * {@link java.util.concurrent.ConcurrentHashMap#ConcurrentHashMap(int)}.\n\t * @param expectedSize the expected number of elements (with a corresponding\n\t * capacity to be derived so that no resize/rehash operations are needed)\n\t * @since 5.3\n\t * @see #newLinkedHashMap(int)\n\t */\n\tpublic static <K, V> HashMap<K, V> newHashMap(int expectedSize) {\n\t\treturn new HashMap<>(computeInitialCapacity(expectedSize), DEFAULT_LOAD_FACTOR);\n\t}\n\n\t/**\n\t * Instantiate a new {@link LinkedHashMap} with an initial capacity\n\t * that can accommodate the specified number of elements without\n\t * any immediate resize/rehash operations to be expected.\n\t * <p>This differs from the regular {@link LinkedHashMap} constructor\n\t * which takes an initial capacity relative to a load factor but is\n\t * aligned with Spring's own {@link LinkedCaseInsensitiveMap} and\n\t * {@link LinkedMultiValueMap} constructor semantics as of 5.3.\n\t * @param expectedSize the expected number of elements (with a corresponding\n\t * capacity to be derived so that no resize/rehash operations are needed)\n\t * @since 5.3\n\t * @see #newHashMap(int)\n\t */\n\tpublic static <K, V> LinkedHashMap<K, V> newLinkedHashMap(int expectedSize) {\n\t\treturn new LinkedHashMap<>(computeInitialCapacity(expectedSize), DEFAULT_LOAD_FACTOR);\n\t}\n\n\t/**\n\t * Instantiate a new {@link HashSet} with an initial capacity that can\n\t * accommodate the specified number of elements without any immediate\n\t * resize/rehash operations to be expected.\n\t * @param expectedSize the expected number of elements (with a corresponding\n\t * capacity to be derived so that no resize/rehash operations are needed)\n\t * @since 6.2\n\t * @see #newLinkedHashSet(int)\n\t */\n\tpublic static <E> HashSet<E> newHashSet(int expectedSize) {\n\t\treturn new HashSet<>(computeInitialCapacity(expectedSize), DEFAULT_LOAD_FACTOR);\n\t}\n\n\t/**\n\t * Instantiate a new {@link LinkedHashSet} with an initial capacity that can\n\t * accommodate the specified number of elements without any immediate\n\t * resize/rehash operations to be expected.\n\t * @param expectedSize the expected number of elements (with a corresponding\n\t * capacity to be derived so that no resize/rehash operations are needed)\n\t * @since 6.2\n\t * @see #newHashSet(int)\n\t */\n\tpublic static <E> LinkedHashSet<E> newLinkedHashSet(int expectedSize) {\n\t\treturn new LinkedHashSet<>(computeInitialCapacity(expectedSize), DEFAULT_LOAD_FACTOR);\n\t}\n\n\tprivate static int computeInitialCapacity(int expectedSize) {\n\t\treturn (int) Math.ceil(expectedSize / (double) DEFAULT_LOAD_FACTOR);\n\t}\n\n\t/**\n\t * Convert the supplied array into a List. A primitive array gets converted\n\t * into a List of the appropriate wrapper type.\n\t * <p><b>NOTE:</b> Generally prefer the standard {@link Arrays#asList} method.\n\t * This {@code arrayToList} method is just meant to deal with an incoming Object\n\t * value that might be an {@code Object[]} or a primitive array at runtime.\n\t * <p>A {@code null} source value will be converted to an empty List.\n\t * @param source the (potentially primitive) array\n\t * @return the converted List result\n\t * @see ObjectUtils#toObjectArray(Object)\n\t * @see Arrays#asList(Object[])\n\t */\n\tpublic static List<?> arrayToList(@Nullable Object source) {\n\t\treturn Arrays.asList(ObjectUtils.toObjectArray(source));\n\t}\n\n\t/**\n\t * Merge the given array into the given Collection.\n\t * @param array the array to merge (may be {@code null})\n\t * @param collection the target Collection to merge the array into\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <E> void mergeArrayIntoCollection(@Nullable Object array, Collection<E> collection) {\n\t\tObject[] arr = ObjectUtils.toObjectArray(array);\n\t\tCollections.addAll(collection, (E[])arr);\n\t}\n\n\t/**\n\t * Merge the given Properties instance into the given Map,\n\t * copying all properties (key-value pairs) over.\n\t * <p>Uses {@code Properties.propertyNames()} to even catch\n\t * default properties linked into the original Properties instance.\n\t * @param props the Properties instance to merge (may be {@code null})\n\t * @param map the target Map to merge the properties into\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <K, V> void mergePropertiesIntoMap(@Nullable Properties props, Map<K, V> map) {\n\t\tif (props != null) {\n\t\t\tfor (Enumeration<?> en = props.propertyNames(); en.hasMoreElements();) {\n\t\t\t\tString key = (String) en.nextElement();\n\t\t\t\tObject value = props.get(key);\n\t\t\t\tif (value == null) {\n\t\t\t\t\t// Allow for defaults fallback or potentially overridden accessor...\n\t\t\t\t\tvalue = props.getProperty(key);\n\t\t\t\t}\n\t\t\t\tmap.put((K) key, (V) value);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Check whether the given Iterator contains the given element.\n\t * @param iterator the Iterator to check\n\t * @param element the element to look for\n\t * @return {@code true} if found, {@code false} otherwise\n\t */\n\tpublic static boolean contains(@Nullable Iterator<?> iterator, Object element) {\n\t\tif (iterator != null) {\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tObject candidate = iterator.next();\n\t\t\t\tif (ObjectUtils.nullSafeEquals(candidate, element)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check whether the given Enumeration contains the given element.\n\t * @param enumeration the Enumeration to check\n\t * @param element the element to look for\n\t * @return {@code true} if found, {@code false} otherwise\n\t */\n\tpublic static boolean contains(@Nullable Enumeration<?> enumeration, Object element) {\n\t\tif (enumeration != null) {\n\t\t\twhile (enumeration.hasMoreElements()) {\n\t\t\t\tObject candidate = enumeration.nextElement();\n\t\t\t\tif (ObjectUtils.nullSafeEquals(candidate, element)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check whether the given Collection contains the given element instance.\n\t * <p>Enforces the given instance to be present, rather than returning\n\t * {@code true} for an equal element as well.\n\t * @param collection the Collection to check\n\t * @param element the element to look for\n\t * @return {@code true} if found, {@code false} otherwise\n\t */\n\tpublic static boolean containsInstance(@Nullable Collection<?> collection, Object element) {\n\t\tif (collection != null) {\n\t\t\tfor (Object candidate : collection) {\n\t\t\t\tif (candidate == element) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Return {@code true} if any element in '{@code candidates}' is\n\t * contained in '{@code source}'; otherwise returns {@code false}.\n\t * @param source the source Collection\n\t * @param candidates the candidates to search for\n\t * @return whether any of the candidates has been found\n\t */\n\tpublic static boolean containsAny(Collection<?> source, Collection<?> candidates) {\n\t\treturn findFirstMatch(source, candidates) != null;\n\t}\n\n\t/**\n\t * Return the first element in '{@code candidates}' that is contained in\n\t * '{@code source}'. If no element in '{@code candidates}' is present in\n\t * '{@code source}' returns {@code null}. Iteration order is\n\t * {@link Collection} implementation specific.\n\t * @param source the source Collection\n\t * @param candidates the candidates to search for\n\t * @return the first present object, or {@code null} if not found\n\t */\n\tpublic static <E> @Nullable E findFirstMatch(Collection<?> source, Collection<E> candidates) {\n\t\tif (isEmpty(source) || isEmpty(candidates)) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (E candidate : candidates) {\n\t\t\tif (source.contains(candidate)) {\n\t\t\t\treturn candidate;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Find a single value of the given type in the given Collection.\n\t * @param collection the Collection to search\n\t * @param type the type to look for\n\t * @return a value of the given type found if there is a clear match,\n\t * or {@code null} if none or more than one such value found\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <T> @Nullable T findValueOfType(@Nullable Collection<?> collection, @Nullable Class<T> type) {\n\t\tif (isEmpty(collection)) {\n\t\t\treturn null;\n\t\t}\n\t\tT value = null;\n\t\tfor (Object element : collection) {\n\t\t\tif (type == null || type.isInstance(element)) {\n\t\t\t\tif (value != null) {\n\t\t\t\t\t// More than one value found... no clear single value.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tvalue = (T) element;\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Find a single value of one of the given types in the given Collection:\n\t * searching the Collection for a value of the first type, then\n\t * searching for a value of the second type, etc.\n\t * @param collection the collection to search\n\t * @param types the types to look for, in prioritized order\n\t * @return a value of one of the given types found if there is a clear match,\n\t * or {@code null} if none or more than one such value found\n\t */\n\tpublic static @Nullable Object findValueOfType(Collection<?> collection, Class<?>[] types) {\n\t\tif (isEmpty(collection) || ObjectUtils.isEmpty(types)) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (Class<?> type : types) {\n\t\t\tObject value = findValueOfType(collection, type);\n\t\t\tif (value != null) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Determine whether the given Collection only contains a single unique object.\n\t * @param collection the Collection to check\n\t * @return {@code true} if the collection contains a single reference or\n\t * multiple references to the same instance, {@code false} otherwise\n\t */\n\tpublic static boolean hasUniqueObject(Collection<?> collection) {\n\t\tif (isEmpty(collection)) {\n\t\t\treturn false;\n\t\t}\n\t\tboolean hasCandidate = false;\n\t\tObject candidate = null;\n\t\tfor (Object elem : collection) {\n\t\t\tif (!hasCandidate) {\n\t\t\t\thasCandidate = true;\n\t\t\t\tcandidate = elem;\n\t\t\t}\n\t\t\telse if (candidate != elem) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Find the common element type of the given Collection, if any.\n\t * @param collection the Collection to check\n\t * @return the common element type, or {@code null} if no clear\n\t * common type has been found (or the collection was empty)\n\t */\n\tpublic static @Nullable Class<?> findCommonElementType(Collection<?> collection) {\n\t\tif (isEmpty(collection)) {\n\t\t\treturn null;\n\t\t}\n\t\tClass<?> candidate = null;\n\t\tfor (Object val : collection) {\n\t\t\tif (val != null) {\n\t\t\t\tif (candidate == null) {\n\t\t\t\t\tcandidate = val.getClass();\n\t\t\t\t}\n\t\t\t\telse if (candidate != val.getClass()) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn candidate;\n\t}\n\n\t/**\n\t * Retrieve the first element of the given Set, using {@link SortedSet#first()}\n\t * or otherwise using the iterator.\n\t * @param set the Set to check (may be {@code null} or empty)\n\t * @return the first element, or {@code null} if none\n\t * @since 5.2.3\n\t * @see SortedSet\n\t * @see LinkedHashMap#keySet()\n\t * @see java.util.LinkedHashSet\n\t */\n\tpublic static <T> @Nullable T firstElement(@Nullable Set<T> set) {\n\t\tif (isEmpty(set)) {\n\t\t\treturn null;\n\t\t}\n\t\tif (set instanceof SortedSet<T> sortedSet) {\n\t\t\treturn sortedSet.first();\n\t\t}\n\n\t\tIterator<T> it = set.iterator();\n\t\tT first = null;\n\t\tif (it.hasNext()) {\n\t\t\tfirst = it.next();\n\t\t}\n\t\treturn first;\n\t}\n\n\t/**\n\t * Retrieve the first element of the given List, accessing the zero index.\n\t * @param list the List to check (may be {@code null} or empty)\n\t * @return the first element, or {@code null} if none\n\t * @since 5.2.3\n\t */\n\tpublic static <T> @Nullable T firstElement(@Nullable List<T> list) {\n\t\tif (isEmpty(list)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn list.get(0);\n\t}\n\n\t/**\n\t * Retrieve the last element of the given Set, using {@link SortedSet#last()}\n\t * or otherwise iterating over all elements (assuming a linked set).\n\t * @param set the Set to check (may be {@code null} or empty)\n\t * @return the last element, or {@code null} if none\n\t * @since 5.0.3\n\t * @see SortedSet\n\t * @see LinkedHashMap#keySet()\n\t * @see java.util.LinkedHashSet\n\t */\n\tpublic static <T> @Nullable T lastElement(@Nullable Set<T> set) {\n\t\tif (isEmpty(set)) {\n\t\t\treturn null;\n\t\t}\n\t\tif (set instanceof SortedSet<T> sortedSet) {\n\t\t\treturn sortedSet.last();\n\t\t}\n\n\t\t// Full iteration necessary...\n\t\tIterator<T> it = set.iterator();\n\t\tT last = null;\n\t\twhile (it.hasNext()) {\n\t\t\tlast = it.next();\n\t\t}\n\t\treturn last;\n\t}\n\n\t/**\n\t * Retrieve the last element of the given List, accessing the highest index.\n\t * @param list the List to check (may be {@code null} or empty)\n\t * @return the last element, or {@code null} if none\n\t * @since 5.0.3\n\t */\n\tpublic static <T> @Nullable T lastElement(@Nullable List<T> list) {\n\t\tif (isEmpty(list)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn list.get(list.size() - 1);\n\t}\n\n\t/**\n\t * Marshal the elements from the given enumeration into an array of the given type.\n\t * Enumeration elements must be assignable to the type of the given array. The array\n\t * returned will be a different instance than the array given.\n\t */\n\tpublic static <A, E extends A> A[] toArray(Enumeration<E> enumeration, A[] array) {\n\t\tArrayList<A> elements = new ArrayList<>();\n\t\twhile (enumeration.hasMoreElements()) {\n\t\t\telements.add(enumeration.nextElement());\n\t\t}\n\t\treturn elements.toArray(array);\n\t}\n\n\t/**\n\t * Adapt an {@link Enumeration} to an {@link Iterator}.\n\t * @param enumeration the original {@code Enumeration}\n\t * @return the adapted {@code Iterator}\n\t */\n\tpublic static <E> Iterator<E> toIterator(@Nullable Enumeration<E> enumeration) {\n\t\treturn (enumeration != null ? enumeration.asIterator() : Collections.emptyIterator());\n\t}\n\n\t/**\n\t * Adapt a {@code Map<K, List<V>>} to an {@code MultiValueMap<K, V>}.\n\t * @param targetMap the original map\n\t * @return the adapted multi-value map (wrapping the original map)\n\t * @since 3.1\n\t */\n\tpublic static <K, V> MultiValueMap<K, V> toMultiValueMap(Map<K, List<V>> targetMap) {\n\t\treturn new MultiValueMapAdapter<>(targetMap);\n\t}\n\n\t/**\n\t * Return an unmodifiable view of the specified multi-value map.\n\t * @param targetMap the map for which an unmodifiable view is to be returned.\n\t * @return an unmodifiable view of the specified multi-value map\n\t * @since 3.1\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <K, V> MultiValueMap<K, V> unmodifiableMultiValueMap(\n\t\t\tMultiValueMap<? extends K, ? extends V> targetMap) {\n\n\t\tAssert.notNull(targetMap, \"'targetMap' must not be null\");\n\t\tif (targetMap instanceof UnmodifiableMultiValueMap) {\n\t\t\treturn (MultiValueMap<K, V>) targetMap;\n\t\t}\n\t\treturn new UnmodifiableMultiValueMap<>(targetMap);\n\t}\n\n\t/**\n\t * Return a (partially unmodifiable) map that combines the provided two\n\t * maps. Invoking {@link Map#put(Object, Object)} or {@link Map#putAll(Map)}\n\t * on the returned map results in an {@link UnsupportedOperationException}.\n\t * <p>In the case of a key collision, {@code first} takes precedence over\n\t * {@code second}. In other words, entries in {@code second} with a key\n\t * that is also mapped by {@code first} are effectively ignored.\n\t * @param first the first map to compose\n\t * @param second the second map to compose\n\t * @return a new map that composes the given two maps\n\t * @since 6.2\n\t */\n\tpublic static <K, V> Map<K, V> compositeMap(Map<K,V> first, Map<K,V> second) {\n\t\treturn new CompositeMap<>(first, second);\n\t}\n\n\t/**\n\t * Return a map that combines the provided maps. Invoking\n\t * {@link Map#put(Object, Object)} on the returned map will apply\n\t * {@code putFunction}, or will throw an\n\t * {@link UnsupportedOperationException} {@code putFunction} is\n\t * {@code null}. The same applies to {@link Map#putAll(Map)} and\n\t * {@code putAllFunction}.\n\t * <p>In the case of a key collision, {@code first} takes precedence over\n\t * {@code second}. In other words, entries in {@code second} with a key\n\t * that is also mapped by {@code first} are effectively ignored.\n\t * @param first the first map to compose\n\t * @param second the second map to compose\n\t * @param putFunction applied when {@code Map::put} is invoked. If\n\t * {@code null}, {@code Map::put} throws an\n\t * {@code UnsupportedOperationException}.\n\t * @param putAllFunction applied when {@code Map::putAll} is invoked. If\n\t * {@code null}, {@code Map::putAll} throws an\n\t * {@code UnsupportedOperationException}.\n\t * @return a new map that composes the give maps\n\t * @since 6.2\n\t */\n\tpublic static <K, V> Map<K, V> compositeMap(Map<K,V> first, Map<K,V> second,\n\t\t\t@Nullable BiFunction<K, V, V> putFunction,\n\t\t\t@Nullable Consumer<Map<K, V>> putAllFunction) {\n\n\t\treturn new CompositeMap<>(first, second, putFunction, putAllFunction);\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.CollectionUtils",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.CollectionUtils#DEFAULT_LOAD_FACTOR",
    "tailType": "field"
  },
  {
    "head": "org.springframework.util.CollectionUtils#DEFAULT_LOAD_FACTOR",
    "headType": "field",
    "relation": "haveType",
    "tail": "float",
    "tailType": "type"
  },
  {
    "head": "org.springframework.util.CollectionUtils#isEmpty(Collection<? extends Object>)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Return {@code true} if the supplied Collection is {@code null} or empty.\r\n * Otherwise, return {@code false}.\r\n * @param collection the Collection to check\r\n * @return whether the given Collection is empty\r\n */\r\n@Contract(\"null -> true\")\r\npublic static boolean isEmpty(@Nullable Collection<? extends @Nullable Object> collection) {\r\n    return (collection == null || collection.isEmpty());\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.CollectionUtils",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.CollectionUtils#isEmpty(Collection<? extends Object>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.CollectionUtils#isEmpty(Collection<? extends Object>)",
    "headType": "method",
    "relation": "use",
    "tail": "@Contract",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.CollectionUtils#isEmpty(Map<?,? extends Object>)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Return {@code true} if the supplied Map is {@code null} or empty.\r\n * Otherwise, return {@code false}.\r\n * @param map the Map to check\r\n * @return whether the given Map is empty\r\n */\r\n@Contract(\"null -> true\")\r\npublic static boolean isEmpty(@Nullable Map<?, ? extends @Nullable Object> map) {\r\n    return (map == null || map.isEmpty());\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.CollectionUtils",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.CollectionUtils#isEmpty(Map<?,? extends Object>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.CollectionUtils#isEmpty(Map<?,? extends Object>)",
    "headType": "method",
    "relation": "use",
    "tail": "@Contract",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.CollectionUtils#newHashMap(int)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Instantiate a new {@link HashMap} with an initial capacity\r\n * that can accommodate the specified number of elements without\r\n * any immediate resize/rehash operations to be expected.\r\n * <p>This differs from the regular {@link HashMap} constructor\r\n * which takes an initial capacity relative to a load factor\r\n * but is effectively aligned with the JDK's\r\n * {@link java.util.concurrent.ConcurrentHashMap#ConcurrentHashMap(int)}.\r\n * @param expectedSize the expected number of elements (with a corresponding\r\n * capacity to be derived so that no resize/rehash operations are needed)\r\n * @since 5.3\r\n * @see #newLinkedHashMap(int)\r\n */\r\npublic static <K, V> HashMap<K, V> newHashMap(int expectedSize) {\r\n    return new HashMap<>(computeInitialCapacity(expectedSize), DEFAULT_LOAD_FACTOR);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.CollectionUtils",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.CollectionUtils#newHashMap(int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.CollectionUtils#newLinkedHashMap(int)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Instantiate a new {@link LinkedHashMap} with an initial capacity\r\n * that can accommodate the specified number of elements without\r\n * any immediate resize/rehash operations to be expected.\r\n * <p>This differs from the regular {@link LinkedHashMap} constructor\r\n * which takes an initial capacity relative to a load factor but is\r\n * aligned with Spring's own {@link LinkedCaseInsensitiveMap} and\r\n * {@link LinkedMultiValueMap} constructor semantics as of 5.3.\r\n * @param expectedSize the expected number of elements (with a corresponding\r\n * capacity to be derived so that no resize/rehash operations are needed)\r\n * @since 5.3\r\n * @see #newHashMap(int)\r\n */\r\npublic static <K, V> LinkedHashMap<K, V> newLinkedHashMap(int expectedSize) {\r\n    return new LinkedHashMap<>(computeInitialCapacity(expectedSize), DEFAULT_LOAD_FACTOR);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.CollectionUtils",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.CollectionUtils#newLinkedHashMap(int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.CollectionUtils#newHashSet(int)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Instantiate a new {@link HashSet} with an initial capacity that can\r\n * accommodate the specified number of elements without any immediate\r\n * resize/rehash operations to be expected.\r\n * @param expectedSize the expected number of elements (with a corresponding\r\n * capacity to be derived so that no resize/rehash operations are needed)\r\n * @since 6.2\r\n * @see #newLinkedHashSet(int)\r\n */\r\npublic static <E> HashSet<E> newHashSet(int expectedSize) {\r\n    return new HashSet<>(computeInitialCapacity(expectedSize), DEFAULT_LOAD_FACTOR);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.CollectionUtils",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.CollectionUtils#newHashSet(int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.CollectionUtils#newLinkedHashSet(int)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Instantiate a new {@link LinkedHashSet} with an initial capacity that can\r\n * accommodate the specified number of elements without any immediate\r\n * resize/rehash operations to be expected.\r\n * @param expectedSize the expected number of elements (with a corresponding\r\n * capacity to be derived so that no resize/rehash operations are needed)\r\n * @since 6.2\r\n * @see #newHashSet(int)\r\n */\r\npublic static <E> LinkedHashSet<E> newLinkedHashSet(int expectedSize) {\r\n    return new LinkedHashSet<>(computeInitialCapacity(expectedSize), DEFAULT_LOAD_FACTOR);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.CollectionUtils",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.CollectionUtils#newLinkedHashSet(int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.CollectionUtils#computeInitialCapacity(int)",
    "headType": "method",
    "relation": "provide",
    "tail": "private static int computeInitialCapacity(int expectedSize) {\r\n    return (int) Math.ceil(expectedSize / (double) DEFAULT_LOAD_FACTOR);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.CollectionUtils",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.CollectionUtils#computeInitialCapacity(int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.CollectionUtils#arrayToList(Object)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Convert the supplied array into a List. A primitive array gets converted\r\n * into a List of the appropriate wrapper type.\r\n * <p><b>NOTE:</b> Generally prefer the standard {@link Arrays#asList} method.\r\n * This {@code arrayToList} method is just meant to deal with an incoming Object\r\n * value that might be an {@code Object[]} or a primitive array at runtime.\r\n * <p>A {@code null} source value will be converted to an empty List.\r\n * @param source the (potentially primitive) array\r\n * @return the converted List result\r\n * @see ObjectUtils#toObjectArray(Object)\r\n * @see Arrays#asList(Object[])\r\n */\r\npublic static List<?> arrayToList(@Nullable Object source) {\r\n    return Arrays.asList(ObjectUtils.toObjectArray(source));\r\n}",
    "tailType": "method_code"
  }
]