[
  {
    "head": "org.springframework.core.type.ComposedConfigurationWithAttributeOverridesClass",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.type;\n\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.AliasFor;\nimport org.springframework.core.annotation.AnnotatedElementUtils;\nimport org.springframework.core.annotation.AnnotationAttributes;\nimport org.springframework.core.testfixture.stereotype.Component;\nimport org.springframework.core.type.classreading.MetadataReader;\nimport org.springframework.core.type.classreading.MetadataReaderFactory;\nimport org.springframework.core.type.classreading.SimpleMetadataReaderFactory;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Unit tests demonstrating that the reflection-based {@link StandardAnnotationMetadata}\n * and ASM-based {@code SimpleAnnotationMetadata} produce <em>almost</em> identical output.\n *\n * @author Juergen Hoeller\n * @author Chris Beams\n * @author Phillip Webb\n * @author Sam Brannen\n * @see InheritedAnnotationsAnnotationMetadataTests\n */\nclass AnnotationMetadataTests {\n\n\t@Test\n\tvoid standardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(AnnotatedComponent.class);\n\t\tdoTestAnnotationInfo(metadata);\n\t\tdoTestMethodAnnotationInfo(metadata);\n\t}\n\n\t@Test\n\tvoid asmAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(AnnotatedComponent.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tdoTestAnnotationInfo(metadata);\n\t\tdoTestMethodAnnotationInfo(metadata);\n\t}\n\n\t@Test\n\tvoid standardAnnotationMetadataForSubclass() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(AnnotatedComponentSubClass.class);\n\t\tdoTestSubClassAnnotationInfo(metadata, false);\n\t}\n\n\t@Test\n\tvoid asmAnnotationMetadataForSubclass() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(AnnotatedComponentSubClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tdoTestSubClassAnnotationInfo(metadata, true);\n\t}\n\n\tprivate void doTestSubClassAnnotationInfo(AnnotationMetadata metadata, boolean asm) {\n\t\tassertThat(metadata.getClassName()).isEqualTo(AnnotatedComponentSubClass.class.getName());\n\t\tassertThat(metadata.isInterface()).isFalse();\n\t\tassertThat(metadata.isAnnotation()).isFalse();\n\t\tassertThat(metadata.isAbstract()).isFalse();\n\t\tassertThat(metadata.isConcrete()).isTrue();\n\t\tassertThat(metadata.hasSuperClass()).isTrue();\n\t\tassertThat(metadata.getSuperClassName()).isEqualTo(AnnotatedComponent.class.getName());\n\t\tassertThat(metadata.getInterfaceNames()).isEmpty();\n\t\tassertThat(metadata.isAnnotated(Component.class.getName())).isFalse();\n\t\tassertThat(metadata.isAnnotated(Scope.class.getName())).isFalse();\n\t\tassertThat(metadata.isAnnotated(SpecialAttr.class.getName())).isFalse();\n\n\t\tif (asm) {\n\t\t\tassertThat(metadata.isAnnotated(NamedComposedAnnotation.class.getName())).isFalse();\n\t\t\tassertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isFalse();\n\t\t\tassertThat(metadata.getAnnotationTypes()).isEmpty();\n\t\t}\n\t\telse {\n\t\t\tassertThat(metadata.isAnnotated(NamedComposedAnnotation.class.getName())).isTrue();\n\t\t\tassertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isTrue();\n\t\t\tassertThat(metadata.getAnnotationTypes()).containsExactly(NamedComposedAnnotation.class.getName());\n\t\t}\n\n\t\tassertThat(metadata.hasAnnotation(Component.class.getName())).isFalse();\n\t\tassertThat(metadata.hasAnnotation(Scope.class.getName())).isFalse();\n\t\tassertThat(metadata.hasAnnotation(SpecialAttr.class.getName())).isFalse();\n\t\tassertThat(metadata.hasMetaAnnotation(Component.class.getName())).isFalse();\n\t\tassertThat(metadata.hasMetaAnnotation(MetaAnnotation.class.getName())).isFalse();\n\t\tassertThat(metadata.getAnnotationAttributes(Component.class.getName())).isNull();\n\t\tassertThat(metadata.getAnnotationAttributes(MetaAnnotation.class.getName(), false)).isNull();\n\t\tassertThat(metadata.getAnnotationAttributes(MetaAnnotation.class.getName(), true)).isNull();\n\t\tassertThat(metadata.getAnnotatedMethods(DirectAnnotation.class.getName())).isEmpty();\n\t\tassertThat(metadata.isAnnotated(IsAnnotatedAnnotation.class.getName())).isFalse();\n\t\tassertThat(metadata.getAllAnnotationAttributes(DirectAnnotation.class.getName())).isNull();\n\t}\n\n\t@Test\n\tvoid standardAnnotationMetadataForInterface() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(AnnotationMetadata.class);\n\t\tdoTestMetadataForInterfaceClass(metadata);\n\t}\n\n\t@Test\n\tvoid asmAnnotationMetadataForInterface() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(AnnotationMetadata.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tdoTestMetadataForInterfaceClass(metadata);\n\t}\n\n\tprivate void doTestMetadataForInterfaceClass(AnnotationMetadata metadata) {\n\t\tassertThat(metadata.getClassName()).isEqualTo(AnnotationMetadata.class.getName());\n\t\tassertThat(metadata.isInterface()).isTrue();\n\t\tassertThat(metadata.isAnnotation()).isFalse();\n\t\tassertThat(metadata.isAbstract()).isTrue();\n\t\tassertThat(metadata.isConcrete()).isFalse();\n\t\tassertThat(metadata.hasSuperClass()).isFalse();\n\t\tassertThat(metadata.getSuperClassName()).isNull();\n\t\tassertThat(metadata.getInterfaceNames()).hasSize(2);\n\t\tassertThat(metadata.getInterfaceNames()[0]).isEqualTo(ClassMetadata.class.getName());\n\t\tassertThat(metadata.getInterfaceNames()[1]).isEqualTo(AnnotatedTypeMetadata.class.getName());\n\t\tassertThat(metadata.getAnnotationTypes()).isEmpty();\n\t}\n\n\t@Test\n\tvoid standardAnnotationMetadataForAnnotation() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(Component.class);\n\t\tdoTestMetadataForAnnotationClass(metadata);\n\t}\n\n\t@Test\n\tvoid asmAnnotationMetadataForAnnotation() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(Component.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tdoTestMetadataForAnnotationClass(metadata);\n\t}\n\n\tprivate void doTestMetadataForAnnotationClass(AnnotationMetadata metadata) {\n\t\tassertThat(metadata.getClassName()).isEqualTo(Component.class.getName());\n\t\tassertThat(metadata.isInterface()).isTrue();\n\t\tassertThat(metadata.isAnnotation()).isTrue();\n\t\tassertThat(metadata.isAbstract()).isTrue();\n\t\tassertThat(metadata.isConcrete()).isFalse();\n\t\tassertThat(metadata.hasSuperClass()).isFalse();\n\t\tassertThat(metadata.getSuperClassName()).isNull();\n\t\tassertThat(metadata.getInterfaceNames()).hasSize(1);\n\t\tassertThat(metadata.getInterfaceNames()[0]).isEqualTo(Annotation.class.getName());\n\t\tassertThat(metadata.isAnnotated(Documented.class.getName())).isFalse();\n\t\tassertThat(metadata.isAnnotated(Scope.class.getName())).isFalse();\n\t\tassertThat(metadata.isAnnotated(SpecialAttr.class.getName())).isFalse();\n\t\tassertThat(metadata.hasAnnotation(Documented.class.getName())).isFalse();\n\t\tassertThat(metadata.hasAnnotation(Scope.class.getName())).isFalse();\n\t\tassertThat(metadata.hasAnnotation(SpecialAttr.class.getName())).isFalse();\n\t\tassertThat(metadata.getAnnotationTypes()).hasSize(1);\n\t}\n\n\t/**\n\t * In order to preserve backward-compatibility, {@link StandardAnnotationMetadata}\n\t * defaults to return nested annotations and annotation arrays as actual\n\t * Annotation instances. It is recommended for compatibility with ASM-based\n\t * AnnotationMetadata implementations to set the 'nestedAnnotationsAsMap' flag to\n\t * 'true' as is done in the main test above.\n\t */\n\t@Test\n\tvoid standardAnnotationMetadata_nestedAnnotationsAsMap_false() {\n\t\t@SuppressWarnings(\"deprecation\")\n\t\tAnnotationMetadata metadata = new StandardAnnotationMetadata(AnnotatedComponent.class);\n\t\tAnnotationAttributes specialAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(SpecialAttr.class.getName());\n\t\tAnnotation[] nestedAnnoArray = (Annotation[]) specialAttrs.get(\"nestedAnnoArray\");\n\t\tassertThat(nestedAnnoArray[0]).isInstanceOf(NestedAnno.class);\n\t}\n\n\t@Test\n\tvoid metaAnnotationOverridesUsingStandardAnnotationMetadata() {\n\t\t@SuppressWarnings(\"deprecation\")\n\t\tAnnotationMetadata metadata = new StandardAnnotationMetadata(ComposedConfigurationWithAttributeOverridesClass.class);\n\t\tassertMetaAnnotationOverrides(metadata);\n\t}\n\n\t@Test\n\tvoid metaAnnotationOverridesUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(ComposedConfigurationWithAttributeOverridesClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertMetaAnnotationOverrides(metadata);\n\t}\n\n\tprivate void assertMetaAnnotationOverrides(AnnotationMetadata metadata) {\n\t\tAnnotationAttributes attributes = (AnnotationAttributes) metadata.getAnnotationAttributes(\n\t\t\t\tTestComponentScan.class.getName(), false);\n\t\tassertThat(attributes.getStringArray(\"value\")).containsExactly(\"org.example.componentscan\");\n\t\tassertThat(attributes.getStringArray(\"basePackages\")).containsExactly(\"org.example.componentscan\");\n\t\tassertThat(attributes.getClassArray(\"basePackageClasses\")).isEmpty();\n\t}\n\n\t@Test  // SPR-11649\n\tvoid multipleAnnotationsWithIdenticalAttributeNamesUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(NamedAnnotationsClass.class);\n\t\tassertMultipleAnnotationsWithIdenticalAttributeNames(metadata);\n\t}\n\n\t@Test  // SPR-11649\n\tvoid multipleAnnotationsWithIdenticalAttributeNamesUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(NamedAnnotationsClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertMultipleAnnotationsWithIdenticalAttributeNames(metadata);\n\t}\n\n\t@Test  // SPR-11649\n\tvoid composedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(NamedComposedAnnotationClass.class);\n\t\tassertMultipleAnnotationsWithIdenticalAttributeNames(metadata);\n\t}\n\n\t@Test  // SPR-11649\n\tvoid composedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(NamedComposedAnnotationClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertMultipleAnnotationsWithIdenticalAttributeNames(metadata);\n\t}\n\n\t@Test  // gh-31041\n\tvoid multipleComposedRepeatableAnnotationsUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(MultipleComposedRepeatableAnnotationsClass.class);\n\t\tassertRepeatableAnnotations(metadata);\n\t}\n\n\t@Test  // gh-31041\n\tvoid multipleComposedRepeatableAnnotationsUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(MultipleComposedRepeatableAnnotationsClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertRepeatableAnnotations(metadata);\n\t}\n\n\t@Test  // gh-31074\n\tvoid multipleComposedRepeatableAnnotationsSortedByReversedMetaDistanceUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(MultipleComposedRepeatableAnnotationsClass.class);\n\t\tassertRepeatableAnnotationsSortedByReversedMetaDistance(metadata);\n\t}\n\n\t@Test  // gh-31074\n\tvoid multipleComposedRepeatableAnnotationsSortedByReversedMetaDistanceUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(MultipleComposedRepeatableAnnotationsClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertRepeatableAnnotationsSortedByReversedMetaDistance(metadata);\n\t}\n\n\t@Test  // gh-31041\n\tvoid multipleRepeatableAnnotationsInContainersUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(MultipleRepeatableAnnotationsInContainersClass.class);\n\t\tassertRepeatableAnnotations(metadata);\n\t}\n\n\t@Test  // gh-31041\n\tvoid multipleRepeatableAnnotationsInContainersUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(MultipleRepeatableAnnotationsInContainersClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertRepeatableAnnotations(metadata);\n\t}\n\n\t/**\n\t * Tests {@code AnnotatedElementUtils#getMergedRepeatableAnnotations()} variants to ensure that\n\t * {@link AnnotationMetadata#getMergedRepeatableAnnotationAttributes(Class, Class, boolean)}\n\t * behaves the same.\n\t */\n\t@Test  // gh-31041\n\tvoid multipleComposedRepeatableAnnotationsUsingAnnotatedElementUtils() {\n\t\tClass<?> element = MultipleComposedRepeatableAnnotationsClass.class;\n\n\t\tSet<TestComponentScan> annotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(element, TestComponentScan.class);\n\t\tassertRepeatableAnnotations(annotations);\n\n\t\tannotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(element, TestComponentScan.class, TestComponentScans.class);\n\t\tassertRepeatableAnnotations(annotations);\n\t}\n\n\t/**\n\t * Tests {@code AnnotatedElementUtils#getMergedRepeatableAnnotations()} variants to ensure that\n\t * {@link AnnotationMetadata#getMergedRepeatableAnnotationAttributes(Class, Class, boolean)}\n\t * behaves the same.\n\t */\n\t@Test  // gh-31041\n\tvoid multipleRepeatableAnnotationsInContainersUsingAnnotatedElementUtils() {\n\t\tClass<?> element = MultipleRepeatableAnnotationsInContainersClass.class;\n\n\t\tSet<TestComponentScan> annotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(element, TestComponentScan.class);\n\t\tassertRepeatableAnnotations(annotations);\n\n\t\tannotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(element, TestComponentScan.class, TestComponentScans.class);\n\t\tassertRepeatableAnnotations(annotations);\n\t}\n\n\tprivate static void assertRepeatableAnnotations(AnnotationMetadata metadata) {\n\t\tSet<AnnotationAttributes> attributesSet =\n\t\t\t\tmetadata.getMergedRepeatableAnnotationAttributes(TestComponentScan.class, TestComponentScans.class, true);\n\t\tassertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"value\")).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"A\", \"B\", \"C\", \"D\");\n\t\tassertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"basePackages\")).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"A\", \"B\", \"C\", \"D\");\n\t\tassertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"basePackageClasses\")).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"java.lang.String\", \"java.lang.Integer\");\n\t}\n\n\tprivate static void assertRepeatableAnnotationsSortedByReversedMetaDistance(AnnotationMetadata metadata) {\n\t\t// Note: although the real @ComponentScan annotation is not looked up using\n\t\t// \"sortByReversedMetaDistance\" semantics, we can still use @TestComponentScan\n\t\t// to verify the expected behavior.\n\t\tSet<AnnotationAttributes> attributesSet =\n\t\t\t\tmetadata.getMergedRepeatableAnnotationAttributes(TestComponentScan.class, TestComponentScans.class, false, true);\n\t\tassertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"value\")).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"C\", \"D\", \"A\", \"B\");\n\t\tassertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"basePackages\")).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"C\", \"D\", \"A\", \"B\");\n\t}\n\n\tprivate static void assertRepeatableAnnotations(Set<TestComponentScan> annotations) {\n\t\tassertThat(annotations.stream().map(TestComponentScan::value).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"A\", \"B\", \"C\", \"D\");\n\t\tassertThat(annotations.stream().map(TestComponentScan::basePackages).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"A\", \"B\", \"C\", \"D\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(NamedComposedAnnotationExtended.class);\n\t\tassertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isTrue();\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(NamedComposedAnnotationExtended.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isFalse();\n\t}\n\n\n\tprivate void assertMultipleAnnotationsWithIdenticalAttributeNames(AnnotationMetadata metadata) {\n\t\tAnnotationAttributes attributes1 = (AnnotationAttributes) metadata.getAnnotationAttributes(\n\t\t\t\tNamedAnnotation1.class.getName(), false);\n\t\tString name1 = attributes1.getString(\"name\");\n\t\tassertThat(name1).as(\"name of NamedAnnotation1\").isEqualTo(\"name 1\");\n\n\t\tAnnotationAttributes attributes2 = (AnnotationAttributes) metadata.getAnnotationAttributes(\n\t\t\t\tNamedAnnotation2.class.getName(), false);\n\t\tString name2 = attributes2.getString(\"name\");\n\t\tassertThat(name2).as(\"name of NamedAnnotation2\").isEqualTo(\"name 2\");\n\n\t\tAnnotationAttributes attributes3 = (AnnotationAttributes) metadata.getAnnotationAttributes(\n\t\t\t\tNamedAnnotation3.class.getName(), false);\n\t\tString name3 = attributes3.getString(\"name\");\n\t\tassertThat(name3).as(\"name of NamedAnnotation3\").isEqualTo(\"name 3\");\n\t}\n\n\tprivate void doTestAnnotationInfo(AnnotationMetadata metadata) {\n\t\tassertThat(metadata.getClassName()).isEqualTo(AnnotatedComponent.class.getName());\n\t\tassertThat(metadata.isInterface()).isFalse();\n\t\tassertThat(metadata.isAnnotation()).isFalse();\n\t\tassertThat(metadata.isAbstract()).isFalse();\n\t\tassertThat(metadata.isConcrete()).isTrue();\n\t\tassertThat(metadata.hasSuperClass()).isTrue();\n\t\tassertThat(metadata.getSuperClassName()).isEqualTo(Object.class.getName());\n\t\tassertThat(metadata.getInterfaceNames()).hasSize(1);\n\t\tassertThat(metadata.getInterfaceNames()[0]).isEqualTo(Serializable.class.getName());\n\n\t\tassertThat(metadata.isAnnotated(Component.class.getName())).isTrue();\n\n\t\tassertThat(metadata.isAnnotated(NamedComposedAnnotation.class.getName())).isTrue();\n\n\t\tassertThat(metadata.hasAnnotation(Component.class.getName())).isTrue();\n\t\tassertThat(metadata.hasAnnotation(Scope.class.getName())).isTrue();\n\t\tassertThat(metadata.hasAnnotation(SpecialAttr.class.getName())).isTrue();\n\n\t\tassertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isTrue();\n\t\tassertThat(metadata.getAnnotationTypes()).containsExactlyInAnyOrder(\n\t\t\t\tComponent.class.getName(), Scope.class.getName(),\n\t\t\t\tSpecialAttr.class.getName(), DirectAnnotation.class.getName(),\n\t\t\t\tMetaMetaAnnotation.class.getName(), EnumSubclasses.class.getName(),\n\t\t\t\tNamedComposedAnnotation.class.getName());\n\n\t\tAnnotationAttributes compAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(Component.class.getName());\n\t\tassertThat(compAttrs).hasSize(1);\n\t\tassertThat(compAttrs.getString(\"value\")).isEqualTo(\"myName\");\n\t\tAnnotationAttributes scopeAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(Scope.class.getName());\n\t\tassertThat(scopeAttrs).hasSize(1);\n\t\tassertThat(scopeAttrs.getString(\"value\")).isEqualTo(\"myScope\");\n\n\t\tSet<MethodMetadata> methods = metadata.getAnnotatedMethods(DirectAnnotation.class.getName());\n\t\tMethodMetadata method = methods.iterator().next();\n\t\tassertThat(method.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\")).isEqualTo(\"direct\");\n\t\tassertThat(method.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"myValue\")).isEqualTo(\"direct\");\n\t\tList<Object> allMeta = method.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\");\n\t\tassertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(Arrays.asList(\"direct\", \"meta\")));\n\t\tallMeta = method.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"additional\");\n\t\tassertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(List.of(\"direct\")));\n\n\t\tassertThat(metadata.isAnnotated(IsAnnotatedAnnotation.class.getName())).isTrue();\n\n\t\t{ // perform tests with classValuesAsString = false (the default)\n\t\t\tAnnotationAttributes specialAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(SpecialAttr.class.getName());\n\t\t\tassertThat(specialAttrs).hasSize(6);\n\t\t\tassertThat(String.class.isAssignableFrom(specialAttrs.getClass(\"clazz\"))).isTrue();\n\t\t\tassertThat(specialAttrs.getEnum(\"state\").equals(Thread.State.NEW)).isTrue();\n\n\t\t\tAnnotationAttributes nestedAnno = specialAttrs.getAnnotation(\"nestedAnno\");\n\t\t\tassertThat(nestedAnno.getString(\"value\")).isEqualTo(\"na\");\n\t\t\tassertThat(nestedAnno.getEnum(\"anEnum\").equals(SomeEnum.LABEL1)).isTrue();\n\t\t\tassertThat((Class<?>[]) nestedAnno.get(\"classArray\")).isEqualTo(new Class<?>[] {String.class});\n\n\t\t\tAnnotationAttributes[] nestedAnnoArray = specialAttrs.getAnnotationArray(\"nestedAnnoArray\");\n\t\t\tassertThat(nestedAnnoArray).hasSize(2);\n\t\t\tassertThat(nestedAnnoArray[0].getString(\"value\")).isEqualTo(\"default\");\n\t\t\tassertThat(nestedAnnoArray[0].getEnum(\"anEnum\").equals(SomeEnum.DEFAULT)).isTrue();\n\t\t\tassertThat((Class<?>[]) nestedAnnoArray[0].get(\"classArray\")).isEqualTo(new Class<?>[] {Void.class});\n\t\t\tassertThat(nestedAnnoArray[1].getString(\"value\")).isEqualTo(\"na1\");\n\t\t\tassertThat(nestedAnnoArray[1].getEnum(\"anEnum\").equals(SomeEnum.LABEL2)).isTrue();\n\t\t\tassertThat((Class<?>[]) nestedAnnoArray[1].get(\"classArray\")).isEqualTo(new Class<?>[] {Number.class});\n\t\t\tassertThat(nestedAnnoArray[1].getClassArray(\"classArray\")).isEqualTo(new Class<?>[] {Number.class});\n\n\t\t\tAnnotationAttributes optional = specialAttrs.getAnnotation(\"optional\");\n\t\t\tassertThat(optional.getString(\"value\")).isEqualTo(\"optional\");\n\t\t\tassertThat(optional.getEnum(\"anEnum\").equals(SomeEnum.DEFAULT)).isTrue();\n\t\t\tassertThat((Class<?>[]) optional.get(\"classArray\")).isEqualTo(new Class<?>[] {Void.class});\n\t\t\tassertThat(optional.getClassArray(\"classArray\")).isEqualTo(new Class<?>[] {Void.class});\n\n\t\t\tAnnotationAttributes[] optionalArray = specialAttrs.getAnnotationArray(\"optionalArray\");\n\t\t\tassertThat(optionalArray).hasSize(1);\n\t\t\tassertThat(optionalArray[0].getString(\"value\")).isEqualTo(\"optional\");\n\t\t\tassertThat(optionalArray[0].getEnum(\"anEnum\").equals(SomeEnum.DEFAULT)).isTrue();\n\t\t\tassertThat((Class<?>[]) optionalArray[0].get(\"classArray\")).isEqualTo(new Class<?>[] {Void.class});\n\t\t\tassertThat(optionalArray[0].getClassArray(\"classArray\")).isEqualTo(new Class<?>[] {Void.class});\n\n\t\t\tassertThat(metadata.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\")).isEqualTo(\"direct\");\n\t\t\tallMeta = metadata.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\");\n\t\t\tassertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(Arrays.asList(\"direct\", \"meta\")));\n\t\t\tallMeta = metadata.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"additional\");\n\t\t\tassertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(Arrays.asList(\"direct\", \"\")));\n\t\t\tassertThat(metadata.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"additional\")).isEqualTo(\"\");\n\t\t\tassertThat(((String[]) metadata.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"additionalArray\"))).isEmpty();\n\t\t}\n\t\t{ // perform tests with classValuesAsString = true\n\t\t\tAnnotationAttributes specialAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(\n\t\t\t\tSpecialAttr.class.getName(), true);\n\t\t\tassertThat(specialAttrs).hasSize(6);\n\t\t\tassertThat(specialAttrs.get(\"clazz\")).isEqualTo(String.class.getName());\n\t\t\tassertThat(specialAttrs.getString(\"clazz\")).isEqualTo(String.class.getName());\n\n\t\t\tAnnotationAttributes nestedAnno = specialAttrs.getAnnotation(\"nestedAnno\");\n\t\t\tassertThat(nestedAnno.getStringArray(\"classArray\")).isEqualTo(new String[] { String.class.getName() });\n\t\t\tassertThat(nestedAnno.getStringArray(\"classArray\")).isEqualTo(new String[] { String.class.getName() });\n\n\t\t\tAnnotationAttributes[] nestedAnnoArray = specialAttrs.getAnnotationArray(\"nestedAnnoArray\");\n\t\t\tassertThat((String[]) nestedAnnoArray[0].get(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\t\t\tassertThat(nestedAnnoArray[0].getStringArray(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\t\t\tassertThat((String[]) nestedAnnoArray[1].get(\"classArray\")).isEqualTo(new String[] { Number.class.getName() });\n\t\t\tassertThat(nestedAnnoArray[1].getStringArray(\"classArray\")).isEqualTo(new String[] { Number.class.getName() });\n\n\t\t\tAnnotationAttributes optional = specialAttrs.getAnnotation(\"optional\");\n\t\t\tassertThat((String[]) optional.get(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\t\t\tassertThat(optional.getStringArray(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\n\t\t\tAnnotationAttributes[] optionalArray = specialAttrs.getAnnotationArray(\"optionalArray\");\n\t\t\tassertThat((String[]) optionalArray[0].get(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\t\t\tassertThat(optionalArray[0].getStringArray(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\n\t\t\tassertThat(metadata.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\")).isEqualTo(\"direct\");\n\t\t\tallMeta = metadata.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\");\n\t\t\tassertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(Arrays.asList(\"direct\", \"meta\")));\n\t\t}\n\t}\n\n\tprivate void doTestMethodAnnotationInfo(AnnotationMetadata classMetadata) {\n\t\tassertThat(classMetadata.getDeclaredMethods()).hasSize(3);\n\t\tSet<MethodMetadata> methods = classMetadata.getAnnotatedMethods(TestAutowired.class.getName());\n\t\tassertThat(methods).hasSize(1);\n\t\tfor (MethodMetadata methodMetadata : methods) {\n\t\t\tassertThat(methodMetadata.isAnnotated(TestAutowired.class.getName())).isTrue();\n\t\t}\n\t}\n\n\n\t// -------------------------------------------------------------------------\n\n\tpublic enum SomeEnum {\n\t\tLABEL1, LABEL2, DEFAULT\n\t}\n\n\t@Target({})\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface NestedAnno {\n\n\t\tString value() default \"default\";\n\n\t\tSomeEnum anEnum() default SomeEnum.DEFAULT;\n\n\t\tClass<?>[] classArray() default Void.class;\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface SpecialAttr {\n\n\t\tClass<?> clazz();\n\n\t\tThread.State state();\n\n\t\tNestedAnno nestedAnno();\n\n\t\tNestedAnno[] nestedAnnoArray();\n\n\t\tNestedAnno optional() default @NestedAnno(value = \"optional\", anEnum = SomeEnum.DEFAULT, classArray = Void.class);\n\n\t\tNestedAnno[] optionalArray() default { @NestedAnno(value = \"optional\", anEnum = SomeEnum.DEFAULT, classArray = Void.class) };\n\t}\n\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface DirectAnnotation {\n\n\t\t@AliasFor(\"myValue\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString myValue() default \"\";\n\n\t\tString additional() default \"direct\";\n\n\t\tString[] additionalArray() default \"direct\";\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface IsAnnotatedAnnotation {\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DirectAnnotation(\"meta\")\n\t@IsAnnotatedAnnotation\n\tpublic @interface MetaAnnotation {\n\n\t\tString additional() default \"meta\";\n\t}\n\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@MetaAnnotation\n\tpublic @interface MetaMetaAnnotation {\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface EnumSubclasses {\n\n\t\tSubclassEnum[] value();\n\t}\n\n\t// SPR-10914\n\tpublic enum SubclassEnum {\n\t\tFOO {\n\t\t/* Do not delete! This subclassing is intentional. */\n\t\t},\n\t\tBAR {\n\t\t/* Do not delete! This subclassing is intentional. */\n\t\t}\n\t}\n\n\t@Component(\"myName\")\n\t@Scope(\"myScope\")\n\t@SpecialAttr(clazz = String.class, state = Thread.State.NEW,\n\t\t\tnestedAnno = @NestedAnno(value = \"na\", anEnum = SomeEnum.LABEL1, classArray = {String.class}),\n\t\t\tnestedAnnoArray = {@NestedAnno, @NestedAnno(value = \"na1\", anEnum = SomeEnum.LABEL2, classArray = {Number.class})})\n\t@SuppressWarnings({\"serial\", \"unused\"})\n\t@DirectAnnotation(value = \"direct\", additional = \"\", additionalArray = {})\n\t@MetaMetaAnnotation\n\t@EnumSubclasses({SubclassEnum.FOO, SubclassEnum.BAR})\n\t@NamedComposedAnnotation\n\tprivate static class AnnotatedComponent implements Serializable {\n\n\t\tpublic AnnotatedComponent() {\n\t\t}\n\n\t\t@TestAutowired\n\t\tpublic void doWork(@TestQualifier(\"myColor\") java.awt.Color color) {\n\t\t}\n\n\t\tpublic void doSleep() {\n\t\t}\n\n\t\t@DirectAnnotation(\"direct\")\n\t\t@MetaMetaAnnotation\n\t\tpublic void meta() {\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"serial\")\n\tprivate static class AnnotatedComponentSubClass extends AnnotatedComponent {\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Component\n\tpublic @interface TestConfiguration {\n\n\t\tString value() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface TestComponentScans {\n\n\t\tTestComponentScan[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@Repeatable(TestComponentScans.class)\n\tpublic @interface TestComponentScan {\n\n\t\t@AliasFor(\"basePackages\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] basePackages() default {};\n\n\t\tClass<?>[] basePackageClasses() default {};\n\t}\n\n\t@TestConfiguration\n\t@TestComponentScan(basePackages = \"bogus\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface ComposedConfigurationWithAttributeOverrides {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = TestComponentScan.class)\n\t\tString[] basePackages() default {};\n\t}\n\n\t@ComposedConfigurationWithAttributeOverrides(basePackages = \"org.example.componentscan\")\n\tpublic static class ComposedConfigurationWithAttributeOverridesClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@TestComponentScan(\"C\")\n\tpublic @interface ScanPackageC {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@TestComponentScan(\"D\")\n\tpublic @interface ScanPackageD {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@TestComponentScans({\n\t\t@TestComponentScan(\"C\"),\n\t\t@TestComponentScan(\"D\")\n\t})\n\tpublic @interface ScanPackagesCandD {\n\t}\n\n\t@TestComponentScan(basePackages = \"A\", basePackageClasses = String.class)\n\t@ScanPackageC\n\t@ScanPackageD\n\t@TestComponentScan(basePackages = \"B\", basePackageClasses = Integer.class)\n\tstatic class MultipleComposedRepeatableAnnotationsClass {\n\t}\n\n\t@TestComponentScan(basePackages = \"A\", basePackageClasses = String.class)\n\t@ScanPackagesCandD\n\t@TestComponentScans(@TestComponentScan(basePackages = \"B\", basePackageClasses = Integer.class))\n\tstatic class MultipleRepeatableAnnotationsInContainersClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface NamedAnnotation1 {\n\t\tString name() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface NamedAnnotation2 {\n\t\tString name() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface NamedAnnotation3 {\n\t\tString name() default \"\";\n\t}\n\n\t@NamedAnnotation1(name = \"name 1\")\n\t@NamedAnnotation2(name = \"name 2\")\n\t@NamedAnnotation3(name = \"name 3\")\n\tpublic static class NamedAnnotationsClass {\n\t}\n\n\t@NamedAnnotation1(name = \"name 1\")\n\t@NamedAnnotation2(name = \"name 2\")\n\t@NamedAnnotation3(name = \"name 3\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@Inherited\n\tpublic @interface NamedComposedAnnotation {\n\t}\n\n\t@NamedComposedAnnotation\n\tpublic static class NamedComposedAnnotationClass {\n\t}\n\n\tpublic static class NamedComposedAnnotationExtended extends NamedComposedAnnotationClass {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.type",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.type.MultipleComposedRepeatableAnnotationsClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.type.MultipleComposedRepeatableAnnotationsClass",
    "headType": "class",
    "relation": "use",
    "tail": "@TestComponentScan",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.type.MultipleComposedRepeatableAnnotationsClass",
    "headType": "class",
    "relation": "use",
    "tail": "@ScanPackageC",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.type.MultipleComposedRepeatableAnnotationsClass",
    "headType": "class",
    "relation": "use",
    "tail": "@ScanPackageD",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.type.MultipleComposedRepeatableAnnotationsClass",
    "headType": "class",
    "relation": "use",
    "tail": "@TestComponentScan",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.type.MultipleComposedRepeatableAnnotationsClass",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.type;\n\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.AliasFor;\nimport org.springframework.core.annotation.AnnotatedElementUtils;\nimport org.springframework.core.annotation.AnnotationAttributes;\nimport org.springframework.core.testfixture.stereotype.Component;\nimport org.springframework.core.type.classreading.MetadataReader;\nimport org.springframework.core.type.classreading.MetadataReaderFactory;\nimport org.springframework.core.type.classreading.SimpleMetadataReaderFactory;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Unit tests demonstrating that the reflection-based {@link StandardAnnotationMetadata}\n * and ASM-based {@code SimpleAnnotationMetadata} produce <em>almost</em> identical output.\n *\n * @author Juergen Hoeller\n * @author Chris Beams\n * @author Phillip Webb\n * @author Sam Brannen\n * @see InheritedAnnotationsAnnotationMetadataTests\n */\nclass AnnotationMetadataTests {\n\n\t@Test\n\tvoid standardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(AnnotatedComponent.class);\n\t\tdoTestAnnotationInfo(metadata);\n\t\tdoTestMethodAnnotationInfo(metadata);\n\t}\n\n\t@Test\n\tvoid asmAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(AnnotatedComponent.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tdoTestAnnotationInfo(metadata);\n\t\tdoTestMethodAnnotationInfo(metadata);\n\t}\n\n\t@Test\n\tvoid standardAnnotationMetadataForSubclass() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(AnnotatedComponentSubClass.class);\n\t\tdoTestSubClassAnnotationInfo(metadata, false);\n\t}\n\n\t@Test\n\tvoid asmAnnotationMetadataForSubclass() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(AnnotatedComponentSubClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tdoTestSubClassAnnotationInfo(metadata, true);\n\t}\n\n\tprivate void doTestSubClassAnnotationInfo(AnnotationMetadata metadata, boolean asm) {\n\t\tassertThat(metadata.getClassName()).isEqualTo(AnnotatedComponentSubClass.class.getName());\n\t\tassertThat(metadata.isInterface()).isFalse();\n\t\tassertThat(metadata.isAnnotation()).isFalse();\n\t\tassertThat(metadata.isAbstract()).isFalse();\n\t\tassertThat(metadata.isConcrete()).isTrue();\n\t\tassertThat(metadata.hasSuperClass()).isTrue();\n\t\tassertThat(metadata.getSuperClassName()).isEqualTo(AnnotatedComponent.class.getName());\n\t\tassertThat(metadata.getInterfaceNames()).isEmpty();\n\t\tassertThat(metadata.isAnnotated(Component.class.getName())).isFalse();\n\t\tassertThat(metadata.isAnnotated(Scope.class.getName())).isFalse();\n\t\tassertThat(metadata.isAnnotated(SpecialAttr.class.getName())).isFalse();\n\n\t\tif (asm) {\n\t\t\tassertThat(metadata.isAnnotated(NamedComposedAnnotation.class.getName())).isFalse();\n\t\t\tassertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isFalse();\n\t\t\tassertThat(metadata.getAnnotationTypes()).isEmpty();\n\t\t}\n\t\telse {\n\t\t\tassertThat(metadata.isAnnotated(NamedComposedAnnotation.class.getName())).isTrue();\n\t\t\tassertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isTrue();\n\t\t\tassertThat(metadata.getAnnotationTypes()).containsExactly(NamedComposedAnnotation.class.getName());\n\t\t}\n\n\t\tassertThat(metadata.hasAnnotation(Component.class.getName())).isFalse();\n\t\tassertThat(metadata.hasAnnotation(Scope.class.getName())).isFalse();\n\t\tassertThat(metadata.hasAnnotation(SpecialAttr.class.getName())).isFalse();\n\t\tassertThat(metadata.hasMetaAnnotation(Component.class.getName())).isFalse();\n\t\tassertThat(metadata.hasMetaAnnotation(MetaAnnotation.class.getName())).isFalse();\n\t\tassertThat(metadata.getAnnotationAttributes(Component.class.getName())).isNull();\n\t\tassertThat(metadata.getAnnotationAttributes(MetaAnnotation.class.getName(), false)).isNull();\n\t\tassertThat(metadata.getAnnotationAttributes(MetaAnnotation.class.getName(), true)).isNull();\n\t\tassertThat(metadata.getAnnotatedMethods(DirectAnnotation.class.getName())).isEmpty();\n\t\tassertThat(metadata.isAnnotated(IsAnnotatedAnnotation.class.getName())).isFalse();\n\t\tassertThat(metadata.getAllAnnotationAttributes(DirectAnnotation.class.getName())).isNull();\n\t}\n\n\t@Test\n\tvoid standardAnnotationMetadataForInterface() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(AnnotationMetadata.class);\n\t\tdoTestMetadataForInterfaceClass(metadata);\n\t}\n\n\t@Test\n\tvoid asmAnnotationMetadataForInterface() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(AnnotationMetadata.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tdoTestMetadataForInterfaceClass(metadata);\n\t}\n\n\tprivate void doTestMetadataForInterfaceClass(AnnotationMetadata metadata) {\n\t\tassertThat(metadata.getClassName()).isEqualTo(AnnotationMetadata.class.getName());\n\t\tassertThat(metadata.isInterface()).isTrue();\n\t\tassertThat(metadata.isAnnotation()).isFalse();\n\t\tassertThat(metadata.isAbstract()).isTrue();\n\t\tassertThat(metadata.isConcrete()).isFalse();\n\t\tassertThat(metadata.hasSuperClass()).isFalse();\n\t\tassertThat(metadata.getSuperClassName()).isNull();\n\t\tassertThat(metadata.getInterfaceNames()).hasSize(2);\n\t\tassertThat(metadata.getInterfaceNames()[0]).isEqualTo(ClassMetadata.class.getName());\n\t\tassertThat(metadata.getInterfaceNames()[1]).isEqualTo(AnnotatedTypeMetadata.class.getName());\n\t\tassertThat(metadata.getAnnotationTypes()).isEmpty();\n\t}\n\n\t@Test\n\tvoid standardAnnotationMetadataForAnnotation() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(Component.class);\n\t\tdoTestMetadataForAnnotationClass(metadata);\n\t}\n\n\t@Test\n\tvoid asmAnnotationMetadataForAnnotation() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(Component.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tdoTestMetadataForAnnotationClass(metadata);\n\t}\n\n\tprivate void doTestMetadataForAnnotationClass(AnnotationMetadata metadata) {\n\t\tassertThat(metadata.getClassName()).isEqualTo(Component.class.getName());\n\t\tassertThat(metadata.isInterface()).isTrue();\n\t\tassertThat(metadata.isAnnotation()).isTrue();\n\t\tassertThat(metadata.isAbstract()).isTrue();\n\t\tassertThat(metadata.isConcrete()).isFalse();\n\t\tassertThat(metadata.hasSuperClass()).isFalse();\n\t\tassertThat(metadata.getSuperClassName()).isNull();\n\t\tassertThat(metadata.getInterfaceNames()).hasSize(1);\n\t\tassertThat(metadata.getInterfaceNames()[0]).isEqualTo(Annotation.class.getName());\n\t\tassertThat(metadata.isAnnotated(Documented.class.getName())).isFalse();\n\t\tassertThat(metadata.isAnnotated(Scope.class.getName())).isFalse();\n\t\tassertThat(metadata.isAnnotated(SpecialAttr.class.getName())).isFalse();\n\t\tassertThat(metadata.hasAnnotation(Documented.class.getName())).isFalse();\n\t\tassertThat(metadata.hasAnnotation(Scope.class.getName())).isFalse();\n\t\tassertThat(metadata.hasAnnotation(SpecialAttr.class.getName())).isFalse();\n\t\tassertThat(metadata.getAnnotationTypes()).hasSize(1);\n\t}\n\n\t/**\n\t * In order to preserve backward-compatibility, {@link StandardAnnotationMetadata}\n\t * defaults to return nested annotations and annotation arrays as actual\n\t * Annotation instances. It is recommended for compatibility with ASM-based\n\t * AnnotationMetadata implementations to set the 'nestedAnnotationsAsMap' flag to\n\t * 'true' as is done in the main test above.\n\t */\n\t@Test\n\tvoid standardAnnotationMetadata_nestedAnnotationsAsMap_false() {\n\t\t@SuppressWarnings(\"deprecation\")\n\t\tAnnotationMetadata metadata = new StandardAnnotationMetadata(AnnotatedComponent.class);\n\t\tAnnotationAttributes specialAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(SpecialAttr.class.getName());\n\t\tAnnotation[] nestedAnnoArray = (Annotation[]) specialAttrs.get(\"nestedAnnoArray\");\n\t\tassertThat(nestedAnnoArray[0]).isInstanceOf(NestedAnno.class);\n\t}\n\n\t@Test\n\tvoid metaAnnotationOverridesUsingStandardAnnotationMetadata() {\n\t\t@SuppressWarnings(\"deprecation\")\n\t\tAnnotationMetadata metadata = new StandardAnnotationMetadata(ComposedConfigurationWithAttributeOverridesClass.class);\n\t\tassertMetaAnnotationOverrides(metadata);\n\t}\n\n\t@Test\n\tvoid metaAnnotationOverridesUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(ComposedConfigurationWithAttributeOverridesClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertMetaAnnotationOverrides(metadata);\n\t}\n\n\tprivate void assertMetaAnnotationOverrides(AnnotationMetadata metadata) {\n\t\tAnnotationAttributes attributes = (AnnotationAttributes) metadata.getAnnotationAttributes(\n\t\t\t\tTestComponentScan.class.getName(), false);\n\t\tassertThat(attributes.getStringArray(\"value\")).containsExactly(\"org.example.componentscan\");\n\t\tassertThat(attributes.getStringArray(\"basePackages\")).containsExactly(\"org.example.componentscan\");\n\t\tassertThat(attributes.getClassArray(\"basePackageClasses\")).isEmpty();\n\t}\n\n\t@Test  // SPR-11649\n\tvoid multipleAnnotationsWithIdenticalAttributeNamesUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(NamedAnnotationsClass.class);\n\t\tassertMultipleAnnotationsWithIdenticalAttributeNames(metadata);\n\t}\n\n\t@Test  // SPR-11649\n\tvoid multipleAnnotationsWithIdenticalAttributeNamesUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(NamedAnnotationsClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertMultipleAnnotationsWithIdenticalAttributeNames(metadata);\n\t}\n\n\t@Test  // SPR-11649\n\tvoid composedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(NamedComposedAnnotationClass.class);\n\t\tassertMultipleAnnotationsWithIdenticalAttributeNames(metadata);\n\t}\n\n\t@Test  // SPR-11649\n\tvoid composedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(NamedComposedAnnotationClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertMultipleAnnotationsWithIdenticalAttributeNames(metadata);\n\t}\n\n\t@Test  // gh-31041\n\tvoid multipleComposedRepeatableAnnotationsUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(MultipleComposedRepeatableAnnotationsClass.class);\n\t\tassertRepeatableAnnotations(metadata);\n\t}\n\n\t@Test  // gh-31041\n\tvoid multipleComposedRepeatableAnnotationsUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(MultipleComposedRepeatableAnnotationsClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertRepeatableAnnotations(metadata);\n\t}\n\n\t@Test  // gh-31074\n\tvoid multipleComposedRepeatableAnnotationsSortedByReversedMetaDistanceUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(MultipleComposedRepeatableAnnotationsClass.class);\n\t\tassertRepeatableAnnotationsSortedByReversedMetaDistance(metadata);\n\t}\n\n\t@Test  // gh-31074\n\tvoid multipleComposedRepeatableAnnotationsSortedByReversedMetaDistanceUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(MultipleComposedRepeatableAnnotationsClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertRepeatableAnnotationsSortedByReversedMetaDistance(metadata);\n\t}\n\n\t@Test  // gh-31041\n\tvoid multipleRepeatableAnnotationsInContainersUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(MultipleRepeatableAnnotationsInContainersClass.class);\n\t\tassertRepeatableAnnotations(metadata);\n\t}\n\n\t@Test  // gh-31041\n\tvoid multipleRepeatableAnnotationsInContainersUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(MultipleRepeatableAnnotationsInContainersClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertRepeatableAnnotations(metadata);\n\t}\n\n\t/**\n\t * Tests {@code AnnotatedElementUtils#getMergedRepeatableAnnotations()} variants to ensure that\n\t * {@link AnnotationMetadata#getMergedRepeatableAnnotationAttributes(Class, Class, boolean)}\n\t * behaves the same.\n\t */\n\t@Test  // gh-31041\n\tvoid multipleComposedRepeatableAnnotationsUsingAnnotatedElementUtils() {\n\t\tClass<?> element = MultipleComposedRepeatableAnnotationsClass.class;\n\n\t\tSet<TestComponentScan> annotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(element, TestComponentScan.class);\n\t\tassertRepeatableAnnotations(annotations);\n\n\t\tannotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(element, TestComponentScan.class, TestComponentScans.class);\n\t\tassertRepeatableAnnotations(annotations);\n\t}\n\n\t/**\n\t * Tests {@code AnnotatedElementUtils#getMergedRepeatableAnnotations()} variants to ensure that\n\t * {@link AnnotationMetadata#getMergedRepeatableAnnotationAttributes(Class, Class, boolean)}\n\t * behaves the same.\n\t */\n\t@Test  // gh-31041\n\tvoid multipleRepeatableAnnotationsInContainersUsingAnnotatedElementUtils() {\n\t\tClass<?> element = MultipleRepeatableAnnotationsInContainersClass.class;\n\n\t\tSet<TestComponentScan> annotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(element, TestComponentScan.class);\n\t\tassertRepeatableAnnotations(annotations);\n\n\t\tannotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(element, TestComponentScan.class, TestComponentScans.class);\n\t\tassertRepeatableAnnotations(annotations);\n\t}\n\n\tprivate static void assertRepeatableAnnotations(AnnotationMetadata metadata) {\n\t\tSet<AnnotationAttributes> attributesSet =\n\t\t\t\tmetadata.getMergedRepeatableAnnotationAttributes(TestComponentScan.class, TestComponentScans.class, true);\n\t\tassertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"value\")).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"A\", \"B\", \"C\", \"D\");\n\t\tassertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"basePackages\")).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"A\", \"B\", \"C\", \"D\");\n\t\tassertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"basePackageClasses\")).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"java.lang.String\", \"java.lang.Integer\");\n\t}\n\n\tprivate static void assertRepeatableAnnotationsSortedByReversedMetaDistance(AnnotationMetadata metadata) {\n\t\t// Note: although the real @ComponentScan annotation is not looked up using\n\t\t// \"sortByReversedMetaDistance\" semantics, we can still use @TestComponentScan\n\t\t// to verify the expected behavior.\n\t\tSet<AnnotationAttributes> attributesSet =\n\t\t\t\tmetadata.getMergedRepeatableAnnotationAttributes(TestComponentScan.class, TestComponentScans.class, false, true);\n\t\tassertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"value\")).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"C\", \"D\", \"A\", \"B\");\n\t\tassertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"basePackages\")).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"C\", \"D\", \"A\", \"B\");\n\t}\n\n\tprivate static void assertRepeatableAnnotations(Set<TestComponentScan> annotations) {\n\t\tassertThat(annotations.stream().map(TestComponentScan::value).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"A\", \"B\", \"C\", \"D\");\n\t\tassertThat(annotations.stream().map(TestComponentScan::basePackages).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"A\", \"B\", \"C\", \"D\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(NamedComposedAnnotationExtended.class);\n\t\tassertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isTrue();\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(NamedComposedAnnotationExtended.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isFalse();\n\t}\n\n\n\tprivate void assertMultipleAnnotationsWithIdenticalAttributeNames(AnnotationMetadata metadata) {\n\t\tAnnotationAttributes attributes1 = (AnnotationAttributes) metadata.getAnnotationAttributes(\n\t\t\t\tNamedAnnotation1.class.getName(), false);\n\t\tString name1 = attributes1.getString(\"name\");\n\t\tassertThat(name1).as(\"name of NamedAnnotation1\").isEqualTo(\"name 1\");\n\n\t\tAnnotationAttributes attributes2 = (AnnotationAttributes) metadata.getAnnotationAttributes(\n\t\t\t\tNamedAnnotation2.class.getName(), false);\n\t\tString name2 = attributes2.getString(\"name\");\n\t\tassertThat(name2).as(\"name of NamedAnnotation2\").isEqualTo(\"name 2\");\n\n\t\tAnnotationAttributes attributes3 = (AnnotationAttributes) metadata.getAnnotationAttributes(\n\t\t\t\tNamedAnnotation3.class.getName(), false);\n\t\tString name3 = attributes3.getString(\"name\");\n\t\tassertThat(name3).as(\"name of NamedAnnotation3\").isEqualTo(\"name 3\");\n\t}\n\n\tprivate void doTestAnnotationInfo(AnnotationMetadata metadata) {\n\t\tassertThat(metadata.getClassName()).isEqualTo(AnnotatedComponent.class.getName());\n\t\tassertThat(metadata.isInterface()).isFalse();\n\t\tassertThat(metadata.isAnnotation()).isFalse();\n\t\tassertThat(metadata.isAbstract()).isFalse();\n\t\tassertThat(metadata.isConcrete()).isTrue();\n\t\tassertThat(metadata.hasSuperClass()).isTrue();\n\t\tassertThat(metadata.getSuperClassName()).isEqualTo(Object.class.getName());\n\t\tassertThat(metadata.getInterfaceNames()).hasSize(1);\n\t\tassertThat(metadata.getInterfaceNames()[0]).isEqualTo(Serializable.class.getName());\n\n\t\tassertThat(metadata.isAnnotated(Component.class.getName())).isTrue();\n\n\t\tassertThat(metadata.isAnnotated(NamedComposedAnnotation.class.getName())).isTrue();\n\n\t\tassertThat(metadata.hasAnnotation(Component.class.getName())).isTrue();\n\t\tassertThat(metadata.hasAnnotation(Scope.class.getName())).isTrue();\n\t\tassertThat(metadata.hasAnnotation(SpecialAttr.class.getName())).isTrue();\n\n\t\tassertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isTrue();\n\t\tassertThat(metadata.getAnnotationTypes()).containsExactlyInAnyOrder(\n\t\t\t\tComponent.class.getName(), Scope.class.getName(),\n\t\t\t\tSpecialAttr.class.getName(), DirectAnnotation.class.getName(),\n\t\t\t\tMetaMetaAnnotation.class.getName(), EnumSubclasses.class.getName(),\n\t\t\t\tNamedComposedAnnotation.class.getName());\n\n\t\tAnnotationAttributes compAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(Component.class.getName());\n\t\tassertThat(compAttrs).hasSize(1);\n\t\tassertThat(compAttrs.getString(\"value\")).isEqualTo(\"myName\");\n\t\tAnnotationAttributes scopeAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(Scope.class.getName());\n\t\tassertThat(scopeAttrs).hasSize(1);\n\t\tassertThat(scopeAttrs.getString(\"value\")).isEqualTo(\"myScope\");\n\n\t\tSet<MethodMetadata> methods = metadata.getAnnotatedMethods(DirectAnnotation.class.getName());\n\t\tMethodMetadata method = methods.iterator().next();\n\t\tassertThat(method.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\")).isEqualTo(\"direct\");\n\t\tassertThat(method.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"myValue\")).isEqualTo(\"direct\");\n\t\tList<Object> allMeta = method.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\");\n\t\tassertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(Arrays.asList(\"direct\", \"meta\")));\n\t\tallMeta = method.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"additional\");\n\t\tassertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(List.of(\"direct\")));\n\n\t\tassertThat(metadata.isAnnotated(IsAnnotatedAnnotation.class.getName())).isTrue();\n\n\t\t{ // perform tests with classValuesAsString = false (the default)\n\t\t\tAnnotationAttributes specialAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(SpecialAttr.class.getName());\n\t\t\tassertThat(specialAttrs).hasSize(6);\n\t\t\tassertThat(String.class.isAssignableFrom(specialAttrs.getClass(\"clazz\"))).isTrue();\n\t\t\tassertThat(specialAttrs.getEnum(\"state\").equals(Thread.State.NEW)).isTrue();\n\n\t\t\tAnnotationAttributes nestedAnno = specialAttrs.getAnnotation(\"nestedAnno\");\n\t\t\tassertThat(nestedAnno.getString(\"value\")).isEqualTo(\"na\");\n\t\t\tassertThat(nestedAnno.getEnum(\"anEnum\").equals(SomeEnum.LABEL1)).isTrue();\n\t\t\tassertThat((Class<?>[]) nestedAnno.get(\"classArray\")).isEqualTo(new Class<?>[] {String.class});\n\n\t\t\tAnnotationAttributes[] nestedAnnoArray = specialAttrs.getAnnotationArray(\"nestedAnnoArray\");\n\t\t\tassertThat(nestedAnnoArray).hasSize(2);\n\t\t\tassertThat(nestedAnnoArray[0].getString(\"value\")).isEqualTo(\"default\");\n\t\t\tassertThat(nestedAnnoArray[0].getEnum(\"anEnum\").equals(SomeEnum.DEFAULT)).isTrue();\n\t\t\tassertThat((Class<?>[]) nestedAnnoArray[0].get(\"classArray\")).isEqualTo(new Class<?>[] {Void.class});\n\t\t\tassertThat(nestedAnnoArray[1].getString(\"value\")).isEqualTo(\"na1\");\n\t\t\tassertThat(nestedAnnoArray[1].getEnum(\"anEnum\").equals(SomeEnum.LABEL2)).isTrue();\n\t\t\tassertThat((Class<?>[]) nestedAnnoArray[1].get(\"classArray\")).isEqualTo(new Class<?>[] {Number.class});\n\t\t\tassertThat(nestedAnnoArray[1].getClassArray(\"classArray\")).isEqualTo(new Class<?>[] {Number.class});\n\n\t\t\tAnnotationAttributes optional = specialAttrs.getAnnotation(\"optional\");\n\t\t\tassertThat(optional.getString(\"value\")).isEqualTo(\"optional\");\n\t\t\tassertThat(optional.getEnum(\"anEnum\").equals(SomeEnum.DEFAULT)).isTrue();\n\t\t\tassertThat((Class<?>[]) optional.get(\"classArray\")).isEqualTo(new Class<?>[] {Void.class});\n\t\t\tassertThat(optional.getClassArray(\"classArray\")).isEqualTo(new Class<?>[] {Void.class});\n\n\t\t\tAnnotationAttributes[] optionalArray = specialAttrs.getAnnotationArray(\"optionalArray\");\n\t\t\tassertThat(optionalArray).hasSize(1);\n\t\t\tassertThat(optionalArray[0].getString(\"value\")).isEqualTo(\"optional\");\n\t\t\tassertThat(optionalArray[0].getEnum(\"anEnum\").equals(SomeEnum.DEFAULT)).isTrue();\n\t\t\tassertThat((Class<?>[]) optionalArray[0].get(\"classArray\")).isEqualTo(new Class<?>[] {Void.class});\n\t\t\tassertThat(optionalArray[0].getClassArray(\"classArray\")).isEqualTo(new Class<?>[] {Void.class});\n\n\t\t\tassertThat(metadata.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\")).isEqualTo(\"direct\");\n\t\t\tallMeta = metadata.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\");\n\t\t\tassertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(Arrays.asList(\"direct\", \"meta\")));\n\t\t\tallMeta = metadata.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"additional\");\n\t\t\tassertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(Arrays.asList(\"direct\", \"\")));\n\t\t\tassertThat(metadata.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"additional\")).isEqualTo(\"\");\n\t\t\tassertThat(((String[]) metadata.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"additionalArray\"))).isEmpty();\n\t\t}\n\t\t{ // perform tests with classValuesAsString = true\n\t\t\tAnnotationAttributes specialAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(\n\t\t\t\tSpecialAttr.class.getName(), true);\n\t\t\tassertThat(specialAttrs).hasSize(6);\n\t\t\tassertThat(specialAttrs.get(\"clazz\")).isEqualTo(String.class.getName());\n\t\t\tassertThat(specialAttrs.getString(\"clazz\")).isEqualTo(String.class.getName());\n\n\t\t\tAnnotationAttributes nestedAnno = specialAttrs.getAnnotation(\"nestedAnno\");\n\t\t\tassertThat(nestedAnno.getStringArray(\"classArray\")).isEqualTo(new String[] { String.class.getName() });\n\t\t\tassertThat(nestedAnno.getStringArray(\"classArray\")).isEqualTo(new String[] { String.class.getName() });\n\n\t\t\tAnnotationAttributes[] nestedAnnoArray = specialAttrs.getAnnotationArray(\"nestedAnnoArray\");\n\t\t\tassertThat((String[]) nestedAnnoArray[0].get(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\t\t\tassertThat(nestedAnnoArray[0].getStringArray(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\t\t\tassertThat((String[]) nestedAnnoArray[1].get(\"classArray\")).isEqualTo(new String[] { Number.class.getName() });\n\t\t\tassertThat(nestedAnnoArray[1].getStringArray(\"classArray\")).isEqualTo(new String[] { Number.class.getName() });\n\n\t\t\tAnnotationAttributes optional = specialAttrs.getAnnotation(\"optional\");\n\t\t\tassertThat((String[]) optional.get(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\t\t\tassertThat(optional.getStringArray(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\n\t\t\tAnnotationAttributes[] optionalArray = specialAttrs.getAnnotationArray(\"optionalArray\");\n\t\t\tassertThat((String[]) optionalArray[0].get(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\t\t\tassertThat(optionalArray[0].getStringArray(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\n\t\t\tassertThat(metadata.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\")).isEqualTo(\"direct\");\n\t\t\tallMeta = metadata.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\");\n\t\t\tassertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(Arrays.asList(\"direct\", \"meta\")));\n\t\t}\n\t}\n\n\tprivate void doTestMethodAnnotationInfo(AnnotationMetadata classMetadata) {\n\t\tassertThat(classMetadata.getDeclaredMethods()).hasSize(3);\n\t\tSet<MethodMetadata> methods = classMetadata.getAnnotatedMethods(TestAutowired.class.getName());\n\t\tassertThat(methods).hasSize(1);\n\t\tfor (MethodMetadata methodMetadata : methods) {\n\t\t\tassertThat(methodMetadata.isAnnotated(TestAutowired.class.getName())).isTrue();\n\t\t}\n\t}\n\n\n\t// -------------------------------------------------------------------------\n\n\tpublic enum SomeEnum {\n\t\tLABEL1, LABEL2, DEFAULT\n\t}\n\n\t@Target({})\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface NestedAnno {\n\n\t\tString value() default \"default\";\n\n\t\tSomeEnum anEnum() default SomeEnum.DEFAULT;\n\n\t\tClass<?>[] classArray() default Void.class;\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface SpecialAttr {\n\n\t\tClass<?> clazz();\n\n\t\tThread.State state();\n\n\t\tNestedAnno nestedAnno();\n\n\t\tNestedAnno[] nestedAnnoArray();\n\n\t\tNestedAnno optional() default @NestedAnno(value = \"optional\", anEnum = SomeEnum.DEFAULT, classArray = Void.class);\n\n\t\tNestedAnno[] optionalArray() default { @NestedAnno(value = \"optional\", anEnum = SomeEnum.DEFAULT, classArray = Void.class) };\n\t}\n\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface DirectAnnotation {\n\n\t\t@AliasFor(\"myValue\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString myValue() default \"\";\n\n\t\tString additional() default \"direct\";\n\n\t\tString[] additionalArray() default \"direct\";\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface IsAnnotatedAnnotation {\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DirectAnnotation(\"meta\")\n\t@IsAnnotatedAnnotation\n\tpublic @interface MetaAnnotation {\n\n\t\tString additional() default \"meta\";\n\t}\n\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@MetaAnnotation\n\tpublic @interface MetaMetaAnnotation {\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface EnumSubclasses {\n\n\t\tSubclassEnum[] value();\n\t}\n\n\t// SPR-10914\n\tpublic enum SubclassEnum {\n\t\tFOO {\n\t\t/* Do not delete! This subclassing is intentional. */\n\t\t},\n\t\tBAR {\n\t\t/* Do not delete! This subclassing is intentional. */\n\t\t}\n\t}\n\n\t@Component(\"myName\")\n\t@Scope(\"myScope\")\n\t@SpecialAttr(clazz = String.class, state = Thread.State.NEW,\n\t\t\tnestedAnno = @NestedAnno(value = \"na\", anEnum = SomeEnum.LABEL1, classArray = {String.class}),\n\t\t\tnestedAnnoArray = {@NestedAnno, @NestedAnno(value = \"na1\", anEnum = SomeEnum.LABEL2, classArray = {Number.class})})\n\t@SuppressWarnings({\"serial\", \"unused\"})\n\t@DirectAnnotation(value = \"direct\", additional = \"\", additionalArray = {})\n\t@MetaMetaAnnotation\n\t@EnumSubclasses({SubclassEnum.FOO, SubclassEnum.BAR})\n\t@NamedComposedAnnotation\n\tprivate static class AnnotatedComponent implements Serializable {\n\n\t\tpublic AnnotatedComponent() {\n\t\t}\n\n\t\t@TestAutowired\n\t\tpublic void doWork(@TestQualifier(\"myColor\") java.awt.Color color) {\n\t\t}\n\n\t\tpublic void doSleep() {\n\t\t}\n\n\t\t@DirectAnnotation(\"direct\")\n\t\t@MetaMetaAnnotation\n\t\tpublic void meta() {\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"serial\")\n\tprivate static class AnnotatedComponentSubClass extends AnnotatedComponent {\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Component\n\tpublic @interface TestConfiguration {\n\n\t\tString value() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface TestComponentScans {\n\n\t\tTestComponentScan[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@Repeatable(TestComponentScans.class)\n\tpublic @interface TestComponentScan {\n\n\t\t@AliasFor(\"basePackages\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] basePackages() default {};\n\n\t\tClass<?>[] basePackageClasses() default {};\n\t}\n\n\t@TestConfiguration\n\t@TestComponentScan(basePackages = \"bogus\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface ComposedConfigurationWithAttributeOverrides {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = TestComponentScan.class)\n\t\tString[] basePackages() default {};\n\t}\n\n\t@ComposedConfigurationWithAttributeOverrides(basePackages = \"org.example.componentscan\")\n\tpublic static class ComposedConfigurationWithAttributeOverridesClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@TestComponentScan(\"C\")\n\tpublic @interface ScanPackageC {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@TestComponentScan(\"D\")\n\tpublic @interface ScanPackageD {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@TestComponentScans({\n\t\t@TestComponentScan(\"C\"),\n\t\t@TestComponentScan(\"D\")\n\t})\n\tpublic @interface ScanPackagesCandD {\n\t}\n\n\t@TestComponentScan(basePackages = \"A\", basePackageClasses = String.class)\n\t@ScanPackageC\n\t@ScanPackageD\n\t@TestComponentScan(basePackages = \"B\", basePackageClasses = Integer.class)\n\tstatic class MultipleComposedRepeatableAnnotationsClass {\n\t}\n\n\t@TestComponentScan(basePackages = \"A\", basePackageClasses = String.class)\n\t@ScanPackagesCandD\n\t@TestComponentScans(@TestComponentScan(basePackages = \"B\", basePackageClasses = Integer.class))\n\tstatic class MultipleRepeatableAnnotationsInContainersClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface NamedAnnotation1 {\n\t\tString name() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface NamedAnnotation2 {\n\t\tString name() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface NamedAnnotation3 {\n\t\tString name() default \"\";\n\t}\n\n\t@NamedAnnotation1(name = \"name 1\")\n\t@NamedAnnotation2(name = \"name 2\")\n\t@NamedAnnotation3(name = \"name 3\")\n\tpublic static class NamedAnnotationsClass {\n\t}\n\n\t@NamedAnnotation1(name = \"name 1\")\n\t@NamedAnnotation2(name = \"name 2\")\n\t@NamedAnnotation3(name = \"name 3\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@Inherited\n\tpublic @interface NamedComposedAnnotation {\n\t}\n\n\t@NamedComposedAnnotation\n\tpublic static class NamedComposedAnnotationClass {\n\t}\n\n\tpublic static class NamedComposedAnnotationExtended extends NamedComposedAnnotationClass {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.type",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.type.MultipleRepeatableAnnotationsInContainersClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.type.MultipleRepeatableAnnotationsInContainersClass",
    "headType": "class",
    "relation": "use",
    "tail": "@TestComponentScan",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.type.MultipleRepeatableAnnotationsInContainersClass",
    "headType": "class",
    "relation": "use",
    "tail": "@ScanPackagesCandD",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.type.MultipleRepeatableAnnotationsInContainersClass",
    "headType": "class",
    "relation": "use",
    "tail": "@TestComponentScans",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.type.MultipleRepeatableAnnotationsInContainersClass",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.type;\n\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.AliasFor;\nimport org.springframework.core.annotation.AnnotatedElementUtils;\nimport org.springframework.core.annotation.AnnotationAttributes;\nimport org.springframework.core.testfixture.stereotype.Component;\nimport org.springframework.core.type.classreading.MetadataReader;\nimport org.springframework.core.type.classreading.MetadataReaderFactory;\nimport org.springframework.core.type.classreading.SimpleMetadataReaderFactory;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Unit tests demonstrating that the reflection-based {@link StandardAnnotationMetadata}\n * and ASM-based {@code SimpleAnnotationMetadata} produce <em>almost</em> identical output.\n *\n * @author Juergen Hoeller\n * @author Chris Beams\n * @author Phillip Webb\n * @author Sam Brannen\n * @see InheritedAnnotationsAnnotationMetadataTests\n */\nclass AnnotationMetadataTests {\n\n\t@Test\n\tvoid standardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(AnnotatedComponent.class);\n\t\tdoTestAnnotationInfo(metadata);\n\t\tdoTestMethodAnnotationInfo(metadata);\n\t}\n\n\t@Test\n\tvoid asmAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(AnnotatedComponent.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tdoTestAnnotationInfo(metadata);\n\t\tdoTestMethodAnnotationInfo(metadata);\n\t}\n\n\t@Test\n\tvoid standardAnnotationMetadataForSubclass() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(AnnotatedComponentSubClass.class);\n\t\tdoTestSubClassAnnotationInfo(metadata, false);\n\t}\n\n\t@Test\n\tvoid asmAnnotationMetadataForSubclass() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(AnnotatedComponentSubClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tdoTestSubClassAnnotationInfo(metadata, true);\n\t}\n\n\tprivate void doTestSubClassAnnotationInfo(AnnotationMetadata metadata, boolean asm) {\n\t\tassertThat(metadata.getClassName()).isEqualTo(AnnotatedComponentSubClass.class.getName());\n\t\tassertThat(metadata.isInterface()).isFalse();\n\t\tassertThat(metadata.isAnnotation()).isFalse();\n\t\tassertThat(metadata.isAbstract()).isFalse();\n\t\tassertThat(metadata.isConcrete()).isTrue();\n\t\tassertThat(metadata.hasSuperClass()).isTrue();\n\t\tassertThat(metadata.getSuperClassName()).isEqualTo(AnnotatedComponent.class.getName());\n\t\tassertThat(metadata.getInterfaceNames()).isEmpty();\n\t\tassertThat(metadata.isAnnotated(Component.class.getName())).isFalse();\n\t\tassertThat(metadata.isAnnotated(Scope.class.getName())).isFalse();\n\t\tassertThat(metadata.isAnnotated(SpecialAttr.class.getName())).isFalse();\n\n\t\tif (asm) {\n\t\t\tassertThat(metadata.isAnnotated(NamedComposedAnnotation.class.getName())).isFalse();\n\t\t\tassertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isFalse();\n\t\t\tassertThat(metadata.getAnnotationTypes()).isEmpty();\n\t\t}\n\t\telse {\n\t\t\tassertThat(metadata.isAnnotated(NamedComposedAnnotation.class.getName())).isTrue();\n\t\t\tassertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isTrue();\n\t\t\tassertThat(metadata.getAnnotationTypes()).containsExactly(NamedComposedAnnotation.class.getName());\n\t\t}\n\n\t\tassertThat(metadata.hasAnnotation(Component.class.getName())).isFalse();\n\t\tassertThat(metadata.hasAnnotation(Scope.class.getName())).isFalse();\n\t\tassertThat(metadata.hasAnnotation(SpecialAttr.class.getName())).isFalse();\n\t\tassertThat(metadata.hasMetaAnnotation(Component.class.getName())).isFalse();\n\t\tassertThat(metadata.hasMetaAnnotation(MetaAnnotation.class.getName())).isFalse();\n\t\tassertThat(metadata.getAnnotationAttributes(Component.class.getName())).isNull();\n\t\tassertThat(metadata.getAnnotationAttributes(MetaAnnotation.class.getName(), false)).isNull();\n\t\tassertThat(metadata.getAnnotationAttributes(MetaAnnotation.class.getName(), true)).isNull();\n\t\tassertThat(metadata.getAnnotatedMethods(DirectAnnotation.class.getName())).isEmpty();\n\t\tassertThat(metadata.isAnnotated(IsAnnotatedAnnotation.class.getName())).isFalse();\n\t\tassertThat(metadata.getAllAnnotationAttributes(DirectAnnotation.class.getName())).isNull();\n\t}\n\n\t@Test\n\tvoid standardAnnotationMetadataForInterface() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(AnnotationMetadata.class);\n\t\tdoTestMetadataForInterfaceClass(metadata);\n\t}\n\n\t@Test\n\tvoid asmAnnotationMetadataForInterface() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(AnnotationMetadata.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tdoTestMetadataForInterfaceClass(metadata);\n\t}\n\n\tprivate void doTestMetadataForInterfaceClass(AnnotationMetadata metadata) {\n\t\tassertThat(metadata.getClassName()).isEqualTo(AnnotationMetadata.class.getName());\n\t\tassertThat(metadata.isInterface()).isTrue();\n\t\tassertThat(metadata.isAnnotation()).isFalse();\n\t\tassertThat(metadata.isAbstract()).isTrue();\n\t\tassertThat(metadata.isConcrete()).isFalse();\n\t\tassertThat(metadata.hasSuperClass()).isFalse();\n\t\tassertThat(metadata.getSuperClassName()).isNull();\n\t\tassertThat(metadata.getInterfaceNames()).hasSize(2);\n\t\tassertThat(metadata.getInterfaceNames()[0]).isEqualTo(ClassMetadata.class.getName());\n\t\tassertThat(metadata.getInterfaceNames()[1]).isEqualTo(AnnotatedTypeMetadata.class.getName());\n\t\tassertThat(metadata.getAnnotationTypes()).isEmpty();\n\t}\n\n\t@Test\n\tvoid standardAnnotationMetadataForAnnotation() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(Component.class);\n\t\tdoTestMetadataForAnnotationClass(metadata);\n\t}\n\n\t@Test\n\tvoid asmAnnotationMetadataForAnnotation() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(Component.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tdoTestMetadataForAnnotationClass(metadata);\n\t}\n\n\tprivate void doTestMetadataForAnnotationClass(AnnotationMetadata metadata) {\n\t\tassertThat(metadata.getClassName()).isEqualTo(Component.class.getName());\n\t\tassertThat(metadata.isInterface()).isTrue();\n\t\tassertThat(metadata.isAnnotation()).isTrue();\n\t\tassertThat(metadata.isAbstract()).isTrue();\n\t\tassertThat(metadata.isConcrete()).isFalse();\n\t\tassertThat(metadata.hasSuperClass()).isFalse();\n\t\tassertThat(metadata.getSuperClassName()).isNull();\n\t\tassertThat(metadata.getInterfaceNames()).hasSize(1);\n\t\tassertThat(metadata.getInterfaceNames()[0]).isEqualTo(Annotation.class.getName());\n\t\tassertThat(metadata.isAnnotated(Documented.class.getName())).isFalse();\n\t\tassertThat(metadata.isAnnotated(Scope.class.getName())).isFalse();\n\t\tassertThat(metadata.isAnnotated(SpecialAttr.class.getName())).isFalse();\n\t\tassertThat(metadata.hasAnnotation(Documented.class.getName())).isFalse();\n\t\tassertThat(metadata.hasAnnotation(Scope.class.getName())).isFalse();\n\t\tassertThat(metadata.hasAnnotation(SpecialAttr.class.getName())).isFalse();\n\t\tassertThat(metadata.getAnnotationTypes()).hasSize(1);\n\t}\n\n\t/**\n\t * In order to preserve backward-compatibility, {@link StandardAnnotationMetadata}\n\t * defaults to return nested annotations and annotation arrays as actual\n\t * Annotation instances. It is recommended for compatibility with ASM-based\n\t * AnnotationMetadata implementations to set the 'nestedAnnotationsAsMap' flag to\n\t * 'true' as is done in the main test above.\n\t */\n\t@Test\n\tvoid standardAnnotationMetadata_nestedAnnotationsAsMap_false() {\n\t\t@SuppressWarnings(\"deprecation\")\n\t\tAnnotationMetadata metadata = new StandardAnnotationMetadata(AnnotatedComponent.class);\n\t\tAnnotationAttributes specialAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(SpecialAttr.class.getName());\n\t\tAnnotation[] nestedAnnoArray = (Annotation[]) specialAttrs.get(\"nestedAnnoArray\");\n\t\tassertThat(nestedAnnoArray[0]).isInstanceOf(NestedAnno.class);\n\t}\n\n\t@Test\n\tvoid metaAnnotationOverridesUsingStandardAnnotationMetadata() {\n\t\t@SuppressWarnings(\"deprecation\")\n\t\tAnnotationMetadata metadata = new StandardAnnotationMetadata(ComposedConfigurationWithAttributeOverridesClass.class);\n\t\tassertMetaAnnotationOverrides(metadata);\n\t}\n\n\t@Test\n\tvoid metaAnnotationOverridesUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(ComposedConfigurationWithAttributeOverridesClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertMetaAnnotationOverrides(metadata);\n\t}\n\n\tprivate void assertMetaAnnotationOverrides(AnnotationMetadata metadata) {\n\t\tAnnotationAttributes attributes = (AnnotationAttributes) metadata.getAnnotationAttributes(\n\t\t\t\tTestComponentScan.class.getName(), false);\n\t\tassertThat(attributes.getStringArray(\"value\")).containsExactly(\"org.example.componentscan\");\n\t\tassertThat(attributes.getStringArray(\"basePackages\")).containsExactly(\"org.example.componentscan\");\n\t\tassertThat(attributes.getClassArray(\"basePackageClasses\")).isEmpty();\n\t}\n\n\t@Test  // SPR-11649\n\tvoid multipleAnnotationsWithIdenticalAttributeNamesUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(NamedAnnotationsClass.class);\n\t\tassertMultipleAnnotationsWithIdenticalAttributeNames(metadata);\n\t}\n\n\t@Test  // SPR-11649\n\tvoid multipleAnnotationsWithIdenticalAttributeNamesUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(NamedAnnotationsClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertMultipleAnnotationsWithIdenticalAttributeNames(metadata);\n\t}\n\n\t@Test  // SPR-11649\n\tvoid composedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(NamedComposedAnnotationClass.class);\n\t\tassertMultipleAnnotationsWithIdenticalAttributeNames(metadata);\n\t}\n\n\t@Test  // SPR-11649\n\tvoid composedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(NamedComposedAnnotationClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertMultipleAnnotationsWithIdenticalAttributeNames(metadata);\n\t}\n\n\t@Test  // gh-31041\n\tvoid multipleComposedRepeatableAnnotationsUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(MultipleComposedRepeatableAnnotationsClass.class);\n\t\tassertRepeatableAnnotations(metadata);\n\t}\n\n\t@Test  // gh-31041\n\tvoid multipleComposedRepeatableAnnotationsUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(MultipleComposedRepeatableAnnotationsClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertRepeatableAnnotations(metadata);\n\t}\n\n\t@Test  // gh-31074\n\tvoid multipleComposedRepeatableAnnotationsSortedByReversedMetaDistanceUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(MultipleComposedRepeatableAnnotationsClass.class);\n\t\tassertRepeatableAnnotationsSortedByReversedMetaDistance(metadata);\n\t}\n\n\t@Test  // gh-31074\n\tvoid multipleComposedRepeatableAnnotationsSortedByReversedMetaDistanceUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(MultipleComposedRepeatableAnnotationsClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertRepeatableAnnotationsSortedByReversedMetaDistance(metadata);\n\t}\n\n\t@Test  // gh-31041\n\tvoid multipleRepeatableAnnotationsInContainersUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(MultipleRepeatableAnnotationsInContainersClass.class);\n\t\tassertRepeatableAnnotations(metadata);\n\t}\n\n\t@Test  // gh-31041\n\tvoid multipleRepeatableAnnotationsInContainersUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(MultipleRepeatableAnnotationsInContainersClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertRepeatableAnnotations(metadata);\n\t}\n\n\t/**\n\t * Tests {@code AnnotatedElementUtils#getMergedRepeatableAnnotations()} variants to ensure that\n\t * {@link AnnotationMetadata#getMergedRepeatableAnnotationAttributes(Class, Class, boolean)}\n\t * behaves the same.\n\t */\n\t@Test  // gh-31041\n\tvoid multipleComposedRepeatableAnnotationsUsingAnnotatedElementUtils() {\n\t\tClass<?> element = MultipleComposedRepeatableAnnotationsClass.class;\n\n\t\tSet<TestComponentScan> annotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(element, TestComponentScan.class);\n\t\tassertRepeatableAnnotations(annotations);\n\n\t\tannotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(element, TestComponentScan.class, TestComponentScans.class);\n\t\tassertRepeatableAnnotations(annotations);\n\t}\n\n\t/**\n\t * Tests {@code AnnotatedElementUtils#getMergedRepeatableAnnotations()} variants to ensure that\n\t * {@link AnnotationMetadata#getMergedRepeatableAnnotationAttributes(Class, Class, boolean)}\n\t * behaves the same.\n\t */\n\t@Test  // gh-31041\n\tvoid multipleRepeatableAnnotationsInContainersUsingAnnotatedElementUtils() {\n\t\tClass<?> element = MultipleRepeatableAnnotationsInContainersClass.class;\n\n\t\tSet<TestComponentScan> annotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(element, TestComponentScan.class);\n\t\tassertRepeatableAnnotations(annotations);\n\n\t\tannotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(element, TestComponentScan.class, TestComponentScans.class);\n\t\tassertRepeatableAnnotations(annotations);\n\t}\n\n\tprivate static void assertRepeatableAnnotations(AnnotationMetadata metadata) {\n\t\tSet<AnnotationAttributes> attributesSet =\n\t\t\t\tmetadata.getMergedRepeatableAnnotationAttributes(TestComponentScan.class, TestComponentScans.class, true);\n\t\tassertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"value\")).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"A\", \"B\", \"C\", \"D\");\n\t\tassertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"basePackages\")).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"A\", \"B\", \"C\", \"D\");\n\t\tassertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"basePackageClasses\")).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"java.lang.String\", \"java.lang.Integer\");\n\t}\n\n\tprivate static void assertRepeatableAnnotationsSortedByReversedMetaDistance(AnnotationMetadata metadata) {\n\t\t// Note: although the real @ComponentScan annotation is not looked up using\n\t\t// \"sortByReversedMetaDistance\" semantics, we can still use @TestComponentScan\n\t\t// to verify the expected behavior.\n\t\tSet<AnnotationAttributes> attributesSet =\n\t\t\t\tmetadata.getMergedRepeatableAnnotationAttributes(TestComponentScan.class, TestComponentScans.class, false, true);\n\t\tassertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"value\")).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"C\", \"D\", \"A\", \"B\");\n\t\tassertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"basePackages\")).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"C\", \"D\", \"A\", \"B\");\n\t}\n\n\tprivate static void assertRepeatableAnnotations(Set<TestComponentScan> annotations) {\n\t\tassertThat(annotations.stream().map(TestComponentScan::value).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"A\", \"B\", \"C\", \"D\");\n\t\tassertThat(annotations.stream().map(TestComponentScan::basePackages).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"A\", \"B\", \"C\", \"D\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(NamedComposedAnnotationExtended.class);\n\t\tassertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isTrue();\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(NamedComposedAnnotationExtended.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isFalse();\n\t}\n\n\n\tprivate void assertMultipleAnnotationsWithIdenticalAttributeNames(AnnotationMetadata metadata) {\n\t\tAnnotationAttributes attributes1 = (AnnotationAttributes) metadata.getAnnotationAttributes(\n\t\t\t\tNamedAnnotation1.class.getName(), false);\n\t\tString name1 = attributes1.getString(\"name\");\n\t\tassertThat(name1).as(\"name of NamedAnnotation1\").isEqualTo(\"name 1\");\n\n\t\tAnnotationAttributes attributes2 = (AnnotationAttributes) metadata.getAnnotationAttributes(\n\t\t\t\tNamedAnnotation2.class.getName(), false);\n\t\tString name2 = attributes2.getString(\"name\");\n\t\tassertThat(name2).as(\"name of NamedAnnotation2\").isEqualTo(\"name 2\");\n\n\t\tAnnotationAttributes attributes3 = (AnnotationAttributes) metadata.getAnnotationAttributes(\n\t\t\t\tNamedAnnotation3.class.getName(), false);\n\t\tString name3 = attributes3.getString(\"name\");\n\t\tassertThat(name3).as(\"name of NamedAnnotation3\").isEqualTo(\"name 3\");\n\t}\n\n\tprivate void doTestAnnotationInfo(AnnotationMetadata metadata) {\n\t\tassertThat(metadata.getClassName()).isEqualTo(AnnotatedComponent.class.getName());\n\t\tassertThat(metadata.isInterface()).isFalse();\n\t\tassertThat(metadata.isAnnotation()).isFalse();\n\t\tassertThat(metadata.isAbstract()).isFalse();\n\t\tassertThat(metadata.isConcrete()).isTrue();\n\t\tassertThat(metadata.hasSuperClass()).isTrue();\n\t\tassertThat(metadata.getSuperClassName()).isEqualTo(Object.class.getName());\n\t\tassertThat(metadata.getInterfaceNames()).hasSize(1);\n\t\tassertThat(metadata.getInterfaceNames()[0]).isEqualTo(Serializable.class.getName());\n\n\t\tassertThat(metadata.isAnnotated(Component.class.getName())).isTrue();\n\n\t\tassertThat(metadata.isAnnotated(NamedComposedAnnotation.class.getName())).isTrue();\n\n\t\tassertThat(metadata.hasAnnotation(Component.class.getName())).isTrue();\n\t\tassertThat(metadata.hasAnnotation(Scope.class.getName())).isTrue();\n\t\tassertThat(metadata.hasAnnotation(SpecialAttr.class.getName())).isTrue();\n\n\t\tassertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isTrue();\n\t\tassertThat(metadata.getAnnotationTypes()).containsExactlyInAnyOrder(\n\t\t\t\tComponent.class.getName(), Scope.class.getName(),\n\t\t\t\tSpecialAttr.class.getName(), DirectAnnotation.class.getName(),\n\t\t\t\tMetaMetaAnnotation.class.getName(), EnumSubclasses.class.getName(),\n\t\t\t\tNamedComposedAnnotation.class.getName());\n\n\t\tAnnotationAttributes compAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(Component.class.getName());\n\t\tassertThat(compAttrs).hasSize(1);\n\t\tassertThat(compAttrs.getString(\"value\")).isEqualTo(\"myName\");\n\t\tAnnotationAttributes scopeAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(Scope.class.getName());\n\t\tassertThat(scopeAttrs).hasSize(1);\n\t\tassertThat(scopeAttrs.getString(\"value\")).isEqualTo(\"myScope\");\n\n\t\tSet<MethodMetadata> methods = metadata.getAnnotatedMethods(DirectAnnotation.class.getName());\n\t\tMethodMetadata method = methods.iterator().next();\n\t\tassertThat(method.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\")).isEqualTo(\"direct\");\n\t\tassertThat(method.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"myValue\")).isEqualTo(\"direct\");\n\t\tList<Object> allMeta = method.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\");\n\t\tassertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(Arrays.asList(\"direct\", \"meta\")));\n\t\tallMeta = method.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"additional\");\n\t\tassertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(List.of(\"direct\")));\n\n\t\tassertThat(metadata.isAnnotated(IsAnnotatedAnnotation.class.getName())).isTrue();\n\n\t\t{ // perform tests with classValuesAsString = false (the default)\n\t\t\tAnnotationAttributes specialAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(SpecialAttr.class.getName());\n\t\t\tassertThat(specialAttrs).hasSize(6);\n\t\t\tassertThat(String.class.isAssignableFrom(specialAttrs.getClass(\"clazz\"))).isTrue();\n\t\t\tassertThat(specialAttrs.getEnum(\"state\").equals(Thread.State.NEW)).isTrue();\n\n\t\t\tAnnotationAttributes nestedAnno = specialAttrs.getAnnotation(\"nestedAnno\");\n\t\t\tassertThat(nestedAnno.getString(\"value\")).isEqualTo(\"na\");\n\t\t\tassertThat(nestedAnno.getEnum(\"anEnum\").equals(SomeEnum.LABEL1)).isTrue();\n\t\t\tassertThat((Class<?>[]) nestedAnno.get(\"classArray\")).isEqualTo(new Class<?>[] {String.class});\n\n\t\t\tAnnotationAttributes[] nestedAnnoArray = specialAttrs.getAnnotationArray(\"nestedAnnoArray\");\n\t\t\tassertThat(nestedAnnoArray).hasSize(2);\n\t\t\tassertThat(nestedAnnoArray[0].getString(\"value\")).isEqualTo(\"default\");\n\t\t\tassertThat(nestedAnnoArray[0].getEnum(\"anEnum\").equals(SomeEnum.DEFAULT)).isTrue();\n\t\t\tassertThat((Class<?>[]) nestedAnnoArray[0].get(\"classArray\")).isEqualTo(new Class<?>[] {Void.class});\n\t\t\tassertThat(nestedAnnoArray[1].getString(\"value\")).isEqualTo(\"na1\");\n\t\t\tassertThat(nestedAnnoArray[1].getEnum(\"anEnum\").equals(SomeEnum.LABEL2)).isTrue();\n\t\t\tassertThat((Class<?>[]) nestedAnnoArray[1].get(\"classArray\")).isEqualTo(new Class<?>[] {Number.class});\n\t\t\tassertThat(nestedAnnoArray[1].getClassArray(\"classArray\")).isEqualTo(new Class<?>[] {Number.class});\n\n\t\t\tAnnotationAttributes optional = specialAttrs.getAnnotation(\"optional\");\n\t\t\tassertThat(optional.getString(\"value\")).isEqualTo(\"optional\");\n\t\t\tassertThat(optional.getEnum(\"anEnum\").equals(SomeEnum.DEFAULT)).isTrue();\n\t\t\tassertThat((Class<?>[]) optional.get(\"classArray\")).isEqualTo(new Class<?>[] {Void.class});\n\t\t\tassertThat(optional.getClassArray(\"classArray\")).isEqualTo(new Class<?>[] {Void.class});\n\n\t\t\tAnnotationAttributes[] optionalArray = specialAttrs.getAnnotationArray(\"optionalArray\");\n\t\t\tassertThat(optionalArray).hasSize(1);\n\t\t\tassertThat(optionalArray[0].getString(\"value\")).isEqualTo(\"optional\");\n\t\t\tassertThat(optionalArray[0].getEnum(\"anEnum\").equals(SomeEnum.DEFAULT)).isTrue();\n\t\t\tassertThat((Class<?>[]) optionalArray[0].get(\"classArray\")).isEqualTo(new Class<?>[] {Void.class});\n\t\t\tassertThat(optionalArray[0].getClassArray(\"classArray\")).isEqualTo(new Class<?>[] {Void.class});\n\n\t\t\tassertThat(metadata.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\")).isEqualTo(\"direct\");\n\t\t\tallMeta = metadata.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\");\n\t\t\tassertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(Arrays.asList(\"direct\", \"meta\")));\n\t\t\tallMeta = metadata.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"additional\");\n\t\t\tassertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(Arrays.asList(\"direct\", \"\")));\n\t\t\tassertThat(metadata.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"additional\")).isEqualTo(\"\");\n\t\t\tassertThat(((String[]) metadata.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"additionalArray\"))).isEmpty();\n\t\t}\n\t\t{ // perform tests with classValuesAsString = true\n\t\t\tAnnotationAttributes specialAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(\n\t\t\t\tSpecialAttr.class.getName(), true);\n\t\t\tassertThat(specialAttrs).hasSize(6);\n\t\t\tassertThat(specialAttrs.get(\"clazz\")).isEqualTo(String.class.getName());\n\t\t\tassertThat(specialAttrs.getString(\"clazz\")).isEqualTo(String.class.getName());\n\n\t\t\tAnnotationAttributes nestedAnno = specialAttrs.getAnnotation(\"nestedAnno\");\n\t\t\tassertThat(nestedAnno.getStringArray(\"classArray\")).isEqualTo(new String[] { String.class.getName() });\n\t\t\tassertThat(nestedAnno.getStringArray(\"classArray\")).isEqualTo(new String[] { String.class.getName() });\n\n\t\t\tAnnotationAttributes[] nestedAnnoArray = specialAttrs.getAnnotationArray(\"nestedAnnoArray\");\n\t\t\tassertThat((String[]) nestedAnnoArray[0].get(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\t\t\tassertThat(nestedAnnoArray[0].getStringArray(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\t\t\tassertThat((String[]) nestedAnnoArray[1].get(\"classArray\")).isEqualTo(new String[] { Number.class.getName() });\n\t\t\tassertThat(nestedAnnoArray[1].getStringArray(\"classArray\")).isEqualTo(new String[] { Number.class.getName() });\n\n\t\t\tAnnotationAttributes optional = specialAttrs.getAnnotation(\"optional\");\n\t\t\tassertThat((String[]) optional.get(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\t\t\tassertThat(optional.getStringArray(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\n\t\t\tAnnotationAttributes[] optionalArray = specialAttrs.getAnnotationArray(\"optionalArray\");\n\t\t\tassertThat((String[]) optionalArray[0].get(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\t\t\tassertThat(optionalArray[0].getStringArray(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\n\t\t\tassertThat(metadata.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\")).isEqualTo(\"direct\");\n\t\t\tallMeta = metadata.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\");\n\t\t\tassertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(Arrays.asList(\"direct\", \"meta\")));\n\t\t}\n\t}\n\n\tprivate void doTestMethodAnnotationInfo(AnnotationMetadata classMetadata) {\n\t\tassertThat(classMetadata.getDeclaredMethods()).hasSize(3);\n\t\tSet<MethodMetadata> methods = classMetadata.getAnnotatedMethods(TestAutowired.class.getName());\n\t\tassertThat(methods).hasSize(1);\n\t\tfor (MethodMetadata methodMetadata : methods) {\n\t\t\tassertThat(methodMetadata.isAnnotated(TestAutowired.class.getName())).isTrue();\n\t\t}\n\t}\n\n\n\t// -------------------------------------------------------------------------\n\n\tpublic enum SomeEnum {\n\t\tLABEL1, LABEL2, DEFAULT\n\t}\n\n\t@Target({})\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface NestedAnno {\n\n\t\tString value() default \"default\";\n\n\t\tSomeEnum anEnum() default SomeEnum.DEFAULT;\n\n\t\tClass<?>[] classArray() default Void.class;\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface SpecialAttr {\n\n\t\tClass<?> clazz();\n\n\t\tThread.State state();\n\n\t\tNestedAnno nestedAnno();\n\n\t\tNestedAnno[] nestedAnnoArray();\n\n\t\tNestedAnno optional() default @NestedAnno(value = \"optional\", anEnum = SomeEnum.DEFAULT, classArray = Void.class);\n\n\t\tNestedAnno[] optionalArray() default { @NestedAnno(value = \"optional\", anEnum = SomeEnum.DEFAULT, classArray = Void.class) };\n\t}\n\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface DirectAnnotation {\n\n\t\t@AliasFor(\"myValue\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString myValue() default \"\";\n\n\t\tString additional() default \"direct\";\n\n\t\tString[] additionalArray() default \"direct\";\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface IsAnnotatedAnnotation {\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DirectAnnotation(\"meta\")\n\t@IsAnnotatedAnnotation\n\tpublic @interface MetaAnnotation {\n\n\t\tString additional() default \"meta\";\n\t}\n\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@MetaAnnotation\n\tpublic @interface MetaMetaAnnotation {\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface EnumSubclasses {\n\n\t\tSubclassEnum[] value();\n\t}\n\n\t// SPR-10914\n\tpublic enum SubclassEnum {\n\t\tFOO {\n\t\t/* Do not delete! This subclassing is intentional. */\n\t\t},\n\t\tBAR {\n\t\t/* Do not delete! This subclassing is intentional. */\n\t\t}\n\t}\n\n\t@Component(\"myName\")\n\t@Scope(\"myScope\")\n\t@SpecialAttr(clazz = String.class, state = Thread.State.NEW,\n\t\t\tnestedAnno = @NestedAnno(value = \"na\", anEnum = SomeEnum.LABEL1, classArray = {String.class}),\n\t\t\tnestedAnnoArray = {@NestedAnno, @NestedAnno(value = \"na1\", anEnum = SomeEnum.LABEL2, classArray = {Number.class})})\n\t@SuppressWarnings({\"serial\", \"unused\"})\n\t@DirectAnnotation(value = \"direct\", additional = \"\", additionalArray = {})\n\t@MetaMetaAnnotation\n\t@EnumSubclasses({SubclassEnum.FOO, SubclassEnum.BAR})\n\t@NamedComposedAnnotation\n\tprivate static class AnnotatedComponent implements Serializable {\n\n\t\tpublic AnnotatedComponent() {\n\t\t}\n\n\t\t@TestAutowired\n\t\tpublic void doWork(@TestQualifier(\"myColor\") java.awt.Color color) {\n\t\t}\n\n\t\tpublic void doSleep() {\n\t\t}\n\n\t\t@DirectAnnotation(\"direct\")\n\t\t@MetaMetaAnnotation\n\t\tpublic void meta() {\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"serial\")\n\tprivate static class AnnotatedComponentSubClass extends AnnotatedComponent {\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Component\n\tpublic @interface TestConfiguration {\n\n\t\tString value() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface TestComponentScans {\n\n\t\tTestComponentScan[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@Repeatable(TestComponentScans.class)\n\tpublic @interface TestComponentScan {\n\n\t\t@AliasFor(\"basePackages\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] basePackages() default {};\n\n\t\tClass<?>[] basePackageClasses() default {};\n\t}\n\n\t@TestConfiguration\n\t@TestComponentScan(basePackages = \"bogus\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface ComposedConfigurationWithAttributeOverrides {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = TestComponentScan.class)\n\t\tString[] basePackages() default {};\n\t}\n\n\t@ComposedConfigurationWithAttributeOverrides(basePackages = \"org.example.componentscan\")\n\tpublic static class ComposedConfigurationWithAttributeOverridesClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@TestComponentScan(\"C\")\n\tpublic @interface ScanPackageC {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@TestComponentScan(\"D\")\n\tpublic @interface ScanPackageD {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@TestComponentScans({\n\t\t@TestComponentScan(\"C\"),\n\t\t@TestComponentScan(\"D\")\n\t})\n\tpublic @interface ScanPackagesCandD {\n\t}\n\n\t@TestComponentScan(basePackages = \"A\", basePackageClasses = String.class)\n\t@ScanPackageC\n\t@ScanPackageD\n\t@TestComponentScan(basePackages = \"B\", basePackageClasses = Integer.class)\n\tstatic class MultipleComposedRepeatableAnnotationsClass {\n\t}\n\n\t@TestComponentScan(basePackages = \"A\", basePackageClasses = String.class)\n\t@ScanPackagesCandD\n\t@TestComponentScans(@TestComponentScan(basePackages = \"B\", basePackageClasses = Integer.class))\n\tstatic class MultipleRepeatableAnnotationsInContainersClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface NamedAnnotation1 {\n\t\tString name() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface NamedAnnotation2 {\n\t\tString name() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface NamedAnnotation3 {\n\t\tString name() default \"\";\n\t}\n\n\t@NamedAnnotation1(name = \"name 1\")\n\t@NamedAnnotation2(name = \"name 2\")\n\t@NamedAnnotation3(name = \"name 3\")\n\tpublic static class NamedAnnotationsClass {\n\t}\n\n\t@NamedAnnotation1(name = \"name 1\")\n\t@NamedAnnotation2(name = \"name 2\")\n\t@NamedAnnotation3(name = \"name 3\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@Inherited\n\tpublic @interface NamedComposedAnnotation {\n\t}\n\n\t@NamedComposedAnnotation\n\tpublic static class NamedComposedAnnotationClass {\n\t}\n\n\tpublic static class NamedComposedAnnotationExtended extends NamedComposedAnnotationClass {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.type",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.type.NamedAnnotationsClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.type.NamedAnnotationsClass",
    "headType": "class",
    "relation": "use",
    "tail": "@NamedAnnotation1",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.type.NamedAnnotationsClass",
    "headType": "class",
    "relation": "use",
    "tail": "@NamedAnnotation2",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.type.NamedAnnotationsClass",
    "headType": "class",
    "relation": "use",
    "tail": "@NamedAnnotation3",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.type.NamedAnnotationsClass",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.type;\n\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.AliasFor;\nimport org.springframework.core.annotation.AnnotatedElementUtils;\nimport org.springframework.core.annotation.AnnotationAttributes;\nimport org.springframework.core.testfixture.stereotype.Component;\nimport org.springframework.core.type.classreading.MetadataReader;\nimport org.springframework.core.type.classreading.MetadataReaderFactory;\nimport org.springframework.core.type.classreading.SimpleMetadataReaderFactory;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Unit tests demonstrating that the reflection-based {@link StandardAnnotationMetadata}\n * and ASM-based {@code SimpleAnnotationMetadata} produce <em>almost</em> identical output.\n *\n * @author Juergen Hoeller\n * @author Chris Beams\n * @author Phillip Webb\n * @author Sam Brannen\n * @see InheritedAnnotationsAnnotationMetadataTests\n */\nclass AnnotationMetadataTests {\n\n\t@Test\n\tvoid standardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(AnnotatedComponent.class);\n\t\tdoTestAnnotationInfo(metadata);\n\t\tdoTestMethodAnnotationInfo(metadata);\n\t}\n\n\t@Test\n\tvoid asmAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(AnnotatedComponent.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tdoTestAnnotationInfo(metadata);\n\t\tdoTestMethodAnnotationInfo(metadata);\n\t}\n\n\t@Test\n\tvoid standardAnnotationMetadataForSubclass() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(AnnotatedComponentSubClass.class);\n\t\tdoTestSubClassAnnotationInfo(metadata, false);\n\t}\n\n\t@Test\n\tvoid asmAnnotationMetadataForSubclass() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(AnnotatedComponentSubClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tdoTestSubClassAnnotationInfo(metadata, true);\n\t}\n\n\tprivate void doTestSubClassAnnotationInfo(AnnotationMetadata metadata, boolean asm) {\n\t\tassertThat(metadata.getClassName()).isEqualTo(AnnotatedComponentSubClass.class.getName());\n\t\tassertThat(metadata.isInterface()).isFalse();\n\t\tassertThat(metadata.isAnnotation()).isFalse();\n\t\tassertThat(metadata.isAbstract()).isFalse();\n\t\tassertThat(metadata.isConcrete()).isTrue();\n\t\tassertThat(metadata.hasSuperClass()).isTrue();\n\t\tassertThat(metadata.getSuperClassName()).isEqualTo(AnnotatedComponent.class.getName());\n\t\tassertThat(metadata.getInterfaceNames()).isEmpty();\n\t\tassertThat(metadata.isAnnotated(Component.class.getName())).isFalse();\n\t\tassertThat(metadata.isAnnotated(Scope.class.getName())).isFalse();\n\t\tassertThat(metadata.isAnnotated(SpecialAttr.class.getName())).isFalse();\n\n\t\tif (asm) {\n\t\t\tassertThat(metadata.isAnnotated(NamedComposedAnnotation.class.getName())).isFalse();\n\t\t\tassertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isFalse();\n\t\t\tassertThat(metadata.getAnnotationTypes()).isEmpty();\n\t\t}\n\t\telse {\n\t\t\tassertThat(metadata.isAnnotated(NamedComposedAnnotation.class.getName())).isTrue();\n\t\t\tassertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isTrue();\n\t\t\tassertThat(metadata.getAnnotationTypes()).containsExactly(NamedComposedAnnotation.class.getName());\n\t\t}\n\n\t\tassertThat(metadata.hasAnnotation(Component.class.getName())).isFalse();\n\t\tassertThat(metadata.hasAnnotation(Scope.class.getName())).isFalse();\n\t\tassertThat(metadata.hasAnnotation(SpecialAttr.class.getName())).isFalse();\n\t\tassertThat(metadata.hasMetaAnnotation(Component.class.getName())).isFalse();\n\t\tassertThat(metadata.hasMetaAnnotation(MetaAnnotation.class.getName())).isFalse();\n\t\tassertThat(metadata.getAnnotationAttributes(Component.class.getName())).isNull();\n\t\tassertThat(metadata.getAnnotationAttributes(MetaAnnotation.class.getName(), false)).isNull();\n\t\tassertThat(metadata.getAnnotationAttributes(MetaAnnotation.class.getName(), true)).isNull();\n\t\tassertThat(metadata.getAnnotatedMethods(DirectAnnotation.class.getName())).isEmpty();\n\t\tassertThat(metadata.isAnnotated(IsAnnotatedAnnotation.class.getName())).isFalse();\n\t\tassertThat(metadata.getAllAnnotationAttributes(DirectAnnotation.class.getName())).isNull();\n\t}\n\n\t@Test\n\tvoid standardAnnotationMetadataForInterface() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(AnnotationMetadata.class);\n\t\tdoTestMetadataForInterfaceClass(metadata);\n\t}\n\n\t@Test\n\tvoid asmAnnotationMetadataForInterface() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(AnnotationMetadata.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tdoTestMetadataForInterfaceClass(metadata);\n\t}\n\n\tprivate void doTestMetadataForInterfaceClass(AnnotationMetadata metadata) {\n\t\tassertThat(metadata.getClassName()).isEqualTo(AnnotationMetadata.class.getName());\n\t\tassertThat(metadata.isInterface()).isTrue();\n\t\tassertThat(metadata.isAnnotation()).isFalse();\n\t\tassertThat(metadata.isAbstract()).isTrue();\n\t\tassertThat(metadata.isConcrete()).isFalse();\n\t\tassertThat(metadata.hasSuperClass()).isFalse();\n\t\tassertThat(metadata.getSuperClassName()).isNull();\n\t\tassertThat(metadata.getInterfaceNames()).hasSize(2);\n\t\tassertThat(metadata.getInterfaceNames()[0]).isEqualTo(ClassMetadata.class.getName());\n\t\tassertThat(metadata.getInterfaceNames()[1]).isEqualTo(AnnotatedTypeMetadata.class.getName());\n\t\tassertThat(metadata.getAnnotationTypes()).isEmpty();\n\t}\n\n\t@Test\n\tvoid standardAnnotationMetadataForAnnotation() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(Component.class);\n\t\tdoTestMetadataForAnnotationClass(metadata);\n\t}\n\n\t@Test\n\tvoid asmAnnotationMetadataForAnnotation() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(Component.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tdoTestMetadataForAnnotationClass(metadata);\n\t}\n\n\tprivate void doTestMetadataForAnnotationClass(AnnotationMetadata metadata) {\n\t\tassertThat(metadata.getClassName()).isEqualTo(Component.class.getName());\n\t\tassertThat(metadata.isInterface()).isTrue();\n\t\tassertThat(metadata.isAnnotation()).isTrue();\n\t\tassertThat(metadata.isAbstract()).isTrue();\n\t\tassertThat(metadata.isConcrete()).isFalse();\n\t\tassertThat(metadata.hasSuperClass()).isFalse();\n\t\tassertThat(metadata.getSuperClassName()).isNull();\n\t\tassertThat(metadata.getInterfaceNames()).hasSize(1);\n\t\tassertThat(metadata.getInterfaceNames()[0]).isEqualTo(Annotation.class.getName());\n\t\tassertThat(metadata.isAnnotated(Documented.class.getName())).isFalse();\n\t\tassertThat(metadata.isAnnotated(Scope.class.getName())).isFalse();\n\t\tassertThat(metadata.isAnnotated(SpecialAttr.class.getName())).isFalse();\n\t\tassertThat(metadata.hasAnnotation(Documented.class.getName())).isFalse();\n\t\tassertThat(metadata.hasAnnotation(Scope.class.getName())).isFalse();\n\t\tassertThat(metadata.hasAnnotation(SpecialAttr.class.getName())).isFalse();\n\t\tassertThat(metadata.getAnnotationTypes()).hasSize(1);\n\t}\n\n\t/**\n\t * In order to preserve backward-compatibility, {@link StandardAnnotationMetadata}\n\t * defaults to return nested annotations and annotation arrays as actual\n\t * Annotation instances. It is recommended for compatibility with ASM-based\n\t * AnnotationMetadata implementations to set the 'nestedAnnotationsAsMap' flag to\n\t * 'true' as is done in the main test above.\n\t */\n\t@Test\n\tvoid standardAnnotationMetadata_nestedAnnotationsAsMap_false() {\n\t\t@SuppressWarnings(\"deprecation\")\n\t\tAnnotationMetadata metadata = new StandardAnnotationMetadata(AnnotatedComponent.class);\n\t\tAnnotationAttributes specialAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(SpecialAttr.class.getName());\n\t\tAnnotation[] nestedAnnoArray = (Annotation[]) specialAttrs.get(\"nestedAnnoArray\");\n\t\tassertThat(nestedAnnoArray[0]).isInstanceOf(NestedAnno.class);\n\t}\n\n\t@Test\n\tvoid metaAnnotationOverridesUsingStandardAnnotationMetadata() {\n\t\t@SuppressWarnings(\"deprecation\")\n\t\tAnnotationMetadata metadata = new StandardAnnotationMetadata(ComposedConfigurationWithAttributeOverridesClass.class);\n\t\tassertMetaAnnotationOverrides(metadata);\n\t}\n\n\t@Test\n\tvoid metaAnnotationOverridesUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(ComposedConfigurationWithAttributeOverridesClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertMetaAnnotationOverrides(metadata);\n\t}\n\n\tprivate void assertMetaAnnotationOverrides(AnnotationMetadata metadata) {\n\t\tAnnotationAttributes attributes = (AnnotationAttributes) metadata.getAnnotationAttributes(\n\t\t\t\tTestComponentScan.class.getName(), false);\n\t\tassertThat(attributes.getStringArray(\"value\")).containsExactly(\"org.example.componentscan\");\n\t\tassertThat(attributes.getStringArray(\"basePackages\")).containsExactly(\"org.example.componentscan\");\n\t\tassertThat(attributes.getClassArray(\"basePackageClasses\")).isEmpty();\n\t}\n\n\t@Test  // SPR-11649\n\tvoid multipleAnnotationsWithIdenticalAttributeNamesUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(NamedAnnotationsClass.class);\n\t\tassertMultipleAnnotationsWithIdenticalAttributeNames(metadata);\n\t}\n\n\t@Test  // SPR-11649\n\tvoid multipleAnnotationsWithIdenticalAttributeNamesUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(NamedAnnotationsClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertMultipleAnnotationsWithIdenticalAttributeNames(metadata);\n\t}\n\n\t@Test  // SPR-11649\n\tvoid composedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(NamedComposedAnnotationClass.class);\n\t\tassertMultipleAnnotationsWithIdenticalAttributeNames(metadata);\n\t}\n\n\t@Test  // SPR-11649\n\tvoid composedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(NamedComposedAnnotationClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertMultipleAnnotationsWithIdenticalAttributeNames(metadata);\n\t}\n\n\t@Test  // gh-31041\n\tvoid multipleComposedRepeatableAnnotationsUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(MultipleComposedRepeatableAnnotationsClass.class);\n\t\tassertRepeatableAnnotations(metadata);\n\t}\n\n\t@Test  // gh-31041\n\tvoid multipleComposedRepeatableAnnotationsUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(MultipleComposedRepeatableAnnotationsClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertRepeatableAnnotations(metadata);\n\t}\n\n\t@Test  // gh-31074\n\tvoid multipleComposedRepeatableAnnotationsSortedByReversedMetaDistanceUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(MultipleComposedRepeatableAnnotationsClass.class);\n\t\tassertRepeatableAnnotationsSortedByReversedMetaDistance(metadata);\n\t}\n\n\t@Test  // gh-31074\n\tvoid multipleComposedRepeatableAnnotationsSortedByReversedMetaDistanceUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(MultipleComposedRepeatableAnnotationsClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertRepeatableAnnotationsSortedByReversedMetaDistance(metadata);\n\t}\n\n\t@Test  // gh-31041\n\tvoid multipleRepeatableAnnotationsInContainersUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(MultipleRepeatableAnnotationsInContainersClass.class);\n\t\tassertRepeatableAnnotations(metadata);\n\t}\n\n\t@Test  // gh-31041\n\tvoid multipleRepeatableAnnotationsInContainersUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(MultipleRepeatableAnnotationsInContainersClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertRepeatableAnnotations(metadata);\n\t}\n\n\t/**\n\t * Tests {@code AnnotatedElementUtils#getMergedRepeatableAnnotations()} variants to ensure that\n\t * {@link AnnotationMetadata#getMergedRepeatableAnnotationAttributes(Class, Class, boolean)}\n\t * behaves the same.\n\t */\n\t@Test  // gh-31041\n\tvoid multipleComposedRepeatableAnnotationsUsingAnnotatedElementUtils() {\n\t\tClass<?> element = MultipleComposedRepeatableAnnotationsClass.class;\n\n\t\tSet<TestComponentScan> annotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(element, TestComponentScan.class);\n\t\tassertRepeatableAnnotations(annotations);\n\n\t\tannotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(element, TestComponentScan.class, TestComponentScans.class);\n\t\tassertRepeatableAnnotations(annotations);\n\t}\n\n\t/**\n\t * Tests {@code AnnotatedElementUtils#getMergedRepeatableAnnotations()} variants to ensure that\n\t * {@link AnnotationMetadata#getMergedRepeatableAnnotationAttributes(Class, Class, boolean)}\n\t * behaves the same.\n\t */\n\t@Test  // gh-31041\n\tvoid multipleRepeatableAnnotationsInContainersUsingAnnotatedElementUtils() {\n\t\tClass<?> element = MultipleRepeatableAnnotationsInContainersClass.class;\n\n\t\tSet<TestComponentScan> annotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(element, TestComponentScan.class);\n\t\tassertRepeatableAnnotations(annotations);\n\n\t\tannotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(element, TestComponentScan.class, TestComponentScans.class);\n\t\tassertRepeatableAnnotations(annotations);\n\t}\n\n\tprivate static void assertRepeatableAnnotations(AnnotationMetadata metadata) {\n\t\tSet<AnnotationAttributes> attributesSet =\n\t\t\t\tmetadata.getMergedRepeatableAnnotationAttributes(TestComponentScan.class, TestComponentScans.class, true);\n\t\tassertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"value\")).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"A\", \"B\", \"C\", \"D\");\n\t\tassertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"basePackages\")).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"A\", \"B\", \"C\", \"D\");\n\t\tassertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"basePackageClasses\")).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"java.lang.String\", \"java.lang.Integer\");\n\t}\n\n\tprivate static void assertRepeatableAnnotationsSortedByReversedMetaDistance(AnnotationMetadata metadata) {\n\t\t// Note: although the real @ComponentScan annotation is not looked up using\n\t\t// \"sortByReversedMetaDistance\" semantics, we can still use @TestComponentScan\n\t\t// to verify the expected behavior.\n\t\tSet<AnnotationAttributes> attributesSet =\n\t\t\t\tmetadata.getMergedRepeatableAnnotationAttributes(TestComponentScan.class, TestComponentScans.class, false, true);\n\t\tassertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"value\")).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"C\", \"D\", \"A\", \"B\");\n\t\tassertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"basePackages\")).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"C\", \"D\", \"A\", \"B\");\n\t}\n\n\tprivate static void assertRepeatableAnnotations(Set<TestComponentScan> annotations) {\n\t\tassertThat(annotations.stream().map(TestComponentScan::value).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"A\", \"B\", \"C\", \"D\");\n\t\tassertThat(annotations.stream().map(TestComponentScan::basePackages).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"A\", \"B\", \"C\", \"D\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(NamedComposedAnnotationExtended.class);\n\t\tassertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isTrue();\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(NamedComposedAnnotationExtended.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isFalse();\n\t}\n\n\n\tprivate void assertMultipleAnnotationsWithIdenticalAttributeNames(AnnotationMetadata metadata) {\n\t\tAnnotationAttributes attributes1 = (AnnotationAttributes) metadata.getAnnotationAttributes(\n\t\t\t\tNamedAnnotation1.class.getName(), false);\n\t\tString name1 = attributes1.getString(\"name\");\n\t\tassertThat(name1).as(\"name of NamedAnnotation1\").isEqualTo(\"name 1\");\n\n\t\tAnnotationAttributes attributes2 = (AnnotationAttributes) metadata.getAnnotationAttributes(\n\t\t\t\tNamedAnnotation2.class.getName(), false);\n\t\tString name2 = attributes2.getString(\"name\");\n\t\tassertThat(name2).as(\"name of NamedAnnotation2\").isEqualTo(\"name 2\");\n\n\t\tAnnotationAttributes attributes3 = (AnnotationAttributes) metadata.getAnnotationAttributes(\n\t\t\t\tNamedAnnotation3.class.getName(), false);\n\t\tString name3 = attributes3.getString(\"name\");\n\t\tassertThat(name3).as(\"name of NamedAnnotation3\").isEqualTo(\"name 3\");\n\t}\n\n\tprivate void doTestAnnotationInfo(AnnotationMetadata metadata) {\n\t\tassertThat(metadata.getClassName()).isEqualTo(AnnotatedComponent.class.getName());\n\t\tassertThat(metadata.isInterface()).isFalse();\n\t\tassertThat(metadata.isAnnotation()).isFalse();\n\t\tassertThat(metadata.isAbstract()).isFalse();\n\t\tassertThat(metadata.isConcrete()).isTrue();\n\t\tassertThat(metadata.hasSuperClass()).isTrue();\n\t\tassertThat(metadata.getSuperClassName()).isEqualTo(Object.class.getName());\n\t\tassertThat(metadata.getInterfaceNames()).hasSize(1);\n\t\tassertThat(metadata.getInterfaceNames()[0]).isEqualTo(Serializable.class.getName());\n\n\t\tassertThat(metadata.isAnnotated(Component.class.getName())).isTrue();\n\n\t\tassertThat(metadata.isAnnotated(NamedComposedAnnotation.class.getName())).isTrue();\n\n\t\tassertThat(metadata.hasAnnotation(Component.class.getName())).isTrue();\n\t\tassertThat(metadata.hasAnnotation(Scope.class.getName())).isTrue();\n\t\tassertThat(metadata.hasAnnotation(SpecialAttr.class.getName())).isTrue();\n\n\t\tassertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isTrue();\n\t\tassertThat(metadata.getAnnotationTypes()).containsExactlyInAnyOrder(\n\t\t\t\tComponent.class.getName(), Scope.class.getName(),\n\t\t\t\tSpecialAttr.class.getName(), DirectAnnotation.class.getName(),\n\t\t\t\tMetaMetaAnnotation.class.getName(), EnumSubclasses.class.getName(),\n\t\t\t\tNamedComposedAnnotation.class.getName());\n\n\t\tAnnotationAttributes compAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(Component.class.getName());\n\t\tassertThat(compAttrs).hasSize(1);\n\t\tassertThat(compAttrs.getString(\"value\")).isEqualTo(\"myName\");\n\t\tAnnotationAttributes scopeAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(Scope.class.getName());\n\t\tassertThat(scopeAttrs).hasSize(1);\n\t\tassertThat(scopeAttrs.getString(\"value\")).isEqualTo(\"myScope\");\n\n\t\tSet<MethodMetadata> methods = metadata.getAnnotatedMethods(DirectAnnotation.class.getName());\n\t\tMethodMetadata method = methods.iterator().next();\n\t\tassertThat(method.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\")).isEqualTo(\"direct\");\n\t\tassertThat(method.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"myValue\")).isEqualTo(\"direct\");\n\t\tList<Object> allMeta = method.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\");\n\t\tassertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(Arrays.asList(\"direct\", \"meta\")));\n\t\tallMeta = method.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"additional\");\n\t\tassertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(List.of(\"direct\")));\n\n\t\tassertThat(metadata.isAnnotated(IsAnnotatedAnnotation.class.getName())).isTrue();\n\n\t\t{ // perform tests with classValuesAsString = false (the default)\n\t\t\tAnnotationAttributes specialAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(SpecialAttr.class.getName());\n\t\t\tassertThat(specialAttrs).hasSize(6);\n\t\t\tassertThat(String.class.isAssignableFrom(specialAttrs.getClass(\"clazz\"))).isTrue();\n\t\t\tassertThat(specialAttrs.getEnum(\"state\").equals(Thread.State.NEW)).isTrue();\n\n\t\t\tAnnotationAttributes nestedAnno = specialAttrs.getAnnotation(\"nestedAnno\");\n\t\t\tassertThat(nestedAnno.getString(\"value\")).isEqualTo(\"na\");\n\t\t\tassertThat(nestedAnno.getEnum(\"anEnum\").equals(SomeEnum.LABEL1)).isTrue();\n\t\t\tassertThat((Class<?>[]) nestedAnno.get(\"classArray\")).isEqualTo(new Class<?>[] {String.class});\n\n\t\t\tAnnotationAttributes[] nestedAnnoArray = specialAttrs.getAnnotationArray(\"nestedAnnoArray\");\n\t\t\tassertThat(nestedAnnoArray).hasSize(2);\n\t\t\tassertThat(nestedAnnoArray[0].getString(\"value\")).isEqualTo(\"default\");\n\t\t\tassertThat(nestedAnnoArray[0].getEnum(\"anEnum\").equals(SomeEnum.DEFAULT)).isTrue();\n\t\t\tassertThat((Class<?>[]) nestedAnnoArray[0].get(\"classArray\")).isEqualTo(new Class<?>[] {Void.class});\n\t\t\tassertThat(nestedAnnoArray[1].getString(\"value\")).isEqualTo(\"na1\");\n\t\t\tassertThat(nestedAnnoArray[1].getEnum(\"anEnum\").equals(SomeEnum.LABEL2)).isTrue();\n\t\t\tassertThat((Class<?>[]) nestedAnnoArray[1].get(\"classArray\")).isEqualTo(new Class<?>[] {Number.class});\n\t\t\tassertThat(nestedAnnoArray[1].getClassArray(\"classArray\")).isEqualTo(new Class<?>[] {Number.class});\n\n\t\t\tAnnotationAttributes optional = specialAttrs.getAnnotation(\"optional\");\n\t\t\tassertThat(optional.getString(\"value\")).isEqualTo(\"optional\");\n\t\t\tassertThat(optional.getEnum(\"anEnum\").equals(SomeEnum.DEFAULT)).isTrue();\n\t\t\tassertThat((Class<?>[]) optional.get(\"classArray\")).isEqualTo(new Class<?>[] {Void.class});\n\t\t\tassertThat(optional.getClassArray(\"classArray\")).isEqualTo(new Class<?>[] {Void.class});\n\n\t\t\tAnnotationAttributes[] optionalArray = specialAttrs.getAnnotationArray(\"optionalArray\");\n\t\t\tassertThat(optionalArray).hasSize(1);\n\t\t\tassertThat(optionalArray[0].getString(\"value\")).isEqualTo(\"optional\");\n\t\t\tassertThat(optionalArray[0].getEnum(\"anEnum\").equals(SomeEnum.DEFAULT)).isTrue();\n\t\t\tassertThat((Class<?>[]) optionalArray[0].get(\"classArray\")).isEqualTo(new Class<?>[] {Void.class});\n\t\t\tassertThat(optionalArray[0].getClassArray(\"classArray\")).isEqualTo(new Class<?>[] {Void.class});\n\n\t\t\tassertThat(metadata.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\")).isEqualTo(\"direct\");\n\t\t\tallMeta = metadata.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\");\n\t\t\tassertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(Arrays.asList(\"direct\", \"meta\")));\n\t\t\tallMeta = metadata.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"additional\");\n\t\t\tassertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(Arrays.asList(\"direct\", \"\")));\n\t\t\tassertThat(metadata.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"additional\")).isEqualTo(\"\");\n\t\t\tassertThat(((String[]) metadata.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"additionalArray\"))).isEmpty();\n\t\t}\n\t\t{ // perform tests with classValuesAsString = true\n\t\t\tAnnotationAttributes specialAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(\n\t\t\t\tSpecialAttr.class.getName(), true);\n\t\t\tassertThat(specialAttrs).hasSize(6);\n\t\t\tassertThat(specialAttrs.get(\"clazz\")).isEqualTo(String.class.getName());\n\t\t\tassertThat(specialAttrs.getString(\"clazz\")).isEqualTo(String.class.getName());\n\n\t\t\tAnnotationAttributes nestedAnno = specialAttrs.getAnnotation(\"nestedAnno\");\n\t\t\tassertThat(nestedAnno.getStringArray(\"classArray\")).isEqualTo(new String[] { String.class.getName() });\n\t\t\tassertThat(nestedAnno.getStringArray(\"classArray\")).isEqualTo(new String[] { String.class.getName() });\n\n\t\t\tAnnotationAttributes[] nestedAnnoArray = specialAttrs.getAnnotationArray(\"nestedAnnoArray\");\n\t\t\tassertThat((String[]) nestedAnnoArray[0].get(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\t\t\tassertThat(nestedAnnoArray[0].getStringArray(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\t\t\tassertThat((String[]) nestedAnnoArray[1].get(\"classArray\")).isEqualTo(new String[] { Number.class.getName() });\n\t\t\tassertThat(nestedAnnoArray[1].getStringArray(\"classArray\")).isEqualTo(new String[] { Number.class.getName() });\n\n\t\t\tAnnotationAttributes optional = specialAttrs.getAnnotation(\"optional\");\n\t\t\tassertThat((String[]) optional.get(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\t\t\tassertThat(optional.getStringArray(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\n\t\t\tAnnotationAttributes[] optionalArray = specialAttrs.getAnnotationArray(\"optionalArray\");\n\t\t\tassertThat((String[]) optionalArray[0].get(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\t\t\tassertThat(optionalArray[0].getStringArray(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\n\t\t\tassertThat(metadata.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\")).isEqualTo(\"direct\");\n\t\t\tallMeta = metadata.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\");\n\t\t\tassertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(Arrays.asList(\"direct\", \"meta\")));\n\t\t}\n\t}\n\n\tprivate void doTestMethodAnnotationInfo(AnnotationMetadata classMetadata) {\n\t\tassertThat(classMetadata.getDeclaredMethods()).hasSize(3);\n\t\tSet<MethodMetadata> methods = classMetadata.getAnnotatedMethods(TestAutowired.class.getName());\n\t\tassertThat(methods).hasSize(1);\n\t\tfor (MethodMetadata methodMetadata : methods) {\n\t\t\tassertThat(methodMetadata.isAnnotated(TestAutowired.class.getName())).isTrue();\n\t\t}\n\t}\n\n\n\t// -------------------------------------------------------------------------\n\n\tpublic enum SomeEnum {\n\t\tLABEL1, LABEL2, DEFAULT\n\t}\n\n\t@Target({})\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface NestedAnno {\n\n\t\tString value() default \"default\";\n\n\t\tSomeEnum anEnum() default SomeEnum.DEFAULT;\n\n\t\tClass<?>[] classArray() default Void.class;\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface SpecialAttr {\n\n\t\tClass<?> clazz();\n\n\t\tThread.State state();\n\n\t\tNestedAnno nestedAnno();\n\n\t\tNestedAnno[] nestedAnnoArray();\n\n\t\tNestedAnno optional() default @NestedAnno(value = \"optional\", anEnum = SomeEnum.DEFAULT, classArray = Void.class);\n\n\t\tNestedAnno[] optionalArray() default { @NestedAnno(value = \"optional\", anEnum = SomeEnum.DEFAULT, classArray = Void.class) };\n\t}\n\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface DirectAnnotation {\n\n\t\t@AliasFor(\"myValue\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString myValue() default \"\";\n\n\t\tString additional() default \"direct\";\n\n\t\tString[] additionalArray() default \"direct\";\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface IsAnnotatedAnnotation {\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DirectAnnotation(\"meta\")\n\t@IsAnnotatedAnnotation\n\tpublic @interface MetaAnnotation {\n\n\t\tString additional() default \"meta\";\n\t}\n\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@MetaAnnotation\n\tpublic @interface MetaMetaAnnotation {\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface EnumSubclasses {\n\n\t\tSubclassEnum[] value();\n\t}\n\n\t// SPR-10914\n\tpublic enum SubclassEnum {\n\t\tFOO {\n\t\t/* Do not delete! This subclassing is intentional. */\n\t\t},\n\t\tBAR {\n\t\t/* Do not delete! This subclassing is intentional. */\n\t\t}\n\t}\n\n\t@Component(\"myName\")\n\t@Scope(\"myScope\")\n\t@SpecialAttr(clazz = String.class, state = Thread.State.NEW,\n\t\t\tnestedAnno = @NestedAnno(value = \"na\", anEnum = SomeEnum.LABEL1, classArray = {String.class}),\n\t\t\tnestedAnnoArray = {@NestedAnno, @NestedAnno(value = \"na1\", anEnum = SomeEnum.LABEL2, classArray = {Number.class})})\n\t@SuppressWarnings({\"serial\", \"unused\"})\n\t@DirectAnnotation(value = \"direct\", additional = \"\", additionalArray = {})\n\t@MetaMetaAnnotation\n\t@EnumSubclasses({SubclassEnum.FOO, SubclassEnum.BAR})\n\t@NamedComposedAnnotation\n\tprivate static class AnnotatedComponent implements Serializable {\n\n\t\tpublic AnnotatedComponent() {\n\t\t}\n\n\t\t@TestAutowired\n\t\tpublic void doWork(@TestQualifier(\"myColor\") java.awt.Color color) {\n\t\t}\n\n\t\tpublic void doSleep() {\n\t\t}\n\n\t\t@DirectAnnotation(\"direct\")\n\t\t@MetaMetaAnnotation\n\t\tpublic void meta() {\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"serial\")\n\tprivate static class AnnotatedComponentSubClass extends AnnotatedComponent {\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Component\n\tpublic @interface TestConfiguration {\n\n\t\tString value() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface TestComponentScans {\n\n\t\tTestComponentScan[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@Repeatable(TestComponentScans.class)\n\tpublic @interface TestComponentScan {\n\n\t\t@AliasFor(\"basePackages\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] basePackages() default {};\n\n\t\tClass<?>[] basePackageClasses() default {};\n\t}\n\n\t@TestConfiguration\n\t@TestComponentScan(basePackages = \"bogus\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface ComposedConfigurationWithAttributeOverrides {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = TestComponentScan.class)\n\t\tString[] basePackages() default {};\n\t}\n\n\t@ComposedConfigurationWithAttributeOverrides(basePackages = \"org.example.componentscan\")\n\tpublic static class ComposedConfigurationWithAttributeOverridesClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@TestComponentScan(\"C\")\n\tpublic @interface ScanPackageC {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@TestComponentScan(\"D\")\n\tpublic @interface ScanPackageD {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@TestComponentScans({\n\t\t@TestComponentScan(\"C\"),\n\t\t@TestComponentScan(\"D\")\n\t})\n\tpublic @interface ScanPackagesCandD {\n\t}\n\n\t@TestComponentScan(basePackages = \"A\", basePackageClasses = String.class)\n\t@ScanPackageC\n\t@ScanPackageD\n\t@TestComponentScan(basePackages = \"B\", basePackageClasses = Integer.class)\n\tstatic class MultipleComposedRepeatableAnnotationsClass {\n\t}\n\n\t@TestComponentScan(basePackages = \"A\", basePackageClasses = String.class)\n\t@ScanPackagesCandD\n\t@TestComponentScans(@TestComponentScan(basePackages = \"B\", basePackageClasses = Integer.class))\n\tstatic class MultipleRepeatableAnnotationsInContainersClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface NamedAnnotation1 {\n\t\tString name() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface NamedAnnotation2 {\n\t\tString name() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface NamedAnnotation3 {\n\t\tString name() default \"\";\n\t}\n\n\t@NamedAnnotation1(name = \"name 1\")\n\t@NamedAnnotation2(name = \"name 2\")\n\t@NamedAnnotation3(name = \"name 3\")\n\tpublic static class NamedAnnotationsClass {\n\t}\n\n\t@NamedAnnotation1(name = \"name 1\")\n\t@NamedAnnotation2(name = \"name 2\")\n\t@NamedAnnotation3(name = \"name 3\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@Inherited\n\tpublic @interface NamedComposedAnnotation {\n\t}\n\n\t@NamedComposedAnnotation\n\tpublic static class NamedComposedAnnotationClass {\n\t}\n\n\tpublic static class NamedComposedAnnotationExtended extends NamedComposedAnnotationClass {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.type",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.type.NamedComposedAnnotationClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.type.NamedComposedAnnotationClass",
    "headType": "class",
    "relation": "use",
    "tail": "@NamedComposedAnnotation",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.type.NamedComposedAnnotationClass",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.type;\n\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.AliasFor;\nimport org.springframework.core.annotation.AnnotatedElementUtils;\nimport org.springframework.core.annotation.AnnotationAttributes;\nimport org.springframework.core.testfixture.stereotype.Component;\nimport org.springframework.core.type.classreading.MetadataReader;\nimport org.springframework.core.type.classreading.MetadataReaderFactory;\nimport org.springframework.core.type.classreading.SimpleMetadataReaderFactory;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Unit tests demonstrating that the reflection-based {@link StandardAnnotationMetadata}\n * and ASM-based {@code SimpleAnnotationMetadata} produce <em>almost</em> identical output.\n *\n * @author Juergen Hoeller\n * @author Chris Beams\n * @author Phillip Webb\n * @author Sam Brannen\n * @see InheritedAnnotationsAnnotationMetadataTests\n */\nclass AnnotationMetadataTests {\n\n\t@Test\n\tvoid standardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(AnnotatedComponent.class);\n\t\tdoTestAnnotationInfo(metadata);\n\t\tdoTestMethodAnnotationInfo(metadata);\n\t}\n\n\t@Test\n\tvoid asmAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(AnnotatedComponent.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tdoTestAnnotationInfo(metadata);\n\t\tdoTestMethodAnnotationInfo(metadata);\n\t}\n\n\t@Test\n\tvoid standardAnnotationMetadataForSubclass() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(AnnotatedComponentSubClass.class);\n\t\tdoTestSubClassAnnotationInfo(metadata, false);\n\t}\n\n\t@Test\n\tvoid asmAnnotationMetadataForSubclass() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(AnnotatedComponentSubClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tdoTestSubClassAnnotationInfo(metadata, true);\n\t}\n\n\tprivate void doTestSubClassAnnotationInfo(AnnotationMetadata metadata, boolean asm) {\n\t\tassertThat(metadata.getClassName()).isEqualTo(AnnotatedComponentSubClass.class.getName());\n\t\tassertThat(metadata.isInterface()).isFalse();\n\t\tassertThat(metadata.isAnnotation()).isFalse();\n\t\tassertThat(metadata.isAbstract()).isFalse();\n\t\tassertThat(metadata.isConcrete()).isTrue();\n\t\tassertThat(metadata.hasSuperClass()).isTrue();\n\t\tassertThat(metadata.getSuperClassName()).isEqualTo(AnnotatedComponent.class.getName());\n\t\tassertThat(metadata.getInterfaceNames()).isEmpty();\n\t\tassertThat(metadata.isAnnotated(Component.class.getName())).isFalse();\n\t\tassertThat(metadata.isAnnotated(Scope.class.getName())).isFalse();\n\t\tassertThat(metadata.isAnnotated(SpecialAttr.class.getName())).isFalse();\n\n\t\tif (asm) {\n\t\t\tassertThat(metadata.isAnnotated(NamedComposedAnnotation.class.getName())).isFalse();\n\t\t\tassertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isFalse();\n\t\t\tassertThat(metadata.getAnnotationTypes()).isEmpty();\n\t\t}\n\t\telse {\n\t\t\tassertThat(metadata.isAnnotated(NamedComposedAnnotation.class.getName())).isTrue();\n\t\t\tassertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isTrue();\n\t\t\tassertThat(metadata.getAnnotationTypes()).containsExactly(NamedComposedAnnotation.class.getName());\n\t\t}\n\n\t\tassertThat(metadata.hasAnnotation(Component.class.getName())).isFalse();\n\t\tassertThat(metadata.hasAnnotation(Scope.class.getName())).isFalse();\n\t\tassertThat(metadata.hasAnnotation(SpecialAttr.class.getName())).isFalse();\n\t\tassertThat(metadata.hasMetaAnnotation(Component.class.getName())).isFalse();\n\t\tassertThat(metadata.hasMetaAnnotation(MetaAnnotation.class.getName())).isFalse();\n\t\tassertThat(metadata.getAnnotationAttributes(Component.class.getName())).isNull();\n\t\tassertThat(metadata.getAnnotationAttributes(MetaAnnotation.class.getName(), false)).isNull();\n\t\tassertThat(metadata.getAnnotationAttributes(MetaAnnotation.class.getName(), true)).isNull();\n\t\tassertThat(metadata.getAnnotatedMethods(DirectAnnotation.class.getName())).isEmpty();\n\t\tassertThat(metadata.isAnnotated(IsAnnotatedAnnotation.class.getName())).isFalse();\n\t\tassertThat(metadata.getAllAnnotationAttributes(DirectAnnotation.class.getName())).isNull();\n\t}\n\n\t@Test\n\tvoid standardAnnotationMetadataForInterface() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(AnnotationMetadata.class);\n\t\tdoTestMetadataForInterfaceClass(metadata);\n\t}\n\n\t@Test\n\tvoid asmAnnotationMetadataForInterface() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(AnnotationMetadata.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tdoTestMetadataForInterfaceClass(metadata);\n\t}\n\n\tprivate void doTestMetadataForInterfaceClass(AnnotationMetadata metadata) {\n\t\tassertThat(metadata.getClassName()).isEqualTo(AnnotationMetadata.class.getName());\n\t\tassertThat(metadata.isInterface()).isTrue();\n\t\tassertThat(metadata.isAnnotation()).isFalse();\n\t\tassertThat(metadata.isAbstract()).isTrue();\n\t\tassertThat(metadata.isConcrete()).isFalse();\n\t\tassertThat(metadata.hasSuperClass()).isFalse();\n\t\tassertThat(metadata.getSuperClassName()).isNull();\n\t\tassertThat(metadata.getInterfaceNames()).hasSize(2);\n\t\tassertThat(metadata.getInterfaceNames()[0]).isEqualTo(ClassMetadata.class.getName());\n\t\tassertThat(metadata.getInterfaceNames()[1]).isEqualTo(AnnotatedTypeMetadata.class.getName());\n\t\tassertThat(metadata.getAnnotationTypes()).isEmpty();\n\t}\n\n\t@Test\n\tvoid standardAnnotationMetadataForAnnotation() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(Component.class);\n\t\tdoTestMetadataForAnnotationClass(metadata);\n\t}\n\n\t@Test\n\tvoid asmAnnotationMetadataForAnnotation() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(Component.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tdoTestMetadataForAnnotationClass(metadata);\n\t}\n\n\tprivate void doTestMetadataForAnnotationClass(AnnotationMetadata metadata) {\n\t\tassertThat(metadata.getClassName()).isEqualTo(Component.class.getName());\n\t\tassertThat(metadata.isInterface()).isTrue();\n\t\tassertThat(metadata.isAnnotation()).isTrue();\n\t\tassertThat(metadata.isAbstract()).isTrue();\n\t\tassertThat(metadata.isConcrete()).isFalse();\n\t\tassertThat(metadata.hasSuperClass()).isFalse();\n\t\tassertThat(metadata.getSuperClassName()).isNull();\n\t\tassertThat(metadata.getInterfaceNames()).hasSize(1);\n\t\tassertThat(metadata.getInterfaceNames()[0]).isEqualTo(Annotation.class.getName());\n\t\tassertThat(metadata.isAnnotated(Documented.class.getName())).isFalse();\n\t\tassertThat(metadata.isAnnotated(Scope.class.getName())).isFalse();\n\t\tassertThat(metadata.isAnnotated(SpecialAttr.class.getName())).isFalse();\n\t\tassertThat(metadata.hasAnnotation(Documented.class.getName())).isFalse();\n\t\tassertThat(metadata.hasAnnotation(Scope.class.getName())).isFalse();\n\t\tassertThat(metadata.hasAnnotation(SpecialAttr.class.getName())).isFalse();\n\t\tassertThat(metadata.getAnnotationTypes()).hasSize(1);\n\t}\n\n\t/**\n\t * In order to preserve backward-compatibility, {@link StandardAnnotationMetadata}\n\t * defaults to return nested annotations and annotation arrays as actual\n\t * Annotation instances. It is recommended for compatibility with ASM-based\n\t * AnnotationMetadata implementations to set the 'nestedAnnotationsAsMap' flag to\n\t * 'true' as is done in the main test above.\n\t */\n\t@Test\n\tvoid standardAnnotationMetadata_nestedAnnotationsAsMap_false() {\n\t\t@SuppressWarnings(\"deprecation\")\n\t\tAnnotationMetadata metadata = new StandardAnnotationMetadata(AnnotatedComponent.class);\n\t\tAnnotationAttributes specialAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(SpecialAttr.class.getName());\n\t\tAnnotation[] nestedAnnoArray = (Annotation[]) specialAttrs.get(\"nestedAnnoArray\");\n\t\tassertThat(nestedAnnoArray[0]).isInstanceOf(NestedAnno.class);\n\t}\n\n\t@Test\n\tvoid metaAnnotationOverridesUsingStandardAnnotationMetadata() {\n\t\t@SuppressWarnings(\"deprecation\")\n\t\tAnnotationMetadata metadata = new StandardAnnotationMetadata(ComposedConfigurationWithAttributeOverridesClass.class);\n\t\tassertMetaAnnotationOverrides(metadata);\n\t}\n\n\t@Test\n\tvoid metaAnnotationOverridesUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(ComposedConfigurationWithAttributeOverridesClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertMetaAnnotationOverrides(metadata);\n\t}\n\n\tprivate void assertMetaAnnotationOverrides(AnnotationMetadata metadata) {\n\t\tAnnotationAttributes attributes = (AnnotationAttributes) metadata.getAnnotationAttributes(\n\t\t\t\tTestComponentScan.class.getName(), false);\n\t\tassertThat(attributes.getStringArray(\"value\")).containsExactly(\"org.example.componentscan\");\n\t\tassertThat(attributes.getStringArray(\"basePackages\")).containsExactly(\"org.example.componentscan\");\n\t\tassertThat(attributes.getClassArray(\"basePackageClasses\")).isEmpty();\n\t}\n\n\t@Test  // SPR-11649\n\tvoid multipleAnnotationsWithIdenticalAttributeNamesUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(NamedAnnotationsClass.class);\n\t\tassertMultipleAnnotationsWithIdenticalAttributeNames(metadata);\n\t}\n\n\t@Test  // SPR-11649\n\tvoid multipleAnnotationsWithIdenticalAttributeNamesUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(NamedAnnotationsClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertMultipleAnnotationsWithIdenticalAttributeNames(metadata);\n\t}\n\n\t@Test  // SPR-11649\n\tvoid composedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(NamedComposedAnnotationClass.class);\n\t\tassertMultipleAnnotationsWithIdenticalAttributeNames(metadata);\n\t}\n\n\t@Test  // SPR-11649\n\tvoid composedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(NamedComposedAnnotationClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertMultipleAnnotationsWithIdenticalAttributeNames(metadata);\n\t}\n\n\t@Test  // gh-31041\n\tvoid multipleComposedRepeatableAnnotationsUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(MultipleComposedRepeatableAnnotationsClass.class);\n\t\tassertRepeatableAnnotations(metadata);\n\t}\n\n\t@Test  // gh-31041\n\tvoid multipleComposedRepeatableAnnotationsUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(MultipleComposedRepeatableAnnotationsClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertRepeatableAnnotations(metadata);\n\t}\n\n\t@Test  // gh-31074\n\tvoid multipleComposedRepeatableAnnotationsSortedByReversedMetaDistanceUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(MultipleComposedRepeatableAnnotationsClass.class);\n\t\tassertRepeatableAnnotationsSortedByReversedMetaDistance(metadata);\n\t}\n\n\t@Test  // gh-31074\n\tvoid multipleComposedRepeatableAnnotationsSortedByReversedMetaDistanceUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(MultipleComposedRepeatableAnnotationsClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertRepeatableAnnotationsSortedByReversedMetaDistance(metadata);\n\t}\n\n\t@Test  // gh-31041\n\tvoid multipleRepeatableAnnotationsInContainersUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(MultipleRepeatableAnnotationsInContainersClass.class);\n\t\tassertRepeatableAnnotations(metadata);\n\t}\n\n\t@Test  // gh-31041\n\tvoid multipleRepeatableAnnotationsInContainersUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(MultipleRepeatableAnnotationsInContainersClass.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertRepeatableAnnotations(metadata);\n\t}\n\n\t/**\n\t * Tests {@code AnnotatedElementUtils#getMergedRepeatableAnnotations()} variants to ensure that\n\t * {@link AnnotationMetadata#getMergedRepeatableAnnotationAttributes(Class, Class, boolean)}\n\t * behaves the same.\n\t */\n\t@Test  // gh-31041\n\tvoid multipleComposedRepeatableAnnotationsUsingAnnotatedElementUtils() {\n\t\tClass<?> element = MultipleComposedRepeatableAnnotationsClass.class;\n\n\t\tSet<TestComponentScan> annotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(element, TestComponentScan.class);\n\t\tassertRepeatableAnnotations(annotations);\n\n\t\tannotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(element, TestComponentScan.class, TestComponentScans.class);\n\t\tassertRepeatableAnnotations(annotations);\n\t}\n\n\t/**\n\t * Tests {@code AnnotatedElementUtils#getMergedRepeatableAnnotations()} variants to ensure that\n\t * {@link AnnotationMetadata#getMergedRepeatableAnnotationAttributes(Class, Class, boolean)}\n\t * behaves the same.\n\t */\n\t@Test  // gh-31041\n\tvoid multipleRepeatableAnnotationsInContainersUsingAnnotatedElementUtils() {\n\t\tClass<?> element = MultipleRepeatableAnnotationsInContainersClass.class;\n\n\t\tSet<TestComponentScan> annotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(element, TestComponentScan.class);\n\t\tassertRepeatableAnnotations(annotations);\n\n\t\tannotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(element, TestComponentScan.class, TestComponentScans.class);\n\t\tassertRepeatableAnnotations(annotations);\n\t}\n\n\tprivate static void assertRepeatableAnnotations(AnnotationMetadata metadata) {\n\t\tSet<AnnotationAttributes> attributesSet =\n\t\t\t\tmetadata.getMergedRepeatableAnnotationAttributes(TestComponentScan.class, TestComponentScans.class, true);\n\t\tassertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"value\")).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"A\", \"B\", \"C\", \"D\");\n\t\tassertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"basePackages\")).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"A\", \"B\", \"C\", \"D\");\n\t\tassertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"basePackageClasses\")).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"java.lang.String\", \"java.lang.Integer\");\n\t}\n\n\tprivate static void assertRepeatableAnnotationsSortedByReversedMetaDistance(AnnotationMetadata metadata) {\n\t\t// Note: although the real @ComponentScan annotation is not looked up using\n\t\t// \"sortByReversedMetaDistance\" semantics, we can still use @TestComponentScan\n\t\t// to verify the expected behavior.\n\t\tSet<AnnotationAttributes> attributesSet =\n\t\t\t\tmetadata.getMergedRepeatableAnnotationAttributes(TestComponentScan.class, TestComponentScans.class, false, true);\n\t\tassertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"value\")).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"C\", \"D\", \"A\", \"B\");\n\t\tassertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"basePackages\")).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"C\", \"D\", \"A\", \"B\");\n\t}\n\n\tprivate static void assertRepeatableAnnotations(Set<TestComponentScan> annotations) {\n\t\tassertThat(annotations.stream().map(TestComponentScan::value).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"A\", \"B\", \"C\", \"D\");\n\t\tassertThat(annotations.stream().map(TestComponentScan::basePackages).flatMap(Arrays::stream))\n\t\t\t\t.containsExactly(\"A\", \"B\", \"C\", \"D\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingStandardAnnotationMetadata() {\n\t\tAnnotationMetadata metadata = AnnotationMetadata.introspect(NamedComposedAnnotationExtended.class);\n\t\tassertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isTrue();\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingSimpleAnnotationMetadata() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(NamedComposedAnnotationExtended.class.getName());\n\t\tAnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\n\t\tassertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isFalse();\n\t}\n\n\n\tprivate void assertMultipleAnnotationsWithIdenticalAttributeNames(AnnotationMetadata metadata) {\n\t\tAnnotationAttributes attributes1 = (AnnotationAttributes) metadata.getAnnotationAttributes(\n\t\t\t\tNamedAnnotation1.class.getName(), false);\n\t\tString name1 = attributes1.getString(\"name\");\n\t\tassertThat(name1).as(\"name of NamedAnnotation1\").isEqualTo(\"name 1\");\n\n\t\tAnnotationAttributes attributes2 = (AnnotationAttributes) metadata.getAnnotationAttributes(\n\t\t\t\tNamedAnnotation2.class.getName(), false);\n\t\tString name2 = attributes2.getString(\"name\");\n\t\tassertThat(name2).as(\"name of NamedAnnotation2\").isEqualTo(\"name 2\");\n\n\t\tAnnotationAttributes attributes3 = (AnnotationAttributes) metadata.getAnnotationAttributes(\n\t\t\t\tNamedAnnotation3.class.getName(), false);\n\t\tString name3 = attributes3.getString(\"name\");\n\t\tassertThat(name3).as(\"name of NamedAnnotation3\").isEqualTo(\"name 3\");\n\t}\n\n\tprivate void doTestAnnotationInfo(AnnotationMetadata metadata) {\n\t\tassertThat(metadata.getClassName()).isEqualTo(AnnotatedComponent.class.getName());\n\t\tassertThat(metadata.isInterface()).isFalse();\n\t\tassertThat(metadata.isAnnotation()).isFalse();\n\t\tassertThat(metadata.isAbstract()).isFalse();\n\t\tassertThat(metadata.isConcrete()).isTrue();\n\t\tassertThat(metadata.hasSuperClass()).isTrue();\n\t\tassertThat(metadata.getSuperClassName()).isEqualTo(Object.class.getName());\n\t\tassertThat(metadata.getInterfaceNames()).hasSize(1);\n\t\tassertThat(metadata.getInterfaceNames()[0]).isEqualTo(Serializable.class.getName());\n\n\t\tassertThat(metadata.isAnnotated(Component.class.getName())).isTrue();\n\n\t\tassertThat(metadata.isAnnotated(NamedComposedAnnotation.class.getName())).isTrue();\n\n\t\tassertThat(metadata.hasAnnotation(Component.class.getName())).isTrue();\n\t\tassertThat(metadata.hasAnnotation(Scope.class.getName())).isTrue();\n\t\tassertThat(metadata.hasAnnotation(SpecialAttr.class.getName())).isTrue();\n\n\t\tassertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isTrue();\n\t\tassertThat(metadata.getAnnotationTypes()).containsExactlyInAnyOrder(\n\t\t\t\tComponent.class.getName(), Scope.class.getName(),\n\t\t\t\tSpecialAttr.class.getName(), DirectAnnotation.class.getName(),\n\t\t\t\tMetaMetaAnnotation.class.getName(), EnumSubclasses.class.getName(),\n\t\t\t\tNamedComposedAnnotation.class.getName());\n\n\t\tAnnotationAttributes compAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(Component.class.getName());\n\t\tassertThat(compAttrs).hasSize(1);\n\t\tassertThat(compAttrs.getString(\"value\")).isEqualTo(\"myName\");\n\t\tAnnotationAttributes scopeAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(Scope.class.getName());\n\t\tassertThat(scopeAttrs).hasSize(1);\n\t\tassertThat(scopeAttrs.getString(\"value\")).isEqualTo(\"myScope\");\n\n\t\tSet<MethodMetadata> methods = metadata.getAnnotatedMethods(DirectAnnotation.class.getName());\n\t\tMethodMetadata method = methods.iterator().next();\n\t\tassertThat(method.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\")).isEqualTo(\"direct\");\n\t\tassertThat(method.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"myValue\")).isEqualTo(\"direct\");\n\t\tList<Object> allMeta = method.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\");\n\t\tassertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(Arrays.asList(\"direct\", \"meta\")));\n\t\tallMeta = method.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"additional\");\n\t\tassertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(List.of(\"direct\")));\n\n\t\tassertThat(metadata.isAnnotated(IsAnnotatedAnnotation.class.getName())).isTrue();\n\n\t\t{ // perform tests with classValuesAsString = false (the default)\n\t\t\tAnnotationAttributes specialAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(SpecialAttr.class.getName());\n\t\t\tassertThat(specialAttrs).hasSize(6);\n\t\t\tassertThat(String.class.isAssignableFrom(specialAttrs.getClass(\"clazz\"))).isTrue();\n\t\t\tassertThat(specialAttrs.getEnum(\"state\").equals(Thread.State.NEW)).isTrue();\n\n\t\t\tAnnotationAttributes nestedAnno = specialAttrs.getAnnotation(\"nestedAnno\");\n\t\t\tassertThat(nestedAnno.getString(\"value\")).isEqualTo(\"na\");\n\t\t\tassertThat(nestedAnno.getEnum(\"anEnum\").equals(SomeEnum.LABEL1)).isTrue();\n\t\t\tassertThat((Class<?>[]) nestedAnno.get(\"classArray\")).isEqualTo(new Class<?>[] {String.class});\n\n\t\t\tAnnotationAttributes[] nestedAnnoArray = specialAttrs.getAnnotationArray(\"nestedAnnoArray\");\n\t\t\tassertThat(nestedAnnoArray).hasSize(2);\n\t\t\tassertThat(nestedAnnoArray[0].getString(\"value\")).isEqualTo(\"default\");\n\t\t\tassertThat(nestedAnnoArray[0].getEnum(\"anEnum\").equals(SomeEnum.DEFAULT)).isTrue();\n\t\t\tassertThat((Class<?>[]) nestedAnnoArray[0].get(\"classArray\")).isEqualTo(new Class<?>[] {Void.class});\n\t\t\tassertThat(nestedAnnoArray[1].getString(\"value\")).isEqualTo(\"na1\");\n\t\t\tassertThat(nestedAnnoArray[1].getEnum(\"anEnum\").equals(SomeEnum.LABEL2)).isTrue();\n\t\t\tassertThat((Class<?>[]) nestedAnnoArray[1].get(\"classArray\")).isEqualTo(new Class<?>[] {Number.class});\n\t\t\tassertThat(nestedAnnoArray[1].getClassArray(\"classArray\")).isEqualTo(new Class<?>[] {Number.class});\n\n\t\t\tAnnotationAttributes optional = specialAttrs.getAnnotation(\"optional\");\n\t\t\tassertThat(optional.getString(\"value\")).isEqualTo(\"optional\");\n\t\t\tassertThat(optional.getEnum(\"anEnum\").equals(SomeEnum.DEFAULT)).isTrue();\n\t\t\tassertThat((Class<?>[]) optional.get(\"classArray\")).isEqualTo(new Class<?>[] {Void.class});\n\t\t\tassertThat(optional.getClassArray(\"classArray\")).isEqualTo(new Class<?>[] {Void.class});\n\n\t\t\tAnnotationAttributes[] optionalArray = specialAttrs.getAnnotationArray(\"optionalArray\");\n\t\t\tassertThat(optionalArray).hasSize(1);\n\t\t\tassertThat(optionalArray[0].getString(\"value\")).isEqualTo(\"optional\");\n\t\t\tassertThat(optionalArray[0].getEnum(\"anEnum\").equals(SomeEnum.DEFAULT)).isTrue();\n\t\t\tassertThat((Class<?>[]) optionalArray[0].get(\"classArray\")).isEqualTo(new Class<?>[] {Void.class});\n\t\t\tassertThat(optionalArray[0].getClassArray(\"classArray\")).isEqualTo(new Class<?>[] {Void.class});\n\n\t\t\tassertThat(metadata.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\")).isEqualTo(\"direct\");\n\t\t\tallMeta = metadata.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\");\n\t\t\tassertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(Arrays.asList(\"direct\", \"meta\")));\n\t\t\tallMeta = metadata.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"additional\");\n\t\t\tassertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(Arrays.asList(\"direct\", \"\")));\n\t\t\tassertThat(metadata.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"additional\")).isEqualTo(\"\");\n\t\t\tassertThat(((String[]) metadata.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"additionalArray\"))).isEmpty();\n\t\t}\n\t\t{ // perform tests with classValuesAsString = true\n\t\t\tAnnotationAttributes specialAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(\n\t\t\t\tSpecialAttr.class.getName(), true);\n\t\t\tassertThat(specialAttrs).hasSize(6);\n\t\t\tassertThat(specialAttrs.get(\"clazz\")).isEqualTo(String.class.getName());\n\t\t\tassertThat(specialAttrs.getString(\"clazz\")).isEqualTo(String.class.getName());\n\n\t\t\tAnnotationAttributes nestedAnno = specialAttrs.getAnnotation(\"nestedAnno\");\n\t\t\tassertThat(nestedAnno.getStringArray(\"classArray\")).isEqualTo(new String[] { String.class.getName() });\n\t\t\tassertThat(nestedAnno.getStringArray(\"classArray\")).isEqualTo(new String[] { String.class.getName() });\n\n\t\t\tAnnotationAttributes[] nestedAnnoArray = specialAttrs.getAnnotationArray(\"nestedAnnoArray\");\n\t\t\tassertThat((String[]) nestedAnnoArray[0].get(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\t\t\tassertThat(nestedAnnoArray[0].getStringArray(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\t\t\tassertThat((String[]) nestedAnnoArray[1].get(\"classArray\")).isEqualTo(new String[] { Number.class.getName() });\n\t\t\tassertThat(nestedAnnoArray[1].getStringArray(\"classArray\")).isEqualTo(new String[] { Number.class.getName() });\n\n\t\t\tAnnotationAttributes optional = specialAttrs.getAnnotation(\"optional\");\n\t\t\tassertThat((String[]) optional.get(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\t\t\tassertThat(optional.getStringArray(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\n\t\t\tAnnotationAttributes[] optionalArray = specialAttrs.getAnnotationArray(\"optionalArray\");\n\t\t\tassertThat((String[]) optionalArray[0].get(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\t\t\tassertThat(optionalArray[0].getStringArray(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\n\n\t\t\tassertThat(metadata.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\")).isEqualTo(\"direct\");\n\t\t\tallMeta = metadata.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\");\n\t\t\tassertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(Arrays.asList(\"direct\", \"meta\")));\n\t\t}\n\t}\n\n\tprivate void doTestMethodAnnotationInfo(AnnotationMetadata classMetadata) {\n\t\tassertThat(classMetadata.getDeclaredMethods()).hasSize(3);\n\t\tSet<MethodMetadata> methods = classMetadata.getAnnotatedMethods(TestAutowired.class.getName());\n\t\tassertThat(methods).hasSize(1);\n\t\tfor (MethodMetadata methodMetadata : methods) {\n\t\t\tassertThat(methodMetadata.isAnnotated(TestAutowired.class.getName())).isTrue();\n\t\t}\n\t}\n\n\n\t// -------------------------------------------------------------------------\n\n\tpublic enum SomeEnum {\n\t\tLABEL1, LABEL2, DEFAULT\n\t}\n\n\t@Target({})\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface NestedAnno {\n\n\t\tString value() default \"default\";\n\n\t\tSomeEnum anEnum() default SomeEnum.DEFAULT;\n\n\t\tClass<?>[] classArray() default Void.class;\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface SpecialAttr {\n\n\t\tClass<?> clazz();\n\n\t\tThread.State state();\n\n\t\tNestedAnno nestedAnno();\n\n\t\tNestedAnno[] nestedAnnoArray();\n\n\t\tNestedAnno optional() default @NestedAnno(value = \"optional\", anEnum = SomeEnum.DEFAULT, classArray = Void.class);\n\n\t\tNestedAnno[] optionalArray() default { @NestedAnno(value = \"optional\", anEnum = SomeEnum.DEFAULT, classArray = Void.class) };\n\t}\n\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface DirectAnnotation {\n\n\t\t@AliasFor(\"myValue\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString myValue() default \"\";\n\n\t\tString additional() default \"direct\";\n\n\t\tString[] additionalArray() default \"direct\";\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface IsAnnotatedAnnotation {\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DirectAnnotation(\"meta\")\n\t@IsAnnotatedAnnotation\n\tpublic @interface MetaAnnotation {\n\n\t\tString additional() default \"meta\";\n\t}\n\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@MetaAnnotation\n\tpublic @interface MetaMetaAnnotation {\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface EnumSubclasses {\n\n\t\tSubclassEnum[] value();\n\t}\n\n\t// SPR-10914\n\tpublic enum SubclassEnum {\n\t\tFOO {\n\t\t/* Do not delete! This subclassing is intentional. */\n\t\t},\n\t\tBAR {\n\t\t/* Do not delete! This subclassing is intentional. */\n\t\t}\n\t}\n\n\t@Component(\"myName\")\n\t@Scope(\"myScope\")\n\t@SpecialAttr(clazz = String.class, state = Thread.State.NEW,\n\t\t\tnestedAnno = @NestedAnno(value = \"na\", anEnum = SomeEnum.LABEL1, classArray = {String.class}),\n\t\t\tnestedAnnoArray = {@NestedAnno, @NestedAnno(value = \"na1\", anEnum = SomeEnum.LABEL2, classArray = {Number.class})})\n\t@SuppressWarnings({\"serial\", \"unused\"})\n\t@DirectAnnotation(value = \"direct\", additional = \"\", additionalArray = {})\n\t@MetaMetaAnnotation\n\t@EnumSubclasses({SubclassEnum.FOO, SubclassEnum.BAR})\n\t@NamedComposedAnnotation\n\tprivate static class AnnotatedComponent implements Serializable {\n\n\t\tpublic AnnotatedComponent() {\n\t\t}\n\n\t\t@TestAutowired\n\t\tpublic void doWork(@TestQualifier(\"myColor\") java.awt.Color color) {\n\t\t}\n\n\t\tpublic void doSleep() {\n\t\t}\n\n\t\t@DirectAnnotation(\"direct\")\n\t\t@MetaMetaAnnotation\n\t\tpublic void meta() {\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"serial\")\n\tprivate static class AnnotatedComponentSubClass extends AnnotatedComponent {\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Component\n\tpublic @interface TestConfiguration {\n\n\t\tString value() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface TestComponentScans {\n\n\t\tTestComponentScan[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@Repeatable(TestComponentScans.class)\n\tpublic @interface TestComponentScan {\n\n\t\t@AliasFor(\"basePackages\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] basePackages() default {};\n\n\t\tClass<?>[] basePackageClasses() default {};\n\t}\n\n\t@TestConfiguration\n\t@TestComponentScan(basePackages = \"bogus\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface ComposedConfigurationWithAttributeOverrides {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = TestComponentScan.class)\n\t\tString[] basePackages() default {};\n\t}\n\n\t@ComposedConfigurationWithAttributeOverrides(basePackages = \"org.example.componentscan\")\n\tpublic static class ComposedConfigurationWithAttributeOverridesClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@TestComponentScan(\"C\")\n\tpublic @interface ScanPackageC {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@TestComponentScan(\"D\")\n\tpublic @interface ScanPackageD {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@TestComponentScans({\n\t\t@TestComponentScan(\"C\"),\n\t\t@TestComponentScan(\"D\")\n\t})\n\tpublic @interface ScanPackagesCandD {\n\t}\n\n\t@TestComponentScan(basePackages = \"A\", basePackageClasses = String.class)\n\t@ScanPackageC\n\t@ScanPackageD\n\t@TestComponentScan(basePackages = \"B\", basePackageClasses = Integer.class)\n\tstatic class MultipleComposedRepeatableAnnotationsClass {\n\t}\n\n\t@TestComponentScan(basePackages = \"A\", basePackageClasses = String.class)\n\t@ScanPackagesCandD\n\t@TestComponentScans(@TestComponentScan(basePackages = \"B\", basePackageClasses = Integer.class))\n\tstatic class MultipleRepeatableAnnotationsInContainersClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface NamedAnnotation1 {\n\t\tString name() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface NamedAnnotation2 {\n\t\tString name() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\tpublic @interface NamedAnnotation3 {\n\t\tString name() default \"\";\n\t}\n\n\t@NamedAnnotation1(name = \"name 1\")\n\t@NamedAnnotation2(name = \"name 2\")\n\t@NamedAnnotation3(name = \"name 3\")\n\tpublic static class NamedAnnotationsClass {\n\t}\n\n\t@NamedAnnotation1(name = \"name 1\")\n\t@NamedAnnotation2(name = \"name 2\")\n\t@NamedAnnotation3(name = \"name 3\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@Inherited\n\tpublic @interface NamedComposedAnnotation {\n\t}\n\n\t@NamedComposedAnnotation\n\tpublic static class NamedComposedAnnotationClass {\n\t}\n\n\tpublic static class NamedComposedAnnotationExtended extends NamedComposedAnnotationClass {\n\t}\n\n}\n",
    "tailType": "class_code"
  }
]