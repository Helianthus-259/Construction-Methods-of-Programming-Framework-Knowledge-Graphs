[
  {
    "head": "org.springframework.aot.hint.predicate.ConstructorHintPredicate",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.hint.predicate.ConstructorHintPredicate#exactMatch()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.aot.hint.predicate.ConstructorHintPredicate#exactMatch()",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.aot.hint.predicate.ConstructorHintPredicate",
    "headType": "class",
    "relation": "extend",
    "tail": "ExecutableHintPredicate",
    "tailType": "class"
  },
  {
    "head": "org.springframework.aot.hint.predicate",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.aot.hint.predicate.MethodHintPredicate",
    "tailType": "class"
  },
  {
    "head": "org.springframework.aot.hint.predicate.MethodHintPredicate",
    "headType": "class",
    "relation": "use",
    "tail": "@Deprecated",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.aot.hint.predicate.MethodHintPredicate",
    "headType": "class",
    "relation": "use",
    "tail": "@SuppressWarnings",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.aot.hint.predicate.MethodHintPredicate",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.aot.hint.predicate;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Executable;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.function.Predicate;\n\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.aot.hint.ExecutableHint;\nimport org.springframework.aot.hint.ExecutableMode;\nimport org.springframework.aot.hint.MemberCategory;\nimport org.springframework.aot.hint.ReflectionHints;\nimport org.springframework.aot.hint.RuntimeHints;\nimport org.springframework.aot.hint.TypeHint;\nimport org.springframework.aot.hint.TypeReference;\nimport org.springframework.core.MethodIntrospector;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ReflectionUtils;\n\n/**\n * Generator of {@link ReflectionHints} predicates, testing whether the given hints\n * match the expected behavior for reflection.\n *\n * @author Brian Clozel\n * @author Stephane Nicoll\n * @since 6.0\n */\npublic class ReflectionHintsPredicates {\n\n\tReflectionHintsPredicates() {\n\t}\n\n\n\t/**\n\t * Return a predicate that checks whether a reflection hint is registered for the given type.\n\t * <p>The returned type exposes additional methods that refine the predicate behavior.\n\t * @param typeReference the type\n\t * @return the {@link RuntimeHints} predicate\n\t */\n\tpublic TypeHintPredicate onType(TypeReference typeReference) {\n\t\tAssert.notNull(typeReference, \"'typeReference' must not be null\");\n\t\treturn new TypeHintPredicate(typeReference);\n\t}\n\n\t/**\n\t * Return a predicate that checks whether a reflection hint is registered for the given type.\n\t * <p>The returned type exposes additional methods that refine the predicate behavior.\n\t * @param type the type\n\t * @return the {@link RuntimeHints} predicate\n\t */\n\tpublic TypeHintPredicate onType(Class<?> type) {\n\t\tAssert.notNull(type, \"'type' must not be null\");\n\t\treturn new TypeHintPredicate(TypeReference.of(type));\n\t}\n\n\t/**\n\t * Return a predicate that checks whether a reflection hint is registered for the given constructor.\n\t * By default, both introspection and invocation hints match.\n\t * <p>The returned type exposes additional methods that refine the predicate behavior.\n\t * @param constructor the constructor\n\t * @return the {@link RuntimeHints} predicate\n\t * @deprecated since 7.0 in favor of {@link #onConstructorInvocation(Constructor)}\n\t * or {@link #onType(Class)}.\n\t */\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\tpublic ConstructorHintPredicate onConstructor(Constructor<?> constructor) {\n\t\tAssert.notNull(constructor, \"'constructor' must not be null\");\n\t\treturn new ConstructorHintPredicate(constructor);\n\t}\n\n\t/**\n\t * Return a predicate that checks whether an invocation hint is registered for the given constructor.\n\t * @param constructor the constructor\n\t * @return the {@link RuntimeHints} predicate\n\t * @since 7.0\n\t */\n\tpublic Predicate<RuntimeHints> onConstructorInvocation(Constructor<?> constructor) {\n\t\tAssert.notNull(constructor, \"'constructor' must not be null\");\n\t\treturn new ConstructorHintPredicate(constructor).invoke();\n\t}\n\n\t/**\n\t * Return a predicate that checks whether a reflection hint is registered for the given method.\n\t * By default, both introspection and invocation hints match.\n\t * <p>The returned type exposes additional methods that refine the predicate behavior.\n\t * @param method the method\n\t * @return the {@link RuntimeHints} predicate\n\t * @deprecated since 7.0 in favor of {@link #onMethodInvocation(Method)}\n\t * or {@link #onType(Class)}.\n\t */\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\tpublic MethodHintPredicate onMethod(Method method) {\n\t\tAssert.notNull(method, \"'method' must not be null\");\n\t\treturn new MethodHintPredicate(method);\n\t}\n\n\t/**\n\t * Return a predicate that checks whether an invocation hint is registered for the given method.\n\t * @param method the method\n\t * @return the {@link RuntimeHints} predicate\n\t * @since 7.0\n\t */\n\tpublic Predicate<RuntimeHints> onMethodInvocation(Method method) {\n\t\tAssert.notNull(method, \"'method' must not be null\");\n\t\treturn new MethodHintPredicate(method).invoke();\n\t}\n\n\t/**\n\t * Return a predicate that checks whether a reflection hint is registered for the method that matches the given selector.\n\t * This looks up a method on the given type with the expected name, if unique.\n\t * By default, both introspection and invocation hints match.\n\t * <p>The returned type exposes additional methods that refine the predicate behavior.\n\t * @param type the type holding the method\n\t * @param methodName the method name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws IllegalArgumentException if the method cannot be found or if multiple methods are found with the same name.\n\t * @deprecated since 7.0 in favor of {@link #onMethodInvocation(Class, String)}\n\t * or {@link #onType(Class)}.\n\t */\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\tpublic MethodHintPredicate onMethod(Class<?> type, String methodName) {\n\t\tAssert.notNull(type, \"'type' must not be null\");\n\t\tAssert.hasText(methodName, \"'methodName' must not be empty\");\n\t\treturn new MethodHintPredicate(getMethod(type, methodName));\n\t}\n\n\t/**\n\t * Return a predicate that checks whether an invocation hint is registered for the method that matches the given selector.\n\t * This looks up a method on the given type with the expected name, if unique.\n\t * @param type the type holding the method\n\t * @param methodName the method name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws IllegalArgumentException if the method cannot be found or if multiple methods are found with the same name.\n\t * @since 7.0\n\t */\n\tpublic Predicate<RuntimeHints> onMethodInvocation(Class<?> type, String methodName) {\n\t\tAssert.notNull(type, \"'type' must not be null\");\n\t\tAssert.hasText(methodName, \"'methodName' must not be empty\");\n\t\treturn new MethodHintPredicate(getMethod(type, methodName)).invoke();\n\t}\n\n\t/**\n\t * Return a predicate that checks whether a reflection hint is registered for the method that matches the given selector.\n\t * This looks up a method on the given type with the expected name, if unique.\n\t * By default, both introspection and invocation hints match.\n\t * <p>The returned type exposes additional methods that refine the predicate behavior.\n\t * @param className the name of the class holding the method\n\t * @param methodName the method name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws ClassNotFoundException if the class cannot be resolved.\n\t * @throws IllegalArgumentException if the method cannot be found or if multiple methods are found with the same name.\n\t * @deprecated since 7.0 in favor of {@link #onMethodInvocation(String, String)}\n\t * or {@link #onType(Class)}.\n\t */\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\tpublic MethodHintPredicate onMethod(String className, String methodName) throws ClassNotFoundException {\n\t\tAssert.hasText(className, \"'className' must not be empty\");\n\t\tAssert.hasText(methodName, \"'methodName' must not be empty\");\n\t\treturn onMethod(Class.forName(className), methodName);\n\t}\n\n\t/**\n\t * Return a predicate that checks whether an invocation hint is registered for the method that matches the given selector.\n\t * This looks up a method on the given type with the expected name, if unique.\n\t * @param className the name of the class holding the method\n\t * @param methodName the method name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws ClassNotFoundException if the class cannot be resolved.\n\t * @throws IllegalArgumentException if the method cannot be found or if multiple methods are found with the same name.\n\t * @since 7.0\n\t */\n\tpublic Predicate<RuntimeHints> onMethodInvocation(String className, String methodName) throws ClassNotFoundException {\n\t\tAssert.hasText(className, \"'className' must not be empty\");\n\t\tAssert.hasText(methodName, \"'methodName' must not be empty\");\n\t\treturn onMethod(Class.forName(className), methodName).invoke();\n\t}\n\n\tprivate Method getMethod(Class<?> type, String methodName) {\n\t\tReflectionUtils.MethodFilter selector = method -> methodName.equals(method.getName());\n\t\tSet<Method> methods = MethodIntrospector.selectMethods(type, selector);\n\t\tif (methods.size() == 1) {\n\t\t\treturn methods.iterator().next();\n\t\t}\n\t\telse if (methods.size() > 1) {\n\t\t\tthrow new IllegalArgumentException(\"Found multiple methods named '%s' on class %s\".formatted(methodName, type.getName()));\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"No method named '%s' on class %s\".formatted(methodName, type.getName()));\n\t\t}\n\t}\n\n\t/**\n\t * Return a predicate that checks whether a reflective field access hint is registered for the field.\n\t * This looks up a field on the given type with the expected name, if present.\n\t * @param type the type holding the field\n\t * @param fieldName the field name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws IllegalArgumentException if a field cannot be found with the given name.\n\t * @deprecated since 7.0 in favor of {@link #onFieldAccess(Class, String)} with similar semantics.\n\t */\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\tpublic Predicate<RuntimeHints> onField(Class<?> type, String fieldName) {\n\t\treturn onFieldAccess(type, fieldName);\n\t}\n\n\t/**\n\t * Return a predicate that checks whether a reflective field access hint is registered for the field.\n\t * This looks up a field on the given type with the expected name, if present.\n\t * @param type the type holding the field\n\t * @param fieldName the field name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws IllegalArgumentException if a field cannot be found with the given name.\n\t * @since 7.0\n\t */\n\tpublic Predicate<RuntimeHints> onFieldAccess(Class<?> type, String fieldName) {\n\t\tAssert.notNull(type, \"'type' must not be null\");\n\t\tAssert.hasText(fieldName, \"'fieldName' must not be empty\");\n\t\tField field = ReflectionUtils.findField(type, fieldName);\n\t\tif (field == null) {\n\t\t\tthrow new IllegalArgumentException(\"No field named '%s' on class %s\".formatted(fieldName, type.getName()));\n\t\t}\n\t\treturn new FieldHintPredicate(field);\n\t}\n\n\t/**\n\t * Return a predicate that checks whether a reflective field access hint is registered for the field.\n\t * This looks up a field on the given type with the expected name, if present.\n\t * @param className the name of the class holding the field\n\t * @param fieldName the field name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws ClassNotFoundException if the class cannot be resolved.\n\t * @throws IllegalArgumentException if a field cannot be found with the given name.\n\t * @deprecated since 7.0 in favor of {@link #onFieldAccess(String, String)} with similar semantics.\n\t */\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\tpublic Predicate<RuntimeHints> onField(String className, String fieldName) throws ClassNotFoundException {\n\t\treturn onFieldAccess(className, fieldName);\n\t}\n\n\t/**\n\t * Return a predicate that checks whether an invocation hint is registered for the field.\n\t * This looks up a field on the given type with the expected name, if present.\n\t * @param className the name of the class holding the field\n\t * @param fieldName the field name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws ClassNotFoundException if the class cannot be resolved.\n\t * @throws IllegalArgumentException if a field cannot be found with the given name.\n\t * @since 7.0\n\t */\n\tpublic Predicate<RuntimeHints> onFieldAccess(String className, String fieldName) throws ClassNotFoundException {\n\t\tAssert.hasText(className, \"'className' must not be empty\");\n\t\tAssert.hasText(fieldName, \"'fieldName' must not be empty\");\n\t\treturn onFieldAccess(Class.forName(className), fieldName);\n\t}\n\n\t/**\n\t * Return a predicate that checks whether a reflective field access hint is registered for the given field.\n\t * @param field the field\n\t * @return the {@link RuntimeHints} predicate\n\t * @deprecated since 7.0 in favor of {@link #onFieldAccess(Field)} with similar semantics.\n\t */\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\tpublic Predicate<RuntimeHints> onField(Field field) {\n\t\treturn onFieldAccess(field);\n\t}\n\n\t/**\n\t * Return a predicate that checks whether an invocation hint is registered for the given field.\n\t * @param field the field\n\t * @return the {@link RuntimeHints} predicate\n\t * @since 7.0\n\t */\n\tpublic Predicate<RuntimeHints> onFieldAccess(Field field) {\n\t\tAssert.notNull(field, \"'field' must not be null\");\n\t\treturn new FieldHintPredicate(field);\n\t}\n\n\n\tpublic static class TypeHintPredicate implements Predicate<RuntimeHints> {\n\n\t\tprivate final TypeReference type;\n\n\t\tTypeHintPredicate(TypeReference type) {\n\t\t\tthis.type = type;\n\t\t}\n\n\t\tprivate @Nullable TypeHint getTypeHint(RuntimeHints hints) {\n\t\t\treturn hints.reflection().getTypeHint(this.type);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(RuntimeHints hints) {\n\t\t\treturn getTypeHint(hints) != null;\n\t\t}\n\n\t\t/**\n\t\t * Refine the current predicate to only match if the given {@link MemberCategory} is present.\n\t\t * @param memberCategory the member category\n\t\t * @return the refined {@link RuntimeHints} predicate\n\t\t */\n\t\tpublic Predicate<RuntimeHints> withMemberCategory(MemberCategory memberCategory) {\n\t\t\tAssert.notNull(memberCategory, \"'memberCategory' must not be null\");\n\t\t\treturn and(hints -> {\n\t\t\t\tTypeHint hint = getTypeHint(hints);\n\t\t\t\treturn (hint != null && hint.getMemberCategories().contains(memberCategory));\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Refine the current predicate to only match if the given {@link MemberCategory categories} are present.\n\t\t * @param memberCategories the member categories\n\t\t * @return the refined {@link RuntimeHints} predicate\n\t\t */\n\t\tpublic Predicate<RuntimeHints> withMemberCategories(MemberCategory... memberCategories) {\n\t\t\tAssert.notEmpty(memberCategories, \"'memberCategories' must not be empty\");\n\t\t\treturn and(hints -> {\n\t\t\t\tTypeHint hint = getTypeHint(hints);\n\t\t\t\treturn (hint != null && hint.getMemberCategories().containsAll(Arrays.asList(memberCategories)));\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Refine the current predicate to match if any of the given {@link MemberCategory categories} is present.\n\t\t * @param memberCategories the member categories\n\t\t * @return the refined {@link RuntimeHints} predicate\n\t\t */\n\t\tpublic Predicate<RuntimeHints> withAnyMemberCategory(MemberCategory... memberCategories) {\n\t\t\tAssert.notEmpty(memberCategories, \"'memberCategories' must not be empty\");\n\t\t\treturn and(hints -> {\n\t\t\t\tTypeHint hint = getTypeHint(hints);\n\t\t\t\treturn (hint != null && Arrays.stream(memberCategories)\n\t\t\t\t\t\t.anyMatch(memberCategory -> hint.getMemberCategories().contains(memberCategory)));\n\t\t\t});\n\t\t}\n\t}\n\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\t@SuppressWarnings(\"removal\")\n\tpublic abstract static class ExecutableHintPredicate<T extends Executable> implements Predicate<RuntimeHints> {\n\n\t\tprotected final T executable;\n\n\t\tprotected ExecutableMode executableMode = ExecutableMode.INTROSPECT;\n\n\t\tExecutableHintPredicate(T executable) {\n\t\t\tthis.executable = executable;\n\t\t}\n\n\t\t/**\n\t\t * Refine the current predicate to match for reflection introspection on the current type.\n\t\t * @return the refined {@link RuntimeHints} predicate\n\t\t */\n\t\tpublic ExecutableHintPredicate<T> introspect() {\n\t\t\tthis.executableMode = ExecutableMode.INTROSPECT;\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Refine the current predicate to match for reflection invocation on the current type.\n\t\t * @return the refined {@link RuntimeHints} predicate\n\t\t */\n\t\tpublic ExecutableHintPredicate<T> invoke() {\n\t\t\tthis.executableMode = ExecutableMode.INVOKE;\n\t\t\treturn this;\n\t\t}\n\n\t\tabstract Predicate<RuntimeHints> exactMatch();\n\n\t\t/**\n\t\t * Indicate whether the specified {@code ExecutableHint} covers the\n\t\t * reflection needs of the specified executable definition.\n\t\t * @return {@code true} if the member matches (same type, name, and parameters),\n\t\t * and the configured {@code ExecutableMode} is compatible\n\t\t */\n\t\tstatic boolean includes(ExecutableHint hint, String name,\n\t\t\t\tList<TypeReference> parameterTypes, ExecutableMode executableModes) {\n\t\t\treturn hint.getName().equals(name) && hint.getParameterTypes().equals(parameterTypes) &&\n\t\t\t\t\t(hint.getMode().equals(ExecutableMode.INVOKE) || !executableModes.equals(ExecutableMode.INVOKE));\n\t\t}\n\t}\n\n\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\t@SuppressWarnings(\"removal\")\n\tpublic static class ConstructorHintPredicate extends ExecutableHintPredicate<Constructor<?>> {\n\n\t\tConstructorHintPredicate(Constructor<?> constructor) {\n\t\t\tsuper(constructor);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(RuntimeHints runtimeHints) {\n\t\t\treturn (new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass()))\n\t\t\t\t\t.and(hints -> this.executableMode == ExecutableMode.INTROSPECT))\n\t\t\t\t\t.or(new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass()))\n\t\t\t\t\t\t\t.withMemberCategory(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS)\n\t\t\t\t\t\t\t.and(hints -> Modifier.isPublic(this.executable.getModifiers()))\n\t\t\t\t\t\t\t.and(hints -> this.executableMode == ExecutableMode.INVOKE))\n\t\t\t\t\t.or(new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass()))\n\t\t\t\t\t\t\t.withMemberCategory(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)\n\t\t\t\t\t\t\t.and(hints -> this.executableMode == ExecutableMode.INVOKE))\n\t\t\t\t\t.or(exactMatch()).test(runtimeHints);\n\t\t}\n\n\t\t@Override\n\t\tPredicate<RuntimeHints> exactMatch() {\n\t\t\treturn hints -> {\n\t\t\t\tTypeHint hint = hints.reflection().getTypeHint(this.executable.getDeclaringClass());\n\t\t\t\treturn (hint != null && hint.constructors().anyMatch(executableHint -> {\n\t\t\t\t\tList<TypeReference> parameters = TypeReference.listOf(this.executable.getParameterTypes());\n\t\t\t\t\treturn includes(executableHint, \"<init>\", parameters, this.executableMode);\n\t\t\t\t}));\n\t\t\t};\n\t\t}\n\t}\n\n\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\t@SuppressWarnings(\"removal\")\n\tpublic static class MethodHintPredicate extends ExecutableHintPredicate<Method> {\n\n\t\tMethodHintPredicate(Method method) {\n\t\t\tsuper(method);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(RuntimeHints runtimeHints) {\n\t\t\treturn (new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass()))\n\t\t\t\t\t.and(hints -> this.executableMode == ExecutableMode.INTROSPECT))\n\t\t\t\t\t.or((new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass()))\n\t\t\t\t\t\t\t.withMemberCategory(MemberCategory.INVOKE_PUBLIC_METHODS)\n\t\t\t\t\t\t\t.and(hints -> Modifier.isPublic(this.executable.getModifiers()))\n\t\t\t\t\t\t\t.and(hints -> this.executableMode == ExecutableMode.INVOKE)))\n\t\t\t\t\t.or((new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass()))\n\t\t\t\t\t\t\t.withMemberCategory(MemberCategory.INVOKE_DECLARED_METHODS)\n\t\t\t\t\t\t\t.and(hints -> !Modifier.isPublic(this.executable.getModifiers()))\n\t\t\t\t\t\t\t.and(hints -> this.executableMode == ExecutableMode.INVOKE)))\n\t\t\t\t\t.or(exactMatch()).test(runtimeHints);\n\t\t}\n\n\t\t@Override\n\t\tPredicate<RuntimeHints> exactMatch() {\n\t\t\treturn hints -> {\n\t\t\t\tTypeHint hint = hints.reflection().getTypeHint(this.executable.getDeclaringClass());\n\t\t\t\treturn (hint != null && hint.methods().anyMatch(executableHint -> {\n\t\t\t\t\tList<TypeReference> parameters = TypeReference.listOf(this.executable.getParameterTypes());\n\t\t\t\t\treturn includes(executableHint, this.executable.getName(), parameters, this.executableMode);\n\t\t\t\t}));\n\t\t\t};\n\t\t}\n\t}\n\n\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\tpublic static class FieldHintPredicate implements Predicate<RuntimeHints> {\n\n\t\tprivate final Field field;\n\n\t\tFieldHintPredicate(Field field) {\n\t\t\tthis.field = field;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(RuntimeHints runtimeHints) {\n\t\t\tTypeHint typeHint = runtimeHints.reflection().getTypeHint(this.field.getDeclaringClass());\n\t\t\tif (typeHint == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn memberCategoryMatch(typeHint) || exactMatch(typeHint);\n\t\t}\n\n\t\t@SuppressWarnings(\"removal\")\n\t\tprivate boolean memberCategoryMatch(TypeHint typeHint) {\n\t\t\tif (Modifier.isPublic(this.field.getModifiers())) {\n\t\t\t\treturn typeHint.getMemberCategories().contains(MemberCategory.ACCESS_PUBLIC_FIELDS)\n\t\t\t\t\t\t|| typeHint.getMemberCategories().contains(MemberCategory.PUBLIC_FIELDS);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn typeHint.getMemberCategories().contains(MemberCategory.ACCESS_DECLARED_FIELDS)\n\t\t\t\t\t\t|| typeHint.getMemberCategories().contains(MemberCategory.DECLARED_FIELDS);\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean exactMatch(TypeHint typeHint) {\n\t\t\treturn typeHint.fields().anyMatch(fieldHint ->\n\t\t\t\t\tthis.field.getName().equals(fieldHint.getName()));\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.aot.hint.predicate.MethodHintPredicate#test(RuntimeHints)",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic boolean test(RuntimeHints runtimeHints) {\r\n    return (new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass())).and(hints -> this.executableMode == ExecutableMode.INTROSPECT)).or((new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass())).withMemberCategory(MemberCategory.INVOKE_PUBLIC_METHODS).and(hints -> Modifier.isPublic(this.executable.getModifiers())).and(hints -> this.executableMode == ExecutableMode.INVOKE))).or((new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass())).withMemberCategory(MemberCategory.INVOKE_DECLARED_METHODS).and(hints -> !Modifier.isPublic(this.executable.getModifiers())).and(hints -> this.executableMode == ExecutableMode.INVOKE))).or(exactMatch()).test(runtimeHints);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.hint.predicate.MethodHintPredicate",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.hint.predicate.MethodHintPredicate#test(RuntimeHints)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.aot.hint.predicate.MethodHintPredicate#test(RuntimeHints)",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.aot.hint.predicate.MethodHintPredicate#exactMatch()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\nPredicate<RuntimeHints> exactMatch() {\r\n    return hints -> {\r\n        TypeHint hint = hints.reflection().getTypeHint(this.executable.getDeclaringClass());\r\n        return (hint != null && hint.methods().anyMatch(executableHint -> {\r\n            List<TypeReference> parameters = TypeReference.listOf(this.executable.getParameterTypes());\r\n            return includes(executableHint, this.executable.getName(), parameters, this.executableMode);\r\n        }));\r\n    };\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.hint.predicate.MethodHintPredicate",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.hint.predicate.MethodHintPredicate#exactMatch()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.aot.hint.predicate.MethodHintPredicate#exactMatch()",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.aot.hint.predicate.MethodHintPredicate",
    "headType": "class",
    "relation": "extend",
    "tail": "ExecutableHintPredicate",
    "tailType": "class"
  },
  {
    "head": "org.springframework.aot.hint.predicate",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.aot.hint.predicate.FieldHintPredicate",
    "tailType": "class"
  },
  {
    "head": "org.springframework.aot.hint.predicate.FieldHintPredicate",
    "headType": "class",
    "relation": "use",
    "tail": "@Deprecated",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.aot.hint.predicate.FieldHintPredicate",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.aot.hint.predicate;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Executable;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.function.Predicate;\n\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.aot.hint.ExecutableHint;\nimport org.springframework.aot.hint.ExecutableMode;\nimport org.springframework.aot.hint.MemberCategory;\nimport org.springframework.aot.hint.ReflectionHints;\nimport org.springframework.aot.hint.RuntimeHints;\nimport org.springframework.aot.hint.TypeHint;\nimport org.springframework.aot.hint.TypeReference;\nimport org.springframework.core.MethodIntrospector;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ReflectionUtils;\n\n/**\n * Generator of {@link ReflectionHints} predicates, testing whether the given hints\n * match the expected behavior for reflection.\n *\n * @author Brian Clozel\n * @author Stephane Nicoll\n * @since 6.0\n */\npublic class ReflectionHintsPredicates {\n\n\tReflectionHintsPredicates() {\n\t}\n\n\n\t/**\n\t * Return a predicate that checks whether a reflection hint is registered for the given type.\n\t * <p>The returned type exposes additional methods that refine the predicate behavior.\n\t * @param typeReference the type\n\t * @return the {@link RuntimeHints} predicate\n\t */\n\tpublic TypeHintPredicate onType(TypeReference typeReference) {\n\t\tAssert.notNull(typeReference, \"'typeReference' must not be null\");\n\t\treturn new TypeHintPredicate(typeReference);\n\t}\n\n\t/**\n\t * Return a predicate that checks whether a reflection hint is registered for the given type.\n\t * <p>The returned type exposes additional methods that refine the predicate behavior.\n\t * @param type the type\n\t * @return the {@link RuntimeHints} predicate\n\t */\n\tpublic TypeHintPredicate onType(Class<?> type) {\n\t\tAssert.notNull(type, \"'type' must not be null\");\n\t\treturn new TypeHintPredicate(TypeReference.of(type));\n\t}\n\n\t/**\n\t * Return a predicate that checks whether a reflection hint is registered for the given constructor.\n\t * By default, both introspection and invocation hints match.\n\t * <p>The returned type exposes additional methods that refine the predicate behavior.\n\t * @param constructor the constructor\n\t * @return the {@link RuntimeHints} predicate\n\t * @deprecated since 7.0 in favor of {@link #onConstructorInvocation(Constructor)}\n\t * or {@link #onType(Class)}.\n\t */\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\tpublic ConstructorHintPredicate onConstructor(Constructor<?> constructor) {\n\t\tAssert.notNull(constructor, \"'constructor' must not be null\");\n\t\treturn new ConstructorHintPredicate(constructor);\n\t}\n\n\t/**\n\t * Return a predicate that checks whether an invocation hint is registered for the given constructor.\n\t * @param constructor the constructor\n\t * @return the {@link RuntimeHints} predicate\n\t * @since 7.0\n\t */\n\tpublic Predicate<RuntimeHints> onConstructorInvocation(Constructor<?> constructor) {\n\t\tAssert.notNull(constructor, \"'constructor' must not be null\");\n\t\treturn new ConstructorHintPredicate(constructor).invoke();\n\t}\n\n\t/**\n\t * Return a predicate that checks whether a reflection hint is registered for the given method.\n\t * By default, both introspection and invocation hints match.\n\t * <p>The returned type exposes additional methods that refine the predicate behavior.\n\t * @param method the method\n\t * @return the {@link RuntimeHints} predicate\n\t * @deprecated since 7.0 in favor of {@link #onMethodInvocation(Method)}\n\t * or {@link #onType(Class)}.\n\t */\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\tpublic MethodHintPredicate onMethod(Method method) {\n\t\tAssert.notNull(method, \"'method' must not be null\");\n\t\treturn new MethodHintPredicate(method);\n\t}\n\n\t/**\n\t * Return a predicate that checks whether an invocation hint is registered for the given method.\n\t * @param method the method\n\t * @return the {@link RuntimeHints} predicate\n\t * @since 7.0\n\t */\n\tpublic Predicate<RuntimeHints> onMethodInvocation(Method method) {\n\t\tAssert.notNull(method, \"'method' must not be null\");\n\t\treturn new MethodHintPredicate(method).invoke();\n\t}\n\n\t/**\n\t * Return a predicate that checks whether a reflection hint is registered for the method that matches the given selector.\n\t * This looks up a method on the given type with the expected name, if unique.\n\t * By default, both introspection and invocation hints match.\n\t * <p>The returned type exposes additional methods that refine the predicate behavior.\n\t * @param type the type holding the method\n\t * @param methodName the method name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws IllegalArgumentException if the method cannot be found or if multiple methods are found with the same name.\n\t * @deprecated since 7.0 in favor of {@link #onMethodInvocation(Class, String)}\n\t * or {@link #onType(Class)}.\n\t */\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\tpublic MethodHintPredicate onMethod(Class<?> type, String methodName) {\n\t\tAssert.notNull(type, \"'type' must not be null\");\n\t\tAssert.hasText(methodName, \"'methodName' must not be empty\");\n\t\treturn new MethodHintPredicate(getMethod(type, methodName));\n\t}\n\n\t/**\n\t * Return a predicate that checks whether an invocation hint is registered for the method that matches the given selector.\n\t * This looks up a method on the given type with the expected name, if unique.\n\t * @param type the type holding the method\n\t * @param methodName the method name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws IllegalArgumentException if the method cannot be found or if multiple methods are found with the same name.\n\t * @since 7.0\n\t */\n\tpublic Predicate<RuntimeHints> onMethodInvocation(Class<?> type, String methodName) {\n\t\tAssert.notNull(type, \"'type' must not be null\");\n\t\tAssert.hasText(methodName, \"'methodName' must not be empty\");\n\t\treturn new MethodHintPredicate(getMethod(type, methodName)).invoke();\n\t}\n\n\t/**\n\t * Return a predicate that checks whether a reflection hint is registered for the method that matches the given selector.\n\t * This looks up a method on the given type with the expected name, if unique.\n\t * By default, both introspection and invocation hints match.\n\t * <p>The returned type exposes additional methods that refine the predicate behavior.\n\t * @param className the name of the class holding the method\n\t * @param methodName the method name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws ClassNotFoundException if the class cannot be resolved.\n\t * @throws IllegalArgumentException if the method cannot be found or if multiple methods are found with the same name.\n\t * @deprecated since 7.0 in favor of {@link #onMethodInvocation(String, String)}\n\t * or {@link #onType(Class)}.\n\t */\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\tpublic MethodHintPredicate onMethod(String className, String methodName) throws ClassNotFoundException {\n\t\tAssert.hasText(className, \"'className' must not be empty\");\n\t\tAssert.hasText(methodName, \"'methodName' must not be empty\");\n\t\treturn onMethod(Class.forName(className), methodName);\n\t}\n\n\t/**\n\t * Return a predicate that checks whether an invocation hint is registered for the method that matches the given selector.\n\t * This looks up a method on the given type with the expected name, if unique.\n\t * @param className the name of the class holding the method\n\t * @param methodName the method name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws ClassNotFoundException if the class cannot be resolved.\n\t * @throws IllegalArgumentException if the method cannot be found or if multiple methods are found with the same name.\n\t * @since 7.0\n\t */\n\tpublic Predicate<RuntimeHints> onMethodInvocation(String className, String methodName) throws ClassNotFoundException {\n\t\tAssert.hasText(className, \"'className' must not be empty\");\n\t\tAssert.hasText(methodName, \"'methodName' must not be empty\");\n\t\treturn onMethod(Class.forName(className), methodName).invoke();\n\t}\n\n\tprivate Method getMethod(Class<?> type, String methodName) {\n\t\tReflectionUtils.MethodFilter selector = method -> methodName.equals(method.getName());\n\t\tSet<Method> methods = MethodIntrospector.selectMethods(type, selector);\n\t\tif (methods.size() == 1) {\n\t\t\treturn methods.iterator().next();\n\t\t}\n\t\telse if (methods.size() > 1) {\n\t\t\tthrow new IllegalArgumentException(\"Found multiple methods named '%s' on class %s\".formatted(methodName, type.getName()));\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"No method named '%s' on class %s\".formatted(methodName, type.getName()));\n\t\t}\n\t}\n\n\t/**\n\t * Return a predicate that checks whether a reflective field access hint is registered for the field.\n\t * This looks up a field on the given type with the expected name, if present.\n\t * @param type the type holding the field\n\t * @param fieldName the field name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws IllegalArgumentException if a field cannot be found with the given name.\n\t * @deprecated since 7.0 in favor of {@link #onFieldAccess(Class, String)} with similar semantics.\n\t */\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\tpublic Predicate<RuntimeHints> onField(Class<?> type, String fieldName) {\n\t\treturn onFieldAccess(type, fieldName);\n\t}\n\n\t/**\n\t * Return a predicate that checks whether a reflective field access hint is registered for the field.\n\t * This looks up a field on the given type with the expected name, if present.\n\t * @param type the type holding the field\n\t * @param fieldName the field name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws IllegalArgumentException if a field cannot be found with the given name.\n\t * @since 7.0\n\t */\n\tpublic Predicate<RuntimeHints> onFieldAccess(Class<?> type, String fieldName) {\n\t\tAssert.notNull(type, \"'type' must not be null\");\n\t\tAssert.hasText(fieldName, \"'fieldName' must not be empty\");\n\t\tField field = ReflectionUtils.findField(type, fieldName);\n\t\tif (field == null) {\n\t\t\tthrow new IllegalArgumentException(\"No field named '%s' on class %s\".formatted(fieldName, type.getName()));\n\t\t}\n\t\treturn new FieldHintPredicate(field);\n\t}\n\n\t/**\n\t * Return a predicate that checks whether a reflective field access hint is registered for the field.\n\t * This looks up a field on the given type with the expected name, if present.\n\t * @param className the name of the class holding the field\n\t * @param fieldName the field name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws ClassNotFoundException if the class cannot be resolved.\n\t * @throws IllegalArgumentException if a field cannot be found with the given name.\n\t * @deprecated since 7.0 in favor of {@link #onFieldAccess(String, String)} with similar semantics.\n\t */\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\tpublic Predicate<RuntimeHints> onField(String className, String fieldName) throws ClassNotFoundException {\n\t\treturn onFieldAccess(className, fieldName);\n\t}\n\n\t/**\n\t * Return a predicate that checks whether an invocation hint is registered for the field.\n\t * This looks up a field on the given type with the expected name, if present.\n\t * @param className the name of the class holding the field\n\t * @param fieldName the field name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws ClassNotFoundException if the class cannot be resolved.\n\t * @throws IllegalArgumentException if a field cannot be found with the given name.\n\t * @since 7.0\n\t */\n\tpublic Predicate<RuntimeHints> onFieldAccess(String className, String fieldName) throws ClassNotFoundException {\n\t\tAssert.hasText(className, \"'className' must not be empty\");\n\t\tAssert.hasText(fieldName, \"'fieldName' must not be empty\");\n\t\treturn onFieldAccess(Class.forName(className), fieldName);\n\t}\n\n\t/**\n\t * Return a predicate that checks whether a reflective field access hint is registered for the given field.\n\t * @param field the field\n\t * @return the {@link RuntimeHints} predicate\n\t * @deprecated since 7.0 in favor of {@link #onFieldAccess(Field)} with similar semantics.\n\t */\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\tpublic Predicate<RuntimeHints> onField(Field field) {\n\t\treturn onFieldAccess(field);\n\t}\n\n\t/**\n\t * Return a predicate that checks whether an invocation hint is registered for the given field.\n\t * @param field the field\n\t * @return the {@link RuntimeHints} predicate\n\t * @since 7.0\n\t */\n\tpublic Predicate<RuntimeHints> onFieldAccess(Field field) {\n\t\tAssert.notNull(field, \"'field' must not be null\");\n\t\treturn new FieldHintPredicate(field);\n\t}\n\n\n\tpublic static class TypeHintPredicate implements Predicate<RuntimeHints> {\n\n\t\tprivate final TypeReference type;\n\n\t\tTypeHintPredicate(TypeReference type) {\n\t\t\tthis.type = type;\n\t\t}\n\n\t\tprivate @Nullable TypeHint getTypeHint(RuntimeHints hints) {\n\t\t\treturn hints.reflection().getTypeHint(this.type);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(RuntimeHints hints) {\n\t\t\treturn getTypeHint(hints) != null;\n\t\t}\n\n\t\t/**\n\t\t * Refine the current predicate to only match if the given {@link MemberCategory} is present.\n\t\t * @param memberCategory the member category\n\t\t * @return the refined {@link RuntimeHints} predicate\n\t\t */\n\t\tpublic Predicate<RuntimeHints> withMemberCategory(MemberCategory memberCategory) {\n\t\t\tAssert.notNull(memberCategory, \"'memberCategory' must not be null\");\n\t\t\treturn and(hints -> {\n\t\t\t\tTypeHint hint = getTypeHint(hints);\n\t\t\t\treturn (hint != null && hint.getMemberCategories().contains(memberCategory));\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Refine the current predicate to only match if the given {@link MemberCategory categories} are present.\n\t\t * @param memberCategories the member categories\n\t\t * @return the refined {@link RuntimeHints} predicate\n\t\t */\n\t\tpublic Predicate<RuntimeHints> withMemberCategories(MemberCategory... memberCategories) {\n\t\t\tAssert.notEmpty(memberCategories, \"'memberCategories' must not be empty\");\n\t\t\treturn and(hints -> {\n\t\t\t\tTypeHint hint = getTypeHint(hints);\n\t\t\t\treturn (hint != null && hint.getMemberCategories().containsAll(Arrays.asList(memberCategories)));\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Refine the current predicate to match if any of the given {@link MemberCategory categories} is present.\n\t\t * @param memberCategories the member categories\n\t\t * @return the refined {@link RuntimeHints} predicate\n\t\t */\n\t\tpublic Predicate<RuntimeHints> withAnyMemberCategory(MemberCategory... memberCategories) {\n\t\t\tAssert.notEmpty(memberCategories, \"'memberCategories' must not be empty\");\n\t\t\treturn and(hints -> {\n\t\t\t\tTypeHint hint = getTypeHint(hints);\n\t\t\t\treturn (hint != null && Arrays.stream(memberCategories)\n\t\t\t\t\t\t.anyMatch(memberCategory -> hint.getMemberCategories().contains(memberCategory)));\n\t\t\t});\n\t\t}\n\t}\n\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\t@SuppressWarnings(\"removal\")\n\tpublic abstract static class ExecutableHintPredicate<T extends Executable> implements Predicate<RuntimeHints> {\n\n\t\tprotected final T executable;\n\n\t\tprotected ExecutableMode executableMode = ExecutableMode.INTROSPECT;\n\n\t\tExecutableHintPredicate(T executable) {\n\t\t\tthis.executable = executable;\n\t\t}\n\n\t\t/**\n\t\t * Refine the current predicate to match for reflection introspection on the current type.\n\t\t * @return the refined {@link RuntimeHints} predicate\n\t\t */\n\t\tpublic ExecutableHintPredicate<T> introspect() {\n\t\t\tthis.executableMode = ExecutableMode.INTROSPECT;\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Refine the current predicate to match for reflection invocation on the current type.\n\t\t * @return the refined {@link RuntimeHints} predicate\n\t\t */\n\t\tpublic ExecutableHintPredicate<T> invoke() {\n\t\t\tthis.executableMode = ExecutableMode.INVOKE;\n\t\t\treturn this;\n\t\t}\n\n\t\tabstract Predicate<RuntimeHints> exactMatch();\n\n\t\t/**\n\t\t * Indicate whether the specified {@code ExecutableHint} covers the\n\t\t * reflection needs of the specified executable definition.\n\t\t * @return {@code true} if the member matches (same type, name, and parameters),\n\t\t * and the configured {@code ExecutableMode} is compatible\n\t\t */\n\t\tstatic boolean includes(ExecutableHint hint, String name,\n\t\t\t\tList<TypeReference> parameterTypes, ExecutableMode executableModes) {\n\t\t\treturn hint.getName().equals(name) && hint.getParameterTypes().equals(parameterTypes) &&\n\t\t\t\t\t(hint.getMode().equals(ExecutableMode.INVOKE) || !executableModes.equals(ExecutableMode.INVOKE));\n\t\t}\n\t}\n\n\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\t@SuppressWarnings(\"removal\")\n\tpublic static class ConstructorHintPredicate extends ExecutableHintPredicate<Constructor<?>> {\n\n\t\tConstructorHintPredicate(Constructor<?> constructor) {\n\t\t\tsuper(constructor);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(RuntimeHints runtimeHints) {\n\t\t\treturn (new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass()))\n\t\t\t\t\t.and(hints -> this.executableMode == ExecutableMode.INTROSPECT))\n\t\t\t\t\t.or(new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass()))\n\t\t\t\t\t\t\t.withMemberCategory(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS)\n\t\t\t\t\t\t\t.and(hints -> Modifier.isPublic(this.executable.getModifiers()))\n\t\t\t\t\t\t\t.and(hints -> this.executableMode == ExecutableMode.INVOKE))\n\t\t\t\t\t.or(new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass()))\n\t\t\t\t\t\t\t.withMemberCategory(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)\n\t\t\t\t\t\t\t.and(hints -> this.executableMode == ExecutableMode.INVOKE))\n\t\t\t\t\t.or(exactMatch()).test(runtimeHints);\n\t\t}\n\n\t\t@Override\n\t\tPredicate<RuntimeHints> exactMatch() {\n\t\t\treturn hints -> {\n\t\t\t\tTypeHint hint = hints.reflection().getTypeHint(this.executable.getDeclaringClass());\n\t\t\t\treturn (hint != null && hint.constructors().anyMatch(executableHint -> {\n\t\t\t\t\tList<TypeReference> parameters = TypeReference.listOf(this.executable.getParameterTypes());\n\t\t\t\t\treturn includes(executableHint, \"<init>\", parameters, this.executableMode);\n\t\t\t\t}));\n\t\t\t};\n\t\t}\n\t}\n\n\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\t@SuppressWarnings(\"removal\")\n\tpublic static class MethodHintPredicate extends ExecutableHintPredicate<Method> {\n\n\t\tMethodHintPredicate(Method method) {\n\t\t\tsuper(method);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(RuntimeHints runtimeHints) {\n\t\t\treturn (new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass()))\n\t\t\t\t\t.and(hints -> this.executableMode == ExecutableMode.INTROSPECT))\n\t\t\t\t\t.or((new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass()))\n\t\t\t\t\t\t\t.withMemberCategory(MemberCategory.INVOKE_PUBLIC_METHODS)\n\t\t\t\t\t\t\t.and(hints -> Modifier.isPublic(this.executable.getModifiers()))\n\t\t\t\t\t\t\t.and(hints -> this.executableMode == ExecutableMode.INVOKE)))\n\t\t\t\t\t.or((new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass()))\n\t\t\t\t\t\t\t.withMemberCategory(MemberCategory.INVOKE_DECLARED_METHODS)\n\t\t\t\t\t\t\t.and(hints -> !Modifier.isPublic(this.executable.getModifiers()))\n\t\t\t\t\t\t\t.and(hints -> this.executableMode == ExecutableMode.INVOKE)))\n\t\t\t\t\t.or(exactMatch()).test(runtimeHints);\n\t\t}\n\n\t\t@Override\n\t\tPredicate<RuntimeHints> exactMatch() {\n\t\t\treturn hints -> {\n\t\t\t\tTypeHint hint = hints.reflection().getTypeHint(this.executable.getDeclaringClass());\n\t\t\t\treturn (hint != null && hint.methods().anyMatch(executableHint -> {\n\t\t\t\t\tList<TypeReference> parameters = TypeReference.listOf(this.executable.getParameterTypes());\n\t\t\t\t\treturn includes(executableHint, this.executable.getName(), parameters, this.executableMode);\n\t\t\t\t}));\n\t\t\t};\n\t\t}\n\t}\n\n\n\t@Deprecated(since = \"7.0\", forRemoval = true)\n\tpublic static class FieldHintPredicate implements Predicate<RuntimeHints> {\n\n\t\tprivate final Field field;\n\n\t\tFieldHintPredicate(Field field) {\n\t\t\tthis.field = field;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(RuntimeHints runtimeHints) {\n\t\t\tTypeHint typeHint = runtimeHints.reflection().getTypeHint(this.field.getDeclaringClass());\n\t\t\tif (typeHint == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn memberCategoryMatch(typeHint) || exactMatch(typeHint);\n\t\t}\n\n\t\t@SuppressWarnings(\"removal\")\n\t\tprivate boolean memberCategoryMatch(TypeHint typeHint) {\n\t\t\tif (Modifier.isPublic(this.field.getModifiers())) {\n\t\t\t\treturn typeHint.getMemberCategories().contains(MemberCategory.ACCESS_PUBLIC_FIELDS)\n\t\t\t\t\t\t|| typeHint.getMemberCategories().contains(MemberCategory.PUBLIC_FIELDS);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn typeHint.getMemberCategories().contains(MemberCategory.ACCESS_DECLARED_FIELDS)\n\t\t\t\t\t\t|| typeHint.getMemberCategories().contains(MemberCategory.DECLARED_FIELDS);\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean exactMatch(TypeHint typeHint) {\n\t\t\treturn typeHint.fields().anyMatch(fieldHint ->\n\t\t\t\t\tthis.field.getName().equals(fieldHint.getName()));\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.aot.hint.predicate.FieldHintPredicate",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.aot.hint.predicate.FieldHintPredicate#field",
    "tailType": "field"
  },
  {
    "head": "org.springframework.aot.hint.predicate.FieldHintPredicate#field",
    "headType": "field",
    "relation": "haveType",
    "tail": "Field",
    "tailType": "type"
  },
  {
    "head": "org.springframework.aot.hint.predicate.FieldHintPredicate#test(RuntimeHints)",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic boolean test(RuntimeHints runtimeHints) {\r\n    TypeHint typeHint = runtimeHints.reflection().getTypeHint(this.field.getDeclaringClass());\r\n    if (typeHint == null) {\r\n        return false;\r\n    }\r\n    return memberCategoryMatch(typeHint) || exactMatch(typeHint);\r\n}",
    "tailType": "method_code"
  }
]