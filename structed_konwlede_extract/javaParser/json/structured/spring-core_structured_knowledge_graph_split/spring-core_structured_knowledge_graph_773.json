[
  {
    "head": "org.springframework.core.annotation.AttributeMethods#hasNestedAnnotation()",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Determine if at least one of the attribute methods is a nested annotation.\r\n * @return {@code true} if there is at least one attribute method with a nested\r\n * annotation type\r\n */\r\nboolean hasNestedAnnotation() {\r\n    return this.hasNestedAnnotation;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AttributeMethods",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AttributeMethods#hasNestedAnnotation()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AttributeMethods#forAnnotationType(Class<? extends Annotation>)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Get the attribute methods for the given annotation type.\r\n * @param annotationType the annotation type\r\n * @return the attribute methods for the annotation type\r\n */\r\nstatic AttributeMethods forAnnotationType(@Nullable Class<? extends Annotation> annotationType) {\r\n    if (annotationType == null) {\r\n        return NONE;\r\n    }\r\n    return cache.computeIfAbsent(annotationType, AttributeMethods::compute);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AttributeMethods",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AttributeMethods#forAnnotationType(Class<? extends Annotation>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AttributeMethods#compute(Class<? extends Annotation>)",
    "headType": "method",
    "relation": "provide",
    "tail": "// Dataflow analysis limitation\r\n@SuppressWarnings(\"NullAway\")\r\nprivate static AttributeMethods compute(Class<? extends Annotation> annotationType) {\r\n    Method[] methods = annotationType.getDeclaredMethods();\r\n    int size = methods.length;\r\n    for (int i = 0; i < methods.length; i++) {\r\n        if (!isAttributeMethod(methods[i])) {\r\n            //noinspection DataFlowIssue\r\n            methods[i] = null;\r\n            size--;\r\n        }\r\n    }\r\n    if (size == 0) {\r\n        return NONE;\r\n    }\r\n    Arrays.sort(methods, methodComparator);\r\n    Method[] attributeMethods = Arrays.copyOf(methods, size);\r\n    return new AttributeMethods(annotationType, attributeMethods);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AttributeMethods",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AttributeMethods#compute(Class<? extends Annotation>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AttributeMethods#compute(Class<? extends Annotation>)",
    "headType": "method",
    "relation": "use",
    "tail": "@SuppressWarnings",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AttributeMethods#isAttributeMethod(Method)",
    "headType": "method",
    "relation": "provide",
    "tail": "private static boolean isAttributeMethod(Method method) {\r\n    return (method.getParameterCount() == 0 && method.getReturnType() != void.class);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AttributeMethods",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AttributeMethods#isAttributeMethod(Method)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AttributeMethods#describe(Method)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Create a description for the given attribute method suitable to use in\r\n * exception messages and logs.\r\n * @param attribute the attribute to describe\r\n * @return a description of the attribute\r\n */\r\nstatic String describe(@Nullable Method attribute) {\r\n    if (attribute == null) {\r\n        return \"(none)\";\r\n    }\r\n    return describe(attribute.getDeclaringClass(), attribute.getName());\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AttributeMethods",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AttributeMethods#describe(Method)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AttributeMethods#describe(Class<?>,String)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Create a description for the given attribute method suitable to use in\r\n * exception messages and logs.\r\n * @param annotationType the annotation type\r\n * @param attributeName the attribute name\r\n * @return a description of the attribute\r\n */\r\nstatic String describe(@Nullable Class<?> annotationType, @Nullable String attributeName) {\r\n    if (attributeName == null) {\r\n        return \"(none)\";\r\n    }\r\n    String in = (annotationType != null ? \" in annotation [\" + annotationType.getName() + \"]\" : \"\");\r\n    return \"attribute '\" + attributeName + \"'\" + in;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AttributeMethods",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AttributeMethods#describe(Class<?>,String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AttributeMethods#getName(Class<?>)",
    "headType": "method",
    "relation": "provide",
    "tail": "private static String getName(Class<?> clazz) {\r\n    String canonicalName = clazz.getCanonicalName();\r\n    return (canonicalName != null ? canonicalName : clazz.getName());\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AttributeMethods",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AttributeMethods#getName(Class<?>)",
    "tailType": "method"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.annotation",
    "tailType": "package"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.annotation",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.MergedAnnotation",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotation",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2022 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Inherited;\nimport java.lang.reflect.AnnotatedElement;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\n\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.core.annotation.MergedAnnotations.SearchStrategy;\n\n/**\n * A single merged annotation returned from a {@link MergedAnnotations}\n * collection. Presents a view onto an annotation where attribute values may\n * have been \"merged\" from different source values.\n *\n * <p>Attribute values may be accessed using the various {@code get} methods.\n * For example, to access an {@code int} attribute the {@link #getInt(String)}\n * method would be used.\n *\n * <p>Note that attribute values are <b>not</b> converted when accessed.\n * For example, it is not possible to call {@link #getString(String)} if the\n * underlying attribute is an {@code int}. The only exception to this rule is\n * {@code Class} and {@code Class[]} values which may be accessed as\n * {@code String} and {@code String[]} respectively to prevent potential early\n * class initialization.\n *\n * <p>If necessary, a {@code MergedAnnotation} can be {@linkplain #synthesize()\n * synthesized} back into an actual {@link java.lang.annotation.Annotation}.\n *\n * @author Phillip Webb\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 5.2\n * @param <A> the annotation type\n * @see MergedAnnotations\n * @see MergedAnnotationPredicates\n */\npublic interface MergedAnnotation<A extends Annotation> {\n\n\t/**\n\t * The attribute name for annotations with a single element.\n\t */\n\tString VALUE = \"value\";\n\n\n\t/**\n\t * Get the {@code Class} reference for the actual annotation type.\n\t * @return the annotation type\n\t */\n\tClass<A> getType();\n\n\t/**\n\t * Determine if the annotation is present on the source. Considers\n\t * {@linkplain #isDirectlyPresent() directly present} and\n\t * {@linkplain #isMetaPresent() meta-present} annotations within the context\n\t * of the {@link SearchStrategy} used.\n\t * @return {@code true} if the annotation is present\n\t */\n\tboolean isPresent();\n\n\t/**\n\t * Determine if the annotation is directly present on the source.\n\t * <p>A directly present annotation is one that the user has explicitly\n\t * declared and not one that is {@linkplain #isMetaPresent() meta-present}\n\t * or {@link Inherited @Inherited}.\n\t * @return {@code true} if the annotation is directly present\n\t */\n\tboolean isDirectlyPresent();\n\n\t/**\n\t * Determine if the annotation is meta-present on the source.\n\t * <p>A meta-present annotation is an annotation that the user hasn't\n\t * explicitly declared, but has been used as a meta-annotation somewhere in\n\t * the annotation hierarchy.\n\t * @return {@code true} if the annotation is meta-present\n\t */\n\tboolean isMetaPresent();\n\n\t/**\n\t * Get the distance of this annotation related to its use as a\n\t * meta-annotation.\n\t * <p>A directly declared annotation has a distance of {@code 0}, a\n\t * meta-annotation has a distance of {@code 1}, a meta-annotation on a\n\t * meta-annotation has a distance of {@code 2}, etc. A {@linkplain #missing()\n\t * missing} annotation will always return a distance of {@code -1}.\n\t * @return the annotation distance or {@code -1} if the annotation is missing\n\t */\n\tint getDistance();\n\n\t/**\n\t * Get the index of the aggregate collection containing this annotation.\n\t * <p>Can be used to reorder a stream of annotations, for example, to give a\n\t * higher priority to annotations declared on a superclass or interface. A\n\t * {@linkplain #missing() missing} annotation will always return an aggregate\n\t * index of {@code -1}.\n\t * @return the aggregate index (starting at {@code 0}) or {@code -1} if the\n\t * annotation is missing\n\t */\n\tint getAggregateIndex();\n\n\t/**\n\t * Get the source that ultimately declared the root annotation, or\n\t * {@code null} if the source is not known.\n\t * <p>If this merged annotation was created\n\t * {@link MergedAnnotations#from(AnnotatedElement) from} an\n\t * {@link AnnotatedElement} then this source will be an element of the same\n\t * type. If the annotation was loaded without using reflection, the source\n\t * can be of any type, but should have a sensible {@code toString()}.\n\t * Meta-annotations will always return the same source as the\n\t * {@link #getRoot() root}.\n\t * @return the source, or {@code null}\n\t */\n\t@Nullable Object getSource();\n\n\t/**\n\t * Get the source of the meta-annotation, or {@code null} if the\n\t * annotation is not {@linkplain #isMetaPresent() meta-present}.\n\t * <p>The meta-source is the annotation that was meta-annotated with this\n\t * annotation.\n\t * @return the meta-annotation source or {@code null}\n\t * @see #getRoot()\n\t */\n\t@Nullable MergedAnnotation<?> getMetaSource();\n\n\t/**\n\t * Get the root annotation, i.e. the {@link #getDistance() distance} {@code 0}\n\t * annotation as directly declared on the source.\n\t * @return the root annotation\n\t * @see #getMetaSource()\n\t */\n\tMergedAnnotation<?> getRoot();\n\n\t/**\n\t * Get the complete list of annotation types within the annotation hierarchy\n\t * from this annotation to the {@link #getRoot() root}.\n\t * <p>Provides a useful way to uniquely identify a merged annotation instance.\n\t * @return the meta types for the annotation\n\t * @see MergedAnnotationPredicates#unique(Function)\n\t * @see #getRoot()\n\t * @see #getMetaSource()\n\t */\n\tList<Class<? extends Annotation>> getMetaTypes();\n\n\n\t/**\n\t * Determine if the specified attribute name has a non-default value when\n\t * compared to the annotation declaration.\n\t * @param attributeName the attribute name\n\t * @return {@code true} if the attribute value is different from the default\n\t * value\n\t */\n\tboolean hasNonDefaultValue(String attributeName);\n\n\t/**\n\t * Determine if the specified attribute name has a default value when compared\n\t * to the annotation declaration.\n\t * @param attributeName the attribute name\n\t * @return {@code true} if the attribute value is the same as the default\n\t * value\n\t */\n\tboolean hasDefaultValue(String attributeName) throws NoSuchElementException;\n\n\t/**\n\t * Get a required byte attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a byte\n\t * @throws NoSuchElementException if there is no matching attribute\n\t */\n\tbyte getByte(String attributeName) throws NoSuchElementException;\n\n\t/**\n\t * Get a required byte array attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a byte array\n\t * @throws NoSuchElementException if there is no matching attribute\n\t */\n\tbyte[] getByteArray(String attributeName) throws NoSuchElementException;\n\n\t/**\n\t * Get a required boolean attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a boolean\n\t * @throws NoSuchElementException if there is no matching attribute\n\t */\n\tboolean getBoolean(String attributeName) throws NoSuchElementException;\n\n\t/**\n\t * Get a required boolean array attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a boolean array\n\t * @throws NoSuchElementException if there is no matching attribute\n\t */\n\tboolean[] getBooleanArray(String attributeName) throws NoSuchElementException;\n\n\t/**\n\t * Get a required char attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a char\n\t * @throws NoSuchElementException if there is no matching attribute\n\t */\n\tchar getChar(String attributeName) throws NoSuchElementException;\n\n\t/**\n\t * Get a required char array attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a char array\n\t * @throws NoSuchElementException if there is no matching attribute\n\t */\n\tchar[] getCharArray(String attributeName) throws NoSuchElementException;\n\n\t/**\n\t * Get a required short attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a short\n\t * @throws NoSuchElementException if there is no matching attribute\n\t */\n\tshort getShort(String attributeName) throws NoSuchElementException;\n\n\t/**\n\t * Get a required short array attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a short array\n\t * @throws NoSuchElementException if there is no matching attribute\n\t */\n\tshort[] getShortArray(String attributeName) throws NoSuchElementException;\n\n\t/**\n\t * Get a required int attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as an int\n\t * @throws NoSuchElementException if there is no matching attribute\n\t */\n\tint getInt(String attributeName) throws NoSuchElementException;\n\n\t/**\n\t * Get a required int array attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as an int array\n\t * @throws NoSuchElementException if there is no matching attribute\n\t */\n\tint[] getIntArray(String attributeName) throws NoSuchElementException;\n\n\t/**\n\t * Get a required long attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a long\n\t * @throws NoSuchElementException if there is no matching attribute\n\t */\n\tlong getLong(String attributeName) throws NoSuchElementException;\n\n\t/**\n\t * Get a required long array attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a long array\n\t * @throws NoSuchElementException if there is no matching attribute\n\t */\n\tlong[] getLongArray(String attributeName) throws NoSuchElementException;\n\n\t/**\n\t * Get a required double attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a double\n\t * @throws NoSuchElementException if there is no matching attribute\n\t */\n\tdouble getDouble(String attributeName) throws NoSuchElementException;\n\n\t/**\n\t * Get a required double array attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a double array\n\t * @throws NoSuchElementException if there is no matching attribute\n\t */\n\tdouble[] getDoubleArray(String attributeName) throws NoSuchElementException;\n\n\t/**\n\t * Get a required float attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a float\n\t * @throws NoSuchElementException if there is no matching attribute\n\t */\n\tfloat getFloat(String attributeName) throws NoSuchElementException;\n\n\t/**\n\t * Get a required float array attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a float array\n\t * @throws NoSuchElementException if there is no matching attribute\n\t */\n\tfloat[] getFloatArray(String attributeName) throws NoSuchElementException;\n\n\t/**\n\t * Get a required string attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a string\n\t * @throws NoSuchElementException if there is no matching attribute\n\t */\n\tString getString(String attributeName) throws NoSuchElementException;\n\n\t/**\n\t * Get a required string array attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a string array\n\t * @throws NoSuchElementException if there is no matching attribute\n\t */\n\tString[] getStringArray(String attributeName) throws NoSuchElementException;\n\n\t/**\n\t * Get a required class attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a class\n\t * @throws NoSuchElementException if there is no matching attribute\n\t */\n\tClass<?> getClass(String attributeName) throws NoSuchElementException;\n\n\t/**\n\t * Get a required class array attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a class array\n\t * @throws NoSuchElementException if there is no matching attribute\n\t */\n\tClass<?>[] getClassArray(String attributeName) throws NoSuchElementException;\n\n\t/**\n\t * Get a required enum attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @param type the enum type\n\t * @return the value as an enum\n\t * @throws NoSuchElementException if there is no matching attribute\n\t */\n\t<E extends Enum<E>> E getEnum(String attributeName, Class<E> type) throws NoSuchElementException;\n\n\t/**\n\t * Get a required enum array attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @param type the enum type\n\t * @return the value as an enum array\n\t * @throws NoSuchElementException if there is no matching attribute\n\t */\n\t<E extends Enum<E>> E[] getEnumArray(String attributeName, Class<E> type) throws NoSuchElementException;\n\n\t/**\n\t * Get a required annotation attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @param type the annotation type\n\t * @return the value as a {@link MergedAnnotation}\n\t * @throws NoSuchElementException if there is no matching attribute\n\t */\n\t<T extends Annotation> MergedAnnotation<T> getAnnotation(String attributeName, Class<T> type)\n\t\t\tthrows NoSuchElementException;\n\n\t/**\n\t * Get a required annotation array attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @param type the annotation type\n\t * @return the value as a {@link MergedAnnotation} array\n\t * @throws NoSuchElementException if there is no matching attribute\n\t */\n\t<T extends Annotation> MergedAnnotation<T>[] getAnnotationArray(String attributeName, Class<T> type)\n\t\t\tthrows NoSuchElementException;\n\n\t/**\n\t * Get an optional attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return an optional value or {@link Optional#empty()} if there is no\n\t * matching attribute\n\t */\n\tOptional<Object> getValue(String attributeName);\n\n\t/**\n\t * Get an optional attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @param type the attribute type. Must be compatible with the underlying\n\t * attribute type or {@code Object.class}.\n\t * @return an optional value or {@link Optional#empty()} if there is no\n\t * matching attribute\n\t */\n\t<T> Optional<T> getValue(String attributeName, Class<T> type);\n\n\t/**\n\t * Get the default attribute value from the annotation as specified in\n\t * the annotation declaration.\n\t * @param attributeName the attribute name\n\t * @return an optional of the default value or {@link Optional#empty()} if\n\t * there is no matching attribute or no defined default\n\t */\n\tOptional<Object> getDefaultValue(String attributeName);\n\n\t/**\n\t * Get the default attribute value from the annotation as specified in\n\t * the annotation declaration.\n\t * @param attributeName the attribute name\n\t * @param type the attribute type. Must be compatible with the underlying\n\t * attribute type or {@code Object.class}.\n\t * @return an optional of the default value or {@link Optional#empty()} if\n\t * there is no matching attribute or no defined default\n\t */\n\t<T> Optional<T> getDefaultValue(String attributeName, Class<T> type);\n\n\t/**\n\t * Create a new view of the annotation with all attributes that have default\n\t * values removed.\n\t * @return a filtered view of the annotation without any attributes that\n\t * have a default value\n\t * @see #filterAttributes(Predicate)\n\t */\n\tMergedAnnotation<A> filterDefaultValues();\n\n\t/**\n\t * Create a new view of the annotation with only attributes that match the\n\t * given predicate.\n\t * @param predicate a predicate used to filter attribute names\n\t * @return a filtered view of the annotation\n\t * @see #filterDefaultValues()\n\t * @see MergedAnnotationPredicates\n\t */\n\tMergedAnnotation<A> filterAttributes(Predicate<String> predicate);\n\n\t/**\n\t * Create a new view of the annotation that exposes non-merged attribute values.\n\t * <p>Methods from this view will return attribute values with only alias mirroring\n\t * rules applied. Aliases to {@link #getMetaSource() meta-source} attributes will\n\t * not be applied.\n\t * @return a non-merged view of the annotation\n\t */\n\tMergedAnnotation<A> withNonMergedAttributes();\n\n\t/**\n\t * Create a new mutable {@link AnnotationAttributes} instance from this\n\t * merged annotation.\n\t * <p>The {@link Adapt adaptations} may be used to change the way that values\n\t * are added.\n\t * @param adaptations the adaptations that should be applied to the annotation values\n\t * @return an immutable map containing the attributes and values\n\t */\n\tAnnotationAttributes asAnnotationAttributes(Adapt... adaptations);\n\n\t/**\n\t * Get an immutable {@link Map} that contains all the annotation attributes.\n\t * <p>The {@link Adapt adaptations} may be used to change the way that values are added.\n\t * @param adaptations the adaptations that should be applied to the annotation values\n\t * @return an immutable map containing the attributes and values\n\t */\n\tMap<String, Object> asMap(Adapt... adaptations);\n\n\t/**\n\t * Create a new {@link Map} instance of the given type that contains all the annotation\n\t * attributes.\n\t * <p>The {@link Adapt adaptations} may be used to change the way that values are added.\n\t * @param factory a map factory\n\t * @param adaptations the adaptations that should be applied to the annotation values\n\t * @return a map containing the attributes and values\n\t */\n\t<T extends Map<String, Object>> T asMap(Function<MergedAnnotation<?>, T> factory, Adapt... adaptations);\n\n\t/**\n\t * Create a type-safe synthesized version of this merged annotation that can\n\t * be used directly in code.\n\t * <p>The result is synthesized using a JDK {@link java.lang.reflect.Proxy Proxy}\n\t * and as a result may incur a computational cost when first invoked.\n\t * <p>If this merged annotation was created {@linkplain #of(AnnotatedElement, Class, Map)\n\t * from} a map of annotation attributes or default attribute values, those\n\t * attributes will always be synthesized into an annotation instance.\n\t * <p>If this merged annotation was created {@linkplain #from(Annotation) from}\n\t * an annotation instance, that annotation will be returned unmodified if it is\n\t * not <em>synthesizable</em>. An annotation is considered synthesizable if\n\t * it has not already been synthesized and one of the following is true.\n\t * <ul>\n\t * <li>The annotation declares attributes annotated with {@link AliasFor @AliasFor}.</li>\n\t * <li>The annotation is a composed annotation that relies on convention-based\n\t * annotation attribute overrides in meta-annotations.</li>\n\t * <li>The annotation declares attributes that are annotations or arrays of\n\t * annotations that are themselves synthesizable.</li>\n\t * </ul>\n\t * @return a synthesized version of the annotation or the original annotation\n\t * unmodified\n\t * @throws NoSuchElementException on a missing annotation\n\t */\n\tA synthesize() throws NoSuchElementException;\n\n\t/**\n\t * Optionally create a type-safe synthesized version of this annotation based\n\t * on a condition predicate.\n\t * <p>The result is synthesized using a JDK {@link java.lang.reflect.Proxy Proxy}\n\t * and as a result may incur a computational cost when first invoked.\n\t * <p>Consult the documentation for {@link #synthesize()} for an explanation\n\t * of what is considered synthesizable.\n\t * @param condition the test to determine if the annotation can be synthesized\n\t * @return an optional containing the synthesized version of the annotation or\n\t * an empty optional if the condition doesn't match\n\t * @throws NoSuchElementException on a missing annotation\n\t * @see MergedAnnotationPredicates\n\t */\n\tOptional<A> synthesize(Predicate<? super MergedAnnotation<A>> condition) throws NoSuchElementException;\n\n\n\t/**\n\t * Create a {@link MergedAnnotation} that represents a missing annotation\n\t * (i.e. one that is not present).\n\t * @return an instance representing a missing annotation\n\t */\n\tstatic <A extends Annotation> MergedAnnotation<A> missing() {\n\t\treturn MissingMergedAnnotation.getInstance();\n\t}\n\n\t/**\n\t * Create a new {@link MergedAnnotation} instance from the specified\n\t * annotation.\n\t * @param annotation the annotation to include\n\t * @return a {@link MergedAnnotation} instance containing the annotation\n\t */\n\tstatic <A extends Annotation> MergedAnnotation<A> from(A annotation) {\n\t\treturn from(null, annotation);\n\t}\n\n\t/**\n\t * Create a new {@link MergedAnnotation} instance from the specified\n\t * annotation.\n\t * @param source the source for the annotation. This source is used only for\n\t * information and logging. It does not need to <em>actually</em> contain\n\t * the specified annotations, and it will not be searched.\n\t * @param annotation the annotation to include\n\t * @return a {@link MergedAnnotation} instance for the annotation\n\t */\n\tstatic <A extends Annotation> MergedAnnotation<A> from(@Nullable Object source, A annotation) {\n\t\treturn TypeMappedAnnotation.from(source, annotation);\n\t}\n\n\t/**\n\t * Create a new {@link MergedAnnotation} instance of the specified\n\t * annotation type. The resulting annotation will not have any attribute\n\t * values but may still be used to query default values.\n\t * @param annotationType the annotation type\n\t * @return a {@link MergedAnnotation} instance for the annotation\n\t */\n\tstatic <A extends Annotation> MergedAnnotation<A> of(Class<A> annotationType) {\n\t\treturn of(null, annotationType, null);\n\t}\n\n\t/**\n\t * Create a new {@link MergedAnnotation} instance of the specified\n\t * annotation type with attribute values supplied by a map.\n\t * @param annotationType the annotation type\n\t * @param attributes the annotation attributes or {@code null} if just default\n\t * values should be used\n\t * @return a {@link MergedAnnotation} instance for the annotation and attributes\n\t * @see #of(AnnotatedElement, Class, Map)\n\t */\n\tstatic <A extends Annotation> MergedAnnotation<A> of(\n\t\t\tClass<A> annotationType, @Nullable Map<String, ?> attributes) {\n\n\t\treturn of(null, annotationType, attributes);\n\t}\n\n\t/**\n\t * Create a new {@link MergedAnnotation} instance of the specified\n\t * annotation type with attribute values supplied by a map.\n\t * @param source the source for the annotation. This source is used only for\n\t * information and logging. It does not need to <em>actually</em> contain\n\t * the specified annotations and it will not be searched.\n\t * @param annotationType the annotation type\n\t * @param attributes the annotation attributes or {@code null} if just default\n\t * values should be used\n\t * @return a {@link MergedAnnotation} instance for the annotation and attributes\n\t */\n\tstatic <A extends Annotation> MergedAnnotation<A> of(\n\t\t\t@Nullable AnnotatedElement source, Class<A> annotationType, @Nullable Map<String, ?> attributes) {\n\n\t\treturn of(null, source, annotationType, attributes);\n\t}\n\n\t/**\n\t * Create a new {@link MergedAnnotation} instance of the specified\n\t * annotation type with attribute values supplied by a map.\n\t * @param classLoader the class loader used to resolve class attributes\n\t * @param source the source for the annotation. This source is used only for\n\t * information and logging. It does not need to <em>actually</em> contain\n\t * the specified annotations and it will not be searched.\n\t * @param annotationType the annotation type\n\t * @param attributes the annotation attributes or {@code null} if just default\n\t * values should be used\n\t * @return a {@link MergedAnnotation} instance for the annotation and attributes\n\t */\n\tstatic <A extends Annotation> MergedAnnotation<A> of(\n\t\t\t@Nullable ClassLoader classLoader, @Nullable Object source,\n\t\t\tClass<A> annotationType, @Nullable Map<String, ?> attributes) {\n\n\t\treturn TypeMappedAnnotation.of(classLoader, source, annotationType, attributes);\n\t}\n\n\n\t/**\n\t * Adaptations that can be applied to attribute values when creating\n\t * {@linkplain MergedAnnotation#asMap(Adapt...) Maps} or\n\t * {@link MergedAnnotation#asAnnotationAttributes(Adapt...) AnnotationAttributes}.\n\t */\n\tenum Adapt {\n\n\t\t/**\n\t\t * Adapt class or class array attributes to strings.\n\t\t */\n\t\tCLASS_TO_STRING,\n\n\t\t/**\n\t\t * Adapt nested annotation or annotation arrays to maps rather\n\t\t * than synthesizing the values.\n\t\t */\n\t\tANNOTATION_TO_MAP;\n\n\t\tprotected final boolean isIn(Adapt... adaptations) {\n\t\t\tfor (Adapt candidate : adaptations) {\n\t\t\t\tif (candidate == this) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * Factory method to create an {@link Adapt} array from a set of boolean flags.\n\t\t * @param classToString if {@link Adapt#CLASS_TO_STRING} is included\n\t\t * @param annotationsToMap if {@link Adapt#ANNOTATION_TO_MAP} is included\n\t\t * @return a new {@link Adapt} array\n\t\t */\n\t\tpublic static Adapt[] values(boolean classToString, boolean annotationsToMap) {\n\t\t\tEnumSet<Adapt> result = EnumSet.noneOf(Adapt.class);\n\t\t\taddIfTrue(result, Adapt.CLASS_TO_STRING, classToString);\n\t\t\taddIfTrue(result, Adapt.ANNOTATION_TO_MAP, annotationsToMap);\n\t\t\treturn result.toArray(new Adapt[0]);\n\t\t}\n\n\t\tprivate static <T> void addIfTrue(Set<T> result, T value, boolean test) {\n\t\t\tif (test) {\n\t\t\t\tresult.add(value);\n\t\t\t}\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotation",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.MergedAnnotation#VALUE",
    "tailType": "field"
  }
]