[
  {
    "head": "org.springframework.util.PatternMatchUtilsTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.PatternMatchUtilsTests#startsEndsBetween()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.PatternMatchUtilsTests#startsEndsBetween()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.PatternMatchUtilsTests#ridiculous()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid ridiculous() {\r\n    assertMatches(\"*1*2*3*\", \"0011002001010030020201030\");\r\n    assertDoesNotMatch(\"1*2*3*4\", \"10300204\");\r\n    assertDoesNotMatch(\"1*2*3*3\", \"10300203\");\r\n    assertMatches(\"*1*2*3*\", \"123\");\r\n    assertDoesNotMatch(\"*1*2*3*\", \"132\");\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.PatternMatchUtilsTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.PatternMatchUtilsTests#ridiculous()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.PatternMatchUtilsTests#ridiculous()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.PatternMatchUtilsTests#patternVariants()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid patternVariants() {\r\n    assertDoesNotMatch(\"*a\", \"*\");\r\n    assertMatches(\"*a\", \"a\");\r\n    assertDoesNotMatch(\"*a\", \"b\");\r\n    assertMatches(\"*a\", \"aa\");\r\n    assertMatches(\"*a\", \"ba\");\r\n    assertDoesNotMatch(\"*a\", \"ab\");\r\n    assertDoesNotMatch(\"**a\", \"*\");\r\n    assertMatches(\"**a\", \"a\");\r\n    assertDoesNotMatch(\"**a\", \"b\");\r\n    assertMatches(\"**a\", \"aa\");\r\n    assertMatches(\"**a\", \"ba\");\r\n    assertDoesNotMatch(\"**a\", \"ab\");\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.PatternMatchUtilsTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.PatternMatchUtilsTests#patternVariants()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.PatternMatchUtilsTests#patternVariants()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.PatternMatchUtilsTests#assertMatches(String,String)",
    "headType": "method",
    "relation": "provide",
    "tail": "private void assertMatches(String pattern, String str) {\r\n    assertThat(PatternMatchUtils.simpleMatch(pattern, str)).isTrue();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.PatternMatchUtilsTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.PatternMatchUtilsTests#assertMatches(String,String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.PatternMatchUtilsTests#assertDoesNotMatch(String,String)",
    "headType": "method",
    "relation": "provide",
    "tail": "private void assertDoesNotMatch(String pattern, String str) {\r\n    assertThat(PatternMatchUtils.simpleMatch(pattern, str)).isFalse();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.PatternMatchUtilsTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.PatternMatchUtilsTests#assertDoesNotMatch(String,String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.PatternMatchUtilsTests#assertMatches(String[],String)",
    "headType": "method",
    "relation": "provide",
    "tail": "private void assertMatches(String[] patterns, String str) {\r\n    assertThat(PatternMatchUtils.simpleMatch(patterns, str)).isTrue();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.PatternMatchUtilsTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.PatternMatchUtilsTests#assertMatches(String[],String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.PatternMatchUtilsTests#assertDoesNotMatch(String[],String)",
    "headType": "method",
    "relation": "provide",
    "tail": "private void assertDoesNotMatch(String[] patterns, String str) {\r\n    assertThat(PatternMatchUtils.simpleMatch(patterns, str)).isFalse();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.PatternMatchUtilsTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.PatternMatchUtilsTests#assertDoesNotMatch(String[],String)",
    "tailType": "method"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.asm",
    "tailType": "package"
  },
  {
    "head": "org.springframework.asm",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.asm.Attribute",
    "tailType": "class"
  },
  {
    "head": "org.springframework.asm.Attribute",
    "headType": "class",
    "relation": "provide",
    "tail": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage org.springframework.asm;\n\n/**\n * A non standard class, field, method or Code attribute, as defined in the Java Virtual Machine\n * Specification (JVMS).\n *\n * @see <a href= \"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7\">JVMS\n *     4.7</a>\n * @see <a href= \"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.3\">JVMS\n *     4.7.3</a>\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n */\npublic class Attribute {\n\n  /** The type of this attribute, also called its name in the JVMS. */\n  public final String type;\n\n  /**\n   * The raw content of this attribute, as returned by {@link\n   * #write(ClassWriter,byte[],int,int,int)}. The 6 header bytes of the attribute\n   * (attribute_name_index and attribute_length) are <i>not</i> included.\n   */\n  private ByteVector cachedContent;\n\n  /**\n   * The next attribute in this attribute list (Attribute instances can be linked via this field to\n   * store a list of class, field, method or Code attributes). May be {@literal null}.\n   */\n  Attribute nextAttribute;\n\n  /**\n   * Constructs a new empty attribute.\n   *\n   * @param type the type of the attribute.\n   */\n  protected Attribute(final String type) {\n    this.type = type;\n  }\n\n  /**\n   * Returns {@literal true} if this type of attribute is unknown. This means that the attribute\n   * content can't be parsed to extract constant pool references, labels, etc. Instead, the\n   * attribute content is read as an opaque byte array, and written back as is. This can lead to\n   * invalid attributes, if the content actually contains constant pool references, labels, or other\n   * symbolic references that need to be updated when there are changes to the constant pool, the\n   * method bytecode, etc. The default implementation of this method always returns {@literal true}.\n   *\n   * @return {@literal true} if this type of attribute is unknown.\n   */\n  public boolean isUnknown() {\n    return true;\n  }\n\n  /**\n   * Returns {@literal true} if this type of attribute is a Code attribute.\n   *\n   * @return {@literal true} if this type of attribute is a Code attribute.\n   */\n  public boolean isCodeAttribute() {\n    return false;\n  }\n\n  /**\n   * Returns the labels corresponding to this attribute.\n   *\n   * @return the labels corresponding to this attribute, or {@literal null} if this attribute is not\n   *     a Code attribute that contains labels.\n   * @deprecated no longer used by ASM.\n   */\n  @Deprecated\n  protected Label[] getLabels() {\n    return new Label[0];\n  }\n\n  /**\n   * Reads a {@link #type} attribute. This method must return a <i>new</i> {@link Attribute} object,\n   * of type {@link #type}, corresponding to the 'length' bytes starting at 'offset', in the given\n   * ClassReader.\n   *\n   * @param classReader the class that contains the attribute to be read.\n   * @param offset index of the first byte of the attribute's content in {@link ClassReader}. The 6\n   *     attribute header bytes (attribute_name_index and attribute_length) are not taken into\n   *     account here.\n   * @param length the length of the attribute's content (excluding the 6 attribute header bytes).\n   * @param charBuffer the buffer to be used to call the ClassReader methods requiring a\n   *     'charBuffer' parameter.\n   * @param codeAttributeOffset index of the first byte of content of the enclosing Code attribute\n   *     in {@link ClassReader}, or -1 if the attribute to be read is not a Code attribute. The 6\n   *     attribute header bytes (attribute_name_index and attribute_length) are not taken into\n   *     account here.\n   * @param labels the labels of the method's code, or {@literal null} if the attribute to be read\n   *     is not a Code attribute. Labels defined in the attribute must be created and added to this\n   *     array, if not already present, by calling the {@link #readLabel} method (do not create\n   *     {@link Label} instances directly).\n   * @return a <i>new</i> {@link Attribute} object corresponding to the specified bytes.\n   */\n  protected Attribute read(\n      final ClassReader classReader,\n      final int offset,\n      final int length,\n      final char[] charBuffer,\n      final int codeAttributeOffset,\n      final Label[] labels) {\n    Attribute attribute = new Attribute(type);\n    attribute.cachedContent = new ByteVector(classReader.readBytes(offset, length));\n    return attribute;\n  }\n\n  /**\n   * Reads an attribute with the same {@link #type} as the given attribute. This method returns a\n   * new {@link Attribute} object, corresponding to the 'length' bytes starting at 'offset', in the\n   * given ClassReader.\n   *\n   * @param attribute The attribute prototype that is used for reading.\n   * @param classReader the class that contains the attribute to be read.\n   * @param offset index of the first byte of the attribute's content in {@link ClassReader}. The 6\n   *     attribute header bytes (attribute_name_index and attribute_length) are not taken into\n   *     account here.\n   * @param length the length of the attribute's content (excluding the 6 attribute header bytes).\n   * @param charBuffer the buffer to be used to call the ClassReader methods requiring a\n   *     'charBuffer' parameter.\n   * @param codeAttributeOffset index of the first byte of content of the enclosing Code attribute\n   *     in {@link ClassReader}, or -1 if the attribute to be read is not a Code attribute. The 6\n   *     attribute header bytes (attribute_name_index and attribute_length) are not taken into\n   *     account here.\n   * @param labels the labels of the method's code, or {@literal null} if the attribute to be read\n   *     is not a Code attribute. Labels defined in the attribute are added to this array, if not\n   *     already present.\n   * @return a new {@link Attribute} object corresponding to the specified bytes.\n   */\n  public static Attribute read(\n      final Attribute attribute,\n      final ClassReader classReader,\n      final int offset,\n      final int length,\n      final char[] charBuffer,\n      final int codeAttributeOffset,\n      final Label[] labels) {\n    return attribute.read(classReader, offset, length, charBuffer, codeAttributeOffset, labels);\n  }\n\n  /**\n   * Returns the label corresponding to the given bytecode offset by calling {@link\n   * ClassReader#readLabel}. This creates and adds the label to the given array if it is not already\n   * present. Note that this created label may be a {@link Label} subclass instance, if the given\n   * ClassReader overrides {@link ClassReader#readLabel}. Hence {@link #read(ClassReader, int, int,\n   * char[], int, Label[])} must not manually create {@link Label} instances.\n   *\n   * @param bytecodeOffset a bytecode offset in a method.\n   * @param labels the already created labels, indexed by their offset. If a label already exists\n   *     for bytecodeOffset this method does not create a new one. Otherwise it stores the new label\n   *     in this array.\n   * @return a label for the given bytecode offset.\n   */\n  public static Label readLabel(\n      final ClassReader classReader, final int bytecodeOffset, final Label[] labels) {\n    return classReader.readLabel(bytecodeOffset, labels);\n  }\n\n  /**\n   * Calls {@link #write(ClassWriter,byte[],int,int,int)} if it has not already been called and\n   * returns its result or its (cached) previous result.\n   *\n   * @param classWriter the class to which this attribute must be added. This parameter can be used\n   *     to add the items that corresponds to this attribute to the constant pool of this class.\n   * @param code the bytecode of the method corresponding to this Code attribute, or {@literal null}\n   *     if this attribute is not a Code attribute. Corresponds to the 'code' field of the Code\n   *     attribute.\n   * @param codeLength the length of the bytecode of the method corresponding to this code\n   *     attribute, or 0 if this attribute is not a Code attribute. Corresponds to the 'code_length'\n   *     field of the Code attribute.\n   * @param maxStack the maximum stack size of the method corresponding to this Code attribute, or\n   *     -1 if this attribute is not a Code attribute.\n   * @param maxLocals the maximum number of local variables of the method corresponding to this code\n   *     attribute, or -1 if this attribute is not a Code attribute.\n   * @return the byte array form of this attribute.\n   */\n  private ByteVector maybeWrite(\n      final ClassWriter classWriter,\n      final byte[] code,\n      final int codeLength,\n      final int maxStack,\n      final int maxLocals) {\n    if (cachedContent == null) {\n      cachedContent = write(classWriter, code, codeLength, maxStack, maxLocals);\n    }\n    return cachedContent;\n  }\n\n  /**\n   * Returns the byte array form of the content of this attribute. The 6 header bytes\n   * (attribute_name_index and attribute_length) must <i>not</i> be added in the returned\n   * ByteVector.\n   *\n   * <p>This method is only invoked once to compute the binary form of this attribute. Subsequent\n   * changes to the attribute after it was written for the first time will not be considered.\n   *\n   * @param classWriter the class to which this attribute must be added. This parameter can be used\n   *     to add the items that corresponds to this attribute to the constant pool of this class.\n   * @param code the bytecode of the method corresponding to this Code attribute, or {@literal null}\n   *     if this attribute is not a Code attribute. Corresponds to the 'code' field of the Code\n   *     attribute.\n   * @param codeLength the length of the bytecode of the method corresponding to this code\n   *     attribute, or 0 if this attribute is not a Code attribute. Corresponds to the 'code_length'\n   *     field of the Code attribute.\n   * @param maxStack the maximum stack size of the method corresponding to this Code attribute, or\n   *     -1 if this attribute is not a Code attribute.\n   * @param maxLocals the maximum number of local variables of the method corresponding to this code\n   *     attribute, or -1 if this attribute is not a Code attribute.\n   * @return the byte array form of this attribute.\n   */\n  protected ByteVector write(\n      final ClassWriter classWriter,\n      final byte[] code,\n      final int codeLength,\n      final int maxStack,\n      final int maxLocals) {\n    return cachedContent;\n  }\n\n  /**\n   * Returns the byte array form of the content of the given attribute. The 6 header bytes\n   * (attribute_name_index and attribute_length) are <i>not</i> added in the returned byte array.\n   *\n   * @param attribute The attribute that should be written.\n   * @param classWriter the class to which this attribute must be added. This parameter can be used\n   *     to add the items that corresponds to this attribute to the constant pool of this class.\n   * @param code the bytecode of the method corresponding to this Code attribute, or {@literal null}\n   *     if this attribute is not a Code attribute. Corresponds to the 'code' field of the Code\n   *     attribute.\n   * @param codeLength the length of the bytecode of the method corresponding to this code\n   *     attribute, or 0 if this attribute is not a Code attribute. Corresponds to the 'code_length'\n   *     field of the Code attribute.\n   * @param maxStack the maximum stack size of the method corresponding to this Code attribute, or\n   *     -1 if this attribute is not a Code attribute.\n   * @param maxLocals the maximum number of local variables of the method corresponding to this code\n   *     attribute, or -1 if this attribute is not a Code attribute.\n   * @return the byte array form of this attribute.\n   */\n  public static byte[] write(\n      final Attribute attribute,\n      final ClassWriter classWriter,\n      final byte[] code,\n      final int codeLength,\n      final int maxStack,\n      final int maxLocals) {\n    ByteVector content = attribute.maybeWrite(classWriter, code, codeLength, maxStack, maxLocals);\n    byte[] result = new byte[content.length];\n    System.arraycopy(content.data, 0, result, 0, content.length);\n    return result;\n  }\n\n  /**\n   * Returns the number of attributes of the attribute list that begins with this attribute.\n   *\n   * @return the number of attributes of the attribute list that begins with this attribute.\n   */\n  final int getAttributeCount() {\n    int count = 0;\n    Attribute attribute = this;\n    while (attribute != null) {\n      count += 1;\n      attribute = attribute.nextAttribute;\n    }\n    return count;\n  }\n\n  /**\n   * Returns the total size in bytes of all the attributes in the attribute list that begins with\n   * this attribute. This size includes the 6 header bytes (attribute_name_index and\n   * attribute_length) per attribute. Also adds the attribute type names to the constant pool.\n   *\n   * @param symbolTable where the constants used in the attributes must be stored.\n   * @return the size of all the attributes in this attribute list. This size includes the size of\n   *     the attribute headers.\n   */\n  final int computeAttributesSize(final SymbolTable symbolTable) {\n    final byte[] code = null;\n    final int codeLength = 0;\n    final int maxStack = -1;\n    final int maxLocals = -1;\n    return computeAttributesSize(symbolTable, code, codeLength, maxStack, maxLocals);\n  }\n\n  /**\n   * Returns the total size in bytes of all the attributes in the attribute list that begins with\n   * this attribute. This size includes the 6 header bytes (attribute_name_index and\n   * attribute_length) per attribute. Also adds the attribute type names to the constant pool.\n   *\n   * @param symbolTable where the constants used in the attributes must be stored.\n   * @param code the bytecode of the method corresponding to these Code attributes, or {@literal\n   *     null} if they are not Code attributes. Corresponds to the 'code' field of the Code\n   *     attribute.\n   * @param codeLength the length of the bytecode of the method corresponding to these code\n   *     attributes, or 0 if they are not Code attributes. Corresponds to the 'code_length' field of\n   *     the Code attribute.\n   * @param maxStack the maximum stack size of the method corresponding to these Code attributes, or\n   *     -1 if they are not Code attributes.\n   * @param maxLocals the maximum number of local variables of the method corresponding to these\n   *     Code attributes, or -1 if they are not Code attribute.\n   * @return the size of all the attributes in this attribute list. This size includes the size of\n   *     the attribute headers.\n   */\n  final int computeAttributesSize(\n      final SymbolTable symbolTable,\n      final byte[] code,\n      final int codeLength,\n      final int maxStack,\n      final int maxLocals) {\n    final ClassWriter classWriter = symbolTable.classWriter;\n    int size = 0;\n    Attribute attribute = this;\n    while (attribute != null) {\n      symbolTable.addConstantUtf8(attribute.type);\n      size += 6 + attribute.maybeWrite(classWriter, code, codeLength, maxStack, maxLocals).length;\n      attribute = attribute.nextAttribute;\n    }\n    return size;\n  }\n\n  /**\n   * Returns the total size in bytes of all the attributes that correspond to the given field,\n   * method or class access flags and signature. This size includes the 6 header bytes\n   * (attribute_name_index and attribute_length) per attribute. Also adds the attribute type names\n   * to the constant pool.\n   *\n   * @param symbolTable where the constants used in the attributes must be stored.\n   * @param accessFlags some field, method or class access flags.\n   * @param signatureIndex the constant pool index of a field, method of class signature.\n   * @return the size of all the attributes in bytes. This size includes the size of the attribute\n   *     headers.\n   */\n  static int computeAttributesSize(\n      final SymbolTable symbolTable, final int accessFlags, final int signatureIndex) {\n    int size = 0;\n    // Before Java 1.5, synthetic fields are represented with a Synthetic attribute.\n    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0\n        && symbolTable.getMajorVersion() < Opcodes.V1_5) {\n      // Synthetic attributes always use 6 bytes.\n      symbolTable.addConstantUtf8(Constants.SYNTHETIC);\n      size += 6;\n    }\n    if (signatureIndex != 0) {\n      // Signature attributes always use 8 bytes.\n      symbolTable.addConstantUtf8(Constants.SIGNATURE);\n      size += 8;\n    }\n    // ACC_DEPRECATED is ASM specific, the ClassFile format uses a Deprecated attribute instead.\n    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {\n      // Deprecated attributes always use 6 bytes.\n      symbolTable.addConstantUtf8(Constants.DEPRECATED);\n      size += 6;\n    }\n    return size;\n  }\n\n  /**\n   * Puts all the attributes of the attribute list that begins with this attribute, in the given\n   * byte vector. This includes the 6 header bytes (attribute_name_index and attribute_length) per\n   * attribute.\n   *\n   * @param symbolTable where the constants used in the attributes must be stored.\n   * @param output where the attributes must be written.\n   */\n  final void putAttributes(final SymbolTable symbolTable, final ByteVector output) {\n    final byte[] code = null;\n    final int codeLength = 0;\n    final int maxStack = -1;\n    final int maxLocals = -1;\n    putAttributes(symbolTable, code, codeLength, maxStack, maxLocals, output);\n  }\n\n  /**\n   * Puts all the attributes of the attribute list that begins with this attribute, in the given\n   * byte vector. This includes the 6 header bytes (attribute_name_index and attribute_length) per\n   * attribute.\n   *\n   * @param symbolTable where the constants used in the attributes must be stored.\n   * @param code the bytecode of the method corresponding to these Code attributes, or {@literal\n   *     null} if they are not Code attributes. Corresponds to the 'code' field of the Code\n   *     attribute.\n   * @param codeLength the length of the bytecode of the method corresponding to these code\n   *     attributes, or 0 if they are not Code attributes. Corresponds to the 'code_length' field of\n   *     the Code attribute.\n   * @param maxStack the maximum stack size of the method corresponding to these Code attributes, or\n   *     -1 if they are not Code attributes.\n   * @param maxLocals the maximum number of local variables of the method corresponding to these\n   *     Code attributes, or -1 if they are not Code attribute.\n   * @param output where the attributes must be written.\n   */\n  final void putAttributes(\n      final SymbolTable symbolTable,\n      final byte[] code,\n      final int codeLength,\n      final int maxStack,\n      final int maxLocals,\n      final ByteVector output) {\n    final ClassWriter classWriter = symbolTable.classWriter;\n    Attribute attribute = this;\n    while (attribute != null) {\n      ByteVector attributeContent =\n          attribute.maybeWrite(classWriter, code, codeLength, maxStack, maxLocals);\n      // Put attribute_name_index and attribute_length.\n      output.putShort(symbolTable.addConstantUtf8(attribute.type)).putInt(attributeContent.length);\n      output.putByteArray(attributeContent.data, 0, attributeContent.length);\n      attribute = attribute.nextAttribute;\n    }\n  }\n\n  /**\n   * Puts all the attributes that correspond to the given field, method or class access flags and\n   * signature, in the given byte vector. This includes the 6 header bytes (attribute_name_index and\n   * attribute_length) per attribute.\n   *\n   * @param symbolTable where the constants used in the attributes must be stored.\n   * @param accessFlags some field, method or class access flags.\n   * @param signatureIndex the constant pool index of a field, method of class signature.\n   * @param output where the attributes must be written.\n   */\n  static void putAttributes(\n      final SymbolTable symbolTable,\n      final int accessFlags,\n      final int signatureIndex,\n      final ByteVector output) {\n    // Before Java 1.5, synthetic fields are represented with a Synthetic attribute.\n    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0\n        && symbolTable.getMajorVersion() < Opcodes.V1_5) {\n      output.putShort(symbolTable.addConstantUtf8(Constants.SYNTHETIC)).putInt(0);\n    }\n    if (signatureIndex != 0) {\n      output\n          .putShort(symbolTable.addConstantUtf8(Constants.SIGNATURE))\n          .putInt(2)\n          .putShort(signatureIndex);\n    }\n    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {\n      output.putShort(symbolTable.addConstantUtf8(Constants.DEPRECATED)).putInt(0);\n    }\n  }\n\n  /** A set of attribute prototypes (attributes with the same type are considered equal). */\n  static final class Set {\n\n    private static final int SIZE_INCREMENT = 6;\n\n    private int size;\n    private Attribute[] data = new Attribute[SIZE_INCREMENT];\n\n    void addAttributes(final Attribute attributeList) {\n      Attribute attribute = attributeList;\n      while (attribute != null) {\n        if (!contains(attribute)) {\n          add(attribute);\n        }\n        attribute = attribute.nextAttribute;\n      }\n    }\n\n    Attribute[] toArray() {\n      Attribute[] result = new Attribute[size];\n      System.arraycopy(data, 0, result, 0, size);\n      return result;\n    }\n\n    private boolean contains(final Attribute attribute) {\n      for (int i = 0; i < size; ++i) {\n        if (data[i].type.equals(attribute.type)) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    private void add(final Attribute attribute) {\n      if (size >= data.length) {\n        Attribute[] newData = new Attribute[data.length + SIZE_INCREMENT];\n        System.arraycopy(data, 0, newData, 0, size);\n        data = newData;\n      }\n      data[size++] = attribute;\n    }\n  }\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.asm.Attribute",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.Attribute#type",
    "tailType": "field"
  }
]