[
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.AnnotationsProcessor",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationsProcessor",
    "headType": "class",
    "relation": "use",
    "tail": "@FunctionalInterface",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationsProcessor",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\n\nimport org.jspecify.annotations.Nullable;\n\n/**\n * Callback interface used to process annotations.\n *\n * @author Phillip Webb\n * @since 5.2\n * @param <C> the context type\n * @param <R> the result type\n * @see AnnotationsScanner\n * @see TypeMappedAnnotations\n */\n@FunctionalInterface\ninterface AnnotationsProcessor<C, R> {\n\n\t/**\n\t * Called when an aggregate is about to be processed. This method may return\n\t * a {@code non-null} result to short-circuit any further processing.\n\t * @param context the context information relevant to the processor\n\t * @param aggregateIndex the aggregate index about to be processed\n\t * @return a {@code non-null} result if no further processing is required\n\t */\n\tdefault @Nullable R doWithAggregate(C context, int aggregateIndex) {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Called when an array of annotations can be processed. This method may\n\t * return a {@code non-null} result to short-circuit any further processing.\n\t * @param context the context information relevant to the processor\n\t * @param aggregateIndex the aggregate index of the provided annotations\n\t * @param source the original source of the annotations, if known\n\t * @param annotations the annotations to process (this array may contain\n\t * {@code null} elements)\n\t * @return a {@code non-null} result if no further processing is required\n\t */\n\t@Nullable R doWithAnnotations(C context, int aggregateIndex, @Nullable Object source, @Nullable Annotation[] annotations);\n\n\t/**\n\t * Get the final result to be returned. By default this method returns\n\t * the last process result.\n\t * @param result the last early exit result, or {@code null} if none\n\t * @return the final result to be returned to the caller\n\t */\n\tdefault @Nullable R finish(@Nullable R result) {\n\t\treturn result;\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationsProcessor#doWithAggregate(C,int)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Called when an aggregate is about to be processed. This method may return\r\n * a {@code non-null} result to short-circuit any further processing.\r\n * @param context the context information relevant to the processor\r\n * @param aggregateIndex the aggregate index about to be processed\r\n * @return a {@code non-null} result if no further processing is required\r\n */\r\n@Nullable\r\ndefault R doWithAggregate(C context, int aggregateIndex) {\r\n    return null;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationsProcessor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotationsProcessor#doWithAggregate(C,int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationsProcessor#doWithAggregate(C,int)",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationsProcessor#doWithAnnotations(C,int,Object,Annotation[])",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Called when an array of annotations can be processed. This method may\r\n * return a {@code non-null} result to short-circuit any further processing.\r\n * @param context the context information relevant to the processor\r\n * @param aggregateIndex the aggregate index of the provided annotations\r\n * @param source the original source of the annotations, if known\r\n * @param annotations the annotations to process (this array may contain\r\n * {@code null} elements)\r\n * @return a {@code non-null} result if no further processing is required\r\n */\r\n@Nullable\r\nR doWithAnnotations(C context, int aggregateIndex, @Nullable Object source, @Nullable Annotation[] annotations);",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationsProcessor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotationsProcessor#doWithAnnotations(C,int,Object,Annotation[])",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationsProcessor#doWithAnnotations(C,int,Object,Annotation[])",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationsProcessor#finish(R)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Get the final result to be returned. By default this method returns\r\n * the last process result.\r\n * @param result the last early exit result, or {@code null} if none\r\n * @return the final result to be returned to the caller\r\n */\r\n@Nullable\r\ndefault R finish(@Nullable R result) {\r\n    return result;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationsProcessor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotationsProcessor#finish(R)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationsProcessor#finish(R)",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.annotation",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.AnnotationsScanner",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationsScanner",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.function.Predicate;\n\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.core.BridgeMethodResolver;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.ResolvableType;\nimport org.springframework.core.annotation.MergedAnnotations.Search;\nimport org.springframework.core.annotation.MergedAnnotations.SearchStrategy;\nimport org.springframework.util.ConcurrentReferenceHashMap;\nimport org.springframework.util.ObjectUtils;\nimport org.springframework.util.ReflectionUtils;\n\n/**\n * Scanner to search for relevant annotations in the annotation hierarchy of an\n * {@link AnnotatedElement}.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n * @since 5.2\n * @see AnnotationsProcessor\n */\nabstract class AnnotationsScanner {\n\n\tprivate static final @Nullable Annotation[] NO_ANNOTATIONS = {};\n\n\tprivate static final Method[] NO_METHODS = {};\n\n\n\tprivate static final Map<AnnotatedElement, Annotation[]> declaredAnnotationCache =\n\t\t\tnew ConcurrentReferenceHashMap<>(256);\n\n\tprivate static final Map<Class<?>, @Nullable Method[]> baseTypeMethodsCache =\n\t\t\tnew ConcurrentReferenceHashMap<>(256);\n\n\n\tprivate AnnotationsScanner() {\n\t}\n\n\n\t/**\n\t * Scan the hierarchy of the specified element for relevant annotations and\n\t * call the processor as required.\n\t * @param context an optional context object that will be passed back to the\n\t * processor\n\t * @param source the source element to scan\n\t * @param searchStrategy the search strategy to use\n\t * @param searchEnclosingClass a predicate which evaluates to {@code true}\n\t * if a search should be performed on the enclosing class of the class\n\t * supplied to the predicate\n\t * @param processor the processor that receives the annotations\n\t * @return the result of {@link AnnotationsProcessor#finish(Object)}\n\t */\n\tstatic <C, R> @Nullable R scan(C context, AnnotatedElement source, SearchStrategy searchStrategy,\n\t\t\tPredicate<Class<?>> searchEnclosingClass, AnnotationsProcessor<C, R> processor) {\n\n\t\tR result = process(context, source, searchStrategy, searchEnclosingClass, processor);\n\t\treturn processor.finish(result);\n\t}\n\n\tprivate static <C, R> @Nullable R process(C context, AnnotatedElement source,\n\t\t\tSearchStrategy searchStrategy, Predicate<Class<?>> searchEnclosingClass,\n\t\t\tAnnotationsProcessor<C, R> processor) {\n\n\t\tif (source instanceof Class<?> clazz) {\n\t\t\treturn processClass(context, clazz, searchStrategy, searchEnclosingClass, processor);\n\t\t}\n\t\tif (source instanceof Method method) {\n\t\t\treturn processMethod(context, method, searchStrategy, processor);\n\t\t}\n\t\treturn processElement(context, source, processor);\n\t}\n\n\tprivate static <C, R> @Nullable R processClass(C context, Class<?> source, SearchStrategy searchStrategy,\n\t\t\tPredicate<Class<?>> searchEnclosingClass, AnnotationsProcessor<C, R> processor) {\n\n\t\treturn switch (searchStrategy) {\n\t\t\tcase DIRECT -> processElement(context, source, processor);\n\t\t\tcase INHERITED_ANNOTATIONS -> processClassInheritedAnnotations(context, source, processor);\n\t\t\tcase SUPERCLASS -> processClassHierarchy(context, source, processor, false, Search.never);\n\t\t\tcase TYPE_HIERARCHY -> processClassHierarchy(context, source, processor, true, searchEnclosingClass);\n\t\t};\n\t}\n\n\tprivate static <C, R> @Nullable R processClassInheritedAnnotations(C context, Class<?> source,\n\t\t\tAnnotationsProcessor<C, R> processor) {\n\n\t\ttry {\n\t\t\tif (isWithoutHierarchy(source, Search.never)) {\n\t\t\t\treturn processElement(context, source, processor);\n\t\t\t}\n\t\t\t@Nullable Annotation[] relevant = null;\n\t\t\tint remaining = Integer.MAX_VALUE;\n\t\t\tint aggregateIndex = 0;\n\t\t\tClass<?> root = source;\n\t\t\twhile (source != null && source != Object.class && remaining > 0 && !hasPlainJavaAnnotationsOnly(source)) {\n\t\t\t\tR result = processor.doWithAggregate(context, aggregateIndex);\n\t\t\t\tif (result != null) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\t@Nullable Annotation[] declaredAnns = getDeclaredAnnotations(source, true);\n\t\t\t\tif (declaredAnns.length > 0) {\n\t\t\t\t\tif (relevant == null) {\n\t\t\t\t\t\trelevant = root.getAnnotations();\n\t\t\t\t\t\tremaining = relevant.length;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < declaredAnns.length; i++) {\n\t\t\t\t\t\tif (declaredAnns[i] != null) {\n\t\t\t\t\t\t\tboolean isRelevant = false;\n\t\t\t\t\t\t\tfor (int relevantIndex = 0; relevantIndex < relevant.length; relevantIndex++) {\n\t\t\t\t\t\t\t\t//noinspection DataFlowIssue\n\t\t\t\t\t\t\t\tif (relevant[relevantIndex] != null &&\n\t\t\t\t\t\t\t\t\t\tdeclaredAnns[i].annotationType() == relevant[relevantIndex].annotationType()) {\n\t\t\t\t\t\t\t\t\tisRelevant = true;\n\t\t\t\t\t\t\t\t\trelevant[relevantIndex] = null;\n\t\t\t\t\t\t\t\t\tremaining--;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!isRelevant) {\n\t\t\t\t\t\t\t\tdeclaredAnns[i] = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult = processor.doWithAnnotations(context, aggregateIndex, source, declaredAnns);\n\t\t\t\tif (result != null) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tsource = source.getSuperclass();\n\t\t\t\taggregateIndex++;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tAnnotationUtils.handleIntrospectionFailure(source, ex);\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate static <C, R> @Nullable R processClassHierarchy(C context, Class<?> source,\n\t\t\tAnnotationsProcessor<C, R> processor, boolean includeInterfaces,\n\t\t\tPredicate<Class<?>> searchEnclosingClass) {\n\n\t\treturn processClassHierarchy(context, new int[] {0}, source, processor,\n\t\t\t\tincludeInterfaces, searchEnclosingClass);\n\t}\n\n\tprivate static <C, R> @Nullable R processClassHierarchy(C context, int[] aggregateIndex, Class<?> source,\n\t\t\tAnnotationsProcessor<C, R> processor, boolean includeInterfaces,\n\t\t\tPredicate<Class<?>> searchEnclosingClass) {\n\n\t\ttry {\n\t\t\tR result = processor.doWithAggregate(context, aggregateIndex[0]);\n\t\t\tif (result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif (hasPlainJavaAnnotationsOnly(source)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t@Nullable Annotation[] annotations = getDeclaredAnnotations(source, false);\n\t\t\tresult = processor.doWithAnnotations(context, aggregateIndex[0], source, annotations);\n\t\t\tif (result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\taggregateIndex[0]++;\n\t\t\tif (includeInterfaces) {\n\t\t\t\tfor (Class<?> interfaceType : source.getInterfaces()) {\n\t\t\t\t\tR interfacesResult = processClassHierarchy(context, aggregateIndex,\n\t\t\t\t\t\tinterfaceType, processor, true, searchEnclosingClass);\n\t\t\t\t\tif (interfacesResult != null) {\n\t\t\t\t\t\treturn interfacesResult;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tClass<?> superclass = source.getSuperclass();\n\t\t\tif (superclass != Object.class && superclass != null) {\n\t\t\t\tR superclassResult = processClassHierarchy(context, aggregateIndex,\n\t\t\t\t\tsuperclass, processor, includeInterfaces, searchEnclosingClass);\n\t\t\t\tif (superclassResult != null) {\n\t\t\t\t\treturn superclassResult;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (searchEnclosingClass.test(source)) {\n\t\t\t\t// Since merely attempting to load the enclosing class may result in\n\t\t\t\t// automatic loading of sibling nested classes that in turn results\n\t\t\t\t// in an exception such as NoClassDefFoundError, we wrap the following\n\t\t\t\t// in its own dedicated try-catch block in order not to preemptively\n\t\t\t\t// halt the annotation scanning process.\n\t\t\t\ttry {\n\t\t\t\t\tClass<?> enclosingClass = source.getEnclosingClass();\n\t\t\t\t\tif (enclosingClass != null) {\n\t\t\t\t\t\tR enclosingResult = processClassHierarchy(context, aggregateIndex,\n\t\t\t\t\t\t\tenclosingClass, processor, includeInterfaces, searchEnclosingClass);\n\t\t\t\t\t\tif (enclosingResult != null) {\n\t\t\t\t\t\t\treturn enclosingResult;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tAnnotationUtils.handleIntrospectionFailure(source, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tAnnotationUtils.handleIntrospectionFailure(source, ex);\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate static <C, R> @Nullable R processMethod(C context, Method source,\n\t\t\tSearchStrategy searchStrategy, AnnotationsProcessor<C, R> processor) {\n\n\t\treturn switch (searchStrategy) {\n\t\t\tcase DIRECT, INHERITED_ANNOTATIONS -> processMethodInheritedAnnotations(context, source, processor);\n\t\t\tcase SUPERCLASS -> processMethodHierarchy(context, new int[]{0}, source.getDeclaringClass(),\n\t\t\t\t\tprocessor, source, false);\n\t\t\tcase TYPE_HIERARCHY -> processMethodHierarchy(context, new int[]{0}, source.getDeclaringClass(),\n\t\t\t\t\tprocessor, source, true);\n\t\t};\n\t}\n\n\tprivate static <C, R> @Nullable R processMethodInheritedAnnotations(C context, Method source,\n\t\t\tAnnotationsProcessor<C, R> processor) {\n\n\t\ttry {\n\t\t\tR result = processor.doWithAggregate(context, 0);\n\t\t\treturn (result != null ? result :\n\t\t\t\tprocessMethodAnnotations(context, 0, source, processor));\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tAnnotationUtils.handleIntrospectionFailure(source, ex);\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate static <C, R> @Nullable R processMethodHierarchy(C context, int[] aggregateIndex,\n\t\t\tClass<?> sourceClass, AnnotationsProcessor<C, R> processor, Method rootMethod,\n\t\t\tboolean includeInterfaces) {\n\n\t\ttry {\n\t\t\tR result = processor.doWithAggregate(context, aggregateIndex[0]);\n\t\t\tif (result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif (hasPlainJavaAnnotationsOnly(sourceClass)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tboolean calledProcessor = false;\n\t\t\tif (sourceClass == rootMethod.getDeclaringClass()) {\n\t\t\t\tresult = processMethodAnnotations(context, aggregateIndex[0],\n\t\t\t\t\trootMethod, processor);\n\t\t\t\tcalledProcessor = true;\n\t\t\t\tif (result != null) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (Method candidateMethod : getBaseTypeMethods(context, sourceClass)) {\n\t\t\t\t\tif (candidateMethod != null && isOverride(rootMethod, candidateMethod)) {\n\t\t\t\t\t\tresult = processMethodAnnotations(context, aggregateIndex[0],\n\t\t\t\t\t\t\tcandidateMethod, processor);\n\t\t\t\t\t\tcalledProcessor = true;\n\t\t\t\t\t\tif (result != null) {\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (Modifier.isPrivate(rootMethod.getModifiers())) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (calledProcessor) {\n\t\t\t\taggregateIndex[0]++;\n\t\t\t}\n\t\t\tif (includeInterfaces) {\n\t\t\t\tfor (Class<?> interfaceType : sourceClass.getInterfaces()) {\n\t\t\t\t\tR interfacesResult = processMethodHierarchy(context, aggregateIndex,\n\t\t\t\t\t\tinterfaceType, processor, rootMethod, true);\n\t\t\t\t\tif (interfacesResult != null) {\n\t\t\t\t\t\treturn interfacesResult;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tClass<?> superclass = sourceClass.getSuperclass();\n\t\t\tif (superclass != Object.class && superclass != null) {\n\t\t\t\tR superclassResult = processMethodHierarchy(context, aggregateIndex,\n\t\t\t\t\tsuperclass, processor, rootMethod, includeInterfaces);\n\t\t\t\tif (superclassResult != null) {\n\t\t\t\t\treturn superclassResult;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tAnnotationUtils.handleIntrospectionFailure(rootMethod, ex);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@SuppressWarnings(\"NullAway\") // Dataflow analysis limitation\n\tprivate static <C> @Nullable Method[] getBaseTypeMethods(C context, Class<?> baseType) {\n\t\tif (baseType == Object.class || hasPlainJavaAnnotationsOnly(baseType)) {\n\t\t\treturn NO_METHODS;\n\t\t}\n\n\t\t@Nullable Method[] methods = baseTypeMethodsCache.get(baseType);\n\t\tif (methods == null) {\n\t\t\tmethods = ReflectionUtils.getDeclaredMethods(baseType);\n\t\t\tint cleared = 0;\n\t\t\tfor (int i = 0; i < methods.length; i++) {\n\t\t\t\t//noinspection DataFlowIssue\n\t\t\t\tif (Modifier.isPrivate(methods[i].getModifiers()) ||\n\t\t\t\t\t\thasPlainJavaAnnotationsOnly(methods[i]) ||\n\t\t\t\t\t\tgetDeclaredAnnotations(methods[i], false).length == 0) {\n\t\t\t\t\tmethods[i] = null;\n\t\t\t\t\tcleared++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cleared == methods.length) {\n\t\t\t\tmethods = NO_METHODS;\n\t\t\t}\n\t\t\tbaseTypeMethodsCache.put(baseType, methods);\n\t\t}\n\t\treturn methods;\n\t}\n\n\tprivate static boolean isOverride(Method rootMethod, Method candidateMethod) {\n\t\treturn (!Modifier.isPrivate(candidateMethod.getModifiers()) &&\n\t\t\t\tcandidateMethod.getName().equals(rootMethod.getName()) &&\n\t\t\t\thasSameParameterTypes(rootMethod, candidateMethod));\n\t}\n\n\tprivate static boolean hasSameParameterTypes(Method rootMethod, Method candidateMethod) {\n\t\tif (candidateMethod.getParameterCount() != rootMethod.getParameterCount()) {\n\t\t\treturn false;\n\t\t}\n\t\tClass<?>[] rootParameterTypes = rootMethod.getParameterTypes();\n\t\tClass<?>[] candidateParameterTypes = candidateMethod.getParameterTypes();\n\t\tif (Arrays.equals(candidateParameterTypes, rootParameterTypes)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn hasSameGenericTypeParameters(rootMethod, candidateMethod,\n\t\t\t\trootParameterTypes);\n\t}\n\n\tprivate static boolean hasSameGenericTypeParameters(\n\t\t\tMethod rootMethod, Method candidateMethod, Class<?>[] rootParameterTypes) {\n\n\t\tClass<?> sourceDeclaringClass = rootMethod.getDeclaringClass();\n\t\tClass<?> candidateDeclaringClass = candidateMethod.getDeclaringClass();\n\t\tif (!candidateDeclaringClass.isAssignableFrom(sourceDeclaringClass)) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < rootParameterTypes.length; i++) {\n\t\t\tClass<?> resolvedParameterType = ResolvableType.forMethodParameter(\n\t\t\t\t\tcandidateMethod, i, sourceDeclaringClass).resolve();\n\t\t\tif (rootParameterTypes[i] != resolvedParameterType) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static <C, R> @Nullable R processMethodAnnotations(C context, int aggregateIndex, Method source,\n\t\t\tAnnotationsProcessor<C, R> processor) {\n\n\t\t@Nullable Annotation[] annotations = getDeclaredAnnotations(source, false);\n\t\tR result = processor.doWithAnnotations(context, aggregateIndex, source, annotations);\n\t\tif (result != null) {\n\t\t\treturn result;\n\t\t}\n\t\tMethod bridgedMethod = BridgeMethodResolver.findBridgedMethod(source);\n\t\tif (bridgedMethod != source) {\n\t\t\t@Nullable Annotation[] bridgedAnnotations = getDeclaredAnnotations(bridgedMethod, true);\n\t\t\tfor (int i = 0; i < bridgedAnnotations.length; i++) {\n\t\t\t\tif (ObjectUtils.containsElement(annotations, bridgedAnnotations[i])) {\n\t\t\t\t\tbridgedAnnotations[i] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn processor.doWithAnnotations(context, aggregateIndex, source, bridgedAnnotations);\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate static <C, R> @Nullable R processElement(C context, AnnotatedElement source,\n\t\t\tAnnotationsProcessor<C, R> processor) {\n\n\t\ttry {\n\t\t\tR result = processor.doWithAggregate(context, 0);\n\t\t\treturn (result != null ? result : processor.doWithAnnotations(\n\t\t\t\tcontext, 0, source, getDeclaredAnnotations(source, false)));\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tAnnotationUtils.handleIntrospectionFailure(source, ex);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tstatic <A extends Annotation> @Nullable A getDeclaredAnnotation(AnnotatedElement source, Class<A> annotationType) {\n\t\t@Nullable Annotation[] annotations = getDeclaredAnnotations(source, false);\n\t\tfor (Annotation annotation : annotations) {\n\t\t\tif (annotation != null && annotationType == annotation.annotationType()) {\n\t\t\t\treturn (A) annotation;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@SuppressWarnings(\"NullAway\") // Dataflow analysis limitation\n\tstatic @Nullable Annotation[] getDeclaredAnnotations(AnnotatedElement source, boolean defensive) {\n\t\tboolean cached = false;\n\t\t@Nullable Annotation[] annotations = declaredAnnotationCache.get(source);\n\t\tif (annotations != null) {\n\t\t\tcached = true;\n\t\t}\n\t\telse {\n\t\t\tannotations = source.getDeclaredAnnotations();\n\t\t\tif (annotations.length != 0) {\n\t\t\t\tboolean allIgnored = true;\n\t\t\t\tfor (int i = 0; i < annotations.length; i++) {\n\t\t\t\t\tAnnotation annotation = annotations[i];\n\t\t\t\t\t//noinspection DataFlowIssue\n\t\t\t\t\tif (isIgnorable(annotation.annotationType()) ||\n\t\t\t\t\t\t\t!AttributeMethods.forAnnotationType(annotation.annotationType()).canLoad(annotation)) {\n\t\t\t\t\t\tannotations[i] = null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tallIgnored = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tannotations = (allIgnored ? NO_ANNOTATIONS : annotations);\n\t\t\t\tif (source instanceof Class || source instanceof Member) {\n\t\t\t\t\t//noinspection NullableProblems\n\t\t\t\t\tdeclaredAnnotationCache.put(source, annotations);\n\t\t\t\t\tcached = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!defensive || annotations.length == 0 || !cached) {\n\t\t\treturn annotations;\n\t\t}\n\t\treturn annotations.clone();\n\t}\n\n\tprivate static boolean isIgnorable(Class<?> annotationType) {\n\t\treturn AnnotationFilter.PLAIN.matches(annotationType);\n\t}\n\n\tstatic boolean isKnownEmpty(AnnotatedElement source, SearchStrategy searchStrategy,\n\t\t\tPredicate<Class<?>> searchEnclosingClass) {\n\n\t\tif (hasPlainJavaAnnotationsOnly(source)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (searchStrategy == SearchStrategy.DIRECT || isWithoutHierarchy(source, searchEnclosingClass)) {\n\t\t\tif (source instanceof Method method && method.isBridge()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn getDeclaredAnnotations(source, false).length == 0;\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic boolean hasPlainJavaAnnotationsOnly(@Nullable Object annotatedElement) {\n\t\tif (annotatedElement instanceof Class<?> clazz) {\n\t\t\treturn hasPlainJavaAnnotationsOnly(clazz);\n\t\t}\n\t\telse if (annotatedElement instanceof Member member) {\n\t\t\treturn hasPlainJavaAnnotationsOnly(member.getDeclaringClass());\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tstatic boolean hasPlainJavaAnnotationsOnly(Class<?> type) {\n\t\treturn (type.getName().startsWith(\"java.\") || type == Ordered.class);\n\t}\n\n\tprivate static boolean isWithoutHierarchy(AnnotatedElement source, Predicate<Class<?>> searchEnclosingClass) {\n\t\tif (source == Object.class) {\n\t\t\treturn true;\n\t\t}\n\t\tif (source instanceof Class<?> sourceClass) {\n\t\t\tboolean noSuperTypes = (sourceClass.getSuperclass() == Object.class &&\n\t\t\t\t\tsourceClass.getInterfaces().length == 0);\n\t\t\treturn (searchEnclosingClass.test(sourceClass) ? noSuperTypes &&\n\t\t\t\t\tsourceClass.getEnclosingClass() == null : noSuperTypes);\n\t\t}\n\t\tif (source instanceof Method sourceMethod) {\n\t\t\treturn (Modifier.isPrivate(sourceMethod.getModifiers()) ||\n\t\t\t\t\tisWithoutHierarchy(sourceMethod.getDeclaringClass(), searchEnclosingClass));\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic void clearCache() {\n\t\tdeclaredAnnotationCache.clear();\n\t\tbaseTypeMethodsCache.clear();\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationsScanner",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.AnnotationsScanner#NO_ANNOTATIONS",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationsScanner#NO_ANNOTATIONS",
    "headType": "field",
    "relation": "haveType",
    "tail": "Annotation",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationsScanner",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.AnnotationsScanner#NO_METHODS",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationsScanner#NO_METHODS",
    "headType": "field",
    "relation": "haveType",
    "tail": "Method",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationsScanner",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.AnnotationsScanner#declaredAnnotationCache",
    "tailType": "field"
  }
]