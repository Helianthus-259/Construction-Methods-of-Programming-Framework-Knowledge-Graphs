[
  {
    "head": "org.springframework.core.convert.GenericClass#getListProperty()",
    "headType": "method",
    "relation": "provide",
    "tail": "@MethodAnnotation1\r\npublic List<T> getListProperty() {\r\n    return null;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.convert.GenericClass",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.convert.GenericClass#getListProperty()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.convert.GenericClass#getListProperty()",
    "headType": "method",
    "relation": "use",
    "tail": "@MethodAnnotation1",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.convert.GenericClass#setListProperty(List<T>)",
    "headType": "method",
    "relation": "provide",
    "tail": "public void setListProperty(List<T> t) ;",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.convert.GenericClass",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.convert.GenericClass#setListProperty(List<T>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.convert",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.convert.IntegerClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.convert.IntegerClass",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.convert;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.MethodParameter;\nimport org.springframework.core.ResolvableType;\nimport org.springframework.util.LinkedMultiValueMap;\nimport org.springframework.util.MultiValueMap;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n\n/**\n * Tests for {@link TypeDescriptor}.\n *\n * @author Keith Donald\n * @author Andy Clement\n * @author Phillip Webb\n * @author Sam Brannen\n * @author Nathan Piper\n */\n@SuppressWarnings(\"rawtypes\")\nclass TypeDescriptorTests {\n\n\t@Test\n\tvoid parameterPrimitive() throws Exception {\n\t\tTypeDescriptor desc = new TypeDescriptor(new MethodParameter(getClass().getMethod(\"testParameterPrimitive\", int.class), 0));\n\t\tassertThat(desc.getType()).isEqualTo(int.class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getName()).isEqualTo(\"int\");\n\t\tassertThat(desc.toString()).isEqualTo(\"int\");\n\t\tassertThat(desc.isPrimitive()).isTrue();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isFalse();\n\t\tassertThat(desc.isMap()).isFalse();\n\t}\n\n\t@Test\n\tvoid parameterScalar() throws Exception {\n\t\tTypeDescriptor desc = new TypeDescriptor(new MethodParameter(getClass().getMethod(\"testParameterScalar\", String.class), 0));\n\t\tassertThat(desc.getType()).isEqualTo(String.class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(String.class);\n\t\tassertThat(desc.getName()).isEqualTo(\"java.lang.String\");\n\t\tassertThat(desc.toString()).isEqualTo(\"java.lang.String\");\n\t\tassertThat(desc.isPrimitive()).isFalse();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isFalse();\n\t\tassertThat(desc.isArray()).isFalse();\n\t\tassertThat(desc.isMap()).isFalse();\n\t}\n\n\t@Test\n\tvoid parameterList() throws Exception {\n\t\tMethodParameter methodParameter = new MethodParameter(getClass().getMethod(\"testParameterList\", List.class), 0);\n\t\tTypeDescriptor desc = new TypeDescriptor(methodParameter);\n\t\tassertThat(desc.getType()).isEqualTo(List.class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(List.class);\n\t\tassertThat(desc.getName()).isEqualTo(\"java.util.List\");\n\t\tassertThat(desc.toString()).isEqualTo(\"java.util.List<java.util.List<java.util.Map<java.lang.Integer, java.lang.Enum<?>>>>\");\n\t\tassertThat(desc.isPrimitive()).isFalse();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isTrue();\n\t\tassertThat(desc.isArray()).isFalse();\n\t\tassertThat(desc.getElementTypeDescriptor().getType()).isEqualTo(List.class);\n\t\tassertThat(desc.getElementTypeDescriptor()).isEqualTo(TypeDescriptor.nested(methodParameter, 1));\n\t\tassertThat(desc.getElementTypeDescriptor().getElementTypeDescriptor()).isEqualTo(TypeDescriptor.nested(methodParameter, 2));\n\t\tassertThat(desc.getElementTypeDescriptor().getElementTypeDescriptor().getMapValueTypeDescriptor()).isEqualTo(TypeDescriptor.nested(methodParameter, 3));\n\t\tassertThat(desc.getElementTypeDescriptor().getElementTypeDescriptor().getMapKeyTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getElementTypeDescriptor().getElementTypeDescriptor().getMapValueTypeDescriptor().getType()).isEqualTo(Enum.class);\n\t\tassertThat(desc.isMap()).isFalse();\n\t}\n\n\t@Test\n\tvoid parameterListNoParamTypes() throws Exception {\n\t\tMethodParameter methodParameter = new MethodParameter(getClass().getMethod(\"testParameterListNoParamTypes\", List.class), 0);\n\t\tTypeDescriptor desc = new TypeDescriptor(methodParameter);\n\t\tassertThat(desc.getType()).isEqualTo(List.class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(List.class);\n\t\tassertThat(desc.getName()).isEqualTo(\"java.util.List\");\n\t\tassertThat(desc.toString()).isEqualTo(\"java.util.List<?>\");\n\t\tassertThat(desc.isPrimitive()).isFalse();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isTrue();\n\t\tassertThat(desc.isArray()).isFalse();\n\t\tassertThat((Object) desc.getElementTypeDescriptor()).isNull();\n\t\tassertThat(desc.isMap()).isFalse();\n\t}\n\n\t@Test\n\tvoid parameterArray() throws Exception {\n\t\tMethodParameter methodParameter = new MethodParameter(getClass().getMethod(\"testParameterArray\", Integer[].class), 0);\n\t\tTypeDescriptor desc = new TypeDescriptor(methodParameter);\n\t\tassertThat(desc.getType()).isEqualTo(Integer[].class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(Integer[].class);\n\t\tassertThat(desc.getName()).isEqualTo(\"java.lang.Integer[]\");\n\t\tassertThat(desc.toString()).isEqualTo(\"java.lang.Integer[]\");\n\t\tassertThat(desc.isPrimitive()).isFalse();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isFalse();\n\t\tassertThat(desc.isArray()).isTrue();\n\t\tassertThat(desc.getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getElementTypeDescriptor()).isEqualTo(TypeDescriptor.valueOf(Integer.class));\n\t\tassertThat(desc.isMap()).isFalse();\n\t}\n\n\t@Test\n\tvoid parameterMap() throws Exception {\n\t\tMethodParameter methodParameter = new MethodParameter(getClass().getMethod(\"testParameterMap\", Map.class), 0);\n\t\tTypeDescriptor desc = new TypeDescriptor(methodParameter);\n\t\tassertThat(desc.getType()).isEqualTo(Map.class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(Map.class);\n\t\tassertThat(desc.getName()).isEqualTo(\"java.util.Map\");\n\t\tassertThat(desc.toString()).isEqualTo(\"java.util.Map<java.lang.Integer, java.util.List<java.lang.String>>\");\n\t\tassertThat(desc.isPrimitive()).isFalse();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isFalse();\n\t\tassertThat(desc.isArray()).isFalse();\n\t\tassertThat(desc.isMap()).isTrue();\n\t\tassertThat(desc.getMapValueTypeDescriptor()).isEqualTo(TypeDescriptor.nested(methodParameter, 1));\n\t\tassertThat(desc.getMapValueTypeDescriptor().getElementTypeDescriptor()).isEqualTo(TypeDescriptor.nested(methodParameter, 2));\n\t\tassertThat(desc.getMapKeyTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getMapValueTypeDescriptor().getType()).isEqualTo(List.class);\n\t\tassertThat(desc.getMapValueTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid parameterAnnotated() throws Exception {\n\t\tTypeDescriptor t1 = new TypeDescriptor(new MethodParameter(getClass().getMethod(\"testAnnotatedMethod\", String.class), 0));\n\t\tassertThat(t1.getType()).isEqualTo(String.class);\n\t\tassertThat(t1.getAnnotations()).hasSize(1);\n\t\tassertThat(t1.getAnnotation(ParameterAnnotation.class)).isNotNull();\n\t\tassertThat(t1.hasAnnotation(ParameterAnnotation.class)).isTrue();\n\t\tassertThat(t1.getAnnotation(ParameterAnnotation.class).value()).isEqualTo(123);\n\t}\n\n\t@Test\n\tvoid getAnnotationsReturnsClonedArray() throws Exception {\n\t\tTypeDescriptor t = new TypeDescriptor(new MethodParameter(getClass().getMethod(\"testAnnotatedMethod\", String.class), 0));\n\t\tt.getAnnotations()[0] = null;\n\t\tassertThat(t.getAnnotations()[0]).isNotNull();\n\t}\n\n\t@Test\n\tvoid propertyComplex() throws Exception {\n\t\tProperty property = new Property(getClass(), getClass().getMethod(\"getComplexProperty\"),\n\t\t\t\tgetClass().getMethod(\"setComplexProperty\", Map.class));\n\t\tTypeDescriptor desc = new TypeDescriptor(property);\n\t\tassertThat(desc.getMapKeyTypeDescriptor().getType()).isEqualTo(String.class);\n\t\tassertThat(desc.getMapValueTypeDescriptor().getElementTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid propertyGenericType() throws Exception {\n\t\tGenericType<Integer> genericBean = new IntegerType();\n\t\tProperty property = new Property(getClass(), genericBean.getClass().getMethod(\"getProperty\"),\n\t\t\t\tgenericBean.getClass().getMethod(\"setProperty\", Integer.class));\n\t\tTypeDescriptor desc = new TypeDescriptor(property);\n\t\tassertThat(desc.getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid propertyTypeCovariance() throws Exception {\n\t\tGenericType<Number> genericBean = new NumberType();\n\t\tProperty property = new Property(getClass(), genericBean.getClass().getMethod(\"getProperty\"),\n\t\t\t\tgenericBean.getClass().getMethod(\"setProperty\", Number.class));\n\t\tTypeDescriptor desc = new TypeDescriptor(property);\n\t\tassertThat(desc.getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid propertyGenericTypeList() throws Exception {\n\t\tGenericType<Integer> genericBean = new IntegerType();\n\t\tProperty property = new Property(getClass(), genericBean.getClass().getMethod(\"getListProperty\"),\n\t\t\t\tgenericBean.getClass().getMethod(\"setListProperty\", List.class));\n\t\tTypeDescriptor desc = new TypeDescriptor(property);\n\t\tassertThat(desc.getType()).isEqualTo(List.class);\n\t\tassertThat(desc.getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid propertyGenericClassList() throws Exception {\n\t\tIntegerClass genericBean = new IntegerClass();\n\t\tProperty property = new Property(genericBean.getClass(), genericBean.getClass().getMethod(\"getListProperty\"),\n\t\t\t\tgenericBean.getClass().getMethod(\"setListProperty\", List.class));\n\t\tTypeDescriptor desc = new TypeDescriptor(property);\n\t\tassertThat(desc.getType()).isEqualTo(List.class);\n\t\tassertThat(desc.getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getAnnotation(MethodAnnotation1.class)).isNotNull();\n\t\tassertThat(desc.hasAnnotation(MethodAnnotation1.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid property() throws Exception {\n\t\tProperty property = new Property(\n\t\t\t\tgetClass(), getClass().getMethod(\"getProperty\"), getClass().getMethod(\"setProperty\", Map.class));\n\t\tTypeDescriptor desc = new TypeDescriptor(property);\n\t\tassertThat(desc.getType()).isEqualTo(Map.class);\n\t\tassertThat(desc.getMapKeyTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getMapValueTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Long.class);\n\t\tassertThat(desc.getAnnotation(MethodAnnotation1.class)).isNotNull();\n\t\tassertThat(desc.getAnnotation(MethodAnnotation2.class)).isNotNull();\n\t\tassertThat(desc.getAnnotation(MethodAnnotation3.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid getAnnotationOnMethodThatIsLocallyAnnotated() throws Exception {\n\t\tassertAnnotationFoundOnMethod(MethodAnnotation1.class, \"methodWithLocalAnnotation\");\n\t}\n\n\t@Test\n\tvoid getAnnotationOnMethodThatIsMetaAnnotated() throws Exception {\n\t\tassertAnnotationFoundOnMethod(MethodAnnotation1.class, \"methodWithComposedAnnotation\");\n\t}\n\n\t@Test\n\tvoid getAnnotationOnMethodThatIsMetaMetaAnnotated() throws Exception {\n\t\tassertAnnotationFoundOnMethod(MethodAnnotation1.class, \"methodWithComposedComposedAnnotation\");\n\t}\n\n\tprivate void assertAnnotationFoundOnMethod(Class<? extends Annotation> annotationType, String methodName) throws Exception {\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(new MethodParameter(getClass().getMethod(methodName), -1));\n\t\tassertThat(typeDescriptor.getAnnotation(annotationType)).as(\"Should have found @\" + annotationType.getSimpleName() + \" on \" + methodName + \".\").isNotNull();\n\t}\n\n\t@Test\n\tvoid fieldScalar() throws Exception {\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(getClass().getField(\"fieldScalar\"));\n\t\tassertThat(typeDescriptor.isPrimitive()).isFalse();\n\t\tassertThat(typeDescriptor.isArray()).isFalse();\n\t\tassertThat(typeDescriptor.isCollection()).isFalse();\n\t\tassertThat(typeDescriptor.isMap()).isFalse();\n\t\tassertThat(typeDescriptor.getType()).isEqualTo(Integer.class);\n\t\tassertThat(typeDescriptor.getObjectType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid fieldList() throws Exception {\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(TypeDescriptorTests.class.getDeclaredField(\"listOfString\"));\n\t\tassertThat(typeDescriptor.isArray()).isFalse();\n\t\tassertThat(typeDescriptor.getType()).isEqualTo(List.class);\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor().getType()).isEqualTo(String.class);\n\t\tassertThat(typeDescriptor.toString()).isEqualTo(\"java.util.List<java.lang.String>\");\n\t}\n\n\t@Test\n\tvoid fieldListOfListOfString() throws Exception {\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(TypeDescriptorTests.class.getDeclaredField(\"listOfListOfString\"));\n\t\tassertThat(typeDescriptor.isArray()).isFalse();\n\t\tassertThat(typeDescriptor.getType()).isEqualTo(List.class);\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor().getType()).isEqualTo(List.class);\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(String.class);\n\t\tassertThat(typeDescriptor.toString()).isEqualTo(\"java.util.List<java.util.List<java.lang.String>>\");\n\t}\n\n\t@Test\n\tvoid fieldListOfListUnknown() throws Exception {\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(TypeDescriptorTests.class.getDeclaredField(\"listOfListOfUnknown\"));\n\t\tassertThat(typeDescriptor.isArray()).isFalse();\n\t\tassertThat(typeDescriptor.getType()).isEqualTo(List.class);\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor().getType()).isEqualTo(List.class);\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor().getElementTypeDescriptor()).isNull();\n\t\tassertThat(typeDescriptor.toString()).isEqualTo(\"java.util.List<java.util.List<?>>\");\n\t}\n\n\t@Test\n\tvoid fieldArray() throws Exception {\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(TypeDescriptorTests.class.getDeclaredField(\"intArray\"));\n\t\tassertThat(typeDescriptor.isArray()).isTrue();\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor().getType()).isEqualTo(int.class);\n\t\tassertThat(typeDescriptor.toString()).isEqualTo(\"int[]\");\n\t}\n\n\t@Test\n\tvoid fieldComplexTypeDescriptor() throws Exception {\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(TypeDescriptorTests.class.getDeclaredField(\"arrayOfListOfString\"));\n\t\tassertThat(typeDescriptor.isArray()).isTrue();\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor().getType()).isEqualTo(List.class);\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(String.class);\n\t\tassertThat(typeDescriptor.toString()).isEqualTo(\"java.util.List<java.lang.String>[]\");\n\t}\n\n\t@Test\n\tvoid fieldComplexTypeDescriptor2() throws Exception {\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(TypeDescriptorTests.class.getDeclaredField(\"nestedMapField\"));\n\t\tassertThat(typeDescriptor.isMap()).isTrue();\n\t\tassertThat(typeDescriptor.getMapKeyTypeDescriptor().getType()).isEqualTo(String.class);\n\t\tassertThat(typeDescriptor.getMapValueTypeDescriptor().getType()).isEqualTo(List.class);\n\t\tassertThat(typeDescriptor.getMapValueTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(typeDescriptor.toString()).isEqualTo(\"java.util.Map<java.lang.String, java.util.List<java.lang.Integer>>\");\n\t}\n\n\t@Test\n\tvoid fieldMap() throws Exception {\n\t\tTypeDescriptor desc = new TypeDescriptor(TypeDescriptorTests.class.getField(\"fieldMap\"));\n\t\tassertThat(desc.isMap()).isTrue();\n\t\tassertThat(desc.getMapKeyTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getMapValueTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Long.class);\n\t}\n\n\t@Test\n\tvoid fieldAnnotated() throws Exception {\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(getClass().getField(\"fieldAnnotated\"));\n\t\tassertThat(typeDescriptor.getAnnotations()).hasSize(1);\n\t\tassertThat(typeDescriptor.getAnnotation(FieldAnnotation.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid valueOfScalar() {\n\t\tTypeDescriptor typeDescriptor = TypeDescriptor.valueOf(Integer.class);\n\t\tassertThat(typeDescriptor.isPrimitive()).isFalse();\n\t\tassertThat(typeDescriptor.isArray()).isFalse();\n\t\tassertThat(typeDescriptor.isCollection()).isFalse();\n\t\tassertThat(typeDescriptor.isMap()).isFalse();\n\t\tassertThat(typeDescriptor.getType()).isEqualTo(Integer.class);\n\t\tassertThat(typeDescriptor.getObjectType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid valueOfPrimitive() {\n\t\tTypeDescriptor typeDescriptor = TypeDescriptor.valueOf(int.class);\n\t\tassertThat(typeDescriptor.isPrimitive()).isTrue();\n\t\tassertThat(typeDescriptor.isArray()).isFalse();\n\t\tassertThat(typeDescriptor.isCollection()).isFalse();\n\t\tassertThat(typeDescriptor.isMap()).isFalse();\n\t\tassertThat(typeDescriptor.getType()).isEqualTo(int.class);\n\t\tassertThat(typeDescriptor.getObjectType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid valueOfArray() {\n\t\tTypeDescriptor typeDescriptor = TypeDescriptor.valueOf(int[].class);\n\t\tassertThat(typeDescriptor.isArray()).isTrue();\n\t\tassertThat(typeDescriptor.isCollection()).isFalse();\n\t\tassertThat(typeDescriptor.isMap()).isFalse();\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor().getType()).isEqualTo(int.class);\n\t}\n\n\t@Test\n\tvoid valueOfCollection() {\n\t\tTypeDescriptor typeDescriptor = TypeDescriptor.valueOf(Collection.class);\n\t\tassertThat(typeDescriptor.isCollection()).isTrue();\n\t\tassertThat(typeDescriptor.isArray()).isFalse();\n\t\tassertThat(typeDescriptor.isMap()).isFalse();\n\t\tassertThat((Object) typeDescriptor.getElementTypeDescriptor()).isNull();\n\t}\n\n\t@Test\n\tvoid forObject() {\n\t\tTypeDescriptor desc = TypeDescriptor.forObject(\"3\");\n\t\tassertThat(desc.getType()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid forObjectNullTypeDescriptor() {\n\t\tTypeDescriptor desc = TypeDescriptor.forObject(null);\n\t\tassertThat((Object) desc).isNull();\n\t}\n\n\t@Test\n\tvoid nestedMethodParameterType2Levels() throws Exception {\n\t\tTypeDescriptor t1 = TypeDescriptor.nested(new MethodParameter(getClass().getMethod(\"test2\", List.class), 0), 2);\n\t\tassertThat(t1.getType()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid nestedMethodParameterTypeMap() throws Exception {\n\t\tTypeDescriptor t1 = TypeDescriptor.nested(new MethodParameter(getClass().getMethod(\"test3\", Map.class), 0), 1);\n\t\tassertThat(t1.getType()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid nestedMethodParameterTypeMapTwoLevels() throws Exception {\n\t\tTypeDescriptor t1 = TypeDescriptor.nested(new MethodParameter(getClass().getMethod(\"test4\", List.class), 0), 2);\n\t\tassertThat(t1.getType()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid nestedMethodParameterNot1NestedLevel() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tTypeDescriptor.nested(new MethodParameter(getClass().getMethod(\"test4\", List.class), 0, 2), 2));\n\t}\n\n\t@Test\n\tvoid nestedTooManyLevels() throws Exception {\n\t\tTypeDescriptor t1 = TypeDescriptor.nested(new MethodParameter(getClass().getMethod(\"test4\", List.class), 0), 3);\n\t\tassertThat((Object) t1).isNull();\n\t}\n\n\t@Test\n\tvoid nestedMethodParameterTypeNotNestable() throws Exception {\n\t\tTypeDescriptor t1 = TypeDescriptor.nested(new MethodParameter(getClass().getMethod(\"test5\", String.class), 0), 2);\n\t\tassertThat((Object) t1).isNull();\n\t}\n\n\t@Test\n\tvoid nestedMethodParameterTypeInvalidNestingLevel() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tTypeDescriptor.nested(new MethodParameter(getClass().getMethod(\"test5\", String.class), 0, 2), 2));\n\t}\n\n\t@Test\n\tvoid nestedNotParameterized() throws Exception {\n\t\tTypeDescriptor t1 = TypeDescriptor.nested(new MethodParameter(getClass().getMethod(\"test6\", List.class), 0), 1);\n\t\tassertThat(t1.getType()).isEqualTo(List.class);\n\t\tassertThat(t1.toString()).isEqualTo(\"java.util.List<?>\");\n\t\tTypeDescriptor t2 = TypeDescriptor.nested(new MethodParameter(getClass().getMethod(\"test6\", List.class), 0), 2);\n\t\tassertThat((Object) t2).isNull();\n\t}\n\n\t@Test\n\tvoid nestedFieldTypeMapTwoLevels() throws Exception {\n\t\tTypeDescriptor t1 = TypeDescriptor.nested(getClass().getField(\"test4\"), 2);\n\t\tassertThat(t1.getType()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid nestedPropertyTypeMapTwoLevels() throws Exception {\n\t\tProperty property = new Property(getClass(), getClass().getMethod(\"getTest4\"), getClass().getMethod(\"setTest4\", List.class));\n\t\tTypeDescriptor t1 = TypeDescriptor.nested(property, 2);\n\t\tassertThat(t1.getType()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid collection() {\n\t\tTypeDescriptor desc = TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(Integer.class));\n\t\tassertThat(desc.getType()).isEqualTo(List.class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(List.class);\n\t\tassertThat(desc.getName()).isEqualTo(\"java.util.List\");\n\t\tassertThat(desc.toString()).isEqualTo(\"java.util.List<java.lang.Integer>\");\n\t\tassertThat(desc.isPrimitive()).isFalse();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isTrue();\n\t\tassertThat(desc.isArray()).isFalse();\n\t\tassertThat(desc.getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getElementTypeDescriptor()).isEqualTo(TypeDescriptor.valueOf(Integer.class));\n\t\tassertThat(desc.isMap()).isFalse();\n\t}\n\n\t@Test\n\tvoid collectionNested() {\n\t\tTypeDescriptor desc = TypeDescriptor.collection(List.class, TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(Integer.class)));\n\t\tassertThat(desc.getType()).isEqualTo(List.class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(List.class);\n\t\tassertThat(desc.getName()).isEqualTo(\"java.util.List\");\n\t\tassertThat(desc.toString()).isEqualTo(\"java.util.List<java.util.List<java.lang.Integer>>\");\n\t\tassertThat(desc.isPrimitive()).isFalse();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isTrue();\n\t\tassertThat(desc.isArray()).isFalse();\n\t\tassertThat(desc.getElementTypeDescriptor().getType()).isEqualTo(List.class);\n\t\tassertThat(desc.getElementTypeDescriptor().getElementTypeDescriptor()).isEqualTo(TypeDescriptor.valueOf(Integer.class));\n\t\tassertThat(desc.isMap()).isFalse();\n\t}\n\n\t@Test\n\tvoid map() {\n\t\tTypeDescriptor desc = TypeDescriptor.map(Map.class, TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(Integer.class));\n\t\tassertThat(desc.getType()).isEqualTo(Map.class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(Map.class);\n\t\tassertThat(desc.getName()).isEqualTo(\"java.util.Map\");\n\t\tassertThat(desc.toString()).isEqualTo(\"java.util.Map<java.lang.String, java.lang.Integer>\");\n\t\tassertThat(desc.isPrimitive()).isFalse();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isFalse();\n\t\tassertThat(desc.isArray()).isFalse();\n\t\tassertThat(desc.isMap()).isTrue();\n\t\tassertThat(desc.getMapKeyTypeDescriptor().getType()).isEqualTo(String.class);\n\t\tassertThat(desc.getMapValueTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid mapNested() {\n\t\tTypeDescriptor desc = TypeDescriptor.map(Map.class, TypeDescriptor.valueOf(String.class),\n\t\t\t\tTypeDescriptor.map(Map.class, TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(Integer.class)));\n\t\tassertThat(desc.getType()).isEqualTo(Map.class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(Map.class);\n\t\tassertThat(desc.getName()).isEqualTo(\"java.util.Map\");\n\t\tassertThat(desc.toString()).isEqualTo(\"java.util.Map<java.lang.String, java.util.Map<java.lang.String, java.lang.Integer>>\");\n\t\tassertThat(desc.isPrimitive()).isFalse();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isFalse();\n\t\tassertThat(desc.isArray()).isFalse();\n\t\tassertThat(desc.isMap()).isTrue();\n\t\tassertThat(desc.getMapKeyTypeDescriptor().getType()).isEqualTo(String.class);\n\t\tassertThat(desc.getMapValueTypeDescriptor().getMapKeyTypeDescriptor().getType()).isEqualTo(String.class);\n\t\tassertThat(desc.getMapValueTypeDescriptor().getMapValueTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid narrow() {\n\t\tTypeDescriptor desc = TypeDescriptor.valueOf(Number.class);\n\t\tInteger value = 3;\n\t\tdesc = desc.narrow(value);\n\t\tassertThat(desc.getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid elementType() {\n\t\tTypeDescriptor desc = TypeDescriptor.valueOf(List.class);\n\t\tInteger value = 3;\n\t\tdesc = desc.elementTypeDescriptor(value);\n\t\tassertThat(desc.getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid elementTypePreserveContext() throws Exception {\n\t\tTypeDescriptor desc = new TypeDescriptor(getClass().getField(\"listPreserveContext\"));\n\t\tassertThat(desc.getElementTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tList<Integer> value = new ArrayList<>(3);\n\t\tdesc = desc.elementTypeDescriptor(value);\n\t\tassertThat(desc.getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getAnnotation(FieldAnnotation.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid mapKeyType() {\n\t\tTypeDescriptor desc = TypeDescriptor.valueOf(Map.class);\n\t\tInteger value = 3;\n\t\tdesc = desc.getMapKeyTypeDescriptor(value);\n\t\tassertThat(desc.getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid mapKeyTypePreserveContext() throws Exception {\n\t\tTypeDescriptor desc = new TypeDescriptor(getClass().getField(\"mapPreserveContext\"));\n\t\tassertThat(desc.getMapKeyTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tList<Integer> value = new ArrayList<>(3);\n\t\tdesc = desc.getMapKeyTypeDescriptor(value);\n\t\tassertThat(desc.getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getAnnotation(FieldAnnotation.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid mapValueType() {\n\t\tTypeDescriptor desc = TypeDescriptor.valueOf(Map.class);\n\t\tInteger value = 3;\n\t\tdesc = desc.getMapValueTypeDescriptor(value);\n\t\tassertThat(desc.getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid mapValueTypePreserveContext() throws Exception {\n\t\tTypeDescriptor desc = new TypeDescriptor(getClass().getField(\"mapPreserveContext\"));\n\t\tassertThat(desc.getMapValueTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tList<Integer> value = new ArrayList<>(3);\n\t\tdesc = desc.getMapValueTypeDescriptor(value);\n\t\tassertThat(desc.getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getAnnotation(FieldAnnotation.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid equality() throws Exception {\n\t\tTypeDescriptor t1 = TypeDescriptor.valueOf(String.class);\n\t\tTypeDescriptor t2 = TypeDescriptor.valueOf(String.class);\n\t\tTypeDescriptor t3 = TypeDescriptor.valueOf(Date.class);\n\t\tTypeDescriptor t4 = TypeDescriptor.valueOf(Date.class);\n\t\tTypeDescriptor t5 = TypeDescriptor.valueOf(List.class);\n\t\tTypeDescriptor t6 = TypeDescriptor.valueOf(List.class);\n\t\tTypeDescriptor t7 = TypeDescriptor.valueOf(Map.class);\n\t\tTypeDescriptor t8 = TypeDescriptor.valueOf(Map.class);\n\t\tassertThat(t2).isEqualTo(t1);\n\t\tassertThat(t4).isEqualTo(t3);\n\t\tassertThat(t6).isEqualTo(t5);\n\t\tassertThat(t8).isEqualTo(t7);\n\n\t\tTypeDescriptor t9 = new TypeDescriptor(getClass().getField(\"listField\"));\n\t\tTypeDescriptor t10 = new TypeDescriptor(getClass().getField(\"listField\"));\n\t\tassertThat(t10).isEqualTo(t9);\n\n\t\tTypeDescriptor t11 = new TypeDescriptor(getClass().getField(\"mapField\"));\n\t\tTypeDescriptor t12 = new TypeDescriptor(getClass().getField(\"mapField\"));\n\t\tassertThat(t12).isEqualTo(t11);\n\n\t\tMethodParameter testAnnotatedMethod = new MethodParameter(getClass().getMethod(\"testAnnotatedMethod\", String.class), 0);\n\t\tTypeDescriptor t13 = new TypeDescriptor(testAnnotatedMethod);\n\t\tTypeDescriptor t14 = new TypeDescriptor(testAnnotatedMethod);\n\t\tassertThat(t14).isEqualTo(t13);\n\n\t\tTypeDescriptor t15 = new TypeDescriptor(testAnnotatedMethod);\n\t\tTypeDescriptor t16 = new TypeDescriptor(new MethodParameter(getClass().getMethod(\"testAnnotatedMethodDifferentAnnotationValue\", String.class), 0));\n\t\tassertThat(t16).isNotEqualTo(t15);\n\n\t\tTypeDescriptor t17 = new TypeDescriptor(testAnnotatedMethod);\n\t\tTypeDescriptor t18 = new TypeDescriptor(new MethodParameter(getClass().getMethod(\"test5\", String.class), 0));\n\t\tassertThat(t18).isNotEqualTo(t17);\n\t}\n\n\t@Test\n\tvoid isAssignableTypes() {\n\t\tassertThat(TypeDescriptor.valueOf(Integer.class).isAssignableTo(TypeDescriptor.valueOf(Number.class))).isTrue();\n\t\tassertThat(TypeDescriptor.valueOf(Number.class).isAssignableTo(TypeDescriptor.valueOf(Integer.class))).isFalse();\n\t\tassertThat(TypeDescriptor.valueOf(String.class).isAssignableTo(TypeDescriptor.valueOf(String[].class))).isFalse();\n\t}\n\n\t@Test\n\tvoid isAssignableElementTypes() throws Exception {\n\t\tassertThat(new TypeDescriptor(getClass().getField(\"listField\")).isAssignableTo(new TypeDescriptor(getClass().getField(\"listField\")))).isTrue();\n\t\tassertThat(new TypeDescriptor(getClass().getField(\"notGenericList\")).isAssignableTo(new TypeDescriptor(getClass().getField(\"listField\")))).isTrue();\n\t\tassertThat(new TypeDescriptor(getClass().getField(\"listField\")).isAssignableTo(new TypeDescriptor(getClass().getField(\"notGenericList\")))).isTrue();\n\t\tassertThat(new TypeDescriptor(getClass().getField(\"isAssignableElementTypes\")).isAssignableTo(new TypeDescriptor(getClass().getField(\"listField\")))).isFalse();\n\t\tassertThat(TypeDescriptor.valueOf(List.class).isAssignableTo(new TypeDescriptor(getClass().getField(\"listField\")))).isTrue();\n\t}\n\n\t@Test\n\tvoid isAssignableMapKeyValueTypes() throws Exception {\n\t\tassertThat(new TypeDescriptor(getClass().getField(\"mapField\")).isAssignableTo(new TypeDescriptor(getClass().getField(\"mapField\")))).isTrue();\n\t\tassertThat(new TypeDescriptor(getClass().getField(\"notGenericMap\")).isAssignableTo(new TypeDescriptor(getClass().getField(\"mapField\")))).isTrue();\n\t\tassertThat(new TypeDescriptor(getClass().getField(\"mapField\")).isAssignableTo(new TypeDescriptor(getClass().getField(\"notGenericMap\")))).isTrue();\n\t\tassertThat(new TypeDescriptor(getClass().getField(\"isAssignableMapKeyValueTypes\")).isAssignableTo(new TypeDescriptor(getClass().getField(\"mapField\")))).isFalse();\n\t\tassertThat(TypeDescriptor.valueOf(Map.class).isAssignableTo(new TypeDescriptor(getClass().getField(\"mapField\")))).isTrue();\n\t}\n\n\t@Test\n\tvoid multiValueMap() throws Exception {\n\t\tTypeDescriptor td = new TypeDescriptor(getClass().getField(\"multiValueMap\"));\n\t\tassertThat(td.isMap()).isTrue();\n\t\tassertThat(td.getMapKeyTypeDescriptor().getType()).isEqualTo(String.class);\n\t\tassertThat(td.getMapValueTypeDescriptor().getType()).isEqualTo(List.class);\n\t\tassertThat(td.getMapValueTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid passDownGeneric() throws Exception {\n\t\tTypeDescriptor td = new TypeDescriptor(getClass().getField(\"passDownGeneric\"));\n\t\tassertThat(td.getElementTypeDescriptor().getType()).isEqualTo(List.class);\n\t\tassertThat(td.getElementTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Set.class);\n\t\tassertThat(td.getElementTypeDescriptor().getElementTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid upcast() throws Exception {\n\t\tProperty property = new Property(getClass(), getClass().getMethod(\"getProperty\"),\n\t\t\t\tgetClass().getMethod(\"setProperty\", Map.class));\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(property);\n\t\tTypeDescriptor upcast = typeDescriptor.upcast(Object.class);\n\t\tassertThat(upcast.getAnnotation(MethodAnnotation1.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid upCastNotSuper() throws Exception {\n\t\tProperty property = new Property(getClass(), getClass().getMethod(\"getProperty\"),\n\t\t\t\tgetClass().getMethod(\"setProperty\", Map.class));\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(property);\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\ttypeDescriptor.upcast(Collection.class))\n\t\t\t.withMessage(\"interface java.util.Map is not assignable to interface java.util.Collection\");\n\t}\n\n\t@Test\n\tvoid elementTypeForCollectionSubclass() {\n\t\t@SuppressWarnings(\"serial\")\n\t\tclass CustomSet extends HashSet<String> {\n\t\t}\n\n\t\tassertThat(TypeDescriptor.valueOf(String.class)).isEqualTo(TypeDescriptor.valueOf(CustomSet.class).getElementTypeDescriptor());\n\t\tassertThat(TypeDescriptor.valueOf(String.class)).isEqualTo(TypeDescriptor.forObject(new CustomSet()).getElementTypeDescriptor());\n\t}\n\n\t@Test\n\tvoid elementTypeForMapSubclass() {\n\t\t@SuppressWarnings(\"serial\")\n\t\tclass CustomMap extends HashMap<String, Integer> {\n\t\t}\n\n\t\tassertThat(TypeDescriptor.valueOf(String.class)).isEqualTo(TypeDescriptor.valueOf(CustomMap.class).getMapKeyTypeDescriptor());\n\t\tassertThat(TypeDescriptor.valueOf(Integer.class)).isEqualTo(TypeDescriptor.valueOf(CustomMap.class).getMapValueTypeDescriptor());\n\t\tassertThat(TypeDescriptor.valueOf(String.class)).isEqualTo(TypeDescriptor.forObject(new CustomMap()).getMapKeyTypeDescriptor());\n\t\tassertThat(TypeDescriptor.valueOf(Integer.class)).isEqualTo(TypeDescriptor.forObject(new CustomMap()).getMapValueTypeDescriptor());\n\t}\n\n\t@Test\n\tvoid createMapArray() {\n\t\tTypeDescriptor mapType = TypeDescriptor.map(\n\t\t\t\tLinkedHashMap.class, TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(Integer.class));\n\t\tTypeDescriptor arrayType = TypeDescriptor.array(mapType);\n\t\tassertThat(LinkedHashMap[].class).isEqualTo(arrayType.getType());\n\t\tassertThat(mapType).isEqualTo(arrayType.getElementTypeDescriptor());\n\t}\n\n\t@Test\n\tvoid createStringArray() {\n\t\tTypeDescriptor arrayType = TypeDescriptor.array(TypeDescriptor.valueOf(String.class));\n\t\tassertThat(TypeDescriptor.valueOf(String[].class)).isEqualTo(arrayType);\n\t}\n\n\t@Test\n\tvoid createNullArray() {\n\t\tassertThat((Object) TypeDescriptor.array(null)).isNull();\n\t}\n\n\t@Test\n\tvoid serializable() throws Exception {\n\t\tTypeDescriptor typeDescriptor = TypeDescriptor.forObject(\"\");\n\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\tObjectOutputStream outputStream = new ObjectOutputStream(out);\n\t\toutputStream.writeObject(typeDescriptor);\n\t\tObjectInputStream inputStream = new ObjectInputStream(new ByteArrayInputStream(\n\t\t\t\tout.toByteArray()));\n\t\tTypeDescriptor readObject = (TypeDescriptor) inputStream.readObject();\n\t\tassertThat(readObject).isEqualTo(typeDescriptor);\n\t}\n\n\t@Test\n\tvoid createCollectionWithNullElement() {\n\t\tTypeDescriptor typeDescriptor = TypeDescriptor.collection(List.class, null);\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor()).isNull();\n\t}\n\n\t@Test\n\tvoid createMapWithNullElements() {\n\t\tTypeDescriptor typeDescriptor = TypeDescriptor.map(LinkedHashMap.class, null, null);\n\t\tassertThat(typeDescriptor.getMapKeyTypeDescriptor()).isNull();\n\t\tassertThat(typeDescriptor.getMapValueTypeDescriptor()).isNull();\n\t}\n\n\t@Test\n\tvoid getSource() throws Exception {\n\t\tField field = getClass().getField(\"fieldScalar\");\n\t\tMethodParameter methodParameter = new MethodParameter(getClass().getMethod(\"testParameterPrimitive\", int.class), 0);\n\t\tassertThat(new TypeDescriptor(field).getSource()).isEqualTo(field);\n\t\tassertThat(new TypeDescriptor(methodParameter).getSource()).isEqualTo(methodParameter);\n\t\tassertThat(TypeDescriptor.valueOf(Integer.class).getSource()).isEqualTo(Integer.class);\n\t}\n\n\t@Test  // gh-31672\n\tvoid equalityWithGenerics() {\n\t\tResolvableType rt1 = ResolvableType.forClassWithGenerics(Optional.class, Integer.class);\n\t\tResolvableType rt2 = ResolvableType.forClassWithGenerics(Optional.class, String.class);\n\n\t\tTypeDescriptor td1 = new TypeDescriptor(rt1, null, null);\n\t\tTypeDescriptor td2 = new TypeDescriptor(rt2, null, null);\n\n\t\tassertThat(td1).isNotEqualTo(td2);\n\t}\n\n\t@Test  // gh-33932\n\tvoid recursiveType() {\n\t\tassertThat(TypeDescriptor.valueOf(RecursiveMap.class)).isEqualTo(\n\t\t\t\tTypeDescriptor.valueOf(RecursiveMap.class));\n\n\t\tTypeDescriptor typeDescriptor1 = TypeDescriptor.map(Map.class,\n\t\t\t\tTypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(RecursiveMap.class));\n\t\tTypeDescriptor typeDescriptor2 = TypeDescriptor.map(Map.class,\n\t\t\t\tTypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(RecursiveMap.class));\n\t\tassertThat(typeDescriptor1).isEqualTo(typeDescriptor2);\n\t}\n\n\t@Test  // gh-33932\n\tvoid recursiveTypeWithInterface() {\n\t\tassertThat(TypeDescriptor.valueOf(RecursiveMapWithInterface.class)).isEqualTo(\n\t\t\t\tTypeDescriptor.valueOf(RecursiveMapWithInterface.class));\n\n\t\tTypeDescriptor typeDescriptor1 = TypeDescriptor.map(Map.class,\n\t\t\t\tTypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(RecursiveMapWithInterface.class));\n\t\tTypeDescriptor typeDescriptor2 = TypeDescriptor.map(Map.class,\n\t\t\t\tTypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(RecursiveMapWithInterface.class));\n\t\tassertThat(typeDescriptor1).isEqualTo(typeDescriptor2);\n\t}\n\n\n\t// Methods designed for test introspection\n\n\tpublic void testParameterPrimitive(int primitive) {\n\t}\n\n\tpublic void testParameterScalar(String value) {\n\t}\n\n\tpublic void testParameterList(List<List<Map<Integer, Enum<?>>>> list) {\n\t}\n\n\tpublic void testParameterListNoParamTypes(List list) {\n\t}\n\n\tpublic void testParameterArray(Integer[] array) {\n\t}\n\n\tpublic void testParameterMap(Map<Integer, List<String>> map) {\n\t}\n\n\tpublic void test1(List<String> param1) {\n\t}\n\n\tpublic void test2(List<List<String>> param1) {\n\t}\n\n\tpublic void test3(Map<Integer, String> param1) {\n\t}\n\n\tpublic void test4(List<Map<Integer, String>> param1) {\n\t}\n\n\tpublic void test5(String param1) {\n\t}\n\n\tpublic void test6(List<List> param1) {\n\t}\n\n\tpublic List<Map<Integer, String>> getTest4() {\n\t\treturn null;\n\t}\n\n\tpublic void setTest4(List<Map<Integer, String>> test4) {\n\t}\n\n\tpublic Map<String, List<List<Integer>>> getComplexProperty() {\n\t\treturn null;\n\t}\n\n\t@MethodAnnotation1\n\tpublic Map<List<Integer>, List<Long>> getProperty() {\n\t\treturn property;\n\t}\n\n\t@MethodAnnotation2\n\tpublic void setProperty(Map<List<Integer>, List<Long>> property) {\n\t\tthis.property = property;\n\t}\n\n\t@MethodAnnotation1\n\tpublic void methodWithLocalAnnotation() {\n\t}\n\n\t@ComposedMethodAnnotation1\n\tpublic void methodWithComposedAnnotation() {\n\t}\n\n\t@ComposedComposedMethodAnnotation1\n\tpublic void methodWithComposedComposedAnnotation() {\n\t}\n\n\tpublic void setComplexProperty(Map<String, List<List<Integer>>> complexProperty) {\n\t}\n\n\tpublic void testAnnotatedMethod(@ParameterAnnotation(123) String parameter) {\n\t}\n\n\tpublic void testAnnotatedMethodDifferentAnnotationValue(@ParameterAnnotation(567) String parameter) {\n\t}\n\n\n\t// Fields designed for test introspection\n\n\tpublic Integer fieldScalar;\n\n\tpublic List<String> listOfString;\n\n\tpublic List<List<String>> listOfListOfString = new ArrayList<>();\n\n\tpublic List<List> listOfListOfUnknown = new ArrayList<>();\n\n\tpublic int[] intArray;\n\n\tpublic List<String>[] arrayOfListOfString;\n\n\tpublic List<Integer> listField = new ArrayList<>();\n\n\tpublic Map<String, Integer> mapField = new HashMap<>();\n\n\tpublic Map<String, List<Integer>> nestedMapField = new HashMap<>();\n\n\tpublic Map<List<Integer>, List<Long>> fieldMap;\n\n\tpublic List<Map<Integer, String>> test4;\n\n\t@FieldAnnotation\n\tpublic List<String> fieldAnnotated;\n\n\t@FieldAnnotation\n\tpublic List<List<Integer>> listPreserveContext;\n\n\t@FieldAnnotation\n\tpublic Map<List<Integer>, List<Integer>> mapPreserveContext;\n\n\t@MethodAnnotation3\n\tprivate Map<List<Integer>, List<Long>> property;\n\n\tpublic List notGenericList;\n\n\tpublic List<Number> isAssignableElementTypes;\n\n\tpublic Map notGenericMap;\n\n\tpublic Map<CharSequence, Number> isAssignableMapKeyValueTypes;\n\n\tpublic MultiValueMap<String, Integer> multiValueMap = new LinkedMultiValueMap<>();\n\n\tpublic PassDownGeneric<Integer> passDownGeneric = new PassDownGeneric<>();\n\n\n\t// Classes designed for test introspection\n\n\t@SuppressWarnings(\"serial\")\n\tpublic static class PassDownGeneric<T> extends ArrayList<List<Set<T>>> {\n\t}\n\n\n\tpublic static class GenericClass<T> {\n\n\t\tpublic T getProperty() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void setProperty(T t) {\n\t\t}\n\n\t\t@MethodAnnotation1\n\t\tpublic List<T> getListProperty() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void setListProperty(List<T> t) {\n\t\t}\n\t}\n\n\n\tpublic static class IntegerClass extends GenericClass<Integer> {\n\t}\n\n\n\tpublic interface GenericType<T> {\n\n\t\tT getProperty();\n\n\t\tvoid setProperty(T t);\n\n\t\tList<T> getListProperty();\n\n\t\tvoid setListProperty(List<T> t);\n\t}\n\n\n\tpublic class IntegerType implements GenericType<Integer> {\n\n\t\t@Override\n\t\tpublic Integer getProperty() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void setProperty(Integer t) {\n\t\t}\n\n\t\t@Override\n\t\tpublic List<Integer> getListProperty() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void setListProperty(List<Integer> t) {\n\t\t}\n\t}\n\n\n\tpublic class NumberType implements GenericType<Number> {\n\n\t\t@Override\n\t\tpublic Integer getProperty() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void setProperty(Number t) {\n\t\t}\n\n\t\t@Override\n\t\tpublic List<Number> getListProperty() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void setListProperty(List<Number> t) {\n\t\t}\n\t}\n\n\n\t@SuppressWarnings(\"serial\")\n\tstatic class RecursiveMap extends HashMap<String, RecursiveMap> {\n\t}\n\n\t@SuppressWarnings(\"serial\")\n\tstatic class RecursiveMapWithInterface extends HashMap<String, RecursiveMapWithInterface>\n\t\t\timplements Map<String, RecursiveMapWithInterface> {\n\t}\n\n\n\t// Annotations used on tested elements\n\n\t@Target({ElementType.PARAMETER})\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface ParameterAnnotation {\n\n\t\tint value();\n\t}\n\n\n\t@Target({ElementType.FIELD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface FieldAnnotation {\n\t}\n\n\n\t@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface MethodAnnotation1 {\n\t}\n\n\n\t@Target({ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface MethodAnnotation2 {\n\t}\n\n\n\t@Target({ElementType.FIELD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface MethodAnnotation3 {\n\t}\n\n\n\t@MethodAnnotation1\n\t@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface ComposedMethodAnnotation1 {\n\t}\n\n\n\t@ComposedMethodAnnotation1\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface ComposedComposedMethodAnnotation1 {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.convert.IntegerClass",
    "headType": "class",
    "relation": "extend",
    "tail": "GenericClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.convert",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.convert.GenericType",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.convert.GenericType",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.convert;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.MethodParameter;\nimport org.springframework.core.ResolvableType;\nimport org.springframework.util.LinkedMultiValueMap;\nimport org.springframework.util.MultiValueMap;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n\n/**\n * Tests for {@link TypeDescriptor}.\n *\n * @author Keith Donald\n * @author Andy Clement\n * @author Phillip Webb\n * @author Sam Brannen\n * @author Nathan Piper\n */\n@SuppressWarnings(\"rawtypes\")\nclass TypeDescriptorTests {\n\n\t@Test\n\tvoid parameterPrimitive() throws Exception {\n\t\tTypeDescriptor desc = new TypeDescriptor(new MethodParameter(getClass().getMethod(\"testParameterPrimitive\", int.class), 0));\n\t\tassertThat(desc.getType()).isEqualTo(int.class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getName()).isEqualTo(\"int\");\n\t\tassertThat(desc.toString()).isEqualTo(\"int\");\n\t\tassertThat(desc.isPrimitive()).isTrue();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isFalse();\n\t\tassertThat(desc.isMap()).isFalse();\n\t}\n\n\t@Test\n\tvoid parameterScalar() throws Exception {\n\t\tTypeDescriptor desc = new TypeDescriptor(new MethodParameter(getClass().getMethod(\"testParameterScalar\", String.class), 0));\n\t\tassertThat(desc.getType()).isEqualTo(String.class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(String.class);\n\t\tassertThat(desc.getName()).isEqualTo(\"java.lang.String\");\n\t\tassertThat(desc.toString()).isEqualTo(\"java.lang.String\");\n\t\tassertThat(desc.isPrimitive()).isFalse();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isFalse();\n\t\tassertThat(desc.isArray()).isFalse();\n\t\tassertThat(desc.isMap()).isFalse();\n\t}\n\n\t@Test\n\tvoid parameterList() throws Exception {\n\t\tMethodParameter methodParameter = new MethodParameter(getClass().getMethod(\"testParameterList\", List.class), 0);\n\t\tTypeDescriptor desc = new TypeDescriptor(methodParameter);\n\t\tassertThat(desc.getType()).isEqualTo(List.class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(List.class);\n\t\tassertThat(desc.getName()).isEqualTo(\"java.util.List\");\n\t\tassertThat(desc.toString()).isEqualTo(\"java.util.List<java.util.List<java.util.Map<java.lang.Integer, java.lang.Enum<?>>>>\");\n\t\tassertThat(desc.isPrimitive()).isFalse();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isTrue();\n\t\tassertThat(desc.isArray()).isFalse();\n\t\tassertThat(desc.getElementTypeDescriptor().getType()).isEqualTo(List.class);\n\t\tassertThat(desc.getElementTypeDescriptor()).isEqualTo(TypeDescriptor.nested(methodParameter, 1));\n\t\tassertThat(desc.getElementTypeDescriptor().getElementTypeDescriptor()).isEqualTo(TypeDescriptor.nested(methodParameter, 2));\n\t\tassertThat(desc.getElementTypeDescriptor().getElementTypeDescriptor().getMapValueTypeDescriptor()).isEqualTo(TypeDescriptor.nested(methodParameter, 3));\n\t\tassertThat(desc.getElementTypeDescriptor().getElementTypeDescriptor().getMapKeyTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getElementTypeDescriptor().getElementTypeDescriptor().getMapValueTypeDescriptor().getType()).isEqualTo(Enum.class);\n\t\tassertThat(desc.isMap()).isFalse();\n\t}\n\n\t@Test\n\tvoid parameterListNoParamTypes() throws Exception {\n\t\tMethodParameter methodParameter = new MethodParameter(getClass().getMethod(\"testParameterListNoParamTypes\", List.class), 0);\n\t\tTypeDescriptor desc = new TypeDescriptor(methodParameter);\n\t\tassertThat(desc.getType()).isEqualTo(List.class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(List.class);\n\t\tassertThat(desc.getName()).isEqualTo(\"java.util.List\");\n\t\tassertThat(desc.toString()).isEqualTo(\"java.util.List<?>\");\n\t\tassertThat(desc.isPrimitive()).isFalse();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isTrue();\n\t\tassertThat(desc.isArray()).isFalse();\n\t\tassertThat((Object) desc.getElementTypeDescriptor()).isNull();\n\t\tassertThat(desc.isMap()).isFalse();\n\t}\n\n\t@Test\n\tvoid parameterArray() throws Exception {\n\t\tMethodParameter methodParameter = new MethodParameter(getClass().getMethod(\"testParameterArray\", Integer[].class), 0);\n\t\tTypeDescriptor desc = new TypeDescriptor(methodParameter);\n\t\tassertThat(desc.getType()).isEqualTo(Integer[].class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(Integer[].class);\n\t\tassertThat(desc.getName()).isEqualTo(\"java.lang.Integer[]\");\n\t\tassertThat(desc.toString()).isEqualTo(\"java.lang.Integer[]\");\n\t\tassertThat(desc.isPrimitive()).isFalse();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isFalse();\n\t\tassertThat(desc.isArray()).isTrue();\n\t\tassertThat(desc.getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getElementTypeDescriptor()).isEqualTo(TypeDescriptor.valueOf(Integer.class));\n\t\tassertThat(desc.isMap()).isFalse();\n\t}\n\n\t@Test\n\tvoid parameterMap() throws Exception {\n\t\tMethodParameter methodParameter = new MethodParameter(getClass().getMethod(\"testParameterMap\", Map.class), 0);\n\t\tTypeDescriptor desc = new TypeDescriptor(methodParameter);\n\t\tassertThat(desc.getType()).isEqualTo(Map.class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(Map.class);\n\t\tassertThat(desc.getName()).isEqualTo(\"java.util.Map\");\n\t\tassertThat(desc.toString()).isEqualTo(\"java.util.Map<java.lang.Integer, java.util.List<java.lang.String>>\");\n\t\tassertThat(desc.isPrimitive()).isFalse();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isFalse();\n\t\tassertThat(desc.isArray()).isFalse();\n\t\tassertThat(desc.isMap()).isTrue();\n\t\tassertThat(desc.getMapValueTypeDescriptor()).isEqualTo(TypeDescriptor.nested(methodParameter, 1));\n\t\tassertThat(desc.getMapValueTypeDescriptor().getElementTypeDescriptor()).isEqualTo(TypeDescriptor.nested(methodParameter, 2));\n\t\tassertThat(desc.getMapKeyTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getMapValueTypeDescriptor().getType()).isEqualTo(List.class);\n\t\tassertThat(desc.getMapValueTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid parameterAnnotated() throws Exception {\n\t\tTypeDescriptor t1 = new TypeDescriptor(new MethodParameter(getClass().getMethod(\"testAnnotatedMethod\", String.class), 0));\n\t\tassertThat(t1.getType()).isEqualTo(String.class);\n\t\tassertThat(t1.getAnnotations()).hasSize(1);\n\t\tassertThat(t1.getAnnotation(ParameterAnnotation.class)).isNotNull();\n\t\tassertThat(t1.hasAnnotation(ParameterAnnotation.class)).isTrue();\n\t\tassertThat(t1.getAnnotation(ParameterAnnotation.class).value()).isEqualTo(123);\n\t}\n\n\t@Test\n\tvoid getAnnotationsReturnsClonedArray() throws Exception {\n\t\tTypeDescriptor t = new TypeDescriptor(new MethodParameter(getClass().getMethod(\"testAnnotatedMethod\", String.class), 0));\n\t\tt.getAnnotations()[0] = null;\n\t\tassertThat(t.getAnnotations()[0]).isNotNull();\n\t}\n\n\t@Test\n\tvoid propertyComplex() throws Exception {\n\t\tProperty property = new Property(getClass(), getClass().getMethod(\"getComplexProperty\"),\n\t\t\t\tgetClass().getMethod(\"setComplexProperty\", Map.class));\n\t\tTypeDescriptor desc = new TypeDescriptor(property);\n\t\tassertThat(desc.getMapKeyTypeDescriptor().getType()).isEqualTo(String.class);\n\t\tassertThat(desc.getMapValueTypeDescriptor().getElementTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid propertyGenericType() throws Exception {\n\t\tGenericType<Integer> genericBean = new IntegerType();\n\t\tProperty property = new Property(getClass(), genericBean.getClass().getMethod(\"getProperty\"),\n\t\t\t\tgenericBean.getClass().getMethod(\"setProperty\", Integer.class));\n\t\tTypeDescriptor desc = new TypeDescriptor(property);\n\t\tassertThat(desc.getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid propertyTypeCovariance() throws Exception {\n\t\tGenericType<Number> genericBean = new NumberType();\n\t\tProperty property = new Property(getClass(), genericBean.getClass().getMethod(\"getProperty\"),\n\t\t\t\tgenericBean.getClass().getMethod(\"setProperty\", Number.class));\n\t\tTypeDescriptor desc = new TypeDescriptor(property);\n\t\tassertThat(desc.getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid propertyGenericTypeList() throws Exception {\n\t\tGenericType<Integer> genericBean = new IntegerType();\n\t\tProperty property = new Property(getClass(), genericBean.getClass().getMethod(\"getListProperty\"),\n\t\t\t\tgenericBean.getClass().getMethod(\"setListProperty\", List.class));\n\t\tTypeDescriptor desc = new TypeDescriptor(property);\n\t\tassertThat(desc.getType()).isEqualTo(List.class);\n\t\tassertThat(desc.getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid propertyGenericClassList() throws Exception {\n\t\tIntegerClass genericBean = new IntegerClass();\n\t\tProperty property = new Property(genericBean.getClass(), genericBean.getClass().getMethod(\"getListProperty\"),\n\t\t\t\tgenericBean.getClass().getMethod(\"setListProperty\", List.class));\n\t\tTypeDescriptor desc = new TypeDescriptor(property);\n\t\tassertThat(desc.getType()).isEqualTo(List.class);\n\t\tassertThat(desc.getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getAnnotation(MethodAnnotation1.class)).isNotNull();\n\t\tassertThat(desc.hasAnnotation(MethodAnnotation1.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid property() throws Exception {\n\t\tProperty property = new Property(\n\t\t\t\tgetClass(), getClass().getMethod(\"getProperty\"), getClass().getMethod(\"setProperty\", Map.class));\n\t\tTypeDescriptor desc = new TypeDescriptor(property);\n\t\tassertThat(desc.getType()).isEqualTo(Map.class);\n\t\tassertThat(desc.getMapKeyTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getMapValueTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Long.class);\n\t\tassertThat(desc.getAnnotation(MethodAnnotation1.class)).isNotNull();\n\t\tassertThat(desc.getAnnotation(MethodAnnotation2.class)).isNotNull();\n\t\tassertThat(desc.getAnnotation(MethodAnnotation3.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid getAnnotationOnMethodThatIsLocallyAnnotated() throws Exception {\n\t\tassertAnnotationFoundOnMethod(MethodAnnotation1.class, \"methodWithLocalAnnotation\");\n\t}\n\n\t@Test\n\tvoid getAnnotationOnMethodThatIsMetaAnnotated() throws Exception {\n\t\tassertAnnotationFoundOnMethod(MethodAnnotation1.class, \"methodWithComposedAnnotation\");\n\t}\n\n\t@Test\n\tvoid getAnnotationOnMethodThatIsMetaMetaAnnotated() throws Exception {\n\t\tassertAnnotationFoundOnMethod(MethodAnnotation1.class, \"methodWithComposedComposedAnnotation\");\n\t}\n\n\tprivate void assertAnnotationFoundOnMethod(Class<? extends Annotation> annotationType, String methodName) throws Exception {\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(new MethodParameter(getClass().getMethod(methodName), -1));\n\t\tassertThat(typeDescriptor.getAnnotation(annotationType)).as(\"Should have found @\" + annotationType.getSimpleName() + \" on \" + methodName + \".\").isNotNull();\n\t}\n\n\t@Test\n\tvoid fieldScalar() throws Exception {\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(getClass().getField(\"fieldScalar\"));\n\t\tassertThat(typeDescriptor.isPrimitive()).isFalse();\n\t\tassertThat(typeDescriptor.isArray()).isFalse();\n\t\tassertThat(typeDescriptor.isCollection()).isFalse();\n\t\tassertThat(typeDescriptor.isMap()).isFalse();\n\t\tassertThat(typeDescriptor.getType()).isEqualTo(Integer.class);\n\t\tassertThat(typeDescriptor.getObjectType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid fieldList() throws Exception {\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(TypeDescriptorTests.class.getDeclaredField(\"listOfString\"));\n\t\tassertThat(typeDescriptor.isArray()).isFalse();\n\t\tassertThat(typeDescriptor.getType()).isEqualTo(List.class);\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor().getType()).isEqualTo(String.class);\n\t\tassertThat(typeDescriptor.toString()).isEqualTo(\"java.util.List<java.lang.String>\");\n\t}\n\n\t@Test\n\tvoid fieldListOfListOfString() throws Exception {\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(TypeDescriptorTests.class.getDeclaredField(\"listOfListOfString\"));\n\t\tassertThat(typeDescriptor.isArray()).isFalse();\n\t\tassertThat(typeDescriptor.getType()).isEqualTo(List.class);\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor().getType()).isEqualTo(List.class);\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(String.class);\n\t\tassertThat(typeDescriptor.toString()).isEqualTo(\"java.util.List<java.util.List<java.lang.String>>\");\n\t}\n\n\t@Test\n\tvoid fieldListOfListUnknown() throws Exception {\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(TypeDescriptorTests.class.getDeclaredField(\"listOfListOfUnknown\"));\n\t\tassertThat(typeDescriptor.isArray()).isFalse();\n\t\tassertThat(typeDescriptor.getType()).isEqualTo(List.class);\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor().getType()).isEqualTo(List.class);\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor().getElementTypeDescriptor()).isNull();\n\t\tassertThat(typeDescriptor.toString()).isEqualTo(\"java.util.List<java.util.List<?>>\");\n\t}\n\n\t@Test\n\tvoid fieldArray() throws Exception {\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(TypeDescriptorTests.class.getDeclaredField(\"intArray\"));\n\t\tassertThat(typeDescriptor.isArray()).isTrue();\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor().getType()).isEqualTo(int.class);\n\t\tassertThat(typeDescriptor.toString()).isEqualTo(\"int[]\");\n\t}\n\n\t@Test\n\tvoid fieldComplexTypeDescriptor() throws Exception {\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(TypeDescriptorTests.class.getDeclaredField(\"arrayOfListOfString\"));\n\t\tassertThat(typeDescriptor.isArray()).isTrue();\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor().getType()).isEqualTo(List.class);\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(String.class);\n\t\tassertThat(typeDescriptor.toString()).isEqualTo(\"java.util.List<java.lang.String>[]\");\n\t}\n\n\t@Test\n\tvoid fieldComplexTypeDescriptor2() throws Exception {\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(TypeDescriptorTests.class.getDeclaredField(\"nestedMapField\"));\n\t\tassertThat(typeDescriptor.isMap()).isTrue();\n\t\tassertThat(typeDescriptor.getMapKeyTypeDescriptor().getType()).isEqualTo(String.class);\n\t\tassertThat(typeDescriptor.getMapValueTypeDescriptor().getType()).isEqualTo(List.class);\n\t\tassertThat(typeDescriptor.getMapValueTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(typeDescriptor.toString()).isEqualTo(\"java.util.Map<java.lang.String, java.util.List<java.lang.Integer>>\");\n\t}\n\n\t@Test\n\tvoid fieldMap() throws Exception {\n\t\tTypeDescriptor desc = new TypeDescriptor(TypeDescriptorTests.class.getField(\"fieldMap\"));\n\t\tassertThat(desc.isMap()).isTrue();\n\t\tassertThat(desc.getMapKeyTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getMapValueTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Long.class);\n\t}\n\n\t@Test\n\tvoid fieldAnnotated() throws Exception {\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(getClass().getField(\"fieldAnnotated\"));\n\t\tassertThat(typeDescriptor.getAnnotations()).hasSize(1);\n\t\tassertThat(typeDescriptor.getAnnotation(FieldAnnotation.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid valueOfScalar() {\n\t\tTypeDescriptor typeDescriptor = TypeDescriptor.valueOf(Integer.class);\n\t\tassertThat(typeDescriptor.isPrimitive()).isFalse();\n\t\tassertThat(typeDescriptor.isArray()).isFalse();\n\t\tassertThat(typeDescriptor.isCollection()).isFalse();\n\t\tassertThat(typeDescriptor.isMap()).isFalse();\n\t\tassertThat(typeDescriptor.getType()).isEqualTo(Integer.class);\n\t\tassertThat(typeDescriptor.getObjectType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid valueOfPrimitive() {\n\t\tTypeDescriptor typeDescriptor = TypeDescriptor.valueOf(int.class);\n\t\tassertThat(typeDescriptor.isPrimitive()).isTrue();\n\t\tassertThat(typeDescriptor.isArray()).isFalse();\n\t\tassertThat(typeDescriptor.isCollection()).isFalse();\n\t\tassertThat(typeDescriptor.isMap()).isFalse();\n\t\tassertThat(typeDescriptor.getType()).isEqualTo(int.class);\n\t\tassertThat(typeDescriptor.getObjectType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid valueOfArray() {\n\t\tTypeDescriptor typeDescriptor = TypeDescriptor.valueOf(int[].class);\n\t\tassertThat(typeDescriptor.isArray()).isTrue();\n\t\tassertThat(typeDescriptor.isCollection()).isFalse();\n\t\tassertThat(typeDescriptor.isMap()).isFalse();\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor().getType()).isEqualTo(int.class);\n\t}\n\n\t@Test\n\tvoid valueOfCollection() {\n\t\tTypeDescriptor typeDescriptor = TypeDescriptor.valueOf(Collection.class);\n\t\tassertThat(typeDescriptor.isCollection()).isTrue();\n\t\tassertThat(typeDescriptor.isArray()).isFalse();\n\t\tassertThat(typeDescriptor.isMap()).isFalse();\n\t\tassertThat((Object) typeDescriptor.getElementTypeDescriptor()).isNull();\n\t}\n\n\t@Test\n\tvoid forObject() {\n\t\tTypeDescriptor desc = TypeDescriptor.forObject(\"3\");\n\t\tassertThat(desc.getType()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid forObjectNullTypeDescriptor() {\n\t\tTypeDescriptor desc = TypeDescriptor.forObject(null);\n\t\tassertThat((Object) desc).isNull();\n\t}\n\n\t@Test\n\tvoid nestedMethodParameterType2Levels() throws Exception {\n\t\tTypeDescriptor t1 = TypeDescriptor.nested(new MethodParameter(getClass().getMethod(\"test2\", List.class), 0), 2);\n\t\tassertThat(t1.getType()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid nestedMethodParameterTypeMap() throws Exception {\n\t\tTypeDescriptor t1 = TypeDescriptor.nested(new MethodParameter(getClass().getMethod(\"test3\", Map.class), 0), 1);\n\t\tassertThat(t1.getType()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid nestedMethodParameterTypeMapTwoLevels() throws Exception {\n\t\tTypeDescriptor t1 = TypeDescriptor.nested(new MethodParameter(getClass().getMethod(\"test4\", List.class), 0), 2);\n\t\tassertThat(t1.getType()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid nestedMethodParameterNot1NestedLevel() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tTypeDescriptor.nested(new MethodParameter(getClass().getMethod(\"test4\", List.class), 0, 2), 2));\n\t}\n\n\t@Test\n\tvoid nestedTooManyLevels() throws Exception {\n\t\tTypeDescriptor t1 = TypeDescriptor.nested(new MethodParameter(getClass().getMethod(\"test4\", List.class), 0), 3);\n\t\tassertThat((Object) t1).isNull();\n\t}\n\n\t@Test\n\tvoid nestedMethodParameterTypeNotNestable() throws Exception {\n\t\tTypeDescriptor t1 = TypeDescriptor.nested(new MethodParameter(getClass().getMethod(\"test5\", String.class), 0), 2);\n\t\tassertThat((Object) t1).isNull();\n\t}\n\n\t@Test\n\tvoid nestedMethodParameterTypeInvalidNestingLevel() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tTypeDescriptor.nested(new MethodParameter(getClass().getMethod(\"test5\", String.class), 0, 2), 2));\n\t}\n\n\t@Test\n\tvoid nestedNotParameterized() throws Exception {\n\t\tTypeDescriptor t1 = TypeDescriptor.nested(new MethodParameter(getClass().getMethod(\"test6\", List.class), 0), 1);\n\t\tassertThat(t1.getType()).isEqualTo(List.class);\n\t\tassertThat(t1.toString()).isEqualTo(\"java.util.List<?>\");\n\t\tTypeDescriptor t2 = TypeDescriptor.nested(new MethodParameter(getClass().getMethod(\"test6\", List.class), 0), 2);\n\t\tassertThat((Object) t2).isNull();\n\t}\n\n\t@Test\n\tvoid nestedFieldTypeMapTwoLevels() throws Exception {\n\t\tTypeDescriptor t1 = TypeDescriptor.nested(getClass().getField(\"test4\"), 2);\n\t\tassertThat(t1.getType()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid nestedPropertyTypeMapTwoLevels() throws Exception {\n\t\tProperty property = new Property(getClass(), getClass().getMethod(\"getTest4\"), getClass().getMethod(\"setTest4\", List.class));\n\t\tTypeDescriptor t1 = TypeDescriptor.nested(property, 2);\n\t\tassertThat(t1.getType()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid collection() {\n\t\tTypeDescriptor desc = TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(Integer.class));\n\t\tassertThat(desc.getType()).isEqualTo(List.class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(List.class);\n\t\tassertThat(desc.getName()).isEqualTo(\"java.util.List\");\n\t\tassertThat(desc.toString()).isEqualTo(\"java.util.List<java.lang.Integer>\");\n\t\tassertThat(desc.isPrimitive()).isFalse();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isTrue();\n\t\tassertThat(desc.isArray()).isFalse();\n\t\tassertThat(desc.getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getElementTypeDescriptor()).isEqualTo(TypeDescriptor.valueOf(Integer.class));\n\t\tassertThat(desc.isMap()).isFalse();\n\t}\n\n\t@Test\n\tvoid collectionNested() {\n\t\tTypeDescriptor desc = TypeDescriptor.collection(List.class, TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(Integer.class)));\n\t\tassertThat(desc.getType()).isEqualTo(List.class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(List.class);\n\t\tassertThat(desc.getName()).isEqualTo(\"java.util.List\");\n\t\tassertThat(desc.toString()).isEqualTo(\"java.util.List<java.util.List<java.lang.Integer>>\");\n\t\tassertThat(desc.isPrimitive()).isFalse();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isTrue();\n\t\tassertThat(desc.isArray()).isFalse();\n\t\tassertThat(desc.getElementTypeDescriptor().getType()).isEqualTo(List.class);\n\t\tassertThat(desc.getElementTypeDescriptor().getElementTypeDescriptor()).isEqualTo(TypeDescriptor.valueOf(Integer.class));\n\t\tassertThat(desc.isMap()).isFalse();\n\t}\n\n\t@Test\n\tvoid map() {\n\t\tTypeDescriptor desc = TypeDescriptor.map(Map.class, TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(Integer.class));\n\t\tassertThat(desc.getType()).isEqualTo(Map.class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(Map.class);\n\t\tassertThat(desc.getName()).isEqualTo(\"java.util.Map\");\n\t\tassertThat(desc.toString()).isEqualTo(\"java.util.Map<java.lang.String, java.lang.Integer>\");\n\t\tassertThat(desc.isPrimitive()).isFalse();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isFalse();\n\t\tassertThat(desc.isArray()).isFalse();\n\t\tassertThat(desc.isMap()).isTrue();\n\t\tassertThat(desc.getMapKeyTypeDescriptor().getType()).isEqualTo(String.class);\n\t\tassertThat(desc.getMapValueTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid mapNested() {\n\t\tTypeDescriptor desc = TypeDescriptor.map(Map.class, TypeDescriptor.valueOf(String.class),\n\t\t\t\tTypeDescriptor.map(Map.class, TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(Integer.class)));\n\t\tassertThat(desc.getType()).isEqualTo(Map.class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(Map.class);\n\t\tassertThat(desc.getName()).isEqualTo(\"java.util.Map\");\n\t\tassertThat(desc.toString()).isEqualTo(\"java.util.Map<java.lang.String, java.util.Map<java.lang.String, java.lang.Integer>>\");\n\t\tassertThat(desc.isPrimitive()).isFalse();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isFalse();\n\t\tassertThat(desc.isArray()).isFalse();\n\t\tassertThat(desc.isMap()).isTrue();\n\t\tassertThat(desc.getMapKeyTypeDescriptor().getType()).isEqualTo(String.class);\n\t\tassertThat(desc.getMapValueTypeDescriptor().getMapKeyTypeDescriptor().getType()).isEqualTo(String.class);\n\t\tassertThat(desc.getMapValueTypeDescriptor().getMapValueTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid narrow() {\n\t\tTypeDescriptor desc = TypeDescriptor.valueOf(Number.class);\n\t\tInteger value = 3;\n\t\tdesc = desc.narrow(value);\n\t\tassertThat(desc.getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid elementType() {\n\t\tTypeDescriptor desc = TypeDescriptor.valueOf(List.class);\n\t\tInteger value = 3;\n\t\tdesc = desc.elementTypeDescriptor(value);\n\t\tassertThat(desc.getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid elementTypePreserveContext() throws Exception {\n\t\tTypeDescriptor desc = new TypeDescriptor(getClass().getField(\"listPreserveContext\"));\n\t\tassertThat(desc.getElementTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tList<Integer> value = new ArrayList<>(3);\n\t\tdesc = desc.elementTypeDescriptor(value);\n\t\tassertThat(desc.getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getAnnotation(FieldAnnotation.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid mapKeyType() {\n\t\tTypeDescriptor desc = TypeDescriptor.valueOf(Map.class);\n\t\tInteger value = 3;\n\t\tdesc = desc.getMapKeyTypeDescriptor(value);\n\t\tassertThat(desc.getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid mapKeyTypePreserveContext() throws Exception {\n\t\tTypeDescriptor desc = new TypeDescriptor(getClass().getField(\"mapPreserveContext\"));\n\t\tassertThat(desc.getMapKeyTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tList<Integer> value = new ArrayList<>(3);\n\t\tdesc = desc.getMapKeyTypeDescriptor(value);\n\t\tassertThat(desc.getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getAnnotation(FieldAnnotation.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid mapValueType() {\n\t\tTypeDescriptor desc = TypeDescriptor.valueOf(Map.class);\n\t\tInteger value = 3;\n\t\tdesc = desc.getMapValueTypeDescriptor(value);\n\t\tassertThat(desc.getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid mapValueTypePreserveContext() throws Exception {\n\t\tTypeDescriptor desc = new TypeDescriptor(getClass().getField(\"mapPreserveContext\"));\n\t\tassertThat(desc.getMapValueTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tList<Integer> value = new ArrayList<>(3);\n\t\tdesc = desc.getMapValueTypeDescriptor(value);\n\t\tassertThat(desc.getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getAnnotation(FieldAnnotation.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid equality() throws Exception {\n\t\tTypeDescriptor t1 = TypeDescriptor.valueOf(String.class);\n\t\tTypeDescriptor t2 = TypeDescriptor.valueOf(String.class);\n\t\tTypeDescriptor t3 = TypeDescriptor.valueOf(Date.class);\n\t\tTypeDescriptor t4 = TypeDescriptor.valueOf(Date.class);\n\t\tTypeDescriptor t5 = TypeDescriptor.valueOf(List.class);\n\t\tTypeDescriptor t6 = TypeDescriptor.valueOf(List.class);\n\t\tTypeDescriptor t7 = TypeDescriptor.valueOf(Map.class);\n\t\tTypeDescriptor t8 = TypeDescriptor.valueOf(Map.class);\n\t\tassertThat(t2).isEqualTo(t1);\n\t\tassertThat(t4).isEqualTo(t3);\n\t\tassertThat(t6).isEqualTo(t5);\n\t\tassertThat(t8).isEqualTo(t7);\n\n\t\tTypeDescriptor t9 = new TypeDescriptor(getClass().getField(\"listField\"));\n\t\tTypeDescriptor t10 = new TypeDescriptor(getClass().getField(\"listField\"));\n\t\tassertThat(t10).isEqualTo(t9);\n\n\t\tTypeDescriptor t11 = new TypeDescriptor(getClass().getField(\"mapField\"));\n\t\tTypeDescriptor t12 = new TypeDescriptor(getClass().getField(\"mapField\"));\n\t\tassertThat(t12).isEqualTo(t11);\n\n\t\tMethodParameter testAnnotatedMethod = new MethodParameter(getClass().getMethod(\"testAnnotatedMethod\", String.class), 0);\n\t\tTypeDescriptor t13 = new TypeDescriptor(testAnnotatedMethod);\n\t\tTypeDescriptor t14 = new TypeDescriptor(testAnnotatedMethod);\n\t\tassertThat(t14).isEqualTo(t13);\n\n\t\tTypeDescriptor t15 = new TypeDescriptor(testAnnotatedMethod);\n\t\tTypeDescriptor t16 = new TypeDescriptor(new MethodParameter(getClass().getMethod(\"testAnnotatedMethodDifferentAnnotationValue\", String.class), 0));\n\t\tassertThat(t16).isNotEqualTo(t15);\n\n\t\tTypeDescriptor t17 = new TypeDescriptor(testAnnotatedMethod);\n\t\tTypeDescriptor t18 = new TypeDescriptor(new MethodParameter(getClass().getMethod(\"test5\", String.class), 0));\n\t\tassertThat(t18).isNotEqualTo(t17);\n\t}\n\n\t@Test\n\tvoid isAssignableTypes() {\n\t\tassertThat(TypeDescriptor.valueOf(Integer.class).isAssignableTo(TypeDescriptor.valueOf(Number.class))).isTrue();\n\t\tassertThat(TypeDescriptor.valueOf(Number.class).isAssignableTo(TypeDescriptor.valueOf(Integer.class))).isFalse();\n\t\tassertThat(TypeDescriptor.valueOf(String.class).isAssignableTo(TypeDescriptor.valueOf(String[].class))).isFalse();\n\t}\n\n\t@Test\n\tvoid isAssignableElementTypes() throws Exception {\n\t\tassertThat(new TypeDescriptor(getClass().getField(\"listField\")).isAssignableTo(new TypeDescriptor(getClass().getField(\"listField\")))).isTrue();\n\t\tassertThat(new TypeDescriptor(getClass().getField(\"notGenericList\")).isAssignableTo(new TypeDescriptor(getClass().getField(\"listField\")))).isTrue();\n\t\tassertThat(new TypeDescriptor(getClass().getField(\"listField\")).isAssignableTo(new TypeDescriptor(getClass().getField(\"notGenericList\")))).isTrue();\n\t\tassertThat(new TypeDescriptor(getClass().getField(\"isAssignableElementTypes\")).isAssignableTo(new TypeDescriptor(getClass().getField(\"listField\")))).isFalse();\n\t\tassertThat(TypeDescriptor.valueOf(List.class).isAssignableTo(new TypeDescriptor(getClass().getField(\"listField\")))).isTrue();\n\t}\n\n\t@Test\n\tvoid isAssignableMapKeyValueTypes() throws Exception {\n\t\tassertThat(new TypeDescriptor(getClass().getField(\"mapField\")).isAssignableTo(new TypeDescriptor(getClass().getField(\"mapField\")))).isTrue();\n\t\tassertThat(new TypeDescriptor(getClass().getField(\"notGenericMap\")).isAssignableTo(new TypeDescriptor(getClass().getField(\"mapField\")))).isTrue();\n\t\tassertThat(new TypeDescriptor(getClass().getField(\"mapField\")).isAssignableTo(new TypeDescriptor(getClass().getField(\"notGenericMap\")))).isTrue();\n\t\tassertThat(new TypeDescriptor(getClass().getField(\"isAssignableMapKeyValueTypes\")).isAssignableTo(new TypeDescriptor(getClass().getField(\"mapField\")))).isFalse();\n\t\tassertThat(TypeDescriptor.valueOf(Map.class).isAssignableTo(new TypeDescriptor(getClass().getField(\"mapField\")))).isTrue();\n\t}\n\n\t@Test\n\tvoid multiValueMap() throws Exception {\n\t\tTypeDescriptor td = new TypeDescriptor(getClass().getField(\"multiValueMap\"));\n\t\tassertThat(td.isMap()).isTrue();\n\t\tassertThat(td.getMapKeyTypeDescriptor().getType()).isEqualTo(String.class);\n\t\tassertThat(td.getMapValueTypeDescriptor().getType()).isEqualTo(List.class);\n\t\tassertThat(td.getMapValueTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid passDownGeneric() throws Exception {\n\t\tTypeDescriptor td = new TypeDescriptor(getClass().getField(\"passDownGeneric\"));\n\t\tassertThat(td.getElementTypeDescriptor().getType()).isEqualTo(List.class);\n\t\tassertThat(td.getElementTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Set.class);\n\t\tassertThat(td.getElementTypeDescriptor().getElementTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid upcast() throws Exception {\n\t\tProperty property = new Property(getClass(), getClass().getMethod(\"getProperty\"),\n\t\t\t\tgetClass().getMethod(\"setProperty\", Map.class));\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(property);\n\t\tTypeDescriptor upcast = typeDescriptor.upcast(Object.class);\n\t\tassertThat(upcast.getAnnotation(MethodAnnotation1.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid upCastNotSuper() throws Exception {\n\t\tProperty property = new Property(getClass(), getClass().getMethod(\"getProperty\"),\n\t\t\t\tgetClass().getMethod(\"setProperty\", Map.class));\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(property);\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\ttypeDescriptor.upcast(Collection.class))\n\t\t\t.withMessage(\"interface java.util.Map is not assignable to interface java.util.Collection\");\n\t}\n\n\t@Test\n\tvoid elementTypeForCollectionSubclass() {\n\t\t@SuppressWarnings(\"serial\")\n\t\tclass CustomSet extends HashSet<String> {\n\t\t}\n\n\t\tassertThat(TypeDescriptor.valueOf(String.class)).isEqualTo(TypeDescriptor.valueOf(CustomSet.class).getElementTypeDescriptor());\n\t\tassertThat(TypeDescriptor.valueOf(String.class)).isEqualTo(TypeDescriptor.forObject(new CustomSet()).getElementTypeDescriptor());\n\t}\n\n\t@Test\n\tvoid elementTypeForMapSubclass() {\n\t\t@SuppressWarnings(\"serial\")\n\t\tclass CustomMap extends HashMap<String, Integer> {\n\t\t}\n\n\t\tassertThat(TypeDescriptor.valueOf(String.class)).isEqualTo(TypeDescriptor.valueOf(CustomMap.class).getMapKeyTypeDescriptor());\n\t\tassertThat(TypeDescriptor.valueOf(Integer.class)).isEqualTo(TypeDescriptor.valueOf(CustomMap.class).getMapValueTypeDescriptor());\n\t\tassertThat(TypeDescriptor.valueOf(String.class)).isEqualTo(TypeDescriptor.forObject(new CustomMap()).getMapKeyTypeDescriptor());\n\t\tassertThat(TypeDescriptor.valueOf(Integer.class)).isEqualTo(TypeDescriptor.forObject(new CustomMap()).getMapValueTypeDescriptor());\n\t}\n\n\t@Test\n\tvoid createMapArray() {\n\t\tTypeDescriptor mapType = TypeDescriptor.map(\n\t\t\t\tLinkedHashMap.class, TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(Integer.class));\n\t\tTypeDescriptor arrayType = TypeDescriptor.array(mapType);\n\t\tassertThat(LinkedHashMap[].class).isEqualTo(arrayType.getType());\n\t\tassertThat(mapType).isEqualTo(arrayType.getElementTypeDescriptor());\n\t}\n\n\t@Test\n\tvoid createStringArray() {\n\t\tTypeDescriptor arrayType = TypeDescriptor.array(TypeDescriptor.valueOf(String.class));\n\t\tassertThat(TypeDescriptor.valueOf(String[].class)).isEqualTo(arrayType);\n\t}\n\n\t@Test\n\tvoid createNullArray() {\n\t\tassertThat((Object) TypeDescriptor.array(null)).isNull();\n\t}\n\n\t@Test\n\tvoid serializable() throws Exception {\n\t\tTypeDescriptor typeDescriptor = TypeDescriptor.forObject(\"\");\n\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\tObjectOutputStream outputStream = new ObjectOutputStream(out);\n\t\toutputStream.writeObject(typeDescriptor);\n\t\tObjectInputStream inputStream = new ObjectInputStream(new ByteArrayInputStream(\n\t\t\t\tout.toByteArray()));\n\t\tTypeDescriptor readObject = (TypeDescriptor) inputStream.readObject();\n\t\tassertThat(readObject).isEqualTo(typeDescriptor);\n\t}\n\n\t@Test\n\tvoid createCollectionWithNullElement() {\n\t\tTypeDescriptor typeDescriptor = TypeDescriptor.collection(List.class, null);\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor()).isNull();\n\t}\n\n\t@Test\n\tvoid createMapWithNullElements() {\n\t\tTypeDescriptor typeDescriptor = TypeDescriptor.map(LinkedHashMap.class, null, null);\n\t\tassertThat(typeDescriptor.getMapKeyTypeDescriptor()).isNull();\n\t\tassertThat(typeDescriptor.getMapValueTypeDescriptor()).isNull();\n\t}\n\n\t@Test\n\tvoid getSource() throws Exception {\n\t\tField field = getClass().getField(\"fieldScalar\");\n\t\tMethodParameter methodParameter = new MethodParameter(getClass().getMethod(\"testParameterPrimitive\", int.class), 0);\n\t\tassertThat(new TypeDescriptor(field).getSource()).isEqualTo(field);\n\t\tassertThat(new TypeDescriptor(methodParameter).getSource()).isEqualTo(methodParameter);\n\t\tassertThat(TypeDescriptor.valueOf(Integer.class).getSource()).isEqualTo(Integer.class);\n\t}\n\n\t@Test  // gh-31672\n\tvoid equalityWithGenerics() {\n\t\tResolvableType rt1 = ResolvableType.forClassWithGenerics(Optional.class, Integer.class);\n\t\tResolvableType rt2 = ResolvableType.forClassWithGenerics(Optional.class, String.class);\n\n\t\tTypeDescriptor td1 = new TypeDescriptor(rt1, null, null);\n\t\tTypeDescriptor td2 = new TypeDescriptor(rt2, null, null);\n\n\t\tassertThat(td1).isNotEqualTo(td2);\n\t}\n\n\t@Test  // gh-33932\n\tvoid recursiveType() {\n\t\tassertThat(TypeDescriptor.valueOf(RecursiveMap.class)).isEqualTo(\n\t\t\t\tTypeDescriptor.valueOf(RecursiveMap.class));\n\n\t\tTypeDescriptor typeDescriptor1 = TypeDescriptor.map(Map.class,\n\t\t\t\tTypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(RecursiveMap.class));\n\t\tTypeDescriptor typeDescriptor2 = TypeDescriptor.map(Map.class,\n\t\t\t\tTypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(RecursiveMap.class));\n\t\tassertThat(typeDescriptor1).isEqualTo(typeDescriptor2);\n\t}\n\n\t@Test  // gh-33932\n\tvoid recursiveTypeWithInterface() {\n\t\tassertThat(TypeDescriptor.valueOf(RecursiveMapWithInterface.class)).isEqualTo(\n\t\t\t\tTypeDescriptor.valueOf(RecursiveMapWithInterface.class));\n\n\t\tTypeDescriptor typeDescriptor1 = TypeDescriptor.map(Map.class,\n\t\t\t\tTypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(RecursiveMapWithInterface.class));\n\t\tTypeDescriptor typeDescriptor2 = TypeDescriptor.map(Map.class,\n\t\t\t\tTypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(RecursiveMapWithInterface.class));\n\t\tassertThat(typeDescriptor1).isEqualTo(typeDescriptor2);\n\t}\n\n\n\t// Methods designed for test introspection\n\n\tpublic void testParameterPrimitive(int primitive) {\n\t}\n\n\tpublic void testParameterScalar(String value) {\n\t}\n\n\tpublic void testParameterList(List<List<Map<Integer, Enum<?>>>> list) {\n\t}\n\n\tpublic void testParameterListNoParamTypes(List list) {\n\t}\n\n\tpublic void testParameterArray(Integer[] array) {\n\t}\n\n\tpublic void testParameterMap(Map<Integer, List<String>> map) {\n\t}\n\n\tpublic void test1(List<String> param1) {\n\t}\n\n\tpublic void test2(List<List<String>> param1) {\n\t}\n\n\tpublic void test3(Map<Integer, String> param1) {\n\t}\n\n\tpublic void test4(List<Map<Integer, String>> param1) {\n\t}\n\n\tpublic void test5(String param1) {\n\t}\n\n\tpublic void test6(List<List> param1) {\n\t}\n\n\tpublic List<Map<Integer, String>> getTest4() {\n\t\treturn null;\n\t}\n\n\tpublic void setTest4(List<Map<Integer, String>> test4) {\n\t}\n\n\tpublic Map<String, List<List<Integer>>> getComplexProperty() {\n\t\treturn null;\n\t}\n\n\t@MethodAnnotation1\n\tpublic Map<List<Integer>, List<Long>> getProperty() {\n\t\treturn property;\n\t}\n\n\t@MethodAnnotation2\n\tpublic void setProperty(Map<List<Integer>, List<Long>> property) {\n\t\tthis.property = property;\n\t}\n\n\t@MethodAnnotation1\n\tpublic void methodWithLocalAnnotation() {\n\t}\n\n\t@ComposedMethodAnnotation1\n\tpublic void methodWithComposedAnnotation() {\n\t}\n\n\t@ComposedComposedMethodAnnotation1\n\tpublic void methodWithComposedComposedAnnotation() {\n\t}\n\n\tpublic void setComplexProperty(Map<String, List<List<Integer>>> complexProperty) {\n\t}\n\n\tpublic void testAnnotatedMethod(@ParameterAnnotation(123) String parameter) {\n\t}\n\n\tpublic void testAnnotatedMethodDifferentAnnotationValue(@ParameterAnnotation(567) String parameter) {\n\t}\n\n\n\t// Fields designed for test introspection\n\n\tpublic Integer fieldScalar;\n\n\tpublic List<String> listOfString;\n\n\tpublic List<List<String>> listOfListOfString = new ArrayList<>();\n\n\tpublic List<List> listOfListOfUnknown = new ArrayList<>();\n\n\tpublic int[] intArray;\n\n\tpublic List<String>[] arrayOfListOfString;\n\n\tpublic List<Integer> listField = new ArrayList<>();\n\n\tpublic Map<String, Integer> mapField = new HashMap<>();\n\n\tpublic Map<String, List<Integer>> nestedMapField = new HashMap<>();\n\n\tpublic Map<List<Integer>, List<Long>> fieldMap;\n\n\tpublic List<Map<Integer, String>> test4;\n\n\t@FieldAnnotation\n\tpublic List<String> fieldAnnotated;\n\n\t@FieldAnnotation\n\tpublic List<List<Integer>> listPreserveContext;\n\n\t@FieldAnnotation\n\tpublic Map<List<Integer>, List<Integer>> mapPreserveContext;\n\n\t@MethodAnnotation3\n\tprivate Map<List<Integer>, List<Long>> property;\n\n\tpublic List notGenericList;\n\n\tpublic List<Number> isAssignableElementTypes;\n\n\tpublic Map notGenericMap;\n\n\tpublic Map<CharSequence, Number> isAssignableMapKeyValueTypes;\n\n\tpublic MultiValueMap<String, Integer> multiValueMap = new LinkedMultiValueMap<>();\n\n\tpublic PassDownGeneric<Integer> passDownGeneric = new PassDownGeneric<>();\n\n\n\t// Classes designed for test introspection\n\n\t@SuppressWarnings(\"serial\")\n\tpublic static class PassDownGeneric<T> extends ArrayList<List<Set<T>>> {\n\t}\n\n\n\tpublic static class GenericClass<T> {\n\n\t\tpublic T getProperty() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void setProperty(T t) {\n\t\t}\n\n\t\t@MethodAnnotation1\n\t\tpublic List<T> getListProperty() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void setListProperty(List<T> t) {\n\t\t}\n\t}\n\n\n\tpublic static class IntegerClass extends GenericClass<Integer> {\n\t}\n\n\n\tpublic interface GenericType<T> {\n\n\t\tT getProperty();\n\n\t\tvoid setProperty(T t);\n\n\t\tList<T> getListProperty();\n\n\t\tvoid setListProperty(List<T> t);\n\t}\n\n\n\tpublic class IntegerType implements GenericType<Integer> {\n\n\t\t@Override\n\t\tpublic Integer getProperty() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void setProperty(Integer t) {\n\t\t}\n\n\t\t@Override\n\t\tpublic List<Integer> getListProperty() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void setListProperty(List<Integer> t) {\n\t\t}\n\t}\n\n\n\tpublic class NumberType implements GenericType<Number> {\n\n\t\t@Override\n\t\tpublic Integer getProperty() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void setProperty(Number t) {\n\t\t}\n\n\t\t@Override\n\t\tpublic List<Number> getListProperty() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void setListProperty(List<Number> t) {\n\t\t}\n\t}\n\n\n\t@SuppressWarnings(\"serial\")\n\tstatic class RecursiveMap extends HashMap<String, RecursiveMap> {\n\t}\n\n\t@SuppressWarnings(\"serial\")\n\tstatic class RecursiveMapWithInterface extends HashMap<String, RecursiveMapWithInterface>\n\t\t\timplements Map<String, RecursiveMapWithInterface> {\n\t}\n\n\n\t// Annotations used on tested elements\n\n\t@Target({ElementType.PARAMETER})\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface ParameterAnnotation {\n\n\t\tint value();\n\t}\n\n\n\t@Target({ElementType.FIELD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface FieldAnnotation {\n\t}\n\n\n\t@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface MethodAnnotation1 {\n\t}\n\n\n\t@Target({ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface MethodAnnotation2 {\n\t}\n\n\n\t@Target({ElementType.FIELD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface MethodAnnotation3 {\n\t}\n\n\n\t@MethodAnnotation1\n\t@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface ComposedMethodAnnotation1 {\n\t}\n\n\n\t@ComposedMethodAnnotation1\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface ComposedComposedMethodAnnotation1 {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.convert.GenericType#getProperty()",
    "headType": "method",
    "relation": "provide",
    "tail": "T getProperty();",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.convert.GenericType",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.convert.GenericType#getProperty()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.convert.GenericType#setProperty(T)",
    "headType": "method",
    "relation": "provide",
    "tail": "void setProperty(T t);",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.convert.GenericType",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.convert.GenericType#setProperty(T)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.convert.GenericType#getListProperty()",
    "headType": "method",
    "relation": "provide",
    "tail": "List<T> getListProperty();",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.convert.GenericType",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.convert.GenericType#getListProperty()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.convert.GenericType#setListProperty(List<T>)",
    "headType": "method",
    "relation": "provide",
    "tail": "void setListProperty(List<T> t);",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.convert.GenericType",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.convert.GenericType#setListProperty(List<T>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.convert",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.convert.IntegerType",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.convert.IntegerType",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.convert;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.MethodParameter;\nimport org.springframework.core.ResolvableType;\nimport org.springframework.util.LinkedMultiValueMap;\nimport org.springframework.util.MultiValueMap;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n\n/**\n * Tests for {@link TypeDescriptor}.\n *\n * @author Keith Donald\n * @author Andy Clement\n * @author Phillip Webb\n * @author Sam Brannen\n * @author Nathan Piper\n */\n@SuppressWarnings(\"rawtypes\")\nclass TypeDescriptorTests {\n\n\t@Test\n\tvoid parameterPrimitive() throws Exception {\n\t\tTypeDescriptor desc = new TypeDescriptor(new MethodParameter(getClass().getMethod(\"testParameterPrimitive\", int.class), 0));\n\t\tassertThat(desc.getType()).isEqualTo(int.class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getName()).isEqualTo(\"int\");\n\t\tassertThat(desc.toString()).isEqualTo(\"int\");\n\t\tassertThat(desc.isPrimitive()).isTrue();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isFalse();\n\t\tassertThat(desc.isMap()).isFalse();\n\t}\n\n\t@Test\n\tvoid parameterScalar() throws Exception {\n\t\tTypeDescriptor desc = new TypeDescriptor(new MethodParameter(getClass().getMethod(\"testParameterScalar\", String.class), 0));\n\t\tassertThat(desc.getType()).isEqualTo(String.class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(String.class);\n\t\tassertThat(desc.getName()).isEqualTo(\"java.lang.String\");\n\t\tassertThat(desc.toString()).isEqualTo(\"java.lang.String\");\n\t\tassertThat(desc.isPrimitive()).isFalse();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isFalse();\n\t\tassertThat(desc.isArray()).isFalse();\n\t\tassertThat(desc.isMap()).isFalse();\n\t}\n\n\t@Test\n\tvoid parameterList() throws Exception {\n\t\tMethodParameter methodParameter = new MethodParameter(getClass().getMethod(\"testParameterList\", List.class), 0);\n\t\tTypeDescriptor desc = new TypeDescriptor(methodParameter);\n\t\tassertThat(desc.getType()).isEqualTo(List.class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(List.class);\n\t\tassertThat(desc.getName()).isEqualTo(\"java.util.List\");\n\t\tassertThat(desc.toString()).isEqualTo(\"java.util.List<java.util.List<java.util.Map<java.lang.Integer, java.lang.Enum<?>>>>\");\n\t\tassertThat(desc.isPrimitive()).isFalse();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isTrue();\n\t\tassertThat(desc.isArray()).isFalse();\n\t\tassertThat(desc.getElementTypeDescriptor().getType()).isEqualTo(List.class);\n\t\tassertThat(desc.getElementTypeDescriptor()).isEqualTo(TypeDescriptor.nested(methodParameter, 1));\n\t\tassertThat(desc.getElementTypeDescriptor().getElementTypeDescriptor()).isEqualTo(TypeDescriptor.nested(methodParameter, 2));\n\t\tassertThat(desc.getElementTypeDescriptor().getElementTypeDescriptor().getMapValueTypeDescriptor()).isEqualTo(TypeDescriptor.nested(methodParameter, 3));\n\t\tassertThat(desc.getElementTypeDescriptor().getElementTypeDescriptor().getMapKeyTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getElementTypeDescriptor().getElementTypeDescriptor().getMapValueTypeDescriptor().getType()).isEqualTo(Enum.class);\n\t\tassertThat(desc.isMap()).isFalse();\n\t}\n\n\t@Test\n\tvoid parameterListNoParamTypes() throws Exception {\n\t\tMethodParameter methodParameter = new MethodParameter(getClass().getMethod(\"testParameterListNoParamTypes\", List.class), 0);\n\t\tTypeDescriptor desc = new TypeDescriptor(methodParameter);\n\t\tassertThat(desc.getType()).isEqualTo(List.class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(List.class);\n\t\tassertThat(desc.getName()).isEqualTo(\"java.util.List\");\n\t\tassertThat(desc.toString()).isEqualTo(\"java.util.List<?>\");\n\t\tassertThat(desc.isPrimitive()).isFalse();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isTrue();\n\t\tassertThat(desc.isArray()).isFalse();\n\t\tassertThat((Object) desc.getElementTypeDescriptor()).isNull();\n\t\tassertThat(desc.isMap()).isFalse();\n\t}\n\n\t@Test\n\tvoid parameterArray() throws Exception {\n\t\tMethodParameter methodParameter = new MethodParameter(getClass().getMethod(\"testParameterArray\", Integer[].class), 0);\n\t\tTypeDescriptor desc = new TypeDescriptor(methodParameter);\n\t\tassertThat(desc.getType()).isEqualTo(Integer[].class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(Integer[].class);\n\t\tassertThat(desc.getName()).isEqualTo(\"java.lang.Integer[]\");\n\t\tassertThat(desc.toString()).isEqualTo(\"java.lang.Integer[]\");\n\t\tassertThat(desc.isPrimitive()).isFalse();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isFalse();\n\t\tassertThat(desc.isArray()).isTrue();\n\t\tassertThat(desc.getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getElementTypeDescriptor()).isEqualTo(TypeDescriptor.valueOf(Integer.class));\n\t\tassertThat(desc.isMap()).isFalse();\n\t}\n\n\t@Test\n\tvoid parameterMap() throws Exception {\n\t\tMethodParameter methodParameter = new MethodParameter(getClass().getMethod(\"testParameterMap\", Map.class), 0);\n\t\tTypeDescriptor desc = new TypeDescriptor(methodParameter);\n\t\tassertThat(desc.getType()).isEqualTo(Map.class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(Map.class);\n\t\tassertThat(desc.getName()).isEqualTo(\"java.util.Map\");\n\t\tassertThat(desc.toString()).isEqualTo(\"java.util.Map<java.lang.Integer, java.util.List<java.lang.String>>\");\n\t\tassertThat(desc.isPrimitive()).isFalse();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isFalse();\n\t\tassertThat(desc.isArray()).isFalse();\n\t\tassertThat(desc.isMap()).isTrue();\n\t\tassertThat(desc.getMapValueTypeDescriptor()).isEqualTo(TypeDescriptor.nested(methodParameter, 1));\n\t\tassertThat(desc.getMapValueTypeDescriptor().getElementTypeDescriptor()).isEqualTo(TypeDescriptor.nested(methodParameter, 2));\n\t\tassertThat(desc.getMapKeyTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getMapValueTypeDescriptor().getType()).isEqualTo(List.class);\n\t\tassertThat(desc.getMapValueTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid parameterAnnotated() throws Exception {\n\t\tTypeDescriptor t1 = new TypeDescriptor(new MethodParameter(getClass().getMethod(\"testAnnotatedMethod\", String.class), 0));\n\t\tassertThat(t1.getType()).isEqualTo(String.class);\n\t\tassertThat(t1.getAnnotations()).hasSize(1);\n\t\tassertThat(t1.getAnnotation(ParameterAnnotation.class)).isNotNull();\n\t\tassertThat(t1.hasAnnotation(ParameterAnnotation.class)).isTrue();\n\t\tassertThat(t1.getAnnotation(ParameterAnnotation.class).value()).isEqualTo(123);\n\t}\n\n\t@Test\n\tvoid getAnnotationsReturnsClonedArray() throws Exception {\n\t\tTypeDescriptor t = new TypeDescriptor(new MethodParameter(getClass().getMethod(\"testAnnotatedMethod\", String.class), 0));\n\t\tt.getAnnotations()[0] = null;\n\t\tassertThat(t.getAnnotations()[0]).isNotNull();\n\t}\n\n\t@Test\n\tvoid propertyComplex() throws Exception {\n\t\tProperty property = new Property(getClass(), getClass().getMethod(\"getComplexProperty\"),\n\t\t\t\tgetClass().getMethod(\"setComplexProperty\", Map.class));\n\t\tTypeDescriptor desc = new TypeDescriptor(property);\n\t\tassertThat(desc.getMapKeyTypeDescriptor().getType()).isEqualTo(String.class);\n\t\tassertThat(desc.getMapValueTypeDescriptor().getElementTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid propertyGenericType() throws Exception {\n\t\tGenericType<Integer> genericBean = new IntegerType();\n\t\tProperty property = new Property(getClass(), genericBean.getClass().getMethod(\"getProperty\"),\n\t\t\t\tgenericBean.getClass().getMethod(\"setProperty\", Integer.class));\n\t\tTypeDescriptor desc = new TypeDescriptor(property);\n\t\tassertThat(desc.getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid propertyTypeCovariance() throws Exception {\n\t\tGenericType<Number> genericBean = new NumberType();\n\t\tProperty property = new Property(getClass(), genericBean.getClass().getMethod(\"getProperty\"),\n\t\t\t\tgenericBean.getClass().getMethod(\"setProperty\", Number.class));\n\t\tTypeDescriptor desc = new TypeDescriptor(property);\n\t\tassertThat(desc.getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid propertyGenericTypeList() throws Exception {\n\t\tGenericType<Integer> genericBean = new IntegerType();\n\t\tProperty property = new Property(getClass(), genericBean.getClass().getMethod(\"getListProperty\"),\n\t\t\t\tgenericBean.getClass().getMethod(\"setListProperty\", List.class));\n\t\tTypeDescriptor desc = new TypeDescriptor(property);\n\t\tassertThat(desc.getType()).isEqualTo(List.class);\n\t\tassertThat(desc.getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid propertyGenericClassList() throws Exception {\n\t\tIntegerClass genericBean = new IntegerClass();\n\t\tProperty property = new Property(genericBean.getClass(), genericBean.getClass().getMethod(\"getListProperty\"),\n\t\t\t\tgenericBean.getClass().getMethod(\"setListProperty\", List.class));\n\t\tTypeDescriptor desc = new TypeDescriptor(property);\n\t\tassertThat(desc.getType()).isEqualTo(List.class);\n\t\tassertThat(desc.getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getAnnotation(MethodAnnotation1.class)).isNotNull();\n\t\tassertThat(desc.hasAnnotation(MethodAnnotation1.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid property() throws Exception {\n\t\tProperty property = new Property(\n\t\t\t\tgetClass(), getClass().getMethod(\"getProperty\"), getClass().getMethod(\"setProperty\", Map.class));\n\t\tTypeDescriptor desc = new TypeDescriptor(property);\n\t\tassertThat(desc.getType()).isEqualTo(Map.class);\n\t\tassertThat(desc.getMapKeyTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getMapValueTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Long.class);\n\t\tassertThat(desc.getAnnotation(MethodAnnotation1.class)).isNotNull();\n\t\tassertThat(desc.getAnnotation(MethodAnnotation2.class)).isNotNull();\n\t\tassertThat(desc.getAnnotation(MethodAnnotation3.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid getAnnotationOnMethodThatIsLocallyAnnotated() throws Exception {\n\t\tassertAnnotationFoundOnMethod(MethodAnnotation1.class, \"methodWithLocalAnnotation\");\n\t}\n\n\t@Test\n\tvoid getAnnotationOnMethodThatIsMetaAnnotated() throws Exception {\n\t\tassertAnnotationFoundOnMethod(MethodAnnotation1.class, \"methodWithComposedAnnotation\");\n\t}\n\n\t@Test\n\tvoid getAnnotationOnMethodThatIsMetaMetaAnnotated() throws Exception {\n\t\tassertAnnotationFoundOnMethod(MethodAnnotation1.class, \"methodWithComposedComposedAnnotation\");\n\t}\n\n\tprivate void assertAnnotationFoundOnMethod(Class<? extends Annotation> annotationType, String methodName) throws Exception {\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(new MethodParameter(getClass().getMethod(methodName), -1));\n\t\tassertThat(typeDescriptor.getAnnotation(annotationType)).as(\"Should have found @\" + annotationType.getSimpleName() + \" on \" + methodName + \".\").isNotNull();\n\t}\n\n\t@Test\n\tvoid fieldScalar() throws Exception {\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(getClass().getField(\"fieldScalar\"));\n\t\tassertThat(typeDescriptor.isPrimitive()).isFalse();\n\t\tassertThat(typeDescriptor.isArray()).isFalse();\n\t\tassertThat(typeDescriptor.isCollection()).isFalse();\n\t\tassertThat(typeDescriptor.isMap()).isFalse();\n\t\tassertThat(typeDescriptor.getType()).isEqualTo(Integer.class);\n\t\tassertThat(typeDescriptor.getObjectType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid fieldList() throws Exception {\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(TypeDescriptorTests.class.getDeclaredField(\"listOfString\"));\n\t\tassertThat(typeDescriptor.isArray()).isFalse();\n\t\tassertThat(typeDescriptor.getType()).isEqualTo(List.class);\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor().getType()).isEqualTo(String.class);\n\t\tassertThat(typeDescriptor.toString()).isEqualTo(\"java.util.List<java.lang.String>\");\n\t}\n\n\t@Test\n\tvoid fieldListOfListOfString() throws Exception {\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(TypeDescriptorTests.class.getDeclaredField(\"listOfListOfString\"));\n\t\tassertThat(typeDescriptor.isArray()).isFalse();\n\t\tassertThat(typeDescriptor.getType()).isEqualTo(List.class);\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor().getType()).isEqualTo(List.class);\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(String.class);\n\t\tassertThat(typeDescriptor.toString()).isEqualTo(\"java.util.List<java.util.List<java.lang.String>>\");\n\t}\n\n\t@Test\n\tvoid fieldListOfListUnknown() throws Exception {\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(TypeDescriptorTests.class.getDeclaredField(\"listOfListOfUnknown\"));\n\t\tassertThat(typeDescriptor.isArray()).isFalse();\n\t\tassertThat(typeDescriptor.getType()).isEqualTo(List.class);\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor().getType()).isEqualTo(List.class);\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor().getElementTypeDescriptor()).isNull();\n\t\tassertThat(typeDescriptor.toString()).isEqualTo(\"java.util.List<java.util.List<?>>\");\n\t}\n\n\t@Test\n\tvoid fieldArray() throws Exception {\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(TypeDescriptorTests.class.getDeclaredField(\"intArray\"));\n\t\tassertThat(typeDescriptor.isArray()).isTrue();\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor().getType()).isEqualTo(int.class);\n\t\tassertThat(typeDescriptor.toString()).isEqualTo(\"int[]\");\n\t}\n\n\t@Test\n\tvoid fieldComplexTypeDescriptor() throws Exception {\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(TypeDescriptorTests.class.getDeclaredField(\"arrayOfListOfString\"));\n\t\tassertThat(typeDescriptor.isArray()).isTrue();\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor().getType()).isEqualTo(List.class);\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(String.class);\n\t\tassertThat(typeDescriptor.toString()).isEqualTo(\"java.util.List<java.lang.String>[]\");\n\t}\n\n\t@Test\n\tvoid fieldComplexTypeDescriptor2() throws Exception {\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(TypeDescriptorTests.class.getDeclaredField(\"nestedMapField\"));\n\t\tassertThat(typeDescriptor.isMap()).isTrue();\n\t\tassertThat(typeDescriptor.getMapKeyTypeDescriptor().getType()).isEqualTo(String.class);\n\t\tassertThat(typeDescriptor.getMapValueTypeDescriptor().getType()).isEqualTo(List.class);\n\t\tassertThat(typeDescriptor.getMapValueTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(typeDescriptor.toString()).isEqualTo(\"java.util.Map<java.lang.String, java.util.List<java.lang.Integer>>\");\n\t}\n\n\t@Test\n\tvoid fieldMap() throws Exception {\n\t\tTypeDescriptor desc = new TypeDescriptor(TypeDescriptorTests.class.getField(\"fieldMap\"));\n\t\tassertThat(desc.isMap()).isTrue();\n\t\tassertThat(desc.getMapKeyTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getMapValueTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Long.class);\n\t}\n\n\t@Test\n\tvoid fieldAnnotated() throws Exception {\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(getClass().getField(\"fieldAnnotated\"));\n\t\tassertThat(typeDescriptor.getAnnotations()).hasSize(1);\n\t\tassertThat(typeDescriptor.getAnnotation(FieldAnnotation.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid valueOfScalar() {\n\t\tTypeDescriptor typeDescriptor = TypeDescriptor.valueOf(Integer.class);\n\t\tassertThat(typeDescriptor.isPrimitive()).isFalse();\n\t\tassertThat(typeDescriptor.isArray()).isFalse();\n\t\tassertThat(typeDescriptor.isCollection()).isFalse();\n\t\tassertThat(typeDescriptor.isMap()).isFalse();\n\t\tassertThat(typeDescriptor.getType()).isEqualTo(Integer.class);\n\t\tassertThat(typeDescriptor.getObjectType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid valueOfPrimitive() {\n\t\tTypeDescriptor typeDescriptor = TypeDescriptor.valueOf(int.class);\n\t\tassertThat(typeDescriptor.isPrimitive()).isTrue();\n\t\tassertThat(typeDescriptor.isArray()).isFalse();\n\t\tassertThat(typeDescriptor.isCollection()).isFalse();\n\t\tassertThat(typeDescriptor.isMap()).isFalse();\n\t\tassertThat(typeDescriptor.getType()).isEqualTo(int.class);\n\t\tassertThat(typeDescriptor.getObjectType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid valueOfArray() {\n\t\tTypeDescriptor typeDescriptor = TypeDescriptor.valueOf(int[].class);\n\t\tassertThat(typeDescriptor.isArray()).isTrue();\n\t\tassertThat(typeDescriptor.isCollection()).isFalse();\n\t\tassertThat(typeDescriptor.isMap()).isFalse();\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor().getType()).isEqualTo(int.class);\n\t}\n\n\t@Test\n\tvoid valueOfCollection() {\n\t\tTypeDescriptor typeDescriptor = TypeDescriptor.valueOf(Collection.class);\n\t\tassertThat(typeDescriptor.isCollection()).isTrue();\n\t\tassertThat(typeDescriptor.isArray()).isFalse();\n\t\tassertThat(typeDescriptor.isMap()).isFalse();\n\t\tassertThat((Object) typeDescriptor.getElementTypeDescriptor()).isNull();\n\t}\n\n\t@Test\n\tvoid forObject() {\n\t\tTypeDescriptor desc = TypeDescriptor.forObject(\"3\");\n\t\tassertThat(desc.getType()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid forObjectNullTypeDescriptor() {\n\t\tTypeDescriptor desc = TypeDescriptor.forObject(null);\n\t\tassertThat((Object) desc).isNull();\n\t}\n\n\t@Test\n\tvoid nestedMethodParameterType2Levels() throws Exception {\n\t\tTypeDescriptor t1 = TypeDescriptor.nested(new MethodParameter(getClass().getMethod(\"test2\", List.class), 0), 2);\n\t\tassertThat(t1.getType()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid nestedMethodParameterTypeMap() throws Exception {\n\t\tTypeDescriptor t1 = TypeDescriptor.nested(new MethodParameter(getClass().getMethod(\"test3\", Map.class), 0), 1);\n\t\tassertThat(t1.getType()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid nestedMethodParameterTypeMapTwoLevels() throws Exception {\n\t\tTypeDescriptor t1 = TypeDescriptor.nested(new MethodParameter(getClass().getMethod(\"test4\", List.class), 0), 2);\n\t\tassertThat(t1.getType()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid nestedMethodParameterNot1NestedLevel() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tTypeDescriptor.nested(new MethodParameter(getClass().getMethod(\"test4\", List.class), 0, 2), 2));\n\t}\n\n\t@Test\n\tvoid nestedTooManyLevels() throws Exception {\n\t\tTypeDescriptor t1 = TypeDescriptor.nested(new MethodParameter(getClass().getMethod(\"test4\", List.class), 0), 3);\n\t\tassertThat((Object) t1).isNull();\n\t}\n\n\t@Test\n\tvoid nestedMethodParameterTypeNotNestable() throws Exception {\n\t\tTypeDescriptor t1 = TypeDescriptor.nested(new MethodParameter(getClass().getMethod(\"test5\", String.class), 0), 2);\n\t\tassertThat((Object) t1).isNull();\n\t}\n\n\t@Test\n\tvoid nestedMethodParameterTypeInvalidNestingLevel() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tTypeDescriptor.nested(new MethodParameter(getClass().getMethod(\"test5\", String.class), 0, 2), 2));\n\t}\n\n\t@Test\n\tvoid nestedNotParameterized() throws Exception {\n\t\tTypeDescriptor t1 = TypeDescriptor.nested(new MethodParameter(getClass().getMethod(\"test6\", List.class), 0), 1);\n\t\tassertThat(t1.getType()).isEqualTo(List.class);\n\t\tassertThat(t1.toString()).isEqualTo(\"java.util.List<?>\");\n\t\tTypeDescriptor t2 = TypeDescriptor.nested(new MethodParameter(getClass().getMethod(\"test6\", List.class), 0), 2);\n\t\tassertThat((Object) t2).isNull();\n\t}\n\n\t@Test\n\tvoid nestedFieldTypeMapTwoLevels() throws Exception {\n\t\tTypeDescriptor t1 = TypeDescriptor.nested(getClass().getField(\"test4\"), 2);\n\t\tassertThat(t1.getType()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid nestedPropertyTypeMapTwoLevels() throws Exception {\n\t\tProperty property = new Property(getClass(), getClass().getMethod(\"getTest4\"), getClass().getMethod(\"setTest4\", List.class));\n\t\tTypeDescriptor t1 = TypeDescriptor.nested(property, 2);\n\t\tassertThat(t1.getType()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid collection() {\n\t\tTypeDescriptor desc = TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(Integer.class));\n\t\tassertThat(desc.getType()).isEqualTo(List.class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(List.class);\n\t\tassertThat(desc.getName()).isEqualTo(\"java.util.List\");\n\t\tassertThat(desc.toString()).isEqualTo(\"java.util.List<java.lang.Integer>\");\n\t\tassertThat(desc.isPrimitive()).isFalse();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isTrue();\n\t\tassertThat(desc.isArray()).isFalse();\n\t\tassertThat(desc.getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getElementTypeDescriptor()).isEqualTo(TypeDescriptor.valueOf(Integer.class));\n\t\tassertThat(desc.isMap()).isFalse();\n\t}\n\n\t@Test\n\tvoid collectionNested() {\n\t\tTypeDescriptor desc = TypeDescriptor.collection(List.class, TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(Integer.class)));\n\t\tassertThat(desc.getType()).isEqualTo(List.class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(List.class);\n\t\tassertThat(desc.getName()).isEqualTo(\"java.util.List\");\n\t\tassertThat(desc.toString()).isEqualTo(\"java.util.List<java.util.List<java.lang.Integer>>\");\n\t\tassertThat(desc.isPrimitive()).isFalse();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isTrue();\n\t\tassertThat(desc.isArray()).isFalse();\n\t\tassertThat(desc.getElementTypeDescriptor().getType()).isEqualTo(List.class);\n\t\tassertThat(desc.getElementTypeDescriptor().getElementTypeDescriptor()).isEqualTo(TypeDescriptor.valueOf(Integer.class));\n\t\tassertThat(desc.isMap()).isFalse();\n\t}\n\n\t@Test\n\tvoid map() {\n\t\tTypeDescriptor desc = TypeDescriptor.map(Map.class, TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(Integer.class));\n\t\tassertThat(desc.getType()).isEqualTo(Map.class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(Map.class);\n\t\tassertThat(desc.getName()).isEqualTo(\"java.util.Map\");\n\t\tassertThat(desc.toString()).isEqualTo(\"java.util.Map<java.lang.String, java.lang.Integer>\");\n\t\tassertThat(desc.isPrimitive()).isFalse();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isFalse();\n\t\tassertThat(desc.isArray()).isFalse();\n\t\tassertThat(desc.isMap()).isTrue();\n\t\tassertThat(desc.getMapKeyTypeDescriptor().getType()).isEqualTo(String.class);\n\t\tassertThat(desc.getMapValueTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid mapNested() {\n\t\tTypeDescriptor desc = TypeDescriptor.map(Map.class, TypeDescriptor.valueOf(String.class),\n\t\t\t\tTypeDescriptor.map(Map.class, TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(Integer.class)));\n\t\tassertThat(desc.getType()).isEqualTo(Map.class);\n\t\tassertThat(desc.getObjectType()).isEqualTo(Map.class);\n\t\tassertThat(desc.getName()).isEqualTo(\"java.util.Map\");\n\t\tassertThat(desc.toString()).isEqualTo(\"java.util.Map<java.lang.String, java.util.Map<java.lang.String, java.lang.Integer>>\");\n\t\tassertThat(desc.isPrimitive()).isFalse();\n\t\tassertThat(desc.getAnnotations()).isEmpty();\n\t\tassertThat(desc.isCollection()).isFalse();\n\t\tassertThat(desc.isArray()).isFalse();\n\t\tassertThat(desc.isMap()).isTrue();\n\t\tassertThat(desc.getMapKeyTypeDescriptor().getType()).isEqualTo(String.class);\n\t\tassertThat(desc.getMapValueTypeDescriptor().getMapKeyTypeDescriptor().getType()).isEqualTo(String.class);\n\t\tassertThat(desc.getMapValueTypeDescriptor().getMapValueTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid narrow() {\n\t\tTypeDescriptor desc = TypeDescriptor.valueOf(Number.class);\n\t\tInteger value = 3;\n\t\tdesc = desc.narrow(value);\n\t\tassertThat(desc.getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid elementType() {\n\t\tTypeDescriptor desc = TypeDescriptor.valueOf(List.class);\n\t\tInteger value = 3;\n\t\tdesc = desc.elementTypeDescriptor(value);\n\t\tassertThat(desc.getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid elementTypePreserveContext() throws Exception {\n\t\tTypeDescriptor desc = new TypeDescriptor(getClass().getField(\"listPreserveContext\"));\n\t\tassertThat(desc.getElementTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tList<Integer> value = new ArrayList<>(3);\n\t\tdesc = desc.elementTypeDescriptor(value);\n\t\tassertThat(desc.getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getAnnotation(FieldAnnotation.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid mapKeyType() {\n\t\tTypeDescriptor desc = TypeDescriptor.valueOf(Map.class);\n\t\tInteger value = 3;\n\t\tdesc = desc.getMapKeyTypeDescriptor(value);\n\t\tassertThat(desc.getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid mapKeyTypePreserveContext() throws Exception {\n\t\tTypeDescriptor desc = new TypeDescriptor(getClass().getField(\"mapPreserveContext\"));\n\t\tassertThat(desc.getMapKeyTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tList<Integer> value = new ArrayList<>(3);\n\t\tdesc = desc.getMapKeyTypeDescriptor(value);\n\t\tassertThat(desc.getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getAnnotation(FieldAnnotation.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid mapValueType() {\n\t\tTypeDescriptor desc = TypeDescriptor.valueOf(Map.class);\n\t\tInteger value = 3;\n\t\tdesc = desc.getMapValueTypeDescriptor(value);\n\t\tassertThat(desc.getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid mapValueTypePreserveContext() throws Exception {\n\t\tTypeDescriptor desc = new TypeDescriptor(getClass().getField(\"mapPreserveContext\"));\n\t\tassertThat(desc.getMapValueTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tList<Integer> value = new ArrayList<>(3);\n\t\tdesc = desc.getMapValueTypeDescriptor(value);\n\t\tassertThat(desc.getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t\tassertThat(desc.getAnnotation(FieldAnnotation.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid equality() throws Exception {\n\t\tTypeDescriptor t1 = TypeDescriptor.valueOf(String.class);\n\t\tTypeDescriptor t2 = TypeDescriptor.valueOf(String.class);\n\t\tTypeDescriptor t3 = TypeDescriptor.valueOf(Date.class);\n\t\tTypeDescriptor t4 = TypeDescriptor.valueOf(Date.class);\n\t\tTypeDescriptor t5 = TypeDescriptor.valueOf(List.class);\n\t\tTypeDescriptor t6 = TypeDescriptor.valueOf(List.class);\n\t\tTypeDescriptor t7 = TypeDescriptor.valueOf(Map.class);\n\t\tTypeDescriptor t8 = TypeDescriptor.valueOf(Map.class);\n\t\tassertThat(t2).isEqualTo(t1);\n\t\tassertThat(t4).isEqualTo(t3);\n\t\tassertThat(t6).isEqualTo(t5);\n\t\tassertThat(t8).isEqualTo(t7);\n\n\t\tTypeDescriptor t9 = new TypeDescriptor(getClass().getField(\"listField\"));\n\t\tTypeDescriptor t10 = new TypeDescriptor(getClass().getField(\"listField\"));\n\t\tassertThat(t10).isEqualTo(t9);\n\n\t\tTypeDescriptor t11 = new TypeDescriptor(getClass().getField(\"mapField\"));\n\t\tTypeDescriptor t12 = new TypeDescriptor(getClass().getField(\"mapField\"));\n\t\tassertThat(t12).isEqualTo(t11);\n\n\t\tMethodParameter testAnnotatedMethod = new MethodParameter(getClass().getMethod(\"testAnnotatedMethod\", String.class), 0);\n\t\tTypeDescriptor t13 = new TypeDescriptor(testAnnotatedMethod);\n\t\tTypeDescriptor t14 = new TypeDescriptor(testAnnotatedMethod);\n\t\tassertThat(t14).isEqualTo(t13);\n\n\t\tTypeDescriptor t15 = new TypeDescriptor(testAnnotatedMethod);\n\t\tTypeDescriptor t16 = new TypeDescriptor(new MethodParameter(getClass().getMethod(\"testAnnotatedMethodDifferentAnnotationValue\", String.class), 0));\n\t\tassertThat(t16).isNotEqualTo(t15);\n\n\t\tTypeDescriptor t17 = new TypeDescriptor(testAnnotatedMethod);\n\t\tTypeDescriptor t18 = new TypeDescriptor(new MethodParameter(getClass().getMethod(\"test5\", String.class), 0));\n\t\tassertThat(t18).isNotEqualTo(t17);\n\t}\n\n\t@Test\n\tvoid isAssignableTypes() {\n\t\tassertThat(TypeDescriptor.valueOf(Integer.class).isAssignableTo(TypeDescriptor.valueOf(Number.class))).isTrue();\n\t\tassertThat(TypeDescriptor.valueOf(Number.class).isAssignableTo(TypeDescriptor.valueOf(Integer.class))).isFalse();\n\t\tassertThat(TypeDescriptor.valueOf(String.class).isAssignableTo(TypeDescriptor.valueOf(String[].class))).isFalse();\n\t}\n\n\t@Test\n\tvoid isAssignableElementTypes() throws Exception {\n\t\tassertThat(new TypeDescriptor(getClass().getField(\"listField\")).isAssignableTo(new TypeDescriptor(getClass().getField(\"listField\")))).isTrue();\n\t\tassertThat(new TypeDescriptor(getClass().getField(\"notGenericList\")).isAssignableTo(new TypeDescriptor(getClass().getField(\"listField\")))).isTrue();\n\t\tassertThat(new TypeDescriptor(getClass().getField(\"listField\")).isAssignableTo(new TypeDescriptor(getClass().getField(\"notGenericList\")))).isTrue();\n\t\tassertThat(new TypeDescriptor(getClass().getField(\"isAssignableElementTypes\")).isAssignableTo(new TypeDescriptor(getClass().getField(\"listField\")))).isFalse();\n\t\tassertThat(TypeDescriptor.valueOf(List.class).isAssignableTo(new TypeDescriptor(getClass().getField(\"listField\")))).isTrue();\n\t}\n\n\t@Test\n\tvoid isAssignableMapKeyValueTypes() throws Exception {\n\t\tassertThat(new TypeDescriptor(getClass().getField(\"mapField\")).isAssignableTo(new TypeDescriptor(getClass().getField(\"mapField\")))).isTrue();\n\t\tassertThat(new TypeDescriptor(getClass().getField(\"notGenericMap\")).isAssignableTo(new TypeDescriptor(getClass().getField(\"mapField\")))).isTrue();\n\t\tassertThat(new TypeDescriptor(getClass().getField(\"mapField\")).isAssignableTo(new TypeDescriptor(getClass().getField(\"notGenericMap\")))).isTrue();\n\t\tassertThat(new TypeDescriptor(getClass().getField(\"isAssignableMapKeyValueTypes\")).isAssignableTo(new TypeDescriptor(getClass().getField(\"mapField\")))).isFalse();\n\t\tassertThat(TypeDescriptor.valueOf(Map.class).isAssignableTo(new TypeDescriptor(getClass().getField(\"mapField\")))).isTrue();\n\t}\n\n\t@Test\n\tvoid multiValueMap() throws Exception {\n\t\tTypeDescriptor td = new TypeDescriptor(getClass().getField(\"multiValueMap\"));\n\t\tassertThat(td.isMap()).isTrue();\n\t\tassertThat(td.getMapKeyTypeDescriptor().getType()).isEqualTo(String.class);\n\t\tassertThat(td.getMapValueTypeDescriptor().getType()).isEqualTo(List.class);\n\t\tassertThat(td.getMapValueTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid passDownGeneric() throws Exception {\n\t\tTypeDescriptor td = new TypeDescriptor(getClass().getField(\"passDownGeneric\"));\n\t\tassertThat(td.getElementTypeDescriptor().getType()).isEqualTo(List.class);\n\t\tassertThat(td.getElementTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Set.class);\n\t\tassertThat(td.getElementTypeDescriptor().getElementTypeDescriptor().getElementTypeDescriptor().getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid upcast() throws Exception {\n\t\tProperty property = new Property(getClass(), getClass().getMethod(\"getProperty\"),\n\t\t\t\tgetClass().getMethod(\"setProperty\", Map.class));\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(property);\n\t\tTypeDescriptor upcast = typeDescriptor.upcast(Object.class);\n\t\tassertThat(upcast.getAnnotation(MethodAnnotation1.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid upCastNotSuper() throws Exception {\n\t\tProperty property = new Property(getClass(), getClass().getMethod(\"getProperty\"),\n\t\t\t\tgetClass().getMethod(\"setProperty\", Map.class));\n\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(property);\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\ttypeDescriptor.upcast(Collection.class))\n\t\t\t.withMessage(\"interface java.util.Map is not assignable to interface java.util.Collection\");\n\t}\n\n\t@Test\n\tvoid elementTypeForCollectionSubclass() {\n\t\t@SuppressWarnings(\"serial\")\n\t\tclass CustomSet extends HashSet<String> {\n\t\t}\n\n\t\tassertThat(TypeDescriptor.valueOf(String.class)).isEqualTo(TypeDescriptor.valueOf(CustomSet.class).getElementTypeDescriptor());\n\t\tassertThat(TypeDescriptor.valueOf(String.class)).isEqualTo(TypeDescriptor.forObject(new CustomSet()).getElementTypeDescriptor());\n\t}\n\n\t@Test\n\tvoid elementTypeForMapSubclass() {\n\t\t@SuppressWarnings(\"serial\")\n\t\tclass CustomMap extends HashMap<String, Integer> {\n\t\t}\n\n\t\tassertThat(TypeDescriptor.valueOf(String.class)).isEqualTo(TypeDescriptor.valueOf(CustomMap.class).getMapKeyTypeDescriptor());\n\t\tassertThat(TypeDescriptor.valueOf(Integer.class)).isEqualTo(TypeDescriptor.valueOf(CustomMap.class).getMapValueTypeDescriptor());\n\t\tassertThat(TypeDescriptor.valueOf(String.class)).isEqualTo(TypeDescriptor.forObject(new CustomMap()).getMapKeyTypeDescriptor());\n\t\tassertThat(TypeDescriptor.valueOf(Integer.class)).isEqualTo(TypeDescriptor.forObject(new CustomMap()).getMapValueTypeDescriptor());\n\t}\n\n\t@Test\n\tvoid createMapArray() {\n\t\tTypeDescriptor mapType = TypeDescriptor.map(\n\t\t\t\tLinkedHashMap.class, TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(Integer.class));\n\t\tTypeDescriptor arrayType = TypeDescriptor.array(mapType);\n\t\tassertThat(LinkedHashMap[].class).isEqualTo(arrayType.getType());\n\t\tassertThat(mapType).isEqualTo(arrayType.getElementTypeDescriptor());\n\t}\n\n\t@Test\n\tvoid createStringArray() {\n\t\tTypeDescriptor arrayType = TypeDescriptor.array(TypeDescriptor.valueOf(String.class));\n\t\tassertThat(TypeDescriptor.valueOf(String[].class)).isEqualTo(arrayType);\n\t}\n\n\t@Test\n\tvoid createNullArray() {\n\t\tassertThat((Object) TypeDescriptor.array(null)).isNull();\n\t}\n\n\t@Test\n\tvoid serializable() throws Exception {\n\t\tTypeDescriptor typeDescriptor = TypeDescriptor.forObject(\"\");\n\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\tObjectOutputStream outputStream = new ObjectOutputStream(out);\n\t\toutputStream.writeObject(typeDescriptor);\n\t\tObjectInputStream inputStream = new ObjectInputStream(new ByteArrayInputStream(\n\t\t\t\tout.toByteArray()));\n\t\tTypeDescriptor readObject = (TypeDescriptor) inputStream.readObject();\n\t\tassertThat(readObject).isEqualTo(typeDescriptor);\n\t}\n\n\t@Test\n\tvoid createCollectionWithNullElement() {\n\t\tTypeDescriptor typeDescriptor = TypeDescriptor.collection(List.class, null);\n\t\tassertThat(typeDescriptor.getElementTypeDescriptor()).isNull();\n\t}\n\n\t@Test\n\tvoid createMapWithNullElements() {\n\t\tTypeDescriptor typeDescriptor = TypeDescriptor.map(LinkedHashMap.class, null, null);\n\t\tassertThat(typeDescriptor.getMapKeyTypeDescriptor()).isNull();\n\t\tassertThat(typeDescriptor.getMapValueTypeDescriptor()).isNull();\n\t}\n\n\t@Test\n\tvoid getSource() throws Exception {\n\t\tField field = getClass().getField(\"fieldScalar\");\n\t\tMethodParameter methodParameter = new MethodParameter(getClass().getMethod(\"testParameterPrimitive\", int.class), 0);\n\t\tassertThat(new TypeDescriptor(field).getSource()).isEqualTo(field);\n\t\tassertThat(new TypeDescriptor(methodParameter).getSource()).isEqualTo(methodParameter);\n\t\tassertThat(TypeDescriptor.valueOf(Integer.class).getSource()).isEqualTo(Integer.class);\n\t}\n\n\t@Test  // gh-31672\n\tvoid equalityWithGenerics() {\n\t\tResolvableType rt1 = ResolvableType.forClassWithGenerics(Optional.class, Integer.class);\n\t\tResolvableType rt2 = ResolvableType.forClassWithGenerics(Optional.class, String.class);\n\n\t\tTypeDescriptor td1 = new TypeDescriptor(rt1, null, null);\n\t\tTypeDescriptor td2 = new TypeDescriptor(rt2, null, null);\n\n\t\tassertThat(td1).isNotEqualTo(td2);\n\t}\n\n\t@Test  // gh-33932\n\tvoid recursiveType() {\n\t\tassertThat(TypeDescriptor.valueOf(RecursiveMap.class)).isEqualTo(\n\t\t\t\tTypeDescriptor.valueOf(RecursiveMap.class));\n\n\t\tTypeDescriptor typeDescriptor1 = TypeDescriptor.map(Map.class,\n\t\t\t\tTypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(RecursiveMap.class));\n\t\tTypeDescriptor typeDescriptor2 = TypeDescriptor.map(Map.class,\n\t\t\t\tTypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(RecursiveMap.class));\n\t\tassertThat(typeDescriptor1).isEqualTo(typeDescriptor2);\n\t}\n\n\t@Test  // gh-33932\n\tvoid recursiveTypeWithInterface() {\n\t\tassertThat(TypeDescriptor.valueOf(RecursiveMapWithInterface.class)).isEqualTo(\n\t\t\t\tTypeDescriptor.valueOf(RecursiveMapWithInterface.class));\n\n\t\tTypeDescriptor typeDescriptor1 = TypeDescriptor.map(Map.class,\n\t\t\t\tTypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(RecursiveMapWithInterface.class));\n\t\tTypeDescriptor typeDescriptor2 = TypeDescriptor.map(Map.class,\n\t\t\t\tTypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(RecursiveMapWithInterface.class));\n\t\tassertThat(typeDescriptor1).isEqualTo(typeDescriptor2);\n\t}\n\n\n\t// Methods designed for test introspection\n\n\tpublic void testParameterPrimitive(int primitive) {\n\t}\n\n\tpublic void testParameterScalar(String value) {\n\t}\n\n\tpublic void testParameterList(List<List<Map<Integer, Enum<?>>>> list) {\n\t}\n\n\tpublic void testParameterListNoParamTypes(List list) {\n\t}\n\n\tpublic void testParameterArray(Integer[] array) {\n\t}\n\n\tpublic void testParameterMap(Map<Integer, List<String>> map) {\n\t}\n\n\tpublic void test1(List<String> param1) {\n\t}\n\n\tpublic void test2(List<List<String>> param1) {\n\t}\n\n\tpublic void test3(Map<Integer, String> param1) {\n\t}\n\n\tpublic void test4(List<Map<Integer, String>> param1) {\n\t}\n\n\tpublic void test5(String param1) {\n\t}\n\n\tpublic void test6(List<List> param1) {\n\t}\n\n\tpublic List<Map<Integer, String>> getTest4() {\n\t\treturn null;\n\t}\n\n\tpublic void setTest4(List<Map<Integer, String>> test4) {\n\t}\n\n\tpublic Map<String, List<List<Integer>>> getComplexProperty() {\n\t\treturn null;\n\t}\n\n\t@MethodAnnotation1\n\tpublic Map<List<Integer>, List<Long>> getProperty() {\n\t\treturn property;\n\t}\n\n\t@MethodAnnotation2\n\tpublic void setProperty(Map<List<Integer>, List<Long>> property) {\n\t\tthis.property = property;\n\t}\n\n\t@MethodAnnotation1\n\tpublic void methodWithLocalAnnotation() {\n\t}\n\n\t@ComposedMethodAnnotation1\n\tpublic void methodWithComposedAnnotation() {\n\t}\n\n\t@ComposedComposedMethodAnnotation1\n\tpublic void methodWithComposedComposedAnnotation() {\n\t}\n\n\tpublic void setComplexProperty(Map<String, List<List<Integer>>> complexProperty) {\n\t}\n\n\tpublic void testAnnotatedMethod(@ParameterAnnotation(123) String parameter) {\n\t}\n\n\tpublic void testAnnotatedMethodDifferentAnnotationValue(@ParameterAnnotation(567) String parameter) {\n\t}\n\n\n\t// Fields designed for test introspection\n\n\tpublic Integer fieldScalar;\n\n\tpublic List<String> listOfString;\n\n\tpublic List<List<String>> listOfListOfString = new ArrayList<>();\n\n\tpublic List<List> listOfListOfUnknown = new ArrayList<>();\n\n\tpublic int[] intArray;\n\n\tpublic List<String>[] arrayOfListOfString;\n\n\tpublic List<Integer> listField = new ArrayList<>();\n\n\tpublic Map<String, Integer> mapField = new HashMap<>();\n\n\tpublic Map<String, List<Integer>> nestedMapField = new HashMap<>();\n\n\tpublic Map<List<Integer>, List<Long>> fieldMap;\n\n\tpublic List<Map<Integer, String>> test4;\n\n\t@FieldAnnotation\n\tpublic List<String> fieldAnnotated;\n\n\t@FieldAnnotation\n\tpublic List<List<Integer>> listPreserveContext;\n\n\t@FieldAnnotation\n\tpublic Map<List<Integer>, List<Integer>> mapPreserveContext;\n\n\t@MethodAnnotation3\n\tprivate Map<List<Integer>, List<Long>> property;\n\n\tpublic List notGenericList;\n\n\tpublic List<Number> isAssignableElementTypes;\n\n\tpublic Map notGenericMap;\n\n\tpublic Map<CharSequence, Number> isAssignableMapKeyValueTypes;\n\n\tpublic MultiValueMap<String, Integer> multiValueMap = new LinkedMultiValueMap<>();\n\n\tpublic PassDownGeneric<Integer> passDownGeneric = new PassDownGeneric<>();\n\n\n\t// Classes designed for test introspection\n\n\t@SuppressWarnings(\"serial\")\n\tpublic static class PassDownGeneric<T> extends ArrayList<List<Set<T>>> {\n\t}\n\n\n\tpublic static class GenericClass<T> {\n\n\t\tpublic T getProperty() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void setProperty(T t) {\n\t\t}\n\n\t\t@MethodAnnotation1\n\t\tpublic List<T> getListProperty() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void setListProperty(List<T> t) {\n\t\t}\n\t}\n\n\n\tpublic static class IntegerClass extends GenericClass<Integer> {\n\t}\n\n\n\tpublic interface GenericType<T> {\n\n\t\tT getProperty();\n\n\t\tvoid setProperty(T t);\n\n\t\tList<T> getListProperty();\n\n\t\tvoid setListProperty(List<T> t);\n\t}\n\n\n\tpublic class IntegerType implements GenericType<Integer> {\n\n\t\t@Override\n\t\tpublic Integer getProperty() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void setProperty(Integer t) {\n\t\t}\n\n\t\t@Override\n\t\tpublic List<Integer> getListProperty() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void setListProperty(List<Integer> t) {\n\t\t}\n\t}\n\n\n\tpublic class NumberType implements GenericType<Number> {\n\n\t\t@Override\n\t\tpublic Integer getProperty() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void setProperty(Number t) {\n\t\t}\n\n\t\t@Override\n\t\tpublic List<Number> getListProperty() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void setListProperty(List<Number> t) {\n\t\t}\n\t}\n\n\n\t@SuppressWarnings(\"serial\")\n\tstatic class RecursiveMap extends HashMap<String, RecursiveMap> {\n\t}\n\n\t@SuppressWarnings(\"serial\")\n\tstatic class RecursiveMapWithInterface extends HashMap<String, RecursiveMapWithInterface>\n\t\t\timplements Map<String, RecursiveMapWithInterface> {\n\t}\n\n\n\t// Annotations used on tested elements\n\n\t@Target({ElementType.PARAMETER})\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface ParameterAnnotation {\n\n\t\tint value();\n\t}\n\n\n\t@Target({ElementType.FIELD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface FieldAnnotation {\n\t}\n\n\n\t@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface MethodAnnotation1 {\n\t}\n\n\n\t@Target({ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface MethodAnnotation2 {\n\t}\n\n\n\t@Target({ElementType.FIELD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface MethodAnnotation3 {\n\t}\n\n\n\t@MethodAnnotation1\n\t@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface ComposedMethodAnnotation1 {\n\t}\n\n\n\t@ComposedMethodAnnotation1\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface ComposedComposedMethodAnnotation1 {\n\t}\n\n}\n",
    "tailType": "class_code"
  }
]