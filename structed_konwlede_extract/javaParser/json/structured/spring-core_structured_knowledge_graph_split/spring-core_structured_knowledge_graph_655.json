[
  {
    "head": "org.springframework.cglib.proxy.MethodInterceptorGenerator#generateFindProxy(ClassEmitter,Map)",
    "headType": "method",
    "relation": "provide",
    "tail": "public void generateFindProxy(ClassEmitter ce, final Map sigMap) {\r\n    final CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC | Constants.ACC_STATIC, FIND_PROXY, null);\r\n    e.load_arg(0);\r\n    e.invoke_virtual(Constants.TYPE_OBJECT, TO_STRING);\r\n    ObjectSwitchCallback callback = new ObjectSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(Object key, Label end) {\r\n            e.getfield((String) sigMap.get(key));\r\n            e.return_value();\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            e.aconst_null();\r\n            e.return_value();\r\n        }\r\n    };\r\n    EmitUtils.string_switch(e, (String[]) sigMap.keySet().toArray(new String[0]), Constants.SWITCH_STYLE_HASH, callback);\r\n    e.end_method();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.cglib.proxy.MethodInterceptorGenerator",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.cglib.proxy.MethodInterceptorGenerator#generateFindProxy(ClassEmitter,Map)",
    "tailType": "method"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.cglib.proxy",
    "tailType": "package"
  },
  {
    "head": "org.springframework.cglib.proxy",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.cglib.proxy.MethodProxy",
    "tailType": "class"
  },
  {
    "head": "org.springframework.cglib.proxy.MethodProxy",
    "headType": "class",
    "relation": "use",
    "tail": "@SuppressWarnings",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.cglib.proxy.MethodProxy",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2003,2004 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.cglib.proxy;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\nimport org.springframework.cglib.core.AbstractClassGenerator;\nimport org.springframework.cglib.core.CodeGenerationException;\nimport org.springframework.cglib.core.GeneratorStrategy;\nimport org.springframework.cglib.core.NamingPolicy;\nimport org.springframework.cglib.core.Signature;\nimport org.springframework.cglib.reflect.FastClass;\n\n/**\n * Classes generated by {@link Enhancer} pass this object to the\n * registered {@link MethodInterceptor} objects when an intercepted method is invoked. It can\n * be used to either invoke the original method, or call the same method on a different\n * object of the same type.\n * @version $Id: MethodProxy.java,v 1.16 2009/01/11 20:09:48 herbyderby Exp $\n */\n@SuppressWarnings({\"rawtypes\", \"unchecked\"})\npublic class MethodProxy {\n\n\tprivate Signature sig1;\n\n\tprivate Signature sig2;\n\n\tprivate CreateInfo createInfo;\n\n\tprivate final Object initLock = new Object();\n\n\tprivate volatile FastClassInfo fastClassInfo;\n\n\t/**\n\t * For internal use by {@link Enhancer} only; see the {@link org.springframework.cglib.reflect.FastMethod} class\n\t * for similar functionality.\n\t */\n\tpublic static MethodProxy create(Class c1, Class c2, String desc, String name1, String name2) {\n\t\tMethodProxy proxy = new MethodProxy();\n\t\tproxy.sig1 = new Signature(name1, desc);\n\t\tproxy.sig2 = new Signature(name2, desc);\n\t\tproxy.createInfo = new CreateInfo(c1, c2);\n\n\t\t// SPRING PATCH BEGIN\n\t\tif (c1 != Object.class && c1.isAssignableFrom(c2.getSuperclass()) && !Factory.class.isAssignableFrom(c2)) {\n\t\t\t// Try early initialization for overridden methods on specifically purposed subclasses\n\t\t\ttry {\n\t\t\t\tproxy.init();\n\t\t\t}\n\t\t\tcatch (CodeGenerationException ex) {\n\t\t\t\t// Ignore - to be retried when actually needed later on (possibly not at all)\n\t\t\t}\n\t\t}\n\t\t// SPRING PATCH END\n\n\t\treturn proxy;\n\t}\n\n\tprivate void init() {\n\t\t/*\n\t\t * Using a volatile invariant allows us to initialize the FastClass and\n\t\t * method index pairs atomically.\n\t\t *\n\t\t * Double-checked locking is safe with volatile in Java 5.  Before 1.5 this\n\t\t * code could allow fastClassInfo to be instantiated more than once, which\n\t\t * appears to be benign.\n\t\t */\n\t\tif (fastClassInfo == null) {\n\t\t\tsynchronized (initLock) {\n\t\t\t\tif (fastClassInfo == null) {\n\t\t\t\t\tCreateInfo ci = createInfo;\n\n\t\t\t\t\tFastClassInfo fci = new FastClassInfo();\n\t\t\t\t\tfci.f1 = helper(ci, ci.c1);\n\t\t\t\t\tfci.f2 = helper(ci, ci.c2);\n\t\t\t\t\tfci.i1 = fci.f1.getIndex(sig1);\n\t\t\t\t\tfci.i2 = fci.f2.getIndex(sig2);\n\t\t\t\t\tfastClassInfo = fci;\n\t\t\t\t\tcreateInfo = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate static class FastClassInfo {\n\n\t\tFastClass f1;\n\n\t\tFastClass f2;\n\n\t\tint i1;\n\n\t\tint i2;\n\t}\n\n\n\tprivate static class CreateInfo {\n\n\t\tClass c1;\n\n\t\tClass c2;\n\n\t\tNamingPolicy namingPolicy;\n\n\t\tGeneratorStrategy strategy;\n\n\t\tboolean attemptLoad;\n\n\t\tpublic CreateInfo(Class c1, Class c2) {\n\t\t\tthis.c1 = c1;\n\t\t\tthis.c2 = c2;\n\t\t\tAbstractClassGenerator fromEnhancer = AbstractClassGenerator.getCurrent();\n\t\t\tif (fromEnhancer != null) {\n\t\t\t\tnamingPolicy = fromEnhancer.getNamingPolicy();\n\t\t\t\tstrategy = fromEnhancer.getStrategy();\n\t\t\t\tattemptLoad = fromEnhancer.getAttemptLoad();\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate static FastClass helper(CreateInfo ci, Class type) {\n\t\tFastClass.Generator g = new FastClass.Generator();\n\t\tg.setType(type);\n\t\t// SPRING PATCH BEGIN\n\t\tg.setContextClass(type);\n\t\t// SPRING PATCH END\n\t\tg.setClassLoader(ci.c2.getClassLoader());\n\t\tg.setNamingPolicy(ci.namingPolicy);\n\t\tg.setStrategy(ci.strategy);\n\t\tg.setAttemptLoad(ci.attemptLoad);\n\t\treturn g.create();\n\t}\n\n\tprivate MethodProxy() {\n\t}\n\n\t/**\n\t * Return the signature of the proxied method.\n\t */\n\tpublic Signature getSignature() {\n\t\treturn sig1;\n\t}\n\n\t/**\n\t * Return the name of the synthetic method created by CGLIB which is\n\t * used by {@link #invokeSuper} to invoke the superclass\n\t * (non-intercepted) method implementation. The parameter types are\n\t * the same as the proxied method.\n\t */\n\tpublic String getSuperName() {\n\t\treturn sig2.getName();\n\t}\n\n\t/**\n\t * Return the {@link org.springframework.cglib.reflect.FastClass} method index\n\t * for the method used by {@link #invokeSuper}. This index uniquely\n\t * identifies the method within the generated proxy, and therefore\n\t * can be useful to reference external metadata.\n\t * @see #getSuperName\n\t */\n\tpublic int getSuperIndex() {\n\t\tinit();\n\t\treturn fastClassInfo.i2;\n\t}\n\n\t// For testing\n\tFastClass getFastClass() {\n\t\tinit();\n\t\treturn fastClassInfo.f1;\n\t}\n\n\t// For testing\n\tFastClass getSuperFastClass() {\n\t\tinit();\n\t\treturn fastClassInfo.f2;\n\t}\n\n\t/**\n\t * Return the <code>MethodProxy</code> used when intercepting the method\n\t * matching the given signature.\n\t * @param type the class generated by Enhancer\n\t * @param sig the signature to match\n\t * @return the MethodProxy instance, or null if no applicable matching method is found\n\t * @throws IllegalArgumentException if the Class was not created by Enhancer or does not use a MethodInterceptor\n\t */\n\tpublic static MethodProxy find(Class type, Signature sig) {\n\t\ttry {\n\t\t\tMethod m = type.getDeclaredMethod(MethodInterceptorGenerator.FIND_PROXY_NAME,\n\t\t\t\t\tMethodInterceptorGenerator.FIND_PROXY_TYPES);\n\t\t\treturn (MethodProxy) m.invoke(null, new Object[]{sig});\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\tthrow new IllegalArgumentException(\"Class \" + type + \" does not use a MethodInterceptor\");\n\t\t}\n\t\tcatch (IllegalAccessException | InvocationTargetException ex) {\n\t\t\tthrow new CodeGenerationException(ex);\n\t\t}\n\t}\n\n\t/**\n\t * Invoke the original method, on a different object of the same type.\n\t * @param obj the compatible object; recursion will result if you use the object passed as the first\n\t * argument to the MethodInterceptor (usually not what you want)\n\t * @param args the arguments passed to the intercepted method; you may substitute a different\n\t * argument array as long as the types are compatible\n\t * @throws Throwable the bare exceptions thrown by the called method are passed through\n\t * without wrapping in an <code>InvocationTargetException</code>\n\t * @see MethodInterceptor#intercept\n\t */\n\tpublic Object invoke(Object obj, Object[] args) throws Throwable {\n\t\ttry {\n\t\t\tinit();\n\t\t\tFastClassInfo fci = fastClassInfo;\n\t\t\treturn fci.f1.invoke(fci.i1, obj, args);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tthrow ex.getTargetException();\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tif (fastClassInfo.i1 < 0) {\n\t\t\t\tthrow new IllegalArgumentException(\"Protected method: \" + sig1);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\t/**\n\t * Invoke the original (super) method on the specified object.\n\t * @param obj the enhanced object, must be the object passed as the first\n\t * argument to the MethodInterceptor\n\t * @param args the arguments passed to the intercepted method; you may substitute a different\n\t * argument array as long as the types are compatible\n\t * @throws Throwable the bare exceptions thrown by the called method are passed through\n\t * without wrapping in an <code>InvocationTargetException</code>\n\t * @see MethodInterceptor#intercept\n\t */\n\tpublic Object invokeSuper(Object obj, Object[] args) throws Throwable {\n\t\ttry {\n\t\t\tinit();\n\t\t\tFastClassInfo fci = fastClassInfo;\n\t\t\treturn fci.f2.invoke(fci.i2, obj, args);\n\t\t}\n\t\tcatch (InvocationTargetException e) {\n\t\t\tthrow e.getTargetException();\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.cglib.proxy.MethodProxy",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.proxy.MethodProxy#sig1",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.proxy.MethodProxy#sig1",
    "headType": "field",
    "relation": "haveType",
    "tail": "Signature",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.proxy.MethodProxy",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.proxy.MethodProxy#sig2",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.proxy.MethodProxy#sig2",
    "headType": "field",
    "relation": "haveType",
    "tail": "Signature",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.proxy.MethodProxy",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.proxy.MethodProxy#createInfo",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.proxy.MethodProxy#createInfo",
    "headType": "field",
    "relation": "haveType",
    "tail": "CreateInfo",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.proxy.MethodProxy",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.proxy.MethodProxy#initLock",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.proxy.MethodProxy#initLock",
    "headType": "field",
    "relation": "haveType",
    "tail": "Object",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.proxy.MethodProxy",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.proxy.MethodProxy#fastClassInfo",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.proxy.MethodProxy#fastClassInfo",
    "headType": "field",
    "relation": "haveType",
    "tail": "FastClassInfo",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.proxy.MethodProxy#create(Class,Class,String,String,String)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * For internal use by {@link Enhancer} only; see the {@link org.springframework.cglib.reflect.FastMethod} class\r\n * for similar functionality.\r\n */\r\npublic static MethodProxy create(Class c1, Class c2, String desc, String name1, String name2) {\r\n    MethodProxy proxy = new MethodProxy();\r\n    proxy.sig1 = new Signature(name1, desc);\r\n    proxy.sig2 = new Signature(name2, desc);\r\n    proxy.createInfo = new CreateInfo(c1, c2);\r\n    // SPRING PATCH BEGIN\r\n    if (c1 != Object.class && c1.isAssignableFrom(c2.getSuperclass()) && !Factory.class.isAssignableFrom(c2)) {\r\n        // Try early initialization for overridden methods on specifically purposed subclasses\r\n        try {\r\n            proxy.init();\r\n        } catch (CodeGenerationException ex) {\r\n            // Ignore - to be retried when actually needed later on (possibly not at all)\r\n        }\r\n    }\r\n    // SPRING PATCH END\r\n    return proxy;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.cglib.proxy.MethodProxy",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.cglib.proxy.MethodProxy#create(Class,Class,String,String,String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.cglib.proxy.MethodProxy#init()",
    "headType": "method",
    "relation": "provide",
    "tail": "private void init() {\r\n    /*\r\n\t\t * Using a volatile invariant allows us to initialize the FastClass and\r\n\t\t * method index pairs atomically.\r\n\t\t *\r\n\t\t * Double-checked locking is safe with volatile in Java 5.  Before 1.5 this\r\n\t\t * code could allow fastClassInfo to be instantiated more than once, which\r\n\t\t * appears to be benign.\r\n\t\t */\r\n    if (fastClassInfo == null) {\r\n        synchronized (initLock) {\r\n            if (fastClassInfo == null) {\r\n                CreateInfo ci = createInfo;\r\n                FastClassInfo fci = new FastClassInfo();\r\n                fci.f1 = helper(ci, ci.c1);\r\n                fci.f2 = helper(ci, ci.c2);\r\n                fci.i1 = fci.f1.getIndex(sig1);\r\n                fci.i2 = fci.f2.getIndex(sig2);\r\n                fastClassInfo = fci;\r\n                createInfo = null;\r\n            }\r\n        }\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.cglib.proxy.MethodProxy",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.cglib.proxy.MethodProxy#init()",
    "tailType": "method"
  }
]