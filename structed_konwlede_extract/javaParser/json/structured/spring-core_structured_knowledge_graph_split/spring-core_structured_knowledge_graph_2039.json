[
  {
    "head": "org.springframework.core.io.ResourceDispatcher",
    "headType": "class",
    "relation": "extend",
    "tail": "Dispatcher",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.io",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.io.AbstractResourceTests",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.io.AbstractResourceTests",
    "headType": "class",
    "relation": "use",
    "tail": "@Nested",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.io.AbstractResourceTests",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.io;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Base64;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.stream.Stream;\n\nimport okhttp3.mockwebserver.Dispatcher;\nimport okhttp3.mockwebserver.MockResponse;\nimport okhttp3.mockwebserver.MockWebServer;\nimport okhttp3.mockwebserver.RecordedRequest;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nimport org.springframework.util.FileCopyUtils;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalStateException;\nimport static org.junit.jupiter.params.provider.Arguments.argumentSet;\n\n/**\n * Tests for various {@link Resource} implementations.\n *\n * @author Juergen Hoeller\n * @author Chris Beams\n * @author Sam Brannen\n * @author Brian Clozel\n */\nclass ResourceTests {\n\n\t@ParameterizedTest\n\t@MethodSource(\"resource\")\n\tvoid resourceIsValid(Resource resource) throws Exception {\n\t\tassertThat(resource.getFilename()).isEqualTo(\"ResourceTests.class\");\n\t\tassertThat(resource.getURL().getFile()).endsWith(\"ResourceTests.class\");\n\t\tassertThat(resource.exists()).isTrue();\n\t\tassertThat(resource.isReadable()).isTrue();\n\t\tassertThat(resource.contentLength()).isGreaterThan(0);\n\t\tassertThat(resource.lastModified()).isGreaterThan(0);\n\t\tassertThat(resource.getContentAsByteArray()).containsExactly(Files.readAllBytes(Path.of(resource.getURI())));\n\t}\n\n\t@ParameterizedTest\n\t@MethodSource(\"resource\")\n\tvoid resourceCreateRelative(Resource resource) throws Exception {\n\t\tResource relative1 = resource.createRelative(\"ClassPathResourceTests.class\");\n\t\tassertThat(relative1.getFilename()).isEqualTo(\"ClassPathResourceTests.class\");\n\t\tassertThat(relative1.getURL().getFile().endsWith(\"ClassPathResourceTests.class\")).isTrue();\n\t\tassertThat(relative1.exists()).isTrue();\n\t\tassertThat(relative1.isReadable()).isTrue();\n\t\tassertThat(relative1.contentLength()).isGreaterThan(0);\n\t\tassertThat(relative1.lastModified()).isGreaterThan(0);\n\t}\n\n\t@ParameterizedTest\n\t@MethodSource(\"resource\")\n\tvoid resourceCreateRelativeWithFolder(Resource resource) throws Exception {\n\t\tResource relative2 = resource.createRelative(\"support/PathMatchingResourcePatternResolverTests.class\");\n\t\tassertThat(relative2.getFilename()).isEqualTo(\"PathMatchingResourcePatternResolverTests.class\");\n\t\tassertThat(relative2.getURL().getFile()).endsWith(\"PathMatchingResourcePatternResolverTests.class\");\n\t\tassertThat(relative2.exists()).isTrue();\n\t\tassertThat(relative2.isReadable()).isTrue();\n\t\tassertThat(relative2.contentLength()).isGreaterThan(0);\n\t\tassertThat(relative2.lastModified()).isGreaterThan(0);\n\t}\n\n\t@ParameterizedTest\n\t@MethodSource(\"resource\")\n\tvoid resourceCreateRelativeWithDotPath(Resource resource) throws Exception {\n\t\tResource relative3 = resource.createRelative(\"../CollectionFactoryTests.class\");\n\t\tassertThat(relative3.getFilename()).isEqualTo(\"CollectionFactoryTests.class\");\n\t\tassertThat(relative3.getURL().getFile()).endsWith(\"CollectionFactoryTests.class\");\n\t\tassertThat(relative3.exists()).isTrue();\n\t\tassertThat(relative3.isReadable()).isTrue();\n\t\tassertThat(relative3.contentLength()).isGreaterThan(0);\n\t\tassertThat(relative3.lastModified()).isGreaterThan(0);\n\t}\n\n\t@ParameterizedTest\n\t@MethodSource(\"resource\")\n\tvoid resourceCreateRelativeUnknown(Resource resource) throws Exception {\n\t\tResource relative4 = resource.createRelative(\"X.class\");\n\t\tassertThat(relative4.exists()).isFalse();\n\t\tassertThat(relative4.isReadable()).isFalse();\n\t\tassertThatExceptionOfType(FileNotFoundException.class).isThrownBy(relative4::contentLength);\n\t\tassertThatExceptionOfType(FileNotFoundException.class).isThrownBy(relative4::lastModified);\n\t\tassertThatExceptionOfType(FileNotFoundException.class).isThrownBy(relative4::getInputStream);\n\t\tassertThatExceptionOfType(FileNotFoundException.class).isThrownBy(relative4::readableChannel);\n\t\tassertThatExceptionOfType(FileNotFoundException.class).isThrownBy(relative4::getContentAsByteArray);\n\t\tassertThatExceptionOfType(FileNotFoundException.class).isThrownBy(() -> relative4.getContentAsString(UTF_8));\n\t}\n\n\tprivate static Stream<Arguments> resource() throws URISyntaxException {\n\t\tURL resourceClass = ResourceTests.class.getResource(\"ResourceTests.class\");\n\t\tPath resourceClassFilePath = Paths.get(resourceClass.toURI());\n\t\treturn Stream.of(\n\t\t\t\targumentSet(\"ClassPathResource\", new ClassPathResource(\"org/springframework/core/io/ResourceTests.class\")),\n\t\t\t\targumentSet(\"ClassPathResource with ClassLoader\", new ClassPathResource(\"org/springframework/core/io/ResourceTests.class\", ResourceTests.class.getClassLoader())),\n\t\t\t\targumentSet(\"ClassPathResource with Class\", new ClassPathResource(\"ResourceTests.class\", ResourceTests.class)),\n\t\t\t\targumentSet(\"FileSystemResource\", new FileSystemResource(resourceClass.getFile())),\n\t\t\t\targumentSet(\"FileSystemResource with File\", new FileSystemResource(new File(resourceClass.getFile()))),\n\t\t\t\targumentSet(\"FileSystemResource with File path\", new FileSystemResource(resourceClassFilePath)),\n\t\t\t\targumentSet(\"UrlResource\", new UrlResource(resourceClass))\n\t\t);\n\t}\n\n\n\t@Nested\n\tclass ByteArrayResourceTests {\n\n\t\t@Test\n\t\tvoid hasContent() throws Exception {\n\t\t\tString testString = \"testString\";\n\t\t\tbyte[] testBytes = testString.getBytes();\n\t\t\tResource resource = new ByteArrayResource(testBytes);\n\t\t\tassertThat(resource.exists()).isTrue();\n\t\t\tassertThat(resource.isOpen()).isFalse();\n\t\t\tbyte[] contentBytes = resource.getContentAsByteArray();\n\t\t\tassertThat(contentBytes).containsExactly(testBytes);\n\t\t\tString contentString = resource.getContentAsString(StandardCharsets.US_ASCII);\n\t\t\tassertThat(contentString).isEqualTo(testString);\n\t\t\tcontentString = FileCopyUtils.copyToString(new InputStreamReader(resource.getInputStream()));\n\t\t\tassertThat(contentString).isEqualTo(testString);\n\t\t\tassertThat(new ByteArrayResource(testBytes)).isEqualTo(resource);\n\t\t}\n\n\t\t@Test\n\t\tvoid isNotOpen() {\n\t\t\tResource resource = new ByteArrayResource(\"testString\".getBytes());\n\t\t\tassertThat(resource.exists()).isTrue();\n\t\t\tassertThat(resource.isOpen()).isFalse();\n\t\t}\n\n\t\t@Test\n\t\tvoid hasDescription() {\n\t\t\tResource resource = new ByteArrayResource(\"testString\".getBytes(), \"my description\");\n\t\t\tassertThat(resource.getDescription()).contains(\"my description\");\n\t\t}\n\t}\n\n\n\t@Nested\n\tclass InputStreamResourceTests {\n\n\t\t@Test\n\t\tvoid hasContent() throws Exception {\n\t\t\tString testString = \"testString\";\n\t\t\tbyte[] testBytes = testString.getBytes();\n\t\t\tInputStream is = new ByteArrayInputStream(testBytes);\n\t\t\tResource resource1 = new InputStreamResource(is);\n\t\t\tString content = FileCopyUtils.copyToString(new InputStreamReader(resource1.getInputStream()));\n\t\t\tassertThat(content).isEqualTo(testString);\n\t\t\tassertThat(new InputStreamResource(is)).isEqualTo(resource1);\n\t\t\tassertThat(new InputStreamResource(() -> is)).isNotEqualTo(resource1);\n\t\t\tassertThatIllegalStateException().isThrownBy(resource1::getInputStream);\n\n\t\t\tResource resource2 = new InputStreamResource(new ByteArrayInputStream(testBytes));\n\t\t\tassertThat(resource2.getContentAsByteArray()).containsExactly(testBytes);\n\t\t\tassertThatIllegalStateException().isThrownBy(resource2::getContentAsByteArray);\n\n\t\t\tAtomicBoolean obtained = new AtomicBoolean();\n\t\t\tResource resource3 = new InputStreamResource(() -> {\n\t\t\t\tobtained.set(true);\n\t\t\t\treturn new ByteArrayInputStream(testBytes);\n\t\t\t});\n\t\t\tassertThat(obtained).isFalse();\n\t\t\tassertThat(resource3.getContentAsString(StandardCharsets.US_ASCII)).isEqualTo(testString);\n\t\t\tassertThat(obtained).isTrue();\n\t\t\tassertThatIllegalStateException().isThrownBy(() -> resource3.getContentAsString(StandardCharsets.US_ASCII));\n\t\t}\n\n\t\t@Test\n\t\tvoid isOpen() {\n\t\t\tInputStream is = new ByteArrayInputStream(\"testString\".getBytes());\n\t\t\tResource resource = new InputStreamResource(is);\n\t\t\tassertThat(resource.exists()).isTrue();\n\t\t\tassertThat(resource.isOpen()).isTrue();\n\n\t\t\tresource = new InputStreamResource(() -> is);\n\t\t\tassertThat(resource.exists()).isTrue();\n\t\t\tassertThat(resource.isOpen()).isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid hasDescription() {\n\t\t\tInputStream is = new ByteArrayInputStream(\"testString\".getBytes());\n\t\t\tResource resource = new InputStreamResource(is, \"my description\");\n\t\t\tassertThat(resource.getDescription()).contains(\"my description\");\n\n\t\t\tresource = new InputStreamResource(() -> is, \"my description\");\n\t\t\tassertThat(resource.getDescription()).contains(\"my description\");\n\t\t}\n\t}\n\n\n\t@Nested\n\tclass FileSystemResourceTests {\n\n\t\t@Test\n\t\tvoid sameResourceIsEqual() {\n\t\t\tString file = getClass().getResource(\"ResourceTests.class\").getFile();\n\t\t\tResource resource = new FileSystemResource(file);\n\t\t\tassertThat(resource).isEqualTo(new FileSystemResource(file));\n\t\t}\n\n\t\t@Test\n\t\tvoid sameResourceFromFileIsEqual() {\n\t\t\tFile file = new File(getClass().getResource(\"ResourceTests.class\").getFile());\n\t\t\tResource resource = new FileSystemResource(file);\n\t\t\tassertThat(resource).isEqualTo(new FileSystemResource(file));\n\t\t}\n\n\t\t@Test\n\t\tvoid sameResourceFromFilePathIsEqual() throws Exception {\n\t\t\tPath filePath = Paths.get(getClass().getResource(\"ResourceTests.class\").toURI());\n\t\t\tResource resource = new FileSystemResource(filePath);\n\t\t\tassertThat(resource).isEqualTo(new FileSystemResource(filePath));\n\t\t}\n\n\t\t@Test\n\t\tvoid sameResourceFromDotPathIsEqual() {\n\t\t\tResource resource = new FileSystemResource(\"core/io/ResourceTests.class\");\n\t\t\tassertThat(new FileSystemResource(\"core/../core/io/./ResourceTests.class\")).isEqualTo(resource);\n\t\t}\n\n\t\t@Test\n\t\tvoid relativeResourcesAreEqual() throws Exception {\n\t\t\tResource resource = new FileSystemResource(\"dir/\");\n\t\t\tResource relative = resource.createRelative(\"subdir\");\n\t\t\tassertThat(relative).isEqualTo(new FileSystemResource(\"dir/subdir\"));\n\t\t}\n\n\t\t@Test\n\t\tvoid readableChannelProvidesContent() throws Exception {\n\t\t\tResource resource = new FileSystemResource(getClass().getResource(\"ResourceTests.class\").getFile());\n\t\t\ttry (ReadableByteChannel channel = resource.readableChannel()) {\n\t\t\t\tByteBuffer buffer = ByteBuffer.allocate((int) resource.contentLength());\n\t\t\t\tchannel.read(buffer);\n\t\t\t\tbuffer.rewind();\n\t\t\t\tassertThat(buffer.limit()).isGreaterThan(0);\n\t\t\t}\n\t\t}\n\n\t\t@Test\n\t\tvoid urlAndUriAreNormalizedWhenCreatedFromFile() throws Exception {\n\t\t\tPath path = Path.of(\"src/test/resources/scanned-resources/resource#test1.txt\").toAbsolutePath();\n\t\t\tassertUrlAndUriBehavior(new FileSystemResource(path.toFile()));\n\t\t}\n\n\t\t@Test\n\t\tvoid urlAndUriAreNormalizedWhenCreatedFromPath() throws Exception {\n\t\t\tPath path = Path.of(\"src/test/resources/scanned-resources/resource#test1.txt\").toAbsolutePath();\n\t\t\tassertUrlAndUriBehavior(new FileSystemResource(path));\n\t\t}\n\n\t\t/**\n\t\t * The following assertions serve as regression tests for the lack of the\n\t\t * \"authority component\" (//) in the returned URI/URL. For example, we are\n\t\t * expecting file:/my/path (or file:/C:/My/Path) instead of file:///my/path.\n\t\t */\n\t\tprivate void assertUrlAndUriBehavior(Resource resource) throws IOException {\n\t\t\tassertThat(resource.getURL().toString()).matches(\"^file:\\\\/[^\\\\/].+test1\\\\.txt$\");\n\t\t\tassertThat(resource.getURI().toString()).matches(\"^file:\\\\/[^\\\\/].+test1\\\\.txt$\");\n\t\t}\n\t}\n\n\n\t@Nested\n\tclass UrlResourceTests {\n\n\t\tprivate static final String LAST_MODIFIED = \"Wed, 09 Apr 2014 09:57:42 GMT\";\n\n\t\tprivate final MockWebServer server = new MockWebServer();\n\n\t\t@Test\n\t\tvoid sameResourceWithRelativePathIsEqual() throws Exception {\n\t\t\tResource resource = new UrlResource(\"file:core/io/ResourceTests.class\");\n\t\t\tassertThat(new UrlResource(\"file:core/../core/io/./ResourceTests.class\")).isEqualTo(resource);\n\t\t}\n\n\t\t@Test\n\t\tvoid filenameIsExtractedFromFilePath() throws Exception {\n\t\t\tassertThat(new UrlResource(\"file:test?argh\").getFilename()).isEqualTo(\"test\");\n\t\t\tassertThat(new UrlResource(\"file:/test?argh\").getFilename()).isEqualTo(\"test\");\n\t\t\tassertThat(new UrlResource(\"file:test.txt?argh\").getFilename()).isEqualTo(\"test.txt\");\n\t\t\tassertThat(new UrlResource(\"file:/test.txt?argh\").getFilename()).isEqualTo(\"test.txt\");\n\t\t\tassertThat(new UrlResource(\"file:/dir/test?argh\").getFilename()).isEqualTo(\"test\");\n\t\t\tassertThat(new UrlResource(\"file:/dir/test.txt?argh\").getFilename()).isEqualTo(\"test.txt\");\n\t\t\tassertThat(new UrlResource(\"file:\\\\dir\\\\test.txt?argh\").getFilename()).isEqualTo(\"test.txt\");\n\t\t\tassertThat(new UrlResource(\"file:\\\\dir/test.txt?argh\").getFilename()).isEqualTo(\"test.txt\");\n\t\t}\n\n\t\t@Test\n\t\tvoid filenameIsExtractedFromURL() throws Exception {\n\t\t\tassertThat(new UrlResource(new URL(\"file:test?argh\")).getFilename()).isEqualTo(\"test\");\n\t\t\tassertThat(new UrlResource(new URL(\"file:/test?argh\")).getFilename()).isEqualTo(\"test\");\n\t\t\tassertThat(new UrlResource(new URL(\"file:test.txt?argh\")).getFilename()).isEqualTo(\"test.txt\");\n\t\t\tassertThat(new UrlResource(new URL(\"file:/test.txt?argh\")).getFilename()).isEqualTo(\"test.txt\");\n\t\t\tassertThat(new UrlResource(new URL(\"file:/dir/test?argh\")).getFilename()).isEqualTo(\"test\");\n\t\t\tassertThat(new UrlResource(new URL(\"file:/dir/test.txt?argh\")).getFilename()).isEqualTo(\"test.txt\");\n\t\t\tassertThat(new UrlResource(new URL(\"file:\\\\dir\\\\test.txt?argh\")).getFilename()).isEqualTo(\"test.txt\");\n\t\t\tassertThat(new UrlResource(new URL(\"file:\\\\dir/test.txt?argh\")).getFilename()).isEqualTo(\"test.txt\");\n\t\t}\n\n\t\t@Test\n\t\tvoid filenameContainingHashTagIsExtractedFromFilePathUnencoded() throws Exception {\n\t\t\tString unencodedPath = \"/dir/test#1.txt\";\n\t\t\tString encodedPath = \"/dir/test%231.txt\";\n\n\t\t\tURI uri = new URI(\"file\", unencodedPath, null);\n\t\t\tURL url = uri.toURL();\n\t\t\tassertThat(uri.getPath()).isEqualTo(unencodedPath);\n\t\t\tassertThat(uri.getRawPath()).isEqualTo(encodedPath);\n\t\t\tassertThat(url.getPath()).isEqualTo(encodedPath);\n\n\t\t\tUrlResource urlResource = new UrlResource(url);\n\t\t\tassertThat(urlResource.getURI().getPath()).isEqualTo(unencodedPath);\n\t\t\tassertThat(urlResource.getFilename()).isEqualTo(\"test#1.txt\");\n\t\t}\n\n\t\t@Test\n\t\tvoid factoryMethodsProduceEqualResources() throws Exception {\n\t\t\tResource resource1 = new UrlResource(\"file:core/io/ResourceTests.class\");\n\t\t\tResource resource2 = UrlResource.from(\"file:core/io/ResourceTests.class\");\n\t\t\tResource resource3 = UrlResource.from(resource1.getURI());\n\n\t\t\tassertThat(resource2.getURL()).isEqualTo(resource1.getURL());\n\t\t\tassertThat(resource3.getURL()).isEqualTo(resource1.getURL());\n\n\t\t\tassertThat(UrlResource.from(\"file:core/../core/io/./ResourceTests.class\")).isEqualTo(resource1);\n\t\t\tassertThat(UrlResource.from(\"file:/dir/test.txt?argh\").getFilename()).isEqualTo(\"test.txt\");\n\t\t\tassertThat(UrlResource.from(\"file:\\\\dir\\\\test.txt?argh\").getFilename()).isEqualTo(\"test.txt\");\n\t\t\tassertThat(UrlResource.from(\"file:\\\\dir/test.txt?argh\").getFilename()).isEqualTo(\"test.txt\");\n\t\t}\n\n\t\t@Test\n\t\tvoid relativeResourcesAreEqual() throws Exception {\n\t\t\tResource resource = new UrlResource(\"file:dir/\");\n\t\t\tResource relative = resource.createRelative(\"subdir\");\n\t\t\tassertThat(relative).isEqualTo(new UrlResource(\"file:dir/subdir\"));\n\t\t}\n\n\t\t@Test\n\t\tvoid unusualRelativeResourcesAreEqual() throws Exception {\n\t\t\tResource resource = new UrlResource(\"file:dir/\");\n\t\t\tResource relative = resource.createRelative(\"https://spring.io\");\n\t\t\tassertThat(relative).isEqualTo(new UrlResource(\"file:dir/https://spring.io\"));\n\t\t}\n\n\t\t@Test\n\t\tvoid missingRemoteResourceDoesNotExist() throws Exception {\n\t\t\tString baseUrl = startServer(true);\n\t\t\tUrlResource resource = new UrlResource(baseUrl + \"/missing\");\n\t\t\tassertThat(resource.exists()).isFalse();\n\t\t}\n\n\t\t@Test\n\t\tvoid remoteResourceExists() throws Exception {\n\t\t\tString baseUrl = startServer(true);\n\t\t\tUrlResource resource = new UrlResource(baseUrl + \"/resource\");\n\t\t\tassertThat(resource.exists()).isTrue();\n\t\t\tassertThat(resource.isReadable()).isTrue();\n\t\t\tassertThat(resource.contentLength()).isEqualTo(6);\n\t\t\tassertThat(resource.lastModified()).isGreaterThan(0);\n\t\t}\n\n\t\t@Test\n\t\tvoid remoteResourceExistsFallback() throws Exception {\n\t\t\tString baseUrl = startServer(false);\n\t\t\tUrlResource resource = new UrlResource(baseUrl + \"/resource\");\n\t\t\tassertThat(resource.exists()).isTrue();\n\t\t\tassertThat(resource.isReadable()).isTrue();\n\t\t\tassertThat(resource.contentLength()).isEqualTo(6);\n\t\t\tassertThat(resource.lastModified()).isGreaterThan(0);\n\t\t}\n\n\t\t@Test\n\t\tvoid canCustomizeHttpUrlConnectionForExists() throws Exception {\n\t\t\tString baseUrl = startServer(true);\n\t\t\tCustomResource resource = new CustomResource(baseUrl + \"/resource\");\n\t\t\tassertThat(resource.exists()).isTrue();\n\t\t\tRecordedRequest request = this.server.takeRequest();\n\t\t\tassertThat(request.getMethod()).isEqualTo(\"HEAD\");\n\t\t\tassertThat(request.getHeader(\"Framework-Name\")).isEqualTo(\"Spring\");\n\t\t}\n\n\t\t@Test\n\t\tvoid canCustomizeHttpUrlConnectionForExistsFallback() throws Exception {\n\t\t\tString baseUrl = startServer(false);\n\t\t\tCustomResource resource = new CustomResource(baseUrl + \"/resource\");\n\t\t\tassertThat(resource.exists()).isTrue();\n\t\t\tRecordedRequest request = this.server.takeRequest();\n\t\t\tassertThat(request.getMethod()).isEqualTo(\"HEAD\");\n\t\t\tassertThat(request.getHeader(\"Framework-Name\")).isEqualTo(\"Spring\");\n\t\t}\n\n\t\t@Test\n\t\tvoid canCustomizeHttpUrlConnectionForRead() throws Exception {\n\t\t\tString baseUrl = startServer(true);\n\t\t\tCustomResource resource = new CustomResource(baseUrl + \"/resource\");\n\t\t\tassertThat(resource.getInputStream()).hasContent(\"Spring\");\n\t\t\tRecordedRequest request = this.server.takeRequest();\n\t\t\tassertThat(request.getMethod()).isEqualTo(\"GET\");\n\t\t\tassertThat(request.getHeader(\"Framework-Name\")).isEqualTo(\"Spring\");\n\t\t}\n\n\t\t@Test\n\t\tvoid useUserInfoToSetBasicAuth() throws Exception {\n\t\t\tstartServer(true);\n\t\t\tUrlResource resource = new UrlResource(\n\t\t\t\t\t\"http://alice:secret@localhost:\" + this.server.getPort() + \"/resource\");\n\t\t\tassertThat(resource.getInputStream()).hasContent(\"Spring\");\n\t\t\tRecordedRequest request = this.server.takeRequest();\n\t\t\tString authorization = request.getHeader(\"Authorization\");\n\t\t\tassertThat(authorization).isNotNull().startsWith(\"Basic \");\n\t\t\tassertThat(new String(Base64.getDecoder().decode(authorization.substring(6)),\n\t\t\t\t\tStandardCharsets.ISO_8859_1)).isEqualTo(\"alice:secret\");\n\t\t}\n\n\t\t@AfterEach\n\t\tvoid shutdown() throws Exception {\n\t\t\tthis.server.shutdown();\n\t\t}\n\n\t\tprivate String startServer(boolean withHeadSupport) throws Exception {\n\t\t\tthis.server.setDispatcher(new ResourceDispatcher(withHeadSupport));\n\t\t\tthis.server.start();\n\t\t\treturn \"http://localhost:\" + this.server.getPort();\n\t\t}\n\n\t\tclass CustomResource extends UrlResource {\n\n\t\t\tpublic CustomResource(String path) throws MalformedURLException {\n\t\t\t\tsuper(path);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void customizeConnection(HttpURLConnection con) {\n\t\t\t\tcon.setRequestProperty(\"Framework-Name\", \"Spring\");\n\t\t\t}\n\t\t}\n\n\t\tclass ResourceDispatcher extends Dispatcher {\n\n\t\t\tboolean withHeadSupport;\n\n\t\t\tpublic ResourceDispatcher(boolean withHeadSupport) {\n\t\t\t\tthis.withHeadSupport = withHeadSupport;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic MockResponse dispatch(RecordedRequest request) {\n\t\t\t\tif (request.getPath().equals(\"/resource\")) {\n\t\t\t\t\treturn switch (request.getMethod()) {\n\t\t\t\t\t\tcase \"HEAD\" -> (this.withHeadSupport ?\n\t\t\t\t\t\t\t\tnew MockResponse()\n\t\t\t\t\t\t\t\t\t\t.addHeader(\"Content-Type\", \"text/plain\")\n\t\t\t\t\t\t\t\t\t\t.addHeader(\"Content-Length\", \"6\")\n\t\t\t\t\t\t\t\t\t\t.addHeader(\"Last-Modified\", LAST_MODIFIED) :\n\t\t\t\t\t\t\t\tnew MockResponse().setResponseCode(405));\n\t\t\t\t\t\tcase \"GET\" -> new MockResponse()\n\t\t\t\t\t\t\t\t\t.addHeader(\"Content-Type\", \"text/plain\")\n\t\t\t\t\t\t\t\t\t.addHeader(\"Content-Length\", \"6\")\n\t\t\t\t\t\t\t\t\t.addHeader(\"Last-Modified\", LAST_MODIFIED)\n\t\t\t\t\t\t\t\t\t.setBody(\"Spring\");\n\t\t\t\t\t\tdefault -> new MockResponse().setResponseCode(404);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn new MockResponse().setResponseCode(404);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t@Nested\n\tclass AbstractResourceTests {\n\n\t\t@Test\n\t\tvoid missingResourceIsNotReadable() {\n\t\t\tfinal String name = \"test-resource\";\n\n\t\t\tResource resource = new AbstractResource() {\n\t\t\t\t@Override\n\t\t\t\tpublic String getDescription() {\n\t\t\t\t\treturn name;\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic InputStream getInputStream() throws IOException {\n\t\t\t\t\tthrow new FileNotFoundException();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tassertThatExceptionOfType(FileNotFoundException.class).isThrownBy(resource::getURL)\n\t\t\t\t\t.withMessageContaining(name);\n\t\t\tassertThatExceptionOfType(FileNotFoundException.class).isThrownBy(resource::getFile)\n\t\t\t\t\t.withMessageContaining(name);\n\t\t\tassertThatExceptionOfType(FileNotFoundException.class).isThrownBy(() ->\n\t\t\t\t\tresource.createRelative(\"/testing\")).withMessageContaining(name);\n\t\t\tassertThatExceptionOfType(FileNotFoundException.class).isThrownBy(resource::getContentAsByteArray);\n\t\t\tassertThatExceptionOfType(FileNotFoundException.class).isThrownBy(\n\t\t\t\t\t() -> resource.getContentAsString(StandardCharsets.US_ASCII));\n\t\t\tassertThat(resource.getFilename()).isNull();\n\t\t}\n\n\t\t@Test\n\t\tvoid hasContentLength() throws Exception {\n\t\t\tAbstractResource resource = new AbstractResource() {\n\t\t\t\t@Override\n\t\t\t\tpublic InputStream getInputStream() {\n\t\t\t\t\treturn new ByteArrayInputStream(new byte[] {'a', 'b', 'c'});\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic String getDescription() {\n\t\t\t\t\treturn \"\";\n\t\t\t\t}\n\t\t\t};\n\t\t\tassertThat(resource.contentLength()).isEqualTo(3L);\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.io.AbstractResourceTests#missingResourceIsNotReadable()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid missingResourceIsNotReadable() {\r\n    final String name = \"test-resource\";\r\n    Resource resource = new AbstractResource() {\r\n\r\n        @Override\r\n        public String getDescription() {\r\n            return name;\r\n        }\r\n\r\n        @Override\r\n        public InputStream getInputStream() throws IOException {\r\n            throw new FileNotFoundException();\r\n        }\r\n    };\r\n    assertThatExceptionOfType(FileNotFoundException.class).isThrownBy(resource::getURL).withMessageContaining(name);\r\n    assertThatExceptionOfType(FileNotFoundException.class).isThrownBy(resource::getFile).withMessageContaining(name);\r\n    assertThatExceptionOfType(FileNotFoundException.class).isThrownBy(() -> resource.createRelative(\"/testing\")).withMessageContaining(name);\r\n    assertThatExceptionOfType(FileNotFoundException.class).isThrownBy(resource::getContentAsByteArray);\r\n    assertThatExceptionOfType(FileNotFoundException.class).isThrownBy(() -> resource.getContentAsString(StandardCharsets.US_ASCII));\r\n    assertThat(resource.getFilename()).isNull();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.io.AbstractResourceTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.io.AbstractResourceTests#missingResourceIsNotReadable()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.io.AbstractResourceTests#missingResourceIsNotReadable()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.io.AbstractResourceTests#hasContentLength()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid hasContentLength() throws Exception {\r\n    AbstractResource resource = new AbstractResource() {\r\n\r\n        @Override\r\n        public InputStream getInputStream() {\r\n            return new ByteArrayInputStream(new byte[] { 'a', 'b', 'c' });\r\n        }\r\n\r\n        @Override\r\n        public String getDescription() {\r\n            return \"\";\r\n        }\r\n    };\r\n    assertThat(resource.contentLength()).isEqualTo(3L);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.io.AbstractResourceTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.io.AbstractResourceTests#hasContentLength()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.io.AbstractResourceTests#hasContentLength()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.io.support",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core.io.support",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.io.support.ClassPathManifestEntriesTestApplication",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.io.support.ClassPathManifestEntriesTestApplication",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.io.support;\n\nimport java.io.IOException;\nimport java.util.List;\n\n/**\n * Class packaged into a temporary jar to test\n * {@link PathMatchingResourcePatternResolver} detection of classpath manifest\n * entries.\n *\n * @author Phillip Webb\n */\npublic class ClassPathManifestEntriesTestApplication {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tPathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();\n\t\tSystem.out.println(\"!!!!\" + List.of(resolver.getResources(\"classpath*:/**/*.txt\")));\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.io.support.ClassPathManifestEntriesTestApplication#main(String[])",
    "headType": "method",
    "relation": "provide",
    "tail": "public static void main(String[] args) throws IOException {\r\n    PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();\r\n    System.out.println(\"!!!!\" + List.of(resolver.getResources(\"classpath*:/**/*.txt\")));\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.io.support.ClassPathManifestEntriesTestApplication",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.io.support.ClassPathManifestEntriesTestApplication#main(String[])",
    "tailType": "method"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.io.support",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core.io.support",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.io.support.ConstructorArgsDummyFactory",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.io.support.ConstructorArgsDummyFactory",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2022 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.io.support;\n\n/**\n * Used by {@link SpringFactoriesLoaderTests}.\n *\n * @author Andy Wilkinson\n */\nclass ConstructorArgsDummyFactory implements DummyFactory {\n\n\tprivate final String string;\n\n\tpublic ConstructorArgsDummyFactory(String string) {\n\t\tthis(string, 0);\n\t}\n\n\tprivate ConstructorArgsDummyFactory(String string, int reasonCode) {\n\t\tthis.string = string;\n\t}\n\n\t@Override\n\tpublic String getString() {\n\t\treturn this.string;\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.io.support.ConstructorArgsDummyFactory",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.io.support.ConstructorArgsDummyFactory#string",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.io.support.ConstructorArgsDummyFactory#string",
    "headType": "field",
    "relation": "haveType",
    "tail": "String",
    "tailType": "type"
  }
]