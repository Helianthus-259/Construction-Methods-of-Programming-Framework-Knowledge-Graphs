[
  {
    "head": "org.springframework.core.ReactiveTypeDescriptor#singleOptionalValue(Class<?>,Supplier<?>)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Descriptor for a reactive type that can produce 0..1 values.\r\n * @param type the reactive type\r\n * @param emptySupplier a supplier of an empty-value instance of the reactive type\r\n */\r\npublic static ReactiveTypeDescriptor singleOptionalValue(Class<?> type, Supplier<?> emptySupplier) {\r\n    return new ReactiveTypeDescriptor(type, false, false, emptySupplier);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.ReactiveTypeDescriptor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.ReactiveTypeDescriptor#singleOptionalValue(Class<?>,Supplier<?>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.ReactiveTypeDescriptor#singleRequiredValue(Class<?>)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Descriptor for a reactive type that must produce 1 value to complete.\r\n * @param type the reactive type\r\n */\r\npublic static ReactiveTypeDescriptor singleRequiredValue(Class<?> type) {\r\n    return new ReactiveTypeDescriptor(type, false, false, null);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.ReactiveTypeDescriptor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.ReactiveTypeDescriptor#singleRequiredValue(Class<?>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.ReactiveTypeDescriptor#noValue(Class<?>,Supplier<?>)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Descriptor for a reactive type that does not produce any values.\r\n * @param type the reactive type\r\n * @param emptySupplier a supplier of an empty-value instance of the reactive type\r\n */\r\npublic static ReactiveTypeDescriptor noValue(Class<?> type, Supplier<?> emptySupplier) {\r\n    return new ReactiveTypeDescriptor(type, false, true, emptySupplier);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.ReactiveTypeDescriptor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.ReactiveTypeDescriptor#noValue(Class<?>,Supplier<?>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.ReactiveTypeDescriptor#nonDeferredAsyncValue(Class<?>,Supplier<?>)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * The same as {@link #singleOptionalValue(Class, Supplier)} but for a\r\n * non-deferred, async type such as {@link java.util.concurrent.CompletableFuture}.\r\n * @param type the reactive type\r\n * @param emptySupplier a supplier of an empty-value instance of the reactive type\r\n * @since 5.2.7\r\n */\r\npublic static ReactiveTypeDescriptor nonDeferredAsyncValue(Class<?> type, Supplier<?> emptySupplier) {\r\n    return new ReactiveTypeDescriptor(type, false, false, emptySupplier, false);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.ReactiveTypeDescriptor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.ReactiveTypeDescriptor#nonDeferredAsyncValue(Class<?>,Supplier<?>)",
    "tailType": "method"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.ResolvableType",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.ResolvableType",
    "headType": "class",
    "relation": "use",
    "tail": "@SuppressWarnings",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.ResolvableType",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.WildcardType;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.StringJoiner;\n\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.core.SerializableTypeWrapper.FieldTypeProvider;\nimport org.springframework.core.SerializableTypeWrapper.MethodParameterTypeProvider;\nimport org.springframework.core.SerializableTypeWrapper.TypeProvider;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.ConcurrentReferenceHashMap;\nimport org.springframework.util.ObjectUtils;\nimport org.springframework.util.StringUtils;\n\n/**\n * Encapsulates a Java {@link java.lang.reflect.Type}, providing access to\n * {@link #getSuperType() supertypes}, {@link #getInterfaces() interfaces}, and\n * {@link #getGeneric(int...) generic parameters} along with the ability to ultimately\n * {@link #resolve() resolve} to a {@link java.lang.Class}.\n *\n * <p>A {@code ResolvableType} may be obtained from a {@linkplain #forField(Field) field},\n * a {@linkplain #forMethodParameter(Method, int) method parameter},\n * a {@linkplain #forMethodReturnType(Method) method return type}, or a\n * {@linkplain #forClass(Class) class}. Most methods on this class will themselves return\n * a {@code ResolvableType}, allowing for easy navigation. For example:\n * <pre class=\"code\">\n * private HashMap&lt;Integer, List&lt;String&gt;&gt; myMap;\n *\n * public void example() {\n *     ResolvableType t = ResolvableType.forField(getClass().getDeclaredField(\"myMap\"));\n *     t.getSuperType(); // AbstractMap&lt;Integer, List&lt;String&gt;&gt;\n *     t.asMap(); // Map&lt;Integer, List&lt;String&gt;&gt;\n *     t.getGeneric(0).resolve(); // Integer\n *     t.getGeneric(1).resolve(); // List\n *     t.getGeneric(1); // List&lt;String&gt;\n *     t.resolveGeneric(1, 0); // String\n * }\n * </pre>\n *\n * @author Phillip Webb\n * @author Juergen Hoeller\n * @author Stephane Nicoll\n * @author Yanming Zhou\n * @since 4.0\n * @see #forField(Field)\n * @see #forMethodParameter(Method, int)\n * @see #forMethodReturnType(Method)\n * @see #forConstructorParameter(Constructor, int)\n * @see #forClass(Class)\n * @see #forType(Type)\n * @see #forInstance(Object)\n * @see ResolvableTypeProvider\n */\n@SuppressWarnings(\"serial\")\npublic class ResolvableType implements Serializable {\n\n\t/**\n\t * {@code ResolvableType} returned when no value is available. {@code NONE} is used\n\t * in preference to {@code null} so that multiple method calls can be safely chained.\n\t */\n\tpublic static final ResolvableType NONE = new ResolvableType(EmptyType.INSTANCE, null, null, 0);\n\n\tprivate static final ResolvableType[] EMPTY_TYPES_ARRAY = new ResolvableType[0];\n\n\tprivate static final ConcurrentReferenceHashMap<ResolvableType, ResolvableType> cache =\n\t\t\tnew ConcurrentReferenceHashMap<>(256);\n\n\n\t/**\n\t * The underlying Java type being managed.\n\t */\n\tprivate final Type type;\n\n\t/**\n\t * The component type for an array or {@code null} if the type should be deduced.\n\t */\n\tprivate final @Nullable ResolvableType componentType;\n\n\t/**\n\t * Optional provider for the type.\n\t */\n\tprivate final @Nullable TypeProvider typeProvider;\n\n\t/**\n\t * The {@code VariableResolver} to use or {@code null} if no resolver is available.\n\t */\n\tprivate final @Nullable VariableResolver variableResolver;\n\n\tprivate final @Nullable Integer hash;\n\n\tprivate @Nullable Class<?> resolved;\n\n\tprivate volatile @Nullable ResolvableType superType;\n\n\tprivate volatile ResolvableType @Nullable [] interfaces;\n\n\tprivate volatile ResolvableType @Nullable [] generics;\n\n\tprivate volatile @Nullable Boolean unresolvableGenerics;\n\n\n\t/**\n\t * Private constructor used to create a new {@code ResolvableType} for cache key purposes,\n\t * with no upfront resolution.\n\t */\n\tprivate ResolvableType(\n\t\t\tType type, @Nullable TypeProvider typeProvider, @Nullable VariableResolver variableResolver) {\n\n\t\tthis.type = type;\n\t\tthis.componentType = null;\n\t\tthis.typeProvider = typeProvider;\n\t\tthis.variableResolver = variableResolver;\n\t\tthis.hash = calculateHashCode();\n\t\tthis.resolved = null;\n\t}\n\n\t/**\n\t * Private constructor used to create a new {@code ResolvableType} for cache value purposes,\n\t * with upfront resolution and a pre-calculated hash.\n\t * @since 4.2\n\t */\n\tprivate ResolvableType(Type type, @Nullable TypeProvider typeProvider,\n\t\t\t@Nullable VariableResolver variableResolver, @Nullable Integer hash) {\n\n\t\tthis.type = type;\n\t\tthis.componentType = null;\n\t\tthis.typeProvider = typeProvider;\n\t\tthis.variableResolver = variableResolver;\n\t\tthis.hash = hash;\n\t\tthis.resolved = resolveClass();\n\t}\n\n\t/**\n\t * Private constructor used to create a new {@code ResolvableType} for uncached purposes,\n\t * with upfront resolution but lazily calculated hash.\n\t */\n\tprivate ResolvableType(Type type, @Nullable ResolvableType componentType,\n\t\t\t@Nullable TypeProvider typeProvider, @Nullable VariableResolver variableResolver) {\n\n\t\tthis.type = type;\n\t\tthis.componentType = componentType;\n\t\tthis.typeProvider = typeProvider;\n\t\tthis.variableResolver = variableResolver;\n\t\tthis.hash = null;\n\t\tthis.resolved = resolveClass();\n\t}\n\n\t/**\n\t * Private constructor used to create a new {@code ResolvableType} on a {@link Class} basis.\n\t * <p>Avoids all {@code instanceof} checks in order to create a straight {@link Class} wrapper.\n\t * @since 4.2\n\t */\n\tprivate ResolvableType(@Nullable Class<?> clazz) {\n\t\tthis.resolved = (clazz != null ? clazz : Object.class);\n\t\tthis.type = this.resolved;\n\t\tthis.componentType = null;\n\t\tthis.typeProvider = null;\n\t\tthis.variableResolver = null;\n\t\tthis.hash = null;\n\t}\n\n\n\t/**\n\t * Return the underling Java {@link Type} being managed.\n\t */\n\tpublic Type getType() {\n\t\treturn SerializableTypeWrapper.unwrap(this.type);\n\t}\n\n\t/**\n\t * Return the underlying Java {@link Class} being managed, if available;\n\t * otherwise {@code null}.\n\t */\n\tpublic @Nullable Class<?> getRawClass() {\n\t\tif (this.type == this.resolved) {\n\t\t\treturn this.resolved;\n\t\t}\n\t\tType rawType = this.type;\n\t\tif (rawType instanceof ParameterizedType parameterizedType) {\n\t\t\trawType = parameterizedType.getRawType();\n\t\t}\n\t\treturn (rawType instanceof Class<?> rawClass ? rawClass : null);\n\t}\n\n\t/**\n\t * Return the underlying source of the resolvable type. Will return a {@link Field},\n\t * {@link MethodParameter} or {@link Type} depending on how the {@code ResolvableType}\n\t * was constructed. This method is primarily to provide access to additional type\n\t * information or meta-data that alternative JVM languages may provide.\n\t */\n\tpublic Object getSource() {\n\t\tObject source = (this.typeProvider != null ? this.typeProvider.getSource() : null);\n\t\treturn (source != null ? source : this.type);\n\t}\n\n\t/**\n\t * Return this type as a resolved {@code Class}, falling back to\n\t * {@link java.lang.Object} if no specific class can be resolved.\n\t * @return the resolved {@link Class} or the {@code Object} fallback\n\t * @since 5.1\n\t * @see #getRawClass()\n\t * @see #resolve(Class)\n\t */\n\tpublic Class<?> toClass() {\n\t\treturn resolve(Object.class);\n\t}\n\n\t/**\n\t * Determine whether the given object is an instance of this {@code ResolvableType}.\n\t * @param obj the object to check\n\t * @since 4.2\n\t * @see #isAssignableFrom(Class)\n\t */\n\tpublic boolean isInstance(@Nullable Object obj) {\n\t\treturn (obj != null && isAssignableFrom(obj.getClass()));\n\t}\n\n\t/**\n\t * Determine whether this {@code ResolvableType} is assignable from the\n\t * specified other type.\n\t * @param other the type to be checked against (as a {@code Class})\n\t * @since 4.2\n\t * @see #isAssignableFrom(ResolvableType)\n\t */\n\tpublic boolean isAssignableFrom(Class<?> other) {\n\t\t// As of 6.1: shortcut assignability check for top-level Class references\n\t\treturn (this.type instanceof Class<?> clazz ? ClassUtils.isAssignable(clazz, other) :\n\t\t\t\tisAssignableFrom(forClass(other), false, null, false));\n\t}\n\n\t/**\n\t * Determine whether this {@code ResolvableType} is assignable from the\n\t * specified other type.\n\t * <p>Attempts to follow the same rules as the Java compiler, considering\n\t * whether both the {@link #resolve() resolved} {@code Class} is\n\t * {@link Class#isAssignableFrom(Class) assignable from} the given type\n\t * as well as whether all {@link #getGenerics() generics} are assignable.\n\t * @param other the type to be checked against (as a {@code ResolvableType})\n\t * @return {@code true} if the specified other type can be assigned to this\n\t * {@code ResolvableType}; {@code false} otherwise\n\t */\n\tpublic boolean isAssignableFrom(ResolvableType other) {\n\t\treturn isAssignableFrom(other, false, null, false);\n\t}\n\n\t/**\n\t * Determine whether this {@code ResolvableType} is assignable from the\n\t * specified other type, as far as the other type is actually resolvable.\n\t * @param other the type to be checked against (as a {@code ResolvableType})\n\t * @return {@code true} if the specified other type can be assigned to this\n\t * {@code ResolvableType} as far as it is resolvable; {@code false} otherwise\n\t * @since 6.2\n\t */\n\tpublic boolean isAssignableFromResolvedPart(ResolvableType other) {\n\t\treturn isAssignableFrom(other, false, null, true);\n\t}\n\n\tprivate boolean isAssignableFrom(ResolvableType other, boolean strict,\n\t\t\t@Nullable Map<Type, Type> matchedBefore, boolean upUntilUnresolvable) {\n\n\t\tAssert.notNull(other, \"ResolvableType must not be null\");\n\n\t\t// If we cannot resolve types, we are not assignable\n\t\tif (this == NONE || other == NONE) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (matchedBefore != null) {\n\t\t\tif (matchedBefore.get(this.type) == other.type) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// As of 6.1: shortcut assignability check for top-level Class references\n\t\t\tif (this.type instanceof Class<?> clazz && other.type instanceof Class<?> otherClazz) {\n\t\t\t\treturn (strict ? clazz.isAssignableFrom(otherClazz) : ClassUtils.isAssignable(clazz, otherClazz));\n\t\t\t}\n\t\t}\n\n\t\tif (upUntilUnresolvable && (other.isUnresolvableTypeVariable() || other.isWildcardWithoutBounds())) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Deal with array by delegating to the component type\n\t\tif (isArray()) {\n\t\t\treturn (other.isArray() && getComponentType().isAssignableFrom(\n\t\t\t\t\tother.getComponentType(), true, matchedBefore, upUntilUnresolvable));\n\t\t}\n\n\t\t// Deal with wildcard bounds\n\t\tWildcardBounds ourBounds = WildcardBounds.get(this);\n\t\tWildcardBounds otherBounds = WildcardBounds.get(other);\n\n\t\t// In the form X is assignable to <? extends Number>\n\t\tif (otherBounds != null) {\n\t\t\tif (ourBounds != null) {\n\t\t\t\treturn (ourBounds.isSameKind(otherBounds) &&\n\t\t\t\t\t\tourBounds.isAssignableFrom(otherBounds.getBounds(), matchedBefore));\n\t\t\t}\n\t\t\telse if (upUntilUnresolvable) {\n\t\t\t\treturn otherBounds.isAssignableFrom(this, matchedBefore);\n\t\t\t}\n\t\t\telse if (!strict) {\n\t\t\t\treturn (matchedBefore != null ? otherBounds.equalsType(this) :\n\t\t\t\t\t\totherBounds.isAssignableTo(this, matchedBefore));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// In the form <? extends Number> is assignable to X...\n\t\tif (ourBounds != null) {\n\t\t\treturn ourBounds.isAssignableFrom(other, matchedBefore);\n\t\t}\n\n\t\t// Main assignability check about to follow\n\t\tboolean exactMatch = (strict && matchedBefore != null);\n\t\tboolean checkGenerics = true;\n\t\tClass<?> ourResolved = null;\n\t\tif (this.type instanceof TypeVariable<?> variable) {\n\t\t\t// Try default variable resolution\n\t\t\tif (this.variableResolver != null) {\n\t\t\t\tResolvableType resolved = this.variableResolver.resolveVariable(variable);\n\t\t\t\tif (resolved != null) {\n\t\t\t\t\tourResolved = resolved.resolve();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ourResolved == null) {\n\t\t\t\t// Try variable resolution against target type\n\t\t\t\tif (other.variableResolver != null) {\n\t\t\t\t\tResolvableType resolved = other.variableResolver.resolveVariable(variable);\n\t\t\t\t\tif (resolved != null) {\n\t\t\t\t\t\tourResolved = resolved.resolve();\n\t\t\t\t\t\tcheckGenerics = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ourResolved == null) {\n\t\t\t\t// Unresolved type variable, potentially nested -> never insist on exact match\n\t\t\t\texactMatch = false;\n\t\t\t}\n\t\t}\n\t\tif (ourResolved == null) {\n\t\t\tourResolved = toClass();\n\t\t}\n\t\tClass<?> otherResolved = other.toClass();\n\n\t\t// We need an exact type match for generics\n\t\t// List<CharSequence> is not assignable from List<String>\n\t\tif (exactMatch ? !ourResolved.equals(otherResolved) :\n\t\t\t\t(strict ? !ourResolved.isAssignableFrom(otherResolved) :\n\t\t\t\t\t\t!ClassUtils.isAssignable(ourResolved, otherResolved))) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (checkGenerics) {\n\t\t\t// Recursively check each generic\n\t\t\tResolvableType[] ourGenerics = getGenerics();\n\t\t\tResolvableType[] otherGenerics = other.as(ourResolved).getGenerics();\n\t\t\tif (ourGenerics.length != otherGenerics.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (ourGenerics.length > 0) {\n\t\t\t\tif (matchedBefore == null) {\n\t\t\t\t\tmatchedBefore = new IdentityHashMap<>(1);\n\t\t\t\t}\n\t\t\t\tmatchedBefore.put(this.type, other.type);\n\t\t\t\tfor (int i = 0; i < ourGenerics.length; i++) {\n\t\t\t\t\tResolvableType otherGeneric = otherGenerics[i];\n\t\t\t\t\tif (!ourGenerics[i].isAssignableFrom(otherGeneric,\n\t\t\t\t\t\t\t!otherGeneric.isUnresolvableTypeVariable(), matchedBefore, upUntilUnresolvable)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Return {@code true} if this type resolves to a Class that represents an array.\n\t * @see #getComponentType()\n\t */\n\tpublic boolean isArray() {\n\t\tif (this == NONE) {\n\t\t\treturn false;\n\t\t}\n\t\treturn ((this.type instanceof Class<?> clazz && clazz.isArray()) ||\n\t\t\t\tthis.type instanceof GenericArrayType || resolveType().isArray());\n\t}\n\n\t/**\n\t * Return the ResolvableType representing the component type of the array or\n\t * {@link #NONE} if this type does not represent an array.\n\t * @see #isArray()\n\t */\n\tpublic ResolvableType getComponentType() {\n\t\tif (this == NONE) {\n\t\t\treturn NONE;\n\t\t}\n\t\tif (this.componentType != null) {\n\t\t\treturn this.componentType;\n\t\t}\n\t\tif (this.type instanceof Class<?> clazz) {\n\t\t\tClass<?> componentType = clazz.componentType();\n\t\t\treturn forType(componentType, this.variableResolver);\n\t\t}\n\t\tif (this.type instanceof GenericArrayType genericArrayType) {\n\t\t\treturn forType(genericArrayType.getGenericComponentType(), this.variableResolver);\n\t\t}\n\t\treturn resolveType().getComponentType();\n\t}\n\n\t/**\n\t * Convenience method to return this type as a resolvable {@link Collection} type.\n\t * <p>Returns {@link #NONE} if this type does not implement or extend\n\t * {@link Collection}.\n\t * @see #as(Class)\n\t * @see #asMap()\n\t */\n\tpublic ResolvableType asCollection() {\n\t\treturn as(Collection.class);\n\t}\n\n\t/**\n\t * Convenience method to return this type as a resolvable {@link Map} type.\n\t * <p>Returns {@link #NONE} if this type does not implement or extend\n\t * {@link Map}.\n\t * @see #as(Class)\n\t * @see #asCollection()\n\t */\n\tpublic ResolvableType asMap() {\n\t\treturn as(Map.class);\n\t}\n\n\t/**\n\t * Return this type as a {@code ResolvableType} of the specified class. Searches\n\t * {@link #getSuperType() supertype} and {@link #getInterfaces() interface}\n\t * hierarchies to find a match, returning {@link #NONE} if this type does not\n\t * implement or extend the specified class.\n\t * @param type the required type (typically narrowed)\n\t * @return a {@code ResolvableType} representing this object as the specified\n\t * type, or {@link #NONE} if not resolvable as that type\n\t * @see #asCollection()\n\t * @see #asMap()\n\t * @see #getSuperType()\n\t * @see #getInterfaces()\n\t */\n\tpublic ResolvableType as(Class<?> type) {\n\t\tif (this == NONE) {\n\t\t\treturn NONE;\n\t\t}\n\t\tClass<?> resolved = resolve();\n\t\tif (resolved == null || resolved == type) {\n\t\t\treturn this;\n\t\t}\n\t\tfor (ResolvableType interfaceType : getInterfaces()) {\n\t\t\tResolvableType interfaceAsType = interfaceType.as(type);\n\t\t\tif (interfaceAsType != NONE) {\n\t\t\t\treturn interfaceAsType;\n\t\t\t}\n\t\t}\n\t\treturn getSuperType().as(type);\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} representing the direct supertype of this type.\n\t * <p>If no supertype is available this method returns {@link #NONE}.\n\t * <p>Note: The resulting {@code ResolvableType} instance may not be {@link Serializable}.\n\t * @see #getInterfaces()\n\t */\n\tpublic ResolvableType getSuperType() {\n\t\tClass<?> resolved = resolve();\n\t\tif (resolved == null) {\n\t\t\treturn NONE;\n\t\t}\n\t\ttry {\n\t\t\tType superclass = resolved.getGenericSuperclass();\n\t\t\tif (superclass == null) {\n\t\t\t\treturn NONE;\n\t\t\t}\n\t\t\tResolvableType superType = this.superType;\n\t\t\tif (superType == null) {\n\t\t\t\tsuperType = forType(superclass, this);\n\t\t\t\tthis.superType = superType;\n\t\t\t}\n\t\t\treturn superType;\n\t\t}\n\t\tcatch (TypeNotPresentException ex) {\n\t\t\t// Ignore non-present types in generic signature\n\t\t\treturn NONE;\n\t\t}\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} array representing the direct interfaces\n\t * implemented by this type. If this type does not implement any interfaces an\n\t * empty array is returned.\n\t * <p>Note: The resulting {@code ResolvableType} instances may not be {@link Serializable}.\n\t * @see #getSuperType()\n\t */\n\tpublic ResolvableType[] getInterfaces() {\n\t\tClass<?> resolved = resolve();\n\t\tif (resolved == null) {\n\t\t\treturn EMPTY_TYPES_ARRAY;\n\t\t}\n\t\tResolvableType[] interfaces = this.interfaces;\n\t\tif (interfaces == null) {\n\t\t\tType[] genericIfcs = resolved.getGenericInterfaces();\n\t\t\tif (genericIfcs.length > 0) {\n\t\t\t\tinterfaces = new ResolvableType[genericIfcs.length];\n\t\t\t\tfor (int i = 0; i < genericIfcs.length; i++) {\n\t\t\t\t\tinterfaces[i] = forType(genericIfcs[i], this);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinterfaces = EMPTY_TYPES_ARRAY;\n\t\t\t}\n\t\t\tthis.interfaces = interfaces;\n\t\t}\n\t\treturn interfaces;\n\t}\n\n\t/**\n\t * Return {@code true} if this type contains generic parameters.\n\t * @see #getGeneric(int...)\n\t * @see #getGenerics()\n\t */\n\tpublic boolean hasGenerics() {\n\t\treturn (getGenerics().length > 0);\n\t}\n\n\t/**\n\t * Return {@code true} if this type contains at least a generic type\n\t * that is resolved. In other words, this returns {@code false} if\n\t * the type contains unresolvable generics only, that is, no substitute\n\t * for any of its declared type variables.\n\t * @since 6.2\n\t */\n\tpublic boolean hasResolvableGenerics() {\n\t\tif (this == NONE) {\n\t\t\treturn false;\n\t\t}\n\t\tResolvableType[] generics = getGenerics();\n\t\tfor (ResolvableType generic : generics) {\n\t\t\tif (!generic.isUnresolvableTypeVariable() && !generic.isWildcardWithoutBounds()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Determine whether the underlying type has any unresolvable generics:\n\t * either through an unresolvable type variable on the type itself\n\t * or through implementing a generic interface in a raw fashion,\n\t * i.e. without substituting that interface's type variables.\n\t * The result will be {@code true} only in those two scenarios.\n\t */\n\tpublic boolean hasUnresolvableGenerics() {\n\t\tif (this == NONE) {\n\t\t\treturn false;\n\t\t}\n\t\treturn hasUnresolvableGenerics(null);\n\t}\n\n\tprivate boolean hasUnresolvableGenerics(@Nullable Set<Type> alreadySeen) {\n\t\tBoolean unresolvableGenerics = this.unresolvableGenerics;\n\t\tif (unresolvableGenerics == null) {\n\t\t\tunresolvableGenerics = determineUnresolvableGenerics(alreadySeen);\n\t\t\tthis.unresolvableGenerics = unresolvableGenerics;\n\t\t}\n\t\treturn unresolvableGenerics;\n\t}\n\n\tprivate boolean determineUnresolvableGenerics(@Nullable Set<Type> alreadySeen) {\n\t\tif (alreadySeen != null && alreadySeen.contains(this.type)) {\n\t\t\t// Self-referencing generic -> not unresolvable\n\t\t\treturn false;\n\t\t}\n\n\t\tResolvableType[] generics = getGenerics();\n\t\tfor (ResolvableType generic : generics) {\n\t\t\tif (generic.isUnresolvableTypeVariable() || generic.isWildcardWithoutBounds() ||\n\t\t\t\t\tgeneric.hasUnresolvableGenerics(currentTypeSeen(alreadySeen))) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tClass<?> resolved = resolve();\n\t\tif (resolved != null) {\n\t\t\ttry {\n\t\t\t\tfor (Type genericInterface : resolved.getGenericInterfaces()) {\n\t\t\t\t\tif (genericInterface instanceof Class<?> clazz) {\n\t\t\t\t\t\tif (clazz.getTypeParameters().length > 0) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeNotPresentException ex) {\n\t\t\t\t// Ignore non-present types in generic signature\n\t\t\t}\n\t\t\tClass<?> superclass = resolved.getSuperclass();\n\t\t\tif (superclass != null && superclass != Object.class) {\n\t\t\t\treturn getSuperType().hasUnresolvableGenerics(currentTypeSeen(alreadySeen));\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate Set<Type> currentTypeSeen(@Nullable Set<Type> alreadySeen) {\n\t\tif (alreadySeen == null) {\n\t\t\talreadySeen = new HashSet<>(4);\n\t\t}\n\t\talreadySeen.add(this.type);\n\t\treturn alreadySeen;\n\t}\n\n\t/**\n\t * Determine whether the underlying type is a type variable that\n\t * cannot be resolved through the associated variable resolver.\n\t */\n\tprivate boolean isUnresolvableTypeVariable() {\n\t\tif (this.type instanceof TypeVariable<?> variable) {\n\t\t\tif (this.variableResolver == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tResolvableType resolved = this.variableResolver.resolveVariable(variable);\n\t\t\tif (resolved == null || resolved.isUnresolvableTypeVariable() || resolved.isWildcardWithoutBounds()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Determine whether the underlying type represents a wildcard\n\t * without specific bounds (i.e., equal to {@code ? extends Object}).\n\t */\n\tprivate boolean isWildcardWithoutBounds() {\n\t\tif (this.type instanceof WildcardType wildcardType) {\n\t\t\tif (wildcardType.getLowerBounds().length == 0) {\n\t\t\t\tType[] upperBounds = wildcardType.getUpperBounds();\n\t\t\t\tif (upperBounds.length == 0 || (upperBounds.length == 1 && Object.class == upperBounds[0])) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} for the specified nesting level.\n\t * <p>See {@link #getNested(int, Map)} for details.\n\t * @param nestingLevel the nesting level\n\t * @return the {@code ResolvableType} type, or {@code #NONE}\n\t */\n\tpublic ResolvableType getNested(int nestingLevel) {\n\t\treturn getNested(nestingLevel, null);\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} for the specified nesting level.\n\t * <p>The nesting level refers to the specific generic parameter that should be returned.\n\t * A nesting level of 1 indicates this type; 2 indicates the first nested generic;\n\t * 3 the second; and so on. For example, given {@code List<Set<Integer>>} level 1 refers\n\t * to the {@code List}, level 2 the {@code Set}, and level 3 the {@code Integer}.\n\t * <p>The {@code typeIndexesPerLevel} map can be used to reference a specific generic\n\t * for the given level. For example, an index of 0 would refer to a {@code Map} key;\n\t * whereas, 1 would refer to the value. If the map does not contain a value for a\n\t * specific level the last generic will be used (for example, a {@code Map} value).\n\t * <p>Nesting levels may also apply to array types; for example given\n\t * {@code String[]}, a nesting level of 2 refers to {@code String}.\n\t * <p>If a type does not {@link #hasGenerics() contain} generics the\n\t * {@link #getSuperType() supertype} hierarchy will be considered.\n\t * @param nestingLevel the required nesting level, indexed from 1 for the\n\t * current type, 2 for the first nested generic, 3 for the second and so on\n\t * @param typeIndexesPerLevel a map containing the generic index for a given\n\t * nesting level (can be {@code null})\n\t * @return a {@code ResolvableType} for the nested level, or {@link #NONE}\n\t */\n\tpublic ResolvableType getNested(int nestingLevel, @Nullable Map<Integer, Integer> typeIndexesPerLevel) {\n\t\tResolvableType result = this;\n\t\tfor (int i = 2; i <= nestingLevel; i++) {\n\t\t\tif (result.isArray()) {\n\t\t\t\tresult = result.getComponentType();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Handle derived types\n\t\t\t\twhile (result != ResolvableType.NONE && !result.hasGenerics()) {\n\t\t\t\t\tresult = result.getSuperType();\n\t\t\t\t}\n\t\t\t\tInteger index = (typeIndexesPerLevel != null ? typeIndexesPerLevel.get(i) : null);\n\t\t\t\tindex = (index == null ? result.getGenerics().length - 1 : index);\n\t\t\t\tresult = result.getGeneric(index);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} representing the generic parameter for the\n\t * given indexes. Indexes are zero based; for example given the type\n\t * {@code Map<Integer, List<String>>}, {@code getGeneric(0)} will access the\n\t * {@code Integer}. Nested generics can be accessed by specifying multiple indexes;\n\t * for example {@code getGeneric(1, 0)} will access the {@code String} from the\n\t * nested {@code List}. For convenience, if no indexes are specified the first\n\t * generic is returned.\n\t * <p>If no generic is available at the specified indexes {@link #NONE} is returned.\n\t * @param indexes the indexes that refer to the generic parameter\n\t * (can be omitted to return the first generic)\n\t * @return a {@code ResolvableType} for the specified generic, or {@link #NONE}\n\t * @see #hasGenerics()\n\t * @see #getGenerics()\n\t * @see #resolveGeneric(int...)\n\t * @see #resolveGenerics()\n\t */\n\tpublic ResolvableType getGeneric(int @Nullable ... indexes) {\n\t\tResolvableType[] generics = getGenerics();\n\t\tif (indexes == null || indexes.length == 0) {\n\t\t\treturn (generics.length == 0 ? NONE : generics[0]);\n\t\t}\n\t\tResolvableType generic = this;\n\t\tfor (int index : indexes) {\n\t\t\tgenerics = generic.getGenerics();\n\t\t\tif (index < 0 || index >= generics.length) {\n\t\t\t\treturn NONE;\n\t\t\t}\n\t\t\tgeneric = generics[index];\n\t\t}\n\t\treturn generic;\n\t}\n\n\t/**\n\t * Return an array of {@code ResolvableType ResolvableTypes} representing the generic parameters of\n\t * this type. If no generics are available an empty array is returned. If you need to\n\t * access a specific generic consider using the {@link #getGeneric(int...)} method as\n\t * it allows access to nested generics and protects against\n\t * {@code IndexOutOfBoundsExceptions}.\n\t * @return an array of {@code ResolvableType ResolvableTypes} representing the generic parameters\n\t * (never {@code null})\n\t * @see #hasGenerics()\n\t * @see #getGeneric(int...)\n\t * @see #resolveGeneric(int...)\n\t * @see #resolveGenerics()\n\t */\n\tpublic ResolvableType[] getGenerics() {\n\t\tif (this == NONE) {\n\t\t\treturn EMPTY_TYPES_ARRAY;\n\t\t}\n\t\tResolvableType[] generics = this.generics;\n\t\tif (generics == null) {\n\t\t\tif (this.type instanceof Class<?> clazz) {\n\t\t\t\tType[] typeParams = clazz.getTypeParameters();\n\t\t\t\tif (typeParams.length > 0) {\n\t\t\t\t\tgenerics = new ResolvableType[typeParams.length];\n\t\t\t\t\tfor (int i = 0; i < generics.length; i++) {\n\t\t\t\t\t\tgenerics[i] = ResolvableType.forType(typeParams[i], this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgenerics = EMPTY_TYPES_ARRAY;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (this.type instanceof ParameterizedType parameterizedType) {\n\t\t\t\tType[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n\t\t\t\tif (actualTypeArguments.length > 0) {\n\t\t\t\t\tgenerics = new ResolvableType[actualTypeArguments.length];\n\t\t\t\t\tfor (int i = 0; i < actualTypeArguments.length; i++) {\n\t\t\t\t\t\tgenerics[i] = forType(actualTypeArguments[i], this.variableResolver);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgenerics = EMPTY_TYPES_ARRAY;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgenerics = resolveType().getGenerics();\n\t\t\t}\n\t\t\tthis.generics = generics;\n\t\t}\n\t\treturn generics;\n\t}\n\n\t/**\n\t * Convenience method that will {@link #getGenerics() get} and\n\t * {@link #resolve() resolve} generic parameters.\n\t * @return an array of resolved generic parameters (the resulting array\n\t * will never be {@code null}, but it may contain {@code null} elements)\n\t * @see #getGenerics()\n\t * @see #resolve()\n\t */\n\tpublic @Nullable Class<?>[] resolveGenerics() {\n\t\tResolvableType[] generics = getGenerics();\n\t\t@Nullable Class<?>[] resolvedGenerics = new Class<?>[generics.length];\n\t\tfor (int i = 0; i < generics.length; i++) {\n\t\t\tresolvedGenerics[i] = generics[i].resolve();\n\t\t}\n\t\treturn resolvedGenerics;\n\t}\n\n\t/**\n\t * Convenience method that will {@link #getGenerics() get} and {@link #resolve()\n\t * resolve} generic parameters, using the specified {@code fallback} if any type\n\t * cannot be resolved.\n\t * @param fallback the fallback class to use if resolution fails\n\t * @return an array of resolved generic parameters\n\t * @see #getGenerics()\n\t * @see #resolve()\n\t */\n\tpublic Class<?>[] resolveGenerics(Class<?> fallback) {\n\t\tResolvableType[] generics = getGenerics();\n\t\tClass<?>[] resolvedGenerics = new Class<?>[generics.length];\n\t\tfor (int i = 0; i < generics.length; i++) {\n\t\t\tresolvedGenerics[i] = generics[i].resolve(fallback);\n\t\t}\n\t\treturn resolvedGenerics;\n\t}\n\n\t/**\n\t * Convenience method that will {@link #getGeneric(int...) get} and\n\t * {@link #resolve() resolve} a specific generic parameter.\n\t * @param indexes the indexes that refer to the generic parameter\n\t * (can be omitted to return the first generic)\n\t * @return a resolved {@link Class} or {@code null}\n\t * @see #getGeneric(int...)\n\t * @see #resolve()\n\t */\n\tpublic @Nullable Class<?> resolveGeneric(int... indexes) {\n\t\treturn getGeneric(indexes).resolve();\n\t}\n\n\t/**\n\t * Resolve this type to a {@link java.lang.Class}, returning {@code null}\n\t * if the type cannot be resolved. This method will consider bounds of\n\t * {@link TypeVariable TypeVariables} and {@link WildcardType WildcardTypes} if\n\t * direct resolution fails; however, bounds of {@code Object.class} will be ignored.\n\t * <p>If this method returns a non-null {@code Class} and {@link #hasGenerics()}\n\t * returns {@code false}, the given type effectively wraps a plain {@code Class},\n\t * allowing for plain {@code Class} processing if desirable.\n\t * @return the resolved {@link Class}, or {@code null} if not resolvable\n\t * @see #resolve(Class)\n\t * @see #resolveGeneric(int...)\n\t * @see #resolveGenerics()\n\t */\n\tpublic @Nullable Class<?> resolve() {\n\t\treturn this.resolved;\n\t}\n\n\t/**\n\t * Resolve this type to a {@link java.lang.Class}, returning the specified\n\t * {@code fallback} if the type cannot be resolved. This method will consider bounds\n\t * of {@link TypeVariable TypeVariables} and {@link WildcardType WildcardTypes} if\n\t * direct resolution fails; however, bounds of {@code Object.class} will be ignored.\n\t * @param fallback the fallback class to use if resolution fails\n\t * @return the resolved {@link Class} or the {@code fallback}\n\t * @see #resolve()\n\t * @see #resolveGeneric(int...)\n\t * @see #resolveGenerics()\n\t */\n\tpublic Class<?> resolve(Class<?> fallback) {\n\t\treturn (this.resolved != null ? this.resolved : fallback);\n\t}\n\n\tprivate @Nullable Class<?> resolveClass() {\n\t\tif (this.type == EmptyType.INSTANCE) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this.type instanceof Class<?> clazz) {\n\t\t\treturn clazz;\n\t\t}\n\t\tif (this.type instanceof GenericArrayType) {\n\t\t\tClass<?> resolvedComponent = getComponentType().resolve();\n\t\t\treturn (resolvedComponent != null ? Array.newInstance(resolvedComponent, 0).getClass() : null);\n\t\t}\n\t\treturn resolveType().resolve();\n\t}\n\n\t/**\n\t * Resolve this type by a single level, returning the resolved value or {@link #NONE}.\n\t * <p>Note: The returned {@code ResolvableType} should only be used as an intermediary\n\t * as it cannot be serialized.\n\t */\n\tResolvableType resolveType() {\n\t\tif (this.type instanceof ParameterizedType parameterizedType) {\n\t\t\treturn forType(parameterizedType.getRawType(), this.variableResolver);\n\t\t}\n\t\tif (this.type instanceof WildcardType wildcardType) {\n\t\t\tType resolved = resolveBounds(wildcardType.getUpperBounds());\n\t\t\tif (resolved == null) {\n\t\t\t\tresolved = resolveBounds(wildcardType.getLowerBounds());\n\t\t\t}\n\t\t\treturn forType(resolved, this.variableResolver);\n\t\t}\n\t\tif (this.type instanceof TypeVariable<?> variable) {\n\t\t\t// Try default variable resolution\n\t\t\tif (this.variableResolver != null) {\n\t\t\t\tResolvableType resolved = this.variableResolver.resolveVariable(variable);\n\t\t\t\tif (resolved != null) {\n\t\t\t\t\treturn resolved;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Fallback to bounds\n\t\t\treturn forType(resolveBounds(variable.getBounds()), this.variableResolver);\n\t\t}\n\t\treturn NONE;\n\t}\n\n\tprivate @Nullable ResolvableType resolveVariable(TypeVariable<?> variable) {\n\t\tif (this.type instanceof TypeVariable) {\n\t\t\treturn resolveType().resolveVariable(variable);\n\t\t}\n\t\tif (this.type instanceof ParameterizedType parameterizedType) {\n\t\t\tClass<?> resolved = resolve();\n\t\t\tif (resolved == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tTypeVariable<?>[] variables = resolved.getTypeParameters();\n\t\t\tfor (int i = 0; i < variables.length; i++) {\n\t\t\t\tif (ObjectUtils.nullSafeEquals(variables[i].getName(), variable.getName())) {\n\t\t\t\t\tType actualType = parameterizedType.getActualTypeArguments()[i];\n\t\t\t\t\treturn forType(actualType, this.variableResolver);\n\t\t\t\t}\n\t\t\t}\n\t\t\tType ownerType = parameterizedType.getOwnerType();\n\t\t\tif (ownerType != null) {\n\t\t\t\treturn forType(ownerType, this.variableResolver).resolveVariable(variable);\n\t\t\t}\n\t\t}\n\t\tif (this.type instanceof WildcardType) {\n\t\t\tResolvableType resolved = resolveType().resolveVariable(variable);\n\t\t\tif (resolved != null) {\n\t\t\t\treturn resolved;\n\t\t\t}\n\t\t}\n\t\tif (this.variableResolver != null) {\n\t\t\treturn this.variableResolver.resolveVariable(variable);\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t/**\n\t * Check for full equality of all type resolution artifacts:\n\t * type as well as {@code TypeProvider} and {@code VariableResolver}.\n\t * @see #equalsType(ResolvableType)\n\t */\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (other == null || other.getClass() != getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\tResolvableType otherType = (ResolvableType) other;\n\n\t\tif (!equalsType(otherType)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.typeProvider != otherType.typeProvider &&\n\t\t\t\t(this.typeProvider == null || otherType.typeProvider == null ||\n\t\t\t\t!ObjectUtils.nullSafeEquals(this.typeProvider.getType(), otherType.typeProvider.getType()))) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.variableResolver != otherType.variableResolver &&\n\t\t\t\t(this.variableResolver == null || otherType.variableResolver == null ||\n\t\t\t\t!ObjectUtils.nullSafeEquals(this.variableResolver.getSource(), otherType.variableResolver.getSource()))) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Check for type-level equality with another {@code ResolvableType}.\n\t * <p>In contrast to {@link #equals(Object)} or {@link #isAssignableFrom(ResolvableType)},\n\t * this works between different sources as well, for example, method parameters and return types.\n\t * @param otherType the {@code ResolvableType} to match against\n\t * @return whether the declared type and type variables match\n\t * @since 6.1\n\t */\n\tpublic boolean equalsType(ResolvableType otherType) {\n\t\treturn (ObjectUtils.nullSafeEquals(this.type, otherType.type) &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.componentType, otherType.componentType));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn (this.hash != null ? this.hash : calculateHashCode());\n\t}\n\n\tprivate int calculateHashCode() {\n\t\tint hashCode = ObjectUtils.nullSafeHashCode(this.type);\n\t\tif (this.componentType != null) {\n\t\t\thashCode = 31 * hashCode + ObjectUtils.nullSafeHashCode(this.componentType);\n\t\t}\n\t\tif (this.typeProvider != null) {\n\t\t\thashCode = 31 * hashCode + ObjectUtils.nullSafeHashCode(this.typeProvider.getType());\n\t\t}\n\t\tif (this.variableResolver != null) {\n\t\t\thashCode = 31 * hashCode + ObjectUtils.nullSafeHashCode(this.variableResolver.getSource());\n\t\t}\n\t\treturn hashCode;\n\t}\n\n\t/**\n\t * Adapts this {@code ResolvableType} to a {@link VariableResolver}.\n\t */\n\t@Nullable VariableResolver asVariableResolver() {\n\t\tif (this == NONE) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new DefaultVariableResolver(this);\n\t}\n\n\t/**\n\t * Custom serialization support for {@link #NONE}.\n\t */\n\tprivate Object readResolve() {\n\t\treturn (this.type == EmptyType.INSTANCE ? NONE : this);\n\t}\n\n\t/**\n\t * Return a String representation of this type in its fully resolved form\n\t * (including any generic parameters).\n\t */\n\t@Override\n\tpublic String toString() {\n\t\tif (isArray()) {\n\t\t\treturn getComponentType() + \"[]\";\n\t\t}\n\t\tif (this.resolved == null) {\n\t\t\treturn \"?\";\n\t\t}\n\t\tif (this.type instanceof TypeVariable<?> variable) {\n\t\t\tif (this.variableResolver == null || this.variableResolver.resolveVariable(variable) == null) {\n\t\t\t\t// Don't bother with variable boundaries for toString()...\n\t\t\t\t// Can cause infinite recursions in case of self-references\n\t\t\t\treturn \"?\";\n\t\t\t}\n\t\t}\n\t\tif (hasGenerics()) {\n\t\t\treturn this.resolved.getName() + '<' + StringUtils.arrayToDelimitedString(getGenerics(), \", \") + '>';\n\t\t}\n\t\treturn this.resolved.getName();\n\t}\n\n\n\t// Factory methods\n\n\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Class},\n\t * using the full generic type information for assignability checks.\n\t * <p>For example: {@code ResolvableType.forClass(MyArrayList.class)}.\n\t * @param clazz the class to introspect ({@code null} is semantically\n\t * equivalent to {@code Object.class} for typical use cases here)\n\t * @return a {@code ResolvableType} for the specified class\n\t * @see #forClass(Class, Class)\n\t * @see #forClassWithGenerics(Class, Class...)\n\t */\n\tpublic static ResolvableType forClass(@Nullable Class<?> clazz) {\n\t\treturn new ResolvableType(clazz);\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Class},\n\t * doing assignability checks against the raw class only (analogous to\n\t * {@link Class#isAssignableFrom}, which this serves as a wrapper for).\n\t * <p>For example: {@code ResolvableType.forRawClass(List.class)}.\n\t * @param clazz the class to introspect ({@code null} is semantically\n\t * equivalent to {@code Object.class} for typical use cases here)\n\t * @return a {@code ResolvableType} for the specified class\n\t * @since 4.2\n\t * @see #forClass(Class)\n\t * @see #getRawClass()\n\t */\n\tpublic static ResolvableType forRawClass(@Nullable Class<?> clazz) {\n\t\treturn new ResolvableType(clazz) {\n\t\t\t@Override\n\t\t\tpublic ResolvableType[] getGenerics() {\n\t\t\t\treturn EMPTY_TYPES_ARRAY;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean isAssignableFrom(Class<?> other) {\n\t\t\t\treturn (clazz == null || ClassUtils.isAssignable(clazz, other));\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean isAssignableFrom(ResolvableType other) {\n\t\t\t\tClass<?> otherClass = other.resolve();\n\t\t\t\treturn (otherClass != null && (clazz == null || ClassUtils.isAssignable(clazz, otherClass)));\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} for the specified base type\n\t * (interface or base class) with a given implementation class.\n\t * <p>For example: {@code ResolvableType.forClass(List.class, MyArrayList.class)}.\n\t * @param baseType the base type (must not be {@code null})\n\t * @param implementationClass the implementation class\n\t * @return a {@code ResolvableType} for the specified base type backed by the\n\t * given implementation class\n\t * @see #forClass(Class)\n\t * @see #forClassWithGenerics(Class, Class...)\n\t */\n\tpublic static ResolvableType forClass(Class<?> baseType, Class<?> implementationClass) {\n\t\tAssert.notNull(baseType, \"Base type must not be null\");\n\t\tResolvableType asType = forType(implementationClass).as(baseType);\n\t\treturn (asType == NONE ? forType(baseType) : asType);\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Class} with pre-declared generics.\n\t * @param clazz the class (or interface) to introspect\n\t * @param generics the generics of the class\n\t * @return a {@code ResolvableType} for the specific class and generics\n\t * @see #forClassWithGenerics(Class, ResolvableType...)\n\t */\n\tpublic static ResolvableType forClassWithGenerics(Class<?> clazz, Class<?>... generics) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(generics, \"Generics array must not be null\");\n\t\tResolvableType[] resolvableGenerics = new ResolvableType[generics.length];\n\t\tfor (int i = 0; i < generics.length; i++) {\n\t\t\tresolvableGenerics[i] = forClass(generics[i]);\n\t\t}\n\t\treturn forClassWithGenerics(clazz, resolvableGenerics);\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Class} with pre-declared generics.\n\t * @param clazz the class (or interface) to introspect\n\t * @param generics the generics of the class\n\t * @return a {@code ResolvableType} for the specific class and generics\n\t * @see #forClassWithGenerics(Class, Class...)\n\t */\n\tpublic static ResolvableType forClassWithGenerics(Class<?> clazz, @Nullable ResolvableType @Nullable ... generics) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tTypeVariable<?>[] variables = clazz.getTypeParameters();\n\t\tif (generics != null) {\n\t\t\tAssert.isTrue(variables.length == generics.length,\n\t\t\t\t\t() -> \"Mismatched number of generics specified for \" + clazz.toGenericString());\n\t\t}\n\t\tType[] arguments = new Type[variables.length];\n\t\tfor (int i = 0; i < variables.length; i++) {\n\t\t\tResolvableType generic = (generics != null ? generics[i] : null);\n\t\t\tType argument = (generic != null ? generic.getType() : null);\n\t\t\targuments[i] = (argument != null && !(argument instanceof TypeVariable) ? argument : variables[i]);\n\t\t}\n\t\treturn forType(new SyntheticParameterizedType(clazz, arguments),\n\t\t\t\t(generics != null ? new TypeVariablesVariableResolver(variables, generics) : null));\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} for the specified instance. The instance does not\n\t * convey generic information but if it implements {@link ResolvableTypeProvider} a\n\t * more precise {@code ResolvableType} can be used than the simple one based on\n\t * the {@link #forClass(Class) Class instance}.\n\t * @param instance the instance (possibly {@code null})\n\t * @return a {@code ResolvableType} for the specified instance,\n\t * or {@code NONE} for {@code null}\n\t * @since 4.2\n\t * @see ResolvableTypeProvider\n\t */\n\tpublic static ResolvableType forInstance(@Nullable Object instance) {\n\t\tif (instance instanceof ResolvableTypeProvider resolvableTypeProvider) {\n\t\t\tResolvableType type = resolvableTypeProvider.getResolvableType();\n\t\t\tif (type != null) {\n\t\t\t\treturn type;\n\t\t\t}\n\t\t}\n\t\treturn (instance != null ? forClass(instance.getClass()) : NONE);\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Field}.\n\t * @param field the source field\n\t * @return a {@code ResolvableType} for the specified field\n\t * @see #forField(Field, Class)\n\t */\n\tpublic static ResolvableType forField(Field field) {\n\t\tAssert.notNull(field, \"Field must not be null\");\n\t\treturn forType(null, new FieldTypeProvider(field), null);\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Field} with a given\n\t * implementation.\n\t * <p>Use this variant when the class that declares the field includes generic\n\t * parameter variables that are satisfied by the implementation class.\n\t * @param field the source field\n\t * @param implementationClass the implementation class\n\t * @return a {@code ResolvableType} for the specified field\n\t * @see #forField(Field)\n\t */\n\tpublic static ResolvableType forField(Field field, Class<?> implementationClass) {\n\t\tAssert.notNull(field, \"Field must not be null\");\n\t\tResolvableType owner = forType(implementationClass).as(field.getDeclaringClass());\n\t\treturn forType(null, new FieldTypeProvider(field), owner.asVariableResolver());\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Field} with a given\n\t * implementation.\n\t * <p>Use this variant when the class that declares the field includes generic\n\t * parameter variables that are satisfied by the implementation type.\n\t * @param field the source field\n\t * @param implementationType the implementation type\n\t * @return a {@code ResolvableType} for the specified field\n\t * @see #forField(Field)\n\t */\n\tpublic static ResolvableType forField(Field field, @Nullable ResolvableType implementationType) {\n\t\tAssert.notNull(field, \"Field must not be null\");\n\t\tResolvableType owner = (implementationType != null ? implementationType : NONE);\n\t\towner = owner.as(field.getDeclaringClass());\n\t\treturn forType(null, new FieldTypeProvider(field), owner.asVariableResolver());\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Field} with the\n\t * given nesting level.\n\t * @param field the source field\n\t * @param nestingLevel the nesting level (1 for the outer level; 2 for a nested\n\t * generic type; etc)\n\t * @see #forField(Field)\n\t */\n\tpublic static ResolvableType forField(Field field, int nestingLevel) {\n\t\tAssert.notNull(field, \"Field must not be null\");\n\t\treturn forType(null, new FieldTypeProvider(field), null).getNested(nestingLevel);\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Field} with a given\n\t * implementation and the given nesting level.\n\t * <p>Use this variant when the class that declares the field includes generic\n\t * parameter variables that are satisfied by the implementation class.\n\t * @param field the source field\n\t * @param nestingLevel the nesting level (1 for the outer level; 2 for a nested\n\t * generic type; etc)\n\t * @param implementationClass the implementation class\n\t * @return a {@code ResolvableType} for the specified field\n\t * @see #forField(Field)\n\t */\n\tpublic static ResolvableType forField(Field field, int nestingLevel, @Nullable Class<?> implementationClass) {\n\t\tAssert.notNull(field, \"Field must not be null\");\n\t\tResolvableType owner = forType(implementationClass).as(field.getDeclaringClass());\n\t\treturn forType(null, new FieldTypeProvider(field), owner.asVariableResolver()).getNested(nestingLevel);\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Constructor} parameter.\n\t * @param constructor the source constructor (must not be {@code null})\n\t * @param parameterIndex the parameter index\n\t * @return a {@code ResolvableType} for the specified constructor parameter\n\t * @see #forConstructorParameter(Constructor, int, Class)\n\t */\n\tpublic static ResolvableType forConstructorParameter(Constructor<?> constructor, int parameterIndex) {\n\t\tAssert.notNull(constructor, \"Constructor must not be null\");\n\t\treturn forMethodParameter(new MethodParameter(constructor, parameterIndex));\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Constructor} parameter\n\t * with a given implementation. Use this variant when the class that declares the\n\t * constructor includes generic parameter variables that are satisfied by the\n\t * implementation class.\n\t * @param constructor the source constructor (must not be {@code null})\n\t * @param parameterIndex the parameter index\n\t * @param implementationClass the implementation class\n\t * @return a {@code ResolvableType} for the specified constructor parameter\n\t * @see #forConstructorParameter(Constructor, int)\n\t */\n\tpublic static ResolvableType forConstructorParameter(Constructor<?> constructor, int parameterIndex,\n\t\t\tClass<?> implementationClass) {\n\n\t\tAssert.notNull(constructor, \"Constructor must not be null\");\n\t\tMethodParameter methodParameter = new MethodParameter(constructor, parameterIndex, implementationClass);\n\t\treturn forMethodParameter(methodParameter);\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Method} return type.\n\t * @param method the source for the method return type\n\t * @return a {@code ResolvableType} for the specified method return\n\t * @see #forMethodReturnType(Method, Class)\n\t */\n\tpublic static ResolvableType forMethodReturnType(Method method) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\treturn forMethodParameter(new MethodParameter(method, -1));\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Method} return type.\n\t * <p>Use this variant when the class that declares the method includes generic\n\t * parameter variables that are satisfied by the implementation class.\n\t * @param method the source for the method return type\n\t * @param implementationClass the implementation class\n\t * @return a {@code ResolvableType} for the specified method return\n\t * @see #forMethodReturnType(Method)\n\t */\n\tpublic static ResolvableType forMethodReturnType(Method method, Class<?> implementationClass) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\tMethodParameter methodParameter = new MethodParameter(method, -1, implementationClass);\n\t\treturn forMethodParameter(methodParameter);\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Method} parameter.\n\t * @param method the source method (must not be {@code null})\n\t * @param parameterIndex the parameter index\n\t * @return a {@code ResolvableType} for the specified method parameter\n\t * @see #forMethodParameter(Method, int, Class)\n\t * @see #forMethodParameter(MethodParameter)\n\t */\n\tpublic static ResolvableType forMethodParameter(Method method, int parameterIndex) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\treturn forMethodParameter(new MethodParameter(method, parameterIndex));\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Method} parameter with a\n\t * given implementation. Use this variant when the class that declares the method\n\t * includes generic parameter variables that are satisfied by the implementation class.\n\t * @param method the source method (must not be {@code null})\n\t * @param parameterIndex the parameter index\n\t * @param implementationClass the implementation class\n\t * @return a {@code ResolvableType} for the specified method parameter\n\t * @see #forMethodParameter(Method, int, Class)\n\t * @see #forMethodParameter(MethodParameter)\n\t */\n\tpublic static ResolvableType forMethodParameter(Method method, int parameterIndex, Class<?> implementationClass) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\tMethodParameter methodParameter = new MethodParameter(method, parameterIndex, implementationClass);\n\t\treturn forMethodParameter(methodParameter);\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} for the specified {@link MethodParameter}.\n\t * @param methodParameter the source method parameter (must not be {@code null})\n\t * @return a {@code ResolvableType} for the specified method parameter\n\t * @see #forMethodParameter(Method, int)\n\t */\n\tpublic static ResolvableType forMethodParameter(MethodParameter methodParameter) {\n\t\treturn forMethodParameter(methodParameter, (Type) null);\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} for the specified {@link MethodParameter} with a\n\t * given implementation type. Use this variant when the class that declares the method\n\t * includes generic parameter variables that are satisfied by the implementation type.\n\t * @param methodParameter the source method parameter (must not be {@code null})\n\t * @param implementationType the implementation type\n\t * @return a {@code ResolvableType} for the specified method parameter\n\t * @see #forMethodParameter(MethodParameter)\n\t */\n\tpublic static ResolvableType forMethodParameter(MethodParameter methodParameter,\n\t\t\t@Nullable ResolvableType implementationType) {\n\n\t\tAssert.notNull(methodParameter, \"MethodParameter must not be null\");\n\t\timplementationType = (implementationType != null ? implementationType :\n\t\t\t\tforType(methodParameter.getContainingClass()));\n\t\tResolvableType owner = implementationType.as(methodParameter.getDeclaringClass());\n\t\treturn forType(null, new MethodParameterTypeProvider(methodParameter), owner.asVariableResolver()).\n\t\t\t\tgetNested(methodParameter.getNestingLevel(), methodParameter.typeIndexesPerLevel);\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} for the specified {@link MethodParameter},\n\t * overriding the target type to resolve with a specific given type.\n\t * @param methodParameter the source method parameter (must not be {@code null})\n\t * @param targetType the type to resolve (a part of the method parameter's type)\n\t * @return a {@code ResolvableType} for the specified method parameter\n\t * @see #forMethodParameter(Method, int)\n\t */\n\tpublic static ResolvableType forMethodParameter(MethodParameter methodParameter, @Nullable Type targetType) {\n\t\tAssert.notNull(methodParameter, \"MethodParameter must not be null\");\n\t\treturn forMethodParameter(methodParameter, targetType, methodParameter.getNestingLevel());\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} for the specified {@link MethodParameter} at\n\t * a specific nesting level, overriding the target type to resolve with a specific\n\t * given type.\n\t * @param methodParameter the source method parameter (must not be {@code null})\n\t * @param targetType the type to resolve (a part of the method parameter's type)\n\t * @param nestingLevel the nesting level to use\n\t * @return a {@code ResolvableType} for the specified method parameter\n\t * @since 5.2\n\t * @see #forMethodParameter(Method, int)\n\t */\n\tstatic ResolvableType forMethodParameter(\n\t\t\tMethodParameter methodParameter, @Nullable Type targetType, int nestingLevel) {\n\n\t\tResolvableType owner = forType(methodParameter.getContainingClass()).as(methodParameter.getDeclaringClass());\n\t\treturn forType(targetType, new MethodParameterTypeProvider(methodParameter), owner.asVariableResolver()).\n\t\t\t\tgetNested(nestingLevel, methodParameter.typeIndexesPerLevel);\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} as an array of the specified {@code componentType}.\n\t * @param componentType the component type\n\t * @return a {@code ResolvableType} as an array of the specified component type\n\t */\n\tpublic static ResolvableType forArrayComponent(ResolvableType componentType) {\n\t\tAssert.notNull(componentType, \"Component type must not be null\");\n\t\tClass<?> arrayType = componentType.toClass().arrayType();\n\t\treturn new ResolvableType(arrayType, componentType, null, null);\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} for the bounds of the specified {@link TypeVariable}.\n\t * @param typeVariable the type variable\n\t * @return a {@code ResolvableType} for the specified bounds\n\t * @since 6.2.3\n\t */\n\tstatic ResolvableType forVariableBounds(TypeVariable<?> typeVariable) {\n\t\treturn forType(resolveBounds(typeVariable.getBounds()));\n\t}\n\n\tprivate static @Nullable Type resolveBounds(Type[] bounds) {\n\t\tif (bounds.length == 0 || bounds[0] == Object.class) {\n\t\t\treturn null;\n\t\t}\n\t\treturn bounds[0];\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Type}.\n\t * <p>Note: The resulting {@code ResolvableType} instance may not be {@link Serializable}.\n\t * @param type the source type (potentially {@code null})\n\t * @return a {@code ResolvableType} for the specified {@link Type}\n\t * @see #forType(Type, ResolvableType)\n\t */\n\tpublic static ResolvableType forType(@Nullable Type type) {\n\t\treturn forType(type, null, null);\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Type} backed by the given\n\t * owner type.\n\t * <p>Note: The resulting {@code ResolvableType} instance may not be {@link Serializable}.\n\t * @param type the source type or {@code null}\n\t * @param owner the owner type used to resolve variables\n\t * @return a {@code ResolvableType} for the specified {@link Type} and owner\n\t * @see #forType(Type)\n\t */\n\tpublic static ResolvableType forType(@Nullable Type type, @Nullable ResolvableType owner) {\n\t\tVariableResolver variableResolver = null;\n\t\tif (owner != null) {\n\t\t\tvariableResolver = owner.asVariableResolver();\n\t\t}\n\t\treturn forType(type, variableResolver);\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} for the specified {@link ParameterizedTypeReference}.\n\t * <p>Note: The resulting {@code ResolvableType} instance may not be {@link Serializable}.\n\t * @param typeReference the reference to obtain the source type from\n\t * @return a {@code ResolvableType} for the specified {@link ParameterizedTypeReference}\n\t * @since 4.3.12\n\t * @see #forType(Type)\n\t */\n\tpublic static ResolvableType forType(ParameterizedTypeReference<?> typeReference) {\n\t\treturn forType(typeReference.getType(), null, null);\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Type} backed by a given\n\t * {@link VariableResolver}.\n\t * @param type the source type or {@code null}\n\t * @param variableResolver the variable resolver or {@code null}\n\t * @return a {@code ResolvableType} for the specified {@link Type} and {@link VariableResolver}\n\t */\n\tstatic ResolvableType forType(@Nullable Type type, @Nullable VariableResolver variableResolver) {\n\t\treturn forType(type, null, variableResolver);\n\t}\n\n\t/**\n\t * Return a {@code ResolvableType} for the specified {@link Type} backed by a given\n\t * {@link VariableResolver}.\n\t * @param type the source type or {@code null}\n\t * @param typeProvider the type provider or {@code null}\n\t * @param variableResolver the variable resolver or {@code null}\n\t * @return a {@code ResolvableType} for the specified {@link Type} and {@link VariableResolver}\n\t */\n\tstatic ResolvableType forType(\n\t\t\t@Nullable Type type, @Nullable TypeProvider typeProvider, @Nullable VariableResolver variableResolver) {\n\n\t\tif (type == null && typeProvider != null) {\n\t\t\ttype = SerializableTypeWrapper.forTypeProvider(typeProvider);\n\t\t}\n\t\tif (type == null) {\n\t\t\treturn NONE;\n\t\t}\n\n\t\t// For simple Class references, build the wrapper right away -\n\t\t// no expensive resolution necessary, so not worth caching...\n\t\tif (type instanceof Class) {\n\t\t\treturn new ResolvableType(type, null, typeProvider, variableResolver);\n\t\t}\n\n\t\t// Purge empty entries on access since we don't have a clean-up thread or the like.\n\t\tcache.purgeUnreferencedEntries();\n\n\t\t// Check the cache - we may have a ResolvableType which has been resolved before...\n\t\tResolvableType resultType = new ResolvableType(type, typeProvider, variableResolver);\n\t\tResolvableType cachedType = cache.get(resultType);\n\t\tif (cachedType == null) {\n\t\t\tcachedType = new ResolvableType(type, typeProvider, variableResolver, resultType.hash);\n\t\t\tcache.put(cachedType, cachedType);\n\t\t}\n\t\tresultType.resolved = cachedType.resolved;\n\t\treturn resultType;\n\t}\n\n\t/**\n\t * Clear the internal {@code ResolvableType}/{@code SerializableTypeWrapper} cache.\n\t * @since 4.2\n\t */\n\tpublic static void clearCache() {\n\t\tcache.clear();\n\t\tSerializableTypeWrapper.cache.clear();\n\t}\n\n\n\t/**\n\t * Strategy interface used to resolve {@link TypeVariable TypeVariables}.\n\t */\n\tinterface VariableResolver extends Serializable {\n\n\t\t/**\n\t\t * Return the source of the resolver (used for hashCode and equals).\n\t\t */\n\t\tObject getSource();\n\n\t\t/**\n\t\t * Resolve the specified variable.\n\t\t * @param variable the variable to resolve\n\t\t * @return the resolved variable, or {@code null} if not found\n\t\t */\n\t\t@Nullable ResolvableType resolveVariable(TypeVariable<?> variable);\n\t}\n\n\n\t@SuppressWarnings(\"serial\")\n\tprivate static class DefaultVariableResolver implements VariableResolver {\n\n\t\tprivate final ResolvableType source;\n\n\t\tDefaultVariableResolver(ResolvableType resolvableType) {\n\t\t\tthis.source = resolvableType;\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable ResolvableType resolveVariable(TypeVariable<?> variable) {\n\t\t\treturn this.source.resolveVariable(variable);\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getSource() {\n\t\t\treturn this.source;\n\t\t}\n\t}\n\n\n\t@SuppressWarnings(\"serial\")\n\tprivate static class TypeVariablesVariableResolver implements VariableResolver {\n\n\t\tprivate final TypeVariable<?>[] variables;\n\n\t\tprivate final @Nullable ResolvableType[] generics;\n\n\t\tpublic TypeVariablesVariableResolver(TypeVariable<?>[] variables, @Nullable ResolvableType[] generics) {\n\t\t\tthis.variables = variables;\n\t\t\tthis.generics = generics;\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable ResolvableType resolveVariable(TypeVariable<?> variable) {\n\t\t\tTypeVariable<?> variableToCompare = SerializableTypeWrapper.unwrap(variable);\n\t\t\tfor (int i = 0; i < this.variables.length; i++) {\n\t\t\t\tTypeVariable<?> resolvedVariable = SerializableTypeWrapper.unwrap(this.variables[i]);\n\t\t\t\tif (ObjectUtils.nullSafeEquals(resolvedVariable, variableToCompare)) {\n\t\t\t\t\treturn this.generics[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getSource() {\n\t\t\treturn this.generics;\n\t\t}\n\t}\n\n\n\tprivate static final class SyntheticParameterizedType implements ParameterizedType, Serializable {\n\n\t\tprivate final Type rawType;\n\n\t\tprivate final Type[] typeArguments;\n\n\t\tpublic SyntheticParameterizedType(Type rawType, Type[] typeArguments) {\n\t\t\tthis.rawType = rawType;\n\t\t\tthis.typeArguments = typeArguments;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getTypeName() {\n\t\t\tString typeName = this.rawType.getTypeName();\n\t\t\tif (this.typeArguments.length > 0) {\n\t\t\t\tStringJoiner stringJoiner = new StringJoiner(\", \", \"<\", \">\");\n\t\t\t\tfor (Type argument : this.typeArguments) {\n\t\t\t\t\tstringJoiner.add(argument.getTypeName());\n\t\t\t\t}\n\t\t\t\treturn typeName + stringJoiner;\n\t\t\t}\n\t\t\treturn typeName;\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable Type getOwnerType() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Type getRawType() {\n\t\t\treturn this.rawType;\n\t\t}\n\n\t\t@Override\n\t\tpublic Type[] getActualTypeArguments() {\n\t\t\treturn this.typeArguments;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || (other instanceof ParameterizedType that &&\n\t\t\t\t\tthat.getOwnerType() == null && this.rawType.equals(that.getRawType()) &&\n\t\t\t\t\tArrays.equals(this.typeArguments, that.getActualTypeArguments())));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn (this.rawType.hashCode() * 31 + Arrays.hashCode(this.typeArguments));\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn getTypeName();\n\t\t}\n\t}\n\n\n\t/**\n\t * Internal helper to handle bounds from {@link WildcardType WildcardTypes}.\n\t */\n\tprivate static class WildcardBounds {\n\n\t\tprivate final Kind kind;\n\n\t\tprivate final ResolvableType[] bounds;\n\n\t\t/**\n\t\t * Internal constructor to create a new {@link WildcardBounds} instance.\n\t\t * @param kind the kind of bounds\n\t\t * @param bounds the bounds\n\t\t * @see #get(ResolvableType)\n\t\t */\n\t\tpublic WildcardBounds(Kind kind, ResolvableType[] bounds) {\n\t\t\tthis.kind = kind;\n\t\t\tthis.bounds = bounds;\n\t\t}\n\n\t\t/**\n\t\t * Return {@code true} if these bounds are the same kind as the specified bounds.\n\t\t */\n\t\tpublic boolean isSameKind(WildcardBounds bounds) {\n\t\t\treturn this.kind == bounds.kind;\n\t\t}\n\n\t\t/**\n\t\t * Return {@code true} if these bounds are assignable from all the specified types.\n\t\t * @param types the types to test against\n\t\t * @return {@code true} if these bounds are assignable from all types\n\t\t */\n\t\tpublic boolean isAssignableFrom(ResolvableType[] types, @Nullable Map<Type, Type> matchedBefore) {\n\t\t\tfor (ResolvableType bound : this.bounds) {\n\t\t\t\tboolean matched = false;\n\t\t\t\tfor (ResolvableType type : types) {\n\t\t\t\t\tif (this.kind == Kind.UPPER ? bound.isAssignableFrom(type, false, matchedBefore, false) :\n\t\t\t\t\t\t\ttype.isAssignableFrom(bound, false, matchedBefore, false)) {\n\t\t\t\t\t\tmatched = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!matched) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * Return {@code true} if these bounds are assignable from the specified type.\n\t\t * @param type the type to test against\n\t\t * @return {@code true} if these bounds are assignable from the type\n\t\t * @since 6.2\n\t\t */\n\t\tpublic boolean isAssignableFrom(ResolvableType type, @Nullable Map<Type, Type> matchedBefore) {\n\t\t\tfor (ResolvableType bound : this.bounds) {\n\t\t\t\tif (this.kind == Kind.UPPER ? !bound.isAssignableFrom(type, false, matchedBefore, false) :\n\t\t\t\t\t\t!type.isAssignableFrom(bound, false, matchedBefore, false)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * Return {@code true} if these bounds are assignable to the specified type.\n\t\t * @param type the type to test against\n\t\t * @return {@code true} if these bounds are assignable to the type\n\t\t * @since 6.2\n\t\t */\n\t\tpublic boolean isAssignableTo(ResolvableType type, @Nullable Map<Type, Type> matchedBefore) {\n\t\t\tif (this.kind == Kind.UPPER) {\n\t\t\t\tfor (ResolvableType bound : this.bounds) {\n\t\t\t\t\tif (type.isAssignableFrom(bound, false, matchedBefore, false)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (type.resolve() == Object.class);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Return {@code true} if these bounds are equal to the specified type.\n\t\t * @param type the type to test against\n\t\t * @return {@code true} if these bounds are equal to the type\n\t\t * @since 6.2.3\n\t\t */\n\t\tpublic boolean equalsType(ResolvableType type) {\n\t\t\tfor (ResolvableType bound : this.bounds) {\n\t\t\t\tif (!type.equalsType(bound)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * Return the underlying bounds.\n\t\t */\n\t\tpublic ResolvableType[] getBounds() {\n\t\t\treturn this.bounds;\n\t\t}\n\n\t\t/**\n\t\t * Get a {@link WildcardBounds} instance for the specified type, returning\n\t\t * {@code null} if the specified type cannot be resolved to a {@link WildcardType}\n\t\t * or an equivalent unresolvable type variable.\n\t\t * @param type the source type\n\t\t * @return a {@link WildcardBounds} instance or {@code null}\n\t\t */\n\t\tpublic static @Nullable WildcardBounds get(ResolvableType type) {\n\t\t\tResolvableType candidate = type;\n\t\t\twhile (!(candidate.getType() instanceof WildcardType || candidate.isUnresolvableTypeVariable())) {\n\t\t\t\tif (candidate == NONE) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tcandidate = candidate.resolveType();\n\t\t\t}\n\t\t\tKind boundsType;\n\t\t\tType[] bounds;\n\t\t\tif (candidate.getType() instanceof WildcardType wildcardType) {\n\t\t\t\tboundsType = (wildcardType.getLowerBounds().length > 0 ? Kind.LOWER : Kind.UPPER);\n\t\t\t\tbounds = (boundsType == Kind.UPPER ? wildcardType.getUpperBounds() : wildcardType.getLowerBounds());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tboundsType = Kind.UPPER;\n\t\t\t\tbounds = ((TypeVariable<?>) candidate.getType()).getBounds();\n\t\t\t}\n\t\t\tResolvableType[] resolvableBounds = new ResolvableType[bounds.length];\n\t\t\tfor (int i = 0; i < bounds.length; i++) {\n\t\t\t\tresolvableBounds[i] = ResolvableType.forType(bounds[i], type.variableResolver);\n\t\t\t}\n\t\t\treturn new WildcardBounds(boundsType, resolvableBounds);\n\t\t}\n\n\t\t/**\n\t\t * The various kinds of bounds.\n\t\t */\n\t\tenum Kind {UPPER, LOWER}\n\t}\n\n\n\t/**\n\t * Internal {@link Type} used to represent an empty value.\n\t */\n\t@SuppressWarnings(\"serial\")\n\tstatic class EmptyType implements Type, Serializable {\n\n\t\tstatic final Type INSTANCE = new EmptyType();\n\n\t\tObject readResolve() {\n\t\t\treturn INSTANCE;\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.ResolvableType",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.ResolvableType#NONE",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.ResolvableType#NONE",
    "headType": "field",
    "relation": "haveType",
    "tail": "ResolvableType",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.ResolvableType",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.ResolvableType#EMPTY_TYPES_ARRAY",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.ResolvableType#EMPTY_TYPES_ARRAY",
    "headType": "field",
    "relation": "haveType",
    "tail": "ResolvableType",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.ResolvableType",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.ResolvableType#cache",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.ResolvableType#cache",
    "headType": "field",
    "relation": "haveType",
    "tail": "ConcurrentReferenceHashMap<ResolvableType, ResolvableType>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.ResolvableType",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.ResolvableType#type",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.ResolvableType#type",
    "headType": "field",
    "relation": "haveType",
    "tail": "Type",
    "tailType": "type"
  }
]