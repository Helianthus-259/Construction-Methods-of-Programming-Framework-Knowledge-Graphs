[
  {
    "head": "org.springframework.core.annotation.TypeMappedAnnotation",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Method;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Optional;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\n\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\n\n/**\n * {@link MergedAnnotation} that adapts attributes from a root annotation by\n * applying the mapping and mirroring rules of an {@link AnnotationTypeMapping}.\n *\n * <p>Root attribute values are extracted from a source object using a supplied\n * {@code BiFunction}. This allows various different annotation models to be\n * supported by the same class. For example, the attributes source might be an\n * actual {@link Annotation} instance where methods on the annotation instance\n * are {@linkplain AnnotationUtils#invokeAnnotationMethod(Method, Object) invoked}\n * to extract values. Similarly, the source could be a simple {@link Map} with\n * values extracted using {@link Map#get(Object)}.\n *\n * <p>Extracted root attribute values must be compatible with the attribute\n * return type, namely:\n *\n * <p><table border=\"1\">\n * <tr><th>Return Type</th><th>Extracted Type</th></tr>\n * <tr><td>Class</td><td>Class or String</td></tr>\n * <tr><td>Class[]</td><td>Class[] or String[]</td></tr>\n * <tr><td>Annotation</td><td>Annotation, Map, or Object compatible with the value\n * extractor</td></tr>\n * <tr><td>Annotation[]</td><td>Annotation[], Map[], or Object[] where elements are\n * compatible with the value extractor</td></tr>\n * <tr><td>Other types</td><td>An exact match or the appropriate primitive wrapper</td></tr>\n * </table>\n *\n * @author Phillip Webb\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 5.2\n * @param <A> the annotation type\n * @see TypeMappedAnnotations\n */\nfinal class TypeMappedAnnotation<A extends Annotation> extends AbstractMergedAnnotation<A> {\n\n\tprivate static final Map<Class<?>, Object> EMPTY_ARRAYS = Map.of(\n\t\tboolean.class, new boolean[0],\n\t\tbyte.class, new byte[0],\n\t\tchar.class, new char[0],\n\t\tdouble.class, new double[0],\n\t\tfloat.class, new float[0],\n\t\tint.class, new int[0],\n\t\tlong.class, new long[0],\n\t\tshort.class, new short[0],\n\t\tString.class, new String[0]);\n\n\n\tprivate final AnnotationTypeMapping mapping;\n\n\tprivate final @Nullable ClassLoader classLoader;\n\n\tprivate final @Nullable Object source;\n\n\tprivate final @Nullable Object rootAttributes;\n\n\tprivate final ValueExtractor valueExtractor;\n\n\tprivate final int aggregateIndex;\n\n\tprivate final boolean useMergedValues;\n\n\tprivate final @Nullable Predicate<String> attributeFilter;\n\n\tprivate final int[] resolvedRootMirrors;\n\n\tprivate final int[] resolvedMirrors;\n\n\n\tprivate TypeMappedAnnotation(AnnotationTypeMapping mapping, @Nullable ClassLoader classLoader,\n\t\t\t@Nullable Object source, @Nullable Object rootAttributes, ValueExtractor valueExtractor,\n\t\t\tint aggregateIndex) {\n\n\t\tthis(mapping, classLoader, source, rootAttributes, valueExtractor, aggregateIndex, null);\n\t}\n\n\tprivate TypeMappedAnnotation(AnnotationTypeMapping mapping, @Nullable ClassLoader classLoader,\n\t\t\t@Nullable Object source, @Nullable Object rootAttributes, ValueExtractor valueExtractor,\n\t\t\tint aggregateIndex, int @Nullable [] resolvedRootMirrors) {\n\n\t\tthis.mapping = mapping;\n\t\tthis.classLoader = classLoader;\n\t\tthis.source = source;\n\t\tthis.rootAttributes = rootAttributes;\n\t\tthis.valueExtractor = valueExtractor;\n\t\tthis.aggregateIndex = aggregateIndex;\n\t\tthis.useMergedValues = true;\n\t\tthis.attributeFilter = null;\n\t\tthis.resolvedRootMirrors = (resolvedRootMirrors != null ? resolvedRootMirrors :\n\t\t\t\tmapping.getRoot().getMirrorSets().resolve(source, rootAttributes, this.valueExtractor));\n\t\tthis.resolvedMirrors = (getDistance() == 0 ? this.resolvedRootMirrors :\n\t\t\t\tmapping.getMirrorSets().resolve(source, this, this::getValueForMirrorResolution));\n\t}\n\n\tprivate TypeMappedAnnotation(AnnotationTypeMapping mapping, @Nullable ClassLoader classLoader,\n\t\t\t@Nullable Object source, @Nullable Object rootAnnotation, ValueExtractor valueExtractor,\n\t\t\tint aggregateIndex, boolean useMergedValues, @Nullable Predicate<String> attributeFilter,\n\t\t\tint[] resolvedRootMirrors, int[] resolvedMirrors) {\n\n\t\tthis.classLoader = classLoader;\n\t\tthis.source = source;\n\t\tthis.rootAttributes = rootAnnotation;\n\t\tthis.valueExtractor = valueExtractor;\n\t\tthis.mapping = mapping;\n\t\tthis.aggregateIndex = aggregateIndex;\n\t\tthis.useMergedValues = useMergedValues;\n\t\tthis.attributeFilter = attributeFilter;\n\t\tthis.resolvedRootMirrors = resolvedRootMirrors;\n\t\tthis.resolvedMirrors = resolvedMirrors;\n\t}\n\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Class<A> getType() {\n\t\treturn (Class<A>) this.mapping.getAnnotationType();\n\t}\n\n\t@Override\n\tpublic List<Class<? extends Annotation>> getMetaTypes() {\n\t\treturn this.mapping.getMetaTypes();\n\t}\n\n\t@Override\n\tpublic boolean isPresent() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic int getDistance() {\n\t\treturn this.mapping.getDistance();\n\t}\n\n\t@Override\n\tpublic int getAggregateIndex() {\n\t\treturn this.aggregateIndex;\n\t}\n\n\t@Override\n\tpublic @Nullable Object getSource() {\n\t\treturn this.source;\n\t}\n\n\t@Override\n\tpublic @Nullable MergedAnnotation<?> getMetaSource() {\n\t\tAnnotationTypeMapping metaSourceMapping = this.mapping.getSource();\n\t\tif (metaSourceMapping == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new TypeMappedAnnotation<>(metaSourceMapping, this.classLoader, this.source,\n\t\t\t\tthis.rootAttributes, this.valueExtractor, this.aggregateIndex, this.resolvedRootMirrors);\n\t}\n\n\t@Override\n\tpublic MergedAnnotation<?> getRoot() {\n\t\tif (getDistance() == 0) {\n\t\t\treturn this;\n\t\t}\n\t\tAnnotationTypeMapping rootMapping = this.mapping.getRoot();\n\t\treturn new TypeMappedAnnotation<>(rootMapping, this.classLoader, this.source,\n\t\t\t\tthis.rootAttributes, this.valueExtractor, this.aggregateIndex, this.resolvedRootMirrors);\n\t}\n\n\t@Override\n\tpublic boolean hasDefaultValue(String attributeName) {\n\t\tint attributeIndex = getAttributeIndex(attributeName, true);\n\t\tObject value = getValue(attributeIndex, true, false);\n\t\treturn (value == null || this.mapping.isEquivalentToDefaultValue(attributeIndex, value, this.valueExtractor));\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T extends Annotation> MergedAnnotation<T> getAnnotation(String attributeName, Class<T> type)\n\t\t\tthrows NoSuchElementException {\n\n\t\tint attributeIndex = getAttributeIndex(attributeName, true);\n\t\tMethod attribute = this.mapping.getAttributes().get(attributeIndex);\n\t\tAssert.notNull(type, \"Type must not be null\");\n\t\tAssert.isAssignable(type, attribute.getReturnType(),\n\t\t\t\t() -> \"Attribute \" + attributeName + \" type mismatch:\");\n\t\treturn (MergedAnnotation<T>) getRequiredValue(attributeIndex, attributeName);\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T extends Annotation> MergedAnnotation<T>[] getAnnotationArray(\n\t\t\tString attributeName, Class<T> type) throws NoSuchElementException {\n\n\t\tint attributeIndex = getAttributeIndex(attributeName, true);\n\t\tMethod attribute = this.mapping.getAttributes().get(attributeIndex);\n\t\tClass<?> componentType = attribute.getReturnType().componentType();\n\t\tAssert.notNull(type, \"Type must not be null\");\n\t\tAssert.notNull(componentType, () -> \"Attribute \" + attributeName + \" is not an array\");\n\t\tAssert.isAssignable(type, componentType, () -> \"Attribute \" + attributeName + \" component type mismatch:\");\n\t\treturn (MergedAnnotation<T>[]) getRequiredValue(attributeIndex, attributeName);\n\t}\n\n\t@Override\n\tpublic <T> Optional<T> getDefaultValue(String attributeName, Class<T> type) {\n\t\tint attributeIndex = getAttributeIndex(attributeName, false);\n\t\tif (attributeIndex == -1) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\tMethod attribute = this.mapping.getAttributes().get(attributeIndex);\n\t\treturn Optional.ofNullable(adapt(attribute, attribute.getDefaultValue(), type));\n\t}\n\n\t@Override\n\tpublic MergedAnnotation<A> filterAttributes(Predicate<String> predicate) {\n\t\tif (this.attributeFilter != null) {\n\t\t\tpredicate = this.attributeFilter.and(predicate);\n\t\t}\n\t\treturn new TypeMappedAnnotation<>(this.mapping, this.classLoader, this.source, this.rootAttributes,\n\t\t\t\tthis.valueExtractor, this.aggregateIndex, this.useMergedValues, predicate,\n\t\t\t\tthis.resolvedRootMirrors, this.resolvedMirrors);\n\t}\n\n\t@Override\n\tpublic MergedAnnotation<A> withNonMergedAttributes() {\n\t\treturn new TypeMappedAnnotation<>(this.mapping, this.classLoader, this.source, this.rootAttributes,\n\t\t\t\tthis.valueExtractor, this.aggregateIndex, false, this.attributeFilter,\n\t\t\t\tthis.resolvedRootMirrors, this.resolvedMirrors);\n\t}\n\n\t@Override\n\tpublic Map<String, Object> asMap(Adapt... adaptations) {\n\t\treturn Collections.unmodifiableMap(asMap(mergedAnnotation -> new LinkedHashMap<>(), adaptations));\n\t}\n\n\t@Override\n\tpublic <T extends Map<String, Object>> T asMap(Function<MergedAnnotation<?>, T> factory, Adapt... adaptations) {\n\t\tT map = factory.apply(this);\n\t\tAssert.state(map != null, \"Factory used to create MergedAnnotation Map must not return null\");\n\t\tAttributeMethods attributes = this.mapping.getAttributes();\n\t\tfor (int i = 0; i < attributes.size(); i++) {\n\t\t\tMethod attribute = attributes.get(i);\n\t\t\tObject value = (isFiltered(attribute.getName()) ? null :\n\t\t\t\t\tgetValue(i, getTypeForMapOptions(attribute, adaptations)));\n\t\t\tif (value != null) {\n\t\t\t\tmap.put(attribute.getName(),\n\t\t\t\t\t\tadaptValueForMapOptions(attribute, value, map.getClass(), factory, adaptations));\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t}\n\n\tprivate Class<?> getTypeForMapOptions(Method attribute, Adapt[] adaptations) {\n\t\tClass<?> attributeType = attribute.getReturnType();\n\t\tClass<?> componentType = (attributeType.isArray() ? attributeType.componentType() : attributeType);\n\t\tif (Adapt.CLASS_TO_STRING.isIn(adaptations) && componentType == Class.class) {\n\t\t\treturn (attributeType.isArray() ? String[].class : String.class);\n\t\t}\n\t\treturn Object.class;\n\t}\n\n\tprivate <T extends Map<String, Object>> Object adaptValueForMapOptions(Method attribute, Object value,\n\t\t\tClass<?> mapType, Function<MergedAnnotation<?>, T> factory, Adapt[] adaptations) {\n\n\t\tif (value instanceof MergedAnnotation<?> annotation) {\n\t\t\treturn (Adapt.ANNOTATION_TO_MAP.isIn(adaptations) ?\n\t\t\t\t\tannotation.asMap(factory, adaptations) : annotation.synthesize());\n\t\t}\n\t\tif (value instanceof MergedAnnotation<?>[] annotations) {\n\t\t\tif (Adapt.ANNOTATION_TO_MAP.isIn(adaptations)) {\n\t\t\t\tObject result = Array.newInstance(mapType, annotations.length);\n\t\t\t\tfor (int i = 0; i < annotations.length; i++) {\n\t\t\t\t\tArray.set(result, i, annotations[i].asMap(factory, adaptations));\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tObject result = Array.newInstance(\n\t\t\t\t\tattribute.getReturnType().componentType(), annotations.length);\n\t\t\tfor (int i = 0; i < annotations.length; i++) {\n\t\t\t\tArray.set(result, i, annotations[i].synthesize());\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\treturn value;\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tprotected A createSynthesizedAnnotation() {\n\t\t// Check root annotation\n\t\tif (this.rootAttributes instanceof Annotation ann && isTargetAnnotation(ann) && !isSynthesizable(ann)) {\n\t\t\treturn (A) ann;\n\t\t}\n\t\t// Check meta-annotation\n\t\tAnnotation meta = this.mapping.getAnnotation();\n\t\tif (meta != null && isTargetAnnotation(meta) && !isSynthesizable(meta)) {\n\t\t\treturn (A) meta;\n\t\t}\n\t\treturn SynthesizedMergedAnnotationInvocationHandler.createProxy(this, getType());\n\t}\n\n\t/**\n\t * Determine if the supplied object is an annotation of the required\n\t * {@linkplain #getType() type}.\n\t * @param obj the object to check\n\t * @since 5.3.22\n\t */\n\tprivate boolean isTargetAnnotation(Object obj) {\n\t\treturn getType().isInstance(obj);\n\t}\n\n\t/**\n\t * Determine if the supplied annotation has not already been synthesized\n\t * <strong>and</strong> whether the mapped annotation is a composed annotation\n\t * that needs to have its attributes merged or the mapped annotation is\n\t * {@linkplain AnnotationTypeMapping#isSynthesizable() synthesizable} in general.\n\t * @param annotation the annotation to check\n\t * @since 5.3.22\n\t */\n\tprivate boolean isSynthesizable(Annotation annotation) {\n\t\t// Already synthesized?\n\t\tif (AnnotationUtils.isSynthesizedAnnotation(annotation)) {\n\t\t\treturn false;\n\t\t}\n\t\t// Is this a mapped annotation for a composed annotation, and are there\n\t\t// annotation attributes (mirrors) that need to be merged?\n\t\tif (getDistance() > 0 && this.resolvedMirrors.length > 0) {\n\t\t\treturn true;\n\t\t}\n\t\t// Is the mapped annotation itself synthesizable?\n\t\treturn this.mapping.isSynthesizable();\n\t}\n\n\t@Override\n\tprotected <T> @Nullable T getAttributeValue(String attributeName, Class<T> type) {\n\t\tint attributeIndex = getAttributeIndex(attributeName, false);\n\t\treturn (attributeIndex != -1 ? getValue(attributeIndex, type) : null);\n\t}\n\n\tprivate Object getRequiredValue(int attributeIndex, String attributeName) {\n\t\tObject value = getValue(attributeIndex, Object.class);\n\t\tif (value == null) {\n\t\t\tthrow new NoSuchElementException(\"No element at attribute index \"\n\t\t\t\t\t+ attributeIndex + \" for name \" + attributeName);\n\t\t}\n\t\treturn value;\n\t}\n\n\tprivate <T> @Nullable T getValue(int attributeIndex, Class<T> type) {\n\t\tMethod attribute = this.mapping.getAttributes().get(attributeIndex);\n\t\tObject value = getValue(attributeIndex, true, false);\n\t\tif (value == null) {\n\t\t\tvalue = attribute.getDefaultValue();\n\t\t}\n\t\treturn adapt(attribute, value, type);\n\t}\n\n\tprivate @Nullable Object getValue(int attributeIndex, boolean useConventionMapping, boolean forMirrorResolution) {\n\t\tAnnotationTypeMapping mapping = this.mapping;\n\t\tif (this.useMergedValues) {\n\t\t\tint mappedIndex = this.mapping.getAliasMapping(attributeIndex);\n\t\t\tif (mappedIndex == -1 && useConventionMapping) {\n\t\t\t\tmappedIndex = this.mapping.getConventionMapping(attributeIndex);\n\t\t\t}\n\t\t\tif (mappedIndex != -1) {\n\t\t\t\tmapping = mapping.getRoot();\n\t\t\t\tattributeIndex = mappedIndex;\n\t\t\t}\n\t\t}\n\t\tif (!forMirrorResolution) {\n\t\t\tattributeIndex =\n\t\t\t\t\t(mapping.getDistance() != 0 ? this.resolvedMirrors : this.resolvedRootMirrors)[attributeIndex];\n\t\t}\n\t\tif (attributeIndex == -1) {\n\t\t\treturn null;\n\t\t}\n\t\tif (mapping.getDistance() == 0) {\n\t\t\tMethod attribute = mapping.getAttributes().get(attributeIndex);\n\t\t\tObject result = this.valueExtractor.extract(attribute, this.rootAttributes);\n\t\t\treturn (result != null ? result : attribute.getDefaultValue());\n\t\t}\n\t\treturn getValueFromMetaAnnotation(attributeIndex, forMirrorResolution);\n\t}\n\n\tprivate @Nullable Object getValueFromMetaAnnotation(int attributeIndex, boolean forMirrorResolution) {\n\t\tObject value = null;\n\t\tif (this.useMergedValues || forMirrorResolution) {\n\t\t\tvalue = this.mapping.getMappedAnnotationValue(attributeIndex, forMirrorResolution);\n\t\t}\n\t\tif (value == null) {\n\t\t\tMethod attribute = this.mapping.getAttributes().get(attributeIndex);\n\t\t\tvalue = AnnotationUtils.invokeAnnotationMethod(attribute, this.mapping.getAnnotation());\n\t\t}\n\t\treturn value;\n\t}\n\n\tprivate @Nullable Object getValueForMirrorResolution(Method attribute, @Nullable Object annotation) {\n\t\tint attributeIndex = this.mapping.getAttributes().indexOf(attribute);\n\t\tboolean valueAttribute = VALUE.equals(attribute.getName());\n\t\treturn getValue(attributeIndex, !valueAttribute, true);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate <T> @Nullable T adapt(Method attribute, @Nullable Object value, Class<T> type) {\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\t\tvalue = adaptForAttribute(attribute, value);\n\t\ttype = getAdaptType(attribute, type);\n\t\tif (value instanceof Class<?> clazz && type == String.class) {\n\t\t\tvalue = clazz.getName();\n\t\t}\n\t\telse if (value instanceof String str && type == Class.class) {\n\t\t\tvalue = ClassUtils.resolveClassName(str, getClassLoader());\n\t\t}\n\t\telse if (value instanceof Class<?>[] classes && type == String[].class) {\n\t\t\tString[] names = new String[classes.length];\n\t\t\tfor (int i = 0; i < classes.length; i++) {\n\t\t\t\tnames[i] = classes[i].getName();\n\t\t\t}\n\t\t\tvalue = names;\n\t\t}\n\t\telse if (value instanceof String[] names && type == Class[].class) {\n\t\t\tClass<?>[] classes = new Class<?>[names.length];\n\t\t\tfor (int i = 0; i < names.length; i++) {\n\t\t\t\tclasses[i] = ClassUtils.resolveClassName(names[i], getClassLoader());\n\t\t\t}\n\t\t\tvalue = classes;\n\t\t}\n\t\telse if (value instanceof MergedAnnotation<?> annotation && type.isAnnotation()) {\n\t\t\tvalue = annotation.synthesize();\n\t\t}\n\t\telse if (value instanceof MergedAnnotation<?>[] annotations &&\n\t\t\t\ttype.isArray() && type.componentType().isAnnotation()) {\n\t\t\tObject array = Array.newInstance(type.componentType(), annotations.length);\n\t\t\tfor (int i = 0; i < annotations.length; i++) {\n\t\t\t\tArray.set(array, i, annotations[i].synthesize());\n\t\t\t}\n\t\t\tvalue = array;\n\t\t}\n\t\tif (!type.isInstance(value)) {\n\t\t\tthrow new IllegalArgumentException(\"Unable to adapt value of type \" +\n\t\t\t\t\tvalue.getClass().getName() + \" to \" + type.getName());\n\t\t}\n\t\treturn (T) value;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate Object adaptForAttribute(Method attribute, Object value) {\n\t\tClass<?> attributeType = ClassUtils.resolvePrimitiveIfNecessary(attribute.getReturnType());\n\t\tif (attributeType.isArray() && !value.getClass().isArray()) {\n\t\t\tObject array = Array.newInstance(value.getClass(), 1);\n\t\t\tArray.set(array, 0, value);\n\t\t\treturn adaptForAttribute(attribute, array);\n\t\t}\n\t\tif (attributeType.isAnnotation()) {\n\t\t\treturn adaptToMergedAnnotation(value, (Class<? extends Annotation>) attributeType);\n\t\t}\n\t\tif (attributeType.isArray() && attributeType.componentType().isAnnotation()) {\n\t\t\tMergedAnnotation<?>[] result = new MergedAnnotation<?>[Array.getLength(value)];\n\t\t\tfor (int i = 0; i < result.length; i++) {\n\t\t\t\tresult[i] = adaptToMergedAnnotation(Array.get(value, i),\n\t\t\t\t\t\t(Class<? extends Annotation>) attributeType.componentType());\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tif ((attributeType == Class.class && value instanceof String) ||\n\t\t\t\t(attributeType == Class[].class && value instanceof String[]) ||\n\t\t\t\t(attributeType == String.class && value instanceof Class) ||\n\t\t\t\t(attributeType == String[].class && value instanceof Class[])) {\n\t\t\treturn value;\n\t\t}\n\t\tif (attributeType.isArray() && isEmptyObjectArray(value)) {\n\t\t\treturn emptyArray(attributeType.componentType());\n\t\t}\n\t\tif (!attributeType.isInstance(value)) {\n\t\t\tthrow new IllegalStateException(\"Attribute '\" + attribute.getName() +\n\t\t\t\t\t\"' in annotation \" + getType().getName() + \" should be compatible with \" +\n\t\t\t\t\tattributeType.getName() + \" but a \" + value.getClass().getName() +\n\t\t\t\t\t\" value was returned\");\n\t\t}\n\t\treturn value;\n\t}\n\n\tprivate boolean isEmptyObjectArray(Object value) {\n\t\treturn (value instanceof Object[] objects && objects.length == 0);\n\t}\n\n\tprivate Object emptyArray(Class<?> componentType) {\n\t\tObject result = EMPTY_ARRAYS.get(componentType);\n\t\tif (result == null) {\n\t\t\tresult = Array.newInstance(componentType, 0);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate MergedAnnotation<?> adaptToMergedAnnotation(Object value, Class<? extends Annotation> annotationType) {\n\t\tif (value instanceof MergedAnnotation<?> mergedAnnotation) {\n\t\t\treturn mergedAnnotation;\n\t\t}\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(annotationType).get(0);\n\t\treturn new TypeMappedAnnotation<>(\n\t\t\t\tmapping, null, this.source, value, getValueExtractor(value), this.aggregateIndex);\n\t}\n\n\tprivate ValueExtractor getValueExtractor(Object value) {\n\t\tif (value instanceof Annotation) {\n\t\t\treturn AnnotationUtils::invokeAnnotationMethod;\n\t\t}\n\t\tif (value instanceof Map) {\n\t\t\treturn TypeMappedAnnotation::extractFromMap;\n\t\t}\n\t\treturn this.valueExtractor;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate <T> Class<T> getAdaptType(Method attribute, Class<T> type) {\n\t\tif (type != Object.class) {\n\t\t\treturn type;\n\t\t}\n\t\tClass<?> attributeType = attribute.getReturnType();\n\t\tif (attributeType.isAnnotation()) {\n\t\t\treturn (Class<T>) MergedAnnotation.class;\n\t\t}\n\t\tif (attributeType.isArray() && attributeType.componentType().isAnnotation()) {\n\t\t\treturn (Class<T>) MergedAnnotation[].class;\n\t\t}\n\t\treturn (Class<T>) ClassUtils.resolvePrimitiveIfNecessary(attributeType);\n\t}\n\n\tprivate int getAttributeIndex(String attributeName, boolean required) {\n\t\tAssert.hasText(attributeName, \"Attribute name must not be null\");\n\t\tint attributeIndex = (isFiltered(attributeName) ? -1 : this.mapping.getAttributes().indexOf(attributeName));\n\t\tif (attributeIndex == -1 && required) {\n\t\t\tthrow new NoSuchElementException(\"No attribute named '\" + attributeName +\n\t\t\t\t\t\"' present in merged annotation \" + getType().getName());\n\t\t}\n\t\treturn attributeIndex;\n\t}\n\n\tprivate boolean isFiltered(String attributeName) {\n\t\tif (this.attributeFilter != null) {\n\t\t\treturn !this.attributeFilter.test(attributeName);\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate @Nullable ClassLoader getClassLoader() {\n\t\tif (this.classLoader != null) {\n\t\t\treturn this.classLoader;\n\t\t}\n\t\tif (this.source != null) {\n\t\t\tif (this.source instanceof Class<?> clazz) {\n\t\t\t\treturn clazz.getClassLoader();\n\t\t\t}\n\t\t\tif (this.source instanceof Member member) {\n\t\t\t\tmember.getDeclaringClass().getClassLoader();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\n\tstatic <A extends Annotation> MergedAnnotation<A> from(@Nullable Object source, A annotation) {\n\t\tAssert.notNull(annotation, \"Annotation must not be null\");\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(annotation.annotationType());\n\t\treturn new TypeMappedAnnotation<>(\n\t\t\t\tmappings.get(0), null, source, annotation, AnnotationUtils::invokeAnnotationMethod, 0);\n\t}\n\n\tstatic <A extends Annotation> MergedAnnotation<A> of(\n\t\t\t@Nullable ClassLoader classLoader, @Nullable Object source,\n\t\t\tClass<A> annotationType, @Nullable Map<String, ?> attributes) {\n\n\t\tAssert.notNull(annotationType, \"Annotation type must not be null\");\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(annotationType);\n\t\treturn new TypeMappedAnnotation<>(\n\t\t\t\tmappings.get(0), classLoader, source, attributes, TypeMappedAnnotation::extractFromMap, 0);\n\t}\n\n\tstatic <A extends Annotation> @Nullable TypeMappedAnnotation<A> createIfPossible(\n\t\t\tAnnotationTypeMapping mapping, MergedAnnotation<?> annotation, IntrospectionFailureLogger logger) {\n\n\t\tif (annotation instanceof TypeMappedAnnotation<?> typeMappedAnnotation) {\n\t\t\treturn createIfPossible(mapping, typeMappedAnnotation.source,\n\t\t\t\t\ttypeMappedAnnotation.rootAttributes,\n\t\t\t\t\ttypeMappedAnnotation.valueExtractor,\n\t\t\t\t\ttypeMappedAnnotation.aggregateIndex, logger);\n\t\t}\n\t\treturn createIfPossible(mapping, annotation.getSource(), annotation.synthesize(),\n\t\t\t\tannotation.getAggregateIndex(), logger);\n\t}\n\n\tstatic <A extends Annotation> @Nullable TypeMappedAnnotation<A> createIfPossible(\n\t\t\tAnnotationTypeMapping mapping, @Nullable Object source, Annotation annotation,\n\t\t\tint aggregateIndex, IntrospectionFailureLogger logger) {\n\n\t\treturn createIfPossible(mapping, source, annotation,\n\t\t\t\tAnnotationUtils::invokeAnnotationMethod, aggregateIndex, logger);\n\t}\n\n\tprivate static <A extends Annotation> @Nullable TypeMappedAnnotation<A> createIfPossible(\n\t\t\tAnnotationTypeMapping mapping, @Nullable Object source, @Nullable Object rootAttribute,\n\t\t\tValueExtractor valueExtractor, int aggregateIndex, IntrospectionFailureLogger logger) {\n\n\t\ttry {\n\t\t\treturn new TypeMappedAnnotation<>(mapping, null, source, rootAttribute,\n\t\t\t\t\tvalueExtractor, aggregateIndex);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tAnnotationUtils.rethrowAnnotationConfigurationException(ex);\n\t\t\tif (logger.isEnabled()) {\n\t\t\t\tString type = mapping.getAnnotationType().getName();\n\t\t\t\tString item = (mapping.getDistance() == 0 ? \"annotation \" + type :\n\t\t\t\t\t\t\"meta-annotation \" + type + \" from \" + mapping.getRoot().getAnnotationType().getName());\n\t\t\t\tlogger.log(\"Failed to introspect \" + item, source, ex);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tstatic @Nullable Object extractFromMap(Method attribute, @Nullable Object map) {\n\t\treturn (map != null ? ((Map<String, ?>) map).get(attribute.getName()) : null);\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation.TypeMappedAnnotation",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.TypeMappedAnnotation#EMPTY_ARRAYS",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.TypeMappedAnnotation#EMPTY_ARRAYS",
    "headType": "field",
    "relation": "haveType",
    "tail": "Map<Class<?>, Object>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.TypeMappedAnnotation",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.TypeMappedAnnotation#mapping",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.TypeMappedAnnotation#mapping",
    "headType": "field",
    "relation": "haveType",
    "tail": "AnnotationTypeMapping",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.TypeMappedAnnotation",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.TypeMappedAnnotation#classLoader",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.TypeMappedAnnotation#classLoader",
    "headType": "field",
    "relation": "haveType",
    "tail": "ClassLoader",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.TypeMappedAnnotation",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.TypeMappedAnnotation#source",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.TypeMappedAnnotation#source",
    "headType": "field",
    "relation": "haveType",
    "tail": "Object",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.TypeMappedAnnotation",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.TypeMappedAnnotation#rootAttributes",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.TypeMappedAnnotation#rootAttributes",
    "headType": "field",
    "relation": "haveType",
    "tail": "Object",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.TypeMappedAnnotation",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.TypeMappedAnnotation#valueExtractor",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.TypeMappedAnnotation#valueExtractor",
    "headType": "field",
    "relation": "haveType",
    "tail": "ValueExtractor",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.TypeMappedAnnotation",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.TypeMappedAnnotation#aggregateIndex",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.TypeMappedAnnotation#aggregateIndex",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.TypeMappedAnnotation",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.TypeMappedAnnotation#useMergedValues",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.TypeMappedAnnotation#useMergedValues",
    "headType": "field",
    "relation": "haveType",
    "tail": "boolean",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.TypeMappedAnnotation",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.TypeMappedAnnotation#attributeFilter",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.TypeMappedAnnotation#attributeFilter",
    "headType": "field",
    "relation": "haveType",
    "tail": "Predicate<String>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.TypeMappedAnnotation",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.TypeMappedAnnotation#resolvedRootMirrors",
    "tailType": "field"
  }
]