[
  {
    "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoCancel(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Test a {@link Decoder#decodeToMono decode} scenario where the input stream is canceled.\r\n * This test method will immediately cancel the output stream.\r\n *\r\n * @param input the input to be provided to the decoder\r\n * @param outputType the desired output type\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n */\r\nprotected void testDecodeToMonoCancel(Publisher<DataBuffer> input, ResolvableType outputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    Mono<?> result = this.decoder.decodeToMono(input, outputType, mimeType, hints);\r\n    StepVerifier.create(result).thenCancel().verify();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoCancel(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoEmpty(ResolvableType,MimeType,Map<String,Object>)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Test a {@link Decoder#decodeToMono decode} scenario where the input stream is empty.\r\n * The output is expected to be empty as well.\r\n *\r\n * @param outputType the desired output type\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n */\r\nprotected void testDecodeToMonoEmpty(ResolvableType outputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    Mono<?> result = this.decoder.decodeToMono(Flux.empty(), outputType, mimeType, hints);\r\n    StepVerifier.create(result).verifyComplete();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoEmpty(ResolvableType,MimeType,Map<String,Object>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#dataBuffer(byte[])",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Creates a deferred {@link DataBuffer} containing the given bytes.\r\n * @param bytes the bytes that are to be stored in the buffer\r\n * @return the deferred buffer\r\n */\r\nprotected Mono<DataBuffer> dataBuffer(byte[] bytes) {\r\n    return Mono.fromCallable(() -> {\r\n        DataBuffer dataBuffer = this.bufferFactory.allocateBuffer(bytes.length);\r\n        dataBuffer.write(bytes);\r\n        return dataBuffer;\r\n    });\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.testfixture.codec.AbstractDecoderTests#dataBuffer(byte[])",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests",
    "headType": "class",
    "relation": "extend",
    "tail": "AbstractLeakCheckingTests",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.testfixture.codec",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.testfixture.codec.InputException",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.testfixture.codec.InputException",
    "headType": "class",
    "relation": "use",
    "tail": "@SuppressWarnings",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.testfixture.codec.InputException",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.testfixture.codec;\n\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.function.Consumer;\n\nimport io.netty5.buffer.Buffer;\nimport org.jspecify.annotations.Nullable;\nimport org.junit.jupiter.api.Test;\nimport org.reactivestreams.Publisher;\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Mono;\nimport reactor.test.StepVerifier;\n\nimport org.springframework.core.ResolvableType;\nimport org.springframework.core.codec.Decoder;\nimport org.springframework.core.io.buffer.DataBuffer;\nimport org.springframework.core.testfixture.io.buffer.AbstractLeakCheckingTests;\nimport org.springframework.util.Assert;\nimport org.springframework.util.MimeType;\n\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n\n/**\n * Abstract base class for {@link Decoder} unit tests. Subclasses need to implement\n * {@link #canDecode()}, {@link #decode()} and {@link #decodeToMono()}, possibly using the wide\n * variety of helper methods like {@link #testDecodeAll} or {@link #testDecodeToMonoAll}.\n *\n * @author Arjen Poutsma\n * @since 5.1.3\n */\npublic abstract class AbstractDecoderTests<D extends Decoder<?>> extends AbstractLeakCheckingTests {\n\n\t/**\n\t * The decoder to test.\n\t */\n\tprotected D decoder;\n\n\t/**\n\t * Construct a new {@code AbstractDecoderTests} instance for the given decoder.\n\t * @param decoder the decoder\n\t */\n\tprotected AbstractDecoderTests(D decoder) {\n\t\tAssert.notNull(decoder, \"Encoder must not be null\");\n\n\t\tthis.decoder = decoder;\n\t}\n\n\n\t/**\n\t * Subclasses should implement this method to test {@link Decoder#canDecode}.\n\t */\n\t@Test\n\tprotected abstract void canDecode() throws Exception;\n\n\t/**\n\t * Subclasses should implement this method to test {@link Decoder#decode}, possibly using\n\t * {@link #testDecodeAll} or other helper methods.\n\t */\n\t@Test\n\tprotected abstract void decode() throws Exception;\n\n\t/**\n\t * Subclasses should implement this method to test {@link Decoder#decodeToMono}, possibly using\n\t * {@link #testDecodeToMonoAll}.\n\t */\n\t@Test\n\tprotected abstract void decodeToMono() throws Exception;\n\n\t// Flux\n\n\t/**\n\t * Helper method that tests for a variety of {@link Flux} decoding scenarios. This method\n\t * invokes:\n\t * <ul>\n\t *     <li>{@link #testDecode(Publisher, ResolvableType, Consumer, MimeType, Map)}</li>\n\t *     <li>{@link #testDecodeError(Publisher, ResolvableType, MimeType, Map)}</li>\n\t *     <li>{@link #testDecodeCancel(Publisher, ResolvableType, MimeType, Map)}</li>\n\t *     <li>{@link #testDecodeEmpty(ResolvableType, MimeType, Map)}</li>\n\t * </ul>\n\t *\n\t * @param input the input to be provided to the decoder\n\t * @param outputClass the desired output class\n\t * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\n\t * @param <T> the output type\n\t */\n\tprotected <T> void testDecodeAll(Publisher<DataBuffer> input, Class<? extends T> outputClass,\n\t\t\tConsumer<StepVerifier.FirstStep<T>> stepConsumer) {\n\n\t\ttestDecodeAll(input, ResolvableType.forClass(outputClass), stepConsumer, null, null);\n\t}\n\n\t/**\n\t * Helper method that tests for a variety of {@link Flux} decoding scenarios. This method\n\t * invokes:\n\t * <ul>\n\t *     <li>{@link #testDecode(Publisher, ResolvableType, Consumer, MimeType, Map)}</li>\n\t *     <li>{@link #testDecodeError(Publisher, ResolvableType, MimeType, Map)}</li>\n\t *     <li>{@link #testDecodeCancel(Publisher, ResolvableType, MimeType, Map)}</li>\n\t *     <li>{@link #testDecodeEmpty(ResolvableType, MimeType, Map)}</li>\n\t * </ul>\n\t *\n\t * @param input the input to be provided to the decoder\n\t * @param outputType the desired output type\n\t * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t * @param <T> the output type\n\t */\n\tprotected <T> void testDecodeAll(Publisher<DataBuffer> input, ResolvableType outputType,\n\t\t\tConsumer<StepVerifier.FirstStep<T>> stepConsumer,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\ttestDecode(input, outputType, stepConsumer, mimeType, hints);\n\t\ttestDecodeError(input, outputType, mimeType, hints);\n\t\ttestDecodeCancel(input, outputType, mimeType, hints);\n\t\ttestDecodeEmpty(outputType, mimeType, hints);\n\t}\n\n\t/**\n\t * Test a standard {@link Decoder#decode decode} scenario. For example:\n\t * <pre class=\"code\">\n\t * byte[] bytes1 = ...\n\t * byte[] bytes2 = ...\n\t *\n\t * Flux&lt;DataBuffer&gt; input = Flux.concat(\n\t *   dataBuffer(bytes1),\n\t *   dataBuffer(bytes2));\n\t *\n\t * testDecodeAll(input, byte[].class, step -&gt; step\n\t *   .consumeNextWith(expectBytes(bytes1))\n\t *   .consumeNextWith(expectBytes(bytes2))\n\t * \t .verifyComplete());\n\t * </pre>\n\t *\n\t * @param input the input to be provided to the decoder\n\t * @param outputClass the desired output class\n\t * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\n\t * @param <T> the output type\n\t */\n\tprotected <T> void testDecode(Publisher<DataBuffer> input, Class<? extends T> outputClass,\n\t\t\tConsumer<StepVerifier.FirstStep<T>> stepConsumer) {\n\n\t\ttestDecode(input, ResolvableType.forClass(outputClass), stepConsumer, null, null);\n\t}\n\n\t/**\n\t * Test a standard {@link Decoder#decode decode} scenario. For example:\n\t * <pre class=\"code\">\n\t * byte[] bytes1 = ...\n\t * byte[] bytes2 = ...\n\t *\n\t * Flux&lt;DataBuffer&gt; input = Flux.concat(\n\t *   dataBuffer(bytes1),\n\t *   dataBuffer(bytes2));\n\t *\n\t * testDecodeAll(input, byte[].class, step -&gt; step\n\t *   .consumeNextWith(expectBytes(bytes1))\n\t *   .consumeNextWith(expectBytes(bytes2))\n\t * \t .verifyComplete());\n\t * </pre>\n\t *\n\t * @param input the input to be provided to the decoder\n\t * @param outputType the desired output type\n\t * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t * @param <T> the output type\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprotected <T> void testDecode(Publisher<DataBuffer> input, ResolvableType outputType,\n\t\t\tConsumer<StepVerifier.FirstStep<T>> stepConsumer,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tFlux<T> result = (Flux<T>) this.decoder.decode(input, outputType, mimeType, hints);\n\t\tStepVerifier.FirstStep<T> step = StepVerifier.create(result);\n\t\tstepConsumer.accept(step);\n\t}\n\n\t/**\n\t * Test a {@link Decoder#decode decode} scenario where the input stream contains an error.\n\t * This test method will feed the first element of the {@code input} stream to the decoder,\n\t * followed by an {@link InputException}.\n\t * The result is expected to contain one \"normal\" element, followed by the error.\n\t *\n\t * @param input the input to be provided to the decoder\n\t * @param outputType the desired output type\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t * @see InputException\n\t */\n\tprotected void testDecodeError(Publisher<DataBuffer> input, ResolvableType outputType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tFlux<DataBuffer> flux = Mono.from(input).concatWith(Flux.error(new InputException()));\n\t\tassertThatExceptionOfType(InputException.class).isThrownBy(() ->\n\t\t\t\tthis.decoder.decode(flux, outputType, mimeType, hints)\n\t\t\t\t\t\t.doOnNext(object -> {\n\t\t\t\t\t\t\tif (object instanceof Buffer buffer) {\n\t\t\t\t\t\t\t\tbuffer.close();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.blockLast(Duration.ofSeconds(5)));\n\t}\n\n\t/**\n\t * Test a {@link Decoder#decode decode} scenario where the input stream is canceled.\n\t * This test method will feed the first element of the {@code input} stream to the decoder,\n\t * followed by a cancel signal.\n\t * The result is expected to contain one \"normal\" element.\n\t *\n\t * @param input the input to be provided to the decoder\n\t * @param outputType the desired output type\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t */\n\tprotected void testDecodeCancel(Publisher<DataBuffer> input, ResolvableType outputType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tFlux<?> result = this.decoder.decode(input, outputType, mimeType, hints)\n\t\t\t\t.doOnNext(object -> {\n\t\t\t\t\tif (object instanceof Buffer buffer) {\n\t\t\t\t\t\tbuffer.close();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tStepVerifier.create(result).expectNextCount(1).thenCancel().verify();\n\t}\n\n\t/**\n\t * Test a {@link Decoder#decode decode} scenario where the input stream is empty.\n\t * The output is expected to be empty as well.\n\t *\n\t * @param outputType the desired output type\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t */\n\tprotected void testDecodeEmpty(ResolvableType outputType, @Nullable MimeType mimeType,\n\t\t\t@Nullable Map<String, Object> hints) {\n\n\t\tFlux<DataBuffer> input = Flux.empty();\n\t\tFlux<?> result = this.decoder.decode(input, outputType, mimeType, hints);\n\t\tStepVerifier.create(result).verifyComplete();\n\t}\n\n\t// Mono\n\n\t/**\n\t * Helper method that tests for a variety of {@link Mono} decoding scenarios. This method\n\t * invokes:\n\t * <ul>\n\t *     <li>{@link #testDecodeToMono(Publisher, ResolvableType, Consumer, MimeType, Map)}</li>\n\t *     <li>{@link #testDecodeToMonoError(Publisher, ResolvableType, MimeType, Map)}</li>\n\t *     <li>{@link #testDecodeToMonoCancel(Publisher, ResolvableType, MimeType, Map)}</li>\n\t *     <li>{@link #testDecodeToMonoEmpty(ResolvableType, MimeType, Map)}</li>\n\t * </ul>\n\t *\n\t * @param input the input to be provided to the decoder\n\t * @param outputClass the desired output class\n\t * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\n\t * @param <T> the output type\n\t */\n\tprotected <T> void testDecodeToMonoAll(Publisher<DataBuffer> input,\n\t\t\tClass<? extends T> outputClass, Consumer<StepVerifier.FirstStep<T>> stepConsumer) {\n\n\t\ttestDecodeToMonoAll(input, ResolvableType.forClass(outputClass), stepConsumer, null, null);\n\t}\n\n\t/**\n\t * Helper method that tests for a variety of {@link Mono} decoding scenarios. This method\n\t * invokes:\n\t * <ul>\n\t *     <li>{@link #testDecodeToMono(Publisher, ResolvableType, Consumer, MimeType, Map)}</li>\n\t *     <li>{@link #testDecodeToMonoError(Publisher, ResolvableType, MimeType, Map)}</li>\n\t *     <li>{@link #testDecodeToMonoCancel(Publisher, ResolvableType, MimeType, Map)}</li>\n\t *     <li>{@link #testDecodeToMonoEmpty(ResolvableType, MimeType, Map)}</li>\n\t * </ul>\n\t *\n\t * @param input the input to be provided to the decoder\n\t * @param outputType the desired output type\n\t * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t * @param <T> the output type\n\t */\n\tprotected <T> void testDecodeToMonoAll(Publisher<DataBuffer> input, ResolvableType outputType,\n\t\t\tConsumer<StepVerifier.FirstStep<T>> stepConsumer,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\ttestDecodeToMono(input, outputType, stepConsumer, mimeType, hints);\n\t\ttestDecodeToMonoError(input, outputType, mimeType, hints);\n\t\ttestDecodeToMonoCancel(input, outputType, mimeType, hints);\n\t\ttestDecodeToMonoEmpty(outputType, mimeType, hints);\n\t}\n\n\t/**\n\t * Test a standard {@link Decoder#decodeToMono decode} scenario. For example:\n\t * <pre class=\"code\">\n\t * byte[] bytes1 = ...\n\t * byte[] bytes2 = ...\n\t * byte[] allBytes = ... // bytes1 + bytes2\n\t *\n\t * Flux&lt;DataBuffer&gt; input = Flux.concat(\n\t *   dataBuffer(bytes1),\n\t *   dataBuffer(bytes2));\n\t *\n\t * testDecodeAll(input, byte[].class, step -&gt; step\n\t *   .consumeNextWith(expectBytes(allBytes))\n\t * \t .verifyComplete());\n\t * </pre>\n\t *\n\t * @param input the input to be provided to the decoder\n\t * @param outputClass the desired output class\n\t * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\n\t * @param <T> the output type\n\t */\n\tprotected <T> void testDecodeToMono(Publisher<DataBuffer> input,\n\t\t\tClass<? extends T> outputClass, Consumer<StepVerifier.FirstStep<T>> stepConsumer) {\n\n\t\ttestDecodeToMono(input, ResolvableType.forClass(outputClass), stepConsumer, null, null);\n\t}\n\n\t/**\n\t * Test a standard {@link Decoder#decodeToMono decode} scenario. For example:\n\t * <pre class=\"code\">\n\t * byte[] bytes1 = ...\n\t * byte[] bytes2 = ...\n\t * byte[] allBytes = ... // bytes1 + bytes2\n\t *\n\t * Flux&lt;DataBuffer&gt; input = Flux.concat(\n\t *   dataBuffer(bytes1),\n\t *   dataBuffer(bytes2));\n\t *\n\t * testDecodeAll(input, byte[].class, step -&gt; step\n\t *   .consumeNextWith(expectBytes(allBytes))\n\t * \t .verifyComplete());\n\t * </pre>\n\t *\n\t * @param input the input to be provided to the decoder\n\t * @param outputType the desired output type\n\t * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t * @param <T> the output type\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprotected <T> void testDecodeToMono(Publisher<DataBuffer> input, ResolvableType outputType,\n\t\t\tConsumer<StepVerifier.FirstStep<T>> stepConsumer,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tMono<T> result = (Mono<T>) this.decoder.decodeToMono(input, outputType, mimeType, hints);\n\t\tStepVerifier.FirstStep<T> step = StepVerifier.create(result);\n\t\tstepConsumer.accept(step);\n\t}\n\n\t/**\n\t * Test a {@link Decoder#decodeToMono decode} scenario where the input stream contains an error.\n\t * This test method will feed the first element of the {@code input} stream to the decoder,\n\t * followed by an {@link InputException}.\n\t * The result is expected to contain the error.\n\t *\n\t * @param input the input to be provided to the decoder\n\t * @param outputType the desired output type\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t * @see InputException\n\t */\n\tprotected void testDecodeToMonoError(Publisher<DataBuffer> input, ResolvableType outputType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tinput = Mono.from(input).concatWith(Flux.error(new InputException()));\n\t\tMono<?> result = this.decoder.decodeToMono(input, outputType, mimeType, hints);\n\t\tStepVerifier.create(result).expectError(InputException.class).verify();\n\t}\n\n\t/**\n\t * Test a {@link Decoder#decodeToMono decode} scenario where the input stream is canceled.\n\t * This test method will immediately cancel the output stream.\n\t *\n\t * @param input the input to be provided to the decoder\n\t * @param outputType the desired output type\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t */\n\tprotected void testDecodeToMonoCancel(Publisher<DataBuffer> input, ResolvableType outputType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tMono<?> result = this.decoder.decodeToMono(input, outputType, mimeType, hints);\n\t\tStepVerifier.create(result).thenCancel().verify();\n\t}\n\n\t/**\n\t * Test a {@link Decoder#decodeToMono decode} scenario where the input stream is empty.\n\t * The output is expected to be empty as well.\n\t *\n\t * @param outputType the desired output type\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t */\n\tprotected void testDecodeToMonoEmpty(ResolvableType outputType, @Nullable MimeType mimeType,\n\t\t\t@Nullable Map<String, Object> hints) {\n\n\t\tMono<?> result = this.decoder.decodeToMono(Flux.empty(), outputType, mimeType, hints);\n\t\tStepVerifier.create(result).verifyComplete();\n\t}\n\n\t/**\n\t * Creates a deferred {@link DataBuffer} containing the given bytes.\n\t * @param bytes the bytes that are to be stored in the buffer\n\t * @return the deferred buffer\n\t */\n\tprotected Mono<DataBuffer> dataBuffer(byte[] bytes) {\n\t\treturn Mono.fromCallable(() -> {\n\t\t\tDataBuffer dataBuffer = this.bufferFactory.allocateBuffer(bytes.length);\n\t\t\tdataBuffer.write(bytes);\n\t\t\treturn dataBuffer;\n\t\t});\n\t}\n\n\t/**\n\t * Exception used in {@link #testDecodeError} and {@link #testDecodeToMonoError}\n\t */\n\t@SuppressWarnings(\"serial\")\n\tpublic static class InputException extends RuntimeException {}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.testfixture.codec.InputException",
    "headType": "class",
    "relation": "extend",
    "tail": "RuntimeException",
    "tailType": "class"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.asm",
    "tailType": "package"
  },
  {
    "head": "org.springframework.asm",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.asm.ModuleVisitor",
    "tailType": "class"
  },
  {
    "head": "org.springframework.asm.ModuleVisitor",
    "headType": "class",
    "relation": "provide",
    "tail": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage org.springframework.asm;\n\n/**\n * A visitor to visit a Java module. The methods of this class must be called in the following\n * order: ( {@code visitMainClass} | ( {@code visitPackage} | {@code visitRequire} | {@code\n * visitExport} | {@code visitOpen} | {@code visitUse} | {@code visitProvide} )* ) {@code visitEnd}.\n *\n * @author Remi Forax\n * @author Eric Bruneton\n */\npublic abstract class ModuleVisitor {\n  /**\n   * The ASM API version implemented by this visitor. The value of this field must be one of {@link\n   * Opcodes#ASM6} or {@link Opcodes#ASM7}.\n   */\n  protected final int api;\n\n  /**\n   * The module visitor to which this visitor must delegate method calls. May be {@literal null}.\n   */\n  protected ModuleVisitor mv;\n\n  /**\n   * Constructs a new {@link ModuleVisitor}.\n   *\n   * @param api the ASM API version implemented by this visitor. Must be one of {@link Opcodes#ASM6}\n   *     or {@link Opcodes#ASM7}.\n   */\n  protected ModuleVisitor(final int api) {\n    this(api, null);\n  }\n\n  /**\n   * Constructs a new {@link ModuleVisitor}.\n   *\n   * @param api the ASM API version implemented by this visitor. Must be one of {@link Opcodes#ASM6}\n   *     or {@link Opcodes#ASM7}.\n   * @param moduleVisitor the module visitor to which this visitor must delegate method calls. May\n   *     be null.\n   */\n  protected ModuleVisitor(final int api, final ModuleVisitor moduleVisitor) {\n    if (api != Opcodes.ASM9\n        && api != Opcodes.ASM8\n        && api != Opcodes.ASM7\n        && api != Opcodes.ASM6\n        && api != Opcodes.ASM5\n        && api != Opcodes.ASM4\n        && api != Opcodes.ASM10_EXPERIMENTAL) {\n      throw new IllegalArgumentException(\"Unsupported api \" + api);\n    }\n    // SPRING PATCH: no preview mode check for ASM experimental\n    this.api = api;\n    this.mv = moduleVisitor;\n  }\n\n  /**\n   * Visit the main class of the current module.\n   *\n   * @param mainClass the internal name of the main class of the current module.\n   */\n  public void visitMainClass(final String mainClass) {\n    if (mv != null) {\n      mv.visitMainClass(mainClass);\n    }\n  }\n\n  /**\n   * Visit a package of the current module.\n   *\n   * @param packaze the internal name of a package.\n   */\n  public void visitPackage(final String packaze) {\n    if (mv != null) {\n      mv.visitPackage(packaze);\n    }\n  }\n\n  /**\n   * Visits a dependence of the current module.\n   *\n   * @param module the fully qualified name (using dots) of the dependence.\n   * @param access the access flag of the dependence among {@code ACC_TRANSITIVE}, {@code\n   *     ACC_STATIC_PHASE}, {@code ACC_SYNTHETIC} and {@code ACC_MANDATED}.\n   * @param version the module version at compile time, or {@literal null}.\n   */\n  public void visitRequire(final String module, final int access, final String version) {\n    if (mv != null) {\n      mv.visitRequire(module, access, version);\n    }\n  }\n\n  /**\n   * Visit an exported package of the current module.\n   *\n   * @param packaze the internal name of the exported package.\n   * @param access the access flag of the exported package, valid values are among {@code\n   *     ACC_SYNTHETIC} and {@code ACC_MANDATED}.\n   * @param modules the fully qualified names (using dots) of the modules that can access the public\n   *     classes of the exported package, or {@literal null}.\n   */\n  public void visitExport(final String packaze, final int access, final String... modules) {\n    if (mv != null) {\n      mv.visitExport(packaze, access, modules);\n    }\n  }\n\n  /**\n   * Visit an open package of the current module.\n   *\n   * @param packaze the internal name of the opened package.\n   * @param access the access flag of the opened package, valid values are among {@code\n   *     ACC_SYNTHETIC} and {@code ACC_MANDATED}.\n   * @param modules the fully qualified names (using dots) of the modules that can use deep\n   *     reflection to the classes of the open package, or {@literal null}.\n   */\n  public void visitOpen(final String packaze, final int access, final String... modules) {\n    if (mv != null) {\n      mv.visitOpen(packaze, access, modules);\n    }\n  }\n\n  /**\n   * Visit a service used by the current module. The name must be the internal name of an interface\n   * or a class.\n   *\n   * @param service the internal name of the service.\n   */\n  public void visitUse(final String service) {\n    if (mv != null) {\n      mv.visitUse(service);\n    }\n  }\n\n  /**\n   * Visit an implementation of a service.\n   *\n   * @param service the internal name of the service.\n   * @param providers the internal names of the implementations of the service (there is at least\n   *     one provider).\n   */\n  public void visitProvide(final String service, final String... providers) {\n    if (mv != null) {\n      mv.visitProvide(service, providers);\n    }\n  }\n\n  /**\n   * Visits the end of the module. This method, which is the last one to be called, is used to\n   * inform the visitor that everything have been visited.\n   */\n  public void visitEnd() {\n    if (mv != null) {\n      mv.visitEnd();\n    }\n  }\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.asm.ModuleVisitor",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.ModuleVisitor#api",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.ModuleVisitor#api",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.ModuleVisitor",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.ModuleVisitor#mv",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.ModuleVisitor#mv",
    "headType": "field",
    "relation": "haveType",
    "tail": "ModuleVisitor",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.ModuleVisitor#visitMainClass(String)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Visit the main class of the current module.\r\n *\r\n * @param mainClass the internal name of the main class of the current module.\r\n */\r\npublic void visitMainClass(final String mainClass) {\r\n    if (mv != null) {\r\n        mv.visitMainClass(mainClass);\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ModuleVisitor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ModuleVisitor#visitMainClass(String)",
    "tailType": "method"
  }
]