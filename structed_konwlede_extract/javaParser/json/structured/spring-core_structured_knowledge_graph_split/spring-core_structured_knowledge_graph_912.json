[
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.DefaultParameterNameDiscoverer",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.DefaultParameterNameDiscoverer",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\n/**\n * Default implementation of the {@link ParameterNameDiscoverer} strategy interface,\n * delegating to the Java 8 standard reflection mechanism.\n *\n * <p>If a Kotlin reflection implementation is present,\n * {@link KotlinReflectionParameterNameDiscoverer} is added first in the list and\n * used for Kotlin classes and interfaces.\n *\n * <p>Further discoverers may be added through {@link #addDiscoverer(ParameterNameDiscoverer)}.\n *\n * @author Juergen Hoeller\n * @author Sebastien Deleuze\n * @author Sam Brannen\n * @since 4.0\n * @see StandardReflectionParameterNameDiscoverer\n * @see KotlinReflectionParameterNameDiscoverer\n */\npublic class DefaultParameterNameDiscoverer extends PrioritizedParameterNameDiscoverer {\n\n\tpublic DefaultParameterNameDiscoverer() {\n\t\tif (KotlinDetector.isKotlinReflectPresent()) {\n\t\t\taddDiscoverer(new KotlinReflectionParameterNameDiscoverer());\n\t\t}\n\n\t\t// Recommended approach on Java 8+: compilation with -parameters.\n\t\taddDiscoverer(new StandardReflectionParameterNameDiscoverer());\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.DefaultParameterNameDiscoverer",
    "headType": "class",
    "relation": "extend",
    "tail": "PrioritizedParameterNameDiscoverer",
    "tailType": "class"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.env",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core.env",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.env.AbstractEnvironment",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.env.AbstractEnvironment",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.env;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.core.SpringProperties;\nimport org.springframework.core.convert.support.ConfigurableConversionService;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ObjectUtils;\nimport org.springframework.util.StringUtils;\n\n/**\n * Abstract base class for {@link Environment} implementations. Supports the notion of\n * reserved default profile names and enables specifying active and default profiles\n * through the {@link #ACTIVE_PROFILES_PROPERTY_NAME} and\n * {@link #DEFAULT_PROFILES_PROPERTY_NAME} properties.\n *\n * <p>Concrete subclasses differ primarily on which {@link PropertySource} objects they\n * add by default. {@code AbstractEnvironment} adds none. Subclasses should contribute\n * property sources through the protected {@link #customizePropertySources(MutablePropertySources)}\n * hook, while clients should customize using {@link ConfigurableEnvironment#getPropertySources()}\n * and working against the {@link MutablePropertySources} API.\n * See {@link ConfigurableEnvironment} javadoc for usage examples.\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @author Phillip Webb\n * @since 3.1\n * @see ConfigurableEnvironment\n * @see StandardEnvironment\n */\npublic abstract class AbstractEnvironment implements ConfigurableEnvironment {\n\n\t/**\n\t * System property that instructs Spring to ignore system environment variables,\n\t * i.e. to never attempt to retrieve such a variable via {@link System#getenv()}.\n\t * <p>The default is \"false\", falling back to system environment variable checks if a\n\t * Spring environment property (for example, a placeholder in a configuration String) isn't\n\t * resolvable otherwise. Consider switching this flag to \"true\" if you experience\n\t * log warnings from {@code getenv} calls coming from Spring.\n\t * @see #suppressGetenvAccess()\n\t */\n\tpublic static final String IGNORE_GETENV_PROPERTY_NAME = \"spring.getenv.ignore\";\n\n\t/**\n\t * Name of the property to set to specify active profiles: {@value}.\n\t * <p>The value may be comma delimited.\n\t * <p>Note that certain shell environments such as Bash disallow the use of the period\n\t * character in variable names. Assuming that Spring's {@link SystemEnvironmentPropertySource}\n\t * is in use, this property may be specified as an environment variable named\n\t * {@code SPRING_PROFILES_ACTIVE}.\n\t * @see ConfigurableEnvironment#setActiveProfiles\n\t */\n\tpublic static final String ACTIVE_PROFILES_PROPERTY_NAME = \"spring.profiles.active\";\n\n\t/**\n\t * Name of the property to set to specify profiles that are active by default: {@value}.\n\t * <p>The value may be comma delimited.\n\t * <p>Note that certain shell environments such as Bash disallow the use of the period\n\t * character in variable names. Assuming that Spring's {@link SystemEnvironmentPropertySource}\n\t * is in use, this property may be specified as an environment variable named\n\t * {@code SPRING_PROFILES_DEFAULT}.\n\t * @see ConfigurableEnvironment#setDefaultProfiles\n\t */\n\tpublic static final String DEFAULT_PROFILES_PROPERTY_NAME = \"spring.profiles.default\";\n\n\t/**\n\t * Name of the reserved default profile name: {@value}.\n\t * <p>If no default profile names are explicitly set and no active profile names\n\t * are explicitly set, this profile will automatically be activated by default.\n\t * @see #getReservedDefaultProfiles\n\t * @see ConfigurableEnvironment#setDefaultProfiles\n\t * @see ConfigurableEnvironment#setActiveProfiles\n\t * @see AbstractEnvironment#DEFAULT_PROFILES_PROPERTY_NAME\n\t * @see AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME\n\t */\n\tpublic static final String RESERVED_DEFAULT_PROFILE_NAME = \"default\";\n\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate final Set<String> activeProfiles = new LinkedHashSet<>();\n\n\tprivate final Set<String> defaultProfiles = new LinkedHashSet<>(getReservedDefaultProfiles());\n\n\tprivate final MutablePropertySources propertySources;\n\n\tprivate final ConfigurablePropertyResolver propertyResolver;\n\n\n\t/**\n\t * Create a new {@code Environment} instance, calling back to\n\t * {@link #customizePropertySources(MutablePropertySources)} during construction to\n\t * allow subclasses to contribute or manipulate {@link PropertySource} instances as\n\t * appropriate.\n\t * @see #customizePropertySources(MutablePropertySources)\n\t */\n\tpublic AbstractEnvironment() {\n\t\tthis(new MutablePropertySources());\n\t}\n\n\t/**\n\t * Create a new {@code Environment} instance with a specific\n\t * {@link MutablePropertySources} instance, calling back to\n\t * {@link #customizePropertySources(MutablePropertySources)} during\n\t * construction to allow subclasses to contribute or manipulate\n\t * {@link PropertySource} instances as appropriate.\n\t * @param propertySources property sources to use\n\t * @since 5.3.4\n\t * @see #customizePropertySources(MutablePropertySources)\n\t */\n\tprotected AbstractEnvironment(MutablePropertySources propertySources) {\n\t\tthis.propertySources = propertySources;\n\t\tthis.propertyResolver = createPropertyResolver(propertySources);\n\t\tcustomizePropertySources(propertySources);\n\t}\n\n\n\t/**\n\t * Factory method used to create the {@link ConfigurablePropertyResolver}\n\t * instance used by the Environment.\n\t * @since 5.3.4\n\t * @see #getPropertyResolver()\n\t */\n\tprotected ConfigurablePropertyResolver createPropertyResolver(MutablePropertySources propertySources) {\n\t\treturn new PropertySourcesPropertyResolver(propertySources);\n\t}\n\n\t/**\n\t * Return the {@link ConfigurablePropertyResolver} being used by the\n\t * {@link Environment}.\n\t * @since 5.3.4\n\t * @see #createPropertyResolver(MutablePropertySources)\n\t */\n\tprotected final ConfigurablePropertyResolver getPropertyResolver() {\n\t\treturn this.propertyResolver;\n\t}\n\n\t/**\n\t * Customize the set of {@link PropertySource} objects to be searched by this\n\t * {@code Environment} during calls to {@link #getProperty(String)} and related\n\t * methods.\n\t *\n\t * <p>Subclasses that override this method are encouraged to add property\n\t * sources using {@link MutablePropertySources#addLast(PropertySource)} such that\n\t * further subclasses may call {@code super.customizePropertySources()} with\n\t * predictable results. For example:\n\t *\n\t * <pre class=\"code\">\n\t * public class Level1Environment extends AbstractEnvironment {\n\t *     &#064;Override\n\t *     protected void customizePropertySources(MutablePropertySources propertySources) {\n\t *         super.customizePropertySources(propertySources); // no-op from base class\n\t *         propertySources.addLast(new PropertySourceA(...));\n\t *         propertySources.addLast(new PropertySourceB(...));\n\t *     }\n\t * }\n\t *\n\t * public class Level2Environment extends Level1Environment {\n\t *     &#064;Override\n\t *     protected void customizePropertySources(MutablePropertySources propertySources) {\n\t *         super.customizePropertySources(propertySources); // add all from superclass\n\t *         propertySources.addLast(new PropertySourceC(...));\n\t *         propertySources.addLast(new PropertySourceD(...));\n\t *     }\n\t * }\n\t * </pre>\n\t *\n\t * <p>In this arrangement, properties will be resolved against sources A, B, C, D in that\n\t * order. That is to say that property source \"A\" has precedence over property source\n\t * \"D\". If the {@code Level2Environment} subclass wished to give property sources C\n\t * and D higher precedence than A and B, it could simply call\n\t * {@code super.customizePropertySources} after, rather than before adding its own:\n\t *\n\t * <pre class=\"code\">\n\t * public class Level2Environment extends Level1Environment {\n\t *     &#064;Override\n\t *     protected void customizePropertySources(MutablePropertySources propertySources) {\n\t *         propertySources.addLast(new PropertySourceC(...));\n\t *         propertySources.addLast(new PropertySourceD(...));\n\t *         super.customizePropertySources(propertySources); // add all from superclass\n\t *     }\n\t * }\n\t * </pre>\n\t *\n\t * <p>The search order is now C, D, A, B as desired.\n\t *\n\t * <p>Beyond these recommendations, subclasses may use any of the {@code add*},\n\t * {@code remove}, or {@code replace} methods exposed by {@link MutablePropertySources}\n\t * in order to create the exact arrangement of property sources desired.\n\t *\n\t * <p>The base implementation registers no property sources.\n\t *\n\t * <p>Note that clients of any {@link ConfigurableEnvironment} may further customize\n\t * property sources via the {@link #getPropertySources()} accessor, typically within\n\t * an {@link org.springframework.context.ApplicationContextInitializer\n\t * ApplicationContextInitializer}. For example:\n\t *\n\t * <pre class=\"code\">\n\t * ConfigurableEnvironment env = new StandardEnvironment();\n\t * env.getPropertySources().addLast(new PropertySourceX(...));\n\t * </pre>\n\t *\n\t * <h2>A warning about instance variable access</h2>\n\t * <p>Instance variables declared in subclasses and having default initial values should\n\t * <em>not</em> be accessed from within this method. Due to Java object creation\n\t * lifecycle constraints, any initial value will not yet be assigned when this\n\t * callback is invoked by the {@link #AbstractEnvironment()} constructor, which may\n\t * lead to a {@code NullPointerException} or other problems. If you need to access\n\t * default values of instance variables, leave this method as a no-op and perform\n\t * property source manipulation and instance variable access directly within the\n\t * subclass constructor. Note that <em>assigning</em> values to instance variables is\n\t * not problematic; it is only attempting to read default values that must be avoided.\n\t * @see MutablePropertySources\n\t * @see PropertySourcesPropertyResolver\n\t * @see org.springframework.context.ApplicationContextInitializer\n\t */\n\tprotected void customizePropertySources(MutablePropertySources propertySources) {\n\t}\n\n\t/**\n\t * Return the set of reserved default profile names. This implementation returns\n\t * {@value #RESERVED_DEFAULT_PROFILE_NAME}. Subclasses may override in order to\n\t * customize the set of reserved names.\n\t * @see #RESERVED_DEFAULT_PROFILE_NAME\n\t * @see #doGetDefaultProfiles()\n\t */\n\tprotected Set<String> getReservedDefaultProfiles() {\n\t\treturn Collections.singleton(RESERVED_DEFAULT_PROFILE_NAME);\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Implementation of ConfigurableEnvironment interface\n\t//---------------------------------------------------------------------\n\n\t@Override\n\tpublic String[] getActiveProfiles() {\n\t\treturn StringUtils.toStringArray(doGetActiveProfiles());\n\t}\n\n\t/**\n\t * Return the set of active profiles as explicitly set through\n\t * {@link #setActiveProfiles} or if the current set of active profiles\n\t * is empty, check for the presence of {@link #doGetActiveProfilesProperty()}\n\t * and assign its value to the set of active profiles.\n\t * @see #getActiveProfiles()\n\t * @see #doGetActiveProfilesProperty()\n\t */\n\tprotected Set<String> doGetActiveProfiles() {\n\t\tsynchronized (this.activeProfiles) {\n\t\t\tif (this.activeProfiles.isEmpty()) {\n\t\t\t\tString profiles = doGetActiveProfilesProperty();\n\t\t\t\tif (StringUtils.hasText(profiles)) {\n\t\t\t\t\tsetActiveProfiles(StringUtils.commaDelimitedListToStringArray(\n\t\t\t\t\t\t\tStringUtils.trimAllWhitespace(profiles)));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.activeProfiles;\n\t\t}\n\t}\n\n\t/**\n\t * Return the property value for the active profiles.\n\t * @since 5.3.4\n\t * @see #ACTIVE_PROFILES_PROPERTY_NAME\n\t */\n\tprotected @Nullable String doGetActiveProfilesProperty() {\n\t\treturn getProperty(ACTIVE_PROFILES_PROPERTY_NAME);\n\t}\n\n\t@Override\n\tpublic void setActiveProfiles(String... profiles) {\n\t\tAssert.notNull(profiles, \"Profile array must not be null\");\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Activating profiles \" + Arrays.toString(profiles));\n\t\t}\n\t\tsynchronized (this.activeProfiles) {\n\t\t\tthis.activeProfiles.clear();\n\t\t\tfor (String profile : profiles) {\n\t\t\t\tvalidateProfile(profile);\n\t\t\t\tthis.activeProfiles.add(profile);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addActiveProfile(String profile) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Activating profile '\" + profile + \"'\");\n\t\t}\n\t\tvalidateProfile(profile);\n\t\tdoGetActiveProfiles();\n\t\tsynchronized (this.activeProfiles) {\n\t\t\tthis.activeProfiles.add(profile);\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic String[] getDefaultProfiles() {\n\t\treturn StringUtils.toStringArray(doGetDefaultProfiles());\n\t}\n\n\t/**\n\t * Return the set of default profiles explicitly set via\n\t * {@link #setDefaultProfiles(String...)} or if the current set of default profiles\n\t * consists only of {@linkplain #getReservedDefaultProfiles() reserved default\n\t * profiles}, then check for the presence of {@link #doGetActiveProfilesProperty()}\n\t * and assign its value (if any) to the set of default profiles.\n\t * @see #AbstractEnvironment()\n\t * @see #getDefaultProfiles()\n\t * @see #getReservedDefaultProfiles()\n\t * @see #doGetDefaultProfilesProperty()\n\t */\n\tprotected Set<String> doGetDefaultProfiles() {\n\t\tsynchronized (this.defaultProfiles) {\n\t\t\tif (this.defaultProfiles.equals(getReservedDefaultProfiles())) {\n\t\t\t\tString profiles = doGetDefaultProfilesProperty();\n\t\t\t\tif (StringUtils.hasText(profiles)) {\n\t\t\t\t\tsetDefaultProfiles(StringUtils.commaDelimitedListToStringArray(\n\t\t\t\t\t\t\tStringUtils.trimAllWhitespace(profiles)));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.defaultProfiles;\n\t\t}\n\t}\n\n\t/**\n\t * Return the property value for the default profiles.\n\t * @since 5.3.4\n\t * @see #DEFAULT_PROFILES_PROPERTY_NAME\n\t */\n\tprotected @Nullable String doGetDefaultProfilesProperty() {\n\t\treturn getProperty(DEFAULT_PROFILES_PROPERTY_NAME);\n\t}\n\n\t/**\n\t * Specify the set of profiles to be made active by default if no other profiles\n\t * are explicitly made active through {@link #setActiveProfiles}.\n\t * <p>Calling this method removes overrides any reserved default profiles\n\t * that may have been added during construction of the environment.\n\t * @see #AbstractEnvironment()\n\t * @see #getReservedDefaultProfiles()\n\t */\n\t@Override\n\tpublic void setDefaultProfiles(String... profiles) {\n\t\tAssert.notNull(profiles, \"Profile array must not be null\");\n\t\tsynchronized (this.defaultProfiles) {\n\t\t\tthis.defaultProfiles.clear();\n\t\t\tfor (String profile : profiles) {\n\t\t\t\tvalidateProfile(profile);\n\t\t\t\tthis.defaultProfiles.add(profile);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\t@Deprecated\n\tpublic boolean acceptsProfiles(String... profiles) {\n\t\tAssert.notEmpty(profiles, \"Must specify at least one profile\");\n\t\tfor (String profile : profiles) {\n\t\t\tif (StringUtils.hasLength(profile) && profile.charAt(0) == '!') {\n\t\t\t\tif (!isProfileActive(profile.substring(1))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (isProfileActive(profile)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean acceptsProfiles(Profiles profiles) {\n\t\tAssert.notNull(profiles, \"Profiles must not be null\");\n\t\treturn profiles.matches(this::isProfileActive);\n\t}\n\n\t/**\n\t * Return whether the given profile is active, or if active profiles are empty\n\t * whether the profile should be active by default.\n\t * @throws IllegalArgumentException per {@link #validateProfile(String)}\n\t */\n\tprotected boolean isProfileActive(String profile) {\n\t\tvalidateProfile(profile);\n\t\tSet<String> currentActiveProfiles = doGetActiveProfiles();\n\t\treturn (currentActiveProfiles.contains(profile) ||\n\t\t\t\t(currentActiveProfiles.isEmpty() && doGetDefaultProfiles().contains(profile)));\n\t}\n\n\t/**\n\t * Validate the given profile, called internally prior to adding to the set of\n\t * active or default profiles.\n\t * <p>Subclasses may override to impose further restrictions on profile syntax.\n\t * @throws IllegalArgumentException if the profile is null, empty, whitespace-only or\n\t * begins with the profile NOT operator (!).\n\t * @see #acceptsProfiles\n\t * @see #addActiveProfile\n\t * @see #setDefaultProfiles\n\t */\n\tprotected void validateProfile(String profile) {\n\t\tif (!StringUtils.hasText(profile)) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid profile [\" + profile + \"]: must contain text\");\n\t\t}\n\t\tif (profile.charAt(0) == '!') {\n\t\t\tthrow new IllegalArgumentException(\"Invalid profile [\" + profile + \"]: must not begin with ! operator\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic MutablePropertySources getPropertySources() {\n\t\treturn this.propertySources;\n\t}\n\n\t@Override\n\t@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n\tpublic Map<String, Object> getSystemProperties() {\n\t\treturn (Map) System.getProperties();\n\t}\n\n\t@Override\n\t@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n\tpublic Map<String, Object> getSystemEnvironment() {\n\t\tif (suppressGetenvAccess()) {\n\t\t\treturn Collections.emptyMap();\n\t\t}\n\t\treturn (Map) System.getenv();\n\t}\n\n\t/**\n\t * Determine whether to suppress {@link System#getenv()}/{@link System#getenv(String)}\n\t * access for the purposes of {@link #getSystemEnvironment()}.\n\t * <p>If this method returns {@code true}, an empty dummy Map will be used instead\n\t * of the regular system environment Map, never even trying to call {@code getenv}\n\t * and therefore avoiding security manager warnings (if any).\n\t * <p>The default implementation checks for the \"spring.getenv.ignore\" system property,\n\t * returning {@code true} if its value equals \"true\" in any case.\n\t * @see #IGNORE_GETENV_PROPERTY_NAME\n\t * @see SpringProperties#getFlag\n\t */\n\tprotected boolean suppressGetenvAccess() {\n\t\treturn SpringProperties.getFlag(IGNORE_GETENV_PROPERTY_NAME);\n\t}\n\n\t@Override\n\tpublic void merge(ConfigurableEnvironment parent) {\n\t\tfor (PropertySource<?> ps : parent.getPropertySources()) {\n\t\t\tif (!this.propertySources.contains(ps.getName())) {\n\t\t\t\tthis.propertySources.addLast(ps);\n\t\t\t}\n\t\t}\n\t\tString[] parentActiveProfiles = parent.getActiveProfiles();\n\t\tif (!ObjectUtils.isEmpty(parentActiveProfiles)) {\n\t\t\tsynchronized (this.activeProfiles) {\n\t\t\t\tCollections.addAll(this.activeProfiles, parentActiveProfiles);\n\t\t\t}\n\t\t}\n\t\tString[] parentDefaultProfiles = parent.getDefaultProfiles();\n\t\tif (!ObjectUtils.isEmpty(parentDefaultProfiles)) {\n\t\t\tsynchronized (this.defaultProfiles) {\n\t\t\t\tthis.defaultProfiles.remove(RESERVED_DEFAULT_PROFILE_NAME);\n\t\t\t\tCollections.addAll(this.defaultProfiles, parentDefaultProfiles);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Implementation of ConfigurablePropertyResolver interface\n\t//---------------------------------------------------------------------\n\n\t@Override\n\tpublic ConfigurableConversionService getConversionService() {\n\t\treturn this.propertyResolver.getConversionService();\n\t}\n\n\t@Override\n\tpublic void setConversionService(ConfigurableConversionService conversionService) {\n\t\tthis.propertyResolver.setConversionService(conversionService);\n\t}\n\n\t@Override\n\tpublic void setPlaceholderPrefix(String placeholderPrefix) {\n\t\tthis.propertyResolver.setPlaceholderPrefix(placeholderPrefix);\n\t}\n\n\t@Override\n\tpublic void setPlaceholderSuffix(String placeholderSuffix) {\n\t\tthis.propertyResolver.setPlaceholderSuffix(placeholderSuffix);\n\t}\n\n\t@Override\n\tpublic void setValueSeparator(@Nullable String valueSeparator) {\n\t\tthis.propertyResolver.setValueSeparator(valueSeparator);\n\t}\n\n\t@Override\n\tpublic void setEscapeCharacter(@Nullable Character escapeCharacter) {\n\t\tthis.propertyResolver.setEscapeCharacter(escapeCharacter);\n\t}\n\n\t@Override\n\tpublic void setIgnoreUnresolvableNestedPlaceholders(boolean ignoreUnresolvableNestedPlaceholders) {\n\t\tthis.propertyResolver.setIgnoreUnresolvableNestedPlaceholders(ignoreUnresolvableNestedPlaceholders);\n\t}\n\n\t@Override\n\tpublic void setRequiredProperties(String... requiredProperties) {\n\t\tthis.propertyResolver.setRequiredProperties(requiredProperties);\n\t}\n\n\t@Override\n\tpublic void validateRequiredProperties() throws MissingRequiredPropertiesException {\n\t\tthis.propertyResolver.validateRequiredProperties();\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Implementation of PropertyResolver interface\n\t//---------------------------------------------------------------------\n\n\t@Override\n\tpublic boolean containsProperty(String key) {\n\t\treturn this.propertyResolver.containsProperty(key);\n\t}\n\n\t@Override\n\tpublic @Nullable String getProperty(String key) {\n\t\treturn this.propertyResolver.getProperty(key);\n\t}\n\n\t@Override\n\tpublic String getProperty(String key, String defaultValue) {\n\t\treturn this.propertyResolver.getProperty(key, defaultValue);\n\t}\n\n\t@Override\n\tpublic <T> @Nullable T getProperty(String key, Class<T> targetType) {\n\t\treturn this.propertyResolver.getProperty(key, targetType);\n\t}\n\n\t@Override\n\tpublic <T> T getProperty(String key, Class<T> targetType, T defaultValue) {\n\t\treturn this.propertyResolver.getProperty(key, targetType, defaultValue);\n\t}\n\n\t@Override\n\tpublic String getRequiredProperty(String key) throws IllegalStateException {\n\t\treturn this.propertyResolver.getRequiredProperty(key);\n\t}\n\n\t@Override\n\tpublic <T> T getRequiredProperty(String key, Class<T> targetType) throws IllegalStateException {\n\t\treturn this.propertyResolver.getRequiredProperty(key, targetType);\n\t}\n\n\t@Override\n\tpublic String resolvePlaceholders(String text) {\n\t\treturn this.propertyResolver.resolvePlaceholders(text);\n\t}\n\n\t@Override\n\tpublic String resolveRequiredPlaceholders(String text) throws IllegalArgumentException {\n\t\treturn this.propertyResolver.resolveRequiredPlaceholders(text);\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \" {activeProfiles=\" + this.activeProfiles +\n\t\t\t\t\", defaultProfiles=\" + this.defaultProfiles + \", propertySources=\" + this.propertySources + \"}\";\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.env.AbstractEnvironment",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.env.AbstractEnvironment#IGNORE_GETENV_PROPERTY_NAME",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.env.AbstractEnvironment#IGNORE_GETENV_PROPERTY_NAME",
    "headType": "field",
    "relation": "haveType",
    "tail": "String",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.env.AbstractEnvironment",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.env.AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.env.AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME",
    "headType": "field",
    "relation": "haveType",
    "tail": "String",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.env.AbstractEnvironment",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.env.AbstractEnvironment#DEFAULT_PROFILES_PROPERTY_NAME",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.env.AbstractEnvironment#DEFAULT_PROFILES_PROPERTY_NAME",
    "headType": "field",
    "relation": "haveType",
    "tail": "String",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.env.AbstractEnvironment",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.env.AbstractEnvironment#RESERVED_DEFAULT_PROFILE_NAME",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.env.AbstractEnvironment#RESERVED_DEFAULT_PROFILE_NAME",
    "headType": "field",
    "relation": "haveType",
    "tail": "String",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.env.AbstractEnvironment",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.env.AbstractEnvironment#logger",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.env.AbstractEnvironment#logger",
    "headType": "field",
    "relation": "haveType",
    "tail": "Log",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.env.AbstractEnvironment",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.env.AbstractEnvironment#activeProfiles",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.env.AbstractEnvironment#activeProfiles",
    "headType": "field",
    "relation": "haveType",
    "tail": "Set<String>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.env.AbstractEnvironment",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.env.AbstractEnvironment#defaultProfiles",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.env.AbstractEnvironment#defaultProfiles",
    "headType": "field",
    "relation": "haveType",
    "tail": "Set<String>",
    "tailType": "type"
  }
]