[
  {
    "head": "org.springframework.core.annotation.StringGenericParameter",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.MergedAnnotations.SearchStrategy;\nimport org.springframework.util.ReflectionUtils;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Unit tests that verify support for finding multiple composed annotations on a single\n * annotated element.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n */\nclass MergedAnnotationsComposedOnSingleAnnotatedElementTests {\n\n\t// See SPR-13486\n\n\t@Test\n\tvoid inheritedStrategyMultipleComposedAnnotationsOnClass() {\n\t\tassertInheritedStrategyBehavior(MultipleComposedCachesClass.class);\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleInheritedComposedAnnotationsOnSuperclass() {\n\t\tassertInheritedStrategyBehavior(SubMultipleComposedCachesClass.class);\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleNoninheritedComposedAnnotationsOnClass() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tMultipleNoninheritedComposedCachesClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS);\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"noninheritedCache1\",\n\t\t\t\t\"noninheritedCache2\");\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleNoninheritedComposedAnnotationsOnSuperclass() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tSubMultipleNoninheritedComposedCachesClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS);\n\t\tassertThat(annotations.stream(Cacheable.class)).isEmpty();\n\t}\n\n\t@Test\n\tvoid inheritedStrategyComposedPlusLocalAnnotationsOnClass() {\n\t\tassertInheritedStrategyBehavior(ComposedPlusLocalCachesClass.class);\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleComposedAnnotationsOnInterface() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tMultipleComposedCachesOnInterfaceClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS);\n\t\tassertThat(annotations.stream(Cacheable.class)).isEmpty();\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleComposedAnnotationsOnMethod() throws Exception {\n\t\tassertInheritedStrategyBehavior(\n\t\t\t\tgetClass().getDeclaredMethod(\"multipleComposedCachesMethod\"));\n\t}\n\n\t@Test\n\tvoid inheritedStrategyComposedPlusLocalAnnotationsOnMethod() throws Exception {\n\t\tassertInheritedStrategyBehavior(\n\t\t\t\tgetClass().getDeclaredMethod(\"composedPlusLocalCachesMethod\"));\n\t}\n\n\tprivate void assertInheritedStrategyBehavior(AnnotatedElement element) {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(element,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS);\n\t\tassertThat(stream(annotations, \"key\")).containsExactly(\"fooKey\", \"barKey\");\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"fooCache\", \"barCache\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleComposedAnnotationsOnClass() {\n\t\tassertTypeHierarchyStrategyBehavior(MultipleComposedCachesClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleInheritedComposedAnnotationsOnSuperclass() {\n\t\tassertTypeHierarchyStrategyBehavior(SubMultipleComposedCachesClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleNoninheritedComposedAnnotationsOnClass() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tMultipleNoninheritedComposedCachesClass.class, SearchStrategy.TYPE_HIERARCHY);\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"noninheritedCache1\",\n\t\t\t\t\"noninheritedCache2\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleNoninheritedComposedAnnotationsOnSuperclass() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tSubMultipleNoninheritedComposedCachesClass.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY);\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"noninheritedCache1\",\n\t\t\t\t\"noninheritedCache2\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyComposedPlusLocalAnnotationsOnClass() {\n\t\tassertTypeHierarchyStrategyBehavior(ComposedPlusLocalCachesClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleComposedAnnotationsOnInterface() {\n\t\tassertTypeHierarchyStrategyBehavior(MultipleComposedCachesOnInterfaceClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyComposedCacheOnInterfaceAndLocalCacheOnClass() {\n\t\tassertTypeHierarchyStrategyBehavior(\n\t\t\t\tComposedCacheOnInterfaceAndLocalCacheClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleComposedAnnotationsOnMethod() throws Exception {\n\t\tassertTypeHierarchyStrategyBehavior(\n\t\t\t\tgetClass().getDeclaredMethod(\"multipleComposedCachesMethod\"));\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyComposedPlusLocalAnnotationsOnMethod()\n\t\t\tthrows Exception {\n\t\tassertTypeHierarchyStrategyBehavior(\n\t\t\t\tgetClass().getDeclaredMethod(\"composedPlusLocalCachesMethod\"));\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleComposedAnnotationsOnBridgeMethod() {\n\t\tassertTypeHierarchyStrategyBehavior(getBridgeMethod());\n\t}\n\n\tprivate void assertTypeHierarchyStrategyBehavior(AnnotatedElement element) {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(element,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY);\n\t\tassertThat(stream(annotations, \"key\")).containsExactly(\"fooKey\", \"barKey\");\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"fooCache\", \"barCache\");\n\t}\n\n\tMethod getBridgeMethod() {\n\t\tList<Method> methods = new ArrayList<>();\n\t\tReflectionUtils.doWithLocalMethods(StringGenericParameter.class, method -> {\n\t\t\tif (\"getFor\".equals(method.getName())) {\n\t\t\t\tmethods.add(method);\n\t\t\t}\n\t\t});\n\t\tMethod bridgeMethod = methods.get(0).getReturnType() == Object.class ? methods.get(0) : methods.get(1);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\treturn bridgeMethod;\n\t}\n\n\tprivate Stream<String> stream(MergedAnnotations annotations, String attributeName) {\n\t\treturn annotations.stream(Cacheable.class).map(\n\t\t\t\tannotation -> annotation.getString(attributeName));\n\t}\n\n\t// @formatter:off\n\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Cacheable {\n\t\t@AliasFor(\"cacheName\")\n\t\tString value() default \"\";\n\t\t@AliasFor(\"value\")\n\t\tString cacheName() default \"\";\n\t\tString key() default \"\";\n\t}\n\n\t@Cacheable(\"fooCache\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface FooCache {\n\t\t@AliasFor(annotation = Cacheable.class)\n\t\tString key() default \"\";\n\t}\n\n\t@Cacheable(\"barCache\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface BarCache {\n\t\t@AliasFor(annotation = Cacheable.class)\n\t\tString key();\n\t}\n\n\t@Cacheable(\"noninheritedCache1\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface NoninheritedCache1 {\n\t\t@AliasFor(annotation = Cacheable.class)\n\t\tString key() default \"\";\n\t}\n\n\t@Cacheable(\"noninheritedCache2\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface NoninheritedCache2 {\n\t\t@AliasFor(annotation = Cacheable.class)\n\t\tString key() default \"\";\n\t}\n\n\t@FooCache(key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate static class MultipleComposedCachesClass {\n\t}\n\n\tprivate static class SubMultipleComposedCachesClass\n\t\t\textends MultipleComposedCachesClass {\n\t}\n\n\t@NoninheritedCache1\n\t@NoninheritedCache2\n\tprivate static class MultipleNoninheritedComposedCachesClass {\n\t}\n\n\tprivate static class SubMultipleNoninheritedComposedCachesClass\n\t\t\textends MultipleNoninheritedComposedCachesClass {\n\t}\n\n\t@Cacheable(cacheName = \"fooCache\", key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate static class ComposedPlusLocalCachesClass {\n\t}\n\n\t@FooCache(key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate interface MultipleComposedCachesInterface {\n\t}\n\n\tprivate static class MultipleComposedCachesOnInterfaceClass implements MultipleComposedCachesInterface {\n\t}\n\n\t@BarCache(key = \"barKey\")\n\tprivate interface ComposedCacheInterface {\n\t}\n\n\t@Cacheable(cacheName = \"fooCache\", key = \"fooKey\")\n\tprivate static class ComposedCacheOnInterfaceAndLocalCacheClass implements ComposedCacheInterface {\n\t}\n\n\t@FooCache(key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate void multipleComposedCachesMethod() {\n\t}\n\n\t@Cacheable(cacheName = \"fooCache\", key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate void composedPlusLocalCachesMethod() {\n\t}\n\n\tpublic interface GenericParameter<T> {\n\t\tT getFor(Class<T> cls);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class StringGenericParameter implements GenericParameter<String> {\n\t\t@FooCache(key = \"fooKey\")\n\t\t@BarCache(key = \"barKey\")\n\t\t@Override\n\t\tpublic String getFor(Class<String> cls) { return \"foo\"; }\n\t\tpublic String getFor(Integer integer) { return \"foo\"; }\n\t}\n\n\t// @formatter:on\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation.StringGenericParameter#getFor(Class<String>)",
    "headType": "method",
    "relation": "provide",
    "tail": "@FooCache(key = \"fooKey\")\r\n@BarCache(key = \"barKey\")\r\n@Override\r\npublic String getFor(Class<String> cls) {\r\n    return \"foo\";\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.StringGenericParameter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.StringGenericParameter#getFor(Class<String>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.StringGenericParameter#getFor(Class<String>)",
    "headType": "method",
    "relation": "use",
    "tail": "@FooCache",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.StringGenericParameter#getFor(Class<String>)",
    "headType": "method",
    "relation": "use",
    "tail": "@BarCache",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.StringGenericParameter#getFor(Class<String>)",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.StringGenericParameter#getFor(Integer)",
    "headType": "method",
    "relation": "provide",
    "tail": "public String getFor(Integer integer) {\r\n    return \"foo\";\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.StringGenericParameter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.StringGenericParameter#getFor(Integer)",
    "tailType": "method"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.annotation",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.MergedAnnotationsRepeatableAnnotationTests",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotationsRepeatableAnnotationTests",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedElement;\nimport java.util.Arrays;\nimport java.util.Set;\nimport java.util.stream.Stream;\n\nimport org.assertj.core.api.ThrowableTypeAssert;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.MergedAnnotations.SearchStrategy;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.springframework.core.annotation.MergedAnnotations.SearchStrategy.INHERITED_ANNOTATIONS;\nimport static org.springframework.core.annotation.MergedAnnotations.SearchStrategy.TYPE_HIERARCHY;\n\n/**\n * Tests for {@link MergedAnnotations} and {@link RepeatableContainers} that\n * verify support for repeatable annotations.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n */\nclass MergedAnnotationsRepeatableAnnotationTests {\n\n\t// See SPR-13973\n\n\t@Test\n\tvoid inheritedAnnotationsWhenNonRepeatableThrowsException() {\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(null, NonRepeatable.class, INHERITED_ANNOTATIONS, getClass()))\n\t\t\t\t.satisfies(this::nonRepeatableRequirements);\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenContainerMissingValueAttributeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerMissingValueAttribute.class, InvalidRepeatable.class,\n\t\t\t\t\t\tINHERITED_ANNOTATIONS, getClass()))\n\t\t\t\t.satisfies(this::missingValueAttributeRequirements);\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenWhenNonArrayValueAttributeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerWithNonArrayValueAttribute.class, InvalidRepeatable.class,\n\t\t\t\t\t\tINHERITED_ANNOTATIONS, getClass()))\n\t\t\t\t.satisfies(this::nonArrayValueAttributeRequirements);\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenWrongComponentTypeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerWithArrayValueAttributeButWrongComponentType.class,\n\t\t\t\t\t\tInvalidRepeatable.class, INHERITED_ANNOTATIONS, getClass()))\n\t\t\t\t.satisfies(this::wrongComponentTypeRequirements);\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, RepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenWhenOnSuperclassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, SubRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenComposedOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, ComposedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenComposedMixedWithContainerOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, ComposedRepeatableMixedWithContainerClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenComposedContainerForRepeatableOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, ComposedContainerClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenNoninheritedComposedRepeatableOnClassReturnsAnnotations() {\n\t\tSet<Noninherited> annotations = getAnnotations(null, Noninherited.class,\n\t\t\t\tINHERITED_ANNOTATIONS, NoninheritedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(Noninherited::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenNoninheritedComposedRepeatableOnSuperclassReturnsAnnotations() {\n\t\tSet<Noninherited> annotations = getAnnotations(null, Noninherited.class,\n\t\t\t\tINHERITED_ANNOTATIONS, SubNoninheritedRepeatableClass.class);\n\t\tassertThat(annotations).isEmpty();\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenNonRepeatableThrowsException() {\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(null, NonRepeatable.class, TYPE_HIERARCHY, getClass()))\n\t\t\t\t.satisfies(this::nonRepeatableRequirements);\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenContainerMissingValueAttributeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerMissingValueAttribute.class, InvalidRepeatable.class,\n\t\t\t\t\t\tTYPE_HIERARCHY, getClass()))\n\t\t\t\t.satisfies(this::missingValueAttributeRequirements);\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenWhenNonArrayValueAttributeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerWithNonArrayValueAttribute.class, InvalidRepeatable.class,\n\t\t\t\t\t\tTYPE_HIERARCHY, getClass()))\n\t\t\t\t.satisfies(this::nonArrayValueAttributeRequirements);\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenWrongComponentTypeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerWithArrayValueAttributeButWrongComponentType.class,\n\t\t\t\t\t\tInvalidRepeatable.class, TYPE_HIERARCHY, getClass()))\n\t\t\t\t.satisfies(this::wrongComponentTypeRequirements);\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, RepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenOnSuperclassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, SubRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenComposedOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, ComposedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenComposedMixedWithContainerOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, ComposedRepeatableMixedWithContainerClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenComposedContainerForRepeatableOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, ComposedContainerClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyAnnotationsWhenNoninheritedComposedRepeatableOnClassReturnsAnnotations() {\n\t\tSet<Noninherited> annotations = getAnnotations(null, Noninherited.class,\n\t\t\t\tTYPE_HIERARCHY, NoninheritedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(Noninherited::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyAnnotationsWhenNoninheritedComposedRepeatableOnSuperclassReturnsAnnotations() {\n\t\tSet<Noninherited> annotations = getAnnotations(null, Noninherited.class,\n\t\t\t\tTYPE_HIERARCHY, SubNoninheritedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(Noninherited::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyAnnotationsWithLocalComposedAnnotationWhoseRepeatableMetaAnnotationsAreFiltered() {\n\t\tClass<WithRepeatedMetaAnnotationsClass> element = WithRepeatedMetaAnnotationsClass.class;\n\t\tSearchStrategy searchStrategy = TYPE_HIERARCHY;\n\t\tAnnotationFilter annotationFilter = PeteRepeat.class.getName()::equals;\n\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class, searchStrategy, element, annotationFilter);\n\t\tassertThat(annotations).isEmpty();\n\n\t\tMergedAnnotations mergedAnnotations = MergedAnnotations.from(element, searchStrategy,\n\t\t\t\tRepeatableContainers.standardRepeatables(), annotationFilter);\n\t\tStream<Class<? extends Annotation>> annotationTypes = mergedAnnotations.stream()\n\t\t\t\t.map(MergedAnnotation::synthesize)\n\t\t\t\t.map(Annotation::annotationType);\n\t\tassertThat(annotationTypes).containsExactly(WithRepeatedMetaAnnotations.class, Noninherited.class, Noninherited.class);\n\t}\n\n\t@Test  // gh-32731\n\tvoid searchFindsRepeatableContainerAnnotationAndRepeatedAnnotations() {\n\t\tClass<?> clazz = StandardRepeatablesWithContainerWithMultipleAttributesTestCase.class;\n\n\t\t// NO RepeatableContainers\n\t\tMergedAnnotations mergedAnnotations = MergedAnnotations.from(clazz, TYPE_HIERARCHY, RepeatableContainers.none());\n\t\tContainerWithMultipleAttributes container = mergedAnnotations\n\t\t\t\t.get(ContainerWithMultipleAttributes.class)\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t\tassertThat(container).as(\"container\").isNotNull();\n\t\tassertThat(container.name()).isEqualTo(\"enigma\");\n\t\tRepeatableWithContainerWithMultipleAttributes[] repeatedAnnotations = container.value();\n\t\tassertThat(Arrays.stream(repeatedAnnotations).map(RepeatableWithContainerWithMultipleAttributes::value))\n\t\t\t\t.containsExactly(\"A\", \"B\");\n\t\tSet<RepeatableWithContainerWithMultipleAttributes> set =\n\t\t\t\tmergedAnnotations.stream(RepeatableWithContainerWithMultipleAttributes.class)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t\t// Only finds the locally declared repeated annotation.\n\t\tassertThat(set.stream().map(RepeatableWithContainerWithMultipleAttributes::value))\n\t\t\t\t.containsExactly(\"C\");\n\n\t\t// Standard RepeatableContainers\n\t\tmergedAnnotations = MergedAnnotations.from(clazz, TYPE_HIERARCHY, RepeatableContainers.standardRepeatables());\n\t\tcontainer = mergedAnnotations\n\t\t\t\t.get(ContainerWithMultipleAttributes.class)\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t\tassertThat(container).as(\"container\").isNotNull();\n\t\tassertThat(container.name()).isEqualTo(\"enigma\");\n\t\trepeatedAnnotations = container.value();\n\t\tassertThat(Arrays.stream(repeatedAnnotations).map(RepeatableWithContainerWithMultipleAttributes::value))\n\t\t\t\t.containsExactly(\"A\", \"B\");\n\t\tset = mergedAnnotations.stream(RepeatableWithContainerWithMultipleAttributes.class)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t\t// Finds the locally declared repeated annotation plus the 2 in the container.\n\t\tassertThat(set.stream().map(RepeatableWithContainerWithMultipleAttributes::value))\n\t\t\t\t.containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\tprivate <A extends Annotation> Set<A> getAnnotations(Class<? extends Annotation> container,\n\t\t\tClass<A> repeatable, SearchStrategy searchStrategy, AnnotatedElement element) {\n\n\t\treturn getAnnotations(container, repeatable, searchStrategy, element, AnnotationFilter.PLAIN);\n\t}\n\n\tprivate <A extends Annotation> Set<A> getAnnotations(Class<? extends Annotation> container,\n\t\t\tClass<A> repeatable, SearchStrategy searchStrategy, AnnotatedElement element, AnnotationFilter annotationFilter) {\n\n\t\tRepeatableContainers containers = RepeatableContainers.of(repeatable, container);\n\t\tMergedAnnotations annotations = MergedAnnotations.from(element, searchStrategy, containers, annotationFilter);\n\t\treturn annotations.stream(repeatable).collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}\n\n\tprivate void nonRepeatableRequirements(Exception ex) {\n\t\tassertThat(ex)\n\t\t\t\t.hasMessageStartingWith(\"Annotation type must be a repeatable annotation\")\n\t\t\t\t.hasMessageContaining(\"failed to resolve container type for\", NonRepeatable.class.getName());\n\t}\n\n\tprivate void missingValueAttributeRequirements(Exception ex) {\n\t\tassertThat(ex)\n\t\t\t\t.hasMessageStartingWith(\"Invalid declaration of container type\")\n\t\t\t\t.hasMessageContaining(\n\t\t\t\t\t\tContainerMissingValueAttribute.class.getName(),\n\t\t\t\t\t\t\"for repeatable annotation\",\n\t\t\t\t\t\tInvalidRepeatable.class.getName())\n\t\t\t\t.hasCauseInstanceOf(NoSuchMethodException.class);\n\t}\n\n\tprivate void nonArrayValueAttributeRequirements(Exception ex) {\n\t\tassertThat(ex)\n\t\t\t\t.hasMessageStartingWith(\"Container type\")\n\t\t\t\t.hasMessageContaining(\n\t\t\t\t\t\tContainerWithNonArrayValueAttribute.class.getName(),\n\t\t\t\t\t\t\"must declare a 'value' attribute for an array of type\",\n\t\t\t\t\t\tInvalidRepeatable.class.getName());\n\t}\n\n\tprivate void wrongComponentTypeRequirements(Exception ex) {\n\t\tassertThat(ex)\n\t\t\t\t.hasMessageStartingWith(\"Container type\")\n\t\t\t\t.hasMessageContaining(\n\t\t\t\t\t\tContainerWithArrayValueAttributeButWrongComponentType.class.getName(),\n\t\t\t\t\t\t\"must declare a 'value' attribute for an array of type\",\n\t\t\t\t\t\tInvalidRepeatable.class.getName());\n\t}\n\n\tprivate static ThrowableTypeAssert<AnnotationConfigurationException> assertThatAnnotationConfigurationException() {\n\t\treturn assertThatExceptionOfType(AnnotationConfigurationException.class);\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface NonRepeatable {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContainerMissingValueAttribute {\n\n\t\t// InvalidRepeatable[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContainerWithNonArrayValueAttribute {\n\n\t\tInvalidRepeatable value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContainerWithArrayValueAttributeButWrongComponentType {\n\n\t\tString[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface InvalidRepeatable {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface PeteRepeats {\n\n\t\tPeteRepeat[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@Repeatable(PeteRepeats.class)\n\t@interface PeteRepeat {\n\n\t\tString value();\n\t}\n\n\t@PeteRepeat(\"shadowed\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface ForPetesSake {\n\n\t\t@AliasFor(annotation = PeteRepeat.class)\n\t\tString value();\n\t}\n\n\t@PeteRepeat(\"shadowed\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface ForTheLoveOfFoo {\n\n\t\t@AliasFor(annotation = PeteRepeat.class)\n\t\tString value();\n\t}\n\n\t@PeteRepeats({ @PeteRepeat(\"B\"), @PeteRepeat(\"C\") })\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface ComposedContainer {\n\t}\n\n\t@PeteRepeat(\"A\")\n\t@PeteRepeats({ @PeteRepeat(\"B\"), @PeteRepeat(\"C\") })\n\tstatic class RepeatableClass {\n\t}\n\n\tstatic class SubRepeatableClass extends RepeatableClass {\n\t}\n\n\t@ForPetesSake(\"B\")\n\t@ForTheLoveOfFoo(\"C\")\n\t@PeteRepeat(\"A\")\n\tstatic class ComposedRepeatableClass {\n\t}\n\n\t@ForPetesSake(\"C\")\n\t@PeteRepeats(@PeteRepeat(\"A\"))\n\t@PeteRepeat(\"B\")\n\tstatic class ComposedRepeatableMixedWithContainerClass {\n\t}\n\n\t@PeteRepeat(\"A\")\n\t@ComposedContainer\n\tstatic class ComposedContainerClass {\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Noninheriteds {\n\n\t\tNoninherited[] value();\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(Noninheriteds.class)\n\t@interface Noninherited {\n\n\t\t@AliasFor(\"name\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString name() default \"\";\n\t}\n\n\t@Noninherited(name = \"shadowed\")\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedNoninherited {\n\n\t\t@AliasFor(annotation = Noninherited.class)\n\t\tString name() default \"\";\n\t}\n\n\t@ComposedNoninherited(name = \"C\")\n\t@Noninheriteds({ @Noninherited(value = \"A\"), @Noninherited(name = \"B\") })\n\tstatic class NoninheritedRepeatableClass {\n\t}\n\n\tstatic class SubNoninheritedRepeatableClass extends NoninheritedRepeatableClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@PeteRepeat(\"A\")\n\t@PeteRepeat(\"B\")\n\t@interface WithRepeatedMetaAnnotations {\n\t}\n\n\t@WithRepeatedMetaAnnotations\n\t@PeteRepeat(\"C\")\n\t@Noninherited(\"X\")\n\t@Noninherited(\"Y\")\n\tstatic class WithRepeatedMetaAnnotationsClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContainerWithMultipleAttributes {\n\n\t\tRepeatableWithContainerWithMultipleAttributes[] value();\n\n\t\tString name() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(ContainerWithMultipleAttributes.class)\n\t@interface RepeatableWithContainerWithMultipleAttributes {\n\n\t\tString value() default \"\";\n\t}\n\n\t@ContainerWithMultipleAttributes(name = \"enigma\", value = {\n\t\t@RepeatableWithContainerWithMultipleAttributes(\"A\"),\n\t\t@RepeatableWithContainerWithMultipleAttributes(\"B\")\n\t})\n\t@RepeatableWithContainerWithMultipleAttributes(\"C\")\n\tstatic class StandardRepeatablesWithContainerWithMultipleAttributesTestCase {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotationsRepeatableAnnotationTests#inheritedAnnotationsWhenNonRepeatableThrowsException()",
    "headType": "method",
    "relation": "provide",
    "tail": "// See SPR-13973\r\n@Test\r\nvoid inheritedAnnotationsWhenNonRepeatableThrowsException() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> getAnnotations(null, NonRepeatable.class, INHERITED_ANNOTATIONS, getClass())).satisfies(this::nonRepeatableRequirements);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotationsRepeatableAnnotationTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.MergedAnnotationsRepeatableAnnotationTests#inheritedAnnotationsWhenNonRepeatableThrowsException()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotationsRepeatableAnnotationTests#inheritedAnnotationsWhenNonRepeatableThrowsException()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotationsRepeatableAnnotationTests#inheritedAnnotationsWhenContainerMissingValueAttributeThrowsException()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid inheritedAnnotationsWhenContainerMissingValueAttributeThrowsException() {\r\n    assertThatAnnotationConfigurationException().isThrownBy(() -> getAnnotations(ContainerMissingValueAttribute.class, InvalidRepeatable.class, INHERITED_ANNOTATIONS, getClass())).satisfies(this::missingValueAttributeRequirements);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotationsRepeatableAnnotationTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.MergedAnnotationsRepeatableAnnotationTests#inheritedAnnotationsWhenContainerMissingValueAttributeThrowsException()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotationsRepeatableAnnotationTests#inheritedAnnotationsWhenContainerMissingValueAttributeThrowsException()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotationsRepeatableAnnotationTests#inheritedAnnotationsWhenWhenNonArrayValueAttributeThrowsException()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid inheritedAnnotationsWhenWhenNonArrayValueAttributeThrowsException() {\r\n    assertThatAnnotationConfigurationException().isThrownBy(() -> getAnnotations(ContainerWithNonArrayValueAttribute.class, InvalidRepeatable.class, INHERITED_ANNOTATIONS, getClass())).satisfies(this::nonArrayValueAttributeRequirements);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotationsRepeatableAnnotationTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.MergedAnnotationsRepeatableAnnotationTests#inheritedAnnotationsWhenWhenNonArrayValueAttributeThrowsException()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotationsRepeatableAnnotationTests#inheritedAnnotationsWhenWhenNonArrayValueAttributeThrowsException()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  }
]