[
  {
    "head": "org.springframework.asm.SymbolTable",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.SymbolTable#hash(int,String,int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.SymbolTable#hash(int,String,String)",
    "headType": "method",
    "relation": "provide",
    "tail": "private static int hash(final int tag, final String value1, final String value2) {\r\n    return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode());\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.SymbolTable",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.SymbolTable#hash(int,String,String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.SymbolTable#hash(int,String,String,int)",
    "headType": "method",
    "relation": "provide",
    "tail": "private static int hash(final int tag, final String value1, final String value2, final int value3) {\r\n    return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode() * (value3 + 1));\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.SymbolTable",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.SymbolTable#hash(int,String,String,int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.SymbolTable#hash(int,String,String,String)",
    "headType": "method",
    "relation": "provide",
    "tail": "private static int hash(final int tag, final String value1, final String value2, final String value3) {\r\n    return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode() * value3.hashCode());\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.SymbolTable",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.SymbolTable#hash(int,String,String,String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.SymbolTable#hash(int,String,String,String,int)",
    "headType": "method",
    "relation": "provide",
    "tail": "private static int hash(final int tag, final String value1, final String value2, final String value3, final int value4) {\r\n    return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode() * value3.hashCode() * value4);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.SymbolTable",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.SymbolTable#hash(int,String,String,String,int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.asm.Entry",
    "tailType": "class"
  },
  {
    "head": "org.springframework.asm.Entry",
    "headType": "class",
    "relation": "provide",
    "tail": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage org.springframework.asm;\n\n/**\n * The constant pool entries, the BootstrapMethods attribute entries and the (ASM specific) type\n * table entries of a class.\n *\n * @author Eric Bruneton\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.4\">JVMS\n *     4.4</a>\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.23\">JVMS\n *     4.7.23</a>\n */\nfinal class SymbolTable {\n\n  /**\n   * The ClassWriter to which this SymbolTable belongs. This is only used to get access to {@link\n   * ClassWriter#getCommonSuperClass} and to serialize custom attributes with {@link\n   * Attribute#write}.\n   */\n  final ClassWriter classWriter;\n\n  /**\n   * The ClassReader from which this SymbolTable was constructed, or {@literal null} if it was\n   * constructed from scratch.\n   */\n  private final ClassReader sourceClassReader;\n\n  /** The major version number of the class to which this symbol table belongs. */\n  private int majorVersion;\n\n  /** The internal name of the class to which this symbol table belongs. */\n  private String className;\n\n  /**\n   * The total number of {@link Entry} instances in {@link #entries}. This includes entries that are\n   * accessible (recursively) via {@link Entry#next}.\n   */\n  private int entryCount;\n\n  /**\n   * A hash set of all the entries in this SymbolTable (this includes the constant pool entries, the\n   * bootstrap method entries and the type table entries). Each {@link Entry} instance is stored at\n   * the array index given by its hash code modulo the array size. If several entries must be stored\n   * at the same array index, they are linked together via their {@link Entry#next} field. The\n   * factory methods of this class make sure that this table does not contain duplicated entries.\n   */\n  private Entry[] entries;\n\n  /**\n   * The number of constant pool items in {@link #constantPool}, plus 1. The first constant pool\n   * item has index 1, and long and double items count for two items.\n   */\n  private int constantPoolCount;\n\n  /**\n   * The content of the ClassFile's constant_pool JVMS structure corresponding to this SymbolTable.\n   * The ClassFile's constant_pool_count field is <i>not</i> included.\n   */\n  private ByteVector constantPool;\n\n  /**\n   * The number of bootstrap methods in {@link #bootstrapMethods}. Corresponds to the\n   * BootstrapMethods_attribute's num_bootstrap_methods field value.\n   */\n  private int bootstrapMethodCount;\n\n  /**\n   * The content of the BootstrapMethods attribute 'bootstrap_methods' array corresponding to this\n   * SymbolTable. Note that the first 6 bytes of the BootstrapMethods_attribute, and its\n   * num_bootstrap_methods field, are <i>not</i> included.\n   */\n  private ByteVector bootstrapMethods;\n\n  /**\n   * The actual number of elements in {@link #typeTable}. These elements are stored from index 0 to\n   * typeCount (excluded). The other array entries are empty.\n   */\n  private int typeCount;\n\n  /**\n   * An ASM specific type table used to temporarily store internal names that will not necessarily\n   * be stored in the constant pool. This type table is used by the control flow and data flow\n   * analysis algorithm used to compute stack map frames from scratch. This array stores {@link\n   * Symbol#TYPE_TAG}, {@link Symbol#UNINITIALIZED_TYPE_TAG},{@link\n   * Symbol#FORWARD_UNINITIALIZED_TYPE_TAG} and {@link Symbol#MERGED_TYPE_TAG} entries. The type\n   * symbol at index {@code i} has its {@link Symbol#index} equal to {@code i} (and vice versa).\n   */\n  private Entry[] typeTable;\n\n  /**\n   * The actual number of {@link LabelEntry} in {@link #labelTable}. These elements are stored from\n   * index 0 to labelCount (excluded). The other array entries are empty. These label entries are\n   * also stored in the {@link #labelEntries} hash set.\n   */\n  private int labelCount;\n\n  /**\n   * The labels corresponding to the \"forward uninitialized\" types in the ASM specific {@link\n   * typeTable} (see {@link Symbol#FORWARD_UNINITIALIZED_TYPE_TAG}). The label entry at index {@code\n   * i} has its {@link LabelEntry#index} equal to {@code i} (and vice versa).\n   */\n  private LabelEntry[] labelTable;\n\n  /**\n   * A hash set of all the {@link LabelEntry} elements in the {@link #labelTable}. Each {@link\n   * LabelEntry} instance is stored at the array index given by its hash code modulo the array size.\n   * If several entries must be stored at the same array index, they are linked together via their\n   * {@link LabelEntry#next} field. The {@link #getOrAddLabelEntry(Label)} method ensures that this\n   * table does not contain duplicated entries.\n   */\n  private LabelEntry[] labelEntries;\n\n  /**\n   * Constructs a new, empty SymbolTable for the given ClassWriter.\n   *\n   * @param classWriter a ClassWriter.\n   */\n  SymbolTable(final ClassWriter classWriter) {\n    this.classWriter = classWriter;\n    this.sourceClassReader = null;\n    this.entries = new Entry[256];\n    this.constantPoolCount = 1;\n    this.constantPool = new ByteVector();\n  }\n\n  /**\n   * Constructs a new SymbolTable for the given ClassWriter, initialized with the constant pool and\n   * bootstrap methods of the given ClassReader.\n   *\n   * @param classWriter a ClassWriter.\n   * @param classReader the ClassReader whose constant pool and bootstrap methods must be copied to\n   *     initialize the SymbolTable.\n   */\n  SymbolTable(final ClassWriter classWriter, final ClassReader classReader) {\n    this.classWriter = classWriter;\n    this.sourceClassReader = classReader;\n\n    // Copy the constant pool binary content.\n    byte[] inputBytes = classReader.classFileBuffer;\n    int constantPoolOffset = classReader.getItem(1) - 1;\n    int constantPoolLength = classReader.header - constantPoolOffset;\n    constantPoolCount = classReader.getItemCount();\n    constantPool = new ByteVector(constantPoolLength);\n    constantPool.putByteArray(inputBytes, constantPoolOffset, constantPoolLength);\n\n    // Add the constant pool items in the symbol table entries. Reserve enough space in 'entries' to\n    // avoid too many hash set collisions (entries is not dynamically resized by the addConstant*\n    // method calls below), and to account for bootstrap method entries.\n    entries = new Entry[constantPoolCount * 2];\n    char[] charBuffer = new char[classReader.getMaxStringLength()];\n    boolean hasBootstrapMethods = false;\n    int itemIndex = 1;\n    while (itemIndex < constantPoolCount) {\n      int itemOffset = classReader.getItem(itemIndex);\n      int itemTag = inputBytes[itemOffset - 1];\n      int nameAndTypeItemOffset;\n      switch (itemTag) {\n        case Symbol.CONSTANT_FIELDREF_TAG:\n        case Symbol.CONSTANT_METHODREF_TAG:\n        case Symbol.CONSTANT_INTERFACE_METHODREF_TAG:\n          nameAndTypeItemOffset =\n              classReader.getItem(classReader.readUnsignedShort(itemOffset + 2));\n          addConstantMemberReference(\n              itemIndex,\n              itemTag,\n              classReader.readClass(itemOffset, charBuffer),\n              classReader.readUTF8(nameAndTypeItemOffset, charBuffer),\n              classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer));\n          break;\n        case Symbol.CONSTANT_INTEGER_TAG:\n        case Symbol.CONSTANT_FLOAT_TAG:\n          addConstantIntegerOrFloat(itemIndex, itemTag, classReader.readInt(itemOffset));\n          break;\n        case Symbol.CONSTANT_NAME_AND_TYPE_TAG:\n          addConstantNameAndType(\n              itemIndex,\n              classReader.readUTF8(itemOffset, charBuffer),\n              classReader.readUTF8(itemOffset + 2, charBuffer));\n          break;\n        case Symbol.CONSTANT_LONG_TAG:\n        case Symbol.CONSTANT_DOUBLE_TAG:\n          addConstantLongOrDouble(itemIndex, itemTag, classReader.readLong(itemOffset));\n          break;\n        case Symbol.CONSTANT_UTF8_TAG:\n          addConstantUtf8(itemIndex, classReader.readUtf(itemIndex, charBuffer));\n          break;\n        case Symbol.CONSTANT_METHOD_HANDLE_TAG:\n          int memberRefItemOffset =\n              classReader.getItem(classReader.readUnsignedShort(itemOffset + 1));\n          nameAndTypeItemOffset =\n              classReader.getItem(classReader.readUnsignedShort(memberRefItemOffset + 2));\n          addConstantMethodHandle(\n              itemIndex,\n              classReader.readByte(itemOffset),\n              classReader.readClass(memberRefItemOffset, charBuffer),\n              classReader.readUTF8(nameAndTypeItemOffset, charBuffer),\n              classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer),\n              classReader.readByte(memberRefItemOffset - 1)\n                  == Symbol.CONSTANT_INTERFACE_METHODREF_TAG);\n          break;\n        case Symbol.CONSTANT_DYNAMIC_TAG:\n        case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:\n          hasBootstrapMethods = true;\n          nameAndTypeItemOffset =\n              classReader.getItem(classReader.readUnsignedShort(itemOffset + 2));\n          addConstantDynamicOrInvokeDynamicReference(\n              itemTag,\n              itemIndex,\n              classReader.readUTF8(nameAndTypeItemOffset, charBuffer),\n              classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer),\n              classReader.readUnsignedShort(itemOffset));\n          break;\n        case Symbol.CONSTANT_STRING_TAG:\n        case Symbol.CONSTANT_CLASS_TAG:\n        case Symbol.CONSTANT_METHOD_TYPE_TAG:\n        case Symbol.CONSTANT_MODULE_TAG:\n        case Symbol.CONSTANT_PACKAGE_TAG:\n          addConstantUtf8Reference(\n              itemIndex, itemTag, classReader.readUTF8(itemOffset, charBuffer));\n          break;\n        default:\n          throw new IllegalArgumentException();\n      }\n      itemIndex +=\n          (itemTag == Symbol.CONSTANT_LONG_TAG || itemTag == Symbol.CONSTANT_DOUBLE_TAG) ? 2 : 1;\n    }\n\n    // Copy the BootstrapMethods, if any.\n    if (hasBootstrapMethods) {\n      copyBootstrapMethods(classReader, charBuffer);\n    }\n  }\n\n  /**\n   * Read the BootstrapMethods 'bootstrap_methods' array binary content and add them as entries of\n   * the SymbolTable.\n   *\n   * @param classReader the ClassReader whose bootstrap methods must be copied to initialize the\n   *     SymbolTable.\n   * @param charBuffer a buffer used to read strings in the constant pool.\n   */\n  private void copyBootstrapMethods(final ClassReader classReader, final char[] charBuffer) {\n    // Find attributOffset of the 'bootstrap_methods' array.\n    byte[] inputBytes = classReader.classFileBuffer;\n    int currentAttributeOffset = classReader.getFirstAttributeOffset();\n    for (int i = classReader.readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {\n      String attributeName = classReader.readUTF8(currentAttributeOffset, charBuffer);\n      if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\n        bootstrapMethodCount = classReader.readUnsignedShort(currentAttributeOffset + 6);\n        break;\n      }\n      currentAttributeOffset += 6 + classReader.readInt(currentAttributeOffset + 2);\n    }\n    if (bootstrapMethodCount > 0) {\n      // Compute the offset and the length of the BootstrapMethods 'bootstrap_methods' array.\n      int bootstrapMethodsOffset = currentAttributeOffset + 8;\n      int bootstrapMethodsLength = classReader.readInt(currentAttributeOffset + 2) - 2;\n      bootstrapMethods = new ByteVector(bootstrapMethodsLength);\n      bootstrapMethods.putByteArray(inputBytes, bootstrapMethodsOffset, bootstrapMethodsLength);\n\n      // Add each bootstrap method in the symbol table entries.\n      int currentOffset = bootstrapMethodsOffset;\n      for (int i = 0; i < bootstrapMethodCount; i++) {\n        int offset = currentOffset - bootstrapMethodsOffset;\n        int bootstrapMethodRef = classReader.readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        int numBootstrapArguments = classReader.readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        int hashCode = classReader.readConst(bootstrapMethodRef, charBuffer).hashCode();\n        while (numBootstrapArguments-- > 0) {\n          int bootstrapArgument = classReader.readUnsignedShort(currentOffset);\n          currentOffset += 2;\n          hashCode ^= classReader.readConst(bootstrapArgument, charBuffer).hashCode();\n        }\n        add(new Entry(i, Symbol.BOOTSTRAP_METHOD_TAG, offset, hashCode & 0x7FFFFFFF));\n      }\n    }\n  }\n\n  /**\n   * Returns the ClassReader from which this SymbolTable was constructed.\n   *\n   * @return the ClassReader from which this SymbolTable was constructed, or {@literal null} if it\n   *     was constructed from scratch.\n   */\n  ClassReader getSource() {\n    return sourceClassReader;\n  }\n\n  /**\n   * Returns the major version of the class to which this symbol table belongs.\n   *\n   * @return the major version of the class to which this symbol table belongs.\n   */\n  int getMajorVersion() {\n    return majorVersion;\n  }\n\n  /**\n   * Returns the internal name of the class to which this symbol table belongs.\n   *\n   * @return the internal name of the class to which this symbol table belongs.\n   */\n  String getClassName() {\n    return className;\n  }\n\n  /**\n   * Sets the major version and the name of the class to which this symbol table belongs. Also adds\n   * the class name to the constant pool.\n   *\n   * @param majorVersion a major ClassFile version number.\n   * @param className an internal class name.\n   * @return the constant pool index of a new or already existing Symbol with the given class name.\n   */\n  int setMajorVersionAndClassName(final int majorVersion, final String className) {\n    this.majorVersion = majorVersion;\n    this.className = className;\n    return addConstantClass(className).index;\n  }\n\n  /**\n   * Returns the number of items in this symbol table's constant_pool array (plus 1).\n   *\n   * @return the number of items in this symbol table's constant_pool array (plus 1).\n   */\n  int getConstantPoolCount() {\n    return constantPoolCount;\n  }\n\n  /**\n   * Returns the length in bytes of this symbol table's constant_pool array.\n   *\n   * @return the length in bytes of this symbol table's constant_pool array.\n   */\n  int getConstantPoolLength() {\n    return constantPool.length;\n  }\n\n  /**\n   * Puts this symbol table's constant_pool array in the given ByteVector, preceded by the\n   * constant_pool_count value.\n   *\n   * @param output where the JVMS ClassFile's constant_pool array must be put.\n   */\n  void putConstantPool(final ByteVector output) {\n    output.putShort(constantPoolCount).putByteArray(constantPool.data, 0, constantPool.length);\n  }\n\n  /**\n   * Returns the size in bytes of this symbol table's BootstrapMethods attribute. Also adds the\n   * attribute name in the constant pool.\n   *\n   * @return the size in bytes of this symbol table's BootstrapMethods attribute.\n   */\n  int computeBootstrapMethodsSize() {\n    if (bootstrapMethods != null) {\n      addConstantUtf8(Constants.BOOTSTRAP_METHODS);\n      return 8 + bootstrapMethods.length;\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n   * Puts this symbol table's BootstrapMethods attribute in the given ByteVector. This includes the\n   * 6 attribute header bytes and the num_bootstrap_methods value.\n   *\n   * @param output where the JVMS BootstrapMethods attribute must be put.\n   */\n  void putBootstrapMethods(final ByteVector output) {\n    if (bootstrapMethods != null) {\n      output\n          .putShort(addConstantUtf8(Constants.BOOTSTRAP_METHODS))\n          .putInt(bootstrapMethods.length + 2)\n          .putShort(bootstrapMethodCount)\n          .putByteArray(bootstrapMethods.data, 0, bootstrapMethods.length);\n    }\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Generic symbol table entries management.\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Returns the list of entries which can potentially have the given hash code.\n   *\n   * @param hashCode a {@link Entry#hashCode} value.\n   * @return the list of entries which can potentially have the given hash code. The list is stored\n   *     via the {@link Entry#next} field.\n   */\n  private Entry get(final int hashCode) {\n    return entries[hashCode % entries.length];\n  }\n\n  /**\n   * Puts the given entry in the {@link #entries} hash set. This method does <i>not</i> check\n   * whether {@link #entries} already contains a similar entry or not. {@link #entries} is resized\n   * if necessary to avoid hash collisions (multiple entries needing to be stored at the same {@link\n   * #entries} array index) as much as possible, with reasonable memory usage.\n   *\n   * @param entry an Entry (which must not already be contained in {@link #entries}).\n   * @return the given entry\n   */\n  private Entry put(final Entry entry) {\n    if (entryCount > (entries.length * 3) / 4) {\n      int currentCapacity = entries.length;\n      int newCapacity = currentCapacity * 2 + 1;\n      Entry[] newEntries = new Entry[newCapacity];\n      for (int i = currentCapacity - 1; i >= 0; --i) {\n        Entry currentEntry = entries[i];\n        while (currentEntry != null) {\n          int newCurrentEntryIndex = currentEntry.hashCode % newCapacity;\n          Entry nextEntry = currentEntry.next;\n          currentEntry.next = newEntries[newCurrentEntryIndex];\n          newEntries[newCurrentEntryIndex] = currentEntry;\n          currentEntry = nextEntry;\n        }\n      }\n      entries = newEntries;\n    }\n    entryCount++;\n    int index = entry.hashCode % entries.length;\n    entry.next = entries[index];\n    return entries[index] = entry;\n  }\n\n  /**\n   * Adds the given entry in the {@link #entries} hash set. This method does <i>not</i> check\n   * whether {@link #entries} already contains a similar entry or not, and does <i>not</i> resize\n   * {@link #entries} if necessary.\n   *\n   * @param entry an Entry (which must not already be contained in {@link #entries}).\n   */\n  private void add(final Entry entry) {\n    entryCount++;\n    int index = entry.hashCode % entries.length;\n    entry.next = entries[index];\n    entries[index] = entry;\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Constant pool entries management.\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Adds a number or string constant to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param value the value of the constant to be added to the constant pool. This parameter must be\n   *     an {@link Integer}, {@link Byte}, {@link Character}, {@link Short}, {@link Boolean}, {@link\n   *     Float}, {@link Long}, {@link Double}, {@link String}, {@link Type} or {@link Handle}.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstant(final Object value) {\n    if (value instanceof Integer) {\n      return addConstantInteger(((Integer) value).intValue());\n    } else if (value instanceof Byte) {\n      return addConstantInteger(((Byte) value).intValue());\n    } else if (value instanceof Character) {\n      return addConstantInteger(((Character) value).charValue());\n    } else if (value instanceof Short) {\n      return addConstantInteger(((Short) value).intValue());\n    } else if (value instanceof Boolean) {\n      return addConstantInteger(((Boolean) value).booleanValue() ? 1 : 0);\n    } else if (value instanceof Float) {\n      return addConstantFloat(((Float) value).floatValue());\n    } else if (value instanceof Long) {\n      return addConstantLong(((Long) value).longValue());\n    } else if (value instanceof Double) {\n      return addConstantDouble(((Double) value).doubleValue());\n    } else if (value instanceof String) {\n      return addConstantString((String) value);\n    } else if (value instanceof Type) {\n      Type type = (Type) value;\n      int typeSort = type.getSort();\n      if (typeSort == Type.OBJECT) {\n        return addConstantClass(type.getInternalName());\n      } else if (typeSort == Type.METHOD) {\n        return addConstantMethodType(type.getDescriptor());\n      } else { // type is a primitive or array type.\n        return addConstantClass(type.getDescriptor());\n      }\n    } else if (value instanceof Handle) {\n      Handle handle = (Handle) value;\n      return addConstantMethodHandle(\n          handle.getTag(),\n          handle.getOwner(),\n          handle.getName(),\n          handle.getDesc(),\n          handle.isInterface());\n    } else if (value instanceof ConstantDynamic) {\n      ConstantDynamic constantDynamic = (ConstantDynamic) value;\n      return addConstantDynamic(\n          constantDynamic.getName(),\n          constantDynamic.getDescriptor(),\n          constantDynamic.getBootstrapMethod(),\n          constantDynamic.getBootstrapMethodArgumentsUnsafe());\n    } else {\n      throw new IllegalArgumentException(\"value \" + value);\n    }\n  }\n\n  /**\n   * Adds a CONSTANT_Class_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param value the internal name of a class.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstantClass(final String value) {\n    return addConstantUtf8Reference(Symbol.CONSTANT_CLASS_TAG, value);\n  }\n\n  /**\n   * Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param owner the internal name of a class.\n   * @param name a field name.\n   * @param descriptor a field descriptor.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstantFieldref(final String owner, final String name, final String descriptor) {\n    return addConstantMemberReference(Symbol.CONSTANT_FIELDREF_TAG, owner, name, descriptor);\n  }\n\n  /**\n   * Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this\n   * symbol table. Does nothing if the constant pool already contains a similar item.\n   *\n   * @param owner the internal name of a class.\n   * @param name a method name.\n   * @param descriptor a method descriptor.\n   * @param isInterface whether owner is an interface or not.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstantMethodref(\n      final String owner, final String name, final String descriptor, final boolean isInterface) {\n    int tag = isInterface ? Symbol.CONSTANT_INTERFACE_METHODREF_TAG : Symbol.CONSTANT_METHODREF_TAG;\n    return addConstantMemberReference(tag, owner, name, descriptor);\n  }\n\n  /**\n   * Adds a CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to\n   * the constant pool of this symbol table. Does nothing if the constant pool already contains a\n   * similar item.\n   *\n   * @param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}\n   *     or {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.\n   * @param owner the internal name of a class.\n   * @param name a field or method name.\n   * @param descriptor a field or method descriptor.\n   * @return a new or already existing Symbol with the given value.\n   */\n  private Entry addConstantMemberReference(\n      final int tag, final String owner, final String name, final String descriptor) {\n    int hashCode = hash(tag, owner, name, descriptor);\n    Entry entry = get(hashCode);\n    while (entry != null) {\n      if (entry.tag == tag\n          && entry.hashCode == hashCode\n          && entry.owner.equals(owner)\n          && entry.name.equals(name)\n          && entry.value.equals(descriptor)) {\n        return entry;\n      }\n      entry = entry.next;\n    }\n    constantPool.put122(\n        tag, addConstantClass(owner).index, addConstantNameAndType(name, descriptor));\n    return put(new Entry(constantPoolCount++, tag, owner, name, descriptor, 0, hashCode));\n  }\n\n  /**\n   * Adds a new CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info\n   * to the constant pool of this symbol table.\n   *\n   * @param index the constant pool index of the new Symbol.\n   * @param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}\n   *     or {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.\n   * @param owner the internal name of a class.\n   * @param name a field or method name.\n   * @param descriptor a field or method descriptor.\n   */\n  private void addConstantMemberReference(\n      final int index,\n      final int tag,\n      final String owner,\n      final String name,\n      final String descriptor) {\n    add(new Entry(index, tag, owner, name, descriptor, 0, hash(tag, owner, name, descriptor)));\n  }\n\n  /**\n   * Adds a CONSTANT_String_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param value a string.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstantString(final String value) {\n    return addConstantUtf8Reference(Symbol.CONSTANT_STRING_TAG, value);\n  }\n\n  /**\n   * Adds a CONSTANT_Integer_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param value an int.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstantInteger(final int value) {\n    return addConstantIntegerOrFloat(Symbol.CONSTANT_INTEGER_TAG, value);\n  }\n\n  /**\n   * Adds a CONSTANT_Float_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param value a float.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstantFloat(final float value) {\n    return addConstantIntegerOrFloat(Symbol.CONSTANT_FLOAT_TAG, Float.floatToRawIntBits(value));\n  }\n\n  /**\n   * Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table.\n   * Does nothing if the constant pool already contains a similar item.\n   *\n   * @param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\n   * @param value an int or float.\n   * @return a constant pool constant with the given tag and primitive values.\n   */\n  private Symbol addConstantIntegerOrFloat(final int tag, final int value) {\n    int hashCode = hash(tag, value);\n    Entry entry = get(hashCode);\n    while (entry != null) {\n      if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) {\n        return entry;\n      }\n      entry = entry.next;\n    }\n    constantPool.putByte(tag).putInt(value);\n    return put(new Entry(constantPoolCount++, tag, value, hashCode));\n  }\n\n  /**\n   * Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol\n   * table.\n   *\n   * @param index the constant pool index of the new Symbol.\n   * @param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\n   * @param value an int or float.\n   */\n  private void addConstantIntegerOrFloat(final int index, final int tag, final int value) {\n    add(new Entry(index, tag, value, hash(tag, value)));\n  }\n\n  /**\n   * Adds a CONSTANT_Long_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param value a long.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstantLong(final long value) {\n    return addConstantLongOrDouble(Symbol.CONSTANT_LONG_TAG, value);\n  }\n\n  /**\n   * Adds a CONSTANT_Double_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param value a double.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstantDouble(final double value) {\n    return addConstantLongOrDouble(Symbol.CONSTANT_DOUBLE_TAG, Double.doubleToRawLongBits(value));\n  }\n\n  /**\n   * Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table.\n   * Does nothing if the constant pool already contains a similar item.\n   *\n   * @param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.\n   * @param value a long or double.\n   * @return a constant pool constant with the given tag and primitive values.\n   */\n  private Symbol addConstantLongOrDouble(final int tag, final long value) {\n    int hashCode = hash(tag, value);\n    Entry entry = get(hashCode);\n    while (entry != null) {\n      if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) {\n        return entry;\n      }\n      entry = entry.next;\n    }\n    int index = constantPoolCount;\n    constantPool.putByte(tag).putLong(value);\n    constantPoolCount += 2;\n    return put(new Entry(index, tag, value, hashCode));\n  }\n\n  /**\n   * Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol\n   * table.\n   *\n   * @param index the constant pool index of the new Symbol.\n   * @param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.\n   * @param value a long or double.\n   */\n  private void addConstantLongOrDouble(final int index, final int tag, final long value) {\n    add(new Entry(index, tag, value, hash(tag, value)));\n  }\n\n  /**\n   * Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param name a field or method name.\n   * @param descriptor a field or method descriptor.\n   * @return a new or already existing Symbol with the given value.\n   */\n  int addConstantNameAndType(final String name, final String descriptor) {\n    final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG;\n    int hashCode = hash(tag, name, descriptor);\n    Entry entry = get(hashCode);\n    while (entry != null) {\n      if (entry.tag == tag\n          && entry.hashCode == hashCode\n          && entry.name.equals(name)\n          && entry.value.equals(descriptor)) {\n        return entry.index;\n      }\n      entry = entry.next;\n    }\n    constantPool.put122(tag, addConstantUtf8(name), addConstantUtf8(descriptor));\n    return put(new Entry(constantPoolCount++, tag, name, descriptor, hashCode)).index;\n  }\n\n  /**\n   * Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table.\n   *\n   * @param index the constant pool index of the new Symbol.\n   * @param name a field or method name.\n   * @param descriptor a field or method descriptor.\n   */\n  private void addConstantNameAndType(final int index, final String name, final String descriptor) {\n    final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG;\n    add(new Entry(index, tag, name, descriptor, hash(tag, name, descriptor)));\n  }\n\n  /**\n   * Adds a CONSTANT_Utf8_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param value a string.\n   * @return a new or already existing Symbol with the given value.\n   */\n  int addConstantUtf8(final String value) {\n    int hashCode = hash(Symbol.CONSTANT_UTF8_TAG, value);\n    Entry entry = get(hashCode);\n    while (entry != null) {\n      if (entry.tag == Symbol.CONSTANT_UTF8_TAG\n          && entry.hashCode == hashCode\n          && entry.value.equals(value)) {\n        return entry.index;\n      }\n      entry = entry.next;\n    }\n    constantPool.putByte(Symbol.CONSTANT_UTF8_TAG).putUTF8(value);\n    return put(new Entry(constantPoolCount++, Symbol.CONSTANT_UTF8_TAG, value, hashCode)).index;\n  }\n\n  /**\n   * Adds a new CONSTANT_String_info to the constant pool of this symbol table.\n   *\n   * @param index the constant pool index of the new Symbol.\n   * @param value a string.\n   */\n  private void addConstantUtf8(final int index, final String value) {\n    add(new Entry(index, Symbol.CONSTANT_UTF8_TAG, value, hash(Symbol.CONSTANT_UTF8_TAG, value)));\n  }\n\n  /**\n   * Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table. Does nothing if\n   * the constant pool already contains a similar item.\n   *\n   * @param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\n   *     Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\n   *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\n   *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n   * @param owner the internal name of a class of interface.\n   * @param name a field or method name.\n   * @param descriptor a field or method descriptor.\n   * @param isInterface whether owner is an interface or not.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstantMethodHandle(\n      final int referenceKind,\n      final String owner,\n      final String name,\n      final String descriptor,\n      final boolean isInterface) {\n    final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG;\n    final int data = getConstantMethodHandleSymbolData(referenceKind, isInterface);\n    // Note that we don't need to include isInterface in the hash computation, because it is\n    // redundant with owner (we can't have the same owner with different isInterface values).\n    int hashCode = hash(tag, owner, name, descriptor, data);\n    Entry entry = get(hashCode);\n    while (entry != null) {\n      if (entry.tag == tag\n          && entry.hashCode == hashCode\n          && entry.data == data\n          && entry.owner.equals(owner)\n          && entry.name.equals(name)\n          && entry.value.equals(descriptor)) {\n        return entry;\n      }\n      entry = entry.next;\n    }\n    if (referenceKind <= Opcodes.H_PUTSTATIC) {\n      constantPool.put112(tag, referenceKind, addConstantFieldref(owner, name, descriptor).index);\n    } else {\n      constantPool.put112(\n          tag, referenceKind, addConstantMethodref(owner, name, descriptor, isInterface).index);\n    }\n    return put(new Entry(constantPoolCount++, tag, owner, name, descriptor, data, hashCode));\n  }\n\n  /**\n   * Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table.\n   *\n   * @param index the constant pool index of the new Symbol.\n   * @param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\n   *     Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\n   *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\n   *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n   * @param owner the internal name of a class of interface.\n   * @param name a field or method name.\n   * @param descriptor a field or method descriptor.\n   * @param isInterface whether owner is an interface or not.\n   */\n  private void addConstantMethodHandle(\n      final int index,\n      final int referenceKind,\n      final String owner,\n      final String name,\n      final String descriptor,\n      final boolean isInterface) {\n    final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG;\n    final int data = getConstantMethodHandleSymbolData(referenceKind, isInterface);\n    int hashCode = hash(tag, owner, name, descriptor, data);\n    add(new Entry(index, tag, owner, name, descriptor, data, hashCode));\n  }\n\n  /**\n   * Returns the {@link Symbol#data} field for a CONSTANT_MethodHandle_info Symbol.\n   *\n   * @param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\n   *     Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\n   *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\n   *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n   * @param isInterface whether owner is an interface or not.\n   */\n  private static int getConstantMethodHandleSymbolData(\n      final int referenceKind, final boolean isInterface) {\n    if (referenceKind > Opcodes.H_PUTSTATIC && isInterface) {\n      return referenceKind << 8;\n    }\n    return referenceKind;\n  }\n\n  /**\n   * Adds a CONSTANT_MethodType_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param methodDescriptor a method descriptor.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstantMethodType(final String methodDescriptor) {\n    return addConstantUtf8Reference(Symbol.CONSTANT_METHOD_TYPE_TAG, methodDescriptor);\n  }\n\n  /**\n   * Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table. Also adds the related\n   * bootstrap method to the BootstrapMethods of this symbol table. Does nothing if the constant\n   * pool already contains a similar item.\n   *\n   * @param name a method name.\n   * @param descriptor a field descriptor.\n   * @param bootstrapMethodHandle a bootstrap method handle.\n   * @param bootstrapMethodArguments the bootstrap method arguments.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstantDynamic(\n      final String name,\n      final String descriptor,\n      final Handle bootstrapMethodHandle,\n      final Object... bootstrapMethodArguments) {\n    Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments);\n    return addConstantDynamicOrInvokeDynamicReference(\n        Symbol.CONSTANT_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index);\n  }\n\n  /**\n   * Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table. Also adds the\n   * related bootstrap method to the BootstrapMethods of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param name a method name.\n   * @param descriptor a method descriptor.\n   * @param bootstrapMethodHandle a bootstrap method handle.\n   * @param bootstrapMethodArguments the bootstrap method arguments.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstantInvokeDynamic(\n      final String name,\n      final String descriptor,\n      final Handle bootstrapMethodHandle,\n      final Object... bootstrapMethodArguments) {\n    Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments);\n    return addConstantDynamicOrInvokeDynamicReference(\n        Symbol.CONSTANT_INVOKE_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index);\n  }\n\n  /**\n   * Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol\n   * table. Does nothing if the constant pool already contains a similar item.\n   *\n   * @param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link\n   *     Symbol#CONSTANT_INVOKE_DYNAMIC_TAG}.\n   * @param name a method name.\n   * @param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG) or a method descriptor for\n   *     CONSTANT_INVOKE_DYNAMIC_TAG.\n   * @param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.\n   * @return a new or already existing Symbol with the given value.\n   */\n  private Symbol addConstantDynamicOrInvokeDynamicReference(\n      final int tag, final String name, final String descriptor, final int bootstrapMethodIndex) {\n    int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex);\n    Entry entry = get(hashCode);\n    while (entry != null) {\n      if (entry.tag == tag\n          && entry.hashCode == hashCode\n          && entry.data == bootstrapMethodIndex\n          && entry.name.equals(name)\n          && entry.value.equals(descriptor)) {\n        return entry;\n      }\n      entry = entry.next;\n    }\n    constantPool.put122(tag, bootstrapMethodIndex, addConstantNameAndType(name, descriptor));\n    return put(\n        new Entry(\n            constantPoolCount++, tag, null, name, descriptor, bootstrapMethodIndex, hashCode));\n  }\n\n  /**\n   * Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this\n   * symbol table.\n   *\n   * @param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link\n   *     Symbol#CONSTANT_INVOKE_DYNAMIC_TAG}.\n   * @param index the constant pool index of the new Symbol.\n   * @param name a method name.\n   * @param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG or a method descriptor for\n   *     CONSTANT_INVOKE_DYNAMIC_TAG.\n   * @param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.\n   */\n  private void addConstantDynamicOrInvokeDynamicReference(\n      final int tag,\n      final int index,\n      final String name,\n      final String descriptor,\n      final int bootstrapMethodIndex) {\n    int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex);\n    add(new Entry(index, tag, null, name, descriptor, bootstrapMethodIndex, hashCode));\n  }\n\n  /**\n   * Adds a CONSTANT_Module_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param moduleName a fully qualified name (using dots) of a module.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstantModule(final String moduleName) {\n    return addConstantUtf8Reference(Symbol.CONSTANT_MODULE_TAG, moduleName);\n  }\n\n  /**\n   * Adds a CONSTANT_Package_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param packageName the internal name of a package.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstantPackage(final String packageName) {\n    return addConstantUtf8Reference(Symbol.CONSTANT_PACKAGE_TAG, packageName);\n  }\n\n  /**\n   * Adds a CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,\n   * CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table. Does\n   * nothing if the constant pool already contains a similar item.\n   *\n   * @param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link\n   *     Symbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link\n   *     Symbol#CONSTANT_PACKAGE_TAG}.\n   * @param value an internal class name, an arbitrary string, a method descriptor, a module or a\n   *     package name, depending on tag.\n   * @return a new or already existing Symbol with the given value.\n   */\n  private Symbol addConstantUtf8Reference(final int tag, final String value) {\n    int hashCode = hash(tag, value);\n    Entry entry = get(hashCode);\n    while (entry != null) {\n      if (entry.tag == tag && entry.hashCode == hashCode && entry.value.equals(value)) {\n        return entry;\n      }\n      entry = entry.next;\n    }\n    constantPool.put12(tag, addConstantUtf8(value));\n    return put(new Entry(constantPoolCount++, tag, value, hashCode));\n  }\n\n  /**\n   * Adds a new CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,\n   * CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table.\n   *\n   * @param index the constant pool index of the new Symbol.\n   * @param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link\n   *     Symbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link\n   *     Symbol#CONSTANT_PACKAGE_TAG}.\n   * @param value an internal class name, an arbitrary string, a method descriptor, a module or a\n   *     package name, depending on tag.\n   */\n  private void addConstantUtf8Reference(final int index, final int tag, final String value) {\n    add(new Entry(index, tag, value, hash(tag, value)));\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Bootstrap method entries management.\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Adds a bootstrap method to the BootstrapMethods attribute of this symbol table. Does nothing if\n   * the BootstrapMethods already contains a similar bootstrap method.\n   *\n   * @param bootstrapMethodHandle a bootstrap method handle.\n   * @param bootstrapMethodArguments the bootstrap method arguments.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addBootstrapMethod(\n      final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\n    ByteVector bootstrapMethodsAttribute = bootstrapMethods;\n    if (bootstrapMethodsAttribute == null) {\n      bootstrapMethodsAttribute = bootstrapMethods = new ByteVector();\n    }\n\n    // The bootstrap method arguments can be Constant_Dynamic values, which reference other\n    // bootstrap methods. We must therefore add the bootstrap method arguments to the constant pool\n    // and BootstrapMethods attribute first, so that the BootstrapMethods attribute is not modified\n    // while adding the given bootstrap method to it, in the rest of this method.\n    int numBootstrapArguments = bootstrapMethodArguments.length;\n    int[] bootstrapMethodArgumentIndexes = new int[numBootstrapArguments];\n    for (int i = 0; i < numBootstrapArguments; i++) {\n      bootstrapMethodArgumentIndexes[i] = addConstant(bootstrapMethodArguments[i]).index;\n    }\n\n    // Write the bootstrap method in the BootstrapMethods table. This is necessary to be able to\n    // compare it with existing ones, and will be reverted below if there is already a similar\n    // bootstrap method.\n    int bootstrapMethodOffset = bootstrapMethodsAttribute.length;\n    bootstrapMethodsAttribute.putShort(\n        addConstantMethodHandle(\n                bootstrapMethodHandle.getTag(),\n                bootstrapMethodHandle.getOwner(),\n                bootstrapMethodHandle.getName(),\n                bootstrapMethodHandle.getDesc(),\n                bootstrapMethodHandle.isInterface())\n            .index);\n\n    bootstrapMethodsAttribute.putShort(numBootstrapArguments);\n    for (int i = 0; i < numBootstrapArguments; i++) {\n      bootstrapMethodsAttribute.putShort(bootstrapMethodArgumentIndexes[i]);\n    }\n\n    // Compute the length and the hash code of the bootstrap method.\n    int bootstrapMethodlength = bootstrapMethodsAttribute.length - bootstrapMethodOffset;\n    int hashCode = bootstrapMethodHandle.hashCode();\n    for (Object bootstrapMethodArgument : bootstrapMethodArguments) {\n      hashCode ^= bootstrapMethodArgument.hashCode();\n    }\n    hashCode &= 0x7FFFFFFF;\n\n    // Add the bootstrap method to the symbol table or revert the above changes.\n    return addBootstrapMethod(bootstrapMethodOffset, bootstrapMethodlength, hashCode);\n  }\n\n  /**\n   * Adds a bootstrap method to the BootstrapMethods attribute of this symbol table. Does nothing if\n   * the BootstrapMethods already contains a similar bootstrap method (more precisely, reverts the\n   * content of {@link #bootstrapMethods} to remove the last, duplicate bootstrap method).\n   *\n   * @param offset the offset of the last bootstrap method in {@link #bootstrapMethods}, in bytes.\n   * @param length the length of this bootstrap method in {@link #bootstrapMethods}, in bytes.\n   * @param hashCode the hash code of this bootstrap method.\n   * @return a new or already existing Symbol with the given value.\n   */\n  private Symbol addBootstrapMethod(final int offset, final int length, final int hashCode) {\n    final byte[] bootstrapMethodsData = bootstrapMethods.data;\n    Entry entry = get(hashCode);\n    while (entry != null) {\n      if (entry.tag == Symbol.BOOTSTRAP_METHOD_TAG && entry.hashCode == hashCode) {\n        int otherOffset = (int) entry.data;\n        boolean isSameBootstrapMethod = true;\n        for (int i = 0; i < length; ++i) {\n          if (bootstrapMethodsData[offset + i] != bootstrapMethodsData[otherOffset + i]) {\n            isSameBootstrapMethod = false;\n            break;\n          }\n        }\n        if (isSameBootstrapMethod) {\n          bootstrapMethods.length = offset; // Revert to old position.\n          return entry;\n        }\n      }\n      entry = entry.next;\n    }\n    return put(new Entry(bootstrapMethodCount++, Symbol.BOOTSTRAP_METHOD_TAG, offset, hashCode));\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Type table entries management.\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Returns the type table element whose index is given.\n   *\n   * @param typeIndex a type table index.\n   * @return the type table element whose index is given.\n   */\n  Symbol getType(final int typeIndex) {\n    return typeTable[typeIndex];\n  }\n\n  /**\n   * Returns the label corresponding to the \"forward uninitialized\" type table element whose index\n   * is given.\n   *\n   * @param typeIndex the type table index of a \"forward uninitialized\" type table element.\n   * @return the label corresponding of the NEW instruction which created this \"forward\n   *     uninitialized\" type.\n   */\n  Label getForwardUninitializedLabel(final int typeIndex) {\n    return labelTable[(int) typeTable[typeIndex].data].label;\n  }\n\n  /**\n   * Adds a type in the type table of this symbol table. Does nothing if the type table already\n   * contains a similar type.\n   *\n   * @param value an internal class name.\n   * @return the index of a new or already existing type Symbol with the given value.\n   */\n  int addType(final String value) {\n    int hashCode = hash(Symbol.TYPE_TAG, value);\n    Entry entry = get(hashCode);\n    while (entry != null) {\n      if (entry.tag == Symbol.TYPE_TAG && entry.hashCode == hashCode && entry.value.equals(value)) {\n        return entry.index;\n      }\n      entry = entry.next;\n    }\n    return addTypeInternal(new Entry(typeCount, Symbol.TYPE_TAG, value, hashCode));\n  }\n\n  /**\n   * Adds an uninitialized type in the type table of this symbol table. Does nothing if the type\n   * table already contains a similar type.\n   *\n   * @param value an internal class name.\n   * @param bytecodeOffset the bytecode offset of the NEW instruction that created this\n   *     uninitialized type value.\n   * @return the index of a new or already existing type #@link Symbol} with the given value.\n   */\n  int addUninitializedType(final String value, final int bytecodeOffset) {\n    int hashCode = hash(Symbol.UNINITIALIZED_TYPE_TAG, value, bytecodeOffset);\n    Entry entry = get(hashCode);\n    while (entry != null) {\n      if (entry.tag == Symbol.UNINITIALIZED_TYPE_TAG\n          && entry.hashCode == hashCode\n          && entry.data == bytecodeOffset\n          && entry.value.equals(value)) {\n        return entry.index;\n      }\n      entry = entry.next;\n    }\n    return addTypeInternal(\n        new Entry(typeCount, Symbol.UNINITIALIZED_TYPE_TAG, value, bytecodeOffset, hashCode));\n  }\n\n  /**\n   * Adds a \"forward uninitialized\" type in the type table of this symbol table. Does nothing if the\n   * type table already contains a similar type.\n   *\n   * @param value an internal class name.\n   * @param label the label of the NEW instruction that created this uninitialized type value. If\n   *     the label is resolved, use the {@link #addUninitializedType} method instead.\n   * @return the index of a new or already existing type {@link Symbol} with the given value.\n   */\n  int addForwardUninitializedType(final String value, final Label label) {\n    int labelIndex = getOrAddLabelEntry(label).index;\n    int hashCode = hash(Symbol.FORWARD_UNINITIALIZED_TYPE_TAG, value, labelIndex);\n    Entry entry = get(hashCode);\n    while (entry != null) {\n      if (entry.tag == Symbol.FORWARD_UNINITIALIZED_TYPE_TAG\n          && entry.hashCode == hashCode\n          && entry.data == labelIndex\n          && entry.value.equals(value)) {\n        return entry.index;\n      }\n      entry = entry.next;\n    }\n    return addTypeInternal(\n        new Entry(typeCount, Symbol.FORWARD_UNINITIALIZED_TYPE_TAG, value, labelIndex, hashCode));\n  }\n\n  /**\n   * Adds a merged type in the type table of this symbol table. Does nothing if the type table\n   * already contains a similar type.\n   *\n   * @param typeTableIndex1 a {@link Symbol#TYPE_TAG} type, specified by its index in the type\n   *     table.\n   * @param typeTableIndex2 another {@link Symbol#TYPE_TAG} type, specified by its index in the type\n   *     table.\n   * @return the index of a new or already existing {@link Symbol#TYPE_TAG} type Symbol,\n   *     corresponding to the common super class of the given types.\n   */\n  int addMergedType(final int typeTableIndex1, final int typeTableIndex2) {\n    long data =\n        typeTableIndex1 < typeTableIndex2\n            ? typeTableIndex1 | (((long) typeTableIndex2) << 32)\n            : typeTableIndex2 | (((long) typeTableIndex1) << 32);\n    int hashCode = hash(Symbol.MERGED_TYPE_TAG, typeTableIndex1 + typeTableIndex2);\n    Entry entry = get(hashCode);\n    while (entry != null) {\n      if (entry.tag == Symbol.MERGED_TYPE_TAG && entry.hashCode == hashCode && entry.data == data) {\n        return entry.info;\n      }\n      entry = entry.next;\n    }\n    String type1 = typeTable[typeTableIndex1].value;\n    String type2 = typeTable[typeTableIndex2].value;\n    int commonSuperTypeIndex = addType(classWriter.getCommonSuperClass(type1, type2));\n    put(new Entry(typeCount, Symbol.MERGED_TYPE_TAG, data, hashCode)).info = commonSuperTypeIndex;\n    return commonSuperTypeIndex;\n  }\n\n  /**\n   * Adds the given type Symbol to {@link #typeTable}.\n   *\n   * @param entry a {@link Symbol#TYPE_TAG} or {@link Symbol#UNINITIALIZED_TYPE_TAG} type symbol.\n   *     The index of this Symbol must be equal to the current value of {@link #typeCount}.\n   * @return the index in {@link #typeTable} where the given type was added, which is also equal to\n   *     entry's index by hypothesis.\n   */\n  private int addTypeInternal(final Entry entry) {\n    if (typeTable == null) {\n      typeTable = new Entry[16];\n    }\n    if (typeCount == typeTable.length) {\n      Entry[] newTypeTable = new Entry[2 * typeTable.length];\n      System.arraycopy(typeTable, 0, newTypeTable, 0, typeTable.length);\n      typeTable = newTypeTable;\n    }\n    typeTable[typeCount++] = entry;\n    return put(entry).index;\n  }\n\n  /**\n   * Returns the {@link LabelEntry} corresponding to the given label. Creates a new one if there is\n   * no such entry.\n   *\n   * @param label the {@link Label} of a NEW instruction which created an uninitialized type, in the\n   *     case where this NEW instruction is after the &lt;init&gt; constructor call (in bytecode\n   *     offset order). See {@link Symbol#FORWARD_UNINITIALIZED_TYPE_TAG}.\n   * @return the {@link LabelEntry} corresponding to {@code label}.\n   */\n  private LabelEntry getOrAddLabelEntry(final Label label) {\n    if (labelEntries == null) {\n      labelEntries = new LabelEntry[16];\n      labelTable = new LabelEntry[16];\n    }\n    int hashCode = System.identityHashCode(label);\n    LabelEntry labelEntry = labelEntries[hashCode % labelEntries.length];\n    while (labelEntry != null && labelEntry.label != label) {\n      labelEntry = labelEntry.next;\n    }\n    if (labelEntry != null) {\n      return labelEntry;\n    }\n\n    if (labelCount > (labelEntries.length * 3) / 4) {\n      int currentCapacity = labelEntries.length;\n      int newCapacity = currentCapacity * 2 + 1;\n      LabelEntry[] newLabelEntries = new LabelEntry[newCapacity];\n      for (int i = currentCapacity - 1; i >= 0; --i) {\n        LabelEntry currentEntry = labelEntries[i];\n        while (currentEntry != null) {\n          int newCurrentEntryIndex = System.identityHashCode(currentEntry.label) % newCapacity;\n          LabelEntry nextEntry = currentEntry.next;\n          currentEntry.next = newLabelEntries[newCurrentEntryIndex];\n          newLabelEntries[newCurrentEntryIndex] = currentEntry;\n          currentEntry = nextEntry;\n        }\n      }\n      labelEntries = newLabelEntries;\n    }\n    if (labelCount == labelTable.length) {\n      LabelEntry[] newLabelTable = new LabelEntry[2 * labelTable.length];\n      System.arraycopy(labelTable, 0, newLabelTable, 0, labelTable.length);\n      labelTable = newLabelTable;\n    }\n\n    labelEntry = new LabelEntry(labelCount, label);\n    int index = hashCode % labelEntries.length;\n    labelEntry.next = labelEntries[index];\n    labelEntries[index] = labelEntry;\n    labelTable[labelCount++] = labelEntry;\n    return labelEntry;\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Static helper methods to compute hash codes.\n  // -----------------------------------------------------------------------------------------------\n\n  private static int hash(final int tag, final int value) {\n    return 0x7FFFFFFF & (tag + value);\n  }\n\n  private static int hash(final int tag, final long value) {\n    return 0x7FFFFFFF & (tag + (int) value + (int) (value >>> 32));\n  }\n\n  private static int hash(final int tag, final String value) {\n    return 0x7FFFFFFF & (tag + value.hashCode());\n  }\n\n  private static int hash(final int tag, final String value1, final int value2) {\n    return 0x7FFFFFFF & (tag + value1.hashCode() + value2);\n  }\n\n  private static int hash(final int tag, final String value1, final String value2) {\n    return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode());\n  }\n\n  private static int hash(\n      final int tag, final String value1, final String value2, final int value3) {\n    return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode() * (value3 + 1));\n  }\n\n  private static int hash(\n      final int tag, final String value1, final String value2, final String value3) {\n    return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode() * value3.hashCode());\n  }\n\n  private static int hash(\n      final int tag,\n      final String value1,\n      final String value2,\n      final String value3,\n      final int value4) {\n    return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode() * value3.hashCode() * value4);\n  }\n\n  /**\n   * An entry of a SymbolTable. This concrete and private subclass of {@link Symbol} adds two fields\n   * which are only used inside SymbolTable, to implement hash sets of symbols (in order to avoid\n   * duplicate symbols). See {@link #entries}.\n   *\n   * @author Eric Bruneton\n   */\n  private static final class Entry extends Symbol {\n\n    /** The hash code of this entry. */\n    final int hashCode;\n\n    /**\n     * Another entry (and so on recursively) having the same hash code (modulo the size of {@link\n     * #entries}) as this one.\n     */\n    Entry next;\n\n    Entry(\n        final int index,\n        final int tag,\n        final String owner,\n        final String name,\n        final String value,\n        final long data,\n        final int hashCode) {\n      super(index, tag, owner, name, value, data);\n      this.hashCode = hashCode;\n    }\n\n    Entry(final int index, final int tag, final String value, final int hashCode) {\n      super(index, tag, /* owner= */ null, /* name= */ null, value, /* data= */ 0);\n      this.hashCode = hashCode;\n    }\n\n    Entry(final int index, final int tag, final String value, final long data, final int hashCode) {\n      super(index, tag, /* owner= */ null, /* name= */ null, value, data);\n      this.hashCode = hashCode;\n    }\n\n    Entry(\n        final int index, final int tag, final String name, final String value, final int hashCode) {\n      super(index, tag, /* owner= */ null, name, value, /* data= */ 0);\n      this.hashCode = hashCode;\n    }\n\n    Entry(final int index, final int tag, final long data, final int hashCode) {\n      super(index, tag, /* owner= */ null, /* name= */ null, /* value= */ null, data);\n      this.hashCode = hashCode;\n    }\n  }\n\n  /**\n   * A label corresponding to a \"forward uninitialized\" type in the ASM specific {@link\n   * SymbolTable#typeTable} (see {@link Symbol#FORWARD_UNINITIALIZED_TYPE_TAG}).\n   *\n   * @author Eric Bruneton\n   */\n  private static final class LabelEntry {\n\n    /** The index of this label entry in the {@link SymbolTable#labelTable} array. */\n    final int index;\n\n    /** The value of this label entry. */\n    final Label label;\n\n    /**\n     * Another entry (and so on recursively) having the same hash code (modulo the size of {@link\n     * SymbolTable#labelEntries}}) as this one.\n     */\n    LabelEntry next;\n\n    LabelEntry(final int index, final Label label) {\n      this.index = index;\n      this.label = label;\n    }\n  }\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.asm.Entry",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.Entry#hashCode",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.Entry#hashCode",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.Entry",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.Entry#next",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.Entry#next",
    "headType": "field",
    "relation": "haveType",
    "tail": "Entry",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.Entry",
    "headType": "class",
    "relation": "extend",
    "tail": "Symbol",
    "tailType": "class"
  },
  {
    "head": "org.springframework.asm",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.asm.LabelEntry",
    "tailType": "class"
  },
  {
    "head": "org.springframework.asm.LabelEntry",
    "headType": "class",
    "relation": "provide",
    "tail": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage org.springframework.asm;\n\n/**\n * The constant pool entries, the BootstrapMethods attribute entries and the (ASM specific) type\n * table entries of a class.\n *\n * @author Eric Bruneton\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.4\">JVMS\n *     4.4</a>\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.23\">JVMS\n *     4.7.23</a>\n */\nfinal class SymbolTable {\n\n  /**\n   * The ClassWriter to which this SymbolTable belongs. This is only used to get access to {@link\n   * ClassWriter#getCommonSuperClass} and to serialize custom attributes with {@link\n   * Attribute#write}.\n   */\n  final ClassWriter classWriter;\n\n  /**\n   * The ClassReader from which this SymbolTable was constructed, or {@literal null} if it was\n   * constructed from scratch.\n   */\n  private final ClassReader sourceClassReader;\n\n  /** The major version number of the class to which this symbol table belongs. */\n  private int majorVersion;\n\n  /** The internal name of the class to which this symbol table belongs. */\n  private String className;\n\n  /**\n   * The total number of {@link Entry} instances in {@link #entries}. This includes entries that are\n   * accessible (recursively) via {@link Entry#next}.\n   */\n  private int entryCount;\n\n  /**\n   * A hash set of all the entries in this SymbolTable (this includes the constant pool entries, the\n   * bootstrap method entries and the type table entries). Each {@link Entry} instance is stored at\n   * the array index given by its hash code modulo the array size. If several entries must be stored\n   * at the same array index, they are linked together via their {@link Entry#next} field. The\n   * factory methods of this class make sure that this table does not contain duplicated entries.\n   */\n  private Entry[] entries;\n\n  /**\n   * The number of constant pool items in {@link #constantPool}, plus 1. The first constant pool\n   * item has index 1, and long and double items count for two items.\n   */\n  private int constantPoolCount;\n\n  /**\n   * The content of the ClassFile's constant_pool JVMS structure corresponding to this SymbolTable.\n   * The ClassFile's constant_pool_count field is <i>not</i> included.\n   */\n  private ByteVector constantPool;\n\n  /**\n   * The number of bootstrap methods in {@link #bootstrapMethods}. Corresponds to the\n   * BootstrapMethods_attribute's num_bootstrap_methods field value.\n   */\n  private int bootstrapMethodCount;\n\n  /**\n   * The content of the BootstrapMethods attribute 'bootstrap_methods' array corresponding to this\n   * SymbolTable. Note that the first 6 bytes of the BootstrapMethods_attribute, and its\n   * num_bootstrap_methods field, are <i>not</i> included.\n   */\n  private ByteVector bootstrapMethods;\n\n  /**\n   * The actual number of elements in {@link #typeTable}. These elements are stored from index 0 to\n   * typeCount (excluded). The other array entries are empty.\n   */\n  private int typeCount;\n\n  /**\n   * An ASM specific type table used to temporarily store internal names that will not necessarily\n   * be stored in the constant pool. This type table is used by the control flow and data flow\n   * analysis algorithm used to compute stack map frames from scratch. This array stores {@link\n   * Symbol#TYPE_TAG}, {@link Symbol#UNINITIALIZED_TYPE_TAG},{@link\n   * Symbol#FORWARD_UNINITIALIZED_TYPE_TAG} and {@link Symbol#MERGED_TYPE_TAG} entries. The type\n   * symbol at index {@code i} has its {@link Symbol#index} equal to {@code i} (and vice versa).\n   */\n  private Entry[] typeTable;\n\n  /**\n   * The actual number of {@link LabelEntry} in {@link #labelTable}. These elements are stored from\n   * index 0 to labelCount (excluded). The other array entries are empty. These label entries are\n   * also stored in the {@link #labelEntries} hash set.\n   */\n  private int labelCount;\n\n  /**\n   * The labels corresponding to the \"forward uninitialized\" types in the ASM specific {@link\n   * typeTable} (see {@link Symbol#FORWARD_UNINITIALIZED_TYPE_TAG}). The label entry at index {@code\n   * i} has its {@link LabelEntry#index} equal to {@code i} (and vice versa).\n   */\n  private LabelEntry[] labelTable;\n\n  /**\n   * A hash set of all the {@link LabelEntry} elements in the {@link #labelTable}. Each {@link\n   * LabelEntry} instance is stored at the array index given by its hash code modulo the array size.\n   * If several entries must be stored at the same array index, they are linked together via their\n   * {@link LabelEntry#next} field. The {@link #getOrAddLabelEntry(Label)} method ensures that this\n   * table does not contain duplicated entries.\n   */\n  private LabelEntry[] labelEntries;\n\n  /**\n   * Constructs a new, empty SymbolTable for the given ClassWriter.\n   *\n   * @param classWriter a ClassWriter.\n   */\n  SymbolTable(final ClassWriter classWriter) {\n    this.classWriter = classWriter;\n    this.sourceClassReader = null;\n    this.entries = new Entry[256];\n    this.constantPoolCount = 1;\n    this.constantPool = new ByteVector();\n  }\n\n  /**\n   * Constructs a new SymbolTable for the given ClassWriter, initialized with the constant pool and\n   * bootstrap methods of the given ClassReader.\n   *\n   * @param classWriter a ClassWriter.\n   * @param classReader the ClassReader whose constant pool and bootstrap methods must be copied to\n   *     initialize the SymbolTable.\n   */\n  SymbolTable(final ClassWriter classWriter, final ClassReader classReader) {\n    this.classWriter = classWriter;\n    this.sourceClassReader = classReader;\n\n    // Copy the constant pool binary content.\n    byte[] inputBytes = classReader.classFileBuffer;\n    int constantPoolOffset = classReader.getItem(1) - 1;\n    int constantPoolLength = classReader.header - constantPoolOffset;\n    constantPoolCount = classReader.getItemCount();\n    constantPool = new ByteVector(constantPoolLength);\n    constantPool.putByteArray(inputBytes, constantPoolOffset, constantPoolLength);\n\n    // Add the constant pool items in the symbol table entries. Reserve enough space in 'entries' to\n    // avoid too many hash set collisions (entries is not dynamically resized by the addConstant*\n    // method calls below), and to account for bootstrap method entries.\n    entries = new Entry[constantPoolCount * 2];\n    char[] charBuffer = new char[classReader.getMaxStringLength()];\n    boolean hasBootstrapMethods = false;\n    int itemIndex = 1;\n    while (itemIndex < constantPoolCount) {\n      int itemOffset = classReader.getItem(itemIndex);\n      int itemTag = inputBytes[itemOffset - 1];\n      int nameAndTypeItemOffset;\n      switch (itemTag) {\n        case Symbol.CONSTANT_FIELDREF_TAG:\n        case Symbol.CONSTANT_METHODREF_TAG:\n        case Symbol.CONSTANT_INTERFACE_METHODREF_TAG:\n          nameAndTypeItemOffset =\n              classReader.getItem(classReader.readUnsignedShort(itemOffset + 2));\n          addConstantMemberReference(\n              itemIndex,\n              itemTag,\n              classReader.readClass(itemOffset, charBuffer),\n              classReader.readUTF8(nameAndTypeItemOffset, charBuffer),\n              classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer));\n          break;\n        case Symbol.CONSTANT_INTEGER_TAG:\n        case Symbol.CONSTANT_FLOAT_TAG:\n          addConstantIntegerOrFloat(itemIndex, itemTag, classReader.readInt(itemOffset));\n          break;\n        case Symbol.CONSTANT_NAME_AND_TYPE_TAG:\n          addConstantNameAndType(\n              itemIndex,\n              classReader.readUTF8(itemOffset, charBuffer),\n              classReader.readUTF8(itemOffset + 2, charBuffer));\n          break;\n        case Symbol.CONSTANT_LONG_TAG:\n        case Symbol.CONSTANT_DOUBLE_TAG:\n          addConstantLongOrDouble(itemIndex, itemTag, classReader.readLong(itemOffset));\n          break;\n        case Symbol.CONSTANT_UTF8_TAG:\n          addConstantUtf8(itemIndex, classReader.readUtf(itemIndex, charBuffer));\n          break;\n        case Symbol.CONSTANT_METHOD_HANDLE_TAG:\n          int memberRefItemOffset =\n              classReader.getItem(classReader.readUnsignedShort(itemOffset + 1));\n          nameAndTypeItemOffset =\n              classReader.getItem(classReader.readUnsignedShort(memberRefItemOffset + 2));\n          addConstantMethodHandle(\n              itemIndex,\n              classReader.readByte(itemOffset),\n              classReader.readClass(memberRefItemOffset, charBuffer),\n              classReader.readUTF8(nameAndTypeItemOffset, charBuffer),\n              classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer),\n              classReader.readByte(memberRefItemOffset - 1)\n                  == Symbol.CONSTANT_INTERFACE_METHODREF_TAG);\n          break;\n        case Symbol.CONSTANT_DYNAMIC_TAG:\n        case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:\n          hasBootstrapMethods = true;\n          nameAndTypeItemOffset =\n              classReader.getItem(classReader.readUnsignedShort(itemOffset + 2));\n          addConstantDynamicOrInvokeDynamicReference(\n              itemTag,\n              itemIndex,\n              classReader.readUTF8(nameAndTypeItemOffset, charBuffer),\n              classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer),\n              classReader.readUnsignedShort(itemOffset));\n          break;\n        case Symbol.CONSTANT_STRING_TAG:\n        case Symbol.CONSTANT_CLASS_TAG:\n        case Symbol.CONSTANT_METHOD_TYPE_TAG:\n        case Symbol.CONSTANT_MODULE_TAG:\n        case Symbol.CONSTANT_PACKAGE_TAG:\n          addConstantUtf8Reference(\n              itemIndex, itemTag, classReader.readUTF8(itemOffset, charBuffer));\n          break;\n        default:\n          throw new IllegalArgumentException();\n      }\n      itemIndex +=\n          (itemTag == Symbol.CONSTANT_LONG_TAG || itemTag == Symbol.CONSTANT_DOUBLE_TAG) ? 2 : 1;\n    }\n\n    // Copy the BootstrapMethods, if any.\n    if (hasBootstrapMethods) {\n      copyBootstrapMethods(classReader, charBuffer);\n    }\n  }\n\n  /**\n   * Read the BootstrapMethods 'bootstrap_methods' array binary content and add them as entries of\n   * the SymbolTable.\n   *\n   * @param classReader the ClassReader whose bootstrap methods must be copied to initialize the\n   *     SymbolTable.\n   * @param charBuffer a buffer used to read strings in the constant pool.\n   */\n  private void copyBootstrapMethods(final ClassReader classReader, final char[] charBuffer) {\n    // Find attributOffset of the 'bootstrap_methods' array.\n    byte[] inputBytes = classReader.classFileBuffer;\n    int currentAttributeOffset = classReader.getFirstAttributeOffset();\n    for (int i = classReader.readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {\n      String attributeName = classReader.readUTF8(currentAttributeOffset, charBuffer);\n      if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\n        bootstrapMethodCount = classReader.readUnsignedShort(currentAttributeOffset + 6);\n        break;\n      }\n      currentAttributeOffset += 6 + classReader.readInt(currentAttributeOffset + 2);\n    }\n    if (bootstrapMethodCount > 0) {\n      // Compute the offset and the length of the BootstrapMethods 'bootstrap_methods' array.\n      int bootstrapMethodsOffset = currentAttributeOffset + 8;\n      int bootstrapMethodsLength = classReader.readInt(currentAttributeOffset + 2) - 2;\n      bootstrapMethods = new ByteVector(bootstrapMethodsLength);\n      bootstrapMethods.putByteArray(inputBytes, bootstrapMethodsOffset, bootstrapMethodsLength);\n\n      // Add each bootstrap method in the symbol table entries.\n      int currentOffset = bootstrapMethodsOffset;\n      for (int i = 0; i < bootstrapMethodCount; i++) {\n        int offset = currentOffset - bootstrapMethodsOffset;\n        int bootstrapMethodRef = classReader.readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        int numBootstrapArguments = classReader.readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        int hashCode = classReader.readConst(bootstrapMethodRef, charBuffer).hashCode();\n        while (numBootstrapArguments-- > 0) {\n          int bootstrapArgument = classReader.readUnsignedShort(currentOffset);\n          currentOffset += 2;\n          hashCode ^= classReader.readConst(bootstrapArgument, charBuffer).hashCode();\n        }\n        add(new Entry(i, Symbol.BOOTSTRAP_METHOD_TAG, offset, hashCode & 0x7FFFFFFF));\n      }\n    }\n  }\n\n  /**\n   * Returns the ClassReader from which this SymbolTable was constructed.\n   *\n   * @return the ClassReader from which this SymbolTable was constructed, or {@literal null} if it\n   *     was constructed from scratch.\n   */\n  ClassReader getSource() {\n    return sourceClassReader;\n  }\n\n  /**\n   * Returns the major version of the class to which this symbol table belongs.\n   *\n   * @return the major version of the class to which this symbol table belongs.\n   */\n  int getMajorVersion() {\n    return majorVersion;\n  }\n\n  /**\n   * Returns the internal name of the class to which this symbol table belongs.\n   *\n   * @return the internal name of the class to which this symbol table belongs.\n   */\n  String getClassName() {\n    return className;\n  }\n\n  /**\n   * Sets the major version and the name of the class to which this symbol table belongs. Also adds\n   * the class name to the constant pool.\n   *\n   * @param majorVersion a major ClassFile version number.\n   * @param className an internal class name.\n   * @return the constant pool index of a new or already existing Symbol with the given class name.\n   */\n  int setMajorVersionAndClassName(final int majorVersion, final String className) {\n    this.majorVersion = majorVersion;\n    this.className = className;\n    return addConstantClass(className).index;\n  }\n\n  /**\n   * Returns the number of items in this symbol table's constant_pool array (plus 1).\n   *\n   * @return the number of items in this symbol table's constant_pool array (plus 1).\n   */\n  int getConstantPoolCount() {\n    return constantPoolCount;\n  }\n\n  /**\n   * Returns the length in bytes of this symbol table's constant_pool array.\n   *\n   * @return the length in bytes of this symbol table's constant_pool array.\n   */\n  int getConstantPoolLength() {\n    return constantPool.length;\n  }\n\n  /**\n   * Puts this symbol table's constant_pool array in the given ByteVector, preceded by the\n   * constant_pool_count value.\n   *\n   * @param output where the JVMS ClassFile's constant_pool array must be put.\n   */\n  void putConstantPool(final ByteVector output) {\n    output.putShort(constantPoolCount).putByteArray(constantPool.data, 0, constantPool.length);\n  }\n\n  /**\n   * Returns the size in bytes of this symbol table's BootstrapMethods attribute. Also adds the\n   * attribute name in the constant pool.\n   *\n   * @return the size in bytes of this symbol table's BootstrapMethods attribute.\n   */\n  int computeBootstrapMethodsSize() {\n    if (bootstrapMethods != null) {\n      addConstantUtf8(Constants.BOOTSTRAP_METHODS);\n      return 8 + bootstrapMethods.length;\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n   * Puts this symbol table's BootstrapMethods attribute in the given ByteVector. This includes the\n   * 6 attribute header bytes and the num_bootstrap_methods value.\n   *\n   * @param output where the JVMS BootstrapMethods attribute must be put.\n   */\n  void putBootstrapMethods(final ByteVector output) {\n    if (bootstrapMethods != null) {\n      output\n          .putShort(addConstantUtf8(Constants.BOOTSTRAP_METHODS))\n          .putInt(bootstrapMethods.length + 2)\n          .putShort(bootstrapMethodCount)\n          .putByteArray(bootstrapMethods.data, 0, bootstrapMethods.length);\n    }\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Generic symbol table entries management.\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Returns the list of entries which can potentially have the given hash code.\n   *\n   * @param hashCode a {@link Entry#hashCode} value.\n   * @return the list of entries which can potentially have the given hash code. The list is stored\n   *     via the {@link Entry#next} field.\n   */\n  private Entry get(final int hashCode) {\n    return entries[hashCode % entries.length];\n  }\n\n  /**\n   * Puts the given entry in the {@link #entries} hash set. This method does <i>not</i> check\n   * whether {@link #entries} already contains a similar entry or not. {@link #entries} is resized\n   * if necessary to avoid hash collisions (multiple entries needing to be stored at the same {@link\n   * #entries} array index) as much as possible, with reasonable memory usage.\n   *\n   * @param entry an Entry (which must not already be contained in {@link #entries}).\n   * @return the given entry\n   */\n  private Entry put(final Entry entry) {\n    if (entryCount > (entries.length * 3) / 4) {\n      int currentCapacity = entries.length;\n      int newCapacity = currentCapacity * 2 + 1;\n      Entry[] newEntries = new Entry[newCapacity];\n      for (int i = currentCapacity - 1; i >= 0; --i) {\n        Entry currentEntry = entries[i];\n        while (currentEntry != null) {\n          int newCurrentEntryIndex = currentEntry.hashCode % newCapacity;\n          Entry nextEntry = currentEntry.next;\n          currentEntry.next = newEntries[newCurrentEntryIndex];\n          newEntries[newCurrentEntryIndex] = currentEntry;\n          currentEntry = nextEntry;\n        }\n      }\n      entries = newEntries;\n    }\n    entryCount++;\n    int index = entry.hashCode % entries.length;\n    entry.next = entries[index];\n    return entries[index] = entry;\n  }\n\n  /**\n   * Adds the given entry in the {@link #entries} hash set. This method does <i>not</i> check\n   * whether {@link #entries} already contains a similar entry or not, and does <i>not</i> resize\n   * {@link #entries} if necessary.\n   *\n   * @param entry an Entry (which must not already be contained in {@link #entries}).\n   */\n  private void add(final Entry entry) {\n    entryCount++;\n    int index = entry.hashCode % entries.length;\n    entry.next = entries[index];\n    entries[index] = entry;\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Constant pool entries management.\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Adds a number or string constant to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param value the value of the constant to be added to the constant pool. This parameter must be\n   *     an {@link Integer}, {@link Byte}, {@link Character}, {@link Short}, {@link Boolean}, {@link\n   *     Float}, {@link Long}, {@link Double}, {@link String}, {@link Type} or {@link Handle}.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstant(final Object value) {\n    if (value instanceof Integer) {\n      return addConstantInteger(((Integer) value).intValue());\n    } else if (value instanceof Byte) {\n      return addConstantInteger(((Byte) value).intValue());\n    } else if (value instanceof Character) {\n      return addConstantInteger(((Character) value).charValue());\n    } else if (value instanceof Short) {\n      return addConstantInteger(((Short) value).intValue());\n    } else if (value instanceof Boolean) {\n      return addConstantInteger(((Boolean) value).booleanValue() ? 1 : 0);\n    } else if (value instanceof Float) {\n      return addConstantFloat(((Float) value).floatValue());\n    } else if (value instanceof Long) {\n      return addConstantLong(((Long) value).longValue());\n    } else if (value instanceof Double) {\n      return addConstantDouble(((Double) value).doubleValue());\n    } else if (value instanceof String) {\n      return addConstantString((String) value);\n    } else if (value instanceof Type) {\n      Type type = (Type) value;\n      int typeSort = type.getSort();\n      if (typeSort == Type.OBJECT) {\n        return addConstantClass(type.getInternalName());\n      } else if (typeSort == Type.METHOD) {\n        return addConstantMethodType(type.getDescriptor());\n      } else { // type is a primitive or array type.\n        return addConstantClass(type.getDescriptor());\n      }\n    } else if (value instanceof Handle) {\n      Handle handle = (Handle) value;\n      return addConstantMethodHandle(\n          handle.getTag(),\n          handle.getOwner(),\n          handle.getName(),\n          handle.getDesc(),\n          handle.isInterface());\n    } else if (value instanceof ConstantDynamic) {\n      ConstantDynamic constantDynamic = (ConstantDynamic) value;\n      return addConstantDynamic(\n          constantDynamic.getName(),\n          constantDynamic.getDescriptor(),\n          constantDynamic.getBootstrapMethod(),\n          constantDynamic.getBootstrapMethodArgumentsUnsafe());\n    } else {\n      throw new IllegalArgumentException(\"value \" + value);\n    }\n  }\n\n  /**\n   * Adds a CONSTANT_Class_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param value the internal name of a class.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstantClass(final String value) {\n    return addConstantUtf8Reference(Symbol.CONSTANT_CLASS_TAG, value);\n  }\n\n  /**\n   * Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param owner the internal name of a class.\n   * @param name a field name.\n   * @param descriptor a field descriptor.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstantFieldref(final String owner, final String name, final String descriptor) {\n    return addConstantMemberReference(Symbol.CONSTANT_FIELDREF_TAG, owner, name, descriptor);\n  }\n\n  /**\n   * Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this\n   * symbol table. Does nothing if the constant pool already contains a similar item.\n   *\n   * @param owner the internal name of a class.\n   * @param name a method name.\n   * @param descriptor a method descriptor.\n   * @param isInterface whether owner is an interface or not.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstantMethodref(\n      final String owner, final String name, final String descriptor, final boolean isInterface) {\n    int tag = isInterface ? Symbol.CONSTANT_INTERFACE_METHODREF_TAG : Symbol.CONSTANT_METHODREF_TAG;\n    return addConstantMemberReference(tag, owner, name, descriptor);\n  }\n\n  /**\n   * Adds a CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to\n   * the constant pool of this symbol table. Does nothing if the constant pool already contains a\n   * similar item.\n   *\n   * @param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}\n   *     or {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.\n   * @param owner the internal name of a class.\n   * @param name a field or method name.\n   * @param descriptor a field or method descriptor.\n   * @return a new or already existing Symbol with the given value.\n   */\n  private Entry addConstantMemberReference(\n      final int tag, final String owner, final String name, final String descriptor) {\n    int hashCode = hash(tag, owner, name, descriptor);\n    Entry entry = get(hashCode);\n    while (entry != null) {\n      if (entry.tag == tag\n          && entry.hashCode == hashCode\n          && entry.owner.equals(owner)\n          && entry.name.equals(name)\n          && entry.value.equals(descriptor)) {\n        return entry;\n      }\n      entry = entry.next;\n    }\n    constantPool.put122(\n        tag, addConstantClass(owner).index, addConstantNameAndType(name, descriptor));\n    return put(new Entry(constantPoolCount++, tag, owner, name, descriptor, 0, hashCode));\n  }\n\n  /**\n   * Adds a new CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info\n   * to the constant pool of this symbol table.\n   *\n   * @param index the constant pool index of the new Symbol.\n   * @param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}\n   *     or {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.\n   * @param owner the internal name of a class.\n   * @param name a field or method name.\n   * @param descriptor a field or method descriptor.\n   */\n  private void addConstantMemberReference(\n      final int index,\n      final int tag,\n      final String owner,\n      final String name,\n      final String descriptor) {\n    add(new Entry(index, tag, owner, name, descriptor, 0, hash(tag, owner, name, descriptor)));\n  }\n\n  /**\n   * Adds a CONSTANT_String_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param value a string.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstantString(final String value) {\n    return addConstantUtf8Reference(Symbol.CONSTANT_STRING_TAG, value);\n  }\n\n  /**\n   * Adds a CONSTANT_Integer_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param value an int.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstantInteger(final int value) {\n    return addConstantIntegerOrFloat(Symbol.CONSTANT_INTEGER_TAG, value);\n  }\n\n  /**\n   * Adds a CONSTANT_Float_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param value a float.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstantFloat(final float value) {\n    return addConstantIntegerOrFloat(Symbol.CONSTANT_FLOAT_TAG, Float.floatToRawIntBits(value));\n  }\n\n  /**\n   * Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table.\n   * Does nothing if the constant pool already contains a similar item.\n   *\n   * @param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\n   * @param value an int or float.\n   * @return a constant pool constant with the given tag and primitive values.\n   */\n  private Symbol addConstantIntegerOrFloat(final int tag, final int value) {\n    int hashCode = hash(tag, value);\n    Entry entry = get(hashCode);\n    while (entry != null) {\n      if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) {\n        return entry;\n      }\n      entry = entry.next;\n    }\n    constantPool.putByte(tag).putInt(value);\n    return put(new Entry(constantPoolCount++, tag, value, hashCode));\n  }\n\n  /**\n   * Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol\n   * table.\n   *\n   * @param index the constant pool index of the new Symbol.\n   * @param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\n   * @param value an int or float.\n   */\n  private void addConstantIntegerOrFloat(final int index, final int tag, final int value) {\n    add(new Entry(index, tag, value, hash(tag, value)));\n  }\n\n  /**\n   * Adds a CONSTANT_Long_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param value a long.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstantLong(final long value) {\n    return addConstantLongOrDouble(Symbol.CONSTANT_LONG_TAG, value);\n  }\n\n  /**\n   * Adds a CONSTANT_Double_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param value a double.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstantDouble(final double value) {\n    return addConstantLongOrDouble(Symbol.CONSTANT_DOUBLE_TAG, Double.doubleToRawLongBits(value));\n  }\n\n  /**\n   * Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table.\n   * Does nothing if the constant pool already contains a similar item.\n   *\n   * @param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.\n   * @param value a long or double.\n   * @return a constant pool constant with the given tag and primitive values.\n   */\n  private Symbol addConstantLongOrDouble(final int tag, final long value) {\n    int hashCode = hash(tag, value);\n    Entry entry = get(hashCode);\n    while (entry != null) {\n      if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) {\n        return entry;\n      }\n      entry = entry.next;\n    }\n    int index = constantPoolCount;\n    constantPool.putByte(tag).putLong(value);\n    constantPoolCount += 2;\n    return put(new Entry(index, tag, value, hashCode));\n  }\n\n  /**\n   * Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol\n   * table.\n   *\n   * @param index the constant pool index of the new Symbol.\n   * @param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.\n   * @param value a long or double.\n   */\n  private void addConstantLongOrDouble(final int index, final int tag, final long value) {\n    add(new Entry(index, tag, value, hash(tag, value)));\n  }\n\n  /**\n   * Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param name a field or method name.\n   * @param descriptor a field or method descriptor.\n   * @return a new or already existing Symbol with the given value.\n   */\n  int addConstantNameAndType(final String name, final String descriptor) {\n    final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG;\n    int hashCode = hash(tag, name, descriptor);\n    Entry entry = get(hashCode);\n    while (entry != null) {\n      if (entry.tag == tag\n          && entry.hashCode == hashCode\n          && entry.name.equals(name)\n          && entry.value.equals(descriptor)) {\n        return entry.index;\n      }\n      entry = entry.next;\n    }\n    constantPool.put122(tag, addConstantUtf8(name), addConstantUtf8(descriptor));\n    return put(new Entry(constantPoolCount++, tag, name, descriptor, hashCode)).index;\n  }\n\n  /**\n   * Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table.\n   *\n   * @param index the constant pool index of the new Symbol.\n   * @param name a field or method name.\n   * @param descriptor a field or method descriptor.\n   */\n  private void addConstantNameAndType(final int index, final String name, final String descriptor) {\n    final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG;\n    add(new Entry(index, tag, name, descriptor, hash(tag, name, descriptor)));\n  }\n\n  /**\n   * Adds a CONSTANT_Utf8_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param value a string.\n   * @return a new or already existing Symbol with the given value.\n   */\n  int addConstantUtf8(final String value) {\n    int hashCode = hash(Symbol.CONSTANT_UTF8_TAG, value);\n    Entry entry = get(hashCode);\n    while (entry != null) {\n      if (entry.tag == Symbol.CONSTANT_UTF8_TAG\n          && entry.hashCode == hashCode\n          && entry.value.equals(value)) {\n        return entry.index;\n      }\n      entry = entry.next;\n    }\n    constantPool.putByte(Symbol.CONSTANT_UTF8_TAG).putUTF8(value);\n    return put(new Entry(constantPoolCount++, Symbol.CONSTANT_UTF8_TAG, value, hashCode)).index;\n  }\n\n  /**\n   * Adds a new CONSTANT_String_info to the constant pool of this symbol table.\n   *\n   * @param index the constant pool index of the new Symbol.\n   * @param value a string.\n   */\n  private void addConstantUtf8(final int index, final String value) {\n    add(new Entry(index, Symbol.CONSTANT_UTF8_TAG, value, hash(Symbol.CONSTANT_UTF8_TAG, value)));\n  }\n\n  /**\n   * Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table. Does nothing if\n   * the constant pool already contains a similar item.\n   *\n   * @param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\n   *     Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\n   *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\n   *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n   * @param owner the internal name of a class of interface.\n   * @param name a field or method name.\n   * @param descriptor a field or method descriptor.\n   * @param isInterface whether owner is an interface or not.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstantMethodHandle(\n      final int referenceKind,\n      final String owner,\n      final String name,\n      final String descriptor,\n      final boolean isInterface) {\n    final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG;\n    final int data = getConstantMethodHandleSymbolData(referenceKind, isInterface);\n    // Note that we don't need to include isInterface in the hash computation, because it is\n    // redundant with owner (we can't have the same owner with different isInterface values).\n    int hashCode = hash(tag, owner, name, descriptor, data);\n    Entry entry = get(hashCode);\n    while (entry != null) {\n      if (entry.tag == tag\n          && entry.hashCode == hashCode\n          && entry.data == data\n          && entry.owner.equals(owner)\n          && entry.name.equals(name)\n          && entry.value.equals(descriptor)) {\n        return entry;\n      }\n      entry = entry.next;\n    }\n    if (referenceKind <= Opcodes.H_PUTSTATIC) {\n      constantPool.put112(tag, referenceKind, addConstantFieldref(owner, name, descriptor).index);\n    } else {\n      constantPool.put112(\n          tag, referenceKind, addConstantMethodref(owner, name, descriptor, isInterface).index);\n    }\n    return put(new Entry(constantPoolCount++, tag, owner, name, descriptor, data, hashCode));\n  }\n\n  /**\n   * Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table.\n   *\n   * @param index the constant pool index of the new Symbol.\n   * @param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\n   *     Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\n   *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\n   *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n   * @param owner the internal name of a class of interface.\n   * @param name a field or method name.\n   * @param descriptor a field or method descriptor.\n   * @param isInterface whether owner is an interface or not.\n   */\n  private void addConstantMethodHandle(\n      final int index,\n      final int referenceKind,\n      final String owner,\n      final String name,\n      final String descriptor,\n      final boolean isInterface) {\n    final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG;\n    final int data = getConstantMethodHandleSymbolData(referenceKind, isInterface);\n    int hashCode = hash(tag, owner, name, descriptor, data);\n    add(new Entry(index, tag, owner, name, descriptor, data, hashCode));\n  }\n\n  /**\n   * Returns the {@link Symbol#data} field for a CONSTANT_MethodHandle_info Symbol.\n   *\n   * @param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\n   *     Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\n   *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\n   *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n   * @param isInterface whether owner is an interface or not.\n   */\n  private static int getConstantMethodHandleSymbolData(\n      final int referenceKind, final boolean isInterface) {\n    if (referenceKind > Opcodes.H_PUTSTATIC && isInterface) {\n      return referenceKind << 8;\n    }\n    return referenceKind;\n  }\n\n  /**\n   * Adds a CONSTANT_MethodType_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param methodDescriptor a method descriptor.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstantMethodType(final String methodDescriptor) {\n    return addConstantUtf8Reference(Symbol.CONSTANT_METHOD_TYPE_TAG, methodDescriptor);\n  }\n\n  /**\n   * Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table. Also adds the related\n   * bootstrap method to the BootstrapMethods of this symbol table. Does nothing if the constant\n   * pool already contains a similar item.\n   *\n   * @param name a method name.\n   * @param descriptor a field descriptor.\n   * @param bootstrapMethodHandle a bootstrap method handle.\n   * @param bootstrapMethodArguments the bootstrap method arguments.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstantDynamic(\n      final String name,\n      final String descriptor,\n      final Handle bootstrapMethodHandle,\n      final Object... bootstrapMethodArguments) {\n    Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments);\n    return addConstantDynamicOrInvokeDynamicReference(\n        Symbol.CONSTANT_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index);\n  }\n\n  /**\n   * Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table. Also adds the\n   * related bootstrap method to the BootstrapMethods of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param name a method name.\n   * @param descriptor a method descriptor.\n   * @param bootstrapMethodHandle a bootstrap method handle.\n   * @param bootstrapMethodArguments the bootstrap method arguments.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstantInvokeDynamic(\n      final String name,\n      final String descriptor,\n      final Handle bootstrapMethodHandle,\n      final Object... bootstrapMethodArguments) {\n    Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments);\n    return addConstantDynamicOrInvokeDynamicReference(\n        Symbol.CONSTANT_INVOKE_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index);\n  }\n\n  /**\n   * Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol\n   * table. Does nothing if the constant pool already contains a similar item.\n   *\n   * @param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link\n   *     Symbol#CONSTANT_INVOKE_DYNAMIC_TAG}.\n   * @param name a method name.\n   * @param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG) or a method descriptor for\n   *     CONSTANT_INVOKE_DYNAMIC_TAG.\n   * @param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.\n   * @return a new or already existing Symbol with the given value.\n   */\n  private Symbol addConstantDynamicOrInvokeDynamicReference(\n      final int tag, final String name, final String descriptor, final int bootstrapMethodIndex) {\n    int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex);\n    Entry entry = get(hashCode);\n    while (entry != null) {\n      if (entry.tag == tag\n          && entry.hashCode == hashCode\n          && entry.data == bootstrapMethodIndex\n          && entry.name.equals(name)\n          && entry.value.equals(descriptor)) {\n        return entry;\n      }\n      entry = entry.next;\n    }\n    constantPool.put122(tag, bootstrapMethodIndex, addConstantNameAndType(name, descriptor));\n    return put(\n        new Entry(\n            constantPoolCount++, tag, null, name, descriptor, bootstrapMethodIndex, hashCode));\n  }\n\n  /**\n   * Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this\n   * symbol table.\n   *\n   * @param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link\n   *     Symbol#CONSTANT_INVOKE_DYNAMIC_TAG}.\n   * @param index the constant pool index of the new Symbol.\n   * @param name a method name.\n   * @param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG or a method descriptor for\n   *     CONSTANT_INVOKE_DYNAMIC_TAG.\n   * @param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.\n   */\n  private void addConstantDynamicOrInvokeDynamicReference(\n      final int tag,\n      final int index,\n      final String name,\n      final String descriptor,\n      final int bootstrapMethodIndex) {\n    int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex);\n    add(new Entry(index, tag, null, name, descriptor, bootstrapMethodIndex, hashCode));\n  }\n\n  /**\n   * Adds a CONSTANT_Module_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param moduleName a fully qualified name (using dots) of a module.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstantModule(final String moduleName) {\n    return addConstantUtf8Reference(Symbol.CONSTANT_MODULE_TAG, moduleName);\n  }\n\n  /**\n   * Adds a CONSTANT_Package_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param packageName the internal name of a package.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addConstantPackage(final String packageName) {\n    return addConstantUtf8Reference(Symbol.CONSTANT_PACKAGE_TAG, packageName);\n  }\n\n  /**\n   * Adds a CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,\n   * CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table. Does\n   * nothing if the constant pool already contains a similar item.\n   *\n   * @param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link\n   *     Symbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link\n   *     Symbol#CONSTANT_PACKAGE_TAG}.\n   * @param value an internal class name, an arbitrary string, a method descriptor, a module or a\n   *     package name, depending on tag.\n   * @return a new or already existing Symbol with the given value.\n   */\n  private Symbol addConstantUtf8Reference(final int tag, final String value) {\n    int hashCode = hash(tag, value);\n    Entry entry = get(hashCode);\n    while (entry != null) {\n      if (entry.tag == tag && entry.hashCode == hashCode && entry.value.equals(value)) {\n        return entry;\n      }\n      entry = entry.next;\n    }\n    constantPool.put12(tag, addConstantUtf8(value));\n    return put(new Entry(constantPoolCount++, tag, value, hashCode));\n  }\n\n  /**\n   * Adds a new CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,\n   * CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table.\n   *\n   * @param index the constant pool index of the new Symbol.\n   * @param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link\n   *     Symbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link\n   *     Symbol#CONSTANT_PACKAGE_TAG}.\n   * @param value an internal class name, an arbitrary string, a method descriptor, a module or a\n   *     package name, depending on tag.\n   */\n  private void addConstantUtf8Reference(final int index, final int tag, final String value) {\n    add(new Entry(index, tag, value, hash(tag, value)));\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Bootstrap method entries management.\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Adds a bootstrap method to the BootstrapMethods attribute of this symbol table. Does nothing if\n   * the BootstrapMethods already contains a similar bootstrap method.\n   *\n   * @param bootstrapMethodHandle a bootstrap method handle.\n   * @param bootstrapMethodArguments the bootstrap method arguments.\n   * @return a new or already existing Symbol with the given value.\n   */\n  Symbol addBootstrapMethod(\n      final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\n    ByteVector bootstrapMethodsAttribute = bootstrapMethods;\n    if (bootstrapMethodsAttribute == null) {\n      bootstrapMethodsAttribute = bootstrapMethods = new ByteVector();\n    }\n\n    // The bootstrap method arguments can be Constant_Dynamic values, which reference other\n    // bootstrap methods. We must therefore add the bootstrap method arguments to the constant pool\n    // and BootstrapMethods attribute first, so that the BootstrapMethods attribute is not modified\n    // while adding the given bootstrap method to it, in the rest of this method.\n    int numBootstrapArguments = bootstrapMethodArguments.length;\n    int[] bootstrapMethodArgumentIndexes = new int[numBootstrapArguments];\n    for (int i = 0; i < numBootstrapArguments; i++) {\n      bootstrapMethodArgumentIndexes[i] = addConstant(bootstrapMethodArguments[i]).index;\n    }\n\n    // Write the bootstrap method in the BootstrapMethods table. This is necessary to be able to\n    // compare it with existing ones, and will be reverted below if there is already a similar\n    // bootstrap method.\n    int bootstrapMethodOffset = bootstrapMethodsAttribute.length;\n    bootstrapMethodsAttribute.putShort(\n        addConstantMethodHandle(\n                bootstrapMethodHandle.getTag(),\n                bootstrapMethodHandle.getOwner(),\n                bootstrapMethodHandle.getName(),\n                bootstrapMethodHandle.getDesc(),\n                bootstrapMethodHandle.isInterface())\n            .index);\n\n    bootstrapMethodsAttribute.putShort(numBootstrapArguments);\n    for (int i = 0; i < numBootstrapArguments; i++) {\n      bootstrapMethodsAttribute.putShort(bootstrapMethodArgumentIndexes[i]);\n    }\n\n    // Compute the length and the hash code of the bootstrap method.\n    int bootstrapMethodlength = bootstrapMethodsAttribute.length - bootstrapMethodOffset;\n    int hashCode = bootstrapMethodHandle.hashCode();\n    for (Object bootstrapMethodArgument : bootstrapMethodArguments) {\n      hashCode ^= bootstrapMethodArgument.hashCode();\n    }\n    hashCode &= 0x7FFFFFFF;\n\n    // Add the bootstrap method to the symbol table or revert the above changes.\n    return addBootstrapMethod(bootstrapMethodOffset, bootstrapMethodlength, hashCode);\n  }\n\n  /**\n   * Adds a bootstrap method to the BootstrapMethods attribute of this symbol table. Does nothing if\n   * the BootstrapMethods already contains a similar bootstrap method (more precisely, reverts the\n   * content of {@link #bootstrapMethods} to remove the last, duplicate bootstrap method).\n   *\n   * @param offset the offset of the last bootstrap method in {@link #bootstrapMethods}, in bytes.\n   * @param length the length of this bootstrap method in {@link #bootstrapMethods}, in bytes.\n   * @param hashCode the hash code of this bootstrap method.\n   * @return a new or already existing Symbol with the given value.\n   */\n  private Symbol addBootstrapMethod(final int offset, final int length, final int hashCode) {\n    final byte[] bootstrapMethodsData = bootstrapMethods.data;\n    Entry entry = get(hashCode);\n    while (entry != null) {\n      if (entry.tag == Symbol.BOOTSTRAP_METHOD_TAG && entry.hashCode == hashCode) {\n        int otherOffset = (int) entry.data;\n        boolean isSameBootstrapMethod = true;\n        for (int i = 0; i < length; ++i) {\n          if (bootstrapMethodsData[offset + i] != bootstrapMethodsData[otherOffset + i]) {\n            isSameBootstrapMethod = false;\n            break;\n          }\n        }\n        if (isSameBootstrapMethod) {\n          bootstrapMethods.length = offset; // Revert to old position.\n          return entry;\n        }\n      }\n      entry = entry.next;\n    }\n    return put(new Entry(bootstrapMethodCount++, Symbol.BOOTSTRAP_METHOD_TAG, offset, hashCode));\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Type table entries management.\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Returns the type table element whose index is given.\n   *\n   * @param typeIndex a type table index.\n   * @return the type table element whose index is given.\n   */\n  Symbol getType(final int typeIndex) {\n    return typeTable[typeIndex];\n  }\n\n  /**\n   * Returns the label corresponding to the \"forward uninitialized\" type table element whose index\n   * is given.\n   *\n   * @param typeIndex the type table index of a \"forward uninitialized\" type table element.\n   * @return the label corresponding of the NEW instruction which created this \"forward\n   *     uninitialized\" type.\n   */\n  Label getForwardUninitializedLabel(final int typeIndex) {\n    return labelTable[(int) typeTable[typeIndex].data].label;\n  }\n\n  /**\n   * Adds a type in the type table of this symbol table. Does nothing if the type table already\n   * contains a similar type.\n   *\n   * @param value an internal class name.\n   * @return the index of a new or already existing type Symbol with the given value.\n   */\n  int addType(final String value) {\n    int hashCode = hash(Symbol.TYPE_TAG, value);\n    Entry entry = get(hashCode);\n    while (entry != null) {\n      if (entry.tag == Symbol.TYPE_TAG && entry.hashCode == hashCode && entry.value.equals(value)) {\n        return entry.index;\n      }\n      entry = entry.next;\n    }\n    return addTypeInternal(new Entry(typeCount, Symbol.TYPE_TAG, value, hashCode));\n  }\n\n  /**\n   * Adds an uninitialized type in the type table of this symbol table. Does nothing if the type\n   * table already contains a similar type.\n   *\n   * @param value an internal class name.\n   * @param bytecodeOffset the bytecode offset of the NEW instruction that created this\n   *     uninitialized type value.\n   * @return the index of a new or already existing type #@link Symbol} with the given value.\n   */\n  int addUninitializedType(final String value, final int bytecodeOffset) {\n    int hashCode = hash(Symbol.UNINITIALIZED_TYPE_TAG, value, bytecodeOffset);\n    Entry entry = get(hashCode);\n    while (entry != null) {\n      if (entry.tag == Symbol.UNINITIALIZED_TYPE_TAG\n          && entry.hashCode == hashCode\n          && entry.data == bytecodeOffset\n          && entry.value.equals(value)) {\n        return entry.index;\n      }\n      entry = entry.next;\n    }\n    return addTypeInternal(\n        new Entry(typeCount, Symbol.UNINITIALIZED_TYPE_TAG, value, bytecodeOffset, hashCode));\n  }\n\n  /**\n   * Adds a \"forward uninitialized\" type in the type table of this symbol table. Does nothing if the\n   * type table already contains a similar type.\n   *\n   * @param value an internal class name.\n   * @param label the label of the NEW instruction that created this uninitialized type value. If\n   *     the label is resolved, use the {@link #addUninitializedType} method instead.\n   * @return the index of a new or already existing type {@link Symbol} with the given value.\n   */\n  int addForwardUninitializedType(final String value, final Label label) {\n    int labelIndex = getOrAddLabelEntry(label).index;\n    int hashCode = hash(Symbol.FORWARD_UNINITIALIZED_TYPE_TAG, value, labelIndex);\n    Entry entry = get(hashCode);\n    while (entry != null) {\n      if (entry.tag == Symbol.FORWARD_UNINITIALIZED_TYPE_TAG\n          && entry.hashCode == hashCode\n          && entry.data == labelIndex\n          && entry.value.equals(value)) {\n        return entry.index;\n      }\n      entry = entry.next;\n    }\n    return addTypeInternal(\n        new Entry(typeCount, Symbol.FORWARD_UNINITIALIZED_TYPE_TAG, value, labelIndex, hashCode));\n  }\n\n  /**\n   * Adds a merged type in the type table of this symbol table. Does nothing if the type table\n   * already contains a similar type.\n   *\n   * @param typeTableIndex1 a {@link Symbol#TYPE_TAG} type, specified by its index in the type\n   *     table.\n   * @param typeTableIndex2 another {@link Symbol#TYPE_TAG} type, specified by its index in the type\n   *     table.\n   * @return the index of a new or already existing {@link Symbol#TYPE_TAG} type Symbol,\n   *     corresponding to the common super class of the given types.\n   */\n  int addMergedType(final int typeTableIndex1, final int typeTableIndex2) {\n    long data =\n        typeTableIndex1 < typeTableIndex2\n            ? typeTableIndex1 | (((long) typeTableIndex2) << 32)\n            : typeTableIndex2 | (((long) typeTableIndex1) << 32);\n    int hashCode = hash(Symbol.MERGED_TYPE_TAG, typeTableIndex1 + typeTableIndex2);\n    Entry entry = get(hashCode);\n    while (entry != null) {\n      if (entry.tag == Symbol.MERGED_TYPE_TAG && entry.hashCode == hashCode && entry.data == data) {\n        return entry.info;\n      }\n      entry = entry.next;\n    }\n    String type1 = typeTable[typeTableIndex1].value;\n    String type2 = typeTable[typeTableIndex2].value;\n    int commonSuperTypeIndex = addType(classWriter.getCommonSuperClass(type1, type2));\n    put(new Entry(typeCount, Symbol.MERGED_TYPE_TAG, data, hashCode)).info = commonSuperTypeIndex;\n    return commonSuperTypeIndex;\n  }\n\n  /**\n   * Adds the given type Symbol to {@link #typeTable}.\n   *\n   * @param entry a {@link Symbol#TYPE_TAG} or {@link Symbol#UNINITIALIZED_TYPE_TAG} type symbol.\n   *     The index of this Symbol must be equal to the current value of {@link #typeCount}.\n   * @return the index in {@link #typeTable} where the given type was added, which is also equal to\n   *     entry's index by hypothesis.\n   */\n  private int addTypeInternal(final Entry entry) {\n    if (typeTable == null) {\n      typeTable = new Entry[16];\n    }\n    if (typeCount == typeTable.length) {\n      Entry[] newTypeTable = new Entry[2 * typeTable.length];\n      System.arraycopy(typeTable, 0, newTypeTable, 0, typeTable.length);\n      typeTable = newTypeTable;\n    }\n    typeTable[typeCount++] = entry;\n    return put(entry).index;\n  }\n\n  /**\n   * Returns the {@link LabelEntry} corresponding to the given label. Creates a new one if there is\n   * no such entry.\n   *\n   * @param label the {@link Label} of a NEW instruction which created an uninitialized type, in the\n   *     case where this NEW instruction is after the &lt;init&gt; constructor call (in bytecode\n   *     offset order). See {@link Symbol#FORWARD_UNINITIALIZED_TYPE_TAG}.\n   * @return the {@link LabelEntry} corresponding to {@code label}.\n   */\n  private LabelEntry getOrAddLabelEntry(final Label label) {\n    if (labelEntries == null) {\n      labelEntries = new LabelEntry[16];\n      labelTable = new LabelEntry[16];\n    }\n    int hashCode = System.identityHashCode(label);\n    LabelEntry labelEntry = labelEntries[hashCode % labelEntries.length];\n    while (labelEntry != null && labelEntry.label != label) {\n      labelEntry = labelEntry.next;\n    }\n    if (labelEntry != null) {\n      return labelEntry;\n    }\n\n    if (labelCount > (labelEntries.length * 3) / 4) {\n      int currentCapacity = labelEntries.length;\n      int newCapacity = currentCapacity * 2 + 1;\n      LabelEntry[] newLabelEntries = new LabelEntry[newCapacity];\n      for (int i = currentCapacity - 1; i >= 0; --i) {\n        LabelEntry currentEntry = labelEntries[i];\n        while (currentEntry != null) {\n          int newCurrentEntryIndex = System.identityHashCode(currentEntry.label) % newCapacity;\n          LabelEntry nextEntry = currentEntry.next;\n          currentEntry.next = newLabelEntries[newCurrentEntryIndex];\n          newLabelEntries[newCurrentEntryIndex] = currentEntry;\n          currentEntry = nextEntry;\n        }\n      }\n      labelEntries = newLabelEntries;\n    }\n    if (labelCount == labelTable.length) {\n      LabelEntry[] newLabelTable = new LabelEntry[2 * labelTable.length];\n      System.arraycopy(labelTable, 0, newLabelTable, 0, labelTable.length);\n      labelTable = newLabelTable;\n    }\n\n    labelEntry = new LabelEntry(labelCount, label);\n    int index = hashCode % labelEntries.length;\n    labelEntry.next = labelEntries[index];\n    labelEntries[index] = labelEntry;\n    labelTable[labelCount++] = labelEntry;\n    return labelEntry;\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Static helper methods to compute hash codes.\n  // -----------------------------------------------------------------------------------------------\n\n  private static int hash(final int tag, final int value) {\n    return 0x7FFFFFFF & (tag + value);\n  }\n\n  private static int hash(final int tag, final long value) {\n    return 0x7FFFFFFF & (tag + (int) value + (int) (value >>> 32));\n  }\n\n  private static int hash(final int tag, final String value) {\n    return 0x7FFFFFFF & (tag + value.hashCode());\n  }\n\n  private static int hash(final int tag, final String value1, final int value2) {\n    return 0x7FFFFFFF & (tag + value1.hashCode() + value2);\n  }\n\n  private static int hash(final int tag, final String value1, final String value2) {\n    return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode());\n  }\n\n  private static int hash(\n      final int tag, final String value1, final String value2, final int value3) {\n    return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode() * (value3 + 1));\n  }\n\n  private static int hash(\n      final int tag, final String value1, final String value2, final String value3) {\n    return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode() * value3.hashCode());\n  }\n\n  private static int hash(\n      final int tag,\n      final String value1,\n      final String value2,\n      final String value3,\n      final int value4) {\n    return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode() * value3.hashCode() * value4);\n  }\n\n  /**\n   * An entry of a SymbolTable. This concrete and private subclass of {@link Symbol} adds two fields\n   * which are only used inside SymbolTable, to implement hash sets of symbols (in order to avoid\n   * duplicate symbols). See {@link #entries}.\n   *\n   * @author Eric Bruneton\n   */\n  private static final class Entry extends Symbol {\n\n    /** The hash code of this entry. */\n    final int hashCode;\n\n    /**\n     * Another entry (and so on recursively) having the same hash code (modulo the size of {@link\n     * #entries}) as this one.\n     */\n    Entry next;\n\n    Entry(\n        final int index,\n        final int tag,\n        final String owner,\n        final String name,\n        final String value,\n        final long data,\n        final int hashCode) {\n      super(index, tag, owner, name, value, data);\n      this.hashCode = hashCode;\n    }\n\n    Entry(final int index, final int tag, final String value, final int hashCode) {\n      super(index, tag, /* owner= */ null, /* name= */ null, value, /* data= */ 0);\n      this.hashCode = hashCode;\n    }\n\n    Entry(final int index, final int tag, final String value, final long data, final int hashCode) {\n      super(index, tag, /* owner= */ null, /* name= */ null, value, data);\n      this.hashCode = hashCode;\n    }\n\n    Entry(\n        final int index, final int tag, final String name, final String value, final int hashCode) {\n      super(index, tag, /* owner= */ null, name, value, /* data= */ 0);\n      this.hashCode = hashCode;\n    }\n\n    Entry(final int index, final int tag, final long data, final int hashCode) {\n      super(index, tag, /* owner= */ null, /* name= */ null, /* value= */ null, data);\n      this.hashCode = hashCode;\n    }\n  }\n\n  /**\n   * A label corresponding to a \"forward uninitialized\" type in the ASM specific {@link\n   * SymbolTable#typeTable} (see {@link Symbol#FORWARD_UNINITIALIZED_TYPE_TAG}).\n   *\n   * @author Eric Bruneton\n   */\n  private static final class LabelEntry {\n\n    /** The index of this label entry in the {@link SymbolTable#labelTable} array. */\n    final int index;\n\n    /** The value of this label entry. */\n    final Label label;\n\n    /**\n     * Another entry (and so on recursively) having the same hash code (modulo the size of {@link\n     * SymbolTable#labelEntries}}) as this one.\n     */\n    LabelEntry next;\n\n    LabelEntry(final int index, final Label label) {\n      this.index = index;\n      this.label = label;\n    }\n  }\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.asm.LabelEntry",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.LabelEntry#index",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.LabelEntry#index",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  }
]