[
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.cglib.proxy",
    "tailType": "package"
  },
  {
    "head": "org.springframework.cglib.proxy",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.cglib.proxy.Enhancer",
    "tailType": "class"
  },
  {
    "head": "org.springframework.cglib.proxy.Enhancer",
    "headType": "class",
    "relation": "use",
    "tail": "@SuppressWarnings",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.cglib.proxy.Enhancer",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002,2003,2004 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.cglib.proxy;\n\nimport java.lang.ref.WeakReference;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.security.ProtectionDomain;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.springframework.asm.ClassVisitor;\nimport org.springframework.asm.Label;\nimport org.springframework.asm.Type;\nimport org.springframework.cglib.core.AbstractClassGenerator;\nimport org.springframework.cglib.core.ClassEmitter;\nimport org.springframework.cglib.core.CodeEmitter;\nimport org.springframework.cglib.core.CodeGenerationException;\nimport org.springframework.cglib.core.CollectionUtils;\nimport org.springframework.cglib.core.Constants;\nimport org.springframework.cglib.core.DuplicatesPredicate;\nimport org.springframework.cglib.core.EmitUtils;\nimport org.springframework.cglib.core.Local;\nimport org.springframework.cglib.core.MethodInfo;\nimport org.springframework.cglib.core.MethodInfoTransformer;\nimport org.springframework.cglib.core.MethodWrapper;\nimport org.springframework.cglib.core.ObjectSwitchCallback;\nimport org.springframework.cglib.core.ProcessSwitchCallback;\nimport org.springframework.cglib.core.ReflectUtils;\nimport org.springframework.cglib.core.RejectModifierPredicate;\nimport org.springframework.cglib.core.Signature;\nimport org.springframework.cglib.core.TypeUtils;\nimport org.springframework.cglib.core.VisibilityPredicate;\nimport org.springframework.cglib.core.WeakCacheKey;\n\n/**\n * Generates dynamic subclasses to enable method interception. This\n * class started as a substitute for the standard Dynamic Proxy support\n * included with JDK 1.3, but one that allowed the proxies to extend a\n * concrete base class, in addition to implementing interfaces. The dynamically\n * generated subclasses override the non-final methods of the superclass and\n * have hooks which callback to user-defined interceptor\n * implementations.\n * <p>\n * The original and most general callback type is the {@link MethodInterceptor}, which\n * in AOP terms enables \"around advice\"--that is, you can invoke custom code both before\n * and after the invocation of the \"super\" method. In addition you can modify the\n * arguments before calling the super method, or not call it at all.\n * <p>\n * Although <code>MethodInterceptor</code> is generic enough to meet any\n * interception need, it is often overkill. For simplicity and performance, additional\n * specialized callback types, such as {@link LazyLoader} are also available.\n * Often a single callback will be used per enhanced class, but you can control\n * which callback is used on a per-method basis with a {@link CallbackFilter}.\n * <p>\n * The most common uses of this class are embodied in the static helper methods. For\n * advanced needs, such as customizing the <code>ClassLoader</code> to use, you should create\n * a new instance of <code>Enhancer</code>. Other classes within CGLIB follow a similar pattern.\n * <p>\n * All enhanced objects implement the {@link Factory} interface, unless {@link #setUseFactory} is\n * used to explicitly disable this feature. The <code>Factory</code> interface provides an API\n * to change the callbacks of an existing object, as well as a faster and easier way to create\n * new instances of the same type.\n * <p>\n * For an almost drop-in replacement for\n * <code>java.lang.reflect.Proxy</code>, see the {@link Proxy} class.\n */\n@SuppressWarnings({\"rawtypes\", \"unchecked\"})\npublic class Enhancer extends AbstractClassGenerator {\n\n\tprivate static final CallbackFilter ALL_ZERO = method -> 0;\n\n\tprivate static final Source SOURCE = new Source(Enhancer.class.getName());\n\n\tprivate static final String BOUND_FIELD = \"CGLIB$BOUND\";\n\n\tprivate static final String FACTORY_DATA_FIELD = \"CGLIB$FACTORY_DATA\";\n\n\tprivate static final String THREAD_CALLBACKS_FIELD = \"CGLIB$THREAD_CALLBACKS\";\n\n\tprivate static final String STATIC_CALLBACKS_FIELD = \"CGLIB$STATIC_CALLBACKS\";\n\n\tprivate static final String SET_THREAD_CALLBACKS_NAME = \"CGLIB$SET_THREAD_CALLBACKS\";\n\n\tprivate static final String SET_STATIC_CALLBACKS_NAME = \"CGLIB$SET_STATIC_CALLBACKS\";\n\n\tprivate static final String CONSTRUCTED_FIELD = \"CGLIB$CONSTRUCTED\";\n\n\t/**\n\t * {@link org.springframework.cglib.core.AbstractClassGenerator.ClassLoaderData#generatedClasses} requires to keep cache key\n\t * in a good shape (the keys should be up and running if the proxy class is alive), and one of the cache keys is\n\t * {@link CallbackFilter}. That is why the generated class contains static field that keeps strong reference to\n\t * the {@link #filter}.\n\t * <p>This dance achieves two goals: ensures generated class is reusable and available through generatedClasses\n\t * cache, and it enables to unload classloader and the related {@link CallbackFilter} in case user does not need\n\t * that</p>\n\t */\n\tprivate static final String CALLBACK_FILTER_FIELD = \"CGLIB$CALLBACK_FILTER\";\n\n\tprivate static final Type OBJECT_TYPE =\n\t\t\tTypeUtils.parseType(\"Object\");\n\n\tprivate static final Type FACTORY =\n\t\t\tTypeUtils.parseType(\"org.springframework.cglib.proxy.Factory\");\n\n\tprivate static final Type ILLEGAL_STATE_EXCEPTION =\n\t\t\tTypeUtils.parseType(\"IllegalStateException\");\n\n\tprivate static final Type ILLEGAL_ARGUMENT_EXCEPTION =\n\t\t\tTypeUtils.parseType(\"IllegalArgumentException\");\n\n\tprivate static final Type THREAD_LOCAL =\n\t\t\tTypeUtils.parseType(\"ThreadLocal\");\n\n\tprivate static final Type CALLBACK =\n\t\t\tTypeUtils.parseType(\"org.springframework.cglib.proxy.Callback\");\n\n\tprivate static final Type CALLBACK_ARRAY =\n\t\t\tType.getType(Callback[].class);\n\n\tprivate static final Signature CSTRUCT_NULL =\n\t\t\tTypeUtils.parseConstructor(\"\");\n\n\tprivate static final Signature SET_THREAD_CALLBACKS =\n\t\t\tnew Signature(SET_THREAD_CALLBACKS_NAME, Type.VOID_TYPE, new Type[]{CALLBACK_ARRAY});\n\n\tprivate static final Signature SET_STATIC_CALLBACKS =\n\t\t\tnew Signature(SET_STATIC_CALLBACKS_NAME, Type.VOID_TYPE, new Type[]{CALLBACK_ARRAY});\n\n\tprivate static final Signature NEW_INSTANCE =\n\t\t\tnew Signature(\"newInstance\", Constants.TYPE_OBJECT, new Type[]{CALLBACK_ARRAY});\n\n\tprivate static final Signature MULTIARG_NEW_INSTANCE =\n\t\t\tnew Signature(\"newInstance\", Constants.TYPE_OBJECT, new Type[]{\n\t\t\t\t\tConstants.TYPE_CLASS_ARRAY,\n\t\t\t\t\tConstants.TYPE_OBJECT_ARRAY,\n\t\t\t\t\tCALLBACK_ARRAY,\n\t\t\t});\n\n\tprivate static final Signature SINGLE_NEW_INSTANCE =\n\t\t\tnew Signature(\"newInstance\", Constants.TYPE_OBJECT, new Type[]{CALLBACK});\n\n\tprivate static final Signature SET_CALLBACK =\n\t\t\tnew Signature(\"setCallback\", Type.VOID_TYPE, new Type[]{Type.INT_TYPE, CALLBACK});\n\n\tprivate static final Signature GET_CALLBACK =\n\t\t\tnew Signature(\"getCallback\", CALLBACK, new Type[]{Type.INT_TYPE});\n\n\tprivate static final Signature SET_CALLBACKS =\n\t\t\tnew Signature(\"setCallbacks\", Type.VOID_TYPE, new Type[]{CALLBACK_ARRAY});\n\n\tprivate static final Signature GET_CALLBACKS =\n\t\t\tnew Signature(\"getCallbacks\", CALLBACK_ARRAY, new Type[0]);\n\n\tprivate static final Signature THREAD_LOCAL_GET =\n\t\t\tTypeUtils.parseSignature(\"Object get()\");\n\n\tprivate static final Signature THREAD_LOCAL_SET =\n\t\t\tTypeUtils.parseSignature(\"void set(Object)\");\n\n\tprivate static final Signature BIND_CALLBACKS =\n\t\t\tTypeUtils.parseSignature(\"void CGLIB$BIND_CALLBACKS(Object)\");\n\n\tprivate EnhancerFactoryData currentData;\n\n\tprivate Object currentKey;\n\n\n\t// SPRING PATCH BEGIN\n\tprivate record EnhancerKey(String type,\n\t\t\t\tList<String> interfaces,\n\t\t\t\tWeakCacheKey<CallbackFilter> filter,\n\t\t\t\tList<Type> callbackTypes,\n\t\t\t\tboolean useFactory,\n\t\t\t\tboolean interceptDuringConstruction,\n\t\t\t\tLong serialVersionUID) {\n\t}\n\t// SPRING PATCH END\n\n\n\tprivate Class[] interfaces;\n\n\tprivate CallbackFilter filter;\n\n\tprivate Callback[] callbacks;\n\n\tprivate Type[] callbackTypes;\n\n\tprivate boolean validateCallbackTypes;\n\n\tprivate boolean classOnly;\n\n\tprivate Class superclass;\n\n\tprivate Class[] argumentTypes;\n\n\tprivate Object[] arguments;\n\n\tprivate boolean useFactory = true;\n\n\tprivate Long serialVersionUID;\n\n\tprivate boolean interceptDuringConstruction = true;\n\n\t/**\n\t * Create a new <code>Enhancer</code>. A new <code>Enhancer</code>\n\t * object should be used for each generated object, and should not\n\t * be shared across threads. To create additional instances of a\n\t * generated class, use the <code>Factory</code> interface.\n\t * @see Factory\n\t */\n\tpublic Enhancer() {\n\t\tsuper(SOURCE);\n\t}\n\n\t/**\n\t * Set the class which the generated class will extend. As a convenience,\n\t * if the supplied superclass is actually an interface, <code>setInterfaces</code>\n\t * will be called with the appropriate argument instead.\n\t * A non-interface argument must not be declared as final, and must have an\n\t * accessible constructor.\n\t * @param superclass class to extend or interface to implement\n\t * @see #setInterfaces(Class[])\n\t */\n\tpublic void setSuperclass(Class superclass) {\n\t\tif (superclass != null && superclass.isInterface()) {\n\t\t\tsetInterfaces(new Class[]{superclass});\n\t\t\t// SPRING PATCH BEGIN\n\t\t\tsetContextClass(superclass);\n\t\t\t// SPRING PATCH END\n\t\t}\n\t\telse if (superclass != null && superclass.equals(Object.class)) {\n\t\t\t// affects choice of ClassLoader\n\t\t\tthis.superclass = null;\n\t\t}\n\t\telse {\n\t\t\tthis.superclass = superclass;\n\t\t\t// SPRING PATCH BEGIN\n\t\t\tsetContextClass(superclass);\n\t\t\t// SPRING PATCH END\n\t\t}\n\t}\n\n\t/**\n\t * Set the interfaces to implement. The <code>Factory</code> interface will\n\t * always be implemented regardless of what is specified here.\n\t * @param interfaces array of interfaces to implement, or null\n\t * @see Factory\n\t */\n\tpublic void setInterfaces(Class[] interfaces) {\n\t\tthis.interfaces = interfaces;\n\t}\n\n\t/**\n\t * Set the {@link CallbackFilter} used to map the generated class' methods\n\t * to a particular callback index.\n\t * New object instances will always use the same mapping, but may use different\n\t * actual callback objects.\n\t * @param filter the callback filter to use when generating a new class\n\t * @see #setCallbacks\n\t */\n\tpublic void setCallbackFilter(CallbackFilter filter) {\n\t\tthis.filter = filter;\n\t}\n\n\n\t/**\n\t * Set the single {@link Callback} to use.\n\t * Ignored if you use {@link #createClass}.\n\t * @param callback the callback to use for all methods\n\t * @see #setCallbacks\n\t */\n\tpublic void setCallback(final Callback callback) {\n\t\tsetCallbacks(new Callback[]{callback});\n\t}\n\n\t/**\n\t * Set the array of callbacks to use.\n\t * Ignored if you use {@link #createClass}.\n\t * You must use a {@link CallbackFilter} to specify the index into this\n\t * array for each method in the proxied class.\n\t * @param callbacks the callback array\n\t * @see #setCallbackFilter\n\t * @see #setCallback\n\t */\n\tpublic void setCallbacks(Callback[] callbacks) {\n\t\tif (callbacks != null && callbacks.length == 0) {\n\t\t\tthrow new IllegalArgumentException(\"Array cannot be empty\");\n\t\t}\n\t\tthis.callbacks = callbacks;\n\t}\n\n\t/**\n\t * Set whether the enhanced object instances should implement\n\t * the {@link Factory} interface.\n\t * This was added for tools that need for proxies to be more\n\t * indistinguishable from their targets. Also, in some cases it may\n\t * be necessary to disable the <code>Factory</code> interface to\n\t * prevent code from changing the underlying callbacks.\n\t * @param useFactory whether to implement <code>Factory</code>; default is <code>true</code>\n\t */\n\tpublic void setUseFactory(boolean useFactory) {\n\t\tthis.useFactory = useFactory;\n\t}\n\n\t/**\n\t * Set whether methods called from within the proxy's constructer\n\t * will be intercepted. The default value is true. Unintercepted methods\n\t * will call the method of the proxy's base class, if it exists.\n\t * @param interceptDuringConstruction whether to intercept methods called from the constructor\n\t */\n\tpublic void setInterceptDuringConstruction(boolean interceptDuringConstruction) {\n\t\tthis.interceptDuringConstruction = interceptDuringConstruction;\n\t}\n\n\t/**\n\t * Set the single type of {@link Callback} to use.\n\t * This may be used instead of {@link #setCallback} when calling\n\t * {@link #createClass}, since it may not be possible to have\n\t * an array of actual callback instances.\n\t * @param callbackType the type of callback to use for all methods\n\t * @see #setCallbackTypes\n\t */\n\tpublic void setCallbackType(Class callbackType) {\n\t\tsetCallbackTypes(new Class[]{callbackType});\n\t}\n\n\t/**\n\t * Set the array of callback types to use.\n\t * This may be used instead of {@link #setCallbacks} when calling\n\t * {@link #createClass}, since it may not be possible to have\n\t * an array of actual callback instances.\n\t * You must use a {@link CallbackFilter} to specify the index into this\n\t * array for each method in the proxied class.\n\t * @param callbackTypes the array of callback types\n\t */\n\tpublic void setCallbackTypes(Class[] callbackTypes) {\n\t\tif (callbackTypes != null && callbackTypes.length == 0) {\n\t\t\tthrow new IllegalArgumentException(\"Array cannot be empty\");\n\t\t}\n\t\tthis.callbackTypes = CallbackInfo.determineTypes(callbackTypes);\n\t}\n\n\t/**\n\t * Generate a new class if necessary and uses the specified\n\t * callbacks (if any) to create a new object instance.\n\t * Uses the no-arg constructor of the superclass.\n\t * @return a new instance\n\t */\n\tpublic Object create() {\n\t\tclassOnly = false;\n\t\targumentTypes = null;\n\t\treturn createHelper();\n\t}\n\n\t/**\n\t * Generate a new class if necessary and uses the specified\n\t * callbacks (if any) to create a new object instance.\n\t * Uses the constructor of the superclass matching the <code>argumentTypes</code>\n\t * parameter, with the given arguments.\n\t * @param argumentTypes constructor signature\n\t * @param arguments compatible wrapped arguments to pass to constructor\n\t * @return a new instance\n\t */\n\tpublic Object create(Class[] argumentTypes, Object[] arguments) {\n\t\tclassOnly = false;\n\t\tif (argumentTypes == null || arguments == null || argumentTypes.length != arguments.length) {\n\t\t\tthrow new IllegalArgumentException(\"Arguments must be non-null and of equal length\");\n\t\t}\n\t\tthis.argumentTypes = argumentTypes;\n\t\tthis.arguments = arguments;\n\t\treturn createHelper();\n\t}\n\n\t/**\n\t * Generate a new class if necessary and return it without creating a new instance.\n\t * This ignores any callbacks that have been set.\n\t * To create a new instance you will have to use reflection, and methods\n\t * called during the constructor will not be intercepted. To avoid this problem,\n\t * use the multi-arg <code>create</code> method.\n\t * @see #create(Class[], Object[])\n\t */\n\tpublic Class createClass() {\n\t\tclassOnly = true;\n\t\treturn (Class) createHelper();\n\t}\n\n\t/**\n\t * Insert a static serialVersionUID field into the generated class.\n\t * @param sUID the field value, or null to avoid generating field.\n\t */\n\tpublic void setSerialVersionUID(Long sUID) {\n\t\tserialVersionUID = sUID;\n\t}\n\n\tprivate void preValidate() {\n\t\tif (callbackTypes == null) {\n\t\t\tcallbackTypes = CallbackInfo.determineTypes(callbacks, false);\n\t\t\tvalidateCallbackTypes = true;\n\t\t}\n\t\tif (filter == null) {\n\t\t\tif (callbackTypes.length > 1) {\n\t\t\t\tthrow new IllegalStateException(\"Multiple callback types possible but no filter specified\");\n\t\t\t}\n\t\t\tfilter = ALL_ZERO;\n\t\t}\n\t}\n\n\tprivate void validate() {\n\t\tif (classOnly ^ (callbacks == null)) {\n\t\t\tif (classOnly) {\n\t\t\t\tthrow new IllegalStateException(\"createClass does not accept callbacks\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalStateException(\"Callbacks are required\");\n\t\t\t}\n\t\t}\n\t\tif (classOnly && (callbackTypes == null)) {\n\t\t\tthrow new IllegalStateException(\"Callback types are required\");\n\t\t}\n\t\tif (validateCallbackTypes) {\n\t\t\tcallbackTypes = null;\n\t\t}\n\t\tif (callbacks != null && callbackTypes != null) {\n\t\t\tif (callbacks.length != callbackTypes.length) {\n\t\t\t\tthrow new IllegalStateException(\"Lengths of callback and callback types array must be the same\");\n\t\t\t}\n\t\t\tType[] check = CallbackInfo.determineTypes(callbacks);\n\t\t\tfor (int i = 0; i < check.length; i++) {\n\t\t\t\tif (!check[i].equals(callbackTypes[i])) {\n\t\t\t\t\tthrow new IllegalStateException(\"Callback \" + check[i] + \" is not assignable to \" + callbackTypes[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (callbacks != null) {\n\t\t\tcallbackTypes = CallbackInfo.determineTypes(callbacks);\n\t\t}\n\t\tif (interfaces != null) {\n\t\t\tfor (Class element : interfaces) {\n\t\t\t\tif (element == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Interfaces cannot be null\");\n\t\t\t\t}\n\t\t\t\tif (!element.isInterface()) {\n\t\t\t\t\tthrow new IllegalStateException(element + \" is not an interface\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The idea of the class is to cache relevant java.lang.reflect instances so\n\t * proxy-class can be instantiated faster that when using {@link ReflectUtils#newInstance(Class, Class[], Object[])}\n\t * and {@link Enhancer#setThreadCallbacks(Class, Callback[])}\n\t */\n\tstatic class EnhancerFactoryData {\n\n\t\tpublic final Class generatedClass;\n\n\t\tprivate final Method setThreadCallbacks;\n\n\t\tprivate final Class[] primaryConstructorArgTypes;\n\n\t\tprivate final Constructor primaryConstructor;\n\n\t\tpublic EnhancerFactoryData(Class generatedClass, Class[] primaryConstructorArgTypes, boolean classOnly) {\n\t\t\tthis.generatedClass = generatedClass;\n\t\t\ttry {\n\t\t\t\tsetThreadCallbacks = getCallbacksSetter(generatedClass, SET_THREAD_CALLBACKS_NAME);\n\t\t\t\tif (classOnly) {\n\t\t\t\t\tthis.primaryConstructorArgTypes = null;\n\t\t\t\t\tthis.primaryConstructor = null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.primaryConstructorArgTypes = primaryConstructorArgTypes;\n\t\t\t\t\tthis.primaryConstructor = ReflectUtils.getConstructor(generatedClass, primaryConstructorArgTypes);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException e) {\n\t\t\t\tthrow new CodeGenerationException(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Creates proxy instance for given argument types, and assigns the callbacks.\n\t\t * Ideally, for each proxy class, just one set of argument types should be used,\n\t\t * otherwise it would have to spend time on constructor lookup.\n\t\t * Technically, it is a re-implementation of {@link Enhancer#createUsingReflection(Class)},\n\t\t * with \"cache {@link #setThreadCallbacks} and {@link #primaryConstructor}\"\n\t\t * @param argumentTypes constructor argument types\n\t\t * @param arguments constructor arguments\n\t\t * @param callbacks callbacks to set for the new instance\n\t\t * @return newly created proxy\n\t\t * @see #createUsingReflection(Class)\n\t\t */\n\t\tpublic Object newInstance(Class[] argumentTypes, Object[] arguments, Callback[] callbacks) {\n\t\t\tsetThreadCallbacks(callbacks);\n\t\t\ttry {\n\t\t\t\t// Explicit reference equality is added here just in case Arrays.equals does not have one\n\t\t\t\tif (primaryConstructorArgTypes == argumentTypes ||\n\t\t\t\t\t\tArrays.equals(primaryConstructorArgTypes, argumentTypes)) {\n\t\t\t\t\t// If we have relevant Constructor instance at hand, just call it\n\t\t\t\t\t// This skips \"get constructors\" machinery\n\t\t\t\t\treturn ReflectUtils.newInstance(primaryConstructor, arguments);\n\t\t\t\t}\n\t\t\t\t// Take a slow path if observing unexpected argument types\n\t\t\t\treturn ReflectUtils.newInstance(generatedClass, argumentTypes, arguments);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\t// clear thread callbacks to allow them to be gc'd\n\t\t\t\tsetThreadCallbacks(null);\n\t\t\t}\n\n\t\t}\n\n\t\tprivate void setThreadCallbacks(Callback[] callbacks) {\n\t\t\ttry {\n\t\t\t\tsetThreadCallbacks.invoke(generatedClass, (Object) callbacks);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException e) {\n\t\t\t\tthrow new CodeGenerationException(e);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException e) {\n\t\t\t\tthrow new CodeGenerationException(e.getTargetException());\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate Object createHelper() {\n\t\tpreValidate();\n\t\t// SPRING PATCH BEGIN\n\t\tObject key = new EnhancerKey((superclass != null ? superclass.getName() : null),\n\t\t\t\t(interfaces != null ? Arrays.asList(ReflectUtils.getNames(interfaces)) : null),\n\t\t\t\t(filter == ALL_ZERO ? null : new WeakCacheKey<>(filter)),\n\t\t\t\tArrays.asList(callbackTypes),\n\t\t\t\tuseFactory,\n\t\t\t\tinterceptDuringConstruction,\n\t\t\t\tserialVersionUID);\n\t\t// SPRING PATCH END\n\t\tthis.currentKey = key;\n\t\tObject result = super.create(key);\n\t\treturn result;\n\t}\n\n\t@Override\n\tprotected Class generate(ClassLoaderData data) {\n\t\tvalidate();\n\t\tif (superclass != null) {\n\t\t\tsetNamePrefix(superclass.getName());\n\t\t}\n\t\telse if (interfaces != null) {\n\t\t\tsetNamePrefix(interfaces[ReflectUtils.findPackageProtected(interfaces)].getName());\n\t\t}\n\t\treturn super.generate(data);\n\t}\n\n\t@Override\n\tprotected ClassLoader getDefaultClassLoader() {\n\t\tif (superclass != null) {\n\t\t\treturn superclass.getClassLoader();\n\t\t}\n\t\telse if (interfaces != null) {\n\t\t\treturn interfaces[0].getClassLoader();\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Override\n\tprotected ProtectionDomain getProtectionDomain() {\n\t\tif (superclass != null) {\n\t\t\treturn ReflectUtils.getProtectionDomain(superclass);\n\t\t}\n\t\telse if (interfaces != null) {\n\t\t\treturn ReflectUtils.getProtectionDomain(interfaces[0]);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate Signature rename(Signature sig, int index) {\n\t\treturn new Signature(\"CGLIB$\" + sig.getName() + \"$\" + index,\n\t\t\t\tsig.getDescriptor());\n\t}\n\n\t/**\n\t * Finds all of the methods that will be extended by an\n\t * Enhancer-generated class using the specified superclass and\n\t * interfaces. This can be useful in building a list of Callback\n\t * objects. The methods are added to the end of the given list.  Due\n\t * to the subclassing nature of the classes generated by Enhancer,\n\t * the methods are guaranteed to be non-static, non-final, and\n\t * non-private. Each method signature will only occur once, even if\n\t * it occurs in multiple classes.\n\t * @param superclass the class that will be extended, or null\n\t * @param interfaces the list of interfaces that will be implemented, or null\n\t * @param methods the list into which to copy the applicable methods\n\t */\n\tpublic static void getMethods(Class superclass, Class[] interfaces, List methods) {\n\t\tgetMethods(superclass, interfaces, methods, null, null);\n\t}\n\n\tprivate static void getMethods(Class superclass, Class[] interfaces, List methods, List interfaceMethods, Set forcePublic) {\n\t\tReflectUtils.addAllMethods(superclass, methods);\n\t\tList target = (interfaceMethods != null) ? interfaceMethods : methods;\n\t\tif (interfaces != null) {\n\t\t\tfor (Class element : interfaces) {\n\t\t\t\tif (element != Factory.class) {\n\t\t\t\t\tReflectUtils.addAllMethods(element, target);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (interfaceMethods != null) {\n\t\t\tif (forcePublic != null) {\n\t\t\t\tforcePublic.addAll(MethodWrapper.createSet(interfaceMethods));\n\t\t\t}\n\t\t\tmethods.addAll(interfaceMethods);\n\t\t}\n\t\tCollectionUtils.filter(methods, new RejectModifierPredicate(Constants.ACC_STATIC));\n\t\tCollectionUtils.filter(methods, new VisibilityPredicate(superclass, true));\n\t\tCollectionUtils.filter(methods, new DuplicatesPredicate());\n\t\tCollectionUtils.filter(methods, new RejectModifierPredicate(Constants.ACC_FINAL));\n\t}\n\n\t@Override\n\tpublic void generateClass(ClassVisitor v) throws Exception {\n\t\tClass sc = (superclass == null) ? Object.class : superclass;\n\n\t\tif (TypeUtils.isFinal(sc.getModifiers())) {\n\t\t\tthrow new IllegalArgumentException(\"Cannot subclass final class \" + sc.getName());\n\t\t}\n\t\tList constructors = new ArrayList(Arrays.asList(sc.getDeclaredConstructors()));\n\t\tfilterConstructors(sc, constructors);\n\n\t\t// Order is very important: must add superclass, then\n\t\t// its superclass chain, then each interface and\n\t\t// its superinterfaces.\n\t\tList actualMethods = new ArrayList();\n\t\tList interfaceMethods = new ArrayList();\n\t\tfinal Set forcePublic = new HashSet();\n\t\tgetMethods(sc, interfaces, actualMethods, interfaceMethods, forcePublic);\n\n\t\tList methods = CollectionUtils.transform(actualMethods, value -> {\n\t\t\tMethod method = (Method) value;\n\t\t\tint modifiers = Constants.ACC_FINAL\n\t\t\t\t\t| (method.getModifiers()\n\t\t\t\t\t& ~Constants.ACC_ABSTRACT\n\t\t\t\t\t& ~Constants.ACC_NATIVE\n\t\t\t\t\t& ~Constants.ACC_SYNCHRONIZED);\n\t\t\tif (forcePublic.contains(MethodWrapper.create(method))) {\n\t\t\t\tmodifiers = (modifiers & ~Constants.ACC_PROTECTED) | Constants.ACC_PUBLIC;\n\t\t\t}\n\t\t\treturn ReflectUtils.getMethodInfo(method, modifiers);\n\t\t});\n\n\t\tClassEmitter e = new ClassEmitter(v);\n\t\tif (currentData == null) {\n\t\t\te.begin_class(Constants.V1_8,\n\t\t\t\t\tConstants.ACC_PUBLIC,\n\t\t\t\t\tgetClassName(),\n\t\t\t\t\tType.getType(sc),\n\t\t\t\t\t(useFactory ?\n\t\t\t\t\t\t\tTypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) :\n\t\t\t\t\t\t\tTypeUtils.getTypes(interfaces)),\n\t\t\t\t\tConstants.SOURCE_FILE);\n\t\t}\n\t\telse {\n\t\t\te.begin_class(Constants.V1_8,\n\t\t\t\t\tConstants.ACC_PUBLIC,\n\t\t\t\t\tgetClassName(),\n\t\t\t\t\tnull,\n\t\t\t\t\tnew Type[]{FACTORY},\n\t\t\t\t\tConstants.SOURCE_FILE);\n\t\t}\n\t\tList constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());\n\n\t\te.declare_field(Constants.ACC_PRIVATE, BOUND_FIELD, Type.BOOLEAN_TYPE, null);\n\t\te.declare_field(Constants.ACC_PUBLIC | Constants.ACC_STATIC, FACTORY_DATA_FIELD, OBJECT_TYPE, null);\n\t\tif (!interceptDuringConstruction) {\n\t\t\te.declare_field(Constants.ACC_PRIVATE, CONSTRUCTED_FIELD, Type.BOOLEAN_TYPE, null);\n\t\t}\n\t\te.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, null);\n\t\te.declare_field(Constants.PRIVATE_FINAL_STATIC, STATIC_CALLBACKS_FIELD, CALLBACK_ARRAY, null);\n\t\tif (serialVersionUID != null) {\n\t\t\te.declare_field(Constants.PRIVATE_FINAL_STATIC, Constants.SUID_FIELD_NAME, Type.LONG_TYPE, serialVersionUID);\n\t\t}\n\n\t\tfor (int i = 0; i < callbackTypes.length; i++) {\n\t\t\te.declare_field(Constants.ACC_PRIVATE, getCallbackField(i), callbackTypes[i], null);\n\t\t}\n\t\t// This is declared private to avoid \"public field\" pollution\n\t\te.declare_field(Constants.ACC_PRIVATE | Constants.ACC_STATIC, CALLBACK_FILTER_FIELD, OBJECT_TYPE, null);\n\n\t\tif (currentData == null) {\n\t\t\temitMethods(e, methods, actualMethods);\n\t\t\temitConstructors(e, constructorInfo);\n\t\t}\n\t\telse {\n\t\t\temitDefaultConstructor(e);\n\t\t}\n\t\temitSetThreadCallbacks(e);\n\t\temitSetStaticCallbacks(e);\n\t\temitBindCallbacks(e);\n\n\t\tif (useFactory || currentData != null) {\n\t\t\tint[] keys = getCallbackKeys();\n\t\t\temitNewInstanceCallbacks(e);\n\t\t\temitNewInstanceCallback(e);\n\t\t\temitNewInstanceMultiarg(e, constructorInfo);\n\t\t\temitGetCallback(e, keys);\n\t\t\temitSetCallback(e, keys);\n\t\t\temitGetCallbacks(e);\n\t\t\temitSetCallbacks(e);\n\t\t}\n\n\t\te.end_class();\n\t}\n\n\t/**\n\t * Filter the list of constructors from the superclass. The\n\t * constructors which remain will be included in the generated\n\t * class. The default implementation is to filter out all private\n\t * constructors, but subclasses may extend Enhancer to override this\n\t * behavior.\n\t * @param sc the superclass\n\t * @param constructors the list of all declared constructors from the superclass\n\t * @throws IllegalArgumentException if there are no non-private constructors\n\t */\n\tprotected void filterConstructors(Class sc, List constructors) {\n\t\tCollectionUtils.filter(constructors, new VisibilityPredicate(sc, true));\n\t\tif (constructors.size() == 0) {\n\t\t\tthrow new IllegalArgumentException(\"No visible constructors in \" + sc);\n\t\t}\n\t}\n\n\t/**\n\t * This method should not be called in regular flow.\n\t * Technically speaking {@link #wrapCachedClass(Class)} uses {@link Enhancer.EnhancerFactoryData} as a cache value,\n\t * and the latter enables faster instantiation than plain old reflection lookup and invoke.\n\t * This method is left intact for backward compatibility reasons: just in case it was ever used.\n\t * @param type class to instantiate\n\t * @return newly created proxy instance\n\t * @throws Exception if something goes wrong\n\t */\n\t@Override\n\tprotected Object firstInstance(Class type) throws Exception {\n\t\tif (classOnly) {\n\t\t\treturn type;\n\t\t}\n\t\telse {\n\t\t\treturn createUsingReflection(type);\n\t\t}\n\t}\n\n\t@Override\n\tprotected Object nextInstance(Object instance) {\n\t\tEnhancerFactoryData data = (EnhancerFactoryData) instance;\n\n\t\tif (classOnly) {\n\t\t\treturn data.generatedClass;\n\t\t}\n\n\t\tClass[] argumentTypes = this.argumentTypes;\n\t\tObject[] arguments = this.arguments;\n\t\tif (argumentTypes == null) {\n\t\t\targumentTypes = Constants.EMPTY_CLASS_ARRAY;\n\t\t\targuments = null;\n\t\t}\n\t\treturn data.newInstance(argumentTypes, arguments, callbacks);\n\t}\n\n\t@Override\n\tprotected Object wrapCachedClass(Class klass) {\n\t\tClass[] argumentTypes = this.argumentTypes;\n\t\tif (argumentTypes == null) {\n\t\t\targumentTypes = Constants.EMPTY_CLASS_ARRAY;\n\t\t}\n\t\tEnhancerFactoryData factoryData = new EnhancerFactoryData(klass, argumentTypes, classOnly);\n\t\tField factoryDataField = null;\n\t\ttry {\n\t\t\t// The subsequent dance is performed just once for each class,\n\t\t\t// so it does not matter much how fast it goes\n\t\t\tfactoryDataField = klass.getField(FACTORY_DATA_FIELD);\n\t\t\tfactoryDataField.set(null, factoryData);\n\t\t\tField callbackFilterField = klass.getDeclaredField(CALLBACK_FILTER_FIELD);\n\t\t\tcallbackFilterField.setAccessible(true);\n\t\t\tcallbackFilterField.set(null, this.filter);\n\t\t}\n\t\tcatch (NoSuchFieldException | IllegalAccessException e) {\n\t\t\tthrow new CodeGenerationException(e);\n\t\t}\n\t\treturn new WeakReference<>(factoryData);\n\t}\n\n\t@Override\n\tprotected Object unwrapCachedValue(Object cached) {\n\t\tif (currentKey instanceof EnhancerKey) {\n\t\t\tEnhancerFactoryData data = ((WeakReference<EnhancerFactoryData>) cached).get();\n\t\t\treturn data;\n\t\t}\n\t\treturn super.unwrapCachedValue(cached);\n\t}\n\n\t/**\n\t * Call this method to register the {@link Callback} array to use before\n\t * creating a new instance of the generated class via reflection. If you are using\n\t * an instance of <code>Enhancer</code> or the {@link Factory} interface to create\n\t * new instances, this method is unnecessary. Its primary use is for when you want to\n\t * cache and reuse a generated class yourself, and the generated class does\n\t * <i>not</i> implement the {@link Factory} interface.\n\t * <p>\n\t * Note that this method only registers the callbacks on the current thread.\n\t * If you want to register callbacks for instances created by multiple threads,\n\t * use {@link #registerStaticCallbacks}.\n\t * <p>\n\t * The registered callbacks are overwritten and subsequently cleared\n\t * when calling any of the <code>create</code> methods (such as\n\t * {@link #create}), or any {@link Factory} <code>newInstance</code> method.\n\t * Otherwise they are <i>not</i> cleared, and you should be careful to set them\n\t * back to <code>null</code> after creating new instances via reflection if\n\t * memory leakage is a concern.\n\t * @param generatedClass a class previously created by {@link Enhancer}\n\t * @param callbacks the array of callbacks to use when instances of the generated\n\t * class are created\n\t * @see #setUseFactory\n\t */\n\tpublic static void registerCallbacks(Class generatedClass, Callback[] callbacks) {\n\t\tsetThreadCallbacks(generatedClass, callbacks);\n\t}\n\n\t/**\n\t * Similar to {@link #registerCallbacks}, but suitable for use\n\t * when multiple threads will be creating instances of the generated class.\n\t * The thread-level callbacks will always override the static callbacks.\n\t * Static callbacks are never cleared.\n\t * @param generatedClass a class previously created by {@link Enhancer}\n\t * @param callbacks the array of callbacks to use when instances of the generated\n\t * class are created\n\t */\n\tpublic static void registerStaticCallbacks(Class generatedClass, Callback[] callbacks) {\n\t\tsetCallbacksHelper(generatedClass, callbacks, SET_STATIC_CALLBACKS_NAME);\n\t}\n\n\t/**\n\t * Determine if a class was generated using <code>Enhancer</code>.\n\t * @param type any class\n\t * @return whether the class was generated  using <code>Enhancer</code>\n\t */\n\tpublic static boolean isEnhanced(Class type) {\n\t\ttry {\n\t\t\tgetCallbacksSetter(type, SET_THREAD_CALLBACKS_NAME);\n\t\t\treturn true;\n\t\t}\n\t\tcatch (NoSuchMethodException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate static void setThreadCallbacks(Class type, Callback[] callbacks) {\n\t\tsetCallbacksHelper(type, callbacks, SET_THREAD_CALLBACKS_NAME);\n\t}\n\n\tprivate static void setCallbacksHelper(Class type, Callback[] callbacks, String methodName) {\n\t\t// TODO: optimize\n\t\ttry {\n\t\t\tMethod setter = getCallbacksSetter(type, methodName);\n\t\t\tsetter.invoke(null, new Object[]{callbacks});\n\t\t}\n\t\tcatch (NoSuchMethodException e) {\n\t\t\tthrow new IllegalArgumentException(type + \" is not an enhanced class\");\n\t\t}\n\t\tcatch (IllegalAccessException | InvocationTargetException e) {\n\t\t\tthrow new CodeGenerationException(e);\n\t\t}\n\t}\n\n\tprivate static Method getCallbacksSetter(Class type, String methodName) throws NoSuchMethodException {\n\t\treturn type.getDeclaredMethod(methodName, new Class[]{Callback[].class});\n\t}\n\n\t/**\n\t * Instantiates a proxy instance and assigns callback values.\n\t * Implementation detail: java.lang.reflect instances are not cached, so this method should not\n\t * be used on a hot path.\n\t * This method is used when {@link #setUseCache(boolean)} is set to {@code false}.\n\t * @param type class to instantiate\n\t * @return newly created instance\n\t */\n\tprivate Object createUsingReflection(Class type) {\n\t\tsetThreadCallbacks(type, callbacks);\n\t\ttry {\n\n\t\t\tif (argumentTypes != null) {\n\n\t\t\t\treturn ReflectUtils.newInstance(type, argumentTypes, arguments);\n\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\treturn ReflectUtils.newInstance(type);\n\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\t// clear thread callbacks to allow them to be gc'd\n\t\t\tsetThreadCallbacks(type, null);\n\t\t}\n\t}\n\n\t/**\n\t * Helper method to create an intercepted object.\n\t * For finer control over the generated instance, use a new instance of <code>Enhancer</code>\n\t * instead of this static method.\n\t * @param type class to extend or interface to implement\n\t * @param callback the callback to use for all methods\n\t */\n\tpublic static Object create(Class type, Callback callback) {\n\t\tEnhancer e = new Enhancer();\n\t\te.setSuperclass(type);\n\t\te.setCallback(callback);\n\t\treturn e.create();\n\t}\n\n\t/**\n\t * Helper method to create an intercepted object.\n\t * For finer control over the generated instance, use a new instance of <code>Enhancer</code>\n\t * instead of this static method.\n\t * @param superclass class to extend or interface to implement\n\t * @param interfaces array of interfaces to implement, or null\n\t * @param callback the callback to use for all methods\n\t */\n\tpublic static Object create(Class superclass, Class interfaces[], Callback callback) {\n\t\tEnhancer e = new Enhancer();\n\t\te.setSuperclass(superclass);\n\t\te.setInterfaces(interfaces);\n\t\te.setCallback(callback);\n\t\treturn e.create();\n\t}\n\n\t/**\n\t * Helper method to create an intercepted object.\n\t * For finer control over the generated instance, use a new instance of <code>Enhancer</code>\n\t * instead of this static method.\n\t * @param superclass class to extend or interface to implement\n\t * @param interfaces array of interfaces to implement, or null\n\t * @param filter the callback filter to use when generating a new class\n\t * @param callbacks callback implementations to use for the enhanced object\n\t */\n\tpublic static Object create(Class superclass, Class[] interfaces, CallbackFilter filter, Callback[] callbacks) {\n\t\tEnhancer e = new Enhancer();\n\t\te.setSuperclass(superclass);\n\t\te.setInterfaces(interfaces);\n\t\te.setCallbackFilter(filter);\n\t\te.setCallbacks(callbacks);\n\t\treturn e.create();\n\t}\n\n\tprivate void emitDefaultConstructor(ClassEmitter ce) {\n\t\tConstructor<Object> declaredConstructor;\n\t\ttry {\n\t\t\tdeclaredConstructor = Object.class.getDeclaredConstructor();\n\t\t}\n\t\tcatch (NoSuchMethodException e) {\n\t\t\tthrow new IllegalStateException(\"Object should have default constructor \", e);\n\t\t}\n\t\tMethodInfo constructor = (MethodInfo) MethodInfoTransformer.getInstance().transform(declaredConstructor);\n\t\tCodeEmitter e = EmitUtils.begin_method(ce, constructor, Constants.ACC_PUBLIC);\n\t\te.load_this();\n\t\te.dup();\n\t\tSignature sig = constructor.getSignature();\n\t\te.super_invoke_constructor(sig);\n\t\te.return_value();\n\t\te.end_method();\n\t}\n\n\tprivate void emitConstructors(ClassEmitter ce, List constructors) {\n\t\tboolean seenNull = false;\n\t\tfor (Iterator it = constructors.iterator(); it.hasNext(); ) {\n\t\t\tMethodInfo constructor = (MethodInfo) it.next();\n\t\t\tif (currentData != null && !\"()V\".equals(constructor.getSignature().getDescriptor())) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCodeEmitter e = EmitUtils.begin_method(ce, constructor, Constants.ACC_PUBLIC);\n\t\t\te.load_this();\n\t\t\te.dup();\n\t\t\te.load_args();\n\t\t\tSignature sig = constructor.getSignature();\n\t\t\tseenNull = seenNull || sig.getDescriptor().equals(\"()V\");\n\t\t\te.super_invoke_constructor(sig);\n\t\t\tif (currentData == null) {\n\t\t\t\te.invoke_static_this(BIND_CALLBACKS);\n\t\t\t\tif (!interceptDuringConstruction) {\n\t\t\t\t\te.load_this();\n\t\t\t\t\te.push(1);\n\t\t\t\t\te.putfield(CONSTRUCTED_FIELD);\n\t\t\t\t}\n\t\t\t}\n\t\t\te.return_value();\n\t\t\te.end_method();\n\t\t}\n\t\tif (!classOnly && !seenNull && arguments == null) {\n\t\t\tthrow new IllegalArgumentException(\"Superclass has no null constructors but no arguments were given\");\n\t\t}\n\t}\n\n\tprivate int[] getCallbackKeys() {\n\t\tint[] keys = new int[callbackTypes.length];\n\t\tfor (int i = 0; i < callbackTypes.length; i++) {\n\t\t\tkeys[i] = i;\n\t\t}\n\t\treturn keys;\n\t}\n\n\tprivate void emitGetCallback(ClassEmitter ce, int[] keys) {\n\t\tfinal CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, GET_CALLBACK, null);\n\t\te.load_this();\n\t\te.invoke_static_this(BIND_CALLBACKS);\n\t\te.load_this();\n\t\te.load_arg(0);\n\t\te.process_switch(keys, new ProcessSwitchCallback() {\n\t\t\t@Override\n\t\t\tpublic void processCase(int key, Label end) {\n\t\t\t\te.getfield(getCallbackField(key));\n\t\t\t\te.goTo(end);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void processDefault() {\n\t\t\t\te.pop(); // stack height\n\t\t\t\te.aconst_null();\n\t\t\t}\n\t\t});\n\t\te.return_value();\n\t\te.end_method();\n\t}\n\n\tprivate void emitSetCallback(ClassEmitter ce, int[] keys) {\n\t\tfinal CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, SET_CALLBACK, null);\n\t\te.load_arg(0);\n\t\te.process_switch(keys, new ProcessSwitchCallback() {\n\t\t\t@Override\n\t\t\tpublic void processCase(int key, Label end) {\n\t\t\t\te.load_this();\n\t\t\t\te.load_arg(1);\n\t\t\t\te.checkcast(callbackTypes[key]);\n\t\t\t\te.putfield(getCallbackField(key));\n\t\t\t\te.goTo(end);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void processDefault() {\n\t\t\t\t// TODO: error?\n\t\t\t}\n\t\t});\n\t\te.return_value();\n\t\te.end_method();\n\t}\n\n\tprivate void emitSetCallbacks(ClassEmitter ce) {\n\t\tCodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, SET_CALLBACKS, null);\n\t\te.load_this();\n\t\te.load_arg(0);\n\t\tfor (int i = 0; i < callbackTypes.length; i++) {\n\t\t\te.dup2();\n\t\t\te.aaload(i);\n\t\t\te.checkcast(callbackTypes[i]);\n\t\t\te.putfield(getCallbackField(i));\n\t\t}\n\t\te.return_value();\n\t\te.end_method();\n\t}\n\n\tprivate void emitGetCallbacks(ClassEmitter ce) {\n\t\tCodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, GET_CALLBACKS, null);\n\t\te.load_this();\n\t\te.invoke_static_this(BIND_CALLBACKS);\n\t\te.load_this();\n\t\te.push(callbackTypes.length);\n\t\te.newarray(CALLBACK);\n\t\tfor (int i = 0; i < callbackTypes.length; i++) {\n\t\t\te.dup();\n\t\t\te.push(i);\n\t\t\te.load_this();\n\t\t\te.getfield(getCallbackField(i));\n\t\t\te.aastore();\n\t\t}\n\t\te.return_value();\n\t\te.end_method();\n\t}\n\n\tprivate void emitNewInstanceCallbacks(ClassEmitter ce) {\n\t\tCodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, NEW_INSTANCE, null);\n\t\tType thisType = getThisType(e);\n\t\te.load_arg(0);\n\t\te.invoke_static(thisType, SET_THREAD_CALLBACKS, false);\n\t\temitCommonNewInstance(e);\n\t}\n\n\tprivate Type getThisType(CodeEmitter e) {\n\t\tif (currentData == null) {\n\t\t\treturn e.getClassEmitter().getClassType();\n\t\t}\n\t\telse {\n\t\t\treturn Type.getType(currentData.generatedClass);\n\t\t}\n\t}\n\n\tprivate void emitCommonNewInstance(CodeEmitter e) {\n\t\tType thisType = getThisType(e);\n\t\te.new_instance(thisType);\n\t\te.dup();\n\t\te.invoke_constructor(thisType);\n\t\te.aconst_null();\n\t\te.invoke_static(thisType, SET_THREAD_CALLBACKS, false);\n\t\te.return_value();\n\t\te.end_method();\n\t}\n\n\tprivate void emitNewInstanceCallback(ClassEmitter ce) {\n\t\tCodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, SINGLE_NEW_INSTANCE, null);\n\t\tswitch (callbackTypes.length) {\n\t\t\tcase 0:\n\t\t\t\t// TODO: make sure Callback is null\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t// for now just make a new array; TODO: optimize\n\t\t\t\te.push(1);\n\t\t\t\te.newarray(CALLBACK);\n\t\t\t\te.dup();\n\t\t\t\te.push(0);\n\t\t\t\te.load_arg(0);\n\t\t\t\te.aastore();\n\t\t\t\te.invoke_static(getThisType(e), SET_THREAD_CALLBACKS, false);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\te.throw_exception(ILLEGAL_STATE_EXCEPTION, \"More than one callback object required\");\n\t\t}\n\t\temitCommonNewInstance(e);\n\t}\n\n\tprivate void emitNewInstanceMultiarg(ClassEmitter ce, List constructors) {\n\t\tfinal CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, MULTIARG_NEW_INSTANCE, null);\n\t\tfinal Type thisType = getThisType(e);\n\t\te.load_arg(2);\n\t\te.invoke_static(thisType, SET_THREAD_CALLBACKS, false);\n\t\te.new_instance(thisType);\n\t\te.dup();\n\t\te.load_arg(0);\n\t\tEmitUtils.constructor_switch(e, constructors, new ObjectSwitchCallback() {\n\t\t\t@Override\n\t\t\tpublic void processCase(Object key, Label end) {\n\t\t\t\tMethodInfo constructor = (MethodInfo) key;\n\t\t\t\tType types[] = constructor.getSignature().getArgumentTypes();\n\t\t\t\tfor (int i = 0; i < types.length; i++) {\n\t\t\t\t\te.load_arg(1);\n\t\t\t\t\te.push(i);\n\t\t\t\t\te.aaload();\n\t\t\t\t\te.unbox(types[i]);\n\t\t\t\t}\n\t\t\t\te.invoke_constructor(thisType, constructor.getSignature());\n\t\t\t\te.goTo(end);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void processDefault() {\n\t\t\t\te.throw_exception(ILLEGAL_ARGUMENT_EXCEPTION, \"Constructor not found\");\n\t\t\t}\n\t\t});\n\t\te.aconst_null();\n\t\te.invoke_static(thisType, SET_THREAD_CALLBACKS, false);\n\t\te.return_value();\n\t\te.end_method();\n\t}\n\n\tprivate void emitMethods(final ClassEmitter ce, List methods, List actualMethods) {\n\t\tCallbackGenerator[] generators = CallbackInfo.getGenerators(callbackTypes);\n\n\t\tMap groups = new HashMap();\n\t\tfinal Map indexes = new HashMap();\n\t\tfinal Map originalModifiers = new HashMap();\n\t\tfinal Map positions = CollectionUtils.getIndexMap(methods);\n\t\tfinal Map declToBridge = new HashMap();\n\n\t\tIterator it1 = methods.iterator();\n\t\tIterator it2 = (actualMethods != null) ? actualMethods.iterator() : null;\n\n\t\twhile (it1.hasNext()) {\n\t\t\tMethodInfo method = (MethodInfo) it1.next();\n\t\t\tMethod actualMethod = (it2 != null) ? (Method) it2.next() : null;\n\t\t\tint index = filter.accept(actualMethod);\n\t\t\tif (index >= callbackTypes.length) {\n\t\t\t\tthrow new IllegalArgumentException(\"Callback filter returned an index that is too large: \" + index);\n\t\t\t}\n\t\t\toriginalModifiers.put(method, (actualMethod != null ? actualMethod.getModifiers() : method.getModifiers()));\n\t\t\tindexes.put(method, index);\n\t\t\tList group = (List) groups.get(generators[index]);\n\t\t\tif (group == null) {\n\t\t\t\tgroups.put(generators[index], group = new ArrayList(methods.size()));\n\t\t\t}\n\t\t\tgroup.add(method);\n\n\t\t\t// Optimization: build up a map of Class -> bridge methods in class\n\t\t\t// so that we can look up all the bridge methods in one pass for a class.\n\t\t\tif (TypeUtils.isBridge(actualMethod.getModifiers())) {\n\t\t\t\tSet bridges = (Set) declToBridge.get(actualMethod.getDeclaringClass());\n\t\t\t\tif (bridges == null) {\n\t\t\t\t\tbridges = new HashSet();\n\t\t\t\t\tdeclToBridge.put(actualMethod.getDeclaringClass(), bridges);\n\t\t\t\t}\n\t\t\t\tbridges.add(method.getSignature());\n\t\t\t}\n\t\t}\n\n\t\tfinal Map bridgeToTarget = new BridgeMethodResolver(declToBridge, getClassLoader()).resolveAll();\n\n\t\tSet seenGen = new HashSet();\n\t\tCodeEmitter se = ce.getStaticHook();\n\t\tse.new_instance(THREAD_LOCAL);\n\t\tse.dup();\n\t\tse.invoke_constructor(THREAD_LOCAL, CSTRUCT_NULL);\n\t\tse.putfield(THREAD_CALLBACKS_FIELD);\n\n\t\tCallbackGenerator.Context context = new CallbackGenerator.Context() {\n\t\t\t@Override\n\t\t\tpublic ClassLoader getClassLoader() {\n\t\t\t\treturn Enhancer.this.getClassLoader();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int getOriginalModifiers(MethodInfo method) {\n\t\t\t\treturn ((Integer) originalModifiers.get(method)).intValue();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int getIndex(MethodInfo method) {\n\t\t\t\treturn ((Integer) indexes.get(method)).intValue();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void emitCallback(CodeEmitter e, int index) {\n\t\t\t\temitCurrentCallback(e, index);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Signature getImplSignature(MethodInfo method) {\n\t\t\t\treturn rename(method.getSignature(), ((Integer) positions.get(method)).intValue());\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void emitLoadArgsAndInvoke(CodeEmitter e, MethodInfo method) {\n\t\t\t\t// If this is a bridge and we know the target was called from invokespecial,\n\t\t\t\t// then we need to invoke_virtual w/ the bridge target instead of doing\n\t\t\t\t// a super, because super may itself be using super, which would bypass\n\t\t\t\t// any proxies on the target.\n\t\t\t\tSignature bridgeTarget = (Signature) bridgeToTarget.get(method.getSignature());\n\t\t\t\tif (bridgeTarget != null) {\n\t\t\t\t\t// checkcast each argument against the target's argument types\n\t\t\t\t\tfor (int i = 0; i < bridgeTarget.getArgumentTypes().length; i++) {\n\t\t\t\t\t\te.load_arg(i);\n\t\t\t\t\t\tType target = bridgeTarget.getArgumentTypes()[i];\n\t\t\t\t\t\tif (!target.equals(method.getSignature().getArgumentTypes()[i])) {\n\t\t\t\t\t\t\te.checkcast(target);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\te.invoke_virtual_this(bridgeTarget);\n\n\t\t\t\t\tType retType = method.getSignature().getReturnType();\n\t\t\t\t\t// Not necessary to cast if the target & bridge have\n\t\t\t\t\t// the same return type.\n\t\t\t\t\t// (This conveniently includes void and primitive types,\n\t\t\t\t\t// which would fail if casted.  It's not possible to\n\t\t\t\t\t// covariant from boxed to unbox (or vice versa), so no having\n\t\t\t\t\t// to box/unbox for bridges).\n\t\t\t\t\t// TODO: It also isn't necessary to checkcast if the return is\n\t\t\t\t\t// assignable from the target.  (This would happen if a subclass\n\t\t\t\t\t// used covariant returns to narrow the return type within a bridge\n\t\t\t\t\t// method.)\n\t\t\t\t\tif (!retType.equals(bridgeTarget.getReturnType())) {\n\t\t\t\t\t\te.checkcast(retType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\te.load_args();\n\t\t\t\t\te.super_invoke(method.getSignature());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CodeEmitter beginMethod(ClassEmitter ce, MethodInfo method) {\n\t\t\t\tCodeEmitter e = EmitUtils.begin_method(ce, method);\n\t\t\t\tif (!interceptDuringConstruction &&\n\t\t\t\t\t\t!TypeUtils.isAbstract(method.getModifiers())) {\n\t\t\t\t\tLabel constructed = e.make_label();\n\t\t\t\t\te.load_this();\n\t\t\t\t\te.getfield(CONSTRUCTED_FIELD);\n\t\t\t\t\te.if_jump(CodeEmitter.NE, constructed);\n\t\t\t\t\te.load_this();\n\t\t\t\t\te.load_args();\n\t\t\t\t\te.super_invoke();\n\t\t\t\t\te.return_value();\n\t\t\t\t\te.mark(constructed);\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t}\n\t\t};\n\t\tfor (int i = 0; i < callbackTypes.length; i++) {\n\t\t\tCallbackGenerator gen = generators[i];\n\t\t\tif (!seenGen.contains(gen)) {\n\t\t\t\tseenGen.add(gen);\n\t\t\t\tfinal List fmethods = (List) groups.get(gen);\n\t\t\t\tif (fmethods != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tgen.generate(ce, context, fmethods);\n\t\t\t\t\t\tgen.generateStatic(se, context, fmethods);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (RuntimeException x) {\n\t\t\t\t\t\tthrow x;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception x) {\n\t\t\t\t\t\tthrow new CodeGenerationException(x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tse.return_value();\n\t\tse.end_method();\n\t}\n\n\tprivate void emitSetThreadCallbacks(ClassEmitter ce) {\n\t\tCodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC | Constants.ACC_STATIC,\n\t\t\t\tSET_THREAD_CALLBACKS,\n\t\t\t\tnull);\n\t\te.getfield(THREAD_CALLBACKS_FIELD);\n\t\te.load_arg(0);\n\t\te.invoke_virtual(THREAD_LOCAL, THREAD_LOCAL_SET);\n\t\te.return_value();\n\t\te.end_method();\n\t}\n\n\tprivate void emitSetStaticCallbacks(ClassEmitter ce) {\n\t\tCodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC | Constants.ACC_STATIC,\n\t\t\t\tSET_STATIC_CALLBACKS,\n\t\t\t\tnull);\n\t\te.load_arg(0);\n\t\te.putfield(STATIC_CALLBACKS_FIELD);\n\t\te.return_value();\n\t\te.end_method();\n\t}\n\n\tprivate void emitCurrentCallback(CodeEmitter e, int index) {\n\t\te.load_this();\n\t\te.getfield(getCallbackField(index));\n\t\te.dup();\n\t\tLabel end = e.make_label();\n\t\te.ifnonnull(end);\n\t\te.pop(); // stack height\n\t\te.load_this();\n\t\te.invoke_static_this(BIND_CALLBACKS);\n\t\te.load_this();\n\t\te.getfield(getCallbackField(index));\n\t\te.mark(end);\n\t}\n\n\tprivate void emitBindCallbacks(ClassEmitter ce) {\n\t\tCodeEmitter e = ce.begin_method(Constants.PRIVATE_FINAL_STATIC,\n\t\t\t\tBIND_CALLBACKS,\n\t\t\t\tnull);\n\t\tLocal me = e.make_local();\n\t\te.load_arg(0);\n\t\te.checkcast_this();\n\t\te.store_local(me);\n\n\t\tLabel end = e.make_label();\n\t\te.load_local(me);\n\t\te.getfield(BOUND_FIELD);\n\t\te.if_jump(CodeEmitter.NE, end);\n\t\te.load_local(me);\n\t\te.push(1);\n\t\te.putfield(BOUND_FIELD);\n\n\t\te.getfield(THREAD_CALLBACKS_FIELD);\n\t\te.invoke_virtual(THREAD_LOCAL, THREAD_LOCAL_GET);\n\t\te.dup();\n\t\tLabel found_callback = e.make_label();\n\t\te.ifnonnull(found_callback);\n\t\te.pop();\n\n\t\te.getfield(STATIC_CALLBACKS_FIELD);\n\t\te.dup();\n\t\te.ifnonnull(found_callback);\n\t\te.pop();\n\t\te.goTo(end);\n\n\t\te.mark(found_callback);\n\t\te.checkcast(CALLBACK_ARRAY);\n\t\te.load_local(me);\n\t\te.swap();\n\t\tfor (int i = callbackTypes.length - 1; i >= 0; i--) {\n\t\t\tif (i != 0) {\n\t\t\t\te.dup2();\n\t\t\t}\n\t\t\te.aaload(i);\n\t\t\te.checkcast(callbackTypes[i]);\n\t\t\te.putfield(getCallbackField(i));\n\t\t}\n\n\t\te.mark(end);\n\t\te.return_value();\n\t\te.end_method();\n\t}\n\n\tprivate static String getCallbackField(int index) {\n\t\treturn \"CGLIB$CALLBACK_\" + index;\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.cglib.proxy.Enhancer",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.proxy.Enhancer#ALL_ZERO",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.proxy.Enhancer#ALL_ZERO",
    "headType": "field",
    "relation": "haveType",
    "tail": "CallbackFilter",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.proxy.Enhancer",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.proxy.Enhancer#SOURCE",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.proxy.Enhancer#SOURCE",
    "headType": "field",
    "relation": "haveType",
    "tail": "Source",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.proxy.Enhancer",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.proxy.Enhancer#BOUND_FIELD",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.proxy.Enhancer#BOUND_FIELD",
    "headType": "field",
    "relation": "haveType",
    "tail": "String",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.proxy.Enhancer",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.proxy.Enhancer#FACTORY_DATA_FIELD",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.proxy.Enhancer#FACTORY_DATA_FIELD",
    "headType": "field",
    "relation": "haveType",
    "tail": "String",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.proxy.Enhancer",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.proxy.Enhancer#THREAD_CALLBACKS_FIELD",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.proxy.Enhancer#THREAD_CALLBACKS_FIELD",
    "headType": "field",
    "relation": "haveType",
    "tail": "String",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.proxy.Enhancer",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.proxy.Enhancer#STATIC_CALLBACKS_FIELD",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.proxy.Enhancer#STATIC_CALLBACKS_FIELD",
    "headType": "field",
    "relation": "haveType",
    "tail": "String",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.proxy.Enhancer",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.proxy.Enhancer#SET_THREAD_CALLBACKS_NAME",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.proxy.Enhancer#SET_THREAD_CALLBACKS_NAME",
    "headType": "field",
    "relation": "haveType",
    "tail": "String",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.proxy.Enhancer",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.proxy.Enhancer#SET_STATIC_CALLBACKS_NAME",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.proxy.Enhancer#SET_STATIC_CALLBACKS_NAME",
    "headType": "field",
    "relation": "haveType",
    "tail": "String",
    "tailType": "type"
  }
]