[
  {
    "head": "org.springframework.asm.ModuleVisitor#visitPackage(String)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Visit a package of the current module.\r\n *\r\n * @param packaze the internal name of a package.\r\n */\r\npublic void visitPackage(final String packaze) {\r\n    if (mv != null) {\r\n        mv.visitPackage(packaze);\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ModuleVisitor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ModuleVisitor#visitPackage(String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ModuleVisitor#visitRequire(String,int,String)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Visits a dependence of the current module.\r\n *\r\n * @param module the fully qualified name (using dots) of the dependence.\r\n * @param access the access flag of the dependence among {@code ACC_TRANSITIVE}, {@code\r\n *     ACC_STATIC_PHASE}, {@code ACC_SYNTHETIC} and {@code ACC_MANDATED}.\r\n * @param version the module version at compile time, or {@literal null}.\r\n */\r\npublic void visitRequire(final String module, final int access, final String version) {\r\n    if (mv != null) {\r\n        mv.visitRequire(module, access, version);\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ModuleVisitor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ModuleVisitor#visitRequire(String,int,String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ModuleVisitor#visitExport(String,int,String)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Visit an exported package of the current module.\r\n *\r\n * @param packaze the internal name of the exported package.\r\n * @param access the access flag of the exported package, valid values are among {@code\r\n *     ACC_SYNTHETIC} and {@code ACC_MANDATED}.\r\n * @param modules the fully qualified names (using dots) of the modules that can access the public\r\n *     classes of the exported package, or {@literal null}.\r\n */\r\npublic void visitExport(final String packaze, final int access, final String... modules) {\r\n    if (mv != null) {\r\n        mv.visitExport(packaze, access, modules);\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ModuleVisitor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ModuleVisitor#visitExport(String,int,String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ModuleVisitor#visitOpen(String,int,String)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Visit an open package of the current module.\r\n *\r\n * @param packaze the internal name of the opened package.\r\n * @param access the access flag of the opened package, valid values are among {@code\r\n *     ACC_SYNTHETIC} and {@code ACC_MANDATED}.\r\n * @param modules the fully qualified names (using dots) of the modules that can use deep\r\n *     reflection to the classes of the open package, or {@literal null}.\r\n */\r\npublic void visitOpen(final String packaze, final int access, final String... modules) {\r\n    if (mv != null) {\r\n        mv.visitOpen(packaze, access, modules);\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ModuleVisitor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ModuleVisitor#visitOpen(String,int,String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ModuleVisitor#visitUse(String)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Visit a service used by the current module. The name must be the internal name of an interface\r\n * or a class.\r\n *\r\n * @param service the internal name of the service.\r\n */\r\npublic void visitUse(final String service) {\r\n    if (mv != null) {\r\n        mv.visitUse(service);\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ModuleVisitor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ModuleVisitor#visitUse(String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ModuleVisitor#visitProvide(String,String)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Visit an implementation of a service.\r\n *\r\n * @param service the internal name of the service.\r\n * @param providers the internal names of the implementations of the service (there is at least\r\n *     one provider).\r\n */\r\npublic void visitProvide(final String service, final String... providers) {\r\n    if (mv != null) {\r\n        mv.visitProvide(service, providers);\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ModuleVisitor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ModuleVisitor#visitProvide(String,String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ModuleVisitor#visitEnd()",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Visits the end of the module. This method, which is the last one to be called, is used to\r\n * inform the visitor that everything have been visited.\r\n */\r\npublic void visitEnd() {\r\n    if (mv != null) {\r\n        mv.visitEnd();\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ModuleVisitor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ModuleVisitor#visitEnd()",
    "tailType": "method"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.testfixture.codec",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core.testfixture.codec",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.testfixture.codec.AbstractEncoderTests",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.testfixture.codec;\n\nimport java.util.Map;\nimport java.util.function.Consumer;\n\nimport org.jspecify.annotations.Nullable;\nimport org.junit.jupiter.api.Test;\nimport org.reactivestreams.Publisher;\nimport reactor.core.publisher.Flux;\nimport reactor.test.StepVerifier;\n\nimport org.springframework.core.ResolvableType;\nimport org.springframework.core.codec.Encoder;\nimport org.springframework.core.io.buffer.DataBuffer;\nimport org.springframework.core.io.buffer.DataBufferUtils;\nimport org.springframework.core.testfixture.io.buffer.AbstractLeakCheckingTests;\nimport org.springframework.util.Assert;\nimport org.springframework.util.MimeType;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.springframework.core.io.buffer.DataBufferUtils.release;\n\n/**\n * Abstract base class for {@link Encoder} unit tests. Subclasses need to implement\n * {@link #canEncode()} and {@link #encode()}, possibly using the wide variety of\n * helper methods like {@link #testEncodeAll}.\n *\n * @author Arjen Poutsma\n * @since 5.1.3\n */\npublic abstract class AbstractEncoderTests<E extends Encoder<?>> extends AbstractLeakCheckingTests {\n\n\t/**\n\t * The encoder to test.\n\t */\n\tprotected final E encoder;\n\n\n\t/**\n\t * Construct a new {@code AbstractEncoderTestCase} for the given parameters.\n\t * @param encoder the encoder\n\t */\n\tprotected AbstractEncoderTests(E encoder) {\n\t\tAssert.notNull(encoder, \"Encoder must not be null\");\n\t\tthis.encoder = encoder;\n\t}\n\n\n\t/**\n\t * Subclasses should implement this method to test {@link Encoder#canEncode}.\n\t */\n\t@Test\n\tprotected abstract void canEncode() throws Exception;\n\n\t/**\n\t * Subclasses should implement this method to test {@link Encoder#encode}, possibly using\n\t * {@link #testEncodeAll} or other helper methods.\n\t */\n\t@Test\n\tprotected abstract void encode() throws Exception;\n\n\n\t/**\n\t * Helper method that tests for a variety of encoding scenarios. This method\n\t * invokes:\n\t * <ul>\n\t *     <li>{@link #testEncode(Publisher, ResolvableType, MimeType, Map, Consumer)}</li>\n\t *     <li>{@link #testEncodeError(Publisher, ResolvableType, MimeType, Map)}</li>\n\t *     <li>{@link #testEncodeCancel(Publisher, ResolvableType, MimeType, Map)}</li>\n\t *     <li>{@link #testEncodeEmpty(ResolvableType, MimeType, Map)}</li>\n\t * </ul>\n\t *\n\t * @param input the input to be provided to the encoder\n\t * @param inputClass the input class\n\t * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\n\t * @param <T> the output type\n\t */\n\tprotected <T> void testEncodeAll(Publisher<? extends T> input, Class<? extends T> inputClass,\n\t\t\tConsumer<StepVerifier.FirstStep<DataBuffer>> stepConsumer) {\n\n\t\ttestEncodeAll(input, ResolvableType.forClass(inputClass), null, null, stepConsumer);\n\t}\n\n\t/**\n\t * Helper method that tests for a variety of decoding scenarios. This method\n\t * invokes:\n\t * <ul>\n\t *     <li>{@link #testEncode(Publisher, ResolvableType, MimeType, Map, Consumer)}</li>\n\t *     <li>{@link #testEncodeError(Publisher, ResolvableType, MimeType, Map)}</li>\n\t *     <li>{@link #testEncodeCancel(Publisher, ResolvableType, MimeType, Map)}</li>\n\t *     <li>{@link #testEncodeEmpty(ResolvableType, MimeType, Map)}</li>\n\t * </ul>\n\t *\n\t * @param <T> the output type\n\t * @param input the input to be provided to the encoder\n\t * @param inputType the input type\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\n\t */\n\tprotected <T> void testEncodeAll(Publisher<? extends T> input, ResolvableType inputType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints,\n\t\t\tConsumer<StepVerifier.FirstStep<DataBuffer>> stepConsumer) {\n\n\t\ttestEncode(input, inputType, mimeType, hints, stepConsumer);\n\t\ttestEncodeError(input, inputType, mimeType, hints);\n\t\ttestEncodeCancel(input, inputType, mimeType, hints);\n\t\ttestEncodeEmpty(inputType, mimeType, hints);\n\t}\n\n\t/**\n\t * Test a standard {@link Encoder#encode encode} scenario.\n\t *\n\t * @param input the input to be provided to the encoder\n\t * @param inputClass the input class\n\t * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\n\t * @param <T> the output type\n\t */\n\tprotected <T> void testEncode(Publisher<? extends T> input, Class<? extends T> inputClass,\n\t\t\tConsumer<StepVerifier.FirstStep<DataBuffer>> stepConsumer) {\n\n\t\ttestEncode(input, ResolvableType.forClass(inputClass), null, null, stepConsumer);\n\t}\n\n\t/**\n\t * Test a standard {@link Encoder#encode encode} scenario.\n\t *\n\t * @param <T> the output type\n\t * @param input the input to be provided to the encoder\n\t * @param inputType the input type\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\n\t */\n\tprotected <T> void testEncode(Publisher<? extends T> input, ResolvableType inputType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints,\n\t\t\tConsumer<StepVerifier.FirstStep<DataBuffer>> stepConsumer) {\n\n\t\tFlux<DataBuffer> result = encoder().encode(input, this.bufferFactory, inputType, mimeType, hints);\n\t\tStepVerifier.FirstStep<DataBuffer> step = StepVerifier.create(result);\n\t\tstepConsumer.accept(step);\n\t}\n\n\t/**\n\t * Test a {@link Encoder#encode encode} scenario where the input stream contains an error.\n\t * This test method will feed the first element of the {@code input} stream to the encoder,\n\t * followed by an {@link InputException}.\n\t * The result is expected to contain one \"normal\" element, followed by the error.\n\t *\n\t * @param input the input to be provided to the encoder\n\t * @param inputType the input type\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t * @see InputException\n\t */\n\tprotected void testEncodeError(Publisher<?> input, ResolvableType inputType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tinput = Flux.concat(\n\t\t\t\tFlux.from(input).take(1),\n\t\t\t\tFlux.error(new InputException()));\n\n\t\tFlux<DataBuffer> result = encoder().encode(input, this.bufferFactory, inputType,\n\t\t\t\tmimeType, hints);\n\n\t\tStepVerifier.create(result)\n\t\t\t\t.consumeNextWith(DataBufferUtils::release)\n\t\t\t\t.expectError(InputException.class)\n\t\t\t\t.verify();\n\t}\n\n\t/**\n\t * Test a {@link Encoder#encode encode} scenario where the input stream is canceled.\n\t * This test method will feed the first element of the {@code input} stream to the decoder,\n\t * followed by a cancel signal.\n\t * The result is expected to contain one \"normal\" element.\n\t *\n\t * @param input the input to be provided to the encoder\n\t * @param inputType the input type\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t */\n\tprotected void testEncodeCancel(Publisher<?> input, ResolvableType inputType,\n\t\t\t@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n\n\t\tFlux<DataBuffer> result = encoder().encode(input, this.bufferFactory, inputType, mimeType,\n\t\t\t\thints);\n\n\t\tStepVerifier.create(result)\n\t\t\t\t.consumeNextWith(DataBufferUtils::release)\n\t\t\t\t.thenCancel()\n\t\t\t\t.verify();\n\t}\n\n\t/**\n\t * Test a {@link Encoder#encode encode} scenario where the input stream is empty.\n\t * The output is expected to be empty as well.\n\t *\n\t * @param inputType the input type\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t */\n\tprotected void testEncodeEmpty(ResolvableType inputType, @Nullable MimeType mimeType,\n\t\t\t@Nullable Map<String, Object> hints) {\n\n\t\tFlux<?> input = Flux.empty();\n\t\tFlux<DataBuffer> result = encoder().encode(input, this.bufferFactory, inputType,\n\t\t\t\tmimeType, hints);\n\n\t\tStepVerifier.create(result)\n\t\t\t\t.verifyComplete();\n\t}\n\n\t/**\n\t * Create a result consumer that expects the given bytes.\n\t * @param expected the expected bytes\n\t * @return a consumer that expects the given data buffer to be equal to {@code expected}\n\t */\n\tprotected final Consumer<DataBuffer> expectBytes(byte[] expected) {\n\t\treturn dataBuffer -> {\n\t\t\tbyte[] resultBytes = new byte[dataBuffer.readableByteCount()];\n\t\t\tdataBuffer.read(resultBytes);\n\t\t\trelease(dataBuffer);\n\t\t\tassertThat(resultBytes).isEqualTo(expected);\n\t\t};\n\t}\n\n\t/**\n\t * Create a result consumer that expects the given string, using the UTF-8 encoding.\n\t * @param expected the expected string\n\t * @return a consumer that expects the given data buffer to be equal to {@code expected}\n\t */\n\tprotected Consumer<DataBuffer> expectString(String expected) {\n\t\treturn dataBuffer -> {\n\t\t\tString actual = dataBuffer.toString(UTF_8);\n\t\t\trelease(dataBuffer);\n\t\t\tassertThat(actual).isEqualToNormalizingNewlines(expected);\n\t\t};\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate <T> Encoder<T> encoder() {\n\t\treturn (Encoder<T>) this.encoder;\n\t}\n\n\t/**\n\t * Exception used in {@link #testEncodeError}.\n\t */\n\t@SuppressWarnings(\"serial\")\n\tpublic static class InputException extends RuntimeException {\n\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.testfixture.codec.AbstractEncoderTests#encoder",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#encoder",
    "headType": "field",
    "relation": "haveType",
    "tail": "E",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#canEncode()",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Subclasses should implement this method to test {@link Encoder#canEncode}.\r\n */\r\n@Test\r\nprotected abstract void canEncode() throws Exception;",
    "tailType": "method_code"
  }
]