[
  {
    "head": "org.springframework.core.FlowAdaptersRegistrar",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.FlowAdaptersRegistrar#registerAdapters(ReactiveAdapterRegistry)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.FlowAdaptersRegistrar#registerAdapters(ReactiveAdapterRegistry)",
    "headType": "method",
    "relation": "use",
    "tail": "@SuppressWarnings",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.SpringCoreBlockHoundIntegration",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.SpringCoreBlockHoundIntegration",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.Flow;\nimport java.util.function.Function;\n\nimport io.smallrye.mutiny.Multi;\nimport io.smallrye.mutiny.Uni;\nimport org.jspecify.annotations.Nullable;\nimport org.reactivestreams.FlowAdapters;\nimport org.reactivestreams.Publisher;\nimport reactor.adapter.JdkFlowAdapter;\nimport reactor.blockhound.BlockHound;\nimport reactor.blockhound.integration.BlockHoundIntegration;\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Mono;\n\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.ConcurrentReferenceHashMap;\nimport org.springframework.util.ReflectionUtils;\n\n/**\n * A registry of adapters to adapt Reactive Streams {@link Publisher} to/from various\n * async/reactive types such as {@code CompletableFuture}, RxJava {@code Flowable}, etc.\n * This is designed to complement Spring's Reactor {@code Mono}/{@code Flux} support while\n * also being usable without Reactor, for example, just for {@code org.reactivestreams} bridging.\n *\n * <p>By default, depending on classpath availability, adapters are registered for Reactor\n * (including {@code CompletableFuture} and {@code Flow.Publisher} adapters), RxJava 3,\n * Kotlin Coroutines' {@code Deferred} (bridged via Reactor) and SmallRye Mutiny 1.x/2.x.\n * If Reactor is not present, a simple {@code Flow.Publisher} bridge will be registered.\n *\n * @author Rossen Stoyanchev\n * @author Sebastien Deleuze\n * @author Juergen Hoeller\n * @since 5.0\n */\npublic class ReactiveAdapterRegistry {\n\n\tprivate static volatile @Nullable ReactiveAdapterRegistry sharedInstance;\n\n\tprivate static final boolean reactiveStreamsPresent;\n\n\tprivate static final boolean reactorPresent;\n\n\tprivate static final boolean rxjava3Present;\n\n\tprivate static final boolean kotlinCoroutinesPresent;\n\n\tprivate static final boolean mutinyPresent;\n\n\tstatic {\n\t\tClassLoader classLoader = ReactiveAdapterRegistry.class.getClassLoader();\n\t\treactiveStreamsPresent = ClassUtils.isPresent(\"org.reactivestreams.Publisher\", classLoader);\n\t\treactorPresent = ClassUtils.isPresent(\"reactor.core.publisher.Flux\", classLoader);\n\t\trxjava3Present = ClassUtils.isPresent(\"io.reactivex.rxjava3.core.Flowable\", classLoader);\n\t\tkotlinCoroutinesPresent = ClassUtils.isPresent(\"kotlinx.coroutines.reactor.MonoKt\", classLoader);\n\t\tmutinyPresent = ClassUtils.isPresent(\"io.smallrye.mutiny.Multi\", classLoader);\n\t}\n\n\tprivate final List<ReactiveAdapter> adapters = new ArrayList<>();\n\n\n\t/**\n\t * Create a registry and auto-register default adapters.\n\t * @see #getSharedInstance()\n\t */\n\tpublic ReactiveAdapterRegistry() {\n\t\t// Defensive guard for the Reactive Streams API itself\n\t\tif (!reactiveStreamsPresent) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Reactor\n\t\tif (reactorPresent) {\n\t\t\tnew ReactorRegistrar().registerAdapters(this);\n\t\t}\n\n\t\t// RxJava\n\t\tif (rxjava3Present) {\n\t\t\tnew RxJava3Registrar().registerAdapters(this);\n\t\t}\n\n\t\t// Kotlin Coroutines\n\t\tif (reactorPresent && kotlinCoroutinesPresent) {\n\t\t\tnew CoroutinesRegistrar().registerAdapters(this);\n\t\t}\n\n\t\t// SmallRye Mutiny\n\t\tif (mutinyPresent) {\n\t\t\tnew MutinyRegistrar().registerAdapters(this);\n\t\t}\n\n\t\t// Simple Flow.Publisher bridge if Reactor is not present\n\t\tif (!reactorPresent) {\n\t\t\tnew FlowAdaptersRegistrar().registerAdapters(this);\n\t\t}\n\t}\n\n\n\t/**\n\t * Register a reactive type along with functions to adapt to and from a\n\t * Reactive Streams {@link Publisher}. The function arguments assume that\n\t * their input is neither {@code null} nor {@link Optional}.\n\t * <p>This variant registers the new adapter after existing adapters.\n\t * It will be matched for the exact reactive type if no earlier adapter was\n\t * registered for the specific type, and it will be matched for assignability\n\t * in a second pass if no earlier adapter had an assignable type before.\n\t * @see #registerReactiveTypeOverride\n\t * @see #getAdapter\n\t */\n\tpublic void registerReactiveType(ReactiveTypeDescriptor descriptor,\n\t\t\tFunction<Object, Publisher<?>> toAdapter, Function<Publisher<?>, Object> fromAdapter) {\n\n\t\tthis.adapters.add(buildAdapter(descriptor, toAdapter, fromAdapter));\n\t}\n\n\t/**\n\t * Register a reactive type along with functions to adapt to and from a\n\t * Reactive Streams {@link Publisher}. The function arguments assume that\n\t * their input is neither {@code null} nor {@link Optional}.\n\t * <p>This variant registers the new adapter first, effectively overriding\n\t * any previously registered adapters for the same reactive type. This allows\n\t * for overriding existing adapters, in particular default adapters.\n\t * <p>Note that existing adapters for specific types will still match before\n\t * an assignability match with the new adapter. In order to override all\n\t * existing matches, a new reactive type adapter needs to be registered\n\t * for every specific type, not relying on subtype assignability matches.\n\t * @since 5.3.30\n\t * @see #registerReactiveType\n\t * @see #getAdapter\n\t */\n\tpublic void registerReactiveTypeOverride(ReactiveTypeDescriptor descriptor,\n\t\t\tFunction<Object, Publisher<?>> toAdapter, Function<Publisher<?>, Object> fromAdapter) {\n\n\t\tthis.adapters.add(0, buildAdapter(descriptor, toAdapter, fromAdapter));\n\t}\n\n\tprivate ReactiveAdapter buildAdapter(ReactiveTypeDescriptor descriptor,\n\t\t\tFunction<Object, Publisher<?>> toAdapter, Function<Publisher<?>, Object> fromAdapter) {\n\n\t\treturn (reactorPresent ? new ReactorAdapter(descriptor, toAdapter, fromAdapter) :\n\t\t\t\tnew ReactiveAdapter(descriptor, toAdapter, fromAdapter));\n\t}\n\n\t/**\n\t * Return whether the registry has any adapters.\n\t */\n\tpublic boolean hasAdapters() {\n\t\treturn !this.adapters.isEmpty();\n\t}\n\n\t/**\n\t * Get the adapter for the given reactive type.\n\t * @return the corresponding adapter, or {@code null} if none available\n\t */\n\tpublic @Nullable ReactiveAdapter getAdapter(Class<?> reactiveType) {\n\t\treturn getAdapter(reactiveType, null);\n\t}\n\n\t/**\n\t * Get the adapter for the given reactive type. Or if a \"source\" object is\n\t * provided, its actual type is used instead.\n\t * @param reactiveType the reactive type\n\t * (may be {@code null} if a concrete source object is given)\n\t * @param source an instance of the reactive type\n\t * (i.e. to adapt from; may be {@code null} if the reactive type is specified)\n\t * @return the corresponding adapter, or {@code null} if none available\n\t */\n\tpublic @Nullable ReactiveAdapter getAdapter(@Nullable Class<?> reactiveType, @Nullable Object source) {\n\t\tif (this.adapters.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tObject sourceToUse = (source instanceof Optional<?> optional ? optional.orElse(null) : source);\n\t\tClass<?> clazz = (sourceToUse != null ? sourceToUse.getClass() : reactiveType);\n\t\tif (clazz == null) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (ReactiveAdapter adapter : this.adapters) {\n\t\t\tif (adapter.getReactiveType() == clazz) {\n\t\t\t\treturn adapter;\n\t\t\t}\n\t\t}\n\t\tfor (ReactiveAdapter adapter : this.adapters) {\n\t\t\tif (adapter.getReactiveType().isAssignableFrom(clazz)) {\n\t\t\t\treturn adapter;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t/**\n\t * Return a shared default {@code ReactiveAdapterRegistry} instance,\n\t * lazily building it once needed.\n\t * <p><b>NOTE:</b> We highly recommend passing a long-lived, pre-configured\n\t * {@code ReactiveAdapterRegistry} instance for customization purposes.\n\t * This accessor is only meant as a fallback for code paths that want to\n\t * fall back on a default instance if one isn't provided.\n\t * @return the shared {@code ReactiveAdapterRegistry} instance\n\t * @since 5.0.2\n\t */\n\tpublic static ReactiveAdapterRegistry getSharedInstance() {\n\t\tReactiveAdapterRegistry registry = sharedInstance;\n\t\tif (registry == null) {\n\t\t\tsynchronized (ReactiveAdapterRegistry.class) {\n\t\t\t\tregistry = sharedInstance;\n\t\t\t\tif (registry == null) {\n\t\t\t\t\tregistry = new ReactiveAdapterRegistry();\n\t\t\t\t\tsharedInstance = registry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn registry;\n\t}\n\n\n\t/**\n\t * ReactiveAdapter variant that wraps adapted Publishers as {@link Flux} or\n\t * {@link Mono} depending on {@link ReactiveTypeDescriptor#isMultiValue()}.\n\t * This is important in places where only the stream and stream element type\n\t * information is available like encoders and decoders.\n\t */\n\tprivate static class ReactorAdapter extends ReactiveAdapter {\n\n\t\tReactorAdapter(ReactiveTypeDescriptor descriptor,\n\t\t\t\tFunction<Object, Publisher<?>> toPublisherFunction,\n\t\t\t\tFunction<Publisher<?>, Object> fromPublisherFunction) {\n\n\t\t\tsuper(descriptor, toPublisherFunction, fromPublisherFunction);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> Publisher<T> toPublisher(@Nullable Object source) {\n\t\t\tPublisher<T> publisher = super.toPublisher(source);\n\t\t\treturn (isMultiValue() ? Flux.from(publisher) : Mono.from(publisher));\n\t\t}\n\t}\n\n\n\tprivate static class ReactorRegistrar {\n\n\t\tprivate static final Flow.Publisher<?> EMPTY_FLOW = JdkFlowAdapter.publisherToFlowPublisher(Flux.empty());\n\n\t\tvoid registerAdapters(ReactiveAdapterRegistry registry) {\n\t\t\t// Register Flux and Mono before Publisher...\n\n\t\t\tregistry.registerReactiveType(\n\t\t\t\t\tReactiveTypeDescriptor.singleOptionalValue(Mono.class, Mono::empty),\n\t\t\t\t\tsource -> (Mono<?>) source,\n\t\t\t\t\tMono::from);\n\n\t\t\tregistry.registerReactiveType(\n\t\t\t\t\tReactiveTypeDescriptor.multiValue(Flux.class, Flux::empty),\n\t\t\t\t\tsource -> (Flux<?>) source,\n\t\t\t\t\tFlux::from);\n\n\t\t\tregistry.registerReactiveType(\n\t\t\t\t\tReactiveTypeDescriptor.multiValue(Publisher.class, Flux::empty),\n\t\t\t\t\tsource -> (Publisher<?>) source,\n\t\t\t\t\tsource -> source);\n\n\t\t\tregistry.registerReactiveType(\n\t\t\t\t\tReactiveTypeDescriptor.nonDeferredAsyncValue(CompletionStage.class, EmptyCompletableFuture::new),\n\t\t\t\t\tsource -> Mono.fromCompletionStage((CompletionStage<?>) source),\n\t\t\t\t\tsource -> Mono.from(source).toFuture());\n\n\t\t\tregistry.registerReactiveType(\n\t\t\t\t\tReactiveTypeDescriptor.multiValue(Flow.Publisher.class, () -> EMPTY_FLOW),\n\t\t\t\t\tsource -> JdkFlowAdapter.flowPublisherToFlux((Flow.Publisher<?>) source),\n\t\t\t\t\tJdkFlowAdapter::publisherToFlowPublisher);\n\t\t}\n\t}\n\n\n\tprivate static class EmptyCompletableFuture<T> extends CompletableFuture<T> {\n\n\t\tEmptyCompletableFuture() {\n\t\t\tcomplete(null);\n\t\t}\n\t}\n\n\n\tprivate static class RxJava3Registrar {\n\n\t\tvoid registerAdapters(ReactiveAdapterRegistry registry) {\n\t\t\tregistry.registerReactiveType(\n\t\t\t\t\tReactiveTypeDescriptor.multiValue(\n\t\t\t\t\t\t\tio.reactivex.rxjava3.core.Flowable.class,\n\t\t\t\t\t\t\tio.reactivex.rxjava3.core.Flowable::empty),\n\t\t\t\t\tsource -> (io.reactivex.rxjava3.core.Flowable<?>) source,\n\t\t\t\t\tio.reactivex.rxjava3.core.Flowable::fromPublisher);\n\n\t\t\tregistry.registerReactiveType(\n\t\t\t\t\tReactiveTypeDescriptor.multiValue(\n\t\t\t\t\t\t\tio.reactivex.rxjava3.core.Observable.class,\n\t\t\t\t\t\t\tio.reactivex.rxjava3.core.Observable::empty),\n\t\t\t\t\tsource -> ((io.reactivex.rxjava3.core.Observable<?>) source).toFlowable(\n\t\t\t\t\t\t\tio.reactivex.rxjava3.core.BackpressureStrategy.BUFFER),\n\t\t\t\t\tio.reactivex.rxjava3.core.Observable::fromPublisher);\n\n\t\t\tregistry.registerReactiveType(\n\t\t\t\t\tReactiveTypeDescriptor.singleRequiredValue(io.reactivex.rxjava3.core.Single.class),\n\t\t\t\t\tsource -> ((io.reactivex.rxjava3.core.Single<?>) source).toFlowable(),\n\t\t\t\t\tio.reactivex.rxjava3.core.Single::fromPublisher);\n\n\t\t\tregistry.registerReactiveType(\n\t\t\t\t\tReactiveTypeDescriptor.singleOptionalValue(\n\t\t\t\t\t\t\tio.reactivex.rxjava3.core.Maybe.class,\n\t\t\t\t\t\t\tio.reactivex.rxjava3.core.Maybe::empty),\n\t\t\t\t\tsource -> ((io.reactivex.rxjava3.core.Maybe<?>) source).toFlowable(),\n\t\t\t\t\tio.reactivex.rxjava3.core.Maybe::fromPublisher);\n\n\t\t\tregistry.registerReactiveType(\n\t\t\t\t\tReactiveTypeDescriptor.noValue(\n\t\t\t\t\t\t\tio.reactivex.rxjava3.core.Completable.class,\n\t\t\t\t\t\t\tio.reactivex.rxjava3.core.Completable::complete),\n\t\t\t\t\tsource -> ((io.reactivex.rxjava3.core.Completable) source).toFlowable(),\n\t\t\t\t\tio.reactivex.rxjava3.core.Completable::fromPublisher);\n\t\t}\n\t}\n\n\n\tprivate static class CoroutinesRegistrar {\n\n\t\t@SuppressWarnings(\"KotlinInternalInJava\")\n\t\tvoid registerAdapters(ReactiveAdapterRegistry registry) {\n\t\t\tregistry.registerReactiveType(\n\t\t\t\t\tReactiveTypeDescriptor.singleOptionalValue(kotlinx.coroutines.Deferred.class,\n\t\t\t\t\t\t\t() -> kotlinx.coroutines.CompletableDeferredKt.CompletableDeferred(null)),\n\t\t\t\t\tsource -> CoroutinesUtils.deferredToMono((kotlinx.coroutines.Deferred<?>) source),\n\t\t\t\t\tsource -> CoroutinesUtils.monoToDeferred(Mono.from(source)));\n\n\t\t\tregistry.registerReactiveType(\n\t\t\t\t\tReactiveTypeDescriptor.multiValue(kotlinx.coroutines.flow.Flow.class, kotlinx.coroutines.flow.FlowKt::emptyFlow),\n\t\t\t\t\tsource -> kotlinx.coroutines.reactor.ReactorFlowKt.asFlux((kotlinx.coroutines.flow.Flow<?>) source),\n\t\t\t\t\tkotlinx.coroutines.reactive.ReactiveFlowKt::asFlow);\n\t\t}\n\t}\n\n\n\tprivate static class MutinyRegistrar {\n\n\t\tprivate static final Method uniToPublisher = ClassUtils.getMethod(io.smallrye.mutiny.groups.UniConvert.class, \"toPublisher\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tvoid registerAdapters(ReactiveAdapterRegistry registry) {\n\t\t\tReactiveTypeDescriptor uniDesc = ReactiveTypeDescriptor.singleOptionalValue(\n\t\t\t\t\tio.smallrye.mutiny.Uni.class,\n\t\t\t\t\t() -> io.smallrye.mutiny.Uni.createFrom().nothing());\n\t\t\tReactiveTypeDescriptor multiDesc = ReactiveTypeDescriptor.multiValue(\n\t\t\t\t\tio.smallrye.mutiny.Multi.class,\n\t\t\t\t\t() -> io.smallrye.mutiny.Multi.createFrom().empty());\n\n\t\t\tif (Flow.Publisher.class.isAssignableFrom(uniToPublisher.getReturnType())) {\n\t\t\t\t// Mutiny 2 based on Flow.Publisher\n\t\t\t\tMethod uniPublisher = ClassUtils.getMethod(\n\t\t\t\t\t\tio.smallrye.mutiny.groups.UniCreate.class, \"publisher\", Flow.Publisher.class);\n\t\t\t\tMethod multiPublisher = ClassUtils.getMethod(\n\t\t\t\t\t\tio.smallrye.mutiny.groups.MultiCreate.class, \"publisher\", Flow.Publisher.class);\n\t\t\t\tregistry.registerReactiveType(uniDesc,\n\t\t\t\t\t\tuni -> FlowAdapters.toPublisher((Flow.Publisher<Object>)\n\t\t\t\t\t\t\t\tObjects.requireNonNull(ReflectionUtils.invokeMethod(uniToPublisher, ((Uni<?>) uni).convert()))),\n\t\t\t\t\t\tpublisher -> Objects.requireNonNull(ReflectionUtils.invokeMethod(uniPublisher, Uni.createFrom(),\n\t\t\t\t\t\t\t\tFlowAdapters.toFlowPublisher(publisher))));\n\t\t\t\tregistry.registerReactiveType(multiDesc,\n\t\t\t\t\t\tmulti -> FlowAdapters.toPublisher((Flow.Publisher<Object>) multi),\n\t\t\t\t\t\tpublisher -> Objects.requireNonNull(ReflectionUtils.invokeMethod(multiPublisher, Multi.createFrom(),\n\t\t\t\t\t\t\t\tFlowAdapters.toFlowPublisher(publisher))));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Mutiny 1 based on Reactive Streams\n\t\t\t\tregistry.registerReactiveType(uniDesc,\n\t\t\t\t\t\tuni -> ((io.smallrye.mutiny.Uni<?>) uni).convert().toPublisher(),\n\t\t\t\t\t\tpublisher -> io.smallrye.mutiny.Uni.createFrom().publisher(publisher));\n\t\t\t\tregistry.registerReactiveType(multiDesc,\n\t\t\t\t\t\tmulti -> (io.smallrye.mutiny.Multi<?>) multi,\n\t\t\t\t\t\tpublisher -> io.smallrye.mutiny.Multi.createFrom().publisher(publisher));\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate static class FlowAdaptersRegistrar {\n\n\t\tprivate static final Flow.Subscription EMPTY_SUBSCRIPTION = new Flow.Subscription() {\n\t\t\t@Override\n\t\t\tpublic void request(long n) {\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void cancel() {\n\t\t\t}\n\t\t};\n\n\t\tprivate static final Flow.Publisher<Object> EMPTY_PUBLISHER = subscriber -> {\n\t\t\tsubscriber.onSubscribe(EMPTY_SUBSCRIPTION);\n\t\t\tsubscriber.onComplete();\n\t\t};\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tvoid registerAdapters(ReactiveAdapterRegistry registry) {\n\t\t\tregistry.registerReactiveType(\n\t\t\t\t\tReactiveTypeDescriptor.multiValue(Flow.Publisher.class, () -> EMPTY_PUBLISHER),\n\t\t\t\t\tsource -> FlowAdapters.toPublisher((Flow.Publisher<Object>) source),\n\t\t\t\t\tsource -> FlowAdapters.toFlowPublisher((Publisher<Object>) source));\n\t\t}\n\t}\n\n\n\t/**\n\t * {@code BlockHoundIntegration} for spring-core classes.\n\t * Explicitly allows locking within {@link ConcurrentReferenceHashMap}.\n\t * @since 5.2.4\n\t */\n\tpublic static class SpringCoreBlockHoundIntegration implements BlockHoundIntegration {\n\n\t\t@Override\n\t\tpublic void applyTo(BlockHound.Builder builder) {\n\t\t\t// Avoid hard references potentially anywhere in spring-core (no need for structural dependency)\n\n\t\t\tString segmentClassName = \"org.springframework.util.ConcurrentReferenceHashMap$Segment\";\n\t\t\tbuilder.allowBlockingCallsInside(segmentClassName, \"doTask\");\n\t\t\tbuilder.allowBlockingCallsInside(segmentClassName, \"clear\");\n\t\t\tbuilder.allowBlockingCallsInside(segmentClassName, \"restructure\");\n\n\t\t\tString referenceManagerClassName = \"org.springframework.util.ConcurrentReferenceHashMap$ReferenceManager\";\n\t\t\tbuilder.allowBlockingCallsInside(referenceManagerClassName, \"pollForPurge\");\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.SpringCoreBlockHoundIntegration#applyTo(BlockHound.Builder)",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic void applyTo(BlockHound.Builder builder) {\r\n    // Avoid hard references potentially anywhere in spring-core (no need for structural dependency)\r\n    String segmentClassName = \"org.springframework.util.ConcurrentReferenceHashMap$Segment\";\r\n    builder.allowBlockingCallsInside(segmentClassName, \"doTask\");\r\n    builder.allowBlockingCallsInside(segmentClassName, \"clear\");\r\n    builder.allowBlockingCallsInside(segmentClassName, \"restructure\");\r\n    String referenceManagerClassName = \"org.springframework.util.ConcurrentReferenceHashMap$ReferenceManager\";\r\n    builder.allowBlockingCallsInside(referenceManagerClassName, \"pollForPurge\");\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.SpringCoreBlockHoundIntegration",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.SpringCoreBlockHoundIntegration#applyTo(BlockHound.Builder)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.SpringCoreBlockHoundIntegration#applyTo(BlockHound.Builder)",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.ReactiveTypeDescriptor",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.ReactiveTypeDescriptor",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.util.function.Supplier;\n\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.util.Assert;\n\n/**\n * Describes the semantics of a reactive type including boolean checks for\n * {@link #isMultiValue()}, {@link #isNoValue()}, and {@link #supportsEmpty()}.\n *\n * @author Rossen Stoyanchev\n * @since 5.0\n */\npublic final class ReactiveTypeDescriptor {\n\n\tprivate final Class<?> reactiveType;\n\n\tprivate final boolean multiValue;\n\n\tprivate final boolean noValue;\n\n\tprivate final @Nullable Supplier<?> emptySupplier;\n\n\tprivate final boolean deferred;\n\n\n\tprivate ReactiveTypeDescriptor(Class<?> reactiveType, boolean multiValue, boolean noValue,\n\t\t\t@Nullable Supplier<?> emptySupplier) {\n\n\t\tthis(reactiveType, multiValue, noValue, emptySupplier, true);\n\t}\n\n\tprivate ReactiveTypeDescriptor(Class<?> reactiveType, boolean multiValue, boolean noValue,\n\t\t\t@Nullable Supplier<?> emptySupplier, boolean deferred) {\n\n\t\tAssert.notNull(reactiveType, \"'reactiveType' must not be null\");\n\t\tthis.reactiveType = reactiveType;\n\t\tthis.multiValue = multiValue;\n\t\tthis.noValue = noValue;\n\t\tthis.emptySupplier = emptySupplier;\n\t\tthis.deferred = deferred;\n\t}\n\n\n\t/**\n\t * Return the reactive type for this descriptor.\n\t */\n\tpublic Class<?> getReactiveType() {\n\t\treturn this.reactiveType;\n\t}\n\n\t/**\n\t * Return {@code true} if the reactive type can produce more than 1 value\n\t * can be produced and is therefore a good fit to adapt to {@code Flux}.\n\t * A {@code false} return value implies the reactive type can produce 1\n\t * value at most and is therefore a good fit to adapt to {@code Mono}.\n\t */\n\tpublic boolean isMultiValue() {\n\t\treturn this.multiValue;\n\t}\n\n\t/**\n\t * Return {@code true} if the reactive type does not produce any values and\n\t * only provides completion and error signals.\n\t */\n\tpublic boolean isNoValue() {\n\t\treturn this.noValue;\n\t}\n\n\t/**\n\t * Return {@code true} if the reactive type can complete with no values.\n\t */\n\tpublic boolean supportsEmpty() {\n\t\treturn (this.emptySupplier != null);\n\t}\n\n\t/**\n\t * Return an empty-value instance for the underlying reactive or async type.\n\t * <p>Use of this type implies {@link #supportsEmpty()} is {@code true}.\n\t */\n\tpublic Object getEmptyValue() {\n\t\tAssert.state(this.emptySupplier != null, \"Empty values not supported\");\n\t\tObject emptyValue = this.emptySupplier.get();\n\t\tAssert.notNull(emptyValue, \"Invalid null return value from emptySupplier\");\n\t\treturn emptyValue;\n\t}\n\n\t/**\n\t * Whether the underlying operation is deferred and needs to be started\n\t * explicitly, for example, via subscribing (or similar), or whether it is triggered\n\t * without the consumer having any control.\n\t * @since 5.2.7\n\t */\n\tpublic boolean isDeferred() {\n\t\treturn this.deferred;\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (other == null || getClass() != other.getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.reactiveType.equals(((ReactiveTypeDescriptor) other).reactiveType);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.reactiveType.hashCode();\n\t}\n\n\n\t/**\n\t * Descriptor for a reactive type that can produce {@code 0..N} values.\n\t * @param type the reactive type\n\t * @param emptySupplier a supplier of an empty-value instance of the reactive type\n\t */\n\tpublic static ReactiveTypeDescriptor multiValue(Class<?> type, Supplier<?> emptySupplier) {\n\t\treturn new ReactiveTypeDescriptor(type, true, false, emptySupplier);\n\t}\n\n\t/**\n\t * Descriptor for a reactive type that can produce 0..1 values.\n\t * @param type the reactive type\n\t * @param emptySupplier a supplier of an empty-value instance of the reactive type\n\t */\n\tpublic static ReactiveTypeDescriptor singleOptionalValue(Class<?> type, Supplier<?> emptySupplier) {\n\t\treturn new ReactiveTypeDescriptor(type, false, false, emptySupplier);\n\t}\n\n\t/**\n\t * Descriptor for a reactive type that must produce 1 value to complete.\n\t * @param type the reactive type\n\t */\n\tpublic static ReactiveTypeDescriptor singleRequiredValue(Class<?> type) {\n\t\treturn new ReactiveTypeDescriptor(type, false, false, null);\n\t}\n\n\t/**\n\t * Descriptor for a reactive type that does not produce any values.\n\t * @param type the reactive type\n\t * @param emptySupplier a supplier of an empty-value instance of the reactive type\n\t */\n\tpublic static ReactiveTypeDescriptor noValue(Class<?> type, Supplier<?> emptySupplier) {\n\t\treturn new ReactiveTypeDescriptor(type, false, true, emptySupplier);\n\t}\n\n\t/**\n\t * The same as {@link #singleOptionalValue(Class, Supplier)} but for a\n\t * non-deferred, async type such as {@link java.util.concurrent.CompletableFuture}.\n\t * @param type the reactive type\n\t * @param emptySupplier a supplier of an empty-value instance of the reactive type\n\t * @since 5.2.7\n\t */\n\tpublic static ReactiveTypeDescriptor nonDeferredAsyncValue(Class<?> type, Supplier<?> emptySupplier) {\n\t\treturn new ReactiveTypeDescriptor(type, false, false, emptySupplier, false);\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.ReactiveTypeDescriptor",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.ReactiveTypeDescriptor#reactiveType",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.ReactiveTypeDescriptor#reactiveType",
    "headType": "field",
    "relation": "haveType",
    "tail": "Class<?>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.ReactiveTypeDescriptor",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.ReactiveTypeDescriptor#multiValue",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.ReactiveTypeDescriptor#multiValue",
    "headType": "field",
    "relation": "haveType",
    "tail": "boolean",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.ReactiveTypeDescriptor",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.ReactiveTypeDescriptor#noValue",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.ReactiveTypeDescriptor#noValue",
    "headType": "field",
    "relation": "haveType",
    "tail": "boolean",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.ReactiveTypeDescriptor",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.ReactiveTypeDescriptor#emptySupplier",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.ReactiveTypeDescriptor#emptySupplier",
    "headType": "field",
    "relation": "haveType",
    "tail": "Supplier<?>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.ReactiveTypeDescriptor",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.ReactiveTypeDescriptor#deferred",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.ReactiveTypeDescriptor#deferred",
    "headType": "field",
    "relation": "haveType",
    "tail": "boolean",
    "tailType": "type"
  }
]