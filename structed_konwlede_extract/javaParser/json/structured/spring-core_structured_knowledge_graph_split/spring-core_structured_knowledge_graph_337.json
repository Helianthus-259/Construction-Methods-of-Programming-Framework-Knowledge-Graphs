[
  {
    "head": "org.springframework.util.StopWatchTests#validUsage()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid validUsage() throws Exception {\r\n    assertThat(stopWatch.isRunning()).isFalse();\r\n    stopWatch.start(name1);\r\n    Thread.sleep(duration1);\r\n    assertThat(stopWatch.isRunning()).isTrue();\r\n    assertThat(stopWatch.currentTaskName()).isEqualTo(name1);\r\n    stopWatch.stop();\r\n    assertThat(stopWatch.isRunning()).isFalse();\r\n    /* Flaky StopWatch time assertions...\r\n\t\tassertThat(stopWatch.getLastTaskTimeNanos())\r\n\t\t\t\t.as(\"last task time in nanoseconds for task #1\")\r\n\t\t\t\t.isGreaterThanOrEqualTo(TimeUnit.MILLISECONDS.toNanos(duration1 - fudgeFactor))\r\n\t\t\t\t.isLessThanOrEqualTo(TimeUnit.MILLISECONDS.toNanos(duration1 + fudgeFactor));\r\n\t\tassertThat(stopWatch.getTotalTimeMillis())\r\n\t\t\t\t.as(\"total time in milliseconds for task #1\")\r\n\t\t\t\t.isGreaterThanOrEqualTo(duration1 - fudgeFactor)\r\n\t\t\t\t.isLessThanOrEqualTo(duration1 + fudgeFactor);\r\n\t\tassertThat(stopWatch.getTotalTimeSeconds())\r\n\t\t\t\t.as(\"total time in seconds for task #1\")\r\n\t\t\t\t.isGreaterThanOrEqualTo((duration1 - fudgeFactor) / 1000.0)\r\n\t\t\t\t.isLessThanOrEqualTo((duration1 + fudgeFactor) / 1000.0);\r\n\t\t*/\r\n    stopWatch.start(name2);\r\n    Thread.sleep(duration2);\r\n    assertThat(stopWatch.isRunning()).isTrue();\r\n    assertThat(stopWatch.currentTaskName()).isEqualTo(name2);\r\n    stopWatch.stop();\r\n    assertThat(stopWatch.isRunning()).isFalse();\r\n    /* Flaky StopWatch time assertions...\r\n\t\tassertThat(stopWatch.getLastTaskTimeNanos())\r\n\t\t\t\t.as(\"last task time in nanoseconds for task #2\")\r\n\t\t\t\t.isGreaterThanOrEqualTo(TimeUnit.MILLISECONDS.toNanos(duration2))\r\n\t\t\t\t.isLessThanOrEqualTo(TimeUnit.MILLISECONDS.toNanos(duration2 + fudgeFactor));\r\n\t\tassertThat(stopWatch.getTotalTimeMillis())\r\n\t\t\t\t.as(\"total time in milliseconds for tasks #1 and #2\")\r\n\t\t\t\t.isGreaterThanOrEqualTo(duration1 + duration2 - fudgeFactor)\r\n\t\t\t\t.isLessThanOrEqualTo(duration1 + duration2 + fudgeFactor);\r\n\t\tassertThat(stopWatch.getTotalTimeSeconds())\r\n\t\t\t\t.as(\"total time in seconds for task #2\")\r\n\t\t\t\t.isGreaterThanOrEqualTo((duration1 + duration2 - fudgeFactor) / 1000.0)\r\n\t\t\t\t.isLessThanOrEqualTo((duration1 + duration2 + fudgeFactor) / 1000.0);\r\n\t\t*/\r\n    assertThat(stopWatch.getTaskCount()).isEqualTo(2);\r\n    assertThat(stopWatch.prettyPrint()).contains(name1, name2);\r\n    assertThat(stopWatch.getTaskInfo()).extracting(TaskInfo::getTaskName).containsExactly(name1, name2);\r\n    assertThat(stopWatch.toString()).contains(ID, name1, name2);\r\n    assertThat(stopWatch.getId()).isEqualTo(ID);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.StopWatchTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.StopWatchTests#validUsage()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.StopWatchTests#validUsage()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.StopWatchTests#validUsageDoesNotKeepTaskList()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid validUsageDoesNotKeepTaskList() throws Exception {\r\n    stopWatch.setKeepTaskList(false);\r\n    stopWatch.start(name1);\r\n    Thread.sleep(duration1);\r\n    assertThat(stopWatch.currentTaskName()).isEqualTo(name1);\r\n    stopWatch.stop();\r\n    stopWatch.start(name2);\r\n    Thread.sleep(duration2);\r\n    assertThat(stopWatch.currentTaskName()).isEqualTo(name2);\r\n    stopWatch.stop();\r\n    assertThat(stopWatch.getTaskCount()).isEqualTo(2);\r\n    assertThat(stopWatch.prettyPrint()).contains(\"No task info kept\");\r\n    assertThat(stopWatch.toString()).doesNotContain(name1, name2);\r\n    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(stopWatch::getTaskInfo).withMessage(\"Task info is not being kept!\");\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.StopWatchTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.StopWatchTests#validUsageDoesNotKeepTaskList()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.StopWatchTests#validUsageDoesNotKeepTaskList()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.util",
    "tailType": "package"
  },
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.StreamUtilsTests",
    "tailType": "class"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "provide",
    "tail": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage org.springframework.asm;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * A parser to make a {@link ClassVisitor} visit a ClassFile structure, as defined in the Java\n * Virtual Machine Specification (JVMS). This class parses the ClassFile content and calls the\n * appropriate visit methods of a given {@link ClassVisitor} for each field, method and bytecode\n * instruction encountered.\n *\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html\">JVMS 4</a>\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n */\npublic class ClassReader {\n\n  /**\n   * A flag to skip the Code attributes. If this flag is set the Code attributes are neither parsed\n   * nor visited.\n   */\n  public static final int SKIP_CODE = 1;\n\n  /**\n   * A flag to skip the SourceFile, SourceDebugExtension, LocalVariableTable,\n   * LocalVariableTypeTable, LineNumberTable and MethodParameters attributes. If this flag is set\n   * these attributes are neither parsed nor visited (i.e. {@link ClassVisitor#visitSource}, {@link\n   * MethodVisitor#visitLocalVariable}, {@link MethodVisitor#visitLineNumber} and {@link\n   * MethodVisitor#visitParameter} are not called).\n   */\n  public static final int SKIP_DEBUG = 2;\n\n  /**\n   * A flag to skip the StackMap and StackMapTable attributes. If this flag is set these attributes\n   * are neither parsed nor visited (i.e. {@link MethodVisitor#visitFrame} is not called). This flag\n   * is useful when the {@link ClassWriter#COMPUTE_FRAMES} option is used: it avoids visiting frames\n   * that will be ignored and recomputed from scratch.\n   */\n  public static final int SKIP_FRAMES = 4;\n\n  /**\n   * A flag to expand the stack map frames. By default stack map frames are visited in their\n   * original format (i.e. \"expanded\" for classes whose version is less than V1_6, and \"compressed\"\n   * for the other classes). If this flag is set, stack map frames are always visited in expanded\n   * format (this option adds a decompression/compression step in ClassReader and ClassWriter which\n   * degrades performance quite a lot).\n   */\n  public static final int EXPAND_FRAMES = 8;\n\n  /**\n   * A flag to expand the ASM specific instructions into an equivalent sequence of standard bytecode\n   * instructions. When resolving a forward jump it may happen that the signed 2 bytes offset\n   * reserved for it is not sufficient to store the bytecode offset. In this case the jump\n   * instruction is replaced with a temporary ASM specific instruction using an unsigned 2 bytes\n   * offset (see {@link Label#resolve}). This internal flag is used to re-read classes containing\n   * such instructions, in order to replace them with standard instructions. In addition, when this\n   * flag is used, goto_w and jsr_w are <i>not</i> converted into goto and jsr, to make sure that\n   * infinite loops where a goto_w is replaced with a goto in ClassReader and converted back to a\n   * goto_w in ClassWriter cannot occur.\n   */\n  static final int EXPAND_ASM_INSNS = 256;\n\n  /** The maximum size of array to allocate. */\n  private static final int MAX_BUFFER_SIZE = 1024 * 1024;\n\n  /** The size of the temporary byte array used to read class input streams chunk by chunk. */\n  private static final int INPUT_STREAM_DATA_CHUNK_SIZE = 4096;\n\n  /**\n   * A byte array containing the JVMS ClassFile structure to be parsed.\n   *\n   * @deprecated Use {@link #readByte(int)} and the other read methods instead. This field will\n   *     eventually be deleted.\n   */\n  @Deprecated\n  // DontCheck(MemberName): can't be renamed (for backward binary compatibility).\n  public final byte[] b;\n\n  /** The offset in bytes of the ClassFile's access_flags field. */\n  public final int header;\n\n  /**\n   * A byte array containing the JVMS ClassFile structure to be parsed. <i>The content of this array\n   * must not be modified. This field is intended for {@link Attribute} sub classes, and is normally\n   * not needed by class visitors.</i>\n   *\n   * <p>NOTE: the ClassFile structure can start at any offset within this array, i.e. it does not\n   * necessarily start at offset 0. Use {@link #getItem} and {@link #header} to get correct\n   * ClassFile element offsets within this byte array.\n   */\n  final byte[] classFileBuffer;\n\n  /**\n   * The offset in bytes, in {@link #classFileBuffer}, of each cp_info entry of the ClassFile's\n   * constant_pool array, <i>plus one</i>. In other words, the offset of constant pool entry i is\n   * given by cpInfoOffsets[i] - 1, i.e. its cp_info's tag field is given by b[cpInfoOffsets[i] -\n   * 1].\n   */\n  private final int[] cpInfoOffsets;\n\n  /**\n   * The String objects corresponding to the CONSTANT_Utf8 constant pool items. This cache avoids\n   * multiple parsing of a given CONSTANT_Utf8 constant pool item.\n   */\n  private final String[] constantUtf8Values;\n\n  /**\n   * The ConstantDynamic objects corresponding to the CONSTANT_Dynamic constant pool items. This\n   * cache avoids multiple parsing of a given CONSTANT_Dynamic constant pool item.\n   */\n  private final ConstantDynamic[] constantDynamicValues;\n\n  /**\n   * The start offsets in {@link #classFileBuffer} of each element of the bootstrap_methods array\n   * (in the BootstrapMethods attribute).\n   *\n   * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.23\">JVMS\n   *     4.7.23</a>\n   */\n  private final int[] bootstrapMethodOffsets;\n\n  /**\n   * A conservative estimate of the maximum length of the strings contained in the constant pool of\n   * the class.\n   */\n  private final int maxStringLength;\n\n  // -----------------------------------------------------------------------------------------------\n  // Constructors\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Constructs a new {@link ClassReader} object.\n   *\n   * @param classFile the JVMS ClassFile structure to be read.\n   */\n  public ClassReader(final byte[] classFile) {\n    this(classFile, 0, classFile.length);\n  }\n\n  /**\n   * Constructs a new {@link ClassReader} object.\n   *\n   * @param classFileBuffer a byte array containing the JVMS ClassFile structure to be read.\n   * @param classFileOffset the offset in byteBuffer of the first byte of the ClassFile to be read.\n   * @param classFileLength the length in bytes of the ClassFile to be read.\n   */\n  public ClassReader(\n      final byte[] classFileBuffer,\n      final int classFileOffset,\n      final int classFileLength) { // NOPMD(UnusedFormalParameter) used for backward compatibility.\n    this(classFileBuffer, classFileOffset, /* checkClassVersion= */ true);\n  }\n\n  /**\n   * Constructs a new {@link ClassReader} object. <i>This internal constructor must not be exposed\n   * as a public API</i>.\n   *\n   * @param classFileBuffer a byte array containing the JVMS ClassFile structure to be read.\n   * @param classFileOffset the offset in byteBuffer of the first byte of the ClassFile to be read.\n   * @param checkClassVersion whether to check the class version or not.\n   */\n  @SuppressWarnings(\"PMD.ConstructorCallsOverridableMethod\")\n  ClassReader(\n      final byte[] classFileBuffer, final int classFileOffset, final boolean checkClassVersion) {\n    this.classFileBuffer = classFileBuffer;\n    this.b = classFileBuffer;\n    // Check the class' major_version. This field is after the magic and minor_version fields, which\n    // use 4 and 2 bytes respectively.\n    if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V24) {\n      throw new IllegalArgumentException(\n          \"Unsupported class file major version \" + readShort(classFileOffset + 6));\n    }\n    // Create the constant pool arrays. The constant_pool_count field is after the magic,\n    // minor_version and major_version fields, which use 4, 2 and 2 bytes respectively.\n    int constantPoolCount = readUnsignedShort(classFileOffset + 8);\n    cpInfoOffsets = new int[constantPoolCount];\n    constantUtf8Values = new String[constantPoolCount];\n    // Compute the offset of each constant pool entry, as well as a conservative estimate of the\n    // maximum length of the constant pool strings. The first constant pool entry is after the\n    // magic, minor_version, major_version and constant_pool_count fields, which use 4, 2, 2 and 2\n    // bytes respectively.\n    int currentCpInfoIndex = 1;\n    int currentCpInfoOffset = classFileOffset + 10;\n    int currentMaxStringLength = 0;\n    boolean hasBootstrapMethods = false;\n    boolean hasConstantDynamic = false;\n    // The offset of the other entries depend on the total size of all the previous entries.\n    while (currentCpInfoIndex < constantPoolCount) {\n      cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + 1;\n      int cpInfoSize;\n      switch (classFileBuffer[currentCpInfoOffset]) {\n        case Symbol.CONSTANT_FIELDREF_TAG:\n        case Symbol.CONSTANT_METHODREF_TAG:\n        case Symbol.CONSTANT_INTERFACE_METHODREF_TAG:\n        case Symbol.CONSTANT_INTEGER_TAG:\n        case Symbol.CONSTANT_FLOAT_TAG:\n        case Symbol.CONSTANT_NAME_AND_TYPE_TAG:\n          cpInfoSize = 5;\n          break;\n        case Symbol.CONSTANT_DYNAMIC_TAG:\n          cpInfoSize = 5;\n          hasBootstrapMethods = true;\n          hasConstantDynamic = true;\n          break;\n        case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:\n          cpInfoSize = 5;\n          hasBootstrapMethods = true;\n          break;\n        case Symbol.CONSTANT_LONG_TAG:\n        case Symbol.CONSTANT_DOUBLE_TAG:\n          cpInfoSize = 9;\n          currentCpInfoIndex++;\n          break;\n        case Symbol.CONSTANT_UTF8_TAG:\n          cpInfoSize = 3 + readUnsignedShort(currentCpInfoOffset + 1);\n          if (cpInfoSize > currentMaxStringLength) {\n            // The size in bytes of this CONSTANT_Utf8 structure provides a conservative estimate\n            // of the length in characters of the corresponding string, and is much cheaper to\n            // compute than this exact length.\n            currentMaxStringLength = cpInfoSize;\n          }\n          break;\n        case Symbol.CONSTANT_METHOD_HANDLE_TAG:\n          cpInfoSize = 4;\n          break;\n        case Symbol.CONSTANT_CLASS_TAG:\n        case Symbol.CONSTANT_STRING_TAG:\n        case Symbol.CONSTANT_METHOD_TYPE_TAG:\n        case Symbol.CONSTANT_PACKAGE_TAG:\n        case Symbol.CONSTANT_MODULE_TAG:\n          cpInfoSize = 3;\n          break;\n        default:\n          throw new IllegalArgumentException();\n      }\n      currentCpInfoOffset += cpInfoSize;\n    }\n    maxStringLength = currentMaxStringLength;\n    // The Classfile's access_flags field is just after the last constant pool entry.\n    header = currentCpInfoOffset;\n\n    // Allocate the cache of ConstantDynamic values, if there is at least one.\n    constantDynamicValues = hasConstantDynamic ? new ConstantDynamic[constantPoolCount] : null;\n\n    // Read the BootstrapMethods attribute, if any (only get the offset of each method).\n    bootstrapMethodOffsets =\n        hasBootstrapMethods ? readBootstrapMethodsAttribute(currentMaxStringLength) : null;\n  }\n\n  /**\n   * Constructs a new {@link ClassReader} object.\n   *\n   * @param inputStream an input stream of the JVMS ClassFile structure to be read. This input\n   *     stream must contain nothing more than the ClassFile structure itself. It is read from its\n   *     current position to its end.\n   * @throws IOException if a problem occurs during reading.\n   */\n  public ClassReader(final InputStream inputStream) throws IOException {\n    this(readStream(inputStream, false));\n  }\n\n  /**\n   * Constructs a new {@link ClassReader} object.\n   *\n   * @param className the fully qualified name of the class to be read. The ClassFile structure is\n   *     retrieved with the current class loader's {@link ClassLoader#getSystemResourceAsStream}.\n   * @throws IOException if an exception occurs during reading.\n   */\n  public ClassReader(final String className) throws IOException {\n    this(\n        readStream(\n            ClassLoader.getSystemResourceAsStream(className.replace('.', '/') + \".class\"), true));\n  }\n\n  /**\n   * Reads the given input stream and returns its content as a byte array.\n   *\n   * @param inputStream an input stream.\n   * @param close true to close the input stream after reading.\n   * @return the content of the given input stream.\n   * @throws IOException if a problem occurs during reading.\n   */\n  @SuppressWarnings(\"PMD.UseTryWithResources\")\n  private static byte[] readStream(final InputStream inputStream, final boolean close)\n      throws IOException {\n    if (inputStream == null) {\n      throw new IOException(\"Class not found\");\n    }\n    int bufferSize = computeBufferSize(inputStream);\n    try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {\n      byte[] data = new byte[bufferSize];\n      int bytesRead;\n      int readCount = 0;\n      while ((bytesRead = inputStream.read(data, 0, bufferSize)) != -1) {\n        outputStream.write(data, 0, bytesRead);\n        readCount++;\n      }\n      outputStream.flush();\n      if (readCount == 1) {\n        // SPRING PATCH: some misbehaving InputStreams return -1 but still write to buffer (gh-27429)\n        // return data;\n        // END OF PATCH\n      }\n      return outputStream.toByteArray();\n    } finally {\n      if (close) {\n        inputStream.close();\n      }\n    }\n  }\n\n  private static int computeBufferSize(final InputStream inputStream) throws IOException {\n    int expectedLength = inputStream.available();\n    /*\n     * Some implementations can return 0 while holding available data (e.g. new\n     * FileInputStream(\"/proc/a_file\")). Also in some pathological cases a very small number might\n     * be returned, and in this case we use a default size.\n     */\n    if (expectedLength < 256) {\n      return INPUT_STREAM_DATA_CHUNK_SIZE;\n    }\n    return Math.min(expectedLength, MAX_BUFFER_SIZE);\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Accessors\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Returns the class's access flags (see {@link Opcodes}). This value may not reflect Deprecated\n   * and Synthetic flags when bytecode is before 1.5 and those flags are represented by attributes.\n   *\n   * @return the class access flags.\n   * @see ClassVisitor#visit(int, int, String, String, String, String[])\n   */\n  public int getAccess() {\n    return readUnsignedShort(header);\n  }\n\n  /**\n   * Returns the internal name of the class (see {@link Type#getInternalName()}).\n   *\n   * @return the internal class name.\n   * @see ClassVisitor#visit(int, int, String, String, String, String[])\n   */\n  public String getClassName() {\n    // this_class is just after the access_flags field (using 2 bytes).\n    return readClass(header + 2, new char[maxStringLength]);\n  }\n\n  /**\n   * Returns the internal name of the super class (see {@link Type#getInternalName()}). For\n   * interfaces, the super class is {@link Object}.\n   *\n   * @return the internal name of the super class, or {@literal null} for {@link Object} class.\n   * @see ClassVisitor#visit(int, int, String, String, String, String[])\n   */\n  public String getSuperName() {\n    // super_class is after the access_flags and this_class fields (2 bytes each).\n    return readClass(header + 4, new char[maxStringLength]);\n  }\n\n  /**\n   * Returns the internal names of the implemented interfaces (see {@link Type#getInternalName()}).\n   *\n   * @return the internal names of the directly implemented interfaces. Inherited implemented\n   *     interfaces are not returned.\n   * @see ClassVisitor#visit(int, int, String, String, String, String[])\n   */\n  public String[] getInterfaces() {\n    // interfaces_count is after the access_flags, this_class and super_class fields (2 bytes each).\n    int currentOffset = header + 6;\n    int interfacesCount = readUnsignedShort(currentOffset);\n    String[] interfaces = new String[interfacesCount];\n    if (interfacesCount > 0) {\n      char[] charBuffer = new char[maxStringLength];\n      for (int i = 0; i < interfacesCount; ++i) {\n        currentOffset += 2;\n        interfaces[i] = readClass(currentOffset, charBuffer);\n      }\n    }\n    return interfaces;\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Public methods\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Makes the given visitor visit the JVMS ClassFile structure passed to the constructor of this\n   * {@link ClassReader}.\n   *\n   * @param classVisitor the visitor that must visit this class.\n   * @param parsingOptions the options to use to parse this class. One or more of {@link\n   *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.\n   */\n  public void accept(final ClassVisitor classVisitor, final int parsingOptions) {\n    accept(classVisitor, new Attribute[0], parsingOptions);\n  }\n\n  /**\n   * Makes the given visitor visit the JVMS ClassFile structure passed to the constructor of this\n   * {@link ClassReader}.\n   *\n   * @param classVisitor the visitor that must visit this class.\n   * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of\n   *     the class. Any attribute whose type is not equal to the type of one the prototypes will not\n   *     be parsed: its byte array value will be passed unchanged to the ClassWriter. <i>This may\n   *     corrupt it if this value contains references to the constant pool, or has syntactic or\n   *     semantic links with a class element that has been transformed by a class adapter between\n   *     the reader and the writer</i>.\n   * @param parsingOptions the options to use to parse this class. One or more of {@link\n   *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.\n   */\n  public void accept(\n      final ClassVisitor classVisitor,\n      final Attribute[] attributePrototypes,\n      final int parsingOptions) {\n    Context context = new Context();\n    context.attributePrototypes = attributePrototypes;\n    context.parsingOptions = parsingOptions;\n    context.charBuffer = new char[maxStringLength];\n\n    // Read the access_flags, this_class, super_class, interface_count and interfaces fields.\n    char[] charBuffer = context.charBuffer;\n    int currentOffset = header;\n    int accessFlags = readUnsignedShort(currentOffset);\n    String thisClass = readClass(currentOffset + 2, charBuffer);\n    String superClass = readClass(currentOffset + 4, charBuffer);\n    String[] interfaces = new String[readUnsignedShort(currentOffset + 6)];\n    currentOffset += 8;\n    for (int i = 0; i < interfaces.length; ++i) {\n      interfaces[i] = readClass(currentOffset, charBuffer);\n      currentOffset += 2;\n    }\n\n    // Read the class attributes (the variables are ordered as in Section 4.7 of the JVMS).\n    // Attribute offsets exclude the attribute_name_index and attribute_length fields.\n    // - The offset of the InnerClasses attribute, or 0.\n    int innerClassesOffset = 0;\n    // - The offset of the EnclosingMethod attribute, or 0.\n    int enclosingMethodOffset = 0;\n    // - The string corresponding to the Signature attribute, or null.\n    String signature = null;\n    // - The string corresponding to the SourceFile attribute, or null.\n    String sourceFile = null;\n    // - The string corresponding to the SourceDebugExtension attribute, or null.\n    String sourceDebugExtension = null;\n    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.\n    int runtimeVisibleAnnotationsOffset = 0;\n    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.\n    int runtimeInvisibleAnnotationsOffset = 0;\n    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.\n    int runtimeVisibleTypeAnnotationsOffset = 0;\n    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.\n    int runtimeInvisibleTypeAnnotationsOffset = 0;\n    // - The offset of the Module attribute, or 0.\n    int moduleOffset = 0;\n    // - The offset of the ModulePackages attribute, or 0.\n    int modulePackagesOffset = 0;\n    // - The string corresponding to the ModuleMainClass attribute, or null.\n    String moduleMainClass = null;\n    // - The string corresponding to the NestHost attribute, or null.\n    String nestHostClass = null;\n    // - The offset of the NestMembers attribute, or 0.\n    int nestMembersOffset = 0;\n    // - The offset of the PermittedSubclasses attribute, or 0\n    int permittedSubclassesOffset = 0;\n    // - The offset of the Record attribute, or 0.\n    int recordOffset = 0;\n    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\n    //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\n    Attribute attributes = null;\n\n    int currentAttributeOffset = getFirstAttributeOffset();\n    for (int i = readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {\n      // Read the attribute_info's attribute_name and attribute_length fields.\n      String attributeName = readUTF8(currentAttributeOffset, charBuffer);\n      int attributeLength = readInt(currentAttributeOffset + 2);\n      currentAttributeOffset += 6;\n      // The tests are sorted in decreasing frequency order (based on frequencies observed on\n      // typical classes).\n      if (Constants.SOURCE_FILE.equals(attributeName)) {\n        sourceFile = readUTF8(currentAttributeOffset, charBuffer);\n      } else if (Constants.INNER_CLASSES.equals(attributeName)) {\n        innerClassesOffset = currentAttributeOffset;\n      } else if (Constants.ENCLOSING_METHOD.equals(attributeName)) {\n        enclosingMethodOffset = currentAttributeOffset;\n      } else if (Constants.NEST_HOST.equals(attributeName)) {\n        nestHostClass = readClass(currentAttributeOffset, charBuffer);\n      } else if (Constants.NEST_MEMBERS.equals(attributeName)) {\n        nestMembersOffset = currentAttributeOffset;\n      } else if (Constants.PERMITTED_SUBCLASSES.equals(attributeName)) {\n        permittedSubclassesOffset = currentAttributeOffset;\n      } else if (Constants.SIGNATURE.equals(attributeName)) {\n        signature = readUTF8(currentAttributeOffset, charBuffer);\n      } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\n        runtimeVisibleAnnotationsOffset = currentAttributeOffset;\n      } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n        runtimeVisibleTypeAnnotationsOffset = currentAttributeOffset;\n      } else if (Constants.DEPRECATED.equals(attributeName)) {\n        accessFlags |= Opcodes.ACC_DEPRECATED;\n      } else if (Constants.SYNTHETIC.equals(attributeName)) {\n        accessFlags |= Opcodes.ACC_SYNTHETIC;\n      } else if (Constants.SOURCE_DEBUG_EXTENSION.equals(attributeName)) {\n        if (attributeLength > classFileBuffer.length - currentAttributeOffset) {\n          throw new IllegalArgumentException();\n        }\n        sourceDebugExtension =\n            readUtf(currentAttributeOffset, attributeLength, new char[attributeLength]);\n      } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\n        runtimeInvisibleAnnotationsOffset = currentAttributeOffset;\n      } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n        runtimeInvisibleTypeAnnotationsOffset = currentAttributeOffset;\n      } else if (Constants.RECORD.equals(attributeName)) {\n        recordOffset = currentAttributeOffset;\n        accessFlags |= Opcodes.ACC_RECORD;\n      } else if (Constants.MODULE.equals(attributeName)) {\n        moduleOffset = currentAttributeOffset;\n      } else if (Constants.MODULE_MAIN_CLASS.equals(attributeName)) {\n        moduleMainClass = readClass(currentAttributeOffset, charBuffer);\n      } else if (Constants.MODULE_PACKAGES.equals(attributeName)) {\n        modulePackagesOffset = currentAttributeOffset;\n      } else if (!Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\n        // The BootstrapMethods attribute is read in the constructor.\n        Attribute attribute =\n            readAttribute(\n                attributePrototypes,\n                attributeName,\n                currentAttributeOffset,\n                attributeLength,\n                charBuffer,\n                -1,\n                null);\n        attribute.nextAttribute = attributes;\n        attributes = attribute;\n      }\n      currentAttributeOffset += attributeLength;\n    }\n\n    // Visit the class declaration. The minor_version and major_version fields start 6 bytes before\n    // the first constant pool entry, which itself starts at cpInfoOffsets[1] - 1 (by definition).\n    classVisitor.visit(\n        readInt(cpInfoOffsets[1] - 7), accessFlags, thisClass, signature, superClass, interfaces);\n\n    // Visit the SourceFile and SourceDebugExtenstion attributes.\n    if ((parsingOptions & SKIP_DEBUG) == 0\n        && (sourceFile != null || sourceDebugExtension != null)) {\n      classVisitor.visitSource(sourceFile, sourceDebugExtension);\n    }\n\n    // Visit the Module, ModulePackages and ModuleMainClass attributes.\n    if (moduleOffset != 0) {\n      readModuleAttributes(\n          classVisitor, context, moduleOffset, modulePackagesOffset, moduleMainClass);\n    }\n\n    // Visit the NestHost attribute.\n    if (nestHostClass != null) {\n      classVisitor.visitNestHost(nestHostClass);\n    }\n\n    // Visit the EnclosingMethod attribute.\n    if (enclosingMethodOffset != 0) {\n      String className = readClass(enclosingMethodOffset, charBuffer);\n      int methodIndex = readUnsignedShort(enclosingMethodOffset + 2);\n      String name = methodIndex == 0 ? null : readUTF8(cpInfoOffsets[methodIndex], charBuffer);\n      String type = methodIndex == 0 ? null : readUTF8(cpInfoOffsets[methodIndex] + 2, charBuffer);\n      classVisitor.visitOuterClass(className, name, type);\n    }\n\n    // Visit the RuntimeVisibleAnnotations attribute.\n    if (runtimeVisibleAnnotationsOffset != 0) {\n      int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\n      int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;\n      while (numAnnotations-- > 0) {\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentAnnotationOffset =\n            readElementValues(\n                classVisitor.visitAnnotation(annotationDescriptor, /* visible= */ true),\n                currentAnnotationOffset,\n                /* named= */ true,\n                charBuffer);\n      }\n    }\n\n    // Visit the RuntimeInvisibleAnnotations attribute.\n    if (runtimeInvisibleAnnotationsOffset != 0) {\n      int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\n      int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;\n      while (numAnnotations-- > 0) {\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentAnnotationOffset =\n            readElementValues(\n                classVisitor.visitAnnotation(annotationDescriptor, /* visible= */ false),\n                currentAnnotationOffset,\n                /* named= */ true,\n                charBuffer);\n      }\n    }\n\n    // Visit the RuntimeVisibleTypeAnnotations attribute.\n    if (runtimeVisibleTypeAnnotationsOffset != 0) {\n      int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\n      int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;\n      while (numAnnotations-- > 0) {\n        // Parse the target_type, target_info and target_path fields.\n        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentAnnotationOffset =\n            readElementValues(\n                classVisitor.visitTypeAnnotation(\n                    context.currentTypeAnnotationTarget,\n                    context.currentTypeAnnotationTargetPath,\n                    annotationDescriptor,\n                    /* visible= */ true),\n                currentAnnotationOffset,\n                /* named= */ true,\n                charBuffer);\n      }\n    }\n\n    // Visit the RuntimeInvisibleTypeAnnotations attribute.\n    if (runtimeInvisibleTypeAnnotationsOffset != 0) {\n      int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\n      int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;\n      while (numAnnotations-- > 0) {\n        // Parse the target_type, target_info and target_path fields.\n        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentAnnotationOffset =\n            readElementValues(\n                classVisitor.visitTypeAnnotation(\n                    context.currentTypeAnnotationTarget,\n                    context.currentTypeAnnotationTargetPath,\n                    annotationDescriptor,\n                    /* visible= */ false),\n                currentAnnotationOffset,\n                /* named= */ true,\n                charBuffer);\n      }\n    }\n\n    // Visit the non standard attributes.\n    while (attributes != null) {\n      // Copy and reset the nextAttribute field so that it can also be used in ClassWriter.\n      Attribute nextAttribute = attributes.nextAttribute;\n      attributes.nextAttribute = null;\n      classVisitor.visitAttribute(attributes);\n      attributes = nextAttribute;\n    }\n\n    // Visit the NestedMembers attribute.\n    if (nestMembersOffset != 0) {\n      int numberOfNestMembers = readUnsignedShort(nestMembersOffset);\n      int currentNestMemberOffset = nestMembersOffset + 2;\n      while (numberOfNestMembers-- > 0) {\n        classVisitor.visitNestMember(readClass(currentNestMemberOffset, charBuffer));\n        currentNestMemberOffset += 2;\n      }\n    }\n\n    // Visit the PermittedSubclasses attribute.\n    if (permittedSubclassesOffset != 0) {\n      int numberOfPermittedSubclasses = readUnsignedShort(permittedSubclassesOffset);\n      int currentPermittedSubclassesOffset = permittedSubclassesOffset + 2;\n      while (numberOfPermittedSubclasses-- > 0) {\n        classVisitor.visitPermittedSubclass(\n            readClass(currentPermittedSubclassesOffset, charBuffer));\n        currentPermittedSubclassesOffset += 2;\n      }\n    }\n\n    // Visit the InnerClasses attribute.\n    if (innerClassesOffset != 0) {\n      int numberOfClasses = readUnsignedShort(innerClassesOffset);\n      int currentClassesOffset = innerClassesOffset + 2;\n      while (numberOfClasses-- > 0) {\n        classVisitor.visitInnerClass(\n            readClass(currentClassesOffset, charBuffer),\n            readClass(currentClassesOffset + 2, charBuffer),\n            readUTF8(currentClassesOffset + 4, charBuffer),\n            readUnsignedShort(currentClassesOffset + 6));\n        currentClassesOffset += 8;\n      }\n    }\n\n    // Visit Record components.\n    if (recordOffset != 0) {\n      int recordComponentsCount = readUnsignedShort(recordOffset);\n      recordOffset += 2;\n      while (recordComponentsCount-- > 0) {\n        recordOffset = readRecordComponent(classVisitor, context, recordOffset);\n      }\n    }\n\n    // Visit the fields and methods.\n    int fieldsCount = readUnsignedShort(currentOffset);\n    currentOffset += 2;\n    while (fieldsCount-- > 0) {\n      currentOffset = readField(classVisitor, context, currentOffset);\n    }\n    int methodsCount = readUnsignedShort(currentOffset);\n    currentOffset += 2;\n    while (methodsCount-- > 0) {\n      currentOffset = readMethod(classVisitor, context, currentOffset);\n    }\n\n    // Visit the end of the class.\n    classVisitor.visitEnd();\n  }\n\n  // ----------------------------------------------------------------------------------------------\n  // Methods to parse modules, fields and methods\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Reads the Module, ModulePackages and ModuleMainClass attributes and visit them.\n   *\n   * @param classVisitor the current class visitor\n   * @param context information about the class being parsed.\n   * @param moduleOffset the offset of the Module attribute (excluding the attribute_info's\n   *     attribute_name_index and attribute_length fields).\n   * @param modulePackagesOffset the offset of the ModulePackages attribute (excluding the\n   *     attribute_info's attribute_name_index and attribute_length fields), or 0.\n   * @param moduleMainClass the string corresponding to the ModuleMainClass attribute, or {@literal\n   *     null}.\n   */\n  private void readModuleAttributes(\n      final ClassVisitor classVisitor,\n      final Context context,\n      final int moduleOffset,\n      final int modulePackagesOffset,\n      final String moduleMainClass) {\n    char[] buffer = context.charBuffer;\n\n    // Read the module_name_index, module_flags and module_version_index fields and visit them.\n    int currentOffset = moduleOffset;\n    String moduleName = readModule(currentOffset, buffer);\n    int moduleFlags = readUnsignedShort(currentOffset + 2);\n    String moduleVersion = readUTF8(currentOffset + 4, buffer);\n    currentOffset += 6;\n    ModuleVisitor moduleVisitor = classVisitor.visitModule(moduleName, moduleFlags, moduleVersion);\n    if (moduleVisitor == null) {\n      return;\n    }\n\n    // Visit the ModuleMainClass attribute.\n    if (moduleMainClass != null) {\n      moduleVisitor.visitMainClass(moduleMainClass);\n    }\n\n    // Visit the ModulePackages attribute.\n    if (modulePackagesOffset != 0) {\n      int packageCount = readUnsignedShort(modulePackagesOffset);\n      int currentPackageOffset = modulePackagesOffset + 2;\n      while (packageCount-- > 0) {\n        moduleVisitor.visitPackage(readPackage(currentPackageOffset, buffer));\n        currentPackageOffset += 2;\n      }\n    }\n\n    // Read the 'requires_count' and 'requires' fields.\n    int requiresCount = readUnsignedShort(currentOffset);\n    currentOffset += 2;\n    while (requiresCount-- > 0) {\n      // Read the requires_index, requires_flags and requires_version fields and visit them.\n      String requires = readModule(currentOffset, buffer);\n      int requiresFlags = readUnsignedShort(currentOffset + 2);\n      String requiresVersion = readUTF8(currentOffset + 4, buffer);\n      currentOffset += 6;\n      moduleVisitor.visitRequire(requires, requiresFlags, requiresVersion);\n    }\n\n    // Read the 'exports_count' and 'exports' fields.\n    int exportsCount = readUnsignedShort(currentOffset);\n    currentOffset += 2;\n    while (exportsCount-- > 0) {\n      // Read the exports_index, exports_flags, exports_to_count and exports_to_index fields\n      // and visit them.\n      String exports = readPackage(currentOffset, buffer);\n      int exportsFlags = readUnsignedShort(currentOffset + 2);\n      int exportsToCount = readUnsignedShort(currentOffset + 4);\n      currentOffset += 6;\n      String[] exportsTo = null;\n      if (exportsToCount != 0) {\n        exportsTo = new String[exportsToCount];\n        for (int i = 0; i < exportsToCount; ++i) {\n          exportsTo[i] = readModule(currentOffset, buffer);\n          currentOffset += 2;\n        }\n      }\n      moduleVisitor.visitExport(exports, exportsFlags, exportsTo);\n    }\n\n    // Reads the 'opens_count' and 'opens' fields.\n    int opensCount = readUnsignedShort(currentOffset);\n    currentOffset += 2;\n    while (opensCount-- > 0) {\n      // Read the opens_index, opens_flags, opens_to_count and opens_to_index fields and visit them.\n      String opens = readPackage(currentOffset, buffer);\n      int opensFlags = readUnsignedShort(currentOffset + 2);\n      int opensToCount = readUnsignedShort(currentOffset + 4);\n      currentOffset += 6;\n      String[] opensTo = null;\n      if (opensToCount != 0) {\n        opensTo = new String[opensToCount];\n        for (int i = 0; i < opensToCount; ++i) {\n          opensTo[i] = readModule(currentOffset, buffer);\n          currentOffset += 2;\n        }\n      }\n      moduleVisitor.visitOpen(opens, opensFlags, opensTo);\n    }\n\n    // Read the 'uses_count' and 'uses' fields.\n    int usesCount = readUnsignedShort(currentOffset);\n    currentOffset += 2;\n    while (usesCount-- > 0) {\n      moduleVisitor.visitUse(readClass(currentOffset, buffer));\n      currentOffset += 2;\n    }\n\n    // Read the 'provides_count' and 'provides' fields.\n    int providesCount = readUnsignedShort(currentOffset);\n    currentOffset += 2;\n    while (providesCount-- > 0) {\n      // Read the provides_index, provides_with_count and provides_with_index fields and visit them.\n      String provides = readClass(currentOffset, buffer);\n      int providesWithCount = readUnsignedShort(currentOffset + 2);\n      currentOffset += 4;\n      String[] providesWith = new String[providesWithCount];\n      for (int i = 0; i < providesWithCount; ++i) {\n        providesWith[i] = readClass(currentOffset, buffer);\n        currentOffset += 2;\n      }\n      moduleVisitor.visitProvide(provides, providesWith);\n    }\n\n    // Visit the end of the module attributes.\n    moduleVisitor.visitEnd();\n  }\n\n  /**\n   * Reads a record component and visit it.\n   *\n   * @param classVisitor the current class visitor\n   * @param context information about the class being parsed.\n   * @param recordComponentOffset the offset of the current record component.\n   * @return the offset of the first byte following the record component.\n   */\n  private int readRecordComponent(\n      final ClassVisitor classVisitor, final Context context, final int recordComponentOffset) {\n    char[] charBuffer = context.charBuffer;\n\n    int currentOffset = recordComponentOffset;\n    String name = readUTF8(currentOffset, charBuffer);\n    String descriptor = readUTF8(currentOffset + 2, charBuffer);\n    currentOffset += 4;\n\n    // Read the record component attributes (the variables are ordered as in Section 4.7 of the\n    // JVMS).\n\n    // Attribute offsets exclude the attribute_name_index and attribute_length fields.\n    // - The string corresponding to the Signature attribute, or null.\n    String signature = null;\n    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.\n    int runtimeVisibleAnnotationsOffset = 0;\n    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.\n    int runtimeInvisibleAnnotationsOffset = 0;\n    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.\n    int runtimeVisibleTypeAnnotationsOffset = 0;\n    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.\n    int runtimeInvisibleTypeAnnotationsOffset = 0;\n    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\n    //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\n    Attribute attributes = null;\n\n    int attributesCount = readUnsignedShort(currentOffset);\n    currentOffset += 2;\n    while (attributesCount-- > 0) {\n      // Read the attribute_info's attribute_name and attribute_length fields.\n      String attributeName = readUTF8(currentOffset, charBuffer);\n      int attributeLength = readInt(currentOffset + 2);\n      currentOffset += 6;\n      // The tests are sorted in decreasing frequency order (based on frequencies observed on\n      // typical classes).\n      if (Constants.SIGNATURE.equals(attributeName)) {\n        signature = readUTF8(currentOffset, charBuffer);\n      } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\n        runtimeVisibleAnnotationsOffset = currentOffset;\n      } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n        runtimeVisibleTypeAnnotationsOffset = currentOffset;\n      } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\n        runtimeInvisibleAnnotationsOffset = currentOffset;\n      } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n        runtimeInvisibleTypeAnnotationsOffset = currentOffset;\n      } else {\n        Attribute attribute =\n            readAttribute(\n                context.attributePrototypes,\n                attributeName,\n                currentOffset,\n                attributeLength,\n                charBuffer,\n                -1,\n                null);\n        attribute.nextAttribute = attributes;\n        attributes = attribute;\n      }\n      currentOffset += attributeLength;\n    }\n\n    RecordComponentVisitor recordComponentVisitor =\n        classVisitor.visitRecordComponent(name, descriptor, signature);\n    if (recordComponentVisitor == null) {\n      return currentOffset;\n    }\n\n    // Visit the RuntimeVisibleAnnotations attribute.\n    if (runtimeVisibleAnnotationsOffset != 0) {\n      int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\n      int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;\n      while (numAnnotations-- > 0) {\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentAnnotationOffset =\n            readElementValues(\n                recordComponentVisitor.visitAnnotation(annotationDescriptor, /* visible= */ true),\n                currentAnnotationOffset,\n                /* named= */ true,\n                charBuffer);\n      }\n    }\n\n    // Visit the RuntimeInvisibleAnnotations attribute.\n    if (runtimeInvisibleAnnotationsOffset != 0) {\n      int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\n      int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;\n      while (numAnnotations-- > 0) {\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentAnnotationOffset =\n            readElementValues(\n                recordComponentVisitor.visitAnnotation(annotationDescriptor, /* visible= */ false),\n                currentAnnotationOffset,\n                /* named= */ true,\n                charBuffer);\n      }\n    }\n\n    // Visit the RuntimeVisibleTypeAnnotations attribute.\n    if (runtimeVisibleTypeAnnotationsOffset != 0) {\n      int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\n      int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;\n      while (numAnnotations-- > 0) {\n        // Parse the target_type, target_info and target_path fields.\n        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentAnnotationOffset =\n            readElementValues(\n                recordComponentVisitor.visitTypeAnnotation(\n                    context.currentTypeAnnotationTarget,\n                    context.currentTypeAnnotationTargetPath,\n                    annotationDescriptor,\n                    /* visible= */ true),\n                currentAnnotationOffset,\n                /* named= */ true,\n                charBuffer);\n      }\n    }\n\n    // Visit the RuntimeInvisibleTypeAnnotations attribute.\n    if (runtimeInvisibleTypeAnnotationsOffset != 0) {\n      int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\n      int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;\n      while (numAnnotations-- > 0) {\n        // Parse the target_type, target_info and target_path fields.\n        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentAnnotationOffset =\n            readElementValues(\n                recordComponentVisitor.visitTypeAnnotation(\n                    context.currentTypeAnnotationTarget,\n                    context.currentTypeAnnotationTargetPath,\n                    annotationDescriptor,\n                    /* visible= */ false),\n                currentAnnotationOffset,\n                /* named= */ true,\n                charBuffer);\n      }\n    }\n\n    // Visit the non standard attributes.\n    while (attributes != null) {\n      // Copy and reset the nextAttribute field so that it can also be used in FieldWriter.\n      Attribute nextAttribute = attributes.nextAttribute;\n      attributes.nextAttribute = null;\n      recordComponentVisitor.visitAttribute(attributes);\n      attributes = nextAttribute;\n    }\n\n    // Visit the end of the field.\n    recordComponentVisitor.visitEnd();\n    return currentOffset;\n  }\n\n  /**\n   * Reads a JVMS field_info structure and makes the given visitor visit it.\n   *\n   * @param classVisitor the visitor that must visit the field.\n   * @param context information about the class being parsed.\n   * @param fieldInfoOffset the start offset of the field_info structure.\n   * @return the offset of the first byte following the field_info structure.\n   */\n  private int readField(\n      final ClassVisitor classVisitor, final Context context, final int fieldInfoOffset) {\n    char[] charBuffer = context.charBuffer;\n\n    // Read the access_flags, name_index and descriptor_index fields.\n    int currentOffset = fieldInfoOffset;\n    int accessFlags = readUnsignedShort(currentOffset);\n    String name = readUTF8(currentOffset + 2, charBuffer);\n    String descriptor = readUTF8(currentOffset + 4, charBuffer);\n    currentOffset += 6;\n\n    // Read the field attributes (the variables are ordered as in Section 4.7 of the JVMS).\n    // Attribute offsets exclude the attribute_name_index and attribute_length fields.\n    // - The value corresponding to the ConstantValue attribute, or null.\n    Object constantValue = null;\n    // - The string corresponding to the Signature attribute, or null.\n    String signature = null;\n    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.\n    int runtimeVisibleAnnotationsOffset = 0;\n    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.\n    int runtimeInvisibleAnnotationsOffset = 0;\n    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.\n    int runtimeVisibleTypeAnnotationsOffset = 0;\n    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.\n    int runtimeInvisibleTypeAnnotationsOffset = 0;\n    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\n    //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\n    Attribute attributes = null;\n\n    int attributesCount = readUnsignedShort(currentOffset);\n    currentOffset += 2;\n    while (attributesCount-- > 0) {\n      // Read the attribute_info's attribute_name and attribute_length fields.\n      String attributeName = readUTF8(currentOffset, charBuffer);\n      int attributeLength = readInt(currentOffset + 2);\n      currentOffset += 6;\n      // The tests are sorted in decreasing frequency order (based on frequencies observed on\n      // typical classes).\n      if (Constants.CONSTANT_VALUE.equals(attributeName)) {\n        int constantvalueIndex = readUnsignedShort(currentOffset);\n        constantValue = constantvalueIndex == 0 ? null : readConst(constantvalueIndex, charBuffer);\n      } else if (Constants.SIGNATURE.equals(attributeName)) {\n        signature = readUTF8(currentOffset, charBuffer);\n      } else if (Constants.DEPRECATED.equals(attributeName)) {\n        accessFlags |= Opcodes.ACC_DEPRECATED;\n      } else if (Constants.SYNTHETIC.equals(attributeName)) {\n        accessFlags |= Opcodes.ACC_SYNTHETIC;\n      } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\n        runtimeVisibleAnnotationsOffset = currentOffset;\n      } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n        runtimeVisibleTypeAnnotationsOffset = currentOffset;\n      } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\n        runtimeInvisibleAnnotationsOffset = currentOffset;\n      } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n        runtimeInvisibleTypeAnnotationsOffset = currentOffset;\n      } else {\n        Attribute attribute =\n            readAttribute(\n                context.attributePrototypes,\n                attributeName,\n                currentOffset,\n                attributeLength,\n                charBuffer,\n                -1,\n                null);\n        attribute.nextAttribute = attributes;\n        attributes = attribute;\n      }\n      currentOffset += attributeLength;\n    }\n\n    // Visit the field declaration.\n    FieldVisitor fieldVisitor =\n        classVisitor.visitField(accessFlags, name, descriptor, signature, constantValue);\n    if (fieldVisitor == null) {\n      return currentOffset;\n    }\n\n    // Visit the RuntimeVisibleAnnotations attribute.\n    if (runtimeVisibleAnnotationsOffset != 0) {\n      int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\n      int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;\n      while (numAnnotations-- > 0) {\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentAnnotationOffset =\n            readElementValues(\n                fieldVisitor.visitAnnotation(annotationDescriptor, /* visible= */ true),\n                currentAnnotationOffset,\n                /* named= */ true,\n                charBuffer);\n      }\n    }\n\n    // Visit the RuntimeInvisibleAnnotations attribute.\n    if (runtimeInvisibleAnnotationsOffset != 0) {\n      int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\n      int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;\n      while (numAnnotations-- > 0) {\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentAnnotationOffset =\n            readElementValues(\n                fieldVisitor.visitAnnotation(annotationDescriptor, /* visible= */ false),\n                currentAnnotationOffset,\n                /* named= */ true,\n                charBuffer);\n      }\n    }\n\n    // Visit the RuntimeVisibleTypeAnnotations attribute.\n    if (runtimeVisibleTypeAnnotationsOffset != 0) {\n      int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\n      int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;\n      while (numAnnotations-- > 0) {\n        // Parse the target_type, target_info and target_path fields.\n        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentAnnotationOffset =\n            readElementValues(\n                fieldVisitor.visitTypeAnnotation(\n                    context.currentTypeAnnotationTarget,\n                    context.currentTypeAnnotationTargetPath,\n                    annotationDescriptor,\n                    /* visible= */ true),\n                currentAnnotationOffset,\n                /* named= */ true,\n                charBuffer);\n      }\n    }\n\n    // Visit the RuntimeInvisibleTypeAnnotations attribute.\n    if (runtimeInvisibleTypeAnnotationsOffset != 0) {\n      int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\n      int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;\n      while (numAnnotations-- > 0) {\n        // Parse the target_type, target_info and target_path fields.\n        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentAnnotationOffset =\n            readElementValues(\n                fieldVisitor.visitTypeAnnotation(\n                    context.currentTypeAnnotationTarget,\n                    context.currentTypeAnnotationTargetPath,\n                    annotationDescriptor,\n                    /* visible= */ false),\n                currentAnnotationOffset,\n                /* named= */ true,\n                charBuffer);\n      }\n    }\n\n    // Visit the non standard attributes.\n    while (attributes != null) {\n      // Copy and reset the nextAttribute field so that it can also be used in FieldWriter.\n      Attribute nextAttribute = attributes.nextAttribute;\n      attributes.nextAttribute = null;\n      fieldVisitor.visitAttribute(attributes);\n      attributes = nextAttribute;\n    }\n\n    // Visit the end of the field.\n    fieldVisitor.visitEnd();\n    return currentOffset;\n  }\n\n  /**\n   * Reads a JVMS method_info structure and makes the given visitor visit it.\n   *\n   * @param classVisitor the visitor that must visit the method.\n   * @param context information about the class being parsed.\n   * @param methodInfoOffset the start offset of the method_info structure.\n   * @return the offset of the first byte following the method_info structure.\n   */\n  private int readMethod(\n      final ClassVisitor classVisitor, final Context context, final int methodInfoOffset) {\n    char[] charBuffer = context.charBuffer;\n\n    // Read the access_flags, name_index and descriptor_index fields.\n    int currentOffset = methodInfoOffset;\n    context.currentMethodAccessFlags = readUnsignedShort(currentOffset);\n    context.currentMethodName = readUTF8(currentOffset + 2, charBuffer);\n    context.currentMethodDescriptor = readUTF8(currentOffset + 4, charBuffer);\n    currentOffset += 6;\n\n    // Read the method attributes (the variables are ordered as in Section 4.7 of the JVMS).\n    // Attribute offsets exclude the attribute_name_index and attribute_length fields.\n    // - The offset of the Code attribute, or 0.\n    int codeOffset = 0;\n    // - The offset of the Exceptions attribute, or 0.\n    int exceptionsOffset = 0;\n    // - The strings corresponding to the Exceptions attribute, or null.\n    String[] exceptions = null;\n    // - Whether the method has a Synthetic attribute.\n    boolean synthetic = false;\n    // - The constant pool index contained in the Signature attribute, or 0.\n    int signatureIndex = 0;\n    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.\n    int runtimeVisibleAnnotationsOffset = 0;\n    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.\n    int runtimeInvisibleAnnotationsOffset = 0;\n    // - The offset of the RuntimeVisibleParameterAnnotations attribute, or 0.\n    int runtimeVisibleParameterAnnotationsOffset = 0;\n    // - The offset of the RuntimeInvisibleParameterAnnotations attribute, or 0.\n    int runtimeInvisibleParameterAnnotationsOffset = 0;\n    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.\n    int runtimeVisibleTypeAnnotationsOffset = 0;\n    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.\n    int runtimeInvisibleTypeAnnotationsOffset = 0;\n    // - The offset of the AnnotationDefault attribute, or 0.\n    int annotationDefaultOffset = 0;\n    // - The offset of the MethodParameters attribute, or 0.\n    int methodParametersOffset = 0;\n    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\n    //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\n    Attribute attributes = null;\n\n    int attributesCount = readUnsignedShort(currentOffset);\n    currentOffset += 2;\n    while (attributesCount-- > 0) {\n      // Read the attribute_info's attribute_name and attribute_length fields.\n      String attributeName = readUTF8(currentOffset, charBuffer);\n      int attributeLength = readInt(currentOffset + 2);\n      currentOffset += 6;\n      // The tests are sorted in decreasing frequency order (based on frequencies observed on\n      // typical classes).\n      if (Constants.CODE.equals(attributeName)) {\n        if ((context.parsingOptions & SKIP_CODE) == 0) {\n          codeOffset = currentOffset;\n        }\n      } else if (Constants.EXCEPTIONS.equals(attributeName)) {\n        exceptionsOffset = currentOffset;\n        exceptions = new String[readUnsignedShort(exceptionsOffset)];\n        int currentExceptionOffset = exceptionsOffset + 2;\n        for (int i = 0; i < exceptions.length; ++i) {\n          exceptions[i] = readClass(currentExceptionOffset, charBuffer);\n          currentExceptionOffset += 2;\n        }\n      } else if (Constants.SIGNATURE.equals(attributeName)) {\n        signatureIndex = readUnsignedShort(currentOffset);\n      } else if (Constants.DEPRECATED.equals(attributeName)) {\n        context.currentMethodAccessFlags |= Opcodes.ACC_DEPRECATED;\n      } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\n        runtimeVisibleAnnotationsOffset = currentOffset;\n      } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n        runtimeVisibleTypeAnnotationsOffset = currentOffset;\n      } else if (Constants.ANNOTATION_DEFAULT.equals(attributeName)) {\n        annotationDefaultOffset = currentOffset;\n      } else if (Constants.SYNTHETIC.equals(attributeName)) {\n        synthetic = true;\n        context.currentMethodAccessFlags |= Opcodes.ACC_SYNTHETIC;\n      } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\n        runtimeInvisibleAnnotationsOffset = currentOffset;\n      } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n        runtimeInvisibleTypeAnnotationsOffset = currentOffset;\n      } else if (Constants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS.equals(attributeName)) {\n        runtimeVisibleParameterAnnotationsOffset = currentOffset;\n      } else if (Constants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS.equals(attributeName)) {\n        runtimeInvisibleParameterAnnotationsOffset = currentOffset;\n      } else if (Constants.METHOD_PARAMETERS.equals(attributeName)) {\n        methodParametersOffset = currentOffset;\n      } else {\n        Attribute attribute =\n            readAttribute(\n                context.attributePrototypes,\n                attributeName,\n                currentOffset,\n                attributeLength,\n                charBuffer,\n                -1,\n                null);\n        attribute.nextAttribute = attributes;\n        attributes = attribute;\n      }\n      currentOffset += attributeLength;\n    }\n\n    // Visit the method declaration.\n    MethodVisitor methodVisitor =\n        classVisitor.visitMethod(\n            context.currentMethodAccessFlags,\n            context.currentMethodName,\n            context.currentMethodDescriptor,\n            signatureIndex == 0 ? null : readUtf(signatureIndex, charBuffer),\n            exceptions);\n    if (methodVisitor == null) {\n      return currentOffset;\n    }\n\n    // If the returned MethodVisitor is in fact a MethodWriter, it means there is no method\n    // adapter between the reader and the writer. In this case, it might be possible to copy\n    // the method attributes directly into the writer. If so, return early without visiting\n    // the content of these attributes.\n    if (methodVisitor instanceof MethodWriter) {\n      MethodWriter methodWriter = (MethodWriter) methodVisitor;\n      if (methodWriter.canCopyMethodAttributes(\n          this,\n          synthetic,\n          (context.currentMethodAccessFlags & Opcodes.ACC_DEPRECATED) != 0,\n          readUnsignedShort(methodInfoOffset + 4),\n          signatureIndex,\n          exceptionsOffset)) {\n        methodWriter.setMethodAttributesSource(methodInfoOffset, currentOffset - methodInfoOffset);\n        return currentOffset;\n      }\n    }\n\n    // Visit the MethodParameters attribute.\n    if (methodParametersOffset != 0 && (context.parsingOptions & SKIP_DEBUG) == 0) {\n      int parametersCount = readByte(methodParametersOffset);\n      int currentParameterOffset = methodParametersOffset + 1;\n      while (parametersCount-- > 0) {\n        // Read the name_index and access_flags fields and visit them.\n        methodVisitor.visitParameter(\n            readUTF8(currentParameterOffset, charBuffer),\n            readUnsignedShort(currentParameterOffset + 2));\n        currentParameterOffset += 4;\n      }\n    }\n\n    // Visit the AnnotationDefault attribute.\n    if (annotationDefaultOffset != 0) {\n      AnnotationVisitor annotationVisitor = methodVisitor.visitAnnotationDefault();\n      readElementValue(annotationVisitor, annotationDefaultOffset, null, charBuffer);\n      if (annotationVisitor != null) {\n        annotationVisitor.visitEnd();\n      }\n    }\n\n    // Visit the RuntimeVisibleAnnotations attribute.\n    if (runtimeVisibleAnnotationsOffset != 0) {\n      int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\n      int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;\n      while (numAnnotations-- > 0) {\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentAnnotationOffset =\n            readElementValues(\n                methodVisitor.visitAnnotation(annotationDescriptor, /* visible= */ true),\n                currentAnnotationOffset,\n                /* named= */ true,\n                charBuffer);\n      }\n    }\n\n    // Visit the RuntimeInvisibleAnnotations attribute.\n    if (runtimeInvisibleAnnotationsOffset != 0) {\n      int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\n      int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;\n      while (numAnnotations-- > 0) {\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentAnnotationOffset =\n            readElementValues(\n                methodVisitor.visitAnnotation(annotationDescriptor, /* visible= */ false),\n                currentAnnotationOffset,\n                /* named= */ true,\n                charBuffer);\n      }\n    }\n\n    // Visit the RuntimeVisibleTypeAnnotations attribute.\n    if (runtimeVisibleTypeAnnotationsOffset != 0) {\n      int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\n      int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;\n      while (numAnnotations-- > 0) {\n        // Parse the target_type, target_info and target_path fields.\n        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentAnnotationOffset =\n            readElementValues(\n                methodVisitor.visitTypeAnnotation(\n                    context.currentTypeAnnotationTarget,\n                    context.currentTypeAnnotationTargetPath,\n                    annotationDescriptor,\n                    /* visible= */ true),\n                currentAnnotationOffset,\n                /* named= */ true,\n                charBuffer);\n      }\n    }\n\n    // Visit the RuntimeInvisibleTypeAnnotations attribute.\n    if (runtimeInvisibleTypeAnnotationsOffset != 0) {\n      int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\n      int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;\n      while (numAnnotations-- > 0) {\n        // Parse the target_type, target_info and target_path fields.\n        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n        currentAnnotationOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentAnnotationOffset =\n            readElementValues(\n                methodVisitor.visitTypeAnnotation(\n                    context.currentTypeAnnotationTarget,\n                    context.currentTypeAnnotationTargetPath,\n                    annotationDescriptor,\n                    /* visible= */ false),\n                currentAnnotationOffset,\n                /* named= */ true,\n                charBuffer);\n      }\n    }\n\n    // Visit the RuntimeVisibleParameterAnnotations attribute.\n    if (runtimeVisibleParameterAnnotationsOffset != 0) {\n      readParameterAnnotations(\n          methodVisitor, context, runtimeVisibleParameterAnnotationsOffset, /* visible= */ true);\n    }\n\n    // Visit the RuntimeInvisibleParameterAnnotations attribute.\n    if (runtimeInvisibleParameterAnnotationsOffset != 0) {\n      readParameterAnnotations(\n          methodVisitor, context, runtimeInvisibleParameterAnnotationsOffset, /* visible= */ false);\n    }\n\n    // Visit the non standard attributes.\n    while (attributes != null) {\n      // Copy and reset the nextAttribute field so that it can also be used in MethodWriter.\n      Attribute nextAttribute = attributes.nextAttribute;\n      attributes.nextAttribute = null;\n      methodVisitor.visitAttribute(attributes);\n      attributes = nextAttribute;\n    }\n\n    // Visit the Code attribute.\n    if (codeOffset != 0) {\n      methodVisitor.visitCode();\n      readCode(methodVisitor, context, codeOffset);\n    }\n\n    // Visit the end of the method.\n    methodVisitor.visitEnd();\n    return currentOffset;\n  }\n\n  // ----------------------------------------------------------------------------------------------\n  // Methods to parse a Code attribute\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Reads a JVMS 'Code' attribute and makes the given visitor visit it.\n   *\n   * @param methodVisitor the visitor that must visit the Code attribute.\n   * @param context information about the class being parsed.\n   * @param codeOffset the start offset in {@link #classFileBuffer} of the Code attribute, excluding\n   *     its attribute_name_index and attribute_length fields.\n   */\n  private void readCode(\n      final MethodVisitor methodVisitor, final Context context, final int codeOffset) {\n    int currentOffset = codeOffset;\n\n    // Read the max_stack, max_locals and code_length fields.\n    final byte[] classBuffer = classFileBuffer;\n    final char[] charBuffer = context.charBuffer;\n    final int maxStack = readUnsignedShort(currentOffset);\n    final int maxLocals = readUnsignedShort(currentOffset + 2);\n    final int codeLength = readInt(currentOffset + 4);\n    currentOffset += 8;\n    if (codeLength > classFileBuffer.length - currentOffset) {\n      throw new IllegalArgumentException();\n    }\n\n    // Read the bytecode 'code' array to create a label for each referenced instruction.\n    final int bytecodeStartOffset = currentOffset;\n    final int bytecodeEndOffset = currentOffset + codeLength;\n    final Label[] labels = context.currentMethodLabels = new Label[codeLength + 1];\n    while (currentOffset < bytecodeEndOffset) {\n      final int bytecodeOffset = currentOffset - bytecodeStartOffset;\n      final int opcode = classBuffer[currentOffset] & 0xFF;\n      switch (opcode) {\n        case Opcodes.NOP:\n        case Opcodes.ACONST_NULL:\n        case Opcodes.ICONST_M1:\n        case Opcodes.ICONST_0:\n        case Opcodes.ICONST_1:\n        case Opcodes.ICONST_2:\n        case Opcodes.ICONST_3:\n        case Opcodes.ICONST_4:\n        case Opcodes.ICONST_5:\n        case Opcodes.LCONST_0:\n        case Opcodes.LCONST_1:\n        case Opcodes.FCONST_0:\n        case Opcodes.FCONST_1:\n        case Opcodes.FCONST_2:\n        case Opcodes.DCONST_0:\n        case Opcodes.DCONST_1:\n        case Opcodes.IALOAD:\n        case Opcodes.LALOAD:\n        case Opcodes.FALOAD:\n        case Opcodes.DALOAD:\n        case Opcodes.AALOAD:\n        case Opcodes.BALOAD:\n        case Opcodes.CALOAD:\n        case Opcodes.SALOAD:\n        case Opcodes.IASTORE:\n        case Opcodes.LASTORE:\n        case Opcodes.FASTORE:\n        case Opcodes.DASTORE:\n        case Opcodes.AASTORE:\n        case Opcodes.BASTORE:\n        case Opcodes.CASTORE:\n        case Opcodes.SASTORE:\n        case Opcodes.POP:\n        case Opcodes.POP2:\n        case Opcodes.DUP:\n        case Opcodes.DUP_X1:\n        case Opcodes.DUP_X2:\n        case Opcodes.DUP2:\n        case Opcodes.DUP2_X1:\n        case Opcodes.DUP2_X2:\n        case Opcodes.SWAP:\n        case Opcodes.IADD:\n        case Opcodes.LADD:\n        case Opcodes.FADD:\n        case Opcodes.DADD:\n        case Opcodes.ISUB:\n        case Opcodes.LSUB:\n        case Opcodes.FSUB:\n        case Opcodes.DSUB:\n        case Opcodes.IMUL:\n        case Opcodes.LMUL:\n        case Opcodes.FMUL:\n        case Opcodes.DMUL:\n        case Opcodes.IDIV:\n        case Opcodes.LDIV:\n        case Opcodes.FDIV:\n        case Opcodes.DDIV:\n        case Opcodes.IREM:\n        case Opcodes.LREM:\n        case Opcodes.FREM:\n        case Opcodes.DREM:\n        case Opcodes.INEG:\n        case Opcodes.LNEG:\n        case Opcodes.FNEG:\n        case Opcodes.DNEG:\n        case Opcodes.ISHL:\n        case Opcodes.LSHL:\n        case Opcodes.ISHR:\n        case Opcodes.LSHR:\n        case Opcodes.IUSHR:\n        case Opcodes.LUSHR:\n        case Opcodes.IAND:\n        case Opcodes.LAND:\n        case Opcodes.IOR:\n        case Opcodes.LOR:\n        case Opcodes.IXOR:\n        case Opcodes.LXOR:\n        case Opcodes.I2L:\n        case Opcodes.I2F:\n        case Opcodes.I2D:\n        case Opcodes.L2I:\n        case Opcodes.L2F:\n        case Opcodes.L2D:\n        case Opcodes.F2I:\n        case Opcodes.F2L:\n        case Opcodes.F2D:\n        case Opcodes.D2I:\n        case Opcodes.D2L:\n        case Opcodes.D2F:\n        case Opcodes.I2B:\n        case Opcodes.I2C:\n        case Opcodes.I2S:\n        case Opcodes.LCMP:\n        case Opcodes.FCMPL:\n        case Opcodes.FCMPG:\n        case Opcodes.DCMPL:\n        case Opcodes.DCMPG:\n        case Opcodes.IRETURN:\n        case Opcodes.LRETURN:\n        case Opcodes.FRETURN:\n        case Opcodes.DRETURN:\n        case Opcodes.ARETURN:\n        case Opcodes.RETURN:\n        case Opcodes.ARRAYLENGTH:\n        case Opcodes.ATHROW:\n        case Opcodes.MONITORENTER:\n        case Opcodes.MONITOREXIT:\n        case Constants.ILOAD_0:\n        case Constants.ILOAD_1:\n        case Constants.ILOAD_2:\n        case Constants.ILOAD_3:\n        case Constants.LLOAD_0:\n        case Constants.LLOAD_1:\n        case Constants.LLOAD_2:\n        case Constants.LLOAD_3:\n        case Constants.FLOAD_0:\n        case Constants.FLOAD_1:\n        case Constants.FLOAD_2:\n        case Constants.FLOAD_3:\n        case Constants.DLOAD_0:\n        case Constants.DLOAD_1:\n        case Constants.DLOAD_2:\n        case Constants.DLOAD_3:\n        case Constants.ALOAD_0:\n        case Constants.ALOAD_1:\n        case Constants.ALOAD_2:\n        case Constants.ALOAD_3:\n        case Constants.ISTORE_0:\n        case Constants.ISTORE_1:\n        case Constants.ISTORE_2:\n        case Constants.ISTORE_3:\n        case Constants.LSTORE_0:\n        case Constants.LSTORE_1:\n        case Constants.LSTORE_2:\n        case Constants.LSTORE_3:\n        case Constants.FSTORE_0:\n        case Constants.FSTORE_1:\n        case Constants.FSTORE_2:\n        case Constants.FSTORE_3:\n        case Constants.DSTORE_0:\n        case Constants.DSTORE_1:\n        case Constants.DSTORE_2:\n        case Constants.DSTORE_3:\n        case Constants.ASTORE_0:\n        case Constants.ASTORE_1:\n        case Constants.ASTORE_2:\n        case Constants.ASTORE_3:\n          currentOffset += 1;\n          break;\n        case Opcodes.IFEQ:\n        case Opcodes.IFNE:\n        case Opcodes.IFLT:\n        case Opcodes.IFGE:\n        case Opcodes.IFGT:\n        case Opcodes.IFLE:\n        case Opcodes.IF_ICMPEQ:\n        case Opcodes.IF_ICMPNE:\n        case Opcodes.IF_ICMPLT:\n        case Opcodes.IF_ICMPGE:\n        case Opcodes.IF_ICMPGT:\n        case Opcodes.IF_ICMPLE:\n        case Opcodes.IF_ACMPEQ:\n        case Opcodes.IF_ACMPNE:\n        case Opcodes.GOTO:\n        case Opcodes.JSR:\n        case Opcodes.IFNULL:\n        case Opcodes.IFNONNULL:\n          createLabel(bytecodeOffset + readShort(currentOffset + 1), labels);\n          currentOffset += 3;\n          break;\n        case Constants.ASM_IFEQ:\n        case Constants.ASM_IFNE:\n        case Constants.ASM_IFLT:\n        case Constants.ASM_IFGE:\n        case Constants.ASM_IFGT:\n        case Constants.ASM_IFLE:\n        case Constants.ASM_IF_ICMPEQ:\n        case Constants.ASM_IF_ICMPNE:\n        case Constants.ASM_IF_ICMPLT:\n        case Constants.ASM_IF_ICMPGE:\n        case Constants.ASM_IF_ICMPGT:\n        case Constants.ASM_IF_ICMPLE:\n        case Constants.ASM_IF_ACMPEQ:\n        case Constants.ASM_IF_ACMPNE:\n        case Constants.ASM_GOTO:\n        case Constants.ASM_JSR:\n        case Constants.ASM_IFNULL:\n        case Constants.ASM_IFNONNULL:\n          createLabel(bytecodeOffset + readUnsignedShort(currentOffset + 1), labels);\n          currentOffset += 3;\n          break;\n        case Constants.GOTO_W:\n        case Constants.JSR_W:\n        case Constants.ASM_GOTO_W:\n          createLabel(bytecodeOffset + readInt(currentOffset + 1), labels);\n          currentOffset += 5;\n          break;\n        case Constants.WIDE:\n          switch (classBuffer[currentOffset + 1] & 0xFF) {\n            case Opcodes.ILOAD:\n            case Opcodes.FLOAD:\n            case Opcodes.ALOAD:\n            case Opcodes.LLOAD:\n            case Opcodes.DLOAD:\n            case Opcodes.ISTORE:\n            case Opcodes.FSTORE:\n            case Opcodes.ASTORE:\n            case Opcodes.LSTORE:\n            case Opcodes.DSTORE:\n            case Opcodes.RET:\n              currentOffset += 4;\n              break;\n            case Opcodes.IINC:\n              currentOffset += 6;\n              break;\n            default:\n              throw new IllegalArgumentException();\n          }\n          break;\n        case Opcodes.TABLESWITCH:\n          // Skip 0 to 3 padding bytes.\n          currentOffset += 4 - (bytecodeOffset & 3);\n          // Read the default label and the number of table entries.\n          createLabel(bytecodeOffset + readInt(currentOffset), labels);\n          int numTableEntries = readInt(currentOffset + 8) - readInt(currentOffset + 4) + 1;\n          currentOffset += 12;\n          // Read the table labels.\n          while (numTableEntries-- > 0) {\n            createLabel(bytecodeOffset + readInt(currentOffset), labels);\n            currentOffset += 4;\n          }\n          break;\n        case Opcodes.LOOKUPSWITCH:\n          // Skip 0 to 3 padding bytes.\n          currentOffset += 4 - (bytecodeOffset & 3);\n          // Read the default label and the number of switch cases.\n          createLabel(bytecodeOffset + readInt(currentOffset), labels);\n          int numSwitchCases = readInt(currentOffset + 4);\n          currentOffset += 8;\n          // Read the switch labels.\n          while (numSwitchCases-- > 0) {\n            createLabel(bytecodeOffset + readInt(currentOffset + 4), labels);\n            currentOffset += 8;\n          }\n          break;\n        case Opcodes.ILOAD:\n        case Opcodes.LLOAD:\n        case Opcodes.FLOAD:\n        case Opcodes.DLOAD:\n        case Opcodes.ALOAD:\n        case Opcodes.ISTORE:\n        case Opcodes.LSTORE:\n        case Opcodes.FSTORE:\n        case Opcodes.DSTORE:\n        case Opcodes.ASTORE:\n        case Opcodes.RET:\n        case Opcodes.BIPUSH:\n        case Opcodes.NEWARRAY:\n        case Opcodes.LDC:\n          currentOffset += 2;\n          break;\n        case Opcodes.SIPUSH:\n        case Constants.LDC_W:\n        case Constants.LDC2_W:\n        case Opcodes.GETSTATIC:\n        case Opcodes.PUTSTATIC:\n        case Opcodes.GETFIELD:\n        case Opcodes.PUTFIELD:\n        case Opcodes.INVOKEVIRTUAL:\n        case Opcodes.INVOKESPECIAL:\n        case Opcodes.INVOKESTATIC:\n        case Opcodes.NEW:\n        case Opcodes.ANEWARRAY:\n        case Opcodes.CHECKCAST:\n        case Opcodes.INSTANCEOF:\n        case Opcodes.IINC:\n          currentOffset += 3;\n          break;\n        case Opcodes.INVOKEINTERFACE:\n        case Opcodes.INVOKEDYNAMIC:\n          currentOffset += 5;\n          break;\n        case Opcodes.MULTIANEWARRAY:\n          currentOffset += 4;\n          break;\n        default:\n          throw new IllegalArgumentException();\n      }\n    }\n\n    // Read the 'exception_table_length' and 'exception_table' field to create a label for each\n    // referenced instruction, and to make methodVisitor visit the corresponding try catch blocks.\n    int exceptionTableLength = readUnsignedShort(currentOffset);\n    currentOffset += 2;\n    while (exceptionTableLength-- > 0) {\n      Label start = createLabel(readUnsignedShort(currentOffset), labels);\n      Label end = createLabel(readUnsignedShort(currentOffset + 2), labels);\n      Label handler = createLabel(readUnsignedShort(currentOffset + 4), labels);\n      String catchType = readUTF8(cpInfoOffsets[readUnsignedShort(currentOffset + 6)], charBuffer);\n      currentOffset += 8;\n      methodVisitor.visitTryCatchBlock(start, end, handler, catchType);\n    }\n\n    // Read the Code attributes to create a label for each referenced instruction (the variables\n    // are ordered as in Section 4.7 of the JVMS). Attribute offsets exclude the\n    // attribute_name_index and attribute_length fields.\n    // - The offset of the current 'stack_map_frame' in the StackMap[Table] attribute, or 0.\n    // Initially, this is the offset of the first 'stack_map_frame' entry. Then this offset is\n    // updated after each stack_map_frame is read.\n    int stackMapFrameOffset = 0;\n    // - The end offset of the StackMap[Table] attribute, or 0.\n    int stackMapTableEndOffset = 0;\n    // - Whether the stack map frames are compressed (i.e. in a StackMapTable) or not.\n    boolean compressedFrames = true;\n    // - The offset of the LocalVariableTable attribute, or 0.\n    int localVariableTableOffset = 0;\n    // - The offset of the LocalVariableTypeTable attribute, or 0.\n    int localVariableTypeTableOffset = 0;\n    // - The offset of each 'type_annotation' entry in the RuntimeVisibleTypeAnnotations\n    // attribute, or null.\n    int[] visibleTypeAnnotationOffsets = null;\n    // - The offset of each 'type_annotation' entry in the RuntimeInvisibleTypeAnnotations\n    // attribute, or null.\n    int[] invisibleTypeAnnotationOffsets = null;\n    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\n    //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\n    Attribute attributes = null;\n\n    int attributesCount = readUnsignedShort(currentOffset);\n    currentOffset += 2;\n    while (attributesCount-- > 0) {\n      // Read the attribute_info's attribute_name and attribute_length fields.\n      String attributeName = readUTF8(currentOffset, charBuffer);\n      int attributeLength = readInt(currentOffset + 2);\n      currentOffset += 6;\n      if (Constants.LOCAL_VARIABLE_TABLE.equals(attributeName)) {\n        if ((context.parsingOptions & SKIP_DEBUG) == 0) {\n          localVariableTableOffset = currentOffset;\n          // Parse the attribute to find the corresponding (debug only) labels.\n          int currentLocalVariableTableOffset = currentOffset;\n          int localVariableTableLength = readUnsignedShort(currentLocalVariableTableOffset);\n          currentLocalVariableTableOffset += 2;\n          while (localVariableTableLength-- > 0) {\n            int startPc = readUnsignedShort(currentLocalVariableTableOffset);\n            createDebugLabel(startPc, labels);\n            int length = readUnsignedShort(currentLocalVariableTableOffset + 2);\n            createDebugLabel(startPc + length, labels);\n            // Skip the name_index, descriptor_index and index fields (2 bytes each).\n            currentLocalVariableTableOffset += 10;\n          }\n        }\n      } else if (Constants.LOCAL_VARIABLE_TYPE_TABLE.equals(attributeName)) {\n        localVariableTypeTableOffset = currentOffset;\n        // Here we do not extract the labels corresponding to the attribute content. We assume they\n        // are the same or a subset of those of the LocalVariableTable attribute.\n      } else if (Constants.LINE_NUMBER_TABLE.equals(attributeName)) {\n        if ((context.parsingOptions & SKIP_DEBUG) == 0) {\n          // Parse the attribute to find the corresponding (debug only) labels.\n          int currentLineNumberTableOffset = currentOffset;\n          int lineNumberTableLength = readUnsignedShort(currentLineNumberTableOffset);\n          currentLineNumberTableOffset += 2;\n          while (lineNumberTableLength-- > 0) {\n            int startPc = readUnsignedShort(currentLineNumberTableOffset);\n            int lineNumber = readUnsignedShort(currentLineNumberTableOffset + 2);\n            currentLineNumberTableOffset += 4;\n            createDebugLabel(startPc, labels);\n            labels[startPc].addLineNumber(lineNumber);\n          }\n        }\n      } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n        visibleTypeAnnotationOffsets =\n            readTypeAnnotations(methodVisitor, context, currentOffset, /* visible= */ true);\n        // Here we do not extract the labels corresponding to the attribute content. This would\n        // require a full parsing of the attribute, which would need to be repeated when parsing\n        // the bytecode instructions (see below). Instead, the content of the attribute is read one\n        // type annotation at a time (i.e. after a type annotation has been visited, the next type\n        // annotation is read), and the labels it contains are also extracted one annotation at a\n        // time. This assumes that type annotations are ordered by increasing bytecode offset.\n      } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\n        invisibleTypeAnnotationOffsets =\n            readTypeAnnotations(methodVisitor, context, currentOffset, /* visible= */ false);\n        // Same comment as above for the RuntimeVisibleTypeAnnotations attribute.\n      } else if (Constants.STACK_MAP_TABLE.equals(attributeName)) {\n        if ((context.parsingOptions & SKIP_FRAMES) == 0) {\n          stackMapFrameOffset = currentOffset + 2;\n          stackMapTableEndOffset = currentOffset + attributeLength;\n        }\n        // Here we do not extract the labels corresponding to the attribute content. This would\n        // require a full parsing of the attribute, which would need to be repeated when parsing\n        // the bytecode instructions (see below). Instead, the content of the attribute is read one\n        // frame at a time (i.e. after a frame has been visited, the next frame is read), and the\n        // labels it contains are also extracted one frame at a time. Thanks to the ordering of\n        // frames, having only a \"one frame lookahead\" is not a problem, i.e. it is not possible to\n        // see an offset smaller than the offset of the current instruction and for which no Label\n        // exist. Except for UNINITIALIZED type offsets. We solve this by parsing the stack map\n        // table without a full decoding (see below).\n      } else if (\"StackMap\".equals(attributeName)) {\n        if ((context.parsingOptions & SKIP_FRAMES) == 0) {\n          stackMapFrameOffset = currentOffset + 2;\n          stackMapTableEndOffset = currentOffset + attributeLength;\n          compressedFrames = false;\n        }\n        // IMPORTANT! Here we assume that the frames are ordered, as in the StackMapTable attribute,\n        // although this is not guaranteed by the attribute format. This allows an incremental\n        // extraction of the labels corresponding to this attribute (see the comment above for the\n        // StackMapTable attribute).\n      } else {\n        Attribute attribute =\n            readAttribute(\n                context.attributePrototypes,\n                attributeName,\n                currentOffset,\n                attributeLength,\n                charBuffer,\n                codeOffset,\n                labels);\n        attribute.nextAttribute = attributes;\n        attributes = attribute;\n      }\n      currentOffset += attributeLength;\n    }\n\n    // Initialize the context fields related to stack map frames, and generate the first\n    // (implicit) stack map frame, if needed.\n    final boolean expandFrames = (context.parsingOptions & EXPAND_FRAMES) != 0;\n    if (stackMapFrameOffset != 0) {\n      // The bytecode offset of the first explicit frame is not offset_delta + 1 but only\n      // offset_delta. Setting the implicit frame offset to -1 allows us to use of the\n      // \"offset_delta + 1\" rule in all cases.\n      context.currentFrameOffset = -1;\n      context.currentFrameType = 0;\n      context.currentFrameLocalCount = 0;\n      context.currentFrameLocalCountDelta = 0;\n      context.currentFrameLocalTypes = new Object[maxLocals];\n      context.currentFrameStackCount = 0;\n      context.currentFrameStackTypes = new Object[maxStack];\n      if (expandFrames) {\n        computeImplicitFrame(context);\n      }\n      // Find the labels for UNINITIALIZED frame types. Instead of decoding each element of the\n      // stack map table, we look for 3 consecutive bytes that \"look like\" an UNINITIALIZED type\n      // (tag ITEM_Uninitialized, offset within bytecode bounds, NEW instruction at this offset).\n      // We may find false positives (i.e. not real UNINITIALIZED types), but this should be rare,\n      // and the only consequence will be the creation of an unneeded label. This is better than\n      // creating a label for each NEW instruction, and faster than fully decoding the whole stack\n      // map table.\n      for (int offset = stackMapFrameOffset; offset < stackMapTableEndOffset - 2; ++offset) {\n        if (classBuffer[offset] == Frame.ITEM_UNINITIALIZED) {\n          int potentialBytecodeOffset = readUnsignedShort(offset + 1);\n          if (potentialBytecodeOffset >= 0\n              && potentialBytecodeOffset < codeLength\n              && (classBuffer[bytecodeStartOffset + potentialBytecodeOffset] & 0xFF)\n                  == Opcodes.NEW) {\n            createLabel(potentialBytecodeOffset, labels);\n          }\n        }\n      }\n    }\n    if (expandFrames && (context.parsingOptions & EXPAND_ASM_INSNS) != 0) {\n      // Expanding the ASM specific instructions can introduce F_INSERT frames, even if the method\n      // does not currently have any frame. These inserted frames must be computed by simulating the\n      // effect of the bytecode instructions, one by one, starting from the implicit first frame.\n      // For this, MethodWriter needs to know maxLocals before the first instruction is visited. To\n      // ensure this, we visit the implicit first frame here (passing only maxLocals - the rest is\n      // computed in MethodWriter).\n      methodVisitor.visitFrame(Opcodes.F_NEW, maxLocals, null, 0, null);\n    }\n\n    // Visit the bytecode instructions. First, introduce state variables for the incremental parsing\n    // of the type annotations.\n\n    // Index of the next runtime visible type annotation to read (in the\n    // visibleTypeAnnotationOffsets array).\n    int currentVisibleTypeAnnotationIndex = 0;\n    // The bytecode offset of the next runtime visible type annotation to read, or -1.\n    int currentVisibleTypeAnnotationBytecodeOffset =\n        getTypeAnnotationBytecodeOffset(visibleTypeAnnotationOffsets, 0);\n    // Index of the next runtime invisible type annotation to read (in the\n    // invisibleTypeAnnotationOffsets array).\n    int currentInvisibleTypeAnnotationIndex = 0;\n    // The bytecode offset of the next runtime invisible type annotation to read, or -1.\n    int currentInvisibleTypeAnnotationBytecodeOffset =\n        getTypeAnnotationBytecodeOffset(invisibleTypeAnnotationOffsets, 0);\n\n    // Whether a F_INSERT stack map frame must be inserted before the current instruction.\n    boolean insertFrame = false;\n\n    // The delta to subtract from a goto_w or jsr_w opcode to get the corresponding goto or jsr\n    // opcode, or 0 if goto_w and jsr_w must be left unchanged (i.e. when expanding ASM specific\n    // instructions).\n    final int wideJumpOpcodeDelta =\n        (context.parsingOptions & EXPAND_ASM_INSNS) == 0 ? Constants.WIDE_JUMP_OPCODE_DELTA : 0;\n\n    currentOffset = bytecodeStartOffset;\n    while (currentOffset < bytecodeEndOffset) {\n      final int currentBytecodeOffset = currentOffset - bytecodeStartOffset;\n      readBytecodeInstructionOffset(currentBytecodeOffset);\n\n      // Visit the label and the line number(s) for this bytecode offset, if any.\n      Label currentLabel = labels[currentBytecodeOffset];\n      if (currentLabel != null) {\n        currentLabel.accept(methodVisitor, (context.parsingOptions & SKIP_DEBUG) == 0);\n      }\n\n      // Visit the stack map frame for this bytecode offset, if any.\n      while (stackMapFrameOffset != 0\n          && (context.currentFrameOffset == currentBytecodeOffset\n              || context.currentFrameOffset == -1)) {\n        // If there is a stack map frame for this offset, make methodVisitor visit it, and read the\n        // next stack map frame if there is one.\n        if (context.currentFrameOffset != -1) {\n          if (!compressedFrames || expandFrames) {\n            methodVisitor.visitFrame(\n                Opcodes.F_NEW,\n                context.currentFrameLocalCount,\n                context.currentFrameLocalTypes,\n                context.currentFrameStackCount,\n                context.currentFrameStackTypes);\n          } else {\n            methodVisitor.visitFrame(\n                context.currentFrameType,\n                context.currentFrameLocalCountDelta,\n                context.currentFrameLocalTypes,\n                context.currentFrameStackCount,\n                context.currentFrameStackTypes);\n          }\n          // Since there is already a stack map frame for this bytecode offset, there is no need to\n          // insert a new one.\n          insertFrame = false;\n        }\n        if (stackMapFrameOffset < stackMapTableEndOffset) {\n          stackMapFrameOffset =\n              readStackMapFrame(stackMapFrameOffset, compressedFrames, expandFrames, context);\n        } else {\n          stackMapFrameOffset = 0;\n        }\n      }\n\n      // Insert a stack map frame for this bytecode offset, if requested by setting insertFrame to\n      // true during the previous iteration. The actual frame content is computed in MethodWriter.\n      if (insertFrame) {\n        if ((context.parsingOptions & EXPAND_FRAMES) != 0) {\n          methodVisitor.visitFrame(Constants.F_INSERT, 0, null, 0, null);\n        }\n        insertFrame = false;\n      }\n\n      // Visit the instruction at this bytecode offset.\n      int opcode = classBuffer[currentOffset] & 0xFF;\n      switch (opcode) {\n        case Opcodes.NOP:\n        case Opcodes.ACONST_NULL:\n        case Opcodes.ICONST_M1:\n        case Opcodes.ICONST_0:\n        case Opcodes.ICONST_1:\n        case Opcodes.ICONST_2:\n        case Opcodes.ICONST_3:\n        case Opcodes.ICONST_4:\n        case Opcodes.ICONST_5:\n        case Opcodes.LCONST_0:\n        case Opcodes.LCONST_1:\n        case Opcodes.FCONST_0:\n        case Opcodes.FCONST_1:\n        case Opcodes.FCONST_2:\n        case Opcodes.DCONST_0:\n        case Opcodes.DCONST_1:\n        case Opcodes.IALOAD:\n        case Opcodes.LALOAD:\n        case Opcodes.FALOAD:\n        case Opcodes.DALOAD:\n        case Opcodes.AALOAD:\n        case Opcodes.BALOAD:\n        case Opcodes.CALOAD:\n        case Opcodes.SALOAD:\n        case Opcodes.IASTORE:\n        case Opcodes.LASTORE:\n        case Opcodes.FASTORE:\n        case Opcodes.DASTORE:\n        case Opcodes.AASTORE:\n        case Opcodes.BASTORE:\n        case Opcodes.CASTORE:\n        case Opcodes.SASTORE:\n        case Opcodes.POP:\n        case Opcodes.POP2:\n        case Opcodes.DUP:\n        case Opcodes.DUP_X1:\n        case Opcodes.DUP_X2:\n        case Opcodes.DUP2:\n        case Opcodes.DUP2_X1:\n        case Opcodes.DUP2_X2:\n        case Opcodes.SWAP:\n        case Opcodes.IADD:\n        case Opcodes.LADD:\n        case Opcodes.FADD:\n        case Opcodes.DADD:\n        case Opcodes.ISUB:\n        case Opcodes.LSUB:\n        case Opcodes.FSUB:\n        case Opcodes.DSUB:\n        case Opcodes.IMUL:\n        case Opcodes.LMUL:\n        case Opcodes.FMUL:\n        case Opcodes.DMUL:\n        case Opcodes.IDIV:\n        case Opcodes.LDIV:\n        case Opcodes.FDIV:\n        case Opcodes.DDIV:\n        case Opcodes.IREM:\n        case Opcodes.LREM:\n        case Opcodes.FREM:\n        case Opcodes.DREM:\n        case Opcodes.INEG:\n        case Opcodes.LNEG:\n        case Opcodes.FNEG:\n        case Opcodes.DNEG:\n        case Opcodes.ISHL:\n        case Opcodes.LSHL:\n        case Opcodes.ISHR:\n        case Opcodes.LSHR:\n        case Opcodes.IUSHR:\n        case Opcodes.LUSHR:\n        case Opcodes.IAND:\n        case Opcodes.LAND:\n        case Opcodes.IOR:\n        case Opcodes.LOR:\n        case Opcodes.IXOR:\n        case Opcodes.LXOR:\n        case Opcodes.I2L:\n        case Opcodes.I2F:\n        case Opcodes.I2D:\n        case Opcodes.L2I:\n        case Opcodes.L2F:\n        case Opcodes.L2D:\n        case Opcodes.F2I:\n        case Opcodes.F2L:\n        case Opcodes.F2D:\n        case Opcodes.D2I:\n        case Opcodes.D2L:\n        case Opcodes.D2F:\n        case Opcodes.I2B:\n        case Opcodes.I2C:\n        case Opcodes.I2S:\n        case Opcodes.LCMP:\n        case Opcodes.FCMPL:\n        case Opcodes.FCMPG:\n        case Opcodes.DCMPL:\n        case Opcodes.DCMPG:\n        case Opcodes.IRETURN:\n        case Opcodes.LRETURN:\n        case Opcodes.FRETURN:\n        case Opcodes.DRETURN:\n        case Opcodes.ARETURN:\n        case Opcodes.RETURN:\n        case Opcodes.ARRAYLENGTH:\n        case Opcodes.ATHROW:\n        case Opcodes.MONITORENTER:\n        case Opcodes.MONITOREXIT:\n          methodVisitor.visitInsn(opcode);\n          currentOffset += 1;\n          break;\n        case Constants.ILOAD_0:\n        case Constants.ILOAD_1:\n        case Constants.ILOAD_2:\n        case Constants.ILOAD_3:\n        case Constants.LLOAD_0:\n        case Constants.LLOAD_1:\n        case Constants.LLOAD_2:\n        case Constants.LLOAD_3:\n        case Constants.FLOAD_0:\n        case Constants.FLOAD_1:\n        case Constants.FLOAD_2:\n        case Constants.FLOAD_3:\n        case Constants.DLOAD_0:\n        case Constants.DLOAD_1:\n        case Constants.DLOAD_2:\n        case Constants.DLOAD_3:\n        case Constants.ALOAD_0:\n        case Constants.ALOAD_1:\n        case Constants.ALOAD_2:\n        case Constants.ALOAD_3:\n          opcode -= Constants.ILOAD_0;\n          methodVisitor.visitVarInsn(Opcodes.ILOAD + (opcode >> 2), opcode & 0x3);\n          currentOffset += 1;\n          break;\n        case Constants.ISTORE_0:\n        case Constants.ISTORE_1:\n        case Constants.ISTORE_2:\n        case Constants.ISTORE_3:\n        case Constants.LSTORE_0:\n        case Constants.LSTORE_1:\n        case Constants.LSTORE_2:\n        case Constants.LSTORE_3:\n        case Constants.FSTORE_0:\n        case Constants.FSTORE_1:\n        case Constants.FSTORE_2:\n        case Constants.FSTORE_3:\n        case Constants.DSTORE_0:\n        case Constants.DSTORE_1:\n        case Constants.DSTORE_2:\n        case Constants.DSTORE_3:\n        case Constants.ASTORE_0:\n        case Constants.ASTORE_1:\n        case Constants.ASTORE_2:\n        case Constants.ASTORE_3:\n          opcode -= Constants.ISTORE_0;\n          methodVisitor.visitVarInsn(Opcodes.ISTORE + (opcode >> 2), opcode & 0x3);\n          currentOffset += 1;\n          break;\n        case Opcodes.IFEQ:\n        case Opcodes.IFNE:\n        case Opcodes.IFLT:\n        case Opcodes.IFGE:\n        case Opcodes.IFGT:\n        case Opcodes.IFLE:\n        case Opcodes.IF_ICMPEQ:\n        case Opcodes.IF_ICMPNE:\n        case Opcodes.IF_ICMPLT:\n        case Opcodes.IF_ICMPGE:\n        case Opcodes.IF_ICMPGT:\n        case Opcodes.IF_ICMPLE:\n        case Opcodes.IF_ACMPEQ:\n        case Opcodes.IF_ACMPNE:\n        case Opcodes.GOTO:\n        case Opcodes.JSR:\n        case Opcodes.IFNULL:\n        case Opcodes.IFNONNULL:\n          methodVisitor.visitJumpInsn(\n              opcode, labels[currentBytecodeOffset + readShort(currentOffset + 1)]);\n          currentOffset += 3;\n          break;\n        case Constants.GOTO_W:\n        case Constants.JSR_W:\n          methodVisitor.visitJumpInsn(\n              opcode - wideJumpOpcodeDelta,\n              labels[currentBytecodeOffset + readInt(currentOffset + 1)]);\n          currentOffset += 5;\n          break;\n        case Constants.ASM_IFEQ:\n        case Constants.ASM_IFNE:\n        case Constants.ASM_IFLT:\n        case Constants.ASM_IFGE:\n        case Constants.ASM_IFGT:\n        case Constants.ASM_IFLE:\n        case Constants.ASM_IF_ICMPEQ:\n        case Constants.ASM_IF_ICMPNE:\n        case Constants.ASM_IF_ICMPLT:\n        case Constants.ASM_IF_ICMPGE:\n        case Constants.ASM_IF_ICMPGT:\n        case Constants.ASM_IF_ICMPLE:\n        case Constants.ASM_IF_ACMPEQ:\n        case Constants.ASM_IF_ACMPNE:\n        case Constants.ASM_GOTO:\n        case Constants.ASM_JSR:\n        case Constants.ASM_IFNULL:\n        case Constants.ASM_IFNONNULL:\n          {\n            // A forward jump with an offset > 32767. In this case we automatically replace ASM_GOTO\n            // with GOTO_W, ASM_JSR with JSR_W and ASM_IFxxx <l> with IFNOTxxx <L> GOTO_W <l> L:...,\n            // where IFNOTxxx is the \"opposite\" opcode of ASMS_IFxxx (e.g. IFNE for ASM_IFEQ) and\n            // where <L> designates the instruction just after the GOTO_W.\n            // First, change the ASM specific opcodes ASM_IFEQ ... ASM_JSR, ASM_IFNULL and\n            // ASM_IFNONNULL to IFEQ ... JSR, IFNULL and IFNONNULL.\n            opcode =\n                opcode < Constants.ASM_IFNULL\n                    ? opcode - Constants.ASM_OPCODE_DELTA\n                    : opcode - Constants.ASM_IFNULL_OPCODE_DELTA;\n            Label target = labels[currentBytecodeOffset + readUnsignedShort(currentOffset + 1)];\n            if (opcode == Opcodes.GOTO || opcode == Opcodes.JSR) {\n              // Replace GOTO with GOTO_W and JSR with JSR_W.\n              methodVisitor.visitJumpInsn(opcode + Constants.WIDE_JUMP_OPCODE_DELTA, target);\n            } else {\n              // Compute the \"opposite\" of opcode. This can be done by flipping the least\n              // significant bit for IFNULL and IFNONNULL, and similarly for IFEQ ... IF_ACMPEQ\n              // (with a pre and post offset by 1).\n              opcode = opcode < Opcodes.GOTO ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1;\n              Label endif = createLabel(currentBytecodeOffset + 3, labels);\n              methodVisitor.visitJumpInsn(opcode, endif);\n              methodVisitor.visitJumpInsn(Constants.GOTO_W, target);\n              // endif designates the instruction just after GOTO_W, and is visited as part of the\n              // next instruction. Since it is a jump target, we need to insert a frame here.\n              insertFrame = true;\n            }\n            currentOffset += 3;\n            break;\n          }\n        case Constants.ASM_GOTO_W:\n          // Replace ASM_GOTO_W with GOTO_W.\n          methodVisitor.visitJumpInsn(\n              Constants.GOTO_W, labels[currentBytecodeOffset + readInt(currentOffset + 1)]);\n          // The instruction just after is a jump target (because ASM_GOTO_W is used in patterns\n          // IFNOTxxx <L> ASM_GOTO_W <l> L:..., see MethodWriter), so we need to insert a frame\n          // here.\n          insertFrame = true;\n          currentOffset += 5;\n          break;\n        case Constants.WIDE:\n          opcode = classBuffer[currentOffset + 1] & 0xFF;\n          if (opcode == Opcodes.IINC) {\n            methodVisitor.visitIincInsn(\n                readUnsignedShort(currentOffset + 2), readShort(currentOffset + 4));\n            currentOffset += 6;\n          } else {\n            methodVisitor.visitVarInsn(opcode, readUnsignedShort(currentOffset + 2));\n            currentOffset += 4;\n          }\n          break;\n        case Opcodes.TABLESWITCH:\n          {\n            // Skip 0 to 3 padding bytes.\n            currentOffset += 4 - (currentBytecodeOffset & 3);\n            // Read the instruction.\n            Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];\n            int low = readInt(currentOffset + 4);\n            int high = readInt(currentOffset + 8);\n            currentOffset += 12;\n            Label[] table = new Label[high - low + 1];\n            for (int i = 0; i < table.length; ++i) {\n              table[i] = labels[currentBytecodeOffset + readInt(currentOffset)];\n              currentOffset += 4;\n            }\n            methodVisitor.visitTableSwitchInsn(low, high, defaultLabel, table);\n            break;\n          }\n        case Opcodes.LOOKUPSWITCH:\n          {\n            // Skip 0 to 3 padding bytes.\n            currentOffset += 4 - (currentBytecodeOffset & 3);\n            // Read the instruction.\n            Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];\n            int numPairs = readInt(currentOffset + 4);\n            currentOffset += 8;\n            int[] keys = new int[numPairs];\n            Label[] values = new Label[numPairs];\n            for (int i = 0; i < numPairs; ++i) {\n              keys[i] = readInt(currentOffset);\n              values[i] = labels[currentBytecodeOffset + readInt(currentOffset + 4)];\n              currentOffset += 8;\n            }\n            methodVisitor.visitLookupSwitchInsn(defaultLabel, keys, values);\n            break;\n          }\n        case Opcodes.ILOAD:\n        case Opcodes.LLOAD:\n        case Opcodes.FLOAD:\n        case Opcodes.DLOAD:\n        case Opcodes.ALOAD:\n        case Opcodes.ISTORE:\n        case Opcodes.LSTORE:\n        case Opcodes.FSTORE:\n        case Opcodes.DSTORE:\n        case Opcodes.ASTORE:\n        case Opcodes.RET:\n          methodVisitor.visitVarInsn(opcode, classBuffer[currentOffset + 1] & 0xFF);\n          currentOffset += 2;\n          break;\n        case Opcodes.BIPUSH:\n        case Opcodes.NEWARRAY:\n          methodVisitor.visitIntInsn(opcode, classBuffer[currentOffset + 1]);\n          currentOffset += 2;\n          break;\n        case Opcodes.SIPUSH:\n          methodVisitor.visitIntInsn(opcode, readShort(currentOffset + 1));\n          currentOffset += 3;\n          break;\n        case Opcodes.LDC:\n          methodVisitor.visitLdcInsn(readConst(classBuffer[currentOffset + 1] & 0xFF, charBuffer));\n          currentOffset += 2;\n          break;\n        case Constants.LDC_W:\n        case Constants.LDC2_W:\n          methodVisitor.visitLdcInsn(readConst(readUnsignedShort(currentOffset + 1), charBuffer));\n          currentOffset += 3;\n          break;\n        case Opcodes.GETSTATIC:\n        case Opcodes.PUTSTATIC:\n        case Opcodes.GETFIELD:\n        case Opcodes.PUTFIELD:\n        case Opcodes.INVOKEVIRTUAL:\n        case Opcodes.INVOKESPECIAL:\n        case Opcodes.INVOKESTATIC:\n        case Opcodes.INVOKEINTERFACE:\n          {\n            int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];\n            int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];\n            String owner = readClass(cpInfoOffset, charBuffer);\n            String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);\n            String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);\n            if (opcode < Opcodes.INVOKEVIRTUAL) {\n              methodVisitor.visitFieldInsn(opcode, owner, name, descriptor);\n            } else {\n              boolean isInterface =\n                  classBuffer[cpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;\n              methodVisitor.visitMethodInsn(opcode, owner, name, descriptor, isInterface);\n            }\n            if (opcode == Opcodes.INVOKEINTERFACE) {\n              currentOffset += 5;\n            } else {\n              currentOffset += 3;\n            }\n            break;\n          }\n        case Opcodes.INVOKEDYNAMIC:\n          {\n            int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];\n            int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];\n            String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);\n            String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);\n            int bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];\n            Handle handle =\n                (Handle) readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);\n            Object[] bootstrapMethodArguments =\n                new Object[readUnsignedShort(bootstrapMethodOffset + 2)];\n            bootstrapMethodOffset += 4;\n            for (int i = 0; i < bootstrapMethodArguments.length; i++) {\n              bootstrapMethodArguments[i] =\n                  readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);\n              bootstrapMethodOffset += 2;\n            }\n            methodVisitor.visitInvokeDynamicInsn(\n                name, descriptor, handle, bootstrapMethodArguments);\n            currentOffset += 5;\n            break;\n          }\n        case Opcodes.NEW:\n        case Opcodes.ANEWARRAY:\n        case Opcodes.CHECKCAST:\n        case Opcodes.INSTANCEOF:\n          methodVisitor.visitTypeInsn(opcode, readClass(currentOffset + 1, charBuffer));\n          currentOffset += 3;\n          break;\n        case Opcodes.IINC:\n          methodVisitor.visitIincInsn(\n              classBuffer[currentOffset + 1] & 0xFF, classBuffer[currentOffset + 2]);\n          currentOffset += 3;\n          break;\n        case Opcodes.MULTIANEWARRAY:\n          methodVisitor.visitMultiANewArrayInsn(\n              readClass(currentOffset + 1, charBuffer), classBuffer[currentOffset + 3] & 0xFF);\n          currentOffset += 4;\n          break;\n        default:\n          throw new AssertionError();\n      }\n\n      // Visit the runtime visible instruction annotations, if any.\n      while (visibleTypeAnnotationOffsets != null\n          && currentVisibleTypeAnnotationIndex < visibleTypeAnnotationOffsets.length\n          && currentVisibleTypeAnnotationBytecodeOffset <= currentBytecodeOffset) {\n        if (currentVisibleTypeAnnotationBytecodeOffset == currentBytecodeOffset) {\n          // Parse the target_type, target_info and target_path fields.\n          int currentAnnotationOffset =\n              readTypeAnnotationTarget(\n                  context, visibleTypeAnnotationOffsets[currentVisibleTypeAnnotationIndex]);\n          // Parse the type_index field.\n          String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n          currentAnnotationOffset += 2;\n          // Parse num_element_value_pairs and element_value_pairs and visit these values.\n          readElementValues(\n              methodVisitor.visitInsnAnnotation(\n                  context.currentTypeAnnotationTarget,\n                  context.currentTypeAnnotationTargetPath,\n                  annotationDescriptor,\n                  /* visible= */ true),\n              currentAnnotationOffset,\n              /* named= */ true,\n              charBuffer);\n        }\n        currentVisibleTypeAnnotationBytecodeOffset =\n            getTypeAnnotationBytecodeOffset(\n                visibleTypeAnnotationOffsets, ++currentVisibleTypeAnnotationIndex);\n      }\n\n      // Visit the runtime invisible instruction annotations, if any.\n      while (invisibleTypeAnnotationOffsets != null\n          && currentInvisibleTypeAnnotationIndex < invisibleTypeAnnotationOffsets.length\n          && currentInvisibleTypeAnnotationBytecodeOffset <= currentBytecodeOffset) {\n        if (currentInvisibleTypeAnnotationBytecodeOffset == currentBytecodeOffset) {\n          // Parse the target_type, target_info and target_path fields.\n          int currentAnnotationOffset =\n              readTypeAnnotationTarget(\n                  context, invisibleTypeAnnotationOffsets[currentInvisibleTypeAnnotationIndex]);\n          // Parse the type_index field.\n          String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\n          currentAnnotationOffset += 2;\n          // Parse num_element_value_pairs and element_value_pairs and visit these values.\n          readElementValues(\n              methodVisitor.visitInsnAnnotation(\n                  context.currentTypeAnnotationTarget,\n                  context.currentTypeAnnotationTargetPath,\n                  annotationDescriptor,\n                  /* visible= */ false),\n              currentAnnotationOffset,\n              /* named= */ true,\n              charBuffer);\n        }\n        currentInvisibleTypeAnnotationBytecodeOffset =\n            getTypeAnnotationBytecodeOffset(\n                invisibleTypeAnnotationOffsets, ++currentInvisibleTypeAnnotationIndex);\n      }\n    }\n    if (labels[codeLength] != null) {\n      methodVisitor.visitLabel(labels[codeLength]);\n    }\n\n    // Visit LocalVariableTable and LocalVariableTypeTable attributes.\n    if (localVariableTableOffset != 0 && (context.parsingOptions & SKIP_DEBUG) == 0) {\n      // The (start_pc, index, signature_index) fields of each entry of the LocalVariableTypeTable.\n      int[] typeTable = null;\n      if (localVariableTypeTableOffset != 0) {\n        typeTable = new int[readUnsignedShort(localVariableTypeTableOffset) * 3];\n        currentOffset = localVariableTypeTableOffset + 2;\n        int typeTableIndex = typeTable.length;\n        while (typeTableIndex > 0) {\n          // Store the offset of 'signature_index', and the value of 'index' and 'start_pc'.\n          typeTable[--typeTableIndex] = currentOffset + 6;\n          typeTable[--typeTableIndex] = readUnsignedShort(currentOffset + 8);\n          typeTable[--typeTableIndex] = readUnsignedShort(currentOffset);\n          currentOffset += 10;\n        }\n      }\n      int localVariableTableLength = readUnsignedShort(localVariableTableOffset);\n      currentOffset = localVariableTableOffset + 2;\n      while (localVariableTableLength-- > 0) {\n        int startPc = readUnsignedShort(currentOffset);\n        int length = readUnsignedShort(currentOffset + 2);\n        String name = readUTF8(currentOffset + 4, charBuffer);\n        String descriptor = readUTF8(currentOffset + 6, charBuffer);\n        int index = readUnsignedShort(currentOffset + 8);\n        currentOffset += 10;\n        String signature = null;\n        if (typeTable != null) {\n          for (int i = 0; i < typeTable.length; i += 3) {\n            if (typeTable[i] == startPc && typeTable[i + 1] == index) {\n              signature = readUTF8(typeTable[i + 2], charBuffer);\n              break;\n            }\n          }\n        }\n        methodVisitor.visitLocalVariable(\n            name, descriptor, signature, labels[startPc], labels[startPc + length], index);\n      }\n    }\n\n    // Visit the local variable type annotations of the RuntimeVisibleTypeAnnotations attribute.\n    if (visibleTypeAnnotationOffsets != null) {\n      for (int typeAnnotationOffset : visibleTypeAnnotationOffsets) {\n        int targetType = readByte(typeAnnotationOffset);\n        if (targetType == TypeReference.LOCAL_VARIABLE\n            || targetType == TypeReference.RESOURCE_VARIABLE) {\n          // Parse the target_type, target_info and target_path fields.\n          currentOffset = readTypeAnnotationTarget(context, typeAnnotationOffset);\n          // Parse the type_index field.\n          String annotationDescriptor = readUTF8(currentOffset, charBuffer);\n          currentOffset += 2;\n          // Parse num_element_value_pairs and element_value_pairs and visit these values.\n          readElementValues(\n              methodVisitor.visitLocalVariableAnnotation(\n                  context.currentTypeAnnotationTarget,\n                  context.currentTypeAnnotationTargetPath,\n                  context.currentLocalVariableAnnotationRangeStarts,\n                  context.currentLocalVariableAnnotationRangeEnds,\n                  context.currentLocalVariableAnnotationRangeIndices,\n                  annotationDescriptor,\n                  /* visible= */ true),\n              currentOffset,\n              /* named= */ true,\n              charBuffer);\n        }\n      }\n    }\n\n    // Visit the local variable type annotations of the RuntimeInvisibleTypeAnnotations attribute.\n    if (invisibleTypeAnnotationOffsets != null) {\n      for (int typeAnnotationOffset : invisibleTypeAnnotationOffsets) {\n        int targetType = readByte(typeAnnotationOffset);\n        if (targetType == TypeReference.LOCAL_VARIABLE\n            || targetType == TypeReference.RESOURCE_VARIABLE) {\n          // Parse the target_type, target_info and target_path fields.\n          currentOffset = readTypeAnnotationTarget(context, typeAnnotationOffset);\n          // Parse the type_index field.\n          String annotationDescriptor = readUTF8(currentOffset, charBuffer);\n          currentOffset += 2;\n          // Parse num_element_value_pairs and element_value_pairs and visit these values.\n          readElementValues(\n              methodVisitor.visitLocalVariableAnnotation(\n                  context.currentTypeAnnotationTarget,\n                  context.currentTypeAnnotationTargetPath,\n                  context.currentLocalVariableAnnotationRangeStarts,\n                  context.currentLocalVariableAnnotationRangeEnds,\n                  context.currentLocalVariableAnnotationRangeIndices,\n                  annotationDescriptor,\n                  /* visible= */ false),\n              currentOffset,\n              /* named= */ true,\n              charBuffer);\n        }\n      }\n    }\n\n    // Visit the non standard attributes.\n    while (attributes != null) {\n      // Copy and reset the nextAttribute field so that it can also be used in MethodWriter.\n      Attribute nextAttribute = attributes.nextAttribute;\n      attributes.nextAttribute = null;\n      methodVisitor.visitAttribute(attributes);\n      attributes = nextAttribute;\n    }\n\n    // Visit the max stack and max locals values.\n    methodVisitor.visitMaxs(maxStack, maxLocals);\n  }\n\n  /**\n   * Handles the bytecode offset of the next instruction to be visited in {@link\n   * #accept(ClassVisitor,int)}. This method is called just before the instruction and before its\n   * associated label and stack map frame, if any. The default implementation of this method does\n   * nothing. Subclasses can override this method to store the argument in a mutable field, for\n   * instance, so that {@link MethodVisitor} instances can get the bytecode offset of each visited\n   * instruction (if so, the usual concurrency issues related to mutable data should be addressed).\n   *\n   * @param bytecodeOffset the bytecode offset of the next instruction to be visited.\n   */\n  protected void readBytecodeInstructionOffset(final int bytecodeOffset) {\n    // Do nothing by default.\n  }\n\n  /**\n   * Returns the label corresponding to the given bytecode offset. The default implementation of\n   * this method creates a label for the given offset if it has not been already created.\n   *\n   * @param bytecodeOffset a bytecode offset in a method.\n   * @param labels the already created labels, indexed by their offset. If a label already exists\n   *     for bytecodeOffset this method must not create a new one. Otherwise it must store the new\n   *     label in this array.\n   * @return a non null Label, which must be equal to labels[bytecodeOffset].\n   */\n  protected Label readLabel(final int bytecodeOffset, final Label[] labels) {\n    // SPRING PATCH: leniently handle offset mismatch\n    if (bytecodeOffset >= labels.length) {\n      return new Label();\n    }\n    // END OF PATCH\n    if (labels[bytecodeOffset] == null) {\n      labels[bytecodeOffset] = new Label();\n    }\n    return labels[bytecodeOffset];\n  }\n\n  /**\n   * Creates a label without the {@link Label#FLAG_DEBUG_ONLY} flag set, for the given bytecode\n   * offset. The label is created with a call to {@link #readLabel} and its {@link\n   * Label#FLAG_DEBUG_ONLY} flag is cleared.\n   *\n   * @param bytecodeOffset a bytecode offset in a method.\n   * @param labels the already created labels, indexed by their offset.\n   * @return a Label without the {@link Label#FLAG_DEBUG_ONLY} flag set.\n   */\n  private Label createLabel(final int bytecodeOffset, final Label[] labels) {\n    Label label = readLabel(bytecodeOffset, labels);\n    label.flags &= ~Label.FLAG_DEBUG_ONLY;\n    return label;\n  }\n\n  /**\n   * Creates a label with the {@link Label#FLAG_DEBUG_ONLY} flag set, if there is no already\n   * existing label for the given bytecode offset (otherwise does nothing). The label is created\n   * with a call to {@link #readLabel}.\n   *\n   * @param bytecodeOffset a bytecode offset in a method.\n   * @param labels the already created labels, indexed by their offset.\n   */\n  private void createDebugLabel(final int bytecodeOffset, final Label[] labels) {\n    if (labels[bytecodeOffset] == null) {\n      readLabel(bytecodeOffset, labels).flags |= Label.FLAG_DEBUG_ONLY;\n    }\n  }\n\n  // ----------------------------------------------------------------------------------------------\n  // Methods to parse annotations, type annotations and parameter annotations\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Parses a Runtime[In]VisibleTypeAnnotations attribute to find the offset of each type_annotation\n   * entry it contains, to find the corresponding labels, and to visit the try catch block\n   * annotations.\n   *\n   * @param methodVisitor the method visitor to be used to visit the try catch block annotations.\n   * @param context information about the class being parsed.\n   * @param runtimeTypeAnnotationsOffset the start offset of a Runtime[In]VisibleTypeAnnotations\n   *     attribute, excluding the attribute_info's attribute_name_index and attribute_length fields.\n   * @param visible true if the attribute to parse is a RuntimeVisibleTypeAnnotations attribute,\n   *     false it is a RuntimeInvisibleTypeAnnotations attribute.\n   * @return the start offset of each entry of the Runtime[In]VisibleTypeAnnotations_attribute's\n   *     'annotations' array field.\n   */\n  private int[] readTypeAnnotations(\n      final MethodVisitor methodVisitor,\n      final Context context,\n      final int runtimeTypeAnnotationsOffset,\n      final boolean visible) {\n    char[] charBuffer = context.charBuffer;\n    int currentOffset = runtimeTypeAnnotationsOffset;\n    // Read the num_annotations field and create an array to store the type_annotation offsets.\n    int[] typeAnnotationsOffsets = new int[readUnsignedShort(currentOffset)];\n    currentOffset += 2;\n    // Parse the 'annotations' array field.\n    for (int i = 0; i < typeAnnotationsOffsets.length; ++i) {\n      typeAnnotationsOffsets[i] = currentOffset;\n      // Parse the type_annotation's target_type and the target_info fields. The size of the\n      // target_info field depends on the value of target_type.\n      int targetType = readInt(currentOffset);\n      switch (targetType >>> 24) {\n        case TypeReference.LOCAL_VARIABLE:\n        case TypeReference.RESOURCE_VARIABLE:\n          // A localvar_target has a variable size, which depends on the value of their table_length\n          // field. It also references bytecode offsets, for which we need labels.\n          int tableLength = readUnsignedShort(currentOffset + 1);\n          currentOffset += 3;\n          while (tableLength-- > 0) {\n            int startPc = readUnsignedShort(currentOffset);\n            int length = readUnsignedShort(currentOffset + 2);\n            // Skip the index field (2 bytes).\n            currentOffset += 6;\n            createLabel(startPc, context.currentMethodLabels);\n            createLabel(startPc + length, context.currentMethodLabels);\n          }\n          break;\n        case TypeReference.CAST:\n        case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:\n        case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:\n        case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:\n        case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:\n          currentOffset += 4;\n          break;\n        case TypeReference.CLASS_EXTENDS:\n        case TypeReference.CLASS_TYPE_PARAMETER_BOUND:\n        case TypeReference.METHOD_TYPE_PARAMETER_BOUND:\n        case TypeReference.THROWS:\n        case TypeReference.EXCEPTION_PARAMETER:\n        case TypeReference.INSTANCEOF:\n        case TypeReference.NEW:\n        case TypeReference.CONSTRUCTOR_REFERENCE:\n        case TypeReference.METHOD_REFERENCE:\n          currentOffset += 3;\n          break;\n        case TypeReference.CLASS_TYPE_PARAMETER:\n        case TypeReference.METHOD_TYPE_PARAMETER:\n        case TypeReference.METHOD_FORMAL_PARAMETER:\n        case TypeReference.FIELD:\n        case TypeReference.METHOD_RETURN:\n        case TypeReference.METHOD_RECEIVER:\n        default:\n          // TypeReference type which can't be used in Code attribute, or which is unknown.\n          throw new IllegalArgumentException();\n      }\n      // Parse the rest of the type_annotation structure, starting with the target_path structure\n      // (whose size depends on its path_length field).\n      int pathLength = readByte(currentOffset);\n      if ((targetType >>> 24) == TypeReference.EXCEPTION_PARAMETER) {\n        // Parse the target_path structure and create a corresponding TypePath.\n        TypePath path = pathLength == 0 ? null : new TypePath(classFileBuffer, currentOffset);\n        currentOffset += 1 + 2 * pathLength;\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentOffset, charBuffer);\n        currentOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentOffset =\n            readElementValues(\n                methodVisitor.visitTryCatchAnnotation(\n                    targetType & 0xFFFFFF00, path, annotationDescriptor, visible),\n                currentOffset,\n                /* named= */ true,\n                charBuffer);\n      } else {\n        // We don't want to visit the other target_type annotations, so we just skip them (which\n        // requires some parsing because the element_value_pairs array has a variable size). First,\n        // skip the target_path structure:\n        currentOffset += 3 + 2 * pathLength;\n        // Then skip the num_element_value_pairs and element_value_pairs fields (by reading them\n        // with a null AnnotationVisitor).\n        currentOffset =\n            readElementValues(\n                /* annotationVisitor= */ null, currentOffset, /* named= */ true, charBuffer);\n      }\n    }\n    return typeAnnotationsOffsets;\n  }\n\n  /**\n   * Returns the bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or\n   * -1 if there is no such type_annotation of if it does not have a bytecode offset.\n   *\n   * @param typeAnnotationOffsets the offset of each 'type_annotation' entry in a\n   *     Runtime[In]VisibleTypeAnnotations attribute, or {@literal null}.\n   * @param typeAnnotationIndex the index a 'type_annotation' entry in typeAnnotationOffsets.\n   * @return bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or -1\n   *     if there is no such type_annotation of if it does not have a bytecode offset.\n   */\n  private int getTypeAnnotationBytecodeOffset(\n      final int[] typeAnnotationOffsets, final int typeAnnotationIndex) {\n    if (typeAnnotationOffsets == null\n        || typeAnnotationIndex >= typeAnnotationOffsets.length\n        || readByte(typeAnnotationOffsets[typeAnnotationIndex]) < TypeReference.INSTANCEOF) {\n      return -1;\n    }\n    return readUnsignedShort(typeAnnotationOffsets[typeAnnotationIndex] + 1);\n  }\n\n  /**\n   * Parses the header of a JVMS type_annotation structure to extract its target_type, target_info\n   * and target_path (the result is stored in the given context), and returns the start offset of\n   * the rest of the type_annotation structure.\n   *\n   * @param context information about the class being parsed. This is where the extracted\n   *     target_type and target_path must be stored.\n   * @param typeAnnotationOffset the start offset of a type_annotation structure.\n   * @return the start offset of the rest of the type_annotation structure.\n   */\n  private int readTypeAnnotationTarget(final Context context, final int typeAnnotationOffset) {\n    int currentOffset = typeAnnotationOffset;\n    // Parse and store the target_type structure.\n    int targetType = readInt(typeAnnotationOffset);\n    switch (targetType >>> 24) {\n      case TypeReference.CLASS_TYPE_PARAMETER:\n      case TypeReference.METHOD_TYPE_PARAMETER:\n      case TypeReference.METHOD_FORMAL_PARAMETER:\n        targetType &= 0xFFFF0000;\n        currentOffset += 2;\n        break;\n      case TypeReference.FIELD:\n      case TypeReference.METHOD_RETURN:\n      case TypeReference.METHOD_RECEIVER:\n        targetType &= 0xFF000000;\n        currentOffset += 1;\n        break;\n      case TypeReference.LOCAL_VARIABLE:\n      case TypeReference.RESOURCE_VARIABLE:\n        targetType &= 0xFF000000;\n        int tableLength = readUnsignedShort(currentOffset + 1);\n        currentOffset += 3;\n        context.currentLocalVariableAnnotationRangeStarts = new Label[tableLength];\n        context.currentLocalVariableAnnotationRangeEnds = new Label[tableLength];\n        context.currentLocalVariableAnnotationRangeIndices = new int[tableLength];\n        for (int i = 0; i < tableLength; ++i) {\n          int startPc = readUnsignedShort(currentOffset);\n          int length = readUnsignedShort(currentOffset + 2);\n          int index = readUnsignedShort(currentOffset + 4);\n          currentOffset += 6;\n          context.currentLocalVariableAnnotationRangeStarts[i] =\n              createLabel(startPc, context.currentMethodLabels);\n          context.currentLocalVariableAnnotationRangeEnds[i] =\n              createLabel(startPc + length, context.currentMethodLabels);\n          context.currentLocalVariableAnnotationRangeIndices[i] = index;\n        }\n        break;\n      case TypeReference.CAST:\n      case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:\n      case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:\n      case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:\n      case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:\n        targetType &= 0xFF0000FF;\n        currentOffset += 4;\n        break;\n      case TypeReference.CLASS_EXTENDS:\n      case TypeReference.CLASS_TYPE_PARAMETER_BOUND:\n      case TypeReference.METHOD_TYPE_PARAMETER_BOUND:\n      case TypeReference.THROWS:\n      case TypeReference.EXCEPTION_PARAMETER:\n        targetType &= 0xFFFFFF00;\n        currentOffset += 3;\n        break;\n      case TypeReference.INSTANCEOF:\n      case TypeReference.NEW:\n      case TypeReference.CONSTRUCTOR_REFERENCE:\n      case TypeReference.METHOD_REFERENCE:\n        targetType &= 0xFF000000;\n        currentOffset += 3;\n        break;\n      default:\n        throw new IllegalArgumentException();\n    }\n    context.currentTypeAnnotationTarget = targetType;\n    // Parse and store the target_path structure.\n    int pathLength = readByte(currentOffset);\n    context.currentTypeAnnotationTargetPath =\n        pathLength == 0 ? null : new TypePath(classFileBuffer, currentOffset);\n    // Return the start offset of the rest of the type_annotation structure.\n    return currentOffset + 1 + 2 * pathLength;\n  }\n\n  /**\n   * Reads a Runtime[In]VisibleParameterAnnotations attribute and makes the given visitor visit it.\n   *\n   * @param methodVisitor the visitor that must visit the parameter annotations.\n   * @param context information about the class being parsed.\n   * @param runtimeParameterAnnotationsOffset the start offset of a\n   *     Runtime[In]VisibleParameterAnnotations attribute, excluding the attribute_info's\n   *     attribute_name_index and attribute_length fields.\n   * @param visible true if the attribute to parse is a RuntimeVisibleParameterAnnotations\n   *     attribute, false it is a RuntimeInvisibleParameterAnnotations attribute.\n   */\n  private void readParameterAnnotations(\n      final MethodVisitor methodVisitor,\n      final Context context,\n      final int runtimeParameterAnnotationsOffset,\n      final boolean visible) {\n    int currentOffset = runtimeParameterAnnotationsOffset;\n    int numParameters = classFileBuffer[currentOffset++] & 0xFF;\n    methodVisitor.visitAnnotableParameterCount(numParameters, visible);\n    char[] charBuffer = context.charBuffer;\n    for (int i = 0; i < numParameters; ++i) {\n      int numAnnotations = readUnsignedShort(currentOffset);\n      currentOffset += 2;\n      while (numAnnotations-- > 0) {\n        // Parse the type_index field.\n        String annotationDescriptor = readUTF8(currentOffset, charBuffer);\n        currentOffset += 2;\n        // Parse num_element_value_pairs and element_value_pairs and visit these values.\n        currentOffset =\n            readElementValues(\n                methodVisitor.visitParameterAnnotation(i, annotationDescriptor, visible),\n                currentOffset,\n                /* named= */ true,\n                charBuffer);\n      }\n    }\n  }\n\n  /**\n   * Reads the element values of a JVMS 'annotation' structure and makes the given visitor visit\n   * them. This method can also be used to read the values of the JVMS 'array_value' field of an\n   * annotation's 'element_value'.\n   *\n   * @param annotationVisitor the visitor that must visit the values.\n   * @param annotationOffset the start offset of an 'annotation' structure (excluding its type_index\n   *     field) or of an 'array_value' structure.\n   * @param named if the annotation values are named or not. This should be true to parse the values\n   *     of a JVMS 'annotation' structure, and false to parse the JVMS 'array_value' of an\n   *     annotation's element_value.\n   * @param charBuffer the buffer used to read strings in the constant pool.\n   * @return the end offset of the JVMS 'annotation' or 'array_value' structure.\n   */\n  private int readElementValues(\n      final AnnotationVisitor annotationVisitor,\n      final int annotationOffset,\n      final boolean named,\n      final char[] charBuffer) {\n    int currentOffset = annotationOffset;\n    // Read the num_element_value_pairs field (or num_values field for an array_value).\n    int numElementValuePairs = readUnsignedShort(currentOffset);\n    currentOffset += 2;\n    if (named) {\n      // Parse the element_value_pairs array.\n      while (numElementValuePairs-- > 0) {\n        String elementName = readUTF8(currentOffset, charBuffer);\n        currentOffset =\n            readElementValue(annotationVisitor, currentOffset + 2, elementName, charBuffer);\n      }\n    } else {\n      // Parse the array_value array.\n      while (numElementValuePairs-- > 0) {\n        currentOffset =\n            readElementValue(annotationVisitor, currentOffset, /* elementName= */ null, charBuffer);\n      }\n    }\n    if (annotationVisitor != null) {\n      annotationVisitor.visitEnd();\n    }\n    return currentOffset;\n  }\n\n  /**\n   * Reads a JVMS 'element_value' structure and makes the given visitor visit it.\n   *\n   * @param annotationVisitor the visitor that must visit the element_value structure.\n   * @param elementValueOffset the start offset in {@link #classFileBuffer} of the element_value\n   *     structure to be read.\n   * @param elementName the name of the element_value structure to be read, or {@literal null}.\n   * @param charBuffer the buffer used to read strings in the constant pool.\n   * @return the end offset of the JVMS 'element_value' structure.\n   */\n  private int readElementValue(\n      final AnnotationVisitor annotationVisitor,\n      final int elementValueOffset,\n      final String elementName,\n      final char[] charBuffer) {\n    int currentOffset = elementValueOffset;\n    if (annotationVisitor == null) {\n      switch (classFileBuffer[currentOffset] & 0xFF) {\n        case 'e': // enum_const_value\n          return currentOffset + 5;\n        case '@': // annotation_value\n          return readElementValues(null, currentOffset + 3, /* named= */ true, charBuffer);\n        case '[': // array_value\n          return readElementValues(null, currentOffset + 1, /* named= */ false, charBuffer);\n        default:\n          return currentOffset + 3;\n      }\n    }\n    switch (classFileBuffer[currentOffset++] & 0xFF) {\n      case 'B': // const_value_index, CONSTANT_Integer\n        annotationVisitor.visit(\n            elementName, (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));\n        currentOffset += 2;\n        break;\n      case 'C': // const_value_index, CONSTANT_Integer\n        annotationVisitor.visit(\n            elementName, (char) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));\n        currentOffset += 2;\n        break;\n      case 'D': // const_value_index, CONSTANT_Double\n      case 'F': // const_value_index, CONSTANT_Float\n      case 'I': // const_value_index, CONSTANT_Integer\n      case 'J': // const_value_index, CONSTANT_Long\n        annotationVisitor.visit(\n            elementName, readConst(readUnsignedShort(currentOffset), charBuffer));\n        currentOffset += 2;\n        break;\n      case 'S': // const_value_index, CONSTANT_Integer\n        annotationVisitor.visit(\n            elementName, (short) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));\n        currentOffset += 2;\n        break;\n\n      case 'Z': // const_value_index, CONSTANT_Integer\n        annotationVisitor.visit(\n            elementName,\n            readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]) == 0\n                ? Boolean.FALSE\n                : Boolean.TRUE);\n        currentOffset += 2;\n        break;\n      case 's': // const_value_index, CONSTANT_Utf8\n        annotationVisitor.visit(elementName, readUTF8(currentOffset, charBuffer));\n        currentOffset += 2;\n        break;\n      case 'e': // enum_const_value\n        annotationVisitor.visitEnum(\n            elementName,\n            readUTF8(currentOffset, charBuffer),\n            readUTF8(currentOffset + 2, charBuffer));\n        currentOffset += 4;\n        break;\n      case 'c': // class_info\n        annotationVisitor.visit(elementName, Type.getType(readUTF8(currentOffset, charBuffer)));\n        currentOffset += 2;\n        break;\n      case '@': // annotation_value\n        currentOffset =\n            readElementValues(\n                annotationVisitor.visitAnnotation(elementName, readUTF8(currentOffset, charBuffer)),\n                currentOffset + 2,\n                true,\n                charBuffer);\n        break;\n      case '[': // array_value\n        int numValues = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        if (numValues == 0) {\n          return readElementValues(\n              annotationVisitor.visitArray(elementName),\n              currentOffset - 2,\n              /* named= */ false,\n              charBuffer);\n        }\n        switch (classFileBuffer[currentOffset] & 0xFF) {\n          case 'B':\n            byte[] byteValues = new byte[numValues];\n            for (int i = 0; i < numValues; i++) {\n              byteValues[i] = (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\n              currentOffset += 3;\n            }\n            annotationVisitor.visit(elementName, byteValues);\n            break;\n          case 'Z':\n            boolean[] booleanValues = new boolean[numValues];\n            for (int i = 0; i < numValues; i++) {\n              booleanValues[i] = readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]) != 0;\n              currentOffset += 3;\n            }\n            annotationVisitor.visit(elementName, booleanValues);\n            break;\n          case 'S':\n            short[] shortValues = new short[numValues];\n            for (int i = 0; i < numValues; i++) {\n              shortValues[i] = (short) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\n              currentOffset += 3;\n            }\n            annotationVisitor.visit(elementName, shortValues);\n            break;\n          case 'C':\n            char[] charValues = new char[numValues];\n            for (int i = 0; i < numValues; i++) {\n              charValues[i] = (char) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\n              currentOffset += 3;\n            }\n            annotationVisitor.visit(elementName, charValues);\n            break;\n          case 'I':\n            int[] intValues = new int[numValues];\n            for (int i = 0; i < numValues; i++) {\n              intValues[i] = readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\n              currentOffset += 3;\n            }\n            annotationVisitor.visit(elementName, intValues);\n            break;\n          case 'J':\n            long[] longValues = new long[numValues];\n            for (int i = 0; i < numValues; i++) {\n              longValues[i] = readLong(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\n              currentOffset += 3;\n            }\n            annotationVisitor.visit(elementName, longValues);\n            break;\n          case 'F':\n            float[] floatValues = new float[numValues];\n            for (int i = 0; i < numValues; i++) {\n              floatValues[i] =\n                  Float.intBitsToFloat(\n                      readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]));\n              currentOffset += 3;\n            }\n            annotationVisitor.visit(elementName, floatValues);\n            break;\n          case 'D':\n            double[] doubleValues = new double[numValues];\n            for (int i = 0; i < numValues; i++) {\n              doubleValues[i] =\n                  Double.longBitsToDouble(\n                      readLong(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]));\n              currentOffset += 3;\n            }\n            annotationVisitor.visit(elementName, doubleValues);\n            break;\n          default:\n            currentOffset =\n                readElementValues(\n                    annotationVisitor.visitArray(elementName),\n                    currentOffset - 2,\n                    /* named= */ false,\n                    charBuffer);\n            break;\n        }\n        break;\n      default:\n        throw new IllegalArgumentException();\n    }\n    return currentOffset;\n  }\n\n  // ----------------------------------------------------------------------------------------------\n  // Methods to parse stack map frames\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Computes the implicit frame of the method currently being parsed (as defined in the given\n   * {@link Context}) and stores it in the given context.\n   *\n   * @param context information about the class being parsed.\n   */\n  private void computeImplicitFrame(final Context context) {\n    String methodDescriptor = context.currentMethodDescriptor;\n    Object[] locals = context.currentFrameLocalTypes;\n    int numLocal = 0;\n    if ((context.currentMethodAccessFlags & Opcodes.ACC_STATIC) == 0) {\n      if (\"<init>\".equals(context.currentMethodName)) {\n        locals[numLocal++] = Opcodes.UNINITIALIZED_THIS;\n      } else {\n        locals[numLocal++] = readClass(header + 2, context.charBuffer);\n      }\n    }\n    // Parse the method descriptor, one argument type descriptor at each iteration. Start by\n    // skipping the first method descriptor character, which is always '('.\n    int currentMethodDescritorOffset = 1;\n    while (true) {\n      int currentArgumentDescriptorStartOffset = currentMethodDescritorOffset;\n      switch (methodDescriptor.charAt(currentMethodDescritorOffset++)) {\n        case 'Z':\n        case 'C':\n        case 'B':\n        case 'S':\n        case 'I':\n          locals[numLocal++] = Opcodes.INTEGER;\n          break;\n        case 'F':\n          locals[numLocal++] = Opcodes.FLOAT;\n          break;\n        case 'J':\n          locals[numLocal++] = Opcodes.LONG;\n          break;\n        case 'D':\n          locals[numLocal++] = Opcodes.DOUBLE;\n          break;\n        case '[':\n          while (methodDescriptor.charAt(currentMethodDescritorOffset) == '[') {\n            ++currentMethodDescritorOffset;\n          }\n          if (methodDescriptor.charAt(currentMethodDescritorOffset) == 'L') {\n            ++currentMethodDescritorOffset;\n            while (methodDescriptor.charAt(currentMethodDescritorOffset) != ';') {\n              ++currentMethodDescritorOffset;\n            }\n          }\n          locals[numLocal++] =\n              methodDescriptor.substring(\n                  currentArgumentDescriptorStartOffset, ++currentMethodDescritorOffset);\n          break;\n        case 'L':\n          while (methodDescriptor.charAt(currentMethodDescritorOffset) != ';') {\n            ++currentMethodDescritorOffset;\n          }\n          locals[numLocal++] =\n              methodDescriptor.substring(\n                  currentArgumentDescriptorStartOffset + 1, currentMethodDescritorOffset++);\n          break;\n        default:\n          context.currentFrameLocalCount = numLocal;\n          return;\n      }\n    }\n  }\n\n  /**\n   * Reads a JVMS 'stack_map_frame' structure and stores the result in the given {@link Context}\n   * object. This method can also be used to read a full_frame structure, excluding its frame_type\n   * field (this is used to parse the legacy StackMap attributes).\n   *\n   * @param stackMapFrameOffset the start offset in {@link #classFileBuffer} of the\n   *     stack_map_frame_value structure to be read, or the start offset of a full_frame structure\n   *     (excluding its frame_type field).\n   * @param compressed true to read a 'stack_map_frame' structure, false to read a 'full_frame'\n   *     structure without its frame_type field.\n   * @param expand if the stack map frame must be expanded. See {@link #EXPAND_FRAMES}.\n   * @param context where the parsed stack map frame must be stored.\n   * @return the end offset of the JVMS 'stack_map_frame' or 'full_frame' structure.\n   */\n  private int readStackMapFrame(\n      final int stackMapFrameOffset,\n      final boolean compressed,\n      final boolean expand,\n      final Context context) {\n    int currentOffset = stackMapFrameOffset;\n    final char[] charBuffer = context.charBuffer;\n    final Label[] labels = context.currentMethodLabels;\n    int frameType;\n    if (compressed) {\n      // Read the frame_type field.\n      frameType = classFileBuffer[currentOffset++] & 0xFF;\n    } else {\n      frameType = Frame.FULL_FRAME;\n      context.currentFrameOffset = -1;\n    }\n    int offsetDelta;\n    context.currentFrameLocalCountDelta = 0;\n    if (frameType < Frame.SAME_LOCALS_1_STACK_ITEM_FRAME) {\n      offsetDelta = frameType;\n      context.currentFrameType = Opcodes.F_SAME;\n      context.currentFrameStackCount = 0;\n    } else if (frameType < Frame.RESERVED) {\n      offsetDelta = frameType - Frame.SAME_LOCALS_1_STACK_ITEM_FRAME;\n      currentOffset =\n          readVerificationTypeInfo(\n              currentOffset, context.currentFrameStackTypes, 0, charBuffer, labels);\n      context.currentFrameType = Opcodes.F_SAME1;\n      context.currentFrameStackCount = 1;\n    } else if (frameType >= Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n      offsetDelta = readUnsignedShort(currentOffset);\n      currentOffset += 2;\n      if (frameType == Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n        currentOffset =\n            readVerificationTypeInfo(\n                currentOffset, context.currentFrameStackTypes, 0, charBuffer, labels);\n        context.currentFrameType = Opcodes.F_SAME1;\n        context.currentFrameStackCount = 1;\n      } else if (frameType >= Frame.CHOP_FRAME && frameType < Frame.SAME_FRAME_EXTENDED) {\n        context.currentFrameType = Opcodes.F_CHOP;\n        context.currentFrameLocalCountDelta = Frame.SAME_FRAME_EXTENDED - frameType;\n        context.currentFrameLocalCount -= context.currentFrameLocalCountDelta;\n        context.currentFrameStackCount = 0;\n      } else if (frameType == Frame.SAME_FRAME_EXTENDED) {\n        context.currentFrameType = Opcodes.F_SAME;\n        context.currentFrameStackCount = 0;\n      } else if (frameType < Frame.FULL_FRAME) {\n        int local = expand ? context.currentFrameLocalCount : 0;\n        for (int k = frameType - Frame.SAME_FRAME_EXTENDED; k > 0; k--) {\n          currentOffset =\n              readVerificationTypeInfo(\n                  currentOffset, context.currentFrameLocalTypes, local++, charBuffer, labels);\n        }\n        context.currentFrameType = Opcodes.F_APPEND;\n        context.currentFrameLocalCountDelta = frameType - Frame.SAME_FRAME_EXTENDED;\n        context.currentFrameLocalCount += context.currentFrameLocalCountDelta;\n        context.currentFrameStackCount = 0;\n      } else {\n        final int numberOfLocals = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        context.currentFrameType = Opcodes.F_FULL;\n        context.currentFrameLocalCountDelta = numberOfLocals;\n        context.currentFrameLocalCount = numberOfLocals;\n        for (int local = 0; local < numberOfLocals; ++local) {\n          currentOffset =\n              readVerificationTypeInfo(\n                  currentOffset, context.currentFrameLocalTypes, local, charBuffer, labels);\n        }\n        final int numberOfStackItems = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        context.currentFrameStackCount = numberOfStackItems;\n        for (int stack = 0; stack < numberOfStackItems; ++stack) {\n          currentOffset =\n              readVerificationTypeInfo(\n                  currentOffset, context.currentFrameStackTypes, stack, charBuffer, labels);\n        }\n      }\n    } else {\n      throw new IllegalArgumentException();\n    }\n    context.currentFrameOffset += offsetDelta + 1;\n    createLabel(context.currentFrameOffset, labels);\n    return currentOffset;\n  }\n\n  /**\n   * Reads a JVMS 'verification_type_info' structure and stores it at the given index in the given\n   * array.\n   *\n   * @param verificationTypeInfoOffset the start offset of the 'verification_type_info' structure to\n   *     read.\n   * @param frame the array where the parsed type must be stored.\n   * @param index the index in 'frame' where the parsed type must be stored.\n   * @param charBuffer the buffer used to read strings in the constant pool.\n   * @param labels the labels of the method currently being parsed, indexed by their offset. If the\n   *     parsed type is an ITEM_Uninitialized, a new label for the corresponding NEW instruction is\n   *     stored in this array if it does not already exist.\n   * @return the end offset of the JVMS 'verification_type_info' structure.\n   */\n  private int readVerificationTypeInfo(\n      final int verificationTypeInfoOffset,\n      final Object[] frame,\n      final int index,\n      final char[] charBuffer,\n      final Label[] labels) {\n    int currentOffset = verificationTypeInfoOffset;\n    int tag = classFileBuffer[currentOffset++] & 0xFF;\n    switch (tag) {\n      case Frame.ITEM_TOP:\n        frame[index] = Opcodes.TOP;\n        break;\n      case Frame.ITEM_INTEGER:\n        frame[index] = Opcodes.INTEGER;\n        break;\n      case Frame.ITEM_FLOAT:\n        frame[index] = Opcodes.FLOAT;\n        break;\n      case Frame.ITEM_DOUBLE:\n        frame[index] = Opcodes.DOUBLE;\n        break;\n      case Frame.ITEM_LONG:\n        frame[index] = Opcodes.LONG;\n        break;\n      case Frame.ITEM_NULL:\n        frame[index] = Opcodes.NULL;\n        break;\n      case Frame.ITEM_UNINITIALIZED_THIS:\n        frame[index] = Opcodes.UNINITIALIZED_THIS;\n        break;\n      case Frame.ITEM_OBJECT:\n        frame[index] = readClass(currentOffset, charBuffer);\n        currentOffset += 2;\n        break;\n      case Frame.ITEM_UNINITIALIZED:\n        frame[index] = createLabel(readUnsignedShort(currentOffset), labels);\n        currentOffset += 2;\n        break;\n      default:\n        throw new IllegalArgumentException();\n    }\n    return currentOffset;\n  }\n\n  // ----------------------------------------------------------------------------------------------\n  // Methods to parse attributes\n  // ----------------------------------------------------------------------------------------------\n\n  /**\n   * Returns the offset in {@link #classFileBuffer} of the first ClassFile's 'attributes' array\n   * field entry.\n   *\n   * @return the offset in {@link #classFileBuffer} of the first ClassFile's 'attributes' array\n   *     field entry.\n   */\n  final int getFirstAttributeOffset() {\n    // Skip the access_flags, this_class, super_class, and interfaces_count fields (using 2 bytes\n    // each), as well as the interfaces array field (2 bytes per interface).\n    int currentOffset = header + 8 + readUnsignedShort(header + 6) * 2;\n\n    // Read the fields_count field.\n    int fieldsCount = readUnsignedShort(currentOffset);\n    currentOffset += 2;\n    // Skip the 'fields' array field.\n    while (fieldsCount-- > 0) {\n      // Invariant: currentOffset is the offset of a field_info structure.\n      // Skip the access_flags, name_index and descriptor_index fields (2 bytes each), and read the\n      // attributes_count field.\n      int attributesCount = readUnsignedShort(currentOffset + 6);\n      currentOffset += 8;\n      // Skip the 'attributes' array field.\n      while (attributesCount-- > 0) {\n        // Invariant: currentOffset is the offset of an attribute_info structure.\n        // Read the attribute_length field (2 bytes after the start of the attribute_info) and skip\n        // this many bytes, plus 6 for the attribute_name_index and attribute_length fields\n        // (yielding the total size of the attribute_info structure).\n        currentOffset += 6 + readInt(currentOffset + 2);\n      }\n    }\n\n    // Skip the methods_count and 'methods' fields, using the same method as above.\n    int methodsCount = readUnsignedShort(currentOffset);\n    currentOffset += 2;\n    while (methodsCount-- > 0) {\n      int attributesCount = readUnsignedShort(currentOffset + 6);\n      currentOffset += 8;\n      while (attributesCount-- > 0) {\n        currentOffset += 6 + readInt(currentOffset + 2);\n      }\n    }\n\n    // Skip the ClassFile's attributes_count field.\n    return currentOffset + 2;\n  }\n\n  /**\n   * Reads the BootstrapMethods attribute to compute the offset of each bootstrap method.\n   *\n   * @param maxStringLength a conservative estimate of the maximum length of the strings contained\n   *     in the constant pool of the class.\n   * @return the offsets of the bootstrap methods.\n   */\n  private int[] readBootstrapMethodsAttribute(final int maxStringLength) {\n    char[] charBuffer = new char[maxStringLength];\n    int currentAttributeOffset = getFirstAttributeOffset();\n    for (int i = readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {\n      // Read the attribute_info's attribute_name and attribute_length fields.\n      String attributeName = readUTF8(currentAttributeOffset, charBuffer);\n      int attributeLength = readInt(currentAttributeOffset + 2);\n      currentAttributeOffset += 6;\n      if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\n        // Read the num_bootstrap_methods field and create an array of this size.\n        int[] result = new int[readUnsignedShort(currentAttributeOffset)];\n        // Compute and store the offset of each 'bootstrap_methods' array field entry.\n        int currentBootstrapMethodOffset = currentAttributeOffset + 2;\n        for (int j = 0; j < result.length; ++j) {\n          result[j] = currentBootstrapMethodOffset;\n          // Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),\n          // as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).\n          currentBootstrapMethodOffset +=\n              4 + readUnsignedShort(currentBootstrapMethodOffset + 2) * 2;\n        }\n        return result;\n      }\n      currentAttributeOffset += attributeLength;\n    }\n    throw new IllegalArgumentException();\n  }\n\n  /**\n   * Reads a non standard JVMS 'attribute' structure in {@link #classFileBuffer}.\n   *\n   * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of\n   *     the class. Any attribute whose type is not equal to the type of one the prototypes will not\n   *     be parsed: its byte array value will be passed unchanged to the ClassWriter.\n   * @param type the type of the attribute.\n   * @param offset the start offset of the JVMS 'attribute' structure in {@link #classFileBuffer}.\n   *     The 6 attribute header bytes (attribute_name_index and attribute_length) are not taken into\n   *     account here.\n   * @param length the length of the attribute's content (excluding the 6 attribute header bytes).\n   * @param charBuffer the buffer to be used to read strings in the constant pool.\n   * @param codeAttributeOffset the start offset of the enclosing Code attribute in {@link\n   *     #classFileBuffer}, or -1 if the attribute to be read is not a code attribute. The 6\n   *     attribute header bytes (attribute_name_index and attribute_length) are not taken into\n   *     account here.\n   * @param labels the labels of the method's code, or {@literal null} if the attribute to be read\n   *     is not a code attribute.\n   * @return the attribute that has been read.\n   */\n  private Attribute readAttribute(\n      final Attribute[] attributePrototypes,\n      final String type,\n      final int offset,\n      final int length,\n      final char[] charBuffer,\n      final int codeAttributeOffset,\n      final Label[] labels) {\n    for (Attribute attributePrototype : attributePrototypes) {\n      if (attributePrototype.type.equals(type)) {\n        return attributePrototype.read(\n            this, offset, length, charBuffer, codeAttributeOffset, labels);\n      }\n    }\n    return new Attribute(type).read(this, offset, length, null, -1, null);\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Utility methods: low level parsing\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Returns the number of entries in the class's constant pool table.\n   *\n   * @return the number of entries in the class's constant pool table.\n   */\n  public int getItemCount() {\n    return cpInfoOffsets.length;\n  }\n\n  /**\n   * Returns the start offset in this {@link ClassReader} of a JVMS 'cp_info' structure (i.e. a\n   * constant pool entry), plus one. <i>This method is intended for {@link Attribute} sub classes,\n   * and is normally not needed by class generators or adapters.</i>\n   *\n   * @param constantPoolEntryIndex the index a constant pool entry in the class's constant pool\n   *     table.\n   * @return the start offset in this {@link ClassReader} of the corresponding JVMS 'cp_info'\n   *     structure, plus one.\n   */\n  public int getItem(final int constantPoolEntryIndex) {\n    return cpInfoOffsets[constantPoolEntryIndex];\n  }\n\n  /**\n   * Returns a conservative estimate of the maximum length of the strings contained in the class's\n   * constant pool table.\n   *\n   * @return a conservative estimate of the maximum length of the strings contained in the class's\n   *     constant pool table.\n   */\n  public int getMaxStringLength() {\n    return maxStringLength;\n  }\n\n  /**\n   * Reads a byte value in this {@link ClassReader}. <i>This method is intended for {@link\n   * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param offset the start offset of the value to be read in this {@link ClassReader}.\n   * @return the read value.\n   */\n  public int readByte(final int offset) {\n    return classFileBuffer[offset] & 0xFF;\n  }\n\n  /**\n   * Reads several bytes in this {@link ClassReader}. <i>This method is intended for {@link\n   * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param offset the start offset of the bytes to be read in this {@link ClassReader}.\n   * @param length the number of bytes to read.\n   * @return the read bytes.\n   */\n  public byte[] readBytes(final int offset, final int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(classFileBuffer, offset, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Reads an unsigned short value in this {@link ClassReader}. <i>This method is intended for\n   * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param offset the start index of the value to be read in this {@link ClassReader}.\n   * @return the read value.\n   */\n  public int readUnsignedShort(final int offset) {\n    byte[] classBuffer = classFileBuffer;\n    return ((classBuffer[offset] & 0xFF) << 8) | (classBuffer[offset + 1] & 0xFF);\n  }\n\n  /**\n   * Reads a signed short value in this {@link ClassReader}. <i>This method is intended for {@link\n   * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param offset the start offset of the value to be read in this {@link ClassReader}.\n   * @return the read value.\n   */\n  public short readShort(final int offset) {\n    byte[] classBuffer = classFileBuffer;\n    return (short) (((classBuffer[offset] & 0xFF) << 8) | (classBuffer[offset + 1] & 0xFF));\n  }\n\n  /**\n   * Reads a signed int value in this {@link ClassReader}. <i>This method is intended for {@link\n   * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param offset the start offset of the value to be read in this {@link ClassReader}.\n   * @return the read value.\n   */\n  public int readInt(final int offset) {\n    byte[] classBuffer = classFileBuffer;\n    return ((classBuffer[offset] & 0xFF) << 24)\n        | ((classBuffer[offset + 1] & 0xFF) << 16)\n        | ((classBuffer[offset + 2] & 0xFF) << 8)\n        | (classBuffer[offset + 3] & 0xFF);\n  }\n\n  /**\n   * Reads a signed long value in this {@link ClassReader}. <i>This method is intended for {@link\n   * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param offset the start offset of the value to be read in this {@link ClassReader}.\n   * @return the read value.\n   */\n  public long readLong(final int offset) {\n    long l1 = readInt(offset);\n    long l0 = readInt(offset + 4) & 0xFFFFFFFFL;\n    return (l1 << 32) | l0;\n  }\n\n  /**\n   * Reads a CONSTANT_Utf8 constant pool entry in this {@link ClassReader}. <i>This method is\n   * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\n   * adapters.</i>\n   *\n   * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\n   *     value is the index of a CONSTANT_Utf8 entry in the class's constant pool table.\n   * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently\n   *     large. It is not automatically resized.\n   * @return the String corresponding to the specified CONSTANT_Utf8 entry.\n   */\n  // DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).\n  public String readUTF8(final int offset, final char[] charBuffer) {\n    int constantPoolEntryIndex = readUnsignedShort(offset);\n    if (offset == 0 || constantPoolEntryIndex == 0) {\n      return null;\n    }\n    return readUtf(constantPoolEntryIndex, charBuffer);\n  }\n\n  /**\n   * Reads a CONSTANT_Utf8 constant pool entry in {@link #classFileBuffer}.\n   *\n   * @param constantPoolEntryIndex the index of a CONSTANT_Utf8 entry in the class's constant pool\n   *     table.\n   * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently\n   *     large. It is not automatically resized.\n   * @return the String corresponding to the specified CONSTANT_Utf8 entry.\n   */\n  final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {\n    String value = constantUtf8Values[constantPoolEntryIndex];\n    if (value != null) {\n      return value;\n    }\n    int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];\n    return constantUtf8Values[constantPoolEntryIndex] =\n        readUtf(cpInfoOffset + 2, readUnsignedShort(cpInfoOffset), charBuffer);\n  }\n\n  /**\n   * Reads an UTF8 string in {@link #classFileBuffer}.\n   *\n   * @param utfOffset the start offset of the UTF8 string to be read.\n   * @param utfLength the length of the UTF8 string to be read.\n   * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently\n   *     large. It is not automatically resized.\n   * @return the String corresponding to the specified UTF8 string.\n   */\n  private String readUtf(final int utfOffset, final int utfLength, final char[] charBuffer) {\n    int currentOffset = utfOffset;\n    int endOffset = currentOffset + utfLength;\n    int strLength = 0;\n    byte[] classBuffer = classFileBuffer;\n    while (currentOffset < endOffset) {\n      int currentByte = classBuffer[currentOffset++];\n      if ((currentByte & 0x80) == 0) {\n        charBuffer[strLength++] = (char) (currentByte & 0x7F);\n      } else if ((currentByte & 0xE0) == 0xC0) {\n        charBuffer[strLength++] =\n            (char) (((currentByte & 0x1F) << 6) + (classBuffer[currentOffset++] & 0x3F));\n      } else {\n        charBuffer[strLength++] =\n            (char)\n                (((currentByte & 0xF) << 12)\n                    + ((classBuffer[currentOffset++] & 0x3F) << 6)\n                    + (classBuffer[currentOffset++] & 0x3F));\n      }\n    }\n    return new String(charBuffer, 0, strLength);\n  }\n\n  /**\n   * Reads a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType, CONSTANT_Module or\n   * CONSTANT_Package constant pool entry in {@link #classFileBuffer}. <i>This method is intended\n   * for {@link Attribute} sub classes, and is normally not needed by class generators or\n   * adapters.</i>\n   *\n   * @param offset the start offset of an unsigned short value in {@link #classFileBuffer}, whose\n   *     value is the index of a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,\n   *     CONSTANT_Module or CONSTANT_Package entry in class's constant pool table.\n   * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\n   *     large. It is not automatically resized.\n   * @return the String corresponding to the specified constant pool entry.\n   */\n  private String readStringish(final int offset, final char[] charBuffer) {\n    // Get the start offset of the cp_info structure (plus one), and read the CONSTANT_Utf8 entry\n    // designated by the first two bytes of this cp_info.\n    return readUTF8(cpInfoOffsets[readUnsignedShort(offset)], charBuffer);\n  }\n\n  /**\n   * Reads a CONSTANT_Class constant pool entry in this {@link ClassReader}. <i>This method is\n   * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\n   * adapters.</i>\n   *\n   * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\n   *     value is the index of a CONSTANT_Class entry in class's constant pool table.\n   * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\n   *     large. It is not automatically resized.\n   * @return the String corresponding to the specified CONSTANT_Class entry.\n   */\n  public String readClass(final int offset, final char[] charBuffer) {\n    return readStringish(offset, charBuffer);\n  }\n\n  /**\n   * Reads a CONSTANT_Module constant pool entry in this {@link ClassReader}. <i>This method is\n   * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\n   * adapters.</i>\n   *\n   * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\n   *     value is the index of a CONSTANT_Module entry in class's constant pool table.\n   * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\n   *     large. It is not automatically resized.\n   * @return the String corresponding to the specified CONSTANT_Module entry.\n   */\n  public String readModule(final int offset, final char[] charBuffer) {\n    return readStringish(offset, charBuffer);\n  }\n\n  /**\n   * Reads a CONSTANT_Package constant pool entry in this {@link ClassReader}. <i>This method is\n   * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\n   * adapters.</i>\n   *\n   * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\n   *     value is the index of a CONSTANT_Package entry in class's constant pool table.\n   * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\n   *     large. It is not automatically resized.\n   * @return the String corresponding to the specified CONSTANT_Package entry.\n   */\n  public String readPackage(final int offset, final char[] charBuffer) {\n    return readStringish(offset, charBuffer);\n  }\n\n  /**\n   * Reads a CONSTANT_Dynamic constant pool entry in {@link #classFileBuffer}.\n   *\n   * @param constantPoolEntryIndex the index of a CONSTANT_Dynamic entry in the class's constant\n   *     pool table.\n   * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently\n   *     large. It is not automatically resized.\n   * @return the ConstantDynamic corresponding to the specified CONSTANT_Dynamic entry.\n   */\n  private ConstantDynamic readConstantDynamic(\n      final int constantPoolEntryIndex, final char[] charBuffer) {\n    ConstantDynamic constantDynamic = constantDynamicValues[constantPoolEntryIndex];\n    if (constantDynamic != null) {\n      return constantDynamic;\n    }\n    int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];\n    int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];\n    String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);\n    String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);\n    int bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];\n    Handle handle = (Handle) readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);\n    Object[] bootstrapMethodArguments = new Object[readUnsignedShort(bootstrapMethodOffset + 2)];\n    bootstrapMethodOffset += 4;\n    for (int i = 0; i < bootstrapMethodArguments.length; i++) {\n      bootstrapMethodArguments[i] = readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);\n      bootstrapMethodOffset += 2;\n    }\n    return constantDynamicValues[constantPoolEntryIndex] =\n        new ConstantDynamic(name, descriptor, handle, bootstrapMethodArguments);\n  }\n\n  /**\n   * Reads a numeric or string constant pool entry in this {@link ClassReader}. <i>This method is\n   * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\n   * adapters.</i>\n   *\n   * @param constantPoolEntryIndex the index of a CONSTANT_Integer, CONSTANT_Float, CONSTANT_Long,\n   *     CONSTANT_Double, CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,\n   *     CONSTANT_MethodHandle or CONSTANT_Dynamic entry in the class's constant pool.\n   * @param charBuffer the buffer to be used to read strings. This buffer must be sufficiently\n   *     large. It is not automatically resized.\n   * @return the {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String},\n   *     {@link Type}, {@link Handle} or {@link ConstantDynamic} corresponding to the specified\n   *     constant pool entry.\n   */\n  public Object readConst(final int constantPoolEntryIndex, final char[] charBuffer) {\n    int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];\n    switch (classFileBuffer[cpInfoOffset - 1]) {\n      case Symbol.CONSTANT_INTEGER_TAG:\n        return readInt(cpInfoOffset);\n      case Symbol.CONSTANT_FLOAT_TAG:\n        return Float.intBitsToFloat(readInt(cpInfoOffset));\n      case Symbol.CONSTANT_LONG_TAG:\n        return readLong(cpInfoOffset);\n      case Symbol.CONSTANT_DOUBLE_TAG:\n        return Double.longBitsToDouble(readLong(cpInfoOffset));\n      case Symbol.CONSTANT_CLASS_TAG:\n        return Type.getObjectType(readUTF8(cpInfoOffset, charBuffer));\n      case Symbol.CONSTANT_STRING_TAG:\n        return readUTF8(cpInfoOffset, charBuffer);\n      case Symbol.CONSTANT_METHOD_TYPE_TAG:\n        return Type.getMethodType(readUTF8(cpInfoOffset, charBuffer));\n      case Symbol.CONSTANT_METHOD_HANDLE_TAG:\n        int referenceKind = readByte(cpInfoOffset);\n        int referenceCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 1)];\n        int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(referenceCpInfoOffset + 2)];\n        String owner = readClass(referenceCpInfoOffset, charBuffer);\n        String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);\n        String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);\n        boolean isInterface =\n            classFileBuffer[referenceCpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;\n        return new Handle(referenceKind, owner, name, descriptor, isInterface);\n      case Symbol.CONSTANT_DYNAMIC_TAG:\n        return readConstantDynamic(constantPoolEntryIndex, charBuffer);\n      default:\n        throw new IllegalArgumentException();\n    }\n  }\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.ClassReader#SKIP_CODE",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.ClassReader#SKIP_CODE",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.ClassReader#SKIP_DEBUG",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.ClassReader#SKIP_DEBUG",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.ClassReader#SKIP_FRAMES",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.ClassReader#SKIP_FRAMES",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.ClassReader#EXPAND_FRAMES",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.ClassReader#EXPAND_FRAMES",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.ClassReader#EXPAND_ASM_INSNS",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.ClassReader#EXPAND_ASM_INSNS",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.ClassReader#MAX_BUFFER_SIZE",
    "tailType": "field"
  }
]