[
  {
    "head": "org.springframework.aot.nativex.RuntimeHintsWriter",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.aot.nativex;\n\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.springframework.aot.hint.RuntimeHints;\nimport org.springframework.core.SpringVersion;\n\n/**\n * Write a {@link RuntimeHints} instance to the JSON output expected by the\n * GraalVM {@code native-image} compiler, typically named {@code reachability-metadata.json}.\n *\n * @author Brian Clozel\n * @since 7.0\n * @see <a href=\"https://www.graalvm.org/jdk23/reference-manual/native-image/metadata/#specifying-metadata-with-json\">GraalVM Reachability Metadata</a>\n */\nclass RuntimeHintsWriter {\n\n\tpublic void write(BasicJsonWriter writer, RuntimeHints hints) {\n\t\tMap<String, Object> document = new LinkedHashMap<>();\n\t\tString springVersion = SpringVersion.getVersion();\n\t\tif (springVersion != null) {\n\t\t\tdocument.put(\"comment\", \"Spring Framework \" + springVersion);\n\t\t}\n\t\tList<Map<String, Object>> reflection = new ReflectionHintsAttributes().reflection(hints);\n\t\tif (!reflection.isEmpty()) {\n\t\t\tdocument.put(\"reflection\", reflection);\n\t\t}\n\t\tList<Map<String, Object>> jni = new ReflectionHintsAttributes().jni(hints);\n\t\tif (!jni.isEmpty()) {\n\t\t\tdocument.put(\"jni\", jni);\n\t\t}\n\t\tList<Map<String, Object>> resourceHints = new ResourceHintsAttributes().resources(hints.resources());\n\t\tif (!resourceHints.isEmpty()) {\n\t\t\tdocument.put(\"resources\", resourceHints);\n\t\t}\n\t\tList<Map<String, Object>> resourceBundles = new ResourceHintsAttributes().resourceBundles(hints.resources());\n\t\tif (!resourceBundles.isEmpty()) {\n\t\t\tdocument.put(\"bundles\", resourceBundles);\n\t\t}\n\t\tList<Map<String, Object>> serialization = new SerializationHintsAttributes().toAttributes(hints.serialization());\n\t\tif (!serialization.isEmpty()) {\n\t\t\tdocument.put(\"serialization\", serialization);\n\t\t}\n\n\t\twriter.writeObject(document);\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.aot.nativex.RuntimeHintsWriter#write(BasicJsonWriter,RuntimeHints)",
    "headType": "method",
    "relation": "provide",
    "tail": "public void write(BasicJsonWriter writer, RuntimeHints hints) {\r\n    Map<String, Object> document = new LinkedHashMap<>();\r\n    String springVersion = SpringVersion.getVersion();\r\n    if (springVersion != null) {\r\n        document.put(\"comment\", \"Spring Framework \" + springVersion);\r\n    }\r\n    List<Map<String, Object>> reflection = new ReflectionHintsAttributes().reflection(hints);\r\n    if (!reflection.isEmpty()) {\r\n        document.put(\"reflection\", reflection);\r\n    }\r\n    List<Map<String, Object>> jni = new ReflectionHintsAttributes().jni(hints);\r\n    if (!jni.isEmpty()) {\r\n        document.put(\"jni\", jni);\r\n    }\r\n    List<Map<String, Object>> resourceHints = new ResourceHintsAttributes().resources(hints.resources());\r\n    if (!resourceHints.isEmpty()) {\r\n        document.put(\"resources\", resourceHints);\r\n    }\r\n    List<Map<String, Object>> resourceBundles = new ResourceHintsAttributes().resourceBundles(hints.resources());\r\n    if (!resourceBundles.isEmpty()) {\r\n        document.put(\"bundles\", resourceBundles);\r\n    }\r\n    List<Map<String, Object>> serialization = new SerializationHintsAttributes().toAttributes(hints.serialization());\r\n    if (!serialization.isEmpty()) {\r\n        document.put(\"serialization\", serialization);\r\n    }\r\n    writer.writeObject(document);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.nativex.RuntimeHintsWriter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.nativex.RuntimeHintsWriter#write(BasicJsonWriter,RuntimeHints)",
    "tailType": "method"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.aot.nativex",
    "tailType": "package"
  },
  {
    "head": "org.springframework.aot.nativex",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.aot.nativex.SerializationHintsAttributes",
    "tailType": "class"
  },
  {
    "head": "org.springframework.aot.nativex.SerializationHintsAttributes",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.aot.nativex;\n\nimport java.util.Comparator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.springframework.aot.hint.ConditionalHint;\nimport org.springframework.aot.hint.JavaSerializationHint;\nimport org.springframework.aot.hint.SerializationHints;\n\n/**\n * Collect {@link SerializationHints} as map attributes ready for JSON serialization for the GraalVM\n * {@code native-image} compiler.\n *\n * @author Sebastien Deleuze\n * @author Stephane Nicoll\n * @author Brian Clozel\n * @see <a href=\"https://www.graalvm.org/jdk23/reference-manual/native-image/overview/BuildConfiguration/\">Native Image Build Configuration</a>\n */\nclass SerializationHintsAttributes {\n\n\tprivate static final Comparator<JavaSerializationHint> JAVA_SERIALIZATION_HINT_COMPARATOR =\n\t\t\tComparator.comparing(JavaSerializationHint::getType);\n\n\tpublic List<Map<String, Object>> toAttributes(SerializationHints hints) {\n\t\treturn hints.javaSerializationHints()\n\t\t\t\t.sorted(JAVA_SERIALIZATION_HINT_COMPARATOR)\n\t\t\t\t.map(this::toAttributes).toList();\n\t}\n\n\tprivate Map<String, Object> toAttributes(JavaSerializationHint serializationHint) {\n\t\tLinkedHashMap<String, Object> attributes = new LinkedHashMap<>();\n\t\thandleCondition(attributes, serializationHint);\n\t\tattributes.put(\"type\", serializationHint.getType());\n\t\treturn attributes;\n\t}\n\n\tprivate void handleCondition(Map<String, Object> attributes, ConditionalHint hint) {\n\t\tif (hint.getReachableType() != null) {\n\t\t\tMap<String, Object> conditionAttributes = new LinkedHashMap<>();\n\t\t\tconditionAttributes.put(\"typeReached\", hint.getReachableType());\n\t\t\tattributes.put(\"condition\", conditionAttributes);\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.aot.nativex.SerializationHintsAttributes",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.aot.nativex.SerializationHintsAttributes#JAVA_SERIALIZATION_HINT_COMPARATOR",
    "tailType": "field"
  },
  {
    "head": "org.springframework.aot.nativex.SerializationHintsAttributes#JAVA_SERIALIZATION_HINT_COMPARATOR",
    "headType": "field",
    "relation": "haveType",
    "tail": "Comparator<JavaSerializationHint>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.aot.nativex.SerializationHintsAttributes#toAttributes(SerializationHints)",
    "headType": "method",
    "relation": "provide",
    "tail": "public List<Map<String, Object>> toAttributes(SerializationHints hints) {\r\n    return hints.javaSerializationHints().sorted(JAVA_SERIALIZATION_HINT_COMPARATOR).map(this::toAttributes).toList();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.nativex.SerializationHintsAttributes",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.nativex.SerializationHintsAttributes#toAttributes(SerializationHints)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.aot.nativex.SerializationHintsAttributes#toAttributes(JavaSerializationHint)",
    "headType": "method",
    "relation": "provide",
    "tail": "private Map<String, Object> toAttributes(JavaSerializationHint serializationHint) {\r\n    LinkedHashMap<String, Object> attributes = new LinkedHashMap<>();\r\n    handleCondition(attributes, serializationHint);\r\n    attributes.put(\"type\", serializationHint.getType());\r\n    return attributes;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.nativex.SerializationHintsAttributes",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.nativex.SerializationHintsAttributes#toAttributes(JavaSerializationHint)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.aot.nativex.SerializationHintsAttributes#handleCondition(Map<String,Object>,ConditionalHint)",
    "headType": "method",
    "relation": "provide",
    "tail": "private void handleCondition(Map<String, Object> attributes, ConditionalHint hint) {\r\n    if (hint.getReachableType() != null) {\r\n        Map<String, Object> conditionAttributes = new LinkedHashMap<>();\r\n        conditionAttributes.put(\"typeReached\", hint.getReachableType());\r\n        attributes.put(\"condition\", conditionAttributes);\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.nativex.SerializationHintsAttributes",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.nativex.SerializationHintsAttributes#handleCondition(Map<String,Object>,ConditionalHint)",
    "tailType": "method"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.aot.nativex.substitution",
    "tailType": "package"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.util",
    "tailType": "package"
  },
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.NumberUtilsTests",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.NumberUtilsTests",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.text.NumberFormat;\nimport java.util.Locale;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n\n/**\n * @author Rob Harrop\n * @author Juergen Hoeller\n */\nclass NumberUtilsTests {\n\n\t@Test\n\tvoid parseNumber() {\n\t\tString aByte = \"\" + Byte.MAX_VALUE;\n\t\tString aShort = \"\" + Short.MAX_VALUE;\n\t\tString anInteger = \"\" + Integer.MAX_VALUE;\n\t\tString aLong = \"\" + Long.MAX_VALUE;\n\t\tString aFloat = \"\" + Float.MAX_VALUE;\n\t\tString aDouble = \"\" + Double.MAX_VALUE;\n\n\t\tassertThat(NumberUtils.parseNumber(aByte, Byte.class)).as(\"Byte did not parse\").isEqualTo(Byte.valueOf(Byte.MAX_VALUE));\n\t\tassertThat(NumberUtils.parseNumber(aShort, Short.class)).as(\"Short did not parse\").isEqualTo(Short.valueOf(Short.MAX_VALUE));\n\t\tassertThat(NumberUtils.parseNumber(anInteger, Integer.class)).as(\"Integer did not parse\").isEqualTo(Integer.valueOf(Integer.MAX_VALUE));\n\t\tassertThat(NumberUtils.parseNumber(aLong, Long.class)).as(\"Long did not parse\").isEqualTo(Long.valueOf(Long.MAX_VALUE));\n\t\tassertThat(NumberUtils.parseNumber(aFloat, Float.class)).as(\"Float did not parse\").isEqualTo(Float.valueOf(Float.MAX_VALUE));\n\t\tassertThat(NumberUtils.parseNumber(aDouble, Double.class)).as(\"Double did not parse\").isEqualTo(Double.valueOf(Double.MAX_VALUE));\n\t}\n\n\t@Test\n\tvoid parseNumberUsingNumberFormat() {\n\t\tNumberFormat nf = NumberFormat.getNumberInstance(Locale.US);\n\t\tString aByte = \"\" + Byte.MAX_VALUE;\n\t\tString aShort = \"\" + Short.MAX_VALUE;\n\t\tString anInteger = \"\" + Integer.MAX_VALUE;\n\t\tString aLong = \"\" + Long.MAX_VALUE;\n\t\tString aFloat = \"\" + Float.MAX_VALUE;\n\t\tString aDouble = \"\" + Double.MAX_VALUE;\n\n\t\tassertThat(NumberUtils.parseNumber(aByte, Byte.class, nf)).as(\"Byte did not parse\").isEqualTo(Byte.valueOf(Byte.MAX_VALUE));\n\t\tassertThat(NumberUtils.parseNumber(aShort, Short.class, nf)).as(\"Short did not parse\").isEqualTo(Short.valueOf(Short.MAX_VALUE));\n\t\tassertThat(NumberUtils.parseNumber(anInteger, Integer.class, nf)).as(\"Integer did not parse\").isEqualTo(Integer.valueOf(Integer.MAX_VALUE));\n\t\tassertThat(NumberUtils.parseNumber(aLong, Long.class, nf)).as(\"Long did not parse\").isEqualTo(Long.valueOf(Long.MAX_VALUE));\n\t\tassertThat(NumberUtils.parseNumber(aFloat, Float.class, nf)).as(\"Float did not parse\").isEqualTo(Float.valueOf(Float.MAX_VALUE));\n\t\tassertThat(NumberUtils.parseNumber(aDouble, Double.class, nf)).as(\"Double did not parse\").isEqualTo(Double.valueOf(Double.MAX_VALUE));\n\t}\n\n\t@Test\n\tvoid parseNumberRequiringTrim() {\n\t\tString aByte = \" \" + Byte.MAX_VALUE + \" \";\n\t\tString aShort = \" \" + Short.MAX_VALUE + \" \";\n\t\tString anInteger = \" \" + Integer.MAX_VALUE + \" \";\n\t\tString aLong = \" \" + Long.MAX_VALUE + \" \";\n\t\tString aFloat = \" \" + Float.MAX_VALUE + \" \";\n\t\tString aDouble = \" \" + Double.MAX_VALUE + \" \";\n\n\t\tassertThat(NumberUtils.parseNumber(aByte, Byte.class)).as(\"Byte did not parse\").isEqualTo(Byte.valueOf(Byte.MAX_VALUE));\n\t\tassertThat(NumberUtils.parseNumber(aShort, Short.class)).as(\"Short did not parse\").isEqualTo(Short.valueOf(Short.MAX_VALUE));\n\t\tassertThat(NumberUtils.parseNumber(anInteger, Integer.class)).as(\"Integer did not parse\").isEqualTo(Integer.valueOf(Integer.MAX_VALUE));\n\t\tassertThat(NumberUtils.parseNumber(aLong, Long.class)).as(\"Long did not parse\").isEqualTo(Long.valueOf(Long.MAX_VALUE));\n\t\tassertThat(NumberUtils.parseNumber(aFloat, Float.class)).as(\"Float did not parse\").isEqualTo(Float.valueOf(Float.MAX_VALUE));\n\t\tassertThat(NumberUtils.parseNumber(aDouble, Double.class)).as(\"Double did not parse\").isEqualTo(Double.valueOf(Double.MAX_VALUE));\n\t}\n\n\t@Test\n\tvoid parseNumberRequiringTrimUsingNumberFormat() {\n\t\tNumberFormat nf = NumberFormat.getNumberInstance(Locale.US);\n\t\tString aByte = \" \" + Byte.MAX_VALUE + \" \";\n\t\tString aShort = \" \" + Short.MAX_VALUE + \" \";\n\t\tString anInteger = \" \" + Integer.MAX_VALUE + \" \";\n\t\tString aLong = \" \" + Long.MAX_VALUE + \" \";\n\t\tString aFloat = \" \" + Float.MAX_VALUE + \" \";\n\t\tString aDouble = \" \" + Double.MAX_VALUE + \" \";\n\n\t\tassertThat(NumberUtils.parseNumber(aByte, Byte.class, nf)).as(\"Byte did not parse\").isEqualTo(Byte.valueOf(Byte.MAX_VALUE));\n\t\tassertThat(NumberUtils.parseNumber(aShort, Short.class, nf)).as(\"Short did not parse\").isEqualTo(Short.valueOf(Short.MAX_VALUE));\n\t\tassertThat(NumberUtils.parseNumber(anInteger, Integer.class, nf)).as(\"Integer did not parse\").isEqualTo(Integer.valueOf(Integer.MAX_VALUE));\n\t\tassertThat(NumberUtils.parseNumber(aLong, Long.class, nf)).as(\"Long did not parse\").isEqualTo(Long.valueOf(Long.MAX_VALUE));\n\t\tassertThat(NumberUtils.parseNumber(aFloat, Float.class, nf)).as(\"Float did not parse\").isEqualTo(Float.valueOf(Float.MAX_VALUE));\n\t\tassertThat(NumberUtils.parseNumber(aDouble, Double.class, nf)).as(\"Double did not parse\").isEqualTo(Double.valueOf(Double.MAX_VALUE));\n\t}\n\n\t@Test\n\tvoid parseNumberAsHex() {\n\t\tString aByte = \"0x\" + Integer.toHexString(Byte.MAX_VALUE);\n\t\tString aShort = \"0x\" + Integer.toHexString(Short.MAX_VALUE);\n\t\tString anInteger = \"0x\" + Integer.toHexString(Integer.MAX_VALUE);\n\t\tString aLong = \"0x\" + Long.toHexString(Long.MAX_VALUE);\n\t\tString aReallyBigInt = \"FEBD4E677898DFEBFFEE44\";\n\n\t\tassertByteEquals(aByte);\n\t\tassertShortEquals(aShort);\n\t\tassertIntegerEquals(anInteger);\n\t\tassertLongEquals(aLong);\n\t\tassertThat(NumberUtils.parseNumber(\"0x\" + aReallyBigInt, BigInteger.class)).as(\"BigInteger did not parse\").isEqualTo(new BigInteger(aReallyBigInt, 16));\n\t}\n\n\t@Test\n\tvoid parseNumberAsNegativeHex() {\n\t\tString aByte = \"-0x80\";\n\t\tString aShort = \"-0x8000\";\n\t\tString anInteger = \"-0x80000000\";\n\t\tString aLong = \"-0x8000000000000000\";\n\t\tString aReallyBigInt = \"FEBD4E677898DFEBFFEE44\";\n\n\t\tassertNegativeByteEquals(aByte);\n\t\tassertNegativeShortEquals(aShort);\n\t\tassertNegativeIntegerEquals(anInteger);\n\t\tassertNegativeLongEquals(aLong);\n\t\tassertThat(NumberUtils.parseNumber(\"-0x\" + aReallyBigInt, BigInteger.class)).as(\"BigInteger did not parse\").isEqualTo(new BigInteger(aReallyBigInt, 16).negate());\n\t}\n\n\t@Test\n\tvoid convertDoubleToBigInteger() {\n\t\tDouble decimal = 3.14d;\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(decimal, BigInteger.class)).isEqualTo(new BigInteger(\"3\"));\n\t}\n\n\t@Test\n\tvoid convertBigDecimalToBigInteger() {\n\t\tString number = \"987459837583750387355346\";\n\t\tBigDecimal decimal = new BigDecimal(number);\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(decimal, BigInteger.class)).isEqualTo(new BigInteger(number));\n\t}\n\n\t@Test\n\tvoid convertNonExactBigDecimalToBigInteger() {\n\t\tBigDecimal decimal = new BigDecimal(\"987459837583750387355346.14\");\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(decimal, BigInteger.class)).isEqualTo(new BigInteger(\"987459837583750387355346\"));\n\t}\n\n\t@Test\n\tvoid parseBigDecimalNumber1() {\n\t\tString bigDecimalAsString = \"0.10\";\n\t\tNumber bigDecimal = NumberUtils.parseNumber(bigDecimalAsString, BigDecimal.class);\n\t\tassertThat(bigDecimal).isEqualTo(new BigDecimal(bigDecimalAsString));\n\t}\n\n\t@Test\n\tvoid parseBigDecimalNumber2() {\n\t\tString bigDecimalAsString = \"0.001\";\n\t\tNumber bigDecimal = NumberUtils.parseNumber(bigDecimalAsString, BigDecimal.class);\n\t\tassertThat(bigDecimal).isEqualTo(new BigDecimal(bigDecimalAsString));\n\t}\n\n\t@Test\n\tvoid parseBigDecimalNumber3() {\n\t\tString bigDecimalAsString = \"3.14159265358979323846\";\n\t\tNumber bigDecimal = NumberUtils.parseNumber(bigDecimalAsString, BigDecimal.class);\n\t\tassertThat(bigDecimal).isEqualTo(new BigDecimal(bigDecimalAsString));\n\t}\n\n\t@Test\n\tvoid parseLocalizedBigDecimalNumber1() {\n\t\tString bigDecimalAsString = \"0.10\";\n\t\tNumberFormat numberFormat = NumberFormat.getInstance(Locale.ENGLISH);\n\t\tNumber bigDecimal = NumberUtils.parseNumber(bigDecimalAsString, BigDecimal.class, numberFormat);\n\t\tassertThat(bigDecimal).isEqualTo(new BigDecimal(bigDecimalAsString));\n\t}\n\n\t@Test\n\tvoid parseLocalizedBigDecimalNumber2() {\n\t\tString bigDecimalAsString = \"0.001\";\n\t\tNumberFormat numberFormat = NumberFormat.getInstance(Locale.ENGLISH);\n\t\tNumber bigDecimal = NumberUtils.parseNumber(bigDecimalAsString, BigDecimal.class, numberFormat);\n\t\tassertThat(bigDecimal).isEqualTo(new BigDecimal(bigDecimalAsString));\n\t}\n\n\t@Test\n\tvoid parseLocalizedBigDecimalNumber3() {\n\t\tString bigDecimalAsString = \"3.14159265358979323846\";\n\t\tNumberFormat numberFormat = NumberFormat.getInstance(Locale.ENGLISH);\n\t\tNumber bigDecimal = NumberUtils.parseNumber(bigDecimalAsString, BigDecimal.class, numberFormat);\n\t\tassertThat(bigDecimal).isEqualTo(new BigDecimal(bigDecimalAsString));\n\t}\n\n\t@Test\n\tvoid parseOverflow() {\n\t\tString aLong = \"\" + Long.MAX_VALUE;\n\t\tString aDouble = \"\" + Double.MAX_VALUE;\n\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tNumberUtils.parseNumber(aLong, Byte.class));\n\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tNumberUtils.parseNumber(aLong, Short.class));\n\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tNumberUtils.parseNumber(aLong, Integer.class));\n\n\t\tassertThat(NumberUtils.parseNumber(aLong, Long.class)).isEqualTo(Long.valueOf(Long.MAX_VALUE));\n\t\tassertThat(NumberUtils.parseNumber(aDouble, Double.class)).isEqualTo(Double.valueOf(Double.MAX_VALUE));\n\t}\n\n\t@Test\n\tvoid parseNegativeOverflow() {\n\t\tString aLong = \"\" + Long.MIN_VALUE;\n\t\tString aDouble = \"\" + Double.MIN_VALUE;\n\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tNumberUtils.parseNumber(aLong, Byte.class));\n\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tNumberUtils.parseNumber(aLong, Short.class));\n\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tNumberUtils.parseNumber(aLong, Integer.class));\n\n\t\tassertThat(NumberUtils.parseNumber(aLong, Long.class)).isEqualTo(Long.valueOf(Long.MIN_VALUE));\n\t\tassertThat(NumberUtils.parseNumber(aDouble, Double.class)).isEqualTo(Double.valueOf(Double.MIN_VALUE));\n\t}\n\n\t@Test\n\tvoid parseOverflowUsingNumberFormat() {\n\t\tNumberFormat nf = NumberFormat.getNumberInstance(Locale.US);\n\t\tString aLong = \"\" + Long.MAX_VALUE;\n\t\tString aDouble = \"\" + Double.MAX_VALUE;\n\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tNumberUtils.parseNumber(aLong, Byte.class, nf));\n\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tNumberUtils.parseNumber(aLong, Short.class, nf));\n\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tNumberUtils.parseNumber(aLong, Integer.class, nf));\n\n\t\tassertThat(NumberUtils.parseNumber(aLong, Long.class, nf)).isEqualTo(Long.valueOf(Long.MAX_VALUE));\n\t\tassertThat(NumberUtils.parseNumber(aDouble, Double.class, nf)).isEqualTo(Double.valueOf(Double.MAX_VALUE));\n\t}\n\n\t@Test\n\tvoid parseNegativeOverflowUsingNumberFormat() {\n\t\tNumberFormat nf = NumberFormat.getNumberInstance(Locale.US);\n\t\tString aLong = \"\" + Long.MIN_VALUE;\n\t\tString aDouble = \"\" + Double.MIN_VALUE;\n\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tNumberUtils.parseNumber(aLong, Byte.class, nf));\n\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tNumberUtils.parseNumber(aLong, Short.class, nf));\n\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tNumberUtils.parseNumber(aLong, Integer.class, nf));\n\n\t\tassertThat(NumberUtils.parseNumber(aLong, Long.class, nf)).isEqualTo(Long.valueOf(Long.MIN_VALUE));\n\t\tassertThat(NumberUtils.parseNumber(aDouble, Double.class, nf)).isEqualTo(Double.valueOf(Double.MIN_VALUE));\n\t}\n\n\t@Test\n\tvoid convertToInteger() {\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(BigInteger.valueOf(-1), Integer.class)).isEqualTo(Integer.valueOf(-1));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(BigInteger.valueOf(0), Integer.class)).isEqualTo(Integer.valueOf(0));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(BigInteger.valueOf(1), Integer.class)).isEqualTo(Integer.valueOf(1));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(BigInteger.valueOf(Integer.MAX_VALUE), Integer.class)).isEqualTo(Integer.valueOf(Integer.MAX_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(BigInteger.valueOf(Integer.MAX_VALUE + 1), Integer.class)).isEqualTo(Integer.valueOf(Integer.MIN_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(BigInteger.valueOf(Integer.MIN_VALUE), Integer.class)).isEqualTo(Integer.valueOf(Integer.MIN_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(BigInteger.valueOf(Integer.MIN_VALUE - 1), Integer.class)).isEqualTo(Integer.valueOf(Integer.MAX_VALUE));\n\n\t\tassertThat(NumberUtils.convertNumberToTargetClass((long) -1, Integer.class)).isEqualTo(Integer.valueOf(-1));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(0L, Integer.class)).isEqualTo(Integer.valueOf(0));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(1L, Integer.class)).isEqualTo(Integer.valueOf(1));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass((long) Integer.MAX_VALUE, Integer.class)).isEqualTo(Integer.valueOf(Integer.MAX_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass((long) (Integer.MAX_VALUE + 1), Integer.class)).isEqualTo(Integer.valueOf(Integer.MIN_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass((long) Integer.MIN_VALUE, Integer.class)).isEqualTo(Integer.valueOf(Integer.MIN_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass((long) (Integer.MIN_VALUE - 1), Integer.class)).isEqualTo(Integer.valueOf(Integer.MAX_VALUE));\n\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(-1, Integer.class)).isEqualTo(Integer.valueOf(-1));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(0, Integer.class)).isEqualTo(Integer.valueOf(0));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(1, Integer.class)).isEqualTo(Integer.valueOf(1));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(Integer.MAX_VALUE, Integer.class)).isEqualTo(Integer.valueOf(Integer.MAX_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(Integer.MAX_VALUE + 1, Integer.class)).isEqualTo(Integer.valueOf(Integer.MIN_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(Integer.MIN_VALUE, Integer.class)).isEqualTo(Integer.valueOf(Integer.MIN_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(Integer.MIN_VALUE - 1, Integer.class)).isEqualTo(Integer.valueOf(Integer.MAX_VALUE));\n\n\t\tassertThat(NumberUtils.convertNumberToTargetClass((short) -1, Integer.class)).isEqualTo(Integer.valueOf(-1));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass((short) 0, Integer.class)).isEqualTo(Integer.valueOf(0));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass((short) 1, Integer.class)).isEqualTo(Integer.valueOf(1));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(Short.MAX_VALUE, Integer.class)).isEqualTo(Integer.valueOf(Short.MAX_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass((short) (Short.MAX_VALUE + 1), Integer.class)).isEqualTo(Integer.valueOf(Short.MIN_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(Short.MIN_VALUE, Integer.class)).isEqualTo(Integer.valueOf(Short.MIN_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass((short) (Short.MIN_VALUE - 1), Integer.class)).isEqualTo(Integer.valueOf(Short.MAX_VALUE));\n\n\t\tassertThat(NumberUtils.convertNumberToTargetClass((byte) -1, Integer.class)).isEqualTo(Integer.valueOf(-1));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass((byte) 0, Integer.class)).isEqualTo(Integer.valueOf(0));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass((byte) 1, Integer.class)).isEqualTo(Integer.valueOf(1));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(Byte.MAX_VALUE, Integer.class)).isEqualTo(Integer.valueOf(Byte.MAX_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass((byte) (Byte.MAX_VALUE + 1), Integer.class)).isEqualTo(Integer.valueOf(Byte.MIN_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(Byte.MIN_VALUE, Integer.class)).isEqualTo(Integer.valueOf(Byte.MIN_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass((byte) (Byte.MIN_VALUE - 1), Integer.class)).isEqualTo(Integer.valueOf(Byte.MAX_VALUE));\n\n\t\tassertToNumberOverflow(Long.MAX_VALUE + 1, Integer.class);\n\t\tassertToNumberOverflow(Long.MIN_VALUE - 1, Integer.class);\n\t\tassertToNumberOverflow(BigInteger.valueOf(Integer.MAX_VALUE).add(BigInteger.ONE), Integer.class);\n\t\tassertToNumberOverflow(BigInteger.valueOf(Integer.MIN_VALUE).subtract(BigInteger.ONE), Integer.class);\n\t\tassertToNumberOverflow(new BigDecimal(\"18446744073709551611\"), Integer.class);\n\t}\n\n\t@Test\n\tvoid convertToLong() {\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(BigInteger.valueOf(-1), Long.class)).isEqualTo(Long.valueOf(-1));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(BigInteger.valueOf(0), Long.class)).isEqualTo(Long.valueOf(0));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(BigInteger.valueOf(1), Long.class)).isEqualTo(Long.valueOf(1));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(BigInteger.valueOf(Long.MAX_VALUE), Long.class)).isEqualTo(Long.valueOf(Long.MAX_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(BigInteger.valueOf(Long.MAX_VALUE + 1), Long.class)).isEqualTo(Long.valueOf(Long.MIN_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(BigInteger.valueOf(Long.MIN_VALUE), Long.class)).isEqualTo(Long.valueOf(Long.MIN_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(BigInteger.valueOf(Long.MIN_VALUE - 1), Long.class)).isEqualTo(Long.valueOf(Long.MAX_VALUE));\n\n\t\tassertThat(NumberUtils.convertNumberToTargetClass((long) -1, Long.class)).isEqualTo(Long.valueOf(-1));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(0L, Long.class)).isEqualTo(Long.valueOf(0));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(1L, Long.class)).isEqualTo(Long.valueOf(1));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(Long.MAX_VALUE, Long.class)).isEqualTo(Long.valueOf(Long.MAX_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(Long.MAX_VALUE + 1, Long.class)).isEqualTo(Long.valueOf(Long.MIN_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(Long.MIN_VALUE, Long.class)).isEqualTo(Long.valueOf(Long.MIN_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(Long.MIN_VALUE - 1, Long.class)).isEqualTo(Long.valueOf(Long.MAX_VALUE));\n\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(-1, Long.class)).isEqualTo(Long.valueOf(-1));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(0, Long.class)).isEqualTo(Long.valueOf(0));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(1, Long.class)).isEqualTo(Long.valueOf(1));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(Integer.MAX_VALUE, Long.class)).isEqualTo(Long.valueOf(Integer.MAX_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(Integer.MAX_VALUE + 1, Long.class)).isEqualTo(Long.valueOf(Integer.MIN_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(Integer.MIN_VALUE, Long.class)).isEqualTo(Long.valueOf(Integer.MIN_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(Integer.MIN_VALUE - 1, Long.class)).isEqualTo(Long.valueOf(Integer.MAX_VALUE));\n\n\t\tassertThat(NumberUtils.convertNumberToTargetClass((short) -1, Long.class)).isEqualTo(Long.valueOf(-1));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass((short) 0, Long.class)).isEqualTo(Long.valueOf(0));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass((short) 1, Long.class)).isEqualTo(Long.valueOf(1));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(Short.MAX_VALUE, Long.class)).isEqualTo(Long.valueOf(Short.MAX_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass((short) (Short.MAX_VALUE + 1), Long.class)).isEqualTo(Long.valueOf(Short.MIN_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(Short.MIN_VALUE, Long.class)).isEqualTo(Long.valueOf(Short.MIN_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass((short) (Short.MIN_VALUE - 1), Long.class)).isEqualTo(Long.valueOf(Short.MAX_VALUE));\n\n\t\tassertThat(NumberUtils.convertNumberToTargetClass((byte) -1, Long.class)).isEqualTo(Long.valueOf(-1));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass((byte) 0, Long.class)).isEqualTo(Long.valueOf(0));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass((byte) 1, Long.class)).isEqualTo(Long.valueOf(1));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(Byte.MAX_VALUE, Long.class)).isEqualTo(Long.valueOf(Byte.MAX_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass((byte) (Byte.MAX_VALUE + 1), Long.class)).isEqualTo(Long.valueOf(Byte.MIN_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass(Byte.MIN_VALUE, Long.class)).isEqualTo(Long.valueOf(Byte.MIN_VALUE));\n\t\tassertThat(NumberUtils.convertNumberToTargetClass((byte) (Byte.MIN_VALUE - 1), Long.class)).isEqualTo(Long.valueOf(Byte.MAX_VALUE));\n\n\t\tassertToNumberOverflow(BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE), Long.class);\n\t\tassertToNumberOverflow(BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.ONE), Long.class);\n\t\tassertToNumberOverflow(new BigDecimal(\"18446744073709551611\"), Long.class);\n\t}\n\n\n\tprivate void assertLongEquals(String aLong) {\n\t\tassertThat(NumberUtils.parseNumber(aLong, Long.class)).as(\"Long did not parse\").isEqualTo(Long.MAX_VALUE);\n\t}\n\n\tprivate void assertIntegerEquals(String anInteger) {\n\t\tassertThat(NumberUtils.parseNumber(anInteger, Integer.class)).as(\"Integer did not parse\").isEqualTo(Integer.MAX_VALUE);\n\t}\n\n\tprivate void assertShortEquals(String aShort) {\n\t\tassertThat(NumberUtils.parseNumber(aShort, Short.class)).as(\"Short did not parse\").isEqualTo(Short.MAX_VALUE);\n\t}\n\n\tprivate void assertByteEquals(String aByte) {\n\t\tassertThat(NumberUtils.parseNumber(aByte, Byte.class)).as(\"Byte did not parse\").isEqualTo(Byte.MAX_VALUE);\n\t}\n\n\tprivate void assertNegativeLongEquals(String aLong) {\n\t\tassertThat(NumberUtils.parseNumber(aLong, Long.class)).as(\"Long did not parse\").isEqualTo(Long.MIN_VALUE);\n\t}\n\n\tprivate void assertNegativeIntegerEquals(String anInteger) {\n\t\tassertThat(NumberUtils.parseNumber(anInteger, Integer.class)).as(\"Integer did not parse\").isEqualTo(Integer.MIN_VALUE);\n\t}\n\n\tprivate void assertNegativeShortEquals(String aShort) {\n\t\tassertThat(NumberUtils.parseNumber(aShort, Short.class)).as(\"Short did not parse\").isEqualTo(Short.MIN_VALUE);\n\t}\n\n\tprivate void assertNegativeByteEquals(String aByte) {\n\t\tassertThat(NumberUtils.parseNumber(aByte, Byte.class)).as(\"Byte did not parse\").isEqualTo(Byte.MIN_VALUE);\n\t}\n\n\tprivate void assertToNumberOverflow(Number number, Class<? extends Number> targetClass) {\n\t\tString msg = \"overflow: from=\" + number + \", toClass=\" + targetClass;\n\t\tassertThatIllegalArgumentException().as(msg).isThrownBy(() ->\n\t\t\t\tNumberUtils.convertNumberToTargetClass(number, targetClass))\n\t\t\t.withMessageEndingWith(\"overflow\");\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.NumberUtilsTests#parseNumber()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid parseNumber() {\r\n    String aByte = \"\" + Byte.MAX_VALUE;\r\n    String aShort = \"\" + Short.MAX_VALUE;\r\n    String anInteger = \"\" + Integer.MAX_VALUE;\r\n    String aLong = \"\" + Long.MAX_VALUE;\r\n    String aFloat = \"\" + Float.MAX_VALUE;\r\n    String aDouble = \"\" + Double.MAX_VALUE;\r\n    assertThat(NumberUtils.parseNumber(aByte, Byte.class)).as(\"Byte did not parse\").isEqualTo(Byte.valueOf(Byte.MAX_VALUE));\r\n    assertThat(NumberUtils.parseNumber(aShort, Short.class)).as(\"Short did not parse\").isEqualTo(Short.valueOf(Short.MAX_VALUE));\r\n    assertThat(NumberUtils.parseNumber(anInteger, Integer.class)).as(\"Integer did not parse\").isEqualTo(Integer.valueOf(Integer.MAX_VALUE));\r\n    assertThat(NumberUtils.parseNumber(aLong, Long.class)).as(\"Long did not parse\").isEqualTo(Long.valueOf(Long.MAX_VALUE));\r\n    assertThat(NumberUtils.parseNumber(aFloat, Float.class)).as(\"Float did not parse\").isEqualTo(Float.valueOf(Float.MAX_VALUE));\r\n    assertThat(NumberUtils.parseNumber(aDouble, Double.class)).as(\"Double did not parse\").isEqualTo(Double.valueOf(Double.MAX_VALUE));\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.NumberUtilsTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.NumberUtilsTests#parseNumber()",
    "tailType": "method"
  }
]