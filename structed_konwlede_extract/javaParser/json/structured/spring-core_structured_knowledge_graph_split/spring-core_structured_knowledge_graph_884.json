[
  {
    "head": "org.springframework.core.convert.support.ConvertersForPair",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.convert.support.ConvertersForPair#getConverter(TypeDescriptor,TypeDescriptor)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.convert.support.ConvertersForPair#getConverter(TypeDescriptor,TypeDescriptor)",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.convert.support.ConvertersForPair#toString()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic String toString() {\r\n    return StringUtils.collectionToCommaDelimitedString(this.converters);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.convert.support.ConvertersForPair",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.convert.support.ConvertersForPair#toString()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.convert.support.ConvertersForPair#toString()",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.convert.support",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.convert.support.NoOpConverter",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.convert.support.NoOpConverter",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.convert.support;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedDeque;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.core.DecoratingProxy;\nimport org.springframework.core.ResolvableType;\nimport org.springframework.core.convert.ConversionFailedException;\nimport org.springframework.core.convert.ConversionService;\nimport org.springframework.core.convert.ConverterNotFoundException;\nimport org.springframework.core.convert.TypeDescriptor;\nimport org.springframework.core.convert.converter.ConditionalConverter;\nimport org.springframework.core.convert.converter.ConditionalGenericConverter;\nimport org.springframework.core.convert.converter.Converter;\nimport org.springframework.core.convert.converter.ConverterFactory;\nimport org.springframework.core.convert.converter.ConverterRegistry;\nimport org.springframework.core.convert.converter.GenericConverter;\nimport org.springframework.core.convert.converter.GenericConverter.ConvertiblePair;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.ConcurrentReferenceHashMap;\nimport org.springframework.util.StringUtils;\n\n/**\n * Base {@link ConversionService} implementation suitable for use in most environments.\n * Indirectly implements {@link ConverterRegistry} as registration API through the\n * {@link ConfigurableConversionService} interface.\n *\n * @author Keith Donald\n * @author Juergen Hoeller\n * @author Chris Beams\n * @author Phillip Webb\n * @author David Haraburda\n * @since 3.0\n */\npublic class GenericConversionService implements ConfigurableConversionService {\n\n\t/**\n\t * General NO-OP converter used when conversion is not required.\n\t */\n\tprivate static final GenericConverter NO_OP_CONVERTER = new NoOpConverter(\"NO_OP\");\n\n\t/**\n\t * Used as a cache entry when no converter is available.\n\t * This converter is never returned.\n\t */\n\tprivate static final GenericConverter NO_MATCH = new NoOpConverter(\"NO_MATCH\");\n\n\n\tprivate final Converters converters = new Converters();\n\n\tprivate final Map<ConverterCacheKey, GenericConverter> converterCache = new ConcurrentReferenceHashMap<>(64);\n\n\n\t// ConverterRegistry implementation\n\n\t@Override\n\tpublic void addConverter(Converter<?, ?> converter) {\n\t\tResolvableType[] typeInfo = getRequiredTypeInfo(converter.getClass(), Converter.class);\n\t\tif (typeInfo == null && converter instanceof DecoratingProxy decoratingProxy) {\n\t\t\ttypeInfo = getRequiredTypeInfo(decoratingProxy.getDecoratedClass(), Converter.class);\n\t\t}\n\t\tif (typeInfo == null) {\n\t\t\tthrow new IllegalArgumentException(\"Unable to determine source type <S> and target type <T> for your \" +\n\t\t\t\t\t\"Converter [\" + converter.getClass().getName() + \"]; does the class parameterize those types?\");\n\t\t}\n\t\taddConverter(new ConverterAdapter(converter, typeInfo[0], typeInfo[1]));\n\t}\n\n\t@Override\n\tpublic <S, T> void addConverter(Class<S> sourceType, Class<T> targetType, Converter<? super S, ? extends T> converter) {\n\t\taddConverter(new ConverterAdapter(\n\t\t\t\tconverter, ResolvableType.forClass(sourceType), ResolvableType.forClass(targetType)));\n\t}\n\n\t@Override\n\tpublic void addConverter(GenericConverter converter) {\n\t\tthis.converters.add(converter);\n\t\tinvalidateCache();\n\t}\n\n\t@Override\n\tpublic void addConverterFactory(ConverterFactory<?, ?> factory) {\n\t\tResolvableType[] typeInfo = getRequiredTypeInfo(factory.getClass(), ConverterFactory.class);\n\t\tif (typeInfo == null && factory instanceof DecoratingProxy decoratingProxy) {\n\t\t\ttypeInfo = getRequiredTypeInfo(decoratingProxy.getDecoratedClass(), ConverterFactory.class);\n\t\t}\n\t\tif (typeInfo == null) {\n\t\t\tthrow new IllegalArgumentException(\"Unable to determine source type <S> and target type <T> for your \" +\n\t\t\t\t\t\"ConverterFactory [\" + factory.getClass().getName() + \"]; does the class parameterize those types?\");\n\t\t}\n\t\taddConverter(new ConverterFactoryAdapter(factory,\n\t\t\t\tnew ConvertiblePair(typeInfo[0].toClass(), typeInfo[1].toClass())));\n\t}\n\n\t@Override\n\tpublic void removeConvertible(Class<?> sourceType, Class<?> targetType) {\n\t\tthis.converters.remove(sourceType, targetType);\n\t\tinvalidateCache();\n\t}\n\n\n\t// ConversionService implementation\n\n\t@Override\n\tpublic boolean canConvert(@Nullable Class<?> sourceType, Class<?> targetType) {\n\t\tAssert.notNull(targetType, \"Target type to convert to cannot be null\");\n\t\treturn canConvert((sourceType != null ? TypeDescriptor.valueOf(sourceType) : null),\n\t\t\t\tTypeDescriptor.valueOf(targetType));\n\t}\n\n\t@Override\n\tpublic boolean canConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\tAssert.notNull(targetType, \"Target type to convert to cannot be null\");\n\t\treturn (sourceType == null || getConverter(sourceType, targetType) != null);\n\t}\n\n\t/**\n\t * Return whether conversion between the source type and the target type can be bypassed.\n\t * <p>More precisely, this method will return true if objects of sourceType can be\n\t * converted to the target type by returning the source object unchanged.\n\t * @param sourceType context about the source type to convert from\n\t * (may be {@code null} if source is {@code null})\n\t * @param targetType context about the target type to convert to (required)\n\t * @return {@code true} if conversion can be bypassed; {@code false} otherwise\n\t * @throws IllegalArgumentException if targetType is {@code null}\n\t * @since 3.2\n\t */\n\tpublic boolean canBypassConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\tAssert.notNull(targetType, \"Target type to convert to cannot be null\");\n\t\treturn (sourceType == null || getConverter(sourceType, targetType) == NO_OP_CONVERTER);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T> @Nullable T convert(@Nullable Object source, Class<T> targetType) {\n\t\tAssert.notNull(targetType, \"Target type to convert to cannot be null\");\n\t\treturn (T) convert(source, TypeDescriptor.forObject(source), TypeDescriptor.valueOf(targetType));\n\t}\n\n\t@Override\n\tpublic @Nullable Object convert(@Nullable Object source, @Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\tAssert.notNull(targetType, \"Target type to convert to cannot be null\");\n\t\tif (sourceType == null) {\n\t\t\tAssert.isTrue(source == null, \"Source must be [null] if source type == [null]\");\n\t\t\treturn handleResult(null, targetType, convertNullSource(null, targetType));\n\t\t}\n\t\tif (source != null && !sourceType.getObjectType().isInstance(source)) {\n\t\t\tthrow new IllegalArgumentException(\"Source to convert from must be an instance of [\" +\n\t\t\t\t\tsourceType + \"]; instead it was a [\" + source.getClass().getName() + \"]\");\n\t\t}\n\t\tGenericConverter converter = getConverter(sourceType, targetType);\n\t\tif (converter != null) {\n\t\t\tObject result = ConversionUtils.invokeConverter(converter, source, sourceType, targetType);\n\t\t\treturn handleResult(sourceType, targetType, result);\n\t\t}\n\t\treturn handleConverterNotFound(source, sourceType, targetType);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn this.converters.toString();\n\t}\n\n\n\t// Protected template methods\n\n\t/**\n\t * Template method to convert a {@code null} source.\n\t * <p>The default implementation returns {@code null} or the Java 8\n\t * {@link java.util.Optional#empty()} instance if the target type is\n\t * {@code java.util.Optional}. Subclasses may override this to return\n\t * custom {@code null} objects for specific target types.\n\t * @param sourceType the source type to convert from\n\t * @param targetType the target type to convert to\n\t * @return the converted null object\n\t */\n\tprotected @Nullable Object convertNullSource(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\tif (targetType.getObjectType() == Optional.class) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Hook method to look up the converter for a given sourceType/targetType pair.\n\t * First queries this ConversionService's converter cache.\n\t * On a cache miss, then performs an exhaustive search for a matching converter.\n\t * If no converter matches, returns the default converter.\n\t * @param sourceType the source type to convert from\n\t * @param targetType the target type to convert to\n\t * @return the generic converter that will perform the conversion,\n\t * or {@code null} if no suitable converter was found\n\t * @see #getDefaultConverter(TypeDescriptor, TypeDescriptor)\n\t */\n\tprotected @Nullable GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\tConverterCacheKey key = new ConverterCacheKey(sourceType, targetType);\n\t\tGenericConverter converter = this.converterCache.get(key);\n\t\tif (converter != null) {\n\t\t\treturn (converter != NO_MATCH ? converter : null);\n\t\t}\n\n\t\tconverter = this.converters.find(sourceType, targetType);\n\t\tif (converter == null) {\n\t\t\tconverter = getDefaultConverter(sourceType, targetType);\n\t\t}\n\n\t\tif (converter != null) {\n\t\t\tthis.converterCache.put(key, converter);\n\t\t\treturn converter;\n\t\t}\n\n\t\tthis.converterCache.put(key, NO_MATCH);\n\t\treturn null;\n\t}\n\n\t/**\n\t * Return the default converter if no converter is found for the given sourceType/targetType pair.\n\t * <p>Returns a NO_OP Converter if the source type is assignable to the target type.\n\t * Returns {@code null} otherwise, indicating no suitable converter could be found.\n\t * @param sourceType the source type to convert from\n\t * @param targetType the target type to convert to\n\t * @return the default generic converter that will perform the conversion\n\t */\n\tprotected @Nullable GenericConverter getDefaultConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\treturn (sourceType.isAssignableTo(targetType) ? NO_OP_CONVERTER : null);\n\t}\n\n\n\t// Internal helpers\n\n\tprivate ResolvableType @Nullable [] getRequiredTypeInfo(Class<?> converterClass, Class<?> genericIfc) {\n\t\tResolvableType resolvableType = ResolvableType.forClass(converterClass).as(genericIfc);\n\t\tResolvableType[] generics = resolvableType.getGenerics();\n\t\tif (generics.length < 2) {\n\t\t\treturn null;\n\t\t}\n\t\tClass<?> sourceType = generics[0].resolve();\n\t\tClass<?> targetType = generics[1].resolve();\n\t\tif (sourceType == null || targetType == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn generics;\n\t}\n\n\tprivate void invalidateCache() {\n\t\tthis.converterCache.clear();\n\t}\n\n\tprivate @Nullable Object handleConverterNotFound(\n\t\t\t@Nullable Object source, @Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {\n\n\t\tif (source == null) {\n\t\t\tassertNotPrimitiveTargetType(sourceType, targetType);\n\t\t\treturn null;\n\t\t}\n\t\tif ((sourceType == null || sourceType.isAssignableTo(targetType)) &&\n\t\t\t\ttargetType.getObjectType().isInstance(source)) {\n\t\t\treturn source;\n\t\t}\n\t\tthrow new ConverterNotFoundException(sourceType, targetType);\n\t}\n\n\tprivate @Nullable Object handleResult(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType, @Nullable Object result) {\n\t\tif (result == null) {\n\t\t\tassertNotPrimitiveTargetType(sourceType, targetType);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate void assertNotPrimitiveTargetType(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\tif (targetType.isPrimitive()) {\n\t\t\tthrow new ConversionFailedException(sourceType, targetType, null,\n\t\t\t\t\tnew IllegalArgumentException(\"A null value cannot be assigned to a primitive type\"));\n\t\t}\n\t}\n\n\n\t/**\n\t * Adapts a {@link Converter} to a {@link GenericConverter}.\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprivate final class ConverterAdapter implements ConditionalGenericConverter {\n\n\t\tprivate final Converter<Object, Object> converter;\n\n\t\tprivate final ConvertiblePair typeInfo;\n\n\t\tprivate final ResolvableType targetType;\n\n\t\tpublic ConverterAdapter(Converter<?, ?> converter, ResolvableType sourceType, ResolvableType targetType) {\n\t\t\tthis.converter = (Converter<Object, Object>) converter;\n\t\t\tthis.typeInfo = new ConvertiblePair(sourceType.toClass(), targetType.toClass());\n\t\t\tthis.targetType = targetType;\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<ConvertiblePair> getConvertibleTypes() {\n\t\t\treturn Collections.singleton(this.typeInfo);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\t// Check raw type first...\n\t\t\tif (this.typeInfo.getTargetType() != targetType.getObjectType()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// Full check for complex generic type match required?\n\t\t\tResolvableType rt = targetType.getResolvableType();\n\t\t\tif (!(rt.getType() instanceof Class) && !rt.isAssignableFromResolvedPart(this.targetType)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn !(this.converter instanceof ConditionalConverter conditionalConverter) ||\n\t\t\t\t\tconditionalConverter.matches(sourceType, targetType);\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\tif (source == null) {\n\t\t\t\treturn convertNullSource(sourceType, targetType);\n\t\t\t}\n\t\t\treturn this.converter.convert(source);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.typeInfo + \" : \" + this.converter;\n\t\t}\n\t}\n\n\n\t/**\n\t * Adapts a {@link ConverterFactory} to a {@link GenericConverter}.\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprivate final class ConverterFactoryAdapter implements ConditionalGenericConverter {\n\n\t\tprivate final ConverterFactory<Object, Object> converterFactory;\n\n\t\tprivate final ConvertiblePair typeInfo;\n\n\t\tpublic ConverterFactoryAdapter(ConverterFactory<?, ?> converterFactory, ConvertiblePair typeInfo) {\n\t\t\tthis.converterFactory = (ConverterFactory<Object, Object>) converterFactory;\n\t\t\tthis.typeInfo = typeInfo;\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<ConvertiblePair> getConvertibleTypes() {\n\t\t\treturn Collections.singleton(this.typeInfo);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\tboolean matches = true;\n\t\t\tif (this.converterFactory instanceof ConditionalConverter conditionalConverter) {\n\t\t\t\tmatches = conditionalConverter.matches(sourceType, targetType);\n\t\t\t}\n\t\t\tif (matches) {\n\t\t\t\tConverter<?, ?> converter = this.converterFactory.getConverter(targetType.getType());\n\t\t\t\tif (converter instanceof ConditionalConverter conditionalConverter) {\n\t\t\t\t\tmatches = conditionalConverter.matches(sourceType, targetType);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn matches;\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\tif (source == null) {\n\t\t\t\treturn convertNullSource(sourceType, targetType);\n\t\t\t}\n\t\t\treturn this.converterFactory.getConverter(targetType.getObjectType()).convert(source);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.typeInfo + \" : \" + this.converterFactory;\n\t\t}\n\t}\n\n\n\t/**\n\t * Key for use with the converter cache.\n\t */\n\tprivate static final class ConverterCacheKey implements Comparable<ConverterCacheKey> {\n\n\t\tprivate final TypeDescriptor sourceType;\n\n\t\tprivate final TypeDescriptor targetType;\n\n\t\tpublic ConverterCacheKey(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\tthis.sourceType = sourceType;\n\t\t\tthis.targetType = targetType;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || (other instanceof ConverterCacheKey that &&\n\t\t\t\t\tthis.sourceType.equals(that.sourceType)) &&\n\t\t\t\t\tthis.targetType.equals(that.targetType));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn this.sourceType.hashCode() * 29 + this.targetType.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"ConverterCacheKey [sourceType = \" + this.sourceType + \", targetType = \" + this.targetType + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(ConverterCacheKey other) {\n\t\t\tint result = this.sourceType.getResolvableType().toString().compareTo(\n\t\t\t\t\tother.sourceType.getResolvableType().toString());\n\t\t\tif (result == 0) {\n\t\t\t\tresult = this.targetType.getResolvableType().toString().compareTo(\n\t\t\t\t\t\tother.targetType.getResolvableType().toString());\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\n\t/**\n\t * Manages all converters registered with the service.\n\t */\n\tprivate static class Converters {\n\n\t\tprivate final Set<GenericConverter> globalConverters = new CopyOnWriteArraySet<>();\n\n\t\tprivate final Map<ConvertiblePair, ConvertersForPair> converters = new ConcurrentHashMap<>(256);\n\n\t\tpublic void add(GenericConverter converter) {\n\t\t\tSet<ConvertiblePair> convertibleTypes = converter.getConvertibleTypes();\n\t\t\tif (convertibleTypes == null) {\n\t\t\t\tAssert.state(converter instanceof ConditionalConverter,\n\t\t\t\t\t\t\"Only conditional converters may return null convertible types\");\n\t\t\t\tthis.globalConverters.add(converter);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (ConvertiblePair convertiblePair : convertibleTypes) {\n\t\t\t\t\tgetMatchableConverters(convertiblePair).add(converter);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate ConvertersForPair getMatchableConverters(ConvertiblePair convertiblePair) {\n\t\t\treturn this.converters.computeIfAbsent(convertiblePair, k -> new ConvertersForPair());\n\t\t}\n\n\t\tpublic void remove(Class<?> sourceType, Class<?> targetType) {\n\t\t\tthis.converters.remove(new ConvertiblePair(sourceType, targetType));\n\t\t}\n\n\t\t/**\n\t\t * Find a {@link GenericConverter} given a source and target type.\n\t\t * <p>This method will attempt to match all possible converters by working\n\t\t * through the class and interface hierarchy of the types.\n\t\t * @param sourceType the source type\n\t\t * @param targetType the target type\n\t\t * @return a matching {@link GenericConverter}, or {@code null} if none found\n\t\t */\n\t\tpublic @Nullable GenericConverter find(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\t// Search the full type hierarchy\n\t\t\tList<Class<?>> sourceCandidates = getClassHierarchy(sourceType.getType());\n\t\t\tList<Class<?>> targetCandidates = getClassHierarchy(targetType.getType());\n\t\t\tfor (Class<?> sourceCandidate : sourceCandidates) {\n\t\t\t\tfor (Class<?> targetCandidate : targetCandidates) {\n\t\t\t\t\tConvertiblePair convertiblePair = new ConvertiblePair(sourceCandidate, targetCandidate);\n\t\t\t\t\tGenericConverter converter = getRegisteredConverter(sourceType, targetType, convertiblePair);\n\t\t\t\t\tif (converter != null) {\n\t\t\t\t\t\treturn converter;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tprivate @Nullable GenericConverter getRegisteredConverter(TypeDescriptor sourceType,\n\t\t\t\tTypeDescriptor targetType, ConvertiblePair convertiblePair) {\n\n\t\t\t// Check specifically registered converters\n\t\t\tConvertersForPair convertersForPair = this.converters.get(convertiblePair);\n\t\t\tif (convertersForPair != null) {\n\t\t\t\tGenericConverter converter = convertersForPair.getConverter(sourceType, targetType);\n\t\t\t\tif (converter != null) {\n\t\t\t\t\treturn converter;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check ConditionalConverters for a dynamic match\n\t\t\tfor (GenericConverter globalConverter : this.globalConverters) {\n\t\t\t\tif (((ConditionalConverter) globalConverter).matches(sourceType, targetType)) {\n\t\t\t\t\treturn globalConverter;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Returns an ordered class hierarchy for the given type.\n\t\t * @param type the type\n\t\t * @return an ordered list of all classes that the given type extends or implements\n\t\t */\n\t\tprivate List<Class<?>> getClassHierarchy(Class<?> type) {\n\t\t\tList<Class<?>> hierarchy = new ArrayList<>(20);\n\t\t\tSet<Class<?>> visited = new HashSet<>(20);\n\t\t\taddToClassHierarchy(0, ClassUtils.resolvePrimitiveIfNecessary(type), false, hierarchy, visited);\n\t\t\tboolean array = type.isArray();\n\n\t\t\tint i = 0;\n\t\t\twhile (i < hierarchy.size()) {\n\t\t\t\tClass<?> candidate = hierarchy.get(i);\n\t\t\t\tcandidate = (array ? candidate.componentType() : ClassUtils.resolvePrimitiveIfNecessary(candidate));\n\t\t\t\tClass<?> superclass = candidate.getSuperclass();\n\t\t\t\tif (superclass != null && superclass != Object.class && superclass != Enum.class) {\n\t\t\t\t\taddToClassHierarchy(i + 1, candidate.getSuperclass(), array, hierarchy, visited);\n\t\t\t\t}\n\t\t\t\taddInterfacesToClassHierarchy(candidate, array, hierarchy, visited);\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tif (Enum.class.isAssignableFrom(type)) {\n\t\t\t\taddToClassHierarchy(hierarchy.size(), Enum.class, false, hierarchy, visited);\n\t\t\t\taddInterfacesToClassHierarchy(Enum.class, false, hierarchy, visited);\n\t\t\t}\n\n\t\t\taddToClassHierarchy(hierarchy.size(), Object.class, array, hierarchy, visited);\n\t\t\taddToClassHierarchy(hierarchy.size(), Object.class, false, hierarchy, visited);\n\t\t\treturn hierarchy;\n\t\t}\n\n\t\tprivate void addInterfacesToClassHierarchy(Class<?> type, boolean asArray,\n\t\t\t\tList<Class<?>> hierarchy, Set<Class<?>> visited) {\n\n\t\t\tfor (Class<?> implementedInterface : type.getInterfaces()) {\n\t\t\t\taddToClassHierarchy(hierarchy.size(), implementedInterface, asArray, hierarchy, visited);\n\t\t\t}\n\t\t}\n\n\t\tprivate void addToClassHierarchy(int index, Class<?> type, boolean asArray,\n\t\t\t\tList<Class<?>> hierarchy, Set<Class<?>> visited) {\n\n\t\t\tif (asArray) {\n\t\t\t\ttype = type.arrayType();\n\t\t\t}\n\t\t\tif (visited.add(type)) {\n\t\t\t\thierarchy.add(index, type);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tStringBuilder builder = new StringBuilder();\n\t\t\tbuilder.append(\"ConversionService converters =\\n\");\n\t\t\tfor (String converterString : getConverterStrings()) {\n\t\t\t\tbuilder.append('\\t').append(converterString).append('\\n');\n\t\t\t}\n\t\t\treturn builder.toString();\n\t\t}\n\n\t\tprivate List<String> getConverterStrings() {\n\t\t\tList<String> converterStrings = new ArrayList<>();\n\t\t\tfor (ConvertersForPair convertersForPair : this.converters.values()) {\n\t\t\t\tconverterStrings.add(convertersForPair.toString());\n\t\t\t}\n\t\t\tCollections.sort(converterStrings);\n\t\t\treturn converterStrings;\n\t\t}\n\t}\n\n\n\t/**\n\t * Manages converters registered with a specific {@link ConvertiblePair}.\n\t */\n\tprivate static class ConvertersForPair {\n\n\t\tprivate final Deque<GenericConverter> converters = new ConcurrentLinkedDeque<>();\n\n\t\tpublic void add(GenericConverter converter) {\n\t\t\tthis.converters.addFirst(converter);\n\t\t}\n\n\t\tpublic @Nullable GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\tfor (GenericConverter converter : this.converters) {\n\t\t\t\tif (!(converter instanceof ConditionalGenericConverter genericConverter) ||\n\t\t\t\t\t\tgenericConverter.matches(sourceType, targetType)) {\n\t\t\t\t\treturn converter;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn StringUtils.collectionToCommaDelimitedString(this.converters);\n\t\t}\n\t}\n\n\n\t/**\n\t * Internal converter that performs no operation.\n\t */\n\tprivate static class NoOpConverter implements GenericConverter {\n\n\t\tprivate final String name;\n\n\t\tpublic NoOpConverter(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable Set<ConvertiblePair> getConvertibleTypes() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\treturn source;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.name;\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.convert.support.NoOpConverter",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.convert.support.NoOpConverter#name",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.convert.support.NoOpConverter#name",
    "headType": "field",
    "relation": "haveType",
    "tail": "String",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.convert.support.NoOpConverter#getConvertibleTypes()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\n@Nullable\r\npublic Set<ConvertiblePair> getConvertibleTypes() {\r\n    return null;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.convert.support.NoOpConverter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.convert.support.NoOpConverter#getConvertibleTypes()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.convert.support.NoOpConverter#getConvertibleTypes()",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.convert.support.NoOpConverter#getConvertibleTypes()",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.convert.support.NoOpConverter#convert(Object,TypeDescriptor,TypeDescriptor)",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\n@Nullable\r\npublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    return source;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.convert.support.NoOpConverter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.convert.support.NoOpConverter#convert(Object,TypeDescriptor,TypeDescriptor)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.convert.support.NoOpConverter#convert(Object,TypeDescriptor,TypeDescriptor)",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.convert.support.NoOpConverter#convert(Object,TypeDescriptor,TypeDescriptor)",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.convert.support.NoOpConverter#toString()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic String toString() {\r\n    return this.name;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.convert.support.NoOpConverter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.convert.support.NoOpConverter#toString()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.convert.support.NoOpConverter#toString()",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  }
]