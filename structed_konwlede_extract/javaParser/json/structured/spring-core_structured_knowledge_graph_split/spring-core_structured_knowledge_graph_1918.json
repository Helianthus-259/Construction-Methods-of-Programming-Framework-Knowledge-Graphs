[
  {
    "head": "org.springframework.core.convert.support.MyStringToGenericCollectionConverter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.convert.support.MyStringToGenericCollectionConverter#convert(String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.convert.support.MyStringToGenericCollectionConverter#convert(String)",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.convert.support",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.convert.support.MyEnumInterfaceToStringConverter",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.convert.support.MyEnumInterfaceToStringConverter",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.convert.support;\n\nimport java.awt.Color;\nimport java.awt.SystemColor;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.jspecify.annotations.Nullable;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.convert.ConversionFailedException;\nimport org.springframework.core.convert.ConverterNotFoundException;\nimport org.springframework.core.convert.TypeDescriptor;\nimport org.springframework.core.convert.converter.ConditionalConverter;\nimport org.springframework.core.convert.converter.Converter;\nimport org.springframework.core.convert.converter.ConverterFactory;\nimport org.springframework.core.convert.converter.GenericConverter;\nimport org.springframework.core.io.DescriptiveResource;\nimport org.springframework.core.io.Resource;\nimport org.springframework.util.StringUtils;\n\nimport static java.util.Comparator.naturalOrder;\nimport static java.util.stream.Collectors.toList;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.assertj.core.api.Assertions.assertThatIllegalStateException;\n\n/**\n * Tests for {@link GenericConversionService}.\n *\n * <p>In this package for access to package-local converter implementations.\n *\n * @author Keith Donald\n * @author Juergen Hoeller\n * @author Phillip Webb\n * @author David Haraburda\n * @author Sam Brannen\n */\nclass GenericConversionServiceTests {\n\n\tprivate final GenericConversionService conversionService = new GenericConversionService();\n\n\n\t@Test\n\tvoid canConvert() {\n\t\tassertThat(conversionService.canConvert(String.class, Integer.class)).isFalse();\n\t\tconversionService.addConverterFactory(new StringToNumberConverterFactory());\n\t\tassertThat(conversionService.canConvert(String.class, Integer.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid canConvertAssignable() {\n\t\tassertThat(conversionService.canConvert(String.class, String.class)).isTrue();\n\t\tassertThat(conversionService.canConvert(Integer.class, Number.class)).isTrue();\n\t\tassertThat(conversionService.canConvert(boolean.class, boolean.class)).isTrue();\n\t\tassertThat(conversionService.canConvert(boolean.class, Boolean.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid canConvertFromClassSourceTypeToNullTargetType() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tconversionService.canConvert(String.class, null));\n\t}\n\n\t@Test\n\tvoid canConvertFromTypeDescriptorSourceTypeToNullTargetType() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tconversionService.canConvert(TypeDescriptor.valueOf(String.class), null));\n\t}\n\n\t@Test\n\tvoid canConvertNullSourceType() {\n\t\tassertThat(conversionService.canConvert(null, Integer.class)).isTrue();\n\t\tassertThat(conversionService.canConvert(null, TypeDescriptor.valueOf(Integer.class))).isTrue();\n\t}\n\n\t@Test\n\tvoid convert() {\n\t\tconversionService.addConverterFactory(new StringToNumberConverterFactory());\n\t\tassertThat(conversionService.convert(\"3\", Integer.class)).isEqualTo(3);\n\t}\n\n\t@Test\n\tvoid convertNullSource() {\n\t\tassertThat(conversionService.convert(null, Integer.class)).isNull();\n\t}\n\n\t@Test\n\tvoid convertNullSourcePrimitiveTarget() {\n\t\tassertThatExceptionOfType(ConversionFailedException.class).isThrownBy(() ->\n\t\t\t\tconversionService.convert(null, int.class));\n\t}\n\n\t@Test\n\tvoid convertNullSourcePrimitiveTargetTypeDescriptor() {\n\t\tassertThatExceptionOfType(ConversionFailedException.class).isThrownBy(() ->\n\t\t\t\tconversionService.convert(null, TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(int.class)));\n\t}\n\n\t@Test\n\tvoid convertNotNullSourceNullSourceTypeDescriptor() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tconversionService.convert(\"3\", null, TypeDescriptor.valueOf(int.class)));\n\t}\n\n\t@Test\n\tvoid convertAssignableSource() {\n\t\tassertThat(conversionService.convert(false, boolean.class)).isFalse();\n\t\tassertThat(conversionService.convert(false, Boolean.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid converterNotFound() {\n\t\tassertThatExceptionOfType(ConverterNotFoundException.class).isThrownBy(() ->\n\t\t\t\tconversionService.convert(\"3\", Integer.class));\n\t}\n\n\t@Test\n\tvoid addConverterNoSourceTargetClassInfoAvailable() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tconversionService.addConverter(new UntypedConverter()));\n\t}\n\n\t@Test\n\tvoid sourceTypeIsVoid() {\n\t\tassertThat(conversionService.canConvert(void.class, String.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid targetTypeIsVoid() {\n\t\tassertThat(conversionService.canConvert(String.class, void.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid convertNull() {\n\t\tassertThat(conversionService.convert(null, Integer.class)).isNull();\n\t}\n\n\t@Test\n\tvoid convertToNullTargetClass() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tconversionService.convert(\"3\", (Class<?>) null));\n\t}\n\n\t@Test\n\tvoid convertToNullTargetTypeDescriptor() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tconversionService.convert(\"3\", TypeDescriptor.valueOf(String.class), null));\n\t}\n\n\t@Test\n\tvoid convertWrongSourceTypeDescriptor() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tconversionService.convert(\"3\", TypeDescriptor.valueOf(Integer.class), TypeDescriptor.valueOf(Long.class)));\n\t}\n\n\t@Test\n\tvoid convertWrongTypeArgument() {\n\t\tconversionService.addConverterFactory(new StringToNumberConverterFactory());\n\t\tassertThatExceptionOfType(ConversionFailedException.class).isThrownBy(() ->\n\t\t\t\tconversionService.convert(\"BOGUS\", Integer.class));\n\t}\n\n\t@Test\n\tvoid convertSuperSourceType() {\n\t\tconversionService.addConverter(CharSequence.class, Integer.class, source -> Integer.valueOf(source.toString()));\n\t\tInteger result = conversionService.convert(\"3\", Integer.class);\n\t\tassertThat(result).isEqualTo(3);\n\t}\n\n\t// SPR-8718\n\t@Test\n\tvoid convertSuperTarget() {\n\t\tconversionService.addConverter(new ColorConverter());\n\t\tassertThatExceptionOfType(ConverterNotFoundException.class).isThrownBy(() ->\n\t\t\t\tconversionService.convert(\"#000000\", SystemColor.class));\n\t}\n\n\t@Test\n\tvoid convertObjectToPrimitive() {\n\t\tassertThat(conversionService.canConvert(String.class, boolean.class)).isFalse();\n\t\tconversionService.addConverter(new StringToBooleanConverter());\n\t\tassertThat(conversionService.canConvert(String.class, boolean.class)).isTrue();\n\t\tBoolean b = conversionService.convert(\"true\", boolean.class);\n\t\tassertThat(b).isTrue();\n\t\tassertThat(conversionService.canConvert(TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(boolean.class))).isTrue();\n\t\tb = (Boolean) conversionService.convert(\"true\", TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(boolean.class));\n\t\tassertThat(b).isTrue();\n\t}\n\n\t@Test\n\tvoid convertObjectToPrimitiveViaConverterFactory() {\n\t\tassertThat(conversionService.canConvert(String.class, int.class)).isFalse();\n\t\tconversionService.addConverterFactory(new StringToNumberConverterFactory());\n\t\tassertThat(conversionService.canConvert(String.class, int.class)).isTrue();\n\t\tInteger three = conversionService.convert(\"3\", int.class);\n\t\tassertThat(three).isEqualTo(3);\n\t}\n\n\t@Test\n\tvoid genericConverterDelegatingBackToConversionServiceConverterNotFound() {\n\t\tconversionService.addConverter(new ObjectToArrayConverter(conversionService));\n\t\tassertThat(conversionService.canConvert(String.class, Integer[].class)).isFalse();\n\t\tassertThatExceptionOfType(ConverterNotFoundException.class).isThrownBy(() ->\n\t\t\t\tconversionService.convert(\"3,4,5\", Integer[].class));\n\t}\n\n\t@Test\n\tvoid listToIterableConversion() {\n\t\tList<Object> raw = List.of(\"one\", \"two\");\n\t\tObject converted = conversionService.convert(raw, Iterable.class);\n\t\tassertThat(converted).isSameAs(raw);\n\t}\n\n\t@Test\n\tvoid listToObjectConversion() {\n\t\tList<Object> raw = List.of(\"one\", \"two\");\n\t\tObject converted = conversionService.convert(raw, Object.class);\n\t\tassertThat(converted).isSameAs(raw);\n\t}\n\n\t@Test\n\tvoid mapToObjectConversion() {\n\t\tMap<Object, Object> raw = Map.of(\"key\", \"value\");\n\t\tObject converted = conversionService.convert(raw, Object.class);\n\t\tassertThat(converted).isSameAs(raw);\n\t}\n\n\t@Test\n\tvoid interfaceToString() {\n\t\tconversionService.addConverter(new MyBaseInterfaceToStringConverter());\n\t\tconversionService.addConverter(new ObjectToStringConverter());\n\t\tObject converted = conversionService.convert(new MyInterfaceImplementer(), String.class);\n\t\tassertThat(converted).isEqualTo(\"RESULT\");\n\t}\n\n\t@Test\n\tvoid interfaceArrayToStringArray() {\n\t\tconversionService.addConverter(new MyBaseInterfaceToStringConverter());\n\t\tconversionService.addConverter(new ArrayToArrayConverter(conversionService));\n\t\tString[] converted = conversionService.convert(new MyInterface[] {new MyInterfaceImplementer()}, String[].class);\n\t\tassertThat(converted[0]).isEqualTo(\"RESULT\");\n\t}\n\n\t@Test\n\tvoid objectArrayToStringArray() {\n\t\tconversionService.addConverter(new MyBaseInterfaceToStringConverter());\n\t\tconversionService.addConverter(new ArrayToArrayConverter(conversionService));\n\t\tString[] converted = conversionService.convert(new MyInterfaceImplementer[] {new MyInterfaceImplementer()}, String[].class);\n\t\tassertThat(converted[0]).isEqualTo(\"RESULT\");\n\t}\n\n\t@Test\n\tvoid stringArrayToResourceArray() {\n\t\tconversionService.addConverter(new MyStringArrayToResourceArrayConverter());\n\t\tResource[] converted = conversionService.convert(new String[] { \"x1\", \"z3\" }, Resource[].class);\n\t\tList<String> descriptions = Arrays.stream(converted).map(Resource::getDescription).sorted(naturalOrder()).collect(toList());\n\t\tassertThat(descriptions).isEqualTo(Arrays.asList(\"1\", \"3\"));\n\t}\n\n\t@Test\n\tvoid stringArrayToIntegerArray() {\n\t\tconversionService.addConverter(new MyStringArrayToIntegerArrayConverter());\n\t\tInteger[] converted = conversionService.convert(new String[] {\"x1\", \"z3\"}, Integer[].class);\n\t\tassertThat(converted).isEqualTo(new Integer[] { 1, 3 });\n\t}\n\n\t@Test\n\tvoid stringToIntegerArray() {\n\t\tconversionService.addConverter(new MyStringToIntegerArrayConverter());\n\t\tInteger[] converted = conversionService.convert(\"x1,z3\", Integer[].class);\n\t\tassertThat(converted).isEqualTo(new Integer[] { 1, 3 });\n\t}\n\n\t@Test\n\tvoid wildcardMap() throws Exception {\n\t\tMap<String, String> input = new LinkedHashMap<>();\n\t\tinput.put(\"key\", \"value\");\n\t\tObject converted = conversionService.convert(input, new TypeDescriptor(getClass().getField(\"wildcardMap\")));\n\t\tassertThat(converted).isEqualTo(input);\n\t}\n\n\t@Test\n\tvoid stringToString() {\n\t\tString value = \"myValue\";\n\t\tString result = conversionService.convert(value, String.class);\n\t\tassertThat(result).isSameAs(value);\n\t}\n\n\t@Test\n\tvoid stringToObject() {\n\t\tString value = \"myValue\";\n\t\tObject result = conversionService.convert(value, Object.class);\n\t\tassertThat(result).isSameAs(value);\n\t}\n\n\t@Test\n\tvoid ignoreCopyConstructor() {\n\t\tWithCopyConstructor value = new WithCopyConstructor();\n\t\tObject result = conversionService.convert(value, WithCopyConstructor.class);\n\t\tassertThat(result).isSameAs(value);\n\t}\n\n\t@Test\n\tvoid emptyListToArray() {\n\t\tconversionService.addConverter(new CollectionToArrayConverter(conversionService));\n\t\tconversionService.addConverterFactory(new StringToNumberConverterFactory());\n\t\tList<String> list = new ArrayList<>();\n\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(list);\n\t\tTypeDescriptor targetType = TypeDescriptor.valueOf(String[].class);\n\t\tassertThat(conversionService.canConvert(sourceType, targetType)).isTrue();\n\t\tassertThat(((String[]) conversionService.convert(list, sourceType, targetType))).isEmpty();\n\t}\n\n\t@Test\n\tvoid emptyListToObject() {\n\t\tconversionService.addConverter(new CollectionToObjectConverter(conversionService));\n\t\tconversionService.addConverterFactory(new StringToNumberConverterFactory());\n\t\tList<String> list = new ArrayList<>();\n\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(list);\n\t\tTypeDescriptor targetType = TypeDescriptor.valueOf(Integer.class);\n\t\tassertThat(conversionService.canConvert(sourceType, targetType)).isTrue();\n\t\tassertThat(conversionService.convert(list, sourceType, targetType)).isNull();\n\t}\n\n\t@Test\n\tvoid stringToArrayCanConvert() {\n\t\tconversionService.addConverter(new StringToArrayConverter(conversionService));\n\t\tassertThat(conversionService.canConvert(String.class, Integer[].class)).isFalse();\n\t\tconversionService.addConverterFactory(new StringToNumberConverterFactory());\n\t\tassertThat(conversionService.canConvert(String.class, Integer[].class)).isTrue();\n\t}\n\n\t@Test\n\tvoid stringToCollectionCanConvert() throws Exception {\n\t\tconversionService.addConverter(new StringToCollectionConverter(conversionService));\n\t\tassertThat(conversionService.canConvert(String.class, Collection.class)).isTrue();\n\t\tTypeDescriptor targetType = new TypeDescriptor(getClass().getField(\"integerCollection\"));\n\t\tassertThat(conversionService.canConvert(TypeDescriptor.valueOf(String.class), targetType)).isFalse();\n\t\tconversionService.addConverterFactory(new StringToNumberConverterFactory());\n\t\tassertThat(conversionService.canConvert(TypeDescriptor.valueOf(String.class), targetType)).isTrue();\n\t}\n\n\t@Test\n\tvoid convertiblePairsInSet() {\n\t\tSet<GenericConverter.ConvertiblePair> set = new HashSet<>();\n\t\tset.add(new GenericConverter.ConvertiblePair(Number.class, String.class));\n\t\tassert set.contains(new GenericConverter.ConvertiblePair(Number.class, String.class));\n\t}\n\n\t@Test\n\tvoid convertiblePairEqualsAndHash() {\n\t\tGenericConverter.ConvertiblePair pair = new GenericConverter.ConvertiblePair(Number.class, String.class);\n\t\tGenericConverter.ConvertiblePair pairEqual = new GenericConverter.ConvertiblePair(Number.class, String.class);\n\t\tassertThat(pairEqual).isEqualTo(pair);\n\t\tassertThat(pairEqual.hashCode()).isEqualTo(pair.hashCode());\n\t}\n\n\t@Test\n\tvoid convertiblePairDifferentEqualsAndHash() {\n\t\tGenericConverter.ConvertiblePair pair = new GenericConverter.ConvertiblePair(Number.class, String.class);\n\t\tGenericConverter.ConvertiblePair pairOpposite = new GenericConverter.ConvertiblePair(String.class, Number.class);\n\t\tassertThat(pair).isNotEqualTo(pairOpposite);\n\t\tassertThat(pair.hashCode()).isNotEqualTo(pairOpposite.hashCode());\n\t}\n\n\t@Test\n\tvoid canConvertIllegalArgumentNullTargetTypeFromClass() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tconversionService.canConvert(String.class, null));\n\t}\n\n\t@Test\n\tvoid canConvertIllegalArgumentNullTargetTypeFromTypeDescriptor() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tconversionService.canConvert(TypeDescriptor.valueOf(String.class), null));\n\t}\n\n\t@Test\n\tvoid removeConvertible() {\n\t\tconversionService.addConverter(new ColorConverter());\n\t\tassertThat(conversionService.canConvert(String.class, Color.class)).isTrue();\n\t\tconversionService.removeConvertible(String.class, Color.class);\n\t\tassertThat(conversionService.canConvert(String.class, Color.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid conditionalConverter() {\n\t\tMyConditionalConverter converter = new MyConditionalConverter();\n\t\tconversionService.addConverter(new ColorConverter());\n\t\tconversionService.addConverter(converter);\n\t\tassertThat(conversionService.convert(\"#000000\", Color.class)).isEqualTo(Color.BLACK);\n\t\tassertThat(converter.getMatchAttempts()).isGreaterThan(0);\n\t}\n\n\t@Test\n\tvoid conditionalConverterFactory() {\n\t\tMyConditionalConverterFactory converter = new MyConditionalConverterFactory();\n\t\tconversionService.addConverter(new ColorConverter());\n\t\tconversionService.addConverterFactory(converter);\n\t\tassertThat(conversionService.convert(\"#000000\", Color.class)).isEqualTo(Color.BLACK);\n\t\tassertThat(converter.getMatchAttempts()).isGreaterThan(0);\n\t\tassertThat(converter.getNestedMatchAttempts()).isGreaterThan(0);\n\t}\n\n\t@Test\n\tvoid conditionalConverterCachingForDifferentAnnotationAttributes() throws Exception {\n\t\tconversionService.addConverter(new ColorConverter());\n\t\tconversionService.addConverter(new MyConditionalColorConverter());\n\n\t\tassertThat(conversionService.convert(\"000000xxxx\",\n\t\t\t\tnew TypeDescriptor(getClass().getField(\"activeColor\")))).isEqualTo(Color.BLACK);\n\t\tassertThat(conversionService.convert(\" #000000 \",\n\t\t\t\tnew TypeDescriptor(getClass().getField(\"inactiveColor\")))).isEqualTo(Color.BLACK);\n\t\tassertThat(conversionService.convert(\"000000yyyy\",\n\t\t\t\tnew TypeDescriptor(getClass().getField(\"activeColor\")))).isEqualTo(Color.BLACK);\n\t\tassertThat(conversionService.convert(\"  #000000  \",\n\t\t\t\tnew TypeDescriptor(getClass().getField(\"inactiveColor\")))).isEqualTo(Color.BLACK);\n\t}\n\n\t@Test\n\tvoid shouldNotSupportNullConvertibleTypesFromNonConditionalGenericConverter() {\n\t\tGenericConverter converter = new NonConditionalGenericConverter();\n\t\tassertThatIllegalStateException().isThrownBy(() ->\n\t\t\t\tconversionService.addConverter(converter))\n\t\t\t.withMessage(\"Only conditional converters may return null convertible types\");\n\t}\n\n\t@Test\n\tvoid conditionalConversionForAllTypes() {\n\t\tMyConditionalGenericConverter converter = new MyConditionalGenericConverter();\n\t\tconversionService.addConverter(converter);\n\t\tassertThat(conversionService.convert(3, Integer.class)).isEqualTo(3);\n\t\tassertThat(converter.getSourceTypes()).hasSizeGreaterThan(2);\n\t\tassertThat(converter.getSourceTypes().stream().allMatch(td -> Integer.class.equals(td.getType()))).isTrue();\n\t}\n\n\t@Test  // gh-14200, SPR-9566\n\tvoid convertOptimizeArray() {\n\t\tbyte[] byteArray = new byte[] { 1, 2, 3 };\n\t\tbyte[] converted = conversionService.convert(byteArray, byte[].class);\n\t\tassertThat(converted).isSameAs(byteArray);\n\t\tassertThat(converted).containsExactly(1, 2, 3);\n\t}\n\n\t@Test\n\tvoid enumToStringConversion() {\n\t\tconversionService.addConverter(new EnumToStringConverter(conversionService));\n\t\tassertThat(conversionService.convert(MyEnum.A, String.class)).isEqualTo(\"A\");\n\t}\n\n\t@Test\n\tvoid subclassOfEnumToString() {\n\t\tconversionService.addConverter(new EnumToStringConverter(conversionService));\n\t\tassertThat(conversionService.convert(EnumWithSubclass.FIRST, String.class)).isEqualTo(\"FIRST\");\n\t}\n\n\t@Test\n\tvoid enumWithInterfaceToStringConversion() {\n\t\t// SPR-9692\n\t\tconversionService.addConverter(new EnumToStringConverter(conversionService));\n\t\tconversionService.addConverter(new MyEnumInterfaceToStringConverter<>());\n\t\tassertThat(conversionService.convert(MyEnum.A, String.class)).isEqualTo(\"1\");\n\t}\n\n\t@Test\n\tvoid stringToEnumWithInterfaceConversion() {\n\t\tconversionService.addConverterFactory(new StringToEnumConverterFactory());\n\t\tconversionService.addConverterFactory(new StringToMyEnumInterfaceConverterFactory());\n\t\tassertThat(conversionService.convert(\"1\", MyEnum.class)).isEqualTo(MyEnum.A);\n\t}\n\n\t@Test\n\tvoid stringToEnumWithBaseInterfaceConversion() {\n\t\tconversionService.addConverterFactory(new StringToEnumConverterFactory());\n\t\tconversionService.addConverterFactory(new StringToMyEnumBaseInterfaceConverterFactory());\n\t\tassertThat(conversionService.convert(\"base1\", MyEnum.class)).isEqualTo(MyEnum.A);\n\t}\n\n\t@Test\n\tvoid convertNullAnnotatedStringToString() throws Exception {\n\t\tString source = null;\n\t\tTypeDescriptor sourceType = new TypeDescriptor(getClass().getField(\"annotatedString\"));\n\t\tTypeDescriptor targetType = TypeDescriptor.valueOf(String.class);\n\t\tconversionService.convert(source, sourceType, targetType);\n\t}\n\n\t@Test\n\tvoid multipleCollectionTypesFromSameSourceType() throws Exception {\n\t\tconversionService.addConverter(new MyStringToRawCollectionConverter());\n\t\tconversionService.addConverter(new MyStringToGenericCollectionConverter());\n\t\tconversionService.addConverter(new MyStringToStringCollectionConverter());\n\t\tconversionService.addConverter(new MyStringToIntegerCollectionConverter());\n\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"stringCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"integerCollection\")))).isEqualTo(Collections.singleton(4));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"rawCollection\")))).isEqualTo(Collections.singleton(4));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"genericCollection\")))).isEqualTo(Collections.singleton(4));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"rawCollection\")))).isEqualTo(Collections.singleton(4));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"stringCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t}\n\n\t@Test\n\tvoid adaptedCollectionTypesFromSameSourceType() throws Exception {\n\t\tconversionService.addConverter(new MyStringToStringCollectionConverter());\n\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"stringCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"genericCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"rawCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"genericCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"stringCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"rawCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\n\t\tassertThatExceptionOfType(ConverterNotFoundException.class).isThrownBy(() ->\n\t\t\t\tconversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"integerCollection\"))));\n\t}\n\n\t@Test\n\tvoid genericCollectionAsSource() throws Exception {\n\t\tconversionService.addConverter(new MyStringToGenericCollectionConverter());\n\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"stringCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"genericCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"rawCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\n\t\t// The following is unpleasant but a consequence of the generic collection converter above...\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"integerCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t}\n\n\t@Test\n\tvoid rawCollectionAsSource() throws Exception {\n\t\tconversionService.addConverter(new MyStringToRawCollectionConverter());\n\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"stringCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"genericCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"rawCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\n\t\t// The following is unpleasant but a consequence of the raw collection converter above...\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"integerCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t}\n\n\t@Test\n\tvoid stringListToListOfSubclassOfUnboundGenericClass() {\n\t\tconversionService.addConverter(new StringListToAListConverter());\n\t\tconversionService.addConverter(new StringListToBListConverter());\n\n\t\tList<?> aList = (List<?>) conversionService.convert(List.of(\"foo\"),\n\t\t\t\tTypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)),\n\t\t\t\tTypeDescriptor.collection(List.class, TypeDescriptor.valueOf(ARaw.class)));\n\t\tassertThat(aList).allMatch(e -> e instanceof ARaw);\n\n\t\tList<?> bList = (List<?>) conversionService.convert(List.of(\"foo\"),\n\t\t\t\tTypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)),\n\t\t\t\tTypeDescriptor.collection(List.class, TypeDescriptor.valueOf(BRaw.class)));\n\t\tassertThat(bList).allMatch(e -> e instanceof BRaw);\n\t}\n\n\n\t@ExampleAnnotation(active = true)\n\tpublic String annotatedString;\n\n\t@ExampleAnnotation(active = true)\n\tpublic Color activeColor;\n\n\t@ExampleAnnotation(active = false)\n\tpublic Color inactiveColor;\n\n\tpublic Map<String, ?> wildcardMap;\n\n\t@SuppressWarnings(\"rawtypes\")\n\tpublic Collection rawCollection;\n\n\tpublic Collection<?> genericCollection;\n\n\tpublic Collection<String> stringCollection;\n\n\tpublic Collection<Integer> integerCollection;\n\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\tprivate @interface ExampleAnnotation {\n\n\t\tboolean active();\n\t}\n\n\n\tprivate interface MyBaseInterface {\n\t}\n\n\n\tprivate interface MyInterface extends MyBaseInterface {\n\t}\n\n\n\tprivate static class MyInterfaceImplementer implements MyInterface {\n\t}\n\n\n\tprivate static class MyBaseInterfaceToStringConverter implements Converter<MyBaseInterface, String> {\n\n\t\t@Override\n\t\tpublic String convert(MyBaseInterface source) {\n\t\t\treturn \"RESULT\";\n\t\t}\n\t}\n\n\n\tprivate static class MyStringArrayToResourceArrayConverter implements Converter<String[], Resource[]> {\n\n\t\t@Override\n\t\tpublic Resource[] convert(String[] source) {\n\t\t\treturn Arrays.stream(source).map(s -> s.substring(1)).map(DescriptiveResource::new).toArray(Resource[]::new);\n\t\t}\n\t}\n\n\n\tprivate static class MyStringArrayToIntegerArrayConverter implements Converter<String[], Integer[]> {\n\n\t\t@Override\n\t\tpublic Integer[] convert(String[] source) {\n\t\t\treturn Arrays.stream(source).map(s -> s.substring(1)).map(Integer::valueOf).toArray(Integer[]::new);\n\t\t}\n\t}\n\n\n\tprivate static class MyStringToIntegerArrayConverter implements Converter<String, Integer[]> {\n\n\t\t@Override\n\t\tpublic Integer[] convert(String source) {\n\t\t\tString[] srcArray = StringUtils.commaDelimitedListToStringArray(source);\n\t\t\treturn Arrays.stream(srcArray).map(s -> s.substring(1)).map(Integer::valueOf).toArray(Integer[]::new);\n\t\t}\n\t}\n\n\n\tprivate static class WithCopyConstructor {\n\n\t\tWithCopyConstructor() {}\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tWithCopyConstructor(WithCopyConstructor value) {}\n\t}\n\n\n\tprivate static class MyConditionalConverter implements Converter<String, Color>, ConditionalConverter {\n\n\t\tprivate int matchAttempts = 0;\n\n\t\t@Override\n\t\tpublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\tmatchAttempts++;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic Color convert(String source) {\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic int getMatchAttempts() {\n\t\t\treturn matchAttempts;\n\t\t}\n\t}\n\n\n\tprivate static class NonConditionalGenericConverter implements GenericConverter {\n\n\t\t@Override\n\t\tpublic Set<ConvertiblePair> getConvertibleTypes() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\tprivate static class MyConditionalGenericConverter implements GenericConverter, ConditionalConverter {\n\n\t\tprivate final List<TypeDescriptor> sourceTypes = new ArrayList<>();\n\n\t\t@Override\n\t\tpublic Set<ConvertiblePair> getConvertibleTypes() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\tsourceTypes.add(sourceType);\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic List<TypeDescriptor> getSourceTypes() {\n\t\t\treturn sourceTypes;\n\t\t}\n\t}\n\n\n\tprivate static class MyConditionalConverterFactory implements ConverterFactory<String, Color>, ConditionalConverter {\n\n\t\tprivate MyConditionalConverter converter = new MyConditionalConverter();\n\n\t\tprivate int matchAttempts = 0;\n\n\t\t@Override\n\t\tpublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\tmatchAttempts++;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic <T extends Color> Converter<String, T> getConverter(Class<T> targetType) {\n\t\t\treturn (Converter<String, T>) converter;\n\t\t}\n\n\t\tpublic int getMatchAttempts() {\n\t\t\treturn matchAttempts;\n\t\t}\n\n\t\tpublic int getNestedMatchAttempts() {\n\t\t\treturn converter.getMatchAttempts();\n\t\t}\n\t}\n\n\n\tprivate interface MyEnumBaseInterface {\n\t\tString getBaseCode();\n\t}\n\n\n\tprivate interface MyEnumInterface extends MyEnumBaseInterface {\n\t\tString getCode();\n\t}\n\n\n\tprivate enum MyEnum implements MyEnumInterface {\n\n\t\tA(\"1\"),\n\t\tB(\"2\"),\n\t\tC(\"3\");\n\n\t\tprivate final String code;\n\n\t\tMyEnum(String code) {\n\t\t\tthis.code = code;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getCode() {\n\t\t\treturn code;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getBaseCode() {\n\t\t\treturn \"base\" + code;\n\t\t}\n\t}\n\n\n\tprivate enum EnumWithSubclass {\n\n\t\tFIRST {\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\treturn \"1st\";\n\t\t\t}\n\t\t}\n\t}\n\n\n\t@SuppressWarnings(\"rawtypes\")\n\tprivate static class MyStringToRawCollectionConverter implements Converter<String, Collection> {\n\n\t\t@Override\n\t\tpublic Collection convert(String source) {\n\t\t\treturn Collections.singleton(source + \"X\");\n\t\t}\n\t}\n\n\n\tprivate static class MyStringToGenericCollectionConverter implements Converter<String, Collection<?>> {\n\n\t\t@Override\n\t\tpublic Collection<?> convert(String source) {\n\t\t\treturn Collections.singleton(source + \"X\");\n\t\t}\n\t}\n\n\n\tprivate static class MyEnumInterfaceToStringConverter<T extends MyEnumInterface> implements Converter<T, String> {\n\n\t\t@Override\n\t\tpublic String convert(T source) {\n\t\t\treturn source.getCode();\n\t\t}\n\t}\n\n\n\tprivate static class StringToMyEnumInterfaceConverterFactory implements ConverterFactory<String, MyEnumInterface> {\n\n\t\t@Override\n\t\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n\t\tpublic <T extends MyEnumInterface> Converter<String, T> getConverter(Class<T> targetType) {\n\t\t\treturn new StringToMyEnumInterfaceConverter(targetType);\n\t\t}\n\n\t\tprivate static class StringToMyEnumInterfaceConverter<T extends Enum<?> & MyEnumInterface> implements Converter<String, T> {\n\n\t\t\tprivate final Class<T> enumType;\n\n\t\t\tpublic StringToMyEnumInterfaceConverter(Class<T> enumType) {\n\t\t\t\tthis.enumType = enumType;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T convert(String source) {\n\t\t\t\tfor (T value : enumType.getEnumConstants()) {\n\t\t\t\t\tif (value.getCode().equals(source)) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate static class StringToMyEnumBaseInterfaceConverterFactory implements ConverterFactory<String, MyEnumBaseInterface> {\n\n\t\t@Override\n\t\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n\t\tpublic <T extends MyEnumBaseInterface> Converter<String, T> getConverter(Class<T> targetType) {\n\t\t\treturn new StringToMyEnumBaseInterfaceConverter(targetType);\n\t\t}\n\n\t\tprivate static class StringToMyEnumBaseInterfaceConverter<T extends Enum<?> & MyEnumBaseInterface> implements Converter<String, T> {\n\n\t\t\tprivate final Class<T> enumType;\n\n\t\t\tpublic StringToMyEnumBaseInterfaceConverter(Class<T> enumType) {\n\t\t\t\tthis.enumType = enumType;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T convert(String source) {\n\t\t\t\tfor (T value : enumType.getEnumConstants()) {\n\t\t\t\t\tif (value.getBaseCode().equals(source)) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate static class MyStringToStringCollectionConverter implements Converter<String, Collection<String>> {\n\n\t\t@Override\n\t\tpublic Collection<String> convert(String source) {\n\t\t\treturn Collections.singleton(source + \"X\");\n\t\t}\n\t}\n\n\n\tprivate static class MyStringToIntegerCollectionConverter implements Converter<String, Collection<Integer>> {\n\n\t\t@Override\n\t\tpublic Collection<Integer> convert(String source) {\n\t\t\treturn Collections.singleton(source.length());\n\t\t}\n\t}\n\n\n\t@SuppressWarnings(\"rawtypes\")\n\tprivate static class UntypedConverter implements Converter {\n\n\t\t@Override\n\t\tpublic Object convert(Object source) {\n\t\t\treturn source;\n\t\t}\n\t}\n\n\n\tprivate static class ColorConverter implements Converter<String, Color> {\n\n\t\t@Override\n\t\tpublic Color convert(String source) {\n\t\t\treturn Color.decode(source.trim());\n\t\t}\n\t}\n\n\n\tprivate static class MyConditionalColorConverter implements Converter<String, Color>, ConditionalConverter {\n\n\t\t@Override\n\t\tpublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\tExampleAnnotation ann = targetType.getAnnotation(ExampleAnnotation.class);\n\t\t\treturn (ann != null && ann.active());\n\t\t}\n\n\t\t@Override\n\t\tpublic Color convert(String source) {\n\t\t\treturn Color.decode(source.substring(0, 6));\n\t\t}\n\t}\n\n\n\tprivate static class GenericBaseClass<T> {\n\t}\n\n\t@SuppressWarnings(\"rawtypes\")\n\tprivate static class ARaw extends GenericBaseClass {\n\t}\n\n\t@SuppressWarnings(\"rawtypes\")\n\tprivate static class BRaw extends GenericBaseClass {\n\t}\n\n\n\tprivate static class StringListToAListConverter implements Converter<List<String>, List<ARaw>> {\n\n\t\t@Override\n\t\tpublic List<ARaw> convert(List<String> source) {\n\t\t\treturn List.of(new ARaw());\n\t\t}\n\t}\n\n\n\tprivate static class StringListToBListConverter implements Converter<List<String>, List<BRaw>> {\n\n\t\t@Override\n\t\tpublic List<BRaw> convert(List<String> source) {\n\t\t\treturn List.of(new BRaw());\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.convert.support.MyEnumInterfaceToStringConverter#convert(T)",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic String convert(T source) {\r\n    return source.getCode();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.convert.support.MyEnumInterfaceToStringConverter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.convert.support.MyEnumInterfaceToStringConverter#convert(T)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.convert.support.MyEnumInterfaceToStringConverter#convert(T)",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.convert.support",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.convert.support.StringToMyEnumInterfaceConverterFactory",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.convert.support.StringToMyEnumInterfaceConverterFactory",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.convert.support;\n\nimport java.awt.Color;\nimport java.awt.SystemColor;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.jspecify.annotations.Nullable;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.convert.ConversionFailedException;\nimport org.springframework.core.convert.ConverterNotFoundException;\nimport org.springframework.core.convert.TypeDescriptor;\nimport org.springframework.core.convert.converter.ConditionalConverter;\nimport org.springframework.core.convert.converter.Converter;\nimport org.springframework.core.convert.converter.ConverterFactory;\nimport org.springframework.core.convert.converter.GenericConverter;\nimport org.springframework.core.io.DescriptiveResource;\nimport org.springframework.core.io.Resource;\nimport org.springframework.util.StringUtils;\n\nimport static java.util.Comparator.naturalOrder;\nimport static java.util.stream.Collectors.toList;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.assertj.core.api.Assertions.assertThatIllegalStateException;\n\n/**\n * Tests for {@link GenericConversionService}.\n *\n * <p>In this package for access to package-local converter implementations.\n *\n * @author Keith Donald\n * @author Juergen Hoeller\n * @author Phillip Webb\n * @author David Haraburda\n * @author Sam Brannen\n */\nclass GenericConversionServiceTests {\n\n\tprivate final GenericConversionService conversionService = new GenericConversionService();\n\n\n\t@Test\n\tvoid canConvert() {\n\t\tassertThat(conversionService.canConvert(String.class, Integer.class)).isFalse();\n\t\tconversionService.addConverterFactory(new StringToNumberConverterFactory());\n\t\tassertThat(conversionService.canConvert(String.class, Integer.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid canConvertAssignable() {\n\t\tassertThat(conversionService.canConvert(String.class, String.class)).isTrue();\n\t\tassertThat(conversionService.canConvert(Integer.class, Number.class)).isTrue();\n\t\tassertThat(conversionService.canConvert(boolean.class, boolean.class)).isTrue();\n\t\tassertThat(conversionService.canConvert(boolean.class, Boolean.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid canConvertFromClassSourceTypeToNullTargetType() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tconversionService.canConvert(String.class, null));\n\t}\n\n\t@Test\n\tvoid canConvertFromTypeDescriptorSourceTypeToNullTargetType() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tconversionService.canConvert(TypeDescriptor.valueOf(String.class), null));\n\t}\n\n\t@Test\n\tvoid canConvertNullSourceType() {\n\t\tassertThat(conversionService.canConvert(null, Integer.class)).isTrue();\n\t\tassertThat(conversionService.canConvert(null, TypeDescriptor.valueOf(Integer.class))).isTrue();\n\t}\n\n\t@Test\n\tvoid convert() {\n\t\tconversionService.addConverterFactory(new StringToNumberConverterFactory());\n\t\tassertThat(conversionService.convert(\"3\", Integer.class)).isEqualTo(3);\n\t}\n\n\t@Test\n\tvoid convertNullSource() {\n\t\tassertThat(conversionService.convert(null, Integer.class)).isNull();\n\t}\n\n\t@Test\n\tvoid convertNullSourcePrimitiveTarget() {\n\t\tassertThatExceptionOfType(ConversionFailedException.class).isThrownBy(() ->\n\t\t\t\tconversionService.convert(null, int.class));\n\t}\n\n\t@Test\n\tvoid convertNullSourcePrimitiveTargetTypeDescriptor() {\n\t\tassertThatExceptionOfType(ConversionFailedException.class).isThrownBy(() ->\n\t\t\t\tconversionService.convert(null, TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(int.class)));\n\t}\n\n\t@Test\n\tvoid convertNotNullSourceNullSourceTypeDescriptor() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tconversionService.convert(\"3\", null, TypeDescriptor.valueOf(int.class)));\n\t}\n\n\t@Test\n\tvoid convertAssignableSource() {\n\t\tassertThat(conversionService.convert(false, boolean.class)).isFalse();\n\t\tassertThat(conversionService.convert(false, Boolean.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid converterNotFound() {\n\t\tassertThatExceptionOfType(ConverterNotFoundException.class).isThrownBy(() ->\n\t\t\t\tconversionService.convert(\"3\", Integer.class));\n\t}\n\n\t@Test\n\tvoid addConverterNoSourceTargetClassInfoAvailable() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tconversionService.addConverter(new UntypedConverter()));\n\t}\n\n\t@Test\n\tvoid sourceTypeIsVoid() {\n\t\tassertThat(conversionService.canConvert(void.class, String.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid targetTypeIsVoid() {\n\t\tassertThat(conversionService.canConvert(String.class, void.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid convertNull() {\n\t\tassertThat(conversionService.convert(null, Integer.class)).isNull();\n\t}\n\n\t@Test\n\tvoid convertToNullTargetClass() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tconversionService.convert(\"3\", (Class<?>) null));\n\t}\n\n\t@Test\n\tvoid convertToNullTargetTypeDescriptor() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tconversionService.convert(\"3\", TypeDescriptor.valueOf(String.class), null));\n\t}\n\n\t@Test\n\tvoid convertWrongSourceTypeDescriptor() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tconversionService.convert(\"3\", TypeDescriptor.valueOf(Integer.class), TypeDescriptor.valueOf(Long.class)));\n\t}\n\n\t@Test\n\tvoid convertWrongTypeArgument() {\n\t\tconversionService.addConverterFactory(new StringToNumberConverterFactory());\n\t\tassertThatExceptionOfType(ConversionFailedException.class).isThrownBy(() ->\n\t\t\t\tconversionService.convert(\"BOGUS\", Integer.class));\n\t}\n\n\t@Test\n\tvoid convertSuperSourceType() {\n\t\tconversionService.addConverter(CharSequence.class, Integer.class, source -> Integer.valueOf(source.toString()));\n\t\tInteger result = conversionService.convert(\"3\", Integer.class);\n\t\tassertThat(result).isEqualTo(3);\n\t}\n\n\t// SPR-8718\n\t@Test\n\tvoid convertSuperTarget() {\n\t\tconversionService.addConverter(new ColorConverter());\n\t\tassertThatExceptionOfType(ConverterNotFoundException.class).isThrownBy(() ->\n\t\t\t\tconversionService.convert(\"#000000\", SystemColor.class));\n\t}\n\n\t@Test\n\tvoid convertObjectToPrimitive() {\n\t\tassertThat(conversionService.canConvert(String.class, boolean.class)).isFalse();\n\t\tconversionService.addConverter(new StringToBooleanConverter());\n\t\tassertThat(conversionService.canConvert(String.class, boolean.class)).isTrue();\n\t\tBoolean b = conversionService.convert(\"true\", boolean.class);\n\t\tassertThat(b).isTrue();\n\t\tassertThat(conversionService.canConvert(TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(boolean.class))).isTrue();\n\t\tb = (Boolean) conversionService.convert(\"true\", TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(boolean.class));\n\t\tassertThat(b).isTrue();\n\t}\n\n\t@Test\n\tvoid convertObjectToPrimitiveViaConverterFactory() {\n\t\tassertThat(conversionService.canConvert(String.class, int.class)).isFalse();\n\t\tconversionService.addConverterFactory(new StringToNumberConverterFactory());\n\t\tassertThat(conversionService.canConvert(String.class, int.class)).isTrue();\n\t\tInteger three = conversionService.convert(\"3\", int.class);\n\t\tassertThat(three).isEqualTo(3);\n\t}\n\n\t@Test\n\tvoid genericConverterDelegatingBackToConversionServiceConverterNotFound() {\n\t\tconversionService.addConverter(new ObjectToArrayConverter(conversionService));\n\t\tassertThat(conversionService.canConvert(String.class, Integer[].class)).isFalse();\n\t\tassertThatExceptionOfType(ConverterNotFoundException.class).isThrownBy(() ->\n\t\t\t\tconversionService.convert(\"3,4,5\", Integer[].class));\n\t}\n\n\t@Test\n\tvoid listToIterableConversion() {\n\t\tList<Object> raw = List.of(\"one\", \"two\");\n\t\tObject converted = conversionService.convert(raw, Iterable.class);\n\t\tassertThat(converted).isSameAs(raw);\n\t}\n\n\t@Test\n\tvoid listToObjectConversion() {\n\t\tList<Object> raw = List.of(\"one\", \"two\");\n\t\tObject converted = conversionService.convert(raw, Object.class);\n\t\tassertThat(converted).isSameAs(raw);\n\t}\n\n\t@Test\n\tvoid mapToObjectConversion() {\n\t\tMap<Object, Object> raw = Map.of(\"key\", \"value\");\n\t\tObject converted = conversionService.convert(raw, Object.class);\n\t\tassertThat(converted).isSameAs(raw);\n\t}\n\n\t@Test\n\tvoid interfaceToString() {\n\t\tconversionService.addConverter(new MyBaseInterfaceToStringConverter());\n\t\tconversionService.addConverter(new ObjectToStringConverter());\n\t\tObject converted = conversionService.convert(new MyInterfaceImplementer(), String.class);\n\t\tassertThat(converted).isEqualTo(\"RESULT\");\n\t}\n\n\t@Test\n\tvoid interfaceArrayToStringArray() {\n\t\tconversionService.addConverter(new MyBaseInterfaceToStringConverter());\n\t\tconversionService.addConverter(new ArrayToArrayConverter(conversionService));\n\t\tString[] converted = conversionService.convert(new MyInterface[] {new MyInterfaceImplementer()}, String[].class);\n\t\tassertThat(converted[0]).isEqualTo(\"RESULT\");\n\t}\n\n\t@Test\n\tvoid objectArrayToStringArray() {\n\t\tconversionService.addConverter(new MyBaseInterfaceToStringConverter());\n\t\tconversionService.addConverter(new ArrayToArrayConverter(conversionService));\n\t\tString[] converted = conversionService.convert(new MyInterfaceImplementer[] {new MyInterfaceImplementer()}, String[].class);\n\t\tassertThat(converted[0]).isEqualTo(\"RESULT\");\n\t}\n\n\t@Test\n\tvoid stringArrayToResourceArray() {\n\t\tconversionService.addConverter(new MyStringArrayToResourceArrayConverter());\n\t\tResource[] converted = conversionService.convert(new String[] { \"x1\", \"z3\" }, Resource[].class);\n\t\tList<String> descriptions = Arrays.stream(converted).map(Resource::getDescription).sorted(naturalOrder()).collect(toList());\n\t\tassertThat(descriptions).isEqualTo(Arrays.asList(\"1\", \"3\"));\n\t}\n\n\t@Test\n\tvoid stringArrayToIntegerArray() {\n\t\tconversionService.addConverter(new MyStringArrayToIntegerArrayConverter());\n\t\tInteger[] converted = conversionService.convert(new String[] {\"x1\", \"z3\"}, Integer[].class);\n\t\tassertThat(converted).isEqualTo(new Integer[] { 1, 3 });\n\t}\n\n\t@Test\n\tvoid stringToIntegerArray() {\n\t\tconversionService.addConverter(new MyStringToIntegerArrayConverter());\n\t\tInteger[] converted = conversionService.convert(\"x1,z3\", Integer[].class);\n\t\tassertThat(converted).isEqualTo(new Integer[] { 1, 3 });\n\t}\n\n\t@Test\n\tvoid wildcardMap() throws Exception {\n\t\tMap<String, String> input = new LinkedHashMap<>();\n\t\tinput.put(\"key\", \"value\");\n\t\tObject converted = conversionService.convert(input, new TypeDescriptor(getClass().getField(\"wildcardMap\")));\n\t\tassertThat(converted).isEqualTo(input);\n\t}\n\n\t@Test\n\tvoid stringToString() {\n\t\tString value = \"myValue\";\n\t\tString result = conversionService.convert(value, String.class);\n\t\tassertThat(result).isSameAs(value);\n\t}\n\n\t@Test\n\tvoid stringToObject() {\n\t\tString value = \"myValue\";\n\t\tObject result = conversionService.convert(value, Object.class);\n\t\tassertThat(result).isSameAs(value);\n\t}\n\n\t@Test\n\tvoid ignoreCopyConstructor() {\n\t\tWithCopyConstructor value = new WithCopyConstructor();\n\t\tObject result = conversionService.convert(value, WithCopyConstructor.class);\n\t\tassertThat(result).isSameAs(value);\n\t}\n\n\t@Test\n\tvoid emptyListToArray() {\n\t\tconversionService.addConverter(new CollectionToArrayConverter(conversionService));\n\t\tconversionService.addConverterFactory(new StringToNumberConverterFactory());\n\t\tList<String> list = new ArrayList<>();\n\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(list);\n\t\tTypeDescriptor targetType = TypeDescriptor.valueOf(String[].class);\n\t\tassertThat(conversionService.canConvert(sourceType, targetType)).isTrue();\n\t\tassertThat(((String[]) conversionService.convert(list, sourceType, targetType))).isEmpty();\n\t}\n\n\t@Test\n\tvoid emptyListToObject() {\n\t\tconversionService.addConverter(new CollectionToObjectConverter(conversionService));\n\t\tconversionService.addConverterFactory(new StringToNumberConverterFactory());\n\t\tList<String> list = new ArrayList<>();\n\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(list);\n\t\tTypeDescriptor targetType = TypeDescriptor.valueOf(Integer.class);\n\t\tassertThat(conversionService.canConvert(sourceType, targetType)).isTrue();\n\t\tassertThat(conversionService.convert(list, sourceType, targetType)).isNull();\n\t}\n\n\t@Test\n\tvoid stringToArrayCanConvert() {\n\t\tconversionService.addConverter(new StringToArrayConverter(conversionService));\n\t\tassertThat(conversionService.canConvert(String.class, Integer[].class)).isFalse();\n\t\tconversionService.addConverterFactory(new StringToNumberConverterFactory());\n\t\tassertThat(conversionService.canConvert(String.class, Integer[].class)).isTrue();\n\t}\n\n\t@Test\n\tvoid stringToCollectionCanConvert() throws Exception {\n\t\tconversionService.addConverter(new StringToCollectionConverter(conversionService));\n\t\tassertThat(conversionService.canConvert(String.class, Collection.class)).isTrue();\n\t\tTypeDescriptor targetType = new TypeDescriptor(getClass().getField(\"integerCollection\"));\n\t\tassertThat(conversionService.canConvert(TypeDescriptor.valueOf(String.class), targetType)).isFalse();\n\t\tconversionService.addConverterFactory(new StringToNumberConverterFactory());\n\t\tassertThat(conversionService.canConvert(TypeDescriptor.valueOf(String.class), targetType)).isTrue();\n\t}\n\n\t@Test\n\tvoid convertiblePairsInSet() {\n\t\tSet<GenericConverter.ConvertiblePair> set = new HashSet<>();\n\t\tset.add(new GenericConverter.ConvertiblePair(Number.class, String.class));\n\t\tassert set.contains(new GenericConverter.ConvertiblePair(Number.class, String.class));\n\t}\n\n\t@Test\n\tvoid convertiblePairEqualsAndHash() {\n\t\tGenericConverter.ConvertiblePair pair = new GenericConverter.ConvertiblePair(Number.class, String.class);\n\t\tGenericConverter.ConvertiblePair pairEqual = new GenericConverter.ConvertiblePair(Number.class, String.class);\n\t\tassertThat(pairEqual).isEqualTo(pair);\n\t\tassertThat(pairEqual.hashCode()).isEqualTo(pair.hashCode());\n\t}\n\n\t@Test\n\tvoid convertiblePairDifferentEqualsAndHash() {\n\t\tGenericConverter.ConvertiblePair pair = new GenericConverter.ConvertiblePair(Number.class, String.class);\n\t\tGenericConverter.ConvertiblePair pairOpposite = new GenericConverter.ConvertiblePair(String.class, Number.class);\n\t\tassertThat(pair).isNotEqualTo(pairOpposite);\n\t\tassertThat(pair.hashCode()).isNotEqualTo(pairOpposite.hashCode());\n\t}\n\n\t@Test\n\tvoid canConvertIllegalArgumentNullTargetTypeFromClass() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tconversionService.canConvert(String.class, null));\n\t}\n\n\t@Test\n\tvoid canConvertIllegalArgumentNullTargetTypeFromTypeDescriptor() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tconversionService.canConvert(TypeDescriptor.valueOf(String.class), null));\n\t}\n\n\t@Test\n\tvoid removeConvertible() {\n\t\tconversionService.addConverter(new ColorConverter());\n\t\tassertThat(conversionService.canConvert(String.class, Color.class)).isTrue();\n\t\tconversionService.removeConvertible(String.class, Color.class);\n\t\tassertThat(conversionService.canConvert(String.class, Color.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid conditionalConverter() {\n\t\tMyConditionalConverter converter = new MyConditionalConverter();\n\t\tconversionService.addConverter(new ColorConverter());\n\t\tconversionService.addConverter(converter);\n\t\tassertThat(conversionService.convert(\"#000000\", Color.class)).isEqualTo(Color.BLACK);\n\t\tassertThat(converter.getMatchAttempts()).isGreaterThan(0);\n\t}\n\n\t@Test\n\tvoid conditionalConverterFactory() {\n\t\tMyConditionalConverterFactory converter = new MyConditionalConverterFactory();\n\t\tconversionService.addConverter(new ColorConverter());\n\t\tconversionService.addConverterFactory(converter);\n\t\tassertThat(conversionService.convert(\"#000000\", Color.class)).isEqualTo(Color.BLACK);\n\t\tassertThat(converter.getMatchAttempts()).isGreaterThan(0);\n\t\tassertThat(converter.getNestedMatchAttempts()).isGreaterThan(0);\n\t}\n\n\t@Test\n\tvoid conditionalConverterCachingForDifferentAnnotationAttributes() throws Exception {\n\t\tconversionService.addConverter(new ColorConverter());\n\t\tconversionService.addConverter(new MyConditionalColorConverter());\n\n\t\tassertThat(conversionService.convert(\"000000xxxx\",\n\t\t\t\tnew TypeDescriptor(getClass().getField(\"activeColor\")))).isEqualTo(Color.BLACK);\n\t\tassertThat(conversionService.convert(\" #000000 \",\n\t\t\t\tnew TypeDescriptor(getClass().getField(\"inactiveColor\")))).isEqualTo(Color.BLACK);\n\t\tassertThat(conversionService.convert(\"000000yyyy\",\n\t\t\t\tnew TypeDescriptor(getClass().getField(\"activeColor\")))).isEqualTo(Color.BLACK);\n\t\tassertThat(conversionService.convert(\"  #000000  \",\n\t\t\t\tnew TypeDescriptor(getClass().getField(\"inactiveColor\")))).isEqualTo(Color.BLACK);\n\t}\n\n\t@Test\n\tvoid shouldNotSupportNullConvertibleTypesFromNonConditionalGenericConverter() {\n\t\tGenericConverter converter = new NonConditionalGenericConverter();\n\t\tassertThatIllegalStateException().isThrownBy(() ->\n\t\t\t\tconversionService.addConverter(converter))\n\t\t\t.withMessage(\"Only conditional converters may return null convertible types\");\n\t}\n\n\t@Test\n\tvoid conditionalConversionForAllTypes() {\n\t\tMyConditionalGenericConverter converter = new MyConditionalGenericConverter();\n\t\tconversionService.addConverter(converter);\n\t\tassertThat(conversionService.convert(3, Integer.class)).isEqualTo(3);\n\t\tassertThat(converter.getSourceTypes()).hasSizeGreaterThan(2);\n\t\tassertThat(converter.getSourceTypes().stream().allMatch(td -> Integer.class.equals(td.getType()))).isTrue();\n\t}\n\n\t@Test  // gh-14200, SPR-9566\n\tvoid convertOptimizeArray() {\n\t\tbyte[] byteArray = new byte[] { 1, 2, 3 };\n\t\tbyte[] converted = conversionService.convert(byteArray, byte[].class);\n\t\tassertThat(converted).isSameAs(byteArray);\n\t\tassertThat(converted).containsExactly(1, 2, 3);\n\t}\n\n\t@Test\n\tvoid enumToStringConversion() {\n\t\tconversionService.addConverter(new EnumToStringConverter(conversionService));\n\t\tassertThat(conversionService.convert(MyEnum.A, String.class)).isEqualTo(\"A\");\n\t}\n\n\t@Test\n\tvoid subclassOfEnumToString() {\n\t\tconversionService.addConverter(new EnumToStringConverter(conversionService));\n\t\tassertThat(conversionService.convert(EnumWithSubclass.FIRST, String.class)).isEqualTo(\"FIRST\");\n\t}\n\n\t@Test\n\tvoid enumWithInterfaceToStringConversion() {\n\t\t// SPR-9692\n\t\tconversionService.addConverter(new EnumToStringConverter(conversionService));\n\t\tconversionService.addConverter(new MyEnumInterfaceToStringConverter<>());\n\t\tassertThat(conversionService.convert(MyEnum.A, String.class)).isEqualTo(\"1\");\n\t}\n\n\t@Test\n\tvoid stringToEnumWithInterfaceConversion() {\n\t\tconversionService.addConverterFactory(new StringToEnumConverterFactory());\n\t\tconversionService.addConverterFactory(new StringToMyEnumInterfaceConverterFactory());\n\t\tassertThat(conversionService.convert(\"1\", MyEnum.class)).isEqualTo(MyEnum.A);\n\t}\n\n\t@Test\n\tvoid stringToEnumWithBaseInterfaceConversion() {\n\t\tconversionService.addConverterFactory(new StringToEnumConverterFactory());\n\t\tconversionService.addConverterFactory(new StringToMyEnumBaseInterfaceConverterFactory());\n\t\tassertThat(conversionService.convert(\"base1\", MyEnum.class)).isEqualTo(MyEnum.A);\n\t}\n\n\t@Test\n\tvoid convertNullAnnotatedStringToString() throws Exception {\n\t\tString source = null;\n\t\tTypeDescriptor sourceType = new TypeDescriptor(getClass().getField(\"annotatedString\"));\n\t\tTypeDescriptor targetType = TypeDescriptor.valueOf(String.class);\n\t\tconversionService.convert(source, sourceType, targetType);\n\t}\n\n\t@Test\n\tvoid multipleCollectionTypesFromSameSourceType() throws Exception {\n\t\tconversionService.addConverter(new MyStringToRawCollectionConverter());\n\t\tconversionService.addConverter(new MyStringToGenericCollectionConverter());\n\t\tconversionService.addConverter(new MyStringToStringCollectionConverter());\n\t\tconversionService.addConverter(new MyStringToIntegerCollectionConverter());\n\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"stringCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"integerCollection\")))).isEqualTo(Collections.singleton(4));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"rawCollection\")))).isEqualTo(Collections.singleton(4));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"genericCollection\")))).isEqualTo(Collections.singleton(4));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"rawCollection\")))).isEqualTo(Collections.singleton(4));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"stringCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t}\n\n\t@Test\n\tvoid adaptedCollectionTypesFromSameSourceType() throws Exception {\n\t\tconversionService.addConverter(new MyStringToStringCollectionConverter());\n\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"stringCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"genericCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"rawCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"genericCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"stringCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"rawCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\n\t\tassertThatExceptionOfType(ConverterNotFoundException.class).isThrownBy(() ->\n\t\t\t\tconversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"integerCollection\"))));\n\t}\n\n\t@Test\n\tvoid genericCollectionAsSource() throws Exception {\n\t\tconversionService.addConverter(new MyStringToGenericCollectionConverter());\n\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"stringCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"genericCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"rawCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\n\t\t// The following is unpleasant but a consequence of the generic collection converter above...\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"integerCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t}\n\n\t@Test\n\tvoid rawCollectionAsSource() throws Exception {\n\t\tconversionService.addConverter(new MyStringToRawCollectionConverter());\n\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"stringCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"genericCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"rawCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\n\t\t// The following is unpleasant but a consequence of the raw collection converter above...\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"integerCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t}\n\n\t@Test\n\tvoid stringListToListOfSubclassOfUnboundGenericClass() {\n\t\tconversionService.addConverter(new StringListToAListConverter());\n\t\tconversionService.addConverter(new StringListToBListConverter());\n\n\t\tList<?> aList = (List<?>) conversionService.convert(List.of(\"foo\"),\n\t\t\t\tTypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)),\n\t\t\t\tTypeDescriptor.collection(List.class, TypeDescriptor.valueOf(ARaw.class)));\n\t\tassertThat(aList).allMatch(e -> e instanceof ARaw);\n\n\t\tList<?> bList = (List<?>) conversionService.convert(List.of(\"foo\"),\n\t\t\t\tTypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)),\n\t\t\t\tTypeDescriptor.collection(List.class, TypeDescriptor.valueOf(BRaw.class)));\n\t\tassertThat(bList).allMatch(e -> e instanceof BRaw);\n\t}\n\n\n\t@ExampleAnnotation(active = true)\n\tpublic String annotatedString;\n\n\t@ExampleAnnotation(active = true)\n\tpublic Color activeColor;\n\n\t@ExampleAnnotation(active = false)\n\tpublic Color inactiveColor;\n\n\tpublic Map<String, ?> wildcardMap;\n\n\t@SuppressWarnings(\"rawtypes\")\n\tpublic Collection rawCollection;\n\n\tpublic Collection<?> genericCollection;\n\n\tpublic Collection<String> stringCollection;\n\n\tpublic Collection<Integer> integerCollection;\n\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\tprivate @interface ExampleAnnotation {\n\n\t\tboolean active();\n\t}\n\n\n\tprivate interface MyBaseInterface {\n\t}\n\n\n\tprivate interface MyInterface extends MyBaseInterface {\n\t}\n\n\n\tprivate static class MyInterfaceImplementer implements MyInterface {\n\t}\n\n\n\tprivate static class MyBaseInterfaceToStringConverter implements Converter<MyBaseInterface, String> {\n\n\t\t@Override\n\t\tpublic String convert(MyBaseInterface source) {\n\t\t\treturn \"RESULT\";\n\t\t}\n\t}\n\n\n\tprivate static class MyStringArrayToResourceArrayConverter implements Converter<String[], Resource[]> {\n\n\t\t@Override\n\t\tpublic Resource[] convert(String[] source) {\n\t\t\treturn Arrays.stream(source).map(s -> s.substring(1)).map(DescriptiveResource::new).toArray(Resource[]::new);\n\t\t}\n\t}\n\n\n\tprivate static class MyStringArrayToIntegerArrayConverter implements Converter<String[], Integer[]> {\n\n\t\t@Override\n\t\tpublic Integer[] convert(String[] source) {\n\t\t\treturn Arrays.stream(source).map(s -> s.substring(1)).map(Integer::valueOf).toArray(Integer[]::new);\n\t\t}\n\t}\n\n\n\tprivate static class MyStringToIntegerArrayConverter implements Converter<String, Integer[]> {\n\n\t\t@Override\n\t\tpublic Integer[] convert(String source) {\n\t\t\tString[] srcArray = StringUtils.commaDelimitedListToStringArray(source);\n\t\t\treturn Arrays.stream(srcArray).map(s -> s.substring(1)).map(Integer::valueOf).toArray(Integer[]::new);\n\t\t}\n\t}\n\n\n\tprivate static class WithCopyConstructor {\n\n\t\tWithCopyConstructor() {}\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tWithCopyConstructor(WithCopyConstructor value) {}\n\t}\n\n\n\tprivate static class MyConditionalConverter implements Converter<String, Color>, ConditionalConverter {\n\n\t\tprivate int matchAttempts = 0;\n\n\t\t@Override\n\t\tpublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\tmatchAttempts++;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic Color convert(String source) {\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic int getMatchAttempts() {\n\t\t\treturn matchAttempts;\n\t\t}\n\t}\n\n\n\tprivate static class NonConditionalGenericConverter implements GenericConverter {\n\n\t\t@Override\n\t\tpublic Set<ConvertiblePair> getConvertibleTypes() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\tprivate static class MyConditionalGenericConverter implements GenericConverter, ConditionalConverter {\n\n\t\tprivate final List<TypeDescriptor> sourceTypes = new ArrayList<>();\n\n\t\t@Override\n\t\tpublic Set<ConvertiblePair> getConvertibleTypes() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\tsourceTypes.add(sourceType);\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic List<TypeDescriptor> getSourceTypes() {\n\t\t\treturn sourceTypes;\n\t\t}\n\t}\n\n\n\tprivate static class MyConditionalConverterFactory implements ConverterFactory<String, Color>, ConditionalConverter {\n\n\t\tprivate MyConditionalConverter converter = new MyConditionalConverter();\n\n\t\tprivate int matchAttempts = 0;\n\n\t\t@Override\n\t\tpublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\tmatchAttempts++;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic <T extends Color> Converter<String, T> getConverter(Class<T> targetType) {\n\t\t\treturn (Converter<String, T>) converter;\n\t\t}\n\n\t\tpublic int getMatchAttempts() {\n\t\t\treturn matchAttempts;\n\t\t}\n\n\t\tpublic int getNestedMatchAttempts() {\n\t\t\treturn converter.getMatchAttempts();\n\t\t}\n\t}\n\n\n\tprivate interface MyEnumBaseInterface {\n\t\tString getBaseCode();\n\t}\n\n\n\tprivate interface MyEnumInterface extends MyEnumBaseInterface {\n\t\tString getCode();\n\t}\n\n\n\tprivate enum MyEnum implements MyEnumInterface {\n\n\t\tA(\"1\"),\n\t\tB(\"2\"),\n\t\tC(\"3\");\n\n\t\tprivate final String code;\n\n\t\tMyEnum(String code) {\n\t\t\tthis.code = code;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getCode() {\n\t\t\treturn code;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getBaseCode() {\n\t\t\treturn \"base\" + code;\n\t\t}\n\t}\n\n\n\tprivate enum EnumWithSubclass {\n\n\t\tFIRST {\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\treturn \"1st\";\n\t\t\t}\n\t\t}\n\t}\n\n\n\t@SuppressWarnings(\"rawtypes\")\n\tprivate static class MyStringToRawCollectionConverter implements Converter<String, Collection> {\n\n\t\t@Override\n\t\tpublic Collection convert(String source) {\n\t\t\treturn Collections.singleton(source + \"X\");\n\t\t}\n\t}\n\n\n\tprivate static class MyStringToGenericCollectionConverter implements Converter<String, Collection<?>> {\n\n\t\t@Override\n\t\tpublic Collection<?> convert(String source) {\n\t\t\treturn Collections.singleton(source + \"X\");\n\t\t}\n\t}\n\n\n\tprivate static class MyEnumInterfaceToStringConverter<T extends MyEnumInterface> implements Converter<T, String> {\n\n\t\t@Override\n\t\tpublic String convert(T source) {\n\t\t\treturn source.getCode();\n\t\t}\n\t}\n\n\n\tprivate static class StringToMyEnumInterfaceConverterFactory implements ConverterFactory<String, MyEnumInterface> {\n\n\t\t@Override\n\t\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n\t\tpublic <T extends MyEnumInterface> Converter<String, T> getConverter(Class<T> targetType) {\n\t\t\treturn new StringToMyEnumInterfaceConverter(targetType);\n\t\t}\n\n\t\tprivate static class StringToMyEnumInterfaceConverter<T extends Enum<?> & MyEnumInterface> implements Converter<String, T> {\n\n\t\t\tprivate final Class<T> enumType;\n\n\t\t\tpublic StringToMyEnumInterfaceConverter(Class<T> enumType) {\n\t\t\t\tthis.enumType = enumType;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T convert(String source) {\n\t\t\t\tfor (T value : enumType.getEnumConstants()) {\n\t\t\t\t\tif (value.getCode().equals(source)) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate static class StringToMyEnumBaseInterfaceConverterFactory implements ConverterFactory<String, MyEnumBaseInterface> {\n\n\t\t@Override\n\t\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n\t\tpublic <T extends MyEnumBaseInterface> Converter<String, T> getConverter(Class<T> targetType) {\n\t\t\treturn new StringToMyEnumBaseInterfaceConverter(targetType);\n\t\t}\n\n\t\tprivate static class StringToMyEnumBaseInterfaceConverter<T extends Enum<?> & MyEnumBaseInterface> implements Converter<String, T> {\n\n\t\t\tprivate final Class<T> enumType;\n\n\t\t\tpublic StringToMyEnumBaseInterfaceConverter(Class<T> enumType) {\n\t\t\t\tthis.enumType = enumType;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T convert(String source) {\n\t\t\t\tfor (T value : enumType.getEnumConstants()) {\n\t\t\t\t\tif (value.getBaseCode().equals(source)) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate static class MyStringToStringCollectionConverter implements Converter<String, Collection<String>> {\n\n\t\t@Override\n\t\tpublic Collection<String> convert(String source) {\n\t\t\treturn Collections.singleton(source + \"X\");\n\t\t}\n\t}\n\n\n\tprivate static class MyStringToIntegerCollectionConverter implements Converter<String, Collection<Integer>> {\n\n\t\t@Override\n\t\tpublic Collection<Integer> convert(String source) {\n\t\t\treturn Collections.singleton(source.length());\n\t\t}\n\t}\n\n\n\t@SuppressWarnings(\"rawtypes\")\n\tprivate static class UntypedConverter implements Converter {\n\n\t\t@Override\n\t\tpublic Object convert(Object source) {\n\t\t\treturn source;\n\t\t}\n\t}\n\n\n\tprivate static class ColorConverter implements Converter<String, Color> {\n\n\t\t@Override\n\t\tpublic Color convert(String source) {\n\t\t\treturn Color.decode(source.trim());\n\t\t}\n\t}\n\n\n\tprivate static class MyConditionalColorConverter implements Converter<String, Color>, ConditionalConverter {\n\n\t\t@Override\n\t\tpublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\tExampleAnnotation ann = targetType.getAnnotation(ExampleAnnotation.class);\n\t\t\treturn (ann != null && ann.active());\n\t\t}\n\n\t\t@Override\n\t\tpublic Color convert(String source) {\n\t\t\treturn Color.decode(source.substring(0, 6));\n\t\t}\n\t}\n\n\n\tprivate static class GenericBaseClass<T> {\n\t}\n\n\t@SuppressWarnings(\"rawtypes\")\n\tprivate static class ARaw extends GenericBaseClass {\n\t}\n\n\t@SuppressWarnings(\"rawtypes\")\n\tprivate static class BRaw extends GenericBaseClass {\n\t}\n\n\n\tprivate static class StringListToAListConverter implements Converter<List<String>, List<ARaw>> {\n\n\t\t@Override\n\t\tpublic List<ARaw> convert(List<String> source) {\n\t\t\treturn List.of(new ARaw());\n\t\t}\n\t}\n\n\n\tprivate static class StringListToBListConverter implements Converter<List<String>, List<BRaw>> {\n\n\t\t@Override\n\t\tpublic List<BRaw> convert(List<String> source) {\n\t\t\treturn List.of(new BRaw());\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.convert.support.StringToMyEnumInterfaceConverterFactory#getConverter(Class<T>)",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\npublic <T extends MyEnumInterface> Converter<String, T> getConverter(Class<T> targetType) {\r\n    return new StringToMyEnumInterfaceConverter(targetType);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.convert.support.StringToMyEnumInterfaceConverterFactory",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.convert.support.StringToMyEnumInterfaceConverterFactory#getConverter(Class<T>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.convert.support.StringToMyEnumInterfaceConverterFactory#getConverter(Class<T>)",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.convert.support.StringToMyEnumInterfaceConverterFactory#getConverter(Class<T>)",
    "headType": "method",
    "relation": "use",
    "tail": "@SuppressWarnings",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.convert.support",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.convert.support.StringToMyEnumInterfaceConverter",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.convert.support.StringToMyEnumInterfaceConverter",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.convert.support;\n\nimport java.awt.Color;\nimport java.awt.SystemColor;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.jspecify.annotations.Nullable;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.convert.ConversionFailedException;\nimport org.springframework.core.convert.ConverterNotFoundException;\nimport org.springframework.core.convert.TypeDescriptor;\nimport org.springframework.core.convert.converter.ConditionalConverter;\nimport org.springframework.core.convert.converter.Converter;\nimport org.springframework.core.convert.converter.ConverterFactory;\nimport org.springframework.core.convert.converter.GenericConverter;\nimport org.springframework.core.io.DescriptiveResource;\nimport org.springframework.core.io.Resource;\nimport org.springframework.util.StringUtils;\n\nimport static java.util.Comparator.naturalOrder;\nimport static java.util.stream.Collectors.toList;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.assertj.core.api.Assertions.assertThatIllegalStateException;\n\n/**\n * Tests for {@link GenericConversionService}.\n *\n * <p>In this package for access to package-local converter implementations.\n *\n * @author Keith Donald\n * @author Juergen Hoeller\n * @author Phillip Webb\n * @author David Haraburda\n * @author Sam Brannen\n */\nclass GenericConversionServiceTests {\n\n\tprivate final GenericConversionService conversionService = new GenericConversionService();\n\n\n\t@Test\n\tvoid canConvert() {\n\t\tassertThat(conversionService.canConvert(String.class, Integer.class)).isFalse();\n\t\tconversionService.addConverterFactory(new StringToNumberConverterFactory());\n\t\tassertThat(conversionService.canConvert(String.class, Integer.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid canConvertAssignable() {\n\t\tassertThat(conversionService.canConvert(String.class, String.class)).isTrue();\n\t\tassertThat(conversionService.canConvert(Integer.class, Number.class)).isTrue();\n\t\tassertThat(conversionService.canConvert(boolean.class, boolean.class)).isTrue();\n\t\tassertThat(conversionService.canConvert(boolean.class, Boolean.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid canConvertFromClassSourceTypeToNullTargetType() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tconversionService.canConvert(String.class, null));\n\t}\n\n\t@Test\n\tvoid canConvertFromTypeDescriptorSourceTypeToNullTargetType() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tconversionService.canConvert(TypeDescriptor.valueOf(String.class), null));\n\t}\n\n\t@Test\n\tvoid canConvertNullSourceType() {\n\t\tassertThat(conversionService.canConvert(null, Integer.class)).isTrue();\n\t\tassertThat(conversionService.canConvert(null, TypeDescriptor.valueOf(Integer.class))).isTrue();\n\t}\n\n\t@Test\n\tvoid convert() {\n\t\tconversionService.addConverterFactory(new StringToNumberConverterFactory());\n\t\tassertThat(conversionService.convert(\"3\", Integer.class)).isEqualTo(3);\n\t}\n\n\t@Test\n\tvoid convertNullSource() {\n\t\tassertThat(conversionService.convert(null, Integer.class)).isNull();\n\t}\n\n\t@Test\n\tvoid convertNullSourcePrimitiveTarget() {\n\t\tassertThatExceptionOfType(ConversionFailedException.class).isThrownBy(() ->\n\t\t\t\tconversionService.convert(null, int.class));\n\t}\n\n\t@Test\n\tvoid convertNullSourcePrimitiveTargetTypeDescriptor() {\n\t\tassertThatExceptionOfType(ConversionFailedException.class).isThrownBy(() ->\n\t\t\t\tconversionService.convert(null, TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(int.class)));\n\t}\n\n\t@Test\n\tvoid convertNotNullSourceNullSourceTypeDescriptor() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tconversionService.convert(\"3\", null, TypeDescriptor.valueOf(int.class)));\n\t}\n\n\t@Test\n\tvoid convertAssignableSource() {\n\t\tassertThat(conversionService.convert(false, boolean.class)).isFalse();\n\t\tassertThat(conversionService.convert(false, Boolean.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid converterNotFound() {\n\t\tassertThatExceptionOfType(ConverterNotFoundException.class).isThrownBy(() ->\n\t\t\t\tconversionService.convert(\"3\", Integer.class));\n\t}\n\n\t@Test\n\tvoid addConverterNoSourceTargetClassInfoAvailable() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tconversionService.addConverter(new UntypedConverter()));\n\t}\n\n\t@Test\n\tvoid sourceTypeIsVoid() {\n\t\tassertThat(conversionService.canConvert(void.class, String.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid targetTypeIsVoid() {\n\t\tassertThat(conversionService.canConvert(String.class, void.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid convertNull() {\n\t\tassertThat(conversionService.convert(null, Integer.class)).isNull();\n\t}\n\n\t@Test\n\tvoid convertToNullTargetClass() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tconversionService.convert(\"3\", (Class<?>) null));\n\t}\n\n\t@Test\n\tvoid convertToNullTargetTypeDescriptor() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tconversionService.convert(\"3\", TypeDescriptor.valueOf(String.class), null));\n\t}\n\n\t@Test\n\tvoid convertWrongSourceTypeDescriptor() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tconversionService.convert(\"3\", TypeDescriptor.valueOf(Integer.class), TypeDescriptor.valueOf(Long.class)));\n\t}\n\n\t@Test\n\tvoid convertWrongTypeArgument() {\n\t\tconversionService.addConverterFactory(new StringToNumberConverterFactory());\n\t\tassertThatExceptionOfType(ConversionFailedException.class).isThrownBy(() ->\n\t\t\t\tconversionService.convert(\"BOGUS\", Integer.class));\n\t}\n\n\t@Test\n\tvoid convertSuperSourceType() {\n\t\tconversionService.addConverter(CharSequence.class, Integer.class, source -> Integer.valueOf(source.toString()));\n\t\tInteger result = conversionService.convert(\"3\", Integer.class);\n\t\tassertThat(result).isEqualTo(3);\n\t}\n\n\t// SPR-8718\n\t@Test\n\tvoid convertSuperTarget() {\n\t\tconversionService.addConverter(new ColorConverter());\n\t\tassertThatExceptionOfType(ConverterNotFoundException.class).isThrownBy(() ->\n\t\t\t\tconversionService.convert(\"#000000\", SystemColor.class));\n\t}\n\n\t@Test\n\tvoid convertObjectToPrimitive() {\n\t\tassertThat(conversionService.canConvert(String.class, boolean.class)).isFalse();\n\t\tconversionService.addConverter(new StringToBooleanConverter());\n\t\tassertThat(conversionService.canConvert(String.class, boolean.class)).isTrue();\n\t\tBoolean b = conversionService.convert(\"true\", boolean.class);\n\t\tassertThat(b).isTrue();\n\t\tassertThat(conversionService.canConvert(TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(boolean.class))).isTrue();\n\t\tb = (Boolean) conversionService.convert(\"true\", TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(boolean.class));\n\t\tassertThat(b).isTrue();\n\t}\n\n\t@Test\n\tvoid convertObjectToPrimitiveViaConverterFactory() {\n\t\tassertThat(conversionService.canConvert(String.class, int.class)).isFalse();\n\t\tconversionService.addConverterFactory(new StringToNumberConverterFactory());\n\t\tassertThat(conversionService.canConvert(String.class, int.class)).isTrue();\n\t\tInteger three = conversionService.convert(\"3\", int.class);\n\t\tassertThat(three).isEqualTo(3);\n\t}\n\n\t@Test\n\tvoid genericConverterDelegatingBackToConversionServiceConverterNotFound() {\n\t\tconversionService.addConverter(new ObjectToArrayConverter(conversionService));\n\t\tassertThat(conversionService.canConvert(String.class, Integer[].class)).isFalse();\n\t\tassertThatExceptionOfType(ConverterNotFoundException.class).isThrownBy(() ->\n\t\t\t\tconversionService.convert(\"3,4,5\", Integer[].class));\n\t}\n\n\t@Test\n\tvoid listToIterableConversion() {\n\t\tList<Object> raw = List.of(\"one\", \"two\");\n\t\tObject converted = conversionService.convert(raw, Iterable.class);\n\t\tassertThat(converted).isSameAs(raw);\n\t}\n\n\t@Test\n\tvoid listToObjectConversion() {\n\t\tList<Object> raw = List.of(\"one\", \"two\");\n\t\tObject converted = conversionService.convert(raw, Object.class);\n\t\tassertThat(converted).isSameAs(raw);\n\t}\n\n\t@Test\n\tvoid mapToObjectConversion() {\n\t\tMap<Object, Object> raw = Map.of(\"key\", \"value\");\n\t\tObject converted = conversionService.convert(raw, Object.class);\n\t\tassertThat(converted).isSameAs(raw);\n\t}\n\n\t@Test\n\tvoid interfaceToString() {\n\t\tconversionService.addConverter(new MyBaseInterfaceToStringConverter());\n\t\tconversionService.addConverter(new ObjectToStringConverter());\n\t\tObject converted = conversionService.convert(new MyInterfaceImplementer(), String.class);\n\t\tassertThat(converted).isEqualTo(\"RESULT\");\n\t}\n\n\t@Test\n\tvoid interfaceArrayToStringArray() {\n\t\tconversionService.addConverter(new MyBaseInterfaceToStringConverter());\n\t\tconversionService.addConverter(new ArrayToArrayConverter(conversionService));\n\t\tString[] converted = conversionService.convert(new MyInterface[] {new MyInterfaceImplementer()}, String[].class);\n\t\tassertThat(converted[0]).isEqualTo(\"RESULT\");\n\t}\n\n\t@Test\n\tvoid objectArrayToStringArray() {\n\t\tconversionService.addConverter(new MyBaseInterfaceToStringConverter());\n\t\tconversionService.addConverter(new ArrayToArrayConverter(conversionService));\n\t\tString[] converted = conversionService.convert(new MyInterfaceImplementer[] {new MyInterfaceImplementer()}, String[].class);\n\t\tassertThat(converted[0]).isEqualTo(\"RESULT\");\n\t}\n\n\t@Test\n\tvoid stringArrayToResourceArray() {\n\t\tconversionService.addConverter(new MyStringArrayToResourceArrayConverter());\n\t\tResource[] converted = conversionService.convert(new String[] { \"x1\", \"z3\" }, Resource[].class);\n\t\tList<String> descriptions = Arrays.stream(converted).map(Resource::getDescription).sorted(naturalOrder()).collect(toList());\n\t\tassertThat(descriptions).isEqualTo(Arrays.asList(\"1\", \"3\"));\n\t}\n\n\t@Test\n\tvoid stringArrayToIntegerArray() {\n\t\tconversionService.addConverter(new MyStringArrayToIntegerArrayConverter());\n\t\tInteger[] converted = conversionService.convert(new String[] {\"x1\", \"z3\"}, Integer[].class);\n\t\tassertThat(converted).isEqualTo(new Integer[] { 1, 3 });\n\t}\n\n\t@Test\n\tvoid stringToIntegerArray() {\n\t\tconversionService.addConverter(new MyStringToIntegerArrayConverter());\n\t\tInteger[] converted = conversionService.convert(\"x1,z3\", Integer[].class);\n\t\tassertThat(converted).isEqualTo(new Integer[] { 1, 3 });\n\t}\n\n\t@Test\n\tvoid wildcardMap() throws Exception {\n\t\tMap<String, String> input = new LinkedHashMap<>();\n\t\tinput.put(\"key\", \"value\");\n\t\tObject converted = conversionService.convert(input, new TypeDescriptor(getClass().getField(\"wildcardMap\")));\n\t\tassertThat(converted).isEqualTo(input);\n\t}\n\n\t@Test\n\tvoid stringToString() {\n\t\tString value = \"myValue\";\n\t\tString result = conversionService.convert(value, String.class);\n\t\tassertThat(result).isSameAs(value);\n\t}\n\n\t@Test\n\tvoid stringToObject() {\n\t\tString value = \"myValue\";\n\t\tObject result = conversionService.convert(value, Object.class);\n\t\tassertThat(result).isSameAs(value);\n\t}\n\n\t@Test\n\tvoid ignoreCopyConstructor() {\n\t\tWithCopyConstructor value = new WithCopyConstructor();\n\t\tObject result = conversionService.convert(value, WithCopyConstructor.class);\n\t\tassertThat(result).isSameAs(value);\n\t}\n\n\t@Test\n\tvoid emptyListToArray() {\n\t\tconversionService.addConverter(new CollectionToArrayConverter(conversionService));\n\t\tconversionService.addConverterFactory(new StringToNumberConverterFactory());\n\t\tList<String> list = new ArrayList<>();\n\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(list);\n\t\tTypeDescriptor targetType = TypeDescriptor.valueOf(String[].class);\n\t\tassertThat(conversionService.canConvert(sourceType, targetType)).isTrue();\n\t\tassertThat(((String[]) conversionService.convert(list, sourceType, targetType))).isEmpty();\n\t}\n\n\t@Test\n\tvoid emptyListToObject() {\n\t\tconversionService.addConverter(new CollectionToObjectConverter(conversionService));\n\t\tconversionService.addConverterFactory(new StringToNumberConverterFactory());\n\t\tList<String> list = new ArrayList<>();\n\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(list);\n\t\tTypeDescriptor targetType = TypeDescriptor.valueOf(Integer.class);\n\t\tassertThat(conversionService.canConvert(sourceType, targetType)).isTrue();\n\t\tassertThat(conversionService.convert(list, sourceType, targetType)).isNull();\n\t}\n\n\t@Test\n\tvoid stringToArrayCanConvert() {\n\t\tconversionService.addConverter(new StringToArrayConverter(conversionService));\n\t\tassertThat(conversionService.canConvert(String.class, Integer[].class)).isFalse();\n\t\tconversionService.addConverterFactory(new StringToNumberConverterFactory());\n\t\tassertThat(conversionService.canConvert(String.class, Integer[].class)).isTrue();\n\t}\n\n\t@Test\n\tvoid stringToCollectionCanConvert() throws Exception {\n\t\tconversionService.addConverter(new StringToCollectionConverter(conversionService));\n\t\tassertThat(conversionService.canConvert(String.class, Collection.class)).isTrue();\n\t\tTypeDescriptor targetType = new TypeDescriptor(getClass().getField(\"integerCollection\"));\n\t\tassertThat(conversionService.canConvert(TypeDescriptor.valueOf(String.class), targetType)).isFalse();\n\t\tconversionService.addConverterFactory(new StringToNumberConverterFactory());\n\t\tassertThat(conversionService.canConvert(TypeDescriptor.valueOf(String.class), targetType)).isTrue();\n\t}\n\n\t@Test\n\tvoid convertiblePairsInSet() {\n\t\tSet<GenericConverter.ConvertiblePair> set = new HashSet<>();\n\t\tset.add(new GenericConverter.ConvertiblePair(Number.class, String.class));\n\t\tassert set.contains(new GenericConverter.ConvertiblePair(Number.class, String.class));\n\t}\n\n\t@Test\n\tvoid convertiblePairEqualsAndHash() {\n\t\tGenericConverter.ConvertiblePair pair = new GenericConverter.ConvertiblePair(Number.class, String.class);\n\t\tGenericConverter.ConvertiblePair pairEqual = new GenericConverter.ConvertiblePair(Number.class, String.class);\n\t\tassertThat(pairEqual).isEqualTo(pair);\n\t\tassertThat(pairEqual.hashCode()).isEqualTo(pair.hashCode());\n\t}\n\n\t@Test\n\tvoid convertiblePairDifferentEqualsAndHash() {\n\t\tGenericConverter.ConvertiblePair pair = new GenericConverter.ConvertiblePair(Number.class, String.class);\n\t\tGenericConverter.ConvertiblePair pairOpposite = new GenericConverter.ConvertiblePair(String.class, Number.class);\n\t\tassertThat(pair).isNotEqualTo(pairOpposite);\n\t\tassertThat(pair.hashCode()).isNotEqualTo(pairOpposite.hashCode());\n\t}\n\n\t@Test\n\tvoid canConvertIllegalArgumentNullTargetTypeFromClass() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tconversionService.canConvert(String.class, null));\n\t}\n\n\t@Test\n\tvoid canConvertIllegalArgumentNullTargetTypeFromTypeDescriptor() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tconversionService.canConvert(TypeDescriptor.valueOf(String.class), null));\n\t}\n\n\t@Test\n\tvoid removeConvertible() {\n\t\tconversionService.addConverter(new ColorConverter());\n\t\tassertThat(conversionService.canConvert(String.class, Color.class)).isTrue();\n\t\tconversionService.removeConvertible(String.class, Color.class);\n\t\tassertThat(conversionService.canConvert(String.class, Color.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid conditionalConverter() {\n\t\tMyConditionalConverter converter = new MyConditionalConverter();\n\t\tconversionService.addConverter(new ColorConverter());\n\t\tconversionService.addConverter(converter);\n\t\tassertThat(conversionService.convert(\"#000000\", Color.class)).isEqualTo(Color.BLACK);\n\t\tassertThat(converter.getMatchAttempts()).isGreaterThan(0);\n\t}\n\n\t@Test\n\tvoid conditionalConverterFactory() {\n\t\tMyConditionalConverterFactory converter = new MyConditionalConverterFactory();\n\t\tconversionService.addConverter(new ColorConverter());\n\t\tconversionService.addConverterFactory(converter);\n\t\tassertThat(conversionService.convert(\"#000000\", Color.class)).isEqualTo(Color.BLACK);\n\t\tassertThat(converter.getMatchAttempts()).isGreaterThan(0);\n\t\tassertThat(converter.getNestedMatchAttempts()).isGreaterThan(0);\n\t}\n\n\t@Test\n\tvoid conditionalConverterCachingForDifferentAnnotationAttributes() throws Exception {\n\t\tconversionService.addConverter(new ColorConverter());\n\t\tconversionService.addConverter(new MyConditionalColorConverter());\n\n\t\tassertThat(conversionService.convert(\"000000xxxx\",\n\t\t\t\tnew TypeDescriptor(getClass().getField(\"activeColor\")))).isEqualTo(Color.BLACK);\n\t\tassertThat(conversionService.convert(\" #000000 \",\n\t\t\t\tnew TypeDescriptor(getClass().getField(\"inactiveColor\")))).isEqualTo(Color.BLACK);\n\t\tassertThat(conversionService.convert(\"000000yyyy\",\n\t\t\t\tnew TypeDescriptor(getClass().getField(\"activeColor\")))).isEqualTo(Color.BLACK);\n\t\tassertThat(conversionService.convert(\"  #000000  \",\n\t\t\t\tnew TypeDescriptor(getClass().getField(\"inactiveColor\")))).isEqualTo(Color.BLACK);\n\t}\n\n\t@Test\n\tvoid shouldNotSupportNullConvertibleTypesFromNonConditionalGenericConverter() {\n\t\tGenericConverter converter = new NonConditionalGenericConverter();\n\t\tassertThatIllegalStateException().isThrownBy(() ->\n\t\t\t\tconversionService.addConverter(converter))\n\t\t\t.withMessage(\"Only conditional converters may return null convertible types\");\n\t}\n\n\t@Test\n\tvoid conditionalConversionForAllTypes() {\n\t\tMyConditionalGenericConverter converter = new MyConditionalGenericConverter();\n\t\tconversionService.addConverter(converter);\n\t\tassertThat(conversionService.convert(3, Integer.class)).isEqualTo(3);\n\t\tassertThat(converter.getSourceTypes()).hasSizeGreaterThan(2);\n\t\tassertThat(converter.getSourceTypes().stream().allMatch(td -> Integer.class.equals(td.getType()))).isTrue();\n\t}\n\n\t@Test  // gh-14200, SPR-9566\n\tvoid convertOptimizeArray() {\n\t\tbyte[] byteArray = new byte[] { 1, 2, 3 };\n\t\tbyte[] converted = conversionService.convert(byteArray, byte[].class);\n\t\tassertThat(converted).isSameAs(byteArray);\n\t\tassertThat(converted).containsExactly(1, 2, 3);\n\t}\n\n\t@Test\n\tvoid enumToStringConversion() {\n\t\tconversionService.addConverter(new EnumToStringConverter(conversionService));\n\t\tassertThat(conversionService.convert(MyEnum.A, String.class)).isEqualTo(\"A\");\n\t}\n\n\t@Test\n\tvoid subclassOfEnumToString() {\n\t\tconversionService.addConverter(new EnumToStringConverter(conversionService));\n\t\tassertThat(conversionService.convert(EnumWithSubclass.FIRST, String.class)).isEqualTo(\"FIRST\");\n\t}\n\n\t@Test\n\tvoid enumWithInterfaceToStringConversion() {\n\t\t// SPR-9692\n\t\tconversionService.addConverter(new EnumToStringConverter(conversionService));\n\t\tconversionService.addConverter(new MyEnumInterfaceToStringConverter<>());\n\t\tassertThat(conversionService.convert(MyEnum.A, String.class)).isEqualTo(\"1\");\n\t}\n\n\t@Test\n\tvoid stringToEnumWithInterfaceConversion() {\n\t\tconversionService.addConverterFactory(new StringToEnumConverterFactory());\n\t\tconversionService.addConverterFactory(new StringToMyEnumInterfaceConverterFactory());\n\t\tassertThat(conversionService.convert(\"1\", MyEnum.class)).isEqualTo(MyEnum.A);\n\t}\n\n\t@Test\n\tvoid stringToEnumWithBaseInterfaceConversion() {\n\t\tconversionService.addConverterFactory(new StringToEnumConverterFactory());\n\t\tconversionService.addConverterFactory(new StringToMyEnumBaseInterfaceConverterFactory());\n\t\tassertThat(conversionService.convert(\"base1\", MyEnum.class)).isEqualTo(MyEnum.A);\n\t}\n\n\t@Test\n\tvoid convertNullAnnotatedStringToString() throws Exception {\n\t\tString source = null;\n\t\tTypeDescriptor sourceType = new TypeDescriptor(getClass().getField(\"annotatedString\"));\n\t\tTypeDescriptor targetType = TypeDescriptor.valueOf(String.class);\n\t\tconversionService.convert(source, sourceType, targetType);\n\t}\n\n\t@Test\n\tvoid multipleCollectionTypesFromSameSourceType() throws Exception {\n\t\tconversionService.addConverter(new MyStringToRawCollectionConverter());\n\t\tconversionService.addConverter(new MyStringToGenericCollectionConverter());\n\t\tconversionService.addConverter(new MyStringToStringCollectionConverter());\n\t\tconversionService.addConverter(new MyStringToIntegerCollectionConverter());\n\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"stringCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"integerCollection\")))).isEqualTo(Collections.singleton(4));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"rawCollection\")))).isEqualTo(Collections.singleton(4));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"genericCollection\")))).isEqualTo(Collections.singleton(4));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"rawCollection\")))).isEqualTo(Collections.singleton(4));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"stringCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t}\n\n\t@Test\n\tvoid adaptedCollectionTypesFromSameSourceType() throws Exception {\n\t\tconversionService.addConverter(new MyStringToStringCollectionConverter());\n\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"stringCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"genericCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"rawCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"genericCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"stringCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"rawCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\n\t\tassertThatExceptionOfType(ConverterNotFoundException.class).isThrownBy(() ->\n\t\t\t\tconversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"integerCollection\"))));\n\t}\n\n\t@Test\n\tvoid genericCollectionAsSource() throws Exception {\n\t\tconversionService.addConverter(new MyStringToGenericCollectionConverter());\n\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"stringCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"genericCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"rawCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\n\t\t// The following is unpleasant but a consequence of the generic collection converter above...\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"integerCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t}\n\n\t@Test\n\tvoid rawCollectionAsSource() throws Exception {\n\t\tconversionService.addConverter(new MyStringToRawCollectionConverter());\n\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"stringCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"genericCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"rawCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\n\t\t// The following is unpleasant but a consequence of the raw collection converter above...\n\t\tassertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"integerCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\n\t}\n\n\t@Test\n\tvoid stringListToListOfSubclassOfUnboundGenericClass() {\n\t\tconversionService.addConverter(new StringListToAListConverter());\n\t\tconversionService.addConverter(new StringListToBListConverter());\n\n\t\tList<?> aList = (List<?>) conversionService.convert(List.of(\"foo\"),\n\t\t\t\tTypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)),\n\t\t\t\tTypeDescriptor.collection(List.class, TypeDescriptor.valueOf(ARaw.class)));\n\t\tassertThat(aList).allMatch(e -> e instanceof ARaw);\n\n\t\tList<?> bList = (List<?>) conversionService.convert(List.of(\"foo\"),\n\t\t\t\tTypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)),\n\t\t\t\tTypeDescriptor.collection(List.class, TypeDescriptor.valueOf(BRaw.class)));\n\t\tassertThat(bList).allMatch(e -> e instanceof BRaw);\n\t}\n\n\n\t@ExampleAnnotation(active = true)\n\tpublic String annotatedString;\n\n\t@ExampleAnnotation(active = true)\n\tpublic Color activeColor;\n\n\t@ExampleAnnotation(active = false)\n\tpublic Color inactiveColor;\n\n\tpublic Map<String, ?> wildcardMap;\n\n\t@SuppressWarnings(\"rawtypes\")\n\tpublic Collection rawCollection;\n\n\tpublic Collection<?> genericCollection;\n\n\tpublic Collection<String> stringCollection;\n\n\tpublic Collection<Integer> integerCollection;\n\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\tprivate @interface ExampleAnnotation {\n\n\t\tboolean active();\n\t}\n\n\n\tprivate interface MyBaseInterface {\n\t}\n\n\n\tprivate interface MyInterface extends MyBaseInterface {\n\t}\n\n\n\tprivate static class MyInterfaceImplementer implements MyInterface {\n\t}\n\n\n\tprivate static class MyBaseInterfaceToStringConverter implements Converter<MyBaseInterface, String> {\n\n\t\t@Override\n\t\tpublic String convert(MyBaseInterface source) {\n\t\t\treturn \"RESULT\";\n\t\t}\n\t}\n\n\n\tprivate static class MyStringArrayToResourceArrayConverter implements Converter<String[], Resource[]> {\n\n\t\t@Override\n\t\tpublic Resource[] convert(String[] source) {\n\t\t\treturn Arrays.stream(source).map(s -> s.substring(1)).map(DescriptiveResource::new).toArray(Resource[]::new);\n\t\t}\n\t}\n\n\n\tprivate static class MyStringArrayToIntegerArrayConverter implements Converter<String[], Integer[]> {\n\n\t\t@Override\n\t\tpublic Integer[] convert(String[] source) {\n\t\t\treturn Arrays.stream(source).map(s -> s.substring(1)).map(Integer::valueOf).toArray(Integer[]::new);\n\t\t}\n\t}\n\n\n\tprivate static class MyStringToIntegerArrayConverter implements Converter<String, Integer[]> {\n\n\t\t@Override\n\t\tpublic Integer[] convert(String source) {\n\t\t\tString[] srcArray = StringUtils.commaDelimitedListToStringArray(source);\n\t\t\treturn Arrays.stream(srcArray).map(s -> s.substring(1)).map(Integer::valueOf).toArray(Integer[]::new);\n\t\t}\n\t}\n\n\n\tprivate static class WithCopyConstructor {\n\n\t\tWithCopyConstructor() {}\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tWithCopyConstructor(WithCopyConstructor value) {}\n\t}\n\n\n\tprivate static class MyConditionalConverter implements Converter<String, Color>, ConditionalConverter {\n\n\t\tprivate int matchAttempts = 0;\n\n\t\t@Override\n\t\tpublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\tmatchAttempts++;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic Color convert(String source) {\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic int getMatchAttempts() {\n\t\t\treturn matchAttempts;\n\t\t}\n\t}\n\n\n\tprivate static class NonConditionalGenericConverter implements GenericConverter {\n\n\t\t@Override\n\t\tpublic Set<ConvertiblePair> getConvertibleTypes() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\tprivate static class MyConditionalGenericConverter implements GenericConverter, ConditionalConverter {\n\n\t\tprivate final List<TypeDescriptor> sourceTypes = new ArrayList<>();\n\n\t\t@Override\n\t\tpublic Set<ConvertiblePair> getConvertibleTypes() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\tsourceTypes.add(sourceType);\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic List<TypeDescriptor> getSourceTypes() {\n\t\t\treturn sourceTypes;\n\t\t}\n\t}\n\n\n\tprivate static class MyConditionalConverterFactory implements ConverterFactory<String, Color>, ConditionalConverter {\n\n\t\tprivate MyConditionalConverter converter = new MyConditionalConverter();\n\n\t\tprivate int matchAttempts = 0;\n\n\t\t@Override\n\t\tpublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\tmatchAttempts++;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic <T extends Color> Converter<String, T> getConverter(Class<T> targetType) {\n\t\t\treturn (Converter<String, T>) converter;\n\t\t}\n\n\t\tpublic int getMatchAttempts() {\n\t\t\treturn matchAttempts;\n\t\t}\n\n\t\tpublic int getNestedMatchAttempts() {\n\t\t\treturn converter.getMatchAttempts();\n\t\t}\n\t}\n\n\n\tprivate interface MyEnumBaseInterface {\n\t\tString getBaseCode();\n\t}\n\n\n\tprivate interface MyEnumInterface extends MyEnumBaseInterface {\n\t\tString getCode();\n\t}\n\n\n\tprivate enum MyEnum implements MyEnumInterface {\n\n\t\tA(\"1\"),\n\t\tB(\"2\"),\n\t\tC(\"3\");\n\n\t\tprivate final String code;\n\n\t\tMyEnum(String code) {\n\t\t\tthis.code = code;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getCode() {\n\t\t\treturn code;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getBaseCode() {\n\t\t\treturn \"base\" + code;\n\t\t}\n\t}\n\n\n\tprivate enum EnumWithSubclass {\n\n\t\tFIRST {\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\treturn \"1st\";\n\t\t\t}\n\t\t}\n\t}\n\n\n\t@SuppressWarnings(\"rawtypes\")\n\tprivate static class MyStringToRawCollectionConverter implements Converter<String, Collection> {\n\n\t\t@Override\n\t\tpublic Collection convert(String source) {\n\t\t\treturn Collections.singleton(source + \"X\");\n\t\t}\n\t}\n\n\n\tprivate static class MyStringToGenericCollectionConverter implements Converter<String, Collection<?>> {\n\n\t\t@Override\n\t\tpublic Collection<?> convert(String source) {\n\t\t\treturn Collections.singleton(source + \"X\");\n\t\t}\n\t}\n\n\n\tprivate static class MyEnumInterfaceToStringConverter<T extends MyEnumInterface> implements Converter<T, String> {\n\n\t\t@Override\n\t\tpublic String convert(T source) {\n\t\t\treturn source.getCode();\n\t\t}\n\t}\n\n\n\tprivate static class StringToMyEnumInterfaceConverterFactory implements ConverterFactory<String, MyEnumInterface> {\n\n\t\t@Override\n\t\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n\t\tpublic <T extends MyEnumInterface> Converter<String, T> getConverter(Class<T> targetType) {\n\t\t\treturn new StringToMyEnumInterfaceConverter(targetType);\n\t\t}\n\n\t\tprivate static class StringToMyEnumInterfaceConverter<T extends Enum<?> & MyEnumInterface> implements Converter<String, T> {\n\n\t\t\tprivate final Class<T> enumType;\n\n\t\t\tpublic StringToMyEnumInterfaceConverter(Class<T> enumType) {\n\t\t\t\tthis.enumType = enumType;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T convert(String source) {\n\t\t\t\tfor (T value : enumType.getEnumConstants()) {\n\t\t\t\t\tif (value.getCode().equals(source)) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate static class StringToMyEnumBaseInterfaceConverterFactory implements ConverterFactory<String, MyEnumBaseInterface> {\n\n\t\t@Override\n\t\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n\t\tpublic <T extends MyEnumBaseInterface> Converter<String, T> getConverter(Class<T> targetType) {\n\t\t\treturn new StringToMyEnumBaseInterfaceConverter(targetType);\n\t\t}\n\n\t\tprivate static class StringToMyEnumBaseInterfaceConverter<T extends Enum<?> & MyEnumBaseInterface> implements Converter<String, T> {\n\n\t\t\tprivate final Class<T> enumType;\n\n\t\t\tpublic StringToMyEnumBaseInterfaceConverter(Class<T> enumType) {\n\t\t\t\tthis.enumType = enumType;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T convert(String source) {\n\t\t\t\tfor (T value : enumType.getEnumConstants()) {\n\t\t\t\t\tif (value.getBaseCode().equals(source)) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate static class MyStringToStringCollectionConverter implements Converter<String, Collection<String>> {\n\n\t\t@Override\n\t\tpublic Collection<String> convert(String source) {\n\t\t\treturn Collections.singleton(source + \"X\");\n\t\t}\n\t}\n\n\n\tprivate static class MyStringToIntegerCollectionConverter implements Converter<String, Collection<Integer>> {\n\n\t\t@Override\n\t\tpublic Collection<Integer> convert(String source) {\n\t\t\treturn Collections.singleton(source.length());\n\t\t}\n\t}\n\n\n\t@SuppressWarnings(\"rawtypes\")\n\tprivate static class UntypedConverter implements Converter {\n\n\t\t@Override\n\t\tpublic Object convert(Object source) {\n\t\t\treturn source;\n\t\t}\n\t}\n\n\n\tprivate static class ColorConverter implements Converter<String, Color> {\n\n\t\t@Override\n\t\tpublic Color convert(String source) {\n\t\t\treturn Color.decode(source.trim());\n\t\t}\n\t}\n\n\n\tprivate static class MyConditionalColorConverter implements Converter<String, Color>, ConditionalConverter {\n\n\t\t@Override\n\t\tpublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\tExampleAnnotation ann = targetType.getAnnotation(ExampleAnnotation.class);\n\t\t\treturn (ann != null && ann.active());\n\t\t}\n\n\t\t@Override\n\t\tpublic Color convert(String source) {\n\t\t\treturn Color.decode(source.substring(0, 6));\n\t\t}\n\t}\n\n\n\tprivate static class GenericBaseClass<T> {\n\t}\n\n\t@SuppressWarnings(\"rawtypes\")\n\tprivate static class ARaw extends GenericBaseClass {\n\t}\n\n\t@SuppressWarnings(\"rawtypes\")\n\tprivate static class BRaw extends GenericBaseClass {\n\t}\n\n\n\tprivate static class StringListToAListConverter implements Converter<List<String>, List<ARaw>> {\n\n\t\t@Override\n\t\tpublic List<ARaw> convert(List<String> source) {\n\t\t\treturn List.of(new ARaw());\n\t\t}\n\t}\n\n\n\tprivate static class StringListToBListConverter implements Converter<List<String>, List<BRaw>> {\n\n\t\t@Override\n\t\tpublic List<BRaw> convert(List<String> source) {\n\t\t\treturn List.of(new BRaw());\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.convert.support.StringToMyEnumInterfaceConverter",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.convert.support.StringToMyEnumInterfaceConverter#enumType",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.convert.support.StringToMyEnumInterfaceConverter#enumType",
    "headType": "field",
    "relation": "haveType",
    "tail": "Class<T>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.convert.support.StringToMyEnumInterfaceConverter#convert(String)",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic T convert(String source) {\r\n    for (T value : enumType.getEnumConstants()) {\r\n        if (value.getCode().equals(source)) {\r\n            return value;\r\n        }\r\n    }\r\n    return null;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.convert.support.StringToMyEnumInterfaceConverter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.convert.support.StringToMyEnumInterfaceConverter#convert(String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.convert.support.StringToMyEnumInterfaceConverter#convert(String)",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  }
]