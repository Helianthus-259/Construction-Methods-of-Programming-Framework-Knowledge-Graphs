[
  {
    "head": "org.springframework.util.MethodFilter#and(MethodFilter)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Create a composite filter based on this filter <em>and</em> the provided filter.\r\n * <p>If this filter does not match, the next filter will not be applied.\r\n * @param next the next {@code MethodFilter}\r\n * @return a composite {@code MethodFilter}\r\n * @throws IllegalArgumentException if the MethodFilter argument is {@code null}\r\n * @since 5.3.2\r\n */\r\ndefault MethodFilter and(MethodFilter next) {\r\n    Assert.notNull(next, \"Next MethodFilter must not be null\");\r\n    return method -> matches(method) && next.matches(method);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.MethodFilter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.MethodFilter#and(MethodFilter)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.FieldCallback",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.FieldCallback",
    "headType": "class",
    "relation": "use",
    "tail": "@FunctionalInterface",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.FieldCallback",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.UndeclaredThrowableException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jspecify.annotations.Nullable;\n\n/**\n * Simple utility class for working with the reflection API and handling\n * reflection exceptions.\n *\n * <p>Only intended for internal use.\n *\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Rod Johnson\n * @author Costin Leau\n * @author Sam Brannen\n * @author Chris Beams\n * @since 1.2.2\n */\npublic abstract class ReflectionUtils {\n\n\t/**\n\t * Pre-built {@link MethodFilter} that matches all non-bridge non-synthetic methods\n\t * which are not declared on {@code java.lang.Object}.\n\t * @since 3.0.5\n\t */\n\tpublic static final MethodFilter USER_DECLARED_METHODS =\n\t\t\t(method -> !method.isBridge() && !method.isSynthetic() && (method.getDeclaringClass() != Object.class));\n\n\t/**\n\t * Pre-built FieldFilter that matches all non-static, non-final fields.\n\t */\n\tpublic static final FieldFilter COPYABLE_FIELDS =\n\t\t\t(field -> !(Modifier.isStatic(field.getModifiers()) || Modifier.isFinal(field.getModifiers())));\n\n\n\t/**\n\t * Naming prefix for CGLIB-renamed methods.\n\t * @see #isCglibRenamedMethod\n\t */\n\tprivate static final String CGLIB_RENAMED_METHOD_PREFIX = \"CGLIB$\";\n\n\tprivate static final Class<?>[] EMPTY_CLASS_ARRAY = new Class<?>[0];\n\n\tprivate static final Method[] EMPTY_METHOD_ARRAY = new Method[0];\n\n\tprivate static final Field[] EMPTY_FIELD_ARRAY = new Field[0];\n\n\tprivate static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n\n\n\t/**\n\t * Cache for {@link Class#getDeclaredMethods()} plus equivalent default methods\n\t * from Java 8 based interfaces, allowing for fast iteration.\n\t */\n\tprivate static final Map<Class<?>, Method[]> declaredMethodsCache = new ConcurrentReferenceHashMap<>(256);\n\n\t/**\n\t * Cache for {@link Class#getDeclaredFields()}, allowing for fast iteration.\n\t */\n\tprivate static final Map<Class<?>, Field[]> declaredFieldsCache = new ConcurrentReferenceHashMap<>(256);\n\n\n\t// Exception handling\n\n\t/**\n\t * Handle the given reflection exception.\n\t * <p>Should only be called if no checked exception is expected to be thrown\n\t * by a target method, or if an error occurs while accessing a method or field.\n\t * <p>Throws the underlying RuntimeException or Error in case of an\n\t * InvocationTargetException with such a root cause. Throws an\n\t * IllegalStateException with an appropriate message or\n\t * UndeclaredThrowableException otherwise.\n\t * @param ex the reflection exception to handle\n\t */\n\tpublic static void handleReflectionException(Exception ex) {\n\t\tif (ex instanceof NoSuchMethodException) {\n\t\t\tthrow new IllegalStateException(\"Method not found: \" + ex.getMessage());\n\t\t}\n\t\tif (ex instanceof IllegalAccessException) {\n\t\t\tthrow new IllegalStateException(\"Could not access method or field: \" + ex.getMessage());\n\t\t}\n\t\tif (ex instanceof InvocationTargetException invocationTargetException) {\n\t\t\thandleInvocationTargetException(invocationTargetException);\n\t\t}\n\t\tif (ex instanceof RuntimeException runtimeException) {\n\t\t\tthrow runtimeException;\n\t\t}\n\t\tthrow new UndeclaredThrowableException(ex);\n\t}\n\n\t/**\n\t * Handle the given invocation target exception. Should only be called if no\n\t * checked exception is expected to be thrown by the target method.\n\t * <p>Throws the underlying RuntimeException or Error in case of such a root\n\t * cause. Throws an UndeclaredThrowableException otherwise.\n\t * @param ex the invocation target exception to handle\n\t */\n\tpublic static void handleInvocationTargetException(InvocationTargetException ex) {\n\t\trethrowRuntimeException(ex.getTargetException());\n\t}\n\n\t/**\n\t * Rethrow the given {@link Throwable exception}, which is presumably the\n\t * <em>target exception</em> of an {@link InvocationTargetException}.\n\t * Should only be called if no checked exception is expected to be thrown\n\t * by the target method.\n\t * <p>Rethrows the underlying exception cast to a {@link RuntimeException} or\n\t * {@link Error} if appropriate; otherwise, throws an\n\t * {@link UndeclaredThrowableException}.\n\t * @param ex the exception to rethrow\n\t * @throws RuntimeException the rethrown exception\n\t */\n\tpublic static void rethrowRuntimeException(@Nullable Throwable ex) {\n\t\tif (ex instanceof RuntimeException runtimeException) {\n\t\t\tthrow runtimeException;\n\t\t}\n\t\tif (ex instanceof Error error) {\n\t\t\tthrow error;\n\t\t}\n\t\tthrow new UndeclaredThrowableException(ex);\n\t}\n\n\t/**\n\t * Rethrow the given {@link Throwable exception}, which is presumably the\n\t * <em>target exception</em> of an {@link InvocationTargetException}.\n\t * Should only be called if no checked exception is expected to be thrown\n\t * by the target method.\n\t * <p>Rethrows the underlying exception cast to an {@link Exception} or\n\t * {@link Error} if appropriate; otherwise, throws an\n\t * {@link UndeclaredThrowableException}.\n\t * @param throwable the exception to rethrow\n\t * @throws Exception the rethrown exception (in case of a checked exception)\n\t */\n\tpublic static void rethrowException(@Nullable Throwable throwable) throws Exception {\n\t\tif (throwable instanceof Exception exception) {\n\t\t\tthrow exception;\n\t\t}\n\t\tif (throwable instanceof Error error) {\n\t\t\tthrow error;\n\t\t}\n\t\tthrow new UndeclaredThrowableException(throwable);\n\t}\n\n\n\t// Constructor handling\n\n\t/**\n\t * Obtain an accessible constructor for the given class and parameters.\n\t * @param clazz the clazz to check\n\t * @param parameterTypes the parameter types of the desired constructor\n\t * @return the constructor reference\n\t * @throws NoSuchMethodException if no such constructor exists\n\t * @since 5.0\n\t */\n\tpublic static <T> Constructor<T> accessibleConstructor(Class<T> clazz, Class<?>... parameterTypes)\n\t\t\tthrows NoSuchMethodException {\n\n\t\tConstructor<T> ctor = clazz.getDeclaredConstructor(parameterTypes);\n\t\tmakeAccessible(ctor);\n\t\treturn ctor;\n\t}\n\n\t/**\n\t * Make the given constructor accessible, explicitly setting it accessible\n\t * if necessary. The {@code setAccessible(true)} method is only called\n\t * when actually necessary, to avoid unnecessary conflicts.\n\t * @param ctor the constructor to make accessible\n\t * @see java.lang.reflect.Constructor#setAccessible\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tpublic static void makeAccessible(Constructor<?> ctor) {\n\t\tif ((!Modifier.isPublic(ctor.getModifiers()) ||\n\t\t\t\t!Modifier.isPublic(ctor.getDeclaringClass().getModifiers())) && !ctor.isAccessible()) {\n\t\t\tctor.setAccessible(true);\n\t\t}\n\t}\n\n\n\t// Method handling\n\n\t/**\n\t * Attempt to find a {@link Method} on the supplied class with the supplied name\n\t * and no parameters. Searches all superclasses up to {@code Object}.\n\t * <p>Returns {@code null} if no {@link Method} can be found.\n\t * @param clazz the class to introspect\n\t * @param name the name of the method\n\t * @return the Method object, or {@code null} if none found\n\t */\n\tpublic static @Nullable Method findMethod(Class<?> clazz, String name) {\n\t\treturn findMethod(clazz, name, EMPTY_CLASS_ARRAY);\n\t}\n\n\t/**\n\t * Attempt to find a {@link Method} on the supplied class with the supplied name\n\t * and parameter types. Searches all superclasses up to {@code Object}.\n\t * <p>Returns {@code null} if no {@link Method} can be found.\n\t * @param clazz the class to introspect\n\t * @param name the name of the method\n\t * @param paramTypes the parameter types of the method\n\t * (may be {@code null} to indicate any signature)\n\t * @return the Method object, or {@code null} if none found\n\t */\n\tpublic static @Nullable Method findMethod(Class<?> clazz, String name, Class<?> @Nullable ... paramTypes) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(name, \"Method name must not be null\");\n\t\tClass<?> searchType = clazz;\n\t\twhile (searchType != null) {\n\t\t\tMethod[] methods = (searchType.isInterface() ? searchType.getMethods() :\n\t\t\t\t\tgetDeclaredMethods(searchType, false));\n\t\t\tfor (Method method : methods) {\n\t\t\t\tif (name.equals(method.getName()) && (paramTypes == null || hasSameParams(method, paramTypes))) {\n\t\t\t\t\treturn method;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsearchType = searchType.getSuperclass();\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate static boolean hasSameParams(Method method, Class<?>[] paramTypes) {\n\t\treturn (paramTypes.length == method.getParameterCount() &&\n\t\t\t\tArrays.equals(paramTypes, method.getParameterTypes()));\n\t}\n\n\t/**\n\t * Invoke the specified {@link Method} against the supplied target object with no arguments.\n\t * The target object can be {@code null} when invoking a static {@link Method}.\n\t * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException}.\n\t * @param method the method to invoke\n\t * @param target the target object to invoke the method on\n\t * @return the invocation result, if any\n\t * @see #invokeMethod(java.lang.reflect.Method, Object, Object[])\n\t */\n\tpublic static @Nullable Object invokeMethod(Method method, @Nullable Object target) {\n\t\treturn invokeMethod(method, target, EMPTY_OBJECT_ARRAY);\n\t}\n\n\t/**\n\t * Invoke the specified {@link Method} against the supplied target object with the\n\t * supplied arguments. The target object can be {@code null} when invoking a\n\t * static {@link Method}.\n\t * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException}.\n\t * @param method the method to invoke\n\t * @param target the target object to invoke the method on\n\t * @param args the invocation arguments (may be {@code null})\n\t * @return the invocation result, if any\n\t */\n\tpublic static @Nullable Object invokeMethod(Method method, @Nullable Object target, @Nullable Object... args) {\n\t\ttry {\n\t\t\treturn method.invoke(target, args);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\thandleReflectionException(ex);\n\t\t}\n\t\tthrow new IllegalStateException(\"Should never get here\");\n\t}\n\n\t/**\n\t * Determine whether the given method explicitly declares the given\n\t * exception or one of its superclasses, which means that an exception\n\t * of that type can be propagated as-is within a reflective invocation.\n\t * @param method the declaring method\n\t * @param exceptionType the exception to throw\n\t * @return {@code true} if the exception can be thrown as-is;\n\t * {@code false} if it needs to be wrapped\n\t */\n\tpublic static boolean declaresException(Method method, Class<?> exceptionType) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\tClass<?>[] declaredExceptions = method.getExceptionTypes();\n\t\tfor (Class<?> declaredException : declaredExceptions) {\n\t\t\tif (declaredException.isAssignableFrom(exceptionType)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Perform the given callback operation on all matching methods of the given\n\t * class, as locally declared or equivalent thereof (such as default methods\n\t * on Java 8 based interfaces that the given class implements).\n\t * @param clazz the class to introspect\n\t * @param mc the callback to invoke for each method\n\t * @throws IllegalStateException if introspection fails\n\t * @since 4.2\n\t * @see #doWithMethods\n\t */\n\tpublic static void doWithLocalMethods(Class<?> clazz, MethodCallback mc) {\n\t\tMethod[] methods = getDeclaredMethods(clazz, false);\n\t\tfor (Method method : methods) {\n\t\t\ttry {\n\t\t\t\tmc.doWith(method);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Not allowed to access method '\" + method.getName() + \"': \" + ex);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Perform the given callback operation on all matching methods of the given\n\t * class and superclasses.\n\t * <p>The same named method occurring on subclass and superclass will appear\n\t * twice, unless excluded by a {@link MethodFilter}.\n\t * @param clazz the class to introspect\n\t * @param mc the callback to invoke for each method\n\t * @throws IllegalStateException if introspection fails\n\t * @see #doWithMethods(Class, MethodCallback, MethodFilter)\n\t */\n\tpublic static void doWithMethods(Class<?> clazz, MethodCallback mc) {\n\t\tdoWithMethods(clazz, mc, null);\n\t}\n\n\t/**\n\t * Perform the given callback operation on all matching methods of the given\n\t * class and superclasses (or given interface and super-interfaces).\n\t * <p>The same named method occurring on subclass and superclass will appear\n\t * twice, unless excluded by the specified {@link MethodFilter}.\n\t * @param clazz the class to introspect\n\t * @param mc the callback to invoke for each method\n\t * @param mf the filter that determines the methods to apply the callback to\n\t * @throws IllegalStateException if introspection fails\n\t */\n\tpublic static void doWithMethods(Class<?> clazz, MethodCallback mc, @Nullable MethodFilter mf) {\n\t\tif (mf == USER_DECLARED_METHODS && clazz == Object.class) {\n\t\t\t// nothing to introspect\n\t\t\treturn;\n\t\t}\n\t\tMethod[] methods = getDeclaredMethods(clazz, false);\n\t\tfor (Method method : methods) {\n\t\t\tif (mf != null && !mf.matches(method)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tmc.doWith(method);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Not allowed to access method '\" + method.getName() + \"': \" + ex);\n\t\t\t}\n\t\t}\n\t\t// Keep backing up the inheritance hierarchy.\n\t\tif (clazz.getSuperclass() != null && (mf != USER_DECLARED_METHODS || clazz.getSuperclass() != Object.class)) {\n\t\t\tdoWithMethods(clazz.getSuperclass(), mc, mf);\n\t\t}\n\t\telse if (clazz.isInterface()) {\n\t\t\tfor (Class<?> superIfc : clazz.getInterfaces()) {\n\t\t\t\tdoWithMethods(superIfc, mc, mf);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get all declared methods on the leaf class and all superclasses.\n\t * Leaf class methods are included first.\n\t * @param leafClass the class to introspect\n\t * @throws IllegalStateException if introspection fails\n\t */\n\tpublic static Method[] getAllDeclaredMethods(Class<?> leafClass) {\n\t\tfinal List<Method> methods = new ArrayList<>(20);\n\t\tdoWithMethods(leafClass, methods::add);\n\t\treturn methods.toArray(EMPTY_METHOD_ARRAY);\n\t}\n\n\t/**\n\t * Get the unique set of declared methods on the leaf class and all superclasses.\n\t * Leaf class methods are included first and while traversing the superclass hierarchy\n\t * any methods found with signatures matching a method already included are filtered out.\n\t * @param leafClass the class to introspect\n\t * @throws IllegalStateException if introspection fails\n\t */\n\tpublic static Method[] getUniqueDeclaredMethods(Class<?> leafClass) {\n\t\treturn getUniqueDeclaredMethods(leafClass, null);\n\t}\n\n\t/**\n\t * Get the unique set of declared methods on the leaf class and all superclasses.\n\t * Leaf class methods are included first and while traversing the superclass hierarchy\n\t * any methods found with signatures matching a method already included are filtered out.\n\t * @param leafClass the class to introspect\n\t * @param mf the filter that determines the methods to take into account\n\t * @throws IllegalStateException if introspection fails\n\t * @since 5.2\n\t */\n\tpublic static Method[] getUniqueDeclaredMethods(Class<?> leafClass, @Nullable MethodFilter mf) {\n\t\tfinal List<Method> methods = new ArrayList<>(20);\n\t\tdoWithMethods(leafClass, method -> {\n\t\t\tboolean knownSignature = false;\n\t\t\tMethod methodBeingOverriddenWithCovariantReturnType = null;\n\t\t\tfor (Method existingMethod : methods) {\n\t\t\t\tif (method.getName().equals(existingMethod.getName()) &&\n\t\t\t\t\t\tmethod.getParameterCount() == existingMethod.getParameterCount() &&\n\t\t\t\t\t\tArrays.equals(method.getParameterTypes(), existingMethod.getParameterTypes())) {\n\t\t\t\t\t// Is this a covariant return type situation?\n\t\t\t\t\tif (existingMethod.getReturnType() != method.getReturnType() &&\n\t\t\t\t\t\t\texistingMethod.getReturnType().isAssignableFrom(method.getReturnType())) {\n\t\t\t\t\t\tmethodBeingOverriddenWithCovariantReturnType = existingMethod;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tknownSignature = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (methodBeingOverriddenWithCovariantReturnType != null) {\n\t\t\t\tmethods.remove(methodBeingOverriddenWithCovariantReturnType);\n\t\t\t}\n\t\t\tif (!knownSignature && !isCglibRenamedMethod(method)) {\n\t\t\t\tmethods.add(method);\n\t\t\t}\n\t\t}, mf);\n\t\treturn methods.toArray(EMPTY_METHOD_ARRAY);\n\t}\n\n\t/**\n\t * Variant of {@link Class#getDeclaredMethods()} that uses a local cache in\n\t * order to avoid new Method instances. In addition, it also includes Java 8\n\t * default methods from locally implemented interfaces, since those are\n\t * effectively to be treated just like declared methods.\n\t * @param clazz the class to introspect\n\t * @return the cached array of methods\n\t * @throws IllegalStateException if introspection fails\n\t * @since 5.2\n\t * @see Class#getDeclaredMethods()\n\t */\n\tpublic static Method[] getDeclaredMethods(Class<?> clazz) {\n\t\treturn getDeclaredMethods(clazz, true);\n\t}\n\n\tprivate static Method[] getDeclaredMethods(Class<?> clazz, boolean defensive) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tMethod[] result = declaredMethodsCache.get(clazz);\n\t\tif (result == null) {\n\t\t\ttry {\n\t\t\t\tMethod[] declaredMethods = clazz.getDeclaredMethods();\n\t\t\t\tList<Method> defaultMethods = findDefaultMethodsOnInterfaces(clazz);\n\t\t\t\tif (defaultMethods != null) {\n\t\t\t\t\tresult = new Method[declaredMethods.length + defaultMethods.size()];\n\t\t\t\t\tSystem.arraycopy(declaredMethods, 0, result, 0, declaredMethods.length);\n\t\t\t\t\tint index = declaredMethods.length;\n\t\t\t\t\tfor (Method defaultMethod : defaultMethods) {\n\t\t\t\t\t\tresult[index] = defaultMethod;\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresult = declaredMethods;\n\t\t\t\t}\n\t\t\t\tdeclaredMethodsCache.put(clazz, (result.length == 0 ? EMPTY_METHOD_ARRAY : result));\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalStateException(\"Failed to introspect Class [\" + clazz.getName() +\n\t\t\t\t\t\t\"] from ClassLoader [\" + clazz.getClassLoader() + \"]\", ex);\n\t\t\t}\n\t\t}\n\t\treturn (result.length == 0 || !defensive) ? result : result.clone();\n\t}\n\n\tprivate static @Nullable List<Method> findDefaultMethodsOnInterfaces(Class<?> clazz) {\n\t\tList<Method> result = null;\n\t\tfor (Class<?> ifc : clazz.getInterfaces()) {\n\t\t\tfor (Method method : ifc.getMethods()) {\n\t\t\t\tif (method.isDefault()) {\n\t\t\t\t\tif (result == null) {\n\t\t\t\t\t\tresult = new ArrayList<>();\n\t\t\t\t\t}\n\t\t\t\t\tresult.add(method);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Determine whether the given method is an \"equals\" method.\n\t * @see java.lang.Object#equals(Object)\n\t */\n\tpublic static boolean isEqualsMethod(@Nullable Method method) {\n\t\treturn (method != null && method.getParameterCount() == 1 && method.getName().equals(\"equals\") &&\n\t\t\t\tmethod.getParameterTypes()[0] == Object.class);\n\t}\n\n\t/**\n\t * Determine whether the given method is a \"hashCode\" method.\n\t * @see java.lang.Object#hashCode()\n\t */\n\tpublic static boolean isHashCodeMethod(@Nullable Method method) {\n\t\treturn (method != null && method.getParameterCount() == 0 && method.getName().equals(\"hashCode\"));\n\t}\n\n\t/**\n\t * Determine whether the given method is a \"toString\" method.\n\t * @see java.lang.Object#toString()\n\t */\n\tpublic static boolean isToStringMethod(@Nullable Method method) {\n\t\treturn (method != null && method.getParameterCount() == 0 && method.getName().equals(\"toString\"));\n\t}\n\n\t/**\n\t * Determine whether the given method is originally declared by {@link java.lang.Object}.\n\t */\n\tpublic static boolean isObjectMethod(@Nullable Method method) {\n\t\treturn (method != null && (method.getDeclaringClass() == Object.class ||\n\t\t\t\tisEqualsMethod(method) || isHashCodeMethod(method) || isToStringMethod(method)));\n\t}\n\n\t/**\n\t * Determine whether the given method is a CGLIB 'renamed' method,\n\t * following the pattern \"CGLIB$methodName$0\".\n\t * @param renamedMethod the method to check\n\t */\n\tpublic static boolean isCglibRenamedMethod(Method renamedMethod) {\n\t\tString name = renamedMethod.getName();\n\t\tif (name.startsWith(CGLIB_RENAMED_METHOD_PREFIX)) {\n\t\t\tint i = name.length() - 1;\n\t\t\twhile (i >= 0 && Character.isDigit(name.charAt(i))) {\n\t\t\t\ti--;\n\t\t\t}\n\t\t\treturn (i > CGLIB_RENAMED_METHOD_PREFIX.length() && (i < name.length() - 1) && name.charAt(i) == '$');\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Make the given method accessible, explicitly setting it accessible if\n\t * necessary. The {@code setAccessible(true)} method is only called\n\t * when actually necessary, to avoid unnecessary conflicts.\n\t * @param method the method to make accessible\n\t * @see java.lang.reflect.Method#setAccessible\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tpublic static void makeAccessible(Method method) {\n\t\tif ((!Modifier.isPublic(method.getModifiers()) ||\n\t\t\t\t!Modifier.isPublic(method.getDeclaringClass().getModifiers())) && !method.isAccessible()) {\n\t\t\tmethod.setAccessible(true);\n\t\t}\n\t}\n\n\n\t// Field handling\n\n\t/**\n\t * Attempt to find a {@link Field field} on the supplied {@link Class} with the\n\t * supplied {@code name}. Searches all superclasses up to {@link Object}.\n\t * @param clazz the class to introspect\n\t * @param name the name of the field\n\t * @return the corresponding Field object, or {@code null} if not found\n\t */\n\tpublic static @Nullable Field findField(Class<?> clazz, String name) {\n\t\treturn findField(clazz, name, null);\n\t}\n\n\t/**\n\t * Attempt to find a {@link Field field} on the supplied {@link Class} with the\n\t * supplied {@code name} and/or {@link Class type}. Searches all superclasses\n\t * up to {@link Object}.\n\t * @param clazz the class to introspect\n\t * @param name the name of the field (may be {@code null} if type is specified)\n\t * @param type the type of the field (may be {@code null} if name is specified)\n\t * @return the corresponding Field object, or {@code null} if not found\n\t */\n\tpublic static @Nullable Field findField(Class<?> clazz, @Nullable String name, @Nullable Class<?> type) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.isTrue(name != null || type != null, \"Either name or type of the field must be specified\");\n\t\tClass<?> searchType = clazz;\n\t\twhile (Object.class != searchType && searchType != null) {\n\t\t\tField[] fields = getDeclaredFields(searchType);\n\t\t\tfor (Field field : fields) {\n\t\t\t\tif ((name == null || name.equals(field.getName())) &&\n\t\t\t\t\t\t(type == null || type.equals(field.getType()))) {\n\t\t\t\t\treturn field;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsearchType = searchType.getSuperclass();\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Attempt to find a {@link Field field} on the supplied {@link Class} with the\n\t * supplied {@code name}. Searches all superclasses up to {@link Object}.\n\t * @param clazz the class to introspect\n\t * @param name the name of the field (with upper/lower case to be ignored)\n\t * @return the corresponding Field object, or {@code null} if not found\n\t * @since 6.1\n\t */\n\tpublic static @Nullable Field findFieldIgnoreCase(Class<?> clazz, String name) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tClass<?> searchType = clazz;\n\t\twhile (Object.class != searchType && searchType != null) {\n\t\t\tField[] fields = getDeclaredFields(searchType);\n\t\t\tfor (Field field : fields) {\n\t\t\t\tif (name.equalsIgnoreCase(field.getName())) {\n\t\t\t\t\treturn field;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsearchType = searchType.getSuperclass();\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Set the field represented by the supplied {@linkplain Field field object} on\n\t * the specified {@linkplain Object target object} to the specified {@code value}.\n\t * <p>In accordance with {@link Field#set(Object, Object)} semantics, the new value\n\t * is automatically unwrapped if the underlying field has a primitive type.\n\t * <p>This method does not support setting {@code static final} fields.\n\t * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException(Exception)}.\n\t * @param field the field to set\n\t * @param target the target object on which to set the field\n\t * (or {@code null} for a static field)\n\t * @param value the value to set (may be {@code null})\n\t */\n\tpublic static void setField(Field field, @Nullable Object target, @Nullable Object value) {\n\t\ttry {\n\t\t\tfield.set(target, value);\n\t\t}\n\t\tcatch (IllegalAccessException ex) {\n\t\t\thandleReflectionException(ex);\n\t\t}\n\t}\n\n\t/**\n\t * Get the field represented by the supplied {@link Field field object} on the\n\t * specified {@link Object target object}. In accordance with {@link Field#get(Object)}\n\t * semantics, the returned value is automatically wrapped if the underlying field\n\t * has a primitive type.\n\t * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException(Exception)}.\n\t * @param field the field to get\n\t * @param target the target object from which to get the field\n\t * (or {@code null} for a static field)\n\t * @return the field's current value\n\t */\n\tpublic static @Nullable Object getField(Field field, @Nullable Object target) {\n\t\ttry {\n\t\t\treturn field.get(target);\n\t\t}\n\t\tcatch (IllegalAccessException ex) {\n\t\t\thandleReflectionException(ex);\n\t\t}\n\t\tthrow new IllegalStateException(\"Should never get here\");\n\t}\n\n\t/**\n\t * Invoke the given callback on all locally declared fields in the given class.\n\t * @param clazz the target class to analyze\n\t * @param fc the callback to invoke for each field\n\t * @throws IllegalStateException if introspection fails\n\t * @since 4.2\n\t * @see #doWithFields\n\t */\n\tpublic static void doWithLocalFields(Class<?> clazz, FieldCallback fc) {\n\t\tfor (Field field : getDeclaredFields(clazz)) {\n\t\t\ttry {\n\t\t\t\tfc.doWith(field);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Not allowed to access field '\" + field.getName() + \"': \" + ex);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Invoke the given callback on all fields in the target class, going up the\n\t * class hierarchy to get all declared fields.\n\t * @param clazz the target class to analyze\n\t * @param fc the callback to invoke for each field\n\t * @throws IllegalStateException if introspection fails\n\t */\n\tpublic static void doWithFields(Class<?> clazz, FieldCallback fc) {\n\t\tdoWithFields(clazz, fc, null);\n\t}\n\n\t/**\n\t * Invoke the given callback on all fields in the target class, going up the\n\t * class hierarchy to get all declared fields.\n\t * @param clazz the target class to analyze\n\t * @param fc the callback to invoke for each field\n\t * @param ff the filter that determines the fields to apply the callback to\n\t * @throws IllegalStateException if introspection fails\n\t */\n\tpublic static void doWithFields(Class<?> clazz, FieldCallback fc, @Nullable FieldFilter ff) {\n\t\t// Keep backing up the inheritance hierarchy.\n\t\tClass<?> targetClass = clazz;\n\t\tdo {\n\t\t\tfor (Field field : getDeclaredFields(targetClass)) {\n\t\t\t\tif (ff != null && !ff.matches(field)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tfc.doWith(field);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\t\tthrow new IllegalStateException(\"Not allowed to access field '\" + field.getName() + \"': \" + ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttargetClass = targetClass.getSuperclass();\n\t\t}\n\t\twhile (targetClass != null && targetClass != Object.class);\n\t}\n\n\t/**\n\t * This variant retrieves {@link Class#getDeclaredFields()} from a local cache\n\t * in order to avoid defensive array copying.\n\t * @param clazz the class to introspect\n\t * @return the cached array of fields\n\t * @throws IllegalStateException if introspection fails\n\t * @see Class#getDeclaredFields()\n\t */\n\tprivate static Field[] getDeclaredFields(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tField[] result = declaredFieldsCache.get(clazz);\n\t\tif (result == null) {\n\t\t\ttry {\n\t\t\t\tresult = clazz.getDeclaredFields();\n\t\t\t\tdeclaredFieldsCache.put(clazz, (result.length == 0 ? EMPTY_FIELD_ARRAY : result));\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalStateException(\"Failed to introspect Class [\" + clazz.getName() +\n\t\t\t\t\t\t\"] from ClassLoader [\" + clazz.getClassLoader() + \"]\", ex);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Given the source object and the destination, which must be the same class\n\t * or a subclass, copy all fields, including inherited fields. Designed to\n\t * work on objects with public no-arg constructors.\n\t * @throws IllegalStateException if introspection fails\n\t */\n\tpublic static void shallowCopyFieldState(final Object src, final Object dest) {\n\t\tAssert.notNull(src, \"Source for field copy cannot be null\");\n\t\tAssert.notNull(dest, \"Destination for field copy cannot be null\");\n\t\tif (!src.getClass().isAssignableFrom(dest.getClass())) {\n\t\t\tthrow new IllegalArgumentException(\"Destination class [\" + dest.getClass().getName() +\n\t\t\t\t\t\"] must be same or subclass as source class [\" + src.getClass().getName() + \"]\");\n\t\t}\n\t\tdoWithFields(src.getClass(), field -> {\n\t\t\tmakeAccessible(field);\n\t\t\tObject srcValue = field.get(src);\n\t\t\tfield.set(dest, srcValue);\n\t\t}, COPYABLE_FIELDS);\n\t}\n\n\t/**\n\t * Determine whether the given field is a \"public static final\" constant.\n\t * @param field the field to check\n\t */\n\tpublic static boolean isPublicStaticFinal(Field field) {\n\t\tint modifiers = field.getModifiers();\n\t\treturn (Modifier.isPublic(modifiers) && Modifier.isStatic(modifiers) && Modifier.isFinal(modifiers));\n\t}\n\n\t/**\n\t * Make the given field accessible, explicitly setting it accessible if\n\t * necessary. The {@code setAccessible(true)} method is only called\n\t * when actually necessary, to avoid unnecessary conflicts.\n\t * @param field the field to make accessible\n\t * @see java.lang.reflect.Field#setAccessible\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tpublic static void makeAccessible(Field field) {\n\t\tif ((!Modifier.isPublic(field.getModifiers()) ||\n\t\t\t\t!Modifier.isPublic(field.getDeclaringClass().getModifiers()) ||\n\t\t\t\tModifier.isFinal(field.getModifiers())) && !field.isAccessible()) {\n\t\t\tfield.setAccessible(true);\n\t\t}\n\t}\n\n\n\t// Cache handling\n\n\t/**\n\t * Clear the internal method/field cache.\n\t * @since 4.2.4\n\t */\n\tpublic static void clearCache() {\n\t\tdeclaredMethodsCache.clear();\n\t\tdeclaredFieldsCache.clear();\n\t}\n\n\n\t/**\n\t * Action to take on each method.\n\t */\n\t@FunctionalInterface\n\tpublic interface MethodCallback {\n\n\t\t/**\n\t\t * Perform an operation using the given method.\n\t\t * @param method the method to operate on\n\t\t */\n\t\tvoid doWith(Method method) throws IllegalArgumentException, IllegalAccessException;\n\t}\n\n\n\t/**\n\t * Callback optionally used to filter methods to be operated on by a method callback.\n\t */\n\t@FunctionalInterface\n\tpublic interface MethodFilter {\n\n\t\t/**\n\t\t * Determine whether the given method matches.\n\t\t * @param method the method to check\n\t\t */\n\t\tboolean matches(Method method);\n\n\t\t/**\n\t\t * Create a composite filter based on this filter <em>and</em> the provided filter.\n\t\t * <p>If this filter does not match, the next filter will not be applied.\n\t\t * @param next the next {@code MethodFilter}\n\t\t * @return a composite {@code MethodFilter}\n\t\t * @throws IllegalArgumentException if the MethodFilter argument is {@code null}\n\t\t * @since 5.3.2\n\t\t */\n\t\tdefault MethodFilter and(MethodFilter next) {\n\t\t\tAssert.notNull(next, \"Next MethodFilter must not be null\");\n\t\t\treturn method -> matches(method) && next.matches(method);\n\t\t}\n\t}\n\n\n\t/**\n\t * Callback interface invoked on each field in the hierarchy.\n\t */\n\t@FunctionalInterface\n\tpublic interface FieldCallback {\n\n\t\t/**\n\t\t * Perform an operation using the given field.\n\t\t * @param field the field to operate on\n\t\t */\n\t\tvoid doWith(Field field) throws IllegalArgumentException, IllegalAccessException;\n\t}\n\n\n\t/**\n\t * Callback optionally used to filter fields to be operated on by a field callback.\n\t */\n\t@FunctionalInterface\n\tpublic interface FieldFilter {\n\n\t\t/**\n\t\t * Determine whether the given field matches.\n\t\t * @param field the field to check\n\t\t */\n\t\tboolean matches(Field field);\n\n\t\t/**\n\t\t * Create a composite filter based on this filter <em>and</em> the provided filter.\n\t\t * <p>If this filter does not match, the next filter will not be applied.\n\t\t * @param next the next {@code FieldFilter}\n\t\t * @return a composite {@code FieldFilter}\n\t\t * @throws IllegalArgumentException if the FieldFilter argument is {@code null}\n\t\t * @since 5.3.2\n\t\t */\n\t\tdefault FieldFilter and(FieldFilter next) {\n\t\t\tAssert.notNull(next, \"Next FieldFilter must not be null\");\n\t\t\treturn field -> matches(field) && next.matches(field);\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.FieldCallback#doWith(Field)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Perform an operation using the given field.\r\n * @param field the field to operate on\r\n */\r\nvoid doWith(Field field) throws IllegalArgumentException, IllegalAccessException;",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.FieldCallback",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.FieldCallback#doWith(Field)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.FieldFilter",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.FieldFilter",
    "headType": "class",
    "relation": "use",
    "tail": "@FunctionalInterface",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.FieldFilter",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.UndeclaredThrowableException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jspecify.annotations.Nullable;\n\n/**\n * Simple utility class for working with the reflection API and handling\n * reflection exceptions.\n *\n * <p>Only intended for internal use.\n *\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Rod Johnson\n * @author Costin Leau\n * @author Sam Brannen\n * @author Chris Beams\n * @since 1.2.2\n */\npublic abstract class ReflectionUtils {\n\n\t/**\n\t * Pre-built {@link MethodFilter} that matches all non-bridge non-synthetic methods\n\t * which are not declared on {@code java.lang.Object}.\n\t * @since 3.0.5\n\t */\n\tpublic static final MethodFilter USER_DECLARED_METHODS =\n\t\t\t(method -> !method.isBridge() && !method.isSynthetic() && (method.getDeclaringClass() != Object.class));\n\n\t/**\n\t * Pre-built FieldFilter that matches all non-static, non-final fields.\n\t */\n\tpublic static final FieldFilter COPYABLE_FIELDS =\n\t\t\t(field -> !(Modifier.isStatic(field.getModifiers()) || Modifier.isFinal(field.getModifiers())));\n\n\n\t/**\n\t * Naming prefix for CGLIB-renamed methods.\n\t * @see #isCglibRenamedMethod\n\t */\n\tprivate static final String CGLIB_RENAMED_METHOD_PREFIX = \"CGLIB$\";\n\n\tprivate static final Class<?>[] EMPTY_CLASS_ARRAY = new Class<?>[0];\n\n\tprivate static final Method[] EMPTY_METHOD_ARRAY = new Method[0];\n\n\tprivate static final Field[] EMPTY_FIELD_ARRAY = new Field[0];\n\n\tprivate static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n\n\n\t/**\n\t * Cache for {@link Class#getDeclaredMethods()} plus equivalent default methods\n\t * from Java 8 based interfaces, allowing for fast iteration.\n\t */\n\tprivate static final Map<Class<?>, Method[]> declaredMethodsCache = new ConcurrentReferenceHashMap<>(256);\n\n\t/**\n\t * Cache for {@link Class#getDeclaredFields()}, allowing for fast iteration.\n\t */\n\tprivate static final Map<Class<?>, Field[]> declaredFieldsCache = new ConcurrentReferenceHashMap<>(256);\n\n\n\t// Exception handling\n\n\t/**\n\t * Handle the given reflection exception.\n\t * <p>Should only be called if no checked exception is expected to be thrown\n\t * by a target method, or if an error occurs while accessing a method or field.\n\t * <p>Throws the underlying RuntimeException or Error in case of an\n\t * InvocationTargetException with such a root cause. Throws an\n\t * IllegalStateException with an appropriate message or\n\t * UndeclaredThrowableException otherwise.\n\t * @param ex the reflection exception to handle\n\t */\n\tpublic static void handleReflectionException(Exception ex) {\n\t\tif (ex instanceof NoSuchMethodException) {\n\t\t\tthrow new IllegalStateException(\"Method not found: \" + ex.getMessage());\n\t\t}\n\t\tif (ex instanceof IllegalAccessException) {\n\t\t\tthrow new IllegalStateException(\"Could not access method or field: \" + ex.getMessage());\n\t\t}\n\t\tif (ex instanceof InvocationTargetException invocationTargetException) {\n\t\t\thandleInvocationTargetException(invocationTargetException);\n\t\t}\n\t\tif (ex instanceof RuntimeException runtimeException) {\n\t\t\tthrow runtimeException;\n\t\t}\n\t\tthrow new UndeclaredThrowableException(ex);\n\t}\n\n\t/**\n\t * Handle the given invocation target exception. Should only be called if no\n\t * checked exception is expected to be thrown by the target method.\n\t * <p>Throws the underlying RuntimeException or Error in case of such a root\n\t * cause. Throws an UndeclaredThrowableException otherwise.\n\t * @param ex the invocation target exception to handle\n\t */\n\tpublic static void handleInvocationTargetException(InvocationTargetException ex) {\n\t\trethrowRuntimeException(ex.getTargetException());\n\t}\n\n\t/**\n\t * Rethrow the given {@link Throwable exception}, which is presumably the\n\t * <em>target exception</em> of an {@link InvocationTargetException}.\n\t * Should only be called if no checked exception is expected to be thrown\n\t * by the target method.\n\t * <p>Rethrows the underlying exception cast to a {@link RuntimeException} or\n\t * {@link Error} if appropriate; otherwise, throws an\n\t * {@link UndeclaredThrowableException}.\n\t * @param ex the exception to rethrow\n\t * @throws RuntimeException the rethrown exception\n\t */\n\tpublic static void rethrowRuntimeException(@Nullable Throwable ex) {\n\t\tif (ex instanceof RuntimeException runtimeException) {\n\t\t\tthrow runtimeException;\n\t\t}\n\t\tif (ex instanceof Error error) {\n\t\t\tthrow error;\n\t\t}\n\t\tthrow new UndeclaredThrowableException(ex);\n\t}\n\n\t/**\n\t * Rethrow the given {@link Throwable exception}, which is presumably the\n\t * <em>target exception</em> of an {@link InvocationTargetException}.\n\t * Should only be called if no checked exception is expected to be thrown\n\t * by the target method.\n\t * <p>Rethrows the underlying exception cast to an {@link Exception} or\n\t * {@link Error} if appropriate; otherwise, throws an\n\t * {@link UndeclaredThrowableException}.\n\t * @param throwable the exception to rethrow\n\t * @throws Exception the rethrown exception (in case of a checked exception)\n\t */\n\tpublic static void rethrowException(@Nullable Throwable throwable) throws Exception {\n\t\tif (throwable instanceof Exception exception) {\n\t\t\tthrow exception;\n\t\t}\n\t\tif (throwable instanceof Error error) {\n\t\t\tthrow error;\n\t\t}\n\t\tthrow new UndeclaredThrowableException(throwable);\n\t}\n\n\n\t// Constructor handling\n\n\t/**\n\t * Obtain an accessible constructor for the given class and parameters.\n\t * @param clazz the clazz to check\n\t * @param parameterTypes the parameter types of the desired constructor\n\t * @return the constructor reference\n\t * @throws NoSuchMethodException if no such constructor exists\n\t * @since 5.0\n\t */\n\tpublic static <T> Constructor<T> accessibleConstructor(Class<T> clazz, Class<?>... parameterTypes)\n\t\t\tthrows NoSuchMethodException {\n\n\t\tConstructor<T> ctor = clazz.getDeclaredConstructor(parameterTypes);\n\t\tmakeAccessible(ctor);\n\t\treturn ctor;\n\t}\n\n\t/**\n\t * Make the given constructor accessible, explicitly setting it accessible\n\t * if necessary. The {@code setAccessible(true)} method is only called\n\t * when actually necessary, to avoid unnecessary conflicts.\n\t * @param ctor the constructor to make accessible\n\t * @see java.lang.reflect.Constructor#setAccessible\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tpublic static void makeAccessible(Constructor<?> ctor) {\n\t\tif ((!Modifier.isPublic(ctor.getModifiers()) ||\n\t\t\t\t!Modifier.isPublic(ctor.getDeclaringClass().getModifiers())) && !ctor.isAccessible()) {\n\t\t\tctor.setAccessible(true);\n\t\t}\n\t}\n\n\n\t// Method handling\n\n\t/**\n\t * Attempt to find a {@link Method} on the supplied class with the supplied name\n\t * and no parameters. Searches all superclasses up to {@code Object}.\n\t * <p>Returns {@code null} if no {@link Method} can be found.\n\t * @param clazz the class to introspect\n\t * @param name the name of the method\n\t * @return the Method object, or {@code null} if none found\n\t */\n\tpublic static @Nullable Method findMethod(Class<?> clazz, String name) {\n\t\treturn findMethod(clazz, name, EMPTY_CLASS_ARRAY);\n\t}\n\n\t/**\n\t * Attempt to find a {@link Method} on the supplied class with the supplied name\n\t * and parameter types. Searches all superclasses up to {@code Object}.\n\t * <p>Returns {@code null} if no {@link Method} can be found.\n\t * @param clazz the class to introspect\n\t * @param name the name of the method\n\t * @param paramTypes the parameter types of the method\n\t * (may be {@code null} to indicate any signature)\n\t * @return the Method object, or {@code null} if none found\n\t */\n\tpublic static @Nullable Method findMethod(Class<?> clazz, String name, Class<?> @Nullable ... paramTypes) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(name, \"Method name must not be null\");\n\t\tClass<?> searchType = clazz;\n\t\twhile (searchType != null) {\n\t\t\tMethod[] methods = (searchType.isInterface() ? searchType.getMethods() :\n\t\t\t\t\tgetDeclaredMethods(searchType, false));\n\t\t\tfor (Method method : methods) {\n\t\t\t\tif (name.equals(method.getName()) && (paramTypes == null || hasSameParams(method, paramTypes))) {\n\t\t\t\t\treturn method;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsearchType = searchType.getSuperclass();\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate static boolean hasSameParams(Method method, Class<?>[] paramTypes) {\n\t\treturn (paramTypes.length == method.getParameterCount() &&\n\t\t\t\tArrays.equals(paramTypes, method.getParameterTypes()));\n\t}\n\n\t/**\n\t * Invoke the specified {@link Method} against the supplied target object with no arguments.\n\t * The target object can be {@code null} when invoking a static {@link Method}.\n\t * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException}.\n\t * @param method the method to invoke\n\t * @param target the target object to invoke the method on\n\t * @return the invocation result, if any\n\t * @see #invokeMethod(java.lang.reflect.Method, Object, Object[])\n\t */\n\tpublic static @Nullable Object invokeMethod(Method method, @Nullable Object target) {\n\t\treturn invokeMethod(method, target, EMPTY_OBJECT_ARRAY);\n\t}\n\n\t/**\n\t * Invoke the specified {@link Method} against the supplied target object with the\n\t * supplied arguments. The target object can be {@code null} when invoking a\n\t * static {@link Method}.\n\t * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException}.\n\t * @param method the method to invoke\n\t * @param target the target object to invoke the method on\n\t * @param args the invocation arguments (may be {@code null})\n\t * @return the invocation result, if any\n\t */\n\tpublic static @Nullable Object invokeMethod(Method method, @Nullable Object target, @Nullable Object... args) {\n\t\ttry {\n\t\t\treturn method.invoke(target, args);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\thandleReflectionException(ex);\n\t\t}\n\t\tthrow new IllegalStateException(\"Should never get here\");\n\t}\n\n\t/**\n\t * Determine whether the given method explicitly declares the given\n\t * exception or one of its superclasses, which means that an exception\n\t * of that type can be propagated as-is within a reflective invocation.\n\t * @param method the declaring method\n\t * @param exceptionType the exception to throw\n\t * @return {@code true} if the exception can be thrown as-is;\n\t * {@code false} if it needs to be wrapped\n\t */\n\tpublic static boolean declaresException(Method method, Class<?> exceptionType) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\tClass<?>[] declaredExceptions = method.getExceptionTypes();\n\t\tfor (Class<?> declaredException : declaredExceptions) {\n\t\t\tif (declaredException.isAssignableFrom(exceptionType)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Perform the given callback operation on all matching methods of the given\n\t * class, as locally declared or equivalent thereof (such as default methods\n\t * on Java 8 based interfaces that the given class implements).\n\t * @param clazz the class to introspect\n\t * @param mc the callback to invoke for each method\n\t * @throws IllegalStateException if introspection fails\n\t * @since 4.2\n\t * @see #doWithMethods\n\t */\n\tpublic static void doWithLocalMethods(Class<?> clazz, MethodCallback mc) {\n\t\tMethod[] methods = getDeclaredMethods(clazz, false);\n\t\tfor (Method method : methods) {\n\t\t\ttry {\n\t\t\t\tmc.doWith(method);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Not allowed to access method '\" + method.getName() + \"': \" + ex);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Perform the given callback operation on all matching methods of the given\n\t * class and superclasses.\n\t * <p>The same named method occurring on subclass and superclass will appear\n\t * twice, unless excluded by a {@link MethodFilter}.\n\t * @param clazz the class to introspect\n\t * @param mc the callback to invoke for each method\n\t * @throws IllegalStateException if introspection fails\n\t * @see #doWithMethods(Class, MethodCallback, MethodFilter)\n\t */\n\tpublic static void doWithMethods(Class<?> clazz, MethodCallback mc) {\n\t\tdoWithMethods(clazz, mc, null);\n\t}\n\n\t/**\n\t * Perform the given callback operation on all matching methods of the given\n\t * class and superclasses (or given interface and super-interfaces).\n\t * <p>The same named method occurring on subclass and superclass will appear\n\t * twice, unless excluded by the specified {@link MethodFilter}.\n\t * @param clazz the class to introspect\n\t * @param mc the callback to invoke for each method\n\t * @param mf the filter that determines the methods to apply the callback to\n\t * @throws IllegalStateException if introspection fails\n\t */\n\tpublic static void doWithMethods(Class<?> clazz, MethodCallback mc, @Nullable MethodFilter mf) {\n\t\tif (mf == USER_DECLARED_METHODS && clazz == Object.class) {\n\t\t\t// nothing to introspect\n\t\t\treturn;\n\t\t}\n\t\tMethod[] methods = getDeclaredMethods(clazz, false);\n\t\tfor (Method method : methods) {\n\t\t\tif (mf != null && !mf.matches(method)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tmc.doWith(method);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Not allowed to access method '\" + method.getName() + \"': \" + ex);\n\t\t\t}\n\t\t}\n\t\t// Keep backing up the inheritance hierarchy.\n\t\tif (clazz.getSuperclass() != null && (mf != USER_DECLARED_METHODS || clazz.getSuperclass() != Object.class)) {\n\t\t\tdoWithMethods(clazz.getSuperclass(), mc, mf);\n\t\t}\n\t\telse if (clazz.isInterface()) {\n\t\t\tfor (Class<?> superIfc : clazz.getInterfaces()) {\n\t\t\t\tdoWithMethods(superIfc, mc, mf);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get all declared methods on the leaf class and all superclasses.\n\t * Leaf class methods are included first.\n\t * @param leafClass the class to introspect\n\t * @throws IllegalStateException if introspection fails\n\t */\n\tpublic static Method[] getAllDeclaredMethods(Class<?> leafClass) {\n\t\tfinal List<Method> methods = new ArrayList<>(20);\n\t\tdoWithMethods(leafClass, methods::add);\n\t\treturn methods.toArray(EMPTY_METHOD_ARRAY);\n\t}\n\n\t/**\n\t * Get the unique set of declared methods on the leaf class and all superclasses.\n\t * Leaf class methods are included first and while traversing the superclass hierarchy\n\t * any methods found with signatures matching a method already included are filtered out.\n\t * @param leafClass the class to introspect\n\t * @throws IllegalStateException if introspection fails\n\t */\n\tpublic static Method[] getUniqueDeclaredMethods(Class<?> leafClass) {\n\t\treturn getUniqueDeclaredMethods(leafClass, null);\n\t}\n\n\t/**\n\t * Get the unique set of declared methods on the leaf class and all superclasses.\n\t * Leaf class methods are included first and while traversing the superclass hierarchy\n\t * any methods found with signatures matching a method already included are filtered out.\n\t * @param leafClass the class to introspect\n\t * @param mf the filter that determines the methods to take into account\n\t * @throws IllegalStateException if introspection fails\n\t * @since 5.2\n\t */\n\tpublic static Method[] getUniqueDeclaredMethods(Class<?> leafClass, @Nullable MethodFilter mf) {\n\t\tfinal List<Method> methods = new ArrayList<>(20);\n\t\tdoWithMethods(leafClass, method -> {\n\t\t\tboolean knownSignature = false;\n\t\t\tMethod methodBeingOverriddenWithCovariantReturnType = null;\n\t\t\tfor (Method existingMethod : methods) {\n\t\t\t\tif (method.getName().equals(existingMethod.getName()) &&\n\t\t\t\t\t\tmethod.getParameterCount() == existingMethod.getParameterCount() &&\n\t\t\t\t\t\tArrays.equals(method.getParameterTypes(), existingMethod.getParameterTypes())) {\n\t\t\t\t\t// Is this a covariant return type situation?\n\t\t\t\t\tif (existingMethod.getReturnType() != method.getReturnType() &&\n\t\t\t\t\t\t\texistingMethod.getReturnType().isAssignableFrom(method.getReturnType())) {\n\t\t\t\t\t\tmethodBeingOverriddenWithCovariantReturnType = existingMethod;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tknownSignature = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (methodBeingOverriddenWithCovariantReturnType != null) {\n\t\t\t\tmethods.remove(methodBeingOverriddenWithCovariantReturnType);\n\t\t\t}\n\t\t\tif (!knownSignature && !isCglibRenamedMethod(method)) {\n\t\t\t\tmethods.add(method);\n\t\t\t}\n\t\t}, mf);\n\t\treturn methods.toArray(EMPTY_METHOD_ARRAY);\n\t}\n\n\t/**\n\t * Variant of {@link Class#getDeclaredMethods()} that uses a local cache in\n\t * order to avoid new Method instances. In addition, it also includes Java 8\n\t * default methods from locally implemented interfaces, since those are\n\t * effectively to be treated just like declared methods.\n\t * @param clazz the class to introspect\n\t * @return the cached array of methods\n\t * @throws IllegalStateException if introspection fails\n\t * @since 5.2\n\t * @see Class#getDeclaredMethods()\n\t */\n\tpublic static Method[] getDeclaredMethods(Class<?> clazz) {\n\t\treturn getDeclaredMethods(clazz, true);\n\t}\n\n\tprivate static Method[] getDeclaredMethods(Class<?> clazz, boolean defensive) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tMethod[] result = declaredMethodsCache.get(clazz);\n\t\tif (result == null) {\n\t\t\ttry {\n\t\t\t\tMethod[] declaredMethods = clazz.getDeclaredMethods();\n\t\t\t\tList<Method> defaultMethods = findDefaultMethodsOnInterfaces(clazz);\n\t\t\t\tif (defaultMethods != null) {\n\t\t\t\t\tresult = new Method[declaredMethods.length + defaultMethods.size()];\n\t\t\t\t\tSystem.arraycopy(declaredMethods, 0, result, 0, declaredMethods.length);\n\t\t\t\t\tint index = declaredMethods.length;\n\t\t\t\t\tfor (Method defaultMethod : defaultMethods) {\n\t\t\t\t\t\tresult[index] = defaultMethod;\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresult = declaredMethods;\n\t\t\t\t}\n\t\t\t\tdeclaredMethodsCache.put(clazz, (result.length == 0 ? EMPTY_METHOD_ARRAY : result));\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalStateException(\"Failed to introspect Class [\" + clazz.getName() +\n\t\t\t\t\t\t\"] from ClassLoader [\" + clazz.getClassLoader() + \"]\", ex);\n\t\t\t}\n\t\t}\n\t\treturn (result.length == 0 || !defensive) ? result : result.clone();\n\t}\n\n\tprivate static @Nullable List<Method> findDefaultMethodsOnInterfaces(Class<?> clazz) {\n\t\tList<Method> result = null;\n\t\tfor (Class<?> ifc : clazz.getInterfaces()) {\n\t\t\tfor (Method method : ifc.getMethods()) {\n\t\t\t\tif (method.isDefault()) {\n\t\t\t\t\tif (result == null) {\n\t\t\t\t\t\tresult = new ArrayList<>();\n\t\t\t\t\t}\n\t\t\t\t\tresult.add(method);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Determine whether the given method is an \"equals\" method.\n\t * @see java.lang.Object#equals(Object)\n\t */\n\tpublic static boolean isEqualsMethod(@Nullable Method method) {\n\t\treturn (method != null && method.getParameterCount() == 1 && method.getName().equals(\"equals\") &&\n\t\t\t\tmethod.getParameterTypes()[0] == Object.class);\n\t}\n\n\t/**\n\t * Determine whether the given method is a \"hashCode\" method.\n\t * @see java.lang.Object#hashCode()\n\t */\n\tpublic static boolean isHashCodeMethod(@Nullable Method method) {\n\t\treturn (method != null && method.getParameterCount() == 0 && method.getName().equals(\"hashCode\"));\n\t}\n\n\t/**\n\t * Determine whether the given method is a \"toString\" method.\n\t * @see java.lang.Object#toString()\n\t */\n\tpublic static boolean isToStringMethod(@Nullable Method method) {\n\t\treturn (method != null && method.getParameterCount() == 0 && method.getName().equals(\"toString\"));\n\t}\n\n\t/**\n\t * Determine whether the given method is originally declared by {@link java.lang.Object}.\n\t */\n\tpublic static boolean isObjectMethod(@Nullable Method method) {\n\t\treturn (method != null && (method.getDeclaringClass() == Object.class ||\n\t\t\t\tisEqualsMethod(method) || isHashCodeMethod(method) || isToStringMethod(method)));\n\t}\n\n\t/**\n\t * Determine whether the given method is a CGLIB 'renamed' method,\n\t * following the pattern \"CGLIB$methodName$0\".\n\t * @param renamedMethod the method to check\n\t */\n\tpublic static boolean isCglibRenamedMethod(Method renamedMethod) {\n\t\tString name = renamedMethod.getName();\n\t\tif (name.startsWith(CGLIB_RENAMED_METHOD_PREFIX)) {\n\t\t\tint i = name.length() - 1;\n\t\t\twhile (i >= 0 && Character.isDigit(name.charAt(i))) {\n\t\t\t\ti--;\n\t\t\t}\n\t\t\treturn (i > CGLIB_RENAMED_METHOD_PREFIX.length() && (i < name.length() - 1) && name.charAt(i) == '$');\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Make the given method accessible, explicitly setting it accessible if\n\t * necessary. The {@code setAccessible(true)} method is only called\n\t * when actually necessary, to avoid unnecessary conflicts.\n\t * @param method the method to make accessible\n\t * @see java.lang.reflect.Method#setAccessible\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tpublic static void makeAccessible(Method method) {\n\t\tif ((!Modifier.isPublic(method.getModifiers()) ||\n\t\t\t\t!Modifier.isPublic(method.getDeclaringClass().getModifiers())) && !method.isAccessible()) {\n\t\t\tmethod.setAccessible(true);\n\t\t}\n\t}\n\n\n\t// Field handling\n\n\t/**\n\t * Attempt to find a {@link Field field} on the supplied {@link Class} with the\n\t * supplied {@code name}. Searches all superclasses up to {@link Object}.\n\t * @param clazz the class to introspect\n\t * @param name the name of the field\n\t * @return the corresponding Field object, or {@code null} if not found\n\t */\n\tpublic static @Nullable Field findField(Class<?> clazz, String name) {\n\t\treturn findField(clazz, name, null);\n\t}\n\n\t/**\n\t * Attempt to find a {@link Field field} on the supplied {@link Class} with the\n\t * supplied {@code name} and/or {@link Class type}. Searches all superclasses\n\t * up to {@link Object}.\n\t * @param clazz the class to introspect\n\t * @param name the name of the field (may be {@code null} if type is specified)\n\t * @param type the type of the field (may be {@code null} if name is specified)\n\t * @return the corresponding Field object, or {@code null} if not found\n\t */\n\tpublic static @Nullable Field findField(Class<?> clazz, @Nullable String name, @Nullable Class<?> type) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.isTrue(name != null || type != null, \"Either name or type of the field must be specified\");\n\t\tClass<?> searchType = clazz;\n\t\twhile (Object.class != searchType && searchType != null) {\n\t\t\tField[] fields = getDeclaredFields(searchType);\n\t\t\tfor (Field field : fields) {\n\t\t\t\tif ((name == null || name.equals(field.getName())) &&\n\t\t\t\t\t\t(type == null || type.equals(field.getType()))) {\n\t\t\t\t\treturn field;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsearchType = searchType.getSuperclass();\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Attempt to find a {@link Field field} on the supplied {@link Class} with the\n\t * supplied {@code name}. Searches all superclasses up to {@link Object}.\n\t * @param clazz the class to introspect\n\t * @param name the name of the field (with upper/lower case to be ignored)\n\t * @return the corresponding Field object, or {@code null} if not found\n\t * @since 6.1\n\t */\n\tpublic static @Nullable Field findFieldIgnoreCase(Class<?> clazz, String name) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tAssert.notNull(name, \"Name must not be null\");\n\t\tClass<?> searchType = clazz;\n\t\twhile (Object.class != searchType && searchType != null) {\n\t\t\tField[] fields = getDeclaredFields(searchType);\n\t\t\tfor (Field field : fields) {\n\t\t\t\tif (name.equalsIgnoreCase(field.getName())) {\n\t\t\t\t\treturn field;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsearchType = searchType.getSuperclass();\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Set the field represented by the supplied {@linkplain Field field object} on\n\t * the specified {@linkplain Object target object} to the specified {@code value}.\n\t * <p>In accordance with {@link Field#set(Object, Object)} semantics, the new value\n\t * is automatically unwrapped if the underlying field has a primitive type.\n\t * <p>This method does not support setting {@code static final} fields.\n\t * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException(Exception)}.\n\t * @param field the field to set\n\t * @param target the target object on which to set the field\n\t * (or {@code null} for a static field)\n\t * @param value the value to set (may be {@code null})\n\t */\n\tpublic static void setField(Field field, @Nullable Object target, @Nullable Object value) {\n\t\ttry {\n\t\t\tfield.set(target, value);\n\t\t}\n\t\tcatch (IllegalAccessException ex) {\n\t\t\thandleReflectionException(ex);\n\t\t}\n\t}\n\n\t/**\n\t * Get the field represented by the supplied {@link Field field object} on the\n\t * specified {@link Object target object}. In accordance with {@link Field#get(Object)}\n\t * semantics, the returned value is automatically wrapped if the underlying field\n\t * has a primitive type.\n\t * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException(Exception)}.\n\t * @param field the field to get\n\t * @param target the target object from which to get the field\n\t * (or {@code null} for a static field)\n\t * @return the field's current value\n\t */\n\tpublic static @Nullable Object getField(Field field, @Nullable Object target) {\n\t\ttry {\n\t\t\treturn field.get(target);\n\t\t}\n\t\tcatch (IllegalAccessException ex) {\n\t\t\thandleReflectionException(ex);\n\t\t}\n\t\tthrow new IllegalStateException(\"Should never get here\");\n\t}\n\n\t/**\n\t * Invoke the given callback on all locally declared fields in the given class.\n\t * @param clazz the target class to analyze\n\t * @param fc the callback to invoke for each field\n\t * @throws IllegalStateException if introspection fails\n\t * @since 4.2\n\t * @see #doWithFields\n\t */\n\tpublic static void doWithLocalFields(Class<?> clazz, FieldCallback fc) {\n\t\tfor (Field field : getDeclaredFields(clazz)) {\n\t\t\ttry {\n\t\t\t\tfc.doWith(field);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tthrow new IllegalStateException(\"Not allowed to access field '\" + field.getName() + \"': \" + ex);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Invoke the given callback on all fields in the target class, going up the\n\t * class hierarchy to get all declared fields.\n\t * @param clazz the target class to analyze\n\t * @param fc the callback to invoke for each field\n\t * @throws IllegalStateException if introspection fails\n\t */\n\tpublic static void doWithFields(Class<?> clazz, FieldCallback fc) {\n\t\tdoWithFields(clazz, fc, null);\n\t}\n\n\t/**\n\t * Invoke the given callback on all fields in the target class, going up the\n\t * class hierarchy to get all declared fields.\n\t * @param clazz the target class to analyze\n\t * @param fc the callback to invoke for each field\n\t * @param ff the filter that determines the fields to apply the callback to\n\t * @throws IllegalStateException if introspection fails\n\t */\n\tpublic static void doWithFields(Class<?> clazz, FieldCallback fc, @Nullable FieldFilter ff) {\n\t\t// Keep backing up the inheritance hierarchy.\n\t\tClass<?> targetClass = clazz;\n\t\tdo {\n\t\t\tfor (Field field : getDeclaredFields(targetClass)) {\n\t\t\t\tif (ff != null && !ff.matches(field)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tfc.doWith(field);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\t\tthrow new IllegalStateException(\"Not allowed to access field '\" + field.getName() + \"': \" + ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttargetClass = targetClass.getSuperclass();\n\t\t}\n\t\twhile (targetClass != null && targetClass != Object.class);\n\t}\n\n\t/**\n\t * This variant retrieves {@link Class#getDeclaredFields()} from a local cache\n\t * in order to avoid defensive array copying.\n\t * @param clazz the class to introspect\n\t * @return the cached array of fields\n\t * @throws IllegalStateException if introspection fails\n\t * @see Class#getDeclaredFields()\n\t */\n\tprivate static Field[] getDeclaredFields(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tField[] result = declaredFieldsCache.get(clazz);\n\t\tif (result == null) {\n\t\t\ttry {\n\t\t\t\tresult = clazz.getDeclaredFields();\n\t\t\t\tdeclaredFieldsCache.put(clazz, (result.length == 0 ? EMPTY_FIELD_ARRAY : result));\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tthrow new IllegalStateException(\"Failed to introspect Class [\" + clazz.getName() +\n\t\t\t\t\t\t\"] from ClassLoader [\" + clazz.getClassLoader() + \"]\", ex);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Given the source object and the destination, which must be the same class\n\t * or a subclass, copy all fields, including inherited fields. Designed to\n\t * work on objects with public no-arg constructors.\n\t * @throws IllegalStateException if introspection fails\n\t */\n\tpublic static void shallowCopyFieldState(final Object src, final Object dest) {\n\t\tAssert.notNull(src, \"Source for field copy cannot be null\");\n\t\tAssert.notNull(dest, \"Destination for field copy cannot be null\");\n\t\tif (!src.getClass().isAssignableFrom(dest.getClass())) {\n\t\t\tthrow new IllegalArgumentException(\"Destination class [\" + dest.getClass().getName() +\n\t\t\t\t\t\"] must be same or subclass as source class [\" + src.getClass().getName() + \"]\");\n\t\t}\n\t\tdoWithFields(src.getClass(), field -> {\n\t\t\tmakeAccessible(field);\n\t\t\tObject srcValue = field.get(src);\n\t\t\tfield.set(dest, srcValue);\n\t\t}, COPYABLE_FIELDS);\n\t}\n\n\t/**\n\t * Determine whether the given field is a \"public static final\" constant.\n\t * @param field the field to check\n\t */\n\tpublic static boolean isPublicStaticFinal(Field field) {\n\t\tint modifiers = field.getModifiers();\n\t\treturn (Modifier.isPublic(modifiers) && Modifier.isStatic(modifiers) && Modifier.isFinal(modifiers));\n\t}\n\n\t/**\n\t * Make the given field accessible, explicitly setting it accessible if\n\t * necessary. The {@code setAccessible(true)} method is only called\n\t * when actually necessary, to avoid unnecessary conflicts.\n\t * @param field the field to make accessible\n\t * @see java.lang.reflect.Field#setAccessible\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tpublic static void makeAccessible(Field field) {\n\t\tif ((!Modifier.isPublic(field.getModifiers()) ||\n\t\t\t\t!Modifier.isPublic(field.getDeclaringClass().getModifiers()) ||\n\t\t\t\tModifier.isFinal(field.getModifiers())) && !field.isAccessible()) {\n\t\t\tfield.setAccessible(true);\n\t\t}\n\t}\n\n\n\t// Cache handling\n\n\t/**\n\t * Clear the internal method/field cache.\n\t * @since 4.2.4\n\t */\n\tpublic static void clearCache() {\n\t\tdeclaredMethodsCache.clear();\n\t\tdeclaredFieldsCache.clear();\n\t}\n\n\n\t/**\n\t * Action to take on each method.\n\t */\n\t@FunctionalInterface\n\tpublic interface MethodCallback {\n\n\t\t/**\n\t\t * Perform an operation using the given method.\n\t\t * @param method the method to operate on\n\t\t */\n\t\tvoid doWith(Method method) throws IllegalArgumentException, IllegalAccessException;\n\t}\n\n\n\t/**\n\t * Callback optionally used to filter methods to be operated on by a method callback.\n\t */\n\t@FunctionalInterface\n\tpublic interface MethodFilter {\n\n\t\t/**\n\t\t * Determine whether the given method matches.\n\t\t * @param method the method to check\n\t\t */\n\t\tboolean matches(Method method);\n\n\t\t/**\n\t\t * Create a composite filter based on this filter <em>and</em> the provided filter.\n\t\t * <p>If this filter does not match, the next filter will not be applied.\n\t\t * @param next the next {@code MethodFilter}\n\t\t * @return a composite {@code MethodFilter}\n\t\t * @throws IllegalArgumentException if the MethodFilter argument is {@code null}\n\t\t * @since 5.3.2\n\t\t */\n\t\tdefault MethodFilter and(MethodFilter next) {\n\t\t\tAssert.notNull(next, \"Next MethodFilter must not be null\");\n\t\t\treturn method -> matches(method) && next.matches(method);\n\t\t}\n\t}\n\n\n\t/**\n\t * Callback interface invoked on each field in the hierarchy.\n\t */\n\t@FunctionalInterface\n\tpublic interface FieldCallback {\n\n\t\t/**\n\t\t * Perform an operation using the given field.\n\t\t * @param field the field to operate on\n\t\t */\n\t\tvoid doWith(Field field) throws IllegalArgumentException, IllegalAccessException;\n\t}\n\n\n\t/**\n\t * Callback optionally used to filter fields to be operated on by a field callback.\n\t */\n\t@FunctionalInterface\n\tpublic interface FieldFilter {\n\n\t\t/**\n\t\t * Determine whether the given field matches.\n\t\t * @param field the field to check\n\t\t */\n\t\tboolean matches(Field field);\n\n\t\t/**\n\t\t * Create a composite filter based on this filter <em>and</em> the provided filter.\n\t\t * <p>If this filter does not match, the next filter will not be applied.\n\t\t * @param next the next {@code FieldFilter}\n\t\t * @return a composite {@code FieldFilter}\n\t\t * @throws IllegalArgumentException if the FieldFilter argument is {@code null}\n\t\t * @since 5.3.2\n\t\t */\n\t\tdefault FieldFilter and(FieldFilter next) {\n\t\t\tAssert.notNull(next, \"Next FieldFilter must not be null\");\n\t\t\treturn field -> matches(field) && next.matches(field);\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.FieldFilter#matches(Field)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Determine whether the given field matches.\r\n * @param field the field to check\r\n */\r\nboolean matches(Field field);",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.FieldFilter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.FieldFilter#matches(Field)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.FieldFilter#and(FieldFilter)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Create a composite filter based on this filter <em>and</em> the provided filter.\r\n * <p>If this filter does not match, the next filter will not be applied.\r\n * @param next the next {@code FieldFilter}\r\n * @return a composite {@code FieldFilter}\r\n * @throws IllegalArgumentException if the FieldFilter argument is {@code null}\r\n * @since 5.3.2\r\n */\r\ndefault FieldFilter and(FieldFilter next) {\r\n    Assert.notNull(next, \"Next FieldFilter must not be null\");\r\n    return field -> matches(field) && next.matches(field);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.FieldFilter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.FieldFilter#and(FieldFilter)",
    "tailType": "method"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.util",
    "tailType": "package"
  },
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.ResizableByteArrayOutputStream",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.ResizableByteArrayOutputStream",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.io.ByteArrayOutputStream;\n\n/**\n * An extension of {@link java.io.ByteArrayOutputStream} that:\n * <ul>\n * <li>has public {@link org.springframework.util.ResizableByteArrayOutputStream#grow(int)}\n * and {@link org.springframework.util.ResizableByteArrayOutputStream#resize(int)} methods\n * to get more control over the size of the internal buffer</li>\n * <li>has a higher initial capacity (256) by default</li>\n * </ul>\n *\n * <p>As of 4.2, this class has been superseded by {@link FastByteArrayOutputStream}\n * for Spring's internal use where no assignability to {@link ByteArrayOutputStream}\n * is needed (since {@link FastByteArrayOutputStream} is more efficient with buffer\n * resize management but doesn't extend the standard {@link ByteArrayOutputStream}).\n *\n * @author Brian Clozel\n * @author Juergen Hoeller\n * @since 4.0.3\n * @see #resize\n * @see FastByteArrayOutputStream\n */\npublic class ResizableByteArrayOutputStream extends ByteArrayOutputStream {\n\n\tprivate static final int DEFAULT_INITIAL_CAPACITY = 256;\n\n\n\t/**\n\t * Create a new <code>ResizableByteArrayOutputStream</code>\n\t * with the default initial capacity of 256 bytes.\n\t */\n\tpublic ResizableByteArrayOutputStream() {\n\t\tsuper(DEFAULT_INITIAL_CAPACITY);\n\t}\n\n\t/**\n\t * Create a new <code>ResizableByteArrayOutputStream</code>\n\t * with the specified initial capacity.\n\t * @param initialCapacity the initial buffer size in bytes\n\t */\n\tpublic ResizableByteArrayOutputStream(int initialCapacity) {\n\t\tsuper(initialCapacity);\n\t}\n\n\n\t/**\n\t * Resize the internal buffer size to a specified capacity.\n\t * @param targetCapacity the desired size of the buffer\n\t * @throws IllegalArgumentException if the given capacity is smaller than\n\t * the actual size of the content stored in the buffer already\n\t * @see ResizableByteArrayOutputStream#size()\n\t */\n\tpublic synchronized void resize(int targetCapacity) {\n\t\tAssert.isTrue(targetCapacity >= this.count, \"New capacity must not be smaller than current size\");\n\t\tbyte[] resizedBuffer = new byte[targetCapacity];\n\t\tSystem.arraycopy(this.buf, 0, resizedBuffer, 0, this.count);\n\t\tthis.buf = resizedBuffer;\n\t}\n\n\t/**\n\t * Grow the internal buffer size.\n\t * @param additionalCapacity the number of bytes to add to the current buffer size\n\t * @see ResizableByteArrayOutputStream#size()\n\t */\n\tpublic synchronized void grow(int additionalCapacity) {\n\t\tAssert.isTrue(additionalCapacity >= 0, \"Additional capacity must be 0 or higher\");\n\t\tif (this.count + additionalCapacity > this.buf.length) {\n\t\t\tint newCapacity = Math.max(this.buf.length * 2, this.count + additionalCapacity);\n\t\t\tresize(newCapacity);\n\t\t}\n\t}\n\n\t/**\n\t * Return the current size of this stream's internal buffer.\n\t */\n\tpublic synchronized int capacity() {\n\t\treturn this.buf.length;\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.ResizableByteArrayOutputStream",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.ResizableByteArrayOutputStream#DEFAULT_INITIAL_CAPACITY",
    "tailType": "field"
  },
  {
    "head": "org.springframework.util.ResizableByteArrayOutputStream#DEFAULT_INITIAL_CAPACITY",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.util.ResizableByteArrayOutputStream#resize(int)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Resize the internal buffer size to a specified capacity.\r\n * @param targetCapacity the desired size of the buffer\r\n * @throws IllegalArgumentException if the given capacity is smaller than\r\n * the actual size of the content stored in the buffer already\r\n * @see ResizableByteArrayOutputStream#size()\r\n */\r\npublic synchronized void resize(int targetCapacity) {\r\n    Assert.isTrue(targetCapacity >= this.count, \"New capacity must not be smaller than current size\");\r\n    byte[] resizedBuffer = new byte[targetCapacity];\r\n    System.arraycopy(this.buf, 0, resizedBuffer, 0, this.count);\r\n    this.buf = resizedBuffer;\r\n}",
    "tailType": "method_code"
  }
]