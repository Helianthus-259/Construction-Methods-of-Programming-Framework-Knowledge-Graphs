[
  {
    "head": "org.springframework.core.FieldAwareConstructorParameter",
    "headType": "class",
    "relation": "extend",
    "tail": "MethodParameter",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.KotlinDelegate",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.KotlinDelegate",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Executable;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.function.Predicate;\n\nimport kotlin.Unit;\nimport kotlin.reflect.KFunction;\nimport kotlin.reflect.KParameter;\nimport kotlin.reflect.jvm.ReflectJvmMapping;\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.ObjectUtils;\n\n/**\n * Helper class that encapsulates the specification of a method parameter, i.e. a {@link Method}\n * or {@link Constructor} plus a parameter index and a nested type index for a declared generic\n * type. Useful as a specification object to pass along.\n *\n * <p>As of 4.2, there is a {@link org.springframework.core.annotation.SynthesizingMethodParameter}\n * subclass available which synthesizes annotations with attribute aliases. That subclass is used\n * for web and message endpoint processing, in particular.\n *\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Andy Clement\n * @author Sam Brannen\n * @author Sebastien Deleuze\n * @author Phillip Webb\n * @since 2.0\n * @see org.springframework.core.annotation.SynthesizingMethodParameter\n */\npublic class MethodParameter {\n\n\tprivate static final Annotation[] EMPTY_ANNOTATION_ARRAY = new Annotation[0];\n\n\n\tprivate final Executable executable;\n\n\tprivate final int parameterIndex;\n\n\tprivate volatile @Nullable Parameter parameter;\n\n\tprivate int nestingLevel;\n\n\t/** Map from Integer level to Integer type index. */\n\t@Nullable Map<Integer, Integer> typeIndexesPerLevel;\n\n\t/** The containing class. Could also be supplied by overriding {@link #getContainingClass()} */\n\tprivate volatile @Nullable Class<?> containingClass;\n\n\tprivate volatile @Nullable Class<?> parameterType;\n\n\tprivate volatile @Nullable Type genericParameterType;\n\n\tprivate volatile Annotation @Nullable [] parameterAnnotations;\n\n\tprivate volatile @Nullable ParameterNameDiscoverer parameterNameDiscoverer;\n\n\tvolatile @Nullable String parameterName;\n\n\tprivate volatile @Nullable MethodParameter nestedMethodParameter;\n\n\n\t/**\n\t * Create a new {@code MethodParameter} for the given method, with nesting level 1.\n\t * @param method the Method to specify a parameter for\n\t * @param parameterIndex the index of the parameter: -1 for the method\n\t * return type; 0 for the first method parameter; 1 for the second method\n\t * parameter, etc.\n\t */\n\tpublic MethodParameter(Method method, int parameterIndex) {\n\t\tthis(method, parameterIndex, 1);\n\t}\n\n\t/**\n\t * Create a new {@code MethodParameter} for the given method.\n\t * @param method the Method to specify a parameter for\n\t * @param parameterIndex the index of the parameter: -1 for the method\n\t * return type; 0 for the first method parameter; 1 for the second method\n\t * parameter, etc.\n\t * @param nestingLevel the nesting level of the target type\n\t * (typically 1; for example, in case of a List of Lists, 1 would indicate the\n\t * nested List, whereas 2 would indicate the element of the nested List)\n\t */\n\tpublic MethodParameter(Method method, int parameterIndex, int nestingLevel) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\tthis.executable = method;\n\t\tthis.parameterIndex = validateIndex(method, parameterIndex);\n\t\tthis.nestingLevel = nestingLevel;\n\t}\n\n\t/**\n\t * Create a new MethodParameter for the given constructor, with nesting level 1.\n\t * @param constructor the Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t */\n\tpublic MethodParameter(Constructor<?> constructor, int parameterIndex) {\n\t\tthis(constructor, parameterIndex, 1);\n\t}\n\n\t/**\n\t * Create a new MethodParameter for the given constructor.\n\t * @param constructor the Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @param nestingLevel the nesting level of the target type\n\t * (typically 1; for example, in case of a List of Lists, 1 would indicate the\n\t * nested List, whereas 2 would indicate the element of the nested List)\n\t */\n\tpublic MethodParameter(Constructor<?> constructor, int parameterIndex, int nestingLevel) {\n\t\tAssert.notNull(constructor, \"Constructor must not be null\");\n\t\tthis.executable = constructor;\n\t\tthis.parameterIndex = validateIndex(constructor, parameterIndex);\n\t\tthis.nestingLevel = nestingLevel;\n\t}\n\n\t/**\n\t * Internal constructor used to create a {@link MethodParameter} with a\n\t * containing class already set.\n\t * @param executable the Executable to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @param containingClass the containing class\n\t * @since 5.2\n\t */\n\tMethodParameter(Executable executable, int parameterIndex, @Nullable Class<?> containingClass) {\n\t\tAssert.notNull(executable, \"Executable must not be null\");\n\t\tthis.executable = executable;\n\t\tthis.parameterIndex = validateIndex(executable, parameterIndex);\n\t\tthis.nestingLevel = 1;\n\t\tthis.containingClass = containingClass;\n\t}\n\n\t/**\n\t * Copy constructor, resulting in an independent MethodParameter object\n\t * based on the same metadata and cache state that the original object was in.\n\t * @param original the original MethodParameter object to copy from\n\t */\n\tpublic MethodParameter(MethodParameter original) {\n\t\tAssert.notNull(original, \"Original must not be null\");\n\t\tthis.executable = original.executable;\n\t\tthis.parameterIndex = original.parameterIndex;\n\t\tthis.parameter = original.parameter;\n\t\tthis.nestingLevel = original.nestingLevel;\n\t\tthis.typeIndexesPerLevel = original.typeIndexesPerLevel;\n\t\tthis.containingClass = original.containingClass;\n\t\tthis.parameterType = original.parameterType;\n\t\tthis.genericParameterType = original.genericParameterType;\n\t\tthis.parameterAnnotations = original.parameterAnnotations;\n\t\tthis.parameterNameDiscoverer = original.parameterNameDiscoverer;\n\t\tthis.parameterName = original.parameterName;\n\t}\n\n\n\t/**\n\t * Return the wrapped Method, if any.\n\t * <p>Note: Either Method or Constructor is available.\n\t * @return the Method, or {@code null} if none\n\t */\n\tpublic @Nullable Method getMethod() {\n\t\treturn (this.executable instanceof Method method ? method : null);\n\t}\n\n\t/**\n\t * Return the wrapped Constructor, if any.\n\t * <p>Note: Either Method or Constructor is available.\n\t * @return the Constructor, or {@code null} if none\n\t */\n\tpublic @Nullable Constructor<?> getConstructor() {\n\t\treturn (this.executable instanceof Constructor<?> constructor ? constructor : null);\n\t}\n\n\t/**\n\t * Return the class that declares the underlying Method or Constructor.\n\t */\n\tpublic Class<?> getDeclaringClass() {\n\t\treturn this.executable.getDeclaringClass();\n\t}\n\n\t/**\n\t * Return the wrapped member.\n\t * @return the Method or Constructor as Member\n\t */\n\tpublic Member getMember() {\n\t\treturn this.executable;\n\t}\n\n\t/**\n\t * Return the wrapped annotated element.\n\t * <p>Note: This method exposes the annotations declared on the method/constructor\n\t * itself (i.e. at the method/constructor level, not at the parameter level).\n\t * <p>To get the {@link AnnotatedElement} at the parameter level, use\n\t * {@link #getParameter()}.\n\t * @return the Method or Constructor as AnnotatedElement\n\t */\n\tpublic AnnotatedElement getAnnotatedElement() {\n\t\treturn this.executable;\n\t}\n\n\t/**\n\t * Return the wrapped executable.\n\t * @return the Method or Constructor as Executable\n\t * @since 5.0\n\t */\n\tpublic Executable getExecutable() {\n\t\treturn this.executable;\n\t}\n\n\t/**\n\t * Return the {@link Parameter} descriptor for method/constructor parameter.\n\t * @since 5.0\n\t */\n\tpublic Parameter getParameter() {\n\t\tif (this.parameterIndex < 0) {\n\t\t\tthrow new IllegalStateException(\"Cannot retrieve Parameter descriptor for method return type\");\n\t\t}\n\t\tParameter parameter = this.parameter;\n\t\tif (parameter == null) {\n\t\t\tparameter = getExecutable().getParameters()[this.parameterIndex];\n\t\t\tthis.parameter = parameter;\n\t\t}\n\t\treturn parameter;\n\t}\n\n\t/**\n\t * Return the index of the method/constructor parameter.\n\t * @return the parameter index (-1 in case of the return type)\n\t */\n\tpublic int getParameterIndex() {\n\t\treturn this.parameterIndex;\n\t}\n\n\t/**\n\t * Increase this parameter's nesting level.\n\t * @see #getNestingLevel()\n\t * @deprecated since 5.2 in favor of {@link #nested(Integer)}\n\t */\n\t@Deprecated\n\tpublic void increaseNestingLevel() {\n\t\tthis.nestingLevel++;\n\t}\n\n\t/**\n\t * Decrease this parameter's nesting level.\n\t * @see #getNestingLevel()\n\t * @deprecated since 5.2 in favor of retaining the original MethodParameter and\n\t * using {@link #nested(Integer)} if nesting is required\n\t */\n\t@Deprecated\n\tpublic void decreaseNestingLevel() {\n\t\tgetTypeIndexesPerLevel().remove(this.nestingLevel);\n\t\tthis.nestingLevel--;\n\t}\n\n\t/**\n\t * Return the nesting level of the target type\n\t * (typically 1; for example, in case of a List of Lists, 1 would indicate the\n\t * nested List, whereas 2 would indicate the element of the nested List).\n\t */\n\tpublic int getNestingLevel() {\n\t\treturn this.nestingLevel;\n\t}\n\n\t/**\n\t * Return a variant of this {@code MethodParameter} with the type\n\t * for the current level set to the specified value.\n\t * @param typeIndex the new type index\n\t * @since 5.2\n\t */\n\tpublic MethodParameter withTypeIndex(int typeIndex) {\n\t\treturn nested(this.nestingLevel, typeIndex);\n\t}\n\n\t/**\n\t * Set the type index for the current nesting level.\n\t * @param typeIndex the corresponding type index\n\t * (or {@code null} for the default type index)\n\t * @see #getNestingLevel()\n\t * @deprecated since 5.2 in favor of {@link #withTypeIndex}\n\t */\n\t@Deprecated\n\tpublic void setTypeIndexForCurrentLevel(int typeIndex) {\n\t\tgetTypeIndexesPerLevel().put(this.nestingLevel, typeIndex);\n\t}\n\n\t/**\n\t * Return the type index for the current nesting level.\n\t * @return the corresponding type index, or {@code null}\n\t * if none specified (indicating the default type index)\n\t * @see #getNestingLevel()\n\t */\n\tpublic @Nullable Integer getTypeIndexForCurrentLevel() {\n\t\treturn getTypeIndexForLevel(this.nestingLevel);\n\t}\n\n\t/**\n\t * Return the type index for the specified nesting level.\n\t * @param nestingLevel the nesting level to check\n\t * @return the corresponding type index, or {@code null}\n\t * if none specified (indicating the default type index)\n\t */\n\tpublic @Nullable Integer getTypeIndexForLevel(int nestingLevel) {\n\t\treturn getTypeIndexesPerLevel().get(nestingLevel);\n\t}\n\n\t/**\n\t * Obtain the (lazily constructed) type-indexes-per-level Map.\n\t */\n\tprivate Map<Integer, Integer> getTypeIndexesPerLevel() {\n\t\tif (this.typeIndexesPerLevel == null) {\n\t\t\tthis.typeIndexesPerLevel = new HashMap<>(4);\n\t\t}\n\t\treturn this.typeIndexesPerLevel;\n\t}\n\n\t/**\n\t * Return a variant of this {@code MethodParameter} which points to the\n\t * same parameter but one nesting level deeper.\n\t * @since 4.3\n\t */\n\tpublic MethodParameter nested() {\n\t\treturn nested(null);\n\t}\n\n\t/**\n\t * Return a variant of this {@code MethodParameter} which points to the\n\t * same parameter but one nesting level deeper.\n\t * @param typeIndex the type index for the new nesting level\n\t * @since 5.2\n\t */\n\tpublic MethodParameter nested(@Nullable Integer typeIndex) {\n\t\tMethodParameter nestedParam = this.nestedMethodParameter;\n\t\tif (nestedParam != null && typeIndex == null) {\n\t\t\treturn nestedParam;\n\t\t}\n\t\tnestedParam = nested(this.nestingLevel + 1, typeIndex);\n\t\tif (typeIndex == null) {\n\t\t\tthis.nestedMethodParameter = nestedParam;\n\t\t}\n\t\treturn nestedParam;\n\t}\n\n\tprivate MethodParameter nested(int nestingLevel, @Nullable Integer typeIndex) {\n\t\tMethodParameter copy = clone();\n\t\tcopy.nestingLevel = nestingLevel;\n\t\tif (this.typeIndexesPerLevel != null) {\n\t\t\tcopy.typeIndexesPerLevel = new HashMap<>(this.typeIndexesPerLevel);\n\t\t}\n\t\tif (typeIndex != null) {\n\t\t\tcopy.getTypeIndexesPerLevel().put(copy.nestingLevel, typeIndex);\n\t\t}\n\t\tcopy.parameterType = null;\n\t\tcopy.genericParameterType = null;\n\t\treturn copy;\n\t}\n\n\t/**\n\t * Return whether this method indicates a parameter which is not required:\n\t * either in the form of Java 8's {@link java.util.Optional}, JSpecify annotations,\n\t * any variant of a parameter-level {@code @Nullable} annotation (such as from Spring,\n\t * JSR-305 or Jakarta set of annotations), a language-level nullable type\n\t * declaration or {@code Continuation} parameter in Kotlin.\n\t * @since 4.3\n\t * @see Nullness#forMethodParameter(MethodParameter)\n\t */\n\tpublic boolean isOptional() {\n\t\treturn (getParameterType() == Optional.class || Nullness.forMethodParameter(this) == Nullness.NULLABLE ||\n\t\t\t\t(KotlinDetector.isKotlinType(getContainingClass()) && KotlinDelegate.isOptional(this)));\n\t}\n\n\t/**\n\t * Return a variant of this {@code MethodParameter} which points to\n\t * the same parameter but one nesting level deeper in case of a\n\t * {@link java.util.Optional} declaration.\n\t * @since 4.3\n\t * @see #isOptional()\n\t * @see #nested()\n\t */\n\tpublic MethodParameter nestedIfOptional() {\n\t\treturn (getParameterType() == Optional.class ? nested() : this);\n\t}\n\n\t/**\n\t * Return a variant of this {@code MethodParameter} which refers to the\n\t * given containing class.\n\t * @param containingClass a specific containing class (potentially a\n\t * subclass of the declaring class, for example, substituting a type variable)\n\t * @since 5.2\n\t * @see #getParameterType()\n\t */\n\tpublic MethodParameter withContainingClass(@Nullable Class<?> containingClass) {\n\t\tMethodParameter result = clone();\n\t\tresult.containingClass = containingClass;\n\t\tresult.parameterType = null;\n\t\treturn result;\n\t}\n\n\t/**\n\t * Set a containing class to resolve the parameter type against.\n\t */\n\t@Deprecated\n\tvoid setContainingClass(Class<?> containingClass) {\n\t\tthis.containingClass = containingClass;\n\t\tthis.parameterType = null;\n\t}\n\n\t/**\n\t * Return the containing class for this method parameter.\n\t * @return a specific containing class (potentially a subclass of the\n\t * declaring class), or otherwise simply the declaring class itself\n\t * @see #getDeclaringClass()\n\t */\n\tpublic Class<?> getContainingClass() {\n\t\tClass<?> containingClass = this.containingClass;\n\t\treturn (containingClass != null ? containingClass : getDeclaringClass());\n\t}\n\n\t/**\n\t * Set a resolved (generic) parameter type.\n\t */\n\t@Deprecated\n\tvoid setParameterType(@Nullable Class<?> parameterType) {\n\t\tthis.parameterType = parameterType;\n\t}\n\n\t/**\n\t * Return the type of the method/constructor parameter.\n\t * @return the parameter type (never {@code null})\n\t */\n\tpublic Class<?> getParameterType() {\n\t\tClass<?> paramType = this.parameterType;\n\t\tif (paramType != null) {\n\t\t\treturn paramType;\n\t\t}\n\t\tif (getContainingClass() != getDeclaringClass()) {\n\t\t\tparamType = ResolvableType.forMethodParameter(this, null, 1).resolve();\n\t\t}\n\t\tif (paramType == null) {\n\t\t\tparamType = computeParameterType();\n\t\t}\n\t\tthis.parameterType = paramType;\n\t\treturn paramType;\n\t}\n\n\t/**\n\t * Return the generic type of the method/constructor parameter.\n\t * @return the parameter type (never {@code null})\n\t * @since 3.0\n\t */\n\tpublic Type getGenericParameterType() {\n\t\tType paramType = this.genericParameterType;\n\t\tif (paramType == null) {\n\t\t\tif (this.parameterIndex < 0) {\n\t\t\t\tMethod method = getMethod();\n\t\t\t\tparamType = (method != null ?\n\t\t\t\t\t\t(KotlinDetector.isKotlinType(getContainingClass()) ?\n\t\t\t\t\t\t\t\tKotlinDelegate.getGenericReturnType(method) : method.getGenericReturnType()) : void.class);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tType[] genericParameterTypes = this.executable.getGenericParameterTypes();\n\t\t\t\tint index = this.parameterIndex;\n\t\t\t\tif (this.executable instanceof Constructor &&\n\t\t\t\t\t\tClassUtils.isInnerClass(this.executable.getDeclaringClass()) &&\n\t\t\t\t\t\tgenericParameterTypes.length == this.executable.getParameterCount() - 1) {\n\t\t\t\t\t// Bug in javac: type array excludes enclosing instance parameter\n\t\t\t\t\t// for inner classes with at least one generic constructor parameter,\n\t\t\t\t\t// so access it with the actual parameter index lowered by 1\n\t\t\t\t\tindex = this.parameterIndex - 1;\n\t\t\t\t}\n\t\t\t\tparamType = (index >= 0 && index < genericParameterTypes.length ?\n\t\t\t\t\t\tgenericParameterTypes[index] : computeParameterType());\n\t\t\t}\n\t\t\tthis.genericParameterType = paramType;\n\t\t}\n\t\treturn paramType;\n\t}\n\n\tprivate Class<?> computeParameterType() {\n\t\tif (this.parameterIndex < 0) {\n\t\t\tMethod method = getMethod();\n\t\t\tif (method == null) {\n\t\t\t\treturn void.class;\n\t\t\t}\n\t\t\tif (KotlinDetector.isKotlinType(getContainingClass())) {\n\t\t\t\treturn KotlinDelegate.getReturnType(method);\n\t\t\t}\n\t\t\treturn method.getReturnType();\n\t\t}\n\t\treturn this.executable.getParameterTypes()[this.parameterIndex];\n\t}\n\n\t/**\n\t * Return the nested type of the method/constructor parameter.\n\t * @return the parameter type (never {@code null})\n\t * @since 3.1\n\t * @see #getNestingLevel()\n\t */\n\tpublic Class<?> getNestedParameterType() {\n\t\tif (this.nestingLevel > 1) {\n\t\t\tType type = getGenericParameterType();\n\t\t\tfor (int i = 2; i <= this.nestingLevel; i++) {\n\t\t\t\tif (type instanceof ParameterizedType parameterizedType) {\n\t\t\t\t\tType[] args = parameterizedType.getActualTypeArguments();\n\t\t\t\t\tInteger index = getTypeIndexForLevel(i);\n\t\t\t\t\ttype = args[index != null ? index : args.length - 1];\n\t\t\t\t}\n\t\t\t\t// TODO: Object.class if unresolvable\n\t\t\t}\n\t\t\tif (type instanceof Class<?> clazz) {\n\t\t\t\treturn clazz;\n\t\t\t}\n\t\t\telse if (type instanceof ParameterizedType parameterizedType) {\n\t\t\t\tType arg = parameterizedType.getRawType();\n\t\t\t\tif (arg instanceof Class<?> clazz) {\n\t\t\t\t\treturn clazz;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Object.class;\n\t\t}\n\t\telse {\n\t\t\treturn getParameterType();\n\t\t}\n\t}\n\n\t/**\n\t * Return the nested generic type of the method/constructor parameter.\n\t * @return the parameter type (never {@code null})\n\t * @since 4.2\n\t * @see #getNestingLevel()\n\t */\n\tpublic Type getNestedGenericParameterType() {\n\t\tif (this.nestingLevel > 1) {\n\t\t\tType type = getGenericParameterType();\n\t\t\tfor (int i = 2; i <= this.nestingLevel; i++) {\n\t\t\t\tif (type instanceof ParameterizedType parameterizedType) {\n\t\t\t\t\tType[] args = parameterizedType.getActualTypeArguments();\n\t\t\t\t\tInteger index = getTypeIndexForLevel(i);\n\t\t\t\t\ttype = args[index != null ? index : args.length - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn type;\n\t\t}\n\t\telse {\n\t\t\treturn getGenericParameterType();\n\t\t}\n\t}\n\n\t/**\n\t * Return the annotations associated with the target method/constructor itself.\n\t */\n\tpublic Annotation[] getMethodAnnotations() {\n\t\treturn adaptAnnotationArray(getAnnotatedElement().getAnnotations());\n\t}\n\n\t/**\n\t * Return the method/constructor annotation of the given type, if available.\n\t * @param annotationType the annotation type to look for\n\t * @return the annotation object, or {@code null} if not found\n\t */\n\tpublic <A extends Annotation> @Nullable A getMethodAnnotation(Class<A> annotationType) {\n\t\tA annotation = getAnnotatedElement().getAnnotation(annotationType);\n\t\treturn (annotation != null ? adaptAnnotation(annotation) : null);\n\t}\n\n\t/**\n\t * Return whether the method/constructor is annotated with the given type.\n\t * @param annotationType the annotation type to look for\n\t * @since 4.3\n\t * @see #getMethodAnnotation(Class)\n\t */\n\tpublic <A extends Annotation> boolean hasMethodAnnotation(Class<A> annotationType) {\n\t\treturn getAnnotatedElement().isAnnotationPresent(annotationType);\n\t}\n\n\t/**\n\t * Return the annotations associated with the specific method/constructor parameter.\n\t */\n\tpublic Annotation[] getParameterAnnotations() {\n\t\tAnnotation[] paramAnns = this.parameterAnnotations;\n\t\tif (paramAnns == null) {\n\t\t\tAnnotation[][] annotationArray = this.executable.getParameterAnnotations();\n\t\t\tint index = this.parameterIndex;\n\t\t\tif (this.executable instanceof Constructor &&\n\t\t\t\t\tClassUtils.isInnerClass(this.executable.getDeclaringClass()) &&\n\t\t\t\t\tannotationArray.length == this.executable.getParameterCount() - 1) {\n\t\t\t\t// Bug in javac in JDK <9: annotation array excludes enclosing instance parameter\n\t\t\t\t// for inner classes, so access it with the actual parameter index lowered by 1\n\t\t\t\tindex = this.parameterIndex - 1;\n\t\t\t}\n\t\t\tparamAnns = (index >= 0 && index < annotationArray.length && annotationArray[index].length > 0 ?\n\t\t\t\t\tadaptAnnotationArray(annotationArray[index]) : EMPTY_ANNOTATION_ARRAY);\n\t\t\tthis.parameterAnnotations = paramAnns;\n\t\t}\n\t\treturn paramAnns;\n\t}\n\n\t/**\n\t * Return {@code true} if the parameter has at least one annotation,\n\t * {@code false} if it has none.\n\t * @see #getParameterAnnotations()\n\t */\n\tpublic boolean hasParameterAnnotations() {\n\t\treturn (getParameterAnnotations().length != 0);\n\t}\n\n\t/**\n\t * Return the parameter annotation of the given type, if available.\n\t * @param annotationType the annotation type to look for\n\t * @return the annotation object, or {@code null} if not found\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <A extends Annotation> @Nullable A getParameterAnnotation(Class<A> annotationType) {\n\t\tAnnotation[] anns = getParameterAnnotations();\n\t\tfor (Annotation ann : anns) {\n\t\t\tif (annotationType.isInstance(ann)) {\n\t\t\t\treturn (A) ann;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Return whether the parameter is declared with the given annotation type.\n\t * @param annotationType the annotation type to look for\n\t * @see #getParameterAnnotation(Class)\n\t */\n\tpublic <A extends Annotation> boolean hasParameterAnnotation(Class<A> annotationType) {\n\t\treturn (getParameterAnnotation(annotationType) != null);\n\t}\n\n\t/**\n\t * Initialize parameter name discovery for this method parameter.\n\t * <p>This method does not actually try to retrieve the parameter name at\n\t * this point; it just allows discovery to happen when the application calls\n\t * {@link #getParameterName()} (if ever).\n\t */\n\tpublic void initParameterNameDiscovery(@Nullable ParameterNameDiscoverer parameterNameDiscoverer) {\n\t\tthis.parameterNameDiscoverer = parameterNameDiscoverer;\n\t}\n\n\t/**\n\t * Return the name of the method/constructor parameter.\n\t * @return the parameter name (may be {@code null} if no\n\t * parameter name metadata is contained in the class file or no\n\t * {@link #initParameterNameDiscovery ParameterNameDiscoverer}\n\t * has been set to begin with)\n\t */\n\tpublic @Nullable String getParameterName() {\n\t\tif (this.parameterIndex < 0) {\n\t\t\treturn null;\n\t\t}\n\t\tParameterNameDiscoverer discoverer = this.parameterNameDiscoverer;\n\t\tif (discoverer != null) {\n\t\t\t@Nullable String[] parameterNames = null;\n\t\t\tif (this.executable instanceof Method method) {\n\t\t\t\tparameterNames = discoverer.getParameterNames(method);\n\t\t\t}\n\t\t\telse if (this.executable instanceof Constructor<?> constructor) {\n\t\t\t\tparameterNames = discoverer.getParameterNames(constructor);\n\t\t\t}\n\t\t\tif (parameterNames != null && this.parameterIndex < parameterNames.length) {\n\t\t\t\tthis.parameterName = parameterNames[this.parameterIndex];\n\t\t\t}\n\t\t\tthis.parameterNameDiscoverer = null;\n\t\t}\n\t\treturn this.parameterName;\n\t}\n\n\n\t/**\n\t * A template method to post-process a given annotation instance before\n\t * returning it to the caller.\n\t * <p>The default implementation simply returns the given annotation as-is.\n\t * @param annotation the annotation about to be returned\n\t * @return the post-processed annotation (or simply the original one)\n\t * @since 4.2\n\t */\n\tprotected <A extends Annotation> A adaptAnnotation(A annotation) {\n\t\treturn annotation;\n\t}\n\n\t/**\n\t * A template method to post-process a given annotation array before\n\t * returning it to the caller.\n\t * <p>The default implementation simply returns the given annotation array as-is.\n\t * @param annotations the annotation array about to be returned\n\t * @return the post-processed annotation array (or simply the original one)\n\t * @since 4.2\n\t */\n\tprotected Annotation[] adaptAnnotationArray(Annotation[] annotations) {\n\t\treturn annotations;\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof MethodParameter that &&\n\t\t\t\tgetContainingClass() == that.getContainingClass() &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.typeIndexesPerLevel, that.typeIndexesPerLevel) &&\n\t\t\t\tthis.nestingLevel == that.nestingLevel &&\n\t\t\t\tthis.parameterIndex == that.parameterIndex &&\n\t\t\t\tthis.executable.equals(that.executable)));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn (31 * this.executable.hashCode() + this.parameterIndex);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tMethod method = getMethod();\n\t\treturn (method != null ? \"method '\" + method.getName() + \"'\" : \"constructor\") +\n\t\t\t\t\" parameter \" + this.parameterIndex;\n\t}\n\n\t@Override\n\tpublic MethodParameter clone() {\n\t\treturn new MethodParameter(this);\n\t}\n\n\n\t/**\n\t * Create a new MethodParameter for the given method or constructor.\n\t * <p>This is a convenience factory method for scenarios where a\n\t * Method or Constructor reference is treated in a generic fashion.\n\t * @param methodOrConstructor the Method or Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @return the corresponding MethodParameter instance\n\t * @deprecated as of 5.0, in favor of {@link #forExecutable}\n\t */\n\t@Deprecated\n\tpublic static MethodParameter forMethodOrConstructor(Object methodOrConstructor, int parameterIndex) {\n\t\tif (!(methodOrConstructor instanceof Executable executable)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Given object [\" + methodOrConstructor + \"] is neither a Method nor a Constructor\");\n\t\t}\n\t\treturn forExecutable(executable, parameterIndex);\n\t}\n\n\t/**\n\t * Create a new MethodParameter for the given method or constructor.\n\t * <p>This is a convenience factory method for scenarios where a\n\t * Method or Constructor reference is treated in a generic fashion.\n\t * @param executable the Method or Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @return the corresponding MethodParameter instance\n\t * @since 5.0\n\t */\n\tpublic static MethodParameter forExecutable(Executable executable, int parameterIndex) {\n\t\tif (executable instanceof Method method) {\n\t\t\treturn new MethodParameter(method, parameterIndex);\n\t\t}\n\t\telse if (executable instanceof Constructor<?> constructor) {\n\t\t\treturn new MethodParameter(constructor, parameterIndex);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Not a Method/Constructor: \" + executable);\n\t\t}\n\t}\n\n\t/**\n\t * Create a new MethodParameter for the given parameter descriptor.\n\t * <p>This is a convenience factory method for scenarios where a\n\t * Java 8 {@link Parameter} descriptor is already available.\n\t * @param parameter the parameter descriptor\n\t * @return the corresponding MethodParameter instance\n\t * @since 5.0\n\t */\n\tpublic static MethodParameter forParameter(Parameter parameter) {\n\t\treturn forExecutable(parameter.getDeclaringExecutable(), findParameterIndex(parameter));\n\t}\n\n\tprotected static int findParameterIndex(Parameter parameter) {\n\t\tExecutable executable = parameter.getDeclaringExecutable();\n\t\tParameter[] allParams = executable.getParameters();\n\t\t// Try first with identity checks for greater performance.\n\t\tfor (int i = 0; i < allParams.length; i++) {\n\t\t\tif (parameter == allParams[i]) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\t// Potentially try again with object equality checks in order to avoid race\n\t\t// conditions while invoking java.lang.reflect.Executable.getParameters().\n\t\tfor (int i = 0; i < allParams.length; i++) {\n\t\t\tif (parameter.equals(allParams[i])) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Given parameter [\" + parameter +\n\t\t\t\t\"] does not match any parameter in the declaring executable\");\n\t}\n\n\tprivate static int validateIndex(Executable executable, int parameterIndex) {\n\t\tint count = executable.getParameterCount();\n\t\tAssert.isTrue(parameterIndex >= -1 && parameterIndex < count,\n\t\t\t\t() -> \"Parameter index needs to be between -1 and \" + (count - 1));\n\t\treturn parameterIndex;\n\t}\n\n\t/**\n\t * Create a new MethodParameter for the given field-aware constructor,\n\t * for example, on a data class or record type.\n\t * <p>A field-aware method parameter will detect field annotations as well,\n\t * as long as the field name matches the parameter name.\n\t * @param ctor the Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @param fieldName the name of the underlying field,\n\t * matching the constructor's parameter name\n\t * @return the corresponding MethodParameter instance\n\t * @since 6.1\n\t */\n\tpublic static MethodParameter forFieldAwareConstructor(Constructor<?> ctor, int parameterIndex, @Nullable String fieldName) {\n\t\treturn new FieldAwareConstructorParameter(ctor, parameterIndex, fieldName);\n\t}\n\n\n\t/**\n\t * {@link MethodParameter} subclass which detects field annotations as well.\n\t */\n\tprivate static class FieldAwareConstructorParameter extends MethodParameter {\n\n\t\tprivate volatile Annotation @Nullable [] combinedAnnotations;\n\n\t\tpublic FieldAwareConstructorParameter(Constructor<?> constructor, int parameterIndex, @Nullable String fieldName) {\n\t\t\tsuper(constructor, parameterIndex);\n\t\t\tthis.parameterName = fieldName;\n\t\t}\n\n\t\t@Override\n\t\tpublic Annotation[] getParameterAnnotations() {\n\t\t\tString parameterName = this.parameterName;\n\t\t\tAssert.state(parameterName != null, \"Parameter name not initialized\");\n\n\t\t\tAnnotation[] anns = this.combinedAnnotations;\n\t\t\tif (anns == null) {\n\t\t\t\tanns = super.getParameterAnnotations();\n\t\t\t\ttry {\n\t\t\t\t\tField field = getDeclaringClass().getDeclaredField(parameterName);\n\t\t\t\t\tAnnotation[] fieldAnns = field.getAnnotations();\n\t\t\t\t\tif (fieldAnns.length > 0) {\n\t\t\t\t\t\tList<Annotation> merged = new ArrayList<>(anns.length + fieldAnns.length);\n\t\t\t\t\t\tmerged.addAll(Arrays.asList(anns));\n\t\t\t\t\t\tfor (Annotation fieldAnn : fieldAnns) {\n\t\t\t\t\t\t\tboolean existingType = false;\n\t\t\t\t\t\t\tfor (Annotation ann : anns) {\n\t\t\t\t\t\t\t\tif (ann.annotationType() == fieldAnn.annotationType()) {\n\t\t\t\t\t\t\t\t\texistingType = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!existingType) {\n\t\t\t\t\t\t\t\tmerged.add(fieldAnn);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tanns = merged.toArray(EMPTY_ANNOTATION_ARRAY);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFieldException | SecurityException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t\tthis.combinedAnnotations = anns;\n\t\t\t}\n\t\t\treturn anns;\n\t\t}\n\t}\n\n\n\t/**\n\t * Inner class to avoid a hard dependency on Kotlin at runtime.\n\t */\n\tprivate static class KotlinDelegate {\n\n\t\t/**\n\t\t * Check whether the specified {@link MethodParameter} represents a nullable Kotlin type,\n\t\t * an optional parameter (with a default value in the Kotlin declaration) or a\n\t\t * {@code Continuation} parameter used in suspending functions.\n\t\t */\n\t\tpublic static boolean isOptional(MethodParameter param) {\n\t\t\tMethod method = param.getMethod();\n\t\t\tint index = param.getParameterIndex();\n\t\t\tif (method != null && index == -1) {\n\t\t\t\tKFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\n\t\t\t\treturn (function != null && function.getReturnType().isMarkedNullable());\n\t\t\t}\n\t\t\tKFunction<?> function;\n\t\t\tPredicate<KParameter> predicate;\n\t\t\tif (method != null) {\n\t\t\t\tif (param.getParameterType().getName().equals(\"kotlin.coroutines.Continuation\")) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tfunction = ReflectJvmMapping.getKotlinFunction(method);\n\t\t\t\tpredicate = p -> KParameter.Kind.VALUE.equals(p.getKind());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tConstructor<?> ctor = param.getConstructor();\n\t\t\t\tAssert.state(ctor != null, \"Neither method nor constructor found\");\n\t\t\t\tfunction = ReflectJvmMapping.getKotlinFunction(ctor);\n\t\t\t\tpredicate = p -> (KParameter.Kind.VALUE.equals(p.getKind()) ||\n\t\t\t\t\t\tKParameter.Kind.INSTANCE.equals(p.getKind()));\n\t\t\t}\n\t\t\tif (function != null) {\n\t\t\t\tint i = 0;\n\t\t\t\tfor (KParameter kParameter : function.getParameters()) {\n\t\t\t\t\tif (predicate.test(kParameter)) {\n\t\t\t\t\t\tif (index == i++) {\n\t\t\t\t\t\t\treturn (kParameter.getType().isMarkedNullable() || kParameter.isOptional());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * Return the generic return type of the method, with support of suspending\n\t\t * functions via Kotlin reflection.\n\t\t */\n\t\tprivate static Type getGenericReturnType(Method method) {\n\t\t\ttry {\n\t\t\t\tKFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\n\t\t\t\tif (function != null && function.isSuspend()) {\n\t\t\t\t\treturn ReflectJvmMapping.getJavaType(function.getReturnType());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (UnsupportedOperationException ex) {\n\t\t\t\t// probably a synthetic class - let's use java reflection instead\n\t\t\t}\n\t\t\treturn method.getGenericReturnType();\n\t\t}\n\n\t\t/**\n\t\t * Return the return type of the method, with support of suspending\n\t\t * functions via Kotlin reflection.\n\t\t */\n\t\tprivate static Class<?> getReturnType(Method method) {\n\t\t\ttry {\n\t\t\t\tKFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\n\t\t\t\tif (function != null && function.isSuspend()) {\n\t\t\t\t\tType paramType = ReflectJvmMapping.getJavaType(function.getReturnType());\n\t\t\t\t\tif (paramType == Unit.class) {\n\t\t\t\t\t\tparamType = void.class;\n\t\t\t\t\t}\n\t\t\t\t\treturn ResolvableType.forType(paramType).resolve(method.getReturnType());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (UnsupportedOperationException ex) {\n\t\t\t\t// probably a synthetic class - let's use java reflection instead\n\t\t\t}\n\t\t\treturn method.getReturnType();\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.KotlinDelegate#isOptional(MethodParameter)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Check whether the specified {@link MethodParameter} represents a nullable Kotlin type,\r\n * an optional parameter (with a default value in the Kotlin declaration) or a\r\n * {@code Continuation} parameter used in suspending functions.\r\n */\r\npublic static boolean isOptional(MethodParameter param) {\r\n    Method method = param.getMethod();\r\n    int index = param.getParameterIndex();\r\n    if (method != null && index == -1) {\r\n        KFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\r\n        return (function != null && function.getReturnType().isMarkedNullable());\r\n    }\r\n    KFunction<?> function;\r\n    Predicate<KParameter> predicate;\r\n    if (method != null) {\r\n        if (param.getParameterType().getName().equals(\"kotlin.coroutines.Continuation\")) {\r\n            return true;\r\n        }\r\n        function = ReflectJvmMapping.getKotlinFunction(method);\r\n        predicate = p -> KParameter.Kind.VALUE.equals(p.getKind());\r\n    } else {\r\n        Constructor<?> ctor = param.getConstructor();\r\n        Assert.state(ctor != null, \"Neither method nor constructor found\");\r\n        function = ReflectJvmMapping.getKotlinFunction(ctor);\r\n        predicate = p -> (KParameter.Kind.VALUE.equals(p.getKind()) || KParameter.Kind.INSTANCE.equals(p.getKind()));\r\n    }\r\n    if (function != null) {\r\n        int i = 0;\r\n        for (KParameter kParameter : function.getParameters()) {\r\n            if (predicate.test(kParameter)) {\r\n                if (index == i++) {\r\n                    return (kParameter.getType().isMarkedNullable() || kParameter.isOptional());\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.KotlinDelegate",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.KotlinDelegate#isOptional(MethodParameter)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.KotlinDelegate#getGenericReturnType(Method)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Return the generic return type of the method, with support of suspending\r\n * functions via Kotlin reflection.\r\n */\r\nprivate static Type getGenericReturnType(Method method) {\r\n    try {\r\n        KFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\r\n        if (function != null && function.isSuspend()) {\r\n            return ReflectJvmMapping.getJavaType(function.getReturnType());\r\n        }\r\n    } catch (UnsupportedOperationException ex) {\r\n        // probably a synthetic class - let's use java reflection instead\r\n    }\r\n    return method.getGenericReturnType();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.KotlinDelegate",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.KotlinDelegate#getGenericReturnType(Method)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.KotlinDelegate#getReturnType(Method)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Return the return type of the method, with support of suspending\r\n * functions via Kotlin reflection.\r\n */\r\nprivate static Class<?> getReturnType(Method method) {\r\n    try {\r\n        KFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\r\n        if (function != null && function.isSuspend()) {\r\n            Type paramType = ReflectJvmMapping.getJavaType(function.getReturnType());\r\n            if (paramType == Unit.class) {\r\n                paramType = void.class;\r\n            }\r\n            return ResolvableType.forType(paramType).resolve(method.getReturnType());\r\n        }\r\n    } catch (UnsupportedOperationException ex) {\r\n        // probably a synthetic class - let's use java reflection instead\r\n    }\r\n    return method.getReturnType();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.KotlinDelegate",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.KotlinDelegate#getReturnType(Method)",
    "tailType": "method"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.metrics",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core.metrics",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.metrics.ApplicationStartup",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.metrics.ApplicationStartup",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2020 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.metrics;\n\n/**\n * Instruments the application startup phase using {@link StartupStep steps}.\n * <p>The core container and its infrastructure components can use the {@code ApplicationStartup}\n * to mark steps during the application startup and collect data about the execution context\n * or their processing time.\n *\n * @author Brian Clozel\n * @since 5.3\n */\npublic interface ApplicationStartup {\n\n\t/**\n\t * Default \"no op\" {@code ApplicationStartup} implementation.\n\t * <p>This variant is designed for minimal overhead and does not record data.\n\t */\n\tApplicationStartup DEFAULT = new DefaultApplicationStartup();\n\n\t/**\n\t * Create a new step and marks its beginning.\n\t * <p>A step name describes the current action or phase. This technical\n\t * name should be \".\" namespaced and can be reused to describe other instances of\n\t * the same step during application startup.\n\t * @param name the step name\n\t */\n\tStartupStep start(String name);\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.metrics.ApplicationStartup",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.metrics.ApplicationStartup#DEFAULT",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.metrics.ApplicationStartup#DEFAULT",
    "headType": "field",
    "relation": "haveType",
    "tail": "ApplicationStartup",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.metrics.ApplicationStartup#start(String)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Create a new step and marks its beginning.\r\n * <p>A step name describes the current action or phase. This technical\r\n * name should be \".\" namespaced and can be reused to describe other instances of\r\n * the same step during application startup.\r\n * @param name the step name\r\n */\r\nStartupStep start(String name);",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.metrics.ApplicationStartup",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.metrics.ApplicationStartup#start(String)",
    "tailType": "method"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.metrics",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core.metrics",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.metrics.DefaultApplicationStartup",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.metrics.DefaultApplicationStartup",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.metrics;\n\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.function.Supplier;\n\nimport org.jspecify.annotations.Nullable;\n\n/**\n * Default \"no op\" {@code ApplicationStartup} implementation.\n *\n * <p>This variant is designed for minimal overhead and does not record events.\n *\n * @author Brian Clozel\n */\nclass DefaultApplicationStartup implements ApplicationStartup {\n\n\tprivate static final DefaultStartupStep DEFAULT_STARTUP_STEP = new DefaultStartupStep();\n\n\t@Override\n\tpublic DefaultStartupStep start(String name) {\n\t\treturn DEFAULT_STARTUP_STEP;\n\t}\n\n\n\tstatic class DefaultStartupStep implements StartupStep {\n\n\t\tprivate final DefaultTags TAGS = new DefaultTags();\n\n\t\t@Override\n\t\tpublic String getName() {\n\t\t\treturn \"default\";\n\t\t}\n\n\t\t@Override\n\t\tpublic long getId() {\n\t\t\treturn 0L;\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable Long getParentId() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Tags getTags() {\n\t\t\treturn this.TAGS;\n\t\t}\n\n\t\t@Override\n\t\tpublic StartupStep tag(String key, String value) {\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic StartupStep tag(String key, Supplier<String> value) {\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic void end() {\n\t\t}\n\n\n\t\tstatic class DefaultTags implements StartupStep.Tags {\n\n\t\t\t@Override\n\t\t\tpublic Iterator<StartupStep.Tag> iterator() {\n\t\t\t\treturn Collections.emptyIterator();\n\t\t\t}\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.metrics.DefaultApplicationStartup",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.metrics.DefaultApplicationStartup#DEFAULT_STARTUP_STEP",
    "tailType": "field"
  }
]