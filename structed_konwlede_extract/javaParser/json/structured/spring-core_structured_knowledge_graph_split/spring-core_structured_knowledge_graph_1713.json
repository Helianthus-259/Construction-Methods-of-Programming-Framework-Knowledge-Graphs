[
  {
    "head": "org.springframework.core.annotation.RepeatableClass",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedElement;\nimport java.util.Arrays;\nimport java.util.Set;\nimport java.util.stream.Stream;\n\nimport org.assertj.core.api.ThrowableTypeAssert;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.MergedAnnotations.SearchStrategy;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.springframework.core.annotation.MergedAnnotations.SearchStrategy.INHERITED_ANNOTATIONS;\nimport static org.springframework.core.annotation.MergedAnnotations.SearchStrategy.TYPE_HIERARCHY;\n\n/**\n * Tests for {@link MergedAnnotations} and {@link RepeatableContainers} that\n * verify support for repeatable annotations.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n */\nclass MergedAnnotationsRepeatableAnnotationTests {\n\n\t// See SPR-13973\n\n\t@Test\n\tvoid inheritedAnnotationsWhenNonRepeatableThrowsException() {\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(null, NonRepeatable.class, INHERITED_ANNOTATIONS, getClass()))\n\t\t\t\t.satisfies(this::nonRepeatableRequirements);\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenContainerMissingValueAttributeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerMissingValueAttribute.class, InvalidRepeatable.class,\n\t\t\t\t\t\tINHERITED_ANNOTATIONS, getClass()))\n\t\t\t\t.satisfies(this::missingValueAttributeRequirements);\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenWhenNonArrayValueAttributeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerWithNonArrayValueAttribute.class, InvalidRepeatable.class,\n\t\t\t\t\t\tINHERITED_ANNOTATIONS, getClass()))\n\t\t\t\t.satisfies(this::nonArrayValueAttributeRequirements);\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenWrongComponentTypeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerWithArrayValueAttributeButWrongComponentType.class,\n\t\t\t\t\t\tInvalidRepeatable.class, INHERITED_ANNOTATIONS, getClass()))\n\t\t\t\t.satisfies(this::wrongComponentTypeRequirements);\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, RepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenWhenOnSuperclassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, SubRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenComposedOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, ComposedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenComposedMixedWithContainerOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, ComposedRepeatableMixedWithContainerClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenComposedContainerForRepeatableOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, ComposedContainerClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenNoninheritedComposedRepeatableOnClassReturnsAnnotations() {\n\t\tSet<Noninherited> annotations = getAnnotations(null, Noninherited.class,\n\t\t\t\tINHERITED_ANNOTATIONS, NoninheritedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(Noninherited::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenNoninheritedComposedRepeatableOnSuperclassReturnsAnnotations() {\n\t\tSet<Noninherited> annotations = getAnnotations(null, Noninherited.class,\n\t\t\t\tINHERITED_ANNOTATIONS, SubNoninheritedRepeatableClass.class);\n\t\tassertThat(annotations).isEmpty();\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenNonRepeatableThrowsException() {\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(null, NonRepeatable.class, TYPE_HIERARCHY, getClass()))\n\t\t\t\t.satisfies(this::nonRepeatableRequirements);\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenContainerMissingValueAttributeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerMissingValueAttribute.class, InvalidRepeatable.class,\n\t\t\t\t\t\tTYPE_HIERARCHY, getClass()))\n\t\t\t\t.satisfies(this::missingValueAttributeRequirements);\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenWhenNonArrayValueAttributeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerWithNonArrayValueAttribute.class, InvalidRepeatable.class,\n\t\t\t\t\t\tTYPE_HIERARCHY, getClass()))\n\t\t\t\t.satisfies(this::nonArrayValueAttributeRequirements);\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenWrongComponentTypeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerWithArrayValueAttributeButWrongComponentType.class,\n\t\t\t\t\t\tInvalidRepeatable.class, TYPE_HIERARCHY, getClass()))\n\t\t\t\t.satisfies(this::wrongComponentTypeRequirements);\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, RepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenOnSuperclassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, SubRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenComposedOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, ComposedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenComposedMixedWithContainerOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, ComposedRepeatableMixedWithContainerClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenComposedContainerForRepeatableOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, ComposedContainerClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyAnnotationsWhenNoninheritedComposedRepeatableOnClassReturnsAnnotations() {\n\t\tSet<Noninherited> annotations = getAnnotations(null, Noninherited.class,\n\t\t\t\tTYPE_HIERARCHY, NoninheritedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(Noninherited::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyAnnotationsWhenNoninheritedComposedRepeatableOnSuperclassReturnsAnnotations() {\n\t\tSet<Noninherited> annotations = getAnnotations(null, Noninherited.class,\n\t\t\t\tTYPE_HIERARCHY, SubNoninheritedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(Noninherited::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyAnnotationsWithLocalComposedAnnotationWhoseRepeatableMetaAnnotationsAreFiltered() {\n\t\tClass<WithRepeatedMetaAnnotationsClass> element = WithRepeatedMetaAnnotationsClass.class;\n\t\tSearchStrategy searchStrategy = TYPE_HIERARCHY;\n\t\tAnnotationFilter annotationFilter = PeteRepeat.class.getName()::equals;\n\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class, searchStrategy, element, annotationFilter);\n\t\tassertThat(annotations).isEmpty();\n\n\t\tMergedAnnotations mergedAnnotations = MergedAnnotations.from(element, searchStrategy,\n\t\t\t\tRepeatableContainers.standardRepeatables(), annotationFilter);\n\t\tStream<Class<? extends Annotation>> annotationTypes = mergedAnnotations.stream()\n\t\t\t\t.map(MergedAnnotation::synthesize)\n\t\t\t\t.map(Annotation::annotationType);\n\t\tassertThat(annotationTypes).containsExactly(WithRepeatedMetaAnnotations.class, Noninherited.class, Noninherited.class);\n\t}\n\n\t@Test  // gh-32731\n\tvoid searchFindsRepeatableContainerAnnotationAndRepeatedAnnotations() {\n\t\tClass<?> clazz = StandardRepeatablesWithContainerWithMultipleAttributesTestCase.class;\n\n\t\t// NO RepeatableContainers\n\t\tMergedAnnotations mergedAnnotations = MergedAnnotations.from(clazz, TYPE_HIERARCHY, RepeatableContainers.none());\n\t\tContainerWithMultipleAttributes container = mergedAnnotations\n\t\t\t\t.get(ContainerWithMultipleAttributes.class)\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t\tassertThat(container).as(\"container\").isNotNull();\n\t\tassertThat(container.name()).isEqualTo(\"enigma\");\n\t\tRepeatableWithContainerWithMultipleAttributes[] repeatedAnnotations = container.value();\n\t\tassertThat(Arrays.stream(repeatedAnnotations).map(RepeatableWithContainerWithMultipleAttributes::value))\n\t\t\t\t.containsExactly(\"A\", \"B\");\n\t\tSet<RepeatableWithContainerWithMultipleAttributes> set =\n\t\t\t\tmergedAnnotations.stream(RepeatableWithContainerWithMultipleAttributes.class)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t\t// Only finds the locally declared repeated annotation.\n\t\tassertThat(set.stream().map(RepeatableWithContainerWithMultipleAttributes::value))\n\t\t\t\t.containsExactly(\"C\");\n\n\t\t// Standard RepeatableContainers\n\t\tmergedAnnotations = MergedAnnotations.from(clazz, TYPE_HIERARCHY, RepeatableContainers.standardRepeatables());\n\t\tcontainer = mergedAnnotations\n\t\t\t\t.get(ContainerWithMultipleAttributes.class)\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t\tassertThat(container).as(\"container\").isNotNull();\n\t\tassertThat(container.name()).isEqualTo(\"enigma\");\n\t\trepeatedAnnotations = container.value();\n\t\tassertThat(Arrays.stream(repeatedAnnotations).map(RepeatableWithContainerWithMultipleAttributes::value))\n\t\t\t\t.containsExactly(\"A\", \"B\");\n\t\tset = mergedAnnotations.stream(RepeatableWithContainerWithMultipleAttributes.class)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t\t// Finds the locally declared repeated annotation plus the 2 in the container.\n\t\tassertThat(set.stream().map(RepeatableWithContainerWithMultipleAttributes::value))\n\t\t\t\t.containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\tprivate <A extends Annotation> Set<A> getAnnotations(Class<? extends Annotation> container,\n\t\t\tClass<A> repeatable, SearchStrategy searchStrategy, AnnotatedElement element) {\n\n\t\treturn getAnnotations(container, repeatable, searchStrategy, element, AnnotationFilter.PLAIN);\n\t}\n\n\tprivate <A extends Annotation> Set<A> getAnnotations(Class<? extends Annotation> container,\n\t\t\tClass<A> repeatable, SearchStrategy searchStrategy, AnnotatedElement element, AnnotationFilter annotationFilter) {\n\n\t\tRepeatableContainers containers = RepeatableContainers.of(repeatable, container);\n\t\tMergedAnnotations annotations = MergedAnnotations.from(element, searchStrategy, containers, annotationFilter);\n\t\treturn annotations.stream(repeatable).collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}\n\n\tprivate void nonRepeatableRequirements(Exception ex) {\n\t\tassertThat(ex)\n\t\t\t\t.hasMessageStartingWith(\"Annotation type must be a repeatable annotation\")\n\t\t\t\t.hasMessageContaining(\"failed to resolve container type for\", NonRepeatable.class.getName());\n\t}\n\n\tprivate void missingValueAttributeRequirements(Exception ex) {\n\t\tassertThat(ex)\n\t\t\t\t.hasMessageStartingWith(\"Invalid declaration of container type\")\n\t\t\t\t.hasMessageContaining(\n\t\t\t\t\t\tContainerMissingValueAttribute.class.getName(),\n\t\t\t\t\t\t\"for repeatable annotation\",\n\t\t\t\t\t\tInvalidRepeatable.class.getName())\n\t\t\t\t.hasCauseInstanceOf(NoSuchMethodException.class);\n\t}\n\n\tprivate void nonArrayValueAttributeRequirements(Exception ex) {\n\t\tassertThat(ex)\n\t\t\t\t.hasMessageStartingWith(\"Container type\")\n\t\t\t\t.hasMessageContaining(\n\t\t\t\t\t\tContainerWithNonArrayValueAttribute.class.getName(),\n\t\t\t\t\t\t\"must declare a 'value' attribute for an array of type\",\n\t\t\t\t\t\tInvalidRepeatable.class.getName());\n\t}\n\n\tprivate void wrongComponentTypeRequirements(Exception ex) {\n\t\tassertThat(ex)\n\t\t\t\t.hasMessageStartingWith(\"Container type\")\n\t\t\t\t.hasMessageContaining(\n\t\t\t\t\t\tContainerWithArrayValueAttributeButWrongComponentType.class.getName(),\n\t\t\t\t\t\t\"must declare a 'value' attribute for an array of type\",\n\t\t\t\t\t\tInvalidRepeatable.class.getName());\n\t}\n\n\tprivate static ThrowableTypeAssert<AnnotationConfigurationException> assertThatAnnotationConfigurationException() {\n\t\treturn assertThatExceptionOfType(AnnotationConfigurationException.class);\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface NonRepeatable {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContainerMissingValueAttribute {\n\n\t\t// InvalidRepeatable[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContainerWithNonArrayValueAttribute {\n\n\t\tInvalidRepeatable value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContainerWithArrayValueAttributeButWrongComponentType {\n\n\t\tString[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface InvalidRepeatable {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface PeteRepeats {\n\n\t\tPeteRepeat[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@Repeatable(PeteRepeats.class)\n\t@interface PeteRepeat {\n\n\t\tString value();\n\t}\n\n\t@PeteRepeat(\"shadowed\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface ForPetesSake {\n\n\t\t@AliasFor(annotation = PeteRepeat.class)\n\t\tString value();\n\t}\n\n\t@PeteRepeat(\"shadowed\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface ForTheLoveOfFoo {\n\n\t\t@AliasFor(annotation = PeteRepeat.class)\n\t\tString value();\n\t}\n\n\t@PeteRepeats({ @PeteRepeat(\"B\"), @PeteRepeat(\"C\") })\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface ComposedContainer {\n\t}\n\n\t@PeteRepeat(\"A\")\n\t@PeteRepeats({ @PeteRepeat(\"B\"), @PeteRepeat(\"C\") })\n\tstatic class RepeatableClass {\n\t}\n\n\tstatic class SubRepeatableClass extends RepeatableClass {\n\t}\n\n\t@ForPetesSake(\"B\")\n\t@ForTheLoveOfFoo(\"C\")\n\t@PeteRepeat(\"A\")\n\tstatic class ComposedRepeatableClass {\n\t}\n\n\t@ForPetesSake(\"C\")\n\t@PeteRepeats(@PeteRepeat(\"A\"))\n\t@PeteRepeat(\"B\")\n\tstatic class ComposedRepeatableMixedWithContainerClass {\n\t}\n\n\t@PeteRepeat(\"A\")\n\t@ComposedContainer\n\tstatic class ComposedContainerClass {\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Noninheriteds {\n\n\t\tNoninherited[] value();\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(Noninheriteds.class)\n\t@interface Noninherited {\n\n\t\t@AliasFor(\"name\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString name() default \"\";\n\t}\n\n\t@Noninherited(name = \"shadowed\")\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedNoninherited {\n\n\t\t@AliasFor(annotation = Noninherited.class)\n\t\tString name() default \"\";\n\t}\n\n\t@ComposedNoninherited(name = \"C\")\n\t@Noninheriteds({ @Noninherited(value = \"A\"), @Noninherited(name = \"B\") })\n\tstatic class NoninheritedRepeatableClass {\n\t}\n\n\tstatic class SubNoninheritedRepeatableClass extends NoninheritedRepeatableClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@PeteRepeat(\"A\")\n\t@PeteRepeat(\"B\")\n\t@interface WithRepeatedMetaAnnotations {\n\t}\n\n\t@WithRepeatedMetaAnnotations\n\t@PeteRepeat(\"C\")\n\t@Noninherited(\"X\")\n\t@Noninherited(\"Y\")\n\tstatic class WithRepeatedMetaAnnotationsClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContainerWithMultipleAttributes {\n\n\t\tRepeatableWithContainerWithMultipleAttributes[] value();\n\n\t\tString name() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(ContainerWithMultipleAttributes.class)\n\t@interface RepeatableWithContainerWithMultipleAttributes {\n\n\t\tString value() default \"\";\n\t}\n\n\t@ContainerWithMultipleAttributes(name = \"enigma\", value = {\n\t\t@RepeatableWithContainerWithMultipleAttributes(\"A\"),\n\t\t@RepeatableWithContainerWithMultipleAttributes(\"B\")\n\t})\n\t@RepeatableWithContainerWithMultipleAttributes(\"C\")\n\tstatic class StandardRepeatablesWithContainerWithMultipleAttributesTestCase {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.SubRepeatableClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.SubRepeatableClass",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedElement;\nimport java.util.Arrays;\nimport java.util.Set;\nimport java.util.stream.Stream;\n\nimport org.assertj.core.api.ThrowableTypeAssert;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.MergedAnnotations.SearchStrategy;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.springframework.core.annotation.MergedAnnotations.SearchStrategy.INHERITED_ANNOTATIONS;\nimport static org.springframework.core.annotation.MergedAnnotations.SearchStrategy.TYPE_HIERARCHY;\n\n/**\n * Tests for {@link MergedAnnotations} and {@link RepeatableContainers} that\n * verify support for repeatable annotations.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n */\nclass MergedAnnotationsRepeatableAnnotationTests {\n\n\t// See SPR-13973\n\n\t@Test\n\tvoid inheritedAnnotationsWhenNonRepeatableThrowsException() {\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(null, NonRepeatable.class, INHERITED_ANNOTATIONS, getClass()))\n\t\t\t\t.satisfies(this::nonRepeatableRequirements);\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenContainerMissingValueAttributeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerMissingValueAttribute.class, InvalidRepeatable.class,\n\t\t\t\t\t\tINHERITED_ANNOTATIONS, getClass()))\n\t\t\t\t.satisfies(this::missingValueAttributeRequirements);\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenWhenNonArrayValueAttributeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerWithNonArrayValueAttribute.class, InvalidRepeatable.class,\n\t\t\t\t\t\tINHERITED_ANNOTATIONS, getClass()))\n\t\t\t\t.satisfies(this::nonArrayValueAttributeRequirements);\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenWrongComponentTypeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerWithArrayValueAttributeButWrongComponentType.class,\n\t\t\t\t\t\tInvalidRepeatable.class, INHERITED_ANNOTATIONS, getClass()))\n\t\t\t\t.satisfies(this::wrongComponentTypeRequirements);\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, RepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenWhenOnSuperclassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, SubRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenComposedOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, ComposedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenComposedMixedWithContainerOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, ComposedRepeatableMixedWithContainerClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenComposedContainerForRepeatableOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, ComposedContainerClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenNoninheritedComposedRepeatableOnClassReturnsAnnotations() {\n\t\tSet<Noninherited> annotations = getAnnotations(null, Noninherited.class,\n\t\t\t\tINHERITED_ANNOTATIONS, NoninheritedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(Noninherited::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenNoninheritedComposedRepeatableOnSuperclassReturnsAnnotations() {\n\t\tSet<Noninherited> annotations = getAnnotations(null, Noninherited.class,\n\t\t\t\tINHERITED_ANNOTATIONS, SubNoninheritedRepeatableClass.class);\n\t\tassertThat(annotations).isEmpty();\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenNonRepeatableThrowsException() {\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(null, NonRepeatable.class, TYPE_HIERARCHY, getClass()))\n\t\t\t\t.satisfies(this::nonRepeatableRequirements);\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenContainerMissingValueAttributeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerMissingValueAttribute.class, InvalidRepeatable.class,\n\t\t\t\t\t\tTYPE_HIERARCHY, getClass()))\n\t\t\t\t.satisfies(this::missingValueAttributeRequirements);\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenWhenNonArrayValueAttributeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerWithNonArrayValueAttribute.class, InvalidRepeatable.class,\n\t\t\t\t\t\tTYPE_HIERARCHY, getClass()))\n\t\t\t\t.satisfies(this::nonArrayValueAttributeRequirements);\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenWrongComponentTypeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerWithArrayValueAttributeButWrongComponentType.class,\n\t\t\t\t\t\tInvalidRepeatable.class, TYPE_HIERARCHY, getClass()))\n\t\t\t\t.satisfies(this::wrongComponentTypeRequirements);\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, RepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenOnSuperclassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, SubRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenComposedOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, ComposedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenComposedMixedWithContainerOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, ComposedRepeatableMixedWithContainerClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenComposedContainerForRepeatableOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, ComposedContainerClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyAnnotationsWhenNoninheritedComposedRepeatableOnClassReturnsAnnotations() {\n\t\tSet<Noninherited> annotations = getAnnotations(null, Noninherited.class,\n\t\t\t\tTYPE_HIERARCHY, NoninheritedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(Noninherited::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyAnnotationsWhenNoninheritedComposedRepeatableOnSuperclassReturnsAnnotations() {\n\t\tSet<Noninherited> annotations = getAnnotations(null, Noninherited.class,\n\t\t\t\tTYPE_HIERARCHY, SubNoninheritedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(Noninherited::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyAnnotationsWithLocalComposedAnnotationWhoseRepeatableMetaAnnotationsAreFiltered() {\n\t\tClass<WithRepeatedMetaAnnotationsClass> element = WithRepeatedMetaAnnotationsClass.class;\n\t\tSearchStrategy searchStrategy = TYPE_HIERARCHY;\n\t\tAnnotationFilter annotationFilter = PeteRepeat.class.getName()::equals;\n\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class, searchStrategy, element, annotationFilter);\n\t\tassertThat(annotations).isEmpty();\n\n\t\tMergedAnnotations mergedAnnotations = MergedAnnotations.from(element, searchStrategy,\n\t\t\t\tRepeatableContainers.standardRepeatables(), annotationFilter);\n\t\tStream<Class<? extends Annotation>> annotationTypes = mergedAnnotations.stream()\n\t\t\t\t.map(MergedAnnotation::synthesize)\n\t\t\t\t.map(Annotation::annotationType);\n\t\tassertThat(annotationTypes).containsExactly(WithRepeatedMetaAnnotations.class, Noninherited.class, Noninherited.class);\n\t}\n\n\t@Test  // gh-32731\n\tvoid searchFindsRepeatableContainerAnnotationAndRepeatedAnnotations() {\n\t\tClass<?> clazz = StandardRepeatablesWithContainerWithMultipleAttributesTestCase.class;\n\n\t\t// NO RepeatableContainers\n\t\tMergedAnnotations mergedAnnotations = MergedAnnotations.from(clazz, TYPE_HIERARCHY, RepeatableContainers.none());\n\t\tContainerWithMultipleAttributes container = mergedAnnotations\n\t\t\t\t.get(ContainerWithMultipleAttributes.class)\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t\tassertThat(container).as(\"container\").isNotNull();\n\t\tassertThat(container.name()).isEqualTo(\"enigma\");\n\t\tRepeatableWithContainerWithMultipleAttributes[] repeatedAnnotations = container.value();\n\t\tassertThat(Arrays.stream(repeatedAnnotations).map(RepeatableWithContainerWithMultipleAttributes::value))\n\t\t\t\t.containsExactly(\"A\", \"B\");\n\t\tSet<RepeatableWithContainerWithMultipleAttributes> set =\n\t\t\t\tmergedAnnotations.stream(RepeatableWithContainerWithMultipleAttributes.class)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t\t// Only finds the locally declared repeated annotation.\n\t\tassertThat(set.stream().map(RepeatableWithContainerWithMultipleAttributes::value))\n\t\t\t\t.containsExactly(\"C\");\n\n\t\t// Standard RepeatableContainers\n\t\tmergedAnnotations = MergedAnnotations.from(clazz, TYPE_HIERARCHY, RepeatableContainers.standardRepeatables());\n\t\tcontainer = mergedAnnotations\n\t\t\t\t.get(ContainerWithMultipleAttributes.class)\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t\tassertThat(container).as(\"container\").isNotNull();\n\t\tassertThat(container.name()).isEqualTo(\"enigma\");\n\t\trepeatedAnnotations = container.value();\n\t\tassertThat(Arrays.stream(repeatedAnnotations).map(RepeatableWithContainerWithMultipleAttributes::value))\n\t\t\t\t.containsExactly(\"A\", \"B\");\n\t\tset = mergedAnnotations.stream(RepeatableWithContainerWithMultipleAttributes.class)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t\t// Finds the locally declared repeated annotation plus the 2 in the container.\n\t\tassertThat(set.stream().map(RepeatableWithContainerWithMultipleAttributes::value))\n\t\t\t\t.containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\tprivate <A extends Annotation> Set<A> getAnnotations(Class<? extends Annotation> container,\n\t\t\tClass<A> repeatable, SearchStrategy searchStrategy, AnnotatedElement element) {\n\n\t\treturn getAnnotations(container, repeatable, searchStrategy, element, AnnotationFilter.PLAIN);\n\t}\n\n\tprivate <A extends Annotation> Set<A> getAnnotations(Class<? extends Annotation> container,\n\t\t\tClass<A> repeatable, SearchStrategy searchStrategy, AnnotatedElement element, AnnotationFilter annotationFilter) {\n\n\t\tRepeatableContainers containers = RepeatableContainers.of(repeatable, container);\n\t\tMergedAnnotations annotations = MergedAnnotations.from(element, searchStrategy, containers, annotationFilter);\n\t\treturn annotations.stream(repeatable).collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}\n\n\tprivate void nonRepeatableRequirements(Exception ex) {\n\t\tassertThat(ex)\n\t\t\t\t.hasMessageStartingWith(\"Annotation type must be a repeatable annotation\")\n\t\t\t\t.hasMessageContaining(\"failed to resolve container type for\", NonRepeatable.class.getName());\n\t}\n\n\tprivate void missingValueAttributeRequirements(Exception ex) {\n\t\tassertThat(ex)\n\t\t\t\t.hasMessageStartingWith(\"Invalid declaration of container type\")\n\t\t\t\t.hasMessageContaining(\n\t\t\t\t\t\tContainerMissingValueAttribute.class.getName(),\n\t\t\t\t\t\t\"for repeatable annotation\",\n\t\t\t\t\t\tInvalidRepeatable.class.getName())\n\t\t\t\t.hasCauseInstanceOf(NoSuchMethodException.class);\n\t}\n\n\tprivate void nonArrayValueAttributeRequirements(Exception ex) {\n\t\tassertThat(ex)\n\t\t\t\t.hasMessageStartingWith(\"Container type\")\n\t\t\t\t.hasMessageContaining(\n\t\t\t\t\t\tContainerWithNonArrayValueAttribute.class.getName(),\n\t\t\t\t\t\t\"must declare a 'value' attribute for an array of type\",\n\t\t\t\t\t\tInvalidRepeatable.class.getName());\n\t}\n\n\tprivate void wrongComponentTypeRequirements(Exception ex) {\n\t\tassertThat(ex)\n\t\t\t\t.hasMessageStartingWith(\"Container type\")\n\t\t\t\t.hasMessageContaining(\n\t\t\t\t\t\tContainerWithArrayValueAttributeButWrongComponentType.class.getName(),\n\t\t\t\t\t\t\"must declare a 'value' attribute for an array of type\",\n\t\t\t\t\t\tInvalidRepeatable.class.getName());\n\t}\n\n\tprivate static ThrowableTypeAssert<AnnotationConfigurationException> assertThatAnnotationConfigurationException() {\n\t\treturn assertThatExceptionOfType(AnnotationConfigurationException.class);\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface NonRepeatable {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContainerMissingValueAttribute {\n\n\t\t// InvalidRepeatable[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContainerWithNonArrayValueAttribute {\n\n\t\tInvalidRepeatable value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContainerWithArrayValueAttributeButWrongComponentType {\n\n\t\tString[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface InvalidRepeatable {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface PeteRepeats {\n\n\t\tPeteRepeat[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@Repeatable(PeteRepeats.class)\n\t@interface PeteRepeat {\n\n\t\tString value();\n\t}\n\n\t@PeteRepeat(\"shadowed\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface ForPetesSake {\n\n\t\t@AliasFor(annotation = PeteRepeat.class)\n\t\tString value();\n\t}\n\n\t@PeteRepeat(\"shadowed\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface ForTheLoveOfFoo {\n\n\t\t@AliasFor(annotation = PeteRepeat.class)\n\t\tString value();\n\t}\n\n\t@PeteRepeats({ @PeteRepeat(\"B\"), @PeteRepeat(\"C\") })\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface ComposedContainer {\n\t}\n\n\t@PeteRepeat(\"A\")\n\t@PeteRepeats({ @PeteRepeat(\"B\"), @PeteRepeat(\"C\") })\n\tstatic class RepeatableClass {\n\t}\n\n\tstatic class SubRepeatableClass extends RepeatableClass {\n\t}\n\n\t@ForPetesSake(\"B\")\n\t@ForTheLoveOfFoo(\"C\")\n\t@PeteRepeat(\"A\")\n\tstatic class ComposedRepeatableClass {\n\t}\n\n\t@ForPetesSake(\"C\")\n\t@PeteRepeats(@PeteRepeat(\"A\"))\n\t@PeteRepeat(\"B\")\n\tstatic class ComposedRepeatableMixedWithContainerClass {\n\t}\n\n\t@PeteRepeat(\"A\")\n\t@ComposedContainer\n\tstatic class ComposedContainerClass {\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Noninheriteds {\n\n\t\tNoninherited[] value();\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(Noninheriteds.class)\n\t@interface Noninherited {\n\n\t\t@AliasFor(\"name\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString name() default \"\";\n\t}\n\n\t@Noninherited(name = \"shadowed\")\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedNoninherited {\n\n\t\t@AliasFor(annotation = Noninherited.class)\n\t\tString name() default \"\";\n\t}\n\n\t@ComposedNoninherited(name = \"C\")\n\t@Noninheriteds({ @Noninherited(value = \"A\"), @Noninherited(name = \"B\") })\n\tstatic class NoninheritedRepeatableClass {\n\t}\n\n\tstatic class SubNoninheritedRepeatableClass extends NoninheritedRepeatableClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@PeteRepeat(\"A\")\n\t@PeteRepeat(\"B\")\n\t@interface WithRepeatedMetaAnnotations {\n\t}\n\n\t@WithRepeatedMetaAnnotations\n\t@PeteRepeat(\"C\")\n\t@Noninherited(\"X\")\n\t@Noninherited(\"Y\")\n\tstatic class WithRepeatedMetaAnnotationsClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContainerWithMultipleAttributes {\n\n\t\tRepeatableWithContainerWithMultipleAttributes[] value();\n\n\t\tString name() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(ContainerWithMultipleAttributes.class)\n\t@interface RepeatableWithContainerWithMultipleAttributes {\n\n\t\tString value() default \"\";\n\t}\n\n\t@ContainerWithMultipleAttributes(name = \"enigma\", value = {\n\t\t@RepeatableWithContainerWithMultipleAttributes(\"A\"),\n\t\t@RepeatableWithContainerWithMultipleAttributes(\"B\")\n\t})\n\t@RepeatableWithContainerWithMultipleAttributes(\"C\")\n\tstatic class StandardRepeatablesWithContainerWithMultipleAttributesTestCase {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation.SubRepeatableClass",
    "headType": "class",
    "relation": "extend",
    "tail": "RepeatableClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.ComposedRepeatableClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.ComposedRepeatableClass",
    "headType": "class",
    "relation": "use",
    "tail": "@ForPetesSake",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.ComposedRepeatableClass",
    "headType": "class",
    "relation": "use",
    "tail": "@ForTheLoveOfFoo",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.ComposedRepeatableClass",
    "headType": "class",
    "relation": "use",
    "tail": "@PeteRepeat",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.ComposedRepeatableClass",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedElement;\nimport java.util.Arrays;\nimport java.util.Set;\nimport java.util.stream.Stream;\n\nimport org.assertj.core.api.ThrowableTypeAssert;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.MergedAnnotations.SearchStrategy;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.springframework.core.annotation.MergedAnnotations.SearchStrategy.INHERITED_ANNOTATIONS;\nimport static org.springframework.core.annotation.MergedAnnotations.SearchStrategy.TYPE_HIERARCHY;\n\n/**\n * Tests for {@link MergedAnnotations} and {@link RepeatableContainers} that\n * verify support for repeatable annotations.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n */\nclass MergedAnnotationsRepeatableAnnotationTests {\n\n\t// See SPR-13973\n\n\t@Test\n\tvoid inheritedAnnotationsWhenNonRepeatableThrowsException() {\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(null, NonRepeatable.class, INHERITED_ANNOTATIONS, getClass()))\n\t\t\t\t.satisfies(this::nonRepeatableRequirements);\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenContainerMissingValueAttributeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerMissingValueAttribute.class, InvalidRepeatable.class,\n\t\t\t\t\t\tINHERITED_ANNOTATIONS, getClass()))\n\t\t\t\t.satisfies(this::missingValueAttributeRequirements);\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenWhenNonArrayValueAttributeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerWithNonArrayValueAttribute.class, InvalidRepeatable.class,\n\t\t\t\t\t\tINHERITED_ANNOTATIONS, getClass()))\n\t\t\t\t.satisfies(this::nonArrayValueAttributeRequirements);\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenWrongComponentTypeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerWithArrayValueAttributeButWrongComponentType.class,\n\t\t\t\t\t\tInvalidRepeatable.class, INHERITED_ANNOTATIONS, getClass()))\n\t\t\t\t.satisfies(this::wrongComponentTypeRequirements);\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, RepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenWhenOnSuperclassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, SubRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenComposedOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, ComposedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenComposedMixedWithContainerOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, ComposedRepeatableMixedWithContainerClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenComposedContainerForRepeatableOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, ComposedContainerClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenNoninheritedComposedRepeatableOnClassReturnsAnnotations() {\n\t\tSet<Noninherited> annotations = getAnnotations(null, Noninherited.class,\n\t\t\t\tINHERITED_ANNOTATIONS, NoninheritedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(Noninherited::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenNoninheritedComposedRepeatableOnSuperclassReturnsAnnotations() {\n\t\tSet<Noninherited> annotations = getAnnotations(null, Noninherited.class,\n\t\t\t\tINHERITED_ANNOTATIONS, SubNoninheritedRepeatableClass.class);\n\t\tassertThat(annotations).isEmpty();\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenNonRepeatableThrowsException() {\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(null, NonRepeatable.class, TYPE_HIERARCHY, getClass()))\n\t\t\t\t.satisfies(this::nonRepeatableRequirements);\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenContainerMissingValueAttributeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerMissingValueAttribute.class, InvalidRepeatable.class,\n\t\t\t\t\t\tTYPE_HIERARCHY, getClass()))\n\t\t\t\t.satisfies(this::missingValueAttributeRequirements);\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenWhenNonArrayValueAttributeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerWithNonArrayValueAttribute.class, InvalidRepeatable.class,\n\t\t\t\t\t\tTYPE_HIERARCHY, getClass()))\n\t\t\t\t.satisfies(this::nonArrayValueAttributeRequirements);\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenWrongComponentTypeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerWithArrayValueAttributeButWrongComponentType.class,\n\t\t\t\t\t\tInvalidRepeatable.class, TYPE_HIERARCHY, getClass()))\n\t\t\t\t.satisfies(this::wrongComponentTypeRequirements);\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, RepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenOnSuperclassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, SubRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenComposedOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, ComposedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenComposedMixedWithContainerOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, ComposedRepeatableMixedWithContainerClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenComposedContainerForRepeatableOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, ComposedContainerClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyAnnotationsWhenNoninheritedComposedRepeatableOnClassReturnsAnnotations() {\n\t\tSet<Noninherited> annotations = getAnnotations(null, Noninherited.class,\n\t\t\t\tTYPE_HIERARCHY, NoninheritedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(Noninherited::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyAnnotationsWhenNoninheritedComposedRepeatableOnSuperclassReturnsAnnotations() {\n\t\tSet<Noninherited> annotations = getAnnotations(null, Noninherited.class,\n\t\t\t\tTYPE_HIERARCHY, SubNoninheritedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(Noninherited::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyAnnotationsWithLocalComposedAnnotationWhoseRepeatableMetaAnnotationsAreFiltered() {\n\t\tClass<WithRepeatedMetaAnnotationsClass> element = WithRepeatedMetaAnnotationsClass.class;\n\t\tSearchStrategy searchStrategy = TYPE_HIERARCHY;\n\t\tAnnotationFilter annotationFilter = PeteRepeat.class.getName()::equals;\n\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class, searchStrategy, element, annotationFilter);\n\t\tassertThat(annotations).isEmpty();\n\n\t\tMergedAnnotations mergedAnnotations = MergedAnnotations.from(element, searchStrategy,\n\t\t\t\tRepeatableContainers.standardRepeatables(), annotationFilter);\n\t\tStream<Class<? extends Annotation>> annotationTypes = mergedAnnotations.stream()\n\t\t\t\t.map(MergedAnnotation::synthesize)\n\t\t\t\t.map(Annotation::annotationType);\n\t\tassertThat(annotationTypes).containsExactly(WithRepeatedMetaAnnotations.class, Noninherited.class, Noninherited.class);\n\t}\n\n\t@Test  // gh-32731\n\tvoid searchFindsRepeatableContainerAnnotationAndRepeatedAnnotations() {\n\t\tClass<?> clazz = StandardRepeatablesWithContainerWithMultipleAttributesTestCase.class;\n\n\t\t// NO RepeatableContainers\n\t\tMergedAnnotations mergedAnnotations = MergedAnnotations.from(clazz, TYPE_HIERARCHY, RepeatableContainers.none());\n\t\tContainerWithMultipleAttributes container = mergedAnnotations\n\t\t\t\t.get(ContainerWithMultipleAttributes.class)\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t\tassertThat(container).as(\"container\").isNotNull();\n\t\tassertThat(container.name()).isEqualTo(\"enigma\");\n\t\tRepeatableWithContainerWithMultipleAttributes[] repeatedAnnotations = container.value();\n\t\tassertThat(Arrays.stream(repeatedAnnotations).map(RepeatableWithContainerWithMultipleAttributes::value))\n\t\t\t\t.containsExactly(\"A\", \"B\");\n\t\tSet<RepeatableWithContainerWithMultipleAttributes> set =\n\t\t\t\tmergedAnnotations.stream(RepeatableWithContainerWithMultipleAttributes.class)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t\t// Only finds the locally declared repeated annotation.\n\t\tassertThat(set.stream().map(RepeatableWithContainerWithMultipleAttributes::value))\n\t\t\t\t.containsExactly(\"C\");\n\n\t\t// Standard RepeatableContainers\n\t\tmergedAnnotations = MergedAnnotations.from(clazz, TYPE_HIERARCHY, RepeatableContainers.standardRepeatables());\n\t\tcontainer = mergedAnnotations\n\t\t\t\t.get(ContainerWithMultipleAttributes.class)\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t\tassertThat(container).as(\"container\").isNotNull();\n\t\tassertThat(container.name()).isEqualTo(\"enigma\");\n\t\trepeatedAnnotations = container.value();\n\t\tassertThat(Arrays.stream(repeatedAnnotations).map(RepeatableWithContainerWithMultipleAttributes::value))\n\t\t\t\t.containsExactly(\"A\", \"B\");\n\t\tset = mergedAnnotations.stream(RepeatableWithContainerWithMultipleAttributes.class)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t\t// Finds the locally declared repeated annotation plus the 2 in the container.\n\t\tassertThat(set.stream().map(RepeatableWithContainerWithMultipleAttributes::value))\n\t\t\t\t.containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\tprivate <A extends Annotation> Set<A> getAnnotations(Class<? extends Annotation> container,\n\t\t\tClass<A> repeatable, SearchStrategy searchStrategy, AnnotatedElement element) {\n\n\t\treturn getAnnotations(container, repeatable, searchStrategy, element, AnnotationFilter.PLAIN);\n\t}\n\n\tprivate <A extends Annotation> Set<A> getAnnotations(Class<? extends Annotation> container,\n\t\t\tClass<A> repeatable, SearchStrategy searchStrategy, AnnotatedElement element, AnnotationFilter annotationFilter) {\n\n\t\tRepeatableContainers containers = RepeatableContainers.of(repeatable, container);\n\t\tMergedAnnotations annotations = MergedAnnotations.from(element, searchStrategy, containers, annotationFilter);\n\t\treturn annotations.stream(repeatable).collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}\n\n\tprivate void nonRepeatableRequirements(Exception ex) {\n\t\tassertThat(ex)\n\t\t\t\t.hasMessageStartingWith(\"Annotation type must be a repeatable annotation\")\n\t\t\t\t.hasMessageContaining(\"failed to resolve container type for\", NonRepeatable.class.getName());\n\t}\n\n\tprivate void missingValueAttributeRequirements(Exception ex) {\n\t\tassertThat(ex)\n\t\t\t\t.hasMessageStartingWith(\"Invalid declaration of container type\")\n\t\t\t\t.hasMessageContaining(\n\t\t\t\t\t\tContainerMissingValueAttribute.class.getName(),\n\t\t\t\t\t\t\"for repeatable annotation\",\n\t\t\t\t\t\tInvalidRepeatable.class.getName())\n\t\t\t\t.hasCauseInstanceOf(NoSuchMethodException.class);\n\t}\n\n\tprivate void nonArrayValueAttributeRequirements(Exception ex) {\n\t\tassertThat(ex)\n\t\t\t\t.hasMessageStartingWith(\"Container type\")\n\t\t\t\t.hasMessageContaining(\n\t\t\t\t\t\tContainerWithNonArrayValueAttribute.class.getName(),\n\t\t\t\t\t\t\"must declare a 'value' attribute for an array of type\",\n\t\t\t\t\t\tInvalidRepeatable.class.getName());\n\t}\n\n\tprivate void wrongComponentTypeRequirements(Exception ex) {\n\t\tassertThat(ex)\n\t\t\t\t.hasMessageStartingWith(\"Container type\")\n\t\t\t\t.hasMessageContaining(\n\t\t\t\t\t\tContainerWithArrayValueAttributeButWrongComponentType.class.getName(),\n\t\t\t\t\t\t\"must declare a 'value' attribute for an array of type\",\n\t\t\t\t\t\tInvalidRepeatable.class.getName());\n\t}\n\n\tprivate static ThrowableTypeAssert<AnnotationConfigurationException> assertThatAnnotationConfigurationException() {\n\t\treturn assertThatExceptionOfType(AnnotationConfigurationException.class);\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface NonRepeatable {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContainerMissingValueAttribute {\n\n\t\t// InvalidRepeatable[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContainerWithNonArrayValueAttribute {\n\n\t\tInvalidRepeatable value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContainerWithArrayValueAttributeButWrongComponentType {\n\n\t\tString[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface InvalidRepeatable {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface PeteRepeats {\n\n\t\tPeteRepeat[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@Repeatable(PeteRepeats.class)\n\t@interface PeteRepeat {\n\n\t\tString value();\n\t}\n\n\t@PeteRepeat(\"shadowed\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface ForPetesSake {\n\n\t\t@AliasFor(annotation = PeteRepeat.class)\n\t\tString value();\n\t}\n\n\t@PeteRepeat(\"shadowed\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface ForTheLoveOfFoo {\n\n\t\t@AliasFor(annotation = PeteRepeat.class)\n\t\tString value();\n\t}\n\n\t@PeteRepeats({ @PeteRepeat(\"B\"), @PeteRepeat(\"C\") })\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface ComposedContainer {\n\t}\n\n\t@PeteRepeat(\"A\")\n\t@PeteRepeats({ @PeteRepeat(\"B\"), @PeteRepeat(\"C\") })\n\tstatic class RepeatableClass {\n\t}\n\n\tstatic class SubRepeatableClass extends RepeatableClass {\n\t}\n\n\t@ForPetesSake(\"B\")\n\t@ForTheLoveOfFoo(\"C\")\n\t@PeteRepeat(\"A\")\n\tstatic class ComposedRepeatableClass {\n\t}\n\n\t@ForPetesSake(\"C\")\n\t@PeteRepeats(@PeteRepeat(\"A\"))\n\t@PeteRepeat(\"B\")\n\tstatic class ComposedRepeatableMixedWithContainerClass {\n\t}\n\n\t@PeteRepeat(\"A\")\n\t@ComposedContainer\n\tstatic class ComposedContainerClass {\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Noninheriteds {\n\n\t\tNoninherited[] value();\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(Noninheriteds.class)\n\t@interface Noninherited {\n\n\t\t@AliasFor(\"name\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString name() default \"\";\n\t}\n\n\t@Noninherited(name = \"shadowed\")\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedNoninherited {\n\n\t\t@AliasFor(annotation = Noninherited.class)\n\t\tString name() default \"\";\n\t}\n\n\t@ComposedNoninherited(name = \"C\")\n\t@Noninheriteds({ @Noninherited(value = \"A\"), @Noninherited(name = \"B\") })\n\tstatic class NoninheritedRepeatableClass {\n\t}\n\n\tstatic class SubNoninheritedRepeatableClass extends NoninheritedRepeatableClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@PeteRepeat(\"A\")\n\t@PeteRepeat(\"B\")\n\t@interface WithRepeatedMetaAnnotations {\n\t}\n\n\t@WithRepeatedMetaAnnotations\n\t@PeteRepeat(\"C\")\n\t@Noninherited(\"X\")\n\t@Noninherited(\"Y\")\n\tstatic class WithRepeatedMetaAnnotationsClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContainerWithMultipleAttributes {\n\n\t\tRepeatableWithContainerWithMultipleAttributes[] value();\n\n\t\tString name() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(ContainerWithMultipleAttributes.class)\n\t@interface RepeatableWithContainerWithMultipleAttributes {\n\n\t\tString value() default \"\";\n\t}\n\n\t@ContainerWithMultipleAttributes(name = \"enigma\", value = {\n\t\t@RepeatableWithContainerWithMultipleAttributes(\"A\"),\n\t\t@RepeatableWithContainerWithMultipleAttributes(\"B\")\n\t})\n\t@RepeatableWithContainerWithMultipleAttributes(\"C\")\n\tstatic class StandardRepeatablesWithContainerWithMultipleAttributesTestCase {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.ComposedRepeatableMixedWithContainerClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.ComposedRepeatableMixedWithContainerClass",
    "headType": "class",
    "relation": "use",
    "tail": "@ForPetesSake",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.ComposedRepeatableMixedWithContainerClass",
    "headType": "class",
    "relation": "use",
    "tail": "@PeteRepeats",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.ComposedRepeatableMixedWithContainerClass",
    "headType": "class",
    "relation": "use",
    "tail": "@PeteRepeat",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.ComposedRepeatableMixedWithContainerClass",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedElement;\nimport java.util.Arrays;\nimport java.util.Set;\nimport java.util.stream.Stream;\n\nimport org.assertj.core.api.ThrowableTypeAssert;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.MergedAnnotations.SearchStrategy;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.springframework.core.annotation.MergedAnnotations.SearchStrategy.INHERITED_ANNOTATIONS;\nimport static org.springframework.core.annotation.MergedAnnotations.SearchStrategy.TYPE_HIERARCHY;\n\n/**\n * Tests for {@link MergedAnnotations} and {@link RepeatableContainers} that\n * verify support for repeatable annotations.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n */\nclass MergedAnnotationsRepeatableAnnotationTests {\n\n\t// See SPR-13973\n\n\t@Test\n\tvoid inheritedAnnotationsWhenNonRepeatableThrowsException() {\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(null, NonRepeatable.class, INHERITED_ANNOTATIONS, getClass()))\n\t\t\t\t.satisfies(this::nonRepeatableRequirements);\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenContainerMissingValueAttributeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerMissingValueAttribute.class, InvalidRepeatable.class,\n\t\t\t\t\t\tINHERITED_ANNOTATIONS, getClass()))\n\t\t\t\t.satisfies(this::missingValueAttributeRequirements);\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenWhenNonArrayValueAttributeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerWithNonArrayValueAttribute.class, InvalidRepeatable.class,\n\t\t\t\t\t\tINHERITED_ANNOTATIONS, getClass()))\n\t\t\t\t.satisfies(this::nonArrayValueAttributeRequirements);\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenWrongComponentTypeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerWithArrayValueAttributeButWrongComponentType.class,\n\t\t\t\t\t\tInvalidRepeatable.class, INHERITED_ANNOTATIONS, getClass()))\n\t\t\t\t.satisfies(this::wrongComponentTypeRequirements);\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, RepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenWhenOnSuperclassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, SubRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenComposedOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, ComposedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenComposedMixedWithContainerOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, ComposedRepeatableMixedWithContainerClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenComposedContainerForRepeatableOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, ComposedContainerClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenNoninheritedComposedRepeatableOnClassReturnsAnnotations() {\n\t\tSet<Noninherited> annotations = getAnnotations(null, Noninherited.class,\n\t\t\t\tINHERITED_ANNOTATIONS, NoninheritedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(Noninherited::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenNoninheritedComposedRepeatableOnSuperclassReturnsAnnotations() {\n\t\tSet<Noninherited> annotations = getAnnotations(null, Noninherited.class,\n\t\t\t\tINHERITED_ANNOTATIONS, SubNoninheritedRepeatableClass.class);\n\t\tassertThat(annotations).isEmpty();\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenNonRepeatableThrowsException() {\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(null, NonRepeatable.class, TYPE_HIERARCHY, getClass()))\n\t\t\t\t.satisfies(this::nonRepeatableRequirements);\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenContainerMissingValueAttributeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerMissingValueAttribute.class, InvalidRepeatable.class,\n\t\t\t\t\t\tTYPE_HIERARCHY, getClass()))\n\t\t\t\t.satisfies(this::missingValueAttributeRequirements);\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenWhenNonArrayValueAttributeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerWithNonArrayValueAttribute.class, InvalidRepeatable.class,\n\t\t\t\t\t\tTYPE_HIERARCHY, getClass()))\n\t\t\t\t.satisfies(this::nonArrayValueAttributeRequirements);\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenWrongComponentTypeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerWithArrayValueAttributeButWrongComponentType.class,\n\t\t\t\t\t\tInvalidRepeatable.class, TYPE_HIERARCHY, getClass()))\n\t\t\t\t.satisfies(this::wrongComponentTypeRequirements);\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, RepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenOnSuperclassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, SubRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenComposedOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, ComposedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenComposedMixedWithContainerOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, ComposedRepeatableMixedWithContainerClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenComposedContainerForRepeatableOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, ComposedContainerClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyAnnotationsWhenNoninheritedComposedRepeatableOnClassReturnsAnnotations() {\n\t\tSet<Noninherited> annotations = getAnnotations(null, Noninherited.class,\n\t\t\t\tTYPE_HIERARCHY, NoninheritedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(Noninherited::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyAnnotationsWhenNoninheritedComposedRepeatableOnSuperclassReturnsAnnotations() {\n\t\tSet<Noninherited> annotations = getAnnotations(null, Noninherited.class,\n\t\t\t\tTYPE_HIERARCHY, SubNoninheritedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(Noninherited::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyAnnotationsWithLocalComposedAnnotationWhoseRepeatableMetaAnnotationsAreFiltered() {\n\t\tClass<WithRepeatedMetaAnnotationsClass> element = WithRepeatedMetaAnnotationsClass.class;\n\t\tSearchStrategy searchStrategy = TYPE_HIERARCHY;\n\t\tAnnotationFilter annotationFilter = PeteRepeat.class.getName()::equals;\n\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class, searchStrategy, element, annotationFilter);\n\t\tassertThat(annotations).isEmpty();\n\n\t\tMergedAnnotations mergedAnnotations = MergedAnnotations.from(element, searchStrategy,\n\t\t\t\tRepeatableContainers.standardRepeatables(), annotationFilter);\n\t\tStream<Class<? extends Annotation>> annotationTypes = mergedAnnotations.stream()\n\t\t\t\t.map(MergedAnnotation::synthesize)\n\t\t\t\t.map(Annotation::annotationType);\n\t\tassertThat(annotationTypes).containsExactly(WithRepeatedMetaAnnotations.class, Noninherited.class, Noninherited.class);\n\t}\n\n\t@Test  // gh-32731\n\tvoid searchFindsRepeatableContainerAnnotationAndRepeatedAnnotations() {\n\t\tClass<?> clazz = StandardRepeatablesWithContainerWithMultipleAttributesTestCase.class;\n\n\t\t// NO RepeatableContainers\n\t\tMergedAnnotations mergedAnnotations = MergedAnnotations.from(clazz, TYPE_HIERARCHY, RepeatableContainers.none());\n\t\tContainerWithMultipleAttributes container = mergedAnnotations\n\t\t\t\t.get(ContainerWithMultipleAttributes.class)\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t\tassertThat(container).as(\"container\").isNotNull();\n\t\tassertThat(container.name()).isEqualTo(\"enigma\");\n\t\tRepeatableWithContainerWithMultipleAttributes[] repeatedAnnotations = container.value();\n\t\tassertThat(Arrays.stream(repeatedAnnotations).map(RepeatableWithContainerWithMultipleAttributes::value))\n\t\t\t\t.containsExactly(\"A\", \"B\");\n\t\tSet<RepeatableWithContainerWithMultipleAttributes> set =\n\t\t\t\tmergedAnnotations.stream(RepeatableWithContainerWithMultipleAttributes.class)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t\t// Only finds the locally declared repeated annotation.\n\t\tassertThat(set.stream().map(RepeatableWithContainerWithMultipleAttributes::value))\n\t\t\t\t.containsExactly(\"C\");\n\n\t\t// Standard RepeatableContainers\n\t\tmergedAnnotations = MergedAnnotations.from(clazz, TYPE_HIERARCHY, RepeatableContainers.standardRepeatables());\n\t\tcontainer = mergedAnnotations\n\t\t\t\t.get(ContainerWithMultipleAttributes.class)\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t\tassertThat(container).as(\"container\").isNotNull();\n\t\tassertThat(container.name()).isEqualTo(\"enigma\");\n\t\trepeatedAnnotations = container.value();\n\t\tassertThat(Arrays.stream(repeatedAnnotations).map(RepeatableWithContainerWithMultipleAttributes::value))\n\t\t\t\t.containsExactly(\"A\", \"B\");\n\t\tset = mergedAnnotations.stream(RepeatableWithContainerWithMultipleAttributes.class)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t\t// Finds the locally declared repeated annotation plus the 2 in the container.\n\t\tassertThat(set.stream().map(RepeatableWithContainerWithMultipleAttributes::value))\n\t\t\t\t.containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\tprivate <A extends Annotation> Set<A> getAnnotations(Class<? extends Annotation> container,\n\t\t\tClass<A> repeatable, SearchStrategy searchStrategy, AnnotatedElement element) {\n\n\t\treturn getAnnotations(container, repeatable, searchStrategy, element, AnnotationFilter.PLAIN);\n\t}\n\n\tprivate <A extends Annotation> Set<A> getAnnotations(Class<? extends Annotation> container,\n\t\t\tClass<A> repeatable, SearchStrategy searchStrategy, AnnotatedElement element, AnnotationFilter annotationFilter) {\n\n\t\tRepeatableContainers containers = RepeatableContainers.of(repeatable, container);\n\t\tMergedAnnotations annotations = MergedAnnotations.from(element, searchStrategy, containers, annotationFilter);\n\t\treturn annotations.stream(repeatable).collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}\n\n\tprivate void nonRepeatableRequirements(Exception ex) {\n\t\tassertThat(ex)\n\t\t\t\t.hasMessageStartingWith(\"Annotation type must be a repeatable annotation\")\n\t\t\t\t.hasMessageContaining(\"failed to resolve container type for\", NonRepeatable.class.getName());\n\t}\n\n\tprivate void missingValueAttributeRequirements(Exception ex) {\n\t\tassertThat(ex)\n\t\t\t\t.hasMessageStartingWith(\"Invalid declaration of container type\")\n\t\t\t\t.hasMessageContaining(\n\t\t\t\t\t\tContainerMissingValueAttribute.class.getName(),\n\t\t\t\t\t\t\"for repeatable annotation\",\n\t\t\t\t\t\tInvalidRepeatable.class.getName())\n\t\t\t\t.hasCauseInstanceOf(NoSuchMethodException.class);\n\t}\n\n\tprivate void nonArrayValueAttributeRequirements(Exception ex) {\n\t\tassertThat(ex)\n\t\t\t\t.hasMessageStartingWith(\"Container type\")\n\t\t\t\t.hasMessageContaining(\n\t\t\t\t\t\tContainerWithNonArrayValueAttribute.class.getName(),\n\t\t\t\t\t\t\"must declare a 'value' attribute for an array of type\",\n\t\t\t\t\t\tInvalidRepeatable.class.getName());\n\t}\n\n\tprivate void wrongComponentTypeRequirements(Exception ex) {\n\t\tassertThat(ex)\n\t\t\t\t.hasMessageStartingWith(\"Container type\")\n\t\t\t\t.hasMessageContaining(\n\t\t\t\t\t\tContainerWithArrayValueAttributeButWrongComponentType.class.getName(),\n\t\t\t\t\t\t\"must declare a 'value' attribute for an array of type\",\n\t\t\t\t\t\tInvalidRepeatable.class.getName());\n\t}\n\n\tprivate static ThrowableTypeAssert<AnnotationConfigurationException> assertThatAnnotationConfigurationException() {\n\t\treturn assertThatExceptionOfType(AnnotationConfigurationException.class);\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface NonRepeatable {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContainerMissingValueAttribute {\n\n\t\t// InvalidRepeatable[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContainerWithNonArrayValueAttribute {\n\n\t\tInvalidRepeatable value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContainerWithArrayValueAttributeButWrongComponentType {\n\n\t\tString[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface InvalidRepeatable {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface PeteRepeats {\n\n\t\tPeteRepeat[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@Repeatable(PeteRepeats.class)\n\t@interface PeteRepeat {\n\n\t\tString value();\n\t}\n\n\t@PeteRepeat(\"shadowed\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface ForPetesSake {\n\n\t\t@AliasFor(annotation = PeteRepeat.class)\n\t\tString value();\n\t}\n\n\t@PeteRepeat(\"shadowed\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface ForTheLoveOfFoo {\n\n\t\t@AliasFor(annotation = PeteRepeat.class)\n\t\tString value();\n\t}\n\n\t@PeteRepeats({ @PeteRepeat(\"B\"), @PeteRepeat(\"C\") })\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface ComposedContainer {\n\t}\n\n\t@PeteRepeat(\"A\")\n\t@PeteRepeats({ @PeteRepeat(\"B\"), @PeteRepeat(\"C\") })\n\tstatic class RepeatableClass {\n\t}\n\n\tstatic class SubRepeatableClass extends RepeatableClass {\n\t}\n\n\t@ForPetesSake(\"B\")\n\t@ForTheLoveOfFoo(\"C\")\n\t@PeteRepeat(\"A\")\n\tstatic class ComposedRepeatableClass {\n\t}\n\n\t@ForPetesSake(\"C\")\n\t@PeteRepeats(@PeteRepeat(\"A\"))\n\t@PeteRepeat(\"B\")\n\tstatic class ComposedRepeatableMixedWithContainerClass {\n\t}\n\n\t@PeteRepeat(\"A\")\n\t@ComposedContainer\n\tstatic class ComposedContainerClass {\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Noninheriteds {\n\n\t\tNoninherited[] value();\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(Noninheriteds.class)\n\t@interface Noninherited {\n\n\t\t@AliasFor(\"name\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString name() default \"\";\n\t}\n\n\t@Noninherited(name = \"shadowed\")\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedNoninherited {\n\n\t\t@AliasFor(annotation = Noninherited.class)\n\t\tString name() default \"\";\n\t}\n\n\t@ComposedNoninherited(name = \"C\")\n\t@Noninheriteds({ @Noninherited(value = \"A\"), @Noninherited(name = \"B\") })\n\tstatic class NoninheritedRepeatableClass {\n\t}\n\n\tstatic class SubNoninheritedRepeatableClass extends NoninheritedRepeatableClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@PeteRepeat(\"A\")\n\t@PeteRepeat(\"B\")\n\t@interface WithRepeatedMetaAnnotations {\n\t}\n\n\t@WithRepeatedMetaAnnotations\n\t@PeteRepeat(\"C\")\n\t@Noninherited(\"X\")\n\t@Noninherited(\"Y\")\n\tstatic class WithRepeatedMetaAnnotationsClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContainerWithMultipleAttributes {\n\n\t\tRepeatableWithContainerWithMultipleAttributes[] value();\n\n\t\tString name() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(ContainerWithMultipleAttributes.class)\n\t@interface RepeatableWithContainerWithMultipleAttributes {\n\n\t\tString value() default \"\";\n\t}\n\n\t@ContainerWithMultipleAttributes(name = \"enigma\", value = {\n\t\t@RepeatableWithContainerWithMultipleAttributes(\"A\"),\n\t\t@RepeatableWithContainerWithMultipleAttributes(\"B\")\n\t})\n\t@RepeatableWithContainerWithMultipleAttributes(\"C\")\n\tstatic class StandardRepeatablesWithContainerWithMultipleAttributesTestCase {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.ComposedContainerClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.ComposedContainerClass",
    "headType": "class",
    "relation": "use",
    "tail": "@PeteRepeat",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.ComposedContainerClass",
    "headType": "class",
    "relation": "use",
    "tail": "@ComposedContainer",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.ComposedContainerClass",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedElement;\nimport java.util.Arrays;\nimport java.util.Set;\nimport java.util.stream.Stream;\n\nimport org.assertj.core.api.ThrowableTypeAssert;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.MergedAnnotations.SearchStrategy;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.springframework.core.annotation.MergedAnnotations.SearchStrategy.INHERITED_ANNOTATIONS;\nimport static org.springframework.core.annotation.MergedAnnotations.SearchStrategy.TYPE_HIERARCHY;\n\n/**\n * Tests for {@link MergedAnnotations} and {@link RepeatableContainers} that\n * verify support for repeatable annotations.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n */\nclass MergedAnnotationsRepeatableAnnotationTests {\n\n\t// See SPR-13973\n\n\t@Test\n\tvoid inheritedAnnotationsWhenNonRepeatableThrowsException() {\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(null, NonRepeatable.class, INHERITED_ANNOTATIONS, getClass()))\n\t\t\t\t.satisfies(this::nonRepeatableRequirements);\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenContainerMissingValueAttributeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerMissingValueAttribute.class, InvalidRepeatable.class,\n\t\t\t\t\t\tINHERITED_ANNOTATIONS, getClass()))\n\t\t\t\t.satisfies(this::missingValueAttributeRequirements);\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenWhenNonArrayValueAttributeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerWithNonArrayValueAttribute.class, InvalidRepeatable.class,\n\t\t\t\t\t\tINHERITED_ANNOTATIONS, getClass()))\n\t\t\t\t.satisfies(this::nonArrayValueAttributeRequirements);\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenWrongComponentTypeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerWithArrayValueAttributeButWrongComponentType.class,\n\t\t\t\t\t\tInvalidRepeatable.class, INHERITED_ANNOTATIONS, getClass()))\n\t\t\t\t.satisfies(this::wrongComponentTypeRequirements);\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, RepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenWhenOnSuperclassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, SubRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenComposedOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, ComposedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenComposedMixedWithContainerOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, ComposedRepeatableMixedWithContainerClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenComposedContainerForRepeatableOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tINHERITED_ANNOTATIONS, ComposedContainerClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenNoninheritedComposedRepeatableOnClassReturnsAnnotations() {\n\t\tSet<Noninherited> annotations = getAnnotations(null, Noninherited.class,\n\t\t\t\tINHERITED_ANNOTATIONS, NoninheritedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(Noninherited::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid inheritedAnnotationsWhenNoninheritedComposedRepeatableOnSuperclassReturnsAnnotations() {\n\t\tSet<Noninherited> annotations = getAnnotations(null, Noninherited.class,\n\t\t\t\tINHERITED_ANNOTATIONS, SubNoninheritedRepeatableClass.class);\n\t\tassertThat(annotations).isEmpty();\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenNonRepeatableThrowsException() {\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(null, NonRepeatable.class, TYPE_HIERARCHY, getClass()))\n\t\t\t\t.satisfies(this::nonRepeatableRequirements);\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenContainerMissingValueAttributeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerMissingValueAttribute.class, InvalidRepeatable.class,\n\t\t\t\t\t\tTYPE_HIERARCHY, getClass()))\n\t\t\t\t.satisfies(this::missingValueAttributeRequirements);\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenWhenNonArrayValueAttributeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerWithNonArrayValueAttribute.class, InvalidRepeatable.class,\n\t\t\t\t\t\tTYPE_HIERARCHY, getClass()))\n\t\t\t\t.satisfies(this::nonArrayValueAttributeRequirements);\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenWrongComponentTypeThrowsException() {\n\t\tassertThatAnnotationConfigurationException()\n\t\t\t\t.isThrownBy(() -> getAnnotations(ContainerWithArrayValueAttributeButWrongComponentType.class,\n\t\t\t\t\t\tInvalidRepeatable.class, TYPE_HIERARCHY, getClass()))\n\t\t\t\t.satisfies(this::wrongComponentTypeRequirements);\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, RepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenOnSuperclassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, SubRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenComposedOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, ComposedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenComposedMixedWithContainerOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, ComposedRepeatableMixedWithContainerClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyWhenComposedContainerForRepeatableOnClassReturnsAnnotations() {\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class,\n\t\t\t\tTYPE_HIERARCHY, ComposedContainerClass.class);\n\t\tassertThat(annotations.stream().map(PeteRepeat::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyAnnotationsWhenNoninheritedComposedRepeatableOnClassReturnsAnnotations() {\n\t\tSet<Noninherited> annotations = getAnnotations(null, Noninherited.class,\n\t\t\t\tTYPE_HIERARCHY, NoninheritedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(Noninherited::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyAnnotationsWhenNoninheritedComposedRepeatableOnSuperclassReturnsAnnotations() {\n\t\tSet<Noninherited> annotations = getAnnotations(null, Noninherited.class,\n\t\t\t\tTYPE_HIERARCHY, SubNoninheritedRepeatableClass.class);\n\t\tassertThat(annotations.stream().map(Noninherited::value)).containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyAnnotationsWithLocalComposedAnnotationWhoseRepeatableMetaAnnotationsAreFiltered() {\n\t\tClass<WithRepeatedMetaAnnotationsClass> element = WithRepeatedMetaAnnotationsClass.class;\n\t\tSearchStrategy searchStrategy = TYPE_HIERARCHY;\n\t\tAnnotationFilter annotationFilter = PeteRepeat.class.getName()::equals;\n\n\t\tSet<PeteRepeat> annotations = getAnnotations(null, PeteRepeat.class, searchStrategy, element, annotationFilter);\n\t\tassertThat(annotations).isEmpty();\n\n\t\tMergedAnnotations mergedAnnotations = MergedAnnotations.from(element, searchStrategy,\n\t\t\t\tRepeatableContainers.standardRepeatables(), annotationFilter);\n\t\tStream<Class<? extends Annotation>> annotationTypes = mergedAnnotations.stream()\n\t\t\t\t.map(MergedAnnotation::synthesize)\n\t\t\t\t.map(Annotation::annotationType);\n\t\tassertThat(annotationTypes).containsExactly(WithRepeatedMetaAnnotations.class, Noninherited.class, Noninherited.class);\n\t}\n\n\t@Test  // gh-32731\n\tvoid searchFindsRepeatableContainerAnnotationAndRepeatedAnnotations() {\n\t\tClass<?> clazz = StandardRepeatablesWithContainerWithMultipleAttributesTestCase.class;\n\n\t\t// NO RepeatableContainers\n\t\tMergedAnnotations mergedAnnotations = MergedAnnotations.from(clazz, TYPE_HIERARCHY, RepeatableContainers.none());\n\t\tContainerWithMultipleAttributes container = mergedAnnotations\n\t\t\t\t.get(ContainerWithMultipleAttributes.class)\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t\tassertThat(container).as(\"container\").isNotNull();\n\t\tassertThat(container.name()).isEqualTo(\"enigma\");\n\t\tRepeatableWithContainerWithMultipleAttributes[] repeatedAnnotations = container.value();\n\t\tassertThat(Arrays.stream(repeatedAnnotations).map(RepeatableWithContainerWithMultipleAttributes::value))\n\t\t\t\t.containsExactly(\"A\", \"B\");\n\t\tSet<RepeatableWithContainerWithMultipleAttributes> set =\n\t\t\t\tmergedAnnotations.stream(RepeatableWithContainerWithMultipleAttributes.class)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t\t// Only finds the locally declared repeated annotation.\n\t\tassertThat(set.stream().map(RepeatableWithContainerWithMultipleAttributes::value))\n\t\t\t\t.containsExactly(\"C\");\n\n\t\t// Standard RepeatableContainers\n\t\tmergedAnnotations = MergedAnnotations.from(clazz, TYPE_HIERARCHY, RepeatableContainers.standardRepeatables());\n\t\tcontainer = mergedAnnotations\n\t\t\t\t.get(ContainerWithMultipleAttributes.class)\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t\tassertThat(container).as(\"container\").isNotNull();\n\t\tassertThat(container.name()).isEqualTo(\"enigma\");\n\t\trepeatedAnnotations = container.value();\n\t\tassertThat(Arrays.stream(repeatedAnnotations).map(RepeatableWithContainerWithMultipleAttributes::value))\n\t\t\t\t.containsExactly(\"A\", \"B\");\n\t\tset = mergedAnnotations.stream(RepeatableWithContainerWithMultipleAttributes.class)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t\t// Finds the locally declared repeated annotation plus the 2 in the container.\n\t\tassertThat(set.stream().map(RepeatableWithContainerWithMultipleAttributes::value))\n\t\t\t\t.containsExactly(\"A\", \"B\", \"C\");\n\t}\n\n\tprivate <A extends Annotation> Set<A> getAnnotations(Class<? extends Annotation> container,\n\t\t\tClass<A> repeatable, SearchStrategy searchStrategy, AnnotatedElement element) {\n\n\t\treturn getAnnotations(container, repeatable, searchStrategy, element, AnnotationFilter.PLAIN);\n\t}\n\n\tprivate <A extends Annotation> Set<A> getAnnotations(Class<? extends Annotation> container,\n\t\t\tClass<A> repeatable, SearchStrategy searchStrategy, AnnotatedElement element, AnnotationFilter annotationFilter) {\n\n\t\tRepeatableContainers containers = RepeatableContainers.of(repeatable, container);\n\t\tMergedAnnotations annotations = MergedAnnotations.from(element, searchStrategy, containers, annotationFilter);\n\t\treturn annotations.stream(repeatable).collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}\n\n\tprivate void nonRepeatableRequirements(Exception ex) {\n\t\tassertThat(ex)\n\t\t\t\t.hasMessageStartingWith(\"Annotation type must be a repeatable annotation\")\n\t\t\t\t.hasMessageContaining(\"failed to resolve container type for\", NonRepeatable.class.getName());\n\t}\n\n\tprivate void missingValueAttributeRequirements(Exception ex) {\n\t\tassertThat(ex)\n\t\t\t\t.hasMessageStartingWith(\"Invalid declaration of container type\")\n\t\t\t\t.hasMessageContaining(\n\t\t\t\t\t\tContainerMissingValueAttribute.class.getName(),\n\t\t\t\t\t\t\"for repeatable annotation\",\n\t\t\t\t\t\tInvalidRepeatable.class.getName())\n\t\t\t\t.hasCauseInstanceOf(NoSuchMethodException.class);\n\t}\n\n\tprivate void nonArrayValueAttributeRequirements(Exception ex) {\n\t\tassertThat(ex)\n\t\t\t\t.hasMessageStartingWith(\"Container type\")\n\t\t\t\t.hasMessageContaining(\n\t\t\t\t\t\tContainerWithNonArrayValueAttribute.class.getName(),\n\t\t\t\t\t\t\"must declare a 'value' attribute for an array of type\",\n\t\t\t\t\t\tInvalidRepeatable.class.getName());\n\t}\n\n\tprivate void wrongComponentTypeRequirements(Exception ex) {\n\t\tassertThat(ex)\n\t\t\t\t.hasMessageStartingWith(\"Container type\")\n\t\t\t\t.hasMessageContaining(\n\t\t\t\t\t\tContainerWithArrayValueAttributeButWrongComponentType.class.getName(),\n\t\t\t\t\t\t\"must declare a 'value' attribute for an array of type\",\n\t\t\t\t\t\tInvalidRepeatable.class.getName());\n\t}\n\n\tprivate static ThrowableTypeAssert<AnnotationConfigurationException> assertThatAnnotationConfigurationException() {\n\t\treturn assertThatExceptionOfType(AnnotationConfigurationException.class);\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface NonRepeatable {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContainerMissingValueAttribute {\n\n\t\t// InvalidRepeatable[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContainerWithNonArrayValueAttribute {\n\n\t\tInvalidRepeatable value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContainerWithArrayValueAttributeButWrongComponentType {\n\n\t\tString[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface InvalidRepeatable {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface PeteRepeats {\n\n\t\tPeteRepeat[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@Repeatable(PeteRepeats.class)\n\t@interface PeteRepeat {\n\n\t\tString value();\n\t}\n\n\t@PeteRepeat(\"shadowed\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface ForPetesSake {\n\n\t\t@AliasFor(annotation = PeteRepeat.class)\n\t\tString value();\n\t}\n\n\t@PeteRepeat(\"shadowed\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface ForTheLoveOfFoo {\n\n\t\t@AliasFor(annotation = PeteRepeat.class)\n\t\tString value();\n\t}\n\n\t@PeteRepeats({ @PeteRepeat(\"B\"), @PeteRepeat(\"C\") })\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface ComposedContainer {\n\t}\n\n\t@PeteRepeat(\"A\")\n\t@PeteRepeats({ @PeteRepeat(\"B\"), @PeteRepeat(\"C\") })\n\tstatic class RepeatableClass {\n\t}\n\n\tstatic class SubRepeatableClass extends RepeatableClass {\n\t}\n\n\t@ForPetesSake(\"B\")\n\t@ForTheLoveOfFoo(\"C\")\n\t@PeteRepeat(\"A\")\n\tstatic class ComposedRepeatableClass {\n\t}\n\n\t@ForPetesSake(\"C\")\n\t@PeteRepeats(@PeteRepeat(\"A\"))\n\t@PeteRepeat(\"B\")\n\tstatic class ComposedRepeatableMixedWithContainerClass {\n\t}\n\n\t@PeteRepeat(\"A\")\n\t@ComposedContainer\n\tstatic class ComposedContainerClass {\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Noninheriteds {\n\n\t\tNoninherited[] value();\n\t}\n\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(Noninheriteds.class)\n\t@interface Noninherited {\n\n\t\t@AliasFor(\"name\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString name() default \"\";\n\t}\n\n\t@Noninherited(name = \"shadowed\")\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedNoninherited {\n\n\t\t@AliasFor(annotation = Noninherited.class)\n\t\tString name() default \"\";\n\t}\n\n\t@ComposedNoninherited(name = \"C\")\n\t@Noninheriteds({ @Noninherited(value = \"A\"), @Noninherited(name = \"B\") })\n\tstatic class NoninheritedRepeatableClass {\n\t}\n\n\tstatic class SubNoninheritedRepeatableClass extends NoninheritedRepeatableClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@PeteRepeat(\"A\")\n\t@PeteRepeat(\"B\")\n\t@interface WithRepeatedMetaAnnotations {\n\t}\n\n\t@WithRepeatedMetaAnnotations\n\t@PeteRepeat(\"C\")\n\t@Noninherited(\"X\")\n\t@Noninherited(\"Y\")\n\tstatic class WithRepeatedMetaAnnotationsClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContainerWithMultipleAttributes {\n\n\t\tRepeatableWithContainerWithMultipleAttributes[] value();\n\n\t\tString name() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(ContainerWithMultipleAttributes.class)\n\t@interface RepeatableWithContainerWithMultipleAttributes {\n\n\t\tString value() default \"\";\n\t}\n\n\t@ContainerWithMultipleAttributes(name = \"enigma\", value = {\n\t\t@RepeatableWithContainerWithMultipleAttributes(\"A\"),\n\t\t@RepeatableWithContainerWithMultipleAttributes(\"B\")\n\t})\n\t@RepeatableWithContainerWithMultipleAttributes(\"C\")\n\tstatic class StandardRepeatablesWithContainerWithMultipleAttributesTestCase {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.NoninheritedRepeatableClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.NoninheritedRepeatableClass",
    "headType": "class",
    "relation": "use",
    "tail": "@ComposedNoninherited",
    "tailType": "annotation"
  }
]