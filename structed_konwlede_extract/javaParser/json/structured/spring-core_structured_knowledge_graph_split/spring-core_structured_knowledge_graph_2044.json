[
  {
    "head": "org.springframework.core.io.support.PathMatchingResourcePatternResolverTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.io.support.PathMatchingResourcePatternResolverTests#assertExactFilenames(String,String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.io.support.PathMatchingResourcePatternResolverTests#assertFilenames(String,boolean,String)",
    "headType": "method",
    "relation": "provide",
    "tail": "private void assertFilenames(String pattern, boolean exactly, String... filenames) {\r\n    try {\r\n        Resource[] resources = resolver.getResources(pattern);\r\n        List<String> actualNames = Arrays.stream(resources).peek(resource -> assertThat(resource.exists()).as(resource + \" exists\").isTrue()).map(Resource::getFilename).sorted().toList();\r\n        // Uncomment the following if you encounter problems with matching against the file system.\r\n        // List<String> expectedNames = Arrays.stream(filenames).sorted().toList();\r\n        // System.out.println(\"----------------------------------------------------------------------\");\r\n        // System.out.println(\"Expected: \" + expectedNames);\r\n        // System.out.println(\"Actual: \" + actualNames);\r\n        // Arrays.stream(resources).forEach(System.out::println);\r\n        if (exactly) {\r\n            assertThat(actualNames).as(\"subset of files found\").containsExactlyInAnyOrder(filenames);\r\n        } else {\r\n            assertThat(actualNames).as(\"subset of files found\").contains(filenames);\r\n        }\r\n    } catch (IOException ex) {\r\n        throw new UncheckedIOException(ex);\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.io.support.PathMatchingResourcePatternResolverTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.io.support.PathMatchingResourcePatternResolverTests#assertFilenames(String,boolean,String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.io.support.PathMatchingResourcePatternResolverTests#assertExactSubPaths(String,String,String)",
    "headType": "method",
    "relation": "provide",
    "tail": "private void assertExactSubPaths(String pattern, String pathPrefix, String... subPaths) {\r\n    try {\r\n        Resource[] resources = resolver.getResources(pattern);\r\n        List<String> actualSubPaths = Arrays.stream(resources).map(resource -> getPath(resource).replaceFirst(pathPrefix, \"\")).sorted().toList();\r\n        assertThat(actualSubPaths).containsExactlyInAnyOrder(subPaths);\r\n    } catch (IOException ex) {\r\n        throw new UncheckedIOException(ex);\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.io.support.PathMatchingResourcePatternResolverTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.io.support.PathMatchingResourcePatternResolverTests#assertExactSubPaths(String,String,String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.io.support.PathMatchingResourcePatternResolverTests#getPath(Resource)",
    "headType": "method",
    "relation": "provide",
    "tail": "private String getPath(Resource resource) {\r\n    // Tests fail if we use resource.getURL().getPath(). They would also fail on macOS when\r\n    // using resource.getURI().getPath() if the resource paths are not Unicode normalized.\r\n    //\r\n    // On the JVM, all tests should pass when using resource.getFile().getPath(); however,\r\n    // we use FileSystemResource#getPath since this test class is sometimes run within a\r\n    // GraalVM native image which cannot support Path#toFile.\r\n    //\r\n    // See: https://github.com/spring-projects/spring-framework/issues/29243\r\n    if (resource instanceof FileSystemResource fileSystemResource) {\r\n        return fileSystemResource.getPath();\r\n    }\r\n    try {\r\n        // Fall back to URL in case the resource came from a JAR\r\n        return resource.getURL().getPath();\r\n    } catch (IOException ex) {\r\n        throw new UncheckedIOException(ex);\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.io.support.PathMatchingResourcePatternResolverTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.io.support.PathMatchingResourcePatternResolverTests#getPath(Resource)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.io.support",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.io.support.InvalidPatterns",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.io.support.InvalidPatterns",
    "headType": "class",
    "relation": "use",
    "tail": "@Nested",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.io.support.InvalidPatterns",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.io.support;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\nimport java.net.JarURLConnection;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.net.URLConnection;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.jar.Attributes;\nimport java.util.jar.Attributes.Name;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarFile;\nimport java.util.jar.JarOutputStream;\nimport java.util.jar.Manifest;\nimport java.util.stream.Collectors;\nimport java.util.zip.ZipEntry;\n\nimport org.apache.commons.logging.LogFactory;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\nimport org.springframework.core.io.DefaultResourceLoader;\nimport org.springframework.core.io.FileSystemResource;\nimport org.springframework.core.io.Resource;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.FileSystemUtils;\nimport org.springframework.util.StreamUtils;\nimport org.springframework.util.StringUtils;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n\n/**\n * Tests for {@link PathMatchingResourcePatternResolver}.\n *\n * <p>If tests fail, uncomment the diagnostics in {@link #assertFilenames(String, boolean, String...)}.\n *\n * @author Oliver Hutchison\n * @author Juergen Hoeller\n * @author Chris Beams\n * @author Sam Brannen\n * @since 17.11.2004\n */\nclass PathMatchingResourcePatternResolverTests {\n\n\tprivate static final String[] CLASSES_IN_CORE_IO_SUPPORT = {\"EncodedResource.class\",\n\t\t\t\"LocalizedResourceHelper.class\", \"PathMatchingResourcePatternResolver.class\", \"PropertiesLoaderSupport.class\",\n\t\t\t\"PropertiesLoaderUtils.class\", \"ResourceArrayPropertyEditor.class\", \"ResourcePatternResolver.class\",\n\t\t\t\"ResourcePatternUtils.class\", \"SpringFactoriesLoader.class\"};\n\n\tprivate static final String[] TEST_CLASSES_IN_CORE_IO_SUPPORT = {\"PathMatchingResourcePatternResolverTests.class\"};\n\n\tprivate static final String[] CLASSES_IN_REACTOR_UTIL_ANNOTATION =\n\t\t\t{\"Incubating.class\", \"NonNull.class\", \"NonNullApi.class\", \"Nullable.class\"};\n\n\n\tprivate PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();\n\n\n\t@Nested\n\tclass InvalidPatterns {\n\n\t\t@Test\n\t\tvoid invalidPrefixWithPatternElementInItThrowsException() {\n\t\t\tassertThatExceptionOfType(FileNotFoundException.class).isThrownBy(() -> resolver.getResources(\"xx**:**/*.xy\"));\n\t\t}\n\t}\n\n\n\t@Nested\n\tclass FileSystemResources {\n\n\t\t@Test\n\t\tvoid singleResourceOnFileSystem() {\n\t\t\tString pattern = \"org/springframework/core/io/support/PathMatchingResourcePatternResolverTests.class\";\n\t\t\tassertExactFilenames(pattern, \"PathMatchingResourcePatternResolverTests.class\");\n\t\t}\n\n\t\t@Test\n\t\tvoid classpathStarWithPatternOnFileSystem() {\n\t\t\tString pattern = \"classpath*:org/springframework/core/io/sup*/*.class\";\n\t\t\tString[] expectedFilenames = StringUtils.concatenateStringArrays(CLASSES_IN_CORE_IO_SUPPORT, TEST_CLASSES_IN_CORE_IO_SUPPORT);\n\t\t\tassertFilenames(pattern, expectedFilenames);\n\t\t}\n\n\t\t@Test  // gh-31111\n\t\tvoid usingFileProtocolWithWildcardInPatternAndNonexistentRootPath() throws IOException {\n\t\t\tPath testResourcesDir = Paths.get(\"src/test/resources\").toAbsolutePath();\n\t\t\tString pattern = String.format(\"file:%s/example/bogus/**\", testResourcesDir);\n\t\t\tassertThat(resolver.getResources(pattern)).isEmpty();\n\t\t\t// When the log level for the resolver is set to at least INFO, we should see\n\t\t\t// a log entry similar to the following.\n\t\t\t//\n\t\t\t// [main] INFO  o.s.c.i.s.PathMatchingResourcePatternResolver -\n\t\t\t// Skipping search for files matching pattern [**]: directory\n\t\t\t// [/<...>/spring-core/src/test/resources/example/bogus] does not exist\n\t\t}\n\n\t\t@Test\n\t\tvoid encodedHashtagInPath() throws IOException {\n\t\t\tPath rootDir = Paths.get(\"src/test/resources/custom%23root\").toAbsolutePath();\n\t\t\tURL root = new URL(\"file:\" + rootDir + \"/\");\n\t\t\tresolver = new PathMatchingResourcePatternResolver(new DefaultResourceLoader(new URLClassLoader(new URL[] {root})));\n\t\t\tassertExactFilenames(\"classpath*:scanned/*.txt\", \"resource#test1.txt\", \"resource#test2.txt\");\n\t\t}\n\n\t\t@Nested\n\t\tclass WithHashtagsInTheirFilenames {\n\n\t\t\t@Test\n\t\t\tvoid usingClasspathStarProtocol() {\n\t\t\t\tString pattern = \"classpath*:org/springframework/core/io/**/resource#test*.txt\";\n\t\t\t\tString pathPrefix = \".+org/springframework/core/io/\";\n\n\t\t\t\tassertExactFilenames(pattern, \"resource#test1.txt\", \"resource#test2.txt\");\n\t\t\t\tassertExactSubPaths(pattern, pathPrefix, \"support/resource#test1.txt\", \"support/resource#test2.txt\");\n\t\t\t}\n\n\t\t\t@Test\n\t\t\tvoid usingClasspathStarProtocolWithWildcardInPatternAndNotEndingInSlash() throws Exception {\n\t\t\t\tString pattern = \"classpath*:org/springframework/core/io/sup*\";\n\t\t\t\tString pathPrefix = \".+org/springframework/core/io/\";\n\n\t\t\t\tList<String> actualSubPaths = getSubPathsIgnoringClassFilesEtc(pattern, pathPrefix);\n\n\t\t\t\t// We DO find \"support\" if the pattern does NOT end with a slash.\n\t\t\t\tassertThat(actualSubPaths).containsExactly(\"support\");\n\t\t\t}\n\n\t\t\t@Test\n\t\t\tvoid usingFileProtocolWithWildcardInPatternAndNotEndingInSlash() throws Exception {\n\t\t\t\tPath testResourcesDir = Paths.get(\"src/test/resources\").toAbsolutePath();\n\t\t\t\tString pattern = String.format(\"file:%s/org/springframework/core/io/sup*\", testResourcesDir);\n\t\t\t\tString pathPrefix = \".+org/springframework/core/io/\";\n\n\t\t\t\tList<String> actualSubPaths = getSubPathsIgnoringClassFilesEtc(pattern, pathPrefix);\n\n\t\t\t\t// We DO find \"support\" if the pattern does NOT end with a slash.\n\t\t\t\tassertThat(actualSubPaths).containsExactly(\"support\");\n\t\t\t}\n\n\t\t\t@Test\n\t\t\tvoid usingClasspathStarProtocolWithWildcardInPatternAndEndingInSlash() throws Exception {\n\t\t\t\tString pattern = \"classpath*:org/springframework/core/io/sup*/\";\n\t\t\t\tString pathPrefix = \".+org/springframework/core/io/\";\n\n\t\t\t\tList<String> actualSubPaths = getSubPathsIgnoringClassFilesEtc(pattern, pathPrefix);\n\n\t\t\t\tURL url = getClass().getClassLoader().getResource(\"org/springframework/core/io/support/EncodedResource.class\");\n\t\t\t\tif (!url.getProtocol().equals(\"jar\")) {\n\t\t\t\t\t// We do NOT find \"support\" if the pattern ENDS with a slash if org/springframework/core/io/support\n\t\t\t\t\t// is in the local file system.\n\t\t\t\t\tassertThat(actualSubPaths).isEmpty();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// But we do find \"support/\" if org/springframework/core/io/support is found in a JAR on the classpath.\n\t\t\t\t\tassertThat(actualSubPaths).containsExactly(\"support/\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Test\n\t\t\tvoid usingFileProtocolWithWildcardInPatternAndEndingInSlash() throws Exception {\n\t\t\t\tPath testResourcesDir = Paths.get(\"src/test/resources\").toAbsolutePath();\n\t\t\t\tString pattern = String.format(\"file:%s/org/springframework/core/io/sup*/\", testResourcesDir);\n\t\t\t\tString pathPrefix = \".+org/springframework/core/io/\";\n\n\t\t\t\tList<String> actualSubPaths = getSubPathsIgnoringClassFilesEtc(pattern, pathPrefix);\n\n\t\t\t\t// We do NOT find \"support\" if the pattern ENDS with a slash.\n\t\t\t\tassertThat(actualSubPaths).isEmpty();\n\t\t\t}\n\n\t\t\t@Test\n\t\t\tvoid usingClasspathStarProtocolWithWildcardInPatternAndEndingWithSuffixPattern() throws Exception {\n\t\t\t\tString pattern = \"classpath*:org/springframework/core/io/sup*/*.txt\";\n\t\t\t\tString pathPrefix = \".+org/springframework/core/io/\";\n\n\t\t\t\tList<String> actualSubPaths = getSubPathsIgnoringClassFilesEtc(pattern, pathPrefix);\n\n\t\t\t\tassertThat(actualSubPaths)\n\t\t\t\t\t\t.containsExactlyInAnyOrder(\"support/resource#test1.txt\", \"support/resource#test2.txt\");\n\t\t\t}\n\n\t\t\tprivate List<String> getSubPathsIgnoringClassFilesEtc(String pattern, String pathPrefix) throws IOException {\n\t\t\t\treturn Arrays.stream(resolver.getResources(pattern))\n\t\t\t\t\t\t.map(resource -> getPath(resource).replaceFirst(pathPrefix, \"\"))\n\t\t\t\t\t\t.filter(name -> !name.endsWith(\".class\"))\n\t\t\t\t\t\t.filter(name -> !name.endsWith(\".kt\"))\n\t\t\t\t\t\t.filter(name -> !name.endsWith(\".factories\"))\n\t\t\t\t\t\t.distinct()\n\t\t\t\t\t\t.sorted()\n\t\t\t\t\t\t.collect(Collectors.toList());\n\t\t\t}\n\n\t\t\t@Test\n\t\t\tvoid usingFileProtocolWithoutWildcardInPatternAndEndingInSlashStarStar() {\n\t\t\t\tPath testResourcesDir = Paths.get(\"src/test/resources\").toAbsolutePath();\n\t\t\t\tString pattern = String.format(\"file:%s/scanned-resources/**\", testResourcesDir);\n\t\t\t\tString pathPrefix = \".+?resources/\";\n\n\t\t\t\t// We do NOT find \"scanned-resources\" if the pattern ENDS with \"/**\" AND does NOT otherwise contain a wildcard.\n\t\t\t\tassertExactFilenames(pattern, \"resource#test1.txt\", \"resource#test2.txt\");\n\t\t\t\tassertExactSubPaths(pattern, pathPrefix, \"scanned-resources/resource#test1.txt\",\n\t\t\t\t\t\t\"scanned-resources/resource#test2.txt\");\n\t\t\t}\n\n\t\t\t@Test\n\t\t\tvoid usingFileProtocolWithWildcardInPatternAndEndingInSlashStarStar() {\n\t\t\t\tPath testResourcesDir = Paths.get(\"src/test/resources\").toAbsolutePath();\n\t\t\t\tString pattern = String.format(\"file:%s/scanned*resources/**\", testResourcesDir);\n\t\t\t\tString pathPrefix = \".+?resources/\";\n\n\t\t\t\t// We DO find \"scanned-resources\" if the pattern ENDS with \"/**\" AND DOES otherwise contain a wildcard.\n\t\t\t\tassertExactFilenames(pattern, \"scanned-resources\", \"resource#test1.txt\", \"resource#test2.txt\");\n\t\t\t\tassertExactSubPaths(pattern, pathPrefix, \"scanned-resources\", \"scanned-resources/resource#test1.txt\",\n\t\t\t\t\t\t\"scanned-resources/resource#test2.txt\");\n\t\t\t}\n\n\t\t\t@Test\n\t\t\tvoid usingFileProtocolAndAssertingUrlAndUriSyntax() throws Exception {\n\t\t\t\tPath testResourcesDir = Paths.get(\"src/test/resources\").toAbsolutePath();\n\t\t\t\tString pattern = \"file:%s/scanned-resources/**/resource#test1.txt\".formatted(testResourcesDir);\n\t\t\t\tResource[] resources = resolver.getResources(pattern);\n\t\t\t\tassertThat(resources).hasSize(1);\n\t\t\t\tResource resource = resources[0];\n\t\t\t\tassertThat(resource.getFilename()).isEqualTo(\"resource#test1.txt\");\n\t\t\t\t// The following assertions serve as regression tests for the lack of the\n\t\t\t\t// \"authority component\" (//) in the returned URI/URL. For example, we are\n\t\t\t\t// expecting file:/my/path (or file:/C:/My/Path) instead of file:///my/path.\n\t\t\t\tassertThat(resource.getURL().toString()).matches(\"^file:\\\\/[^\\\\/].+test1\\\\.txt$\");\n\t\t\t\tassertThat(resource.getURI().toString()).matches(\"^file:\\\\/[^\\\\/].+test1\\\\.txt$\");\n\t\t\t}\n\t\t}\n\t}\n\n\n\t@Nested\n\tclass JarResources {\n\n\t\t@Test\n\t\tvoid singleResourceInJar() {\n\t\t\tString pattern = \"org/reactivestreams/Publisher.class\";\n\t\t\tassertExactFilenames(pattern, \"Publisher.class\");\n\t\t}\n\n\t\t@Test\n\t\tvoid singleResourceInRootOfJar() {\n\t\t\tString pattern = \"aspectj_1_5_0.dtd\";\n\t\t\tassertExactFilenames(pattern, \"aspectj_1_5_0.dtd\");\n\t\t}\n\n\t\t@Test\n\t\tvoid classpathWithPatternInJar() {\n\t\t\tString pattern = \"classpath:reactor/util/annotation/*.class\";\n\t\t\tassertExactFilenames(pattern, CLASSES_IN_REACTOR_UTIL_ANNOTATION);\n\t\t}\n\n\t\t@Test\n\t\tvoid classpathStarWithPatternInJar() {\n\t\t\tString pattern = \"classpath*:reactor/util/annotation/*.class\";\n\t\t\tassertExactFilenames(pattern, CLASSES_IN_REACTOR_UTIL_ANNOTATION);\n\t\t}\n\n\t\t// Fails in a native image -- https://github.com/oracle/graal/issues/5020\n\t\t@Test\n\t\tvoid rootPatternRetrievalInJarFiles() throws IOException {\n\t\t\tassertThat(resolver.getResources(\"classpath*:aspectj*.dtd\")).extracting(Resource::getFilename)\n\t\t\t\t.as(\"Could not find aspectj_1_5_0.dtd in the root of the aspectjweaver jar\")\n\t\t\t\t.containsExactly(\"aspectj_1_5_0.dtd\");\n\t\t}\n\t}\n\n\t@Nested\n\tclass ClassPathManifestEntries {\n\n\t\t@TempDir\n\t\tPath temp;\n\n\t\t@Test\n\t\tvoid javaDashJarFindsClassPathManifestEntries() throws Exception {\n\t\t\tPath lib = this.temp.resolve(\"lib\");\n\t\t\tFiles.createDirectories(lib);\n\t\t\twriteAssetJar(lib.resolve(\"asset.jar\"));\n\t\t\twriteApplicationJar(this.temp.resolve(\"app.jar\"));\n\t\t\tString java = ProcessHandle.current().info().command().get();\n\t\t\tProcess process = new ProcessBuilder(java, \"-jar\", \"app.jar\")\n\t\t\t\t.directory(this.temp.toFile())\n\t\t\t\t.start();\n\t\t\tassertThat(process.waitFor()).isZero();\n\t\t\tString result = StreamUtils.copyToString(process.getInputStream(), StandardCharsets.UTF_8);\n\t\t\tassertThat(result.replace(\"\\\\\", \"/\")).contains(\"!!!!\").contains(\"/lib/asset.jar!/assets/file.txt\");\n\t\t}\n\n\t\tprivate void writeAssetJar(Path path) throws Exception {\n\t\t\ttry (JarOutputStream jar = new JarOutputStream(new FileOutputStream(path.toFile()))) {\n\t\t\t\tjar.putNextEntry(new ZipEntry(\"assets/\"));\n\t\t\t\tjar.closeEntry();\n\t\t\t\tjar.putNextEntry(new ZipEntry(\"assets/file.txt\"));\n\t\t\t\tStreamUtils.copy(\"test\", StandardCharsets.UTF_8, jar);\n\t\t\t\tjar.closeEntry();\n\t\t\t}\n\t\t}\n\n\t\tprivate void writeApplicationJar(Path path) throws Exception {\n\t\t\tManifest manifest = new Manifest();\n\t\t\tAttributes mainAttributes = manifest.getMainAttributes();\n\t\t\tmainAttributes.put(Name.CLASS_PATH, buildSpringClassPath() + \"lib/asset.jar\");\n\t\t\tmainAttributes.put(Name.MAIN_CLASS, ClassPathManifestEntriesTestApplication.class.getName());\n\t\t\tmainAttributes.put(Name.MANIFEST_VERSION, \"1.0\");\n\t\t\ttry (JarOutputStream jar = new JarOutputStream(new FileOutputStream(path.toFile()), manifest)) {\n\t\t\t\tString appClassResource = ClassUtils.convertClassNameToResourcePath(\n\t\t\t\t\t\tClassPathManifestEntriesTestApplication.class.getName())\n\t\t\t\t\t\t+ ClassUtils.CLASS_FILE_SUFFIX;\n\t\t\t\tString folder = \"\";\n\t\t\t\tfor (String name : appClassResource.split(\"/\")) {\n\t\t\t\t\tif (!name.endsWith(ClassUtils.CLASS_FILE_SUFFIX)) {\n\t\t\t\t\t\tfolder += name + \"/\";\n\t\t\t\t\t\tjar.putNextEntry(new ZipEntry(folder));\n\t\t\t\t\t\tjar.closeEntry();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tjar.putNextEntry(new ZipEntry(folder + name));\n\t\t\t\t\t\ttry (InputStream in = getClass().getResourceAsStream(name)) {\n\t\t\t\t\t\t\tin.transferTo(jar);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjar.closeEntry();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate String buildSpringClassPath() throws Exception {\n\t\t\treturn copyClasses(PathMatchingResourcePatternResolver.class, \"spring-core\")\n\t\t\t\t\t+ copyClasses(LogFactory.class, \"commons-logging\");\n\t\t}\n\n\t\tprivate String copyClasses(Class<?> sourceClass, String destinationName)\n\t\t\t\tthrows URISyntaxException, IOException {\n\t\t\tPath destination = this.temp.resolve(destinationName);\n\t\t\tString resourcePath = ClassUtils.convertClassNameToResourcePath(sourceClass.getName())\n\t\t\t\t\t+ ClassUtils.CLASS_FILE_SUFFIX;\n\t\t\tURL resource = getClass().getClassLoader().getResource(resourcePath);\n\t\t\tURL url = new URL(resource.toString().replace(resourcePath, \"\"));\n\t\t\tURLConnection connection = url.openConnection();\n\t\t\tif (connection instanceof JarURLConnection jarUrlConnection) {\n\t\t\t\ttry (JarFile jarFile = jarUrlConnection.getJarFile()) {\n\t\t\t\t\tEnumeration<JarEntry> entries = jarFile.entries();\n\t\t\t\t\twhile (entries.hasMoreElements()) {\n\t\t\t\t\t\tJarEntry entry = entries.nextElement();\n\t\t\t\t\t\tif (!entry.isDirectory()) {\n\t\t\t\t\t\t\tPath entryPath = destination.resolve(entry.getName());\n\t\t\t\t\t\t\ttry (InputStream in = jarFile.getInputStream(entry)) {\n\t\t\t\t\t\t\t\tFiles.createDirectories(entryPath.getParent());\n\t\t\t\t\t\t\t\tFiles.copy(in, destination.resolve(entry.getName()));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFile source = new File(url.toURI());\n\t\t\t\tFiles.createDirectories(destination);\n\t\t\t\tFileSystemUtils.copyRecursively(source, destination.toFile());\n\t\t\t}\n\t\t\treturn destinationName + \"/ \";\n\t\t}\n\n\t}\n\n\n\tprivate void assertFilenames(String pattern, String... filenames) {\n\t\tassertFilenames(pattern, false, filenames);\n\t}\n\n\tprivate void assertExactFilenames(String pattern, String... filenames) {\n\t\tassertFilenames(pattern, true, filenames);\n\t}\n\n\tprivate void assertFilenames(String pattern, boolean exactly, String... filenames) {\n\t\ttry {\n\t\t\tResource[] resources = resolver.getResources(pattern);\n\t\t\tList<String> actualNames = Arrays.stream(resources)\n\t\t\t\t\t.peek(resource -> assertThat(resource.exists()).as(resource + \" exists\").isTrue())\n\t\t\t\t\t.map(Resource::getFilename)\n\t\t\t\t\t.sorted()\n\t\t\t\t\t.toList();\n\n\t\t\t// Uncomment the following if you encounter problems with matching against the file system.\n\t\t\t// List<String> expectedNames = Arrays.stream(filenames).sorted().toList();\n\t\t\t// System.out.println(\"----------------------------------------------------------------------\");\n\t\t\t// System.out.println(\"Expected: \" + expectedNames);\n\t\t\t// System.out.println(\"Actual: \" + actualNames);\n\t\t\t// Arrays.stream(resources).forEach(System.out::println);\n\n\t\t\tif (exactly) {\n\t\t\t\tassertThat(actualNames).as(\"subset of files found\").containsExactlyInAnyOrder(filenames);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassertThat(actualNames).as(\"subset of files found\").contains(filenames);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new UncheckedIOException(ex);\n\t\t}\n\t}\n\n\tprivate void assertExactSubPaths(String pattern, String pathPrefix, String... subPaths) {\n\t\ttry {\n\t\t\tResource[] resources = resolver.getResources(pattern);\n\t\t\tList<String> actualSubPaths = Arrays.stream(resources)\n\t\t\t\t\t.map(resource -> getPath(resource).replaceFirst(pathPrefix, \"\"))\n\t\t\t\t\t.sorted()\n\t\t\t\t\t.toList();\n\t\t\tassertThat(actualSubPaths).containsExactlyInAnyOrder(subPaths);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new UncheckedIOException(ex);\n\t\t}\n\t}\n\n\tprivate String getPath(Resource resource) {\n\t\t// Tests fail if we use resource.getURL().getPath(). They would also fail on macOS when\n\t\t// using resource.getURI().getPath() if the resource paths are not Unicode normalized.\n\t\t//\n\t\t// On the JVM, all tests should pass when using resource.getFile().getPath(); however,\n\t\t// we use FileSystemResource#getPath since this test class is sometimes run within a\n\t\t// GraalVM native image which cannot support Path#toFile.\n\t\t//\n\t\t// See: https://github.com/spring-projects/spring-framework/issues/29243\n\t\tif (resource instanceof FileSystemResource fileSystemResource) {\n\t\t\treturn fileSystemResource.getPath();\n\t\t}\n\t\ttry {\n\t\t\t// Fall back to URL in case the resource came from a JAR\n\t\t\treturn resource.getURL().getPath();\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new UncheckedIOException(ex);\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.io.support.InvalidPatterns#invalidPrefixWithPatternElementInItThrowsException()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid invalidPrefixWithPatternElementInItThrowsException() {\r\n    assertThatExceptionOfType(FileNotFoundException.class).isThrownBy(() -> resolver.getResources(\"xx**:**/*.xy\"));\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.io.support.InvalidPatterns",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.io.support.InvalidPatterns#invalidPrefixWithPatternElementInItThrowsException()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.io.support.InvalidPatterns#invalidPrefixWithPatternElementInItThrowsException()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.io.support",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.io.support.FileSystemResources",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.io.support.FileSystemResources",
    "headType": "class",
    "relation": "use",
    "tail": "@Nested",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.io.support.FileSystemResources",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.io.support;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\nimport java.net.JarURLConnection;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.net.URLConnection;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.jar.Attributes;\nimport java.util.jar.Attributes.Name;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarFile;\nimport java.util.jar.JarOutputStream;\nimport java.util.jar.Manifest;\nimport java.util.stream.Collectors;\nimport java.util.zip.ZipEntry;\n\nimport org.apache.commons.logging.LogFactory;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\nimport org.springframework.core.io.DefaultResourceLoader;\nimport org.springframework.core.io.FileSystemResource;\nimport org.springframework.core.io.Resource;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.FileSystemUtils;\nimport org.springframework.util.StreamUtils;\nimport org.springframework.util.StringUtils;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n\n/**\n * Tests for {@link PathMatchingResourcePatternResolver}.\n *\n * <p>If tests fail, uncomment the diagnostics in {@link #assertFilenames(String, boolean, String...)}.\n *\n * @author Oliver Hutchison\n * @author Juergen Hoeller\n * @author Chris Beams\n * @author Sam Brannen\n * @since 17.11.2004\n */\nclass PathMatchingResourcePatternResolverTests {\n\n\tprivate static final String[] CLASSES_IN_CORE_IO_SUPPORT = {\"EncodedResource.class\",\n\t\t\t\"LocalizedResourceHelper.class\", \"PathMatchingResourcePatternResolver.class\", \"PropertiesLoaderSupport.class\",\n\t\t\t\"PropertiesLoaderUtils.class\", \"ResourceArrayPropertyEditor.class\", \"ResourcePatternResolver.class\",\n\t\t\t\"ResourcePatternUtils.class\", \"SpringFactoriesLoader.class\"};\n\n\tprivate static final String[] TEST_CLASSES_IN_CORE_IO_SUPPORT = {\"PathMatchingResourcePatternResolverTests.class\"};\n\n\tprivate static final String[] CLASSES_IN_REACTOR_UTIL_ANNOTATION =\n\t\t\t{\"Incubating.class\", \"NonNull.class\", \"NonNullApi.class\", \"Nullable.class\"};\n\n\n\tprivate PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();\n\n\n\t@Nested\n\tclass InvalidPatterns {\n\n\t\t@Test\n\t\tvoid invalidPrefixWithPatternElementInItThrowsException() {\n\t\t\tassertThatExceptionOfType(FileNotFoundException.class).isThrownBy(() -> resolver.getResources(\"xx**:**/*.xy\"));\n\t\t}\n\t}\n\n\n\t@Nested\n\tclass FileSystemResources {\n\n\t\t@Test\n\t\tvoid singleResourceOnFileSystem() {\n\t\t\tString pattern = \"org/springframework/core/io/support/PathMatchingResourcePatternResolverTests.class\";\n\t\t\tassertExactFilenames(pattern, \"PathMatchingResourcePatternResolverTests.class\");\n\t\t}\n\n\t\t@Test\n\t\tvoid classpathStarWithPatternOnFileSystem() {\n\t\t\tString pattern = \"classpath*:org/springframework/core/io/sup*/*.class\";\n\t\t\tString[] expectedFilenames = StringUtils.concatenateStringArrays(CLASSES_IN_CORE_IO_SUPPORT, TEST_CLASSES_IN_CORE_IO_SUPPORT);\n\t\t\tassertFilenames(pattern, expectedFilenames);\n\t\t}\n\n\t\t@Test  // gh-31111\n\t\tvoid usingFileProtocolWithWildcardInPatternAndNonexistentRootPath() throws IOException {\n\t\t\tPath testResourcesDir = Paths.get(\"src/test/resources\").toAbsolutePath();\n\t\t\tString pattern = String.format(\"file:%s/example/bogus/**\", testResourcesDir);\n\t\t\tassertThat(resolver.getResources(pattern)).isEmpty();\n\t\t\t// When the log level for the resolver is set to at least INFO, we should see\n\t\t\t// a log entry similar to the following.\n\t\t\t//\n\t\t\t// [main] INFO  o.s.c.i.s.PathMatchingResourcePatternResolver -\n\t\t\t// Skipping search for files matching pattern [**]: directory\n\t\t\t// [/<...>/spring-core/src/test/resources/example/bogus] does not exist\n\t\t}\n\n\t\t@Test\n\t\tvoid encodedHashtagInPath() throws IOException {\n\t\t\tPath rootDir = Paths.get(\"src/test/resources/custom%23root\").toAbsolutePath();\n\t\t\tURL root = new URL(\"file:\" + rootDir + \"/\");\n\t\t\tresolver = new PathMatchingResourcePatternResolver(new DefaultResourceLoader(new URLClassLoader(new URL[] {root})));\n\t\t\tassertExactFilenames(\"classpath*:scanned/*.txt\", \"resource#test1.txt\", \"resource#test2.txt\");\n\t\t}\n\n\t\t@Nested\n\t\tclass WithHashtagsInTheirFilenames {\n\n\t\t\t@Test\n\t\t\tvoid usingClasspathStarProtocol() {\n\t\t\t\tString pattern = \"classpath*:org/springframework/core/io/**/resource#test*.txt\";\n\t\t\t\tString pathPrefix = \".+org/springframework/core/io/\";\n\n\t\t\t\tassertExactFilenames(pattern, \"resource#test1.txt\", \"resource#test2.txt\");\n\t\t\t\tassertExactSubPaths(pattern, pathPrefix, \"support/resource#test1.txt\", \"support/resource#test2.txt\");\n\t\t\t}\n\n\t\t\t@Test\n\t\t\tvoid usingClasspathStarProtocolWithWildcardInPatternAndNotEndingInSlash() throws Exception {\n\t\t\t\tString pattern = \"classpath*:org/springframework/core/io/sup*\";\n\t\t\t\tString pathPrefix = \".+org/springframework/core/io/\";\n\n\t\t\t\tList<String> actualSubPaths = getSubPathsIgnoringClassFilesEtc(pattern, pathPrefix);\n\n\t\t\t\t// We DO find \"support\" if the pattern does NOT end with a slash.\n\t\t\t\tassertThat(actualSubPaths).containsExactly(\"support\");\n\t\t\t}\n\n\t\t\t@Test\n\t\t\tvoid usingFileProtocolWithWildcardInPatternAndNotEndingInSlash() throws Exception {\n\t\t\t\tPath testResourcesDir = Paths.get(\"src/test/resources\").toAbsolutePath();\n\t\t\t\tString pattern = String.format(\"file:%s/org/springframework/core/io/sup*\", testResourcesDir);\n\t\t\t\tString pathPrefix = \".+org/springframework/core/io/\";\n\n\t\t\t\tList<String> actualSubPaths = getSubPathsIgnoringClassFilesEtc(pattern, pathPrefix);\n\n\t\t\t\t// We DO find \"support\" if the pattern does NOT end with a slash.\n\t\t\t\tassertThat(actualSubPaths).containsExactly(\"support\");\n\t\t\t}\n\n\t\t\t@Test\n\t\t\tvoid usingClasspathStarProtocolWithWildcardInPatternAndEndingInSlash() throws Exception {\n\t\t\t\tString pattern = \"classpath*:org/springframework/core/io/sup*/\";\n\t\t\t\tString pathPrefix = \".+org/springframework/core/io/\";\n\n\t\t\t\tList<String> actualSubPaths = getSubPathsIgnoringClassFilesEtc(pattern, pathPrefix);\n\n\t\t\t\tURL url = getClass().getClassLoader().getResource(\"org/springframework/core/io/support/EncodedResource.class\");\n\t\t\t\tif (!url.getProtocol().equals(\"jar\")) {\n\t\t\t\t\t// We do NOT find \"support\" if the pattern ENDS with a slash if org/springframework/core/io/support\n\t\t\t\t\t// is in the local file system.\n\t\t\t\t\tassertThat(actualSubPaths).isEmpty();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// But we do find \"support/\" if org/springframework/core/io/support is found in a JAR on the classpath.\n\t\t\t\t\tassertThat(actualSubPaths).containsExactly(\"support/\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Test\n\t\t\tvoid usingFileProtocolWithWildcardInPatternAndEndingInSlash() throws Exception {\n\t\t\t\tPath testResourcesDir = Paths.get(\"src/test/resources\").toAbsolutePath();\n\t\t\t\tString pattern = String.format(\"file:%s/org/springframework/core/io/sup*/\", testResourcesDir);\n\t\t\t\tString pathPrefix = \".+org/springframework/core/io/\";\n\n\t\t\t\tList<String> actualSubPaths = getSubPathsIgnoringClassFilesEtc(pattern, pathPrefix);\n\n\t\t\t\t// We do NOT find \"support\" if the pattern ENDS with a slash.\n\t\t\t\tassertThat(actualSubPaths).isEmpty();\n\t\t\t}\n\n\t\t\t@Test\n\t\t\tvoid usingClasspathStarProtocolWithWildcardInPatternAndEndingWithSuffixPattern() throws Exception {\n\t\t\t\tString pattern = \"classpath*:org/springframework/core/io/sup*/*.txt\";\n\t\t\t\tString pathPrefix = \".+org/springframework/core/io/\";\n\n\t\t\t\tList<String> actualSubPaths = getSubPathsIgnoringClassFilesEtc(pattern, pathPrefix);\n\n\t\t\t\tassertThat(actualSubPaths)\n\t\t\t\t\t\t.containsExactlyInAnyOrder(\"support/resource#test1.txt\", \"support/resource#test2.txt\");\n\t\t\t}\n\n\t\t\tprivate List<String> getSubPathsIgnoringClassFilesEtc(String pattern, String pathPrefix) throws IOException {\n\t\t\t\treturn Arrays.stream(resolver.getResources(pattern))\n\t\t\t\t\t\t.map(resource -> getPath(resource).replaceFirst(pathPrefix, \"\"))\n\t\t\t\t\t\t.filter(name -> !name.endsWith(\".class\"))\n\t\t\t\t\t\t.filter(name -> !name.endsWith(\".kt\"))\n\t\t\t\t\t\t.filter(name -> !name.endsWith(\".factories\"))\n\t\t\t\t\t\t.distinct()\n\t\t\t\t\t\t.sorted()\n\t\t\t\t\t\t.collect(Collectors.toList());\n\t\t\t}\n\n\t\t\t@Test\n\t\t\tvoid usingFileProtocolWithoutWildcardInPatternAndEndingInSlashStarStar() {\n\t\t\t\tPath testResourcesDir = Paths.get(\"src/test/resources\").toAbsolutePath();\n\t\t\t\tString pattern = String.format(\"file:%s/scanned-resources/**\", testResourcesDir);\n\t\t\t\tString pathPrefix = \".+?resources/\";\n\n\t\t\t\t// We do NOT find \"scanned-resources\" if the pattern ENDS with \"/**\" AND does NOT otherwise contain a wildcard.\n\t\t\t\tassertExactFilenames(pattern, \"resource#test1.txt\", \"resource#test2.txt\");\n\t\t\t\tassertExactSubPaths(pattern, pathPrefix, \"scanned-resources/resource#test1.txt\",\n\t\t\t\t\t\t\"scanned-resources/resource#test2.txt\");\n\t\t\t}\n\n\t\t\t@Test\n\t\t\tvoid usingFileProtocolWithWildcardInPatternAndEndingInSlashStarStar() {\n\t\t\t\tPath testResourcesDir = Paths.get(\"src/test/resources\").toAbsolutePath();\n\t\t\t\tString pattern = String.format(\"file:%s/scanned*resources/**\", testResourcesDir);\n\t\t\t\tString pathPrefix = \".+?resources/\";\n\n\t\t\t\t// We DO find \"scanned-resources\" if the pattern ENDS with \"/**\" AND DOES otherwise contain a wildcard.\n\t\t\t\tassertExactFilenames(pattern, \"scanned-resources\", \"resource#test1.txt\", \"resource#test2.txt\");\n\t\t\t\tassertExactSubPaths(pattern, pathPrefix, \"scanned-resources\", \"scanned-resources/resource#test1.txt\",\n\t\t\t\t\t\t\"scanned-resources/resource#test2.txt\");\n\t\t\t}\n\n\t\t\t@Test\n\t\t\tvoid usingFileProtocolAndAssertingUrlAndUriSyntax() throws Exception {\n\t\t\t\tPath testResourcesDir = Paths.get(\"src/test/resources\").toAbsolutePath();\n\t\t\t\tString pattern = \"file:%s/scanned-resources/**/resource#test1.txt\".formatted(testResourcesDir);\n\t\t\t\tResource[] resources = resolver.getResources(pattern);\n\t\t\t\tassertThat(resources).hasSize(1);\n\t\t\t\tResource resource = resources[0];\n\t\t\t\tassertThat(resource.getFilename()).isEqualTo(\"resource#test1.txt\");\n\t\t\t\t// The following assertions serve as regression tests for the lack of the\n\t\t\t\t// \"authority component\" (//) in the returned URI/URL. For example, we are\n\t\t\t\t// expecting file:/my/path (or file:/C:/My/Path) instead of file:///my/path.\n\t\t\t\tassertThat(resource.getURL().toString()).matches(\"^file:\\\\/[^\\\\/].+test1\\\\.txt$\");\n\t\t\t\tassertThat(resource.getURI().toString()).matches(\"^file:\\\\/[^\\\\/].+test1\\\\.txt$\");\n\t\t\t}\n\t\t}\n\t}\n\n\n\t@Nested\n\tclass JarResources {\n\n\t\t@Test\n\t\tvoid singleResourceInJar() {\n\t\t\tString pattern = \"org/reactivestreams/Publisher.class\";\n\t\t\tassertExactFilenames(pattern, \"Publisher.class\");\n\t\t}\n\n\t\t@Test\n\t\tvoid singleResourceInRootOfJar() {\n\t\t\tString pattern = \"aspectj_1_5_0.dtd\";\n\t\t\tassertExactFilenames(pattern, \"aspectj_1_5_0.dtd\");\n\t\t}\n\n\t\t@Test\n\t\tvoid classpathWithPatternInJar() {\n\t\t\tString pattern = \"classpath:reactor/util/annotation/*.class\";\n\t\t\tassertExactFilenames(pattern, CLASSES_IN_REACTOR_UTIL_ANNOTATION);\n\t\t}\n\n\t\t@Test\n\t\tvoid classpathStarWithPatternInJar() {\n\t\t\tString pattern = \"classpath*:reactor/util/annotation/*.class\";\n\t\t\tassertExactFilenames(pattern, CLASSES_IN_REACTOR_UTIL_ANNOTATION);\n\t\t}\n\n\t\t// Fails in a native image -- https://github.com/oracle/graal/issues/5020\n\t\t@Test\n\t\tvoid rootPatternRetrievalInJarFiles() throws IOException {\n\t\t\tassertThat(resolver.getResources(\"classpath*:aspectj*.dtd\")).extracting(Resource::getFilename)\n\t\t\t\t.as(\"Could not find aspectj_1_5_0.dtd in the root of the aspectjweaver jar\")\n\t\t\t\t.containsExactly(\"aspectj_1_5_0.dtd\");\n\t\t}\n\t}\n\n\t@Nested\n\tclass ClassPathManifestEntries {\n\n\t\t@TempDir\n\t\tPath temp;\n\n\t\t@Test\n\t\tvoid javaDashJarFindsClassPathManifestEntries() throws Exception {\n\t\t\tPath lib = this.temp.resolve(\"lib\");\n\t\t\tFiles.createDirectories(lib);\n\t\t\twriteAssetJar(lib.resolve(\"asset.jar\"));\n\t\t\twriteApplicationJar(this.temp.resolve(\"app.jar\"));\n\t\t\tString java = ProcessHandle.current().info().command().get();\n\t\t\tProcess process = new ProcessBuilder(java, \"-jar\", \"app.jar\")\n\t\t\t\t.directory(this.temp.toFile())\n\t\t\t\t.start();\n\t\t\tassertThat(process.waitFor()).isZero();\n\t\t\tString result = StreamUtils.copyToString(process.getInputStream(), StandardCharsets.UTF_8);\n\t\t\tassertThat(result.replace(\"\\\\\", \"/\")).contains(\"!!!!\").contains(\"/lib/asset.jar!/assets/file.txt\");\n\t\t}\n\n\t\tprivate void writeAssetJar(Path path) throws Exception {\n\t\t\ttry (JarOutputStream jar = new JarOutputStream(new FileOutputStream(path.toFile()))) {\n\t\t\t\tjar.putNextEntry(new ZipEntry(\"assets/\"));\n\t\t\t\tjar.closeEntry();\n\t\t\t\tjar.putNextEntry(new ZipEntry(\"assets/file.txt\"));\n\t\t\t\tStreamUtils.copy(\"test\", StandardCharsets.UTF_8, jar);\n\t\t\t\tjar.closeEntry();\n\t\t\t}\n\t\t}\n\n\t\tprivate void writeApplicationJar(Path path) throws Exception {\n\t\t\tManifest manifest = new Manifest();\n\t\t\tAttributes mainAttributes = manifest.getMainAttributes();\n\t\t\tmainAttributes.put(Name.CLASS_PATH, buildSpringClassPath() + \"lib/asset.jar\");\n\t\t\tmainAttributes.put(Name.MAIN_CLASS, ClassPathManifestEntriesTestApplication.class.getName());\n\t\t\tmainAttributes.put(Name.MANIFEST_VERSION, \"1.0\");\n\t\t\ttry (JarOutputStream jar = new JarOutputStream(new FileOutputStream(path.toFile()), manifest)) {\n\t\t\t\tString appClassResource = ClassUtils.convertClassNameToResourcePath(\n\t\t\t\t\t\tClassPathManifestEntriesTestApplication.class.getName())\n\t\t\t\t\t\t+ ClassUtils.CLASS_FILE_SUFFIX;\n\t\t\t\tString folder = \"\";\n\t\t\t\tfor (String name : appClassResource.split(\"/\")) {\n\t\t\t\t\tif (!name.endsWith(ClassUtils.CLASS_FILE_SUFFIX)) {\n\t\t\t\t\t\tfolder += name + \"/\";\n\t\t\t\t\t\tjar.putNextEntry(new ZipEntry(folder));\n\t\t\t\t\t\tjar.closeEntry();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tjar.putNextEntry(new ZipEntry(folder + name));\n\t\t\t\t\t\ttry (InputStream in = getClass().getResourceAsStream(name)) {\n\t\t\t\t\t\t\tin.transferTo(jar);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjar.closeEntry();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate String buildSpringClassPath() throws Exception {\n\t\t\treturn copyClasses(PathMatchingResourcePatternResolver.class, \"spring-core\")\n\t\t\t\t\t+ copyClasses(LogFactory.class, \"commons-logging\");\n\t\t}\n\n\t\tprivate String copyClasses(Class<?> sourceClass, String destinationName)\n\t\t\t\tthrows URISyntaxException, IOException {\n\t\t\tPath destination = this.temp.resolve(destinationName);\n\t\t\tString resourcePath = ClassUtils.convertClassNameToResourcePath(sourceClass.getName())\n\t\t\t\t\t+ ClassUtils.CLASS_FILE_SUFFIX;\n\t\t\tURL resource = getClass().getClassLoader().getResource(resourcePath);\n\t\t\tURL url = new URL(resource.toString().replace(resourcePath, \"\"));\n\t\t\tURLConnection connection = url.openConnection();\n\t\t\tif (connection instanceof JarURLConnection jarUrlConnection) {\n\t\t\t\ttry (JarFile jarFile = jarUrlConnection.getJarFile()) {\n\t\t\t\t\tEnumeration<JarEntry> entries = jarFile.entries();\n\t\t\t\t\twhile (entries.hasMoreElements()) {\n\t\t\t\t\t\tJarEntry entry = entries.nextElement();\n\t\t\t\t\t\tif (!entry.isDirectory()) {\n\t\t\t\t\t\t\tPath entryPath = destination.resolve(entry.getName());\n\t\t\t\t\t\t\ttry (InputStream in = jarFile.getInputStream(entry)) {\n\t\t\t\t\t\t\t\tFiles.createDirectories(entryPath.getParent());\n\t\t\t\t\t\t\t\tFiles.copy(in, destination.resolve(entry.getName()));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFile source = new File(url.toURI());\n\t\t\t\tFiles.createDirectories(destination);\n\t\t\t\tFileSystemUtils.copyRecursively(source, destination.toFile());\n\t\t\t}\n\t\t\treturn destinationName + \"/ \";\n\t\t}\n\n\t}\n\n\n\tprivate void assertFilenames(String pattern, String... filenames) {\n\t\tassertFilenames(pattern, false, filenames);\n\t}\n\n\tprivate void assertExactFilenames(String pattern, String... filenames) {\n\t\tassertFilenames(pattern, true, filenames);\n\t}\n\n\tprivate void assertFilenames(String pattern, boolean exactly, String... filenames) {\n\t\ttry {\n\t\t\tResource[] resources = resolver.getResources(pattern);\n\t\t\tList<String> actualNames = Arrays.stream(resources)\n\t\t\t\t\t.peek(resource -> assertThat(resource.exists()).as(resource + \" exists\").isTrue())\n\t\t\t\t\t.map(Resource::getFilename)\n\t\t\t\t\t.sorted()\n\t\t\t\t\t.toList();\n\n\t\t\t// Uncomment the following if you encounter problems with matching against the file system.\n\t\t\t// List<String> expectedNames = Arrays.stream(filenames).sorted().toList();\n\t\t\t// System.out.println(\"----------------------------------------------------------------------\");\n\t\t\t// System.out.println(\"Expected: \" + expectedNames);\n\t\t\t// System.out.println(\"Actual: \" + actualNames);\n\t\t\t// Arrays.stream(resources).forEach(System.out::println);\n\n\t\t\tif (exactly) {\n\t\t\t\tassertThat(actualNames).as(\"subset of files found\").containsExactlyInAnyOrder(filenames);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassertThat(actualNames).as(\"subset of files found\").contains(filenames);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new UncheckedIOException(ex);\n\t\t}\n\t}\n\n\tprivate void assertExactSubPaths(String pattern, String pathPrefix, String... subPaths) {\n\t\ttry {\n\t\t\tResource[] resources = resolver.getResources(pattern);\n\t\t\tList<String> actualSubPaths = Arrays.stream(resources)\n\t\t\t\t\t.map(resource -> getPath(resource).replaceFirst(pathPrefix, \"\"))\n\t\t\t\t\t.sorted()\n\t\t\t\t\t.toList();\n\t\t\tassertThat(actualSubPaths).containsExactlyInAnyOrder(subPaths);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new UncheckedIOException(ex);\n\t\t}\n\t}\n\n\tprivate String getPath(Resource resource) {\n\t\t// Tests fail if we use resource.getURL().getPath(). They would also fail on macOS when\n\t\t// using resource.getURI().getPath() if the resource paths are not Unicode normalized.\n\t\t//\n\t\t// On the JVM, all tests should pass when using resource.getFile().getPath(); however,\n\t\t// we use FileSystemResource#getPath since this test class is sometimes run within a\n\t\t// GraalVM native image which cannot support Path#toFile.\n\t\t//\n\t\t// See: https://github.com/spring-projects/spring-framework/issues/29243\n\t\tif (resource instanceof FileSystemResource fileSystemResource) {\n\t\t\treturn fileSystemResource.getPath();\n\t\t}\n\t\ttry {\n\t\t\t// Fall back to URL in case the resource came from a JAR\n\t\t\treturn resource.getURL().getPath();\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new UncheckedIOException(ex);\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.io.support.FileSystemResources#singleResourceOnFileSystem()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid singleResourceOnFileSystem() {\r\n    String pattern = \"org/springframework/core/io/support/PathMatchingResourcePatternResolverTests.class\";\r\n    assertExactFilenames(pattern, \"PathMatchingResourcePatternResolverTests.class\");\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.io.support.FileSystemResources",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.io.support.FileSystemResources#singleResourceOnFileSystem()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.io.support.FileSystemResources#singleResourceOnFileSystem()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.io.support.FileSystemResources#classpathStarWithPatternOnFileSystem()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid classpathStarWithPatternOnFileSystem() {\r\n    String pattern = \"classpath*:org/springframework/core/io/sup*/*.class\";\r\n    String[] expectedFilenames = StringUtils.concatenateStringArrays(CLASSES_IN_CORE_IO_SUPPORT, TEST_CLASSES_IN_CORE_IO_SUPPORT);\r\n    assertFilenames(pattern, expectedFilenames);\r\n}",
    "tailType": "method_code"
  }
]