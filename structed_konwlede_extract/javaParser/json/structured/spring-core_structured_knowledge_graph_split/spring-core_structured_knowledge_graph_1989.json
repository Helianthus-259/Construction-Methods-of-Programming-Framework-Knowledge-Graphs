[
  {
    "head": "org.springframework.core.GenericTypeResolverTests#resolveTypeWithUnresolvableElement()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid resolveTypeWithUnresolvableElement() {\r\n    Type type = method(WithUnresolvableElement.class, \"get\").getGenericReturnType();\r\n    Type resolvedType = resolveType(type, WithUnresolvableElement.class);\r\n    assertThat(resolvedType.toString()).isEqualTo(\"java.util.List<E>\");\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.GenericTypeResolverTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.GenericTypeResolverTests#resolveTypeWithUnresolvableElement()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.GenericTypeResolverTests#resolveTypeWithUnresolvableElement()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.GenericTypeResolverTests#method(Class<?>,String,Class<?>)",
    "headType": "method",
    "relation": "provide",
    "tail": "private static Method method(Class<?> target, String methodName, Class<?>... parameterTypes) {\r\n    Method method = findMethod(target, methodName, parameterTypes);\r\n    assertThat(method).describedAs(target.getName() + \"#\" + methodName).isNotNull();\r\n    return method;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.GenericTypeResolverTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.GenericTypeResolverTests#method(Class<?>,String,Class<?>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.MyInterfaceType",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.MyInterfaceType",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.springframework.core.GenericTypeResolver.getTypeVariableMap;\nimport static org.springframework.core.GenericTypeResolver.resolveReturnTypeArgument;\nimport static org.springframework.core.GenericTypeResolver.resolveType;\nimport static org.springframework.core.GenericTypeResolver.resolveTypeArgument;\nimport static org.springframework.util.ReflectionUtils.findMethod;\n\n/**\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Sebastien Deleuze\n * @author Stephane Nicoll\n * @author Yanming Zhou\n */\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\nclass GenericTypeResolverTests {\n\n\t@Test\n\tvoid simpleInterfaceType() {\n\t\tassertThat(resolveTypeArgument(MySimpleInterfaceType.class, MyInterfaceType.class)).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid simpleCollectionInterfaceType() {\n\t\tassertThat(resolveTypeArgument(MyCollectionInterfaceType.class, MyInterfaceType.class)).isEqualTo(Collection.class);\n\t}\n\n\t@Test\n\tvoid simpleSuperclassType() {\n\t\tassertThat(resolveTypeArgument(MySimpleSuperclassType.class, MySuperclassType.class)).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid simpleCollectionSuperclassType() {\n\t\tassertThat(resolveTypeArgument(MyCollectionSuperclassType.class, MySuperclassType.class)).isEqualTo(Collection.class);\n\t}\n\n\t@Test\n\tvoid nullIfNotResolvable() {\n\t\tGenericClass<String> obj = new GenericClass<>();\n\t\tassertThat(resolveTypeArgument(obj.getClass(), GenericClass.class)).isNull();\n\t}\n\n\t@Test\n\tvoid methodReturnTypes() {\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"integer\"), MyInterfaceType.class)).isEqualTo(Integer.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"string\"), MyInterfaceType.class)).isEqualTo(String.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"character\"), MyAbstractType.class)).isEqualTo(Character.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"raw\"), MyInterfaceType.class)).isNull();\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"object\"), MyInterfaceType.class)).isNull();\n\t}\n\n\t@Test\n\tvoid testResolveType() {\n\t\tMethod intMessageMethod = method(MyTypeWithMethods.class, \"readIntegerInputMessage\", MyInterfaceType.class);\n\t\tMethodParameter intMessageMethodParam = new MethodParameter(intMessageMethod, 0);\n\t\tassertThat(resolveType(intMessageMethodParam.getGenericParameterType(), new HashMap<>())).isEqualTo(MyInterfaceType.class);\n\n\t\tMethod intArrMessageMethod = method(MyTypeWithMethods.class, \"readIntegerArrayInputMessage\",\n\t\t\t\tMyInterfaceType[].class);\n\t\tMethodParameter intArrMessageMethodParam = new MethodParameter(intArrMessageMethod, 0);\n\t\tassertThat(resolveType(intArrMessageMethodParam.getGenericParameterType(), new HashMap<>())).isEqualTo(MyInterfaceType[].class);\n\n\t\tMethod genericArrMessageMethod = method(MySimpleTypeWithMethods.class, \"readGenericArrayInputMessage\",\n\t\t\t\tObject[].class);\n\t\tMethodParameter genericArrMessageMethodParam = new MethodParameter(genericArrMessageMethod, 0);\n\t\tMap<TypeVariable, Type> varMap = getTypeVariableMap(MySimpleTypeWithMethods.class);\n\t\tassertThat(resolveType(genericArrMessageMethodParam.getGenericParameterType(), varMap)).isEqualTo(Integer[].class);\n\t}\n\n\t@Test\n\tvoid boundParameterizedType() {\n\t\tassertThat(resolveTypeArgument(TestImpl.class, TestIfc.class)).isEqualTo(B.class);\n\t}\n\n\t@Test\n\tvoid testGetTypeVariableMap() {\n\t\tMap<TypeVariable, Type> map;\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MySimpleInterfaceType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.String}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MyCollectionInterfaceType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=java.util.Collection<java.lang.String>}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MyCollectionSuperclassType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=java.util.Collection<java.lang.String>}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MySimpleTypeWithMethods.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.Integer}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TopLevelClass.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TypedTopLevelClass.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.Integer}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TypedTopLevelClass.TypedNested.class);\n\t\tassertThat(map).hasSize(2);\n\t\tType t = null;\n\t\tType x = null;\n\t\tfor (Map.Entry<TypeVariable, Type> entry : map.entrySet()) {\n\t\t\tif (entry.getKey().toString().equals(\"T\")) {\n\t\t\t\tt = entry.getValue();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = entry.getValue();\n\t\t\t}\n\t\t}\n\t\tassertThat(t).isEqualTo(Integer.class);\n\t\tassertThat(x).isEqualTo(Long.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeArgumentsOfAbstractType() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(MyConcreteType.class, MyAbstractType.class);\n\t\tassertThat(resolved).containsExactly(Character.class);\n\t}\n\n\t@Test  // SPR-11030\n\tvoid getGenericsCannotBeResolved() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(List.class, Iterable.class);\n\t\tassertThat(resolved).isNull();\n\t}\n\n\t@Test  // SPR-11052\n\tvoid getRawMapTypeCannotBeResolved() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(Map.class, Map.class);\n\t\tassertThat(resolved).isNull();\n\t}\n\n\t@Test  // SPR-11044\n\t@SuppressWarnings(\"deprecation\")\n\tvoid getGenericsOnArrayFromParamCannotBeResolved() throws Exception {\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(\n\t\t\t\tWithArrayBase.class.getDeclaredMethod(\"array\", Object[].class), 0);\n\t\tClass<?> resolved = GenericTypeResolver.resolveParameterType(methodParameter, WithArray.class);\n\t\tassertThat(resolved).isEqualTo(Object[].class);\n\t}\n\n\t@Test  // SPR-11044\n\tvoid getGenericsOnArrayFromReturnCannotBeResolved() throws Exception {\n\t\tClass<?> resolved = GenericTypeResolver.resolveReturnType(\n\t\t\t\tWithArrayBase.class.getDeclaredMethod(\"array\", Object[].class), WithArray.class);\n\t\tassertThat(resolved).isEqualTo(Object[].class);\n\t}\n\n\t@Test  // SPR-11763\n\tvoid resolveIncompleteTypeVariables() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(IdFixingRepository.class, Repository.class);\n\t\tassertThat(resolved).isNotNull();\n\t\tassertThat(resolved).hasSize(2);\n\t\tassertThat(resolved[0]).isEqualTo(Object.class);\n\t\tassertThat(resolved[1]).isEqualTo(Long.class);\n\t}\n\n\t@Test\n\tvoid resolvePartiallySpecializedTypeVariables() {\n\t\tType resolved = resolveType(BiGenericClass.class.getTypeParameters()[0], TypeFixedBiGenericClass.class);\n\t\tassertThat(resolved).isEqualTo(D.class);\n\t}\n\n\t@Test\n\tvoid resolveTransitiveTypeVariableWithDifferentName() {\n\t\tType resolved = resolveType(BiGenericClass.class.getTypeParameters()[1], TypeFixedBiGenericClass.class);\n\t\tassertThat(resolved).isEqualTo(E.class);\n\t}\n\n\t@Test\n\tvoid resolveMethodParameterWithNestedGenerics() {\n\t\tMethod method = method(WithMethodParameter.class, \"nestedGenerics\", List.class);\n\t\tMethodParameter methodParameter = new MethodParameter(method, 0);\n\t\tType resolvedType = resolveType(methodParameter.getGenericParameterType(), WithMethodParameter.class);\n\t\tParameterizedTypeReference<List<Map<String, Integer>>> reference = new ParameterizedTypeReference<>() {};\n\t\tassertThat(resolvedType).isEqualTo(reference.getType());\n\t}\n\n\t@Test\n\tvoid resolveNestedTypeVariable() throws Exception {\n\t\tType resolved = resolveType(ListOfListSupplier.class.getMethod(\"get\").getGenericReturnType(),\n\t\t\t\tStringListOfListSupplier.class);\n\t\tassertThat(ResolvableType.forType(resolved).getGeneric(0).getGeneric(0).resolve()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeWithElementBounds() {\n\t\tType type = method(WithElementBounds.class, \"get\").getGenericReturnType();\n\t\tType resolvedType = resolveType(type, WithElementBounds.class);\n\t\tParameterizedTypeReference<List<A>> reference = new ParameterizedTypeReference<>() {};\n\t\tassertThat(resolvedType).isEqualTo(reference.getType());\n\t}\n\n\t@Test\n\tvoid resolveTypeWithUnresolvableElement() {\n\t\tType type = method(WithUnresolvableElement.class, \"get\").getGenericReturnType();\n\t\tType resolvedType = resolveType(type, WithUnresolvableElement.class);\n\t\tassertThat(resolvedType.toString()).isEqualTo(\"java.util.List<E>\");\n\t}\n\n\tprivate static Method method(Class<?> target, String methodName, Class<?>... parameterTypes) {\n\t\tMethod method = findMethod(target, methodName, parameterTypes);\n\t\tassertThat(method).describedAs(target.getName() + \"#\" + methodName).isNotNull();\n\t\treturn method;\n\t}\n\n\n\tpublic interface MyInterfaceType<T> {\n\t}\n\n\tpublic class MySimpleInterfaceType implements MyInterfaceType<String> {\n\t}\n\n\tpublic class MyCollectionInterfaceType implements MyInterfaceType<Collection<String>> {\n\t}\n\n\tpublic abstract class MyAbstractType<T> implements MyInterfaceType<T> {\n\t}\n\n\tpublic class MyConcreteType extends MyAbstractType<Character> {\n\t}\n\n\tpublic abstract class MySuperclassType<T> {\n\t}\n\n\tpublic class MySimpleSuperclassType extends MySuperclassType<String> {\n\t}\n\n\tpublic class MyCollectionSuperclassType extends MySuperclassType<Collection<String>> {\n\t}\n\n\tpublic static class MyTypeWithMethods<T> {\n\n\t\tpublic MyInterfaceType<Integer> integer() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MySimpleInterfaceType string() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MyConcreteType character() { return null; }\n\n\t\tpublic Object object() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MyInterfaceType raw() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic String notParameterized() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic String notParameterizedWithArguments(Integer x, Boolean b) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Simulates a factory method that wraps the supplied object in a proxy of the\n\t\t * same type.\n\t\t */\n\t\tpublic static <T> T createProxy(T object) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createProxy(Object)} but adds an additional argument before\n\t\t * the argument of type {@code T}. Note that they may potentially be of the same\n\t\t * time when invoked!\n\t\t */\n\t\tpublic static <T> T createNamedProxy(String name, T object) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Simulates factory methods found in libraries such as Mockito and EasyMock.\n\t\t */\n\t\tpublic static <MOCK> MOCK createMock(Class<MOCK> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createMock(Class)} but adds an additional method argument\n\t\t * before the parameterized argument.\n\t\t */\n\t\tpublic static <T> T createNamedMock(String name, Class<T> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createNamedMock(String, Class)} but adds an additional\n\t\t * parameterized type.\n\t\t */\n\t\tpublic static <V extends Object, T> T createVMock(V name, Class<T> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Extract some value of the type supported by the interface (i.e., by a concrete,\n\t\t * non-generic implementation of the interface).\n\t\t */\n\t\tpublic static <T> T extractValueFrom(MyInterfaceType<T> myInterfaceType) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Extract some magic value from the supplied map.\n\t\t */\n\t\tpublic static <K, V> V extractMagicValue(Map<K, V> map) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void readIntegerInputMessage(MyInterfaceType<Integer> message) {\n\t\t}\n\n\t\tpublic void readIntegerArrayInputMessage(MyInterfaceType<Integer>[] message) {\n\t\t}\n\n\t\tpublic void readGenericArrayInputMessage(T[] message) {\n\t\t}\n\t}\n\n\tpublic static class MySimpleTypeWithMethods extends MyTypeWithMethods<Integer> {\n\t}\n\n\tstatic class GenericClass<T> {\n\t}\n\n\tclass A {}\n\n\tclass B<T> {}\n\n\tclass C extends A {}\n\n\tclass D extends B<Long> {}\n\n\tclass E extends C {}\n\n\tclass TestIfc<T> {}\n\n\tclass TestImpl<I extends A, T extends B<I>> extends TestIfc<T> {\n\t}\n\n\tabstract static class BiGenericClass<T extends B<?>, V extends A> {}\n\n\tabstract static class SpecializedBiGenericClass<U extends C> extends BiGenericClass<D, U> {}\n\n\tstatic class TypeFixedBiGenericClass extends SpecializedBiGenericClass<E> {}\n\n\tstatic class TopLevelClass<T> {\n\n\t\tclass Nested<X> {\n\t\t}\n\t}\n\n\tstatic class TypedTopLevelClass extends TopLevelClass<Integer> {\n\n\t\tclass TypedNested extends Nested<Long> {\n\t\t}\n\t}\n\n\tabstract static class WithArrayBase<T> {\n\n\t\tpublic abstract T[] array(T... args);\n\t}\n\n\tabstract static class WithArray<T> extends WithArrayBase<T> {\n\t}\n\n\tinterface Repository<T, ID extends Serializable> {\n\t}\n\n\tinterface IdFixingRepository<T> extends Repository<T, Long> {\n\t}\n\n\tstatic class WithMethodParameter {\n\n\t\tpublic void nestedGenerics(List<Map<String, Integer>> input) {\n\t\t}\n\t}\n\n\tinterface ListOfListSupplier<T> {\n\n\t\tList<List<T>> get();\n\t}\n\n\tinterface StringListOfListSupplier extends ListOfListSupplier<String> {\n\t}\n\n\tstatic class WithElementBounds {\n\n\t\t<T extends A> List<T> get() {\n\t\t\treturn List.of();\n\t\t}\n\t}\n\n\tstatic class WithUnresolvableElement<T> {\n\n\t\tList<T> get() {\n\t\t\treturn List.of();\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.MySimpleInterfaceType",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.MySimpleInterfaceType",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.springframework.core.GenericTypeResolver.getTypeVariableMap;\nimport static org.springframework.core.GenericTypeResolver.resolveReturnTypeArgument;\nimport static org.springframework.core.GenericTypeResolver.resolveType;\nimport static org.springframework.core.GenericTypeResolver.resolveTypeArgument;\nimport static org.springframework.util.ReflectionUtils.findMethod;\n\n/**\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Sebastien Deleuze\n * @author Stephane Nicoll\n * @author Yanming Zhou\n */\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\nclass GenericTypeResolverTests {\n\n\t@Test\n\tvoid simpleInterfaceType() {\n\t\tassertThat(resolveTypeArgument(MySimpleInterfaceType.class, MyInterfaceType.class)).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid simpleCollectionInterfaceType() {\n\t\tassertThat(resolveTypeArgument(MyCollectionInterfaceType.class, MyInterfaceType.class)).isEqualTo(Collection.class);\n\t}\n\n\t@Test\n\tvoid simpleSuperclassType() {\n\t\tassertThat(resolveTypeArgument(MySimpleSuperclassType.class, MySuperclassType.class)).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid simpleCollectionSuperclassType() {\n\t\tassertThat(resolveTypeArgument(MyCollectionSuperclassType.class, MySuperclassType.class)).isEqualTo(Collection.class);\n\t}\n\n\t@Test\n\tvoid nullIfNotResolvable() {\n\t\tGenericClass<String> obj = new GenericClass<>();\n\t\tassertThat(resolveTypeArgument(obj.getClass(), GenericClass.class)).isNull();\n\t}\n\n\t@Test\n\tvoid methodReturnTypes() {\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"integer\"), MyInterfaceType.class)).isEqualTo(Integer.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"string\"), MyInterfaceType.class)).isEqualTo(String.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"character\"), MyAbstractType.class)).isEqualTo(Character.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"raw\"), MyInterfaceType.class)).isNull();\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"object\"), MyInterfaceType.class)).isNull();\n\t}\n\n\t@Test\n\tvoid testResolveType() {\n\t\tMethod intMessageMethod = method(MyTypeWithMethods.class, \"readIntegerInputMessage\", MyInterfaceType.class);\n\t\tMethodParameter intMessageMethodParam = new MethodParameter(intMessageMethod, 0);\n\t\tassertThat(resolveType(intMessageMethodParam.getGenericParameterType(), new HashMap<>())).isEqualTo(MyInterfaceType.class);\n\n\t\tMethod intArrMessageMethod = method(MyTypeWithMethods.class, \"readIntegerArrayInputMessage\",\n\t\t\t\tMyInterfaceType[].class);\n\t\tMethodParameter intArrMessageMethodParam = new MethodParameter(intArrMessageMethod, 0);\n\t\tassertThat(resolveType(intArrMessageMethodParam.getGenericParameterType(), new HashMap<>())).isEqualTo(MyInterfaceType[].class);\n\n\t\tMethod genericArrMessageMethod = method(MySimpleTypeWithMethods.class, \"readGenericArrayInputMessage\",\n\t\t\t\tObject[].class);\n\t\tMethodParameter genericArrMessageMethodParam = new MethodParameter(genericArrMessageMethod, 0);\n\t\tMap<TypeVariable, Type> varMap = getTypeVariableMap(MySimpleTypeWithMethods.class);\n\t\tassertThat(resolveType(genericArrMessageMethodParam.getGenericParameterType(), varMap)).isEqualTo(Integer[].class);\n\t}\n\n\t@Test\n\tvoid boundParameterizedType() {\n\t\tassertThat(resolveTypeArgument(TestImpl.class, TestIfc.class)).isEqualTo(B.class);\n\t}\n\n\t@Test\n\tvoid testGetTypeVariableMap() {\n\t\tMap<TypeVariable, Type> map;\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MySimpleInterfaceType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.String}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MyCollectionInterfaceType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=java.util.Collection<java.lang.String>}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MyCollectionSuperclassType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=java.util.Collection<java.lang.String>}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MySimpleTypeWithMethods.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.Integer}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TopLevelClass.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TypedTopLevelClass.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.Integer}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TypedTopLevelClass.TypedNested.class);\n\t\tassertThat(map).hasSize(2);\n\t\tType t = null;\n\t\tType x = null;\n\t\tfor (Map.Entry<TypeVariable, Type> entry : map.entrySet()) {\n\t\t\tif (entry.getKey().toString().equals(\"T\")) {\n\t\t\t\tt = entry.getValue();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = entry.getValue();\n\t\t\t}\n\t\t}\n\t\tassertThat(t).isEqualTo(Integer.class);\n\t\tassertThat(x).isEqualTo(Long.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeArgumentsOfAbstractType() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(MyConcreteType.class, MyAbstractType.class);\n\t\tassertThat(resolved).containsExactly(Character.class);\n\t}\n\n\t@Test  // SPR-11030\n\tvoid getGenericsCannotBeResolved() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(List.class, Iterable.class);\n\t\tassertThat(resolved).isNull();\n\t}\n\n\t@Test  // SPR-11052\n\tvoid getRawMapTypeCannotBeResolved() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(Map.class, Map.class);\n\t\tassertThat(resolved).isNull();\n\t}\n\n\t@Test  // SPR-11044\n\t@SuppressWarnings(\"deprecation\")\n\tvoid getGenericsOnArrayFromParamCannotBeResolved() throws Exception {\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(\n\t\t\t\tWithArrayBase.class.getDeclaredMethod(\"array\", Object[].class), 0);\n\t\tClass<?> resolved = GenericTypeResolver.resolveParameterType(methodParameter, WithArray.class);\n\t\tassertThat(resolved).isEqualTo(Object[].class);\n\t}\n\n\t@Test  // SPR-11044\n\tvoid getGenericsOnArrayFromReturnCannotBeResolved() throws Exception {\n\t\tClass<?> resolved = GenericTypeResolver.resolveReturnType(\n\t\t\t\tWithArrayBase.class.getDeclaredMethod(\"array\", Object[].class), WithArray.class);\n\t\tassertThat(resolved).isEqualTo(Object[].class);\n\t}\n\n\t@Test  // SPR-11763\n\tvoid resolveIncompleteTypeVariables() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(IdFixingRepository.class, Repository.class);\n\t\tassertThat(resolved).isNotNull();\n\t\tassertThat(resolved).hasSize(2);\n\t\tassertThat(resolved[0]).isEqualTo(Object.class);\n\t\tassertThat(resolved[1]).isEqualTo(Long.class);\n\t}\n\n\t@Test\n\tvoid resolvePartiallySpecializedTypeVariables() {\n\t\tType resolved = resolveType(BiGenericClass.class.getTypeParameters()[0], TypeFixedBiGenericClass.class);\n\t\tassertThat(resolved).isEqualTo(D.class);\n\t}\n\n\t@Test\n\tvoid resolveTransitiveTypeVariableWithDifferentName() {\n\t\tType resolved = resolveType(BiGenericClass.class.getTypeParameters()[1], TypeFixedBiGenericClass.class);\n\t\tassertThat(resolved).isEqualTo(E.class);\n\t}\n\n\t@Test\n\tvoid resolveMethodParameterWithNestedGenerics() {\n\t\tMethod method = method(WithMethodParameter.class, \"nestedGenerics\", List.class);\n\t\tMethodParameter methodParameter = new MethodParameter(method, 0);\n\t\tType resolvedType = resolveType(methodParameter.getGenericParameterType(), WithMethodParameter.class);\n\t\tParameterizedTypeReference<List<Map<String, Integer>>> reference = new ParameterizedTypeReference<>() {};\n\t\tassertThat(resolvedType).isEqualTo(reference.getType());\n\t}\n\n\t@Test\n\tvoid resolveNestedTypeVariable() throws Exception {\n\t\tType resolved = resolveType(ListOfListSupplier.class.getMethod(\"get\").getGenericReturnType(),\n\t\t\t\tStringListOfListSupplier.class);\n\t\tassertThat(ResolvableType.forType(resolved).getGeneric(0).getGeneric(0).resolve()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeWithElementBounds() {\n\t\tType type = method(WithElementBounds.class, \"get\").getGenericReturnType();\n\t\tType resolvedType = resolveType(type, WithElementBounds.class);\n\t\tParameterizedTypeReference<List<A>> reference = new ParameterizedTypeReference<>() {};\n\t\tassertThat(resolvedType).isEqualTo(reference.getType());\n\t}\n\n\t@Test\n\tvoid resolveTypeWithUnresolvableElement() {\n\t\tType type = method(WithUnresolvableElement.class, \"get\").getGenericReturnType();\n\t\tType resolvedType = resolveType(type, WithUnresolvableElement.class);\n\t\tassertThat(resolvedType.toString()).isEqualTo(\"java.util.List<E>\");\n\t}\n\n\tprivate static Method method(Class<?> target, String methodName, Class<?>... parameterTypes) {\n\t\tMethod method = findMethod(target, methodName, parameterTypes);\n\t\tassertThat(method).describedAs(target.getName() + \"#\" + methodName).isNotNull();\n\t\treturn method;\n\t}\n\n\n\tpublic interface MyInterfaceType<T> {\n\t}\n\n\tpublic class MySimpleInterfaceType implements MyInterfaceType<String> {\n\t}\n\n\tpublic class MyCollectionInterfaceType implements MyInterfaceType<Collection<String>> {\n\t}\n\n\tpublic abstract class MyAbstractType<T> implements MyInterfaceType<T> {\n\t}\n\n\tpublic class MyConcreteType extends MyAbstractType<Character> {\n\t}\n\n\tpublic abstract class MySuperclassType<T> {\n\t}\n\n\tpublic class MySimpleSuperclassType extends MySuperclassType<String> {\n\t}\n\n\tpublic class MyCollectionSuperclassType extends MySuperclassType<Collection<String>> {\n\t}\n\n\tpublic static class MyTypeWithMethods<T> {\n\n\t\tpublic MyInterfaceType<Integer> integer() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MySimpleInterfaceType string() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MyConcreteType character() { return null; }\n\n\t\tpublic Object object() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MyInterfaceType raw() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic String notParameterized() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic String notParameterizedWithArguments(Integer x, Boolean b) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Simulates a factory method that wraps the supplied object in a proxy of the\n\t\t * same type.\n\t\t */\n\t\tpublic static <T> T createProxy(T object) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createProxy(Object)} but adds an additional argument before\n\t\t * the argument of type {@code T}. Note that they may potentially be of the same\n\t\t * time when invoked!\n\t\t */\n\t\tpublic static <T> T createNamedProxy(String name, T object) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Simulates factory methods found in libraries such as Mockito and EasyMock.\n\t\t */\n\t\tpublic static <MOCK> MOCK createMock(Class<MOCK> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createMock(Class)} but adds an additional method argument\n\t\t * before the parameterized argument.\n\t\t */\n\t\tpublic static <T> T createNamedMock(String name, Class<T> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createNamedMock(String, Class)} but adds an additional\n\t\t * parameterized type.\n\t\t */\n\t\tpublic static <V extends Object, T> T createVMock(V name, Class<T> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Extract some value of the type supported by the interface (i.e., by a concrete,\n\t\t * non-generic implementation of the interface).\n\t\t */\n\t\tpublic static <T> T extractValueFrom(MyInterfaceType<T> myInterfaceType) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Extract some magic value from the supplied map.\n\t\t */\n\t\tpublic static <K, V> V extractMagicValue(Map<K, V> map) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void readIntegerInputMessage(MyInterfaceType<Integer> message) {\n\t\t}\n\n\t\tpublic void readIntegerArrayInputMessage(MyInterfaceType<Integer>[] message) {\n\t\t}\n\n\t\tpublic void readGenericArrayInputMessage(T[] message) {\n\t\t}\n\t}\n\n\tpublic static class MySimpleTypeWithMethods extends MyTypeWithMethods<Integer> {\n\t}\n\n\tstatic class GenericClass<T> {\n\t}\n\n\tclass A {}\n\n\tclass B<T> {}\n\n\tclass C extends A {}\n\n\tclass D extends B<Long> {}\n\n\tclass E extends C {}\n\n\tclass TestIfc<T> {}\n\n\tclass TestImpl<I extends A, T extends B<I>> extends TestIfc<T> {\n\t}\n\n\tabstract static class BiGenericClass<T extends B<?>, V extends A> {}\n\n\tabstract static class SpecializedBiGenericClass<U extends C> extends BiGenericClass<D, U> {}\n\n\tstatic class TypeFixedBiGenericClass extends SpecializedBiGenericClass<E> {}\n\n\tstatic class TopLevelClass<T> {\n\n\t\tclass Nested<X> {\n\t\t}\n\t}\n\n\tstatic class TypedTopLevelClass extends TopLevelClass<Integer> {\n\n\t\tclass TypedNested extends Nested<Long> {\n\t\t}\n\t}\n\n\tabstract static class WithArrayBase<T> {\n\n\t\tpublic abstract T[] array(T... args);\n\t}\n\n\tabstract static class WithArray<T> extends WithArrayBase<T> {\n\t}\n\n\tinterface Repository<T, ID extends Serializable> {\n\t}\n\n\tinterface IdFixingRepository<T> extends Repository<T, Long> {\n\t}\n\n\tstatic class WithMethodParameter {\n\n\t\tpublic void nestedGenerics(List<Map<String, Integer>> input) {\n\t\t}\n\t}\n\n\tinterface ListOfListSupplier<T> {\n\n\t\tList<List<T>> get();\n\t}\n\n\tinterface StringListOfListSupplier extends ListOfListSupplier<String> {\n\t}\n\n\tstatic class WithElementBounds {\n\n\t\t<T extends A> List<T> get() {\n\t\t\treturn List.of();\n\t\t}\n\t}\n\n\tstatic class WithUnresolvableElement<T> {\n\n\t\tList<T> get() {\n\t\t\treturn List.of();\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.MyCollectionInterfaceType",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.MyCollectionInterfaceType",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.springframework.core.GenericTypeResolver.getTypeVariableMap;\nimport static org.springframework.core.GenericTypeResolver.resolveReturnTypeArgument;\nimport static org.springframework.core.GenericTypeResolver.resolveType;\nimport static org.springframework.core.GenericTypeResolver.resolveTypeArgument;\nimport static org.springframework.util.ReflectionUtils.findMethod;\n\n/**\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Sebastien Deleuze\n * @author Stephane Nicoll\n * @author Yanming Zhou\n */\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\nclass GenericTypeResolverTests {\n\n\t@Test\n\tvoid simpleInterfaceType() {\n\t\tassertThat(resolveTypeArgument(MySimpleInterfaceType.class, MyInterfaceType.class)).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid simpleCollectionInterfaceType() {\n\t\tassertThat(resolveTypeArgument(MyCollectionInterfaceType.class, MyInterfaceType.class)).isEqualTo(Collection.class);\n\t}\n\n\t@Test\n\tvoid simpleSuperclassType() {\n\t\tassertThat(resolveTypeArgument(MySimpleSuperclassType.class, MySuperclassType.class)).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid simpleCollectionSuperclassType() {\n\t\tassertThat(resolveTypeArgument(MyCollectionSuperclassType.class, MySuperclassType.class)).isEqualTo(Collection.class);\n\t}\n\n\t@Test\n\tvoid nullIfNotResolvable() {\n\t\tGenericClass<String> obj = new GenericClass<>();\n\t\tassertThat(resolveTypeArgument(obj.getClass(), GenericClass.class)).isNull();\n\t}\n\n\t@Test\n\tvoid methodReturnTypes() {\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"integer\"), MyInterfaceType.class)).isEqualTo(Integer.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"string\"), MyInterfaceType.class)).isEqualTo(String.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"character\"), MyAbstractType.class)).isEqualTo(Character.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"raw\"), MyInterfaceType.class)).isNull();\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"object\"), MyInterfaceType.class)).isNull();\n\t}\n\n\t@Test\n\tvoid testResolveType() {\n\t\tMethod intMessageMethod = method(MyTypeWithMethods.class, \"readIntegerInputMessage\", MyInterfaceType.class);\n\t\tMethodParameter intMessageMethodParam = new MethodParameter(intMessageMethod, 0);\n\t\tassertThat(resolveType(intMessageMethodParam.getGenericParameterType(), new HashMap<>())).isEqualTo(MyInterfaceType.class);\n\n\t\tMethod intArrMessageMethod = method(MyTypeWithMethods.class, \"readIntegerArrayInputMessage\",\n\t\t\t\tMyInterfaceType[].class);\n\t\tMethodParameter intArrMessageMethodParam = new MethodParameter(intArrMessageMethod, 0);\n\t\tassertThat(resolveType(intArrMessageMethodParam.getGenericParameterType(), new HashMap<>())).isEqualTo(MyInterfaceType[].class);\n\n\t\tMethod genericArrMessageMethod = method(MySimpleTypeWithMethods.class, \"readGenericArrayInputMessage\",\n\t\t\t\tObject[].class);\n\t\tMethodParameter genericArrMessageMethodParam = new MethodParameter(genericArrMessageMethod, 0);\n\t\tMap<TypeVariable, Type> varMap = getTypeVariableMap(MySimpleTypeWithMethods.class);\n\t\tassertThat(resolveType(genericArrMessageMethodParam.getGenericParameterType(), varMap)).isEqualTo(Integer[].class);\n\t}\n\n\t@Test\n\tvoid boundParameterizedType() {\n\t\tassertThat(resolveTypeArgument(TestImpl.class, TestIfc.class)).isEqualTo(B.class);\n\t}\n\n\t@Test\n\tvoid testGetTypeVariableMap() {\n\t\tMap<TypeVariable, Type> map;\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MySimpleInterfaceType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.String}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MyCollectionInterfaceType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=java.util.Collection<java.lang.String>}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MyCollectionSuperclassType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=java.util.Collection<java.lang.String>}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MySimpleTypeWithMethods.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.Integer}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TopLevelClass.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TypedTopLevelClass.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.Integer}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TypedTopLevelClass.TypedNested.class);\n\t\tassertThat(map).hasSize(2);\n\t\tType t = null;\n\t\tType x = null;\n\t\tfor (Map.Entry<TypeVariable, Type> entry : map.entrySet()) {\n\t\t\tif (entry.getKey().toString().equals(\"T\")) {\n\t\t\t\tt = entry.getValue();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = entry.getValue();\n\t\t\t}\n\t\t}\n\t\tassertThat(t).isEqualTo(Integer.class);\n\t\tassertThat(x).isEqualTo(Long.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeArgumentsOfAbstractType() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(MyConcreteType.class, MyAbstractType.class);\n\t\tassertThat(resolved).containsExactly(Character.class);\n\t}\n\n\t@Test  // SPR-11030\n\tvoid getGenericsCannotBeResolved() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(List.class, Iterable.class);\n\t\tassertThat(resolved).isNull();\n\t}\n\n\t@Test  // SPR-11052\n\tvoid getRawMapTypeCannotBeResolved() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(Map.class, Map.class);\n\t\tassertThat(resolved).isNull();\n\t}\n\n\t@Test  // SPR-11044\n\t@SuppressWarnings(\"deprecation\")\n\tvoid getGenericsOnArrayFromParamCannotBeResolved() throws Exception {\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(\n\t\t\t\tWithArrayBase.class.getDeclaredMethod(\"array\", Object[].class), 0);\n\t\tClass<?> resolved = GenericTypeResolver.resolveParameterType(methodParameter, WithArray.class);\n\t\tassertThat(resolved).isEqualTo(Object[].class);\n\t}\n\n\t@Test  // SPR-11044\n\tvoid getGenericsOnArrayFromReturnCannotBeResolved() throws Exception {\n\t\tClass<?> resolved = GenericTypeResolver.resolveReturnType(\n\t\t\t\tWithArrayBase.class.getDeclaredMethod(\"array\", Object[].class), WithArray.class);\n\t\tassertThat(resolved).isEqualTo(Object[].class);\n\t}\n\n\t@Test  // SPR-11763\n\tvoid resolveIncompleteTypeVariables() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(IdFixingRepository.class, Repository.class);\n\t\tassertThat(resolved).isNotNull();\n\t\tassertThat(resolved).hasSize(2);\n\t\tassertThat(resolved[0]).isEqualTo(Object.class);\n\t\tassertThat(resolved[1]).isEqualTo(Long.class);\n\t}\n\n\t@Test\n\tvoid resolvePartiallySpecializedTypeVariables() {\n\t\tType resolved = resolveType(BiGenericClass.class.getTypeParameters()[0], TypeFixedBiGenericClass.class);\n\t\tassertThat(resolved).isEqualTo(D.class);\n\t}\n\n\t@Test\n\tvoid resolveTransitiveTypeVariableWithDifferentName() {\n\t\tType resolved = resolveType(BiGenericClass.class.getTypeParameters()[1], TypeFixedBiGenericClass.class);\n\t\tassertThat(resolved).isEqualTo(E.class);\n\t}\n\n\t@Test\n\tvoid resolveMethodParameterWithNestedGenerics() {\n\t\tMethod method = method(WithMethodParameter.class, \"nestedGenerics\", List.class);\n\t\tMethodParameter methodParameter = new MethodParameter(method, 0);\n\t\tType resolvedType = resolveType(methodParameter.getGenericParameterType(), WithMethodParameter.class);\n\t\tParameterizedTypeReference<List<Map<String, Integer>>> reference = new ParameterizedTypeReference<>() {};\n\t\tassertThat(resolvedType).isEqualTo(reference.getType());\n\t}\n\n\t@Test\n\tvoid resolveNestedTypeVariable() throws Exception {\n\t\tType resolved = resolveType(ListOfListSupplier.class.getMethod(\"get\").getGenericReturnType(),\n\t\t\t\tStringListOfListSupplier.class);\n\t\tassertThat(ResolvableType.forType(resolved).getGeneric(0).getGeneric(0).resolve()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeWithElementBounds() {\n\t\tType type = method(WithElementBounds.class, \"get\").getGenericReturnType();\n\t\tType resolvedType = resolveType(type, WithElementBounds.class);\n\t\tParameterizedTypeReference<List<A>> reference = new ParameterizedTypeReference<>() {};\n\t\tassertThat(resolvedType).isEqualTo(reference.getType());\n\t}\n\n\t@Test\n\tvoid resolveTypeWithUnresolvableElement() {\n\t\tType type = method(WithUnresolvableElement.class, \"get\").getGenericReturnType();\n\t\tType resolvedType = resolveType(type, WithUnresolvableElement.class);\n\t\tassertThat(resolvedType.toString()).isEqualTo(\"java.util.List<E>\");\n\t}\n\n\tprivate static Method method(Class<?> target, String methodName, Class<?>... parameterTypes) {\n\t\tMethod method = findMethod(target, methodName, parameterTypes);\n\t\tassertThat(method).describedAs(target.getName() + \"#\" + methodName).isNotNull();\n\t\treturn method;\n\t}\n\n\n\tpublic interface MyInterfaceType<T> {\n\t}\n\n\tpublic class MySimpleInterfaceType implements MyInterfaceType<String> {\n\t}\n\n\tpublic class MyCollectionInterfaceType implements MyInterfaceType<Collection<String>> {\n\t}\n\n\tpublic abstract class MyAbstractType<T> implements MyInterfaceType<T> {\n\t}\n\n\tpublic class MyConcreteType extends MyAbstractType<Character> {\n\t}\n\n\tpublic abstract class MySuperclassType<T> {\n\t}\n\n\tpublic class MySimpleSuperclassType extends MySuperclassType<String> {\n\t}\n\n\tpublic class MyCollectionSuperclassType extends MySuperclassType<Collection<String>> {\n\t}\n\n\tpublic static class MyTypeWithMethods<T> {\n\n\t\tpublic MyInterfaceType<Integer> integer() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MySimpleInterfaceType string() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MyConcreteType character() { return null; }\n\n\t\tpublic Object object() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MyInterfaceType raw() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic String notParameterized() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic String notParameterizedWithArguments(Integer x, Boolean b) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Simulates a factory method that wraps the supplied object in a proxy of the\n\t\t * same type.\n\t\t */\n\t\tpublic static <T> T createProxy(T object) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createProxy(Object)} but adds an additional argument before\n\t\t * the argument of type {@code T}. Note that they may potentially be of the same\n\t\t * time when invoked!\n\t\t */\n\t\tpublic static <T> T createNamedProxy(String name, T object) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Simulates factory methods found in libraries such as Mockito and EasyMock.\n\t\t */\n\t\tpublic static <MOCK> MOCK createMock(Class<MOCK> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createMock(Class)} but adds an additional method argument\n\t\t * before the parameterized argument.\n\t\t */\n\t\tpublic static <T> T createNamedMock(String name, Class<T> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createNamedMock(String, Class)} but adds an additional\n\t\t * parameterized type.\n\t\t */\n\t\tpublic static <V extends Object, T> T createVMock(V name, Class<T> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Extract some value of the type supported by the interface (i.e., by a concrete,\n\t\t * non-generic implementation of the interface).\n\t\t */\n\t\tpublic static <T> T extractValueFrom(MyInterfaceType<T> myInterfaceType) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Extract some magic value from the supplied map.\n\t\t */\n\t\tpublic static <K, V> V extractMagicValue(Map<K, V> map) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void readIntegerInputMessage(MyInterfaceType<Integer> message) {\n\t\t}\n\n\t\tpublic void readIntegerArrayInputMessage(MyInterfaceType<Integer>[] message) {\n\t\t}\n\n\t\tpublic void readGenericArrayInputMessage(T[] message) {\n\t\t}\n\t}\n\n\tpublic static class MySimpleTypeWithMethods extends MyTypeWithMethods<Integer> {\n\t}\n\n\tstatic class GenericClass<T> {\n\t}\n\n\tclass A {}\n\n\tclass B<T> {}\n\n\tclass C extends A {}\n\n\tclass D extends B<Long> {}\n\n\tclass E extends C {}\n\n\tclass TestIfc<T> {}\n\n\tclass TestImpl<I extends A, T extends B<I>> extends TestIfc<T> {\n\t}\n\n\tabstract static class BiGenericClass<T extends B<?>, V extends A> {}\n\n\tabstract static class SpecializedBiGenericClass<U extends C> extends BiGenericClass<D, U> {}\n\n\tstatic class TypeFixedBiGenericClass extends SpecializedBiGenericClass<E> {}\n\n\tstatic class TopLevelClass<T> {\n\n\t\tclass Nested<X> {\n\t\t}\n\t}\n\n\tstatic class TypedTopLevelClass extends TopLevelClass<Integer> {\n\n\t\tclass TypedNested extends Nested<Long> {\n\t\t}\n\t}\n\n\tabstract static class WithArrayBase<T> {\n\n\t\tpublic abstract T[] array(T... args);\n\t}\n\n\tabstract static class WithArray<T> extends WithArrayBase<T> {\n\t}\n\n\tinterface Repository<T, ID extends Serializable> {\n\t}\n\n\tinterface IdFixingRepository<T> extends Repository<T, Long> {\n\t}\n\n\tstatic class WithMethodParameter {\n\n\t\tpublic void nestedGenerics(List<Map<String, Integer>> input) {\n\t\t}\n\t}\n\n\tinterface ListOfListSupplier<T> {\n\n\t\tList<List<T>> get();\n\t}\n\n\tinterface StringListOfListSupplier extends ListOfListSupplier<String> {\n\t}\n\n\tstatic class WithElementBounds {\n\n\t\t<T extends A> List<T> get() {\n\t\t\treturn List.of();\n\t\t}\n\t}\n\n\tstatic class WithUnresolvableElement<T> {\n\n\t\tList<T> get() {\n\t\t\treturn List.of();\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.MyAbstractType",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.MyAbstractType",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.springframework.core.GenericTypeResolver.getTypeVariableMap;\nimport static org.springframework.core.GenericTypeResolver.resolveReturnTypeArgument;\nimport static org.springframework.core.GenericTypeResolver.resolveType;\nimport static org.springframework.core.GenericTypeResolver.resolveTypeArgument;\nimport static org.springframework.util.ReflectionUtils.findMethod;\n\n/**\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Sebastien Deleuze\n * @author Stephane Nicoll\n * @author Yanming Zhou\n */\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\nclass GenericTypeResolverTests {\n\n\t@Test\n\tvoid simpleInterfaceType() {\n\t\tassertThat(resolveTypeArgument(MySimpleInterfaceType.class, MyInterfaceType.class)).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid simpleCollectionInterfaceType() {\n\t\tassertThat(resolveTypeArgument(MyCollectionInterfaceType.class, MyInterfaceType.class)).isEqualTo(Collection.class);\n\t}\n\n\t@Test\n\tvoid simpleSuperclassType() {\n\t\tassertThat(resolveTypeArgument(MySimpleSuperclassType.class, MySuperclassType.class)).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid simpleCollectionSuperclassType() {\n\t\tassertThat(resolveTypeArgument(MyCollectionSuperclassType.class, MySuperclassType.class)).isEqualTo(Collection.class);\n\t}\n\n\t@Test\n\tvoid nullIfNotResolvable() {\n\t\tGenericClass<String> obj = new GenericClass<>();\n\t\tassertThat(resolveTypeArgument(obj.getClass(), GenericClass.class)).isNull();\n\t}\n\n\t@Test\n\tvoid methodReturnTypes() {\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"integer\"), MyInterfaceType.class)).isEqualTo(Integer.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"string\"), MyInterfaceType.class)).isEqualTo(String.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"character\"), MyAbstractType.class)).isEqualTo(Character.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"raw\"), MyInterfaceType.class)).isNull();\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"object\"), MyInterfaceType.class)).isNull();\n\t}\n\n\t@Test\n\tvoid testResolveType() {\n\t\tMethod intMessageMethod = method(MyTypeWithMethods.class, \"readIntegerInputMessage\", MyInterfaceType.class);\n\t\tMethodParameter intMessageMethodParam = new MethodParameter(intMessageMethod, 0);\n\t\tassertThat(resolveType(intMessageMethodParam.getGenericParameterType(), new HashMap<>())).isEqualTo(MyInterfaceType.class);\n\n\t\tMethod intArrMessageMethod = method(MyTypeWithMethods.class, \"readIntegerArrayInputMessage\",\n\t\t\t\tMyInterfaceType[].class);\n\t\tMethodParameter intArrMessageMethodParam = new MethodParameter(intArrMessageMethod, 0);\n\t\tassertThat(resolveType(intArrMessageMethodParam.getGenericParameterType(), new HashMap<>())).isEqualTo(MyInterfaceType[].class);\n\n\t\tMethod genericArrMessageMethod = method(MySimpleTypeWithMethods.class, \"readGenericArrayInputMessage\",\n\t\t\t\tObject[].class);\n\t\tMethodParameter genericArrMessageMethodParam = new MethodParameter(genericArrMessageMethod, 0);\n\t\tMap<TypeVariable, Type> varMap = getTypeVariableMap(MySimpleTypeWithMethods.class);\n\t\tassertThat(resolveType(genericArrMessageMethodParam.getGenericParameterType(), varMap)).isEqualTo(Integer[].class);\n\t}\n\n\t@Test\n\tvoid boundParameterizedType() {\n\t\tassertThat(resolveTypeArgument(TestImpl.class, TestIfc.class)).isEqualTo(B.class);\n\t}\n\n\t@Test\n\tvoid testGetTypeVariableMap() {\n\t\tMap<TypeVariable, Type> map;\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MySimpleInterfaceType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.String}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MyCollectionInterfaceType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=java.util.Collection<java.lang.String>}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MyCollectionSuperclassType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=java.util.Collection<java.lang.String>}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MySimpleTypeWithMethods.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.Integer}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TopLevelClass.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TypedTopLevelClass.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.Integer}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TypedTopLevelClass.TypedNested.class);\n\t\tassertThat(map).hasSize(2);\n\t\tType t = null;\n\t\tType x = null;\n\t\tfor (Map.Entry<TypeVariable, Type> entry : map.entrySet()) {\n\t\t\tif (entry.getKey().toString().equals(\"T\")) {\n\t\t\t\tt = entry.getValue();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = entry.getValue();\n\t\t\t}\n\t\t}\n\t\tassertThat(t).isEqualTo(Integer.class);\n\t\tassertThat(x).isEqualTo(Long.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeArgumentsOfAbstractType() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(MyConcreteType.class, MyAbstractType.class);\n\t\tassertThat(resolved).containsExactly(Character.class);\n\t}\n\n\t@Test  // SPR-11030\n\tvoid getGenericsCannotBeResolved() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(List.class, Iterable.class);\n\t\tassertThat(resolved).isNull();\n\t}\n\n\t@Test  // SPR-11052\n\tvoid getRawMapTypeCannotBeResolved() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(Map.class, Map.class);\n\t\tassertThat(resolved).isNull();\n\t}\n\n\t@Test  // SPR-11044\n\t@SuppressWarnings(\"deprecation\")\n\tvoid getGenericsOnArrayFromParamCannotBeResolved() throws Exception {\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(\n\t\t\t\tWithArrayBase.class.getDeclaredMethod(\"array\", Object[].class), 0);\n\t\tClass<?> resolved = GenericTypeResolver.resolveParameterType(methodParameter, WithArray.class);\n\t\tassertThat(resolved).isEqualTo(Object[].class);\n\t}\n\n\t@Test  // SPR-11044\n\tvoid getGenericsOnArrayFromReturnCannotBeResolved() throws Exception {\n\t\tClass<?> resolved = GenericTypeResolver.resolveReturnType(\n\t\t\t\tWithArrayBase.class.getDeclaredMethod(\"array\", Object[].class), WithArray.class);\n\t\tassertThat(resolved).isEqualTo(Object[].class);\n\t}\n\n\t@Test  // SPR-11763\n\tvoid resolveIncompleteTypeVariables() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(IdFixingRepository.class, Repository.class);\n\t\tassertThat(resolved).isNotNull();\n\t\tassertThat(resolved).hasSize(2);\n\t\tassertThat(resolved[0]).isEqualTo(Object.class);\n\t\tassertThat(resolved[1]).isEqualTo(Long.class);\n\t}\n\n\t@Test\n\tvoid resolvePartiallySpecializedTypeVariables() {\n\t\tType resolved = resolveType(BiGenericClass.class.getTypeParameters()[0], TypeFixedBiGenericClass.class);\n\t\tassertThat(resolved).isEqualTo(D.class);\n\t}\n\n\t@Test\n\tvoid resolveTransitiveTypeVariableWithDifferentName() {\n\t\tType resolved = resolveType(BiGenericClass.class.getTypeParameters()[1], TypeFixedBiGenericClass.class);\n\t\tassertThat(resolved).isEqualTo(E.class);\n\t}\n\n\t@Test\n\tvoid resolveMethodParameterWithNestedGenerics() {\n\t\tMethod method = method(WithMethodParameter.class, \"nestedGenerics\", List.class);\n\t\tMethodParameter methodParameter = new MethodParameter(method, 0);\n\t\tType resolvedType = resolveType(methodParameter.getGenericParameterType(), WithMethodParameter.class);\n\t\tParameterizedTypeReference<List<Map<String, Integer>>> reference = new ParameterizedTypeReference<>() {};\n\t\tassertThat(resolvedType).isEqualTo(reference.getType());\n\t}\n\n\t@Test\n\tvoid resolveNestedTypeVariable() throws Exception {\n\t\tType resolved = resolveType(ListOfListSupplier.class.getMethod(\"get\").getGenericReturnType(),\n\t\t\t\tStringListOfListSupplier.class);\n\t\tassertThat(ResolvableType.forType(resolved).getGeneric(0).getGeneric(0).resolve()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeWithElementBounds() {\n\t\tType type = method(WithElementBounds.class, \"get\").getGenericReturnType();\n\t\tType resolvedType = resolveType(type, WithElementBounds.class);\n\t\tParameterizedTypeReference<List<A>> reference = new ParameterizedTypeReference<>() {};\n\t\tassertThat(resolvedType).isEqualTo(reference.getType());\n\t}\n\n\t@Test\n\tvoid resolveTypeWithUnresolvableElement() {\n\t\tType type = method(WithUnresolvableElement.class, \"get\").getGenericReturnType();\n\t\tType resolvedType = resolveType(type, WithUnresolvableElement.class);\n\t\tassertThat(resolvedType.toString()).isEqualTo(\"java.util.List<E>\");\n\t}\n\n\tprivate static Method method(Class<?> target, String methodName, Class<?>... parameterTypes) {\n\t\tMethod method = findMethod(target, methodName, parameterTypes);\n\t\tassertThat(method).describedAs(target.getName() + \"#\" + methodName).isNotNull();\n\t\treturn method;\n\t}\n\n\n\tpublic interface MyInterfaceType<T> {\n\t}\n\n\tpublic class MySimpleInterfaceType implements MyInterfaceType<String> {\n\t}\n\n\tpublic class MyCollectionInterfaceType implements MyInterfaceType<Collection<String>> {\n\t}\n\n\tpublic abstract class MyAbstractType<T> implements MyInterfaceType<T> {\n\t}\n\n\tpublic class MyConcreteType extends MyAbstractType<Character> {\n\t}\n\n\tpublic abstract class MySuperclassType<T> {\n\t}\n\n\tpublic class MySimpleSuperclassType extends MySuperclassType<String> {\n\t}\n\n\tpublic class MyCollectionSuperclassType extends MySuperclassType<Collection<String>> {\n\t}\n\n\tpublic static class MyTypeWithMethods<T> {\n\n\t\tpublic MyInterfaceType<Integer> integer() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MySimpleInterfaceType string() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MyConcreteType character() { return null; }\n\n\t\tpublic Object object() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MyInterfaceType raw() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic String notParameterized() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic String notParameterizedWithArguments(Integer x, Boolean b) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Simulates a factory method that wraps the supplied object in a proxy of the\n\t\t * same type.\n\t\t */\n\t\tpublic static <T> T createProxy(T object) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createProxy(Object)} but adds an additional argument before\n\t\t * the argument of type {@code T}. Note that they may potentially be of the same\n\t\t * time when invoked!\n\t\t */\n\t\tpublic static <T> T createNamedProxy(String name, T object) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Simulates factory methods found in libraries such as Mockito and EasyMock.\n\t\t */\n\t\tpublic static <MOCK> MOCK createMock(Class<MOCK> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createMock(Class)} but adds an additional method argument\n\t\t * before the parameterized argument.\n\t\t */\n\t\tpublic static <T> T createNamedMock(String name, Class<T> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createNamedMock(String, Class)} but adds an additional\n\t\t * parameterized type.\n\t\t */\n\t\tpublic static <V extends Object, T> T createVMock(V name, Class<T> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Extract some value of the type supported by the interface (i.e., by a concrete,\n\t\t * non-generic implementation of the interface).\n\t\t */\n\t\tpublic static <T> T extractValueFrom(MyInterfaceType<T> myInterfaceType) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Extract some magic value from the supplied map.\n\t\t */\n\t\tpublic static <K, V> V extractMagicValue(Map<K, V> map) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void readIntegerInputMessage(MyInterfaceType<Integer> message) {\n\t\t}\n\n\t\tpublic void readIntegerArrayInputMessage(MyInterfaceType<Integer>[] message) {\n\t\t}\n\n\t\tpublic void readGenericArrayInputMessage(T[] message) {\n\t\t}\n\t}\n\n\tpublic static class MySimpleTypeWithMethods extends MyTypeWithMethods<Integer> {\n\t}\n\n\tstatic class GenericClass<T> {\n\t}\n\n\tclass A {}\n\n\tclass B<T> {}\n\n\tclass C extends A {}\n\n\tclass D extends B<Long> {}\n\n\tclass E extends C {}\n\n\tclass TestIfc<T> {}\n\n\tclass TestImpl<I extends A, T extends B<I>> extends TestIfc<T> {\n\t}\n\n\tabstract static class BiGenericClass<T extends B<?>, V extends A> {}\n\n\tabstract static class SpecializedBiGenericClass<U extends C> extends BiGenericClass<D, U> {}\n\n\tstatic class TypeFixedBiGenericClass extends SpecializedBiGenericClass<E> {}\n\n\tstatic class TopLevelClass<T> {\n\n\t\tclass Nested<X> {\n\t\t}\n\t}\n\n\tstatic class TypedTopLevelClass extends TopLevelClass<Integer> {\n\n\t\tclass TypedNested extends Nested<Long> {\n\t\t}\n\t}\n\n\tabstract static class WithArrayBase<T> {\n\n\t\tpublic abstract T[] array(T... args);\n\t}\n\n\tabstract static class WithArray<T> extends WithArrayBase<T> {\n\t}\n\n\tinterface Repository<T, ID extends Serializable> {\n\t}\n\n\tinterface IdFixingRepository<T> extends Repository<T, Long> {\n\t}\n\n\tstatic class WithMethodParameter {\n\n\t\tpublic void nestedGenerics(List<Map<String, Integer>> input) {\n\t\t}\n\t}\n\n\tinterface ListOfListSupplier<T> {\n\n\t\tList<List<T>> get();\n\t}\n\n\tinterface StringListOfListSupplier extends ListOfListSupplier<String> {\n\t}\n\n\tstatic class WithElementBounds {\n\n\t\t<T extends A> List<T> get() {\n\t\t\treturn List.of();\n\t\t}\n\t}\n\n\tstatic class WithUnresolvableElement<T> {\n\n\t\tList<T> get() {\n\t\t\treturn List.of();\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.MyConcreteType",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.MyConcreteType",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.springframework.core.GenericTypeResolver.getTypeVariableMap;\nimport static org.springframework.core.GenericTypeResolver.resolveReturnTypeArgument;\nimport static org.springframework.core.GenericTypeResolver.resolveType;\nimport static org.springframework.core.GenericTypeResolver.resolveTypeArgument;\nimport static org.springframework.util.ReflectionUtils.findMethod;\n\n/**\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Sebastien Deleuze\n * @author Stephane Nicoll\n * @author Yanming Zhou\n */\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\nclass GenericTypeResolverTests {\n\n\t@Test\n\tvoid simpleInterfaceType() {\n\t\tassertThat(resolveTypeArgument(MySimpleInterfaceType.class, MyInterfaceType.class)).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid simpleCollectionInterfaceType() {\n\t\tassertThat(resolveTypeArgument(MyCollectionInterfaceType.class, MyInterfaceType.class)).isEqualTo(Collection.class);\n\t}\n\n\t@Test\n\tvoid simpleSuperclassType() {\n\t\tassertThat(resolveTypeArgument(MySimpleSuperclassType.class, MySuperclassType.class)).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid simpleCollectionSuperclassType() {\n\t\tassertThat(resolveTypeArgument(MyCollectionSuperclassType.class, MySuperclassType.class)).isEqualTo(Collection.class);\n\t}\n\n\t@Test\n\tvoid nullIfNotResolvable() {\n\t\tGenericClass<String> obj = new GenericClass<>();\n\t\tassertThat(resolveTypeArgument(obj.getClass(), GenericClass.class)).isNull();\n\t}\n\n\t@Test\n\tvoid methodReturnTypes() {\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"integer\"), MyInterfaceType.class)).isEqualTo(Integer.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"string\"), MyInterfaceType.class)).isEqualTo(String.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"character\"), MyAbstractType.class)).isEqualTo(Character.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"raw\"), MyInterfaceType.class)).isNull();\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"object\"), MyInterfaceType.class)).isNull();\n\t}\n\n\t@Test\n\tvoid testResolveType() {\n\t\tMethod intMessageMethod = method(MyTypeWithMethods.class, \"readIntegerInputMessage\", MyInterfaceType.class);\n\t\tMethodParameter intMessageMethodParam = new MethodParameter(intMessageMethod, 0);\n\t\tassertThat(resolveType(intMessageMethodParam.getGenericParameterType(), new HashMap<>())).isEqualTo(MyInterfaceType.class);\n\n\t\tMethod intArrMessageMethod = method(MyTypeWithMethods.class, \"readIntegerArrayInputMessage\",\n\t\t\t\tMyInterfaceType[].class);\n\t\tMethodParameter intArrMessageMethodParam = new MethodParameter(intArrMessageMethod, 0);\n\t\tassertThat(resolveType(intArrMessageMethodParam.getGenericParameterType(), new HashMap<>())).isEqualTo(MyInterfaceType[].class);\n\n\t\tMethod genericArrMessageMethod = method(MySimpleTypeWithMethods.class, \"readGenericArrayInputMessage\",\n\t\t\t\tObject[].class);\n\t\tMethodParameter genericArrMessageMethodParam = new MethodParameter(genericArrMessageMethod, 0);\n\t\tMap<TypeVariable, Type> varMap = getTypeVariableMap(MySimpleTypeWithMethods.class);\n\t\tassertThat(resolveType(genericArrMessageMethodParam.getGenericParameterType(), varMap)).isEqualTo(Integer[].class);\n\t}\n\n\t@Test\n\tvoid boundParameterizedType() {\n\t\tassertThat(resolveTypeArgument(TestImpl.class, TestIfc.class)).isEqualTo(B.class);\n\t}\n\n\t@Test\n\tvoid testGetTypeVariableMap() {\n\t\tMap<TypeVariable, Type> map;\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MySimpleInterfaceType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.String}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MyCollectionInterfaceType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=java.util.Collection<java.lang.String>}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MyCollectionSuperclassType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=java.util.Collection<java.lang.String>}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MySimpleTypeWithMethods.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.Integer}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TopLevelClass.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TypedTopLevelClass.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.Integer}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TypedTopLevelClass.TypedNested.class);\n\t\tassertThat(map).hasSize(2);\n\t\tType t = null;\n\t\tType x = null;\n\t\tfor (Map.Entry<TypeVariable, Type> entry : map.entrySet()) {\n\t\t\tif (entry.getKey().toString().equals(\"T\")) {\n\t\t\t\tt = entry.getValue();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = entry.getValue();\n\t\t\t}\n\t\t}\n\t\tassertThat(t).isEqualTo(Integer.class);\n\t\tassertThat(x).isEqualTo(Long.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeArgumentsOfAbstractType() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(MyConcreteType.class, MyAbstractType.class);\n\t\tassertThat(resolved).containsExactly(Character.class);\n\t}\n\n\t@Test  // SPR-11030\n\tvoid getGenericsCannotBeResolved() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(List.class, Iterable.class);\n\t\tassertThat(resolved).isNull();\n\t}\n\n\t@Test  // SPR-11052\n\tvoid getRawMapTypeCannotBeResolved() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(Map.class, Map.class);\n\t\tassertThat(resolved).isNull();\n\t}\n\n\t@Test  // SPR-11044\n\t@SuppressWarnings(\"deprecation\")\n\tvoid getGenericsOnArrayFromParamCannotBeResolved() throws Exception {\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(\n\t\t\t\tWithArrayBase.class.getDeclaredMethod(\"array\", Object[].class), 0);\n\t\tClass<?> resolved = GenericTypeResolver.resolveParameterType(methodParameter, WithArray.class);\n\t\tassertThat(resolved).isEqualTo(Object[].class);\n\t}\n\n\t@Test  // SPR-11044\n\tvoid getGenericsOnArrayFromReturnCannotBeResolved() throws Exception {\n\t\tClass<?> resolved = GenericTypeResolver.resolveReturnType(\n\t\t\t\tWithArrayBase.class.getDeclaredMethod(\"array\", Object[].class), WithArray.class);\n\t\tassertThat(resolved).isEqualTo(Object[].class);\n\t}\n\n\t@Test  // SPR-11763\n\tvoid resolveIncompleteTypeVariables() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(IdFixingRepository.class, Repository.class);\n\t\tassertThat(resolved).isNotNull();\n\t\tassertThat(resolved).hasSize(2);\n\t\tassertThat(resolved[0]).isEqualTo(Object.class);\n\t\tassertThat(resolved[1]).isEqualTo(Long.class);\n\t}\n\n\t@Test\n\tvoid resolvePartiallySpecializedTypeVariables() {\n\t\tType resolved = resolveType(BiGenericClass.class.getTypeParameters()[0], TypeFixedBiGenericClass.class);\n\t\tassertThat(resolved).isEqualTo(D.class);\n\t}\n\n\t@Test\n\tvoid resolveTransitiveTypeVariableWithDifferentName() {\n\t\tType resolved = resolveType(BiGenericClass.class.getTypeParameters()[1], TypeFixedBiGenericClass.class);\n\t\tassertThat(resolved).isEqualTo(E.class);\n\t}\n\n\t@Test\n\tvoid resolveMethodParameterWithNestedGenerics() {\n\t\tMethod method = method(WithMethodParameter.class, \"nestedGenerics\", List.class);\n\t\tMethodParameter methodParameter = new MethodParameter(method, 0);\n\t\tType resolvedType = resolveType(methodParameter.getGenericParameterType(), WithMethodParameter.class);\n\t\tParameterizedTypeReference<List<Map<String, Integer>>> reference = new ParameterizedTypeReference<>() {};\n\t\tassertThat(resolvedType).isEqualTo(reference.getType());\n\t}\n\n\t@Test\n\tvoid resolveNestedTypeVariable() throws Exception {\n\t\tType resolved = resolveType(ListOfListSupplier.class.getMethod(\"get\").getGenericReturnType(),\n\t\t\t\tStringListOfListSupplier.class);\n\t\tassertThat(ResolvableType.forType(resolved).getGeneric(0).getGeneric(0).resolve()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeWithElementBounds() {\n\t\tType type = method(WithElementBounds.class, \"get\").getGenericReturnType();\n\t\tType resolvedType = resolveType(type, WithElementBounds.class);\n\t\tParameterizedTypeReference<List<A>> reference = new ParameterizedTypeReference<>() {};\n\t\tassertThat(resolvedType).isEqualTo(reference.getType());\n\t}\n\n\t@Test\n\tvoid resolveTypeWithUnresolvableElement() {\n\t\tType type = method(WithUnresolvableElement.class, \"get\").getGenericReturnType();\n\t\tType resolvedType = resolveType(type, WithUnresolvableElement.class);\n\t\tassertThat(resolvedType.toString()).isEqualTo(\"java.util.List<E>\");\n\t}\n\n\tprivate static Method method(Class<?> target, String methodName, Class<?>... parameterTypes) {\n\t\tMethod method = findMethod(target, methodName, parameterTypes);\n\t\tassertThat(method).describedAs(target.getName() + \"#\" + methodName).isNotNull();\n\t\treturn method;\n\t}\n\n\n\tpublic interface MyInterfaceType<T> {\n\t}\n\n\tpublic class MySimpleInterfaceType implements MyInterfaceType<String> {\n\t}\n\n\tpublic class MyCollectionInterfaceType implements MyInterfaceType<Collection<String>> {\n\t}\n\n\tpublic abstract class MyAbstractType<T> implements MyInterfaceType<T> {\n\t}\n\n\tpublic class MyConcreteType extends MyAbstractType<Character> {\n\t}\n\n\tpublic abstract class MySuperclassType<T> {\n\t}\n\n\tpublic class MySimpleSuperclassType extends MySuperclassType<String> {\n\t}\n\n\tpublic class MyCollectionSuperclassType extends MySuperclassType<Collection<String>> {\n\t}\n\n\tpublic static class MyTypeWithMethods<T> {\n\n\t\tpublic MyInterfaceType<Integer> integer() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MySimpleInterfaceType string() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MyConcreteType character() { return null; }\n\n\t\tpublic Object object() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MyInterfaceType raw() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic String notParameterized() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic String notParameterizedWithArguments(Integer x, Boolean b) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Simulates a factory method that wraps the supplied object in a proxy of the\n\t\t * same type.\n\t\t */\n\t\tpublic static <T> T createProxy(T object) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createProxy(Object)} but adds an additional argument before\n\t\t * the argument of type {@code T}. Note that they may potentially be of the same\n\t\t * time when invoked!\n\t\t */\n\t\tpublic static <T> T createNamedProxy(String name, T object) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Simulates factory methods found in libraries such as Mockito and EasyMock.\n\t\t */\n\t\tpublic static <MOCK> MOCK createMock(Class<MOCK> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createMock(Class)} but adds an additional method argument\n\t\t * before the parameterized argument.\n\t\t */\n\t\tpublic static <T> T createNamedMock(String name, Class<T> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createNamedMock(String, Class)} but adds an additional\n\t\t * parameterized type.\n\t\t */\n\t\tpublic static <V extends Object, T> T createVMock(V name, Class<T> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Extract some value of the type supported by the interface (i.e., by a concrete,\n\t\t * non-generic implementation of the interface).\n\t\t */\n\t\tpublic static <T> T extractValueFrom(MyInterfaceType<T> myInterfaceType) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Extract some magic value from the supplied map.\n\t\t */\n\t\tpublic static <K, V> V extractMagicValue(Map<K, V> map) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void readIntegerInputMessage(MyInterfaceType<Integer> message) {\n\t\t}\n\n\t\tpublic void readIntegerArrayInputMessage(MyInterfaceType<Integer>[] message) {\n\t\t}\n\n\t\tpublic void readGenericArrayInputMessage(T[] message) {\n\t\t}\n\t}\n\n\tpublic static class MySimpleTypeWithMethods extends MyTypeWithMethods<Integer> {\n\t}\n\n\tstatic class GenericClass<T> {\n\t}\n\n\tclass A {}\n\n\tclass B<T> {}\n\n\tclass C extends A {}\n\n\tclass D extends B<Long> {}\n\n\tclass E extends C {}\n\n\tclass TestIfc<T> {}\n\n\tclass TestImpl<I extends A, T extends B<I>> extends TestIfc<T> {\n\t}\n\n\tabstract static class BiGenericClass<T extends B<?>, V extends A> {}\n\n\tabstract static class SpecializedBiGenericClass<U extends C> extends BiGenericClass<D, U> {}\n\n\tstatic class TypeFixedBiGenericClass extends SpecializedBiGenericClass<E> {}\n\n\tstatic class TopLevelClass<T> {\n\n\t\tclass Nested<X> {\n\t\t}\n\t}\n\n\tstatic class TypedTopLevelClass extends TopLevelClass<Integer> {\n\n\t\tclass TypedNested extends Nested<Long> {\n\t\t}\n\t}\n\n\tabstract static class WithArrayBase<T> {\n\n\t\tpublic abstract T[] array(T... args);\n\t}\n\n\tabstract static class WithArray<T> extends WithArrayBase<T> {\n\t}\n\n\tinterface Repository<T, ID extends Serializable> {\n\t}\n\n\tinterface IdFixingRepository<T> extends Repository<T, Long> {\n\t}\n\n\tstatic class WithMethodParameter {\n\n\t\tpublic void nestedGenerics(List<Map<String, Integer>> input) {\n\t\t}\n\t}\n\n\tinterface ListOfListSupplier<T> {\n\n\t\tList<List<T>> get();\n\t}\n\n\tinterface StringListOfListSupplier extends ListOfListSupplier<String> {\n\t}\n\n\tstatic class WithElementBounds {\n\n\t\t<T extends A> List<T> get() {\n\t\t\treturn List.of();\n\t\t}\n\t}\n\n\tstatic class WithUnresolvableElement<T> {\n\n\t\tList<T> get() {\n\t\t\treturn List.of();\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.MyConcreteType",
    "headType": "class",
    "relation": "extend",
    "tail": "MyAbstractType",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.MySuperclassType",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.MySuperclassType",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.springframework.core.GenericTypeResolver.getTypeVariableMap;\nimport static org.springframework.core.GenericTypeResolver.resolveReturnTypeArgument;\nimport static org.springframework.core.GenericTypeResolver.resolveType;\nimport static org.springframework.core.GenericTypeResolver.resolveTypeArgument;\nimport static org.springframework.util.ReflectionUtils.findMethod;\n\n/**\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Sebastien Deleuze\n * @author Stephane Nicoll\n * @author Yanming Zhou\n */\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\nclass GenericTypeResolverTests {\n\n\t@Test\n\tvoid simpleInterfaceType() {\n\t\tassertThat(resolveTypeArgument(MySimpleInterfaceType.class, MyInterfaceType.class)).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid simpleCollectionInterfaceType() {\n\t\tassertThat(resolveTypeArgument(MyCollectionInterfaceType.class, MyInterfaceType.class)).isEqualTo(Collection.class);\n\t}\n\n\t@Test\n\tvoid simpleSuperclassType() {\n\t\tassertThat(resolveTypeArgument(MySimpleSuperclassType.class, MySuperclassType.class)).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid simpleCollectionSuperclassType() {\n\t\tassertThat(resolveTypeArgument(MyCollectionSuperclassType.class, MySuperclassType.class)).isEqualTo(Collection.class);\n\t}\n\n\t@Test\n\tvoid nullIfNotResolvable() {\n\t\tGenericClass<String> obj = new GenericClass<>();\n\t\tassertThat(resolveTypeArgument(obj.getClass(), GenericClass.class)).isNull();\n\t}\n\n\t@Test\n\tvoid methodReturnTypes() {\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"integer\"), MyInterfaceType.class)).isEqualTo(Integer.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"string\"), MyInterfaceType.class)).isEqualTo(String.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"character\"), MyAbstractType.class)).isEqualTo(Character.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"raw\"), MyInterfaceType.class)).isNull();\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"object\"), MyInterfaceType.class)).isNull();\n\t}\n\n\t@Test\n\tvoid testResolveType() {\n\t\tMethod intMessageMethod = method(MyTypeWithMethods.class, \"readIntegerInputMessage\", MyInterfaceType.class);\n\t\tMethodParameter intMessageMethodParam = new MethodParameter(intMessageMethod, 0);\n\t\tassertThat(resolveType(intMessageMethodParam.getGenericParameterType(), new HashMap<>())).isEqualTo(MyInterfaceType.class);\n\n\t\tMethod intArrMessageMethod = method(MyTypeWithMethods.class, \"readIntegerArrayInputMessage\",\n\t\t\t\tMyInterfaceType[].class);\n\t\tMethodParameter intArrMessageMethodParam = new MethodParameter(intArrMessageMethod, 0);\n\t\tassertThat(resolveType(intArrMessageMethodParam.getGenericParameterType(), new HashMap<>())).isEqualTo(MyInterfaceType[].class);\n\n\t\tMethod genericArrMessageMethod = method(MySimpleTypeWithMethods.class, \"readGenericArrayInputMessage\",\n\t\t\t\tObject[].class);\n\t\tMethodParameter genericArrMessageMethodParam = new MethodParameter(genericArrMessageMethod, 0);\n\t\tMap<TypeVariable, Type> varMap = getTypeVariableMap(MySimpleTypeWithMethods.class);\n\t\tassertThat(resolveType(genericArrMessageMethodParam.getGenericParameterType(), varMap)).isEqualTo(Integer[].class);\n\t}\n\n\t@Test\n\tvoid boundParameterizedType() {\n\t\tassertThat(resolveTypeArgument(TestImpl.class, TestIfc.class)).isEqualTo(B.class);\n\t}\n\n\t@Test\n\tvoid testGetTypeVariableMap() {\n\t\tMap<TypeVariable, Type> map;\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MySimpleInterfaceType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.String}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MyCollectionInterfaceType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=java.util.Collection<java.lang.String>}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MyCollectionSuperclassType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=java.util.Collection<java.lang.String>}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MySimpleTypeWithMethods.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.Integer}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TopLevelClass.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TypedTopLevelClass.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.Integer}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TypedTopLevelClass.TypedNested.class);\n\t\tassertThat(map).hasSize(2);\n\t\tType t = null;\n\t\tType x = null;\n\t\tfor (Map.Entry<TypeVariable, Type> entry : map.entrySet()) {\n\t\t\tif (entry.getKey().toString().equals(\"T\")) {\n\t\t\t\tt = entry.getValue();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = entry.getValue();\n\t\t\t}\n\t\t}\n\t\tassertThat(t).isEqualTo(Integer.class);\n\t\tassertThat(x).isEqualTo(Long.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeArgumentsOfAbstractType() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(MyConcreteType.class, MyAbstractType.class);\n\t\tassertThat(resolved).containsExactly(Character.class);\n\t}\n\n\t@Test  // SPR-11030\n\tvoid getGenericsCannotBeResolved() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(List.class, Iterable.class);\n\t\tassertThat(resolved).isNull();\n\t}\n\n\t@Test  // SPR-11052\n\tvoid getRawMapTypeCannotBeResolved() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(Map.class, Map.class);\n\t\tassertThat(resolved).isNull();\n\t}\n\n\t@Test  // SPR-11044\n\t@SuppressWarnings(\"deprecation\")\n\tvoid getGenericsOnArrayFromParamCannotBeResolved() throws Exception {\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(\n\t\t\t\tWithArrayBase.class.getDeclaredMethod(\"array\", Object[].class), 0);\n\t\tClass<?> resolved = GenericTypeResolver.resolveParameterType(methodParameter, WithArray.class);\n\t\tassertThat(resolved).isEqualTo(Object[].class);\n\t}\n\n\t@Test  // SPR-11044\n\tvoid getGenericsOnArrayFromReturnCannotBeResolved() throws Exception {\n\t\tClass<?> resolved = GenericTypeResolver.resolveReturnType(\n\t\t\t\tWithArrayBase.class.getDeclaredMethod(\"array\", Object[].class), WithArray.class);\n\t\tassertThat(resolved).isEqualTo(Object[].class);\n\t}\n\n\t@Test  // SPR-11763\n\tvoid resolveIncompleteTypeVariables() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(IdFixingRepository.class, Repository.class);\n\t\tassertThat(resolved).isNotNull();\n\t\tassertThat(resolved).hasSize(2);\n\t\tassertThat(resolved[0]).isEqualTo(Object.class);\n\t\tassertThat(resolved[1]).isEqualTo(Long.class);\n\t}\n\n\t@Test\n\tvoid resolvePartiallySpecializedTypeVariables() {\n\t\tType resolved = resolveType(BiGenericClass.class.getTypeParameters()[0], TypeFixedBiGenericClass.class);\n\t\tassertThat(resolved).isEqualTo(D.class);\n\t}\n\n\t@Test\n\tvoid resolveTransitiveTypeVariableWithDifferentName() {\n\t\tType resolved = resolveType(BiGenericClass.class.getTypeParameters()[1], TypeFixedBiGenericClass.class);\n\t\tassertThat(resolved).isEqualTo(E.class);\n\t}\n\n\t@Test\n\tvoid resolveMethodParameterWithNestedGenerics() {\n\t\tMethod method = method(WithMethodParameter.class, \"nestedGenerics\", List.class);\n\t\tMethodParameter methodParameter = new MethodParameter(method, 0);\n\t\tType resolvedType = resolveType(methodParameter.getGenericParameterType(), WithMethodParameter.class);\n\t\tParameterizedTypeReference<List<Map<String, Integer>>> reference = new ParameterizedTypeReference<>() {};\n\t\tassertThat(resolvedType).isEqualTo(reference.getType());\n\t}\n\n\t@Test\n\tvoid resolveNestedTypeVariable() throws Exception {\n\t\tType resolved = resolveType(ListOfListSupplier.class.getMethod(\"get\").getGenericReturnType(),\n\t\t\t\tStringListOfListSupplier.class);\n\t\tassertThat(ResolvableType.forType(resolved).getGeneric(0).getGeneric(0).resolve()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeWithElementBounds() {\n\t\tType type = method(WithElementBounds.class, \"get\").getGenericReturnType();\n\t\tType resolvedType = resolveType(type, WithElementBounds.class);\n\t\tParameterizedTypeReference<List<A>> reference = new ParameterizedTypeReference<>() {};\n\t\tassertThat(resolvedType).isEqualTo(reference.getType());\n\t}\n\n\t@Test\n\tvoid resolveTypeWithUnresolvableElement() {\n\t\tType type = method(WithUnresolvableElement.class, \"get\").getGenericReturnType();\n\t\tType resolvedType = resolveType(type, WithUnresolvableElement.class);\n\t\tassertThat(resolvedType.toString()).isEqualTo(\"java.util.List<E>\");\n\t}\n\n\tprivate static Method method(Class<?> target, String methodName, Class<?>... parameterTypes) {\n\t\tMethod method = findMethod(target, methodName, parameterTypes);\n\t\tassertThat(method).describedAs(target.getName() + \"#\" + methodName).isNotNull();\n\t\treturn method;\n\t}\n\n\n\tpublic interface MyInterfaceType<T> {\n\t}\n\n\tpublic class MySimpleInterfaceType implements MyInterfaceType<String> {\n\t}\n\n\tpublic class MyCollectionInterfaceType implements MyInterfaceType<Collection<String>> {\n\t}\n\n\tpublic abstract class MyAbstractType<T> implements MyInterfaceType<T> {\n\t}\n\n\tpublic class MyConcreteType extends MyAbstractType<Character> {\n\t}\n\n\tpublic abstract class MySuperclassType<T> {\n\t}\n\n\tpublic class MySimpleSuperclassType extends MySuperclassType<String> {\n\t}\n\n\tpublic class MyCollectionSuperclassType extends MySuperclassType<Collection<String>> {\n\t}\n\n\tpublic static class MyTypeWithMethods<T> {\n\n\t\tpublic MyInterfaceType<Integer> integer() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MySimpleInterfaceType string() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MyConcreteType character() { return null; }\n\n\t\tpublic Object object() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MyInterfaceType raw() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic String notParameterized() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic String notParameterizedWithArguments(Integer x, Boolean b) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Simulates a factory method that wraps the supplied object in a proxy of the\n\t\t * same type.\n\t\t */\n\t\tpublic static <T> T createProxy(T object) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createProxy(Object)} but adds an additional argument before\n\t\t * the argument of type {@code T}. Note that they may potentially be of the same\n\t\t * time when invoked!\n\t\t */\n\t\tpublic static <T> T createNamedProxy(String name, T object) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Simulates factory methods found in libraries such as Mockito and EasyMock.\n\t\t */\n\t\tpublic static <MOCK> MOCK createMock(Class<MOCK> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createMock(Class)} but adds an additional method argument\n\t\t * before the parameterized argument.\n\t\t */\n\t\tpublic static <T> T createNamedMock(String name, Class<T> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createNamedMock(String, Class)} but adds an additional\n\t\t * parameterized type.\n\t\t */\n\t\tpublic static <V extends Object, T> T createVMock(V name, Class<T> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Extract some value of the type supported by the interface (i.e., by a concrete,\n\t\t * non-generic implementation of the interface).\n\t\t */\n\t\tpublic static <T> T extractValueFrom(MyInterfaceType<T> myInterfaceType) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Extract some magic value from the supplied map.\n\t\t */\n\t\tpublic static <K, V> V extractMagicValue(Map<K, V> map) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void readIntegerInputMessage(MyInterfaceType<Integer> message) {\n\t\t}\n\n\t\tpublic void readIntegerArrayInputMessage(MyInterfaceType<Integer>[] message) {\n\t\t}\n\n\t\tpublic void readGenericArrayInputMessage(T[] message) {\n\t\t}\n\t}\n\n\tpublic static class MySimpleTypeWithMethods extends MyTypeWithMethods<Integer> {\n\t}\n\n\tstatic class GenericClass<T> {\n\t}\n\n\tclass A {}\n\n\tclass B<T> {}\n\n\tclass C extends A {}\n\n\tclass D extends B<Long> {}\n\n\tclass E extends C {}\n\n\tclass TestIfc<T> {}\n\n\tclass TestImpl<I extends A, T extends B<I>> extends TestIfc<T> {\n\t}\n\n\tabstract static class BiGenericClass<T extends B<?>, V extends A> {}\n\n\tabstract static class SpecializedBiGenericClass<U extends C> extends BiGenericClass<D, U> {}\n\n\tstatic class TypeFixedBiGenericClass extends SpecializedBiGenericClass<E> {}\n\n\tstatic class TopLevelClass<T> {\n\n\t\tclass Nested<X> {\n\t\t}\n\t}\n\n\tstatic class TypedTopLevelClass extends TopLevelClass<Integer> {\n\n\t\tclass TypedNested extends Nested<Long> {\n\t\t}\n\t}\n\n\tabstract static class WithArrayBase<T> {\n\n\t\tpublic abstract T[] array(T... args);\n\t}\n\n\tabstract static class WithArray<T> extends WithArrayBase<T> {\n\t}\n\n\tinterface Repository<T, ID extends Serializable> {\n\t}\n\n\tinterface IdFixingRepository<T> extends Repository<T, Long> {\n\t}\n\n\tstatic class WithMethodParameter {\n\n\t\tpublic void nestedGenerics(List<Map<String, Integer>> input) {\n\t\t}\n\t}\n\n\tinterface ListOfListSupplier<T> {\n\n\t\tList<List<T>> get();\n\t}\n\n\tinterface StringListOfListSupplier extends ListOfListSupplier<String> {\n\t}\n\n\tstatic class WithElementBounds {\n\n\t\t<T extends A> List<T> get() {\n\t\t\treturn List.of();\n\t\t}\n\t}\n\n\tstatic class WithUnresolvableElement<T> {\n\n\t\tList<T> get() {\n\t\t\treturn List.of();\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.MySimpleSuperclassType",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.MySimpleSuperclassType",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.springframework.core.GenericTypeResolver.getTypeVariableMap;\nimport static org.springframework.core.GenericTypeResolver.resolveReturnTypeArgument;\nimport static org.springframework.core.GenericTypeResolver.resolveType;\nimport static org.springframework.core.GenericTypeResolver.resolveTypeArgument;\nimport static org.springframework.util.ReflectionUtils.findMethod;\n\n/**\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Sebastien Deleuze\n * @author Stephane Nicoll\n * @author Yanming Zhou\n */\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\nclass GenericTypeResolverTests {\n\n\t@Test\n\tvoid simpleInterfaceType() {\n\t\tassertThat(resolveTypeArgument(MySimpleInterfaceType.class, MyInterfaceType.class)).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid simpleCollectionInterfaceType() {\n\t\tassertThat(resolveTypeArgument(MyCollectionInterfaceType.class, MyInterfaceType.class)).isEqualTo(Collection.class);\n\t}\n\n\t@Test\n\tvoid simpleSuperclassType() {\n\t\tassertThat(resolveTypeArgument(MySimpleSuperclassType.class, MySuperclassType.class)).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid simpleCollectionSuperclassType() {\n\t\tassertThat(resolveTypeArgument(MyCollectionSuperclassType.class, MySuperclassType.class)).isEqualTo(Collection.class);\n\t}\n\n\t@Test\n\tvoid nullIfNotResolvable() {\n\t\tGenericClass<String> obj = new GenericClass<>();\n\t\tassertThat(resolveTypeArgument(obj.getClass(), GenericClass.class)).isNull();\n\t}\n\n\t@Test\n\tvoid methodReturnTypes() {\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"integer\"), MyInterfaceType.class)).isEqualTo(Integer.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"string\"), MyInterfaceType.class)).isEqualTo(String.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"character\"), MyAbstractType.class)).isEqualTo(Character.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"raw\"), MyInterfaceType.class)).isNull();\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"object\"), MyInterfaceType.class)).isNull();\n\t}\n\n\t@Test\n\tvoid testResolveType() {\n\t\tMethod intMessageMethod = method(MyTypeWithMethods.class, \"readIntegerInputMessage\", MyInterfaceType.class);\n\t\tMethodParameter intMessageMethodParam = new MethodParameter(intMessageMethod, 0);\n\t\tassertThat(resolveType(intMessageMethodParam.getGenericParameterType(), new HashMap<>())).isEqualTo(MyInterfaceType.class);\n\n\t\tMethod intArrMessageMethod = method(MyTypeWithMethods.class, \"readIntegerArrayInputMessage\",\n\t\t\t\tMyInterfaceType[].class);\n\t\tMethodParameter intArrMessageMethodParam = new MethodParameter(intArrMessageMethod, 0);\n\t\tassertThat(resolveType(intArrMessageMethodParam.getGenericParameterType(), new HashMap<>())).isEqualTo(MyInterfaceType[].class);\n\n\t\tMethod genericArrMessageMethod = method(MySimpleTypeWithMethods.class, \"readGenericArrayInputMessage\",\n\t\t\t\tObject[].class);\n\t\tMethodParameter genericArrMessageMethodParam = new MethodParameter(genericArrMessageMethod, 0);\n\t\tMap<TypeVariable, Type> varMap = getTypeVariableMap(MySimpleTypeWithMethods.class);\n\t\tassertThat(resolveType(genericArrMessageMethodParam.getGenericParameterType(), varMap)).isEqualTo(Integer[].class);\n\t}\n\n\t@Test\n\tvoid boundParameterizedType() {\n\t\tassertThat(resolveTypeArgument(TestImpl.class, TestIfc.class)).isEqualTo(B.class);\n\t}\n\n\t@Test\n\tvoid testGetTypeVariableMap() {\n\t\tMap<TypeVariable, Type> map;\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MySimpleInterfaceType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.String}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MyCollectionInterfaceType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=java.util.Collection<java.lang.String>}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MyCollectionSuperclassType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=java.util.Collection<java.lang.String>}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MySimpleTypeWithMethods.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.Integer}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TopLevelClass.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TypedTopLevelClass.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.Integer}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TypedTopLevelClass.TypedNested.class);\n\t\tassertThat(map).hasSize(2);\n\t\tType t = null;\n\t\tType x = null;\n\t\tfor (Map.Entry<TypeVariable, Type> entry : map.entrySet()) {\n\t\t\tif (entry.getKey().toString().equals(\"T\")) {\n\t\t\t\tt = entry.getValue();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = entry.getValue();\n\t\t\t}\n\t\t}\n\t\tassertThat(t).isEqualTo(Integer.class);\n\t\tassertThat(x).isEqualTo(Long.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeArgumentsOfAbstractType() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(MyConcreteType.class, MyAbstractType.class);\n\t\tassertThat(resolved).containsExactly(Character.class);\n\t}\n\n\t@Test  // SPR-11030\n\tvoid getGenericsCannotBeResolved() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(List.class, Iterable.class);\n\t\tassertThat(resolved).isNull();\n\t}\n\n\t@Test  // SPR-11052\n\tvoid getRawMapTypeCannotBeResolved() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(Map.class, Map.class);\n\t\tassertThat(resolved).isNull();\n\t}\n\n\t@Test  // SPR-11044\n\t@SuppressWarnings(\"deprecation\")\n\tvoid getGenericsOnArrayFromParamCannotBeResolved() throws Exception {\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(\n\t\t\t\tWithArrayBase.class.getDeclaredMethod(\"array\", Object[].class), 0);\n\t\tClass<?> resolved = GenericTypeResolver.resolveParameterType(methodParameter, WithArray.class);\n\t\tassertThat(resolved).isEqualTo(Object[].class);\n\t}\n\n\t@Test  // SPR-11044\n\tvoid getGenericsOnArrayFromReturnCannotBeResolved() throws Exception {\n\t\tClass<?> resolved = GenericTypeResolver.resolveReturnType(\n\t\t\t\tWithArrayBase.class.getDeclaredMethod(\"array\", Object[].class), WithArray.class);\n\t\tassertThat(resolved).isEqualTo(Object[].class);\n\t}\n\n\t@Test  // SPR-11763\n\tvoid resolveIncompleteTypeVariables() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(IdFixingRepository.class, Repository.class);\n\t\tassertThat(resolved).isNotNull();\n\t\tassertThat(resolved).hasSize(2);\n\t\tassertThat(resolved[0]).isEqualTo(Object.class);\n\t\tassertThat(resolved[1]).isEqualTo(Long.class);\n\t}\n\n\t@Test\n\tvoid resolvePartiallySpecializedTypeVariables() {\n\t\tType resolved = resolveType(BiGenericClass.class.getTypeParameters()[0], TypeFixedBiGenericClass.class);\n\t\tassertThat(resolved).isEqualTo(D.class);\n\t}\n\n\t@Test\n\tvoid resolveTransitiveTypeVariableWithDifferentName() {\n\t\tType resolved = resolveType(BiGenericClass.class.getTypeParameters()[1], TypeFixedBiGenericClass.class);\n\t\tassertThat(resolved).isEqualTo(E.class);\n\t}\n\n\t@Test\n\tvoid resolveMethodParameterWithNestedGenerics() {\n\t\tMethod method = method(WithMethodParameter.class, \"nestedGenerics\", List.class);\n\t\tMethodParameter methodParameter = new MethodParameter(method, 0);\n\t\tType resolvedType = resolveType(methodParameter.getGenericParameterType(), WithMethodParameter.class);\n\t\tParameterizedTypeReference<List<Map<String, Integer>>> reference = new ParameterizedTypeReference<>() {};\n\t\tassertThat(resolvedType).isEqualTo(reference.getType());\n\t}\n\n\t@Test\n\tvoid resolveNestedTypeVariable() throws Exception {\n\t\tType resolved = resolveType(ListOfListSupplier.class.getMethod(\"get\").getGenericReturnType(),\n\t\t\t\tStringListOfListSupplier.class);\n\t\tassertThat(ResolvableType.forType(resolved).getGeneric(0).getGeneric(0).resolve()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeWithElementBounds() {\n\t\tType type = method(WithElementBounds.class, \"get\").getGenericReturnType();\n\t\tType resolvedType = resolveType(type, WithElementBounds.class);\n\t\tParameterizedTypeReference<List<A>> reference = new ParameterizedTypeReference<>() {};\n\t\tassertThat(resolvedType).isEqualTo(reference.getType());\n\t}\n\n\t@Test\n\tvoid resolveTypeWithUnresolvableElement() {\n\t\tType type = method(WithUnresolvableElement.class, \"get\").getGenericReturnType();\n\t\tType resolvedType = resolveType(type, WithUnresolvableElement.class);\n\t\tassertThat(resolvedType.toString()).isEqualTo(\"java.util.List<E>\");\n\t}\n\n\tprivate static Method method(Class<?> target, String methodName, Class<?>... parameterTypes) {\n\t\tMethod method = findMethod(target, methodName, parameterTypes);\n\t\tassertThat(method).describedAs(target.getName() + \"#\" + methodName).isNotNull();\n\t\treturn method;\n\t}\n\n\n\tpublic interface MyInterfaceType<T> {\n\t}\n\n\tpublic class MySimpleInterfaceType implements MyInterfaceType<String> {\n\t}\n\n\tpublic class MyCollectionInterfaceType implements MyInterfaceType<Collection<String>> {\n\t}\n\n\tpublic abstract class MyAbstractType<T> implements MyInterfaceType<T> {\n\t}\n\n\tpublic class MyConcreteType extends MyAbstractType<Character> {\n\t}\n\n\tpublic abstract class MySuperclassType<T> {\n\t}\n\n\tpublic class MySimpleSuperclassType extends MySuperclassType<String> {\n\t}\n\n\tpublic class MyCollectionSuperclassType extends MySuperclassType<Collection<String>> {\n\t}\n\n\tpublic static class MyTypeWithMethods<T> {\n\n\t\tpublic MyInterfaceType<Integer> integer() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MySimpleInterfaceType string() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MyConcreteType character() { return null; }\n\n\t\tpublic Object object() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MyInterfaceType raw() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic String notParameterized() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic String notParameterizedWithArguments(Integer x, Boolean b) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Simulates a factory method that wraps the supplied object in a proxy of the\n\t\t * same type.\n\t\t */\n\t\tpublic static <T> T createProxy(T object) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createProxy(Object)} but adds an additional argument before\n\t\t * the argument of type {@code T}. Note that they may potentially be of the same\n\t\t * time when invoked!\n\t\t */\n\t\tpublic static <T> T createNamedProxy(String name, T object) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Simulates factory methods found in libraries such as Mockito and EasyMock.\n\t\t */\n\t\tpublic static <MOCK> MOCK createMock(Class<MOCK> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createMock(Class)} but adds an additional method argument\n\t\t * before the parameterized argument.\n\t\t */\n\t\tpublic static <T> T createNamedMock(String name, Class<T> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createNamedMock(String, Class)} but adds an additional\n\t\t * parameterized type.\n\t\t */\n\t\tpublic static <V extends Object, T> T createVMock(V name, Class<T> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Extract some value of the type supported by the interface (i.e., by a concrete,\n\t\t * non-generic implementation of the interface).\n\t\t */\n\t\tpublic static <T> T extractValueFrom(MyInterfaceType<T> myInterfaceType) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Extract some magic value from the supplied map.\n\t\t */\n\t\tpublic static <K, V> V extractMagicValue(Map<K, V> map) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void readIntegerInputMessage(MyInterfaceType<Integer> message) {\n\t\t}\n\n\t\tpublic void readIntegerArrayInputMessage(MyInterfaceType<Integer>[] message) {\n\t\t}\n\n\t\tpublic void readGenericArrayInputMessage(T[] message) {\n\t\t}\n\t}\n\n\tpublic static class MySimpleTypeWithMethods extends MyTypeWithMethods<Integer> {\n\t}\n\n\tstatic class GenericClass<T> {\n\t}\n\n\tclass A {}\n\n\tclass B<T> {}\n\n\tclass C extends A {}\n\n\tclass D extends B<Long> {}\n\n\tclass E extends C {}\n\n\tclass TestIfc<T> {}\n\n\tclass TestImpl<I extends A, T extends B<I>> extends TestIfc<T> {\n\t}\n\n\tabstract static class BiGenericClass<T extends B<?>, V extends A> {}\n\n\tabstract static class SpecializedBiGenericClass<U extends C> extends BiGenericClass<D, U> {}\n\n\tstatic class TypeFixedBiGenericClass extends SpecializedBiGenericClass<E> {}\n\n\tstatic class TopLevelClass<T> {\n\n\t\tclass Nested<X> {\n\t\t}\n\t}\n\n\tstatic class TypedTopLevelClass extends TopLevelClass<Integer> {\n\n\t\tclass TypedNested extends Nested<Long> {\n\t\t}\n\t}\n\n\tabstract static class WithArrayBase<T> {\n\n\t\tpublic abstract T[] array(T... args);\n\t}\n\n\tabstract static class WithArray<T> extends WithArrayBase<T> {\n\t}\n\n\tinterface Repository<T, ID extends Serializable> {\n\t}\n\n\tinterface IdFixingRepository<T> extends Repository<T, Long> {\n\t}\n\n\tstatic class WithMethodParameter {\n\n\t\tpublic void nestedGenerics(List<Map<String, Integer>> input) {\n\t\t}\n\t}\n\n\tinterface ListOfListSupplier<T> {\n\n\t\tList<List<T>> get();\n\t}\n\n\tinterface StringListOfListSupplier extends ListOfListSupplier<String> {\n\t}\n\n\tstatic class WithElementBounds {\n\n\t\t<T extends A> List<T> get() {\n\t\t\treturn List.of();\n\t\t}\n\t}\n\n\tstatic class WithUnresolvableElement<T> {\n\n\t\tList<T> get() {\n\t\t\treturn List.of();\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  }
]