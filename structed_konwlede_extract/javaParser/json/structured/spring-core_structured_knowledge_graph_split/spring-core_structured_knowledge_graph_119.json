[
  {
    "head": "org.springframework.aot.hint.BindingReflectionHintsRegistrar",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.hint.BindingReflectionHintsRegistrar#forEachJacksonAnnotation(AnnotatedElement,Consumer<MergedAnnotation<Annotation>>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.aot.hint.BindingReflectionHintsRegistrar#registerHintsForClassAttributes(ReflectionHints,MergedAnnotation<Annotation>)",
    "headType": "method",
    "relation": "provide",
    "tail": "private void registerHintsForClassAttributes(ReflectionHints hints, MergedAnnotation<Annotation> annotation) {\r\n    annotation.getRoot().asMap().forEach((attributeName, value) -> {\r\n        if (value instanceof Class<?> classValue && value != Void.class) {\r\n            if (attributeName.equals(\"builder\")) {\r\n                hints.registerType(classValue, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS);\r\n            } else {\r\n                hints.registerType(classValue, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);\r\n            }\r\n        }\r\n    });\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.hint.BindingReflectionHintsRegistrar",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.hint.BindingReflectionHintsRegistrar#registerHintsForClassAttributes(ReflectionHints,MergedAnnotation<Annotation>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.aot.hint",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.aot.hint.KotlinDelegate",
    "tailType": "class"
  },
  {
    "head": "org.springframework.aot.hint.KotlinDelegate",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.aot.hint;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.RecordComponent;\nimport java.lang.reflect.Type;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\nimport java.util.function.Consumer;\n\nimport kotlin.jvm.JvmClassMappingKt;\nimport kotlin.reflect.KClass;\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.core.KotlinDetector;\nimport org.springframework.core.MethodParameter;\nimport org.springframework.core.ResolvableType;\nimport org.springframework.core.annotation.MergedAnnotation;\nimport org.springframework.core.annotation.MergedAnnotations;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.ReflectionUtils;\n\n/**\n * Register the necessary reflection hints so that the specified type can be\n * bound at runtime. Fields, constructors, properties, and record components\n * are registered, except for a set of types like those in the {@code java.}\n * package where just the type is registered. Types are discovered transitively\n * on properties and record components, and generic types are registered as well.\n *\n * @author Sebastien Deleuze\n * @since 6.0\n */\npublic class BindingReflectionHintsRegistrar {\n\n\tprivate static final String KOTLIN_COMPANION_SUFFIX = \"$Companion\";\n\n\tprivate static final String JACKSON_ANNOTATION = \"com.fasterxml.jackson.annotation.JacksonAnnotation\";\n\n\tprivate static final boolean jacksonAnnotationPresent =\n\t\t\tClassUtils.isPresent(JACKSON_ANNOTATION, BindingReflectionHintsRegistrar.class.getClassLoader());\n\n\n\t/**\n\t * Register the necessary reflection hints to bind the specified types.\n\t * @param hints the hints instance to use\n\t * @param types the types to register\n\t */\n\tpublic void registerReflectionHints(ReflectionHints hints, Type... types) {\n\t\tSet<Type> seen = new HashSet<>();\n\t\tfor (Type type : types) {\n\t\t\tregisterReflectionHints(hints, seen, type);\n\t\t}\n\t}\n\n\tprivate boolean shouldSkipType(Class<?> type) {\n\t\treturn type.isPrimitive() || type == Object.class;\n\t}\n\n\tprivate boolean shouldSkipMembers(Class<?> type) {\n\t\treturn type.getCanonicalName().startsWith(\"java.\") || type.isArray();\n\t}\n\n\tprivate void registerReflectionHints(ReflectionHints hints, Set<Type> seen, Type type) {\n\t\tif (seen.contains(type)) {\n\t\t\treturn;\n\t\t}\n\t\tseen.add(type);\n\t\tif (type instanceof Class<?> clazz) {\n\t\t\tif (shouldSkipType(clazz)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\thints.registerType(clazz, typeHint -> {\n\t\t\t\tif (!shouldSkipMembers(clazz)) {\n\t\t\t\t\tif (clazz.isRecord()) {\n\t\t\t\t\t\ttypeHint.withMembers(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);\n\t\t\t\t\t\tfor (RecordComponent recordComponent : clazz.getRecordComponents()) {\n\t\t\t\t\t\t\tregisterRecordHints(hints, seen, recordComponent.getAccessor());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (clazz.isEnum()) {\n\t\t\t\t\t\ttypeHint.withMembers(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS,\n\t\t\t\t\t\t\t\tMemberCategory.INVOKE_PUBLIC_METHODS);\n\t\t\t\t\t}\n\t\t\t\t\ttypeHint.withMembers(MemberCategory.ACCESS_DECLARED_FIELDS,\n\t\t\t\t\t\t\tMemberCategory.INVOKE_DECLARED_CONSTRUCTORS);\n\t\t\t\t\tfor (Method method : clazz.getMethods()) {\n\t\t\t\t\t\tString methodName = method.getName();\n\t\t\t\t\t\tif (methodName.startsWith(\"set\") && method.getParameterCount() == 1) {\n\t\t\t\t\t\t\tregisterPropertyHints(hints, seen, method, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ((methodName.startsWith(\"get\") && method.getParameterCount() == 0 && method.getReturnType() != void.class) ||\n\t\t\t\t\t\t\t\t(methodName.startsWith(\"is\") && method.getParameterCount() == 0\n\t\t\t\t\t\t\t\t\t\t&& ClassUtils.resolvePrimitiveIfNecessary(method.getReturnType()) == Boolean.class)) {\n\t\t\t\t\t\t\tregisterPropertyHints(hints, seen, method, -1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (jacksonAnnotationPresent) {\n\t\t\t\t\t\tregisterJacksonHints(hints, clazz);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (KotlinDetector.isKotlinType(clazz)) {\n\t\t\t\t\tKotlinDelegate.registerComponentHints(hints, clazz);\n\t\t\t\t\tregisterKotlinSerializationHints(hints, clazz);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tSet<Class<?>> referencedTypes = new LinkedHashSet<>();\n\t\tcollectReferencedTypes(referencedTypes, ResolvableType.forType(type));\n\t\treferencedTypes.forEach(referencedType -> registerReflectionHints(hints, seen, referencedType));\n\t}\n\n\tprivate void registerRecordHints(ReflectionHints hints, Set<Type> seen, Method method) {\n\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(method, -1);\n\t\tType methodParameterType = methodParameter.getGenericParameterType();\n\t\tregisterReflectionHints(hints, seen, methodParameterType);\n\t}\n\n\tprivate void registerPropertyHints(ReflectionHints hints, Set<Type> seen, @Nullable Method method, int parameterIndex) {\n\t\tif (method != null && method.getDeclaringClass() != Object.class && method.getDeclaringClass() != Enum.class) {\n\t\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t\t\tMethodParameter methodParameter = MethodParameter.forExecutable(method, parameterIndex);\n\t\t\tType methodParameterType = methodParameter.getGenericParameterType();\n\t\t\tregisterReflectionHints(hints, seen, methodParameterType);\n\t\t}\n\t}\n\n\tprivate void registerKotlinSerializationHints(ReflectionHints hints, Class<?> clazz) {\n\t\tString companionClassName = clazz.getCanonicalName() + KOTLIN_COMPANION_SUFFIX;\n\t\tif (ClassUtils.isPresent(companionClassName, null)) {\n\t\t\tClass<?> companionClass = ClassUtils.resolveClassName(companionClassName, null);\n\t\t\tMethod serializerMethod = ClassUtils.getMethodIfAvailable(companionClass, \"serializer\");\n\t\t\tif (serializerMethod != null) {\n\t\t\t\thints.registerMethod(serializerMethod, ExecutableMode.INVOKE);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void collectReferencedTypes(Set<Class<?>> types, ResolvableType resolvableType) {\n\t\tClass<?> clazz = resolvableType.resolve();\n\t\tif (clazz != null && !types.contains(clazz)) {\n\t\t\ttypes.add(clazz);\n\t\t\tfor (ResolvableType genericResolvableType : resolvableType.getGenerics()) {\n\t\t\t\tcollectReferencedTypes(types, genericResolvableType);\n\t\t\t}\n\t\t\tClass<?> superClass = clazz.getSuperclass();\n\t\t\tif (superClass != null && superClass != Object.class && superClass != Record.class && superClass != Enum.class) {\n\t\t\t\ttypes.add(superClass);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void registerJacksonHints(ReflectionHints hints, Class<?> clazz) {\n\t\tReflectionUtils.doWithFields(clazz, field ->\n\t\t\t\tforEachJacksonAnnotation(field, annotation -> {\n\t\t\t\t\t\t\tField sourceField = (Field) annotation.getSource();\n\t\t\t\t\t\t\tif (sourceField != null) {\n\t\t\t\t\t\t\t\thints.registerField(sourceField);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tregisterHintsForClassAttributes(hints, annotation);\n\t\t\t\t\t\t}));\n\t\tReflectionUtils.doWithMethods(clazz, method ->\n\t\t\t\tforEachJacksonAnnotation(method, annotation -> {\n\t\t\t\t\t\t\tMethod sourceMethod = (Method) annotation.getSource();\n\t\t\t\t\t\t\tif (sourceMethod != null) {\n\t\t\t\t\t\t\t\thints.registerMethod(sourceMethod, ExecutableMode.INVOKE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tregisterHintsForClassAttributes(hints, annotation);\n\t\t\t\t\t\t}));\n\t\tforEachJacksonAnnotation(clazz, annotation -> registerHintsForClassAttributes(hints, annotation));\n\t}\n\n\tprivate void forEachJacksonAnnotation(AnnotatedElement element, Consumer<MergedAnnotation<Annotation>> action) {\n\t\tMergedAnnotations\n\t\t\t\t.from(element, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.stream(JACKSON_ANNOTATION)\n\t\t\t\t.filter(MergedAnnotation::isMetaPresent)\n\t\t\t\t.forEach(action);\n\t}\n\n\tprivate void registerHintsForClassAttributes(ReflectionHints hints, MergedAnnotation<Annotation> annotation) {\n\t\tannotation.getRoot().asMap().forEach((attributeName, value) -> {\n\t\t\tif (value instanceof Class<?> classValue && value != Void.class) {\n\t\t\t\tif (attributeName.equals(\"builder\")) {\n\t\t\t\t\thints.registerType(classValue, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS,\n\t\t\t\t\t\t\tMemberCategory.INVOKE_DECLARED_METHODS);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thints.registerType(classValue, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\n\t/**\n\t * Inner class to avoid a hard dependency on Kotlin at runtime.\n\t */\n\tprivate static class KotlinDelegate {\n\n\t\tpublic static void registerComponentHints(ReflectionHints hints, Class<?> type) {\n\t\t\tKClass<?> kClass = JvmClassMappingKt.getKotlinClass(type);\n\t\t\tif (kClass.isData()) {\n\t\t\t\tfor (Method method : type.getMethods()) {\n\t\t\t\t\tString methodName = method.getName();\n\t\t\t\t\tif (methodName.startsWith(\"component\") || methodName.equals(\"copy\") || methodName.equals(\"copy$default\")) {\n\t\t\t\t\t\thints.registerMethod(method, ExecutableMode.INVOKE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.aot.hint.KotlinDelegate#registerComponentHints(ReflectionHints,Class<?>)",
    "headType": "method",
    "relation": "provide",
    "tail": "public static void registerComponentHints(ReflectionHints hints, Class<?> type) {\r\n    KClass<?> kClass = JvmClassMappingKt.getKotlinClass(type);\r\n    if (kClass.isData()) {\r\n        for (Method method : type.getMethods()) {\r\n            String methodName = method.getName();\r\n            if (methodName.startsWith(\"component\") || methodName.equals(\"copy\") || methodName.equals(\"copy$default\")) {\r\n                hints.registerMethod(method, ExecutableMode.INVOKE);\r\n            }\r\n        }\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.hint.KotlinDelegate",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.hint.KotlinDelegate#registerComponentHints(ReflectionHints,Class<?>)",
    "tailType": "method"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.util",
    "tailType": "package"
  },
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.AntPathMatcherTests",
    "tailType": "class"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.aot.hint",
    "tailType": "package"
  },
  {
    "head": "org.springframework.aot.hint",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.aot.hint.ConditionalHint",
    "tailType": "class"
  },
  {
    "head": "org.springframework.aot.hint.ConditionalHint",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2022 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.aot.hint;\n\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.util.ClassUtils;\n\n/**\n * Contract for {@link RuntimeHints runtime hints} that only apply\n * if the described condition is met.\n *\n * @author Brian Clozel\n * @since 6.0\n */\npublic interface ConditionalHint {\n\n\t/**\n\t * Return the type that should be reachable for this hint to apply, or\n\t * {@code null} if this hint should always been applied.\n\t * @return the reachable type, if any\n\t */\n\t@Nullable TypeReference getReachableType();\n\n\t/**\n\t * Whether the condition described for this hint is met. If it is not,\n\t * the hint does not apply.\n\t * <p>Instead of checking for actual reachability of a type in the\n\t * application, the classpath is checked for the presence of this\n\t * type as a simple heuristic.\n\t * @param classLoader the current classloader\n\t * @return whether the condition is met and the hint applies\n\t */\n\tdefault boolean conditionMatches(ClassLoader classLoader) {\n\t\tTypeReference reachableType = getReachableType();\n\t\tif (reachableType != null) {\n\t\t\treturn ClassUtils.isPresent(reachableType.getCanonicalName(), classLoader);\n\t\t}\n\t\treturn true;\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.aot.hint.ConditionalHint#getReachableType()",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Return the type that should be reachable for this hint to apply, or\r\n * {@code null} if this hint should always been applied.\r\n * @return the reachable type, if any\r\n */\r\n@Nullable\r\nTypeReference getReachableType();",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.hint.ConditionalHint",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.hint.ConditionalHint#getReachableType()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.aot.hint.ConditionalHint#getReachableType()",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.aot.hint.ConditionalHint#conditionMatches(ClassLoader)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Whether the condition described for this hint is met. If it is not,\r\n * the hint does not apply.\r\n * <p>Instead of checking for actual reachability of a type in the\r\n * application, the classpath is checked for the presence of this\r\n * type as a simple heuristic.\r\n * @param classLoader the current classloader\r\n * @return whether the condition is met and the hint applies\r\n */\r\ndefault boolean conditionMatches(ClassLoader classLoader) {\r\n    TypeReference reachableType = getReachableType();\r\n    if (reachableType != null) {\r\n        return ClassUtils.isPresent(reachableType.getCanonicalName(), classLoader);\r\n    }\r\n    return true;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.hint.ConditionalHint",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.hint.ConditionalHint#conditionMatches(ClassLoader)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.AntPathMatcherTests",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n\n/**\n * Tests for {@link AntPathMatcher}.\n *\n * @author Alef Arendsen\n * @author Seth Ladd\n * @author Juergen Hoeller\n * @author Arjen Poutsma\n * @author Rossen Stoyanchev\n * @author Sam Brannen\n */\nclass AntPathMatcherTests {\n\n\tprivate final AntPathMatcher pathMatcher = new AntPathMatcher();\n\tprivate final AntPathMatcher dotSeparatedPathMatcher = new AntPathMatcher(\".\");\n\n\n\t@Test\n\tvoid match() {\n\t\t// test exact matching\n\t\tassertThat(pathMatcher.match(\"test\", \"test\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"/test\", \"/test\")).isTrue();\n\t\t// SPR-14141\n\t\tassertThat(pathMatcher.match(\"https://example.org\", \"https://example.org\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"/test.jpg\", \"test.jpg\")).isFalse();\n\t\tassertThat(pathMatcher.match(\"test\", \"/test\")).isFalse();\n\t\tassertThat(pathMatcher.match(\"/test\", \"test\")).isFalse();\n\n\t\t// test matching with ?'s\n\t\tassertThat(pathMatcher.match(\"t?st\", \"test\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"??st\", \"test\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"tes?\", \"test\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"te??\", \"test\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"?es?\", \"test\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"tes?\", \"tes\")).isFalse();\n\t\tassertThat(pathMatcher.match(\"tes?\", \"testt\")).isFalse();\n\t\tassertThat(pathMatcher.match(\"tes?\", \"tsst\")).isFalse();\n\n\t\t// test matching with *'s\n\t\tassertThat(pathMatcher.match(\"*\", \"test\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"test*\", \"test\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"test*\", \"testTest\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"test/*\", \"test/Test\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"test/*\", \"test/t\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"test/*\", \"test/\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"*test*\", \"AnothertestTest\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"*test\", \"Anothertest\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"*.*\", \"test.\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"*.*\", \"test.test\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"*.*\", \"test.test.test\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"test*aaa\", \"testblaaaa\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"test*\", \"tst\")).isFalse();\n\t\tassertThat(pathMatcher.match(\"test*\", \"tsttest\")).isFalse();\n\t\tassertThat(pathMatcher.match(\"test*\", \"test/\")).isFalse();\n\t\tassertThat(pathMatcher.match(\"test*\", \"test/t\")).isFalse();\n\t\tassertThat(pathMatcher.match(\"test/*\", \"test\")).isFalse();\n\t\tassertThat(pathMatcher.match(\"*test*\", \"tsttst\")).isFalse();\n\t\tassertThat(pathMatcher.match(\"*test\", \"tsttst\")).isFalse();\n\t\tassertThat(pathMatcher.match(\"*.*\", \"tsttst\")).isFalse();\n\t\tassertThat(pathMatcher.match(\"test*aaa\", \"test\")).isFalse();\n\t\tassertThat(pathMatcher.match(\"test*aaa\", \"testblaaab\")).isFalse();\n\n\t\t// test matching with ?'s and /'s\n\t\tassertThat(pathMatcher.match(\"/?\", \"/a\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"/?/a\", \"/a/a\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"/a/?\", \"/a/b\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"/??/a\", \"/aa/a\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"/a/??\", \"/a/bb\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"/?\", \"/a\")).isTrue();\n\n\t\t// test matching with **'s\n\t\tassertThat(pathMatcher.match(\"/**\", \"/testing/testing\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"/*/**\", \"/testing/testing\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"/**/*\", \"/testing/testing\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"/bla/**/bla\", \"/bla/testing/testing/bla\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"/bla/**/bla\", \"/bla/testing/testing/bla/bla\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"/**/test\", \"/bla/bla/test\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"/bla/**/**/bla\", \"/bla/bla/bla/bla/bla/bla\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"/bla*bla/test\", \"/blaXXXbla/test\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"/*bla/test\", \"/XXXbla/test\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"/bla*bla/test\", \"/blaXXXbl/test\")).isFalse();\n\t\tassertThat(pathMatcher.match(\"/*bla/test\", \"XXXblab/test\")).isFalse();\n\t\tassertThat(pathMatcher.match(\"/*bla/test\", \"XXXbl/test\")).isFalse();\n\n\t\tassertThat(pathMatcher.match(\"/????\", \"/bala/bla\")).isFalse();\n\t\tassertThat(pathMatcher.match(\"/**/*bla\", \"/bla/bla/bla/bbb\")).isFalse();\n\n\t\tassertThat(pathMatcher.match(\"/*bla*/**/bla/**\", \"/XXXblaXXXX/testing/testing/bla/testing/testing/\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"/*bla*/**/bla/*\", \"/XXXblaXXXX/testing/testing/bla/testing\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"/*bla*/**/bla/**\", \"/XXXblaXXXX/testing/testing/bla/testing/testing\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"/*bla*/**/bla/**\", \"/XXXblaXXXX/testing/testing/bla/testing/testing.jpg\")).isTrue();\n\n\t\tassertThat(pathMatcher.match(\"*bla*/**/bla/**\", \"XXXblaXXXX/testing/testing/bla/testing/testing/\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"*bla*/**/bla/*\", \"XXXblaXXXX/testing/testing/bla/testing\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"*bla*/**/bla/**\", \"XXXblaXXXX/testing/testing/bla/testing/testing\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"*bla*/**/bla/*\", \"XXXblaXXXX/testing/testing/bla/testing/testing\")).isFalse();\n\n\t\tassertThat(pathMatcher.match(\"/x/x/**/bla\", \"/x/x/x/\")).isFalse();\n\n\t\tassertThat(pathMatcher.match(\"/foo/bar/**\", \"/foo/bar\")).isTrue();\n\n\t\tassertThat(pathMatcher.match(\"\", \"\")).isTrue();\n\n\t\tassertThat(pathMatcher.match(\"/{bla}.*\", \"/testing.html\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"/{bla}\", \"//x\\ny\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"/{var:.*}\", \"/x\\ny\")).isTrue();\n\t}\n\n\t@Test\n\tvoid matchWithNullPath() {\n\t\tassertThat(pathMatcher.match(\"/test\", null)).isFalse();\n\t\tassertThat(pathMatcher.match(\"/\", null)).isFalse();\n\t\tassertThat(pathMatcher.match(null, null)).isFalse();\n\t}\n\n\t// SPR-14247\n\t@Test\n\tvoid matchWithTrimTokensEnabled() {\n\t\tpathMatcher.setTrimTokens(true);\n\n\t\tassertThat(pathMatcher.match(\"/foo/bar\", \"/foo /bar\")).isTrue();\n\t}\n\n\t@Test\n\tvoid matchStart() {\n\t\t// test exact matching\n\t\tassertThat(pathMatcher.matchStart(\"test\", \"test\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"/test\", \"/test\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"/test.jpg\", \"test.jpg\")).isFalse();\n\t\tassertThat(pathMatcher.matchStart(\"test\", \"/test\")).isFalse();\n\t\tassertThat(pathMatcher.matchStart(\"/test\", \"test\")).isFalse();\n\n\t\t// test matching with ?'s\n\t\tassertThat(pathMatcher.matchStart(\"t?st\", \"test\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"??st\", \"test\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"tes?\", \"test\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"te??\", \"test\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"?es?\", \"test\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"tes?\", \"tes\")).isFalse();\n\t\tassertThat(pathMatcher.matchStart(\"tes?\", \"testt\")).isFalse();\n\t\tassertThat(pathMatcher.matchStart(\"tes?\", \"tsst\")).isFalse();\n\n\t\t// test matching with *'s\n\t\tassertThat(pathMatcher.matchStart(\"*\", \"test\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"test*\", \"test\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"test*\", \"testTest\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"test/*\", \"test/Test\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"test/*\", \"test/t\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"test/*\", \"test/\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"*test*\", \"AnothertestTest\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"*test\", \"Anothertest\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"*.*\", \"test.\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"*.*\", \"test.test\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"*.*\", \"test.test.test\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"test*aaa\", \"testblaaaa\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"test*\", \"tst\")).isFalse();\n\t\tassertThat(pathMatcher.matchStart(\"test*\", \"test/\")).isFalse();\n\t\tassertThat(pathMatcher.matchStart(\"test*\", \"tsttest\")).isFalse();\n\t\tassertThat(pathMatcher.matchStart(\"test*\", \"test/\")).isFalse();\n\t\tassertThat(pathMatcher.matchStart(\"test*\", \"test/t\")).isFalse();\n\t\tassertThat(pathMatcher.matchStart(\"test/*\", \"test\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"test/t*.txt\", \"test\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"*test*\", \"tsttst\")).isFalse();\n\t\tassertThat(pathMatcher.matchStart(\"*test\", \"tsttst\")).isFalse();\n\t\tassertThat(pathMatcher.matchStart(\"*.*\", \"tsttst\")).isFalse();\n\t\tassertThat(pathMatcher.matchStart(\"test*aaa\", \"test\")).isFalse();\n\t\tassertThat(pathMatcher.matchStart(\"test*aaa\", \"testblaaab\")).isFalse();\n\n\t\t// test matching with ?'s and /'s\n\t\tassertThat(pathMatcher.matchStart(\"/?\", \"/a\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"/?/a\", \"/a/a\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"/a/?\", \"/a/b\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"/??/a\", \"/aa/a\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"/a/??\", \"/a/bb\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"/?\", \"/a\")).isTrue();\n\n\t\t// test matching with **'s\n\t\tassertThat(pathMatcher.matchStart(\"/**\", \"/testing/testing\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"/*/**\", \"/testing/testing\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"/**/*\", \"/testing/testing\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"test*/**\", \"test/\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"test*/**\", \"test/t\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"/bla/**/bla\", \"/bla/testing/testing/bla\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"/bla/**/bla\", \"/bla/testing/testing/bla/bla\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"/**/test\", \"/bla/bla/test\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"/bla/**/**/bla\", \"/bla/bla/bla/bla/bla/bla\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"/bla*bla/test\", \"/blaXXXbla/test\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"/*bla/test\", \"/XXXbla/test\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"/bla*bla/test\", \"/blaXXXbl/test\")).isFalse();\n\t\tassertThat(pathMatcher.matchStart(\"/*bla/test\", \"XXXblab/test\")).isFalse();\n\t\tassertThat(pathMatcher.matchStart(\"/*bla/test\", \"XXXbl/test\")).isFalse();\n\n\t\tassertThat(pathMatcher.matchStart(\"/????\", \"/bala/bla\")).isFalse();\n\t\tassertThat(pathMatcher.matchStart(\"/**/*bla\", \"/bla/bla/bla/bbb\")).isTrue();\n\n\t\tassertThat(pathMatcher.matchStart(\"/*bla*/**/bla/**\", \"/XXXblaXXXX/testing/testing/bla/testing/testing/\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"/*bla*/**/bla/*\", \"/XXXblaXXXX/testing/testing/bla/testing\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"/*bla*/**/bla/**\", \"/XXXblaXXXX/testing/testing/bla/testing/testing\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"/*bla*/**/bla/**\", \"/XXXblaXXXX/testing/testing/bla/testing/testing.jpg\")).isTrue();\n\n\t\tassertThat(pathMatcher.matchStart(\"*bla*/**/bla/**\", \"XXXblaXXXX/testing/testing/bla/testing/testing/\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"*bla*/**/bla/*\", \"XXXblaXXXX/testing/testing/bla/testing\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"*bla*/**/bla/**\", \"XXXblaXXXX/testing/testing/bla/testing/testing\")).isTrue();\n\t\tassertThat(pathMatcher.matchStart(\"*bla*/**/bla/*\", \"XXXblaXXXX/testing/testing/bla/testing/testing\")).isTrue();\n\n\t\tassertThat(pathMatcher.matchStart(\"/x/x/**/bla\", \"/x/x/x/\")).isTrue();\n\n\t\tassertThat(pathMatcher.matchStart(\"\", \"\")).isTrue();\n\t}\n\n\t@Test\n\tvoid uniqueDeliminator() {\n\t\tpathMatcher.setPathSeparator(\".\");\n\n\t\t// test exact matching\n\t\tassertThat(pathMatcher.match(\"test\", \"test\")).isTrue();\n\t\tassertThat(pathMatcher.match(\".test\", \".test\")).isTrue();\n\t\tassertThat(pathMatcher.match(\".test/jpg\", \"test/jpg\")).isFalse();\n\t\tassertThat(pathMatcher.match(\"test\", \".test\")).isFalse();\n\t\tassertThat(pathMatcher.match(\".test\", \"test\")).isFalse();\n\n\t\t// test matching with ?'s\n\t\tassertThat(pathMatcher.match(\"t?st\", \"test\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"??st\", \"test\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"tes?\", \"test\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"te??\", \"test\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"?es?\", \"test\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"tes?\", \"tes\")).isFalse();\n\t\tassertThat(pathMatcher.match(\"tes?\", \"testt\")).isFalse();\n\t\tassertThat(pathMatcher.match(\"tes?\", \"tsst\")).isFalse();\n\n\t\t// test matching with *'s\n\t\tassertThat(pathMatcher.match(\"*\", \"test\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"test*\", \"test\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"test*\", \"testTest\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"*test*\", \"AnothertestTest\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"*test\", \"Anothertest\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"*/*\", \"test/\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"*/*\", \"test/test\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"*/*\", \"test/test/test\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"test*aaa\", \"testblaaaa\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"test*\", \"tst\")).isFalse();\n\t\tassertThat(pathMatcher.match(\"test*\", \"tsttest\")).isFalse();\n\t\tassertThat(pathMatcher.match(\"*test*\", \"tsttst\")).isFalse();\n\t\tassertThat(pathMatcher.match(\"*test\", \"tsttst\")).isFalse();\n\t\tassertThat(pathMatcher.match(\"*/*\", \"tsttst\")).isFalse();\n\t\tassertThat(pathMatcher.match(\"test*aaa\", \"test\")).isFalse();\n\t\tassertThat(pathMatcher.match(\"test*aaa\", \"testblaaab\")).isFalse();\n\n\t\t// test matching with ?'s and .'s\n\t\tassertThat(pathMatcher.match(\".?\", \".a\")).isTrue();\n\t\tassertThat(pathMatcher.match(\".?.a\", \".a.a\")).isTrue();\n\t\tassertThat(pathMatcher.match(\".a.?\", \".a.b\")).isTrue();\n\t\tassertThat(pathMatcher.match(\".??.a\", \".aa.a\")).isTrue();\n\t\tassertThat(pathMatcher.match(\".a.??\", \".a.bb\")).isTrue();\n\t\tassertThat(pathMatcher.match(\".?\", \".a\")).isTrue();\n\n\t\t// test matching with **'s\n\t\tassertThat(pathMatcher.match(\".**\", \".testing.testing\")).isTrue();\n\t\tassertThat(pathMatcher.match(\".*.**\", \".testing.testing\")).isTrue();\n\t\tassertThat(pathMatcher.match(\".**.*\", \".testing.testing\")).isTrue();\n\t\tassertThat(pathMatcher.match(\".bla.**.bla\", \".bla.testing.testing.bla\")).isTrue();\n\t\tassertThat(pathMatcher.match(\".bla.**.bla\", \".bla.testing.testing.bla.bla\")).isTrue();\n\t\tassertThat(pathMatcher.match(\".**.test\", \".bla.bla.test\")).isTrue();\n\t\tassertThat(pathMatcher.match(\".bla.**.**.bla\", \".bla.bla.bla.bla.bla.bla\")).isTrue();\n\t\tassertThat(pathMatcher.match(\".bla*bla.test\", \".blaXXXbla.test\")).isTrue();\n\t\tassertThat(pathMatcher.match(\".*bla.test\", \".XXXbla.test\")).isTrue();\n\t\tassertThat(pathMatcher.match(\".bla*bla.test\", \".blaXXXbl.test\")).isFalse();\n\t\tassertThat(pathMatcher.match(\".*bla.test\", \"XXXblab.test\")).isFalse();\n\t\tassertThat(pathMatcher.match(\".*bla.test\", \"XXXbl.test\")).isFalse();\n\t}\n\n\t@Test\n\tvoid extractPathWithinPattern() {\n\t\tassertThat(pathMatcher.extractPathWithinPattern(\"/docs/commit.html\", \"/docs/commit.html\")).isEmpty();\n\n\t\tassertThat(pathMatcher.extractPathWithinPattern(\"/docs/*\", \"/docs/cvs/commit\")).isEqualTo(\"cvs/commit\");\n\t\tassertThat(pathMatcher.extractPathWithinPattern(\"/docs/cvs/*.html\", \"/docs/cvs/commit.html\")).isEqualTo(\"commit.html\");\n\t\tassertThat(pathMatcher.extractPathWithinPattern(\"/docs/**\", \"/docs/cvs/commit\")).isEqualTo(\"cvs/commit\");\n\t\tassertThat(pathMatcher.extractPathWithinPattern(\"/docs/**/*.html\", \"/docs/cvs/commit.html\")).isEqualTo(\"cvs/commit.html\");\n\t\tassertThat(pathMatcher.extractPathWithinPattern(\"/docs/**/*.html\", \"/docs/commit.html\")).isEqualTo(\"commit.html\");\n\t\tassertThat(pathMatcher.extractPathWithinPattern(\"/*.html\", \"/commit.html\")).isEqualTo(\"commit.html\");\n\t\tassertThat(pathMatcher.extractPathWithinPattern(\"/*.html\", \"/docs/commit.html\")).isEqualTo(\"docs/commit.html\");\n\t\tassertThat(pathMatcher.extractPathWithinPattern(\"*.html\", \"/commit.html\")).isEqualTo(\"/commit.html\");\n\t\tassertThat(pathMatcher.extractPathWithinPattern(\"*.html\", \"/docs/commit.html\")).isEqualTo(\"/docs/commit.html\");\n\t\tassertThat(pathMatcher.extractPathWithinPattern(\"**/*.*\", \"/docs/commit.html\")).isEqualTo(\"/docs/commit.html\");\n\t\tassertThat(pathMatcher.extractPathWithinPattern(\"*\", \"/docs/commit.html\")).isEqualTo(\"/docs/commit.html\");\n\t\t// SPR-10515\n\t\tassertThat(pathMatcher.extractPathWithinPattern(\"**/commit.html\", \"/docs/cvs/other/commit.html\")).isEqualTo(\"/docs/cvs/other/commit.html\");\n\t\tassertThat(pathMatcher.extractPathWithinPattern(\"/docs/**/commit.html\", \"/docs/cvs/other/commit.html\")).isEqualTo(\"cvs/other/commit.html\");\n\t\tassertThat(pathMatcher.extractPathWithinPattern(\"/docs/**/**/**/**\", \"/docs/cvs/other/commit.html\")).isEqualTo(\"cvs/other/commit.html\");\n\n\t\tassertThat(pathMatcher.extractPathWithinPattern(\"/d?cs/*\", \"/docs/cvs/commit\")).isEqualTo(\"docs/cvs/commit\");\n\t\tassertThat(pathMatcher.extractPathWithinPattern(\"/docs/c?s/*.html\", \"/docs/cvs/commit.html\")).isEqualTo(\"cvs/commit.html\");\n\t\tassertThat(pathMatcher.extractPathWithinPattern(\"/d?cs/**\", \"/docs/cvs/commit\")).isEqualTo(\"docs/cvs/commit\");\n\t\tassertThat(pathMatcher.extractPathWithinPattern(\"/d?cs/**/*.html\", \"/docs/cvs/commit.html\")).isEqualTo(\"docs/cvs/commit.html\");\n\t}\n\n\t@Test\n\tvoid extractUriTemplateVariables() {\n\t\tMap<String, String> result = pathMatcher.extractUriTemplateVariables(\"/hotels/{hotel}\", \"/hotels/1\");\n\t\tassertThat(result).isEqualTo(Collections.singletonMap(\"hotel\", \"1\"));\n\n\t\tresult = pathMatcher.extractUriTemplateVariables(\"/h?tels/{hotel}\", \"/hotels/1\");\n\t\tassertThat(result).isEqualTo(Collections.singletonMap(\"hotel\", \"1\"));\n\n\t\tresult = pathMatcher.extractUriTemplateVariables(\"/hotels/{hotel}/bookings/{booking}\", \"/hotels/1/bookings/2\");\n\t\tMap<String, String> expected = new LinkedHashMap<>();\n\t\texpected.put(\"hotel\", \"1\");\n\t\texpected.put(\"booking\", \"2\");\n\t\tassertThat(result).isEqualTo(expected);\n\n\t\tresult = pathMatcher.extractUriTemplateVariables(\"/**/hotels/**/{hotel}\", \"/foo/hotels/bar/1\");\n\t\tassertThat(result).isEqualTo(Collections.singletonMap(\"hotel\", \"1\"));\n\n\t\tresult = pathMatcher.extractUriTemplateVariables(\"/{page}.html\", \"/42.html\");\n\t\tassertThat(result).isEqualTo(Collections.singletonMap(\"page\", \"42\"));\n\n\t\tresult = pathMatcher.extractUriTemplateVariables(\"/{page}.*\", \"/42.html\");\n\t\tassertThat(result).isEqualTo(Collections.singletonMap(\"page\", \"42\"));\n\n\t\tresult = pathMatcher.extractUriTemplateVariables(\"/A-{B}-C\", \"/A-b-C\");\n\t\tassertThat(result).isEqualTo(Collections.singletonMap(\"B\", \"b\"));\n\n\t\tresult = pathMatcher.extractUriTemplateVariables(\"/{name}.{extension}\", \"/test.html\");\n\t\texpected = new LinkedHashMap<>();\n\t\texpected.put(\"name\", \"test\");\n\t\texpected.put(\"extension\", \"html\");\n\t\tassertThat(result).isEqualTo(expected);\n\t}\n\n\t@Test // gh-26264\n\tvoid extractUriTemplateVariablesFromDotSeparatedPath() {\n\t\tMap<String, String> result = dotSeparatedPathMatcher.extractUriTemplateVariables(\"price.stock.{tickerSymbol}\", \"price.stock.aaa\");\n\t\tassertThat(result).isEqualTo(Collections.singletonMap(\"tickerSymbol\", \"aaa\"));\n\n\t\tresult = dotSeparatedPathMatcher.extractUriTemplateVariables(\"price.stock.{ticker/symbol}\", \"price.stock.aaa\");\n\t\tassertThat(result).isEqualTo(Collections.singletonMap(\"ticker/symbol\", \"aaa\"));\n\n\t\tresult = dotSeparatedPathMatcher.extractUriTemplateVariables(\"notification.**.{operation}\", \"notification.foo.update\");\n\t\tassertThat(result).isEqualTo(Collections.singletonMap(\"operation\", \"update\"));\n\n\t\tresult = dotSeparatedPathMatcher.extractUriTemplateVariables(\"news.sports.feed/{type}\", \"news.sports.feed/xml\");\n\t\tassertThat(result).isEqualTo(Collections.singletonMap(\"type\", \"xml\"));\n\n\t\tresult = dotSeparatedPathMatcher.extractUriTemplateVariables(\"news.sports.{operation}/*\", \"news.sports.feed/xml\");\n\t\tassertThat(result).isEqualTo(Collections.singletonMap(\"operation\", \"feed\"));\n\t}\n\n\t@Test\n\tvoid extractUriTemplateVariablesRegex() {\n\t\tMap<String, String> result = pathMatcher\n\t\t\t\t.extractUriTemplateVariables(\"{symbolicName:[\\\\w\\\\.]+}-{version:[\\\\w\\\\.]+}.jar\",\n\t\t\t\t\t\t\"com.example-1.0.0.jar\");\n\t\tassertThat(result.get(\"symbolicName\")).isEqualTo(\"com.example\");\n\t\tassertThat(result.get(\"version\")).isEqualTo(\"1.0.0\");\n\n\t\tresult = pathMatcher.extractUriTemplateVariables(\"{symbolicName:[\\\\w\\\\.]+}-sources-{version:[\\\\w\\\\.]+}.jar\",\n\t\t\t\t\"com.example-sources-1.0.0.jar\");\n\t\tassertThat(result.get(\"symbolicName\")).isEqualTo(\"com.example\");\n\t\tassertThat(result.get(\"version\")).isEqualTo(\"1.0.0\");\n\t}\n\n\t/**\n\t * SPR-7787\n\t */\n\t@Test\n\tvoid extractUriTemplateVarsRegexQualifiers() {\n\t\tMap<String, String> result = pathMatcher.extractUriTemplateVariables(\n\t\t\t\t\"{symbolicName:[\\\\p{L}\\\\.]+}-sources-{version:[\\\\p{N}\\\\.]+}.jar\",\n\t\t\t\t\"com.example-sources-1.0.0.jar\");\n\t\tassertThat(result.get(\"symbolicName\")).isEqualTo(\"com.example\");\n\t\tassertThat(result.get(\"version\")).isEqualTo(\"1.0.0\");\n\n\t\tresult = pathMatcher.extractUriTemplateVariables(\n\t\t\t\t\"{symbolicName:[\\\\w\\\\.]+}-sources-{version:[\\\\d\\\\.]+}-{year:\\\\d{4}}{month:\\\\d{2}}{day:\\\\d{2}}.jar\",\n\t\t\t\t\"com.example-sources-1.0.0-20100220.jar\");\n\t\tassertThat(result.get(\"symbolicName\")).isEqualTo(\"com.example\");\n\t\tassertThat(result.get(\"version\")).isEqualTo(\"1.0.0\");\n\t\tassertThat(result.get(\"year\")).isEqualTo(\"2010\");\n\t\tassertThat(result.get(\"month\")).isEqualTo(\"02\");\n\t\tassertThat(result.get(\"day\")).isEqualTo(\"20\");\n\n\t\tresult = pathMatcher.extractUriTemplateVariables(\n\t\t\t\t\"{symbolicName:[\\\\p{L}\\\\.]+}-sources-{version:[\\\\p{N}\\\\.\\\\{\\\\}]+}.jar\",\n\t\t\t\t\"com.example-sources-1.0.0.{12}.jar\");\n\t\tassertThat(result.get(\"symbolicName\")).isEqualTo(\"com.example\");\n\t\tassertThat(result.get(\"version\")).isEqualTo(\"1.0.0.{12}\");\n\t}\n\n\t/**\n\t * SPR-8455\n\t */\n\t@Test\n\tvoid extractUriTemplateVarsRegexCapturingGroups() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tpathMatcher.extractUriTemplateVariables(\"/web/{id:foo(bar)?}\", \"/web/foobar\"))\n\t\t\t.withMessageContaining(\"The number of capturing groups in the pattern\");\n\t}\n\n\t@Test\n\tvoid combine() {\n\t\tassertThat(pathMatcher.combine(null, null)).isEmpty();\n\t\tassertThat(pathMatcher.combine(\"/hotels\", null)).isEqualTo(\"/hotels\");\n\t\tassertThat(pathMatcher.combine(null, \"/hotels\")).isEqualTo(\"/hotels\");\n\t\tassertThat(pathMatcher.combine(\"/hotels/*\", \"booking\")).isEqualTo(\"/hotels/booking\");\n\t\tassertThat(pathMatcher.combine(\"/hotels/*\", \"/booking\")).isEqualTo(\"/hotels/booking\");\n\t\tassertThat(pathMatcher.combine(\"/hotels/**\", \"booking\")).isEqualTo(\"/hotels/**/booking\");\n\t\tassertThat(pathMatcher.combine(\"/hotels/**\", \"/booking\")).isEqualTo(\"/hotels/**/booking\");\n\t\tassertThat(pathMatcher.combine(\"/hotels\", \"/booking\")).isEqualTo(\"/hotels/booking\");\n\t\tassertThat(pathMatcher.combine(\"/hotels\", \"booking\")).isEqualTo(\"/hotels/booking\");\n\t\tassertThat(pathMatcher.combine(\"/hotels/\", \"booking\")).isEqualTo(\"/hotels/booking\");\n\t\tassertThat(pathMatcher.combine(\"/hotels/*\", \"{hotel}\")).isEqualTo(\"/hotels/{hotel}\");\n\t\tassertThat(pathMatcher.combine(\"/hotels/**\", \"{hotel}\")).isEqualTo(\"/hotels/**/{hotel}\");\n\t\tassertThat(pathMatcher.combine(\"/hotels\", \"{hotel}\")).isEqualTo(\"/hotels/{hotel}\");\n\t\tassertThat(pathMatcher.combine(\"/hotels\", \"{hotel}.*\")).isEqualTo(\"/hotels/{hotel}.*\");\n\t\tassertThat(pathMatcher.combine(\"/hotels/*/booking\", \"{booking}\")).isEqualTo(\"/hotels/*/booking/{booking}\");\n\t\tassertThat(pathMatcher.combine(\"/*.html\", \"/hotel.html\")).isEqualTo(\"/hotel.html\");\n\t\tassertThat(pathMatcher.combine(\"/*.html\", \"/hotel\")).isEqualTo(\"/hotel.html\");\n\t\tassertThat(pathMatcher.combine(\"/*.html\", \"/hotel.*\")).isEqualTo(\"/hotel.html\");\n\t\tassertThat(pathMatcher.combine(\"/**\", \"/*.html\")).isEqualTo(\"/*.html\");\n\t\tassertThat(pathMatcher.combine(\"/*\", \"/*.html\")).isEqualTo(\"/*.html\");\n\t\tassertThat(pathMatcher.combine(\"/*.*\", \"/*.html\")).isEqualTo(\"/*.html\");\n\t\t// SPR-8858\n\t\tassertThat(pathMatcher.combine(\"/{foo}\", \"/bar\")).isEqualTo(\"/{foo}/bar\");\n\t\t// SPR-7970\n\t\tassertThat(pathMatcher.combine(\"/user\", \"/user\")).isEqualTo(\"/user/user\");\n\t\t// SPR-10062\n\t\tassertThat(pathMatcher.combine(\"/{foo:.*[^0-9].*}\", \"/edit/\")).isEqualTo(\"/{foo:.*[^0-9].*}/edit/\");\n\t\t// SPR-10554\n\t\tassertThat(pathMatcher.combine(\"/1.0\", \"/foo/test\")).isEqualTo(\"/1.0/foo/test\");\n\t\t// SPR-12975\n\t\tassertThat(pathMatcher.combine(\"/\", \"/hotel\")).isEqualTo(\"/hotel\");\n\t\t// SPR-12975\n\t\tassertThat(pathMatcher.combine(\"/hotel/\", \"/booking\")).isEqualTo(\"/hotel/booking\");\n\t}\n\n\t@Test\n\tvoid combineWithTwoFileExtensionPatterns() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tpathMatcher.combine(\"/*.html\", \"/*.txt\"));\n\t}\n\n\t@Test\n\tvoid patternComparator() {\n\t\tComparator<String> comparator = pathMatcher.getPatternComparator(\"/hotels/new\");\n\n\t\tassertThat(comparator.compare(null, null)).isEqualTo(0);\n\t\tassertThat(comparator.compare(null, \"/hotels/new\")).isEqualTo(1);\n\t\tassertThat(comparator.compare(\"/hotels/new\", null)).isEqualTo(-1);\n\n\t\tassertThat(comparator.compare(\"/hotels/new\", \"/hotels/new\")).isEqualTo(0);\n\n\t\tassertThat(comparator.compare(\"/hotels/new\", \"/hotels/*\")).isEqualTo(-1);\n\t\tassertThat(comparator.compare(\"/hotels/*\", \"/hotels/new\")).isEqualTo(1);\n\t\tassertThat(comparator.compare(\"/hotels/*\", \"/hotels/*\")).isEqualTo(0);\n\n\t\tassertThat(comparator.compare(\"/hotels/new\", \"/hotels/{hotel}\")).isEqualTo(-1);\n\t\tassertThat(comparator.compare(\"/hotels/{hotel}\", \"/hotels/new\")).isEqualTo(1);\n\t\tassertThat(comparator.compare(\"/hotels/{hotel}\", \"/hotels/{hotel}\")).isEqualTo(0);\n\t\tassertThat(comparator.compare(\"/hotels/{hotel}/booking\", \"/hotels/{hotel}/bookings/{booking}\")).isEqualTo(-1);\n\t\tassertThat(comparator.compare(\"/hotels/{hotel}/bookings/{booking}\", \"/hotels/{hotel}/booking\")).isEqualTo(1);\n\n\t\t// SPR-10550\n\t\tassertThat(comparator.compare(\"/hotels/{hotel}/bookings/{booking}/cutomers/{customer}\", \"/**\")).isEqualTo(-1);\n\t\tassertThat(comparator.compare(\"/**\", \"/hotels/{hotel}/bookings/{booking}/cutomers/{customer}\")).isEqualTo(1);\n\t\tassertThat(comparator.compare(\"/**\", \"/**\")).isEqualTo(0);\n\n\t\tassertThat(comparator.compare(\"/hotels/{hotel}\", \"/hotels/*\")).isEqualTo(-1);\n\t\tassertThat(comparator.compare(\"/hotels/*\", \"/hotels/{hotel}\")).isEqualTo(1);\n\n\t\tassertThat(comparator.compare(\"/hotels/*\", \"/hotels/*/**\")).isEqualTo(-1);\n\t\tassertThat(comparator.compare(\"/hotels/*/**\", \"/hotels/*\")).isEqualTo(1);\n\n\t\tassertThat(comparator.compare(\"/hotels/new\", \"/hotels/new.*\")).isEqualTo(-1);\n\t\tassertThat(comparator.compare(\"/hotels/{hotel}\", \"/hotels/{hotel}.*\")).isEqualTo(2);\n\n\t\t// SPR-6741\n\t\tassertThat(comparator.compare(\"/hotels/{hotel}/bookings/{booking}/cutomers/{customer}\", \"/hotels/**\")).isEqualTo(-1);\n\t\tassertThat(comparator.compare(\"/hotels/**\", \"/hotels/{hotel}/bookings/{booking}/cutomers/{customer}\")).isEqualTo(1);\n\t\tassertThat(comparator.compare(\"/hotels/foo/bar/**\", \"/hotels/{hotel}\")).isEqualTo(1);\n\t\tassertThat(comparator.compare(\"/hotels/{hotel}\", \"/hotels/foo/bar/**\")).isEqualTo(-1);\n\n\t\t// gh-23125\n\t\tassertThat(comparator.compare(\"/hotels/*/bookings/**\", \"/hotels/**\")).isEqualTo(-11);\n\n\t\t// SPR-8683\n\t\tassertThat(comparator.compare(\"/**\", \"/hotels/{hotel}\")).isEqualTo(1);\n\n\t\t// longer is better\n\t\tassertThat(comparator.compare(\"/hotels\", \"/hotels2\")).isEqualTo(1);\n\n\t\t// SPR-13139\n\t\tassertThat(comparator.compare(\"*\", \"*/**\")).isEqualTo(-1);\n\t\tassertThat(comparator.compare(\"*/**\", \"*\")).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid patternComparatorWithDotSeparator() {\n\t\tComparator<String> comparator = dotSeparatedPathMatcher.getPatternComparator(\"price.stock.spring\");\n\n\t\tassertThat(comparator.compare(null, null)).isEqualTo(0);\n\t\tassertThat(comparator.compare(\"price.stock.ticker/symbol\", \"price.stock.ticker/symbol\")).isEqualTo(0);\n\t\tassertThat(comparator.compare(\"price.stock.**\", \"price.stock.ticker\")).isEqualTo(1);\n\t}\n\n\n\t@Test\n\tvoid patternComparatorSort() {\n\t\tComparator<String> comparator = pathMatcher.getPatternComparator(\"/hotels/new\");\n\t\tList<String> paths = new ArrayList<>(3);\n\n\t\tpaths.add(null);\n\t\tpaths.add(\"/hotels/new\");\n\t\tpaths.sort(comparator);\n\t\tassertThat(paths).containsExactly(\"/hotels/new\", null);\n\t\tpaths.clear();\n\n\t\tpaths.add(\"/hotels/new\");\n\t\tpaths.add(null);\n\t\tpaths.sort(comparator);\n\t\tassertThat(paths).containsExactly(\"/hotels/new\", null);\n\t\tpaths.clear();\n\n\t\tpaths.add(\"/hotels/*\");\n\t\tpaths.add(\"/hotels/new\");\n\t\tpaths.sort(comparator);\n\t\tassertThat(paths).containsExactly(\"/hotels/new\", \"/hotels/*\");\n\t\tpaths.clear();\n\n\t\tpaths.add(\"/hotels/new\");\n\t\tpaths.add(\"/hotels/*\");\n\t\tpaths.sort(comparator);\n\t\tassertThat(paths).containsExactly(\"/hotels/new\", \"/hotels/*\");\n\t\tpaths.clear();\n\n\t\tpaths.add(\"/hotels/**\");\n\t\tpaths.add(\"/hotels/*\");\n\t\tpaths.sort(comparator);\n\t\tassertThat(paths).containsExactly(\"/hotels/*\", \"/hotels/**\");\n\t\tpaths.clear();\n\n\t\tpaths.add(\"/hotels/*\");\n\t\tpaths.add(\"/hotels/**\");\n\t\tpaths.sort(comparator);\n\t\tassertThat(paths).containsExactly(\"/hotels/*\", \"/hotels/**\");\n\t\tpaths.clear();\n\n\t\tpaths.add(\"/hotels/{hotel}\");\n\t\tpaths.add(\"/hotels/new\");\n\t\tpaths.sort(comparator);\n\t\tassertThat(paths).containsExactly(\"/hotels/new\", \"/hotels/{hotel}\");\n\t\tpaths.clear();\n\n\t\tpaths.add(\"/hotels/new\");\n\t\tpaths.add(\"/hotels/{hotel}\");\n\t\tpaths.sort(comparator);\n\t\tassertThat(paths).containsExactly(\"/hotels/new\", \"/hotels/{hotel}\");\n\t\tpaths.clear();\n\n\t\tpaths.add(\"/hotels/*\");\n\t\tpaths.add(\"/hotels/{hotel}\");\n\t\tpaths.add(\"/hotels/new\");\n\t\tpaths.sort(comparator);\n\t\tassertThat(paths).containsExactly(\"/hotels/new\", \"/hotels/{hotel}\", \"/hotels/*\");\n\t\tpaths.clear();\n\n\t\tpaths.add(\"/hotels/ne*\");\n\t\tpaths.add(\"/hotels/n*\");\n\t\tCollections.shuffle(paths);\n\t\tpaths.sort(comparator);\n\t\tassertThat(paths).containsExactly(\"/hotels/ne*\", \"/hotels/n*\");\n\t\tpaths.clear();\n\n\t\tcomparator = pathMatcher.getPatternComparator(\"/hotels/new.html\");\n\t\tpaths.add(\"/hotels/new.*\");\n\t\tpaths.add(\"/hotels/{hotel}\");\n\t\tCollections.shuffle(paths);\n\t\tpaths.sort(comparator);\n\t\tassertThat(paths).containsExactly(\"/hotels/new.*\", \"/hotels/{hotel}\");\n\t\tpaths.clear();\n\n\t\tcomparator = pathMatcher.getPatternComparator(\"/web/endUser/action/login.html\");\n\t\tpaths.add(\"/**/login.*\");\n\t\tpaths.add(\"/**/endUser/action/login.*\");\n\t\tpaths.sort(comparator);\n\t\tassertThat(paths).containsExactly(\"/**/endUser/action/login.*\", \"/**/login.*\");\n\t\tpaths.clear();\n\t}\n\n\t@Test  // SPR-8687\n\tvoid trimTokensOff() {\n\t\tpathMatcher.setTrimTokens(false);\n\n\t\tassertThat(pathMatcher.match(\"/group/{groupName}/members\", \"/group/sales/members\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"/group/{groupName}/members\", \"/group/  sales/members\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"/group/{groupName}/members\", \"/Group/  Sales/Members\")).isFalse();\n\t}\n\n\t@Test  // SPR-13286\n\tvoid caseInsensitive() {\n\t\tpathMatcher.setCaseSensitive(false);\n\n\t\tassertThat(pathMatcher.match(\"/group/{groupName}/members\", \"/group/sales/members\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"/group/{groupName}/members\", \"/Group/Sales/Members\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"/Group/{groupName}/Members\", \"/group/Sales/members\")).isTrue();\n\t}\n\n\t@Test\n\tvoid defaultCacheSetting() {\n\t\tmatch();\n\t\tassertThat(pathMatcher.stringMatcherCache).hasSizeGreaterThan(20);\n\n\t\tfor (int i = 0; i < 65536; i++) {\n\t\t\tpathMatcher.match(\"test\" + i, \"test\");\n\t\t}\n\t\t// Cache turned off because it went beyond the threshold\n\t\tassertThat(pathMatcher.stringMatcherCache).isEmpty();\n\t}\n\n\t@Test\n\tvoid cachePatternsSetToTrue() {\n\t\tpathMatcher.setCachePatterns(true);\n\t\tmatch();\n\t\tassertThat(pathMatcher.stringMatcherCache).hasSizeGreaterThan(20);\n\n\t\tfor (int i = 0; i < 65536; i++) {\n\t\t\tpathMatcher.match(\"test\" + i, \"test\" + i);\n\t\t}\n\t\t// Cache keeps being alive due to the explicit cache setting\n\t\tassertThat(pathMatcher.stringMatcherCache).hasSizeGreaterThan(65536);\n\t}\n\n\t@Test\n\tvoid preventCreatingStringMatchersIfPathDoesNotStartsWithPatternPrefix() {\n\t\tpathMatcher.setCachePatterns(true);\n\t\tassertThat(pathMatcher.stringMatcherCache).isEmpty();\n\n\t\tpathMatcher.match(\"test?\", \"test\");\n\t\tassertThat(pathMatcher.stringMatcherCache).hasSize(1);\n\n\t\tpathMatcher.match(\"test?\", \"best\");\n\t\tpathMatcher.match(\"test/*\", \"view/test.jpg\");\n\t\tpathMatcher.match(\"test/**/test.jpg\", \"view/test.jpg\");\n\t\tpathMatcher.match(\"test/{name}.jpg\", \"view/test.jpg\");\n\t\tassertThat(pathMatcher.stringMatcherCache).hasSize(1);\n\t}\n\n\t@Test\n\tvoid creatingStringMatchersIfPatternPrefixCannotDetermineIfPathMatch() {\n\t\tpathMatcher.setCachePatterns(true);\n\t\tassertThat(pathMatcher.stringMatcherCache).isEmpty();\n\n\t\tpathMatcher.match(\"test\", \"testian\");\n\t\tpathMatcher.match(\"test?\", \"testFf\");\n\t\tpathMatcher.match(\"test/*\", \"test/dir/name.jpg\");\n\t\tpathMatcher.match(\"test/{name}.jpg\", \"test/lorem.jpg\");\n\t\tpathMatcher.match(\"bla/**/test.jpg\", \"bla/test.jpg\");\n\t\tpathMatcher.match(\"**/{name}.jpg\", \"test/lorem.jpg\");\n\t\tpathMatcher.match(\"/**/{name}.jpg\", \"/test/lorem.jpg\");\n\t\tpathMatcher.match(\"/*/dir/{name}.jpg\", \"/*/dir/lorem.jpg\");\n\n\t\tassertThat(pathMatcher.stringMatcherCache).hasSize(7);\n\t}\n\n\t@Test\n\tvoid cachePatternsSetToFalse() {\n\t\tpathMatcher.setCachePatterns(false);\n\t\tmatch();\n\t\tassertThat(pathMatcher.stringMatcherCache).isEmpty();\n\t}\n\n\t@Test\n\tvoid extensionMappingWithDotPathSeparator() {\n\t\tpathMatcher.setPathSeparator(\".\");\n\t\tassertThat(pathMatcher.combine(\"/*.html\", \"hotel.*\")).as(\"Extension mapping should be disabled with \\\".\\\" as path separator\").isEqualTo(\"/*.html.hotel.*\");\n\t}\n\n\t@Test // gh-22959\n\tvoid isPattern() {\n\t\tassertThat(pathMatcher.isPattern(\"/test/*\")).isTrue();\n\t\tassertThat(pathMatcher.isPattern(\"/test/**/name\")).isTrue();\n\t\tassertThat(pathMatcher.isPattern(\"/test?\")).isTrue();\n\t\tassertThat(pathMatcher.isPattern(\"/test/{name}\")).isTrue();\n\n\t\tassertThat(pathMatcher.isPattern(\"/test/name\")).isFalse();\n\t\tassertThat(pathMatcher.isPattern(\"/test/foo{bar\")).isFalse();\n\t}\n\n\t@Test // gh-23297\n\tvoid isPatternWithNullPath() {\n\t\tassertThat(pathMatcher.isPattern(null)).isFalse();\n\t}\n\n\t@Test // gh-27506\n\tvoid consistentMatchWithWildcardsAndTrailingSlash() {\n\t\tassertThat(pathMatcher.match(\"/*/foo\", \"/en/foo\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"/*/foo\", \"/en/foo/\")).isFalse();\n\t\tassertThat(pathMatcher.match(\"/**/foo\", \"/en/foo\")).isTrue();\n\t\tassertThat(pathMatcher.match(\"/**/foo\", \"/en/foo/\")).isFalse();\n\t}\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.AntPathMatcherTests",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.AntPathMatcherTests#pathMatcher",
    "tailType": "field"
  },
  {
    "head": "org.springframework.util.AntPathMatcherTests#pathMatcher",
    "headType": "field",
    "relation": "haveType",
    "tail": "AntPathMatcher",
    "tailType": "type"
  }
]