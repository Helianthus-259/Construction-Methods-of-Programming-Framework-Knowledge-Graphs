[
  {
    "head": "org.springframework.core.annotation.Aggregate",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.Aggregate#size()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.Aggregate#getMapping(int,int)",
    "headType": "method",
    "relation": "provide",
    "tail": "@Nullable\r\nAnnotationTypeMapping getMapping(int annotationIndex, int mappingIndex) {\r\n    AnnotationTypeMappings mappings = getMappings(annotationIndex);\r\n    return (mappingIndex < mappings.size() ? mappings.get(mappingIndex) : null);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.Aggregate",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.Aggregate#getMapping(int,int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.Aggregate#getMapping(int,int)",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.Aggregate#getMappings(int)",
    "headType": "method",
    "relation": "provide",
    "tail": "AnnotationTypeMappings getMappings(int annotationIndex) {\r\n    return this.mappings[annotationIndex];\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.Aggregate",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.Aggregate#getMappings(int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.Aggregate#createMergedAnnotationIfPossible(int,int,IntrospectionFailureLogger)",
    "headType": "method",
    "relation": "provide",
    "tail": "@Nullable\r\n<A extends Annotation> MergedAnnotation<A> createMergedAnnotationIfPossible(int annotationIndex, int mappingIndex, IntrospectionFailureLogger logger) {\r\n    return TypeMappedAnnotation.createIfPossible(this.mappings[annotationIndex].get(mappingIndex), this.source, this.annotations.get(annotationIndex), this.aggregateIndex, logger);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.Aggregate",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.Aggregate#createMergedAnnotationIfPossible(int,int,IntrospectionFailureLogger)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.Aggregate#createMergedAnnotationIfPossible(int,int,IntrospectionFailureLogger)",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.AggregatesSpliterator",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.AggregatesSpliterator",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport org.jspecify.annotations.NonNull;\nimport org.jspecify.annotations.Nullable;\n\n/**\n * {@link MergedAnnotations} implementation that searches for and adapts\n * annotations and meta-annotations using {@link AnnotationTypeMappings}.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n * @since 5.2\n */\nfinal class TypeMappedAnnotations implements MergedAnnotations {\n\n\t/**\n\t * Shared instance that can be used when there are no annotations.\n\t */\n\tstatic final MergedAnnotations NONE = new TypeMappedAnnotations(\n\t\t\tnull, new Annotation[0], RepeatableContainers.none(), AnnotationFilter.ALL);\n\n\n\tprivate final @Nullable Object source;\n\n\tprivate final @Nullable AnnotatedElement element;\n\n\tprivate final @Nullable SearchStrategy searchStrategy;\n\n\tprivate final Predicate<Class<?>> searchEnclosingClass;\n\n\tprivate final Annotation @Nullable [] annotations;\n\n\tprivate final RepeatableContainers repeatableContainers;\n\n\tprivate final AnnotationFilter annotationFilter;\n\n\tprivate volatile @Nullable List<Aggregate> aggregates;\n\n\n\tprivate TypeMappedAnnotations(AnnotatedElement element, SearchStrategy searchStrategy,\n\t\t\tPredicate<Class<?>> searchEnclosingClass, RepeatableContainers repeatableContainers,\n\t\t\tAnnotationFilter annotationFilter) {\n\n\t\tthis.source = element;\n\t\tthis.element = element;\n\t\tthis.searchStrategy = searchStrategy;\n\t\tthis.searchEnclosingClass = searchEnclosingClass;\n\t\tthis.annotations = null;\n\t\tthis.repeatableContainers = repeatableContainers;\n\t\tthis.annotationFilter = annotationFilter;\n\t}\n\n\tprivate TypeMappedAnnotations(@Nullable Object source, Annotation[] annotations,\n\t\t\tRepeatableContainers repeatableContainers, AnnotationFilter annotationFilter) {\n\n\t\tthis.source = source;\n\t\tthis.element = null;\n\t\tthis.searchStrategy = null;\n\t\tthis.searchEnclosingClass = Search.never;\n\t\tthis.annotations = annotations;\n\t\tthis.repeatableContainers = repeatableContainers;\n\t\tthis.annotationFilter = annotationFilter;\n\t}\n\n\n\t@Override\n\tpublic <A extends Annotation> boolean isPresent(Class<A> annotationType) {\n\t\tif (this.annotationFilter.matches(annotationType)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn Boolean.TRUE.equals(scan(annotationType,\n\t\t\t\tIsPresent.get(this.repeatableContainers, this.annotationFilter, false)));\n\t}\n\n\t@Override\n\tpublic boolean isPresent(String annotationType) {\n\t\tif (this.annotationFilter.matches(annotationType)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn Boolean.TRUE.equals(scan(annotationType,\n\t\t\t\tIsPresent.get(this.repeatableContainers, this.annotationFilter, false)));\n\t}\n\n\t@Override\n\tpublic <A extends Annotation> boolean isDirectlyPresent(Class<A> annotationType) {\n\t\tif (this.annotationFilter.matches(annotationType)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn Boolean.TRUE.equals(scan(annotationType,\n\t\t\t\tIsPresent.get(this.repeatableContainers, this.annotationFilter, true)));\n\t}\n\n\t@Override\n\tpublic boolean isDirectlyPresent(String annotationType) {\n\t\tif (this.annotationFilter.matches(annotationType)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn Boolean.TRUE.equals(scan(annotationType,\n\t\t\t\tIsPresent.get(this.repeatableContainers, this.annotationFilter, true)));\n\t}\n\n\t@Override\n\tpublic <A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType) {\n\t\treturn get(annotationType, null, null);\n\t}\n\n\t@Override\n\tpublic <A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType,\n\t\t\t@Nullable Predicate<? super MergedAnnotation<A>> predicate) {\n\n\t\treturn get(annotationType, predicate, null);\n\t}\n\n\t@Override\n\tpublic <A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType,\n\t\t\t@Nullable Predicate<? super MergedAnnotation<A>> predicate,\n\t\t\t@Nullable MergedAnnotationSelector<A> selector) {\n\n\t\tif (this.annotationFilter.matches(annotationType)) {\n\t\t\treturn MergedAnnotation.missing();\n\t\t}\n\t\tMergedAnnotation<A> result = scan(annotationType,\n\t\t\t\tnew MergedAnnotationFinder<>(annotationType, predicate, selector));\n\t\treturn (result != null ? result : MergedAnnotation.missing());\n\t}\n\n\t@Override\n\tpublic <A extends Annotation> MergedAnnotation<A> get(String annotationType) {\n\t\treturn get(annotationType, null, null);\n\t}\n\n\t@Override\n\tpublic <A extends Annotation> MergedAnnotation<A> get(String annotationType,\n\t\t\t@Nullable Predicate<? super MergedAnnotation<A>> predicate) {\n\n\t\treturn get(annotationType, predicate, null);\n\t}\n\n\t@Override\n\tpublic <A extends Annotation> MergedAnnotation<A> get(String annotationType,\n\t\t\t@Nullable Predicate<? super MergedAnnotation<A>> predicate,\n\t\t\t@Nullable MergedAnnotationSelector<A> selector) {\n\n\t\tif (this.annotationFilter.matches(annotationType)) {\n\t\t\treturn MergedAnnotation.missing();\n\t\t}\n\t\tMergedAnnotation<A> result = scan(annotationType,\n\t\t\t\tnew MergedAnnotationFinder<>(annotationType, predicate, selector));\n\t\treturn (result != null ? result : MergedAnnotation.missing());\n\t}\n\n\t@Override\n\tpublic <A extends Annotation> Stream<MergedAnnotation<A>> stream(Class<A> annotationType) {\n\t\tif (this.annotationFilter == AnnotationFilter.ALL) {\n\t\t\treturn Stream.empty();\n\t\t}\n\t\treturn StreamSupport.stream(spliterator(annotationType), false);\n\t}\n\n\t@Override\n\tpublic <A extends Annotation> Stream<MergedAnnotation<A>> stream(String annotationType) {\n\t\tif (this.annotationFilter == AnnotationFilter.ALL) {\n\t\t\treturn Stream.empty();\n\t\t}\n\t\treturn StreamSupport.stream(spliterator(annotationType), false);\n\t}\n\n\t@Override\n\tpublic Stream<MergedAnnotation<Annotation>> stream() {\n\t\tif (this.annotationFilter == AnnotationFilter.ALL) {\n\t\t\treturn Stream.empty();\n\t\t}\n\t\treturn StreamSupport.stream(spliterator(), false);\n\t}\n\n\t@Override\n\tpublic Iterator<MergedAnnotation<Annotation>> iterator() {\n\t\tif (this.annotationFilter == AnnotationFilter.ALL) {\n\t\t\treturn Collections.emptyIterator();\n\t\t}\n\t\treturn Spliterators.iterator(spliterator());\n\t}\n\n\t@Override\n\tpublic Spliterator<MergedAnnotation<Annotation>> spliterator() {\n\t\tif (this.annotationFilter == AnnotationFilter.ALL) {\n\t\t\treturn Spliterators.emptySpliterator();\n\t\t}\n\t\treturn spliterator(null);\n\t}\n\n\tprivate <A extends Annotation> Spliterator<MergedAnnotation<A>> spliterator(@Nullable Object annotationType) {\n\t\treturn new AggregatesSpliterator<>(annotationType, getAggregates());\n\t}\n\n\tprivate List<Aggregate> getAggregates() {\n\t\tList<Aggregate> aggregates = this.aggregates;\n\t\tif (aggregates == null) {\n\t\t\taggregates = scan(this, new AggregatesCollector());\n\t\t\tif (aggregates == null || aggregates.isEmpty()) {\n\t\t\t\taggregates = Collections.emptyList();\n\t\t\t}\n\t\t\tthis.aggregates = aggregates;\n\t\t}\n\t\treturn aggregates;\n\t}\n\n\tprivate <C, R> @Nullable R scan(C criteria, AnnotationsProcessor<C, R> processor) {\n\t\tif (this.annotations != null) {\n\t\t\tR result = processor.doWithAnnotations(criteria, 0, this.source, this.annotations);\n\t\t\treturn processor.finish(result);\n\t\t}\n\t\tif (this.element != null && this.searchStrategy != null) {\n\t\t\treturn AnnotationsScanner.scan(criteria, this.element, this.searchStrategy,\n\t\t\t\t\tthis.searchEnclosingClass, processor);\n\t\t}\n\t\treturn null;\n\t}\n\n\n\tstatic MergedAnnotations from(AnnotatedElement element, SearchStrategy searchStrategy,\n\t\t\tPredicate<Class<?>> searchEnclosingClass, RepeatableContainers repeatableContainers,\n\t\t\tAnnotationFilter annotationFilter) {\n\n\t\tif (AnnotationsScanner.isKnownEmpty(element, searchStrategy, searchEnclosingClass)) {\n\t\t\treturn NONE;\n\t\t}\n\t\treturn new TypeMappedAnnotations(element, searchStrategy, searchEnclosingClass, repeatableContainers, annotationFilter);\n\t}\n\n\tstatic MergedAnnotations from(@Nullable Object source, Annotation[] annotations,\n\t\t\tRepeatableContainers repeatableContainers, AnnotationFilter annotationFilter) {\n\n\t\tif (annotations.length == 0) {\n\t\t\treturn NONE;\n\t\t}\n\t\treturn new TypeMappedAnnotations(source, annotations, repeatableContainers, annotationFilter);\n\t}\n\n\tprivate static boolean isMappingForType(AnnotationTypeMapping mapping,\n\t\t\tAnnotationFilter annotationFilter, @Nullable Object requiredType) {\n\n\t\tClass<? extends Annotation> actualType = mapping.getAnnotationType();\n\t\treturn (!annotationFilter.matches(actualType) &&\n\t\t\t\t(requiredType == null || actualType == requiredType || actualType.getName().equals(requiredType)));\n\t}\n\n\n\t/**\n\t * {@link AnnotationsProcessor} used to detect if an annotation is directly\n\t * present or meta-present.\n\t */\n\tprivate static final class IsPresent implements AnnotationsProcessor<Object, Boolean> {\n\n\t\t/**\n\t\t * Shared instances that save us needing to create a new processor for\n\t\t * the common combinations.\n\t\t */\n\t\tprivate static final IsPresent[] SHARED;\n\t\tstatic {\n\t\t\tSHARED = new IsPresent[4];\n\t\t\tSHARED[0] = new IsPresent(RepeatableContainers.none(), AnnotationFilter.PLAIN, true);\n\t\t\tSHARED[1] = new IsPresent(RepeatableContainers.none(), AnnotationFilter.PLAIN, false);\n\t\t\tSHARED[2] = new IsPresent(RepeatableContainers.standardRepeatables(), AnnotationFilter.PLAIN, true);\n\t\t\tSHARED[3] = new IsPresent(RepeatableContainers.standardRepeatables(), AnnotationFilter.PLAIN, false);\n\t\t}\n\n\t\tprivate final RepeatableContainers repeatableContainers;\n\n\t\tprivate final AnnotationFilter annotationFilter;\n\n\t\tprivate final boolean directOnly;\n\n\t\tprivate IsPresent(RepeatableContainers repeatableContainers,\n\t\t\t\tAnnotationFilter annotationFilter, boolean directOnly) {\n\n\t\t\tthis.repeatableContainers = repeatableContainers;\n\t\t\tthis.annotationFilter = annotationFilter;\n\t\t\tthis.directOnly = directOnly;\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable Boolean doWithAnnotations(Object requiredType, int aggregateIndex,\n\t\t\t\t@Nullable Object source, @Nullable Annotation[] annotations) {\n\n\t\t\tfor (Annotation annotation : annotations) {\n\t\t\t\tif (annotation != null) {\n\t\t\t\t\tClass<? extends Annotation> type = annotation.annotationType();\n\t\t\t\t\tif (type != null && !this.annotationFilter.matches(type)) {\n\t\t\t\t\t\tif (type == requiredType || type.getName().equals(requiredType)) {\n\t\t\t\t\t\t\treturn Boolean.TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tAnnotation[] repeatedAnnotations =\n\t\t\t\t\t\t\t\tthis.repeatableContainers.findRepeatedAnnotations(annotation);\n\t\t\t\t\t\tif (repeatedAnnotations != null) {\n\t\t\t\t\t\t\tBoolean result = doWithAnnotations(\n\t\t\t\t\t\t\t\t\trequiredType, aggregateIndex, source, repeatedAnnotations);\n\t\t\t\t\t\t\tif (result != null) {\n\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!this.directOnly) {\n\t\t\t\t\t\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(type);\n\t\t\t\t\t\t\tfor (int i = 0; i < mappings.size(); i++) {\n\t\t\t\t\t\t\t\tAnnotationTypeMapping mapping = mappings.get(i);\n\t\t\t\t\t\t\t\tif (isMappingForType(mapping, this.annotationFilter, requiredType)) {\n\t\t\t\t\t\t\t\t\treturn Boolean.TRUE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tstatic IsPresent get(RepeatableContainers repeatableContainers,\n\t\t\t\tAnnotationFilter annotationFilter, boolean directOnly) {\n\n\t\t\t// Use a single shared instance for common combinations\n\t\t\tif (annotationFilter == AnnotationFilter.PLAIN) {\n\t\t\t\tif (repeatableContainers == RepeatableContainers.none()) {\n\t\t\t\t\treturn SHARED[directOnly ? 0 : 1];\n\t\t\t\t}\n\t\t\t\tif (repeatableContainers == RepeatableContainers.standardRepeatables()) {\n\t\t\t\t\treturn SHARED[directOnly ? 2 : 3];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new IsPresent(repeatableContainers, annotationFilter, directOnly);\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link AnnotationsProcessor} that finds a single {@link MergedAnnotation}.\n\t */\n\tprivate class MergedAnnotationFinder<A extends Annotation>\n\t\t\timplements AnnotationsProcessor<Object, MergedAnnotation<A>> {\n\n\t\tprivate final Object requiredType;\n\n\t\tprivate final @Nullable Predicate<? super MergedAnnotation<A>> predicate;\n\n\t\tprivate final MergedAnnotationSelector<A> selector;\n\n\t\tprivate @Nullable MergedAnnotation<A> result;\n\n\t\tMergedAnnotationFinder(Object requiredType, @Nullable Predicate<? super MergedAnnotation<A>> predicate,\n\t\t\t\t@Nullable MergedAnnotationSelector<A> selector) {\n\n\t\t\tthis.requiredType = requiredType;\n\t\t\tthis.predicate = predicate;\n\t\t\tthis.selector = (selector != null ? selector : MergedAnnotationSelectors.nearest());\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable MergedAnnotation<A> doWithAggregate(Object context, int aggregateIndex) {\n\t\t\treturn this.result;\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable MergedAnnotation<A> doWithAnnotations(Object type, int aggregateIndex,\n\t\t\t\t@Nullable Object source, @Nullable Annotation[] annotations) {\n\n\t\t\tfor (Annotation annotation : annotations) {\n\t\t\t\tif (annotation != null && !annotationFilter.matches(annotation)) {\n\t\t\t\t\tMergedAnnotation<A> result = process(type, aggregateIndex, source, annotation);\n\t\t\t\t\tif (result != null) {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tprivate @Nullable MergedAnnotation<A> process(\n\t\t\t\tObject type, int aggregateIndex, @Nullable Object source, Annotation annotation) {\n\n\t\t\tAnnotation[] repeatedAnnotations = repeatableContainers.findRepeatedAnnotations(annotation);\n\t\t\tif (repeatedAnnotations != null) {\n\t\t\t\tMergedAnnotation<A> result = doWithAnnotations(type, aggregateIndex, source, repeatedAnnotations);\n\t\t\t\tif (result != null) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(\n\t\t\t\t\tannotation.annotationType(), repeatableContainers, annotationFilter);\n\t\t\tfor (int i = 0; i < mappings.size(); i++) {\n\t\t\t\tAnnotationTypeMapping mapping = mappings.get(i);\n\t\t\t\tif (isMappingForType(mapping, annotationFilter, this.requiredType)) {\n\t\t\t\t\tMergedAnnotation<A> candidate = TypeMappedAnnotation.createIfPossible(\n\t\t\t\t\t\t\tmapping, source, annotation, aggregateIndex, IntrospectionFailureLogger.INFO);\n\t\t\t\t\tif (candidate != null && (this.predicate == null || this.predicate.test(candidate))) {\n\t\t\t\t\t\tif (this.selector.isBestCandidate(candidate)) {\n\t\t\t\t\t\t\treturn candidate;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tupdateLastResult(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tprivate void updateLastResult(MergedAnnotation<A> candidate) {\n\t\t\tMergedAnnotation<A> lastResult = this.result;\n\t\t\tthis.result = (lastResult != null ? this.selector.select(lastResult, candidate) : candidate);\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable MergedAnnotation<A> finish(@Nullable MergedAnnotation<A> result) {\n\t\t\treturn (result != null ? result : this.result);\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link AnnotationsProcessor} that collects {@link Aggregate} instances.\n\t */\n\tprivate class AggregatesCollector implements AnnotationsProcessor<Object, List<Aggregate>> {\n\n\t\tprivate final List<Aggregate> aggregates = new ArrayList<>();\n\n\t\t@Override\n\t\tpublic @Nullable List<Aggregate> doWithAnnotations(Object criteria, int aggregateIndex,\n\t\t\t\t@Nullable Object source, @Nullable Annotation[] annotations) {\n\n\t\t\tthis.aggregates.add(createAggregate(aggregateIndex, source, annotations));\n\t\t\treturn null;\n\t\t}\n\n\t\tprivate Aggregate createAggregate(int aggregateIndex, @Nullable Object source, @Nullable Annotation[] annotations) {\n\t\t\tList<Annotation> aggregateAnnotations = getAggregateAnnotations(annotations);\n\t\t\treturn new Aggregate(aggregateIndex, source, aggregateAnnotations);\n\t\t}\n\n\t\tprivate List<Annotation> getAggregateAnnotations(@Nullable Annotation[] annotations) {\n\t\t\tList<Annotation> result = new ArrayList<>(annotations.length);\n\t\t\taddAggregateAnnotations(result, annotations);\n\t\t\treturn result;\n\t\t}\n\n\t\tprivate void addAggregateAnnotations(List<Annotation> aggregateAnnotations, @Nullable Annotation[] annotations) {\n\t\t\tfor (Annotation annotation : annotations) {\n\t\t\t\tif (annotation != null && !annotationFilter.matches(annotation)) {\n\t\t\t\t\tAnnotation[] repeatedAnnotations = repeatableContainers.findRepeatedAnnotations(annotation);\n\t\t\t\t\tif (repeatedAnnotations != null) {\n\t\t\t\t\t\taddAggregateAnnotations(aggregateAnnotations, repeatedAnnotations);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\taggregateAnnotations.add(annotation);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic @NonNull List<Aggregate> finish(@Nullable List<Aggregate> processResult) {\n\t\t\treturn this.aggregates;\n\t\t}\n\t}\n\n\n\tprivate static class Aggregate {\n\n\t\tprivate final int aggregateIndex;\n\n\t\tprivate final @Nullable Object source;\n\n\t\tprivate final List<Annotation> annotations;\n\n\t\tprivate final AnnotationTypeMappings[] mappings;\n\n\t\tAggregate(int aggregateIndex, @Nullable Object source, List<Annotation> annotations) {\n\t\t\tthis.aggregateIndex = aggregateIndex;\n\t\t\tthis.source = source;\n\t\t\tthis.annotations = annotations;\n\t\t\tthis.mappings = new AnnotationTypeMappings[annotations.size()];\n\t\t\tfor (int i = 0; i < annotations.size(); i++) {\n\t\t\t\tthis.mappings[i] = AnnotationTypeMappings.forAnnotationType(annotations.get(i).annotationType());\n\t\t\t}\n\t\t}\n\n\t\tint size() {\n\t\t\treturn this.annotations.size();\n\t\t}\n\n\t\t@Nullable AnnotationTypeMapping getMapping(int annotationIndex, int mappingIndex) {\n\t\t\tAnnotationTypeMappings mappings = getMappings(annotationIndex);\n\t\t\treturn (mappingIndex < mappings.size() ? mappings.get(mappingIndex) : null);\n\t\t}\n\n\t\tAnnotationTypeMappings getMappings(int annotationIndex) {\n\t\t\treturn this.mappings[annotationIndex];\n\t\t}\n\n\t\t<A extends Annotation> @Nullable MergedAnnotation<A> createMergedAnnotationIfPossible(\n\t\t\t\tint annotationIndex, int mappingIndex, IntrospectionFailureLogger logger) {\n\n\t\t\treturn TypeMappedAnnotation.createIfPossible(\n\t\t\t\t\tthis.mappings[annotationIndex].get(mappingIndex), this.source,\n\t\t\t\t\tthis.annotations.get(annotationIndex), this.aggregateIndex, logger);\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link Spliterator} used to consume merged annotations from the\n\t * aggregates in distance fist order.\n\t */\n\tprivate class AggregatesSpliterator<A extends Annotation> implements Spliterator<MergedAnnotation<A>> {\n\n\t\tprivate final @Nullable Object requiredType;\n\n\t\tprivate final List<Aggregate> aggregates;\n\n\t\tprivate int aggregateCursor;\n\n\t\tprivate int @Nullable [] mappingCursors;\n\n\t\tAggregatesSpliterator(@Nullable Object requiredType, List<Aggregate> aggregates) {\n\t\t\tthis.requiredType = requiredType;\n\t\t\tthis.aggregates = aggregates;\n\t\t\tthis.aggregateCursor = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean tryAdvance(Consumer<? super MergedAnnotation<A>> action) {\n\t\t\twhile (this.aggregateCursor < this.aggregates.size()) {\n\t\t\t\tAggregate aggregate = this.aggregates.get(this.aggregateCursor);\n\t\t\t\tif (tryAdvance(aggregate, action)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tthis.aggregateCursor++;\n\t\t\t\tthis.mappingCursors = null;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate boolean tryAdvance(Aggregate aggregate, Consumer<? super MergedAnnotation<A>> action) {\n\t\t\tif (this.mappingCursors == null) {\n\t\t\t\tthis.mappingCursors = new int[aggregate.size()];\n\t\t\t}\n\t\t\tint lowestDistance = Integer.MAX_VALUE;\n\t\t\tint annotationResult = -1;\n\t\t\tfor (int annotationIndex = 0; annotationIndex < aggregate.size(); annotationIndex++) {\n\t\t\t\tAnnotationTypeMapping mapping = getNextSuitableMapping(aggregate, annotationIndex);\n\t\t\t\tif (mapping != null && mapping.getDistance() < lowestDistance) {\n\t\t\t\t\tannotationResult = annotationIndex;\n\t\t\t\t\tlowestDistance = mapping.getDistance();\n\t\t\t\t}\n\t\t\t\tif (lowestDistance == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (annotationResult != -1) {\n\t\t\t\tMergedAnnotation<A> mergedAnnotation = aggregate.createMergedAnnotationIfPossible(\n\t\t\t\t\t\tannotationResult, this.mappingCursors[annotationResult],\n\t\t\t\t\t\tthis.requiredType != null ? IntrospectionFailureLogger.INFO : IntrospectionFailureLogger.DEBUG);\n\t\t\t\tthis.mappingCursors[annotationResult]++;\n\t\t\t\tif (mergedAnnotation == null) {\n\t\t\t\t\treturn tryAdvance(aggregate, action);\n\t\t\t\t}\n\t\t\t\taction.accept(mergedAnnotation);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate @Nullable AnnotationTypeMapping getNextSuitableMapping(Aggregate aggregate, int annotationIndex) {\n\t\t\tint[] cursors = this.mappingCursors;\n\t\t\tif (cursors != null) {\n\t\t\t\tAnnotationTypeMapping mapping;\n\t\t\t\tdo {\n\t\t\t\t\tmapping = aggregate.getMapping(annotationIndex, cursors[annotationIndex]);\n\t\t\t\t\tif (mapping != null && isMappingForType(mapping, annotationFilter, this.requiredType)) {\n\t\t\t\t\t\treturn mapping;\n\t\t\t\t\t}\n\t\t\t\t\tcursors[annotationIndex]++;\n\t\t\t\t}\n\t\t\t\twhile (mapping != null);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable Spliterator<MergedAnnotation<A>> trySplit() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic long estimateSize() {\n\t\t\tint size = 0;\n\t\t\tfor (int aggregateIndex = this.aggregateCursor;\n\t\t\t\t\taggregateIndex < this.aggregates.size(); aggregateIndex++) {\n\t\t\t\tAggregate aggregate = this.aggregates.get(aggregateIndex);\n\t\t\t\tfor (int annotationIndex = 0; annotationIndex < aggregate.size(); annotationIndex++) {\n\t\t\t\t\tAnnotationTypeMappings mappings = aggregate.getMappings(annotationIndex);\n\t\t\t\t\tint numberOfMappings = mappings.size();\n\t\t\t\t\tif (aggregateIndex == this.aggregateCursor && this.mappingCursors != null) {\n\t\t\t\t\t\tnumberOfMappings -= Math.min(this.mappingCursors[annotationIndex], mappings.size());\n\t\t\t\t\t}\n\t\t\t\t\tsize += numberOfMappings;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn size;\n\t\t}\n\n\t\t@Override\n\t\tpublic int characteristics() {\n\t\t\treturn NONNULL | IMMUTABLE;\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation.AggregatesSpliterator",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.AggregatesSpliterator#requiredType",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.AggregatesSpliterator#requiredType",
    "headType": "field",
    "relation": "haveType",
    "tail": "Object",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.AggregatesSpliterator",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.AggregatesSpliterator#aggregates",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.AggregatesSpliterator#aggregates",
    "headType": "field",
    "relation": "haveType",
    "tail": "List<Aggregate>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.AggregatesSpliterator",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.AggregatesSpliterator#aggregateCursor",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.AggregatesSpliterator#aggregateCursor",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.AggregatesSpliterator",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.AggregatesSpliterator#mappingCursors",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.AggregatesSpliterator#mappingCursors",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.AggregatesSpliterator#tryAdvance(Consumer<? super MergedAnnotation<A>>)",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic boolean tryAdvance(Consumer<? super MergedAnnotation<A>> action) {\r\n    while (this.aggregateCursor < this.aggregates.size()) {\r\n        Aggregate aggregate = this.aggregates.get(this.aggregateCursor);\r\n        if (tryAdvance(aggregate, action)) {\r\n            return true;\r\n        }\r\n        this.aggregateCursor++;\r\n        this.mappingCursors = null;\r\n    }\r\n    return false;\r\n}",
    "tailType": "method_code"
  }
]