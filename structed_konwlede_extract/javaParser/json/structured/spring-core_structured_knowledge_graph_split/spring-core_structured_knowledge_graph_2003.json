[
  {
    "head": "org.springframework.core.io.buffer.DataBufferTests#getByte(DataBufferFactory)",
    "headType": "method",
    "relation": "provide",
    "tail": "@ParameterizedDataBufferAllocatingTest\r\nvoid getByte(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = stringBuffer(\"abc\");\r\n    assertThat(buffer.getByte(0)).isEqualTo((byte) 'a');\r\n    assertThat(buffer.getByte(1)).isEqualTo((byte) 'b');\r\n    assertThat(buffer.getByte(2)).isEqualTo((byte) 'c');\r\n    assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> buffer.getByte(-1));\r\n    assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> buffer.getByte(3));\r\n    release(buffer);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.io.buffer.DataBufferTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.io.buffer.DataBufferTests#getByte(DataBufferFactory)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.io.buffer.DataBufferTests#getByte(DataBufferFactory)",
    "headType": "method",
    "relation": "use",
    "tail": "@ParameterizedDataBufferAllocatingTest",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.io.buffer.DataBufferTests#shouldHonorSourceBuffersReadPosition(DataBufferFactory)",
    "headType": "method",
    "relation": "provide",
    "tail": "// gh-31605\r\n@ParameterizedDataBufferAllocatingTest\r\nvoid shouldHonorSourceBuffersReadPosition(DataBufferFactory bufferFactory) {\r\n    DataBuffer dataBuffer = bufferFactory.wrap(\"ab\".getBytes(StandardCharsets.UTF_8));\r\n    dataBuffer.readPosition(1);\r\n    ByteBuffer byteBuffer = ByteBuffer.allocate(dataBuffer.readableByteCount());\r\n    dataBuffer.toByteBuffer(byteBuffer);\r\n    assertThat(StandardCharsets.UTF_8.decode(byteBuffer).toString()).isEqualTo(\"b\");\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.io.buffer.DataBufferTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.io.buffer.DataBufferTests#shouldHonorSourceBuffersReadPosition(DataBufferFactory)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.io.buffer.DataBufferTests#shouldHonorSourceBuffersReadPosition(DataBufferFactory)",
    "headType": "method",
    "relation": "use",
    "tail": "@ParameterizedDataBufferAllocatingTest",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.io.buffer.DataBufferTests#repeatedWrites(DataBufferFactory)",
    "headType": "method",
    "relation": "provide",
    "tail": "// gh-31873\r\n@ParameterizedDataBufferAllocatingTest\r\nvoid repeatedWrites(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = bufferFactory.allocateBuffer(256);\r\n    String name = \"MÃ¼ller\";\r\n    int repeatCount = 19;\r\n    for (int i = 0; i < repeatCount; i++) {\r\n        buffer.write(name, StandardCharsets.UTF_8);\r\n    }\r\n    String result = buffer.toString(StandardCharsets.UTF_8);\r\n    String expected = name.repeat(repeatCount);\r\n    assertThat(result).isEqualTo(expected);\r\n    release(buffer);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.io.buffer.DataBufferTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.io.buffer.DataBufferTests#repeatedWrites(DataBufferFactory)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.io.buffer.DataBufferTests#repeatedWrites(DataBufferFactory)",
    "headType": "method",
    "relation": "use",
    "tail": "@ParameterizedDataBufferAllocatingTest",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.io.buffer.DataBufferTests",
    "headType": "class",
    "relation": "extend",
    "tail": "AbstractDataBufferAllocatingTests",
    "tailType": "class"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.io.buffer",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core.io.buffer",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.io.buffer.DataBufferUtilsTests",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.io.buffer.DataBufferUtilsTests",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.io.buffer;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.URI;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.AsynchronousFileChannel;\nimport java.nio.channels.CompletionHandler;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.PooledByteBufAllocator;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.stubbing.Answer;\nimport org.reactivestreams.Publisher;\nimport org.reactivestreams.Subscription;\nimport reactor.core.publisher.BaseSubscriber;\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Mono;\nimport reactor.test.StepVerifier;\nimport reactor.util.context.Context;\n\nimport org.springframework.core.io.ByteArrayResource;\nimport org.springframework.core.io.ClassPathResource;\nimport org.springframework.core.io.Resource;\nimport org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatIOException;\nimport static org.assertj.core.api.Assertions.fail;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.anyLong;\nimport static org.mockito.BDDMockito.given;\nimport static org.mockito.BDDMockito.willAnswer;\nimport static org.mockito.Mockito.mock;\n\n/**\n * @author Arjen Poutsma\n * @author Sam Brannen\n */\nclass DataBufferUtilsTests extends AbstractDataBufferAllocatingTests {\n\n\tprivate final Resource resource;\n\n\tprivate final Path tempFile;\n\n\n\tDataBufferUtilsTests() throws Exception {\n\t\tthis.resource = new ClassPathResource(\"DataBufferUtilsTests.txt\", getClass());\n\t\tthis.tempFile = Files.createTempFile(\"DataBufferUtilsTests\", null);\n\t}\n\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid readInputStream(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tFlux<DataBuffer> flux = DataBufferUtils.readInputStream(\n\t\t\t\tthis.resource::getInputStream, super.bufferFactory, 3);\n\n\t\tverifyReadData(flux);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid readByteChannel(DataBufferFactory bufferFactory) throws Exception {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tURI uri = this.resource.getURI();\n\t\tFlux<DataBuffer> result =\n\t\t\t\tDataBufferUtils.readByteChannel(() -> FileChannel.open(Paths.get(uri), StandardOpenOption.READ),\n\t\t\t\t\tsuper.bufferFactory, 3);\n\n\t\tverifyReadData(result);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid readByteChannelError(DataBufferFactory bufferFactory) throws Exception {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tReadableByteChannel channel = mock();\n\t\tgiven(channel.read(any()))\n\t\t\t\t.willAnswer(invocation -> {\n\t\t\t\t\tByteBuffer buffer = invocation.getArgument(0);\n\t\t\t\t\tbuffer.put(\"foo\".getBytes(StandardCharsets.UTF_8));\n\t\t\t\t\tbuffer.flip();\n\t\t\t\t\treturn 3;\n\t\t\t\t})\n\t\t\t\t.willThrow(new IOException());\n\n\t\tFlux<DataBuffer> result =\n\t\t\t\tDataBufferUtils.readByteChannel(() -> channel, super.bufferFactory, 3);\n\n\t\tStepVerifier.create(result)\n\t\t\t\t.consumeNextWith(stringConsumer(\"foo\"))\n\t\t\t\t.expectError(IOException.class)\n\t\t\t\t.verify(Duration.ofSeconds(3));\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid readByteChannelCancel(DataBufferFactory bufferFactory) throws Exception {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tURI uri = this.resource.getURI();\n\t\tFlux<DataBuffer> result =\n\t\t\t\tDataBufferUtils.readByteChannel(() -> FileChannel.open(Paths.get(uri), StandardOpenOption.READ),\n\t\t\t\t\tsuper.bufferFactory, 3);\n\n\t\tStepVerifier.create(result)\n\t\t\t\t.consumeNextWith(stringConsumer(\"foo\"))\n\t\t\t\t.thenCancel()\n\t\t\t\t.verify();\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid readAsynchronousFileChannel(DataBufferFactory bufferFactory) throws Exception {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tURI uri = this.resource.getURI();\n\t\tFlux<DataBuffer> flux = DataBufferUtils.readAsynchronousFileChannel(\n\t\t\t\t() -> AsynchronousFileChannel.open(Paths.get(uri), StandardOpenOption.READ),\n\t\t\t\tsuper.bufferFactory, 3);\n\n\t\tverifyReadData(flux);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid readAsynchronousFileChannelPosition(DataBufferFactory bufferFactory) throws Exception {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tURI uri = this.resource.getURI();\n\t\tFlux<DataBuffer> flux = DataBufferUtils.readAsynchronousFileChannel(\n\t\t\t\t() -> AsynchronousFileChannel.open(Paths.get(uri), StandardOpenOption.READ),\n\t\t\t\t9, super.bufferFactory, 3);\n\n\t\tStepVerifier.create(flux)\n\t\t\t\t.consumeNextWith(stringConsumer(\"qux\"))\n\t\t\t\t.expectComplete()\n\t\t\t\t.verify(Duration.ofSeconds(5));\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid readAsynchronousFileChannelError(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tAsynchronousFileChannel channel = mock();\n\t\twillAnswer(invocation -> {\n\t\t\tByteBuffer byteBuffer = invocation.getArgument(0);\n\t\t\tbyteBuffer.put(\"foo\".getBytes(StandardCharsets.UTF_8));\n\t\t\tlong pos = invocation.getArgument(1);\n\t\t\tassertThat(pos).isEqualTo(0);\n\t\t\tObject attachment = invocation.getArgument(2);\n\t\t\tCompletionHandler<Integer, Object> completionHandler = invocation.getArgument(3);\n\t\t\tcompletionHandler.completed(3, attachment);\n\t\t\treturn null;\n\t\t}).willAnswer(invocation -> {\n\t\t\tObject attachment = invocation.getArgument(2);\n\t\t\tCompletionHandler<Integer, Object> completionHandler = invocation.getArgument(3);\n\t\t\tcompletionHandler.failed(new IOException(), attachment);\n\t\t\treturn null;\n\t\t})\n\t\t.given(channel).read(any(), anyLong(), any(), any());\n\n\t\tFlux<DataBuffer> result=\n\t\t\t\tDataBufferUtils.readAsynchronousFileChannel(() -> channel, super.bufferFactory, 3);\n\n\t\tStepVerifier.create(result)\n\t\t\t\t.consumeNextWith(stringConsumer(\"foo\"))\n\t\t\t\t.expectError(IOException.class)\n\t\t\t\t.verify(Duration.ofSeconds(3));\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid readAsynchronousFileChannelCancel(DataBufferFactory bufferFactory) throws Exception {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tURI uri = this.resource.getURI();\n\t\tFlux<DataBuffer> flux = DataBufferUtils.readAsynchronousFileChannel(\n\t\t\t\t() -> AsynchronousFileChannel.open(Paths.get(uri), StandardOpenOption.READ),\n\t\t\t\tsuper.bufferFactory, 3);\n\n\t\tStepVerifier.create(flux)\n\t\t\t\t.consumeNextWith(stringConsumer(\"foo\"))\n\t\t\t\t.thenCancel()\n\t\t\t\t.verify();\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest  // gh-22107\n\tvoid readAsynchronousFileChannelCancelWithoutDemand(DataBufferFactory bufferFactory) throws Exception {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tURI uri = this.resource.getURI();\n\t\tFlux<DataBuffer> flux = DataBufferUtils.readAsynchronousFileChannel(\n\t\t\t\t() -> AsynchronousFileChannel.open(Paths.get(uri), StandardOpenOption.READ),\n\t\t\t\tsuper.bufferFactory, 3);\n\n\t\tBaseSubscriber<DataBuffer> subscriber = new ZeroDemandSubscriber();\n\t\tflux.subscribe(subscriber);\n\t\tsubscriber.cancel();\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid readPath(DataBufferFactory bufferFactory) throws Exception {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tFlux<DataBuffer> flux = DataBufferUtils.read(this.resource.getFile().toPath(), super.bufferFactory, 3);\n\n\t\tverifyReadData(flux);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid readResource(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tFlux<DataBuffer> flux = DataBufferUtils.read(this.resource, super.bufferFactory, 3);\n\n\t\tverifyReadData(flux);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid readResourcePosition(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tFlux<DataBuffer> flux = DataBufferUtils.read(this.resource, 9, super.bufferFactory, 3);\n\n\t\tStepVerifier.create(flux)\n\t\t\t\t.consumeNextWith(stringConsumer(\"qux\"))\n\t\t\t\t.expectComplete()\n\t\t\t\t.verify(Duration.ofSeconds(5));\n\t}\n\n\tprivate void verifyReadData(Flux<DataBuffer> buffers) {\n\t\tStepVerifier.create(buffers)\n\t\t\t\t.consumeNextWith(stringConsumer(\"foo\"))\n\t\t\t\t.consumeNextWith(stringConsumer(\"bar\"))\n\t\t\t\t.consumeNextWith(stringConsumer(\"baz\"))\n\t\t\t\t.consumeNextWith(stringConsumer(\"qux\"))\n\t\t\t\t.expectComplete()\n\t\t\t\t.verify(Duration.ofSeconds(3));\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid readResourcePositionAndTakeUntil(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tResource resource = new ClassPathResource(\"DataBufferUtilsTests.txt\", getClass());\n\t\tFlux<DataBuffer> flux = DataBufferUtils.read(resource, 3, super.bufferFactory, 3);\n\n\t\tflux = DataBufferUtils.takeUntilByteCount(flux, 5);\n\n\n\t\tStepVerifier.create(flux)\n\t\t\t\t.consumeNextWith(stringConsumer(\"bar\"))\n\t\t\t\t.consumeNextWith(stringConsumer(\"ba\"))\n\t\t\t\t.expectComplete()\n\t\t\t\t.verify(Duration.ofSeconds(5));\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid readByteArrayResourcePositionAndTakeUntil(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tResource resource = new ByteArrayResource(\"foobarbazqux\" .getBytes());\n\t\tFlux<DataBuffer> flux = DataBufferUtils.read(resource, 3, super.bufferFactory, 3);\n\n\t\tflux = DataBufferUtils.takeUntilByteCount(flux, 5);\n\n\n\t\tStepVerifier.create(flux)\n\t\t\t\t.consumeNextWith(stringConsumer(\"bar\"))\n\t\t\t\t.consumeNextWith(stringConsumer(\"ba\"))\n\t\t\t\t.expectComplete()\n\t\t\t\t.verify(Duration.ofSeconds(5));\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid writeOutputStream(DataBufferFactory bufferFactory) throws Exception {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer foo = stringBuffer(\"foo\");\n\t\tDataBuffer bar = stringBuffer(\"bar\");\n\t\tDataBuffer baz = stringBuffer(\"baz\");\n\t\tDataBuffer qux = stringBuffer(\"qux\");\n\t\tFlux<DataBuffer> flux = Flux.just(foo, bar, baz, qux);\n\n\t\tOutputStream os = Files.newOutputStream(tempFile);\n\n\t\tFlux<DataBuffer> writeResult = DataBufferUtils.write(flux, os);\n\t\tverifyWrittenData(writeResult);\n\t\tos.close();\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid writeWritableByteChannel(DataBufferFactory bufferFactory) throws Exception {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer foo = stringBuffer(\"foo\");\n\t\tDataBuffer bar = stringBuffer(\"bar\");\n\t\tDataBuffer baz = stringBuffer(\"baz\");\n\t\tDataBuffer qux = stringBuffer(\"qux\");\n\t\tFlux<DataBuffer> flux = Flux.just(foo, bar, baz, qux);\n\n\t\tWritableByteChannel channel = Files.newByteChannel(tempFile, StandardOpenOption.WRITE);\n\n\t\tFlux<DataBuffer> writeResult = DataBufferUtils.write(flux, channel);\n\t\tverifyWrittenData(writeResult);\n\t\tchannel.close();\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid writeWritableByteChannelErrorInFlux(DataBufferFactory bufferFactory) throws Exception {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer foo = stringBuffer(\"foo\");\n\t\tDataBuffer bar = stringBuffer(\"bar\");\n\t\tFlux<DataBuffer> flux = Flux.just(foo, bar).concatWith(Flux.error(new RuntimeException()));\n\n\t\tWritableByteChannel channel = Files.newByteChannel(tempFile, StandardOpenOption.WRITE);\n\n\t\tFlux<DataBuffer> writeResult = DataBufferUtils.write(flux, channel);\n\t\tStepVerifier.create(writeResult)\n\t\t\t\t.consumeNextWith(stringConsumer(\"foo\"))\n\t\t\t\t.consumeNextWith(stringConsumer(\"bar\"))\n\t\t\t\t.expectError()\n\t\t\t\t.verify(Duration.ofSeconds(5));\n\n\t\tString result = String.join(\"\", Files.readAllLines(tempFile));\n\n\t\tassertThat(result).isEqualTo(\"foobar\");\n\t\tchannel.close();\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid writeWritableByteChannelErrorInWrite(DataBufferFactory bufferFactory) throws Exception {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer foo = stringBuffer(\"foo\");\n\t\tDataBuffer bar = stringBuffer(\"bar\");\n\t\tFlux<DataBuffer> flux = Flux.just(foo, bar);\n\n\t\tWritableByteChannel channel = mock();\n\t\tgiven(channel.write(any()))\n\t\t\t\t.willAnswer(invocation -> {\n\t\t\t\t\tByteBuffer buffer = invocation.getArgument(0);\n\t\t\t\t\tint written = buffer.remaining();\n\t\t\t\t\tbuffer.position(buffer.limit());\n\t\t\t\t\treturn written;\n\t\t\t\t})\n\t\t\t\t.willThrow(new IOException());\n\n\t\tFlux<DataBuffer> writeResult = DataBufferUtils.write(flux, channel);\n\t\tStepVerifier.create(writeResult)\n\t\t\t\t.consumeNextWith(stringConsumer(\"foo\"))\n\t\t\t\t.consumeNextWith(stringConsumer(\"bar\"))\n\t\t\t\t.expectError(IOException.class)\n\t\t\t\t.verify(Duration.ofSeconds(3));\n\n\t\tchannel.close();\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid writeWritableByteChannelCancel(DataBufferFactory bufferFactory) throws Exception {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer foo = stringBuffer(\"foo\");\n\t\tDataBuffer bar = stringBuffer(\"bar\");\n\t\tFlux<DataBuffer> flux = Flux.just(foo, bar);\n\n\t\tWritableByteChannel channel = Files.newByteChannel(tempFile, StandardOpenOption.WRITE);\n\n\t\tFlux<DataBuffer> writeResult = DataBufferUtils.write(flux, channel);\n\t\tStepVerifier.create(writeResult, 1)\n\t\t\t\t.consumeNextWith(stringConsumer(\"foo\"))\n\t\t\t\t.thenCancel()\n\t\t\t\t.verify(Duration.ofSeconds(5));\n\n\t\tString result = String.join(\"\", Files.readAllLines(tempFile));\n\n\t\tassertThat(result).isEqualTo(\"foo\");\n\t\tchannel.close();\n\n\t\tflux.subscribe(DataBufferUtils::release);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid writeAsynchronousFileChannel(DataBufferFactory bufferFactory) throws Exception {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer foo = stringBuffer(\"foo\");\n\t\tDataBuffer bar = stringBuffer(\"bar\");\n\t\tDataBuffer baz = stringBuffer(\"baz\");\n\t\tDataBuffer qux = stringBuffer(\"qux\");\n\t\tFlux<DataBuffer> flux = Flux.just(foo, bar, baz, qux);\n\n\t\tAsynchronousFileChannel channel =\n\t\t\t\tAsynchronousFileChannel.open(tempFile, StandardOpenOption.WRITE);\n\n\t\tFlux<DataBuffer> writeResult = DataBufferUtils.write(flux, channel);\n\t\tverifyWrittenData(writeResult);\n\t\tchannel.close();\n\t}\n\n\tprivate void verifyWrittenData(Flux<DataBuffer> writeResult) throws IOException {\n\t\tStepVerifier.create(writeResult)\n\t\t\t\t.consumeNextWith(stringConsumer(\"foo\"))\n\t\t\t\t.consumeNextWith(stringConsumer(\"bar\"))\n\t\t\t\t.consumeNextWith(stringConsumer(\"baz\"))\n\t\t\t\t.consumeNextWith(stringConsumer(\"qux\"))\n\t\t\t\t.expectComplete()\n\t\t\t\t.verify(Duration.ofSeconds(3));\n\n\t\tString result = String.join(\"\", Files.readAllLines(tempFile));\n\n\t\tassertThat(result).isEqualTo(\"foobarbazqux\");\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid writeAsynchronousFileChannelErrorInFlux(DataBufferFactory bufferFactory) throws Exception {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer foo = stringBuffer(\"foo\");\n\t\tDataBuffer bar = stringBuffer(\"bar\");\n\t\tFlux<DataBuffer> flux =\n\t\t\t\tFlux.just(foo, bar).concatWith(Mono.error(new RuntimeException()));\n\n\t\tAsynchronousFileChannel channel =\n\t\t\t\tAsynchronousFileChannel.open(tempFile, StandardOpenOption.WRITE);\n\n\t\tFlux<DataBuffer> writeResult = DataBufferUtils.write(flux, channel);\n\t\tStepVerifier.create(writeResult)\n\t\t\t\t.consumeNextWith(stringConsumer(\"foo\"))\n\t\t\t\t.consumeNextWith(stringConsumer(\"bar\"))\n\t\t\t\t.expectError(RuntimeException.class)\n\t\t\t\t.verify();\n\n\t\tString result = String.join(\"\", Files.readAllLines(tempFile));\n\n\t\tassertThat(result).isEqualTo(\"foobar\");\n\t\tchannel.close();\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid writeAsynchronousFileChannelErrorInWrite(DataBufferFactory bufferFactory) throws Exception {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer foo = stringBuffer(\"foo\");\n\t\tDataBuffer bar = stringBuffer(\"bar\");\n\t\tFlux<DataBuffer> flux = Flux.just(foo, bar);\n\n\t\tAsynchronousFileChannel channel = mock();\n\t\twillAnswer(invocation -> {\n\t\t\tByteBuffer buffer = invocation.getArgument(0);\n\t\t\tlong pos = invocation.getArgument(1);\n\t\t\tassertThat(pos).isEqualTo(0);\n\t\t\tObject attachment = invocation.getArgument(2);\n\t\t\tCompletionHandler<Integer, Object> completionHandler = invocation.getArgument(3);\n\t\t\tint written = buffer.remaining();\n\t\t\tbuffer.position(buffer.limit());\n\t\t\tcompletionHandler.completed(written, attachment);\n\t\t\treturn null;\n\t\t})\n\t\t.willAnswer(invocation -> {\n\t\t\tObject attachment = invocation.getArgument(2);\n\t\t\tCompletionHandler<Integer, Object> completionHandler = invocation.getArgument(3);\n\t\t\tcompletionHandler.failed(new IOException(), attachment);\n\t\t\treturn null;\n\t\t})\n\t\t.given(channel).write(any(), anyLong(), any(), any());\n\n\t\tFlux<DataBuffer> writeResult = DataBufferUtils.write(flux, channel);\n\t\tStepVerifier.create(writeResult)\n\t\t\t\t.consumeNextWith(stringConsumer(\"foo\"))\n\t\t\t\t.consumeNextWith(stringConsumer(\"bar\"))\n\t\t\t\t.expectError(IOException.class)\n\t\t\t\t.verify();\n\n\t\tchannel.close();\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid writeAsynchronousFileChannelCanceled(DataBufferFactory bufferFactory) throws Exception {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer foo = stringBuffer(\"foo\");\n\t\tDataBuffer bar = stringBuffer(\"bar\");\n\t\tFlux<DataBuffer> flux = Flux.just(foo, bar);\n\n\t\tAsynchronousFileChannel channel =\n\t\t\t\tAsynchronousFileChannel.open(tempFile, StandardOpenOption.WRITE);\n\n\t\tFlux<DataBuffer> writeResult = DataBufferUtils.write(flux, channel);\n\t\tStepVerifier.create(writeResult, 1)\n\t\t\t\t.consumeNextWith(stringConsumer(\"foo\"))\n\t\t\t\t.thenCancel()\n\t\t\t\t.verify();\n\n\t\tString result = String.join(\"\", Files.readAllLines(tempFile));\n\n\t\tassertThat(result).isEqualTo(\"foo\");\n\t\tchannel.close();\n\n\t\tflux.subscribe(DataBufferUtils::release);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid writePath(DataBufferFactory bufferFactory) throws Exception {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer foo = stringBuffer(\"foo\");\n\t\tDataBuffer bar = stringBuffer(\"bar\");\n\t\tFlux<DataBuffer> flux = Flux.just(foo, bar);\n\n\t\tMono<Void> result = DataBufferUtils.write(flux, tempFile);\n\n\t\tStepVerifier.create(result)\n\t\t\t\t.verifyComplete();\n\n\t\tList<String> written = Files.readAllLines(tempFile);\n\t\tassertThat(written).contains(\"foobar\");\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid outputStreamPublisher(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tbyte[] foo = \"foo\".getBytes(StandardCharsets.UTF_8);\n\t\tbyte[] bar = \"bar\".getBytes(StandardCharsets.UTF_8);\n\t\tbyte[] baz = \"baz\".getBytes(StandardCharsets.UTF_8);\n\n\t\tPublisher<DataBuffer> publisher = DataBufferUtils.outputStreamPublisher(outputStream -> {\n\t\t\ttry {\n\t\t\t\toutputStream.write(foo);\n\t\t\t\toutputStream.write(bar);\n\t\t\t\toutputStream.write(baz);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tfail(ex.getMessage(), ex);\n\t\t\t}\n\t\t}, super.bufferFactory, Executors.newSingleThreadExecutor());\n\n\t\tStepVerifier.create(publisher)\n\t\t\t\t.consumeNextWith(stringConsumer(\"foobarbaz\"))\n\t\t\t\t.verifyComplete();\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid outputStreamPublisherFlush(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tbyte[] foo = \"foo\".getBytes(StandardCharsets.UTF_8);\n\t\tbyte[] bar = \"bar\".getBytes(StandardCharsets.UTF_8);\n\t\tbyte[] baz = \"baz\".getBytes(StandardCharsets.UTF_8);\n\n\t\tPublisher<DataBuffer> publisher = DataBufferUtils.outputStreamPublisher(outputStream -> {\n\t\t\ttry {\n\t\t\t\toutputStream.write(foo);\n\t\t\t\toutputStream.flush();\n\t\t\t\toutputStream.write(bar);\n\t\t\t\toutputStream.flush();\n\t\t\t\toutputStream.write(baz);\n\t\t\t\toutputStream.flush();\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tfail(ex.getMessage(), ex);\n\t\t\t}\n\t\t}, super.bufferFactory, Executors.newSingleThreadExecutor());\n\n\t\tStepVerifier.create(publisher)\n\t\t\t\t.consumeNextWith(stringConsumer(\"foo\"))\n\t\t\t\t.consumeNextWith(stringConsumer(\"bar\"))\n\t\t\t\t.consumeNextWith(stringConsumer(\"baz\"))\n\t\t\t\t.verifyComplete();\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid outputStreamPublisherChunkSize(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tbyte[] foo = \"foo\".getBytes(StandardCharsets.UTF_8);\n\t\tbyte[] bar = \"bar\".getBytes(StandardCharsets.UTF_8);\n\t\tbyte[] baz = \"baz\".getBytes(StandardCharsets.UTF_8);\n\n\t\tPublisher<DataBuffer> publisher = DataBufferUtils.outputStreamPublisher(outputStream -> {\n\t\t\ttry {\n\t\t\t\toutputStream.write(foo);\n\t\t\t\toutputStream.write(bar);\n\t\t\t\toutputStream.write(baz);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tfail(ex.getMessage(), ex);\n\t\t\t}\n\t\t}, super.bufferFactory, Executors.newSingleThreadExecutor(), 3);\n\n\t\tStepVerifier.create(publisher)\n\t\t\t\t.consumeNextWith(stringConsumer(\"foo\"))\n\t\t\t\t.consumeNextWith(stringConsumer(\"bar\"))\n\t\t\t\t.consumeNextWith(stringConsumer(\"baz\"))\n\t\t\t\t.verifyComplete();\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid outputStreamPublisherCancel(DataBufferFactory bufferFactory) throws InterruptedException {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tbyte[] foo = \"foo\".getBytes(StandardCharsets.UTF_8);\n\t\tbyte[] bar = \"bar\".getBytes(StandardCharsets.UTF_8);\n\n\t\tCountDownLatch latch = new CountDownLatch(1);\n\n\t\tPublisher<DataBuffer> publisher = DataBufferUtils.outputStreamPublisher(outputStream -> {\n\t\t\ttry {\n\t\t\t\tassertThatIOException()\n\t\t\t\t\t\t.isThrownBy(() -> {\n\t\t\t\t\t\t\toutputStream.write(foo);\n\t\t\t\t\t\t\toutputStream.flush();\n\t\t\t\t\t\t\toutputStream.write(bar);\n\t\t\t\t\t\t\toutputStream.flush();\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.withMessage(\"Subscription has been terminated\");\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tlatch.countDown();\n\t\t\t}\n\t\t}, super.bufferFactory, Executors.newSingleThreadExecutor());\n\n\t\tStepVerifier.create(publisher, 1)\n\t\t\t\t.consumeNextWith(stringConsumer(\"foo\"))\n\t\t\t\t.thenCancel()\n\t\t\t\t.verify();\n\n\t\tlatch.await();\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid outputStreamPublisherClosed(DataBufferFactory bufferFactory) throws InterruptedException {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tCountDownLatch latch = new CountDownLatch(1);\n\n\t\tPublisher<DataBuffer> publisher = DataBufferUtils.outputStreamPublisher(outputStream -> {\n\t\t\ttry {\n\t\t\t\tOutputStreamWriter writer = new OutputStreamWriter(outputStream, StandardCharsets.UTF_8);\n\t\t\t\twriter.write(\"foo\");\n\t\t\t\twriter.close();\n\t\t\t\tassertThatIOException().isThrownBy(() -> writer.write(\"bar\"))\n\t\t\t\t\t\t.withMessage(\"Stream closed\");\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tfail(ex.getMessage(), ex);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tlatch.countDown();\n\t\t\t}\n\t\t}, super.bufferFactory, Executors.newSingleThreadExecutor());\n\n\t\tStepVerifier.create(publisher)\n\t\t\t\t.consumeNextWith(stringConsumer(\"foo\"))\n\t\t\t\t.verifyComplete();\n\n\t\tlatch.await();\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid inputStreamSubscriberChunkSize(DataBufferFactory factory) {\n\t\tgenericInputStreamSubscriberTest(\n\t\t\t\tfactory, 3, 3, 64, List.of(\"foo\", \"bar\", \"baz\"), List.of(\"foo\", \"bar\", \"baz\"));\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid inputStreamSubscriberChunkSize2(DataBufferFactory factory) {\n\t\tgenericInputStreamSubscriberTest(\n\t\t\t\tfactory, 3, 3, 1, List.of(\"foo\", \"bar\", \"baz\"), List.of(\"foo\", \"bar\", \"baz\"));\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid inputStreamSubscriberChunkSize3(DataBufferFactory factory) {\n\t\tgenericInputStreamSubscriberTest(factory, 3, 12, 1, List.of(\"foo\", \"bar\", \"baz\"), List.of(\"foobarbaz\"));\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid inputStreamSubscriberChunkSize4(DataBufferFactory factory) {\n\t\tgenericInputStreamSubscriberTest(\n\t\t\t\tfactory, 3, 1, 1, List.of(\"foo\", \"bar\", \"baz\"), List.of(\"f\", \"o\", \"o\", \"b\", \"a\", \"r\", \"b\", \"a\", \"z\"));\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid inputStreamSubscriberChunkSize5(DataBufferFactory factory) {\n\t\tgenericInputStreamSubscriberTest(\n\t\t\t\tfactory, 3, 2, 1, List.of(\"foo\", \"bar\", \"baz\"), List.of(\"fo\", \"ob\", \"ar\", \"ba\", \"z\"));\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid inputStreamSubscriberChunkSize6(DataBufferFactory factory) {\n\t\tgenericInputStreamSubscriberTest(\n\t\t\t\tfactory, 1, 3, 1, List.of(\"foo\", \"bar\", \"baz\"), List.of(\"foo\", \"bar\", \"baz\"));\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid inputStreamSubscriberChunkSize7(DataBufferFactory factory) {\n\t\tgenericInputStreamSubscriberTest(\n\t\t\t\tfactory, 1, 3, 64, List.of(\"foo\", \"bar\", \"baz\"), List.of(\"foo\", \"bar\", \"baz\"));\n\t}\n\n\tvoid genericInputStreamSubscriberTest(\n\t\t\tDataBufferFactory factory, int writeChunkSize, int readChunkSize, int bufferSize,\n\t\t\tList<String> input, List<String> expectedOutput) {\n\n\t\tsuper.bufferFactory = factory;\n\n\t\tPublisher<DataBuffer> publisher = DataBufferUtils.outputStreamPublisher(\n\t\t\t\tout -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor (String word : input) {\n\t\t\t\t\t\t\tout.write(word.getBytes(StandardCharsets.UTF_8));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\t\tfail(ex.getMessage(), ex);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsuper.bufferFactory, Executors.newSingleThreadExecutor(), writeChunkSize);\n\n\t\tbyte[] chunk = new byte[readChunkSize];\n\t\tList<String> words = new ArrayList<>();\n\n\t\ttry (InputStream in = DataBufferUtils.subscriberInputStream(publisher, bufferSize)) {\n\t\t\tint read;\n\t\t\twhile ((read = in.read(chunk)) > -1) {\n\t\t\t\twords.add(new String(chunk, 0, read, StandardCharsets.UTF_8));\n\t\t\t}\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\tassertThat(words).containsExactlyElementsOf(expectedOutput);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid inputStreamSubscriberError(DataBufferFactory factory) {\n\t\tsuper.bufferFactory = factory;\n\n\t\tvar input = List.of(\"foo \", \"bar \", \"baz\");\n\n\t\tPublisher<DataBuffer> publisher = DataBufferUtils.outputStreamPublisher(\n\t\t\t\tout -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor (String word : input) {\n\t\t\t\t\t\t\tout.write(word.getBytes(StandardCharsets.UTF_8));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new RuntimeException(\"boom\");\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\t\tfail(ex.getMessage(), ex);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsuper.bufferFactory, Executors.newSingleThreadExecutor(), 1);\n\n\n\t\tRuntimeException error = null;\n\t\tbyte[] chunk = new byte[4];\n\t\tList<String> words = new ArrayList<>();\n\n\t\ttry (InputStream in = DataBufferUtils.subscriberInputStream(publisher, 1)) {\n\t\t\tint read;\n\t\t\twhile ((read = in.read(chunk)) > -1) {\n\t\t\t\twords.add(new String(chunk, 0, read, StandardCharsets.UTF_8));\n\t\t\t}\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\tcatch (RuntimeException e) {\n\t\t\terror = e;\n\t\t}\n\t\tassertThat(words).containsExactlyElementsOf(List.of(\"foo \", \"bar \", \"baz\"));\n\t\tassertThat(error).hasMessage(\"boom\");\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid inputStreamSubscriberMixedReadMode(DataBufferFactory factory) {\n\t\tsuper.bufferFactory = factory;\n\n\t\tvar input = List.of(\"foo \", \"bar \", \"baz\");\n\n\t\tPublisher<DataBuffer> publisher = DataBufferUtils.outputStreamPublisher(\n\t\t\t\tout -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor (String word : input) {\n\t\t\t\t\t\t\tout.write(word.getBytes(StandardCharsets.UTF_8));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\t\tfail(ex.getMessage(), ex);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsuper.bufferFactory, Executors.newSingleThreadExecutor(), 1);\n\n\n\t\tbyte[] chunk = new byte[3];\n\t\tArrayList<String> words = new ArrayList<>();\n\n\t\ttry (InputStream inputStream = DataBufferUtils.subscriberInputStream(publisher, 1)) {\n\t\t\twords.add(new String(chunk,0, inputStream.read(chunk), StandardCharsets.UTF_8));\n\t\t\tassertThat(inputStream.read()).isEqualTo(' ' & 0xFF);\n\t\t\twords.add(new String(chunk,0, inputStream.read(chunk), StandardCharsets.UTF_8));\n\t\t\tassertThat(inputStream.read()).isEqualTo(' ' & 0xFF);\n\t\t\twords.add(new String(chunk,0, inputStream.read(chunk), StandardCharsets.UTF_8));\n\t\t\tassertThat(inputStream.read()).isEqualTo(-1);\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\tassertThat(words).containsExactlyElementsOf(List.of(\"foo\", \"bar\", \"baz\"));\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid inputStreamSubscriberClose(DataBufferFactory bufferFactory) throws InterruptedException {\n\t\tfor (int i = 1; i < 100; i++) {\n\t\t\tCountDownLatch latch = new CountDownLatch(1);\n\t\t\tsuper.bufferFactory = bufferFactory;\n\n\t\t\tvar input = List.of(\"foo\", \"bar\", \"baz\");\n\n\t\t\tPublisher<DataBuffer> publisher = DataBufferUtils.outputStreamPublisher(\n\t\t\t\t\tout -> {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tassertThatIOException()\n\t\t\t\t\t\t\t\t\t.isThrownBy(() -> {\n\t\t\t\t\t\t\t\t\t\tfor (String word : input) {\n\t\t\t\t\t\t\t\t\t\t\tout.write(word.getBytes(StandardCharsets.UTF_8));\n\t\t\t\t\t\t\t\t\t\t\tout.flush();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t.withMessage(\"Subscription has been terminated\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\tlatch.countDown();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tsuper.bufferFactory, Executors.newSingleThreadExecutor(), 1);\n\n\n\t\t\tbyte[] chunk = new byte[3];\n\t\t\tArrayList<String> words = new ArrayList<>();\n\n\t\t\ttry (InputStream in = DataBufferUtils.subscriberInputStream(publisher, ThreadLocalRandom.current().nextInt(1, 4))) {\n\t\t\t\tin.read(chunk);\n\t\t\t\tString word = new String(chunk, StandardCharsets.UTF_8);\n\t\t\t\twords.add(word);\n\t\t\t}\n\t\t\tcatch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tassertThat(words).containsExactlyElementsOf(List.of(\"foo\"));\n\t\t\tlatch.await();\n\t\t}\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid readAndWriteByteChannel(DataBufferFactory bufferFactory) throws Exception {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tPath source = Paths.get(\n\t\t\t\tDataBufferUtilsTests.class.getResource(\"DataBufferUtilsTests.txt\").toURI());\n\t\tFlux<DataBuffer> sourceFlux =\n\t\t\t\tDataBufferUtils\n\t\t\t\t\t\t.readByteChannel(() -> FileChannel.open(source, StandardOpenOption.READ),\n\t\t\t\t\t\t\tsuper.bufferFactory, 3);\n\n\t\tPath destination = Files.createTempFile(\"DataBufferUtilsTests\", null);\n\t\tWritableByteChannel channel = Files.newByteChannel(destination, StandardOpenOption.WRITE);\n\n\t\tDataBufferUtils.write(sourceFlux, channel)\n\t\t\t\t.subscribe(DataBufferUtils.releaseConsumer(),\n\t\t\t\t\t\tthrowable -> {\n\t\t\t\t\t\t\tthrow new AssertionError(throwable.getMessage(), throwable);\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tString expected = String.join(\"\", Files.readAllLines(source));\n\t\t\t\t\t\t\t\tString result = String.join(\"\", Files.readAllLines(destination));\n\t\t\t\t\t\t\t\tassertThat(result).isEqualTo(expected);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (IOException e) {\n\t\t\t\t\t\t\t\tthrow new AssertionError(e.getMessage(), e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\t\tDataBufferUtils.closeChannel(channel);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid readAndWriteAsynchronousFileChannel(DataBufferFactory bufferFactory) throws Exception {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tPath source = Paths.get(\n\t\t\t\tDataBufferUtilsTests.class.getResource(\"DataBufferUtilsTests.txt\").toURI());\n\t\tFlux<DataBuffer> sourceFlux = DataBufferUtils.readAsynchronousFileChannel(\n\t\t\t\t() -> AsynchronousFileChannel.open(source, StandardOpenOption.READ),\n\t\t\t\tsuper.bufferFactory, 3);\n\n\t\tPath destination = Files.createTempFile(\"DataBufferUtilsTests\", null);\n\t\tAsynchronousFileChannel channel =\n\t\t\t\tAsynchronousFileChannel.open(destination, StandardOpenOption.WRITE);\n\n\t\tCountDownLatch latch = new CountDownLatch(1);\n\n\t\tDataBufferUtils.write(sourceFlux, channel)\n\t\t\t\t.subscribe(DataBufferUtils::release,\n\t\t\t\t\t\tthrowable -> {\n\t\t\t\t\t\t\tthrow new AssertionError(throwable.getMessage(), throwable);\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tString expected = String.join(\"\", Files.readAllLines(source));\n\t\t\t\t\t\t\t\tString result = String.join(\"\", Files.readAllLines(destination));\n\n\t\t\t\t\t\t\t\tassertThat(result).isEqualTo(expected);\n\t\t\t\t\t\t\t\tlatch.countDown();\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (IOException e) {\n\t\t\t\t\t\t\t\tthrow new AssertionError(e.getMessage(), e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\t\tDataBufferUtils.closeChannel(channel);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\tlatch.await();\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid takeUntilByteCount(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tFlux<DataBuffer> result = DataBufferUtils.takeUntilByteCount(\n\t\t\t\tFlux.just(stringBuffer(\"foo\"), stringBuffer(\"bar\")), 5L);\n\n\t\tStepVerifier.create(result)\n\t\t\t\t.consumeNextWith(stringConsumer(\"foo\"))\n\t\t\t\t.consumeNextWith(stringConsumer(\"ba\"))\n\t\t\t\t.expectComplete()\n\t\t\t\t.verify(Duration.ofSeconds(5));\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid takeUntilByteCountCanceled(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tFlux<DataBuffer> source = Flux.concat(\n\t\t\t\tdeferStringBuffer(\"foo\"),\n\t\t\t\tdeferStringBuffer(\"bar\")\n\t\t);\n\t\tFlux<DataBuffer> result = DataBufferUtils.takeUntilByteCount(\n\t\t\t\tsource, 5L);\n\n\t\tStepVerifier.create(result)\n\t\t\t\t.consumeNextWith(stringConsumer(\"foo\"))\n\t\t\t\t.thenCancel()\n\t\t\t\t.verify(Duration.ofSeconds(5));\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid takeUntilByteCountError(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tFlux<DataBuffer> source = Flux.concat(\n\t\t\t\tMono.defer(() -> Mono.just(stringBuffer(\"foo\"))),\n\t\t\t\tMono.error(new RuntimeException())\n\t\t);\n\n\t\tFlux<DataBuffer> result = DataBufferUtils.takeUntilByteCount(source, 5L);\n\n\t\tStepVerifier.create(result)\n\t\t\t\t.consumeNextWith(stringConsumer(\"foo\"))\n\t\t\t\t.expectError(RuntimeException.class)\n\t\t\t\t.verify(Duration.ofSeconds(5));\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid takeUntilByteCountExact(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tFlux<DataBuffer> source = Flux.concat(\n\t\t\t\tdeferStringBuffer(\"foo\"),\n\t\t\t\tdeferStringBuffer(\"bar\"),\n\t\t\t\tdeferStringBuffer(\"baz\")\n\t\t);\n\n\t\tFlux<DataBuffer> result = DataBufferUtils.takeUntilByteCount(source, 6L);\n\n\t\tStepVerifier.create(result)\n\t\t\t\t.consumeNextWith(stringConsumer(\"foo\"))\n\t\t\t\t.consumeNextWith(stringConsumer(\"bar\"))\n\t\t\t\t.expectComplete()\n\t\t\t\t.verify(Duration.ofSeconds(5));\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid skipUntilByteCount(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tFlux<DataBuffer> source = Flux.concat(\n\t\t\t\tdeferStringBuffer(\"foo\"),\n\t\t\t\tdeferStringBuffer(\"bar\"),\n\t\t\t\tdeferStringBuffer(\"baz\")\n\t\t);\n\t\tFlux<DataBuffer> result = DataBufferUtils.skipUntilByteCount(source, 5L);\n\n\t\tStepVerifier.create(result)\n\t\t\t\t.consumeNextWith(stringConsumer(\"r\"))\n\t\t\t\t.consumeNextWith(stringConsumer(\"baz\"))\n\t\t\t\t.expectComplete()\n\t\t\t\t.verify(Duration.ofSeconds(5));\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid skipUntilByteCountCancelled(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tFlux<DataBuffer> source = Flux.concat(\n\t\t\t\tdeferStringBuffer(\"foo\"),\n\t\t\t\tdeferStringBuffer(\"bar\")\n\t\t);\n\t\tFlux<DataBuffer> result = DataBufferUtils.skipUntilByteCount(source, 5L);\n\n\t\tStepVerifier.create(result)\n\t\t\t\t.consumeNextWith(stringConsumer(\"r\"))\n\t\t\t\t.thenCancel()\n\t\t\t\t.verify(Duration.ofSeconds(5));\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid skipUntilByteCountErrorInFlux(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer foo = stringBuffer(\"foo\");\n\t\tFlux<DataBuffer> flux =\n\t\t\t\tFlux.just(foo).concatWith(Mono.error(new RuntimeException()));\n\t\tFlux<DataBuffer> result = DataBufferUtils.skipUntilByteCount(flux, 3L);\n\n\t\tStepVerifier.create(result)\n\t\t\t\t.expectError(RuntimeException.class)\n\t\t\t\t.verify(Duration.ofSeconds(5));\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid skipUntilByteCountShouldSkipAll(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer foo = stringBuffer(\"foo\");\n\t\tDataBuffer bar = stringBuffer(\"bar\");\n\t\tDataBuffer baz = stringBuffer(\"baz\");\n\t\tFlux<DataBuffer> flux = Flux.just(foo, bar, baz);\n\t\tFlux<DataBuffer> result = DataBufferUtils.skipUntilByteCount(flux, 9L);\n\n\t\tStepVerifier.create(result)\n\t\t\t\t.expectComplete()\n\t\t\t\t.verify(Duration.ofSeconds(5));\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid releaseConsumer(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer foo = stringBuffer(\"foo\");\n\t\tDataBuffer bar = stringBuffer(\"bar\");\n\t\tDataBuffer baz = stringBuffer(\"baz\");\n\t\tFlux<DataBuffer> flux = Flux.just(foo, bar, baz);\n\n\t\tflux.subscribe(DataBufferUtils.releaseConsumer());\n\n\t\tassertReleased(foo);\n\t\tassertReleased(bar);\n\t\tassertReleased(baz);\n\t}\n\n\tprivate static void assertReleased(DataBuffer dataBuffer) {\n\t\tif (dataBuffer instanceof NettyDataBuffer nettyDataBuffer) {\n\t\t\tByteBuf byteBuf = nettyDataBuffer.getNativeBuffer();\n\t\t\tassertThat(byteBuf.refCnt()).isEqualTo(0);\n\t\t}\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid SPR16070(DataBufferFactory bufferFactory) throws Exception {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tReadableByteChannel channel = mock();\n\t\tgiven(channel.read(any()))\n\t\t\t\t.willAnswer(putByte('a'))\n\t\t\t\t.willAnswer(putByte('b'))\n\t\t\t\t.willAnswer(putByte('c'))\n\t\t\t\t.willReturn(-1);\n\n\t\tFlux<DataBuffer> read =\n\t\t\t\tDataBufferUtils.readByteChannel(() -> channel, super.bufferFactory, 1);\n\n\t\tStepVerifier.create(read)\n\t\t\t\t.consumeNextWith(stringConsumer(\"a\"))\n\t\t\t\t.consumeNextWith(stringConsumer(\"b\"))\n\t\t\t\t.consumeNextWith(stringConsumer(\"c\"))\n\t\t\t\t.expectComplete()\n\t\t\t\t.verify(Duration.ofSeconds(5));\n\t}\n\n\tprivate Answer<Integer> putByte(int b) {\n\t\treturn invocation -> {\n\t\t\tByteBuffer buffer = invocation.getArgument(0);\n\t\t\tbuffer.put((byte) b);\n\t\t\treturn 1;\n\t\t};\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid join(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer foo = stringBuffer(\"foo\");\n\t\tDataBuffer bar = stringBuffer(\"bar\");\n\t\tDataBuffer baz = stringBuffer(\"baz\");\n\t\tFlux<DataBuffer> flux = Flux.just(foo, bar, baz);\n\t\tMono<DataBuffer> result = DataBufferUtils.join(flux);\n\n\t\tStepVerifier.create(result)\n\t\t\t\t.consumeNextWith(buf -> {\n\t\t\t\t\tassertThat(buf.toString(StandardCharsets.UTF_8)).isEqualTo(\"foobarbaz\");\n\t\t\t\t\trelease(buf);\n\t\t\t\t})\n\t\t\t\t.verifyComplete();\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid joinWithLimit(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer foo = stringBuffer(\"foo\");\n\t\tDataBuffer bar = stringBuffer(\"bar\");\n\t\tDataBuffer baz = stringBuffer(\"baz\");\n\t\tFlux<DataBuffer> flux = Flux.just(foo, bar, baz);\n\t\tMono<DataBuffer> result = DataBufferUtils.join(flux, 8);\n\n\t\tStepVerifier.create(result)\n\t\t\t\t.verifyError(DataBufferLimitException.class);\n\t}\n\n\t@Test  // gh-26060\n\tvoid joinWithLimitDoesNotOverRelease() {\n\t\tNettyDataBufferFactory bufferFactory = new NettyDataBufferFactory(PooledByteBufAllocator.DEFAULT);\n\t\tbyte[] bytes = \"foo-bar-baz\".getBytes(StandardCharsets.UTF_8);\n\n\t\tNettyDataBuffer buffer = bufferFactory.allocateBuffer(bytes.length);\n\t\tbuffer.getNativeBuffer().retain(); // should be at 2 now\n\t\tbuffer.write(bytes);\n\n\t\tMono<DataBuffer> result = DataBufferUtils.join(Flux.just(buffer), 8);\n\n\t\tStepVerifier.create(result).verifyError(DataBufferLimitException.class);\n\t\tassertThat(buffer.getNativeBuffer().refCnt()).isEqualTo(1);\n\t\tbuffer.release();\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid joinErrors(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer foo = stringBuffer(\"foo\");\n\t\tDataBuffer bar = stringBuffer(\"bar\");\n\t\tFlux<DataBuffer> flux = Flux.just(foo, bar).concatWith(Flux.error(new RuntimeException()));\n\t\tMono<DataBuffer> result = DataBufferUtils.join(flux);\n\n\t\tStepVerifier.create(result)\n\t\t\t\t.expectError(RuntimeException.class)\n\t\t\t\t.verify();\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid joinCanceled(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tFlux<DataBuffer> source = Flux.concat(\n\t\t\t\tdeferStringBuffer(\"foo\"),\n\t\t\t\tdeferStringBuffer(\"bar\"),\n\t\t\t\tdeferStringBuffer(\"baz\")\n\t\t);\n\t\tMono<DataBuffer> result = DataBufferUtils.join(source);\n\n\t\tStepVerifier.create(result)\n\t\t\t\t.thenCancel()\n\t\t\t\t.verify();\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid matcher(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer foo = stringBuffer(\"foo\");\n\t\tDataBuffer bar = stringBuffer(\"bar\");\n\n\t\tbyte[] delims = \"ooba\".getBytes(StandardCharsets.UTF_8);\n\t\tDataBufferUtils.Matcher matcher = DataBufferUtils.matcher(delims);\n\t\tint result = matcher.match(foo);\n\t\tassertThat(result).isEqualTo(-1);\n\t\tresult = matcher.match(bar);\n\t\tassertThat(result).isEqualTo(1);\n\n\n\t\trelease(foo, bar);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid matcher2(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer foo = stringBuffer(\"foooobar\");\n\n\t\tbyte[] delims = \"oo\".getBytes(StandardCharsets.UTF_8);\n\t\tDataBufferUtils.Matcher matcher = DataBufferUtils.matcher(delims);\n\t\tint endIndex = matcher.match(foo);\n\t\tassertThat(endIndex).isEqualTo(2);\n\t\tfoo.readPosition(endIndex + 1);\n\t\tendIndex = matcher.match(foo);\n\t\tassertThat(endIndex).isEqualTo(4);\n\t\tfoo.readPosition(endIndex + 1);\n\t\tendIndex = matcher.match(foo);\n\t\tassertThat(endIndex).isEqualTo(-1);\n\n\t\trelease(foo);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid matcher3(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer foo = stringBuffer(\"foooobar\");\n\n\t\tbyte[] delims = \"oo\".getBytes(StandardCharsets.UTF_8);\n\t\tDataBufferUtils.Matcher matcher = DataBufferUtils.matcher(delims);\n\t\tint endIndex = matcher.match(foo);\n\t\tassertThat(endIndex).isEqualTo(2);\n\t\tfoo.readPosition(endIndex + 1);\n\t\tendIndex = matcher.match(foo);\n\t\tassertThat(endIndex).isEqualTo(4);\n\t\tfoo.readPosition(endIndex + 1);\n\t\tendIndex = matcher.match(foo);\n\t\tassertThat(endIndex).isEqualTo(-1);\n\n\t\trelease(foo);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid propagateContextByteChannel(DataBufferFactory bufferFactory) throws IOException {\n\t\tPath path = Paths.get(this.resource.getURI());\n\t\ttry (SeekableByteChannel out = Files.newByteChannel(this.tempFile, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING)) {\n\t\t\tFlux<DataBuffer> result = DataBufferUtils.read(path, bufferFactory, 1024, StandardOpenOption.READ)\n\t\t\t\t\t.transformDeferredContextual((f, ctx) -> {\n\t\t\t\t\t\tassertThat(ctx.getOrDefault(\"key\", \"EMPTY\")).isEqualTo(\"TEST\");\n\t\t\t\t\t\treturn f;\n\t\t\t\t\t})\n\t\t\t\t\t.transform(f -> DataBufferUtils.write(f, out))\n\t\t\t\t\t.transformDeferredContextual((f, ctx) -> {\n\t\t\t\t\t\tassertThat(ctx.getOrDefault(\"key\", \"EMPTY\")).isEqualTo(\"TEST\");\n\t\t\t\t\t\treturn f;\n\t\t\t\t\t})\n\t\t\t\t\t.contextWrite(Context.of(\"key\", \"TEST\"));\n\n\t\t\tStepVerifier.create(result)\n\t\t\t\t\t.consumeNextWith(DataBufferUtils::release)\n\t\t\t\t\t.verifyComplete();\n\n\n\t\t}\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid propagateContextAsynchronousFileChannel(DataBufferFactory bufferFactory) throws IOException {\n\t\tPath path = Paths.get(this.resource.getURI());\n\t\ttry (AsynchronousFileChannel out = AsynchronousFileChannel.open(this.tempFile, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING)) {\n\t\t\tFlux<DataBuffer> result = DataBufferUtils.read(path, bufferFactory, 1024, StandardOpenOption.READ)\n\t\t\t\t\t.transformDeferredContextual((f, ctx) -> {\n\t\t\t\t\t\tassertThat(ctx.getOrDefault(\"key\", \"EMPTY\")).isEqualTo(\"TEST\");\n\t\t\t\t\t\treturn f;\n\t\t\t\t\t})\n\t\t\t\t\t.transform(f -> DataBufferUtils.write(f, out))\n\t\t\t\t\t.transformDeferredContextual((f, ctx) -> {\n\t\t\t\t\t\tassertThat(ctx.getOrDefault(\"key\", \"EMPTY\")).isEqualTo(\"TEST\");\n\t\t\t\t\t\treturn f;\n\t\t\t\t\t})\n\t\t\t\t\t.contextWrite(Context.of(\"key\", \"TEST\"));\n\n\t\t\tStepVerifier.create(result)\n\t\t\t\t\t.consumeNextWith(DataBufferUtils::release)\n\t\t\t\t\t.verifyComplete();\n\n\n\t\t}\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid propagateContextPath(DataBufferFactory bufferFactory) throws IOException {\n\t\tPath path = Paths.get(this.resource.getURI());\n\t\tPath out = Files.createTempFile(\"data-buffer-utils-tests\", \".tmp\");\n\n\t\tFlux<Void> result = DataBufferUtils.read(path, bufferFactory, 1024, StandardOpenOption.READ)\n\t\t\t\t.transformDeferredContextual((f, ctx) -> {\n\t\t\t\t\tassertThat(ctx.getOrDefault(\"key\", \"EMPTY\")).isEqualTo(\"TEST\");\n\t\t\t\t\treturn f;\n\t\t\t\t})\n\t\t\t\t.transform(f -> DataBufferUtils.write(f, out))\n\t\t\t\t.transformDeferredContextual((f, ctx) -> {\n\t\t\t\t\tassertThat(ctx.getOrDefault(\"key\", \"EMPTY\")).isEqualTo(\"TEST\");\n\t\t\t\t\treturn f;\n\t\t\t\t})\n\t\t\t\t.contextWrite(Context.of(\"key\", \"TEST\"));\n\n\t\tStepVerifier.create(result)\n\t\t\t\t.verifyComplete();\n\t}\n\n\n\tprivate static class ZeroDemandSubscriber extends BaseSubscriber<DataBuffer> {\n\n\t\t@Override\n\t\tprotected void hookOnSubscribe(Subscription subscription) {\n\t\t\t// Just subscribe without requesting\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.io.buffer.DataBufferUtilsTests",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.io.buffer.DataBufferUtilsTests#resource",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.io.buffer.DataBufferUtilsTests#resource",
    "headType": "field",
    "relation": "haveType",
    "tail": "Resource",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.io.buffer.DataBufferUtilsTests",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.io.buffer.DataBufferUtilsTests#tempFile",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.io.buffer.DataBufferUtilsTests#tempFile",
    "headType": "field",
    "relation": "haveType",
    "tail": "Path",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.io.buffer.DataBufferUtilsTests#readInputStream(DataBufferFactory)",
    "headType": "method",
    "relation": "provide",
    "tail": "@ParameterizedDataBufferAllocatingTest\r\nvoid readInputStream(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    Flux<DataBuffer> flux = DataBufferUtils.readInputStream(this.resource::getInputStream, super.bufferFactory, 3);\r\n    verifyReadData(flux);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.io.buffer.DataBufferUtilsTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.io.buffer.DataBufferUtilsTests#readInputStream(DataBufferFactory)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.io.buffer.DataBufferUtilsTests#readInputStream(DataBufferFactory)",
    "headType": "method",
    "relation": "use",
    "tail": "@ParameterizedDataBufferAllocatingTest",
    "tailType": "annotation"
  }
]