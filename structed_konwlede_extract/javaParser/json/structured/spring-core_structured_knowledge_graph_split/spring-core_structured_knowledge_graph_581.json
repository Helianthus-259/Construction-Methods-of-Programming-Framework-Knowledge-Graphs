[
  {
    "head": "org.springframework.cglib.core.CodeEmitter#invoke(MethodInfo,Type)",
    "headType": "method",
    "relation": "provide",
    "tail": "public void invoke(MethodInfo method, Type virtualType) {\r\n    ClassInfo classInfo = method.getClassInfo();\r\n    Type type = classInfo.getType();\r\n    Signature sig = method.getSignature();\r\n    if (sig.getName().equals(Constants.CONSTRUCTOR_NAME)) {\r\n        invoke_constructor(type, sig);\r\n    } else if (TypeUtils.isStatic(method.getModifiers())) {\r\n        invoke_static(type, sig, TypeUtils.isInterface(classInfo.getModifiers()));\r\n    } else if (TypeUtils.isInterface(classInfo.getModifiers())) {\r\n        invoke_interface(type, sig);\r\n    } else {\r\n        invoke_virtual(virtualType, sig);\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.cglib.core.CodeEmitter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.cglib.core.CodeEmitter#invoke(MethodInfo,Type)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.cglib.core.CodeEmitter#invoke(MethodInfo)",
    "headType": "method",
    "relation": "provide",
    "tail": "public void invoke(MethodInfo method) {\r\n    invoke(method, method.getClassInfo().getType());\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.cglib.core.CodeEmitter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.cglib.core.CodeEmitter#invoke(MethodInfo)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.cglib.core.CodeEmitter",
    "headType": "class",
    "relation": "extend",
    "tail": "LocalVariablesSorter",
    "tailType": "class"
  },
  {
    "head": "org.springframework.cglib.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.cglib.core.State",
    "tailType": "class"
  },
  {
    "head": "org.springframework.cglib.core.State",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2003,2004 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.cglib.core;\n\nimport java.util.Arrays;\n\nimport org.springframework.asm.Label;\nimport org.springframework.asm.MethodVisitor;\nimport org.springframework.asm.Type;\n\n/**\n * @author Juozas Baliuka, Chris Nokleberg\n */\n@SuppressWarnings(\"fallthrough\")\npublic class CodeEmitter extends LocalVariablesSorter {\n    private static final Signature BOOLEAN_VALUE =\n      TypeUtils.parseSignature(\"boolean booleanValue()\");\n    private static final Signature CHAR_VALUE =\n      TypeUtils.parseSignature(\"char charValue()\");\n    private static final Signature LONG_VALUE =\n      TypeUtils.parseSignature(\"long longValue()\");\n    private static final Signature DOUBLE_VALUE =\n      TypeUtils.parseSignature(\"double doubleValue()\");\n    private static final Signature FLOAT_VALUE =\n      TypeUtils.parseSignature(\"float floatValue()\");\n    private static final Signature INT_VALUE =\n      TypeUtils.parseSignature(\"int intValue()\");\n    private static final Signature CSTRUCT_NULL =\n      TypeUtils.parseConstructor(\"\");\n    private static final Signature CSTRUCT_STRING =\n      TypeUtils.parseConstructor(\"String\");\n\n    public static final int ADD = Constants.IADD;\n    public static final int MUL = Constants.IMUL;\n    public static final int XOR = Constants.IXOR;\n    public static final int USHR = Constants.IUSHR;\n    public static final int SUB = Constants.ISUB;\n    public static final int DIV = Constants.IDIV;\n    public static final int NEG = Constants.INEG;\n    public static final int REM = Constants.IREM;\n    public static final int AND = Constants.IAND;\n    public static final int OR = Constants.IOR;\n\n    public static final int GT = Constants.IFGT;\n    public static final int LT = Constants.IFLT;\n    public static final int GE = Constants.IFGE;\n    public static final int LE = Constants.IFLE;\n    public static final int NE = Constants.IFNE;\n    public static final int EQ = Constants.IFEQ;\n\n    private ClassEmitter ce;\n    private State state;\n\n    private static class State\n    extends MethodInfo\n    {\n        ClassInfo classInfo;\n        int access;\n        Signature sig;\n        Type[] argumentTypes;\n        int localOffset;\n        Type[] exceptionTypes;\n\n        State(ClassInfo classInfo, int access, Signature sig, Type[] exceptionTypes) {\n            this.classInfo = classInfo;\n            this.access = access;\n            this.sig = sig;\n            this.exceptionTypes = exceptionTypes;\n            localOffset = TypeUtils.isStatic(access) ? 0 : 1;\n            argumentTypes = sig.getArgumentTypes();\n        }\n\n        @Override\n        public ClassInfo getClassInfo() {\n            return classInfo;\n        }\n\n        @Override\n        public int getModifiers() {\n            return access;\n        }\n\n        @Override\n        public Signature getSignature() {\n            return sig;\n        }\n\n        @Override\n        public Type[] getExceptionTypes() {\n            return exceptionTypes;\n        }\n\n    }\n\n    CodeEmitter(ClassEmitter ce, MethodVisitor mv, int access, Signature sig, Type[] exceptionTypes) {\n        super(access, sig.getDescriptor(), mv);\n        this.ce = ce;\n        state = new State(ce.getClassInfo(), access, sig, exceptionTypes);\n    }\n\n    public CodeEmitter(CodeEmitter wrap) {\n        super(wrap);\n        this.ce = wrap.ce;\n        this.state = wrap.state;\n    }\n\n    public boolean isStaticHook() {\n        return false;\n    }\n\n    public Signature getSignature() {\n        return state.sig;\n    }\n\n    public Type getReturnType() {\n        return state.sig.getReturnType();\n    }\n\n    public MethodInfo getMethodInfo() {\n        return state;\n    }\n\n    public ClassEmitter getClassEmitter() {\n        return ce;\n    }\n\n    public void end_method() {\n        visitMaxs(0, 0);\n    }\n\n    public Block begin_block() {\n        return new Block(this);\n    }\n\n    public void catch_exception(Block block, Type exception) {\n        if (block.getEnd() == null) {\n            throw new IllegalStateException(\"end of block is unset\");\n        }\n        mv.visitTryCatchBlock(block.getStart(),\n                              block.getEnd(),\n                              mark(),\n                              exception.getInternalName());\n    }\n\n    public void goTo(Label label) { mv.visitJumpInsn(Constants.GOTO, label); }\n    public void ifnull(Label label) { mv.visitJumpInsn(Constants.IFNULL, label); }\n    public void ifnonnull(Label label) { mv.visitJumpInsn(Constants.IFNONNULL, label); }\n\n    public void if_jump(int mode, Label label) {\n        mv.visitJumpInsn(mode, label);\n    }\n\n    public void if_icmp(int mode, Label label) {\n        if_cmp(Type.INT_TYPE, mode, label);\n    }\n\n    public void if_cmp(Type type, int mode, Label label) {\n        int intOp = -1;\n        int jumpmode = mode;\n        switch (mode) {\n        case GE: jumpmode = LT; break;\n        case LE: jumpmode = GT; break;\n        }\n        switch (type.getSort()) {\n        case Type.LONG:\n            mv.visitInsn(Constants.LCMP);\n            break;\n        case Type.DOUBLE:\n            mv.visitInsn(Constants.DCMPG);\n            break;\n        case Type.FLOAT:\n            mv.visitInsn(Constants.FCMPG);\n            break;\n        case Type.ARRAY:\n        case Type.OBJECT:\n            switch (mode) {\n            case EQ:\n                mv.visitJumpInsn(Constants.IF_ACMPEQ, label);\n                return;\n            case NE:\n                mv.visitJumpInsn(Constants.IF_ACMPNE, label);\n                return;\n            }\n            throw new IllegalArgumentException(\"Bad comparison for type \" + type);\n        default:\n            switch (mode) {\n            case EQ: intOp = Constants.IF_ICMPEQ; break;\n            case NE: intOp = Constants.IF_ICMPNE; break;\n            case GE: swap(); /* fall through */\n            case LT: intOp = Constants.IF_ICMPLT; break;\n            case LE: swap(); /* fall through */\n            case GT: intOp = Constants.IF_ICMPGT; break;\n            }\n            mv.visitJumpInsn(intOp, label);\n            return;\n        }\n        if_jump(jumpmode, label);\n    }\n\n    public void pop() { mv.visitInsn(Constants.POP); }\n    public void pop2() { mv.visitInsn(Constants.POP2); }\n    public void dup() { mv.visitInsn(Constants.DUP); }\n    public void dup2() { mv.visitInsn(Constants.DUP2); }\n    public void dup_x1() { mv.visitInsn(Constants.DUP_X1); }\n    public void dup_x2() { mv.visitInsn(Constants.DUP_X2); }\n    public void dup2_x1() { mv.visitInsn(Constants.DUP2_X1); }\n    public void dup2_x2() { mv.visitInsn(Constants.DUP2_X2); }\n    public void swap() { mv.visitInsn(Constants.SWAP); }\n    public void aconst_null() { mv.visitInsn(Constants.ACONST_NULL); }\n\n    public void swap(Type prev, Type type) {\n        if (type.getSize() == 1) {\n            if (prev.getSize() == 1) {\n                swap(); // same as dup_x1(), pop();\n            } else {\n                dup_x2();\n                pop();\n            }\n        } else {\n            if (prev.getSize() == 1) {\n                dup2_x1();\n                pop2();\n            } else {\n                dup2_x2();\n                pop2();\n            }\n        }\n    }\n\n    public void monitorenter() { mv.visitInsn(Constants.MONITORENTER); }\n    public void monitorexit() { mv.visitInsn(Constants.MONITOREXIT); }\n\n    public void math(int op, Type type) { mv.visitInsn(type.getOpcode(op)); }\n\n    public void array_load(Type type) { mv.visitInsn(type.getOpcode(Constants.IALOAD)); }\n    public void array_store(Type type) { mv.visitInsn(type.getOpcode(Constants.IASTORE)); }\n\n    /**\n     * Casts from one primitive numeric type to another\n     */\n    public void cast_numeric(Type from, Type to) {\n        if (from != to) {\n            if (from == Type.DOUBLE_TYPE) {\n                if (to == Type.FLOAT_TYPE) {\n                    mv.visitInsn(Constants.D2F);\n                } else if (to == Type.LONG_TYPE) {\n                    mv.visitInsn(Constants.D2L);\n                } else {\n                    mv.visitInsn(Constants.D2I);\n                    cast_numeric(Type.INT_TYPE, to);\n                }\n            } else if (from == Type.FLOAT_TYPE) {\n                if (to == Type.DOUBLE_TYPE) {\n                    mv.visitInsn(Constants.F2D);\n                } else if (to == Type.LONG_TYPE) {\n                    mv.visitInsn(Constants.F2L);\n                } else {\n                    mv.visitInsn(Constants.F2I);\n                    cast_numeric(Type.INT_TYPE, to);\n                }\n            } else if (from == Type.LONG_TYPE) {\n                if (to == Type.DOUBLE_TYPE) {\n                    mv.visitInsn(Constants.L2D);\n                } else if (to == Type.FLOAT_TYPE) {\n                    mv.visitInsn(Constants.L2F);\n                } else {\n                    mv.visitInsn(Constants.L2I);\n                    cast_numeric(Type.INT_TYPE, to);\n                }\n            } else {\n                if (to == Type.BYTE_TYPE) {\n                    mv.visitInsn(Constants.I2B);\n                } else if (to == Type.CHAR_TYPE) {\n                    mv.visitInsn(Constants.I2C);\n                } else if (to == Type.DOUBLE_TYPE) {\n                    mv.visitInsn(Constants.I2D);\n                } else if (to == Type.FLOAT_TYPE) {\n                    mv.visitInsn(Constants.I2F);\n                } else if (to == Type.LONG_TYPE) {\n                    mv.visitInsn(Constants.I2L);\n                } else if (to == Type.SHORT_TYPE) {\n                    mv.visitInsn(Constants.I2S);\n                }\n            }\n        }\n    }\n\n    public void push(int i) {\n        if (i < -1) {\n            mv.visitLdcInsn(i);\n        } else if (i <= 5) {\n            mv.visitInsn(TypeUtils.ICONST(i));\n        } else if (i <= Byte.MAX_VALUE) {\n            mv.visitIntInsn(Constants.BIPUSH, i);\n        } else if (i <= Short.MAX_VALUE) {\n            mv.visitIntInsn(Constants.SIPUSH, i);\n        } else {\n            mv.visitLdcInsn(i);\n        }\n    }\n\n    public void push(long value) {\n        if (value == 0L || value == 1L) {\n            mv.visitInsn(TypeUtils.LCONST(value));\n        } else {\n            mv.visitLdcInsn(value);\n        }\n    }\n\n    public void push(float value) {\n        if (value == 0f || value == 1f || value == 2f) {\n            mv.visitInsn(TypeUtils.FCONST(value));\n        } else {\n            mv.visitLdcInsn(value);\n        }\n    }\n    public void push(double value) {\n        if (value == 0d || value == 1d) {\n            mv.visitInsn(TypeUtils.DCONST(value));\n        } else {\n            mv.visitLdcInsn(value);\n        }\n    }\n\n    public void push(String value) {\n        mv.visitLdcInsn(value);\n    }\n\n    public void newarray() {\n        newarray(Constants.TYPE_OBJECT);\n    }\n\n    public void newarray(Type type) {\n        if (TypeUtils.isPrimitive(type)) {\n            mv.visitIntInsn(Constants.NEWARRAY, TypeUtils.NEWARRAY(type));\n        } else {\n            emit_type(Constants.ANEWARRAY, type);\n        }\n    }\n\n    public void arraylength() {\n        mv.visitInsn(Constants.ARRAYLENGTH);\n    }\n\n    public void load_this() {\n        if (TypeUtils.isStatic(state.access)) {\n            throw new IllegalStateException(\"no 'this' pointer within static method\");\n        }\n        mv.visitVarInsn(Constants.ALOAD, 0);\n    }\n\n    /**\n     * Pushes all of the arguments of the current method onto the stack.\n     */\n    public void load_args() {\n        load_args(0, state.argumentTypes.length);\n    }\n\n    /**\n     * Pushes the specified argument of the current method onto the stack.\n     * @param index the zero-based index into the argument list\n     */\n    public void load_arg(int index) {\n        load_local(state.argumentTypes[index],\n                   state.localOffset + skipArgs(index));\n    }\n\n    // zero-based (see load_this)\n    public void load_args(int fromArg, int count) {\n        int pos = state.localOffset + skipArgs(fromArg);\n        for (int i = 0; i < count; i++) {\n            Type t = state.argumentTypes[fromArg + i];\n            load_local(t, pos);\n            pos += t.getSize();\n        }\n    }\n\n    private int skipArgs(int numArgs) {\n        int amount = 0;\n        for (int i = 0; i < numArgs; i++) {\n            amount += state.argumentTypes[i].getSize();\n        }\n        return amount;\n    }\n\n    private void load_local(Type t, int pos) {\n        // TODO: make t == null ok?\n        mv.visitVarInsn(t.getOpcode(Constants.ILOAD), pos);\n    }\n\n    private void store_local(Type t, int pos) {\n        // TODO: make t == null ok?\n        mv.visitVarInsn(t.getOpcode(Constants.ISTORE), pos);\n    }\n\n    public void iinc(Local local, int amount) {\n        mv.visitIincInsn(local.getIndex(), amount);\n    }\n\n    public void store_local(Local local) {\n        store_local(local.getType(), local.getIndex());\n    }\n\n    public void load_local(Local local) {\n        load_local(local.getType(), local.getIndex());\n    }\n\n    public void return_value() {\n        mv.visitInsn(state.sig.getReturnType().getOpcode(Constants.IRETURN));\n    }\n\n    public void getfield(String name) {\n        ClassEmitter.FieldInfo info = ce.getFieldInfo(name);\n        int opcode = TypeUtils.isStatic(info.access) ? Constants.GETSTATIC : Constants.GETFIELD;\n        emit_field(opcode, ce.getClassType(), name, info.type);\n    }\n\n    public void putfield(String name) {\n        ClassEmitter.FieldInfo info = ce.getFieldInfo(name);\n        int opcode = TypeUtils.isStatic(info.access) ? Constants.PUTSTATIC : Constants.PUTFIELD;\n        emit_field(opcode, ce.getClassType(), name, info.type);\n    }\n\n    public void super_getfield(String name, Type type) {\n        emit_field(Constants.GETFIELD, ce.getSuperType(), name, type);\n    }\n\n    public void super_putfield(String name, Type type) {\n        emit_field(Constants.PUTFIELD, ce.getSuperType(), name, type);\n    }\n\n    public void super_getstatic(String name, Type type) {\n        emit_field(Constants.GETSTATIC, ce.getSuperType(), name, type);\n    }\n\n    public void super_putstatic(String name, Type type) {\n        emit_field(Constants.PUTSTATIC, ce.getSuperType(), name, type);\n    }\n\n    public void getfield(Type owner, String name, Type type) {\n        emit_field(Constants.GETFIELD, owner, name, type);\n    }\n\n    public void putfield(Type owner, String name, Type type) {\n        emit_field(Constants.PUTFIELD, owner, name, type);\n    }\n\n    public void getstatic(Type owner, String name, Type type) {\n        emit_field(Constants.GETSTATIC, owner, name, type);\n    }\n\n    public void putstatic(Type owner, String name, Type type) {\n        emit_field(Constants.PUTSTATIC, owner, name, type);\n    }\n\n    // package-protected for EmitUtils, try to fix\n    void emit_field(int opcode, Type ctype, String name, Type ftype) {\n        mv.visitFieldInsn(opcode,\n                          ctype.getInternalName(),\n                          name,\n                          ftype.getDescriptor());\n    }\n\n    public void super_invoke() {\n        super_invoke(state.sig);\n    }\n\n    public void super_invoke(Signature sig) {\n        emit_invoke(Constants.INVOKESPECIAL, ce.getSuperType(), sig, false);\n    }\n\n    public void invoke_constructor(Type type) {\n        invoke_constructor(type, CSTRUCT_NULL);\n    }\n\n    public void super_invoke_constructor() {\n        invoke_constructor(ce.getSuperType());\n    }\n\n    public void invoke_constructor_this() {\n        invoke_constructor(ce.getClassType());\n    }\n\n    private void emit_invoke(int opcode, Type type, Signature sig, boolean isInterface) {\n        if (sig.getName().equals(Constants.CONSTRUCTOR_NAME) &&\n            ((opcode == Constants.INVOKEVIRTUAL) ||\n             (opcode == Constants.INVOKESTATIC))) {\n            // TODO: error\n        }\n        mv.visitMethodInsn(opcode,\n                           type.getInternalName(),\n                           sig.getName(),\n                           sig.getDescriptor(),\n                           isInterface);\n    }\n\n    public void invoke_interface(Type owner, Signature sig) {\n        emit_invoke(Constants.INVOKEINTERFACE, owner, sig, true);\n    }\n\n    public void invoke_virtual(Type owner, Signature sig) {\n        emit_invoke(Constants.INVOKEVIRTUAL, owner, sig, false);\n    }\n\n    @Deprecated\n    public void invoke_static(Type owner, Signature sig) {\n        invoke_static(owner, sig, false);\n    }\n\n    public void invoke_static(Type owner, Signature sig, boolean isInterface) {\n        emit_invoke(Constants.INVOKESTATIC, owner, sig, isInterface);\n    }\n\n    public void invoke_virtual_this(Signature sig) {\n        invoke_virtual(ce.getClassType(), sig);\n    }\n\n    public void invoke_static_this(Signature sig) {\n        invoke_static(ce.getClassType(), sig);\n    }\n\n    public void invoke_constructor(Type type, Signature sig) {\n        emit_invoke(Constants.INVOKESPECIAL, type, sig, false);\n    }\n\n    public void invoke_constructor_this(Signature sig) {\n        invoke_constructor(ce.getClassType(), sig);\n    }\n\n    public void super_invoke_constructor(Signature sig) {\n        invoke_constructor(ce.getSuperType(), sig);\n    }\n\n    public void new_instance_this() {\n        new_instance(ce.getClassType());\n    }\n\n    public void new_instance(Type type) {\n        emit_type(Constants.NEW, type);\n    }\n\n    private void emit_type(int opcode, Type type) {\n        String desc;\n        if (TypeUtils.isArray(type)) {\n            desc = type.getDescriptor();\n        } else {\n            desc = type.getInternalName();\n        }\n        mv.visitTypeInsn(opcode, desc);\n    }\n\n    public void aaload(int index) {\n        push(index);\n        aaload();\n    }\n\n    public void aaload() { mv.visitInsn(Constants.AALOAD); }\n    public void aastore() { mv.visitInsn(Constants.AASTORE); }\n    public void athrow() { mv.visitInsn(Constants.ATHROW); }\n\n    public Label make_label() {\n        return new Label();\n    }\n\n    public Local make_local() {\n        return make_local(Constants.TYPE_OBJECT);\n    }\n\n    public Local make_local(Type type) {\n        return new Local(newLocal(type.getSize()), type);\n    }\n\n    public void checkcast_this() {\n        checkcast(ce.getClassType());\n    }\n\n    public void checkcast(Type type) {\n        if (!type.equals(Constants.TYPE_OBJECT)) {\n            emit_type(Constants.CHECKCAST, type);\n        }\n    }\n\n    public void instance_of(Type type) {\n        emit_type(Constants.INSTANCEOF, type);\n    }\n\n    public void instance_of_this() {\n        instance_of(ce.getClassType());\n    }\n\n    public void process_switch(int[] keys, ProcessSwitchCallback callback) {\n        float density;\n        if (keys.length == 0) {\n            density = 0;\n        } else {\n            density = (float)keys.length / (keys[keys.length - 1] - keys[0] + 1);\n        }\n        process_switch(keys, callback, density >= 0.5f);\n    }\n\n    public void process_switch(int[] keys, ProcessSwitchCallback callback, boolean useTable) {\n        if (!isSorted(keys)) {\n\t\t\tthrow new IllegalArgumentException(\"keys to switch must be sorted ascending\");\n\t\t}\n        Label def = make_label();\n        Label end = make_label();\n\n        try {\n            if (keys.length > 0) {\n                int len = keys.length;\n                int min = keys[0];\n                int max = keys[len - 1];\n                int range = max - min + 1;\n\n                if (useTable) {\n                    Label[] labels = new Label[range];\n                    Arrays.fill(labels, def);\n                    for (int i = 0; i < len; i++) {\n                        labels[keys[i] - min] = make_label();\n                    }\n                    mv.visitTableSwitchInsn(min, max, def, labels);\n                    for (int i = 0; i < range; i++) {\n                        Label label = labels[i];\n                        if (label != def) {\n                            mark(label);\n                            callback.processCase(i + min, end);\n                        }\n                    }\n                } else {\n                    Label[] labels = new Label[len];\n                    for (int i = 0; i < len; i++) {\n                        labels[i] = make_label();\n                    }\n                    mv.visitLookupSwitchInsn(def, keys, labels);\n                    for (int i = 0; i < len; i++) {\n                        mark(labels[i]);\n                        callback.processCase(keys[i], end);\n                    }\n                }\n            }\n\n            mark(def);\n            callback.processDefault();\n            mark(end);\n\n        } catch (RuntimeException | Error e) {\n            throw e;\n        } catch (Exception e) {\n            throw new CodeGenerationException(e);\n        }\n    }\n\n    private static boolean isSorted(int[] keys) {\n        for (int i = 1; i < keys.length; i++) {\n            if (keys[i] < keys[i - 1]) {\n\t\t\t\treturn false;\n\t\t\t}\n        }\n        return true;\n    }\n\n    public void mark(Label label) {\n        mv.visitLabel(label);\n    }\n\n    Label mark() {\n        Label label = make_label();\n        mv.visitLabel(label);\n        return label;\n    }\n\n    public void push(boolean value) {\n        push(value ? 1 : 0);\n    }\n\n    /**\n     * Toggles the integer on the top of the stack from 1 to 0 or vice versa\n     */\n    public void not() {\n        push(1);\n        math(XOR, Type.INT_TYPE);\n    }\n\n    public void throw_exception(Type type, String msg) {\n        new_instance(type);\n        dup();\n        push(msg);\n        invoke_constructor(type, CSTRUCT_STRING);\n        athrow();\n    }\n\n    /**\n     * If the argument is a primitive class, replaces the primitive value\n     * on the top of the stack with the wrapped (Object) equivalent. For\n     * example, char -> Character.\n     * If the class is Void, a null is pushed onto the stack instead.\n     * @param type the class indicating the current type of the top stack value\n     */\n    public void box(Type type) {\n        if (TypeUtils.isPrimitive(type)) {\n            if (type == Type.VOID_TYPE) {\n                aconst_null();\n            } else {\n                Type boxed = TypeUtils.getBoxedType(type);\n                new_instance(boxed);\n                if (type.getSize() == 2) {\n                    // Pp -> Ppo -> oPpo -> ooPpo -> ooPp -> o\n                    dup_x2();\n                    dup_x2();\n                    pop();\n                } else {\n                    // p -> po -> opo -> oop -> o\n                    dup_x1();\n                    swap();\n                }\n                invoke_constructor(boxed, new Signature(Constants.CONSTRUCTOR_NAME, Type.VOID_TYPE, new Type[]{ type }));\n            }\n        }\n    }\n\n    /**\n     * If the argument is a primitive class, replaces the object\n     * on the top of the stack with the unwrapped (primitive)\n     * equivalent. For example, Character -> char.\n     * @param type the class indicating the desired type of the top stack value\n     */\n    public void unbox(Type type) {\n        Type t = Constants.TYPE_NUMBER;\n        Signature sig = null;\n        switch (type.getSort()) {\n        case Type.VOID:\n            return;\n        case Type.CHAR:\n            t = Constants.TYPE_CHARACTER;\n            sig = CHAR_VALUE;\n            break;\n        case Type.BOOLEAN:\n            t = Constants.TYPE_BOOLEAN;\n            sig = BOOLEAN_VALUE;\n            break;\n        case Type.DOUBLE:\n            sig = DOUBLE_VALUE;\n            break;\n        case Type.FLOAT:\n            sig = FLOAT_VALUE;\n            break;\n        case Type.LONG:\n            sig = LONG_VALUE;\n            break;\n        case Type.INT:\n        case Type.SHORT:\n        case Type.BYTE:\n            sig = INT_VALUE;\n        }\n\n        if (sig == null) {\n            checkcast(type);\n        } else {\n            checkcast(t);\n            invoke_virtual(t, sig);\n        }\n    }\n\n    /**\n     * Allocates and fills an Object[] array with the arguments to the\n     * current method. Primitive values are inserted as their boxed\n     * (Object) equivalents.\n     */\n    public void create_arg_array() {\n        /* generates:\n           Object[] args = new Object[]{ arg1, new Integer(arg2) };\n         */\n\n        push(state.argumentTypes.length);\n        newarray();\n        for (int i = 0; i < state.argumentTypes.length; i++) {\n            dup();\n            push(i);\n            load_arg(i);\n            box(state.argumentTypes[i]);\n            aastore();\n        }\n    }\n\n\n    /**\n     * Pushes a zero onto the stack if the argument is a primitive class, or a null otherwise.\n     */\n    public void zero_or_null(Type type) {\n        if (TypeUtils.isPrimitive(type)) {\n            switch (type.getSort()) {\n            case Type.DOUBLE:\n                push(0d);\n                break;\n            case Type.LONG:\n                push(0L);\n                break;\n            case Type.FLOAT:\n                push(0f);\n                break;\n            case Type.VOID:\n                aconst_null();\n            default:\n                push(0);\n            }\n        } else {\n            aconst_null();\n        }\n    }\n\n    /**\n     * Unboxes the object on the top of the stack. If the object is null, the\n     * unboxed primitive value becomes zero.\n     */\n    public void unbox_or_zero(Type type) {\n        if (TypeUtils.isPrimitive(type)) {\n            if (type != Type.VOID_TYPE) {\n                Label nonNull = make_label();\n                Label end = make_label();\n                dup();\n                ifnonnull(nonNull);\n                pop();\n                zero_or_null(type);\n                goTo(end);\n                mark(nonNull);\n                unbox(type);\n                mark(end);\n            }\n        } else {\n            checkcast(type);\n        }\n    }\n\n    @Override\n    public void visitMaxs(int maxStack, int maxLocals) {\n        if (!TypeUtils.isAbstract(state.access)) {\n            mv.visitMaxs(0, 0);\n        }\n    }\n\n    public void invoke(MethodInfo method, Type virtualType) {\n        ClassInfo classInfo = method.getClassInfo();\n        Type type = classInfo.getType();\n        Signature sig = method.getSignature();\n        if (sig.getName().equals(Constants.CONSTRUCTOR_NAME)) {\n            invoke_constructor(type, sig);\n        } else if (TypeUtils.isStatic(method.getModifiers())) {\n            invoke_static(type, sig, TypeUtils.isInterface(classInfo.getModifiers()));\n        } else if (TypeUtils.isInterface(classInfo.getModifiers())) {\n            invoke_interface(type, sig);\n        } else {\n            invoke_virtual(virtualType, sig);\n        }\n    }\n\n    public void invoke(MethodInfo method) {\n        invoke(method, method.getClassInfo().getType());\n    }\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.cglib.core.State",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.core.State#classInfo",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.core.State#classInfo",
    "headType": "field",
    "relation": "haveType",
    "tail": "ClassInfo",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.core.State",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.core.State#access",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.core.State#access",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.core.State",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.core.State#sig",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.core.State#sig",
    "headType": "field",
    "relation": "haveType",
    "tail": "Signature",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.core.State",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.core.State#argumentTypes",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.core.State#argumentTypes",
    "headType": "field",
    "relation": "haveType",
    "tail": "Type",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.core.State",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.core.State#localOffset",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.core.State#localOffset",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.core.State",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.core.State#exceptionTypes",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.core.State#exceptionTypes",
    "headType": "field",
    "relation": "haveType",
    "tail": "Type",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.core.State#getClassInfo()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic ClassInfo getClassInfo() {\r\n    return classInfo;\r\n}",
    "tailType": "method_code"
  }
]