[
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.asm",
    "tailType": "package"
  },
  {
    "head": "org.springframework.asm",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.asm.MethodVisitor",
    "tailType": "class"
  },
  {
    "head": "org.springframework.asm.MethodVisitor",
    "headType": "class",
    "relation": "provide",
    "tail": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage org.springframework.asm;\n\n/**\n * A visitor to visit a Java method. The methods of this class must be called in the following\n * order: ( {@code visitParameter} )* [ {@code visitAnnotationDefault} ] ( {@code visitAnnotation} |\n * {@code visitAnnotableParameterCount} | {@code visitParameterAnnotation} | {@code\n * visitTypeAnnotation} | {@code visitAttribute} )* [ {@code visitCode} ( {@code visitFrame} |\n * {@code visit<i>X</i>Insn} | {@code visitLabel} | {@code visitInsnAnnotation} | {@code\n * visitTryCatchBlock} | {@code visitTryCatchAnnotation} | {@code visitLocalVariable} | {@code\n * visitLocalVariableAnnotation} | {@code visitLineNumber} | {@code visitAttribute} )* {@code\n * visitMaxs} ] {@code visitEnd}. In addition, the {@code visit<i>X</i>Insn} and {@code visitLabel}\n * methods must be called in the sequential order of the bytecode instructions of the visited code,\n * {@code visitInsnAnnotation} must be called <i>after</i> the annotated instruction, {@code\n * visitTryCatchBlock} must be called <i>before</i> the labels passed as arguments have been\n * visited, {@code visitTryCatchBlockAnnotation} must be called <i>after</i> the corresponding try\n * catch block has been visited, and the {@code visitLocalVariable}, {@code\n * visitLocalVariableAnnotation} and {@code visitLineNumber} methods must be called <i>after</i> the\n * labels passed as arguments have been visited. Finally, the {@code visitAttribute} method must be\n * called before {@code visitCode} for non-code attributes, and after it for code attributes.\n *\n * @author Eric Bruneton\n */\npublic abstract class MethodVisitor {\n\n  private static final String REQUIRES_ASM5 = \"This feature requires ASM5\";\n\n  /**\n   * The ASM API version implemented by this visitor. The value of this field must be one of the\n   * {@code ASM}<i>x</i> values in {@link Opcodes}.\n   */\n  protected final int api;\n\n  /**\n   * The method visitor to which this visitor must delegate method calls. May be {@literal null}.\n   */\n  protected MethodVisitor mv;\n\n  /**\n   * Constructs a new {@link MethodVisitor}.\n   *\n   * @param api the ASM API version implemented by this visitor. Must be one of the {@code\n   *     ASM}<i>x</i> values in {@link Opcodes}.\n   */\n  protected MethodVisitor(final int api) {\n    this(api, null);\n  }\n\n  /**\n   * Constructs a new {@link MethodVisitor}.\n   *\n   * @param api the ASM API version implemented by this visitor. Must be one of the {@code\n   *     ASM}<i>x</i> values in {@link Opcodes}.\n   * @param methodVisitor the method visitor to which this visitor must delegate method calls. May\n   *     be null.\n   */\n  protected MethodVisitor(final int api, final MethodVisitor methodVisitor) {\n    if (api != Opcodes.ASM9\n        && api != Opcodes.ASM8\n        && api != Opcodes.ASM7\n        && api != Opcodes.ASM6\n        && api != Opcodes.ASM5\n        && api != Opcodes.ASM4\n        && api != Opcodes.ASM10_EXPERIMENTAL) {\n      throw new IllegalArgumentException(\"Unsupported api \" + api);\n    }\n    // SPRING PATCH: no preview mode check for ASM experimental\n    this.api = api;\n    this.mv = methodVisitor;\n  }\n\n  /**\n   * The method visitor to which this visitor must delegate method calls. May be {@literal null}.\n   *\n   * @return the method visitor to which this visitor must delegate method calls, or {@literal\n   *     null}.\n   */\n  public MethodVisitor getDelegate() {\n    return mv;\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Parameters, annotations and non standard attributes\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Visits a parameter of this method.\n   *\n   * @param name parameter name or {@literal null} if none is provided.\n   * @param access the parameter's access flags, only {@code ACC_FINAL}, {@code ACC_SYNTHETIC}\n   *     or/and {@code ACC_MANDATED} are allowed (see {@link Opcodes}).\n   */\n  public void visitParameter(final String name, final int access) {\n    if (api < Opcodes.ASM5) {\n      throw new UnsupportedOperationException(REQUIRES_ASM5);\n    }\n    if (mv != null) {\n      mv.visitParameter(name, access);\n    }\n  }\n\n  /**\n   * Visits the default value of this annotation interface method.\n   *\n   * @return a visitor to the visit the actual default value of this annotation interface method, or\n   *     {@literal null} if this visitor is not interested in visiting this default value. The\n   *     'name' parameters passed to the methods of this annotation visitor are ignored. Moreover,\n   *     exactly one visit method must be called on this annotation visitor, followed by visitEnd.\n   */\n  public AnnotationVisitor visitAnnotationDefault() {\n    if (mv != null) {\n      return mv.visitAnnotationDefault();\n    }\n    return null;\n  }\n\n  /**\n   * Visits an annotation of this method.\n   *\n   * @param descriptor the class descriptor of the annotation class.\n   * @param visible {@literal true} if the annotation is visible at runtime.\n   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\n   *     interested in visiting this annotation.\n   */\n  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\n    if (mv != null) {\n      return mv.visitAnnotation(descriptor, visible);\n    }\n    return null;\n  }\n\n  /**\n   * Visits an annotation on a type in the method signature.\n   *\n   * @param typeRef a reference to the annotated type. The sort of this type reference must be\n   *     {@link TypeReference#METHOD_TYPE_PARAMETER}, {@link\n   *     TypeReference#METHOD_TYPE_PARAMETER_BOUND}, {@link TypeReference#METHOD_RETURN}, {@link\n   *     TypeReference#METHOD_RECEIVER}, {@link TypeReference#METHOD_FORMAL_PARAMETER} or {@link\n   *     TypeReference#THROWS}. See {@link TypeReference}.\n   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\n   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\n   *     'typeRef' as a whole.\n   * @param descriptor the class descriptor of the annotation class.\n   * @param visible {@literal true} if the annotation is visible at runtime.\n   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\n   *     interested in visiting this annotation.\n   */\n  public AnnotationVisitor visitTypeAnnotation(\n      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\n    if (api < Opcodes.ASM5) {\n      throw new UnsupportedOperationException(REQUIRES_ASM5);\n    }\n    if (mv != null) {\n      return mv.visitTypeAnnotation(typeRef, typePath, descriptor, visible);\n    }\n    return null;\n  }\n\n  /**\n   * Visits the number of method parameters that can have annotations. By default (i.e. when this\n   * method is not called), all the method parameters defined by the method descriptor can have\n   * annotations.\n   *\n   * @param parameterCount the number of method parameters than can have annotations. This number\n   *     must be less or equal than the number of parameter types in the method descriptor. It can\n   *     be strictly less when a method has synthetic parameters and when these parameters are\n   *     ignored when computing parameter indices for the purpose of parameter annotations (see\n   *     https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.18).\n   * @param visible {@literal true} to define the number of method parameters that can have\n   *     annotations visible at runtime, {@literal false} to define the number of method parameters\n   *     that can have annotations invisible at runtime.\n   */\n  public void visitAnnotableParameterCount(final int parameterCount, final boolean visible) {\n    if (mv != null) {\n      mv.visitAnnotableParameterCount(parameterCount, visible);\n    }\n  }\n\n  /**\n   * Visits an annotation of a parameter this method.\n   *\n   * @param parameter the parameter index. This index must be strictly smaller than the number of\n   *     parameters in the method descriptor, and strictly smaller than the parameter count\n   *     specified in {@link #visitAnnotableParameterCount}. Important note: <i>a parameter index i\n   *     is not required to correspond to the i'th parameter descriptor in the method\n   *     descriptor</i>, in particular in case of synthetic parameters (see\n   *     https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.18).\n   * @param descriptor the class descriptor of the annotation class.\n   * @param visible {@literal true} if the annotation is visible at runtime.\n   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\n   *     interested in visiting this annotation.\n   */\n  public AnnotationVisitor visitParameterAnnotation(\n      final int parameter, final String descriptor, final boolean visible) {\n    if (mv != null) {\n      return mv.visitParameterAnnotation(parameter, descriptor, visible);\n    }\n    return null;\n  }\n\n  /**\n   * Visits a non standard attribute of this method.\n   *\n   * @param attribute an attribute.\n   */\n  public void visitAttribute(final Attribute attribute) {\n    if (mv != null) {\n      mv.visitAttribute(attribute);\n    }\n  }\n\n  /** Starts the visit of the method's code, if any (i.e. non abstract method). */\n  public void visitCode() {\n    if (mv != null) {\n      mv.visitCode();\n    }\n  }\n\n  /**\n   * Visits the current state of the local variables and operand stack elements. This method must(*)\n   * be called <i>just before</i> any instruction <b>i</b> that follows an unconditional branch\n   * instruction such as GOTO or THROW, that is the target of a jump instruction, or that starts an\n   * exception handler block. The visited types must describe the values of the local variables and\n   * of the operand stack elements <i>just before</i> <b>i</b> is executed.<br>\n   * <br>\n   * (*) this is mandatory only for classes whose version is greater than or equal to {@link\n   * Opcodes#V1_6}. <br>\n   * <br>\n   * The frames of a method must be given either in expanded form, or in compressed form (all frames\n   * must use the same format, i.e. you must not mix expanded and compressed frames within a single\n   * method):\n   *\n   * <ul>\n   *   <li>In expanded form, all frames must have the F_NEW type.\n   *   <li>In compressed form, frames are basically \"deltas\" from the state of the previous frame:\n   *       <ul>\n   *         <li>{@link Opcodes#F_SAME} representing frame with exactly the same locals as the\n   *             previous frame and with the empty stack.\n   *         <li>{@link Opcodes#F_SAME1} representing frame with exactly the same locals as the\n   *             previous frame and with single value on the stack ( <code>numStack</code> is 1 and\n   *             <code>stack[0]</code> contains value for the type of the stack item).\n   *         <li>{@link Opcodes#F_APPEND} representing frame with current locals are the same as the\n   *             locals in the previous frame, except that additional locals are defined (<code>\n   *             numLocal</code> is 1, 2 or 3 and <code>local</code> elements contains values\n   *             representing added types).\n   *         <li>{@link Opcodes#F_CHOP} representing frame with current locals are the same as the\n   *             locals in the previous frame, except that the last 1-3 locals are absent and with\n   *             the empty stack (<code>numLocal</code> is 1, 2 or 3).\n   *         <li>{@link Opcodes#F_FULL} representing complete frame data.\n   *       </ul>\n   * </ul>\n   *\n   * <br>\n   * In both cases the first frame, corresponding to the method's parameters and access flags, is\n   * implicit and must not be visited. Also, it is illegal to visit two or more frames for the same\n   * code location (i.e., at least one instruction must be visited between two calls to visitFrame).\n   *\n   * @param type the type of this stack map frame. Must be {@link Opcodes#F_NEW} for expanded\n   *     frames, or {@link Opcodes#F_FULL}, {@link Opcodes#F_APPEND}, {@link Opcodes#F_CHOP}, {@link\n   *     Opcodes#F_SAME} or {@link Opcodes#F_APPEND}, {@link Opcodes#F_SAME1} for compressed frames.\n   * @param numLocal the number of local variables in the visited frame. Long and double values\n   *     count for one variable.\n   * @param local the local variable types in this frame. This array must not be modified. Primitive\n   *     types are represented by {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link\n   *     Opcodes#FLOAT}, {@link Opcodes#LONG}, {@link Opcodes#DOUBLE}, {@link Opcodes#NULL} or\n   *     {@link Opcodes#UNINITIALIZED_THIS} (long and double are represented by a single element).\n   *     Reference types are represented by String objects (representing internal names, see {@link\n   *     Type#getInternalName()}), and uninitialized types by Label objects (this label designates\n   *     the NEW instruction that created this uninitialized value).\n   * @param numStack the number of operand stack elements in the visited frame. Long and double\n   *     values count for one stack element.\n   * @param stack the operand stack types in this frame. This array must not be modified. Its\n   *     content has the same format as the \"local\" array.\n   * @throws IllegalStateException if a frame is visited just after another one, without any\n   *     instruction between the two (unless this frame is a Opcodes#F_SAME frame, in which case it\n   *     is silently ignored).\n   */\n  public void visitFrame(\n      final int type,\n      final int numLocal,\n      final Object[] local,\n      final int numStack,\n      final Object[] stack) {\n    if (mv != null) {\n      mv.visitFrame(type, numLocal, local, numStack, stack);\n    }\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Normal instructions\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Visits a zero operand instruction.\n   *\n   * @param opcode the opcode of the instruction to be visited. This opcode is either NOP,\n   *     ACONST_NULL, ICONST_M1, ICONST_0, ICONST_1, ICONST_2, ICONST_3, ICONST_4, ICONST_5,\n   *     LCONST_0, LCONST_1, FCONST_0, FCONST_1, FCONST_2, DCONST_0, DCONST_1, IALOAD, LALOAD,\n   *     FALOAD, DALOAD, AALOAD, BALOAD, CALOAD, SALOAD, IASTORE, LASTORE, FASTORE, DASTORE,\n   *     AASTORE, BASTORE, CASTORE, SASTORE, POP, POP2, DUP, DUP_X1, DUP_X2, DUP2, DUP2_X1, DUP2_X2,\n   *     SWAP, IADD, LADD, FADD, DADD, ISUB, LSUB, FSUB, DSUB, IMUL, LMUL, FMUL, DMUL, IDIV, LDIV,\n   *     FDIV, DDIV, IREM, LREM, FREM, DREM, INEG, LNEG, FNEG, DNEG, ISHL, LSHL, ISHR, LSHR, IUSHR,\n   *     LUSHR, IAND, LAND, IOR, LOR, IXOR, LXOR, I2L, I2F, I2D, L2I, L2F, L2D, F2I, F2L, F2D, D2I,\n   *     D2L, D2F, I2B, I2C, I2S, LCMP, FCMPL, FCMPG, DCMPL, DCMPG, IRETURN, LRETURN, FRETURN,\n   *     DRETURN, ARETURN, RETURN, ARRAYLENGTH, ATHROW, MONITORENTER, or MONITOREXIT.\n   */\n  public void visitInsn(final int opcode) {\n    if (mv != null) {\n      mv.visitInsn(opcode);\n    }\n  }\n\n  /**\n   * Visits an instruction with a single int operand.\n   *\n   * @param opcode the opcode of the instruction to be visited. This opcode is either BIPUSH, SIPUSH\n   *     or NEWARRAY.\n   * @param operand the operand of the instruction to be visited.<br>\n   *     When opcode is BIPUSH, operand value should be between Byte.MIN_VALUE and Byte.MAX_VALUE.\n   *     <br>\n   *     When opcode is SIPUSH, operand value should be between Short.MIN_VALUE and Short.MAX_VALUE.\n   *     <br>\n   *     When opcode is NEWARRAY, operand value should be one of {@link Opcodes#T_BOOLEAN}, {@link\n   *     Opcodes#T_CHAR}, {@link Opcodes#T_FLOAT}, {@link Opcodes#T_DOUBLE}, {@link Opcodes#T_BYTE},\n   *     {@link Opcodes#T_SHORT}, {@link Opcodes#T_INT} or {@link Opcodes#T_LONG}.\n   */\n  public void visitIntInsn(final int opcode, final int operand) {\n    if (mv != null) {\n      mv.visitIntInsn(opcode, operand);\n    }\n  }\n\n  /**\n   * Visits a local variable instruction. A local variable instruction is an instruction that loads\n   * or stores the value of a local variable.\n   *\n   * @param opcode the opcode of the local variable instruction to be visited. This opcode is either\n   *     ILOAD, LLOAD, FLOAD, DLOAD, ALOAD, ISTORE, LSTORE, FSTORE, DSTORE, ASTORE or RET.\n   * @param varIndex the operand of the instruction to be visited. This operand is the index of a\n   *     local variable.\n   */\n  public void visitVarInsn(final int opcode, final int varIndex) {\n    if (mv != null) {\n      mv.visitVarInsn(opcode, varIndex);\n    }\n  }\n\n  /**\n   * Visits a type instruction. A type instruction is an instruction that takes the internal name of\n   * a class as parameter (see {@link Type#getInternalName()}).\n   *\n   * @param opcode the opcode of the type instruction to be visited. This opcode is either NEW,\n   *     ANEWARRAY, CHECKCAST or INSTANCEOF.\n   * @param type the operand of the instruction to be visited. This operand must be the internal\n   *     name of an object or array class (see {@link Type#getInternalName()}).\n   */\n  public void visitTypeInsn(final int opcode, final String type) {\n    if (mv != null) {\n      mv.visitTypeInsn(opcode, type);\n    }\n  }\n\n  /**\n   * Visits a field instruction. A field instruction is an instruction that loads or stores the\n   * value of a field of an object.\n   *\n   * @param opcode the opcode of the type instruction to be visited. This opcode is either\n   *     GETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD.\n   * @param owner the internal name of the field's owner class (see {@link Type#getInternalName()}).\n   * @param name the field's name.\n   * @param descriptor the field's descriptor (see {@link Type}).\n   */\n  public void visitFieldInsn(\n      final int opcode, final String owner, final String name, final String descriptor) {\n    if (mv != null) {\n      mv.visitFieldInsn(opcode, owner, name, descriptor);\n    }\n  }\n\n  /**\n   * Visits a method instruction. A method instruction is an instruction that invokes a method.\n   *\n   * @param opcode the opcode of the type instruction to be visited. This opcode is either\n   *     INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.\n   * @param owner the internal name of the method's owner class (see {@link\n   *     Type#getInternalName()}).\n   * @param name the method's name.\n   * @param descriptor the method's descriptor (see {@link Type}).\n   * @deprecated use {@link #visitMethodInsn(int, String, String, String, boolean)} instead.\n   */\n  @Deprecated\n  public void visitMethodInsn(\n      final int opcode, final String owner, final String name, final String descriptor) {\n    int opcodeAndSource = opcode | (api < Opcodes.ASM5 ? Opcodes.SOURCE_DEPRECATED : 0);\n    visitMethodInsn(opcodeAndSource, owner, name, descriptor, opcode == Opcodes.INVOKEINTERFACE);\n  }\n\n  /**\n   * Visits a method instruction. A method instruction is an instruction that invokes a method.\n   *\n   * @param opcode the opcode of the type instruction to be visited. This opcode is either\n   *     INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.\n   * @param owner the internal name of the method's owner class (see {@link\n   *     Type#getInternalName()}).\n   * @param name the method's name.\n   * @param descriptor the method's descriptor (see {@link Type}).\n   * @param isInterface if the method's owner class is an interface.\n   */\n  public void visitMethodInsn(\n      final int opcode,\n      final String owner,\n      final String name,\n      final String descriptor,\n      final boolean isInterface) {\n    if (api < Opcodes.ASM5 && (opcode & Opcodes.SOURCE_DEPRECATED) == 0) {\n      if (isInterface != (opcode == Opcodes.INVOKEINTERFACE)) {\n        throw new UnsupportedOperationException(\"INVOKESPECIAL/STATIC on interfaces requires ASM5\");\n      }\n      visitMethodInsn(opcode, owner, name, descriptor);\n      return;\n    }\n    if (mv != null) {\n      mv.visitMethodInsn(opcode & ~Opcodes.SOURCE_MASK, owner, name, descriptor, isInterface);\n    }\n  }\n\n  /**\n   * Visits an invokedynamic instruction.\n   *\n   * @param name the method's name.\n   * @param descriptor the method's descriptor (see {@link Type}).\n   * @param bootstrapMethodHandle the bootstrap method.\n   * @param bootstrapMethodArguments the bootstrap method constant arguments. Each argument must be\n   *     an {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String}, {@link\n   *     Type}, {@link Handle} or {@link ConstantDynamic} value. This method is allowed to modify\n   *     the content of the array so a caller should expect that this array may change.\n   */\n  public void visitInvokeDynamicInsn(\n      final String name,\n      final String descriptor,\n      final Handle bootstrapMethodHandle,\n      final Object... bootstrapMethodArguments) {\n    if (api < Opcodes.ASM5) {\n      throw new UnsupportedOperationException(REQUIRES_ASM5);\n    }\n    if (mv != null) {\n      mv.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);\n    }\n  }\n\n  /**\n   * Visits a jump instruction. A jump instruction is an instruction that may jump to another\n   * instruction.\n   *\n   * @param opcode the opcode of the type instruction to be visited. This opcode is either IFEQ,\n   *     IFNE, IFLT, IFGE, IFGT, IFLE, IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT,\n   *     IF_ICMPLE, IF_ACMPEQ, IF_ACMPNE, GOTO, JSR, IFNULL or IFNONNULL.\n   * @param label the operand of the instruction to be visited. This operand is a label that\n   *     designates the instruction to which the jump instruction may jump.\n   */\n  public void visitJumpInsn(final int opcode, final Label label) {\n    if (mv != null) {\n      mv.visitJumpInsn(opcode, label);\n    }\n  }\n\n  /**\n   * Visits a label. A label designates the instruction that will be visited just after it.\n   *\n   * @param label a {@link Label} object.\n   */\n  public void visitLabel(final Label label) {\n    if (mv != null) {\n      mv.visitLabel(label);\n    }\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Special instructions\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Visits a LDC instruction. Note that new constant types may be added in future versions of the\n   * Java Virtual Machine. To easily detect new constant types, implementations of this method\n   * should check for unexpected constant types, like this:\n   *\n   * <pre>\n   * if (cst instanceof Integer) {\n   *     // ...\n   * } else if (cst instanceof Float) {\n   *     // ...\n   * } else if (cst instanceof Long) {\n   *     // ...\n   * } else if (cst instanceof Double) {\n   *     // ...\n   * } else if (cst instanceof String) {\n   *     // ...\n   * } else if (cst instanceof Type) {\n   *     int sort = ((Type) cst).getSort();\n   *     if (sort == Type.OBJECT) {\n   *         // ...\n   *     } else if (sort == Type.ARRAY) {\n   *         // ...\n   *     } else if (sort == Type.METHOD) {\n   *         // ...\n   *     } else {\n   *         // throw an exception\n   *     }\n   * } else if (cst instanceof Handle) {\n   *     // ...\n   * } else if (cst instanceof ConstantDynamic) {\n   *     // ...\n   * } else {\n   *     // throw an exception\n   * }\n   * </pre>\n   *\n   * @param value the constant to be loaded on the stack. This parameter must be a non null {@link\n   *     Integer}, a {@link Float}, a {@link Long}, a {@link Double}, a {@link String}, a {@link\n   *     Type} of OBJECT or ARRAY sort for {@code .class} constants, for classes whose version is\n   *     49, a {@link Type} of METHOD sort for MethodType, a {@link Handle} for MethodHandle\n   *     constants, for classes whose version is 51 or a {@link ConstantDynamic} for a constant\n   *     dynamic for classes whose version is 55.\n   */\n  public void visitLdcInsn(final Object value) {\n    if (api < Opcodes.ASM5\n        && (value instanceof Handle\n            || (value instanceof Type && ((Type) value).getSort() == Type.METHOD))) {\n      throw new UnsupportedOperationException(REQUIRES_ASM5);\n    }\n    if (api < Opcodes.ASM7 && value instanceof ConstantDynamic) {\n      throw new UnsupportedOperationException(\"This feature requires ASM7\");\n    }\n    if (mv != null) {\n      mv.visitLdcInsn(value);\n    }\n  }\n\n  /**\n   * Visits an IINC instruction.\n   *\n   * @param varIndex index of the local variable to be incremented.\n   * @param increment amount to increment the local variable by.\n   */\n  public void visitIincInsn(final int varIndex, final int increment) {\n    if (mv != null) {\n      mv.visitIincInsn(varIndex, increment);\n    }\n  }\n\n  /**\n   * Visits a TABLESWITCH instruction.\n   *\n   * @param min the minimum key value.\n   * @param max the maximum key value.\n   * @param dflt beginning of the default handler block.\n   * @param labels beginnings of the handler blocks. {@code labels[i]} is the beginning of the\n   *     handler block for the {@code min + i} key.\n   */\n  public void visitTableSwitchInsn(\n      final int min, final int max, final Label dflt, final Label... labels) {\n    if (mv != null) {\n      mv.visitTableSwitchInsn(min, max, dflt, labels);\n    }\n  }\n\n  /**\n   * Visits a LOOKUPSWITCH instruction.\n   *\n   * @param dflt beginning of the default handler block.\n   * @param keys the values of the keys.\n   * @param labels beginnings of the handler blocks. {@code labels[i]} is the beginning of the\n   *     handler block for the {@code keys[i]} key.\n   */\n  public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {\n    if (mv != null) {\n      mv.visitLookupSwitchInsn(dflt, keys, labels);\n    }\n  }\n\n  /**\n   * Visits a MULTIANEWARRAY instruction.\n   *\n   * @param descriptor an array type descriptor (see {@link Type}).\n   * @param numDimensions the number of dimensions of the array to allocate.\n   */\n  public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {\n    if (mv != null) {\n      mv.visitMultiANewArrayInsn(descriptor, numDimensions);\n    }\n  }\n\n  /**\n   * Visits an annotation on an instruction. This method must be called just <i>after</i> the\n   * annotated instruction. It can be called several times for the same instruction.\n   *\n   * @param typeRef a reference to the annotated type. The sort of this type reference must be\n   *     {@link TypeReference#INSTANCEOF}, {@link TypeReference#NEW}, {@link\n   *     TypeReference#CONSTRUCTOR_REFERENCE}, {@link TypeReference#METHOD_REFERENCE}, {@link\n   *     TypeReference#CAST}, {@link TypeReference#CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT}, {@link\n   *     TypeReference#METHOD_INVOCATION_TYPE_ARGUMENT}, {@link\n   *     TypeReference#CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or {@link\n   *     TypeReference#METHOD_REFERENCE_TYPE_ARGUMENT}. See {@link TypeReference}.\n   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\n   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\n   *     'typeRef' as a whole.\n   * @param descriptor the class descriptor of the annotation class.\n   * @param visible {@literal true} if the annotation is visible at runtime.\n   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\n   *     interested in visiting this annotation.\n   */\n  public AnnotationVisitor visitInsnAnnotation(\n      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\n    if (api < Opcodes.ASM5) {\n      throw new UnsupportedOperationException(REQUIRES_ASM5);\n    }\n    if (mv != null) {\n      return mv.visitInsnAnnotation(typeRef, typePath, descriptor, visible);\n    }\n    return null;\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Exceptions table entries, debug information, max stack and max locals\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Visits a try catch block.\n   *\n   * @param start the beginning of the exception handler's scope (inclusive).\n   * @param end the end of the exception handler's scope (exclusive).\n   * @param handler the beginning of the exception handler's code.\n   * @param type the internal name of the type of exceptions handled by the handler (see {@link\n   *     Type#getInternalName()}), or {@literal null} to catch any exceptions (for \"finally\"\n   *     blocks).\n   * @throws IllegalArgumentException if one of the labels has already been visited by this visitor\n   *     (by the {@link #visitLabel} method).\n   */\n  public void visitTryCatchBlock(\n      final Label start, final Label end, final Label handler, final String type) {\n    if (mv != null) {\n      mv.visitTryCatchBlock(start, end, handler, type);\n    }\n  }\n\n  /**\n   * Visits an annotation on an exception handler type. This method must be called <i>after</i> the\n   * {@link #visitTryCatchBlock} for the annotated exception handler. It can be called several times\n   * for the same exception handler.\n   *\n   * @param typeRef a reference to the annotated type. The sort of this type reference must be\n   *     {@link TypeReference#EXCEPTION_PARAMETER}. See {@link TypeReference}.\n   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\n   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\n   *     'typeRef' as a whole.\n   * @param descriptor the class descriptor of the annotation class.\n   * @param visible {@literal true} if the annotation is visible at runtime.\n   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\n   *     interested in visiting this annotation.\n   */\n  public AnnotationVisitor visitTryCatchAnnotation(\n      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\n    if (api < Opcodes.ASM5) {\n      throw new UnsupportedOperationException(REQUIRES_ASM5);\n    }\n    if (mv != null) {\n      return mv.visitTryCatchAnnotation(typeRef, typePath, descriptor, visible);\n    }\n    return null;\n  }\n\n  /**\n   * Visits a local variable declaration.\n   *\n   * @param name the name of a local variable.\n   * @param descriptor the type descriptor of this local variable.\n   * @param signature the type signature of this local variable. May be {@literal null} if the local\n   *     variable type does not use generic types.\n   * @param start the first instruction corresponding to the scope of this local variable\n   *     (inclusive).\n   * @param end the last instruction corresponding to the scope of this local variable (exclusive).\n   * @param index the local variable's index.\n   * @throws IllegalArgumentException if one of the labels has not already been visited by this\n   *     visitor (by the {@link #visitLabel} method).\n   */\n  public void visitLocalVariable(\n      final String name,\n      final String descriptor,\n      final String signature,\n      final Label start,\n      final Label end,\n      final int index) {\n    if (mv != null) {\n      mv.visitLocalVariable(name, descriptor, signature, start, end, index);\n    }\n  }\n\n  /**\n   * Visits an annotation on a local variable type.\n   *\n   * @param typeRef a reference to the annotated type. The sort of this type reference must be\n   *     {@link TypeReference#LOCAL_VARIABLE} or {@link TypeReference#RESOURCE_VARIABLE}. See {@link\n   *     TypeReference}.\n   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\n   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\n   *     'typeRef' as a whole.\n   * @param start the fist instructions corresponding to the continuous ranges that make the scope\n   *     of this local variable (inclusive).\n   * @param end the last instructions corresponding to the continuous ranges that make the scope of\n   *     this local variable (exclusive). This array must have the same size as the 'start' array.\n   * @param index the local variable's index in each range. This array must have the same size as\n   *     the 'start' array.\n   * @param descriptor the class descriptor of the annotation class.\n   * @param visible {@literal true} if the annotation is visible at runtime.\n   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\n   *     interested in visiting this annotation.\n   */\n  public AnnotationVisitor visitLocalVariableAnnotation(\n      final int typeRef,\n      final TypePath typePath,\n      final Label[] start,\n      final Label[] end,\n      final int[] index,\n      final String descriptor,\n      final boolean visible) {\n    if (api < Opcodes.ASM5) {\n      throw new UnsupportedOperationException(REQUIRES_ASM5);\n    }\n    if (mv != null) {\n      return mv.visitLocalVariableAnnotation(\n          typeRef, typePath, start, end, index, descriptor, visible);\n    }\n    return null;\n  }\n\n  /**\n   * Visits a line number declaration.\n   *\n   * @param line a line number. This number refers to the source file from which the class was\n   *     compiled.\n   * @param start the first instruction corresponding to this line number.\n   * @throws IllegalArgumentException if {@code start} has not already been visited by this visitor\n   *     (by the {@link #visitLabel} method).\n   */\n  public void visitLineNumber(final int line, final Label start) {\n    if (mv != null) {\n      mv.visitLineNumber(line, start);\n    }\n  }\n\n  /**\n   * Visits the maximum stack size and the maximum number of local variables of the method.\n   *\n   * @param maxStack maximum stack size of the method.\n   * @param maxLocals maximum number of local variables for the method.\n   */\n  public void visitMaxs(final int maxStack, final int maxLocals) {\n    if (mv != null) {\n      mv.visitMaxs(maxStack, maxLocals);\n    }\n  }\n\n  /**\n   * Visits the end of the method. This method, which is the last one to be called, is used to\n   * inform the visitor that all the annotations and attributes of the method have been visited.\n   */\n  public void visitEnd() {\n    if (mv != null) {\n      mv.visitEnd();\n    }\n  }\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.asm.MethodVisitor",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.MethodVisitor#REQUIRES_ASM5",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.MethodVisitor#REQUIRES_ASM5",
    "headType": "field",
    "relation": "haveType",
    "tail": "String",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.MethodVisitor",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.MethodVisitor#api",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.MethodVisitor#api",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.MethodVisitor",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.MethodVisitor#mv",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.MethodVisitor#mv",
    "headType": "field",
    "relation": "haveType",
    "tail": "MethodVisitor",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.MethodVisitor#getDelegate()",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * The method visitor to which this visitor must delegate method calls. May be {@literal null}.\r\n *\r\n * @return the method visitor to which this visitor must delegate method calls, or {@literal\r\n *     null}.\r\n */\r\npublic MethodVisitor getDelegate() {\r\n    return mv;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.MethodVisitor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.MethodVisitor#getDelegate()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.MethodVisitor#visitParameter(String,int)",
    "headType": "method",
    "relation": "provide",
    "tail": "// -----------------------------------------------------------------------------------------------\r\n// Parameters, annotations and non standard attributes\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Visits a parameter of this method.\r\n *\r\n * @param name parameter name or {@literal null} if none is provided.\r\n * @param access the parameter's access flags, only {@code ACC_FINAL}, {@code ACC_SYNTHETIC}\r\n *     or/and {@code ACC_MANDATED} are allowed (see {@link Opcodes}).\r\n */\r\npublic void visitParameter(final String name, final int access) {\r\n    if (api < Opcodes.ASM5) {\r\n        throw new UnsupportedOperationException(REQUIRES_ASM5);\r\n    }\r\n    if (mv != null) {\r\n        mv.visitParameter(name, access);\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.MethodVisitor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.MethodVisitor#visitParameter(String,int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.MethodVisitor#visitAnnotationDefault()",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Visits the default value of this annotation interface method.\r\n *\r\n * @return a visitor to the visit the actual default value of this annotation interface method, or\r\n *     {@literal null} if this visitor is not interested in visiting this default value. The\r\n *     'name' parameters passed to the methods of this annotation visitor are ignored. Moreover,\r\n *     exactly one visit method must be called on this annotation visitor, followed by visitEnd.\r\n */\r\npublic AnnotationVisitor visitAnnotationDefault() {\r\n    if (mv != null) {\r\n        return mv.visitAnnotationDefault();\r\n    }\r\n    return null;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.MethodVisitor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.MethodVisitor#visitAnnotationDefault()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.MethodVisitor#visitAnnotation(String,boolean)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Visits an annotation of this method.\r\n *\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param visible {@literal true} if the annotation is visible at runtime.\r\n * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\r\n *     interested in visiting this annotation.\r\n */\r\npublic AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\r\n    if (mv != null) {\r\n        return mv.visitAnnotation(descriptor, visible);\r\n    }\r\n    return null;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.MethodVisitor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.MethodVisitor#visitAnnotation(String,boolean)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.MethodVisitor#visitTypeAnnotation(int,TypePath,String,boolean)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Visits an annotation on a type in the method signature.\r\n *\r\n * @param typeRef a reference to the annotated type. The sort of this type reference must be\r\n *     {@link TypeReference#METHOD_TYPE_PARAMETER}, {@link\r\n *     TypeReference#METHOD_TYPE_PARAMETER_BOUND}, {@link TypeReference#METHOD_RETURN}, {@link\r\n *     TypeReference#METHOD_RECEIVER}, {@link TypeReference#METHOD_FORMAL_PARAMETER} or {@link\r\n *     TypeReference#THROWS}. See {@link TypeReference}.\r\n * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\r\n *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\r\n *     'typeRef' as a whole.\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param visible {@literal true} if the annotation is visible at runtime.\r\n * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\r\n *     interested in visiting this annotation.\r\n */\r\npublic AnnotationVisitor visitTypeAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\r\n    if (api < Opcodes.ASM5) {\r\n        throw new UnsupportedOperationException(REQUIRES_ASM5);\r\n    }\r\n    if (mv != null) {\r\n        return mv.visitTypeAnnotation(typeRef, typePath, descriptor, visible);\r\n    }\r\n    return null;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.MethodVisitor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.MethodVisitor#visitTypeAnnotation(int,TypePath,String,boolean)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.MethodVisitor#visitAnnotableParameterCount(int,boolean)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Visits the number of method parameters that can have annotations. By default (i.e. when this\r\n * method is not called), all the method parameters defined by the method descriptor can have\r\n * annotations.\r\n *\r\n * @param parameterCount the number of method parameters than can have annotations. This number\r\n *     must be less or equal than the number of parameter types in the method descriptor. It can\r\n *     be strictly less when a method has synthetic parameters and when these parameters are\r\n *     ignored when computing parameter indices for the purpose of parameter annotations (see\r\n *     https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.18).\r\n * @param visible {@literal true} to define the number of method parameters that can have\r\n *     annotations visible at runtime, {@literal false} to define the number of method parameters\r\n *     that can have annotations invisible at runtime.\r\n */\r\npublic void visitAnnotableParameterCount(final int parameterCount, final boolean visible) {\r\n    if (mv != null) {\r\n        mv.visitAnnotableParameterCount(parameterCount, visible);\r\n    }\r\n}",
    "tailType": "method_code"
  }
]