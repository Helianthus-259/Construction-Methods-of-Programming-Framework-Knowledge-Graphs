[
  {
    "head": "org.springframework.cglib.proxy.BridgedFinder#visitMethod(int,String,String,String,String[])",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\r\n    Signature sig = new Signature(name, desc);\r\n    if (eligibleMethods.remove(sig)) {\r\n        currentMethod = sig;\r\n        return new MethodVisitor(Constants.ASM_API) {\r\n\r\n            @Override\r\n            public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\r\n                if ((opcode == Opcodes.INVOKESPECIAL || (itf && opcode == Opcodes.INVOKEINTERFACE)) && currentMethod != null) {\r\n                    Signature target = new Signature(name, desc);\r\n                    // If the target signature is the same as the current,\r\n                    // we shouldn't change our bridge becaues invokespecial\r\n                    // is the only way to make progress (otherwise we'll\r\n                    // get infinite recursion).  This would typically\r\n                    // only happen when a bridge method is created to widen\r\n                    // the visibility of a superclass' method.\r\n                    if (!target.equals(currentMethod)) {\r\n                        resolved.put(currentMethod, target);\r\n                    }\r\n                    currentMethod = null;\r\n                }\r\n            }\r\n        };\r\n    } else {\r\n        return null;\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.cglib.proxy.BridgedFinder",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.cglib.proxy.BridgedFinder#visitMethod(int,String,String,String,String[])",
    "tailType": "method"
  },
  {
    "head": "org.springframework.cglib.proxy.BridgedFinder#visitMethod(int,String,String,String,String[])",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.cglib.proxy.BridgedFinder",
    "headType": "class",
    "relation": "extend",
    "tail": "ClassVisitor",
    "tailType": "class"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.cglib.proxy",
    "tailType": "package"
  },
  {
    "head": "org.springframework.cglib.proxy",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.cglib.proxy.Callback",
    "tailType": "class"
  },
  {
    "head": "org.springframework.cglib.proxy.Callback",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2003 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.cglib.proxy;\n\n/**\n * All callback interfaces used by {@link Enhancer} extend this interface.\n * @see MethodInterceptor\n * @see NoOp\n * @see LazyLoader\n * @see Dispatcher\n * @see InvocationHandler\n * @see FixedValue\n */\npublic interface Callback\n{\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.cglib.proxy",
    "tailType": "package"
  },
  {
    "head": "org.springframework.cglib.proxy",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.cglib.proxy.CallbackFilter",
    "tailType": "class"
  },
  {
    "head": "org.springframework.cglib.proxy.CallbackFilter",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2003,2004 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.cglib.proxy;\n\nimport java.lang.reflect.Method;\n\n/**\n * Map methods of subclasses generated by {@link Enhancer} to a particular\n * callback. The type of the callbacks chosen for each method affects\n * the bytecode generated for that method in the subclass, and cannot\n * change for the life of the class.\n * <p>Note: {@link CallbackFilter} implementations are supposed to be\n * lightweight as cglib might keep {@link CallbackFilter} objects\n * alive to enable caching of generated classes. Prefer using {@code static}\n * classes for implementation of {@link CallbackFilter}.</p>\n */\npublic interface CallbackFilter {\n    /**\n     * Map a method to a callback.\n     * @param method the intercepted method\n     * @return the index into the array of callbacks (as specified by {@link Enhancer#setCallbacks}) to use for the method,\n     */\n    int accept(Method method);\n\n    /**\n     * The <code>CallbackFilter</code> in use affects which cached class\n     * the <code>Enhancer</code> will use, so this is a reminder that\n     * you should correctly implement <code>equals</code> and\n     * <code>hashCode</code> for custom <code>CallbackFilter</code>\n     * implementations in order to improve performance.\n    */\n    @Override\n\tboolean equals(Object o);\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.cglib.proxy.CallbackFilter#accept(Method)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Map a method to a callback.\r\n * @param method the intercepted method\r\n * @return the index into the array of callbacks (as specified by {@link Enhancer#setCallbacks}) to use for the method,\r\n */\r\nint accept(Method method);",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.cglib.proxy.CallbackFilter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.cglib.proxy.CallbackFilter#accept(Method)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.cglib.proxy.CallbackFilter#equals(Object)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * The <code>CallbackFilter</code> in use affects which cached class\r\n * the <code>Enhancer</code> will use, so this is a reminder that\r\n * you should correctly implement <code>equals</code> and\r\n * <code>hashCode</code> for custom <code>CallbackFilter</code>\r\n * implementations in order to improve performance.\r\n */\r\n@Override\r\nboolean equals(Object o);",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.cglib.proxy.CallbackFilter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.cglib.proxy.CallbackFilter#equals(Object)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.cglib.proxy.CallbackFilter#equals(Object)",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.cglib.proxy",
    "tailType": "package"
  },
  {
    "head": "org.springframework.cglib.proxy",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.cglib.proxy.CallbackGenerator",
    "tailType": "class"
  },
  {
    "head": "org.springframework.cglib.proxy.CallbackGenerator",
    "headType": "class",
    "relation": "use",
    "tail": "@SuppressWarnings",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.cglib.proxy.CallbackGenerator",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2003,2004 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.cglib.proxy;\n\nimport java.util.List;\n\nimport org.springframework.cglib.core.ClassEmitter;\nimport org.springframework.cglib.core.CodeEmitter;\nimport org.springframework.cglib.core.MethodInfo;\nimport org.springframework.cglib.core.Signature;\n\n@SuppressWarnings({\"rawtypes\", \"unchecked\"})\ninterface CallbackGenerator\n{\n    void generate(ClassEmitter ce, Context context, List methods) throws Exception;\n    void generateStatic(CodeEmitter e, Context context, List methods) throws Exception;\n\n    interface Context\n    {\n        ClassLoader getClassLoader();\n        CodeEmitter beginMethod(ClassEmitter ce, MethodInfo method);\n        int getOriginalModifiers(MethodInfo method);\n        int getIndex(MethodInfo method);\n        void emitCallback(CodeEmitter ce, int index);\n        Signature getImplSignature(MethodInfo method);\n        void emitLoadArgsAndInvoke(CodeEmitter e, MethodInfo method);\n    }\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.cglib.proxy.CallbackGenerator#generate(ClassEmitter,Context,List)",
    "headType": "method",
    "relation": "provide",
    "tail": "void generate(ClassEmitter ce, Context context, List methods) throws Exception;",
    "tailType": "method_code"
  }
]