[
  {
    "head": "org.springframework.cglib.proxy.FastClassInfo",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.proxy.FastClassInfo#f1",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.proxy.FastClassInfo#f1",
    "headType": "field",
    "relation": "haveType",
    "tail": "FastClass",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.proxy.FastClassInfo",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.proxy.FastClassInfo#f2",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.proxy.FastClassInfo#f2",
    "headType": "field",
    "relation": "haveType",
    "tail": "FastClass",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.proxy.FastClassInfo",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.proxy.FastClassInfo#i1",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.proxy.FastClassInfo#i1",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.proxy.FastClassInfo",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.proxy.FastClassInfo#i2",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.proxy.FastClassInfo#i2",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.proxy",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.cglib.proxy.CreateInfo",
    "tailType": "class"
  },
  {
    "head": "org.springframework.cglib.proxy.CreateInfo",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2003,2004 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.cglib.proxy;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\nimport org.springframework.cglib.core.AbstractClassGenerator;\nimport org.springframework.cglib.core.CodeGenerationException;\nimport org.springframework.cglib.core.GeneratorStrategy;\nimport org.springframework.cglib.core.NamingPolicy;\nimport org.springframework.cglib.core.Signature;\nimport org.springframework.cglib.reflect.FastClass;\n\n/**\n * Classes generated by {@link Enhancer} pass this object to the\n * registered {@link MethodInterceptor} objects when an intercepted method is invoked. It can\n * be used to either invoke the original method, or call the same method on a different\n * object of the same type.\n * @version $Id: MethodProxy.java,v 1.16 2009/01/11 20:09:48 herbyderby Exp $\n */\n@SuppressWarnings({\"rawtypes\", \"unchecked\"})\npublic class MethodProxy {\n\n\tprivate Signature sig1;\n\n\tprivate Signature sig2;\n\n\tprivate CreateInfo createInfo;\n\n\tprivate final Object initLock = new Object();\n\n\tprivate volatile FastClassInfo fastClassInfo;\n\n\t/**\n\t * For internal use by {@link Enhancer} only; see the {@link org.springframework.cglib.reflect.FastMethod} class\n\t * for similar functionality.\n\t */\n\tpublic static MethodProxy create(Class c1, Class c2, String desc, String name1, String name2) {\n\t\tMethodProxy proxy = new MethodProxy();\n\t\tproxy.sig1 = new Signature(name1, desc);\n\t\tproxy.sig2 = new Signature(name2, desc);\n\t\tproxy.createInfo = new CreateInfo(c1, c2);\n\n\t\t// SPRING PATCH BEGIN\n\t\tif (c1 != Object.class && c1.isAssignableFrom(c2.getSuperclass()) && !Factory.class.isAssignableFrom(c2)) {\n\t\t\t// Try early initialization for overridden methods on specifically purposed subclasses\n\t\t\ttry {\n\t\t\t\tproxy.init();\n\t\t\t}\n\t\t\tcatch (CodeGenerationException ex) {\n\t\t\t\t// Ignore - to be retried when actually needed later on (possibly not at all)\n\t\t\t}\n\t\t}\n\t\t// SPRING PATCH END\n\n\t\treturn proxy;\n\t}\n\n\tprivate void init() {\n\t\t/*\n\t\t * Using a volatile invariant allows us to initialize the FastClass and\n\t\t * method index pairs atomically.\n\t\t *\n\t\t * Double-checked locking is safe with volatile in Java 5.  Before 1.5 this\n\t\t * code could allow fastClassInfo to be instantiated more than once, which\n\t\t * appears to be benign.\n\t\t */\n\t\tif (fastClassInfo == null) {\n\t\t\tsynchronized (initLock) {\n\t\t\t\tif (fastClassInfo == null) {\n\t\t\t\t\tCreateInfo ci = createInfo;\n\n\t\t\t\t\tFastClassInfo fci = new FastClassInfo();\n\t\t\t\t\tfci.f1 = helper(ci, ci.c1);\n\t\t\t\t\tfci.f2 = helper(ci, ci.c2);\n\t\t\t\t\tfci.i1 = fci.f1.getIndex(sig1);\n\t\t\t\t\tfci.i2 = fci.f2.getIndex(sig2);\n\t\t\t\t\tfastClassInfo = fci;\n\t\t\t\t\tcreateInfo = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate static class FastClassInfo {\n\n\t\tFastClass f1;\n\n\t\tFastClass f2;\n\n\t\tint i1;\n\n\t\tint i2;\n\t}\n\n\n\tprivate static class CreateInfo {\n\n\t\tClass c1;\n\n\t\tClass c2;\n\n\t\tNamingPolicy namingPolicy;\n\n\t\tGeneratorStrategy strategy;\n\n\t\tboolean attemptLoad;\n\n\t\tpublic CreateInfo(Class c1, Class c2) {\n\t\t\tthis.c1 = c1;\n\t\t\tthis.c2 = c2;\n\t\t\tAbstractClassGenerator fromEnhancer = AbstractClassGenerator.getCurrent();\n\t\t\tif (fromEnhancer != null) {\n\t\t\t\tnamingPolicy = fromEnhancer.getNamingPolicy();\n\t\t\t\tstrategy = fromEnhancer.getStrategy();\n\t\t\t\tattemptLoad = fromEnhancer.getAttemptLoad();\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate static FastClass helper(CreateInfo ci, Class type) {\n\t\tFastClass.Generator g = new FastClass.Generator();\n\t\tg.setType(type);\n\t\t// SPRING PATCH BEGIN\n\t\tg.setContextClass(type);\n\t\t// SPRING PATCH END\n\t\tg.setClassLoader(ci.c2.getClassLoader());\n\t\tg.setNamingPolicy(ci.namingPolicy);\n\t\tg.setStrategy(ci.strategy);\n\t\tg.setAttemptLoad(ci.attemptLoad);\n\t\treturn g.create();\n\t}\n\n\tprivate MethodProxy() {\n\t}\n\n\t/**\n\t * Return the signature of the proxied method.\n\t */\n\tpublic Signature getSignature() {\n\t\treturn sig1;\n\t}\n\n\t/**\n\t * Return the name of the synthetic method created by CGLIB which is\n\t * used by {@link #invokeSuper} to invoke the superclass\n\t * (non-intercepted) method implementation. The parameter types are\n\t * the same as the proxied method.\n\t */\n\tpublic String getSuperName() {\n\t\treturn sig2.getName();\n\t}\n\n\t/**\n\t * Return the {@link org.springframework.cglib.reflect.FastClass} method index\n\t * for the method used by {@link #invokeSuper}. This index uniquely\n\t * identifies the method within the generated proxy, and therefore\n\t * can be useful to reference external metadata.\n\t * @see #getSuperName\n\t */\n\tpublic int getSuperIndex() {\n\t\tinit();\n\t\treturn fastClassInfo.i2;\n\t}\n\n\t// For testing\n\tFastClass getFastClass() {\n\t\tinit();\n\t\treturn fastClassInfo.f1;\n\t}\n\n\t// For testing\n\tFastClass getSuperFastClass() {\n\t\tinit();\n\t\treturn fastClassInfo.f2;\n\t}\n\n\t/**\n\t * Return the <code>MethodProxy</code> used when intercepting the method\n\t * matching the given signature.\n\t * @param type the class generated by Enhancer\n\t * @param sig the signature to match\n\t * @return the MethodProxy instance, or null if no applicable matching method is found\n\t * @throws IllegalArgumentException if the Class was not created by Enhancer or does not use a MethodInterceptor\n\t */\n\tpublic static MethodProxy find(Class type, Signature sig) {\n\t\ttry {\n\t\t\tMethod m = type.getDeclaredMethod(MethodInterceptorGenerator.FIND_PROXY_NAME,\n\t\t\t\t\tMethodInterceptorGenerator.FIND_PROXY_TYPES);\n\t\t\treturn (MethodProxy) m.invoke(null, new Object[]{sig});\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\tthrow new IllegalArgumentException(\"Class \" + type + \" does not use a MethodInterceptor\");\n\t\t}\n\t\tcatch (IllegalAccessException | InvocationTargetException ex) {\n\t\t\tthrow new CodeGenerationException(ex);\n\t\t}\n\t}\n\n\t/**\n\t * Invoke the original method, on a different object of the same type.\n\t * @param obj the compatible object; recursion will result if you use the object passed as the first\n\t * argument to the MethodInterceptor (usually not what you want)\n\t * @param args the arguments passed to the intercepted method; you may substitute a different\n\t * argument array as long as the types are compatible\n\t * @throws Throwable the bare exceptions thrown by the called method are passed through\n\t * without wrapping in an <code>InvocationTargetException</code>\n\t * @see MethodInterceptor#intercept\n\t */\n\tpublic Object invoke(Object obj, Object[] args) throws Throwable {\n\t\ttry {\n\t\t\tinit();\n\t\t\tFastClassInfo fci = fastClassInfo;\n\t\t\treturn fci.f1.invoke(fci.i1, obj, args);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tthrow ex.getTargetException();\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tif (fastClassInfo.i1 < 0) {\n\t\t\t\tthrow new IllegalArgumentException(\"Protected method: \" + sig1);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\t/**\n\t * Invoke the original (super) method on the specified object.\n\t * @param obj the enhanced object, must be the object passed as the first\n\t * argument to the MethodInterceptor\n\t * @param args the arguments passed to the intercepted method; you may substitute a different\n\t * argument array as long as the types are compatible\n\t * @throws Throwable the bare exceptions thrown by the called method are passed through\n\t * without wrapping in an <code>InvocationTargetException</code>\n\t * @see MethodInterceptor#intercept\n\t */\n\tpublic Object invokeSuper(Object obj, Object[] args) throws Throwable {\n\t\ttry {\n\t\t\tinit();\n\t\t\tFastClassInfo fci = fastClassInfo;\n\t\t\treturn fci.f2.invoke(fci.i2, obj, args);\n\t\t}\n\t\tcatch (InvocationTargetException e) {\n\t\t\tthrow e.getTargetException();\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.cglib.proxy.CreateInfo",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.proxy.CreateInfo#c1",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.proxy.CreateInfo#c1",
    "headType": "field",
    "relation": "haveType",
    "tail": "Class",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.proxy.CreateInfo",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.proxy.CreateInfo#c2",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.proxy.CreateInfo#c2",
    "headType": "field",
    "relation": "haveType",
    "tail": "Class",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.proxy.CreateInfo",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.proxy.CreateInfo#namingPolicy",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.proxy.CreateInfo#namingPolicy",
    "headType": "field",
    "relation": "haveType",
    "tail": "NamingPolicy",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.proxy.CreateInfo",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.proxy.CreateInfo#strategy",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.proxy.CreateInfo#strategy",
    "headType": "field",
    "relation": "haveType",
    "tail": "GeneratorStrategy",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.proxy.CreateInfo",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.proxy.CreateInfo#attemptLoad",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.proxy.CreateInfo#attemptLoad",
    "headType": "field",
    "relation": "haveType",
    "tail": "boolean",
    "tailType": "type"
  }
]