[
  {
    "head": "org.springframework.util.TestObjectSubclassWithPublicField",
    "headType": "class",
    "relation": "extend",
    "tail": "TestObject",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.TestObjectSubclassWithNewField",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.TestObjectSubclassWithNewField",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.rmi.ConnectException;\nimport java.rmi.RemoteException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.tests.sample.objects.TestObject;\nimport org.springframework.util.ReflectionUtils.MethodFilter;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n\n/**\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Arjen Poutsma\n */\nclass ReflectionUtilsTests {\n\n\t@Test\n\tvoid findField() {\n\t\tField field = ReflectionUtils.findField(TestObjectSubclassWithPublicField.class, \"publicField\", String.class);\n\t\tassertThat(field).isNotNull();\n\t\tassertThat(field.getName()).isEqualTo(\"publicField\");\n\t\tassertThat(field.getType()).isEqualTo(String.class);\n\t\tassertThat(Modifier.isPublic(field.getModifiers())).as(\"Field should be public.\").isTrue();\n\n\t\tfield = ReflectionUtils.findField(TestObjectSubclassWithNewField.class, \"prot\", String.class);\n\t\tassertThat(field).isNotNull();\n\t\tassertThat(field.getName()).isEqualTo(\"prot\");\n\t\tassertThat(field.getType()).isEqualTo(String.class);\n\t\tassertThat(Modifier.isProtected(field.getModifiers())).as(\"Field should be protected.\").isTrue();\n\n\t\tfield = ReflectionUtils.findField(TestObjectSubclassWithNewField.class, \"name\", String.class);\n\t\tassertThat(field).isNotNull();\n\t\tassertThat(field.getName()).isEqualTo(\"name\");\n\t\tassertThat(field.getType()).isEqualTo(String.class);\n\t\tassertThat(Modifier.isPrivate(field.getModifiers())).as(\"Field should be private.\").isTrue();\n\t}\n\n\t@Test\n\tvoid setField() {\n\t\tTestObjectSubclassWithNewField testBean = new TestObjectSubclassWithNewField();\n\t\tField field = ReflectionUtils.findField(TestObjectSubclassWithNewField.class, \"name\", String.class);\n\n\t\tReflectionUtils.makeAccessible(field);\n\n\t\tReflectionUtils.setField(field, testBean, \"FooBar\");\n\t\tassertThat(testBean.getName()).isNotNull();\n\t\tassertThat(testBean.getName()).isEqualTo(\"FooBar\");\n\n\t\tReflectionUtils.setField(field, testBean, null);\n\t\tassertThat(testBean.getName()).isNull();\n\t}\n\n\t@Test\n\tvoid invokeMethod() throws Exception {\n\t\tString rob = \"Rob Harrop\";\n\n\t\tTestObject bean = new TestObject();\n\t\tbean.setName(rob);\n\n\t\tMethod getName = TestObject.class.getMethod(\"getName\");\n\t\tMethod setName = TestObject.class.getMethod(\"setName\", String.class);\n\n\t\tObject name = ReflectionUtils.invokeMethod(getName, bean);\n\t\tassertThat(name).as(\"Incorrect name returned\").isEqualTo(rob);\n\n\t\tString juergen = \"Juergen Hoeller\";\n\t\tReflectionUtils.invokeMethod(setName, bean, juergen);\n\t\tassertThat(bean.getName()).as(\"Incorrect name set\").isEqualTo(juergen);\n\t}\n\n\t@Test\n\tvoid declaresException() throws Exception {\n\t\tMethod remoteExMethod = A.class.getDeclaredMethod(\"foo\", Integer.class);\n\t\tassertThat(ReflectionUtils.declaresException(remoteExMethod, RemoteException.class)).isTrue();\n\t\tassertThat(ReflectionUtils.declaresException(remoteExMethod, ConnectException.class)).isTrue();\n\t\tassertThat(ReflectionUtils.declaresException(remoteExMethod, NoSuchMethodException.class)).isFalse();\n\t\tassertThat(ReflectionUtils.declaresException(remoteExMethod, Exception.class)).isFalse();\n\n\t\tMethod illegalExMethod = B.class.getDeclaredMethod(\"bar\", String.class);\n\t\tassertThat(ReflectionUtils.declaresException(illegalExMethod, IllegalArgumentException.class)).isTrue();\n\t\tassertThat(ReflectionUtils.declaresException(illegalExMethod, NumberFormatException.class)).isTrue();\n\t\tassertThat(ReflectionUtils.declaresException(illegalExMethod, IllegalStateException.class)).isFalse();\n\t\tassertThat(ReflectionUtils.declaresException(illegalExMethod, Exception.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid copySrcToDestinationOfIncorrectClass() {\n\t\tTestObject src = new TestObject();\n\t\tString dest = new String();\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tReflectionUtils.shallowCopyFieldState(src, dest));\n\t}\n\n\t@Test\n\tvoid rejectsNullSrc() {\n\t\tTestObject src = null;\n\t\tString dest = new String();\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tReflectionUtils.shallowCopyFieldState(src, dest));\n\t}\n\n\t@Test\n\tvoid rejectsNullDest() {\n\t\tTestObject src = new TestObject();\n\t\tString dest = null;\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tReflectionUtils.shallowCopyFieldState(src, dest));\n\t}\n\n\t@Test\n\tvoid validCopy() {\n\t\tTestObject src = new TestObject();\n\t\tTestObject dest = new TestObject();\n\t\ttestValidCopy(src, dest);\n\t}\n\n\t@Test\n\tvoid validCopyOnSubTypeWithNewField() {\n\t\tTestObjectSubclassWithNewField src = new TestObjectSubclassWithNewField();\n\t\tTestObjectSubclassWithNewField dest = new TestObjectSubclassWithNewField();\n\t\tsrc.magic = 11;\n\n\t\t// Will check inherited fields are copied\n\t\ttestValidCopy(src, dest);\n\n\t\t// Check subclass fields were copied\n\t\tassertThat(dest.magic).isEqualTo(src.magic);\n\t\tassertThat(dest.prot).isEqualTo(src.prot);\n\t}\n\n\t@Test\n\tvoid validCopyToSubType() {\n\t\tTestObject src = new TestObject();\n\t\tTestObjectSubclassWithNewField dest = new TestObjectSubclassWithNewField();\n\t\tdest.magic = 11;\n\t\ttestValidCopy(src, dest);\n\t\t// Should have left this one alone\n\t\tassertThat(dest.magic).isEqualTo(11);\n\t}\n\n\t@Test\n\tvoid validCopyToSubTypeWithFinalField() {\n\t\tTestObjectSubclassWithFinalField src = new TestObjectSubclassWithFinalField();\n\t\tTestObjectSubclassWithFinalField dest = new TestObjectSubclassWithFinalField();\n\t\t// Check that this doesn't fail due to attempt to assign final\n\t\ttestValidCopy(src, dest);\n\t}\n\n\tprivate void testValidCopy(TestObject src, TestObject dest) {\n\t\tsrc.setName(\"freddie\");\n\t\tsrc.setAge(15);\n\t\tsrc.setSpouse(new TestObject());\n\t\tassertThat(src.getAge()).isNotEqualTo(dest.getAge());\n\n\t\tReflectionUtils.shallowCopyFieldState(src, dest);\n\t\tassertThat(dest.getAge()).isEqualTo(src.getAge());\n\t\tassertThat(dest.getSpouse()).isEqualTo(src.getSpouse());\n\t}\n\n\t@Test\n\tvoid doWithMethodsUsingProtectedFilter() {\n\t\tListSavingMethodCallback mc = new ListSavingMethodCallback();\n\t\tReflectionUtils.doWithMethods(TestObject.class, mc, method -> Modifier.isProtected(method.getModifiers()));\n\t\tassertThat(mc.getMethodNames())\n\t\t\t.hasSizeGreaterThanOrEqualTo(2)\n\t\t\t.as(\"Must find protected methods on Object\").contains(\"clone\", \"finalize\")\n\t\t\t.as(\"Public, not protected\").doesNotContain(\"hashCode\", \"absquatulate\");\n\t}\n\n\t@Test\n\tvoid doWithMethodsUsingUserDeclaredMethodsFilterStartingWithObject() {\n\t\tListSavingMethodCallback mc = new ListSavingMethodCallback();\n\t\tReflectionUtils.doWithMethods(Object.class, mc, ReflectionUtils.USER_DECLARED_METHODS);\n\t\tassertThat(mc.getMethodNames()).isEmpty();\n\t}\n\n\t@Test\n\tvoid doWithMethodsUsingUserDeclaredMethodsFilterStartingWithTestObject() {\n\t\tListSavingMethodCallback mc = new ListSavingMethodCallback();\n\t\tReflectionUtils.doWithMethods(TestObject.class, mc, ReflectionUtils.USER_DECLARED_METHODS);\n\t\tassertThat(mc.getMethodNames())\n\t\t\t.as(\"user declared methods\").contains(\"absquatulate\", \"compareTo\", \"getName\", \"setName\", \"getAge\", \"setAge\", \"getSpouse\", \"setSpouse\")\n\t\t\t.as(\"methods on Object\").doesNotContain(\"equals\", \"hashCode\", \"toString\", \"clone\", \"finalize\", \"getClass\", \"notify\", \"notifyAll\", \"wait\");\n\t}\n\n\t@Test\n\tvoid doWithMethodsUsingUserDeclaredMethodsComposedFilter() {\n\t\tListSavingMethodCallback mc = new ListSavingMethodCallback();\n\t\t// \"q\" because both absquatulate() and equals() contain \"q\"\n\t\tMethodFilter isSetterMethodOrNameContainsQ = m -> m.getName().startsWith(\"set\") || m.getName().contains(\"q\");\n\t\tMethodFilter methodFilter = ReflectionUtils.USER_DECLARED_METHODS.and(isSetterMethodOrNameContainsQ);\n\t\tReflectionUtils.doWithMethods(TestObject.class, mc, methodFilter);\n\t\tassertThat(mc.getMethodNames()).containsExactlyInAnyOrder(\"setName\", \"setAge\", \"setSpouse\", \"absquatulate\");\n\t}\n\n\t@Test\n\tvoid doWithMethodsFindsDuplicatesInClassHierarchy() {\n\t\tListSavingMethodCallback mc = new ListSavingMethodCallback();\n\t\tReflectionUtils.doWithMethods(TestObjectSubclass.class, mc);\n\t\tassertThat(mc.getMethodNames().stream()).filteredOn(\"absquatulate\"::equals).as(\"Found 2 absquatulates\").hasSize(2);\n\t}\n\n\t@Test\n\tvoid findMethod() {\n\t\tassertThat(ReflectionUtils.findMethod(B.class, \"bar\", String.class)).isNotNull();\n\t\tassertThat(ReflectionUtils.findMethod(B.class, \"foo\", Integer.class)).isNotNull();\n\t\tassertThat(ReflectionUtils.findMethod(B.class, \"getClass\")).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodWithVarArgs() {\n\t\tassertThat(ReflectionUtils.findMethod(B.class, \"add\", int[].class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid isCglibRenamedMethod() throws SecurityException, NoSuchMethodException {\n\t\t@SuppressWarnings(\"unused\")\n\t\tclass C {\n\t\t\tpublic void CGLIB$m1$123() {\n\t\t\t}\n\n\t\t\tpublic void CGLIB$m1$0() {\n\t\t\t}\n\n\t\t\tpublic void CGLIB$$0() {\n\t\t\t}\n\n\t\t\tpublic void CGLIB$m1$() {\n\t\t\t}\n\n\t\t\tpublic void CGLIB$m1() {\n\t\t\t}\n\n\t\t\tpublic void m1() {\n\t\t\t}\n\n\t\t\tpublic void m1$() {\n\t\t\t}\n\n\t\t\tpublic void m1$1() {\n\t\t\t}\n\t\t}\n\t\tassertThat(ReflectionUtils.isCglibRenamedMethod(C.class.getMethod(\"CGLIB$m1$123\"))).isTrue();\n\t\tassertThat(ReflectionUtils.isCglibRenamedMethod(C.class.getMethod(\"CGLIB$m1$0\"))).isTrue();\n\t\tassertThat(ReflectionUtils.isCglibRenamedMethod(C.class.getMethod(\"CGLIB$$0\"))).isFalse();\n\t\tassertThat(ReflectionUtils.isCglibRenamedMethod(C.class.getMethod(\"CGLIB$m1$\"))).isFalse();\n\t\tassertThat(ReflectionUtils.isCglibRenamedMethod(C.class.getMethod(\"CGLIB$m1\"))).isFalse();\n\t\tassertThat(ReflectionUtils.isCglibRenamedMethod(C.class.getMethod(\"m1\"))).isFalse();\n\t\tassertThat(ReflectionUtils.isCglibRenamedMethod(C.class.getMethod(\"m1$\"))).isFalse();\n\t\tassertThat(ReflectionUtils.isCglibRenamedMethod(C.class.getMethod(\"m1$1\"))).isFalse();\n\t}\n\n\t@Test\n\tvoid getAllDeclaredMethods() {\n\t\tclass Foo {\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\treturn super.toString();\n\t\t\t}\n\t\t}\n\t\tMethod[] allDeclaredMethods = ReflectionUtils.getAllDeclaredMethods(Foo.class);\n\t\tassertThat(allDeclaredMethods).extracting(Method::getName).filteredOn(\"toString\"::equals).hasSize(2);\n\t}\n\n\t@Test\n\tvoid getUniqueDeclaredMethods() {\n\t\tclass Foo {\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\treturn super.toString();\n\t\t\t}\n\t\t}\n\t\tMethod[] uniqueDeclaredMethods = ReflectionUtils.getUniqueDeclaredMethods(Foo.class);\n\t\tassertThat(uniqueDeclaredMethods).extracting(Method::getName).filteredOn(\"toString\"::equals).hasSize(1);\n\t}\n\n\t@Test\n\tvoid getUniqueDeclaredMethods_withCovariantReturnType() throws Exception {\n\t\tclass Parent {\n\t\t\t@SuppressWarnings(\"unused\")\n\t\t\tpublic Number m1() {\n\t\t\t\treturn 42;\n\t\t\t}\n\t\t}\n\t\tclass Leaf extends Parent {\n\t\t\t@Override\n\t\t\tpublic Integer m1() {\n\t\t\t\treturn 42;\n\t\t\t}\n\t\t}\n\t\tMethod[] methods = ReflectionUtils.getUniqueDeclaredMethods(Leaf.class);\n\t\tassertThat(methods).extracting(Method::getName).filteredOn(\"m1\"::equals).hasSize(1);\n\t\tassertThat(methods).contains(Leaf.class.getMethod(\"m1\"));\n\t\tassertThat(methods).doesNotContain(Parent.class.getMethod(\"m1\"));\n\t}\n\n\t@Test\n\tvoid getDeclaredMethodsReturnsCopy() {\n\t\tMethod[] m1 = ReflectionUtils.getDeclaredMethods(A.class);\n\t\tMethod[] m2 = ReflectionUtils.getDeclaredMethods(A.class);\n\t\tassertThat(m1). isNotSameAs(m2);\n\t}\n\n\tprivate static class ListSavingMethodCallback implements ReflectionUtils.MethodCallback {\n\n\t\tprivate List<String> methodNames = new ArrayList<>();\n\n\t\tprivate List<Method> methods = new ArrayList<>();\n\n\t\t@Override\n\t\tpublic void doWith(Method m) throws IllegalArgumentException {\n\t\t\tthis.methodNames.add(m.getName());\n\t\t\tthis.methods.add(m);\n\t\t}\n\n\t\tpublic List<String> getMethodNames() {\n\t\t\treturn this.methodNames;\n\t\t}\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tpublic List<Method> getMethods() {\n\t\t\treturn this.methods;\n\t\t}\n\t}\n\n\tprivate static class TestObjectSubclass extends TestObject {\n\n\t\t@Override\n\t\tpublic void absquatulate() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\tprivate static class TestObjectSubclassWithPublicField extends TestObject {\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tpublic String publicField = \"foo\";\n\t}\n\n\tprivate static class TestObjectSubclassWithNewField extends TestObject {\n\n\t\tprivate int magic;\n\n\t\tprotected String prot = \"foo\";\n\t}\n\n\tprivate static class TestObjectSubclassWithFinalField extends TestObject {\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tprivate final String foo = \"will break naive copy that doesn't exclude statics\";\n\t}\n\n\tprivate static class A {\n\n\t\t@SuppressWarnings({ \"unused\", \"RedundantThrows\" })\n\t\tprivate void foo(Integer i) throws RemoteException {\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class B extends A {\n\n\t\tvoid bar(String s) throws IllegalArgumentException {\n\t\t}\n\n\t\tint add(int... args) {\n\t\t\tint sum = 0;\n\t\t\tfor (int arg : args) {\n\t\t\t\tsum += arg;\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.TestObjectSubclassWithNewField",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.TestObjectSubclassWithNewField#magic",
    "tailType": "field"
  },
  {
    "head": "org.springframework.util.TestObjectSubclassWithNewField#magic",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.util.TestObjectSubclassWithNewField",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.TestObjectSubclassWithNewField#prot",
    "tailType": "field"
  },
  {
    "head": "org.springframework.util.TestObjectSubclassWithNewField#prot",
    "headType": "field",
    "relation": "haveType",
    "tail": "String",
    "tailType": "type"
  },
  {
    "head": "org.springframework.util.TestObjectSubclassWithNewField",
    "headType": "class",
    "relation": "extend",
    "tail": "TestObject",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.TestObjectSubclassWithFinalField",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.TestObjectSubclassWithFinalField",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.rmi.ConnectException;\nimport java.rmi.RemoteException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.tests.sample.objects.TestObject;\nimport org.springframework.util.ReflectionUtils.MethodFilter;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n\n/**\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Arjen Poutsma\n */\nclass ReflectionUtilsTests {\n\n\t@Test\n\tvoid findField() {\n\t\tField field = ReflectionUtils.findField(TestObjectSubclassWithPublicField.class, \"publicField\", String.class);\n\t\tassertThat(field).isNotNull();\n\t\tassertThat(field.getName()).isEqualTo(\"publicField\");\n\t\tassertThat(field.getType()).isEqualTo(String.class);\n\t\tassertThat(Modifier.isPublic(field.getModifiers())).as(\"Field should be public.\").isTrue();\n\n\t\tfield = ReflectionUtils.findField(TestObjectSubclassWithNewField.class, \"prot\", String.class);\n\t\tassertThat(field).isNotNull();\n\t\tassertThat(field.getName()).isEqualTo(\"prot\");\n\t\tassertThat(field.getType()).isEqualTo(String.class);\n\t\tassertThat(Modifier.isProtected(field.getModifiers())).as(\"Field should be protected.\").isTrue();\n\n\t\tfield = ReflectionUtils.findField(TestObjectSubclassWithNewField.class, \"name\", String.class);\n\t\tassertThat(field).isNotNull();\n\t\tassertThat(field.getName()).isEqualTo(\"name\");\n\t\tassertThat(field.getType()).isEqualTo(String.class);\n\t\tassertThat(Modifier.isPrivate(field.getModifiers())).as(\"Field should be private.\").isTrue();\n\t}\n\n\t@Test\n\tvoid setField() {\n\t\tTestObjectSubclassWithNewField testBean = new TestObjectSubclassWithNewField();\n\t\tField field = ReflectionUtils.findField(TestObjectSubclassWithNewField.class, \"name\", String.class);\n\n\t\tReflectionUtils.makeAccessible(field);\n\n\t\tReflectionUtils.setField(field, testBean, \"FooBar\");\n\t\tassertThat(testBean.getName()).isNotNull();\n\t\tassertThat(testBean.getName()).isEqualTo(\"FooBar\");\n\n\t\tReflectionUtils.setField(field, testBean, null);\n\t\tassertThat(testBean.getName()).isNull();\n\t}\n\n\t@Test\n\tvoid invokeMethod() throws Exception {\n\t\tString rob = \"Rob Harrop\";\n\n\t\tTestObject bean = new TestObject();\n\t\tbean.setName(rob);\n\n\t\tMethod getName = TestObject.class.getMethod(\"getName\");\n\t\tMethod setName = TestObject.class.getMethod(\"setName\", String.class);\n\n\t\tObject name = ReflectionUtils.invokeMethod(getName, bean);\n\t\tassertThat(name).as(\"Incorrect name returned\").isEqualTo(rob);\n\n\t\tString juergen = \"Juergen Hoeller\";\n\t\tReflectionUtils.invokeMethod(setName, bean, juergen);\n\t\tassertThat(bean.getName()).as(\"Incorrect name set\").isEqualTo(juergen);\n\t}\n\n\t@Test\n\tvoid declaresException() throws Exception {\n\t\tMethod remoteExMethod = A.class.getDeclaredMethod(\"foo\", Integer.class);\n\t\tassertThat(ReflectionUtils.declaresException(remoteExMethod, RemoteException.class)).isTrue();\n\t\tassertThat(ReflectionUtils.declaresException(remoteExMethod, ConnectException.class)).isTrue();\n\t\tassertThat(ReflectionUtils.declaresException(remoteExMethod, NoSuchMethodException.class)).isFalse();\n\t\tassertThat(ReflectionUtils.declaresException(remoteExMethod, Exception.class)).isFalse();\n\n\t\tMethod illegalExMethod = B.class.getDeclaredMethod(\"bar\", String.class);\n\t\tassertThat(ReflectionUtils.declaresException(illegalExMethod, IllegalArgumentException.class)).isTrue();\n\t\tassertThat(ReflectionUtils.declaresException(illegalExMethod, NumberFormatException.class)).isTrue();\n\t\tassertThat(ReflectionUtils.declaresException(illegalExMethod, IllegalStateException.class)).isFalse();\n\t\tassertThat(ReflectionUtils.declaresException(illegalExMethod, Exception.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid copySrcToDestinationOfIncorrectClass() {\n\t\tTestObject src = new TestObject();\n\t\tString dest = new String();\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tReflectionUtils.shallowCopyFieldState(src, dest));\n\t}\n\n\t@Test\n\tvoid rejectsNullSrc() {\n\t\tTestObject src = null;\n\t\tString dest = new String();\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tReflectionUtils.shallowCopyFieldState(src, dest));\n\t}\n\n\t@Test\n\tvoid rejectsNullDest() {\n\t\tTestObject src = new TestObject();\n\t\tString dest = null;\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tReflectionUtils.shallowCopyFieldState(src, dest));\n\t}\n\n\t@Test\n\tvoid validCopy() {\n\t\tTestObject src = new TestObject();\n\t\tTestObject dest = new TestObject();\n\t\ttestValidCopy(src, dest);\n\t}\n\n\t@Test\n\tvoid validCopyOnSubTypeWithNewField() {\n\t\tTestObjectSubclassWithNewField src = new TestObjectSubclassWithNewField();\n\t\tTestObjectSubclassWithNewField dest = new TestObjectSubclassWithNewField();\n\t\tsrc.magic = 11;\n\n\t\t// Will check inherited fields are copied\n\t\ttestValidCopy(src, dest);\n\n\t\t// Check subclass fields were copied\n\t\tassertThat(dest.magic).isEqualTo(src.magic);\n\t\tassertThat(dest.prot).isEqualTo(src.prot);\n\t}\n\n\t@Test\n\tvoid validCopyToSubType() {\n\t\tTestObject src = new TestObject();\n\t\tTestObjectSubclassWithNewField dest = new TestObjectSubclassWithNewField();\n\t\tdest.magic = 11;\n\t\ttestValidCopy(src, dest);\n\t\t// Should have left this one alone\n\t\tassertThat(dest.magic).isEqualTo(11);\n\t}\n\n\t@Test\n\tvoid validCopyToSubTypeWithFinalField() {\n\t\tTestObjectSubclassWithFinalField src = new TestObjectSubclassWithFinalField();\n\t\tTestObjectSubclassWithFinalField dest = new TestObjectSubclassWithFinalField();\n\t\t// Check that this doesn't fail due to attempt to assign final\n\t\ttestValidCopy(src, dest);\n\t}\n\n\tprivate void testValidCopy(TestObject src, TestObject dest) {\n\t\tsrc.setName(\"freddie\");\n\t\tsrc.setAge(15);\n\t\tsrc.setSpouse(new TestObject());\n\t\tassertThat(src.getAge()).isNotEqualTo(dest.getAge());\n\n\t\tReflectionUtils.shallowCopyFieldState(src, dest);\n\t\tassertThat(dest.getAge()).isEqualTo(src.getAge());\n\t\tassertThat(dest.getSpouse()).isEqualTo(src.getSpouse());\n\t}\n\n\t@Test\n\tvoid doWithMethodsUsingProtectedFilter() {\n\t\tListSavingMethodCallback mc = new ListSavingMethodCallback();\n\t\tReflectionUtils.doWithMethods(TestObject.class, mc, method -> Modifier.isProtected(method.getModifiers()));\n\t\tassertThat(mc.getMethodNames())\n\t\t\t.hasSizeGreaterThanOrEqualTo(2)\n\t\t\t.as(\"Must find protected methods on Object\").contains(\"clone\", \"finalize\")\n\t\t\t.as(\"Public, not protected\").doesNotContain(\"hashCode\", \"absquatulate\");\n\t}\n\n\t@Test\n\tvoid doWithMethodsUsingUserDeclaredMethodsFilterStartingWithObject() {\n\t\tListSavingMethodCallback mc = new ListSavingMethodCallback();\n\t\tReflectionUtils.doWithMethods(Object.class, mc, ReflectionUtils.USER_DECLARED_METHODS);\n\t\tassertThat(mc.getMethodNames()).isEmpty();\n\t}\n\n\t@Test\n\tvoid doWithMethodsUsingUserDeclaredMethodsFilterStartingWithTestObject() {\n\t\tListSavingMethodCallback mc = new ListSavingMethodCallback();\n\t\tReflectionUtils.doWithMethods(TestObject.class, mc, ReflectionUtils.USER_DECLARED_METHODS);\n\t\tassertThat(mc.getMethodNames())\n\t\t\t.as(\"user declared methods\").contains(\"absquatulate\", \"compareTo\", \"getName\", \"setName\", \"getAge\", \"setAge\", \"getSpouse\", \"setSpouse\")\n\t\t\t.as(\"methods on Object\").doesNotContain(\"equals\", \"hashCode\", \"toString\", \"clone\", \"finalize\", \"getClass\", \"notify\", \"notifyAll\", \"wait\");\n\t}\n\n\t@Test\n\tvoid doWithMethodsUsingUserDeclaredMethodsComposedFilter() {\n\t\tListSavingMethodCallback mc = new ListSavingMethodCallback();\n\t\t// \"q\" because both absquatulate() and equals() contain \"q\"\n\t\tMethodFilter isSetterMethodOrNameContainsQ = m -> m.getName().startsWith(\"set\") || m.getName().contains(\"q\");\n\t\tMethodFilter methodFilter = ReflectionUtils.USER_DECLARED_METHODS.and(isSetterMethodOrNameContainsQ);\n\t\tReflectionUtils.doWithMethods(TestObject.class, mc, methodFilter);\n\t\tassertThat(mc.getMethodNames()).containsExactlyInAnyOrder(\"setName\", \"setAge\", \"setSpouse\", \"absquatulate\");\n\t}\n\n\t@Test\n\tvoid doWithMethodsFindsDuplicatesInClassHierarchy() {\n\t\tListSavingMethodCallback mc = new ListSavingMethodCallback();\n\t\tReflectionUtils.doWithMethods(TestObjectSubclass.class, mc);\n\t\tassertThat(mc.getMethodNames().stream()).filteredOn(\"absquatulate\"::equals).as(\"Found 2 absquatulates\").hasSize(2);\n\t}\n\n\t@Test\n\tvoid findMethod() {\n\t\tassertThat(ReflectionUtils.findMethod(B.class, \"bar\", String.class)).isNotNull();\n\t\tassertThat(ReflectionUtils.findMethod(B.class, \"foo\", Integer.class)).isNotNull();\n\t\tassertThat(ReflectionUtils.findMethod(B.class, \"getClass\")).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodWithVarArgs() {\n\t\tassertThat(ReflectionUtils.findMethod(B.class, \"add\", int[].class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid isCglibRenamedMethod() throws SecurityException, NoSuchMethodException {\n\t\t@SuppressWarnings(\"unused\")\n\t\tclass C {\n\t\t\tpublic void CGLIB$m1$123() {\n\t\t\t}\n\n\t\t\tpublic void CGLIB$m1$0() {\n\t\t\t}\n\n\t\t\tpublic void CGLIB$$0() {\n\t\t\t}\n\n\t\t\tpublic void CGLIB$m1$() {\n\t\t\t}\n\n\t\t\tpublic void CGLIB$m1() {\n\t\t\t}\n\n\t\t\tpublic void m1() {\n\t\t\t}\n\n\t\t\tpublic void m1$() {\n\t\t\t}\n\n\t\t\tpublic void m1$1() {\n\t\t\t}\n\t\t}\n\t\tassertThat(ReflectionUtils.isCglibRenamedMethod(C.class.getMethod(\"CGLIB$m1$123\"))).isTrue();\n\t\tassertThat(ReflectionUtils.isCglibRenamedMethod(C.class.getMethod(\"CGLIB$m1$0\"))).isTrue();\n\t\tassertThat(ReflectionUtils.isCglibRenamedMethod(C.class.getMethod(\"CGLIB$$0\"))).isFalse();\n\t\tassertThat(ReflectionUtils.isCglibRenamedMethod(C.class.getMethod(\"CGLIB$m1$\"))).isFalse();\n\t\tassertThat(ReflectionUtils.isCglibRenamedMethod(C.class.getMethod(\"CGLIB$m1\"))).isFalse();\n\t\tassertThat(ReflectionUtils.isCglibRenamedMethod(C.class.getMethod(\"m1\"))).isFalse();\n\t\tassertThat(ReflectionUtils.isCglibRenamedMethod(C.class.getMethod(\"m1$\"))).isFalse();\n\t\tassertThat(ReflectionUtils.isCglibRenamedMethod(C.class.getMethod(\"m1$1\"))).isFalse();\n\t}\n\n\t@Test\n\tvoid getAllDeclaredMethods() {\n\t\tclass Foo {\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\treturn super.toString();\n\t\t\t}\n\t\t}\n\t\tMethod[] allDeclaredMethods = ReflectionUtils.getAllDeclaredMethods(Foo.class);\n\t\tassertThat(allDeclaredMethods).extracting(Method::getName).filteredOn(\"toString\"::equals).hasSize(2);\n\t}\n\n\t@Test\n\tvoid getUniqueDeclaredMethods() {\n\t\tclass Foo {\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\treturn super.toString();\n\t\t\t}\n\t\t}\n\t\tMethod[] uniqueDeclaredMethods = ReflectionUtils.getUniqueDeclaredMethods(Foo.class);\n\t\tassertThat(uniqueDeclaredMethods).extracting(Method::getName).filteredOn(\"toString\"::equals).hasSize(1);\n\t}\n\n\t@Test\n\tvoid getUniqueDeclaredMethods_withCovariantReturnType() throws Exception {\n\t\tclass Parent {\n\t\t\t@SuppressWarnings(\"unused\")\n\t\t\tpublic Number m1() {\n\t\t\t\treturn 42;\n\t\t\t}\n\t\t}\n\t\tclass Leaf extends Parent {\n\t\t\t@Override\n\t\t\tpublic Integer m1() {\n\t\t\t\treturn 42;\n\t\t\t}\n\t\t}\n\t\tMethod[] methods = ReflectionUtils.getUniqueDeclaredMethods(Leaf.class);\n\t\tassertThat(methods).extracting(Method::getName).filteredOn(\"m1\"::equals).hasSize(1);\n\t\tassertThat(methods).contains(Leaf.class.getMethod(\"m1\"));\n\t\tassertThat(methods).doesNotContain(Parent.class.getMethod(\"m1\"));\n\t}\n\n\t@Test\n\tvoid getDeclaredMethodsReturnsCopy() {\n\t\tMethod[] m1 = ReflectionUtils.getDeclaredMethods(A.class);\n\t\tMethod[] m2 = ReflectionUtils.getDeclaredMethods(A.class);\n\t\tassertThat(m1). isNotSameAs(m2);\n\t}\n\n\tprivate static class ListSavingMethodCallback implements ReflectionUtils.MethodCallback {\n\n\t\tprivate List<String> methodNames = new ArrayList<>();\n\n\t\tprivate List<Method> methods = new ArrayList<>();\n\n\t\t@Override\n\t\tpublic void doWith(Method m) throws IllegalArgumentException {\n\t\t\tthis.methodNames.add(m.getName());\n\t\t\tthis.methods.add(m);\n\t\t}\n\n\t\tpublic List<String> getMethodNames() {\n\t\t\treturn this.methodNames;\n\t\t}\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tpublic List<Method> getMethods() {\n\t\t\treturn this.methods;\n\t\t}\n\t}\n\n\tprivate static class TestObjectSubclass extends TestObject {\n\n\t\t@Override\n\t\tpublic void absquatulate() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\tprivate static class TestObjectSubclassWithPublicField extends TestObject {\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tpublic String publicField = \"foo\";\n\t}\n\n\tprivate static class TestObjectSubclassWithNewField extends TestObject {\n\n\t\tprivate int magic;\n\n\t\tprotected String prot = \"foo\";\n\t}\n\n\tprivate static class TestObjectSubclassWithFinalField extends TestObject {\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tprivate final String foo = \"will break naive copy that doesn't exclude statics\";\n\t}\n\n\tprivate static class A {\n\n\t\t@SuppressWarnings({ \"unused\", \"RedundantThrows\" })\n\t\tprivate void foo(Integer i) throws RemoteException {\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class B extends A {\n\n\t\tvoid bar(String s) throws IllegalArgumentException {\n\t\t}\n\n\t\tint add(int... args) {\n\t\t\tint sum = 0;\n\t\t\tfor (int arg : args) {\n\t\t\t\tsum += arg;\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.TestObjectSubclassWithFinalField",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.TestObjectSubclassWithFinalField#foo",
    "tailType": "field"
  },
  {
    "head": "org.springframework.util.TestObjectSubclassWithFinalField#foo",
    "headType": "field",
    "relation": "haveType",
    "tail": "String",
    "tailType": "type"
  },
  {
    "head": "org.springframework.util.TestObjectSubclassWithFinalField",
    "headType": "class",
    "relation": "extend",
    "tail": "TestObject",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.A",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.A",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.rmi.ConnectException;\nimport java.rmi.RemoteException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.tests.sample.objects.TestObject;\nimport org.springframework.util.ReflectionUtils.MethodFilter;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n\n/**\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Arjen Poutsma\n */\nclass ReflectionUtilsTests {\n\n\t@Test\n\tvoid findField() {\n\t\tField field = ReflectionUtils.findField(TestObjectSubclassWithPublicField.class, \"publicField\", String.class);\n\t\tassertThat(field).isNotNull();\n\t\tassertThat(field.getName()).isEqualTo(\"publicField\");\n\t\tassertThat(field.getType()).isEqualTo(String.class);\n\t\tassertThat(Modifier.isPublic(field.getModifiers())).as(\"Field should be public.\").isTrue();\n\n\t\tfield = ReflectionUtils.findField(TestObjectSubclassWithNewField.class, \"prot\", String.class);\n\t\tassertThat(field).isNotNull();\n\t\tassertThat(field.getName()).isEqualTo(\"prot\");\n\t\tassertThat(field.getType()).isEqualTo(String.class);\n\t\tassertThat(Modifier.isProtected(field.getModifiers())).as(\"Field should be protected.\").isTrue();\n\n\t\tfield = ReflectionUtils.findField(TestObjectSubclassWithNewField.class, \"name\", String.class);\n\t\tassertThat(field).isNotNull();\n\t\tassertThat(field.getName()).isEqualTo(\"name\");\n\t\tassertThat(field.getType()).isEqualTo(String.class);\n\t\tassertThat(Modifier.isPrivate(field.getModifiers())).as(\"Field should be private.\").isTrue();\n\t}\n\n\t@Test\n\tvoid setField() {\n\t\tTestObjectSubclassWithNewField testBean = new TestObjectSubclassWithNewField();\n\t\tField field = ReflectionUtils.findField(TestObjectSubclassWithNewField.class, \"name\", String.class);\n\n\t\tReflectionUtils.makeAccessible(field);\n\n\t\tReflectionUtils.setField(field, testBean, \"FooBar\");\n\t\tassertThat(testBean.getName()).isNotNull();\n\t\tassertThat(testBean.getName()).isEqualTo(\"FooBar\");\n\n\t\tReflectionUtils.setField(field, testBean, null);\n\t\tassertThat(testBean.getName()).isNull();\n\t}\n\n\t@Test\n\tvoid invokeMethod() throws Exception {\n\t\tString rob = \"Rob Harrop\";\n\n\t\tTestObject bean = new TestObject();\n\t\tbean.setName(rob);\n\n\t\tMethod getName = TestObject.class.getMethod(\"getName\");\n\t\tMethod setName = TestObject.class.getMethod(\"setName\", String.class);\n\n\t\tObject name = ReflectionUtils.invokeMethod(getName, bean);\n\t\tassertThat(name).as(\"Incorrect name returned\").isEqualTo(rob);\n\n\t\tString juergen = \"Juergen Hoeller\";\n\t\tReflectionUtils.invokeMethod(setName, bean, juergen);\n\t\tassertThat(bean.getName()).as(\"Incorrect name set\").isEqualTo(juergen);\n\t}\n\n\t@Test\n\tvoid declaresException() throws Exception {\n\t\tMethod remoteExMethod = A.class.getDeclaredMethod(\"foo\", Integer.class);\n\t\tassertThat(ReflectionUtils.declaresException(remoteExMethod, RemoteException.class)).isTrue();\n\t\tassertThat(ReflectionUtils.declaresException(remoteExMethod, ConnectException.class)).isTrue();\n\t\tassertThat(ReflectionUtils.declaresException(remoteExMethod, NoSuchMethodException.class)).isFalse();\n\t\tassertThat(ReflectionUtils.declaresException(remoteExMethod, Exception.class)).isFalse();\n\n\t\tMethod illegalExMethod = B.class.getDeclaredMethod(\"bar\", String.class);\n\t\tassertThat(ReflectionUtils.declaresException(illegalExMethod, IllegalArgumentException.class)).isTrue();\n\t\tassertThat(ReflectionUtils.declaresException(illegalExMethod, NumberFormatException.class)).isTrue();\n\t\tassertThat(ReflectionUtils.declaresException(illegalExMethod, IllegalStateException.class)).isFalse();\n\t\tassertThat(ReflectionUtils.declaresException(illegalExMethod, Exception.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid copySrcToDestinationOfIncorrectClass() {\n\t\tTestObject src = new TestObject();\n\t\tString dest = new String();\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tReflectionUtils.shallowCopyFieldState(src, dest));\n\t}\n\n\t@Test\n\tvoid rejectsNullSrc() {\n\t\tTestObject src = null;\n\t\tString dest = new String();\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tReflectionUtils.shallowCopyFieldState(src, dest));\n\t}\n\n\t@Test\n\tvoid rejectsNullDest() {\n\t\tTestObject src = new TestObject();\n\t\tString dest = null;\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tReflectionUtils.shallowCopyFieldState(src, dest));\n\t}\n\n\t@Test\n\tvoid validCopy() {\n\t\tTestObject src = new TestObject();\n\t\tTestObject dest = new TestObject();\n\t\ttestValidCopy(src, dest);\n\t}\n\n\t@Test\n\tvoid validCopyOnSubTypeWithNewField() {\n\t\tTestObjectSubclassWithNewField src = new TestObjectSubclassWithNewField();\n\t\tTestObjectSubclassWithNewField dest = new TestObjectSubclassWithNewField();\n\t\tsrc.magic = 11;\n\n\t\t// Will check inherited fields are copied\n\t\ttestValidCopy(src, dest);\n\n\t\t// Check subclass fields were copied\n\t\tassertThat(dest.magic).isEqualTo(src.magic);\n\t\tassertThat(dest.prot).isEqualTo(src.prot);\n\t}\n\n\t@Test\n\tvoid validCopyToSubType() {\n\t\tTestObject src = new TestObject();\n\t\tTestObjectSubclassWithNewField dest = new TestObjectSubclassWithNewField();\n\t\tdest.magic = 11;\n\t\ttestValidCopy(src, dest);\n\t\t// Should have left this one alone\n\t\tassertThat(dest.magic).isEqualTo(11);\n\t}\n\n\t@Test\n\tvoid validCopyToSubTypeWithFinalField() {\n\t\tTestObjectSubclassWithFinalField src = new TestObjectSubclassWithFinalField();\n\t\tTestObjectSubclassWithFinalField dest = new TestObjectSubclassWithFinalField();\n\t\t// Check that this doesn't fail due to attempt to assign final\n\t\ttestValidCopy(src, dest);\n\t}\n\n\tprivate void testValidCopy(TestObject src, TestObject dest) {\n\t\tsrc.setName(\"freddie\");\n\t\tsrc.setAge(15);\n\t\tsrc.setSpouse(new TestObject());\n\t\tassertThat(src.getAge()).isNotEqualTo(dest.getAge());\n\n\t\tReflectionUtils.shallowCopyFieldState(src, dest);\n\t\tassertThat(dest.getAge()).isEqualTo(src.getAge());\n\t\tassertThat(dest.getSpouse()).isEqualTo(src.getSpouse());\n\t}\n\n\t@Test\n\tvoid doWithMethodsUsingProtectedFilter() {\n\t\tListSavingMethodCallback mc = new ListSavingMethodCallback();\n\t\tReflectionUtils.doWithMethods(TestObject.class, mc, method -> Modifier.isProtected(method.getModifiers()));\n\t\tassertThat(mc.getMethodNames())\n\t\t\t.hasSizeGreaterThanOrEqualTo(2)\n\t\t\t.as(\"Must find protected methods on Object\").contains(\"clone\", \"finalize\")\n\t\t\t.as(\"Public, not protected\").doesNotContain(\"hashCode\", \"absquatulate\");\n\t}\n\n\t@Test\n\tvoid doWithMethodsUsingUserDeclaredMethodsFilterStartingWithObject() {\n\t\tListSavingMethodCallback mc = new ListSavingMethodCallback();\n\t\tReflectionUtils.doWithMethods(Object.class, mc, ReflectionUtils.USER_DECLARED_METHODS);\n\t\tassertThat(mc.getMethodNames()).isEmpty();\n\t}\n\n\t@Test\n\tvoid doWithMethodsUsingUserDeclaredMethodsFilterStartingWithTestObject() {\n\t\tListSavingMethodCallback mc = new ListSavingMethodCallback();\n\t\tReflectionUtils.doWithMethods(TestObject.class, mc, ReflectionUtils.USER_DECLARED_METHODS);\n\t\tassertThat(mc.getMethodNames())\n\t\t\t.as(\"user declared methods\").contains(\"absquatulate\", \"compareTo\", \"getName\", \"setName\", \"getAge\", \"setAge\", \"getSpouse\", \"setSpouse\")\n\t\t\t.as(\"methods on Object\").doesNotContain(\"equals\", \"hashCode\", \"toString\", \"clone\", \"finalize\", \"getClass\", \"notify\", \"notifyAll\", \"wait\");\n\t}\n\n\t@Test\n\tvoid doWithMethodsUsingUserDeclaredMethodsComposedFilter() {\n\t\tListSavingMethodCallback mc = new ListSavingMethodCallback();\n\t\t// \"q\" because both absquatulate() and equals() contain \"q\"\n\t\tMethodFilter isSetterMethodOrNameContainsQ = m -> m.getName().startsWith(\"set\") || m.getName().contains(\"q\");\n\t\tMethodFilter methodFilter = ReflectionUtils.USER_DECLARED_METHODS.and(isSetterMethodOrNameContainsQ);\n\t\tReflectionUtils.doWithMethods(TestObject.class, mc, methodFilter);\n\t\tassertThat(mc.getMethodNames()).containsExactlyInAnyOrder(\"setName\", \"setAge\", \"setSpouse\", \"absquatulate\");\n\t}\n\n\t@Test\n\tvoid doWithMethodsFindsDuplicatesInClassHierarchy() {\n\t\tListSavingMethodCallback mc = new ListSavingMethodCallback();\n\t\tReflectionUtils.doWithMethods(TestObjectSubclass.class, mc);\n\t\tassertThat(mc.getMethodNames().stream()).filteredOn(\"absquatulate\"::equals).as(\"Found 2 absquatulates\").hasSize(2);\n\t}\n\n\t@Test\n\tvoid findMethod() {\n\t\tassertThat(ReflectionUtils.findMethod(B.class, \"bar\", String.class)).isNotNull();\n\t\tassertThat(ReflectionUtils.findMethod(B.class, \"foo\", Integer.class)).isNotNull();\n\t\tassertThat(ReflectionUtils.findMethod(B.class, \"getClass\")).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodWithVarArgs() {\n\t\tassertThat(ReflectionUtils.findMethod(B.class, \"add\", int[].class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid isCglibRenamedMethod() throws SecurityException, NoSuchMethodException {\n\t\t@SuppressWarnings(\"unused\")\n\t\tclass C {\n\t\t\tpublic void CGLIB$m1$123() {\n\t\t\t}\n\n\t\t\tpublic void CGLIB$m1$0() {\n\t\t\t}\n\n\t\t\tpublic void CGLIB$$0() {\n\t\t\t}\n\n\t\t\tpublic void CGLIB$m1$() {\n\t\t\t}\n\n\t\t\tpublic void CGLIB$m1() {\n\t\t\t}\n\n\t\t\tpublic void m1() {\n\t\t\t}\n\n\t\t\tpublic void m1$() {\n\t\t\t}\n\n\t\t\tpublic void m1$1() {\n\t\t\t}\n\t\t}\n\t\tassertThat(ReflectionUtils.isCglibRenamedMethod(C.class.getMethod(\"CGLIB$m1$123\"))).isTrue();\n\t\tassertThat(ReflectionUtils.isCglibRenamedMethod(C.class.getMethod(\"CGLIB$m1$0\"))).isTrue();\n\t\tassertThat(ReflectionUtils.isCglibRenamedMethod(C.class.getMethod(\"CGLIB$$0\"))).isFalse();\n\t\tassertThat(ReflectionUtils.isCglibRenamedMethod(C.class.getMethod(\"CGLIB$m1$\"))).isFalse();\n\t\tassertThat(ReflectionUtils.isCglibRenamedMethod(C.class.getMethod(\"CGLIB$m1\"))).isFalse();\n\t\tassertThat(ReflectionUtils.isCglibRenamedMethod(C.class.getMethod(\"m1\"))).isFalse();\n\t\tassertThat(ReflectionUtils.isCglibRenamedMethod(C.class.getMethod(\"m1$\"))).isFalse();\n\t\tassertThat(ReflectionUtils.isCglibRenamedMethod(C.class.getMethod(\"m1$1\"))).isFalse();\n\t}\n\n\t@Test\n\tvoid getAllDeclaredMethods() {\n\t\tclass Foo {\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\treturn super.toString();\n\t\t\t}\n\t\t}\n\t\tMethod[] allDeclaredMethods = ReflectionUtils.getAllDeclaredMethods(Foo.class);\n\t\tassertThat(allDeclaredMethods).extracting(Method::getName).filteredOn(\"toString\"::equals).hasSize(2);\n\t}\n\n\t@Test\n\tvoid getUniqueDeclaredMethods() {\n\t\tclass Foo {\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\treturn super.toString();\n\t\t\t}\n\t\t}\n\t\tMethod[] uniqueDeclaredMethods = ReflectionUtils.getUniqueDeclaredMethods(Foo.class);\n\t\tassertThat(uniqueDeclaredMethods).extracting(Method::getName).filteredOn(\"toString\"::equals).hasSize(1);\n\t}\n\n\t@Test\n\tvoid getUniqueDeclaredMethods_withCovariantReturnType() throws Exception {\n\t\tclass Parent {\n\t\t\t@SuppressWarnings(\"unused\")\n\t\t\tpublic Number m1() {\n\t\t\t\treturn 42;\n\t\t\t}\n\t\t}\n\t\tclass Leaf extends Parent {\n\t\t\t@Override\n\t\t\tpublic Integer m1() {\n\t\t\t\treturn 42;\n\t\t\t}\n\t\t}\n\t\tMethod[] methods = ReflectionUtils.getUniqueDeclaredMethods(Leaf.class);\n\t\tassertThat(methods).extracting(Method::getName).filteredOn(\"m1\"::equals).hasSize(1);\n\t\tassertThat(methods).contains(Leaf.class.getMethod(\"m1\"));\n\t\tassertThat(methods).doesNotContain(Parent.class.getMethod(\"m1\"));\n\t}\n\n\t@Test\n\tvoid getDeclaredMethodsReturnsCopy() {\n\t\tMethod[] m1 = ReflectionUtils.getDeclaredMethods(A.class);\n\t\tMethod[] m2 = ReflectionUtils.getDeclaredMethods(A.class);\n\t\tassertThat(m1). isNotSameAs(m2);\n\t}\n\n\tprivate static class ListSavingMethodCallback implements ReflectionUtils.MethodCallback {\n\n\t\tprivate List<String> methodNames = new ArrayList<>();\n\n\t\tprivate List<Method> methods = new ArrayList<>();\n\n\t\t@Override\n\t\tpublic void doWith(Method m) throws IllegalArgumentException {\n\t\t\tthis.methodNames.add(m.getName());\n\t\t\tthis.methods.add(m);\n\t\t}\n\n\t\tpublic List<String> getMethodNames() {\n\t\t\treturn this.methodNames;\n\t\t}\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tpublic List<Method> getMethods() {\n\t\t\treturn this.methods;\n\t\t}\n\t}\n\n\tprivate static class TestObjectSubclass extends TestObject {\n\n\t\t@Override\n\t\tpublic void absquatulate() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\tprivate static class TestObjectSubclassWithPublicField extends TestObject {\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tpublic String publicField = \"foo\";\n\t}\n\n\tprivate static class TestObjectSubclassWithNewField extends TestObject {\n\n\t\tprivate int magic;\n\n\t\tprotected String prot = \"foo\";\n\t}\n\n\tprivate static class TestObjectSubclassWithFinalField extends TestObject {\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tprivate final String foo = \"will break naive copy that doesn't exclude statics\";\n\t}\n\n\tprivate static class A {\n\n\t\t@SuppressWarnings({ \"unused\", \"RedundantThrows\" })\n\t\tprivate void foo(Integer i) throws RemoteException {\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class B extends A {\n\n\t\tvoid bar(String s) throws IllegalArgumentException {\n\t\t}\n\n\t\tint add(int... args) {\n\t\t\tint sum = 0;\n\t\t\tfor (int arg : args) {\n\t\t\t\tsum += arg;\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.A#foo(Integer)",
    "headType": "method",
    "relation": "provide",
    "tail": "@SuppressWarnings({ \"unused\", \"RedundantThrows\" })\r\nprivate void foo(Integer i) throws RemoteException ;",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.A",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.A#foo(Integer)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.A#foo(Integer)",
    "headType": "method",
    "relation": "use",
    "tail": "@SuppressWarnings",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.B",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.B",
    "headType": "class",
    "relation": "use",
    "tail": "@SuppressWarnings",
    "tailType": "annotation"
  }
]