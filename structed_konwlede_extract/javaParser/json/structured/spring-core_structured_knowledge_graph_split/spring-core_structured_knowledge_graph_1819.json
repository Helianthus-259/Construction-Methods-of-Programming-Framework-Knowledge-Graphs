[
  {
    "head": "org.springframework.core.MessageBroadcaster",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.concurrent.DelayQueue;\nimport java.util.concurrent.Delayed;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.testfixture.ide.IdeUtils;\nimport org.springframework.util.ReflectionUtils;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @author Chris Beams\n * @author Yanming Zhou\n */\n@SuppressWarnings(\"rawtypes\")\nclass BridgeMethodResolverTests {\n\n\tprivate static Method findMethodWithReturnType(String name, Class<?> returnType, Class<SettingsDaoImpl> targetType) {\n\t\tMethod[] methods = targetType.getMethods();\n\t\tfor (Method m : methods) {\n\t\t\tif (m.getName().equals(name) && m.getReturnType().equals(returnType)) {\n\t\t\t\treturn m;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t@Test\n\tvoid findBridgedMethod() throws Exception {\n\t\tMethod unbridged = MyFoo.class.getDeclaredMethod(\"someMethod\", String.class, Object.class);\n\t\tMethod bridged = MyFoo.class.getDeclaredMethod(\"someMethod\", Serializable.class, Object.class);\n\t\tassertThat(unbridged.isBridge()).isFalse();\n\t\tassertThat(bridged.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(unbridged)).as(\"Unbridged method not returned directly\").isEqualTo(unbridged);\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridged)).as(\"Incorrect bridged method returned\").isEqualTo(unbridged);\n\t}\n\n\t@Test\n\tvoid findBridgedVarargMethod() throws Exception {\n\t\tMethod unbridged = MyFoo.class.getDeclaredMethod(\"someVarargMethod\", String.class, Object[].class);\n\t\tMethod bridged = MyFoo.class.getDeclaredMethod(\"someVarargMethod\", Serializable.class, Object[].class);\n\t\tassertThat(unbridged.isBridge()).isFalse();\n\t\tassertThat(bridged.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(unbridged)).as(\"Unbridged method not returned directly\").isEqualTo(unbridged);\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridged)).as(\"Incorrect bridged method returned\").isEqualTo(unbridged);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodInHierarchy() throws Exception {\n\t\tMethod bridgeMethod = DateAdder.class.getMethod(\"add\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\tMethod bridgedMethod = BridgeMethodResolver.findBridgedMethod(bridgeMethod);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tassertThat(bridgedMethod.getName()).isEqualTo(\"add\");\n\t\tassertThat(bridgedMethod.getParameterCount()).isEqualTo(1);\n\t\tassertThat(bridgedMethod.getParameterTypes()[0]).isEqualTo(Date.class);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodFromOriginalMethodInHierarchy() throws Exception {\n\t\tMethod originalMethod = Adder.class.getMethod(\"add\", Object.class);\n\t\tassertThat(originalMethod.isBridge()).isFalse();\n\t\tMethod bridgedMethod = BridgeMethodResolver.getMostSpecificMethod(originalMethod, DateAdder.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tassertThat(bridgedMethod.getName()).isEqualTo(\"add\");\n\t\tassertThat(bridgedMethod.getParameterCount()).isEqualTo(1);\n\t\tassertThat(bridgedMethod.getParameterTypes()[0]).isEqualTo(Date.class);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodFromOriginalMethodNotInHierarchy() throws Exception {\n\t\tMethod originalMethod = Adder.class.getMethod(\"add\", Object.class);\n\t\tMethod mostSpecificMethod = BridgeMethodResolver.getMostSpecificMethod(originalMethod, FakeAdder.class);\n\t\tassertThat(mostSpecificMethod).isSameAs(originalMethod);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodInHierarchyWithBoundedGenerics() throws Exception {\n\t\tMethod originalMethod = Bar.class.getDeclaredMethod(\"someMethod\", Object.class, Object.class);\n\t\tassertThat(originalMethod.isBridge()).isFalse();\n\t\tMethod bridgedMethod = BridgeMethodResolver.getMostSpecificMethod(originalMethod, SubBar.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tassertThat(bridgedMethod.getName()).isEqualTo(\"someMethod\");\n\t\tassertThat(bridgedMethod.getParameterCount()).isEqualTo(2);\n\t\tassertThat(bridgedMethod.getParameterTypes()[0]).isEqualTo(CharSequence.class);\n\t}\n\n\t@Test\n\tvoid isBridgeMethodFor() throws Exception {\n\t\tMethod bridged = MyBar.class.getDeclaredMethod(\"someMethod\", String.class, Object.class);\n\t\tMethod other = MyBar.class.getDeclaredMethod(\"someMethod\", Integer.class, Object.class);\n\t\tMethod bridge;\n\n\t\tif (IdeUtils.runningInEclipse()) {\n\t\t\tbridge = InterBar.class.getDeclaredMethod(\"someMethod\", Object.class, Object.class);\n\t\t}\n\t\telse {\n\t\t\tbridge = MyBar.class.getDeclaredMethod(\"someMethod\", Object.class, Object.class);\n\t\t}\n\t\tassertThat(bridge.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.isBridgeMethodFor(bridge, bridged, MyBar.class)).as(\"Should be bridge method\").isTrue();\n\t\tassertThat(BridgeMethodResolver.isBridgeMethodFor(bridge, other, MyBar.class)).as(\"Should not be bridge method\").isFalse();\n\t}\n\n\t@Test\n\tvoid doubleParameterization() throws Exception {\n\t\tMethod objectBridge = MyBoo.class.getDeclaredMethod(\"foo\", Object.class);\n\t\tMethod serializableBridge = MyBoo.class.getDeclaredMethod(\"foo\", Serializable.class);\n\n\t\tMethod stringFoo = MyBoo.class.getDeclaredMethod(\"foo\", String.class);\n\t\tMethod integerFoo = MyBoo.class.getDeclaredMethod(\"foo\", Integer.class);\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(objectBridge)).as(\"foo(String) not resolved.\").isEqualTo(stringFoo);\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(serializableBridge)).as(\"foo(Integer) not resolved.\").isEqualTo(integerFoo);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodFromMultipleBridges() throws Exception {\n\t\tMethod loadWithObjectReturn = findMethodWithReturnType(\"load\", Object.class, SettingsDaoImpl.class);\n\t\tassertThat(loadWithObjectReturn).isNotNull();\n\n\t\tMethod loadWithSettingsReturn = findMethodWithReturnType(\"load\", Settings.class, SettingsDaoImpl.class);\n\t\tassertThat(loadWithSettingsReturn).isNotNull();\n\t\tassertThat(loadWithSettingsReturn).isNotSameAs(loadWithObjectReturn);\n\n\t\tMethod method = SettingsDaoImpl.class.getMethod(\"load\");\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(loadWithObjectReturn)).isEqualTo(method);\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(loadWithSettingsReturn)).isEqualTo(method);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodFromParent() throws Exception {\n\t\tMethod loadFromParentBridge = SettingsDaoImpl.class.getMethod(\"loadFromParent\");\n\t\tassertThat(loadFromParentBridge.isBridge()).isTrue();\n\n\t\tMethod loadFromParent = AbstractDaoImpl.class.getMethod(\"loadFromParent\");\n\t\tassertThat(loadFromParent.isBridge()).isFalse();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(loadFromParentBridge)).isEqualTo(loadFromParent);\n\t}\n\n\t@Test\n\tvoid withSingleBoundParameterizedOnInstantiate() throws Exception {\n\t\tMethod bridgeMethod = DelayQueue.class.getMethod(\"add\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\tMethod actualMethod = DelayQueue.class.getMethod(\"add\", Delayed.class);\n\t\tassertThat(actualMethod.isBridge()).isFalse();\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(actualMethod);\n\t}\n\n\t@Test\n\tvoid withDoubleBoundParameterizedOnInstantiate() throws Exception {\n\t\tMethod bridgeMethod = SerializableBounded.class.getMethod(\"boundedOperation\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\tMethod actualMethod = SerializableBounded.class.getMethod(\"boundedOperation\", HashMap.class);\n\t\tassertThat(actualMethod.isBridge()).isFalse();\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(actualMethod);\n\t}\n\n\t@Test\n\tvoid withGenericParameter() {\n\t\tMethod[] methods = StringGenericParameter.class.getMethods();\n\t\tMethod bridgeMethod = null;\n\t\tMethod bridgedMethod = null;\n\t\tfor (Method method : methods) {\n\t\t\tif (\"getFor\".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {\n\t\t\t\tif (method.getReturnType().equals(Object.class)) {\n\t\t\t\t\tbridgeMethod = method;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbridgedMethod = method;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\n\t\tboolean condition = bridgedMethod != null && !bridgedMethod.isBridge();\n\t\tassertThat(condition).isTrue();\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid onAllMethods() {\n\t\tMethod[] methods = StringList.class.getMethods();\n\t\tfor (Method method : methods) {\n\t\t\tassertThat(BridgeMethodResolver.findBridgedMethod(method)).isNotNull();\n\t\t}\n\t}\n\n\t@Test\n\tvoid spr2583() throws Exception {\n\t\tMethod bridgedMethod = MessageBroadcasterImpl.class.getMethod(\"receive\", MessageEvent.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tMethod bridgeMethod = MessageBroadcasterImpl.class.getMethod(\"receive\", Event.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tMethod otherMethod = MessageBroadcasterImpl.class.getMethod(\"receive\", NewMessageEvent.class);\n\t\tassertThat(otherMethod.isBridge()).isFalse();\n\n\t\tassertThat(BridgeMethodResolver.isBridgeMethodFor(bridgeMethod, otherMethod, MessageBroadcasterImpl.class)).as(\"Match identified incorrectly\").isFalse();\n\t\tassertThat(BridgeMethodResolver.isBridgeMethodFor(bridgeMethod, bridgedMethod, MessageBroadcasterImpl.class)).as(\"Match not found correctly\").isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr2603() throws Exception {\n\t\tMethod objectBridge = YourHomer.class.getDeclaredMethod(\"foo\", Bounded.class);\n\t\tMethod abstractBoundedFoo = YourHomer.class.getDeclaredMethod(\"foo\", AbstractBounded.class);\n\n\t\tMethod bridgedMethod = BridgeMethodResolver.findBridgedMethod(objectBridge);\n\t\tassertThat(bridgedMethod).as(\"foo(AbstractBounded) not resolved.\").isEqualTo(abstractBoundedFoo);\n\t}\n\n\t@Test\n\tvoid spr2648() {\n\t\tMethod bridgeMethod = ReflectionUtils.findMethod(GenericSqlMapIntegerDao.class, \"saveOrUpdate\", Object.class);\n\t\tassertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\n\t\tMethod bridgedMethod = BridgeMethodResolver.findBridgedMethod(bridgeMethod);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tassertThat(bridgedMethod.getName()).isEqualTo(\"saveOrUpdate\");\n\t}\n\n\t@Test\n\tvoid spr2763() throws Exception {\n\t\tMethod bridgedMethod = AbstractDao.class.getDeclaredMethod(\"save\", Object.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = UserDaoImpl.class.getDeclaredMethod(\"save\", User.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3041() throws Exception {\n\t\tMethod bridgedMethod = BusinessDao.class.getDeclaredMethod(\"save\", Business.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = BusinessDao.class.getDeclaredMethod(\"save\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3173() throws Exception {\n\t\tMethod bridgedMethod = UserDaoImpl.class.getDeclaredMethod(\"saveVararg\", User.class, Object[].class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = UserDaoImpl.class.getDeclaredMethod(\"saveVararg\", Object.class, Object[].class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3304() throws Exception {\n\t\tMethod bridgedMethod = MegaMessageProducerImpl.class.getDeclaredMethod(\"receive\", MegaMessageEvent.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = MegaMessageProducerImpl.class.getDeclaredMethod(\"receive\", MegaEvent.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3324() throws Exception {\n\t\tMethod bridgedMethod = BusinessDao.class.getDeclaredMethod(\"get\", Long.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = BusinessDao.class.getDeclaredMethod(\"get\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3357() throws Exception {\n\t\tMethod bridgedMethod = ExtendsAbstractImplementsInterface.class.getDeclaredMethod(\n\t\t\t\t\"doSomething\", DomainObjectExtendsSuper.class, Object.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = ExtendsAbstractImplementsInterface.class.getDeclaredMethod(\n\t\t\t\t\"doSomething\", DomainObjectSuper.class, Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3485() throws Exception {\n\t\tMethod bridgedMethod = DomainObject.class.getDeclaredMethod(\n\t\t\t\t\"method2\", ParameterType.class, byte[].class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = DomainObject.class.getDeclaredMethod(\n\t\t\t\t\"method2\", Serializable.class, Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3534() {\n\t\tMethod bridgeMethod = ReflectionUtils.findMethod(TestEmailProvider.class, \"findBy\", Object.class);\n\t\tassertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\n\t\tMethod bridgedMethod = BridgeMethodResolver.findBridgedMethod(bridgeMethod);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tassertThat(bridgedMethod.getName()).isEqualTo(\"findBy\");\n\t}\n\n\t@Test  // SPR-16103\n\tvoid testClassHierarchy() throws Exception {\n\t\tdoTestHierarchyResolution(FooClass.class);\n\t}\n\n\t@Test  // SPR-16103\n\tvoid testInterfaceHierarchy() throws Exception {\n\t\tdoTestHierarchyResolution(FooInterface.class);\n\t}\n\n\tprivate void doTestHierarchyResolution(Class<?> clazz) throws Exception {\n\t\tfor (Method method : clazz.getDeclaredMethods()){\n\t\t\tMethod bridged = BridgeMethodResolver.findBridgedMethod(method);\n\t\t\tMethod expected = clazz.getMethod(\"test\", FooEntity.class);\n\t\t\tassertThat(bridged).isEqualTo(expected);\n\t\t}\n\t}\n\n\n\tpublic interface Foo<T extends Serializable> {\n\n\t\tvoid someMethod(T theArg, Object otherArg);\n\n\t\tvoid someVarargMethod(T theArg, Object... otherArg);\n\t}\n\n\n\tpublic static class MyFoo implements Foo<String> {\n\n\t\tpublic void someMethod(Integer theArg, Object otherArg) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void someMethod(String theArg, Object otherArg) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void someVarargMethod(String theArg, Object... otherArgs) {\n\t\t}\n\t}\n\n\n\tpublic abstract static class Bar<T> {\n\n\t\tvoid someMethod(Map<?, ?> m, Object otherArg) {\n\t\t}\n\n\t\tvoid someMethod(T theArg, Map<?, ?> m) {\n\t\t}\n\n\t\tabstract void someMethod(T theArg, Object otherArg);\n\t}\n\n\n\tpublic abstract static class InterBar<T extends CharSequence> extends Bar<T> {\n\n\t\t@Override\n\t\tvoid someMethod(T theArg, Object otherArg) {\n\t\t}\n\t}\n\n\n\tpublic abstract static class SubBar<T extends StringProducer> extends InterBar<T> {\n\t}\n\n\tpublic interface StringProducer extends CharSequence {\n\t}\n\n\n\tpublic static class MyBar extends InterBar<String> {\n\n\t\t@Override\n\t\tpublic void someMethod(String theArg, Object otherArg) {\n\t\t}\n\n\t\tpublic void someMethod(Integer theArg, Object otherArg) {\n\t\t}\n\t}\n\n\n\tpublic interface Adder<T> {\n\n\t\tvoid add(T item);\n\t}\n\n\n\tpublic abstract static class AbstractDateAdder implements Adder<Date> {\n\n\t\t@Override\n\t\tpublic abstract void add(Date date);\n\t}\n\n\n\tpublic static class DateAdder extends AbstractDateAdder {\n\n\t\t@Override\n\t\tpublic void add(Date date) {\n\t\t}\n\t}\n\n\n\tpublic static class FakeAdder {\n\n\t\tpublic void add(Date date) {\n\t\t}\n\t}\n\n\n\tpublic static class Enclosing<T> {\n\n\t\tpublic class Enclosed<S> {\n\n\t\t\tpublic class ReallyDeepNow<R> {\n\n\t\t\t\tvoid someMethod(S s, T t, R r) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tpublic static class ExtendsEnclosing extends Enclosing<String> {\n\n\t\tpublic class ExtendsEnclosed extends Enclosed<Integer> {\n\n\t\t\tpublic class ExtendsReallyDeepNow extends ReallyDeepNow<Long> {\n\n\t\t\t\t@Override\n\t\t\t\tvoid someMethod(Integer s, String t, Long r) {\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tpublic interface Boo<E, T extends Serializable> {\n\n\t\tvoid foo(E e);\n\n\t\tvoid foo(T t);\n\t}\n\n\n\tpublic static class MyBoo implements Boo<String, Integer> {\n\n\t\t@Override\n\t\tpublic void foo(String e) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void foo(Integer t) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\tpublic interface Settings {\n\t}\n\n\n\tpublic interface ConcreteSettings extends Settings {\n\t}\n\n\n\tpublic interface Dao<T, S> {\n\n\t\tT load();\n\n\t\tS loadFromParent();\n\t}\n\n\n\tpublic interface SettingsDao<T extends Settings, S> extends Dao<T, S> {\n\n\t\t@Override\n\t\tT load();\n\t}\n\n\n\tpublic interface ConcreteSettingsDao extends SettingsDao<ConcreteSettings, String> {\n\n\t\t@Override\n\t\tString loadFromParent();\n\t}\n\n\n\tabstract static class AbstractDaoImpl<T, S> implements Dao<T, S> {\n\n\t\tprotected T object;\n\n\t\tprotected S otherObject;\n\n\t\tprotected AbstractDaoImpl(T object, S otherObject) {\n\t\t\tthis.object = object;\n\t\t\tthis.otherObject = otherObject;\n\t\t}\n\n\t\t// @Transactional(readOnly = true)\n\t\t@Override\n\t\tpublic S loadFromParent() {\n\t\t\treturn otherObject;\n\t\t}\n\t}\n\n\n\tstatic class SettingsDaoImpl extends AbstractDaoImpl<ConcreteSettings, String>\n\t\t\timplements ConcreteSettingsDao {\n\n\t\tprotected SettingsDaoImpl(ConcreteSettings object) {\n\t\t\tsuper(object, \"From Parent\");\n\t\t}\n\n\t\t// @Transactional(readOnly = true)\n\t\t@Override\n\t\tpublic ConcreteSettings load() {\n\t\t\treturn super.object;\n\t\t}\n\t}\n\n\n\tpublic interface Bounded<E> {\n\n\t\tboolean boundedOperation(E e);\n\t}\n\n\n\tprivate static class AbstractBounded<E> implements Bounded<E> {\n\n\t\t@Override\n\t\tpublic boolean boundedOperation(E myE) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\n\tprivate static class SerializableBounded<E extends HashMap & Delayed> extends AbstractBounded<E> {\n\n\t\t@Override\n\t\tpublic boolean boundedOperation(E myE) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\n\tpublic interface GenericParameter<T> {\n\n\t\tT getFor(Class<T> cls);\n\t}\n\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class StringGenericParameter implements GenericParameter<String> {\n\n\t\t@Override\n\t\tpublic String getFor(Class<String> cls) {\n\t\t\treturn \"foo\";\n\t\t}\n\n\t\tpublic String getFor(Integer integer) {\n\t\t\treturn \"foo\";\n\t\t}\n\t}\n\n\n\tprivate static class StringList implements List<String> {\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object o) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<String> iterator() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] a) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(String o) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends String> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(int index, Collection<? extends String> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic String get(int index) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic String set(int index, String element) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void add(int index, String element) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic String remove(int index) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic int indexOf(Object o) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic int lastIndexOf(Object o) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic ListIterator<String> listIterator() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic ListIterator<String> listIterator(int index) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> subList(int fromIndex, int toIndex) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\tpublic interface Event {\n\n\t\tint getPriority();\n\t}\n\n\n\tpublic static class GenericEvent implements Event {\n\n\t\tprivate int priority;\n\n\t\t@Override\n\t\tpublic int getPriority() {\n\t\t\treturn priority;\n\t\t}\n\n\t\t/**\n\t\t * Constructor that takes an event priority\n\t\t */\n\t\tpublic GenericEvent(int priority) {\n\t\t\tthis.priority = priority;\n\t\t}\n\n\t\t/**\n\t\t * Default Constructor\n\t\t */\n\t\tpublic GenericEvent() {\n\t\t}\n\t}\n\n\n\tpublic interface UserInitiatedEvent {\n\t}\n\n\n\tpublic abstract static class BaseUserInitiatedEvent extends GenericEvent implements UserInitiatedEvent {\n\t}\n\n\n\tpublic static class MessageEvent extends BaseUserInitiatedEvent {\n\t}\n\n\n\tpublic interface Channel<E extends Event> {\n\n\t\tvoid send(E event);\n\n\t\tvoid subscribe(final Receiver<E> receiver, Class<E> event);\n\n\t\tvoid unsubscribe(final Receiver<E> receiver, Class<E> event);\n\t}\n\n\n\tpublic interface Broadcaster {\n\t}\n\n\n\tpublic interface EventBroadcaster extends Broadcaster {\n\n\t\tvoid subscribe();\n\n\t\tvoid unsubscribe();\n\n\t\tvoid setChannel(Channel<?> channel);\n\t}\n\n\n\tpublic static class GenericBroadcasterImpl implements Broadcaster {\n\t}\n\n\n\t@SuppressWarnings({\"unused\", \"unchecked\"})\n\tpublic abstract static class GenericEventBroadcasterImpl<T extends Event>\n\t\t\textends GenericBroadcasterImpl implements EventBroadcaster {\n\n\t\tprivate Class<T>[] subscribingEvents;\n\n\t\tprivate Channel<T> channel;\n\n\t\t/**\n\t\t * Abstract method to retrieve instance of subclass\n\t\t *\n\t\t * @return receiver instance\n\t\t */\n\t\tpublic abstract Receiver<T> getInstance();\n\n\t\t@Override\n\t\tpublic void setChannel(Channel channel) {\n\t\t\tthis.channel = channel;\n\t\t}\n\n\t\tprivate String beanName;\n\n\t\tpublic void setBeanName(String name) {\n\t\t\tthis.beanName = name;\n\t\t}\n\n\t\t@Override\n\t\tpublic void subscribe() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void unsubscribe() {\n\t\t}\n\n\t\tpublic GenericEventBroadcasterImpl(Class<? extends T>... events) {\n\t\t}\n\t}\n\n\n\tpublic interface Receiver<E extends Event> {\n\n\t\tvoid receive(E event);\n\t}\n\n\n\tpublic interface MessageBroadcaster extends Receiver<MessageEvent> {\n\n\t}\n\n\n\tpublic static class RemovedMessageEvent extends MessageEvent {\n\n\t}\n\n\n\tpublic static class NewMessageEvent extends MessageEvent {\n\n\t}\n\n\n\tpublic static class ModifiedMessageEvent extends MessageEvent {\n\n\t}\n\n\n\t@SuppressWarnings({\"serial\", \"unchecked\"})\n\tpublic static class MessageBroadcasterImpl extends GenericEventBroadcasterImpl<MessageEvent>\n\t\t\timplements Serializable,  // implement an unrelated interface first (SPR-16288)\n\t\t\tMessageBroadcaster {\n\n\t\tpublic MessageBroadcasterImpl() {\n\t\t\tsuper(NewMessageEvent.class);\n\t\t}\n\n\t\t@Override\n\t\tpublic void receive(MessageEvent event) {\n\t\t\tthrow new UnsupportedOperationException(\"should not be called, use subclassed events\");\n\t\t}\n\n\t\tpublic void receive(NewMessageEvent event) {\n\t\t}\n\n\t\t@Override\n\t\tpublic Receiver<MessageEvent> getInstance() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void receive(RemovedMessageEvent event) {\n\t\t}\n\n\t\tpublic void receive(ModifiedMessageEvent event) {\n\t\t}\n\t}\n\n\n\t//-----------------------------\n\t// SPR-2454 Test Classes\n\t//-----------------------------\n\n\tpublic interface SimpleGenericRepository<T> {\n\n\t\tClass<T> getPersistentClass();\n\n\t\tList<T> findByQuery();\n\n\t\tList<T> findAll();\n\n\t\tT refresh(T entity);\n\n\t\tT saveOrUpdate(T entity);\n\n\t\tvoid delete(Collection<T> entities);\n\t}\n\n\n\tpublic interface RepositoryRegistry {\n\n\t\t<T> SimpleGenericRepository<T> getFor(Class<T> entityType);\n\t}\n\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static class SettableRepositoryRegistry<R extends SimpleGenericRepository<?>>\n\t\t\timplements RepositoryRegistry {\n\n\t\tprotected void injectInto(R rep) {\n\t\t}\n\n\t\tpublic void register(R rep) {\n\t\t}\n\n\t\tpublic void register(R... reps) {\n\t\t}\n\n\t\tpublic void setRepos(R... reps) {\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> SimpleGenericRepository<T> getFor(Class<T> entityType) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void afterPropertiesSet() {\n\t\t}\n\t}\n\n\n\tpublic interface ConvenientGenericRepository<T, ID extends Serializable>\n\t\t\textends SimpleGenericRepository<T> {\n\n\t\tT findById(ID id, boolean lock);\n\n\t\tList<T> findByExample(T exampleInstance);\n\n\t\tvoid delete(ID id);\n\n\t\tvoid delete(T entity);\n\t}\n\n\n\tpublic static class GenericHibernateRepository<T, ID extends Serializable>\n\t\t\timplements ConvenientGenericRepository<T, ID> {\n\n\t\t/**\n\t\t * @param c Mandatory. The domain class this repository is responsible for.\n\t\t */\n\t\t// Since it is impossible to determine the actual type of a type\n\t\t// parameter (!), we resort to requiring the caller to provide the\n\t\t// actual type as parameter, too.\n\t\t// Not set in a constructor to enable easy CGLIB-proxying (passing\n\t\t// constructor arguments to Spring AOP proxies is quite cumbersome).\n\t\tpublic void setPersistentClass(Class<T> c) {\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<T> getPersistentClass() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic T findById(ID id, boolean lock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<T> findAll() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<T> findByExample(T exampleInstance) {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<T> findByQuery() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic T saveOrUpdate(T entity) {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void delete(T entity) {\n\t\t}\n\n\t\t@Override\n\t\tpublic T refresh(T entity) {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void delete(ID id) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void delete(Collection<T> entities) {\n\t\t}\n\t}\n\n\n\tpublic static class HibernateRepositoryRegistry\n\t\t\textends SettableRepositoryRegistry<GenericHibernateRepository<?, ?>> {\n\n\t\t@Override\n\t\tpublic void injectInto(GenericHibernateRepository<?, ?> rep) {\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> GenericHibernateRepository<T, ?> getFor(Class<T> entityType) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-2603 classes\n\t//-------------------\n\n\tpublic interface Homer<E> {\n\n\t\tvoid foo(E e);\n\t}\n\n\n\tpublic static class MyHomer<T extends Bounded<T>, L extends T> implements Homer<L> {\n\n\t\t@Override\n\t\tpublic void foo(L t) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\tpublic static class YourHomer<T extends AbstractBounded<T>, L extends T> extends\n\t\t\tMyHomer<T, L> {\n\n\t\t@Override\n\t\tpublic void foo(L t) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\tpublic interface GenericDao<T> {\n\n\t\tvoid saveOrUpdate(T t);\n\t}\n\n\n\tpublic interface ConvenienceGenericDao<T> extends GenericDao<T> {\n\t}\n\n\n\tpublic static class GenericSqlMapDao<T extends Serializable> implements ConvenienceGenericDao<T> {\n\n\t\t@Override\n\t\tpublic void saveOrUpdate(T t) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\tpublic static class GenericSqlMapIntegerDao<T extends Number> extends GenericSqlMapDao<T> {\n\n\t\t@Override\n\t\tpublic void saveOrUpdate(T t) {\n\t\t}\n\t}\n\n\n\tpublic static class Permission {\n\t}\n\n\n\tpublic static class User {\n\t}\n\n\n\tpublic interface UserDao {\n\n\t\t// @Transactional\n\t\tvoid save(User user);\n\n\t\t// @Transactional\n\t\tvoid save(Permission perm);\n\t}\n\n\n\tpublic abstract static class AbstractDao<T> {\n\n\t\tpublic void save(T t) {\n\t\t}\n\n\t\tpublic void saveVararg(T t, Object... args) {\n\t\t}\n\t}\n\n\n\tpublic static class UserDaoImpl extends AbstractDao<User> implements UserDao {\n\n\t\t@Override\n\t\tpublic void save(Permission perm) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void saveVararg(User user, Object... args) {\n\t\t}\n\t}\n\n\n\tpublic interface DaoInterface<T, P> {\n\n\t\tT get(P id);\n\t}\n\n\n\tpublic abstract static class BusinessGenericDao<T, PK extends Serializable>\n\t\t\timplements DaoInterface<T, PK> {\n\n\t\tpublic void save(T object) {\n\t\t}\n\t}\n\n\n\tpublic static class Business<T> {\n\t}\n\n\n\tpublic static class BusinessDao extends BusinessGenericDao<Business<?>, Long> {\n\n\t\t@Override\n\t\tpublic void save(Business<?> business) {\n\t\t}\n\n\t\t@Override\n\t\tpublic Business<?> get(Long id) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic Business<?> get(String code) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-3304 classes\n\t//-------------------\n\n\tprivate static class MegaEvent {\n\t}\n\n\n\tprivate static class MegaMessageEvent extends MegaEvent {\n\t}\n\n\n\tprivate static class NewMegaMessageEvent extends MegaEvent {\n\t}\n\n\n\tprivate static class ModifiedMegaMessageEvent extends MegaEvent {\n\t}\n\n\n\tpublic interface MegaReceiver<E extends MegaEvent> {\n\n\t\tvoid receive(E event);\n\t}\n\n\n\tpublic interface MegaMessageProducer extends MegaReceiver<MegaMessageEvent> {\n\t}\n\n\n\tprivate static class Other<S,E> {\n\t}\n\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class MegaMessageProducerImpl extends Other<Long, String> implements MegaMessageProducer {\n\n\t\tpublic void receive(NewMegaMessageEvent event) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\tpublic void receive(ModifiedMegaMessageEvent event) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void receive(MegaMessageEvent event) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-3357 classes\n\t//-------------------\n\n\tprivate static class DomainObjectSuper {\n\t}\n\n\n\tprivate static class DomainObjectExtendsSuper extends DomainObjectSuper {\n\t}\n\n\n\tpublic interface IGenericInterface<D extends DomainObjectSuper> {\n\n\t\t<T> void doSomething(final D domainObject, final T value);\n\t}\n\n\n\t@SuppressWarnings(\"unused\")\n\tprivate abstract static class AbstractImplementsInterface<D extends DomainObjectSuper> implements IGenericInterface<D> {\n\n\t\t@Override\n\t\tpublic <T> void doSomething(D domainObject, T value) {\n\t\t}\n\n\t\tpublic void anotherBaseMethod() {\n\t\t}\n\t}\n\n\n\tprivate static class ExtendsAbstractImplementsInterface extends AbstractImplementsInterface<DomainObjectExtendsSuper> {\n\n\t\t@Override\n\t\tpublic <T> void doSomething(DomainObjectExtendsSuper domainObject, T value) {\n\t\t\tsuper.doSomething(domainObject, value);\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-3485 classes\n\t//-------------------\n\n\t@SuppressWarnings(\"serial\")\n\tprivate static class ParameterType implements Serializable {\n\t}\n\n\n\tprivate static class AbstractDomainObject<P extends Serializable, R> {\n\n\t\tpublic R method1(P p) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void method2(P p, R r) {\n\t\t}\n\t}\n\n\n\tprivate static class DomainObject extends AbstractDomainObject<ParameterType, byte[]> {\n\n\t\t@Override\n\t\tpublic byte[] method1(ParameterType p) {\n\t\t\treturn super.method1(p);\n\t\t}\n\n\t\t@Override\n\t\tpublic void method2(ParameterType p, byte[] r) {\n\t\t\tsuper.method2(p, r);\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-3534 classes\n\t//-------------------\n\n\tpublic interface SearchProvider<RETURN_TYPE, CONDITIONS_TYPE> {\n\n\t\tCollection<RETURN_TYPE> findBy(CONDITIONS_TYPE conditions);\n\t}\n\n\n\tpublic static class SearchConditions {\n\t}\n\n\n\tpublic interface IExternalMessageProvider<S extends ExternalMessage, T extends ExternalMessageSearchConditions<?>>\n\t\t\textends SearchProvider<S, T> {\n\t}\n\n\n\tpublic static class ExternalMessage {\n\t}\n\n\n\tpublic static class ExternalMessageSearchConditions<T extends ExternalMessage> extends SearchConditions {\n\t}\n\n\n\tpublic static class ExternalMessageProvider<S extends ExternalMessage, T extends ExternalMessageSearchConditions<S>>\n\t\t\timplements IExternalMessageProvider<S, T> {\n\n\t\t@Override\n\t\tpublic Collection<S> findBy(T conditions) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\tpublic static class EmailMessage extends ExternalMessage {\n\t}\n\n\n\tpublic static class EmailSearchConditions extends ExternalMessageSearchConditions<EmailMessage> {\n\t}\n\n\n\tpublic static class EmailMessageProvider extends ExternalMessageProvider<EmailMessage, EmailSearchConditions> {\n\t}\n\n\n\tpublic static class TestEmailProvider extends EmailMessageProvider {\n\n\t\t@Override\n\t\tpublic Collection<EmailMessage> findBy(EmailSearchConditions conditions) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-16103 classes\n\t//-------------------\n\n\tpublic abstract static class BaseEntity {\n\t}\n\n\tpublic static class FooEntity extends BaseEntity {\n\t}\n\n\tpublic static class BaseClass<T> {\n\n\t\tpublic <S extends T> S test(S T) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic static class EntityClass<T extends BaseEntity> extends BaseClass<T> {\n\n\t\t@Override\n\t\tpublic <S extends T> S test(S T) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic static class FooClass extends EntityClass<FooEntity> {\n\n\t\t@Override\n\t\tpublic <S extends FooEntity> S test(S T) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic interface BaseInterface<T> {\n\n\t\t<S extends T> S test(S T);\n\t}\n\n\tpublic interface EntityInterface<T extends BaseEntity> extends BaseInterface<T> {\n\n\t\t@Override\n\t\t<S extends T> S test(S T);\n\t}\n\n\tpublic interface FooInterface extends EntityInterface<FooEntity> {\n\n\t\t@Override\n\t\t<S extends FooEntity> S test(S T);\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.MessageBroadcaster",
    "headType": "class",
    "relation": "extend",
    "tail": "Receiver",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.RemovedMessageEvent",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.RemovedMessageEvent",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.concurrent.DelayQueue;\nimport java.util.concurrent.Delayed;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.testfixture.ide.IdeUtils;\nimport org.springframework.util.ReflectionUtils;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @author Chris Beams\n * @author Yanming Zhou\n */\n@SuppressWarnings(\"rawtypes\")\nclass BridgeMethodResolverTests {\n\n\tprivate static Method findMethodWithReturnType(String name, Class<?> returnType, Class<SettingsDaoImpl> targetType) {\n\t\tMethod[] methods = targetType.getMethods();\n\t\tfor (Method m : methods) {\n\t\t\tif (m.getName().equals(name) && m.getReturnType().equals(returnType)) {\n\t\t\t\treturn m;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t@Test\n\tvoid findBridgedMethod() throws Exception {\n\t\tMethod unbridged = MyFoo.class.getDeclaredMethod(\"someMethod\", String.class, Object.class);\n\t\tMethod bridged = MyFoo.class.getDeclaredMethod(\"someMethod\", Serializable.class, Object.class);\n\t\tassertThat(unbridged.isBridge()).isFalse();\n\t\tassertThat(bridged.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(unbridged)).as(\"Unbridged method not returned directly\").isEqualTo(unbridged);\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridged)).as(\"Incorrect bridged method returned\").isEqualTo(unbridged);\n\t}\n\n\t@Test\n\tvoid findBridgedVarargMethod() throws Exception {\n\t\tMethod unbridged = MyFoo.class.getDeclaredMethod(\"someVarargMethod\", String.class, Object[].class);\n\t\tMethod bridged = MyFoo.class.getDeclaredMethod(\"someVarargMethod\", Serializable.class, Object[].class);\n\t\tassertThat(unbridged.isBridge()).isFalse();\n\t\tassertThat(bridged.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(unbridged)).as(\"Unbridged method not returned directly\").isEqualTo(unbridged);\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridged)).as(\"Incorrect bridged method returned\").isEqualTo(unbridged);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodInHierarchy() throws Exception {\n\t\tMethod bridgeMethod = DateAdder.class.getMethod(\"add\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\tMethod bridgedMethod = BridgeMethodResolver.findBridgedMethod(bridgeMethod);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tassertThat(bridgedMethod.getName()).isEqualTo(\"add\");\n\t\tassertThat(bridgedMethod.getParameterCount()).isEqualTo(1);\n\t\tassertThat(bridgedMethod.getParameterTypes()[0]).isEqualTo(Date.class);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodFromOriginalMethodInHierarchy() throws Exception {\n\t\tMethod originalMethod = Adder.class.getMethod(\"add\", Object.class);\n\t\tassertThat(originalMethod.isBridge()).isFalse();\n\t\tMethod bridgedMethod = BridgeMethodResolver.getMostSpecificMethod(originalMethod, DateAdder.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tassertThat(bridgedMethod.getName()).isEqualTo(\"add\");\n\t\tassertThat(bridgedMethod.getParameterCount()).isEqualTo(1);\n\t\tassertThat(bridgedMethod.getParameterTypes()[0]).isEqualTo(Date.class);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodFromOriginalMethodNotInHierarchy() throws Exception {\n\t\tMethod originalMethod = Adder.class.getMethod(\"add\", Object.class);\n\t\tMethod mostSpecificMethod = BridgeMethodResolver.getMostSpecificMethod(originalMethod, FakeAdder.class);\n\t\tassertThat(mostSpecificMethod).isSameAs(originalMethod);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodInHierarchyWithBoundedGenerics() throws Exception {\n\t\tMethod originalMethod = Bar.class.getDeclaredMethod(\"someMethod\", Object.class, Object.class);\n\t\tassertThat(originalMethod.isBridge()).isFalse();\n\t\tMethod bridgedMethod = BridgeMethodResolver.getMostSpecificMethod(originalMethod, SubBar.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tassertThat(bridgedMethod.getName()).isEqualTo(\"someMethod\");\n\t\tassertThat(bridgedMethod.getParameterCount()).isEqualTo(2);\n\t\tassertThat(bridgedMethod.getParameterTypes()[0]).isEqualTo(CharSequence.class);\n\t}\n\n\t@Test\n\tvoid isBridgeMethodFor() throws Exception {\n\t\tMethod bridged = MyBar.class.getDeclaredMethod(\"someMethod\", String.class, Object.class);\n\t\tMethod other = MyBar.class.getDeclaredMethod(\"someMethod\", Integer.class, Object.class);\n\t\tMethod bridge;\n\n\t\tif (IdeUtils.runningInEclipse()) {\n\t\t\tbridge = InterBar.class.getDeclaredMethod(\"someMethod\", Object.class, Object.class);\n\t\t}\n\t\telse {\n\t\t\tbridge = MyBar.class.getDeclaredMethod(\"someMethod\", Object.class, Object.class);\n\t\t}\n\t\tassertThat(bridge.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.isBridgeMethodFor(bridge, bridged, MyBar.class)).as(\"Should be bridge method\").isTrue();\n\t\tassertThat(BridgeMethodResolver.isBridgeMethodFor(bridge, other, MyBar.class)).as(\"Should not be bridge method\").isFalse();\n\t}\n\n\t@Test\n\tvoid doubleParameterization() throws Exception {\n\t\tMethod objectBridge = MyBoo.class.getDeclaredMethod(\"foo\", Object.class);\n\t\tMethod serializableBridge = MyBoo.class.getDeclaredMethod(\"foo\", Serializable.class);\n\n\t\tMethod stringFoo = MyBoo.class.getDeclaredMethod(\"foo\", String.class);\n\t\tMethod integerFoo = MyBoo.class.getDeclaredMethod(\"foo\", Integer.class);\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(objectBridge)).as(\"foo(String) not resolved.\").isEqualTo(stringFoo);\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(serializableBridge)).as(\"foo(Integer) not resolved.\").isEqualTo(integerFoo);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodFromMultipleBridges() throws Exception {\n\t\tMethod loadWithObjectReturn = findMethodWithReturnType(\"load\", Object.class, SettingsDaoImpl.class);\n\t\tassertThat(loadWithObjectReturn).isNotNull();\n\n\t\tMethod loadWithSettingsReturn = findMethodWithReturnType(\"load\", Settings.class, SettingsDaoImpl.class);\n\t\tassertThat(loadWithSettingsReturn).isNotNull();\n\t\tassertThat(loadWithSettingsReturn).isNotSameAs(loadWithObjectReturn);\n\n\t\tMethod method = SettingsDaoImpl.class.getMethod(\"load\");\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(loadWithObjectReturn)).isEqualTo(method);\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(loadWithSettingsReturn)).isEqualTo(method);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodFromParent() throws Exception {\n\t\tMethod loadFromParentBridge = SettingsDaoImpl.class.getMethod(\"loadFromParent\");\n\t\tassertThat(loadFromParentBridge.isBridge()).isTrue();\n\n\t\tMethod loadFromParent = AbstractDaoImpl.class.getMethod(\"loadFromParent\");\n\t\tassertThat(loadFromParent.isBridge()).isFalse();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(loadFromParentBridge)).isEqualTo(loadFromParent);\n\t}\n\n\t@Test\n\tvoid withSingleBoundParameterizedOnInstantiate() throws Exception {\n\t\tMethod bridgeMethod = DelayQueue.class.getMethod(\"add\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\tMethod actualMethod = DelayQueue.class.getMethod(\"add\", Delayed.class);\n\t\tassertThat(actualMethod.isBridge()).isFalse();\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(actualMethod);\n\t}\n\n\t@Test\n\tvoid withDoubleBoundParameterizedOnInstantiate() throws Exception {\n\t\tMethod bridgeMethod = SerializableBounded.class.getMethod(\"boundedOperation\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\tMethod actualMethod = SerializableBounded.class.getMethod(\"boundedOperation\", HashMap.class);\n\t\tassertThat(actualMethod.isBridge()).isFalse();\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(actualMethod);\n\t}\n\n\t@Test\n\tvoid withGenericParameter() {\n\t\tMethod[] methods = StringGenericParameter.class.getMethods();\n\t\tMethod bridgeMethod = null;\n\t\tMethod bridgedMethod = null;\n\t\tfor (Method method : methods) {\n\t\t\tif (\"getFor\".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {\n\t\t\t\tif (method.getReturnType().equals(Object.class)) {\n\t\t\t\t\tbridgeMethod = method;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbridgedMethod = method;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\n\t\tboolean condition = bridgedMethod != null && !bridgedMethod.isBridge();\n\t\tassertThat(condition).isTrue();\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid onAllMethods() {\n\t\tMethod[] methods = StringList.class.getMethods();\n\t\tfor (Method method : methods) {\n\t\t\tassertThat(BridgeMethodResolver.findBridgedMethod(method)).isNotNull();\n\t\t}\n\t}\n\n\t@Test\n\tvoid spr2583() throws Exception {\n\t\tMethod bridgedMethod = MessageBroadcasterImpl.class.getMethod(\"receive\", MessageEvent.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tMethod bridgeMethod = MessageBroadcasterImpl.class.getMethod(\"receive\", Event.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tMethod otherMethod = MessageBroadcasterImpl.class.getMethod(\"receive\", NewMessageEvent.class);\n\t\tassertThat(otherMethod.isBridge()).isFalse();\n\n\t\tassertThat(BridgeMethodResolver.isBridgeMethodFor(bridgeMethod, otherMethod, MessageBroadcasterImpl.class)).as(\"Match identified incorrectly\").isFalse();\n\t\tassertThat(BridgeMethodResolver.isBridgeMethodFor(bridgeMethod, bridgedMethod, MessageBroadcasterImpl.class)).as(\"Match not found correctly\").isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr2603() throws Exception {\n\t\tMethod objectBridge = YourHomer.class.getDeclaredMethod(\"foo\", Bounded.class);\n\t\tMethod abstractBoundedFoo = YourHomer.class.getDeclaredMethod(\"foo\", AbstractBounded.class);\n\n\t\tMethod bridgedMethod = BridgeMethodResolver.findBridgedMethod(objectBridge);\n\t\tassertThat(bridgedMethod).as(\"foo(AbstractBounded) not resolved.\").isEqualTo(abstractBoundedFoo);\n\t}\n\n\t@Test\n\tvoid spr2648() {\n\t\tMethod bridgeMethod = ReflectionUtils.findMethod(GenericSqlMapIntegerDao.class, \"saveOrUpdate\", Object.class);\n\t\tassertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\n\t\tMethod bridgedMethod = BridgeMethodResolver.findBridgedMethod(bridgeMethod);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tassertThat(bridgedMethod.getName()).isEqualTo(\"saveOrUpdate\");\n\t}\n\n\t@Test\n\tvoid spr2763() throws Exception {\n\t\tMethod bridgedMethod = AbstractDao.class.getDeclaredMethod(\"save\", Object.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = UserDaoImpl.class.getDeclaredMethod(\"save\", User.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3041() throws Exception {\n\t\tMethod bridgedMethod = BusinessDao.class.getDeclaredMethod(\"save\", Business.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = BusinessDao.class.getDeclaredMethod(\"save\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3173() throws Exception {\n\t\tMethod bridgedMethod = UserDaoImpl.class.getDeclaredMethod(\"saveVararg\", User.class, Object[].class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = UserDaoImpl.class.getDeclaredMethod(\"saveVararg\", Object.class, Object[].class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3304() throws Exception {\n\t\tMethod bridgedMethod = MegaMessageProducerImpl.class.getDeclaredMethod(\"receive\", MegaMessageEvent.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = MegaMessageProducerImpl.class.getDeclaredMethod(\"receive\", MegaEvent.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3324() throws Exception {\n\t\tMethod bridgedMethod = BusinessDao.class.getDeclaredMethod(\"get\", Long.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = BusinessDao.class.getDeclaredMethod(\"get\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3357() throws Exception {\n\t\tMethod bridgedMethod = ExtendsAbstractImplementsInterface.class.getDeclaredMethod(\n\t\t\t\t\"doSomething\", DomainObjectExtendsSuper.class, Object.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = ExtendsAbstractImplementsInterface.class.getDeclaredMethod(\n\t\t\t\t\"doSomething\", DomainObjectSuper.class, Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3485() throws Exception {\n\t\tMethod bridgedMethod = DomainObject.class.getDeclaredMethod(\n\t\t\t\t\"method2\", ParameterType.class, byte[].class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = DomainObject.class.getDeclaredMethod(\n\t\t\t\t\"method2\", Serializable.class, Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3534() {\n\t\tMethod bridgeMethod = ReflectionUtils.findMethod(TestEmailProvider.class, \"findBy\", Object.class);\n\t\tassertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\n\t\tMethod bridgedMethod = BridgeMethodResolver.findBridgedMethod(bridgeMethod);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tassertThat(bridgedMethod.getName()).isEqualTo(\"findBy\");\n\t}\n\n\t@Test  // SPR-16103\n\tvoid testClassHierarchy() throws Exception {\n\t\tdoTestHierarchyResolution(FooClass.class);\n\t}\n\n\t@Test  // SPR-16103\n\tvoid testInterfaceHierarchy() throws Exception {\n\t\tdoTestHierarchyResolution(FooInterface.class);\n\t}\n\n\tprivate void doTestHierarchyResolution(Class<?> clazz) throws Exception {\n\t\tfor (Method method : clazz.getDeclaredMethods()){\n\t\t\tMethod bridged = BridgeMethodResolver.findBridgedMethod(method);\n\t\t\tMethod expected = clazz.getMethod(\"test\", FooEntity.class);\n\t\t\tassertThat(bridged).isEqualTo(expected);\n\t\t}\n\t}\n\n\n\tpublic interface Foo<T extends Serializable> {\n\n\t\tvoid someMethod(T theArg, Object otherArg);\n\n\t\tvoid someVarargMethod(T theArg, Object... otherArg);\n\t}\n\n\n\tpublic static class MyFoo implements Foo<String> {\n\n\t\tpublic void someMethod(Integer theArg, Object otherArg) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void someMethod(String theArg, Object otherArg) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void someVarargMethod(String theArg, Object... otherArgs) {\n\t\t}\n\t}\n\n\n\tpublic abstract static class Bar<T> {\n\n\t\tvoid someMethod(Map<?, ?> m, Object otherArg) {\n\t\t}\n\n\t\tvoid someMethod(T theArg, Map<?, ?> m) {\n\t\t}\n\n\t\tabstract void someMethod(T theArg, Object otherArg);\n\t}\n\n\n\tpublic abstract static class InterBar<T extends CharSequence> extends Bar<T> {\n\n\t\t@Override\n\t\tvoid someMethod(T theArg, Object otherArg) {\n\t\t}\n\t}\n\n\n\tpublic abstract static class SubBar<T extends StringProducer> extends InterBar<T> {\n\t}\n\n\tpublic interface StringProducer extends CharSequence {\n\t}\n\n\n\tpublic static class MyBar extends InterBar<String> {\n\n\t\t@Override\n\t\tpublic void someMethod(String theArg, Object otherArg) {\n\t\t}\n\n\t\tpublic void someMethod(Integer theArg, Object otherArg) {\n\t\t}\n\t}\n\n\n\tpublic interface Adder<T> {\n\n\t\tvoid add(T item);\n\t}\n\n\n\tpublic abstract static class AbstractDateAdder implements Adder<Date> {\n\n\t\t@Override\n\t\tpublic abstract void add(Date date);\n\t}\n\n\n\tpublic static class DateAdder extends AbstractDateAdder {\n\n\t\t@Override\n\t\tpublic void add(Date date) {\n\t\t}\n\t}\n\n\n\tpublic static class FakeAdder {\n\n\t\tpublic void add(Date date) {\n\t\t}\n\t}\n\n\n\tpublic static class Enclosing<T> {\n\n\t\tpublic class Enclosed<S> {\n\n\t\t\tpublic class ReallyDeepNow<R> {\n\n\t\t\t\tvoid someMethod(S s, T t, R r) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tpublic static class ExtendsEnclosing extends Enclosing<String> {\n\n\t\tpublic class ExtendsEnclosed extends Enclosed<Integer> {\n\n\t\t\tpublic class ExtendsReallyDeepNow extends ReallyDeepNow<Long> {\n\n\t\t\t\t@Override\n\t\t\t\tvoid someMethod(Integer s, String t, Long r) {\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tpublic interface Boo<E, T extends Serializable> {\n\n\t\tvoid foo(E e);\n\n\t\tvoid foo(T t);\n\t}\n\n\n\tpublic static class MyBoo implements Boo<String, Integer> {\n\n\t\t@Override\n\t\tpublic void foo(String e) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void foo(Integer t) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\tpublic interface Settings {\n\t}\n\n\n\tpublic interface ConcreteSettings extends Settings {\n\t}\n\n\n\tpublic interface Dao<T, S> {\n\n\t\tT load();\n\n\t\tS loadFromParent();\n\t}\n\n\n\tpublic interface SettingsDao<T extends Settings, S> extends Dao<T, S> {\n\n\t\t@Override\n\t\tT load();\n\t}\n\n\n\tpublic interface ConcreteSettingsDao extends SettingsDao<ConcreteSettings, String> {\n\n\t\t@Override\n\t\tString loadFromParent();\n\t}\n\n\n\tabstract static class AbstractDaoImpl<T, S> implements Dao<T, S> {\n\n\t\tprotected T object;\n\n\t\tprotected S otherObject;\n\n\t\tprotected AbstractDaoImpl(T object, S otherObject) {\n\t\t\tthis.object = object;\n\t\t\tthis.otherObject = otherObject;\n\t\t}\n\n\t\t// @Transactional(readOnly = true)\n\t\t@Override\n\t\tpublic S loadFromParent() {\n\t\t\treturn otherObject;\n\t\t}\n\t}\n\n\n\tstatic class SettingsDaoImpl extends AbstractDaoImpl<ConcreteSettings, String>\n\t\t\timplements ConcreteSettingsDao {\n\n\t\tprotected SettingsDaoImpl(ConcreteSettings object) {\n\t\t\tsuper(object, \"From Parent\");\n\t\t}\n\n\t\t// @Transactional(readOnly = true)\n\t\t@Override\n\t\tpublic ConcreteSettings load() {\n\t\t\treturn super.object;\n\t\t}\n\t}\n\n\n\tpublic interface Bounded<E> {\n\n\t\tboolean boundedOperation(E e);\n\t}\n\n\n\tprivate static class AbstractBounded<E> implements Bounded<E> {\n\n\t\t@Override\n\t\tpublic boolean boundedOperation(E myE) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\n\tprivate static class SerializableBounded<E extends HashMap & Delayed> extends AbstractBounded<E> {\n\n\t\t@Override\n\t\tpublic boolean boundedOperation(E myE) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\n\tpublic interface GenericParameter<T> {\n\n\t\tT getFor(Class<T> cls);\n\t}\n\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class StringGenericParameter implements GenericParameter<String> {\n\n\t\t@Override\n\t\tpublic String getFor(Class<String> cls) {\n\t\t\treturn \"foo\";\n\t\t}\n\n\t\tpublic String getFor(Integer integer) {\n\t\t\treturn \"foo\";\n\t\t}\n\t}\n\n\n\tprivate static class StringList implements List<String> {\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object o) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<String> iterator() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] a) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(String o) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends String> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(int index, Collection<? extends String> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic String get(int index) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic String set(int index, String element) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void add(int index, String element) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic String remove(int index) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic int indexOf(Object o) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic int lastIndexOf(Object o) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic ListIterator<String> listIterator() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic ListIterator<String> listIterator(int index) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> subList(int fromIndex, int toIndex) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\tpublic interface Event {\n\n\t\tint getPriority();\n\t}\n\n\n\tpublic static class GenericEvent implements Event {\n\n\t\tprivate int priority;\n\n\t\t@Override\n\t\tpublic int getPriority() {\n\t\t\treturn priority;\n\t\t}\n\n\t\t/**\n\t\t * Constructor that takes an event priority\n\t\t */\n\t\tpublic GenericEvent(int priority) {\n\t\t\tthis.priority = priority;\n\t\t}\n\n\t\t/**\n\t\t * Default Constructor\n\t\t */\n\t\tpublic GenericEvent() {\n\t\t}\n\t}\n\n\n\tpublic interface UserInitiatedEvent {\n\t}\n\n\n\tpublic abstract static class BaseUserInitiatedEvent extends GenericEvent implements UserInitiatedEvent {\n\t}\n\n\n\tpublic static class MessageEvent extends BaseUserInitiatedEvent {\n\t}\n\n\n\tpublic interface Channel<E extends Event> {\n\n\t\tvoid send(E event);\n\n\t\tvoid subscribe(final Receiver<E> receiver, Class<E> event);\n\n\t\tvoid unsubscribe(final Receiver<E> receiver, Class<E> event);\n\t}\n\n\n\tpublic interface Broadcaster {\n\t}\n\n\n\tpublic interface EventBroadcaster extends Broadcaster {\n\n\t\tvoid subscribe();\n\n\t\tvoid unsubscribe();\n\n\t\tvoid setChannel(Channel<?> channel);\n\t}\n\n\n\tpublic static class GenericBroadcasterImpl implements Broadcaster {\n\t}\n\n\n\t@SuppressWarnings({\"unused\", \"unchecked\"})\n\tpublic abstract static class GenericEventBroadcasterImpl<T extends Event>\n\t\t\textends GenericBroadcasterImpl implements EventBroadcaster {\n\n\t\tprivate Class<T>[] subscribingEvents;\n\n\t\tprivate Channel<T> channel;\n\n\t\t/**\n\t\t * Abstract method to retrieve instance of subclass\n\t\t *\n\t\t * @return receiver instance\n\t\t */\n\t\tpublic abstract Receiver<T> getInstance();\n\n\t\t@Override\n\t\tpublic void setChannel(Channel channel) {\n\t\t\tthis.channel = channel;\n\t\t}\n\n\t\tprivate String beanName;\n\n\t\tpublic void setBeanName(String name) {\n\t\t\tthis.beanName = name;\n\t\t}\n\n\t\t@Override\n\t\tpublic void subscribe() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void unsubscribe() {\n\t\t}\n\n\t\tpublic GenericEventBroadcasterImpl(Class<? extends T>... events) {\n\t\t}\n\t}\n\n\n\tpublic interface Receiver<E extends Event> {\n\n\t\tvoid receive(E event);\n\t}\n\n\n\tpublic interface MessageBroadcaster extends Receiver<MessageEvent> {\n\n\t}\n\n\n\tpublic static class RemovedMessageEvent extends MessageEvent {\n\n\t}\n\n\n\tpublic static class NewMessageEvent extends MessageEvent {\n\n\t}\n\n\n\tpublic static class ModifiedMessageEvent extends MessageEvent {\n\n\t}\n\n\n\t@SuppressWarnings({\"serial\", \"unchecked\"})\n\tpublic static class MessageBroadcasterImpl extends GenericEventBroadcasterImpl<MessageEvent>\n\t\t\timplements Serializable,  // implement an unrelated interface first (SPR-16288)\n\t\t\tMessageBroadcaster {\n\n\t\tpublic MessageBroadcasterImpl() {\n\t\t\tsuper(NewMessageEvent.class);\n\t\t}\n\n\t\t@Override\n\t\tpublic void receive(MessageEvent event) {\n\t\t\tthrow new UnsupportedOperationException(\"should not be called, use subclassed events\");\n\t\t}\n\n\t\tpublic void receive(NewMessageEvent event) {\n\t\t}\n\n\t\t@Override\n\t\tpublic Receiver<MessageEvent> getInstance() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void receive(RemovedMessageEvent event) {\n\t\t}\n\n\t\tpublic void receive(ModifiedMessageEvent event) {\n\t\t}\n\t}\n\n\n\t//-----------------------------\n\t// SPR-2454 Test Classes\n\t//-----------------------------\n\n\tpublic interface SimpleGenericRepository<T> {\n\n\t\tClass<T> getPersistentClass();\n\n\t\tList<T> findByQuery();\n\n\t\tList<T> findAll();\n\n\t\tT refresh(T entity);\n\n\t\tT saveOrUpdate(T entity);\n\n\t\tvoid delete(Collection<T> entities);\n\t}\n\n\n\tpublic interface RepositoryRegistry {\n\n\t\t<T> SimpleGenericRepository<T> getFor(Class<T> entityType);\n\t}\n\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static class SettableRepositoryRegistry<R extends SimpleGenericRepository<?>>\n\t\t\timplements RepositoryRegistry {\n\n\t\tprotected void injectInto(R rep) {\n\t\t}\n\n\t\tpublic void register(R rep) {\n\t\t}\n\n\t\tpublic void register(R... reps) {\n\t\t}\n\n\t\tpublic void setRepos(R... reps) {\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> SimpleGenericRepository<T> getFor(Class<T> entityType) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void afterPropertiesSet() {\n\t\t}\n\t}\n\n\n\tpublic interface ConvenientGenericRepository<T, ID extends Serializable>\n\t\t\textends SimpleGenericRepository<T> {\n\n\t\tT findById(ID id, boolean lock);\n\n\t\tList<T> findByExample(T exampleInstance);\n\n\t\tvoid delete(ID id);\n\n\t\tvoid delete(T entity);\n\t}\n\n\n\tpublic static class GenericHibernateRepository<T, ID extends Serializable>\n\t\t\timplements ConvenientGenericRepository<T, ID> {\n\n\t\t/**\n\t\t * @param c Mandatory. The domain class this repository is responsible for.\n\t\t */\n\t\t// Since it is impossible to determine the actual type of a type\n\t\t// parameter (!), we resort to requiring the caller to provide the\n\t\t// actual type as parameter, too.\n\t\t// Not set in a constructor to enable easy CGLIB-proxying (passing\n\t\t// constructor arguments to Spring AOP proxies is quite cumbersome).\n\t\tpublic void setPersistentClass(Class<T> c) {\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<T> getPersistentClass() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic T findById(ID id, boolean lock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<T> findAll() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<T> findByExample(T exampleInstance) {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<T> findByQuery() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic T saveOrUpdate(T entity) {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void delete(T entity) {\n\t\t}\n\n\t\t@Override\n\t\tpublic T refresh(T entity) {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void delete(ID id) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void delete(Collection<T> entities) {\n\t\t}\n\t}\n\n\n\tpublic static class HibernateRepositoryRegistry\n\t\t\textends SettableRepositoryRegistry<GenericHibernateRepository<?, ?>> {\n\n\t\t@Override\n\t\tpublic void injectInto(GenericHibernateRepository<?, ?> rep) {\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> GenericHibernateRepository<T, ?> getFor(Class<T> entityType) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-2603 classes\n\t//-------------------\n\n\tpublic interface Homer<E> {\n\n\t\tvoid foo(E e);\n\t}\n\n\n\tpublic static class MyHomer<T extends Bounded<T>, L extends T> implements Homer<L> {\n\n\t\t@Override\n\t\tpublic void foo(L t) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\tpublic static class YourHomer<T extends AbstractBounded<T>, L extends T> extends\n\t\t\tMyHomer<T, L> {\n\n\t\t@Override\n\t\tpublic void foo(L t) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\tpublic interface GenericDao<T> {\n\n\t\tvoid saveOrUpdate(T t);\n\t}\n\n\n\tpublic interface ConvenienceGenericDao<T> extends GenericDao<T> {\n\t}\n\n\n\tpublic static class GenericSqlMapDao<T extends Serializable> implements ConvenienceGenericDao<T> {\n\n\t\t@Override\n\t\tpublic void saveOrUpdate(T t) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\tpublic static class GenericSqlMapIntegerDao<T extends Number> extends GenericSqlMapDao<T> {\n\n\t\t@Override\n\t\tpublic void saveOrUpdate(T t) {\n\t\t}\n\t}\n\n\n\tpublic static class Permission {\n\t}\n\n\n\tpublic static class User {\n\t}\n\n\n\tpublic interface UserDao {\n\n\t\t// @Transactional\n\t\tvoid save(User user);\n\n\t\t// @Transactional\n\t\tvoid save(Permission perm);\n\t}\n\n\n\tpublic abstract static class AbstractDao<T> {\n\n\t\tpublic void save(T t) {\n\t\t}\n\n\t\tpublic void saveVararg(T t, Object... args) {\n\t\t}\n\t}\n\n\n\tpublic static class UserDaoImpl extends AbstractDao<User> implements UserDao {\n\n\t\t@Override\n\t\tpublic void save(Permission perm) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void saveVararg(User user, Object... args) {\n\t\t}\n\t}\n\n\n\tpublic interface DaoInterface<T, P> {\n\n\t\tT get(P id);\n\t}\n\n\n\tpublic abstract static class BusinessGenericDao<T, PK extends Serializable>\n\t\t\timplements DaoInterface<T, PK> {\n\n\t\tpublic void save(T object) {\n\t\t}\n\t}\n\n\n\tpublic static class Business<T> {\n\t}\n\n\n\tpublic static class BusinessDao extends BusinessGenericDao<Business<?>, Long> {\n\n\t\t@Override\n\t\tpublic void save(Business<?> business) {\n\t\t}\n\n\t\t@Override\n\t\tpublic Business<?> get(Long id) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic Business<?> get(String code) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-3304 classes\n\t//-------------------\n\n\tprivate static class MegaEvent {\n\t}\n\n\n\tprivate static class MegaMessageEvent extends MegaEvent {\n\t}\n\n\n\tprivate static class NewMegaMessageEvent extends MegaEvent {\n\t}\n\n\n\tprivate static class ModifiedMegaMessageEvent extends MegaEvent {\n\t}\n\n\n\tpublic interface MegaReceiver<E extends MegaEvent> {\n\n\t\tvoid receive(E event);\n\t}\n\n\n\tpublic interface MegaMessageProducer extends MegaReceiver<MegaMessageEvent> {\n\t}\n\n\n\tprivate static class Other<S,E> {\n\t}\n\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class MegaMessageProducerImpl extends Other<Long, String> implements MegaMessageProducer {\n\n\t\tpublic void receive(NewMegaMessageEvent event) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\tpublic void receive(ModifiedMegaMessageEvent event) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void receive(MegaMessageEvent event) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-3357 classes\n\t//-------------------\n\n\tprivate static class DomainObjectSuper {\n\t}\n\n\n\tprivate static class DomainObjectExtendsSuper extends DomainObjectSuper {\n\t}\n\n\n\tpublic interface IGenericInterface<D extends DomainObjectSuper> {\n\n\t\t<T> void doSomething(final D domainObject, final T value);\n\t}\n\n\n\t@SuppressWarnings(\"unused\")\n\tprivate abstract static class AbstractImplementsInterface<D extends DomainObjectSuper> implements IGenericInterface<D> {\n\n\t\t@Override\n\t\tpublic <T> void doSomething(D domainObject, T value) {\n\t\t}\n\n\t\tpublic void anotherBaseMethod() {\n\t\t}\n\t}\n\n\n\tprivate static class ExtendsAbstractImplementsInterface extends AbstractImplementsInterface<DomainObjectExtendsSuper> {\n\n\t\t@Override\n\t\tpublic <T> void doSomething(DomainObjectExtendsSuper domainObject, T value) {\n\t\t\tsuper.doSomething(domainObject, value);\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-3485 classes\n\t//-------------------\n\n\t@SuppressWarnings(\"serial\")\n\tprivate static class ParameterType implements Serializable {\n\t}\n\n\n\tprivate static class AbstractDomainObject<P extends Serializable, R> {\n\n\t\tpublic R method1(P p) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void method2(P p, R r) {\n\t\t}\n\t}\n\n\n\tprivate static class DomainObject extends AbstractDomainObject<ParameterType, byte[]> {\n\n\t\t@Override\n\t\tpublic byte[] method1(ParameterType p) {\n\t\t\treturn super.method1(p);\n\t\t}\n\n\t\t@Override\n\t\tpublic void method2(ParameterType p, byte[] r) {\n\t\t\tsuper.method2(p, r);\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-3534 classes\n\t//-------------------\n\n\tpublic interface SearchProvider<RETURN_TYPE, CONDITIONS_TYPE> {\n\n\t\tCollection<RETURN_TYPE> findBy(CONDITIONS_TYPE conditions);\n\t}\n\n\n\tpublic static class SearchConditions {\n\t}\n\n\n\tpublic interface IExternalMessageProvider<S extends ExternalMessage, T extends ExternalMessageSearchConditions<?>>\n\t\t\textends SearchProvider<S, T> {\n\t}\n\n\n\tpublic static class ExternalMessage {\n\t}\n\n\n\tpublic static class ExternalMessageSearchConditions<T extends ExternalMessage> extends SearchConditions {\n\t}\n\n\n\tpublic static class ExternalMessageProvider<S extends ExternalMessage, T extends ExternalMessageSearchConditions<S>>\n\t\t\timplements IExternalMessageProvider<S, T> {\n\n\t\t@Override\n\t\tpublic Collection<S> findBy(T conditions) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\tpublic static class EmailMessage extends ExternalMessage {\n\t}\n\n\n\tpublic static class EmailSearchConditions extends ExternalMessageSearchConditions<EmailMessage> {\n\t}\n\n\n\tpublic static class EmailMessageProvider extends ExternalMessageProvider<EmailMessage, EmailSearchConditions> {\n\t}\n\n\n\tpublic static class TestEmailProvider extends EmailMessageProvider {\n\n\t\t@Override\n\t\tpublic Collection<EmailMessage> findBy(EmailSearchConditions conditions) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-16103 classes\n\t//-------------------\n\n\tpublic abstract static class BaseEntity {\n\t}\n\n\tpublic static class FooEntity extends BaseEntity {\n\t}\n\n\tpublic static class BaseClass<T> {\n\n\t\tpublic <S extends T> S test(S T) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic static class EntityClass<T extends BaseEntity> extends BaseClass<T> {\n\n\t\t@Override\n\t\tpublic <S extends T> S test(S T) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic static class FooClass extends EntityClass<FooEntity> {\n\n\t\t@Override\n\t\tpublic <S extends FooEntity> S test(S T) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic interface BaseInterface<T> {\n\n\t\t<S extends T> S test(S T);\n\t}\n\n\tpublic interface EntityInterface<T extends BaseEntity> extends BaseInterface<T> {\n\n\t\t@Override\n\t\t<S extends T> S test(S T);\n\t}\n\n\tpublic interface FooInterface extends EntityInterface<FooEntity> {\n\n\t\t@Override\n\t\t<S extends FooEntity> S test(S T);\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.RemovedMessageEvent",
    "headType": "class",
    "relation": "extend",
    "tail": "MessageEvent",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.NewMessageEvent",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.NewMessageEvent",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.concurrent.DelayQueue;\nimport java.util.concurrent.Delayed;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.testfixture.ide.IdeUtils;\nimport org.springframework.util.ReflectionUtils;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @author Chris Beams\n * @author Yanming Zhou\n */\n@SuppressWarnings(\"rawtypes\")\nclass BridgeMethodResolverTests {\n\n\tprivate static Method findMethodWithReturnType(String name, Class<?> returnType, Class<SettingsDaoImpl> targetType) {\n\t\tMethod[] methods = targetType.getMethods();\n\t\tfor (Method m : methods) {\n\t\t\tif (m.getName().equals(name) && m.getReturnType().equals(returnType)) {\n\t\t\t\treturn m;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t@Test\n\tvoid findBridgedMethod() throws Exception {\n\t\tMethod unbridged = MyFoo.class.getDeclaredMethod(\"someMethod\", String.class, Object.class);\n\t\tMethod bridged = MyFoo.class.getDeclaredMethod(\"someMethod\", Serializable.class, Object.class);\n\t\tassertThat(unbridged.isBridge()).isFalse();\n\t\tassertThat(bridged.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(unbridged)).as(\"Unbridged method not returned directly\").isEqualTo(unbridged);\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridged)).as(\"Incorrect bridged method returned\").isEqualTo(unbridged);\n\t}\n\n\t@Test\n\tvoid findBridgedVarargMethod() throws Exception {\n\t\tMethod unbridged = MyFoo.class.getDeclaredMethod(\"someVarargMethod\", String.class, Object[].class);\n\t\tMethod bridged = MyFoo.class.getDeclaredMethod(\"someVarargMethod\", Serializable.class, Object[].class);\n\t\tassertThat(unbridged.isBridge()).isFalse();\n\t\tassertThat(bridged.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(unbridged)).as(\"Unbridged method not returned directly\").isEqualTo(unbridged);\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridged)).as(\"Incorrect bridged method returned\").isEqualTo(unbridged);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodInHierarchy() throws Exception {\n\t\tMethod bridgeMethod = DateAdder.class.getMethod(\"add\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\tMethod bridgedMethod = BridgeMethodResolver.findBridgedMethod(bridgeMethod);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tassertThat(bridgedMethod.getName()).isEqualTo(\"add\");\n\t\tassertThat(bridgedMethod.getParameterCount()).isEqualTo(1);\n\t\tassertThat(bridgedMethod.getParameterTypes()[0]).isEqualTo(Date.class);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodFromOriginalMethodInHierarchy() throws Exception {\n\t\tMethod originalMethod = Adder.class.getMethod(\"add\", Object.class);\n\t\tassertThat(originalMethod.isBridge()).isFalse();\n\t\tMethod bridgedMethod = BridgeMethodResolver.getMostSpecificMethod(originalMethod, DateAdder.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tassertThat(bridgedMethod.getName()).isEqualTo(\"add\");\n\t\tassertThat(bridgedMethod.getParameterCount()).isEqualTo(1);\n\t\tassertThat(bridgedMethod.getParameterTypes()[0]).isEqualTo(Date.class);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodFromOriginalMethodNotInHierarchy() throws Exception {\n\t\tMethod originalMethod = Adder.class.getMethod(\"add\", Object.class);\n\t\tMethod mostSpecificMethod = BridgeMethodResolver.getMostSpecificMethod(originalMethod, FakeAdder.class);\n\t\tassertThat(mostSpecificMethod).isSameAs(originalMethod);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodInHierarchyWithBoundedGenerics() throws Exception {\n\t\tMethod originalMethod = Bar.class.getDeclaredMethod(\"someMethod\", Object.class, Object.class);\n\t\tassertThat(originalMethod.isBridge()).isFalse();\n\t\tMethod bridgedMethod = BridgeMethodResolver.getMostSpecificMethod(originalMethod, SubBar.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tassertThat(bridgedMethod.getName()).isEqualTo(\"someMethod\");\n\t\tassertThat(bridgedMethod.getParameterCount()).isEqualTo(2);\n\t\tassertThat(bridgedMethod.getParameterTypes()[0]).isEqualTo(CharSequence.class);\n\t}\n\n\t@Test\n\tvoid isBridgeMethodFor() throws Exception {\n\t\tMethod bridged = MyBar.class.getDeclaredMethod(\"someMethod\", String.class, Object.class);\n\t\tMethod other = MyBar.class.getDeclaredMethod(\"someMethod\", Integer.class, Object.class);\n\t\tMethod bridge;\n\n\t\tif (IdeUtils.runningInEclipse()) {\n\t\t\tbridge = InterBar.class.getDeclaredMethod(\"someMethod\", Object.class, Object.class);\n\t\t}\n\t\telse {\n\t\t\tbridge = MyBar.class.getDeclaredMethod(\"someMethod\", Object.class, Object.class);\n\t\t}\n\t\tassertThat(bridge.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.isBridgeMethodFor(bridge, bridged, MyBar.class)).as(\"Should be bridge method\").isTrue();\n\t\tassertThat(BridgeMethodResolver.isBridgeMethodFor(bridge, other, MyBar.class)).as(\"Should not be bridge method\").isFalse();\n\t}\n\n\t@Test\n\tvoid doubleParameterization() throws Exception {\n\t\tMethod objectBridge = MyBoo.class.getDeclaredMethod(\"foo\", Object.class);\n\t\tMethod serializableBridge = MyBoo.class.getDeclaredMethod(\"foo\", Serializable.class);\n\n\t\tMethod stringFoo = MyBoo.class.getDeclaredMethod(\"foo\", String.class);\n\t\tMethod integerFoo = MyBoo.class.getDeclaredMethod(\"foo\", Integer.class);\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(objectBridge)).as(\"foo(String) not resolved.\").isEqualTo(stringFoo);\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(serializableBridge)).as(\"foo(Integer) not resolved.\").isEqualTo(integerFoo);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodFromMultipleBridges() throws Exception {\n\t\tMethod loadWithObjectReturn = findMethodWithReturnType(\"load\", Object.class, SettingsDaoImpl.class);\n\t\tassertThat(loadWithObjectReturn).isNotNull();\n\n\t\tMethod loadWithSettingsReturn = findMethodWithReturnType(\"load\", Settings.class, SettingsDaoImpl.class);\n\t\tassertThat(loadWithSettingsReturn).isNotNull();\n\t\tassertThat(loadWithSettingsReturn).isNotSameAs(loadWithObjectReturn);\n\n\t\tMethod method = SettingsDaoImpl.class.getMethod(\"load\");\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(loadWithObjectReturn)).isEqualTo(method);\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(loadWithSettingsReturn)).isEqualTo(method);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodFromParent() throws Exception {\n\t\tMethod loadFromParentBridge = SettingsDaoImpl.class.getMethod(\"loadFromParent\");\n\t\tassertThat(loadFromParentBridge.isBridge()).isTrue();\n\n\t\tMethod loadFromParent = AbstractDaoImpl.class.getMethod(\"loadFromParent\");\n\t\tassertThat(loadFromParent.isBridge()).isFalse();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(loadFromParentBridge)).isEqualTo(loadFromParent);\n\t}\n\n\t@Test\n\tvoid withSingleBoundParameterizedOnInstantiate() throws Exception {\n\t\tMethod bridgeMethod = DelayQueue.class.getMethod(\"add\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\tMethod actualMethod = DelayQueue.class.getMethod(\"add\", Delayed.class);\n\t\tassertThat(actualMethod.isBridge()).isFalse();\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(actualMethod);\n\t}\n\n\t@Test\n\tvoid withDoubleBoundParameterizedOnInstantiate() throws Exception {\n\t\tMethod bridgeMethod = SerializableBounded.class.getMethod(\"boundedOperation\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\tMethod actualMethod = SerializableBounded.class.getMethod(\"boundedOperation\", HashMap.class);\n\t\tassertThat(actualMethod.isBridge()).isFalse();\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(actualMethod);\n\t}\n\n\t@Test\n\tvoid withGenericParameter() {\n\t\tMethod[] methods = StringGenericParameter.class.getMethods();\n\t\tMethod bridgeMethod = null;\n\t\tMethod bridgedMethod = null;\n\t\tfor (Method method : methods) {\n\t\t\tif (\"getFor\".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {\n\t\t\t\tif (method.getReturnType().equals(Object.class)) {\n\t\t\t\t\tbridgeMethod = method;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbridgedMethod = method;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\n\t\tboolean condition = bridgedMethod != null && !bridgedMethod.isBridge();\n\t\tassertThat(condition).isTrue();\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid onAllMethods() {\n\t\tMethod[] methods = StringList.class.getMethods();\n\t\tfor (Method method : methods) {\n\t\t\tassertThat(BridgeMethodResolver.findBridgedMethod(method)).isNotNull();\n\t\t}\n\t}\n\n\t@Test\n\tvoid spr2583() throws Exception {\n\t\tMethod bridgedMethod = MessageBroadcasterImpl.class.getMethod(\"receive\", MessageEvent.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tMethod bridgeMethod = MessageBroadcasterImpl.class.getMethod(\"receive\", Event.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tMethod otherMethod = MessageBroadcasterImpl.class.getMethod(\"receive\", NewMessageEvent.class);\n\t\tassertThat(otherMethod.isBridge()).isFalse();\n\n\t\tassertThat(BridgeMethodResolver.isBridgeMethodFor(bridgeMethod, otherMethod, MessageBroadcasterImpl.class)).as(\"Match identified incorrectly\").isFalse();\n\t\tassertThat(BridgeMethodResolver.isBridgeMethodFor(bridgeMethod, bridgedMethod, MessageBroadcasterImpl.class)).as(\"Match not found correctly\").isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr2603() throws Exception {\n\t\tMethod objectBridge = YourHomer.class.getDeclaredMethod(\"foo\", Bounded.class);\n\t\tMethod abstractBoundedFoo = YourHomer.class.getDeclaredMethod(\"foo\", AbstractBounded.class);\n\n\t\tMethod bridgedMethod = BridgeMethodResolver.findBridgedMethod(objectBridge);\n\t\tassertThat(bridgedMethod).as(\"foo(AbstractBounded) not resolved.\").isEqualTo(abstractBoundedFoo);\n\t}\n\n\t@Test\n\tvoid spr2648() {\n\t\tMethod bridgeMethod = ReflectionUtils.findMethod(GenericSqlMapIntegerDao.class, \"saveOrUpdate\", Object.class);\n\t\tassertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\n\t\tMethod bridgedMethod = BridgeMethodResolver.findBridgedMethod(bridgeMethod);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tassertThat(bridgedMethod.getName()).isEqualTo(\"saveOrUpdate\");\n\t}\n\n\t@Test\n\tvoid spr2763() throws Exception {\n\t\tMethod bridgedMethod = AbstractDao.class.getDeclaredMethod(\"save\", Object.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = UserDaoImpl.class.getDeclaredMethod(\"save\", User.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3041() throws Exception {\n\t\tMethod bridgedMethod = BusinessDao.class.getDeclaredMethod(\"save\", Business.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = BusinessDao.class.getDeclaredMethod(\"save\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3173() throws Exception {\n\t\tMethod bridgedMethod = UserDaoImpl.class.getDeclaredMethod(\"saveVararg\", User.class, Object[].class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = UserDaoImpl.class.getDeclaredMethod(\"saveVararg\", Object.class, Object[].class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3304() throws Exception {\n\t\tMethod bridgedMethod = MegaMessageProducerImpl.class.getDeclaredMethod(\"receive\", MegaMessageEvent.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = MegaMessageProducerImpl.class.getDeclaredMethod(\"receive\", MegaEvent.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3324() throws Exception {\n\t\tMethod bridgedMethod = BusinessDao.class.getDeclaredMethod(\"get\", Long.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = BusinessDao.class.getDeclaredMethod(\"get\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3357() throws Exception {\n\t\tMethod bridgedMethod = ExtendsAbstractImplementsInterface.class.getDeclaredMethod(\n\t\t\t\t\"doSomething\", DomainObjectExtendsSuper.class, Object.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = ExtendsAbstractImplementsInterface.class.getDeclaredMethod(\n\t\t\t\t\"doSomething\", DomainObjectSuper.class, Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3485() throws Exception {\n\t\tMethod bridgedMethod = DomainObject.class.getDeclaredMethod(\n\t\t\t\t\"method2\", ParameterType.class, byte[].class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = DomainObject.class.getDeclaredMethod(\n\t\t\t\t\"method2\", Serializable.class, Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3534() {\n\t\tMethod bridgeMethod = ReflectionUtils.findMethod(TestEmailProvider.class, \"findBy\", Object.class);\n\t\tassertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\n\t\tMethod bridgedMethod = BridgeMethodResolver.findBridgedMethod(bridgeMethod);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tassertThat(bridgedMethod.getName()).isEqualTo(\"findBy\");\n\t}\n\n\t@Test  // SPR-16103\n\tvoid testClassHierarchy() throws Exception {\n\t\tdoTestHierarchyResolution(FooClass.class);\n\t}\n\n\t@Test  // SPR-16103\n\tvoid testInterfaceHierarchy() throws Exception {\n\t\tdoTestHierarchyResolution(FooInterface.class);\n\t}\n\n\tprivate void doTestHierarchyResolution(Class<?> clazz) throws Exception {\n\t\tfor (Method method : clazz.getDeclaredMethods()){\n\t\t\tMethod bridged = BridgeMethodResolver.findBridgedMethod(method);\n\t\t\tMethod expected = clazz.getMethod(\"test\", FooEntity.class);\n\t\t\tassertThat(bridged).isEqualTo(expected);\n\t\t}\n\t}\n\n\n\tpublic interface Foo<T extends Serializable> {\n\n\t\tvoid someMethod(T theArg, Object otherArg);\n\n\t\tvoid someVarargMethod(T theArg, Object... otherArg);\n\t}\n\n\n\tpublic static class MyFoo implements Foo<String> {\n\n\t\tpublic void someMethod(Integer theArg, Object otherArg) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void someMethod(String theArg, Object otherArg) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void someVarargMethod(String theArg, Object... otherArgs) {\n\t\t}\n\t}\n\n\n\tpublic abstract static class Bar<T> {\n\n\t\tvoid someMethod(Map<?, ?> m, Object otherArg) {\n\t\t}\n\n\t\tvoid someMethod(T theArg, Map<?, ?> m) {\n\t\t}\n\n\t\tabstract void someMethod(T theArg, Object otherArg);\n\t}\n\n\n\tpublic abstract static class InterBar<T extends CharSequence> extends Bar<T> {\n\n\t\t@Override\n\t\tvoid someMethod(T theArg, Object otherArg) {\n\t\t}\n\t}\n\n\n\tpublic abstract static class SubBar<T extends StringProducer> extends InterBar<T> {\n\t}\n\n\tpublic interface StringProducer extends CharSequence {\n\t}\n\n\n\tpublic static class MyBar extends InterBar<String> {\n\n\t\t@Override\n\t\tpublic void someMethod(String theArg, Object otherArg) {\n\t\t}\n\n\t\tpublic void someMethod(Integer theArg, Object otherArg) {\n\t\t}\n\t}\n\n\n\tpublic interface Adder<T> {\n\n\t\tvoid add(T item);\n\t}\n\n\n\tpublic abstract static class AbstractDateAdder implements Adder<Date> {\n\n\t\t@Override\n\t\tpublic abstract void add(Date date);\n\t}\n\n\n\tpublic static class DateAdder extends AbstractDateAdder {\n\n\t\t@Override\n\t\tpublic void add(Date date) {\n\t\t}\n\t}\n\n\n\tpublic static class FakeAdder {\n\n\t\tpublic void add(Date date) {\n\t\t}\n\t}\n\n\n\tpublic static class Enclosing<T> {\n\n\t\tpublic class Enclosed<S> {\n\n\t\t\tpublic class ReallyDeepNow<R> {\n\n\t\t\t\tvoid someMethod(S s, T t, R r) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tpublic static class ExtendsEnclosing extends Enclosing<String> {\n\n\t\tpublic class ExtendsEnclosed extends Enclosed<Integer> {\n\n\t\t\tpublic class ExtendsReallyDeepNow extends ReallyDeepNow<Long> {\n\n\t\t\t\t@Override\n\t\t\t\tvoid someMethod(Integer s, String t, Long r) {\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tpublic interface Boo<E, T extends Serializable> {\n\n\t\tvoid foo(E e);\n\n\t\tvoid foo(T t);\n\t}\n\n\n\tpublic static class MyBoo implements Boo<String, Integer> {\n\n\t\t@Override\n\t\tpublic void foo(String e) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void foo(Integer t) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\tpublic interface Settings {\n\t}\n\n\n\tpublic interface ConcreteSettings extends Settings {\n\t}\n\n\n\tpublic interface Dao<T, S> {\n\n\t\tT load();\n\n\t\tS loadFromParent();\n\t}\n\n\n\tpublic interface SettingsDao<T extends Settings, S> extends Dao<T, S> {\n\n\t\t@Override\n\t\tT load();\n\t}\n\n\n\tpublic interface ConcreteSettingsDao extends SettingsDao<ConcreteSettings, String> {\n\n\t\t@Override\n\t\tString loadFromParent();\n\t}\n\n\n\tabstract static class AbstractDaoImpl<T, S> implements Dao<T, S> {\n\n\t\tprotected T object;\n\n\t\tprotected S otherObject;\n\n\t\tprotected AbstractDaoImpl(T object, S otherObject) {\n\t\t\tthis.object = object;\n\t\t\tthis.otherObject = otherObject;\n\t\t}\n\n\t\t// @Transactional(readOnly = true)\n\t\t@Override\n\t\tpublic S loadFromParent() {\n\t\t\treturn otherObject;\n\t\t}\n\t}\n\n\n\tstatic class SettingsDaoImpl extends AbstractDaoImpl<ConcreteSettings, String>\n\t\t\timplements ConcreteSettingsDao {\n\n\t\tprotected SettingsDaoImpl(ConcreteSettings object) {\n\t\t\tsuper(object, \"From Parent\");\n\t\t}\n\n\t\t// @Transactional(readOnly = true)\n\t\t@Override\n\t\tpublic ConcreteSettings load() {\n\t\t\treturn super.object;\n\t\t}\n\t}\n\n\n\tpublic interface Bounded<E> {\n\n\t\tboolean boundedOperation(E e);\n\t}\n\n\n\tprivate static class AbstractBounded<E> implements Bounded<E> {\n\n\t\t@Override\n\t\tpublic boolean boundedOperation(E myE) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\n\tprivate static class SerializableBounded<E extends HashMap & Delayed> extends AbstractBounded<E> {\n\n\t\t@Override\n\t\tpublic boolean boundedOperation(E myE) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\n\tpublic interface GenericParameter<T> {\n\n\t\tT getFor(Class<T> cls);\n\t}\n\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class StringGenericParameter implements GenericParameter<String> {\n\n\t\t@Override\n\t\tpublic String getFor(Class<String> cls) {\n\t\t\treturn \"foo\";\n\t\t}\n\n\t\tpublic String getFor(Integer integer) {\n\t\t\treturn \"foo\";\n\t\t}\n\t}\n\n\n\tprivate static class StringList implements List<String> {\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object o) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<String> iterator() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] a) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(String o) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends String> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(int index, Collection<? extends String> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic String get(int index) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic String set(int index, String element) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void add(int index, String element) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic String remove(int index) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic int indexOf(Object o) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic int lastIndexOf(Object o) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic ListIterator<String> listIterator() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic ListIterator<String> listIterator(int index) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> subList(int fromIndex, int toIndex) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\tpublic interface Event {\n\n\t\tint getPriority();\n\t}\n\n\n\tpublic static class GenericEvent implements Event {\n\n\t\tprivate int priority;\n\n\t\t@Override\n\t\tpublic int getPriority() {\n\t\t\treturn priority;\n\t\t}\n\n\t\t/**\n\t\t * Constructor that takes an event priority\n\t\t */\n\t\tpublic GenericEvent(int priority) {\n\t\t\tthis.priority = priority;\n\t\t}\n\n\t\t/**\n\t\t * Default Constructor\n\t\t */\n\t\tpublic GenericEvent() {\n\t\t}\n\t}\n\n\n\tpublic interface UserInitiatedEvent {\n\t}\n\n\n\tpublic abstract static class BaseUserInitiatedEvent extends GenericEvent implements UserInitiatedEvent {\n\t}\n\n\n\tpublic static class MessageEvent extends BaseUserInitiatedEvent {\n\t}\n\n\n\tpublic interface Channel<E extends Event> {\n\n\t\tvoid send(E event);\n\n\t\tvoid subscribe(final Receiver<E> receiver, Class<E> event);\n\n\t\tvoid unsubscribe(final Receiver<E> receiver, Class<E> event);\n\t}\n\n\n\tpublic interface Broadcaster {\n\t}\n\n\n\tpublic interface EventBroadcaster extends Broadcaster {\n\n\t\tvoid subscribe();\n\n\t\tvoid unsubscribe();\n\n\t\tvoid setChannel(Channel<?> channel);\n\t}\n\n\n\tpublic static class GenericBroadcasterImpl implements Broadcaster {\n\t}\n\n\n\t@SuppressWarnings({\"unused\", \"unchecked\"})\n\tpublic abstract static class GenericEventBroadcasterImpl<T extends Event>\n\t\t\textends GenericBroadcasterImpl implements EventBroadcaster {\n\n\t\tprivate Class<T>[] subscribingEvents;\n\n\t\tprivate Channel<T> channel;\n\n\t\t/**\n\t\t * Abstract method to retrieve instance of subclass\n\t\t *\n\t\t * @return receiver instance\n\t\t */\n\t\tpublic abstract Receiver<T> getInstance();\n\n\t\t@Override\n\t\tpublic void setChannel(Channel channel) {\n\t\t\tthis.channel = channel;\n\t\t}\n\n\t\tprivate String beanName;\n\n\t\tpublic void setBeanName(String name) {\n\t\t\tthis.beanName = name;\n\t\t}\n\n\t\t@Override\n\t\tpublic void subscribe() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void unsubscribe() {\n\t\t}\n\n\t\tpublic GenericEventBroadcasterImpl(Class<? extends T>... events) {\n\t\t}\n\t}\n\n\n\tpublic interface Receiver<E extends Event> {\n\n\t\tvoid receive(E event);\n\t}\n\n\n\tpublic interface MessageBroadcaster extends Receiver<MessageEvent> {\n\n\t}\n\n\n\tpublic static class RemovedMessageEvent extends MessageEvent {\n\n\t}\n\n\n\tpublic static class NewMessageEvent extends MessageEvent {\n\n\t}\n\n\n\tpublic static class ModifiedMessageEvent extends MessageEvent {\n\n\t}\n\n\n\t@SuppressWarnings({\"serial\", \"unchecked\"})\n\tpublic static class MessageBroadcasterImpl extends GenericEventBroadcasterImpl<MessageEvent>\n\t\t\timplements Serializable,  // implement an unrelated interface first (SPR-16288)\n\t\t\tMessageBroadcaster {\n\n\t\tpublic MessageBroadcasterImpl() {\n\t\t\tsuper(NewMessageEvent.class);\n\t\t}\n\n\t\t@Override\n\t\tpublic void receive(MessageEvent event) {\n\t\t\tthrow new UnsupportedOperationException(\"should not be called, use subclassed events\");\n\t\t}\n\n\t\tpublic void receive(NewMessageEvent event) {\n\t\t}\n\n\t\t@Override\n\t\tpublic Receiver<MessageEvent> getInstance() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void receive(RemovedMessageEvent event) {\n\t\t}\n\n\t\tpublic void receive(ModifiedMessageEvent event) {\n\t\t}\n\t}\n\n\n\t//-----------------------------\n\t// SPR-2454 Test Classes\n\t//-----------------------------\n\n\tpublic interface SimpleGenericRepository<T> {\n\n\t\tClass<T> getPersistentClass();\n\n\t\tList<T> findByQuery();\n\n\t\tList<T> findAll();\n\n\t\tT refresh(T entity);\n\n\t\tT saveOrUpdate(T entity);\n\n\t\tvoid delete(Collection<T> entities);\n\t}\n\n\n\tpublic interface RepositoryRegistry {\n\n\t\t<T> SimpleGenericRepository<T> getFor(Class<T> entityType);\n\t}\n\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static class SettableRepositoryRegistry<R extends SimpleGenericRepository<?>>\n\t\t\timplements RepositoryRegistry {\n\n\t\tprotected void injectInto(R rep) {\n\t\t}\n\n\t\tpublic void register(R rep) {\n\t\t}\n\n\t\tpublic void register(R... reps) {\n\t\t}\n\n\t\tpublic void setRepos(R... reps) {\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> SimpleGenericRepository<T> getFor(Class<T> entityType) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void afterPropertiesSet() {\n\t\t}\n\t}\n\n\n\tpublic interface ConvenientGenericRepository<T, ID extends Serializable>\n\t\t\textends SimpleGenericRepository<T> {\n\n\t\tT findById(ID id, boolean lock);\n\n\t\tList<T> findByExample(T exampleInstance);\n\n\t\tvoid delete(ID id);\n\n\t\tvoid delete(T entity);\n\t}\n\n\n\tpublic static class GenericHibernateRepository<T, ID extends Serializable>\n\t\t\timplements ConvenientGenericRepository<T, ID> {\n\n\t\t/**\n\t\t * @param c Mandatory. The domain class this repository is responsible for.\n\t\t */\n\t\t// Since it is impossible to determine the actual type of a type\n\t\t// parameter (!), we resort to requiring the caller to provide the\n\t\t// actual type as parameter, too.\n\t\t// Not set in a constructor to enable easy CGLIB-proxying (passing\n\t\t// constructor arguments to Spring AOP proxies is quite cumbersome).\n\t\tpublic void setPersistentClass(Class<T> c) {\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<T> getPersistentClass() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic T findById(ID id, boolean lock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<T> findAll() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<T> findByExample(T exampleInstance) {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<T> findByQuery() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic T saveOrUpdate(T entity) {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void delete(T entity) {\n\t\t}\n\n\t\t@Override\n\t\tpublic T refresh(T entity) {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void delete(ID id) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void delete(Collection<T> entities) {\n\t\t}\n\t}\n\n\n\tpublic static class HibernateRepositoryRegistry\n\t\t\textends SettableRepositoryRegistry<GenericHibernateRepository<?, ?>> {\n\n\t\t@Override\n\t\tpublic void injectInto(GenericHibernateRepository<?, ?> rep) {\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> GenericHibernateRepository<T, ?> getFor(Class<T> entityType) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-2603 classes\n\t//-------------------\n\n\tpublic interface Homer<E> {\n\n\t\tvoid foo(E e);\n\t}\n\n\n\tpublic static class MyHomer<T extends Bounded<T>, L extends T> implements Homer<L> {\n\n\t\t@Override\n\t\tpublic void foo(L t) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\tpublic static class YourHomer<T extends AbstractBounded<T>, L extends T> extends\n\t\t\tMyHomer<T, L> {\n\n\t\t@Override\n\t\tpublic void foo(L t) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\tpublic interface GenericDao<T> {\n\n\t\tvoid saveOrUpdate(T t);\n\t}\n\n\n\tpublic interface ConvenienceGenericDao<T> extends GenericDao<T> {\n\t}\n\n\n\tpublic static class GenericSqlMapDao<T extends Serializable> implements ConvenienceGenericDao<T> {\n\n\t\t@Override\n\t\tpublic void saveOrUpdate(T t) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\tpublic static class GenericSqlMapIntegerDao<T extends Number> extends GenericSqlMapDao<T> {\n\n\t\t@Override\n\t\tpublic void saveOrUpdate(T t) {\n\t\t}\n\t}\n\n\n\tpublic static class Permission {\n\t}\n\n\n\tpublic static class User {\n\t}\n\n\n\tpublic interface UserDao {\n\n\t\t// @Transactional\n\t\tvoid save(User user);\n\n\t\t// @Transactional\n\t\tvoid save(Permission perm);\n\t}\n\n\n\tpublic abstract static class AbstractDao<T> {\n\n\t\tpublic void save(T t) {\n\t\t}\n\n\t\tpublic void saveVararg(T t, Object... args) {\n\t\t}\n\t}\n\n\n\tpublic static class UserDaoImpl extends AbstractDao<User> implements UserDao {\n\n\t\t@Override\n\t\tpublic void save(Permission perm) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void saveVararg(User user, Object... args) {\n\t\t}\n\t}\n\n\n\tpublic interface DaoInterface<T, P> {\n\n\t\tT get(P id);\n\t}\n\n\n\tpublic abstract static class BusinessGenericDao<T, PK extends Serializable>\n\t\t\timplements DaoInterface<T, PK> {\n\n\t\tpublic void save(T object) {\n\t\t}\n\t}\n\n\n\tpublic static class Business<T> {\n\t}\n\n\n\tpublic static class BusinessDao extends BusinessGenericDao<Business<?>, Long> {\n\n\t\t@Override\n\t\tpublic void save(Business<?> business) {\n\t\t}\n\n\t\t@Override\n\t\tpublic Business<?> get(Long id) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic Business<?> get(String code) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-3304 classes\n\t//-------------------\n\n\tprivate static class MegaEvent {\n\t}\n\n\n\tprivate static class MegaMessageEvent extends MegaEvent {\n\t}\n\n\n\tprivate static class NewMegaMessageEvent extends MegaEvent {\n\t}\n\n\n\tprivate static class ModifiedMegaMessageEvent extends MegaEvent {\n\t}\n\n\n\tpublic interface MegaReceiver<E extends MegaEvent> {\n\n\t\tvoid receive(E event);\n\t}\n\n\n\tpublic interface MegaMessageProducer extends MegaReceiver<MegaMessageEvent> {\n\t}\n\n\n\tprivate static class Other<S,E> {\n\t}\n\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class MegaMessageProducerImpl extends Other<Long, String> implements MegaMessageProducer {\n\n\t\tpublic void receive(NewMegaMessageEvent event) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\tpublic void receive(ModifiedMegaMessageEvent event) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void receive(MegaMessageEvent event) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-3357 classes\n\t//-------------------\n\n\tprivate static class DomainObjectSuper {\n\t}\n\n\n\tprivate static class DomainObjectExtendsSuper extends DomainObjectSuper {\n\t}\n\n\n\tpublic interface IGenericInterface<D extends DomainObjectSuper> {\n\n\t\t<T> void doSomething(final D domainObject, final T value);\n\t}\n\n\n\t@SuppressWarnings(\"unused\")\n\tprivate abstract static class AbstractImplementsInterface<D extends DomainObjectSuper> implements IGenericInterface<D> {\n\n\t\t@Override\n\t\tpublic <T> void doSomething(D domainObject, T value) {\n\t\t}\n\n\t\tpublic void anotherBaseMethod() {\n\t\t}\n\t}\n\n\n\tprivate static class ExtendsAbstractImplementsInterface extends AbstractImplementsInterface<DomainObjectExtendsSuper> {\n\n\t\t@Override\n\t\tpublic <T> void doSomething(DomainObjectExtendsSuper domainObject, T value) {\n\t\t\tsuper.doSomething(domainObject, value);\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-3485 classes\n\t//-------------------\n\n\t@SuppressWarnings(\"serial\")\n\tprivate static class ParameterType implements Serializable {\n\t}\n\n\n\tprivate static class AbstractDomainObject<P extends Serializable, R> {\n\n\t\tpublic R method1(P p) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void method2(P p, R r) {\n\t\t}\n\t}\n\n\n\tprivate static class DomainObject extends AbstractDomainObject<ParameterType, byte[]> {\n\n\t\t@Override\n\t\tpublic byte[] method1(ParameterType p) {\n\t\t\treturn super.method1(p);\n\t\t}\n\n\t\t@Override\n\t\tpublic void method2(ParameterType p, byte[] r) {\n\t\t\tsuper.method2(p, r);\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-3534 classes\n\t//-------------------\n\n\tpublic interface SearchProvider<RETURN_TYPE, CONDITIONS_TYPE> {\n\n\t\tCollection<RETURN_TYPE> findBy(CONDITIONS_TYPE conditions);\n\t}\n\n\n\tpublic static class SearchConditions {\n\t}\n\n\n\tpublic interface IExternalMessageProvider<S extends ExternalMessage, T extends ExternalMessageSearchConditions<?>>\n\t\t\textends SearchProvider<S, T> {\n\t}\n\n\n\tpublic static class ExternalMessage {\n\t}\n\n\n\tpublic static class ExternalMessageSearchConditions<T extends ExternalMessage> extends SearchConditions {\n\t}\n\n\n\tpublic static class ExternalMessageProvider<S extends ExternalMessage, T extends ExternalMessageSearchConditions<S>>\n\t\t\timplements IExternalMessageProvider<S, T> {\n\n\t\t@Override\n\t\tpublic Collection<S> findBy(T conditions) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\tpublic static class EmailMessage extends ExternalMessage {\n\t}\n\n\n\tpublic static class EmailSearchConditions extends ExternalMessageSearchConditions<EmailMessage> {\n\t}\n\n\n\tpublic static class EmailMessageProvider extends ExternalMessageProvider<EmailMessage, EmailSearchConditions> {\n\t}\n\n\n\tpublic static class TestEmailProvider extends EmailMessageProvider {\n\n\t\t@Override\n\t\tpublic Collection<EmailMessage> findBy(EmailSearchConditions conditions) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-16103 classes\n\t//-------------------\n\n\tpublic abstract static class BaseEntity {\n\t}\n\n\tpublic static class FooEntity extends BaseEntity {\n\t}\n\n\tpublic static class BaseClass<T> {\n\n\t\tpublic <S extends T> S test(S T) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic static class EntityClass<T extends BaseEntity> extends BaseClass<T> {\n\n\t\t@Override\n\t\tpublic <S extends T> S test(S T) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic static class FooClass extends EntityClass<FooEntity> {\n\n\t\t@Override\n\t\tpublic <S extends FooEntity> S test(S T) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic interface BaseInterface<T> {\n\n\t\t<S extends T> S test(S T);\n\t}\n\n\tpublic interface EntityInterface<T extends BaseEntity> extends BaseInterface<T> {\n\n\t\t@Override\n\t\t<S extends T> S test(S T);\n\t}\n\n\tpublic interface FooInterface extends EntityInterface<FooEntity> {\n\n\t\t@Override\n\t\t<S extends FooEntity> S test(S T);\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.NewMessageEvent",
    "headType": "class",
    "relation": "extend",
    "tail": "MessageEvent",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.ModifiedMessageEvent",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.ModifiedMessageEvent",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.concurrent.DelayQueue;\nimport java.util.concurrent.Delayed;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.testfixture.ide.IdeUtils;\nimport org.springframework.util.ReflectionUtils;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @author Chris Beams\n * @author Yanming Zhou\n */\n@SuppressWarnings(\"rawtypes\")\nclass BridgeMethodResolverTests {\n\n\tprivate static Method findMethodWithReturnType(String name, Class<?> returnType, Class<SettingsDaoImpl> targetType) {\n\t\tMethod[] methods = targetType.getMethods();\n\t\tfor (Method m : methods) {\n\t\t\tif (m.getName().equals(name) && m.getReturnType().equals(returnType)) {\n\t\t\t\treturn m;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t@Test\n\tvoid findBridgedMethod() throws Exception {\n\t\tMethod unbridged = MyFoo.class.getDeclaredMethod(\"someMethod\", String.class, Object.class);\n\t\tMethod bridged = MyFoo.class.getDeclaredMethod(\"someMethod\", Serializable.class, Object.class);\n\t\tassertThat(unbridged.isBridge()).isFalse();\n\t\tassertThat(bridged.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(unbridged)).as(\"Unbridged method not returned directly\").isEqualTo(unbridged);\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridged)).as(\"Incorrect bridged method returned\").isEqualTo(unbridged);\n\t}\n\n\t@Test\n\tvoid findBridgedVarargMethod() throws Exception {\n\t\tMethod unbridged = MyFoo.class.getDeclaredMethod(\"someVarargMethod\", String.class, Object[].class);\n\t\tMethod bridged = MyFoo.class.getDeclaredMethod(\"someVarargMethod\", Serializable.class, Object[].class);\n\t\tassertThat(unbridged.isBridge()).isFalse();\n\t\tassertThat(bridged.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(unbridged)).as(\"Unbridged method not returned directly\").isEqualTo(unbridged);\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridged)).as(\"Incorrect bridged method returned\").isEqualTo(unbridged);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodInHierarchy() throws Exception {\n\t\tMethod bridgeMethod = DateAdder.class.getMethod(\"add\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\tMethod bridgedMethod = BridgeMethodResolver.findBridgedMethod(bridgeMethod);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tassertThat(bridgedMethod.getName()).isEqualTo(\"add\");\n\t\tassertThat(bridgedMethod.getParameterCount()).isEqualTo(1);\n\t\tassertThat(bridgedMethod.getParameterTypes()[0]).isEqualTo(Date.class);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodFromOriginalMethodInHierarchy() throws Exception {\n\t\tMethod originalMethod = Adder.class.getMethod(\"add\", Object.class);\n\t\tassertThat(originalMethod.isBridge()).isFalse();\n\t\tMethod bridgedMethod = BridgeMethodResolver.getMostSpecificMethod(originalMethod, DateAdder.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tassertThat(bridgedMethod.getName()).isEqualTo(\"add\");\n\t\tassertThat(bridgedMethod.getParameterCount()).isEqualTo(1);\n\t\tassertThat(bridgedMethod.getParameterTypes()[0]).isEqualTo(Date.class);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodFromOriginalMethodNotInHierarchy() throws Exception {\n\t\tMethod originalMethod = Adder.class.getMethod(\"add\", Object.class);\n\t\tMethod mostSpecificMethod = BridgeMethodResolver.getMostSpecificMethod(originalMethod, FakeAdder.class);\n\t\tassertThat(mostSpecificMethod).isSameAs(originalMethod);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodInHierarchyWithBoundedGenerics() throws Exception {\n\t\tMethod originalMethod = Bar.class.getDeclaredMethod(\"someMethod\", Object.class, Object.class);\n\t\tassertThat(originalMethod.isBridge()).isFalse();\n\t\tMethod bridgedMethod = BridgeMethodResolver.getMostSpecificMethod(originalMethod, SubBar.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tassertThat(bridgedMethod.getName()).isEqualTo(\"someMethod\");\n\t\tassertThat(bridgedMethod.getParameterCount()).isEqualTo(2);\n\t\tassertThat(bridgedMethod.getParameterTypes()[0]).isEqualTo(CharSequence.class);\n\t}\n\n\t@Test\n\tvoid isBridgeMethodFor() throws Exception {\n\t\tMethod bridged = MyBar.class.getDeclaredMethod(\"someMethod\", String.class, Object.class);\n\t\tMethod other = MyBar.class.getDeclaredMethod(\"someMethod\", Integer.class, Object.class);\n\t\tMethod bridge;\n\n\t\tif (IdeUtils.runningInEclipse()) {\n\t\t\tbridge = InterBar.class.getDeclaredMethod(\"someMethod\", Object.class, Object.class);\n\t\t}\n\t\telse {\n\t\t\tbridge = MyBar.class.getDeclaredMethod(\"someMethod\", Object.class, Object.class);\n\t\t}\n\t\tassertThat(bridge.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.isBridgeMethodFor(bridge, bridged, MyBar.class)).as(\"Should be bridge method\").isTrue();\n\t\tassertThat(BridgeMethodResolver.isBridgeMethodFor(bridge, other, MyBar.class)).as(\"Should not be bridge method\").isFalse();\n\t}\n\n\t@Test\n\tvoid doubleParameterization() throws Exception {\n\t\tMethod objectBridge = MyBoo.class.getDeclaredMethod(\"foo\", Object.class);\n\t\tMethod serializableBridge = MyBoo.class.getDeclaredMethod(\"foo\", Serializable.class);\n\n\t\tMethod stringFoo = MyBoo.class.getDeclaredMethod(\"foo\", String.class);\n\t\tMethod integerFoo = MyBoo.class.getDeclaredMethod(\"foo\", Integer.class);\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(objectBridge)).as(\"foo(String) not resolved.\").isEqualTo(stringFoo);\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(serializableBridge)).as(\"foo(Integer) not resolved.\").isEqualTo(integerFoo);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodFromMultipleBridges() throws Exception {\n\t\tMethod loadWithObjectReturn = findMethodWithReturnType(\"load\", Object.class, SettingsDaoImpl.class);\n\t\tassertThat(loadWithObjectReturn).isNotNull();\n\n\t\tMethod loadWithSettingsReturn = findMethodWithReturnType(\"load\", Settings.class, SettingsDaoImpl.class);\n\t\tassertThat(loadWithSettingsReturn).isNotNull();\n\t\tassertThat(loadWithSettingsReturn).isNotSameAs(loadWithObjectReturn);\n\n\t\tMethod method = SettingsDaoImpl.class.getMethod(\"load\");\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(loadWithObjectReturn)).isEqualTo(method);\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(loadWithSettingsReturn)).isEqualTo(method);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodFromParent() throws Exception {\n\t\tMethod loadFromParentBridge = SettingsDaoImpl.class.getMethod(\"loadFromParent\");\n\t\tassertThat(loadFromParentBridge.isBridge()).isTrue();\n\n\t\tMethod loadFromParent = AbstractDaoImpl.class.getMethod(\"loadFromParent\");\n\t\tassertThat(loadFromParent.isBridge()).isFalse();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(loadFromParentBridge)).isEqualTo(loadFromParent);\n\t}\n\n\t@Test\n\tvoid withSingleBoundParameterizedOnInstantiate() throws Exception {\n\t\tMethod bridgeMethod = DelayQueue.class.getMethod(\"add\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\tMethod actualMethod = DelayQueue.class.getMethod(\"add\", Delayed.class);\n\t\tassertThat(actualMethod.isBridge()).isFalse();\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(actualMethod);\n\t}\n\n\t@Test\n\tvoid withDoubleBoundParameterizedOnInstantiate() throws Exception {\n\t\tMethod bridgeMethod = SerializableBounded.class.getMethod(\"boundedOperation\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\tMethod actualMethod = SerializableBounded.class.getMethod(\"boundedOperation\", HashMap.class);\n\t\tassertThat(actualMethod.isBridge()).isFalse();\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(actualMethod);\n\t}\n\n\t@Test\n\tvoid withGenericParameter() {\n\t\tMethod[] methods = StringGenericParameter.class.getMethods();\n\t\tMethod bridgeMethod = null;\n\t\tMethod bridgedMethod = null;\n\t\tfor (Method method : methods) {\n\t\t\tif (\"getFor\".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {\n\t\t\t\tif (method.getReturnType().equals(Object.class)) {\n\t\t\t\t\tbridgeMethod = method;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbridgedMethod = method;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\n\t\tboolean condition = bridgedMethod != null && !bridgedMethod.isBridge();\n\t\tassertThat(condition).isTrue();\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid onAllMethods() {\n\t\tMethod[] methods = StringList.class.getMethods();\n\t\tfor (Method method : methods) {\n\t\t\tassertThat(BridgeMethodResolver.findBridgedMethod(method)).isNotNull();\n\t\t}\n\t}\n\n\t@Test\n\tvoid spr2583() throws Exception {\n\t\tMethod bridgedMethod = MessageBroadcasterImpl.class.getMethod(\"receive\", MessageEvent.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tMethod bridgeMethod = MessageBroadcasterImpl.class.getMethod(\"receive\", Event.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tMethod otherMethod = MessageBroadcasterImpl.class.getMethod(\"receive\", NewMessageEvent.class);\n\t\tassertThat(otherMethod.isBridge()).isFalse();\n\n\t\tassertThat(BridgeMethodResolver.isBridgeMethodFor(bridgeMethod, otherMethod, MessageBroadcasterImpl.class)).as(\"Match identified incorrectly\").isFalse();\n\t\tassertThat(BridgeMethodResolver.isBridgeMethodFor(bridgeMethod, bridgedMethod, MessageBroadcasterImpl.class)).as(\"Match not found correctly\").isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr2603() throws Exception {\n\t\tMethod objectBridge = YourHomer.class.getDeclaredMethod(\"foo\", Bounded.class);\n\t\tMethod abstractBoundedFoo = YourHomer.class.getDeclaredMethod(\"foo\", AbstractBounded.class);\n\n\t\tMethod bridgedMethod = BridgeMethodResolver.findBridgedMethod(objectBridge);\n\t\tassertThat(bridgedMethod).as(\"foo(AbstractBounded) not resolved.\").isEqualTo(abstractBoundedFoo);\n\t}\n\n\t@Test\n\tvoid spr2648() {\n\t\tMethod bridgeMethod = ReflectionUtils.findMethod(GenericSqlMapIntegerDao.class, \"saveOrUpdate\", Object.class);\n\t\tassertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\n\t\tMethod bridgedMethod = BridgeMethodResolver.findBridgedMethod(bridgeMethod);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tassertThat(bridgedMethod.getName()).isEqualTo(\"saveOrUpdate\");\n\t}\n\n\t@Test\n\tvoid spr2763() throws Exception {\n\t\tMethod bridgedMethod = AbstractDao.class.getDeclaredMethod(\"save\", Object.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = UserDaoImpl.class.getDeclaredMethod(\"save\", User.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3041() throws Exception {\n\t\tMethod bridgedMethod = BusinessDao.class.getDeclaredMethod(\"save\", Business.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = BusinessDao.class.getDeclaredMethod(\"save\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3173() throws Exception {\n\t\tMethod bridgedMethod = UserDaoImpl.class.getDeclaredMethod(\"saveVararg\", User.class, Object[].class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = UserDaoImpl.class.getDeclaredMethod(\"saveVararg\", Object.class, Object[].class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3304() throws Exception {\n\t\tMethod bridgedMethod = MegaMessageProducerImpl.class.getDeclaredMethod(\"receive\", MegaMessageEvent.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = MegaMessageProducerImpl.class.getDeclaredMethod(\"receive\", MegaEvent.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3324() throws Exception {\n\t\tMethod bridgedMethod = BusinessDao.class.getDeclaredMethod(\"get\", Long.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = BusinessDao.class.getDeclaredMethod(\"get\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3357() throws Exception {\n\t\tMethod bridgedMethod = ExtendsAbstractImplementsInterface.class.getDeclaredMethod(\n\t\t\t\t\"doSomething\", DomainObjectExtendsSuper.class, Object.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = ExtendsAbstractImplementsInterface.class.getDeclaredMethod(\n\t\t\t\t\"doSomething\", DomainObjectSuper.class, Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3485() throws Exception {\n\t\tMethod bridgedMethod = DomainObject.class.getDeclaredMethod(\n\t\t\t\t\"method2\", ParameterType.class, byte[].class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = DomainObject.class.getDeclaredMethod(\n\t\t\t\t\"method2\", Serializable.class, Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3534() {\n\t\tMethod bridgeMethod = ReflectionUtils.findMethod(TestEmailProvider.class, \"findBy\", Object.class);\n\t\tassertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\n\t\tMethod bridgedMethod = BridgeMethodResolver.findBridgedMethod(bridgeMethod);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tassertThat(bridgedMethod.getName()).isEqualTo(\"findBy\");\n\t}\n\n\t@Test  // SPR-16103\n\tvoid testClassHierarchy() throws Exception {\n\t\tdoTestHierarchyResolution(FooClass.class);\n\t}\n\n\t@Test  // SPR-16103\n\tvoid testInterfaceHierarchy() throws Exception {\n\t\tdoTestHierarchyResolution(FooInterface.class);\n\t}\n\n\tprivate void doTestHierarchyResolution(Class<?> clazz) throws Exception {\n\t\tfor (Method method : clazz.getDeclaredMethods()){\n\t\t\tMethod bridged = BridgeMethodResolver.findBridgedMethod(method);\n\t\t\tMethod expected = clazz.getMethod(\"test\", FooEntity.class);\n\t\t\tassertThat(bridged).isEqualTo(expected);\n\t\t}\n\t}\n\n\n\tpublic interface Foo<T extends Serializable> {\n\n\t\tvoid someMethod(T theArg, Object otherArg);\n\n\t\tvoid someVarargMethod(T theArg, Object... otherArg);\n\t}\n\n\n\tpublic static class MyFoo implements Foo<String> {\n\n\t\tpublic void someMethod(Integer theArg, Object otherArg) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void someMethod(String theArg, Object otherArg) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void someVarargMethod(String theArg, Object... otherArgs) {\n\t\t}\n\t}\n\n\n\tpublic abstract static class Bar<T> {\n\n\t\tvoid someMethod(Map<?, ?> m, Object otherArg) {\n\t\t}\n\n\t\tvoid someMethod(T theArg, Map<?, ?> m) {\n\t\t}\n\n\t\tabstract void someMethod(T theArg, Object otherArg);\n\t}\n\n\n\tpublic abstract static class InterBar<T extends CharSequence> extends Bar<T> {\n\n\t\t@Override\n\t\tvoid someMethod(T theArg, Object otherArg) {\n\t\t}\n\t}\n\n\n\tpublic abstract static class SubBar<T extends StringProducer> extends InterBar<T> {\n\t}\n\n\tpublic interface StringProducer extends CharSequence {\n\t}\n\n\n\tpublic static class MyBar extends InterBar<String> {\n\n\t\t@Override\n\t\tpublic void someMethod(String theArg, Object otherArg) {\n\t\t}\n\n\t\tpublic void someMethod(Integer theArg, Object otherArg) {\n\t\t}\n\t}\n\n\n\tpublic interface Adder<T> {\n\n\t\tvoid add(T item);\n\t}\n\n\n\tpublic abstract static class AbstractDateAdder implements Adder<Date> {\n\n\t\t@Override\n\t\tpublic abstract void add(Date date);\n\t}\n\n\n\tpublic static class DateAdder extends AbstractDateAdder {\n\n\t\t@Override\n\t\tpublic void add(Date date) {\n\t\t}\n\t}\n\n\n\tpublic static class FakeAdder {\n\n\t\tpublic void add(Date date) {\n\t\t}\n\t}\n\n\n\tpublic static class Enclosing<T> {\n\n\t\tpublic class Enclosed<S> {\n\n\t\t\tpublic class ReallyDeepNow<R> {\n\n\t\t\t\tvoid someMethod(S s, T t, R r) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tpublic static class ExtendsEnclosing extends Enclosing<String> {\n\n\t\tpublic class ExtendsEnclosed extends Enclosed<Integer> {\n\n\t\t\tpublic class ExtendsReallyDeepNow extends ReallyDeepNow<Long> {\n\n\t\t\t\t@Override\n\t\t\t\tvoid someMethod(Integer s, String t, Long r) {\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tpublic interface Boo<E, T extends Serializable> {\n\n\t\tvoid foo(E e);\n\n\t\tvoid foo(T t);\n\t}\n\n\n\tpublic static class MyBoo implements Boo<String, Integer> {\n\n\t\t@Override\n\t\tpublic void foo(String e) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void foo(Integer t) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\tpublic interface Settings {\n\t}\n\n\n\tpublic interface ConcreteSettings extends Settings {\n\t}\n\n\n\tpublic interface Dao<T, S> {\n\n\t\tT load();\n\n\t\tS loadFromParent();\n\t}\n\n\n\tpublic interface SettingsDao<T extends Settings, S> extends Dao<T, S> {\n\n\t\t@Override\n\t\tT load();\n\t}\n\n\n\tpublic interface ConcreteSettingsDao extends SettingsDao<ConcreteSettings, String> {\n\n\t\t@Override\n\t\tString loadFromParent();\n\t}\n\n\n\tabstract static class AbstractDaoImpl<T, S> implements Dao<T, S> {\n\n\t\tprotected T object;\n\n\t\tprotected S otherObject;\n\n\t\tprotected AbstractDaoImpl(T object, S otherObject) {\n\t\t\tthis.object = object;\n\t\t\tthis.otherObject = otherObject;\n\t\t}\n\n\t\t// @Transactional(readOnly = true)\n\t\t@Override\n\t\tpublic S loadFromParent() {\n\t\t\treturn otherObject;\n\t\t}\n\t}\n\n\n\tstatic class SettingsDaoImpl extends AbstractDaoImpl<ConcreteSettings, String>\n\t\t\timplements ConcreteSettingsDao {\n\n\t\tprotected SettingsDaoImpl(ConcreteSettings object) {\n\t\t\tsuper(object, \"From Parent\");\n\t\t}\n\n\t\t// @Transactional(readOnly = true)\n\t\t@Override\n\t\tpublic ConcreteSettings load() {\n\t\t\treturn super.object;\n\t\t}\n\t}\n\n\n\tpublic interface Bounded<E> {\n\n\t\tboolean boundedOperation(E e);\n\t}\n\n\n\tprivate static class AbstractBounded<E> implements Bounded<E> {\n\n\t\t@Override\n\t\tpublic boolean boundedOperation(E myE) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\n\tprivate static class SerializableBounded<E extends HashMap & Delayed> extends AbstractBounded<E> {\n\n\t\t@Override\n\t\tpublic boolean boundedOperation(E myE) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\n\tpublic interface GenericParameter<T> {\n\n\t\tT getFor(Class<T> cls);\n\t}\n\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class StringGenericParameter implements GenericParameter<String> {\n\n\t\t@Override\n\t\tpublic String getFor(Class<String> cls) {\n\t\t\treturn \"foo\";\n\t\t}\n\n\t\tpublic String getFor(Integer integer) {\n\t\t\treturn \"foo\";\n\t\t}\n\t}\n\n\n\tprivate static class StringList implements List<String> {\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object o) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<String> iterator() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] a) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(String o) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends String> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(int index, Collection<? extends String> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic String get(int index) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic String set(int index, String element) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void add(int index, String element) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic String remove(int index) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic int indexOf(Object o) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic int lastIndexOf(Object o) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic ListIterator<String> listIterator() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic ListIterator<String> listIterator(int index) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> subList(int fromIndex, int toIndex) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\tpublic interface Event {\n\n\t\tint getPriority();\n\t}\n\n\n\tpublic static class GenericEvent implements Event {\n\n\t\tprivate int priority;\n\n\t\t@Override\n\t\tpublic int getPriority() {\n\t\t\treturn priority;\n\t\t}\n\n\t\t/**\n\t\t * Constructor that takes an event priority\n\t\t */\n\t\tpublic GenericEvent(int priority) {\n\t\t\tthis.priority = priority;\n\t\t}\n\n\t\t/**\n\t\t * Default Constructor\n\t\t */\n\t\tpublic GenericEvent() {\n\t\t}\n\t}\n\n\n\tpublic interface UserInitiatedEvent {\n\t}\n\n\n\tpublic abstract static class BaseUserInitiatedEvent extends GenericEvent implements UserInitiatedEvent {\n\t}\n\n\n\tpublic static class MessageEvent extends BaseUserInitiatedEvent {\n\t}\n\n\n\tpublic interface Channel<E extends Event> {\n\n\t\tvoid send(E event);\n\n\t\tvoid subscribe(final Receiver<E> receiver, Class<E> event);\n\n\t\tvoid unsubscribe(final Receiver<E> receiver, Class<E> event);\n\t}\n\n\n\tpublic interface Broadcaster {\n\t}\n\n\n\tpublic interface EventBroadcaster extends Broadcaster {\n\n\t\tvoid subscribe();\n\n\t\tvoid unsubscribe();\n\n\t\tvoid setChannel(Channel<?> channel);\n\t}\n\n\n\tpublic static class GenericBroadcasterImpl implements Broadcaster {\n\t}\n\n\n\t@SuppressWarnings({\"unused\", \"unchecked\"})\n\tpublic abstract static class GenericEventBroadcasterImpl<T extends Event>\n\t\t\textends GenericBroadcasterImpl implements EventBroadcaster {\n\n\t\tprivate Class<T>[] subscribingEvents;\n\n\t\tprivate Channel<T> channel;\n\n\t\t/**\n\t\t * Abstract method to retrieve instance of subclass\n\t\t *\n\t\t * @return receiver instance\n\t\t */\n\t\tpublic abstract Receiver<T> getInstance();\n\n\t\t@Override\n\t\tpublic void setChannel(Channel channel) {\n\t\t\tthis.channel = channel;\n\t\t}\n\n\t\tprivate String beanName;\n\n\t\tpublic void setBeanName(String name) {\n\t\t\tthis.beanName = name;\n\t\t}\n\n\t\t@Override\n\t\tpublic void subscribe() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void unsubscribe() {\n\t\t}\n\n\t\tpublic GenericEventBroadcasterImpl(Class<? extends T>... events) {\n\t\t}\n\t}\n\n\n\tpublic interface Receiver<E extends Event> {\n\n\t\tvoid receive(E event);\n\t}\n\n\n\tpublic interface MessageBroadcaster extends Receiver<MessageEvent> {\n\n\t}\n\n\n\tpublic static class RemovedMessageEvent extends MessageEvent {\n\n\t}\n\n\n\tpublic static class NewMessageEvent extends MessageEvent {\n\n\t}\n\n\n\tpublic static class ModifiedMessageEvent extends MessageEvent {\n\n\t}\n\n\n\t@SuppressWarnings({\"serial\", \"unchecked\"})\n\tpublic static class MessageBroadcasterImpl extends GenericEventBroadcasterImpl<MessageEvent>\n\t\t\timplements Serializable,  // implement an unrelated interface first (SPR-16288)\n\t\t\tMessageBroadcaster {\n\n\t\tpublic MessageBroadcasterImpl() {\n\t\t\tsuper(NewMessageEvent.class);\n\t\t}\n\n\t\t@Override\n\t\tpublic void receive(MessageEvent event) {\n\t\t\tthrow new UnsupportedOperationException(\"should not be called, use subclassed events\");\n\t\t}\n\n\t\tpublic void receive(NewMessageEvent event) {\n\t\t}\n\n\t\t@Override\n\t\tpublic Receiver<MessageEvent> getInstance() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void receive(RemovedMessageEvent event) {\n\t\t}\n\n\t\tpublic void receive(ModifiedMessageEvent event) {\n\t\t}\n\t}\n\n\n\t//-----------------------------\n\t// SPR-2454 Test Classes\n\t//-----------------------------\n\n\tpublic interface SimpleGenericRepository<T> {\n\n\t\tClass<T> getPersistentClass();\n\n\t\tList<T> findByQuery();\n\n\t\tList<T> findAll();\n\n\t\tT refresh(T entity);\n\n\t\tT saveOrUpdate(T entity);\n\n\t\tvoid delete(Collection<T> entities);\n\t}\n\n\n\tpublic interface RepositoryRegistry {\n\n\t\t<T> SimpleGenericRepository<T> getFor(Class<T> entityType);\n\t}\n\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static class SettableRepositoryRegistry<R extends SimpleGenericRepository<?>>\n\t\t\timplements RepositoryRegistry {\n\n\t\tprotected void injectInto(R rep) {\n\t\t}\n\n\t\tpublic void register(R rep) {\n\t\t}\n\n\t\tpublic void register(R... reps) {\n\t\t}\n\n\t\tpublic void setRepos(R... reps) {\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> SimpleGenericRepository<T> getFor(Class<T> entityType) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void afterPropertiesSet() {\n\t\t}\n\t}\n\n\n\tpublic interface ConvenientGenericRepository<T, ID extends Serializable>\n\t\t\textends SimpleGenericRepository<T> {\n\n\t\tT findById(ID id, boolean lock);\n\n\t\tList<T> findByExample(T exampleInstance);\n\n\t\tvoid delete(ID id);\n\n\t\tvoid delete(T entity);\n\t}\n\n\n\tpublic static class GenericHibernateRepository<T, ID extends Serializable>\n\t\t\timplements ConvenientGenericRepository<T, ID> {\n\n\t\t/**\n\t\t * @param c Mandatory. The domain class this repository is responsible for.\n\t\t */\n\t\t// Since it is impossible to determine the actual type of a type\n\t\t// parameter (!), we resort to requiring the caller to provide the\n\t\t// actual type as parameter, too.\n\t\t// Not set in a constructor to enable easy CGLIB-proxying (passing\n\t\t// constructor arguments to Spring AOP proxies is quite cumbersome).\n\t\tpublic void setPersistentClass(Class<T> c) {\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<T> getPersistentClass() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic T findById(ID id, boolean lock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<T> findAll() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<T> findByExample(T exampleInstance) {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<T> findByQuery() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic T saveOrUpdate(T entity) {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void delete(T entity) {\n\t\t}\n\n\t\t@Override\n\t\tpublic T refresh(T entity) {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void delete(ID id) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void delete(Collection<T> entities) {\n\t\t}\n\t}\n\n\n\tpublic static class HibernateRepositoryRegistry\n\t\t\textends SettableRepositoryRegistry<GenericHibernateRepository<?, ?>> {\n\n\t\t@Override\n\t\tpublic void injectInto(GenericHibernateRepository<?, ?> rep) {\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> GenericHibernateRepository<T, ?> getFor(Class<T> entityType) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-2603 classes\n\t//-------------------\n\n\tpublic interface Homer<E> {\n\n\t\tvoid foo(E e);\n\t}\n\n\n\tpublic static class MyHomer<T extends Bounded<T>, L extends T> implements Homer<L> {\n\n\t\t@Override\n\t\tpublic void foo(L t) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\tpublic static class YourHomer<T extends AbstractBounded<T>, L extends T> extends\n\t\t\tMyHomer<T, L> {\n\n\t\t@Override\n\t\tpublic void foo(L t) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\tpublic interface GenericDao<T> {\n\n\t\tvoid saveOrUpdate(T t);\n\t}\n\n\n\tpublic interface ConvenienceGenericDao<T> extends GenericDao<T> {\n\t}\n\n\n\tpublic static class GenericSqlMapDao<T extends Serializable> implements ConvenienceGenericDao<T> {\n\n\t\t@Override\n\t\tpublic void saveOrUpdate(T t) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\tpublic static class GenericSqlMapIntegerDao<T extends Number> extends GenericSqlMapDao<T> {\n\n\t\t@Override\n\t\tpublic void saveOrUpdate(T t) {\n\t\t}\n\t}\n\n\n\tpublic static class Permission {\n\t}\n\n\n\tpublic static class User {\n\t}\n\n\n\tpublic interface UserDao {\n\n\t\t// @Transactional\n\t\tvoid save(User user);\n\n\t\t// @Transactional\n\t\tvoid save(Permission perm);\n\t}\n\n\n\tpublic abstract static class AbstractDao<T> {\n\n\t\tpublic void save(T t) {\n\t\t}\n\n\t\tpublic void saveVararg(T t, Object... args) {\n\t\t}\n\t}\n\n\n\tpublic static class UserDaoImpl extends AbstractDao<User> implements UserDao {\n\n\t\t@Override\n\t\tpublic void save(Permission perm) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void saveVararg(User user, Object... args) {\n\t\t}\n\t}\n\n\n\tpublic interface DaoInterface<T, P> {\n\n\t\tT get(P id);\n\t}\n\n\n\tpublic abstract static class BusinessGenericDao<T, PK extends Serializable>\n\t\t\timplements DaoInterface<T, PK> {\n\n\t\tpublic void save(T object) {\n\t\t}\n\t}\n\n\n\tpublic static class Business<T> {\n\t}\n\n\n\tpublic static class BusinessDao extends BusinessGenericDao<Business<?>, Long> {\n\n\t\t@Override\n\t\tpublic void save(Business<?> business) {\n\t\t}\n\n\t\t@Override\n\t\tpublic Business<?> get(Long id) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic Business<?> get(String code) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-3304 classes\n\t//-------------------\n\n\tprivate static class MegaEvent {\n\t}\n\n\n\tprivate static class MegaMessageEvent extends MegaEvent {\n\t}\n\n\n\tprivate static class NewMegaMessageEvent extends MegaEvent {\n\t}\n\n\n\tprivate static class ModifiedMegaMessageEvent extends MegaEvent {\n\t}\n\n\n\tpublic interface MegaReceiver<E extends MegaEvent> {\n\n\t\tvoid receive(E event);\n\t}\n\n\n\tpublic interface MegaMessageProducer extends MegaReceiver<MegaMessageEvent> {\n\t}\n\n\n\tprivate static class Other<S,E> {\n\t}\n\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class MegaMessageProducerImpl extends Other<Long, String> implements MegaMessageProducer {\n\n\t\tpublic void receive(NewMegaMessageEvent event) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\tpublic void receive(ModifiedMegaMessageEvent event) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void receive(MegaMessageEvent event) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-3357 classes\n\t//-------------------\n\n\tprivate static class DomainObjectSuper {\n\t}\n\n\n\tprivate static class DomainObjectExtendsSuper extends DomainObjectSuper {\n\t}\n\n\n\tpublic interface IGenericInterface<D extends DomainObjectSuper> {\n\n\t\t<T> void doSomething(final D domainObject, final T value);\n\t}\n\n\n\t@SuppressWarnings(\"unused\")\n\tprivate abstract static class AbstractImplementsInterface<D extends DomainObjectSuper> implements IGenericInterface<D> {\n\n\t\t@Override\n\t\tpublic <T> void doSomething(D domainObject, T value) {\n\t\t}\n\n\t\tpublic void anotherBaseMethod() {\n\t\t}\n\t}\n\n\n\tprivate static class ExtendsAbstractImplementsInterface extends AbstractImplementsInterface<DomainObjectExtendsSuper> {\n\n\t\t@Override\n\t\tpublic <T> void doSomething(DomainObjectExtendsSuper domainObject, T value) {\n\t\t\tsuper.doSomething(domainObject, value);\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-3485 classes\n\t//-------------------\n\n\t@SuppressWarnings(\"serial\")\n\tprivate static class ParameterType implements Serializable {\n\t}\n\n\n\tprivate static class AbstractDomainObject<P extends Serializable, R> {\n\n\t\tpublic R method1(P p) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void method2(P p, R r) {\n\t\t}\n\t}\n\n\n\tprivate static class DomainObject extends AbstractDomainObject<ParameterType, byte[]> {\n\n\t\t@Override\n\t\tpublic byte[] method1(ParameterType p) {\n\t\t\treturn super.method1(p);\n\t\t}\n\n\t\t@Override\n\t\tpublic void method2(ParameterType p, byte[] r) {\n\t\t\tsuper.method2(p, r);\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-3534 classes\n\t//-------------------\n\n\tpublic interface SearchProvider<RETURN_TYPE, CONDITIONS_TYPE> {\n\n\t\tCollection<RETURN_TYPE> findBy(CONDITIONS_TYPE conditions);\n\t}\n\n\n\tpublic static class SearchConditions {\n\t}\n\n\n\tpublic interface IExternalMessageProvider<S extends ExternalMessage, T extends ExternalMessageSearchConditions<?>>\n\t\t\textends SearchProvider<S, T> {\n\t}\n\n\n\tpublic static class ExternalMessage {\n\t}\n\n\n\tpublic static class ExternalMessageSearchConditions<T extends ExternalMessage> extends SearchConditions {\n\t}\n\n\n\tpublic static class ExternalMessageProvider<S extends ExternalMessage, T extends ExternalMessageSearchConditions<S>>\n\t\t\timplements IExternalMessageProvider<S, T> {\n\n\t\t@Override\n\t\tpublic Collection<S> findBy(T conditions) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\tpublic static class EmailMessage extends ExternalMessage {\n\t}\n\n\n\tpublic static class EmailSearchConditions extends ExternalMessageSearchConditions<EmailMessage> {\n\t}\n\n\n\tpublic static class EmailMessageProvider extends ExternalMessageProvider<EmailMessage, EmailSearchConditions> {\n\t}\n\n\n\tpublic static class TestEmailProvider extends EmailMessageProvider {\n\n\t\t@Override\n\t\tpublic Collection<EmailMessage> findBy(EmailSearchConditions conditions) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-16103 classes\n\t//-------------------\n\n\tpublic abstract static class BaseEntity {\n\t}\n\n\tpublic static class FooEntity extends BaseEntity {\n\t}\n\n\tpublic static class BaseClass<T> {\n\n\t\tpublic <S extends T> S test(S T) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic static class EntityClass<T extends BaseEntity> extends BaseClass<T> {\n\n\t\t@Override\n\t\tpublic <S extends T> S test(S T) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic static class FooClass extends EntityClass<FooEntity> {\n\n\t\t@Override\n\t\tpublic <S extends FooEntity> S test(S T) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic interface BaseInterface<T> {\n\n\t\t<S extends T> S test(S T);\n\t}\n\n\tpublic interface EntityInterface<T extends BaseEntity> extends BaseInterface<T> {\n\n\t\t@Override\n\t\t<S extends T> S test(S T);\n\t}\n\n\tpublic interface FooInterface extends EntityInterface<FooEntity> {\n\n\t\t@Override\n\t\t<S extends FooEntity> S test(S T);\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.ModifiedMessageEvent",
    "headType": "class",
    "relation": "extend",
    "tail": "MessageEvent",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.MessageBroadcasterImpl",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.MessageBroadcasterImpl",
    "headType": "class",
    "relation": "use",
    "tail": "@SuppressWarnings",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.MessageBroadcasterImpl",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.concurrent.DelayQueue;\nimport java.util.concurrent.Delayed;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.testfixture.ide.IdeUtils;\nimport org.springframework.util.ReflectionUtils;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @author Chris Beams\n * @author Yanming Zhou\n */\n@SuppressWarnings(\"rawtypes\")\nclass BridgeMethodResolverTests {\n\n\tprivate static Method findMethodWithReturnType(String name, Class<?> returnType, Class<SettingsDaoImpl> targetType) {\n\t\tMethod[] methods = targetType.getMethods();\n\t\tfor (Method m : methods) {\n\t\t\tif (m.getName().equals(name) && m.getReturnType().equals(returnType)) {\n\t\t\t\treturn m;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t@Test\n\tvoid findBridgedMethod() throws Exception {\n\t\tMethod unbridged = MyFoo.class.getDeclaredMethod(\"someMethod\", String.class, Object.class);\n\t\tMethod bridged = MyFoo.class.getDeclaredMethod(\"someMethod\", Serializable.class, Object.class);\n\t\tassertThat(unbridged.isBridge()).isFalse();\n\t\tassertThat(bridged.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(unbridged)).as(\"Unbridged method not returned directly\").isEqualTo(unbridged);\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridged)).as(\"Incorrect bridged method returned\").isEqualTo(unbridged);\n\t}\n\n\t@Test\n\tvoid findBridgedVarargMethod() throws Exception {\n\t\tMethod unbridged = MyFoo.class.getDeclaredMethod(\"someVarargMethod\", String.class, Object[].class);\n\t\tMethod bridged = MyFoo.class.getDeclaredMethod(\"someVarargMethod\", Serializable.class, Object[].class);\n\t\tassertThat(unbridged.isBridge()).isFalse();\n\t\tassertThat(bridged.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(unbridged)).as(\"Unbridged method not returned directly\").isEqualTo(unbridged);\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridged)).as(\"Incorrect bridged method returned\").isEqualTo(unbridged);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodInHierarchy() throws Exception {\n\t\tMethod bridgeMethod = DateAdder.class.getMethod(\"add\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\tMethod bridgedMethod = BridgeMethodResolver.findBridgedMethod(bridgeMethod);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tassertThat(bridgedMethod.getName()).isEqualTo(\"add\");\n\t\tassertThat(bridgedMethod.getParameterCount()).isEqualTo(1);\n\t\tassertThat(bridgedMethod.getParameterTypes()[0]).isEqualTo(Date.class);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodFromOriginalMethodInHierarchy() throws Exception {\n\t\tMethod originalMethod = Adder.class.getMethod(\"add\", Object.class);\n\t\tassertThat(originalMethod.isBridge()).isFalse();\n\t\tMethod bridgedMethod = BridgeMethodResolver.getMostSpecificMethod(originalMethod, DateAdder.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tassertThat(bridgedMethod.getName()).isEqualTo(\"add\");\n\t\tassertThat(bridgedMethod.getParameterCount()).isEqualTo(1);\n\t\tassertThat(bridgedMethod.getParameterTypes()[0]).isEqualTo(Date.class);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodFromOriginalMethodNotInHierarchy() throws Exception {\n\t\tMethod originalMethod = Adder.class.getMethod(\"add\", Object.class);\n\t\tMethod mostSpecificMethod = BridgeMethodResolver.getMostSpecificMethod(originalMethod, FakeAdder.class);\n\t\tassertThat(mostSpecificMethod).isSameAs(originalMethod);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodInHierarchyWithBoundedGenerics() throws Exception {\n\t\tMethod originalMethod = Bar.class.getDeclaredMethod(\"someMethod\", Object.class, Object.class);\n\t\tassertThat(originalMethod.isBridge()).isFalse();\n\t\tMethod bridgedMethod = BridgeMethodResolver.getMostSpecificMethod(originalMethod, SubBar.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tassertThat(bridgedMethod.getName()).isEqualTo(\"someMethod\");\n\t\tassertThat(bridgedMethod.getParameterCount()).isEqualTo(2);\n\t\tassertThat(bridgedMethod.getParameterTypes()[0]).isEqualTo(CharSequence.class);\n\t}\n\n\t@Test\n\tvoid isBridgeMethodFor() throws Exception {\n\t\tMethod bridged = MyBar.class.getDeclaredMethod(\"someMethod\", String.class, Object.class);\n\t\tMethod other = MyBar.class.getDeclaredMethod(\"someMethod\", Integer.class, Object.class);\n\t\tMethod bridge;\n\n\t\tif (IdeUtils.runningInEclipse()) {\n\t\t\tbridge = InterBar.class.getDeclaredMethod(\"someMethod\", Object.class, Object.class);\n\t\t}\n\t\telse {\n\t\t\tbridge = MyBar.class.getDeclaredMethod(\"someMethod\", Object.class, Object.class);\n\t\t}\n\t\tassertThat(bridge.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.isBridgeMethodFor(bridge, bridged, MyBar.class)).as(\"Should be bridge method\").isTrue();\n\t\tassertThat(BridgeMethodResolver.isBridgeMethodFor(bridge, other, MyBar.class)).as(\"Should not be bridge method\").isFalse();\n\t}\n\n\t@Test\n\tvoid doubleParameterization() throws Exception {\n\t\tMethod objectBridge = MyBoo.class.getDeclaredMethod(\"foo\", Object.class);\n\t\tMethod serializableBridge = MyBoo.class.getDeclaredMethod(\"foo\", Serializable.class);\n\n\t\tMethod stringFoo = MyBoo.class.getDeclaredMethod(\"foo\", String.class);\n\t\tMethod integerFoo = MyBoo.class.getDeclaredMethod(\"foo\", Integer.class);\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(objectBridge)).as(\"foo(String) not resolved.\").isEqualTo(stringFoo);\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(serializableBridge)).as(\"foo(Integer) not resolved.\").isEqualTo(integerFoo);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodFromMultipleBridges() throws Exception {\n\t\tMethod loadWithObjectReturn = findMethodWithReturnType(\"load\", Object.class, SettingsDaoImpl.class);\n\t\tassertThat(loadWithObjectReturn).isNotNull();\n\n\t\tMethod loadWithSettingsReturn = findMethodWithReturnType(\"load\", Settings.class, SettingsDaoImpl.class);\n\t\tassertThat(loadWithSettingsReturn).isNotNull();\n\t\tassertThat(loadWithSettingsReturn).isNotSameAs(loadWithObjectReturn);\n\n\t\tMethod method = SettingsDaoImpl.class.getMethod(\"load\");\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(loadWithObjectReturn)).isEqualTo(method);\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(loadWithSettingsReturn)).isEqualTo(method);\n\t}\n\n\t@Test\n\tvoid findBridgedMethodFromParent() throws Exception {\n\t\tMethod loadFromParentBridge = SettingsDaoImpl.class.getMethod(\"loadFromParent\");\n\t\tassertThat(loadFromParentBridge.isBridge()).isTrue();\n\n\t\tMethod loadFromParent = AbstractDaoImpl.class.getMethod(\"loadFromParent\");\n\t\tassertThat(loadFromParent.isBridge()).isFalse();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(loadFromParentBridge)).isEqualTo(loadFromParent);\n\t}\n\n\t@Test\n\tvoid withSingleBoundParameterizedOnInstantiate() throws Exception {\n\t\tMethod bridgeMethod = DelayQueue.class.getMethod(\"add\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\tMethod actualMethod = DelayQueue.class.getMethod(\"add\", Delayed.class);\n\t\tassertThat(actualMethod.isBridge()).isFalse();\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(actualMethod);\n\t}\n\n\t@Test\n\tvoid withDoubleBoundParameterizedOnInstantiate() throws Exception {\n\t\tMethod bridgeMethod = SerializableBounded.class.getMethod(\"boundedOperation\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\tMethod actualMethod = SerializableBounded.class.getMethod(\"boundedOperation\", HashMap.class);\n\t\tassertThat(actualMethod.isBridge()).isFalse();\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(actualMethod);\n\t}\n\n\t@Test\n\tvoid withGenericParameter() {\n\t\tMethod[] methods = StringGenericParameter.class.getMethods();\n\t\tMethod bridgeMethod = null;\n\t\tMethod bridgedMethod = null;\n\t\tfor (Method method : methods) {\n\t\t\tif (\"getFor\".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {\n\t\t\t\tif (method.getReturnType().equals(Object.class)) {\n\t\t\t\t\tbridgeMethod = method;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbridgedMethod = method;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\n\t\tboolean condition = bridgedMethod != null && !bridgedMethod.isBridge();\n\t\tassertThat(condition).isTrue();\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid onAllMethods() {\n\t\tMethod[] methods = StringList.class.getMethods();\n\t\tfor (Method method : methods) {\n\t\t\tassertThat(BridgeMethodResolver.findBridgedMethod(method)).isNotNull();\n\t\t}\n\t}\n\n\t@Test\n\tvoid spr2583() throws Exception {\n\t\tMethod bridgedMethod = MessageBroadcasterImpl.class.getMethod(\"receive\", MessageEvent.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tMethod bridgeMethod = MessageBroadcasterImpl.class.getMethod(\"receive\", Event.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tMethod otherMethod = MessageBroadcasterImpl.class.getMethod(\"receive\", NewMessageEvent.class);\n\t\tassertThat(otherMethod.isBridge()).isFalse();\n\n\t\tassertThat(BridgeMethodResolver.isBridgeMethodFor(bridgeMethod, otherMethod, MessageBroadcasterImpl.class)).as(\"Match identified incorrectly\").isFalse();\n\t\tassertThat(BridgeMethodResolver.isBridgeMethodFor(bridgeMethod, bridgedMethod, MessageBroadcasterImpl.class)).as(\"Match not found correctly\").isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr2603() throws Exception {\n\t\tMethod objectBridge = YourHomer.class.getDeclaredMethod(\"foo\", Bounded.class);\n\t\tMethod abstractBoundedFoo = YourHomer.class.getDeclaredMethod(\"foo\", AbstractBounded.class);\n\n\t\tMethod bridgedMethod = BridgeMethodResolver.findBridgedMethod(objectBridge);\n\t\tassertThat(bridgedMethod).as(\"foo(AbstractBounded) not resolved.\").isEqualTo(abstractBoundedFoo);\n\t}\n\n\t@Test\n\tvoid spr2648() {\n\t\tMethod bridgeMethod = ReflectionUtils.findMethod(GenericSqlMapIntegerDao.class, \"saveOrUpdate\", Object.class);\n\t\tassertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\n\t\tMethod bridgedMethod = BridgeMethodResolver.findBridgedMethod(bridgeMethod);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tassertThat(bridgedMethod.getName()).isEqualTo(\"saveOrUpdate\");\n\t}\n\n\t@Test\n\tvoid spr2763() throws Exception {\n\t\tMethod bridgedMethod = AbstractDao.class.getDeclaredMethod(\"save\", Object.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = UserDaoImpl.class.getDeclaredMethod(\"save\", User.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3041() throws Exception {\n\t\tMethod bridgedMethod = BusinessDao.class.getDeclaredMethod(\"save\", Business.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = BusinessDao.class.getDeclaredMethod(\"save\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3173() throws Exception {\n\t\tMethod bridgedMethod = UserDaoImpl.class.getDeclaredMethod(\"saveVararg\", User.class, Object[].class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = UserDaoImpl.class.getDeclaredMethod(\"saveVararg\", Object.class, Object[].class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3304() throws Exception {\n\t\tMethod bridgedMethod = MegaMessageProducerImpl.class.getDeclaredMethod(\"receive\", MegaMessageEvent.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = MegaMessageProducerImpl.class.getDeclaredMethod(\"receive\", MegaEvent.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3324() throws Exception {\n\t\tMethod bridgedMethod = BusinessDao.class.getDeclaredMethod(\"get\", Long.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = BusinessDao.class.getDeclaredMethod(\"get\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3357() throws Exception {\n\t\tMethod bridgedMethod = ExtendsAbstractImplementsInterface.class.getDeclaredMethod(\n\t\t\t\t\"doSomething\", DomainObjectExtendsSuper.class, Object.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = ExtendsAbstractImplementsInterface.class.getDeclaredMethod(\n\t\t\t\t\"doSomething\", DomainObjectSuper.class, Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3485() throws Exception {\n\t\tMethod bridgedMethod = DomainObject.class.getDeclaredMethod(\n\t\t\t\t\"method2\", ParameterType.class, byte[].class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tMethod bridgeMethod = DomainObject.class.getDeclaredMethod(\n\t\t\t\t\"method2\", Serializable.class, Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\n\t}\n\n\t@Test\n\tvoid spr3534() {\n\t\tMethod bridgeMethod = ReflectionUtils.findMethod(TestEmailProvider.class, \"findBy\", Object.class);\n\t\tassertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\n\t\tMethod bridgedMethod = BridgeMethodResolver.findBridgedMethod(bridgeMethod);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tassertThat(bridgedMethod.getName()).isEqualTo(\"findBy\");\n\t}\n\n\t@Test  // SPR-16103\n\tvoid testClassHierarchy() throws Exception {\n\t\tdoTestHierarchyResolution(FooClass.class);\n\t}\n\n\t@Test  // SPR-16103\n\tvoid testInterfaceHierarchy() throws Exception {\n\t\tdoTestHierarchyResolution(FooInterface.class);\n\t}\n\n\tprivate void doTestHierarchyResolution(Class<?> clazz) throws Exception {\n\t\tfor (Method method : clazz.getDeclaredMethods()){\n\t\t\tMethod bridged = BridgeMethodResolver.findBridgedMethod(method);\n\t\t\tMethod expected = clazz.getMethod(\"test\", FooEntity.class);\n\t\t\tassertThat(bridged).isEqualTo(expected);\n\t\t}\n\t}\n\n\n\tpublic interface Foo<T extends Serializable> {\n\n\t\tvoid someMethod(T theArg, Object otherArg);\n\n\t\tvoid someVarargMethod(T theArg, Object... otherArg);\n\t}\n\n\n\tpublic static class MyFoo implements Foo<String> {\n\n\t\tpublic void someMethod(Integer theArg, Object otherArg) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void someMethod(String theArg, Object otherArg) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void someVarargMethod(String theArg, Object... otherArgs) {\n\t\t}\n\t}\n\n\n\tpublic abstract static class Bar<T> {\n\n\t\tvoid someMethod(Map<?, ?> m, Object otherArg) {\n\t\t}\n\n\t\tvoid someMethod(T theArg, Map<?, ?> m) {\n\t\t}\n\n\t\tabstract void someMethod(T theArg, Object otherArg);\n\t}\n\n\n\tpublic abstract static class InterBar<T extends CharSequence> extends Bar<T> {\n\n\t\t@Override\n\t\tvoid someMethod(T theArg, Object otherArg) {\n\t\t}\n\t}\n\n\n\tpublic abstract static class SubBar<T extends StringProducer> extends InterBar<T> {\n\t}\n\n\tpublic interface StringProducer extends CharSequence {\n\t}\n\n\n\tpublic static class MyBar extends InterBar<String> {\n\n\t\t@Override\n\t\tpublic void someMethod(String theArg, Object otherArg) {\n\t\t}\n\n\t\tpublic void someMethod(Integer theArg, Object otherArg) {\n\t\t}\n\t}\n\n\n\tpublic interface Adder<T> {\n\n\t\tvoid add(T item);\n\t}\n\n\n\tpublic abstract static class AbstractDateAdder implements Adder<Date> {\n\n\t\t@Override\n\t\tpublic abstract void add(Date date);\n\t}\n\n\n\tpublic static class DateAdder extends AbstractDateAdder {\n\n\t\t@Override\n\t\tpublic void add(Date date) {\n\t\t}\n\t}\n\n\n\tpublic static class FakeAdder {\n\n\t\tpublic void add(Date date) {\n\t\t}\n\t}\n\n\n\tpublic static class Enclosing<T> {\n\n\t\tpublic class Enclosed<S> {\n\n\t\t\tpublic class ReallyDeepNow<R> {\n\n\t\t\t\tvoid someMethod(S s, T t, R r) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tpublic static class ExtendsEnclosing extends Enclosing<String> {\n\n\t\tpublic class ExtendsEnclosed extends Enclosed<Integer> {\n\n\t\t\tpublic class ExtendsReallyDeepNow extends ReallyDeepNow<Long> {\n\n\t\t\t\t@Override\n\t\t\t\tvoid someMethod(Integer s, String t, Long r) {\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tpublic interface Boo<E, T extends Serializable> {\n\n\t\tvoid foo(E e);\n\n\t\tvoid foo(T t);\n\t}\n\n\n\tpublic static class MyBoo implements Boo<String, Integer> {\n\n\t\t@Override\n\t\tpublic void foo(String e) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void foo(Integer t) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\tpublic interface Settings {\n\t}\n\n\n\tpublic interface ConcreteSettings extends Settings {\n\t}\n\n\n\tpublic interface Dao<T, S> {\n\n\t\tT load();\n\n\t\tS loadFromParent();\n\t}\n\n\n\tpublic interface SettingsDao<T extends Settings, S> extends Dao<T, S> {\n\n\t\t@Override\n\t\tT load();\n\t}\n\n\n\tpublic interface ConcreteSettingsDao extends SettingsDao<ConcreteSettings, String> {\n\n\t\t@Override\n\t\tString loadFromParent();\n\t}\n\n\n\tabstract static class AbstractDaoImpl<T, S> implements Dao<T, S> {\n\n\t\tprotected T object;\n\n\t\tprotected S otherObject;\n\n\t\tprotected AbstractDaoImpl(T object, S otherObject) {\n\t\t\tthis.object = object;\n\t\t\tthis.otherObject = otherObject;\n\t\t}\n\n\t\t// @Transactional(readOnly = true)\n\t\t@Override\n\t\tpublic S loadFromParent() {\n\t\t\treturn otherObject;\n\t\t}\n\t}\n\n\n\tstatic class SettingsDaoImpl extends AbstractDaoImpl<ConcreteSettings, String>\n\t\t\timplements ConcreteSettingsDao {\n\n\t\tprotected SettingsDaoImpl(ConcreteSettings object) {\n\t\t\tsuper(object, \"From Parent\");\n\t\t}\n\n\t\t// @Transactional(readOnly = true)\n\t\t@Override\n\t\tpublic ConcreteSettings load() {\n\t\t\treturn super.object;\n\t\t}\n\t}\n\n\n\tpublic interface Bounded<E> {\n\n\t\tboolean boundedOperation(E e);\n\t}\n\n\n\tprivate static class AbstractBounded<E> implements Bounded<E> {\n\n\t\t@Override\n\t\tpublic boolean boundedOperation(E myE) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\n\tprivate static class SerializableBounded<E extends HashMap & Delayed> extends AbstractBounded<E> {\n\n\t\t@Override\n\t\tpublic boolean boundedOperation(E myE) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\n\tpublic interface GenericParameter<T> {\n\n\t\tT getFor(Class<T> cls);\n\t}\n\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class StringGenericParameter implements GenericParameter<String> {\n\n\t\t@Override\n\t\tpublic String getFor(Class<String> cls) {\n\t\t\treturn \"foo\";\n\t\t}\n\n\t\tpublic String getFor(Integer integer) {\n\t\t\treturn \"foo\";\n\t\t}\n\t}\n\n\n\tprivate static class StringList implements List<String> {\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object o) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<String> iterator() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] a) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(String o) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends String> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(int index, Collection<? extends String> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic String get(int index) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic String set(int index, String element) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void add(int index, String element) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic String remove(int index) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic int indexOf(Object o) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic int lastIndexOf(Object o) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic ListIterator<String> listIterator() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic ListIterator<String> listIterator(int index) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> subList(int fromIndex, int toIndex) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\tpublic interface Event {\n\n\t\tint getPriority();\n\t}\n\n\n\tpublic static class GenericEvent implements Event {\n\n\t\tprivate int priority;\n\n\t\t@Override\n\t\tpublic int getPriority() {\n\t\t\treturn priority;\n\t\t}\n\n\t\t/**\n\t\t * Constructor that takes an event priority\n\t\t */\n\t\tpublic GenericEvent(int priority) {\n\t\t\tthis.priority = priority;\n\t\t}\n\n\t\t/**\n\t\t * Default Constructor\n\t\t */\n\t\tpublic GenericEvent() {\n\t\t}\n\t}\n\n\n\tpublic interface UserInitiatedEvent {\n\t}\n\n\n\tpublic abstract static class BaseUserInitiatedEvent extends GenericEvent implements UserInitiatedEvent {\n\t}\n\n\n\tpublic static class MessageEvent extends BaseUserInitiatedEvent {\n\t}\n\n\n\tpublic interface Channel<E extends Event> {\n\n\t\tvoid send(E event);\n\n\t\tvoid subscribe(final Receiver<E> receiver, Class<E> event);\n\n\t\tvoid unsubscribe(final Receiver<E> receiver, Class<E> event);\n\t}\n\n\n\tpublic interface Broadcaster {\n\t}\n\n\n\tpublic interface EventBroadcaster extends Broadcaster {\n\n\t\tvoid subscribe();\n\n\t\tvoid unsubscribe();\n\n\t\tvoid setChannel(Channel<?> channel);\n\t}\n\n\n\tpublic static class GenericBroadcasterImpl implements Broadcaster {\n\t}\n\n\n\t@SuppressWarnings({\"unused\", \"unchecked\"})\n\tpublic abstract static class GenericEventBroadcasterImpl<T extends Event>\n\t\t\textends GenericBroadcasterImpl implements EventBroadcaster {\n\n\t\tprivate Class<T>[] subscribingEvents;\n\n\t\tprivate Channel<T> channel;\n\n\t\t/**\n\t\t * Abstract method to retrieve instance of subclass\n\t\t *\n\t\t * @return receiver instance\n\t\t */\n\t\tpublic abstract Receiver<T> getInstance();\n\n\t\t@Override\n\t\tpublic void setChannel(Channel channel) {\n\t\t\tthis.channel = channel;\n\t\t}\n\n\t\tprivate String beanName;\n\n\t\tpublic void setBeanName(String name) {\n\t\t\tthis.beanName = name;\n\t\t}\n\n\t\t@Override\n\t\tpublic void subscribe() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void unsubscribe() {\n\t\t}\n\n\t\tpublic GenericEventBroadcasterImpl(Class<? extends T>... events) {\n\t\t}\n\t}\n\n\n\tpublic interface Receiver<E extends Event> {\n\n\t\tvoid receive(E event);\n\t}\n\n\n\tpublic interface MessageBroadcaster extends Receiver<MessageEvent> {\n\n\t}\n\n\n\tpublic static class RemovedMessageEvent extends MessageEvent {\n\n\t}\n\n\n\tpublic static class NewMessageEvent extends MessageEvent {\n\n\t}\n\n\n\tpublic static class ModifiedMessageEvent extends MessageEvent {\n\n\t}\n\n\n\t@SuppressWarnings({\"serial\", \"unchecked\"})\n\tpublic static class MessageBroadcasterImpl extends GenericEventBroadcasterImpl<MessageEvent>\n\t\t\timplements Serializable,  // implement an unrelated interface first (SPR-16288)\n\t\t\tMessageBroadcaster {\n\n\t\tpublic MessageBroadcasterImpl() {\n\t\t\tsuper(NewMessageEvent.class);\n\t\t}\n\n\t\t@Override\n\t\tpublic void receive(MessageEvent event) {\n\t\t\tthrow new UnsupportedOperationException(\"should not be called, use subclassed events\");\n\t\t}\n\n\t\tpublic void receive(NewMessageEvent event) {\n\t\t}\n\n\t\t@Override\n\t\tpublic Receiver<MessageEvent> getInstance() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void receive(RemovedMessageEvent event) {\n\t\t}\n\n\t\tpublic void receive(ModifiedMessageEvent event) {\n\t\t}\n\t}\n\n\n\t//-----------------------------\n\t// SPR-2454 Test Classes\n\t//-----------------------------\n\n\tpublic interface SimpleGenericRepository<T> {\n\n\t\tClass<T> getPersistentClass();\n\n\t\tList<T> findByQuery();\n\n\t\tList<T> findAll();\n\n\t\tT refresh(T entity);\n\n\t\tT saveOrUpdate(T entity);\n\n\t\tvoid delete(Collection<T> entities);\n\t}\n\n\n\tpublic interface RepositoryRegistry {\n\n\t\t<T> SimpleGenericRepository<T> getFor(Class<T> entityType);\n\t}\n\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static class SettableRepositoryRegistry<R extends SimpleGenericRepository<?>>\n\t\t\timplements RepositoryRegistry {\n\n\t\tprotected void injectInto(R rep) {\n\t\t}\n\n\t\tpublic void register(R rep) {\n\t\t}\n\n\t\tpublic void register(R... reps) {\n\t\t}\n\n\t\tpublic void setRepos(R... reps) {\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> SimpleGenericRepository<T> getFor(Class<T> entityType) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void afterPropertiesSet() {\n\t\t}\n\t}\n\n\n\tpublic interface ConvenientGenericRepository<T, ID extends Serializable>\n\t\t\textends SimpleGenericRepository<T> {\n\n\t\tT findById(ID id, boolean lock);\n\n\t\tList<T> findByExample(T exampleInstance);\n\n\t\tvoid delete(ID id);\n\n\t\tvoid delete(T entity);\n\t}\n\n\n\tpublic static class GenericHibernateRepository<T, ID extends Serializable>\n\t\t\timplements ConvenientGenericRepository<T, ID> {\n\n\t\t/**\n\t\t * @param c Mandatory. The domain class this repository is responsible for.\n\t\t */\n\t\t// Since it is impossible to determine the actual type of a type\n\t\t// parameter (!), we resort to requiring the caller to provide the\n\t\t// actual type as parameter, too.\n\t\t// Not set in a constructor to enable easy CGLIB-proxying (passing\n\t\t// constructor arguments to Spring AOP proxies is quite cumbersome).\n\t\tpublic void setPersistentClass(Class<T> c) {\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<T> getPersistentClass() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic T findById(ID id, boolean lock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<T> findAll() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<T> findByExample(T exampleInstance) {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<T> findByQuery() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic T saveOrUpdate(T entity) {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void delete(T entity) {\n\t\t}\n\n\t\t@Override\n\t\tpublic T refresh(T entity) {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void delete(ID id) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void delete(Collection<T> entities) {\n\t\t}\n\t}\n\n\n\tpublic static class HibernateRepositoryRegistry\n\t\t\textends SettableRepositoryRegistry<GenericHibernateRepository<?, ?>> {\n\n\t\t@Override\n\t\tpublic void injectInto(GenericHibernateRepository<?, ?> rep) {\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> GenericHibernateRepository<T, ?> getFor(Class<T> entityType) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-2603 classes\n\t//-------------------\n\n\tpublic interface Homer<E> {\n\n\t\tvoid foo(E e);\n\t}\n\n\n\tpublic static class MyHomer<T extends Bounded<T>, L extends T> implements Homer<L> {\n\n\t\t@Override\n\t\tpublic void foo(L t) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\tpublic static class YourHomer<T extends AbstractBounded<T>, L extends T> extends\n\t\t\tMyHomer<T, L> {\n\n\t\t@Override\n\t\tpublic void foo(L t) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\tpublic interface GenericDao<T> {\n\n\t\tvoid saveOrUpdate(T t);\n\t}\n\n\n\tpublic interface ConvenienceGenericDao<T> extends GenericDao<T> {\n\t}\n\n\n\tpublic static class GenericSqlMapDao<T extends Serializable> implements ConvenienceGenericDao<T> {\n\n\t\t@Override\n\t\tpublic void saveOrUpdate(T t) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\tpublic static class GenericSqlMapIntegerDao<T extends Number> extends GenericSqlMapDao<T> {\n\n\t\t@Override\n\t\tpublic void saveOrUpdate(T t) {\n\t\t}\n\t}\n\n\n\tpublic static class Permission {\n\t}\n\n\n\tpublic static class User {\n\t}\n\n\n\tpublic interface UserDao {\n\n\t\t// @Transactional\n\t\tvoid save(User user);\n\n\t\t// @Transactional\n\t\tvoid save(Permission perm);\n\t}\n\n\n\tpublic abstract static class AbstractDao<T> {\n\n\t\tpublic void save(T t) {\n\t\t}\n\n\t\tpublic void saveVararg(T t, Object... args) {\n\t\t}\n\t}\n\n\n\tpublic static class UserDaoImpl extends AbstractDao<User> implements UserDao {\n\n\t\t@Override\n\t\tpublic void save(Permission perm) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void saveVararg(User user, Object... args) {\n\t\t}\n\t}\n\n\n\tpublic interface DaoInterface<T, P> {\n\n\t\tT get(P id);\n\t}\n\n\n\tpublic abstract static class BusinessGenericDao<T, PK extends Serializable>\n\t\t\timplements DaoInterface<T, PK> {\n\n\t\tpublic void save(T object) {\n\t\t}\n\t}\n\n\n\tpublic static class Business<T> {\n\t}\n\n\n\tpublic static class BusinessDao extends BusinessGenericDao<Business<?>, Long> {\n\n\t\t@Override\n\t\tpublic void save(Business<?> business) {\n\t\t}\n\n\t\t@Override\n\t\tpublic Business<?> get(Long id) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic Business<?> get(String code) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-3304 classes\n\t//-------------------\n\n\tprivate static class MegaEvent {\n\t}\n\n\n\tprivate static class MegaMessageEvent extends MegaEvent {\n\t}\n\n\n\tprivate static class NewMegaMessageEvent extends MegaEvent {\n\t}\n\n\n\tprivate static class ModifiedMegaMessageEvent extends MegaEvent {\n\t}\n\n\n\tpublic interface MegaReceiver<E extends MegaEvent> {\n\n\t\tvoid receive(E event);\n\t}\n\n\n\tpublic interface MegaMessageProducer extends MegaReceiver<MegaMessageEvent> {\n\t}\n\n\n\tprivate static class Other<S,E> {\n\t}\n\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class MegaMessageProducerImpl extends Other<Long, String> implements MegaMessageProducer {\n\n\t\tpublic void receive(NewMegaMessageEvent event) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\tpublic void receive(ModifiedMegaMessageEvent event) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void receive(MegaMessageEvent event) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-3357 classes\n\t//-------------------\n\n\tprivate static class DomainObjectSuper {\n\t}\n\n\n\tprivate static class DomainObjectExtendsSuper extends DomainObjectSuper {\n\t}\n\n\n\tpublic interface IGenericInterface<D extends DomainObjectSuper> {\n\n\t\t<T> void doSomething(final D domainObject, final T value);\n\t}\n\n\n\t@SuppressWarnings(\"unused\")\n\tprivate abstract static class AbstractImplementsInterface<D extends DomainObjectSuper> implements IGenericInterface<D> {\n\n\t\t@Override\n\t\tpublic <T> void doSomething(D domainObject, T value) {\n\t\t}\n\n\t\tpublic void anotherBaseMethod() {\n\t\t}\n\t}\n\n\n\tprivate static class ExtendsAbstractImplementsInterface extends AbstractImplementsInterface<DomainObjectExtendsSuper> {\n\n\t\t@Override\n\t\tpublic <T> void doSomething(DomainObjectExtendsSuper domainObject, T value) {\n\t\t\tsuper.doSomething(domainObject, value);\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-3485 classes\n\t//-------------------\n\n\t@SuppressWarnings(\"serial\")\n\tprivate static class ParameterType implements Serializable {\n\t}\n\n\n\tprivate static class AbstractDomainObject<P extends Serializable, R> {\n\n\t\tpublic R method1(P p) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void method2(P p, R r) {\n\t\t}\n\t}\n\n\n\tprivate static class DomainObject extends AbstractDomainObject<ParameterType, byte[]> {\n\n\t\t@Override\n\t\tpublic byte[] method1(ParameterType p) {\n\t\t\treturn super.method1(p);\n\t\t}\n\n\t\t@Override\n\t\tpublic void method2(ParameterType p, byte[] r) {\n\t\t\tsuper.method2(p, r);\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-3534 classes\n\t//-------------------\n\n\tpublic interface SearchProvider<RETURN_TYPE, CONDITIONS_TYPE> {\n\n\t\tCollection<RETURN_TYPE> findBy(CONDITIONS_TYPE conditions);\n\t}\n\n\n\tpublic static class SearchConditions {\n\t}\n\n\n\tpublic interface IExternalMessageProvider<S extends ExternalMessage, T extends ExternalMessageSearchConditions<?>>\n\t\t\textends SearchProvider<S, T> {\n\t}\n\n\n\tpublic static class ExternalMessage {\n\t}\n\n\n\tpublic static class ExternalMessageSearchConditions<T extends ExternalMessage> extends SearchConditions {\n\t}\n\n\n\tpublic static class ExternalMessageProvider<S extends ExternalMessage, T extends ExternalMessageSearchConditions<S>>\n\t\t\timplements IExternalMessageProvider<S, T> {\n\n\t\t@Override\n\t\tpublic Collection<S> findBy(T conditions) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\tpublic static class EmailMessage extends ExternalMessage {\n\t}\n\n\n\tpublic static class EmailSearchConditions extends ExternalMessageSearchConditions<EmailMessage> {\n\t}\n\n\n\tpublic static class EmailMessageProvider extends ExternalMessageProvider<EmailMessage, EmailSearchConditions> {\n\t}\n\n\n\tpublic static class TestEmailProvider extends EmailMessageProvider {\n\n\t\t@Override\n\t\tpublic Collection<EmailMessage> findBy(EmailSearchConditions conditions) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t//-------------------\n\t// SPR-16103 classes\n\t//-------------------\n\n\tpublic abstract static class BaseEntity {\n\t}\n\n\tpublic static class FooEntity extends BaseEntity {\n\t}\n\n\tpublic static class BaseClass<T> {\n\n\t\tpublic <S extends T> S test(S T) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic static class EntityClass<T extends BaseEntity> extends BaseClass<T> {\n\n\t\t@Override\n\t\tpublic <S extends T> S test(S T) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic static class FooClass extends EntityClass<FooEntity> {\n\n\t\t@Override\n\t\tpublic <S extends FooEntity> S test(S T) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic interface BaseInterface<T> {\n\n\t\t<S extends T> S test(S T);\n\t}\n\n\tpublic interface EntityInterface<T extends BaseEntity> extends BaseInterface<T> {\n\n\t\t@Override\n\t\t<S extends T> S test(S T);\n\t}\n\n\tpublic interface FooInterface extends EntityInterface<FooEntity> {\n\n\t\t@Override\n\t\t<S extends FooEntity> S test(S T);\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.MessageBroadcasterImpl#receive(MessageEvent)",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic void receive(MessageEvent event) {\r\n    throw new UnsupportedOperationException(\"should not be called, use subclassed events\");\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.MessageBroadcasterImpl",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.MessageBroadcasterImpl#receive(MessageEvent)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.MessageBroadcasterImpl#receive(MessageEvent)",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.MessageBroadcasterImpl#receive(NewMessageEvent)",
    "headType": "method",
    "relation": "provide",
    "tail": "public void receive(NewMessageEvent event) ;",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.MessageBroadcasterImpl",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.MessageBroadcasterImpl#receive(NewMessageEvent)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.MessageBroadcasterImpl#getInstance()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic Receiver<MessageEvent> getInstance() {\r\n    return null;\r\n}",
    "tailType": "method_code"
  }
]