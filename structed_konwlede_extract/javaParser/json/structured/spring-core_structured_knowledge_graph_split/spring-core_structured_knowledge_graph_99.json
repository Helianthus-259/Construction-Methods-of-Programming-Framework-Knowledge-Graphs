[
  {
    "head": "org.springframework.aot.generate.ValueCodeGenerator",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.generate.ValueCodeGenerator#add(List<Delegate>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.aot.generate.ValueCodeGenerator#scoped(GeneratedMethods)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Return a {@link ValueCodeGenerator} that is scoped for the specified\r\n * {@link GeneratedMethods}. This allows code generation to generate\r\n * additional methods if necessary, or perform some optimization in\r\n * case of visibility issues.\r\n * @param generatedMethods the generated methods to use\r\n * @return an instance scoped to the specified generated methods\r\n */\r\npublic ValueCodeGenerator scoped(GeneratedMethods generatedMethods) {\r\n    return new ValueCodeGenerator(this.delegates, generatedMethods);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.generate.ValueCodeGenerator",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.generate.ValueCodeGenerator#scoped(GeneratedMethods)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.aot.generate.ValueCodeGenerator#generateCode(Object)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Generate the code that represents the specified {@code value}.\r\n * @param value the value to generate\r\n * @return the code that represents the specified value\r\n */\r\npublic CodeBlock generateCode(@Nullable Object value) {\r\n    if (value == null) {\r\n        return NULL_VALUE_CODE_BLOCK;\r\n    }\r\n    try {\r\n        for (Delegate delegate : this.delegates) {\r\n            CodeBlock code = delegate.generateCode(this, value);\r\n            if (code != null) {\r\n                return code;\r\n            }\r\n        }\r\n        throw new UnsupportedTypeValueCodeGenerationException(value);\r\n    } catch (Exception ex) {\r\n        throw new ValueCodeGenerationException(value, ex);\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.generate.ValueCodeGenerator",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.generate.ValueCodeGenerator#generateCode(Object)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.aot.generate.ValueCodeGenerator#getGeneratedMethods()",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Return the {@link GeneratedMethods} that represents the scope\r\n * in which code generated by this instance will be added, or\r\n * {@code null} if no specific scope is set.\r\n * @return the generated methods to use for code generation\r\n */\r\n@Nullable\r\npublic GeneratedMethods getGeneratedMethods() {\r\n    return this.generatedMethods;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.generate.ValueCodeGenerator",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.generate.ValueCodeGenerator#getGeneratedMethods()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.aot.generate.ValueCodeGenerator#getGeneratedMethods()",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.aot.generate",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.aot.generate.Delegate",
    "tailType": "class"
  },
  {
    "head": "org.springframework.aot.generate.Delegate",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.aot.generate;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.javapoet.CodeBlock;\nimport org.springframework.util.Assert;\n\n/**\n * Code generator for a single value. Delegates code generation to a list of\n * configurable {@link Delegate} implementations.\n *\n * @author Stephane Nicoll\n * @since 6.1.2\n */\npublic final class ValueCodeGenerator {\n\n\tprivate static final ValueCodeGenerator INSTANCE =\n\t\t\tnew ValueCodeGenerator(ValueCodeGeneratorDelegates.INSTANCES, null);\n\n\tprivate static final CodeBlock NULL_VALUE_CODE_BLOCK = CodeBlock.of(\"null\");\n\n\n\tprivate final List<Delegate> delegates;\n\n\tprivate final @Nullable GeneratedMethods generatedMethods;\n\n\n\tprivate ValueCodeGenerator(List<Delegate> delegates, @Nullable GeneratedMethods generatedMethods) {\n\t\tthis.delegates = delegates;\n\t\tthis.generatedMethods = generatedMethods;\n\t}\n\n\n\t/**\n\t * Return an instance that provides support for {@linkplain\n\t * ValueCodeGeneratorDelegates#INSTANCES common value types}.\n\t * @return an instance with support for common value types\n\t */\n\tpublic static ValueCodeGenerator withDefaults() {\n\t\treturn INSTANCE;\n\t}\n\n\t/**\n\t * Create an instance with the specified {@link Delegate} implementations.\n\t * @param delegates the delegates to use\n\t * @return an instance with the specified delegates\n\t */\n\tpublic static ValueCodeGenerator with(Delegate... delegates) {\n\t\treturn with(Arrays.asList(delegates));\n\t}\n\n\t/**\n\t * Create an instance with the specified {@link Delegate} implementations.\n\t * @param delegates the delegates to use\n\t * @return an instance with the specified delegates\n\t */\n\tpublic static ValueCodeGenerator with(List<Delegate> delegates) {\n\t\tAssert.notEmpty(delegates, \"Delegates must not be empty\");\n\t\treturn new ValueCodeGenerator(new ArrayList<>(delegates), null);\n\t}\n\n\n\tpublic ValueCodeGenerator add(List<Delegate> additionalDelegates) {\n\t\tAssert.notEmpty(additionalDelegates, \"AdditionalDelegates must not be empty\");\n\t\tList<Delegate> allDelegates = new ArrayList<>(this.delegates);\n\t\tallDelegates.addAll(additionalDelegates);\n\t\treturn new ValueCodeGenerator(allDelegates, this.generatedMethods);\n\t}\n\n\t/**\n\t * Return a {@link ValueCodeGenerator} that is scoped for the specified\n\t * {@link GeneratedMethods}. This allows code generation to generate\n\t * additional methods if necessary, or perform some optimization in\n\t * case of visibility issues.\n\t * @param generatedMethods the generated methods to use\n\t * @return an instance scoped to the specified generated methods\n\t */\n\tpublic ValueCodeGenerator scoped(GeneratedMethods generatedMethods) {\n\t\treturn new ValueCodeGenerator(this.delegates, generatedMethods);\n\t}\n\n\t/**\n\t * Generate the code that represents the specified {@code value}.\n\t * @param value the value to generate\n\t * @return the code that represents the specified value\n\t */\n\tpublic CodeBlock generateCode(@Nullable Object value) {\n\t\tif (value == null) {\n\t\t\treturn NULL_VALUE_CODE_BLOCK;\n\t\t}\n\t\ttry {\n\t\t\tfor (Delegate delegate : this.delegates) {\n\t\t\t\tCodeBlock code = delegate.generateCode(this, value);\n\t\t\t\tif (code != null) {\n\t\t\t\t\treturn code;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new UnsupportedTypeValueCodeGenerationException(value);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new ValueCodeGenerationException(value, ex);\n\t\t}\n\t}\n\n\t/**\n\t * Return the {@link GeneratedMethods} that represents the scope\n\t * in which code generated by this instance will be added, or\n\t * {@code null} if no specific scope is set.\n\t * @return the generated methods to use for code generation\n\t */\n\tpublic @Nullable GeneratedMethods getGeneratedMethods() {\n\t\treturn this.generatedMethods;\n\t}\n\n\n\t/**\n\t * Strategy interface that can be used to implement code generation for a\n\t * particular value type.\n\t */\n\tpublic interface Delegate {\n\n\t\t/**\n\t\t * Generate the code for the specified non-null {@code value}. If this\n\t\t * instance does not support the value, it should return {@code null} to\n\t\t * indicate so.\n\t\t * @param valueCodeGenerator the code generator to use for embedded values\n\t\t * @param value the value to generate\n\t\t * @return the code that represents the specified value or {@code null} if\n\t\t * the specified value is not supported.\n\t\t */\n\t\t@Nullable CodeBlock generateCode(ValueCodeGenerator valueCodeGenerator, Object value);\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.aot.generate.Delegate#generateCode(ValueCodeGenerator,Object)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Generate the code for the specified non-null {@code value}. If this\r\n * instance does not support the value, it should return {@code null} to\r\n * indicate so.\r\n * @param valueCodeGenerator the code generator to use for embedded values\r\n * @param value the value to generate\r\n * @return the code that represents the specified value or {@code null} if\r\n * the specified value is not supported.\r\n */\r\n@Nullable\r\nCodeBlock generateCode(ValueCodeGenerator valueCodeGenerator, Object value);",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.generate.Delegate",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.generate.Delegate#generateCode(ValueCodeGenerator,Object)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.aot.generate.Delegate#generateCode(ValueCodeGenerator,Object)",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.type",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core.type",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.type.InheritedAnnotationsAnnotationMetadataTests",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.type.InheritedAnnotationsAnnotationMetadataTests",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2019 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.type;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.type.classreading.MetadataReader;\nimport org.springframework.core.type.classreading.MetadataReaderFactory;\nimport org.springframework.core.type.classreading.SimpleMetadataReaderFactory;\nimport org.springframework.util.MultiValueMap;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Unit tests demonstrating that the reflection-based {@link StandardAnnotationMetadata}\n * supports {@link Inherited @Inherited} annotations; whereas, the ASM-based\n * {@code SimpleAnnotationMetadata} does not.\n *\n * @author Sam Brannen\n * @since 5.2.3\n * @see AnnotationMetadataTests\n */\nclass InheritedAnnotationsAnnotationMetadataTests {\n\n\tprivate final AnnotationMetadata standardMetadata = AnnotationMetadata.introspect(AnnotatedSubclass.class);\n\n\tprivate final AnnotationMetadata asmMetadata;\n\n\n\tInheritedAnnotationsAnnotationMetadataTests() throws Exception {\n\t\tMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\n\t\tMetadataReader metadataReader = metadataReaderFactory.getMetadataReader(AnnotatedSubclass.class.getName());\n\t\tthis.asmMetadata = metadataReader.getAnnotationMetadata();\n\t}\n\n\t@Test\n\tvoid getAnnotationTypes() {\n\t\tassertThat(standardMetadata.getAnnotationTypes()).containsExactlyInAnyOrder(\n\t\t\tNamedAnnotation3.class.getName(),\n\t\t\tInheritedComposedAnnotation.class.getName());\n\n\t\tassertThat(asmMetadata.getAnnotationTypes()).containsExactly(\n\t\t\tNamedAnnotation3.class.getName());\n\t}\n\n\t@Test\n\tvoid hasAnnotation() {\n\t\tassertThat(standardMetadata.hasAnnotation(InheritedComposedAnnotation.class.getName())).isTrue();\n\t\tassertThat(standardMetadata.hasAnnotation(NamedAnnotation3.class.getName())).isTrue();\n\n\t\t// true because @NamedAnnotation3 is also directly present\n\t\tassertThat(asmMetadata.hasAnnotation(NamedAnnotation3.class.getName())).isTrue();\n\n\t\tassertThat(asmMetadata.hasAnnotation(InheritedComposedAnnotation.class.getName())).isFalse();\n\t}\n\n\t@Test\n\tvoid getMetaAnnotationTypes() {\n\t\tSet<String> metaAnnotationTypes;\n\n\t\tmetaAnnotationTypes = standardMetadata.getMetaAnnotationTypes(InheritedComposedAnnotation.class.getName());\n\t\tassertThat(metaAnnotationTypes).containsExactlyInAnyOrder(\n\t\t\tMetaAnnotation.class.getName(),\n\t\t\tNamedAnnotation1.class.getName(),\n\t\t\tNamedAnnotation2.class.getName(),\n\t\t\tNamedAnnotation3.class.getName());\n\n\t\tmetaAnnotationTypes = asmMetadata.getMetaAnnotationTypes(InheritedComposedAnnotation.class.getName());\n\t\tassertThat(metaAnnotationTypes).isEmpty();\n\t}\n\n\t@Test\n\tvoid hasMetaAnnotation() {\n\t\tassertThat(standardMetadata.hasMetaAnnotation(NamedAnnotation1.class.getName())).isTrue();\n\t\tassertThat(standardMetadata.hasMetaAnnotation(NamedAnnotation2.class.getName())).isTrue();\n\t\tassertThat(standardMetadata.hasMetaAnnotation(NamedAnnotation3.class.getName())).isTrue();\n\t\tassertThat(standardMetadata.hasMetaAnnotation(MetaAnnotation.class.getName())).isTrue();\n\n\t\tassertThat(asmMetadata.hasMetaAnnotation(NamedAnnotation1.class.getName())).isFalse();\n\t\tassertThat(asmMetadata.hasMetaAnnotation(NamedAnnotation2.class.getName())).isFalse();\n\t\tassertThat(asmMetadata.hasMetaAnnotation(NamedAnnotation3.class.getName())).isFalse();\n\t\tassertThat(asmMetadata.hasMetaAnnotation(MetaAnnotation.class.getName())).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotated() {\n\t\tassertThat(standardMetadata.isAnnotated(InheritedComposedAnnotation.class.getName())).isTrue();\n\t\tassertThat(standardMetadata.isAnnotated(NamedAnnotation1.class.getName())).isTrue();\n\t\tassertThat(standardMetadata.isAnnotated(NamedAnnotation2.class.getName())).isTrue();\n\t\tassertThat(standardMetadata.isAnnotated(NamedAnnotation3.class.getName())).isTrue();\n\t\tassertThat(standardMetadata.isAnnotated(MetaAnnotation.class.getName())).isTrue();\n\n\t\t// true because @NamedAnnotation3 is also directly present\n\t\tassertThat(asmMetadata.isAnnotated(NamedAnnotation3.class.getName())).isTrue();\n\n\t\tassertThat(asmMetadata.isAnnotated(InheritedComposedAnnotation.class.getName())).isFalse();\n\t\tassertThat(asmMetadata.isAnnotated(NamedAnnotation1.class.getName())).isFalse();\n\t\tassertThat(asmMetadata.isAnnotated(NamedAnnotation2.class.getName())).isFalse();\n\t\tassertThat(asmMetadata.isAnnotated(MetaAnnotation.class.getName())).isFalse();\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributes() {\n\t\tMap<String, Object> annotationAttributes;\n\n\t\tannotationAttributes = standardMetadata.getAnnotationAttributes(NamedAnnotation1.class.getName());\n\t\tassertThat(annotationAttributes.get(\"name\")).isEqualTo(\"name 1\");\n\n\t\tannotationAttributes = asmMetadata.getAnnotationAttributes(NamedAnnotation1.class.getName());\n\t\tassertThat(annotationAttributes).isNull();\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributes() {\n\t\tMultiValueMap<String, Object> annotationAttributes;\n\n\t\tannotationAttributes = standardMetadata.getAllAnnotationAttributes(NamedAnnotation3.class.getName());\n\t\tassertThat(annotationAttributes).containsKey(\"name\");\n\t\tassertThat(annotationAttributes.get(\"name\")).containsExactlyInAnyOrder(\"name 3\", \"local\");\n\n\t\tannotationAttributes = asmMetadata.getAllAnnotationAttributes(NamedAnnotation1.class.getName());\n\t\tassertThat(annotationAttributes).isNull();\n\t}\n\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.ANNOTATION_TYPE)\n\t@interface MetaAnnotation {\n\t}\n\n\t@MetaAnnotation\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface NamedAnnotation1 {\n\n\t\tString name() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface NamedAnnotation2 {\n\n\t\tString name() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface NamedAnnotation3 {\n\n\t\tString name() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@NamedAnnotation1(name = \"name 1\")\n\t@NamedAnnotation2(name = \"name 2\")\n\t@NamedAnnotation3(name = \"name 3\")\n\t@Inherited\n\t@interface InheritedComposedAnnotation {\n\t}\n\n\t@InheritedComposedAnnotation\n\tprivate static class AnnotatedClass {\n\t}\n\n\t@NamedAnnotation3(name = \"local\")\n\tprivate static class AnnotatedSubclass extends AnnotatedClass {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.type.InheritedAnnotationsAnnotationMetadataTests",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.type.InheritedAnnotationsAnnotationMetadataTests#standardMetadata",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.type.InheritedAnnotationsAnnotationMetadataTests#standardMetadata",
    "headType": "field",
    "relation": "haveType",
    "tail": "AnnotationMetadata",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.type.InheritedAnnotationsAnnotationMetadataTests",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.type.InheritedAnnotationsAnnotationMetadataTests#asmMetadata",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.type.InheritedAnnotationsAnnotationMetadataTests#asmMetadata",
    "headType": "field",
    "relation": "haveType",
    "tail": "AnnotationMetadata",
    "tailType": "type"
  }
]