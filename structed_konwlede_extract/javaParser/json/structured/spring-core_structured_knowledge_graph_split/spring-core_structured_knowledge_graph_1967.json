[
  {
    "head": "org.springframework.core.env.PropertySourcesPropertyResolverTests#resolveNestedPropertyPlaceholders()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.env.PropertySourcesPropertyResolverTests#resolveNestedPlaceholdersIfValueIsCharSequence()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid resolveNestedPlaceholdersIfValueIsCharSequence() {\r\n    MutablePropertySources ps = new MutablePropertySources();\r\n    ps.addFirst(new MockPropertySource().withProperty(\"p1\", \"v1\").withProperty(\"p2\", \"v2\").withProperty(\"p3\", new StringBuilder(\"${p1}:${p2}\")));\r\n    ConfigurablePropertyResolver pr = new PropertySourcesPropertyResolver(ps);\r\n    assertThat(pr.getProperty(\"p1\")).isEqualTo(\"v1\");\r\n    assertThat(pr.getProperty(\"p2\")).isEqualTo(\"v2\");\r\n    assertThat(pr.getProperty(\"p3\")).isEqualTo(\"v1:v2\");\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.env.PropertySourcesPropertyResolverTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.env.PropertySourcesPropertyResolverTests#resolveNestedPlaceholdersIfValueIsCharSequence()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.env.PropertySourcesPropertyResolverTests#resolveNestedPlaceholdersIfValueIsCharSequence()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.env.PropertySourcesPropertyResolverTests#resolveNestedPlaceholdersIfValueIsCharSequenceAndStringBuilderIsRequested()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid resolveNestedPlaceholdersIfValueIsCharSequenceAndStringBuilderIsRequested() {\r\n    MutablePropertySources ps = new MutablePropertySources();\r\n    ps.addFirst(new MockPropertySource().withProperty(\"p1\", \"v1\").withProperty(\"p2\", \"v2\").withProperty(\"p3\", new StringBuilder(\"${p1}:${p2}\")));\r\n    ConfigurablePropertyResolver pr = new PropertySourcesPropertyResolver(ps);\r\n    assertThat(pr.getProperty(\"p3\", StringBuilder.class)).isInstanceOf(StringBuilder.class).hasToString(\"${p1}:${p2}\");\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.env.PropertySourcesPropertyResolverTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.env.PropertySourcesPropertyResolverTests#resolveNestedPlaceholdersIfValueIsCharSequenceAndStringBuilderIsRequested()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.env.PropertySourcesPropertyResolverTests#resolveNestedPlaceholdersIfValueIsCharSequenceAndStringBuilderIsRequested()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.env.PropertySourcesPropertyResolverTests#resolveNestedPlaceHolderIfValueShouldConvertToOtherTypes()",
    "headType": "method",
    "relation": "provide",
    "tail": "// gh-33727\r\n@Test\r\nvoid resolveNestedPlaceHolderIfValueShouldConvertToOtherTypes() {\r\n    MutablePropertySources ps = new MutablePropertySources();\r\n    ps.addFirst(new MockPropertySource().withProperty(\"new.enabled\", \"${old.enabled:true}\"));\r\n    ConfigurablePropertyResolver pr = new PropertySourcesPropertyResolver(ps);\r\n    assertThat(pr.getProperty(\"new.enabled\", Boolean.class, false)).isTrue();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.env.PropertySourcesPropertyResolverTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.env.PropertySourcesPropertyResolverTests#resolveNestedPlaceHolderIfValueShouldConvertToOtherTypes()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.env.PropertySourcesPropertyResolverTests#resolveNestedPlaceHolderIfValueShouldConvertToOtherTypes()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.env.PropertySourcesPropertyResolverTests#ignoreUnresolvableNestedPlaceholdersIsConfigurable()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid ignoreUnresolvableNestedPlaceholdersIsConfigurable() {\r\n    MutablePropertySources ps = new MutablePropertySources();\r\n    ps.addFirst(new MockPropertySource().withProperty(\"p1\", \"v1\").withProperty(\"p2\", \"v2\").withProperty(\"p3\", // unresolvable w/ default\r\n    \"${p1}:${p2}:${bogus:def}\").withProperty(\"p4\", // unresolvable placeholder\r\n    \"${p1}:${p2}:${bogus}\"));\r\n    ConfigurablePropertyResolver pr = new PropertySourcesPropertyResolver(ps);\r\n    assertThat(pr.getProperty(\"p1\")).isEqualTo(\"v1\");\r\n    assertThat(pr.getProperty(\"p2\")).isEqualTo(\"v2\");\r\n    assertThat(pr.getProperty(\"p3\")).isEqualTo(\"v1:v2:def\");\r\n    // placeholders nested within the value of \"p4\" are unresolvable and cause an\r\n    // exception by default\r\n    assertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(() -> pr.getProperty(\"p4\")).withMessageContaining(\"Could not resolve placeholder 'bogus' in value \\\"${p1}:${p2}:${bogus}\\\"\");\r\n    // relax the treatment of unresolvable nested placeholders\r\n    pr.setIgnoreUnresolvableNestedPlaceholders(true);\r\n    // and observe they now pass through unresolved\r\n    assertThat(pr.getProperty(\"p4\")).isEqualTo(\"v1:v2:${bogus}\");\r\n    // resolve[Nested]Placeholders methods behave as usual regardless the value of\r\n    // ignoreUnresolvableNestedPlaceholders\r\n    assertThat(pr.resolvePlaceholders(\"${p1}:${p2}:${bogus}\")).isEqualTo(\"v1:v2:${bogus}\");\r\n    assertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(() -> pr.resolveRequiredPlaceholders(\"${p1}:${p2}:${bogus}\")).withMessageContaining(\"Could not resolve placeholder 'bogus' in value \\\"${p1}:${p2}:${bogus}\\\"\");\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.env.PropertySourcesPropertyResolverTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.env.PropertySourcesPropertyResolverTests#ignoreUnresolvableNestedPlaceholdersIsConfigurable()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.env.PropertySourcesPropertyResolverTests#ignoreUnresolvableNestedPlaceholdersIsConfigurable()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.env",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.env.TestType",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.env.TestType",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.env;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.convert.ConverterNotFoundException;\nimport org.springframework.core.testfixture.env.MockPropertySource;\nimport org.springframework.util.PlaceholderResolutionException;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.assertj.core.api.Assertions.assertThatIllegalStateException;\n\n/**\n * @author Chris Beams\n * @since 3.1\n */\nclass PropertySourcesPropertyResolverTests {\n\n\tprivate Properties testProperties;\n\n\tprivate MutablePropertySources propertySources;\n\n\tprivate ConfigurablePropertyResolver propertyResolver;\n\n\n\t@BeforeEach\n\tvoid setUp() {\n\t\tpropertySources = new MutablePropertySources();\n\t\tpropertyResolver = new PropertySourcesPropertyResolver(propertySources);\n\t\ttestProperties = new Properties();\n\t\tpropertySources.addFirst(new PropertiesPropertySource(\"testProperties\", testProperties));\n\t}\n\n\n\t@Test\n\tvoid containsProperty() {\n\t\tassertThat(propertyResolver.containsProperty(\"foo\")).isFalse();\n\t\ttestProperties.put(\"foo\", \"bar\");\n\t\tassertThat(propertyResolver.containsProperty(\"foo\")).isTrue();\n\t}\n\n\t@Test\n\tvoid getProperty() {\n\t\tassertThat(propertyResolver.getProperty(\"foo\")).isNull();\n\t\ttestProperties.put(\"foo\", \"bar\");\n\t\tassertThat(propertyResolver.getProperty(\"foo\")).isEqualTo(\"bar\");\n\t}\n\n\t@Test\n\tvoid getProperty_withDefaultValue() {\n\t\tassertThat(propertyResolver.getProperty(\"foo\", \"myDefault\")).isEqualTo(\"myDefault\");\n\t\ttestProperties.put(\"foo\", \"bar\");\n\t\tassertThat(propertyResolver.getProperty(\"foo\")).isEqualTo(\"bar\");\n\t}\n\n\t@Test\n\tvoid getProperty_propertySourceSearchOrderIsFIFO() {\n\t\tMutablePropertySources sources = new MutablePropertySources();\n\t\tPropertyResolver resolver = new PropertySourcesPropertyResolver(sources);\n\t\tsources.addFirst(new MockPropertySource(\"ps1\").withProperty(\"pName\", \"ps1Value\"));\n\t\tassertThat(resolver.getProperty(\"pName\")).isEqualTo(\"ps1Value\");\n\t\tsources.addFirst(new MockPropertySource(\"ps2\").withProperty(\"pName\", \"ps2Value\"));\n\t\tassertThat(resolver.getProperty(\"pName\")).isEqualTo(\"ps2Value\");\n\t\tsources.addFirst(new MockPropertySource(\"ps3\").withProperty(\"pName\", \"ps3Value\"));\n\t\tassertThat(resolver.getProperty(\"pName\")).isEqualTo(\"ps3Value\");\n\t}\n\n\t@Test\n\tvoid getProperty_withExplicitNullValue() {\n\t\t// java.util.Properties does not allow null values (because Hashtable does not)\n\t\tMap<String, Object> nullableProperties = new HashMap<>();\n\t\tpropertySources.addLast(new MapPropertySource(\"nullableProperties\", nullableProperties));\n\t\tnullableProperties.put(\"foo\", null);\n\t\tassertThat(propertyResolver.getProperty(\"foo\")).isNull();\n\t}\n\n\t@Test\n\tvoid getProperty_withTargetType_andDefaultValue() {\n\t\tassertThat(propertyResolver.getProperty(\"foo\", Integer.class, 42)).isEqualTo(42);\n\t\ttestProperties.put(\"foo\", 13);\n\t\tassertThat(propertyResolver.getProperty(\"foo\", Integer.class, 42)).isEqualTo(13);\n\t}\n\n\t@Test\n\tvoid getProperty_withStringArrayConversion() {\n\t\ttestProperties.put(\"foo\", \"bar,baz\");\n\t\tassertThat(propertyResolver.getProperty(\"foo\", String[].class)).isEqualTo(new String[] { \"bar\", \"baz\" });\n\t}\n\n\t@Test\n\tvoid getProperty_withNonConvertibleTargetType() {\n\t\ttestProperties.put(\"foo\", \"bar\");\n\n\t\tclass TestType { }\n\n\t\tassertThatExceptionOfType(ConverterNotFoundException.class).isThrownBy(() ->\n\t\t\t\tpropertyResolver.getProperty(\"foo\", TestType.class));\n\t}\n\n\t@Test\n\tvoid getProperty_doesNotCache_replaceExistingKeyPostConstruction() {\n\t\tString key = \"foo\";\n\t\tString value1 = \"bar\";\n\t\tString value2 = \"biz\";\n\n\t\tHashMap<String, Object> map = new HashMap<>();\n\t\tmap.put(key, value1); // before construction\n\t\tMutablePropertySources propertySources = new MutablePropertySources();\n\t\tpropertySources.addFirst(new MapPropertySource(\"testProperties\", map));\n\t\tPropertyResolver propertyResolver = new PropertySourcesPropertyResolver(propertySources);\n\t\tassertThat(propertyResolver.getProperty(key)).isEqualTo(value1);\n\t\tmap.put(key, value2); // after construction and first resolution\n\t\tassertThat(propertyResolver.getProperty(key)).isEqualTo(value2);\n\t}\n\n\t@Test\n\tvoid getProperty_doesNotCache_addNewKeyPostConstruction() {\n\t\tHashMap<String, Object> map = new HashMap<>();\n\t\tMutablePropertySources propertySources = new MutablePropertySources();\n\t\tpropertySources.addFirst(new MapPropertySource(\"testProperties\", map));\n\t\tPropertyResolver propertyResolver = new PropertySourcesPropertyResolver(propertySources);\n\t\tassertThat(propertyResolver.getProperty(\"foo\")).isNull();\n\t\tmap.put(\"foo\", \"42\");\n\t\tassertThat(propertyResolver.getProperty(\"foo\")).isEqualTo(\"42\");\n\t}\n\n\t@Test\n\tvoid getPropertySources_replacePropertySource() {\n\t\tpropertySources = new MutablePropertySources();\n\t\tpropertyResolver = new PropertySourcesPropertyResolver(propertySources);\n\t\tpropertySources.addLast(new MockPropertySource(\"local\").withProperty(\"foo\", \"localValue\"));\n\t\tpropertySources.addLast(new MockPropertySource(\"system\").withProperty(\"foo\", \"systemValue\"));\n\n\t\t// 'local' was added first so has precedence\n\t\tassertThat(propertyResolver.getProperty(\"foo\")).isEqualTo(\"localValue\");\n\n\t\t// replace 'local' with new property source\n\t\tpropertySources.replace(\"local\", new MockPropertySource(\"new\").withProperty(\"foo\", \"newValue\"));\n\n\t\t// 'system' now has precedence\n\t\tassertThat(propertyResolver.getProperty(\"foo\")).isEqualTo(\"newValue\");\n\n\t\tassertThat(propertySources).hasSize(2);\n\t}\n\n\t@Test\n\tvoid getRequiredProperty() {\n\t\ttestProperties.put(\"exists\", \"xyz\");\n\t\tassertThat(propertyResolver.getRequiredProperty(\"exists\")).isEqualTo(\"xyz\");\n\n\t\tassertThatIllegalStateException().isThrownBy(() ->\n\t\t\t\tpropertyResolver.getRequiredProperty(\"bogus\"));\n\t}\n\n\t@Test\n\tvoid getRequiredProperty_withStringArrayConversion() {\n\t\ttestProperties.put(\"exists\", \"abc,123\");\n\t\tassertThat(propertyResolver.getRequiredProperty(\"exists\", String[].class)).isEqualTo(new String[] { \"abc\", \"123\" });\n\n\t\tassertThatIllegalStateException().isThrownBy(() ->\n\t\t\t\tpropertyResolver.getRequiredProperty(\"bogus\", String[].class));\n\t}\n\n\t@Test\n\tvoid resolvePlaceholders() {\n\t\tMutablePropertySources propertySources = new MutablePropertySources();\n\t\tpropertySources.addFirst(new MockPropertySource().withProperty(\"key\", \"value\"));\n\t\tPropertyResolver resolver = new PropertySourcesPropertyResolver(propertySources);\n\t\tassertThat(resolver.resolvePlaceholders(\"Replace this ${key}\")).isEqualTo(\"Replace this value\");\n\t}\n\n\t@Test\n\tvoid resolvePlaceholders_withUnresolvable() {\n\t\tMutablePropertySources propertySources = new MutablePropertySources();\n\t\tpropertySources.addFirst(new MockPropertySource().withProperty(\"key\", \"value\"));\n\t\tPropertyResolver resolver = new PropertySourcesPropertyResolver(propertySources);\n\t\tassertThat(resolver.resolvePlaceholders(\"Replace this ${key} plus ${unknown}\"))\n\t\t\t\t.isEqualTo(\"Replace this value plus ${unknown}\");\n\t}\n\n\t@Test\n\tvoid resolvePlaceholders_withDefaultValue() {\n\t\tMutablePropertySources propertySources = new MutablePropertySources();\n\t\tpropertySources.addFirst(new MockPropertySource().withProperty(\"key\", \"value\"));\n\t\tPropertyResolver resolver = new PropertySourcesPropertyResolver(propertySources);\n\t\tassertThat(resolver.resolvePlaceholders(\"Replace this ${key} plus ${unknown:defaultValue}\"))\n\t\t\t\t.isEqualTo(\"Replace this value plus defaultValue\");\n\t}\n\n\t@Test\n\tvoid resolvePlaceholders_withNullInput() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tnew PropertySourcesPropertyResolver(new MutablePropertySources()).resolvePlaceholders(null));\n\t}\n\n\t@Test\n\tvoid resolveRequiredPlaceholders() {\n\t\tMutablePropertySources propertySources = new MutablePropertySources();\n\t\tpropertySources.addFirst(new MockPropertySource().withProperty(\"key\", \"value\"));\n\t\tPropertyResolver resolver = new PropertySourcesPropertyResolver(propertySources);\n\t\tassertThat(resolver.resolveRequiredPlaceholders(\"Replace this ${key}\")).isEqualTo(\"Replace this value\");\n\t}\n\n\t@Test\n\tvoid resolveRequiredPlaceholders_withUnresolvable() {\n\t\tMutablePropertySources propertySources = new MutablePropertySources();\n\t\tpropertySources.addFirst(new MockPropertySource().withProperty(\"key\", \"value\"));\n\t\tPropertyResolver resolver = new PropertySourcesPropertyResolver(propertySources);\n\t\tassertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(() ->\n\t\t\t\tresolver.resolveRequiredPlaceholders(\"Replace this ${key} plus ${unknown}\"));\n\t}\n\n\t@Test\n\tvoid resolveRequiredPlaceholders_withDefaultValue() {\n\t\tMutablePropertySources propertySources = new MutablePropertySources();\n\t\tpropertySources.addFirst(new MockPropertySource().withProperty(\"key\", \"value\"));\n\t\tPropertyResolver resolver = new PropertySourcesPropertyResolver(propertySources);\n\t\tassertThat(resolver.resolveRequiredPlaceholders(\"Replace this ${key} plus ${unknown:defaultValue}\"))\n\t\t\t\t.isEqualTo(\"Replace this value plus defaultValue\");\n\t}\n\n\t@Test\n\tvoid resolveRequiredPlaceholders_withNullInput() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tnew PropertySourcesPropertyResolver(new MutablePropertySources()).resolveRequiredPlaceholders(null));\n\t}\n\n\t@Test\n\tvoid setRequiredProperties_andValidateRequiredProperties() {\n\t\t// no properties have been marked as required -> validation should pass\n\t\tpropertyResolver.validateRequiredProperties();\n\n\t\t// mark which properties are required\n\t\tpropertyResolver.setRequiredProperties(\"foo\", \"bar\");\n\n\t\t// neither foo nor bar properties are present -> validating should throw\n\t\tassertThatExceptionOfType(MissingRequiredPropertiesException.class).isThrownBy(\n\t\t\t\tpropertyResolver::validateRequiredProperties)\n\t\t\t.withMessage(\"The following properties were declared as required \" +\n\t\t\t\t\t\"but could not be resolved: [foo, bar]\");\n\n\t\t// add foo property -> validation should fail only on missing 'bar' property\n\t\ttestProperties.put(\"foo\", \"fooValue\");\n\t\tassertThatExceptionOfType(MissingRequiredPropertiesException.class).isThrownBy(\n\t\t\t\tpropertyResolver::validateRequiredProperties)\n\t\t\t.withMessage(\"The following properties were declared as required \" +\n\t\t\t\t\t\"but could not be resolved: [bar]\");\n\n\t\t// add bar property -> validation should pass, even with an empty string value\n\t\ttestProperties.put(\"bar\", \"\");\n\t\tpropertyResolver.validateRequiredProperties();\n\t}\n\n\t@Test\n\tvoid resolveNestedPropertyPlaceholders() {\n\t\tMutablePropertySources ps = new MutablePropertySources();\n\t\tps.addFirst(new MockPropertySource()\n\t\t\t.withProperty(\"p1\", \"v1\")\n\t\t\t.withProperty(\"p2\", \"v2\")\n\t\t\t.withProperty(\"p3\", \"${p1}:${p2}\")              // nested placeholders\n\t\t\t.withProperty(\"p4\", \"${p3}\")                    // deeply nested placeholders\n\t\t\t.withProperty(\"p5\", \"${p1}:${p2}:${bogus}\")     // unresolvable placeholder\n\t\t\t.withProperty(\"p6\", \"${p1}:${p2}:${bogus:def}\") // unresolvable w/ default\n\t\t\t.withProperty(\"pL\", \"${pR}\")                    // cyclic reference left\n\t\t\t.withProperty(\"pR\", \"${pL}\")                    // cyclic reference right\n\t\t);\n\t\tConfigurablePropertyResolver pr = new PropertySourcesPropertyResolver(ps);\n\t\tassertThat(pr.getProperty(\"p1\")).isEqualTo(\"v1\");\n\t\tassertThat(pr.getProperty(\"p2\")).isEqualTo(\"v2\");\n\t\tassertThat(pr.getProperty(\"p3\")).isEqualTo(\"v1:v2\");\n\t\tassertThat(pr.getProperty(\"p4\")).isEqualTo(\"v1:v2\");\n\t\tassertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(() ->\n\t\t\t\tpr.getProperty(\"p5\"))\n\t\t\t.withMessageContaining(\"Could not resolve placeholder 'bogus' in value \\\"${p1}:${p2}:${bogus}\\\"\");\n\t\tassertThat(pr.getProperty(\"p6\")).isEqualTo(\"v1:v2:def\");\n\t\tassertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(() ->\n\t\t\t\tpr.getProperty(\"pL\"))\n\t\t\t.withMessageContaining(\"Circular\");\n\t}\n\n\t@Test\n\tvoid resolveNestedPlaceholdersIfValueIsCharSequence() {\n\t\tMutablePropertySources ps = new MutablePropertySources();\n\t\tps.addFirst(new MockPropertySource()\n\t\t\t\t.withProperty(\"p1\", \"v1\")\n\t\t\t\t.withProperty(\"p2\", \"v2\")\n\t\t\t\t.withProperty(\"p3\", new StringBuilder(\"${p1}:${p2}\")));\n\t\tConfigurablePropertyResolver pr = new PropertySourcesPropertyResolver(ps);\n\t\tassertThat(pr.getProperty(\"p1\")).isEqualTo(\"v1\");\n\t\tassertThat(pr.getProperty(\"p2\")).isEqualTo(\"v2\");\n\t\tassertThat(pr.getProperty(\"p3\")).isEqualTo(\"v1:v2\");\n\t}\n\n\t@Test\n\tvoid resolveNestedPlaceholdersIfValueIsCharSequenceAndStringBuilderIsRequested() {\n\t\tMutablePropertySources ps = new MutablePropertySources();\n\t\tps.addFirst(new MockPropertySource()\n\t\t\t\t.withProperty(\"p1\", \"v1\")\n\t\t\t\t.withProperty(\"p2\", \"v2\")\n\t\t\t\t.withProperty(\"p3\", new StringBuilder(\"${p1}:${p2}\")));\n\t\tConfigurablePropertyResolver pr = new PropertySourcesPropertyResolver(ps);\n\t\tassertThat(pr.getProperty(\"p3\", StringBuilder.class)).isInstanceOf(StringBuilder.class)\n\t\t\t\t.hasToString(\"${p1}:${p2}\");\n\t}\n\n\t@Test // gh-33727\n\tvoid resolveNestedPlaceHolderIfValueShouldConvertToOtherTypes() {\n\t\tMutablePropertySources ps = new MutablePropertySources();\n\t\tps.addFirst(new MockPropertySource().withProperty(\"new.enabled\", \"${old.enabled:true}\"));\n\t\tConfigurablePropertyResolver pr = new PropertySourcesPropertyResolver(ps);\n\t\tassertThat(pr.getProperty(\"new.enabled\", Boolean.class, false)).isTrue();\n\t}\n\n\t@Test\n\tvoid ignoreUnresolvableNestedPlaceholdersIsConfigurable() {\n\t\tMutablePropertySources ps = new MutablePropertySources();\n\t\tps.addFirst(new MockPropertySource()\n\t\t\t.withProperty(\"p1\", \"v1\")\n\t\t\t.withProperty(\"p2\", \"v2\")\n\t\t\t.withProperty(\"p3\", \"${p1}:${p2}:${bogus:def}\") // unresolvable w/ default\n\t\t\t.withProperty(\"p4\", \"${p1}:${p2}:${bogus}\")     // unresolvable placeholder\n\t\t);\n\t\tConfigurablePropertyResolver pr = new PropertySourcesPropertyResolver(ps);\n\t\tassertThat(pr.getProperty(\"p1\")).isEqualTo(\"v1\");\n\t\tassertThat(pr.getProperty(\"p2\")).isEqualTo(\"v2\");\n\t\tassertThat(pr.getProperty(\"p3\")).isEqualTo(\"v1:v2:def\");\n\n\t\t// placeholders nested within the value of \"p4\" are unresolvable and cause an\n\t\t// exception by default\n\t\tassertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(() ->\n\t\t\t\tpr.getProperty(\"p4\"))\n\t\t\t.withMessageContaining(\"Could not resolve placeholder 'bogus' in value \\\"${p1}:${p2}:${bogus}\\\"\");\n\n\t\t// relax the treatment of unresolvable nested placeholders\n\t\tpr.setIgnoreUnresolvableNestedPlaceholders(true);\n\t\t// and observe they now pass through unresolved\n\t\tassertThat(pr.getProperty(\"p4\")).isEqualTo(\"v1:v2:${bogus}\");\n\n\t\t// resolve[Nested]Placeholders methods behave as usual regardless the value of\n\t\t// ignoreUnresolvableNestedPlaceholders\n\t\tassertThat(pr.resolvePlaceholders(\"${p1}:${p2}:${bogus}\")).isEqualTo(\"v1:v2:${bogus}\");\n\t\tassertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(() ->\n\t\t\t\tpr.resolveRequiredPlaceholders(\"${p1}:${p2}:${bogus}\"))\n\t\t\t.withMessageContaining(\"Could not resolve placeholder 'bogus' in value \\\"${p1}:${p2}:${bogus}\\\"\");\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.env",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core.env",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.env.PropertySourceTests",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.env.PropertySourceTests",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.env;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Tests for {@link PropertySource} implementations.\n *\n * @author Chris Beams\n * @since 3.1\n */\nclass PropertySourceTests {\n\n\t@Test\n\t@SuppressWarnings(\"serial\")\n\tvoid equals() {\n\t\tMap<String, Object> map1 = Map.of(\"a\", \"b\");\n\t\tMap<String, Object> map2 = Map.of(\"c\", \"d\");\n\t\tProperties props1 = new Properties() {{\n\t\t\tsetProperty(\"a\", \"b\");\n\t\t}};\n\t\tProperties props2 = new Properties() {{\n\t\t\tsetProperty(\"c\", \"d\");\n\t\t}};\n\n\t\tMapPropertySource mps = new MapPropertySource(\"mps\", map1);\n\t\tassertThat(mps).isEqualTo(mps);\n\n\t\tassertThat(new MapPropertySource(\"x\", map1)).isEqualTo(new MapPropertySource(\"x\", map1));\n\t\tassertThat(new MapPropertySource(\"x\", map1)).isEqualTo(new MapPropertySource(\"x\", map2));\n\t\tassertThat(new MapPropertySource(\"x\", map1)).isEqualTo(new PropertiesPropertySource(\"x\", props1));\n\t\tassertThat(new MapPropertySource(\"x\", map1)).isEqualTo(new PropertiesPropertySource(\"x\", props2));\n\n\t\tassertThat(new MapPropertySource(\"x\", map1)).isNotEqualTo(new Object());\n\t\tassertThat(new MapPropertySource(\"x\", map1)).isNotEqualTo(\"x\");\n\t\tassertThat(new MapPropertySource(\"x\", map1)).isNotEqualTo(new MapPropertySource(\"y\", map1));\n\t\tassertThat(new MapPropertySource(\"x\", map1)).isNotEqualTo(new MapPropertySource(\"y\", map2));\n\t\tassertThat(new MapPropertySource(\"x\", map1)).isNotEqualTo(new PropertiesPropertySource(\"y\", props1));\n\t\tassertThat(new MapPropertySource(\"x\", map1)).isNotEqualTo(new PropertiesPropertySource(\"y\", props2));\n\t}\n\n\t@Test\n\tvoid collectionsOperations() {\n\t\tMap<String, Object> map1 = Map.of(\"a\", \"b\");\n\t\tMap<String, Object> map2 = Map.of(\"c\", \"d\");\n\n\t\tPropertySource<?> ps1 = new MapPropertySource(\"ps1\", map1);\n\t\tps1.getSource();\n\t\tList<PropertySource<?>> propertySources = new ArrayList<>();\n\t\tassertThat(propertySources.add(ps1)).isTrue();\n\t\tassertThat(propertySources).contains(ps1);\n\t\tassertThat(propertySources).contains(PropertySource.named(\"ps1\"));\n\n\t\tPropertySource<?> ps1replacement = new MapPropertySource(\"ps1\", map2); // notice - different map\n\t\tassertThat(propertySources.add(ps1replacement)).isTrue(); // true because linkedlist allows duplicates\n\t\tassertThat(propertySources).hasSize(2);\n\t\tassertThat(propertySources.remove(PropertySource.named(\"ps1\"))).isTrue();\n\t\tassertThat(propertySources).hasSize(1);\n\t\tassertThat(propertySources.remove(PropertySource.named(\"ps1\"))).isTrue();\n\t\tassertThat(propertySources).isEmpty();\n\n\t\tPropertySource<?> ps2 = new MapPropertySource(\"ps2\", map2);\n\t\tpropertySources.add(ps1);\n\t\tpropertySources.add(ps2);\n\t\tassertThat(propertySources.indexOf(PropertySource.named(\"ps1\"))).isEqualTo(0);\n\t\tassertThat(propertySources.indexOf(PropertySource.named(\"ps2\"))).isEqualTo(1);\n\t\tpropertySources.clear();\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.env.PropertySourceTests#equals()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\n@SuppressWarnings(\"serial\")\r\nvoid equals() {\r\n    Map<String, Object> map1 = Map.of(\"a\", \"b\");\r\n    Map<String, Object> map2 = Map.of(\"c\", \"d\");\r\n    Properties props1 = new Properties() {\r\n\r\n        {\r\n            setProperty(\"a\", \"b\");\r\n        }\r\n    };\r\n    Properties props2 = new Properties() {\r\n\r\n        {\r\n            setProperty(\"c\", \"d\");\r\n        }\r\n    };\r\n    MapPropertySource mps = new MapPropertySource(\"mps\", map1);\r\n    assertThat(mps).isEqualTo(mps);\r\n    assertThat(new MapPropertySource(\"x\", map1)).isEqualTo(new MapPropertySource(\"x\", map1));\r\n    assertThat(new MapPropertySource(\"x\", map1)).isEqualTo(new MapPropertySource(\"x\", map2));\r\n    assertThat(new MapPropertySource(\"x\", map1)).isEqualTo(new PropertiesPropertySource(\"x\", props1));\r\n    assertThat(new MapPropertySource(\"x\", map1)).isEqualTo(new PropertiesPropertySource(\"x\", props2));\r\n    assertThat(new MapPropertySource(\"x\", map1)).isNotEqualTo(new Object());\r\n    assertThat(new MapPropertySource(\"x\", map1)).isNotEqualTo(\"x\");\r\n    assertThat(new MapPropertySource(\"x\", map1)).isNotEqualTo(new MapPropertySource(\"y\", map1));\r\n    assertThat(new MapPropertySource(\"x\", map1)).isNotEqualTo(new MapPropertySource(\"y\", map2));\r\n    assertThat(new MapPropertySource(\"x\", map1)).isNotEqualTo(new PropertiesPropertySource(\"y\", props1));\r\n    assertThat(new MapPropertySource(\"x\", map1)).isNotEqualTo(new PropertiesPropertySource(\"y\", props2));\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.env.PropertySourceTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.env.PropertySourceTests#equals()",
    "tailType": "method"
  }
]