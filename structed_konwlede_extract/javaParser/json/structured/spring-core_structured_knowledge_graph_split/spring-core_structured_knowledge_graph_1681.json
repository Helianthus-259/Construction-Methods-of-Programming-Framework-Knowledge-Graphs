[
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.AliasForNonexistentAttributeClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.AliasForNonexistentAttributeClass",
    "headType": "class",
    "relation": "use",
    "tail": "@AliasForNonexistentAttribute",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AliasForNonexistentAttributeClass",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Method;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.ParametersAreNonnullByDefault;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.subpackage.NonPublicAnnotatedClass;\nimport org.springframework.core.testfixture.ide.IdeUtils;\nimport org.springframework.core.testfixture.stereotype.Component;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Collectors.toList;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalStateException;\nimport static org.springframework.core.annotation.AnnotationUtils.VALUE;\nimport static org.springframework.core.annotation.AnnotationUtils.findAnnotation;\nimport static org.springframework.core.annotation.AnnotationUtils.findAnnotationDeclaringClass;\nimport static org.springframework.core.annotation.AnnotationUtils.findAnnotationDeclaringClassForTypes;\nimport static org.springframework.core.annotation.AnnotationUtils.getAnnotation;\nimport static org.springframework.core.annotation.AnnotationUtils.getAnnotationAttributes;\nimport static org.springframework.core.annotation.AnnotationUtils.getDeclaredRepeatableAnnotations;\nimport static org.springframework.core.annotation.AnnotationUtils.getDefaultValue;\nimport static org.springframework.core.annotation.AnnotationUtils.getRepeatableAnnotations;\nimport static org.springframework.core.annotation.AnnotationUtils.getValue;\nimport static org.springframework.core.annotation.AnnotationUtils.isAnnotationDeclaredLocally;\nimport static org.springframework.core.annotation.AnnotationUtils.isAnnotationInherited;\nimport static org.springframework.core.annotation.AnnotationUtils.isAnnotationMetaPresent;\nimport static org.springframework.core.annotation.AnnotationUtils.synthesizeAnnotation;\n\n/**\n * Tests for {@link AnnotationUtils}.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Chris Beams\n * @author Phillip Webb\n * @author Oleg Zhurakousky\n */\n@SuppressWarnings(\"deprecation\")\nclass AnnotationUtilsTests {\n\n\t@BeforeEach\n\tvoid clearCacheBeforeTests() {\n\t\tAnnotationUtils.clearCache();\n\t}\n\n\n\t@Test\n\tvoid findMethodAnnotationOnLeaf() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"annotatedOnLeaf\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNotNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNotNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findMethodAnnotationWithAnnotationOnMethodInInterface() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"fromInterfaceImplementedByRoot\");\n\t\t// @Order is not @Inherited\n\t\tassertThat(m.getAnnotation(Order.class)).isNull();\n\t\t// getAnnotation() does not search on interfaces\n\t\tassertThat(getAnnotation(m, Order.class)).isNull();\n\t\t// findAnnotation() does search on interfaces\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findMethodAnnotationWithMetaAnnotationOnLeaf() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"metaAnnotatedOnLeaf\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNotNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findMethodAnnotationWithMetaMetaAnnotationOnLeaf() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"metaMetaAnnotatedOnLeaf\");\n\t\tassertThat(m.getAnnotation(Component.class)).isNull();\n\t\tassertThat(getAnnotation(m, Component.class)).isNull();\n\t\tassertThat(findAnnotation(m, Component.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationOnRoot() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"annotatedOnRoot\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNotNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNotNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findMethodAnnotationWithMetaAnnotationOnRoot() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"metaAnnotatedOnRoot\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNotNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationOnRootButOverridden() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"overrideWithoutNewAnnotation\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationNotAnnotated() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"notAnnotated\");\n\t\tassertThat(findAnnotation(m, Order.class)).isNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationOnBridgeMethod() throws Exception {\n\t\tMethod bridgeMethod = SimpleFoo.class.getMethod(\"something\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(bridgeMethod.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(bridgeMethod, Order.class)).isNull();\n\t\tassertThat(findAnnotation(bridgeMethod, Order.class)).isNotNull();\n\n\t\t// As of JDK 8, invoking getAnnotation() on a bridge method actually finds an\n\t\t// annotation on its 'bridged' method [1]; however, the Eclipse compiler does\n\t\t// not support this [2]. Thus, we effectively ignore the following\n\t\t// assertion if the test is currently executing within the Eclipse IDE.\n\t\t//\n\t\t// [1] https://bugs.openjdk.java.net/browse/JDK-6695379\n\t\t// [2] https://bugs.eclipse.org/bugs/show_bug.cgi?id=495396\n\t\t//\n\t\tif (!IdeUtils.runningInEclipse()) {\n\t\t\tassertThat(bridgeMethod.getAnnotation(Transactional.class)).isNotNull();\n\t\t}\n\t\tassertThat(getAnnotation(bridgeMethod, Transactional.class)).isNotNull();\n\t\tassertThat(findAnnotation(bridgeMethod, Transactional.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationOnBridgedMethod() throws Exception {\n\t\tMethod bridgedMethod = SimpleFoo.class.getMethod(\"something\", String.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tassertThat(bridgedMethod.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(bridgedMethod, Order.class)).isNull();\n\t\tassertThat(findAnnotation(bridgedMethod, Order.class)).isNotNull();\n\n\t\tassertThat(bridgedMethod.getAnnotation(Transactional.class)).isNotNull();\n\t\tassertThat(getAnnotation(bridgedMethod, Transactional.class)).isNotNull();\n\t\tassertThat(findAnnotation(bridgedMethod, Transactional.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationFromInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test  // SPR-16060\n\tvoid findMethodAnnotationFromGenericInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test  // SPR-17146\n\tvoid findMethodAnnotationFromGenericSuperclass() throws Exception {\n\t\tMethod method = ExtendsBaseClassWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationFromInterfaceOnSuper() throws Exception {\n\t\tMethod method = SubOfImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationFromInterfaceWhenSuperDoesNotImplementMethod() throws Exception {\n\t\tMethod method = SubOfAbstractImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t// @since 4.1.2\n\t@Test\n\tvoid findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverAnnotationsOnInterfaces() {\n\t\tComponent component = findAnnotation(ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface.class, Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tassertThat(component.value()).isEqualTo(\"meta2\");\n\t}\n\n\t// @since 4.0.3\n\t@Test\n\tvoid findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedAnnotations() {\n\t\tTransactional transactional = findAnnotation(SubSubClassWithInheritedAnnotation.class, Transactional.class);\n\t\tassertThat(transactional).isNotNull();\n\t\tassertThat(transactional.readOnly()).as(\"readOnly flag for SubSubClassWithInheritedAnnotation\").isTrue();\n\t}\n\n\t// @since 4.0.3\n\t@Test\n\tvoid findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedComposedAnnotations() {\n\t\tComponent component = findAnnotation(SubSubClassWithInheritedMetaAnnotation.class, Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tassertThat(component.value()).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid findClassAnnotationOnMetaMetaAnnotatedClass() {\n\t\tComponent component = findAnnotation(MetaMetaAnnotatedClass.class, Component.class);\n\t\tassertThat(component).as(\"Should find meta-annotation on composed annotation on class\").isNotNull();\n\t\tassertThat(component.value()).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid findClassAnnotationOnMetaMetaMetaAnnotatedClass() {\n\t\tComponent component = findAnnotation(MetaMetaMetaAnnotatedClass.class, Component.class);\n\t\tassertThat(component).as(\"Should find meta-annotation on meta-annotation on composed annotation on class\").isNotNull();\n\t\tassertThat(component.value()).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid findClassAnnotationOnAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\t// TransactionalClass is NOT annotated or meta-annotated with @Component\n\t\tComponent component = findAnnotation(TransactionalClass.class, Component.class);\n\t\tassertThat(component).as(\"Should not find @Component on TransactionalClass\").isNull();\n\t}\n\n\t@Test\n\tvoid findClassAnnotationOnMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\tComponent component = findAnnotation(MetaCycleAnnotatedClass.class, Component.class);\n\t\tassertThat(component).as(\"Should not find @Component on MetaCycleAnnotatedClass\").isNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnInheritedAnnotationInterface() {\n\t\tTransactional tx = findAnnotation(InheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(tx).as(\"Should find @Transactional on InheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnSubInheritedAnnotationInterface() {\n\t\tTransactional tx = findAnnotation(SubInheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(tx).as(\"Should find @Transactional on SubInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnSubSubInheritedAnnotationInterface() {\n\t\tTransactional tx = findAnnotation(SubSubInheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(tx).as(\"Should find @Transactional on SubSubInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnNonInheritedAnnotationInterface() {\n\t\tOrder order = findAnnotation(NonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(order).as(\"Should find @Order on NonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnSubNonInheritedAnnotationInterface() {\n\t\tOrder order = findAnnotation(SubNonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(order).as(\"Should find @Order on SubNonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnSubSubNonInheritedAnnotationInterface() {\n\t\tOrder order = findAnnotation(SubSubNonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(order).as(\"Should find @Order on SubSubNonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findAnnotationDeclaringClassForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, NonAnnotatedInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, NonAnnotatedClass.class)).isNull();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, InheritedAnnotationInterface.class)).isEqualTo(InheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, SubInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, InheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, SubInheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but findAnnotationDeclaringClass() should still find it on classes.\n\t\tassertThat(findAnnotationDeclaringClass(Order.class, NonInheritedAnnotationInterface.class)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClass(Order.class, SubNonInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClass(Order.class, NonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClass(Order.class, SubNonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t}\n\n\t@Test\n\tvoid findAnnotationDeclaringClassForTypesWithSingleCandidateType() {\n\t\t// no class-level annotation\n\t\tList<Class<? extends Annotation>> transactionalCandidateList = Collections.singletonList(Transactional.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, NonAnnotatedInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, NonAnnotatedClass.class)).isNull();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, InheritedAnnotationInterface.class)).isEqualTo(InheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, SubInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, InheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, SubInheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but findAnnotationDeclaringClassForTypes() should still find it on classes.\n\t\tList<Class<? extends Annotation>> orderCandidateList = Collections.singletonList(Order.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, NonInheritedAnnotationInterface.class)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, SubNonInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, NonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, SubNonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t}\n\n\t@Test\n\tvoid findAnnotationDeclaringClassForTypesWithMultipleCandidateTypes() {\n\t\tList<Class<? extends Annotation>> candidates = asList(Transactional.class, Order.class);\n\n\t\t// no class-level annotation\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, NonAnnotatedInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, NonAnnotatedClass.class)).isNull();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, InheritedAnnotationInterface.class)).isEqualTo(InheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, InheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubInheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but findAnnotationDeclaringClassForTypes() should still find it on classes.\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, NonInheritedAnnotationInterface.class)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubNonInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, NonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubNonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\n\t\t// class hierarchy mixed with @Transactional and @Order declarations\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, TransactionalClass.class)).isEqualTo(TransactionalClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, TransactionalAndOrderedClass.class)).isEqualTo(TransactionalAndOrderedClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubTransactionalAndOrderedClass.class)).isEqualTo(TransactionalAndOrderedClass.class);\n\t}\n\n\t@Test\n\tvoid isAnnotationDeclaredLocallyForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, NonAnnotatedInterface.class)).isFalse();\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, NonAnnotatedClass.class)).isFalse();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, InheritedAnnotationInterface.class)).isTrue();\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, SubInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, InheritedAnnotationClass.class)).isTrue();\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, SubInheritedAnnotationClass.class)).isFalse();\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited\n\t\tassertThat(isAnnotationDeclaredLocally(Order.class, NonInheritedAnnotationInterface.class)).isTrue();\n\t\tassertThat(isAnnotationDeclaredLocally(Order.class, SubNonInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationDeclaredLocally(Order.class, NonInheritedAnnotationClass.class)).isTrue();\n\t\tassertThat(isAnnotationDeclaredLocally(Order.class, SubNonInheritedAnnotationClass.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotationInheritedForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(isAnnotationInherited(Transactional.class, NonAnnotatedInterface.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Transactional.class, NonAnnotatedClass.class)).isFalse();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(isAnnotationInherited(Transactional.class, InheritedAnnotationInterface.class)).isFalse();\n\t\t// isAnnotationInherited() does not currently traverse interface hierarchies.\n\t\t// Thus the following, though perhaps counterintuitive, must be false:\n\t\tassertThat(isAnnotationInherited(Transactional.class, SubInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Transactional.class, InheritedAnnotationClass.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Transactional.class, SubInheritedAnnotationClass.class)).isTrue();\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited\n\t\tassertThat(isAnnotationInherited(Order.class, NonInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Order.class, SubNonInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Order.class, NonInheritedAnnotationClass.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Order.class, SubNonInheritedAnnotationClass.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotationMetaPresentForPlainType() {\n\t\tassertThat(isAnnotationMetaPresent(Order.class, Documented.class)).isTrue();\n\t\tassertThat(isAnnotationMetaPresent(ParametersAreNonnullByDefault.class, Documented.class)).isTrue();\n\t\tassertThat(isAnnotationMetaPresent(ParametersAreNonnullByDefault.class, Nonnull.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributesWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\n\t\tAnnotationAttributes attributes = (AnnotationAttributes) getAnnotationAttributes(component);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.getString(VALUE)).as(\"value attribute: \").isEqualTo(\"webController\");\n\t\tassertThat(attributes.annotationType()).isEqualTo(Component.class);\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributesWithNestedAnnotations() {\n\t\tComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class);\n\t\tassertThat(componentScan).isNotNull();\n\n\t\tAnnotationAttributes attributes = getAnnotationAttributes(ComponentScanClass.class, componentScan);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(ComponentScan.class);\n\n\t\tFilter[] filters = attributes.getAnnotationArray(\"excludeFilters\", Filter.class);\n\t\tassertThat(filters).isNotNull();\n\n\t\tList<String> patterns = stream(filters).map(Filter::pattern).collect(toList());\n\t\tassertThat(patterns).isEqualTo(asList(\"*Foo\", \"*Bar\"));\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributesWithAttributeAliases() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\t\tWebMapping webMapping = method.getAnnotation(WebMapping.class);\n\t\tAnnotationAttributes attributes = (AnnotationAttributes) getAnnotationAttributes(webMapping);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(WebMapping.class);\n\t\tassertThat(attributes.getString(\"name\")).as(\"name attribute: \").isEqualTo(\"foo\");\n\t\tassertThat(attributes.getStringArray(VALUE)).as(\"value attribute: \").isEqualTo(asArray(\"/test\"));\n\t\tassertThat(attributes.getStringArray(\"path\")).as(\"path attribute: \").isEqualTo(asArray(\"/test\"));\n\n\t\tmethod = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\twebMapping = method.getAnnotation(WebMapping.class);\n\t\tattributes = (AnnotationAttributes) getAnnotationAttributes(webMapping);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(WebMapping.class);\n\t\tassertThat(attributes.getString(\"name\")).as(\"name attribute: \").isEqualTo(\"bar\");\n\t\tassertThat(attributes.getStringArray(VALUE)).as(\"value attribute: \").isEqualTo(asArray(\"/test\"));\n\t\tassertThat(attributes.getStringArray(\"path\")).as(\"path attribute: \").isEqualTo(asArray(\"/test\"));\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributesWithAttributeAliasesWithDifferentValues() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithDifferentPathAndValueAttributes\");\n\t\tWebMapping webMapping = method.getAnnotation(WebMapping.class);\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tgetAnnotationAttributes(webMapping))\n\t\t\t.withMessageContaining(\"attribute 'path' and its alias 'value'\")\n\t\t\t.withMessageContaining(\"values of [{/test}] and [{/enigma}]\");\n\t}\n\n\t@Test\n\tvoid getValueFromAnnotation() throws Exception {\n\t\tMethod method = SimpleFoo.class.getMethod(\"something\", Object.class);\n\t\tOrder order = findAnnotation(method, Order.class);\n\n\t\tassertThat(getValue(order, VALUE)).isEqualTo(1);\n\t\tassertThat(getValue(order)).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getValueFromNonPublicAnnotation() {\n\t\tAnnotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\n\t\tassertThat(declaredAnnotations).hasSize(1);\n\t\tAnnotation annotation = declaredAnnotations[0];\n\t\tassertThat(annotation).isNotNull();\n\t\tassertThat(annotation.annotationType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\n\t\tassertThat(getValue(annotation, VALUE)).isEqualTo(42);\n\t\tassertThat(getValue(annotation)).isEqualTo(42);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromAnnotation() throws Exception {\n\t\tMethod method = SimpleFoo.class.getMethod(\"something\", Object.class);\n\t\tOrder order = findAnnotation(method, Order.class);\n\n\t\tassertThat(getDefaultValue(order, VALUE)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\n\t\tassertThat(getDefaultValue(order)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromNonPublicAnnotation() {\n\t\tAnnotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\n\t\tassertThat(declaredAnnotations).hasSize(1);\n\t\tAnnotation annotation = declaredAnnotations[0];\n\t\tassertThat(annotation).isNotNull();\n\t\tassertThat(annotation.annotationType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\n\t\tassertThat(getDefaultValue(annotation, VALUE)).isEqualTo(-1);\n\t\tassertThat(getDefaultValue(annotation)).isEqualTo(-1);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromAnnotationType() {\n\t\tassertThat(getDefaultValue(Order.class, VALUE)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\n\t\tassertThat(getDefaultValue(Order.class)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Test\n\tvoid findRepeatableAnnotation() {\n\t\tRepeatable repeatable = findAnnotation(MyRepeatable.class, Repeatable.class);\n\t\tassertThat(repeatable).isNotNull();\n\t\tassertThat(repeatable.value()).isEqualTo(MyRepeatableContainer.class);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnMethod() throws Exception {\n\t\tMethod method = InterfaceWithRepeated.class.getMethod(\"foo\");\n\t\tSet<MyRepeatable> annotations = getRepeatableAnnotations(method, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(annotations).isNotNull();\n\t\tList<String> values = annotations.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(asList(\"A\", \"B\", \"C\", \"meta1\"));\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnClassWithAttributeAliases() {\n\t\tfinal List<String> expectedLocations = asList(\"A\", \"B\");\n\n\t\tSet<ContextConfig> annotations = getRepeatableAnnotations(ConfigHierarchyTestCase.class, ContextConfig.class, null);\n\t\tassertThat(annotations).isNotNull();\n\t\tassertThat(annotations).as(\"size if container type is omitted: \").isEmpty();\n\n\t\tannotations = getRepeatableAnnotations(ConfigHierarchyTestCase.class, ContextConfig.class, Hierarchy.class);\n\t\tassertThat(annotations).isNotNull();\n\n\t\tList<String> locations = annotations.stream().map(ContextConfig::location).collect(toList());\n\t\tassertThat(locations).isEqualTo(expectedLocations);\n\n\t\tList<String> values = annotations.stream().map(ContextConfig::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedLocations);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnClass() {\n\t\tfinal List<String> expectedValuesJava = asList(\"A\", \"B\", \"C\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"A\", \"B\", \"C\", \"meta1\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = MyRepeatableClass.class.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnSuperclass() {\n\t\tfinal Class<?> clazz = SubMyRepeatableClass.class;\n\t\tfinal List<String> expectedValuesJava = asList(\"A\", \"B\", \"C\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"A\", \"B\", \"C\", \"meta1\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getRepeatableAnnotations(clazz, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnClassAndSuperclass() {\n\t\tfinal Class<?> clazz = SubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\n\t\tfinal List<String> expectedValuesJava = asList(\"X\", \"Y\", \"Z\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"X\", \"Y\", \"Z\", \"meta2\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getRepeatableAnnotations(clazz, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnMultipleSuperclasses() {\n\t\tfinal Class<?> clazz = SubSubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\n\t\tfinal List<String> expectedValuesJava = asList(\"X\", \"Y\", \"Z\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"X\", \"Y\", \"Z\", \"meta2\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getRepeatableAnnotations(clazz, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getDeclaredRepeatableAnnotationsDeclaredOnClass() {\n\t\tfinal List<String> expectedValuesJava = asList(\"A\", \"B\", \"C\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"A\", \"B\", \"C\", \"meta1\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = MyRepeatableClass.class.getDeclaredAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getDeclaredRepeatableAnnotations(\n\t\t\t\tMyRepeatableClass.class, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getDeclaredRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getDeclaredRepeatableAnnotationsDeclaredOnSuperclass() {\n\t\tfinal Class<?> clazz = SubMyRepeatableClass.class;\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = clazz.getDeclaredAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tassertThat(array).isEmpty();\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getDeclaredRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tassertThat(set).isEmpty();\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getDeclaredRepeatableAnnotations(clazz, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tassertThat(set).isEmpty();\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationWithImplicitAliasesWithMissingDefaultValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithMissingDefaultValuesContextConfigClass.class;\n\t\tClass<ImplicitAliasesWithMissingDefaultValuesContextConfig> annotationType =\n\t\t\t\tImplicitAliasesWithMissingDefaultValuesContextConfig.class;\n\t\tImplicitAliasesWithMissingDefaultValuesContextConfig config = clazz.getAnnotation(annotationType);\n\t\tassertThat(config).isNotNull();\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(config, clazz))\n\t\t\t.withMessageStartingWith(\"Misconfigured aliases:\")\n\t\t\t.withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t.withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t.withMessageContaining(\"default values\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationWithImplicitAliasesWithDifferentDefaultValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithDifferentDefaultValuesContextConfigClass.class;\n\t\tClass<ImplicitAliasesWithDifferentDefaultValuesContextConfig> annotationType =\n\t\t\t\tImplicitAliasesWithDifferentDefaultValuesContextConfig.class;\n\t\tImplicitAliasesWithDifferentDefaultValuesContextConfig config = clazz.getAnnotation(annotationType);\n\t\tassertThat(config).isNotNull();\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(config, clazz))\n\t\t\t.withMessageStartingWith(\"Misconfigured aliases:\")\n\t\t\t.withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t.withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t.withMessageContaining(\"same default value\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationWithImplicitAliasesWithDuplicateValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithDuplicateValuesContextConfigClass.class;\n\t\tClass<ImplicitAliasesWithDuplicateValuesContextConfig> annotationType =\n\t\t\t\tImplicitAliasesWithDuplicateValuesContextConfig.class;\n\t\tImplicitAliasesWithDuplicateValuesContextConfig config = clazz.getAnnotation(annotationType);\n\t\tassertThat(config).isNotNull();\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(config, clazz).location1())\n\t\t\t.withMessageStartingWith(\"Different @AliasFor mirror values\")\n\t\t\t.withMessageContaining(annotationType.getName())\n\t\t\t.withMessageContaining(\"declared on class\")\n\t\t\t.withMessageContaining(clazz.getName())\n\t\t\t.withMessageContaining(\"attribute 'location1' and its alias 'location2'\")\n\t\t\t.withMessageContaining(\"with values of [1] and [2]\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\n\t\tMap<String, Object> map = Collections.singletonMap(VALUE, \"webController\");\n\t\tComponent synthesizedComponent = synthesizeAnnotation(map, Component.class, WebController.class);\n\t\tassertThat(synthesizedComponent).isNotNull();\n\n\t\tassertThat(synthesizedComponent).isNotSameAs(component);\n\t\tassertThat(component.value()).as(\"value from component: \").isEqualTo(\"webController\");\n\t\tassertThat(synthesizedComponent.value()).as(\"value from synthesized component: \").isEqualTo(\"webController\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeAnnotationFromMapWithNestedMap() {\n\t\tComponentScanSingleFilter componentScan =\n\t\t\t\tComponentScanSingleFilterClass.class.getAnnotation(ComponentScanSingleFilter.class);\n\t\tassertThat(componentScan).isNotNull();\n\t\tassertThat(componentScan.value().pattern()).as(\"value from ComponentScan: \").isEqualTo(\"*Foo\");\n\n\t\tAnnotationAttributes attributes = getAnnotationAttributes(\n\t\t\t\tComponentScanSingleFilterClass.class, componentScan, false, true);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(ComponentScanSingleFilter.class);\n\n\t\tMap<String, Object> filterMap = (Map<String, Object>) attributes.get(\"value\");\n\t\tassertThat(filterMap).isNotNull();\n\t\tassertThat(filterMap.get(\"pattern\")).isEqualTo(\"*Foo\");\n\n\t\t// Modify nested map\n\t\tfilterMap.put(\"pattern\", \"newFoo\");\n\t\tfilterMap.put(\"enigma\", 42);\n\n\t\tComponentScanSingleFilter synthesizedComponentScan = synthesizeAnnotation(\n\t\t\t\tattributes, ComponentScanSingleFilter.class, ComponentScanSingleFilterClass.class);\n\t\tassertThat(synthesizedComponentScan).isNotNull();\n\n\t\tassertThat(synthesizedComponentScan).isNotSameAs(componentScan);\n\t\tassertThat(synthesizedComponentScan.value().pattern()).as(\"value from synthesized ComponentScan: \").isEqualTo(\"newFoo\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeAnnotationFromMapWithNestedArrayOfMaps() {\n\t\tComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class);\n\t\tassertThat(componentScan).isNotNull();\n\n\t\tAnnotationAttributes attributes = getAnnotationAttributes(ComponentScanClass.class, componentScan, false, true);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(ComponentScan.class);\n\n\t\tMap<String, Object>[] filters = (Map[]) attributes.get(\"excludeFilters\");\n\t\tassertThat(filters).isNotNull();\n\n\t\tList<String> patterns = stream(filters).map(m -> (String) m.get(\"pattern\")).collect(toList());\n\t\tassertThat(patterns).isEqualTo(asList(\"*Foo\", \"*Bar\"));\n\n\t\t// Modify nested maps\n\t\tfilters[0].put(\"pattern\", \"newFoo\");\n\t\tfilters[0].put(\"enigma\", 42);\n\t\tfilters[1].put(\"pattern\", \"newBar\");\n\t\tfilters[1].put(\"enigma\", 42);\n\n\t\tComponentScan synthesizedComponentScan =\n\t\t\t\tsynthesizeAnnotation(attributes, ComponentScan.class, ComponentScanClass.class);\n\t\tassertThat(synthesizedComponentScan).isNotNull();\n\n\t\tassertThat(synthesizedComponentScan).isNotSameAs(componentScan);\n\t\tpatterns = stream(synthesizedComponentScan.excludeFilters()).map(Filter::pattern).collect(toList());\n\t\tassertThat(patterns).isEqualTo(asList(\"newFoo\", \"newBar\"));\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromDefaultsWithoutAttributeAliases() {\n\t\tAnnotationWithDefaults annotationWithDefaults = synthesizeAnnotation(AnnotationWithDefaults.class);\n\t\tassertThat(annotationWithDefaults).isNotNull();\n\t\tassertThat(annotationWithDefaults.text()).as(\"text: \").isEqualTo(\"enigma\");\n\t\tassertThat(annotationWithDefaults.predicate()).as(\"predicate: \").isTrue();\n\t\tassertThat(annotationWithDefaults.characters()).as(\"characters: \").isEqualTo(new char[] { 'a', 'b', 'c' });\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromDefaultsWithAttributeAliases() {\n\t\tContextConfig contextConfig = synthesizeAnnotation(ContextConfig.class);\n\t\tassertThat(contextConfig).isNotNull();\n\t\tassertThat(contextConfig.value()).as(\"value: \").isEmpty();\n\t\tassertThat(contextConfig.location()).as(\"location: \").isEmpty();\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithMinimalAttributesWithAttributeAliases() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"location\", \"test.xml\");\n\t\tContextConfig contextConfig = synthesizeAnnotation(map, ContextConfig.class, null);\n\t\tassertThat(contextConfig).isNotNull();\n\t\tassertThat(contextConfig.value()).as(\"value: \").isEqualTo(\"test.xml\");\n\t\tassertThat(contextConfig.location()).as(\"location: \").isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"value\", \"/foo\");\n\t\tGet get = synthesizeAnnotation(map, Get.class, null);\n\t\tassertThat(get).isNotNull();\n\t\tassertThat(get.value()).as(\"value: \").isEqualTo(\"/foo\");\n\t\tassertThat(get.path()).as(\"path: \").isEqualTo(\"/foo\");\n\n\t\tmap = Collections.singletonMap(\"path\", \"/foo\");\n\t\tget = synthesizeAnnotation(map, Get.class, null);\n\t\tassertThat(get).isNotNull();\n\t\tassertThat(get.value()).as(\"value: \").isEqualTo(\"/foo\");\n\t\tassertThat(get.path()).as(\"path: \").isEqualTo(\"/foo\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithImplicitAttributeAliases() {\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"value\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"location1\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"location2\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"location3\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"xmlFile\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"groovyScript\");\n\t}\n\n\tprivate void assertAnnotationSynthesisFromMapWithImplicitAliases(String attributeNameAndValue) {\n\t\tMap<String, Object> map = Collections.singletonMap(attributeNameAndValue, attributeNameAndValue);\n\t\tImplicitAliasesContextConfig config = synthesizeAnnotation(map, ImplicitAliasesContextConfig.class, null);\n\t\tassertThat(config).isNotNull();\n\t\tassertThat(config.value()).as(\"value: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.location1()).as(\"location1: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.location2()).as(\"location2: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.location3()).as(\"location3: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.xmlFile()).as(\"xmlFile: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.groovyScript()).as(\"groovyScript: \").isEqualTo(attributeNameAndValue);\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithMissingAttributeValue() {\n\t\tassertMissingTextAttribute(Collections.emptyMap());\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithNullAttributeValue() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"text\", null);\n\t\tassertThat(map.containsKey(\"text\")).isTrue();\n\t\tassertMissingTextAttribute(map);\n\t}\n\n\tprivate void assertMissingTextAttribute(Map<String, Object> attributes) {\n\t\tassertThatExceptionOfType(NoSuchElementException.class).isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(attributes, AnnotationWithoutDefaults.class, null).text())\n\t\t\t.withMessageContaining(\"No value found for attribute named 'text' in merged annotation\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithAttributeOfIncorrectType() {\n\t\tMap<String, Object> map = Collections.singletonMap(VALUE, 42L);\n\t\tassertThatIllegalStateException().isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(map, Component.class, null).value())\n\t\t\t.withMessageContaining(\"Attribute 'value' in annotation org.springframework.core.testfixture.stereotype.Component \"\n\t\t\t\t\t+ \"should be compatible with java.lang.String but a java.lang.Long value was returned\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromAnnotationAttributesWithoutAttributeAliases() {\n\t\t// 1) Get an annotation\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\n\t\t// 2) Convert the annotation into AnnotationAttributes\n\t\tAnnotationAttributes attributes = getAnnotationAttributes(WebController.class, component);\n\t\tassertThat(attributes).isNotNull();\n\n\t\t// 3) Synthesize the AnnotationAttributes back into an annotation\n\t\tComponent synthesizedComponent = synthesizeAnnotation(attributes, Component.class, WebController.class);\n\t\tassertThat(synthesizedComponent).isNotNull();\n\n\t\t// 4) Verify that the original and synthesized annotations are equivalent\n\t\tassertThat(synthesizedComponent).isNotSameAs(component);\n\t\tassertThat(synthesizedComponent).isEqualTo(component);\n\t\tassertThat(component.value()).as(\"value from component: \").isEqualTo(\"webController\");\n\t\tassertThat(synthesizedComponent.value()).as(\"value from synthesized component: \").isEqualTo(\"webController\");\n\t}\n\n\t@Test  // gh-22702\n\tvoid findAnnotationWithRepeatablesElements() {\n\t\tassertThat(AnnotationUtils.findAnnotation(TestRepeatablesClass.class,\n\t\t\t\tTestRepeatable.class)).isNull();\n\t\tassertThat(AnnotationUtils.findAnnotation(TestRepeatablesClass.class,\n\t\tTestRepeatableContainer.class)).isNotNull();\n\t}\n\n\t@Test  // gh-23856\n\tvoid findAnnotationFindsRepeatableContainerOnComposedAnnotationMetaAnnotatedWithRepeatableAnnotations() {\n\t\tMyRepeatableContainer annotation = AnnotationUtils.findAnnotation(MyRepeatableMeta1And2.class, MyRepeatableContainer.class);\n\n\t\tassertThat(annotation).isNotNull();\n\t\tassertThat(annotation.value()).extracting(MyRepeatable::value).containsExactly(\"meta1\", \"meta2\");\n\t}\n\n\t@Test  // gh-23856\n\tvoid findAnnotationFindsRepeatableContainerOnComposedAnnotationMetaAnnotatedWithRepeatableAnnotationsOnMethod() throws Exception {\n\t\tMethod method = getClass().getDeclaredMethod(\"methodWithComposedAnnotationMetaAnnotatedWithRepeatableAnnotations\");\n\t\tMyRepeatableContainer annotation = AnnotationUtils.findAnnotation(method, MyRepeatableContainer.class);\n\n\t\tassertThat(annotation).isNotNull();\n\t\tassertThat(annotation.value()).extracting(MyRepeatable::value).containsExactly(\"meta1\", \"meta2\");\n\t}\n\n\t@Test  // gh-23929\n\tvoid findDeprecatedAnnotation() {\n\t\tassertThat(getAnnotation(DeprecatedClass.class, Deprecated.class)).isNotNull();\n\t\tassertThat(getAnnotation(SubclassOfDeprecatedClass.class, Deprecated.class)).isNull();\n\t\tassertThat(findAnnotation(DeprecatedClass.class, Deprecated.class)).isNotNull();\n\t\tassertThat(findAnnotation(SubclassOfDeprecatedClass.class, Deprecated.class)).isNotNull();\n\t}\n\n\n\t@SafeVarargs\n\tstatic <T> T[] asArray(T... arr) {\n\t\treturn arr;\n\t}\n\n\n\t@Component(\"meta1\")\n\t@Order\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Meta1 {\n\t}\n\n\t@Component(\"meta2\")\n\t@Transactional(readOnly = true)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Meta2 {\n\t}\n\n\t@Meta2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMeta {\n\t}\n\n\t@MetaMeta\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMetaMeta {\n\t}\n\n\t@MetaCycle3\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle1 {\n\t}\n\n\t@MetaCycle1\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle2 {\n\t}\n\n\t@MetaCycle2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle3 {\n\t}\n\n\t@Meta1\n\tinterface InterfaceWithMetaAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface implements InterfaceWithMetaAnnotation {\n\t}\n\n\t@Meta1\n\tstatic class ClassWithInheritedMetaAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class SubClassWithInheritedMetaAnnotation extends ClassWithInheritedMetaAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedMetaAnnotation extends SubClassWithInheritedMetaAnnotation {\n\t}\n\n\t@Transactional\n\tstatic class ClassWithInheritedAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class SubClassWithInheritedAnnotation extends ClassWithInheritedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedAnnotation extends SubClassWithInheritedAnnotation {\n\t}\n\n\t@MetaMeta\n\tstatic class MetaMetaAnnotatedClass {\n\t}\n\n\t@MetaMetaMeta\n\tstatic class MetaMetaMetaAnnotatedClass {\n\t}\n\n\t@MetaCycle3\n\tstatic class MetaCycleAnnotatedClass {\n\t}\n\n\tpublic interface AnnotatedInterface {\n\n\t\t@Order(0)\n\t\tvoid fromInterfaceImplementedByRoot();\n\t}\n\n\tpublic static class Root implements AnnotatedInterface {\n\n\t\t@Order(27)\n\t\tpublic void annotatedOnRoot() {\n\t\t}\n\n\t\t@Meta1\n\t\tpublic void metaAnnotatedOnRoot() {\n\t\t}\n\n\t\tpublic void overrideToAnnotate() {\n\t\t}\n\n\t\t@Order(27)\n\t\tpublic void overrideWithoutNewAnnotation() {\n\t\t}\n\n\t\tpublic void notAnnotated() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void fromInterfaceImplementedByRoot() {\n\t\t}\n\t}\n\n\tpublic static class Leaf extends Root {\n\n\t\t@Order(25)\n\t\tpublic void annotatedOnLeaf() {\n\t\t}\n\n\t\t@Meta1\n\t\tpublic void metaAnnotatedOnLeaf() {\n\t\t}\n\n\t\t@MetaMeta\n\t\tpublic void metaMetaAnnotatedOnLeaf() {\n\t\t}\n\n\t\t@Override\n\t\t@Order(1)\n\t\tpublic void overrideToAnnotate() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void overrideWithoutNewAnnotation() {\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Transactional {\n\n\t\tboolean readOnly() default false;\n\t}\n\n\tpublic abstract static class Foo<T> {\n\n\t\t@Order(1)\n\t\tpublic abstract void something(T arg);\n\t}\n\n\tpublic static class SimpleFoo extends Foo<String> {\n\n\t\t@Override\n\t\t@Transactional\n\t\tpublic void something(final String arg) {\n\t\t}\n\t}\n\n\t@Transactional\n\tpublic interface InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubInheritedAnnotationInterface extends InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubInheritedAnnotationInterface extends SubInheritedAnnotationInterface {\n\t}\n\n\t@Order\n\tpublic interface NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubNonInheritedAnnotationInterface extends NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubNonInheritedAnnotationInterface extends SubNonInheritedAnnotationInterface {\n\t}\n\n\tpublic static class NonAnnotatedClass {\n\t}\n\n\tpublic interface NonAnnotatedInterface {\n\t}\n\n\t@Transactional\n\tpublic static class InheritedAnnotationClass {\n\t}\n\n\tpublic static class SubInheritedAnnotationClass extends InheritedAnnotationClass {\n\t}\n\n\t@Order\n\tpublic static class NonInheritedAnnotationClass {\n\t}\n\n\tpublic static class SubNonInheritedAnnotationClass extends NonInheritedAnnotationClass {\n\t}\n\n\t@Transactional\n\tpublic static class TransactionalClass {\n\t}\n\n\t@Order\n\tpublic static class TransactionalAndOrderedClass extends TransactionalClass {\n\t}\n\n\tpublic static class SubTransactionalAndOrderedClass extends TransactionalAndOrderedClass {\n\t}\n\n\tpublic interface InterfaceWithAnnotatedMethod {\n\n\t\t@Order\n\t\tvoid foo();\n\t}\n\n\tpublic static class ImplementsInterfaceWithAnnotatedMethod implements InterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic static class SubOfImplementsInterfaceWithAnnotatedMethod extends ImplementsInterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic abstract static class AbstractDoesNotImplementInterfaceWithAnnotatedMethod\n\t\t\timplements InterfaceWithAnnotatedMethod {\n\t}\n\n\tpublic static class SubOfAbstractImplementsInterfaceWithAnnotatedMethod\n\t\t\textends AbstractDoesNotImplementInterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic interface InterfaceWithGenericAnnotatedMethod<T> {\n\n\t\t@Order\n\t\tvoid foo(T t);\n\t}\n\n\tpublic static class ImplementsInterfaceWithGenericAnnotatedMethod implements InterfaceWithGenericAnnotatedMethod<String> {\n\n\t\t@Override\n\t\tpublic void foo(String t) {\n\t\t}\n\t}\n\n\tpublic abstract static class BaseClassWithGenericAnnotatedMethod<T> {\n\n\t\t@Order\n\t\tabstract void foo(T t);\n\t}\n\n\tpublic static class ExtendsBaseClassWithGenericAnnotatedMethod extends BaseClassWithGenericAnnotatedMethod<String> {\n\n\t\t@Override\n\t\tpublic void foo(String t) {\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface MyRepeatableContainer {\n\n\t\tMyRepeatable[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@Repeatable(MyRepeatableContainer.class)\n\t@interface MyRepeatable {\n\n\t\tString value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta1\")\n\t@interface MyRepeatableMeta1 {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta2\")\n\t@interface MyRepeatableMeta2 {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta1\")\n\t@MyRepeatable(\"meta2\")\n\t@interface MyRepeatableMeta1And2 {\n\t}\n\n\t@MyRepeatableMeta1And2\n\tvoid methodWithComposedAnnotationMetaAnnotatedWithRepeatableAnnotations() {\n\t}\n\n\tinterface InterfaceWithRepeated {\n\n\t\t@MyRepeatable(\"A\")\n\t\t@MyRepeatableContainer({@MyRepeatable(\"B\"), @MyRepeatable(\"C\")})\n\t\t@MyRepeatableMeta1\n\t\tvoid foo();\n\t}\n\n\t@MyRepeatable(\"A\")\n\t@MyRepeatableContainer({@MyRepeatable(\"B\"), @MyRepeatable(\"C\")})\n\t@MyRepeatableMeta1\n\tstatic class MyRepeatableClass {\n\t}\n\n\tstatic class SubMyRepeatableClass extends MyRepeatableClass {\n\t}\n\n\t@MyRepeatable(\"X\")\n\t@MyRepeatableContainer({@MyRepeatable(\"Y\"), @MyRepeatable(\"Z\")})\n\t@MyRepeatableMeta2\n\tstatic class SubMyRepeatableWithAdditionalLocalDeclarationsClass extends MyRepeatableClass {\n\t}\n\n\tstatic class SubSubMyRepeatableWithAdditionalLocalDeclarationsClass extends\n\t\t\tSubMyRepeatableWithAdditionalLocalDeclarationsClass {\n\t}\n\n\tenum RequestMethod {\n\t\tGET, POST\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.web.bind.annotation.RequestMapping}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface WebMapping {\n\n\t\tString name();\n\n\t\t@AliasFor(\"path\")\n\t\tString[] value() default \"\";\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tString[] path() default \"\";\n\n\t\tRequestMethod[] method() default {};\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.web.bind.annotation.GetMapping}, except\n\t * that the String arrays are overridden with single String elements.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@WebMapping(method = RequestMethod.GET, name = \"\")\n\t@interface Get {\n\n\t\t@AliasFor(annotation = WebMapping.class)\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = WebMapping.class)\n\t\tString path() default \"\";\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.web.bind.annotation.PostMapping}, except\n\t * that the path is overridden by convention with single String element.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@WebMapping(method = RequestMethod.POST, name = \"\")\n\t@interface Post {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = WebMapping.class)\n\t\tString path() default \"\";\n\t}\n\n\t@Component(\"webController\")\n\tstatic class WebController {\n\n\t\t@WebMapping(value = \"/test\", name = \"foo\")\n\t\tpublic void handleMappedWithValueAttribute() {\n\t\t}\n\n\t\t@WebMapping(path = \"/test\", name = \"bar\", method = { RequestMethod.GET, RequestMethod.POST })\n\t\tpublic void handleMappedWithPathAttribute() {\n\t\t}\n\n\t\t@Get(\"/test\")\n\t\tpublic void getMappedWithValueAttribute() {\n\t\t}\n\n\t\t@Get(path = \"/test\")\n\t\tpublic void getMappedWithPathAttribute() {\n\t\t}\n\n\t\t@Post(path = \"/test\")\n\t\tpublic void postMappedWithPathAttribute() {\n\t\t}\n\n\t\t/**\n\t\t * mapping is logically \"equal\" to handleMappedWithPathAttribute().\n\t\t */\n\t\t@WebMapping(value = \"/test\", path = \"/test\", name = \"bar\", method = { RequestMethod.GET, RequestMethod.POST })\n\t\tpublic void handleMappedWithSamePathAndValueAttributes() {\n\t\t}\n\n\t\t@WebMapping(value = \"/enigma\", path = \"/test\", name = \"baz\")\n\t\tpublic void handleMappedWithDifferentPathAndValueAttributes() {\n\t\t}\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.test.context.ContextConfiguration}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContextConfig {\n\n\t\t@AliasFor(\"location\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString location() default \"\";\n\n\t\tClass<?> klass() default Object.class;\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.test.context.ContextHierarchy}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Hierarchy {\n\t\tContextConfig[] value();\n\t}\n\n\t@Hierarchy({@ContextConfig(\"A\"), @ContextConfig(location = \"B\")})\n\tstatic class ConfigHierarchyTestCase {\n\t}\n\n\t@ContextConfig(\"simple.xml\")\n\tstatic class SimpleConfigTestCase {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface CharsContainer {\n\n\t\t@AliasFor(attribute = \"chars\")\n\t\tchar[] value() default {};\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tchar[] chars() default {};\n\t}\n\n\t@CharsContainer(chars = { 'x', 'y', 'z' })\n\tstatic class GroupOfCharsClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMissingAttributeDeclaration {\n\n\t\t@AliasFor\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForWithMissingAttributeDeclaration\n\tstatic class AliasForWithMissingAttributeDeclarationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithDuplicateAttributeDeclaration {\n\n\t\t@AliasFor(value = \"bar\", attribute = \"baz\")\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForWithDuplicateAttributeDeclaration\n\tstatic class AliasForWithDuplicateAttributeDeclarationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForNonexistentAttribute {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForNonexistentAttribute\n\tstatic class AliasForNonexistentAttributeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithoutMirroredAliasFor {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"\";\n\n\t\tString bar() default \"\";\n\t}\n\n\t@AliasForWithoutMirroredAliasFor\n\tstatic class AliasForWithoutMirroredAliasForClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMirroredAliasForWrongAttribute {\n\n\t\t@AliasFor(attribute = \"bar\")\n\t\tString[] foo() default \"\";\n\n\t\t@AliasFor(attribute = \"quux\")\n\t\tString[] bar() default \"\";\n\t}\n\n\t@AliasForWithMirroredAliasForWrongAttribute\n\tstatic class AliasForWithMirroredAliasForWrongAttributeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForAttributeOfDifferentType {\n\n\t\t@AliasFor(\"bar\")\n\t\tString[] foo() default \"\";\n\n\t\t@AliasFor(\"foo\")\n\t\tboolean bar() default true;\n\t}\n\n\t@AliasForAttributeOfDifferentType\n\tstatic class AliasForAttributeOfDifferentTypeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMissingDefaultValues {\n\n\t\t@AliasFor(attribute = \"bar\")\n\t\tString foo();\n\n\t\t@AliasFor(attribute = \"foo\")\n\t\tString bar();\n\t}\n\n\t@AliasForWithMissingDefaultValues(foo = \"foo\", bar = \"bar\")\n\tstatic class AliasForWithMissingDefaultValuesClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForAttributeWithDifferentDefaultValue {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"X\";\n\n\t\t@AliasFor(\"foo\")\n\t\tString bar() default \"Z\";\n\t}\n\n\t@AliasForAttributeWithDifferentDefaultValue\n\tstatic class AliasForAttributeWithDifferentDefaultValueClass {\n\t}\n\n\t// @ContextConfig --> Intentionally NOT meta-present\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfigNotMetaPresent {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlConfigFile();\n\t}\n\n\t@AliasedComposedContextConfigNotMetaPresent(xmlConfigFile = \"test.xml\")\n\tstatic class AliasedComposedContextConfigNotMetaPresentClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlConfigFile();\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface ImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString groovyScript() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location1() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location2() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location3() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"klass\")\n\t\tClass<?> configClass() default Object.class;\n\n\t\tString nonAliasedAttribute() default \"\";\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(groovyScript = \"groovyScript\")\n\tstatic class GroovyImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(xmlFile = \"xmlFile\")\n\tstatic class XmlImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(\"value\")\n\tstatic class ValueImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(location1 = \"location1\")\n\tstatic class Location1ImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(location2 = \"location2\")\n\tstatic class Location2ImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(location3 = \"location3\")\n\tstatic class Location3ImplicitAliasesContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig {\n\n\t\t// intentionally omitted: attribute = \"value\"\n\t\t@AliasFor(annotation = ContextConfig.class)\n\t\tString value() default \"\";\n\n\t\t// intentionally omitted: attribute = \"locations\"\n\t\t@AliasFor(annotation = ContextConfig.class)\n\t\tString location() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesWithImpliedAliasNamesOmittedContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig.class, attribute = \"location\")\n\t\tString groovy() default \"\";\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig(\"value\")\n\tstatic class ValueImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig(location = \"location\")\n\tstatic class LocationsImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig(xmlFile = \"xmlFile\")\n\tstatic class XmlFilesImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithMissingDefaultValuesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location1();\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location2();\n\t}\n\n\t@ImplicitAliasesWithMissingDefaultValuesContextConfig(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithMissingDefaultValuesContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithDifferentDefaultValuesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location1() default \"foo\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location2() default \"bar\";\n\t}\n\n\t@ImplicitAliasesWithDifferentDefaultValuesContextConfig(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithDifferentDefaultValuesContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithDuplicateValuesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location1() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location2() default \"\";\n\t}\n\n\t@ImplicitAliasesWithDuplicateValuesContextConfig(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithDuplicateValuesContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesForAliasPairContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, value = \"value\")\n\t\tString groovyScript() default \"\";\n\t}\n\n\t@ImplicitAliasesForAliasPairContextConfig(xmlFile = \"test.xml\")\n\tstatic class ImplicitAliasesForAliasPairContextConfigClass {\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScript\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@TransitiveImplicitAliasesContextConfig(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesContextConfigClass {\n\t}\n\n\t@ImplicitAliasesForAliasPairContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesForAliasPairContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesForAliasPairContextConfig.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesForAliasPairContextConfig.class, attribute = \"groovyScript\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@TransitiveImplicitAliasesForAliasPairContextConfig(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesForAliasPairContextConfigClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({})\n\t@interface Filter {\n\t\tString pattern();\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.context.annotation.ComponentScan}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScan {\n\t\tFilter[] excludeFilters() default {};\n\t}\n\n\t@ComponentScan(excludeFilters = {@Filter(pattern = \"*Foo\"), @Filter(pattern = \"*Bar\")})\n\tstatic class ComponentScanClass {\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.context.annotation.ComponentScan}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScanSingleFilter {\n\t\tFilter value();\n\t}\n\n\t@ComponentScanSingleFilter(@Filter(pattern = \"*Foo\"))\n\tstatic class ComponentScanSingleFilterClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnotationWithDefaults {\n\t\tString text() default \"enigma\";\n\t\tboolean predicate() default true;\n\t\tchar[] characters() default {'a', 'b', 'c'};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnotationWithoutDefaults {\n\t\tString text();\n\t}\n\n\t@ContextConfig(value = \"foo\", location = \"bar\")\n\tinterface ContextConfigMismatch {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(TestRepeatableContainer.class)\n\t@interface TestRepeatable {\n\n\t\tString value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestRepeatableContainer {\n\n\t\tTestRepeatable[] value();\n\t}\n\n\t@TestRepeatable(\"a\")\n\t@TestRepeatable(\"b\")\n\tstatic class TestRepeatablesClass {\n\t}\n\n\t@Deprecated\n\tstatic class DeprecatedClass {\n\t}\n\n\tstatic class SubclassOfDeprecatedClass extends DeprecatedClass {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.AliasForWithoutMirroredAliasForClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.AliasForWithoutMirroredAliasForClass",
    "headType": "class",
    "relation": "use",
    "tail": "@AliasForWithoutMirroredAliasFor",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AliasForWithoutMirroredAliasForClass",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Method;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.ParametersAreNonnullByDefault;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.subpackage.NonPublicAnnotatedClass;\nimport org.springframework.core.testfixture.ide.IdeUtils;\nimport org.springframework.core.testfixture.stereotype.Component;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Collectors.toList;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalStateException;\nimport static org.springframework.core.annotation.AnnotationUtils.VALUE;\nimport static org.springframework.core.annotation.AnnotationUtils.findAnnotation;\nimport static org.springframework.core.annotation.AnnotationUtils.findAnnotationDeclaringClass;\nimport static org.springframework.core.annotation.AnnotationUtils.findAnnotationDeclaringClassForTypes;\nimport static org.springframework.core.annotation.AnnotationUtils.getAnnotation;\nimport static org.springframework.core.annotation.AnnotationUtils.getAnnotationAttributes;\nimport static org.springframework.core.annotation.AnnotationUtils.getDeclaredRepeatableAnnotations;\nimport static org.springframework.core.annotation.AnnotationUtils.getDefaultValue;\nimport static org.springframework.core.annotation.AnnotationUtils.getRepeatableAnnotations;\nimport static org.springframework.core.annotation.AnnotationUtils.getValue;\nimport static org.springframework.core.annotation.AnnotationUtils.isAnnotationDeclaredLocally;\nimport static org.springframework.core.annotation.AnnotationUtils.isAnnotationInherited;\nimport static org.springframework.core.annotation.AnnotationUtils.isAnnotationMetaPresent;\nimport static org.springframework.core.annotation.AnnotationUtils.synthesizeAnnotation;\n\n/**\n * Tests for {@link AnnotationUtils}.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Chris Beams\n * @author Phillip Webb\n * @author Oleg Zhurakousky\n */\n@SuppressWarnings(\"deprecation\")\nclass AnnotationUtilsTests {\n\n\t@BeforeEach\n\tvoid clearCacheBeforeTests() {\n\t\tAnnotationUtils.clearCache();\n\t}\n\n\n\t@Test\n\tvoid findMethodAnnotationOnLeaf() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"annotatedOnLeaf\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNotNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNotNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findMethodAnnotationWithAnnotationOnMethodInInterface() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"fromInterfaceImplementedByRoot\");\n\t\t// @Order is not @Inherited\n\t\tassertThat(m.getAnnotation(Order.class)).isNull();\n\t\t// getAnnotation() does not search on interfaces\n\t\tassertThat(getAnnotation(m, Order.class)).isNull();\n\t\t// findAnnotation() does search on interfaces\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findMethodAnnotationWithMetaAnnotationOnLeaf() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"metaAnnotatedOnLeaf\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNotNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findMethodAnnotationWithMetaMetaAnnotationOnLeaf() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"metaMetaAnnotatedOnLeaf\");\n\t\tassertThat(m.getAnnotation(Component.class)).isNull();\n\t\tassertThat(getAnnotation(m, Component.class)).isNull();\n\t\tassertThat(findAnnotation(m, Component.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationOnRoot() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"annotatedOnRoot\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNotNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNotNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findMethodAnnotationWithMetaAnnotationOnRoot() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"metaAnnotatedOnRoot\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNotNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationOnRootButOverridden() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"overrideWithoutNewAnnotation\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationNotAnnotated() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"notAnnotated\");\n\t\tassertThat(findAnnotation(m, Order.class)).isNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationOnBridgeMethod() throws Exception {\n\t\tMethod bridgeMethod = SimpleFoo.class.getMethod(\"something\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(bridgeMethod.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(bridgeMethod, Order.class)).isNull();\n\t\tassertThat(findAnnotation(bridgeMethod, Order.class)).isNotNull();\n\n\t\t// As of JDK 8, invoking getAnnotation() on a bridge method actually finds an\n\t\t// annotation on its 'bridged' method [1]; however, the Eclipse compiler does\n\t\t// not support this [2]. Thus, we effectively ignore the following\n\t\t// assertion if the test is currently executing within the Eclipse IDE.\n\t\t//\n\t\t// [1] https://bugs.openjdk.java.net/browse/JDK-6695379\n\t\t// [2] https://bugs.eclipse.org/bugs/show_bug.cgi?id=495396\n\t\t//\n\t\tif (!IdeUtils.runningInEclipse()) {\n\t\t\tassertThat(bridgeMethod.getAnnotation(Transactional.class)).isNotNull();\n\t\t}\n\t\tassertThat(getAnnotation(bridgeMethod, Transactional.class)).isNotNull();\n\t\tassertThat(findAnnotation(bridgeMethod, Transactional.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationOnBridgedMethod() throws Exception {\n\t\tMethod bridgedMethod = SimpleFoo.class.getMethod(\"something\", String.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tassertThat(bridgedMethod.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(bridgedMethod, Order.class)).isNull();\n\t\tassertThat(findAnnotation(bridgedMethod, Order.class)).isNotNull();\n\n\t\tassertThat(bridgedMethod.getAnnotation(Transactional.class)).isNotNull();\n\t\tassertThat(getAnnotation(bridgedMethod, Transactional.class)).isNotNull();\n\t\tassertThat(findAnnotation(bridgedMethod, Transactional.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationFromInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test  // SPR-16060\n\tvoid findMethodAnnotationFromGenericInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test  // SPR-17146\n\tvoid findMethodAnnotationFromGenericSuperclass() throws Exception {\n\t\tMethod method = ExtendsBaseClassWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationFromInterfaceOnSuper() throws Exception {\n\t\tMethod method = SubOfImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationFromInterfaceWhenSuperDoesNotImplementMethod() throws Exception {\n\t\tMethod method = SubOfAbstractImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t// @since 4.1.2\n\t@Test\n\tvoid findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverAnnotationsOnInterfaces() {\n\t\tComponent component = findAnnotation(ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface.class, Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tassertThat(component.value()).isEqualTo(\"meta2\");\n\t}\n\n\t// @since 4.0.3\n\t@Test\n\tvoid findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedAnnotations() {\n\t\tTransactional transactional = findAnnotation(SubSubClassWithInheritedAnnotation.class, Transactional.class);\n\t\tassertThat(transactional).isNotNull();\n\t\tassertThat(transactional.readOnly()).as(\"readOnly flag for SubSubClassWithInheritedAnnotation\").isTrue();\n\t}\n\n\t// @since 4.0.3\n\t@Test\n\tvoid findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedComposedAnnotations() {\n\t\tComponent component = findAnnotation(SubSubClassWithInheritedMetaAnnotation.class, Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tassertThat(component.value()).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid findClassAnnotationOnMetaMetaAnnotatedClass() {\n\t\tComponent component = findAnnotation(MetaMetaAnnotatedClass.class, Component.class);\n\t\tassertThat(component).as(\"Should find meta-annotation on composed annotation on class\").isNotNull();\n\t\tassertThat(component.value()).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid findClassAnnotationOnMetaMetaMetaAnnotatedClass() {\n\t\tComponent component = findAnnotation(MetaMetaMetaAnnotatedClass.class, Component.class);\n\t\tassertThat(component).as(\"Should find meta-annotation on meta-annotation on composed annotation on class\").isNotNull();\n\t\tassertThat(component.value()).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid findClassAnnotationOnAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\t// TransactionalClass is NOT annotated or meta-annotated with @Component\n\t\tComponent component = findAnnotation(TransactionalClass.class, Component.class);\n\t\tassertThat(component).as(\"Should not find @Component on TransactionalClass\").isNull();\n\t}\n\n\t@Test\n\tvoid findClassAnnotationOnMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\tComponent component = findAnnotation(MetaCycleAnnotatedClass.class, Component.class);\n\t\tassertThat(component).as(\"Should not find @Component on MetaCycleAnnotatedClass\").isNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnInheritedAnnotationInterface() {\n\t\tTransactional tx = findAnnotation(InheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(tx).as(\"Should find @Transactional on InheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnSubInheritedAnnotationInterface() {\n\t\tTransactional tx = findAnnotation(SubInheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(tx).as(\"Should find @Transactional on SubInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnSubSubInheritedAnnotationInterface() {\n\t\tTransactional tx = findAnnotation(SubSubInheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(tx).as(\"Should find @Transactional on SubSubInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnNonInheritedAnnotationInterface() {\n\t\tOrder order = findAnnotation(NonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(order).as(\"Should find @Order on NonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnSubNonInheritedAnnotationInterface() {\n\t\tOrder order = findAnnotation(SubNonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(order).as(\"Should find @Order on SubNonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnSubSubNonInheritedAnnotationInterface() {\n\t\tOrder order = findAnnotation(SubSubNonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(order).as(\"Should find @Order on SubSubNonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findAnnotationDeclaringClassForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, NonAnnotatedInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, NonAnnotatedClass.class)).isNull();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, InheritedAnnotationInterface.class)).isEqualTo(InheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, SubInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, InheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, SubInheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but findAnnotationDeclaringClass() should still find it on classes.\n\t\tassertThat(findAnnotationDeclaringClass(Order.class, NonInheritedAnnotationInterface.class)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClass(Order.class, SubNonInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClass(Order.class, NonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClass(Order.class, SubNonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t}\n\n\t@Test\n\tvoid findAnnotationDeclaringClassForTypesWithSingleCandidateType() {\n\t\t// no class-level annotation\n\t\tList<Class<? extends Annotation>> transactionalCandidateList = Collections.singletonList(Transactional.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, NonAnnotatedInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, NonAnnotatedClass.class)).isNull();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, InheritedAnnotationInterface.class)).isEqualTo(InheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, SubInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, InheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, SubInheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but findAnnotationDeclaringClassForTypes() should still find it on classes.\n\t\tList<Class<? extends Annotation>> orderCandidateList = Collections.singletonList(Order.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, NonInheritedAnnotationInterface.class)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, SubNonInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, NonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, SubNonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t}\n\n\t@Test\n\tvoid findAnnotationDeclaringClassForTypesWithMultipleCandidateTypes() {\n\t\tList<Class<? extends Annotation>> candidates = asList(Transactional.class, Order.class);\n\n\t\t// no class-level annotation\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, NonAnnotatedInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, NonAnnotatedClass.class)).isNull();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, InheritedAnnotationInterface.class)).isEqualTo(InheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, InheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubInheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but findAnnotationDeclaringClassForTypes() should still find it on classes.\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, NonInheritedAnnotationInterface.class)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubNonInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, NonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubNonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\n\t\t// class hierarchy mixed with @Transactional and @Order declarations\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, TransactionalClass.class)).isEqualTo(TransactionalClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, TransactionalAndOrderedClass.class)).isEqualTo(TransactionalAndOrderedClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubTransactionalAndOrderedClass.class)).isEqualTo(TransactionalAndOrderedClass.class);\n\t}\n\n\t@Test\n\tvoid isAnnotationDeclaredLocallyForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, NonAnnotatedInterface.class)).isFalse();\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, NonAnnotatedClass.class)).isFalse();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, InheritedAnnotationInterface.class)).isTrue();\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, SubInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, InheritedAnnotationClass.class)).isTrue();\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, SubInheritedAnnotationClass.class)).isFalse();\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited\n\t\tassertThat(isAnnotationDeclaredLocally(Order.class, NonInheritedAnnotationInterface.class)).isTrue();\n\t\tassertThat(isAnnotationDeclaredLocally(Order.class, SubNonInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationDeclaredLocally(Order.class, NonInheritedAnnotationClass.class)).isTrue();\n\t\tassertThat(isAnnotationDeclaredLocally(Order.class, SubNonInheritedAnnotationClass.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotationInheritedForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(isAnnotationInherited(Transactional.class, NonAnnotatedInterface.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Transactional.class, NonAnnotatedClass.class)).isFalse();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(isAnnotationInherited(Transactional.class, InheritedAnnotationInterface.class)).isFalse();\n\t\t// isAnnotationInherited() does not currently traverse interface hierarchies.\n\t\t// Thus the following, though perhaps counterintuitive, must be false:\n\t\tassertThat(isAnnotationInherited(Transactional.class, SubInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Transactional.class, InheritedAnnotationClass.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Transactional.class, SubInheritedAnnotationClass.class)).isTrue();\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited\n\t\tassertThat(isAnnotationInherited(Order.class, NonInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Order.class, SubNonInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Order.class, NonInheritedAnnotationClass.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Order.class, SubNonInheritedAnnotationClass.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotationMetaPresentForPlainType() {\n\t\tassertThat(isAnnotationMetaPresent(Order.class, Documented.class)).isTrue();\n\t\tassertThat(isAnnotationMetaPresent(ParametersAreNonnullByDefault.class, Documented.class)).isTrue();\n\t\tassertThat(isAnnotationMetaPresent(ParametersAreNonnullByDefault.class, Nonnull.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributesWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\n\t\tAnnotationAttributes attributes = (AnnotationAttributes) getAnnotationAttributes(component);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.getString(VALUE)).as(\"value attribute: \").isEqualTo(\"webController\");\n\t\tassertThat(attributes.annotationType()).isEqualTo(Component.class);\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributesWithNestedAnnotations() {\n\t\tComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class);\n\t\tassertThat(componentScan).isNotNull();\n\n\t\tAnnotationAttributes attributes = getAnnotationAttributes(ComponentScanClass.class, componentScan);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(ComponentScan.class);\n\n\t\tFilter[] filters = attributes.getAnnotationArray(\"excludeFilters\", Filter.class);\n\t\tassertThat(filters).isNotNull();\n\n\t\tList<String> patterns = stream(filters).map(Filter::pattern).collect(toList());\n\t\tassertThat(patterns).isEqualTo(asList(\"*Foo\", \"*Bar\"));\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributesWithAttributeAliases() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\t\tWebMapping webMapping = method.getAnnotation(WebMapping.class);\n\t\tAnnotationAttributes attributes = (AnnotationAttributes) getAnnotationAttributes(webMapping);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(WebMapping.class);\n\t\tassertThat(attributes.getString(\"name\")).as(\"name attribute: \").isEqualTo(\"foo\");\n\t\tassertThat(attributes.getStringArray(VALUE)).as(\"value attribute: \").isEqualTo(asArray(\"/test\"));\n\t\tassertThat(attributes.getStringArray(\"path\")).as(\"path attribute: \").isEqualTo(asArray(\"/test\"));\n\n\t\tmethod = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\twebMapping = method.getAnnotation(WebMapping.class);\n\t\tattributes = (AnnotationAttributes) getAnnotationAttributes(webMapping);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(WebMapping.class);\n\t\tassertThat(attributes.getString(\"name\")).as(\"name attribute: \").isEqualTo(\"bar\");\n\t\tassertThat(attributes.getStringArray(VALUE)).as(\"value attribute: \").isEqualTo(asArray(\"/test\"));\n\t\tassertThat(attributes.getStringArray(\"path\")).as(\"path attribute: \").isEqualTo(asArray(\"/test\"));\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributesWithAttributeAliasesWithDifferentValues() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithDifferentPathAndValueAttributes\");\n\t\tWebMapping webMapping = method.getAnnotation(WebMapping.class);\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tgetAnnotationAttributes(webMapping))\n\t\t\t.withMessageContaining(\"attribute 'path' and its alias 'value'\")\n\t\t\t.withMessageContaining(\"values of [{/test}] and [{/enigma}]\");\n\t}\n\n\t@Test\n\tvoid getValueFromAnnotation() throws Exception {\n\t\tMethod method = SimpleFoo.class.getMethod(\"something\", Object.class);\n\t\tOrder order = findAnnotation(method, Order.class);\n\n\t\tassertThat(getValue(order, VALUE)).isEqualTo(1);\n\t\tassertThat(getValue(order)).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getValueFromNonPublicAnnotation() {\n\t\tAnnotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\n\t\tassertThat(declaredAnnotations).hasSize(1);\n\t\tAnnotation annotation = declaredAnnotations[0];\n\t\tassertThat(annotation).isNotNull();\n\t\tassertThat(annotation.annotationType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\n\t\tassertThat(getValue(annotation, VALUE)).isEqualTo(42);\n\t\tassertThat(getValue(annotation)).isEqualTo(42);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromAnnotation() throws Exception {\n\t\tMethod method = SimpleFoo.class.getMethod(\"something\", Object.class);\n\t\tOrder order = findAnnotation(method, Order.class);\n\n\t\tassertThat(getDefaultValue(order, VALUE)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\n\t\tassertThat(getDefaultValue(order)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromNonPublicAnnotation() {\n\t\tAnnotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\n\t\tassertThat(declaredAnnotations).hasSize(1);\n\t\tAnnotation annotation = declaredAnnotations[0];\n\t\tassertThat(annotation).isNotNull();\n\t\tassertThat(annotation.annotationType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\n\t\tassertThat(getDefaultValue(annotation, VALUE)).isEqualTo(-1);\n\t\tassertThat(getDefaultValue(annotation)).isEqualTo(-1);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromAnnotationType() {\n\t\tassertThat(getDefaultValue(Order.class, VALUE)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\n\t\tassertThat(getDefaultValue(Order.class)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Test\n\tvoid findRepeatableAnnotation() {\n\t\tRepeatable repeatable = findAnnotation(MyRepeatable.class, Repeatable.class);\n\t\tassertThat(repeatable).isNotNull();\n\t\tassertThat(repeatable.value()).isEqualTo(MyRepeatableContainer.class);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnMethod() throws Exception {\n\t\tMethod method = InterfaceWithRepeated.class.getMethod(\"foo\");\n\t\tSet<MyRepeatable> annotations = getRepeatableAnnotations(method, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(annotations).isNotNull();\n\t\tList<String> values = annotations.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(asList(\"A\", \"B\", \"C\", \"meta1\"));\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnClassWithAttributeAliases() {\n\t\tfinal List<String> expectedLocations = asList(\"A\", \"B\");\n\n\t\tSet<ContextConfig> annotations = getRepeatableAnnotations(ConfigHierarchyTestCase.class, ContextConfig.class, null);\n\t\tassertThat(annotations).isNotNull();\n\t\tassertThat(annotations).as(\"size if container type is omitted: \").isEmpty();\n\n\t\tannotations = getRepeatableAnnotations(ConfigHierarchyTestCase.class, ContextConfig.class, Hierarchy.class);\n\t\tassertThat(annotations).isNotNull();\n\n\t\tList<String> locations = annotations.stream().map(ContextConfig::location).collect(toList());\n\t\tassertThat(locations).isEqualTo(expectedLocations);\n\n\t\tList<String> values = annotations.stream().map(ContextConfig::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedLocations);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnClass() {\n\t\tfinal List<String> expectedValuesJava = asList(\"A\", \"B\", \"C\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"A\", \"B\", \"C\", \"meta1\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = MyRepeatableClass.class.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnSuperclass() {\n\t\tfinal Class<?> clazz = SubMyRepeatableClass.class;\n\t\tfinal List<String> expectedValuesJava = asList(\"A\", \"B\", \"C\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"A\", \"B\", \"C\", \"meta1\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getRepeatableAnnotations(clazz, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnClassAndSuperclass() {\n\t\tfinal Class<?> clazz = SubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\n\t\tfinal List<String> expectedValuesJava = asList(\"X\", \"Y\", \"Z\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"X\", \"Y\", \"Z\", \"meta2\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getRepeatableAnnotations(clazz, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnMultipleSuperclasses() {\n\t\tfinal Class<?> clazz = SubSubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\n\t\tfinal List<String> expectedValuesJava = asList(\"X\", \"Y\", \"Z\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"X\", \"Y\", \"Z\", \"meta2\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getRepeatableAnnotations(clazz, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getDeclaredRepeatableAnnotationsDeclaredOnClass() {\n\t\tfinal List<String> expectedValuesJava = asList(\"A\", \"B\", \"C\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"A\", \"B\", \"C\", \"meta1\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = MyRepeatableClass.class.getDeclaredAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getDeclaredRepeatableAnnotations(\n\t\t\t\tMyRepeatableClass.class, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getDeclaredRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getDeclaredRepeatableAnnotationsDeclaredOnSuperclass() {\n\t\tfinal Class<?> clazz = SubMyRepeatableClass.class;\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = clazz.getDeclaredAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tassertThat(array).isEmpty();\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getDeclaredRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tassertThat(set).isEmpty();\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getDeclaredRepeatableAnnotations(clazz, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tassertThat(set).isEmpty();\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationWithImplicitAliasesWithMissingDefaultValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithMissingDefaultValuesContextConfigClass.class;\n\t\tClass<ImplicitAliasesWithMissingDefaultValuesContextConfig> annotationType =\n\t\t\t\tImplicitAliasesWithMissingDefaultValuesContextConfig.class;\n\t\tImplicitAliasesWithMissingDefaultValuesContextConfig config = clazz.getAnnotation(annotationType);\n\t\tassertThat(config).isNotNull();\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(config, clazz))\n\t\t\t.withMessageStartingWith(\"Misconfigured aliases:\")\n\t\t\t.withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t.withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t.withMessageContaining(\"default values\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationWithImplicitAliasesWithDifferentDefaultValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithDifferentDefaultValuesContextConfigClass.class;\n\t\tClass<ImplicitAliasesWithDifferentDefaultValuesContextConfig> annotationType =\n\t\t\t\tImplicitAliasesWithDifferentDefaultValuesContextConfig.class;\n\t\tImplicitAliasesWithDifferentDefaultValuesContextConfig config = clazz.getAnnotation(annotationType);\n\t\tassertThat(config).isNotNull();\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(config, clazz))\n\t\t\t.withMessageStartingWith(\"Misconfigured aliases:\")\n\t\t\t.withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t.withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t.withMessageContaining(\"same default value\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationWithImplicitAliasesWithDuplicateValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithDuplicateValuesContextConfigClass.class;\n\t\tClass<ImplicitAliasesWithDuplicateValuesContextConfig> annotationType =\n\t\t\t\tImplicitAliasesWithDuplicateValuesContextConfig.class;\n\t\tImplicitAliasesWithDuplicateValuesContextConfig config = clazz.getAnnotation(annotationType);\n\t\tassertThat(config).isNotNull();\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(config, clazz).location1())\n\t\t\t.withMessageStartingWith(\"Different @AliasFor mirror values\")\n\t\t\t.withMessageContaining(annotationType.getName())\n\t\t\t.withMessageContaining(\"declared on class\")\n\t\t\t.withMessageContaining(clazz.getName())\n\t\t\t.withMessageContaining(\"attribute 'location1' and its alias 'location2'\")\n\t\t\t.withMessageContaining(\"with values of [1] and [2]\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\n\t\tMap<String, Object> map = Collections.singletonMap(VALUE, \"webController\");\n\t\tComponent synthesizedComponent = synthesizeAnnotation(map, Component.class, WebController.class);\n\t\tassertThat(synthesizedComponent).isNotNull();\n\n\t\tassertThat(synthesizedComponent).isNotSameAs(component);\n\t\tassertThat(component.value()).as(\"value from component: \").isEqualTo(\"webController\");\n\t\tassertThat(synthesizedComponent.value()).as(\"value from synthesized component: \").isEqualTo(\"webController\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeAnnotationFromMapWithNestedMap() {\n\t\tComponentScanSingleFilter componentScan =\n\t\t\t\tComponentScanSingleFilterClass.class.getAnnotation(ComponentScanSingleFilter.class);\n\t\tassertThat(componentScan).isNotNull();\n\t\tassertThat(componentScan.value().pattern()).as(\"value from ComponentScan: \").isEqualTo(\"*Foo\");\n\n\t\tAnnotationAttributes attributes = getAnnotationAttributes(\n\t\t\t\tComponentScanSingleFilterClass.class, componentScan, false, true);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(ComponentScanSingleFilter.class);\n\n\t\tMap<String, Object> filterMap = (Map<String, Object>) attributes.get(\"value\");\n\t\tassertThat(filterMap).isNotNull();\n\t\tassertThat(filterMap.get(\"pattern\")).isEqualTo(\"*Foo\");\n\n\t\t// Modify nested map\n\t\tfilterMap.put(\"pattern\", \"newFoo\");\n\t\tfilterMap.put(\"enigma\", 42);\n\n\t\tComponentScanSingleFilter synthesizedComponentScan = synthesizeAnnotation(\n\t\t\t\tattributes, ComponentScanSingleFilter.class, ComponentScanSingleFilterClass.class);\n\t\tassertThat(synthesizedComponentScan).isNotNull();\n\n\t\tassertThat(synthesizedComponentScan).isNotSameAs(componentScan);\n\t\tassertThat(synthesizedComponentScan.value().pattern()).as(\"value from synthesized ComponentScan: \").isEqualTo(\"newFoo\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeAnnotationFromMapWithNestedArrayOfMaps() {\n\t\tComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class);\n\t\tassertThat(componentScan).isNotNull();\n\n\t\tAnnotationAttributes attributes = getAnnotationAttributes(ComponentScanClass.class, componentScan, false, true);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(ComponentScan.class);\n\n\t\tMap<String, Object>[] filters = (Map[]) attributes.get(\"excludeFilters\");\n\t\tassertThat(filters).isNotNull();\n\n\t\tList<String> patterns = stream(filters).map(m -> (String) m.get(\"pattern\")).collect(toList());\n\t\tassertThat(patterns).isEqualTo(asList(\"*Foo\", \"*Bar\"));\n\n\t\t// Modify nested maps\n\t\tfilters[0].put(\"pattern\", \"newFoo\");\n\t\tfilters[0].put(\"enigma\", 42);\n\t\tfilters[1].put(\"pattern\", \"newBar\");\n\t\tfilters[1].put(\"enigma\", 42);\n\n\t\tComponentScan synthesizedComponentScan =\n\t\t\t\tsynthesizeAnnotation(attributes, ComponentScan.class, ComponentScanClass.class);\n\t\tassertThat(synthesizedComponentScan).isNotNull();\n\n\t\tassertThat(synthesizedComponentScan).isNotSameAs(componentScan);\n\t\tpatterns = stream(synthesizedComponentScan.excludeFilters()).map(Filter::pattern).collect(toList());\n\t\tassertThat(patterns).isEqualTo(asList(\"newFoo\", \"newBar\"));\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromDefaultsWithoutAttributeAliases() {\n\t\tAnnotationWithDefaults annotationWithDefaults = synthesizeAnnotation(AnnotationWithDefaults.class);\n\t\tassertThat(annotationWithDefaults).isNotNull();\n\t\tassertThat(annotationWithDefaults.text()).as(\"text: \").isEqualTo(\"enigma\");\n\t\tassertThat(annotationWithDefaults.predicate()).as(\"predicate: \").isTrue();\n\t\tassertThat(annotationWithDefaults.characters()).as(\"characters: \").isEqualTo(new char[] { 'a', 'b', 'c' });\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromDefaultsWithAttributeAliases() {\n\t\tContextConfig contextConfig = synthesizeAnnotation(ContextConfig.class);\n\t\tassertThat(contextConfig).isNotNull();\n\t\tassertThat(contextConfig.value()).as(\"value: \").isEmpty();\n\t\tassertThat(contextConfig.location()).as(\"location: \").isEmpty();\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithMinimalAttributesWithAttributeAliases() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"location\", \"test.xml\");\n\t\tContextConfig contextConfig = synthesizeAnnotation(map, ContextConfig.class, null);\n\t\tassertThat(contextConfig).isNotNull();\n\t\tassertThat(contextConfig.value()).as(\"value: \").isEqualTo(\"test.xml\");\n\t\tassertThat(contextConfig.location()).as(\"location: \").isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"value\", \"/foo\");\n\t\tGet get = synthesizeAnnotation(map, Get.class, null);\n\t\tassertThat(get).isNotNull();\n\t\tassertThat(get.value()).as(\"value: \").isEqualTo(\"/foo\");\n\t\tassertThat(get.path()).as(\"path: \").isEqualTo(\"/foo\");\n\n\t\tmap = Collections.singletonMap(\"path\", \"/foo\");\n\t\tget = synthesizeAnnotation(map, Get.class, null);\n\t\tassertThat(get).isNotNull();\n\t\tassertThat(get.value()).as(\"value: \").isEqualTo(\"/foo\");\n\t\tassertThat(get.path()).as(\"path: \").isEqualTo(\"/foo\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithImplicitAttributeAliases() {\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"value\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"location1\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"location2\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"location3\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"xmlFile\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"groovyScript\");\n\t}\n\n\tprivate void assertAnnotationSynthesisFromMapWithImplicitAliases(String attributeNameAndValue) {\n\t\tMap<String, Object> map = Collections.singletonMap(attributeNameAndValue, attributeNameAndValue);\n\t\tImplicitAliasesContextConfig config = synthesizeAnnotation(map, ImplicitAliasesContextConfig.class, null);\n\t\tassertThat(config).isNotNull();\n\t\tassertThat(config.value()).as(\"value: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.location1()).as(\"location1: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.location2()).as(\"location2: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.location3()).as(\"location3: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.xmlFile()).as(\"xmlFile: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.groovyScript()).as(\"groovyScript: \").isEqualTo(attributeNameAndValue);\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithMissingAttributeValue() {\n\t\tassertMissingTextAttribute(Collections.emptyMap());\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithNullAttributeValue() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"text\", null);\n\t\tassertThat(map.containsKey(\"text\")).isTrue();\n\t\tassertMissingTextAttribute(map);\n\t}\n\n\tprivate void assertMissingTextAttribute(Map<String, Object> attributes) {\n\t\tassertThatExceptionOfType(NoSuchElementException.class).isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(attributes, AnnotationWithoutDefaults.class, null).text())\n\t\t\t.withMessageContaining(\"No value found for attribute named 'text' in merged annotation\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithAttributeOfIncorrectType() {\n\t\tMap<String, Object> map = Collections.singletonMap(VALUE, 42L);\n\t\tassertThatIllegalStateException().isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(map, Component.class, null).value())\n\t\t\t.withMessageContaining(\"Attribute 'value' in annotation org.springframework.core.testfixture.stereotype.Component \"\n\t\t\t\t\t+ \"should be compatible with java.lang.String but a java.lang.Long value was returned\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromAnnotationAttributesWithoutAttributeAliases() {\n\t\t// 1) Get an annotation\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\n\t\t// 2) Convert the annotation into AnnotationAttributes\n\t\tAnnotationAttributes attributes = getAnnotationAttributes(WebController.class, component);\n\t\tassertThat(attributes).isNotNull();\n\n\t\t// 3) Synthesize the AnnotationAttributes back into an annotation\n\t\tComponent synthesizedComponent = synthesizeAnnotation(attributes, Component.class, WebController.class);\n\t\tassertThat(synthesizedComponent).isNotNull();\n\n\t\t// 4) Verify that the original and synthesized annotations are equivalent\n\t\tassertThat(synthesizedComponent).isNotSameAs(component);\n\t\tassertThat(synthesizedComponent).isEqualTo(component);\n\t\tassertThat(component.value()).as(\"value from component: \").isEqualTo(\"webController\");\n\t\tassertThat(synthesizedComponent.value()).as(\"value from synthesized component: \").isEqualTo(\"webController\");\n\t}\n\n\t@Test  // gh-22702\n\tvoid findAnnotationWithRepeatablesElements() {\n\t\tassertThat(AnnotationUtils.findAnnotation(TestRepeatablesClass.class,\n\t\t\t\tTestRepeatable.class)).isNull();\n\t\tassertThat(AnnotationUtils.findAnnotation(TestRepeatablesClass.class,\n\t\tTestRepeatableContainer.class)).isNotNull();\n\t}\n\n\t@Test  // gh-23856\n\tvoid findAnnotationFindsRepeatableContainerOnComposedAnnotationMetaAnnotatedWithRepeatableAnnotations() {\n\t\tMyRepeatableContainer annotation = AnnotationUtils.findAnnotation(MyRepeatableMeta1And2.class, MyRepeatableContainer.class);\n\n\t\tassertThat(annotation).isNotNull();\n\t\tassertThat(annotation.value()).extracting(MyRepeatable::value).containsExactly(\"meta1\", \"meta2\");\n\t}\n\n\t@Test  // gh-23856\n\tvoid findAnnotationFindsRepeatableContainerOnComposedAnnotationMetaAnnotatedWithRepeatableAnnotationsOnMethod() throws Exception {\n\t\tMethod method = getClass().getDeclaredMethod(\"methodWithComposedAnnotationMetaAnnotatedWithRepeatableAnnotations\");\n\t\tMyRepeatableContainer annotation = AnnotationUtils.findAnnotation(method, MyRepeatableContainer.class);\n\n\t\tassertThat(annotation).isNotNull();\n\t\tassertThat(annotation.value()).extracting(MyRepeatable::value).containsExactly(\"meta1\", \"meta2\");\n\t}\n\n\t@Test  // gh-23929\n\tvoid findDeprecatedAnnotation() {\n\t\tassertThat(getAnnotation(DeprecatedClass.class, Deprecated.class)).isNotNull();\n\t\tassertThat(getAnnotation(SubclassOfDeprecatedClass.class, Deprecated.class)).isNull();\n\t\tassertThat(findAnnotation(DeprecatedClass.class, Deprecated.class)).isNotNull();\n\t\tassertThat(findAnnotation(SubclassOfDeprecatedClass.class, Deprecated.class)).isNotNull();\n\t}\n\n\n\t@SafeVarargs\n\tstatic <T> T[] asArray(T... arr) {\n\t\treturn arr;\n\t}\n\n\n\t@Component(\"meta1\")\n\t@Order\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Meta1 {\n\t}\n\n\t@Component(\"meta2\")\n\t@Transactional(readOnly = true)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Meta2 {\n\t}\n\n\t@Meta2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMeta {\n\t}\n\n\t@MetaMeta\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMetaMeta {\n\t}\n\n\t@MetaCycle3\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle1 {\n\t}\n\n\t@MetaCycle1\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle2 {\n\t}\n\n\t@MetaCycle2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle3 {\n\t}\n\n\t@Meta1\n\tinterface InterfaceWithMetaAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface implements InterfaceWithMetaAnnotation {\n\t}\n\n\t@Meta1\n\tstatic class ClassWithInheritedMetaAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class SubClassWithInheritedMetaAnnotation extends ClassWithInheritedMetaAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedMetaAnnotation extends SubClassWithInheritedMetaAnnotation {\n\t}\n\n\t@Transactional\n\tstatic class ClassWithInheritedAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class SubClassWithInheritedAnnotation extends ClassWithInheritedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedAnnotation extends SubClassWithInheritedAnnotation {\n\t}\n\n\t@MetaMeta\n\tstatic class MetaMetaAnnotatedClass {\n\t}\n\n\t@MetaMetaMeta\n\tstatic class MetaMetaMetaAnnotatedClass {\n\t}\n\n\t@MetaCycle3\n\tstatic class MetaCycleAnnotatedClass {\n\t}\n\n\tpublic interface AnnotatedInterface {\n\n\t\t@Order(0)\n\t\tvoid fromInterfaceImplementedByRoot();\n\t}\n\n\tpublic static class Root implements AnnotatedInterface {\n\n\t\t@Order(27)\n\t\tpublic void annotatedOnRoot() {\n\t\t}\n\n\t\t@Meta1\n\t\tpublic void metaAnnotatedOnRoot() {\n\t\t}\n\n\t\tpublic void overrideToAnnotate() {\n\t\t}\n\n\t\t@Order(27)\n\t\tpublic void overrideWithoutNewAnnotation() {\n\t\t}\n\n\t\tpublic void notAnnotated() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void fromInterfaceImplementedByRoot() {\n\t\t}\n\t}\n\n\tpublic static class Leaf extends Root {\n\n\t\t@Order(25)\n\t\tpublic void annotatedOnLeaf() {\n\t\t}\n\n\t\t@Meta1\n\t\tpublic void metaAnnotatedOnLeaf() {\n\t\t}\n\n\t\t@MetaMeta\n\t\tpublic void metaMetaAnnotatedOnLeaf() {\n\t\t}\n\n\t\t@Override\n\t\t@Order(1)\n\t\tpublic void overrideToAnnotate() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void overrideWithoutNewAnnotation() {\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Transactional {\n\n\t\tboolean readOnly() default false;\n\t}\n\n\tpublic abstract static class Foo<T> {\n\n\t\t@Order(1)\n\t\tpublic abstract void something(T arg);\n\t}\n\n\tpublic static class SimpleFoo extends Foo<String> {\n\n\t\t@Override\n\t\t@Transactional\n\t\tpublic void something(final String arg) {\n\t\t}\n\t}\n\n\t@Transactional\n\tpublic interface InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubInheritedAnnotationInterface extends InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubInheritedAnnotationInterface extends SubInheritedAnnotationInterface {\n\t}\n\n\t@Order\n\tpublic interface NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubNonInheritedAnnotationInterface extends NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubNonInheritedAnnotationInterface extends SubNonInheritedAnnotationInterface {\n\t}\n\n\tpublic static class NonAnnotatedClass {\n\t}\n\n\tpublic interface NonAnnotatedInterface {\n\t}\n\n\t@Transactional\n\tpublic static class InheritedAnnotationClass {\n\t}\n\n\tpublic static class SubInheritedAnnotationClass extends InheritedAnnotationClass {\n\t}\n\n\t@Order\n\tpublic static class NonInheritedAnnotationClass {\n\t}\n\n\tpublic static class SubNonInheritedAnnotationClass extends NonInheritedAnnotationClass {\n\t}\n\n\t@Transactional\n\tpublic static class TransactionalClass {\n\t}\n\n\t@Order\n\tpublic static class TransactionalAndOrderedClass extends TransactionalClass {\n\t}\n\n\tpublic static class SubTransactionalAndOrderedClass extends TransactionalAndOrderedClass {\n\t}\n\n\tpublic interface InterfaceWithAnnotatedMethod {\n\n\t\t@Order\n\t\tvoid foo();\n\t}\n\n\tpublic static class ImplementsInterfaceWithAnnotatedMethod implements InterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic static class SubOfImplementsInterfaceWithAnnotatedMethod extends ImplementsInterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic abstract static class AbstractDoesNotImplementInterfaceWithAnnotatedMethod\n\t\t\timplements InterfaceWithAnnotatedMethod {\n\t}\n\n\tpublic static class SubOfAbstractImplementsInterfaceWithAnnotatedMethod\n\t\t\textends AbstractDoesNotImplementInterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic interface InterfaceWithGenericAnnotatedMethod<T> {\n\n\t\t@Order\n\t\tvoid foo(T t);\n\t}\n\n\tpublic static class ImplementsInterfaceWithGenericAnnotatedMethod implements InterfaceWithGenericAnnotatedMethod<String> {\n\n\t\t@Override\n\t\tpublic void foo(String t) {\n\t\t}\n\t}\n\n\tpublic abstract static class BaseClassWithGenericAnnotatedMethod<T> {\n\n\t\t@Order\n\t\tabstract void foo(T t);\n\t}\n\n\tpublic static class ExtendsBaseClassWithGenericAnnotatedMethod extends BaseClassWithGenericAnnotatedMethod<String> {\n\n\t\t@Override\n\t\tpublic void foo(String t) {\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface MyRepeatableContainer {\n\n\t\tMyRepeatable[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@Repeatable(MyRepeatableContainer.class)\n\t@interface MyRepeatable {\n\n\t\tString value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta1\")\n\t@interface MyRepeatableMeta1 {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta2\")\n\t@interface MyRepeatableMeta2 {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta1\")\n\t@MyRepeatable(\"meta2\")\n\t@interface MyRepeatableMeta1And2 {\n\t}\n\n\t@MyRepeatableMeta1And2\n\tvoid methodWithComposedAnnotationMetaAnnotatedWithRepeatableAnnotations() {\n\t}\n\n\tinterface InterfaceWithRepeated {\n\n\t\t@MyRepeatable(\"A\")\n\t\t@MyRepeatableContainer({@MyRepeatable(\"B\"), @MyRepeatable(\"C\")})\n\t\t@MyRepeatableMeta1\n\t\tvoid foo();\n\t}\n\n\t@MyRepeatable(\"A\")\n\t@MyRepeatableContainer({@MyRepeatable(\"B\"), @MyRepeatable(\"C\")})\n\t@MyRepeatableMeta1\n\tstatic class MyRepeatableClass {\n\t}\n\n\tstatic class SubMyRepeatableClass extends MyRepeatableClass {\n\t}\n\n\t@MyRepeatable(\"X\")\n\t@MyRepeatableContainer({@MyRepeatable(\"Y\"), @MyRepeatable(\"Z\")})\n\t@MyRepeatableMeta2\n\tstatic class SubMyRepeatableWithAdditionalLocalDeclarationsClass extends MyRepeatableClass {\n\t}\n\n\tstatic class SubSubMyRepeatableWithAdditionalLocalDeclarationsClass extends\n\t\t\tSubMyRepeatableWithAdditionalLocalDeclarationsClass {\n\t}\n\n\tenum RequestMethod {\n\t\tGET, POST\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.web.bind.annotation.RequestMapping}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface WebMapping {\n\n\t\tString name();\n\n\t\t@AliasFor(\"path\")\n\t\tString[] value() default \"\";\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tString[] path() default \"\";\n\n\t\tRequestMethod[] method() default {};\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.web.bind.annotation.GetMapping}, except\n\t * that the String arrays are overridden with single String elements.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@WebMapping(method = RequestMethod.GET, name = \"\")\n\t@interface Get {\n\n\t\t@AliasFor(annotation = WebMapping.class)\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = WebMapping.class)\n\t\tString path() default \"\";\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.web.bind.annotation.PostMapping}, except\n\t * that the path is overridden by convention with single String element.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@WebMapping(method = RequestMethod.POST, name = \"\")\n\t@interface Post {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = WebMapping.class)\n\t\tString path() default \"\";\n\t}\n\n\t@Component(\"webController\")\n\tstatic class WebController {\n\n\t\t@WebMapping(value = \"/test\", name = \"foo\")\n\t\tpublic void handleMappedWithValueAttribute() {\n\t\t}\n\n\t\t@WebMapping(path = \"/test\", name = \"bar\", method = { RequestMethod.GET, RequestMethod.POST })\n\t\tpublic void handleMappedWithPathAttribute() {\n\t\t}\n\n\t\t@Get(\"/test\")\n\t\tpublic void getMappedWithValueAttribute() {\n\t\t}\n\n\t\t@Get(path = \"/test\")\n\t\tpublic void getMappedWithPathAttribute() {\n\t\t}\n\n\t\t@Post(path = \"/test\")\n\t\tpublic void postMappedWithPathAttribute() {\n\t\t}\n\n\t\t/**\n\t\t * mapping is logically \"equal\" to handleMappedWithPathAttribute().\n\t\t */\n\t\t@WebMapping(value = \"/test\", path = \"/test\", name = \"bar\", method = { RequestMethod.GET, RequestMethod.POST })\n\t\tpublic void handleMappedWithSamePathAndValueAttributes() {\n\t\t}\n\n\t\t@WebMapping(value = \"/enigma\", path = \"/test\", name = \"baz\")\n\t\tpublic void handleMappedWithDifferentPathAndValueAttributes() {\n\t\t}\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.test.context.ContextConfiguration}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContextConfig {\n\n\t\t@AliasFor(\"location\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString location() default \"\";\n\n\t\tClass<?> klass() default Object.class;\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.test.context.ContextHierarchy}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Hierarchy {\n\t\tContextConfig[] value();\n\t}\n\n\t@Hierarchy({@ContextConfig(\"A\"), @ContextConfig(location = \"B\")})\n\tstatic class ConfigHierarchyTestCase {\n\t}\n\n\t@ContextConfig(\"simple.xml\")\n\tstatic class SimpleConfigTestCase {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface CharsContainer {\n\n\t\t@AliasFor(attribute = \"chars\")\n\t\tchar[] value() default {};\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tchar[] chars() default {};\n\t}\n\n\t@CharsContainer(chars = { 'x', 'y', 'z' })\n\tstatic class GroupOfCharsClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMissingAttributeDeclaration {\n\n\t\t@AliasFor\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForWithMissingAttributeDeclaration\n\tstatic class AliasForWithMissingAttributeDeclarationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithDuplicateAttributeDeclaration {\n\n\t\t@AliasFor(value = \"bar\", attribute = \"baz\")\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForWithDuplicateAttributeDeclaration\n\tstatic class AliasForWithDuplicateAttributeDeclarationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForNonexistentAttribute {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForNonexistentAttribute\n\tstatic class AliasForNonexistentAttributeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithoutMirroredAliasFor {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"\";\n\n\t\tString bar() default \"\";\n\t}\n\n\t@AliasForWithoutMirroredAliasFor\n\tstatic class AliasForWithoutMirroredAliasForClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMirroredAliasForWrongAttribute {\n\n\t\t@AliasFor(attribute = \"bar\")\n\t\tString[] foo() default \"\";\n\n\t\t@AliasFor(attribute = \"quux\")\n\t\tString[] bar() default \"\";\n\t}\n\n\t@AliasForWithMirroredAliasForWrongAttribute\n\tstatic class AliasForWithMirroredAliasForWrongAttributeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForAttributeOfDifferentType {\n\n\t\t@AliasFor(\"bar\")\n\t\tString[] foo() default \"\";\n\n\t\t@AliasFor(\"foo\")\n\t\tboolean bar() default true;\n\t}\n\n\t@AliasForAttributeOfDifferentType\n\tstatic class AliasForAttributeOfDifferentTypeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMissingDefaultValues {\n\n\t\t@AliasFor(attribute = \"bar\")\n\t\tString foo();\n\n\t\t@AliasFor(attribute = \"foo\")\n\t\tString bar();\n\t}\n\n\t@AliasForWithMissingDefaultValues(foo = \"foo\", bar = \"bar\")\n\tstatic class AliasForWithMissingDefaultValuesClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForAttributeWithDifferentDefaultValue {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"X\";\n\n\t\t@AliasFor(\"foo\")\n\t\tString bar() default \"Z\";\n\t}\n\n\t@AliasForAttributeWithDifferentDefaultValue\n\tstatic class AliasForAttributeWithDifferentDefaultValueClass {\n\t}\n\n\t// @ContextConfig --> Intentionally NOT meta-present\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfigNotMetaPresent {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlConfigFile();\n\t}\n\n\t@AliasedComposedContextConfigNotMetaPresent(xmlConfigFile = \"test.xml\")\n\tstatic class AliasedComposedContextConfigNotMetaPresentClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlConfigFile();\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface ImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString groovyScript() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location1() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location2() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location3() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"klass\")\n\t\tClass<?> configClass() default Object.class;\n\n\t\tString nonAliasedAttribute() default \"\";\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(groovyScript = \"groovyScript\")\n\tstatic class GroovyImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(xmlFile = \"xmlFile\")\n\tstatic class XmlImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(\"value\")\n\tstatic class ValueImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(location1 = \"location1\")\n\tstatic class Location1ImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(location2 = \"location2\")\n\tstatic class Location2ImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(location3 = \"location3\")\n\tstatic class Location3ImplicitAliasesContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig {\n\n\t\t// intentionally omitted: attribute = \"value\"\n\t\t@AliasFor(annotation = ContextConfig.class)\n\t\tString value() default \"\";\n\n\t\t// intentionally omitted: attribute = \"locations\"\n\t\t@AliasFor(annotation = ContextConfig.class)\n\t\tString location() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesWithImpliedAliasNamesOmittedContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig.class, attribute = \"location\")\n\t\tString groovy() default \"\";\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig(\"value\")\n\tstatic class ValueImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig(location = \"location\")\n\tstatic class LocationsImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig(xmlFile = \"xmlFile\")\n\tstatic class XmlFilesImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithMissingDefaultValuesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location1();\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location2();\n\t}\n\n\t@ImplicitAliasesWithMissingDefaultValuesContextConfig(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithMissingDefaultValuesContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithDifferentDefaultValuesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location1() default \"foo\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location2() default \"bar\";\n\t}\n\n\t@ImplicitAliasesWithDifferentDefaultValuesContextConfig(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithDifferentDefaultValuesContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithDuplicateValuesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location1() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location2() default \"\";\n\t}\n\n\t@ImplicitAliasesWithDuplicateValuesContextConfig(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithDuplicateValuesContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesForAliasPairContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, value = \"value\")\n\t\tString groovyScript() default \"\";\n\t}\n\n\t@ImplicitAliasesForAliasPairContextConfig(xmlFile = \"test.xml\")\n\tstatic class ImplicitAliasesForAliasPairContextConfigClass {\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScript\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@TransitiveImplicitAliasesContextConfig(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesContextConfigClass {\n\t}\n\n\t@ImplicitAliasesForAliasPairContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesForAliasPairContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesForAliasPairContextConfig.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesForAliasPairContextConfig.class, attribute = \"groovyScript\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@TransitiveImplicitAliasesForAliasPairContextConfig(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesForAliasPairContextConfigClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({})\n\t@interface Filter {\n\t\tString pattern();\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.context.annotation.ComponentScan}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScan {\n\t\tFilter[] excludeFilters() default {};\n\t}\n\n\t@ComponentScan(excludeFilters = {@Filter(pattern = \"*Foo\"), @Filter(pattern = \"*Bar\")})\n\tstatic class ComponentScanClass {\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.context.annotation.ComponentScan}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScanSingleFilter {\n\t\tFilter value();\n\t}\n\n\t@ComponentScanSingleFilter(@Filter(pattern = \"*Foo\"))\n\tstatic class ComponentScanSingleFilterClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnotationWithDefaults {\n\t\tString text() default \"enigma\";\n\t\tboolean predicate() default true;\n\t\tchar[] characters() default {'a', 'b', 'c'};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnotationWithoutDefaults {\n\t\tString text();\n\t}\n\n\t@ContextConfig(value = \"foo\", location = \"bar\")\n\tinterface ContextConfigMismatch {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(TestRepeatableContainer.class)\n\t@interface TestRepeatable {\n\n\t\tString value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestRepeatableContainer {\n\n\t\tTestRepeatable[] value();\n\t}\n\n\t@TestRepeatable(\"a\")\n\t@TestRepeatable(\"b\")\n\tstatic class TestRepeatablesClass {\n\t}\n\n\t@Deprecated\n\tstatic class DeprecatedClass {\n\t}\n\n\tstatic class SubclassOfDeprecatedClass extends DeprecatedClass {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.AliasForWithMirroredAliasForWrongAttributeClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.AliasForWithMirroredAliasForWrongAttributeClass",
    "headType": "class",
    "relation": "use",
    "tail": "@AliasForWithMirroredAliasForWrongAttribute",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AliasForWithMirroredAliasForWrongAttributeClass",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Method;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.ParametersAreNonnullByDefault;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.subpackage.NonPublicAnnotatedClass;\nimport org.springframework.core.testfixture.ide.IdeUtils;\nimport org.springframework.core.testfixture.stereotype.Component;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Collectors.toList;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalStateException;\nimport static org.springframework.core.annotation.AnnotationUtils.VALUE;\nimport static org.springframework.core.annotation.AnnotationUtils.findAnnotation;\nimport static org.springframework.core.annotation.AnnotationUtils.findAnnotationDeclaringClass;\nimport static org.springframework.core.annotation.AnnotationUtils.findAnnotationDeclaringClassForTypes;\nimport static org.springframework.core.annotation.AnnotationUtils.getAnnotation;\nimport static org.springframework.core.annotation.AnnotationUtils.getAnnotationAttributes;\nimport static org.springframework.core.annotation.AnnotationUtils.getDeclaredRepeatableAnnotations;\nimport static org.springframework.core.annotation.AnnotationUtils.getDefaultValue;\nimport static org.springframework.core.annotation.AnnotationUtils.getRepeatableAnnotations;\nimport static org.springframework.core.annotation.AnnotationUtils.getValue;\nimport static org.springframework.core.annotation.AnnotationUtils.isAnnotationDeclaredLocally;\nimport static org.springframework.core.annotation.AnnotationUtils.isAnnotationInherited;\nimport static org.springframework.core.annotation.AnnotationUtils.isAnnotationMetaPresent;\nimport static org.springframework.core.annotation.AnnotationUtils.synthesizeAnnotation;\n\n/**\n * Tests for {@link AnnotationUtils}.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Chris Beams\n * @author Phillip Webb\n * @author Oleg Zhurakousky\n */\n@SuppressWarnings(\"deprecation\")\nclass AnnotationUtilsTests {\n\n\t@BeforeEach\n\tvoid clearCacheBeforeTests() {\n\t\tAnnotationUtils.clearCache();\n\t}\n\n\n\t@Test\n\tvoid findMethodAnnotationOnLeaf() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"annotatedOnLeaf\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNotNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNotNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findMethodAnnotationWithAnnotationOnMethodInInterface() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"fromInterfaceImplementedByRoot\");\n\t\t// @Order is not @Inherited\n\t\tassertThat(m.getAnnotation(Order.class)).isNull();\n\t\t// getAnnotation() does not search on interfaces\n\t\tassertThat(getAnnotation(m, Order.class)).isNull();\n\t\t// findAnnotation() does search on interfaces\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findMethodAnnotationWithMetaAnnotationOnLeaf() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"metaAnnotatedOnLeaf\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNotNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findMethodAnnotationWithMetaMetaAnnotationOnLeaf() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"metaMetaAnnotatedOnLeaf\");\n\t\tassertThat(m.getAnnotation(Component.class)).isNull();\n\t\tassertThat(getAnnotation(m, Component.class)).isNull();\n\t\tassertThat(findAnnotation(m, Component.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationOnRoot() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"annotatedOnRoot\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNotNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNotNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findMethodAnnotationWithMetaAnnotationOnRoot() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"metaAnnotatedOnRoot\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNotNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationOnRootButOverridden() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"overrideWithoutNewAnnotation\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationNotAnnotated() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"notAnnotated\");\n\t\tassertThat(findAnnotation(m, Order.class)).isNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationOnBridgeMethod() throws Exception {\n\t\tMethod bridgeMethod = SimpleFoo.class.getMethod(\"something\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(bridgeMethod.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(bridgeMethod, Order.class)).isNull();\n\t\tassertThat(findAnnotation(bridgeMethod, Order.class)).isNotNull();\n\n\t\t// As of JDK 8, invoking getAnnotation() on a bridge method actually finds an\n\t\t// annotation on its 'bridged' method [1]; however, the Eclipse compiler does\n\t\t// not support this [2]. Thus, we effectively ignore the following\n\t\t// assertion if the test is currently executing within the Eclipse IDE.\n\t\t//\n\t\t// [1] https://bugs.openjdk.java.net/browse/JDK-6695379\n\t\t// [2] https://bugs.eclipse.org/bugs/show_bug.cgi?id=495396\n\t\t//\n\t\tif (!IdeUtils.runningInEclipse()) {\n\t\t\tassertThat(bridgeMethod.getAnnotation(Transactional.class)).isNotNull();\n\t\t}\n\t\tassertThat(getAnnotation(bridgeMethod, Transactional.class)).isNotNull();\n\t\tassertThat(findAnnotation(bridgeMethod, Transactional.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationOnBridgedMethod() throws Exception {\n\t\tMethod bridgedMethod = SimpleFoo.class.getMethod(\"something\", String.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tassertThat(bridgedMethod.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(bridgedMethod, Order.class)).isNull();\n\t\tassertThat(findAnnotation(bridgedMethod, Order.class)).isNotNull();\n\n\t\tassertThat(bridgedMethod.getAnnotation(Transactional.class)).isNotNull();\n\t\tassertThat(getAnnotation(bridgedMethod, Transactional.class)).isNotNull();\n\t\tassertThat(findAnnotation(bridgedMethod, Transactional.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationFromInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test  // SPR-16060\n\tvoid findMethodAnnotationFromGenericInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test  // SPR-17146\n\tvoid findMethodAnnotationFromGenericSuperclass() throws Exception {\n\t\tMethod method = ExtendsBaseClassWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationFromInterfaceOnSuper() throws Exception {\n\t\tMethod method = SubOfImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationFromInterfaceWhenSuperDoesNotImplementMethod() throws Exception {\n\t\tMethod method = SubOfAbstractImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t// @since 4.1.2\n\t@Test\n\tvoid findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverAnnotationsOnInterfaces() {\n\t\tComponent component = findAnnotation(ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface.class, Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tassertThat(component.value()).isEqualTo(\"meta2\");\n\t}\n\n\t// @since 4.0.3\n\t@Test\n\tvoid findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedAnnotations() {\n\t\tTransactional transactional = findAnnotation(SubSubClassWithInheritedAnnotation.class, Transactional.class);\n\t\tassertThat(transactional).isNotNull();\n\t\tassertThat(transactional.readOnly()).as(\"readOnly flag for SubSubClassWithInheritedAnnotation\").isTrue();\n\t}\n\n\t// @since 4.0.3\n\t@Test\n\tvoid findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedComposedAnnotations() {\n\t\tComponent component = findAnnotation(SubSubClassWithInheritedMetaAnnotation.class, Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tassertThat(component.value()).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid findClassAnnotationOnMetaMetaAnnotatedClass() {\n\t\tComponent component = findAnnotation(MetaMetaAnnotatedClass.class, Component.class);\n\t\tassertThat(component).as(\"Should find meta-annotation on composed annotation on class\").isNotNull();\n\t\tassertThat(component.value()).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid findClassAnnotationOnMetaMetaMetaAnnotatedClass() {\n\t\tComponent component = findAnnotation(MetaMetaMetaAnnotatedClass.class, Component.class);\n\t\tassertThat(component).as(\"Should find meta-annotation on meta-annotation on composed annotation on class\").isNotNull();\n\t\tassertThat(component.value()).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid findClassAnnotationOnAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\t// TransactionalClass is NOT annotated or meta-annotated with @Component\n\t\tComponent component = findAnnotation(TransactionalClass.class, Component.class);\n\t\tassertThat(component).as(\"Should not find @Component on TransactionalClass\").isNull();\n\t}\n\n\t@Test\n\tvoid findClassAnnotationOnMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\tComponent component = findAnnotation(MetaCycleAnnotatedClass.class, Component.class);\n\t\tassertThat(component).as(\"Should not find @Component on MetaCycleAnnotatedClass\").isNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnInheritedAnnotationInterface() {\n\t\tTransactional tx = findAnnotation(InheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(tx).as(\"Should find @Transactional on InheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnSubInheritedAnnotationInterface() {\n\t\tTransactional tx = findAnnotation(SubInheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(tx).as(\"Should find @Transactional on SubInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnSubSubInheritedAnnotationInterface() {\n\t\tTransactional tx = findAnnotation(SubSubInheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(tx).as(\"Should find @Transactional on SubSubInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnNonInheritedAnnotationInterface() {\n\t\tOrder order = findAnnotation(NonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(order).as(\"Should find @Order on NonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnSubNonInheritedAnnotationInterface() {\n\t\tOrder order = findAnnotation(SubNonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(order).as(\"Should find @Order on SubNonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnSubSubNonInheritedAnnotationInterface() {\n\t\tOrder order = findAnnotation(SubSubNonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(order).as(\"Should find @Order on SubSubNonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findAnnotationDeclaringClassForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, NonAnnotatedInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, NonAnnotatedClass.class)).isNull();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, InheritedAnnotationInterface.class)).isEqualTo(InheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, SubInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, InheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, SubInheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but findAnnotationDeclaringClass() should still find it on classes.\n\t\tassertThat(findAnnotationDeclaringClass(Order.class, NonInheritedAnnotationInterface.class)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClass(Order.class, SubNonInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClass(Order.class, NonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClass(Order.class, SubNonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t}\n\n\t@Test\n\tvoid findAnnotationDeclaringClassForTypesWithSingleCandidateType() {\n\t\t// no class-level annotation\n\t\tList<Class<? extends Annotation>> transactionalCandidateList = Collections.singletonList(Transactional.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, NonAnnotatedInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, NonAnnotatedClass.class)).isNull();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, InheritedAnnotationInterface.class)).isEqualTo(InheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, SubInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, InheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, SubInheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but findAnnotationDeclaringClassForTypes() should still find it on classes.\n\t\tList<Class<? extends Annotation>> orderCandidateList = Collections.singletonList(Order.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, NonInheritedAnnotationInterface.class)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, SubNonInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, NonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, SubNonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t}\n\n\t@Test\n\tvoid findAnnotationDeclaringClassForTypesWithMultipleCandidateTypes() {\n\t\tList<Class<? extends Annotation>> candidates = asList(Transactional.class, Order.class);\n\n\t\t// no class-level annotation\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, NonAnnotatedInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, NonAnnotatedClass.class)).isNull();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, InheritedAnnotationInterface.class)).isEqualTo(InheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, InheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubInheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but findAnnotationDeclaringClassForTypes() should still find it on classes.\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, NonInheritedAnnotationInterface.class)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubNonInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, NonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubNonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\n\t\t// class hierarchy mixed with @Transactional and @Order declarations\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, TransactionalClass.class)).isEqualTo(TransactionalClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, TransactionalAndOrderedClass.class)).isEqualTo(TransactionalAndOrderedClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubTransactionalAndOrderedClass.class)).isEqualTo(TransactionalAndOrderedClass.class);\n\t}\n\n\t@Test\n\tvoid isAnnotationDeclaredLocallyForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, NonAnnotatedInterface.class)).isFalse();\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, NonAnnotatedClass.class)).isFalse();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, InheritedAnnotationInterface.class)).isTrue();\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, SubInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, InheritedAnnotationClass.class)).isTrue();\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, SubInheritedAnnotationClass.class)).isFalse();\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited\n\t\tassertThat(isAnnotationDeclaredLocally(Order.class, NonInheritedAnnotationInterface.class)).isTrue();\n\t\tassertThat(isAnnotationDeclaredLocally(Order.class, SubNonInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationDeclaredLocally(Order.class, NonInheritedAnnotationClass.class)).isTrue();\n\t\tassertThat(isAnnotationDeclaredLocally(Order.class, SubNonInheritedAnnotationClass.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotationInheritedForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(isAnnotationInherited(Transactional.class, NonAnnotatedInterface.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Transactional.class, NonAnnotatedClass.class)).isFalse();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(isAnnotationInherited(Transactional.class, InheritedAnnotationInterface.class)).isFalse();\n\t\t// isAnnotationInherited() does not currently traverse interface hierarchies.\n\t\t// Thus the following, though perhaps counterintuitive, must be false:\n\t\tassertThat(isAnnotationInherited(Transactional.class, SubInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Transactional.class, InheritedAnnotationClass.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Transactional.class, SubInheritedAnnotationClass.class)).isTrue();\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited\n\t\tassertThat(isAnnotationInherited(Order.class, NonInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Order.class, SubNonInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Order.class, NonInheritedAnnotationClass.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Order.class, SubNonInheritedAnnotationClass.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotationMetaPresentForPlainType() {\n\t\tassertThat(isAnnotationMetaPresent(Order.class, Documented.class)).isTrue();\n\t\tassertThat(isAnnotationMetaPresent(ParametersAreNonnullByDefault.class, Documented.class)).isTrue();\n\t\tassertThat(isAnnotationMetaPresent(ParametersAreNonnullByDefault.class, Nonnull.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributesWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\n\t\tAnnotationAttributes attributes = (AnnotationAttributes) getAnnotationAttributes(component);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.getString(VALUE)).as(\"value attribute: \").isEqualTo(\"webController\");\n\t\tassertThat(attributes.annotationType()).isEqualTo(Component.class);\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributesWithNestedAnnotations() {\n\t\tComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class);\n\t\tassertThat(componentScan).isNotNull();\n\n\t\tAnnotationAttributes attributes = getAnnotationAttributes(ComponentScanClass.class, componentScan);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(ComponentScan.class);\n\n\t\tFilter[] filters = attributes.getAnnotationArray(\"excludeFilters\", Filter.class);\n\t\tassertThat(filters).isNotNull();\n\n\t\tList<String> patterns = stream(filters).map(Filter::pattern).collect(toList());\n\t\tassertThat(patterns).isEqualTo(asList(\"*Foo\", \"*Bar\"));\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributesWithAttributeAliases() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\t\tWebMapping webMapping = method.getAnnotation(WebMapping.class);\n\t\tAnnotationAttributes attributes = (AnnotationAttributes) getAnnotationAttributes(webMapping);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(WebMapping.class);\n\t\tassertThat(attributes.getString(\"name\")).as(\"name attribute: \").isEqualTo(\"foo\");\n\t\tassertThat(attributes.getStringArray(VALUE)).as(\"value attribute: \").isEqualTo(asArray(\"/test\"));\n\t\tassertThat(attributes.getStringArray(\"path\")).as(\"path attribute: \").isEqualTo(asArray(\"/test\"));\n\n\t\tmethod = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\twebMapping = method.getAnnotation(WebMapping.class);\n\t\tattributes = (AnnotationAttributes) getAnnotationAttributes(webMapping);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(WebMapping.class);\n\t\tassertThat(attributes.getString(\"name\")).as(\"name attribute: \").isEqualTo(\"bar\");\n\t\tassertThat(attributes.getStringArray(VALUE)).as(\"value attribute: \").isEqualTo(asArray(\"/test\"));\n\t\tassertThat(attributes.getStringArray(\"path\")).as(\"path attribute: \").isEqualTo(asArray(\"/test\"));\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributesWithAttributeAliasesWithDifferentValues() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithDifferentPathAndValueAttributes\");\n\t\tWebMapping webMapping = method.getAnnotation(WebMapping.class);\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tgetAnnotationAttributes(webMapping))\n\t\t\t.withMessageContaining(\"attribute 'path' and its alias 'value'\")\n\t\t\t.withMessageContaining(\"values of [{/test}] and [{/enigma}]\");\n\t}\n\n\t@Test\n\tvoid getValueFromAnnotation() throws Exception {\n\t\tMethod method = SimpleFoo.class.getMethod(\"something\", Object.class);\n\t\tOrder order = findAnnotation(method, Order.class);\n\n\t\tassertThat(getValue(order, VALUE)).isEqualTo(1);\n\t\tassertThat(getValue(order)).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getValueFromNonPublicAnnotation() {\n\t\tAnnotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\n\t\tassertThat(declaredAnnotations).hasSize(1);\n\t\tAnnotation annotation = declaredAnnotations[0];\n\t\tassertThat(annotation).isNotNull();\n\t\tassertThat(annotation.annotationType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\n\t\tassertThat(getValue(annotation, VALUE)).isEqualTo(42);\n\t\tassertThat(getValue(annotation)).isEqualTo(42);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromAnnotation() throws Exception {\n\t\tMethod method = SimpleFoo.class.getMethod(\"something\", Object.class);\n\t\tOrder order = findAnnotation(method, Order.class);\n\n\t\tassertThat(getDefaultValue(order, VALUE)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\n\t\tassertThat(getDefaultValue(order)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromNonPublicAnnotation() {\n\t\tAnnotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\n\t\tassertThat(declaredAnnotations).hasSize(1);\n\t\tAnnotation annotation = declaredAnnotations[0];\n\t\tassertThat(annotation).isNotNull();\n\t\tassertThat(annotation.annotationType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\n\t\tassertThat(getDefaultValue(annotation, VALUE)).isEqualTo(-1);\n\t\tassertThat(getDefaultValue(annotation)).isEqualTo(-1);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromAnnotationType() {\n\t\tassertThat(getDefaultValue(Order.class, VALUE)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\n\t\tassertThat(getDefaultValue(Order.class)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Test\n\tvoid findRepeatableAnnotation() {\n\t\tRepeatable repeatable = findAnnotation(MyRepeatable.class, Repeatable.class);\n\t\tassertThat(repeatable).isNotNull();\n\t\tassertThat(repeatable.value()).isEqualTo(MyRepeatableContainer.class);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnMethod() throws Exception {\n\t\tMethod method = InterfaceWithRepeated.class.getMethod(\"foo\");\n\t\tSet<MyRepeatable> annotations = getRepeatableAnnotations(method, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(annotations).isNotNull();\n\t\tList<String> values = annotations.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(asList(\"A\", \"B\", \"C\", \"meta1\"));\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnClassWithAttributeAliases() {\n\t\tfinal List<String> expectedLocations = asList(\"A\", \"B\");\n\n\t\tSet<ContextConfig> annotations = getRepeatableAnnotations(ConfigHierarchyTestCase.class, ContextConfig.class, null);\n\t\tassertThat(annotations).isNotNull();\n\t\tassertThat(annotations).as(\"size if container type is omitted: \").isEmpty();\n\n\t\tannotations = getRepeatableAnnotations(ConfigHierarchyTestCase.class, ContextConfig.class, Hierarchy.class);\n\t\tassertThat(annotations).isNotNull();\n\n\t\tList<String> locations = annotations.stream().map(ContextConfig::location).collect(toList());\n\t\tassertThat(locations).isEqualTo(expectedLocations);\n\n\t\tList<String> values = annotations.stream().map(ContextConfig::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedLocations);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnClass() {\n\t\tfinal List<String> expectedValuesJava = asList(\"A\", \"B\", \"C\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"A\", \"B\", \"C\", \"meta1\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = MyRepeatableClass.class.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnSuperclass() {\n\t\tfinal Class<?> clazz = SubMyRepeatableClass.class;\n\t\tfinal List<String> expectedValuesJava = asList(\"A\", \"B\", \"C\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"A\", \"B\", \"C\", \"meta1\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getRepeatableAnnotations(clazz, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnClassAndSuperclass() {\n\t\tfinal Class<?> clazz = SubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\n\t\tfinal List<String> expectedValuesJava = asList(\"X\", \"Y\", \"Z\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"X\", \"Y\", \"Z\", \"meta2\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getRepeatableAnnotations(clazz, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnMultipleSuperclasses() {\n\t\tfinal Class<?> clazz = SubSubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\n\t\tfinal List<String> expectedValuesJava = asList(\"X\", \"Y\", \"Z\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"X\", \"Y\", \"Z\", \"meta2\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getRepeatableAnnotations(clazz, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getDeclaredRepeatableAnnotationsDeclaredOnClass() {\n\t\tfinal List<String> expectedValuesJava = asList(\"A\", \"B\", \"C\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"A\", \"B\", \"C\", \"meta1\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = MyRepeatableClass.class.getDeclaredAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getDeclaredRepeatableAnnotations(\n\t\t\t\tMyRepeatableClass.class, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getDeclaredRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getDeclaredRepeatableAnnotationsDeclaredOnSuperclass() {\n\t\tfinal Class<?> clazz = SubMyRepeatableClass.class;\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = clazz.getDeclaredAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tassertThat(array).isEmpty();\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getDeclaredRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tassertThat(set).isEmpty();\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getDeclaredRepeatableAnnotations(clazz, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tassertThat(set).isEmpty();\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationWithImplicitAliasesWithMissingDefaultValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithMissingDefaultValuesContextConfigClass.class;\n\t\tClass<ImplicitAliasesWithMissingDefaultValuesContextConfig> annotationType =\n\t\t\t\tImplicitAliasesWithMissingDefaultValuesContextConfig.class;\n\t\tImplicitAliasesWithMissingDefaultValuesContextConfig config = clazz.getAnnotation(annotationType);\n\t\tassertThat(config).isNotNull();\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(config, clazz))\n\t\t\t.withMessageStartingWith(\"Misconfigured aliases:\")\n\t\t\t.withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t.withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t.withMessageContaining(\"default values\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationWithImplicitAliasesWithDifferentDefaultValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithDifferentDefaultValuesContextConfigClass.class;\n\t\tClass<ImplicitAliasesWithDifferentDefaultValuesContextConfig> annotationType =\n\t\t\t\tImplicitAliasesWithDifferentDefaultValuesContextConfig.class;\n\t\tImplicitAliasesWithDifferentDefaultValuesContextConfig config = clazz.getAnnotation(annotationType);\n\t\tassertThat(config).isNotNull();\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(config, clazz))\n\t\t\t.withMessageStartingWith(\"Misconfigured aliases:\")\n\t\t\t.withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t.withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t.withMessageContaining(\"same default value\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationWithImplicitAliasesWithDuplicateValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithDuplicateValuesContextConfigClass.class;\n\t\tClass<ImplicitAliasesWithDuplicateValuesContextConfig> annotationType =\n\t\t\t\tImplicitAliasesWithDuplicateValuesContextConfig.class;\n\t\tImplicitAliasesWithDuplicateValuesContextConfig config = clazz.getAnnotation(annotationType);\n\t\tassertThat(config).isNotNull();\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(config, clazz).location1())\n\t\t\t.withMessageStartingWith(\"Different @AliasFor mirror values\")\n\t\t\t.withMessageContaining(annotationType.getName())\n\t\t\t.withMessageContaining(\"declared on class\")\n\t\t\t.withMessageContaining(clazz.getName())\n\t\t\t.withMessageContaining(\"attribute 'location1' and its alias 'location2'\")\n\t\t\t.withMessageContaining(\"with values of [1] and [2]\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\n\t\tMap<String, Object> map = Collections.singletonMap(VALUE, \"webController\");\n\t\tComponent synthesizedComponent = synthesizeAnnotation(map, Component.class, WebController.class);\n\t\tassertThat(synthesizedComponent).isNotNull();\n\n\t\tassertThat(synthesizedComponent).isNotSameAs(component);\n\t\tassertThat(component.value()).as(\"value from component: \").isEqualTo(\"webController\");\n\t\tassertThat(synthesizedComponent.value()).as(\"value from synthesized component: \").isEqualTo(\"webController\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeAnnotationFromMapWithNestedMap() {\n\t\tComponentScanSingleFilter componentScan =\n\t\t\t\tComponentScanSingleFilterClass.class.getAnnotation(ComponentScanSingleFilter.class);\n\t\tassertThat(componentScan).isNotNull();\n\t\tassertThat(componentScan.value().pattern()).as(\"value from ComponentScan: \").isEqualTo(\"*Foo\");\n\n\t\tAnnotationAttributes attributes = getAnnotationAttributes(\n\t\t\t\tComponentScanSingleFilterClass.class, componentScan, false, true);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(ComponentScanSingleFilter.class);\n\n\t\tMap<String, Object> filterMap = (Map<String, Object>) attributes.get(\"value\");\n\t\tassertThat(filterMap).isNotNull();\n\t\tassertThat(filterMap.get(\"pattern\")).isEqualTo(\"*Foo\");\n\n\t\t// Modify nested map\n\t\tfilterMap.put(\"pattern\", \"newFoo\");\n\t\tfilterMap.put(\"enigma\", 42);\n\n\t\tComponentScanSingleFilter synthesizedComponentScan = synthesizeAnnotation(\n\t\t\t\tattributes, ComponentScanSingleFilter.class, ComponentScanSingleFilterClass.class);\n\t\tassertThat(synthesizedComponentScan).isNotNull();\n\n\t\tassertThat(synthesizedComponentScan).isNotSameAs(componentScan);\n\t\tassertThat(synthesizedComponentScan.value().pattern()).as(\"value from synthesized ComponentScan: \").isEqualTo(\"newFoo\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeAnnotationFromMapWithNestedArrayOfMaps() {\n\t\tComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class);\n\t\tassertThat(componentScan).isNotNull();\n\n\t\tAnnotationAttributes attributes = getAnnotationAttributes(ComponentScanClass.class, componentScan, false, true);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(ComponentScan.class);\n\n\t\tMap<String, Object>[] filters = (Map[]) attributes.get(\"excludeFilters\");\n\t\tassertThat(filters).isNotNull();\n\n\t\tList<String> patterns = stream(filters).map(m -> (String) m.get(\"pattern\")).collect(toList());\n\t\tassertThat(patterns).isEqualTo(asList(\"*Foo\", \"*Bar\"));\n\n\t\t// Modify nested maps\n\t\tfilters[0].put(\"pattern\", \"newFoo\");\n\t\tfilters[0].put(\"enigma\", 42);\n\t\tfilters[1].put(\"pattern\", \"newBar\");\n\t\tfilters[1].put(\"enigma\", 42);\n\n\t\tComponentScan synthesizedComponentScan =\n\t\t\t\tsynthesizeAnnotation(attributes, ComponentScan.class, ComponentScanClass.class);\n\t\tassertThat(synthesizedComponentScan).isNotNull();\n\n\t\tassertThat(synthesizedComponentScan).isNotSameAs(componentScan);\n\t\tpatterns = stream(synthesizedComponentScan.excludeFilters()).map(Filter::pattern).collect(toList());\n\t\tassertThat(patterns).isEqualTo(asList(\"newFoo\", \"newBar\"));\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromDefaultsWithoutAttributeAliases() {\n\t\tAnnotationWithDefaults annotationWithDefaults = synthesizeAnnotation(AnnotationWithDefaults.class);\n\t\tassertThat(annotationWithDefaults).isNotNull();\n\t\tassertThat(annotationWithDefaults.text()).as(\"text: \").isEqualTo(\"enigma\");\n\t\tassertThat(annotationWithDefaults.predicate()).as(\"predicate: \").isTrue();\n\t\tassertThat(annotationWithDefaults.characters()).as(\"characters: \").isEqualTo(new char[] { 'a', 'b', 'c' });\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromDefaultsWithAttributeAliases() {\n\t\tContextConfig contextConfig = synthesizeAnnotation(ContextConfig.class);\n\t\tassertThat(contextConfig).isNotNull();\n\t\tassertThat(contextConfig.value()).as(\"value: \").isEmpty();\n\t\tassertThat(contextConfig.location()).as(\"location: \").isEmpty();\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithMinimalAttributesWithAttributeAliases() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"location\", \"test.xml\");\n\t\tContextConfig contextConfig = synthesizeAnnotation(map, ContextConfig.class, null);\n\t\tassertThat(contextConfig).isNotNull();\n\t\tassertThat(contextConfig.value()).as(\"value: \").isEqualTo(\"test.xml\");\n\t\tassertThat(contextConfig.location()).as(\"location: \").isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"value\", \"/foo\");\n\t\tGet get = synthesizeAnnotation(map, Get.class, null);\n\t\tassertThat(get).isNotNull();\n\t\tassertThat(get.value()).as(\"value: \").isEqualTo(\"/foo\");\n\t\tassertThat(get.path()).as(\"path: \").isEqualTo(\"/foo\");\n\n\t\tmap = Collections.singletonMap(\"path\", \"/foo\");\n\t\tget = synthesizeAnnotation(map, Get.class, null);\n\t\tassertThat(get).isNotNull();\n\t\tassertThat(get.value()).as(\"value: \").isEqualTo(\"/foo\");\n\t\tassertThat(get.path()).as(\"path: \").isEqualTo(\"/foo\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithImplicitAttributeAliases() {\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"value\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"location1\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"location2\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"location3\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"xmlFile\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"groovyScript\");\n\t}\n\n\tprivate void assertAnnotationSynthesisFromMapWithImplicitAliases(String attributeNameAndValue) {\n\t\tMap<String, Object> map = Collections.singletonMap(attributeNameAndValue, attributeNameAndValue);\n\t\tImplicitAliasesContextConfig config = synthesizeAnnotation(map, ImplicitAliasesContextConfig.class, null);\n\t\tassertThat(config).isNotNull();\n\t\tassertThat(config.value()).as(\"value: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.location1()).as(\"location1: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.location2()).as(\"location2: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.location3()).as(\"location3: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.xmlFile()).as(\"xmlFile: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.groovyScript()).as(\"groovyScript: \").isEqualTo(attributeNameAndValue);\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithMissingAttributeValue() {\n\t\tassertMissingTextAttribute(Collections.emptyMap());\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithNullAttributeValue() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"text\", null);\n\t\tassertThat(map.containsKey(\"text\")).isTrue();\n\t\tassertMissingTextAttribute(map);\n\t}\n\n\tprivate void assertMissingTextAttribute(Map<String, Object> attributes) {\n\t\tassertThatExceptionOfType(NoSuchElementException.class).isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(attributes, AnnotationWithoutDefaults.class, null).text())\n\t\t\t.withMessageContaining(\"No value found for attribute named 'text' in merged annotation\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithAttributeOfIncorrectType() {\n\t\tMap<String, Object> map = Collections.singletonMap(VALUE, 42L);\n\t\tassertThatIllegalStateException().isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(map, Component.class, null).value())\n\t\t\t.withMessageContaining(\"Attribute 'value' in annotation org.springframework.core.testfixture.stereotype.Component \"\n\t\t\t\t\t+ \"should be compatible with java.lang.String but a java.lang.Long value was returned\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromAnnotationAttributesWithoutAttributeAliases() {\n\t\t// 1) Get an annotation\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\n\t\t// 2) Convert the annotation into AnnotationAttributes\n\t\tAnnotationAttributes attributes = getAnnotationAttributes(WebController.class, component);\n\t\tassertThat(attributes).isNotNull();\n\n\t\t// 3) Synthesize the AnnotationAttributes back into an annotation\n\t\tComponent synthesizedComponent = synthesizeAnnotation(attributes, Component.class, WebController.class);\n\t\tassertThat(synthesizedComponent).isNotNull();\n\n\t\t// 4) Verify that the original and synthesized annotations are equivalent\n\t\tassertThat(synthesizedComponent).isNotSameAs(component);\n\t\tassertThat(synthesizedComponent).isEqualTo(component);\n\t\tassertThat(component.value()).as(\"value from component: \").isEqualTo(\"webController\");\n\t\tassertThat(synthesizedComponent.value()).as(\"value from synthesized component: \").isEqualTo(\"webController\");\n\t}\n\n\t@Test  // gh-22702\n\tvoid findAnnotationWithRepeatablesElements() {\n\t\tassertThat(AnnotationUtils.findAnnotation(TestRepeatablesClass.class,\n\t\t\t\tTestRepeatable.class)).isNull();\n\t\tassertThat(AnnotationUtils.findAnnotation(TestRepeatablesClass.class,\n\t\tTestRepeatableContainer.class)).isNotNull();\n\t}\n\n\t@Test  // gh-23856\n\tvoid findAnnotationFindsRepeatableContainerOnComposedAnnotationMetaAnnotatedWithRepeatableAnnotations() {\n\t\tMyRepeatableContainer annotation = AnnotationUtils.findAnnotation(MyRepeatableMeta1And2.class, MyRepeatableContainer.class);\n\n\t\tassertThat(annotation).isNotNull();\n\t\tassertThat(annotation.value()).extracting(MyRepeatable::value).containsExactly(\"meta1\", \"meta2\");\n\t}\n\n\t@Test  // gh-23856\n\tvoid findAnnotationFindsRepeatableContainerOnComposedAnnotationMetaAnnotatedWithRepeatableAnnotationsOnMethod() throws Exception {\n\t\tMethod method = getClass().getDeclaredMethod(\"methodWithComposedAnnotationMetaAnnotatedWithRepeatableAnnotations\");\n\t\tMyRepeatableContainer annotation = AnnotationUtils.findAnnotation(method, MyRepeatableContainer.class);\n\n\t\tassertThat(annotation).isNotNull();\n\t\tassertThat(annotation.value()).extracting(MyRepeatable::value).containsExactly(\"meta1\", \"meta2\");\n\t}\n\n\t@Test  // gh-23929\n\tvoid findDeprecatedAnnotation() {\n\t\tassertThat(getAnnotation(DeprecatedClass.class, Deprecated.class)).isNotNull();\n\t\tassertThat(getAnnotation(SubclassOfDeprecatedClass.class, Deprecated.class)).isNull();\n\t\tassertThat(findAnnotation(DeprecatedClass.class, Deprecated.class)).isNotNull();\n\t\tassertThat(findAnnotation(SubclassOfDeprecatedClass.class, Deprecated.class)).isNotNull();\n\t}\n\n\n\t@SafeVarargs\n\tstatic <T> T[] asArray(T... arr) {\n\t\treturn arr;\n\t}\n\n\n\t@Component(\"meta1\")\n\t@Order\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Meta1 {\n\t}\n\n\t@Component(\"meta2\")\n\t@Transactional(readOnly = true)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Meta2 {\n\t}\n\n\t@Meta2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMeta {\n\t}\n\n\t@MetaMeta\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMetaMeta {\n\t}\n\n\t@MetaCycle3\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle1 {\n\t}\n\n\t@MetaCycle1\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle2 {\n\t}\n\n\t@MetaCycle2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle3 {\n\t}\n\n\t@Meta1\n\tinterface InterfaceWithMetaAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface implements InterfaceWithMetaAnnotation {\n\t}\n\n\t@Meta1\n\tstatic class ClassWithInheritedMetaAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class SubClassWithInheritedMetaAnnotation extends ClassWithInheritedMetaAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedMetaAnnotation extends SubClassWithInheritedMetaAnnotation {\n\t}\n\n\t@Transactional\n\tstatic class ClassWithInheritedAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class SubClassWithInheritedAnnotation extends ClassWithInheritedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedAnnotation extends SubClassWithInheritedAnnotation {\n\t}\n\n\t@MetaMeta\n\tstatic class MetaMetaAnnotatedClass {\n\t}\n\n\t@MetaMetaMeta\n\tstatic class MetaMetaMetaAnnotatedClass {\n\t}\n\n\t@MetaCycle3\n\tstatic class MetaCycleAnnotatedClass {\n\t}\n\n\tpublic interface AnnotatedInterface {\n\n\t\t@Order(0)\n\t\tvoid fromInterfaceImplementedByRoot();\n\t}\n\n\tpublic static class Root implements AnnotatedInterface {\n\n\t\t@Order(27)\n\t\tpublic void annotatedOnRoot() {\n\t\t}\n\n\t\t@Meta1\n\t\tpublic void metaAnnotatedOnRoot() {\n\t\t}\n\n\t\tpublic void overrideToAnnotate() {\n\t\t}\n\n\t\t@Order(27)\n\t\tpublic void overrideWithoutNewAnnotation() {\n\t\t}\n\n\t\tpublic void notAnnotated() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void fromInterfaceImplementedByRoot() {\n\t\t}\n\t}\n\n\tpublic static class Leaf extends Root {\n\n\t\t@Order(25)\n\t\tpublic void annotatedOnLeaf() {\n\t\t}\n\n\t\t@Meta1\n\t\tpublic void metaAnnotatedOnLeaf() {\n\t\t}\n\n\t\t@MetaMeta\n\t\tpublic void metaMetaAnnotatedOnLeaf() {\n\t\t}\n\n\t\t@Override\n\t\t@Order(1)\n\t\tpublic void overrideToAnnotate() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void overrideWithoutNewAnnotation() {\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Transactional {\n\n\t\tboolean readOnly() default false;\n\t}\n\n\tpublic abstract static class Foo<T> {\n\n\t\t@Order(1)\n\t\tpublic abstract void something(T arg);\n\t}\n\n\tpublic static class SimpleFoo extends Foo<String> {\n\n\t\t@Override\n\t\t@Transactional\n\t\tpublic void something(final String arg) {\n\t\t}\n\t}\n\n\t@Transactional\n\tpublic interface InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubInheritedAnnotationInterface extends InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubInheritedAnnotationInterface extends SubInheritedAnnotationInterface {\n\t}\n\n\t@Order\n\tpublic interface NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubNonInheritedAnnotationInterface extends NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubNonInheritedAnnotationInterface extends SubNonInheritedAnnotationInterface {\n\t}\n\n\tpublic static class NonAnnotatedClass {\n\t}\n\n\tpublic interface NonAnnotatedInterface {\n\t}\n\n\t@Transactional\n\tpublic static class InheritedAnnotationClass {\n\t}\n\n\tpublic static class SubInheritedAnnotationClass extends InheritedAnnotationClass {\n\t}\n\n\t@Order\n\tpublic static class NonInheritedAnnotationClass {\n\t}\n\n\tpublic static class SubNonInheritedAnnotationClass extends NonInheritedAnnotationClass {\n\t}\n\n\t@Transactional\n\tpublic static class TransactionalClass {\n\t}\n\n\t@Order\n\tpublic static class TransactionalAndOrderedClass extends TransactionalClass {\n\t}\n\n\tpublic static class SubTransactionalAndOrderedClass extends TransactionalAndOrderedClass {\n\t}\n\n\tpublic interface InterfaceWithAnnotatedMethod {\n\n\t\t@Order\n\t\tvoid foo();\n\t}\n\n\tpublic static class ImplementsInterfaceWithAnnotatedMethod implements InterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic static class SubOfImplementsInterfaceWithAnnotatedMethod extends ImplementsInterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic abstract static class AbstractDoesNotImplementInterfaceWithAnnotatedMethod\n\t\t\timplements InterfaceWithAnnotatedMethod {\n\t}\n\n\tpublic static class SubOfAbstractImplementsInterfaceWithAnnotatedMethod\n\t\t\textends AbstractDoesNotImplementInterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic interface InterfaceWithGenericAnnotatedMethod<T> {\n\n\t\t@Order\n\t\tvoid foo(T t);\n\t}\n\n\tpublic static class ImplementsInterfaceWithGenericAnnotatedMethod implements InterfaceWithGenericAnnotatedMethod<String> {\n\n\t\t@Override\n\t\tpublic void foo(String t) {\n\t\t}\n\t}\n\n\tpublic abstract static class BaseClassWithGenericAnnotatedMethod<T> {\n\n\t\t@Order\n\t\tabstract void foo(T t);\n\t}\n\n\tpublic static class ExtendsBaseClassWithGenericAnnotatedMethod extends BaseClassWithGenericAnnotatedMethod<String> {\n\n\t\t@Override\n\t\tpublic void foo(String t) {\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface MyRepeatableContainer {\n\n\t\tMyRepeatable[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@Repeatable(MyRepeatableContainer.class)\n\t@interface MyRepeatable {\n\n\t\tString value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta1\")\n\t@interface MyRepeatableMeta1 {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta2\")\n\t@interface MyRepeatableMeta2 {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta1\")\n\t@MyRepeatable(\"meta2\")\n\t@interface MyRepeatableMeta1And2 {\n\t}\n\n\t@MyRepeatableMeta1And2\n\tvoid methodWithComposedAnnotationMetaAnnotatedWithRepeatableAnnotations() {\n\t}\n\n\tinterface InterfaceWithRepeated {\n\n\t\t@MyRepeatable(\"A\")\n\t\t@MyRepeatableContainer({@MyRepeatable(\"B\"), @MyRepeatable(\"C\")})\n\t\t@MyRepeatableMeta1\n\t\tvoid foo();\n\t}\n\n\t@MyRepeatable(\"A\")\n\t@MyRepeatableContainer({@MyRepeatable(\"B\"), @MyRepeatable(\"C\")})\n\t@MyRepeatableMeta1\n\tstatic class MyRepeatableClass {\n\t}\n\n\tstatic class SubMyRepeatableClass extends MyRepeatableClass {\n\t}\n\n\t@MyRepeatable(\"X\")\n\t@MyRepeatableContainer({@MyRepeatable(\"Y\"), @MyRepeatable(\"Z\")})\n\t@MyRepeatableMeta2\n\tstatic class SubMyRepeatableWithAdditionalLocalDeclarationsClass extends MyRepeatableClass {\n\t}\n\n\tstatic class SubSubMyRepeatableWithAdditionalLocalDeclarationsClass extends\n\t\t\tSubMyRepeatableWithAdditionalLocalDeclarationsClass {\n\t}\n\n\tenum RequestMethod {\n\t\tGET, POST\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.web.bind.annotation.RequestMapping}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface WebMapping {\n\n\t\tString name();\n\n\t\t@AliasFor(\"path\")\n\t\tString[] value() default \"\";\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tString[] path() default \"\";\n\n\t\tRequestMethod[] method() default {};\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.web.bind.annotation.GetMapping}, except\n\t * that the String arrays are overridden with single String elements.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@WebMapping(method = RequestMethod.GET, name = \"\")\n\t@interface Get {\n\n\t\t@AliasFor(annotation = WebMapping.class)\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = WebMapping.class)\n\t\tString path() default \"\";\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.web.bind.annotation.PostMapping}, except\n\t * that the path is overridden by convention with single String element.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@WebMapping(method = RequestMethod.POST, name = \"\")\n\t@interface Post {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = WebMapping.class)\n\t\tString path() default \"\";\n\t}\n\n\t@Component(\"webController\")\n\tstatic class WebController {\n\n\t\t@WebMapping(value = \"/test\", name = \"foo\")\n\t\tpublic void handleMappedWithValueAttribute() {\n\t\t}\n\n\t\t@WebMapping(path = \"/test\", name = \"bar\", method = { RequestMethod.GET, RequestMethod.POST })\n\t\tpublic void handleMappedWithPathAttribute() {\n\t\t}\n\n\t\t@Get(\"/test\")\n\t\tpublic void getMappedWithValueAttribute() {\n\t\t}\n\n\t\t@Get(path = \"/test\")\n\t\tpublic void getMappedWithPathAttribute() {\n\t\t}\n\n\t\t@Post(path = \"/test\")\n\t\tpublic void postMappedWithPathAttribute() {\n\t\t}\n\n\t\t/**\n\t\t * mapping is logically \"equal\" to handleMappedWithPathAttribute().\n\t\t */\n\t\t@WebMapping(value = \"/test\", path = \"/test\", name = \"bar\", method = { RequestMethod.GET, RequestMethod.POST })\n\t\tpublic void handleMappedWithSamePathAndValueAttributes() {\n\t\t}\n\n\t\t@WebMapping(value = \"/enigma\", path = \"/test\", name = \"baz\")\n\t\tpublic void handleMappedWithDifferentPathAndValueAttributes() {\n\t\t}\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.test.context.ContextConfiguration}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContextConfig {\n\n\t\t@AliasFor(\"location\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString location() default \"\";\n\n\t\tClass<?> klass() default Object.class;\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.test.context.ContextHierarchy}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Hierarchy {\n\t\tContextConfig[] value();\n\t}\n\n\t@Hierarchy({@ContextConfig(\"A\"), @ContextConfig(location = \"B\")})\n\tstatic class ConfigHierarchyTestCase {\n\t}\n\n\t@ContextConfig(\"simple.xml\")\n\tstatic class SimpleConfigTestCase {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface CharsContainer {\n\n\t\t@AliasFor(attribute = \"chars\")\n\t\tchar[] value() default {};\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tchar[] chars() default {};\n\t}\n\n\t@CharsContainer(chars = { 'x', 'y', 'z' })\n\tstatic class GroupOfCharsClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMissingAttributeDeclaration {\n\n\t\t@AliasFor\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForWithMissingAttributeDeclaration\n\tstatic class AliasForWithMissingAttributeDeclarationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithDuplicateAttributeDeclaration {\n\n\t\t@AliasFor(value = \"bar\", attribute = \"baz\")\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForWithDuplicateAttributeDeclaration\n\tstatic class AliasForWithDuplicateAttributeDeclarationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForNonexistentAttribute {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForNonexistentAttribute\n\tstatic class AliasForNonexistentAttributeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithoutMirroredAliasFor {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"\";\n\n\t\tString bar() default \"\";\n\t}\n\n\t@AliasForWithoutMirroredAliasFor\n\tstatic class AliasForWithoutMirroredAliasForClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMirroredAliasForWrongAttribute {\n\n\t\t@AliasFor(attribute = \"bar\")\n\t\tString[] foo() default \"\";\n\n\t\t@AliasFor(attribute = \"quux\")\n\t\tString[] bar() default \"\";\n\t}\n\n\t@AliasForWithMirroredAliasForWrongAttribute\n\tstatic class AliasForWithMirroredAliasForWrongAttributeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForAttributeOfDifferentType {\n\n\t\t@AliasFor(\"bar\")\n\t\tString[] foo() default \"\";\n\n\t\t@AliasFor(\"foo\")\n\t\tboolean bar() default true;\n\t}\n\n\t@AliasForAttributeOfDifferentType\n\tstatic class AliasForAttributeOfDifferentTypeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMissingDefaultValues {\n\n\t\t@AliasFor(attribute = \"bar\")\n\t\tString foo();\n\n\t\t@AliasFor(attribute = \"foo\")\n\t\tString bar();\n\t}\n\n\t@AliasForWithMissingDefaultValues(foo = \"foo\", bar = \"bar\")\n\tstatic class AliasForWithMissingDefaultValuesClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForAttributeWithDifferentDefaultValue {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"X\";\n\n\t\t@AliasFor(\"foo\")\n\t\tString bar() default \"Z\";\n\t}\n\n\t@AliasForAttributeWithDifferentDefaultValue\n\tstatic class AliasForAttributeWithDifferentDefaultValueClass {\n\t}\n\n\t// @ContextConfig --> Intentionally NOT meta-present\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfigNotMetaPresent {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlConfigFile();\n\t}\n\n\t@AliasedComposedContextConfigNotMetaPresent(xmlConfigFile = \"test.xml\")\n\tstatic class AliasedComposedContextConfigNotMetaPresentClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlConfigFile();\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface ImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString groovyScript() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location1() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location2() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location3() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"klass\")\n\t\tClass<?> configClass() default Object.class;\n\n\t\tString nonAliasedAttribute() default \"\";\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(groovyScript = \"groovyScript\")\n\tstatic class GroovyImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(xmlFile = \"xmlFile\")\n\tstatic class XmlImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(\"value\")\n\tstatic class ValueImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(location1 = \"location1\")\n\tstatic class Location1ImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(location2 = \"location2\")\n\tstatic class Location2ImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(location3 = \"location3\")\n\tstatic class Location3ImplicitAliasesContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig {\n\n\t\t// intentionally omitted: attribute = \"value\"\n\t\t@AliasFor(annotation = ContextConfig.class)\n\t\tString value() default \"\";\n\n\t\t// intentionally omitted: attribute = \"locations\"\n\t\t@AliasFor(annotation = ContextConfig.class)\n\t\tString location() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesWithImpliedAliasNamesOmittedContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig.class, attribute = \"location\")\n\t\tString groovy() default \"\";\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig(\"value\")\n\tstatic class ValueImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig(location = \"location\")\n\tstatic class LocationsImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig(xmlFile = \"xmlFile\")\n\tstatic class XmlFilesImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithMissingDefaultValuesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location1();\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location2();\n\t}\n\n\t@ImplicitAliasesWithMissingDefaultValuesContextConfig(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithMissingDefaultValuesContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithDifferentDefaultValuesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location1() default \"foo\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location2() default \"bar\";\n\t}\n\n\t@ImplicitAliasesWithDifferentDefaultValuesContextConfig(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithDifferentDefaultValuesContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithDuplicateValuesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location1() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location2() default \"\";\n\t}\n\n\t@ImplicitAliasesWithDuplicateValuesContextConfig(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithDuplicateValuesContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesForAliasPairContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, value = \"value\")\n\t\tString groovyScript() default \"\";\n\t}\n\n\t@ImplicitAliasesForAliasPairContextConfig(xmlFile = \"test.xml\")\n\tstatic class ImplicitAliasesForAliasPairContextConfigClass {\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScript\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@TransitiveImplicitAliasesContextConfig(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesContextConfigClass {\n\t}\n\n\t@ImplicitAliasesForAliasPairContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesForAliasPairContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesForAliasPairContextConfig.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesForAliasPairContextConfig.class, attribute = \"groovyScript\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@TransitiveImplicitAliasesForAliasPairContextConfig(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesForAliasPairContextConfigClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({})\n\t@interface Filter {\n\t\tString pattern();\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.context.annotation.ComponentScan}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScan {\n\t\tFilter[] excludeFilters() default {};\n\t}\n\n\t@ComponentScan(excludeFilters = {@Filter(pattern = \"*Foo\"), @Filter(pattern = \"*Bar\")})\n\tstatic class ComponentScanClass {\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.context.annotation.ComponentScan}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScanSingleFilter {\n\t\tFilter value();\n\t}\n\n\t@ComponentScanSingleFilter(@Filter(pattern = \"*Foo\"))\n\tstatic class ComponentScanSingleFilterClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnotationWithDefaults {\n\t\tString text() default \"enigma\";\n\t\tboolean predicate() default true;\n\t\tchar[] characters() default {'a', 'b', 'c'};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnotationWithoutDefaults {\n\t\tString text();\n\t}\n\n\t@ContextConfig(value = \"foo\", location = \"bar\")\n\tinterface ContextConfigMismatch {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(TestRepeatableContainer.class)\n\t@interface TestRepeatable {\n\n\t\tString value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestRepeatableContainer {\n\n\t\tTestRepeatable[] value();\n\t}\n\n\t@TestRepeatable(\"a\")\n\t@TestRepeatable(\"b\")\n\tstatic class TestRepeatablesClass {\n\t}\n\n\t@Deprecated\n\tstatic class DeprecatedClass {\n\t}\n\n\tstatic class SubclassOfDeprecatedClass extends DeprecatedClass {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.AliasForAttributeOfDifferentTypeClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.AliasForAttributeOfDifferentTypeClass",
    "headType": "class",
    "relation": "use",
    "tail": "@AliasForAttributeOfDifferentType",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AliasForAttributeOfDifferentTypeClass",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Method;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.ParametersAreNonnullByDefault;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.subpackage.NonPublicAnnotatedClass;\nimport org.springframework.core.testfixture.ide.IdeUtils;\nimport org.springframework.core.testfixture.stereotype.Component;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Collectors.toList;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalStateException;\nimport static org.springframework.core.annotation.AnnotationUtils.VALUE;\nimport static org.springframework.core.annotation.AnnotationUtils.findAnnotation;\nimport static org.springframework.core.annotation.AnnotationUtils.findAnnotationDeclaringClass;\nimport static org.springframework.core.annotation.AnnotationUtils.findAnnotationDeclaringClassForTypes;\nimport static org.springframework.core.annotation.AnnotationUtils.getAnnotation;\nimport static org.springframework.core.annotation.AnnotationUtils.getAnnotationAttributes;\nimport static org.springframework.core.annotation.AnnotationUtils.getDeclaredRepeatableAnnotations;\nimport static org.springframework.core.annotation.AnnotationUtils.getDefaultValue;\nimport static org.springframework.core.annotation.AnnotationUtils.getRepeatableAnnotations;\nimport static org.springframework.core.annotation.AnnotationUtils.getValue;\nimport static org.springframework.core.annotation.AnnotationUtils.isAnnotationDeclaredLocally;\nimport static org.springframework.core.annotation.AnnotationUtils.isAnnotationInherited;\nimport static org.springframework.core.annotation.AnnotationUtils.isAnnotationMetaPresent;\nimport static org.springframework.core.annotation.AnnotationUtils.synthesizeAnnotation;\n\n/**\n * Tests for {@link AnnotationUtils}.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Chris Beams\n * @author Phillip Webb\n * @author Oleg Zhurakousky\n */\n@SuppressWarnings(\"deprecation\")\nclass AnnotationUtilsTests {\n\n\t@BeforeEach\n\tvoid clearCacheBeforeTests() {\n\t\tAnnotationUtils.clearCache();\n\t}\n\n\n\t@Test\n\tvoid findMethodAnnotationOnLeaf() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"annotatedOnLeaf\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNotNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNotNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findMethodAnnotationWithAnnotationOnMethodInInterface() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"fromInterfaceImplementedByRoot\");\n\t\t// @Order is not @Inherited\n\t\tassertThat(m.getAnnotation(Order.class)).isNull();\n\t\t// getAnnotation() does not search on interfaces\n\t\tassertThat(getAnnotation(m, Order.class)).isNull();\n\t\t// findAnnotation() does search on interfaces\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findMethodAnnotationWithMetaAnnotationOnLeaf() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"metaAnnotatedOnLeaf\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNotNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findMethodAnnotationWithMetaMetaAnnotationOnLeaf() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"metaMetaAnnotatedOnLeaf\");\n\t\tassertThat(m.getAnnotation(Component.class)).isNull();\n\t\tassertThat(getAnnotation(m, Component.class)).isNull();\n\t\tassertThat(findAnnotation(m, Component.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationOnRoot() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"annotatedOnRoot\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNotNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNotNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findMethodAnnotationWithMetaAnnotationOnRoot() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"metaAnnotatedOnRoot\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNotNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationOnRootButOverridden() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"overrideWithoutNewAnnotation\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationNotAnnotated() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"notAnnotated\");\n\t\tassertThat(findAnnotation(m, Order.class)).isNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationOnBridgeMethod() throws Exception {\n\t\tMethod bridgeMethod = SimpleFoo.class.getMethod(\"something\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(bridgeMethod.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(bridgeMethod, Order.class)).isNull();\n\t\tassertThat(findAnnotation(bridgeMethod, Order.class)).isNotNull();\n\n\t\t// As of JDK 8, invoking getAnnotation() on a bridge method actually finds an\n\t\t// annotation on its 'bridged' method [1]; however, the Eclipse compiler does\n\t\t// not support this [2]. Thus, we effectively ignore the following\n\t\t// assertion if the test is currently executing within the Eclipse IDE.\n\t\t//\n\t\t// [1] https://bugs.openjdk.java.net/browse/JDK-6695379\n\t\t// [2] https://bugs.eclipse.org/bugs/show_bug.cgi?id=495396\n\t\t//\n\t\tif (!IdeUtils.runningInEclipse()) {\n\t\t\tassertThat(bridgeMethod.getAnnotation(Transactional.class)).isNotNull();\n\t\t}\n\t\tassertThat(getAnnotation(bridgeMethod, Transactional.class)).isNotNull();\n\t\tassertThat(findAnnotation(bridgeMethod, Transactional.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationOnBridgedMethod() throws Exception {\n\t\tMethod bridgedMethod = SimpleFoo.class.getMethod(\"something\", String.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tassertThat(bridgedMethod.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(bridgedMethod, Order.class)).isNull();\n\t\tassertThat(findAnnotation(bridgedMethod, Order.class)).isNotNull();\n\n\t\tassertThat(bridgedMethod.getAnnotation(Transactional.class)).isNotNull();\n\t\tassertThat(getAnnotation(bridgedMethod, Transactional.class)).isNotNull();\n\t\tassertThat(findAnnotation(bridgedMethod, Transactional.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationFromInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test  // SPR-16060\n\tvoid findMethodAnnotationFromGenericInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test  // SPR-17146\n\tvoid findMethodAnnotationFromGenericSuperclass() throws Exception {\n\t\tMethod method = ExtendsBaseClassWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationFromInterfaceOnSuper() throws Exception {\n\t\tMethod method = SubOfImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationFromInterfaceWhenSuperDoesNotImplementMethod() throws Exception {\n\t\tMethod method = SubOfAbstractImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t// @since 4.1.2\n\t@Test\n\tvoid findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverAnnotationsOnInterfaces() {\n\t\tComponent component = findAnnotation(ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface.class, Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tassertThat(component.value()).isEqualTo(\"meta2\");\n\t}\n\n\t// @since 4.0.3\n\t@Test\n\tvoid findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedAnnotations() {\n\t\tTransactional transactional = findAnnotation(SubSubClassWithInheritedAnnotation.class, Transactional.class);\n\t\tassertThat(transactional).isNotNull();\n\t\tassertThat(transactional.readOnly()).as(\"readOnly flag for SubSubClassWithInheritedAnnotation\").isTrue();\n\t}\n\n\t// @since 4.0.3\n\t@Test\n\tvoid findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedComposedAnnotations() {\n\t\tComponent component = findAnnotation(SubSubClassWithInheritedMetaAnnotation.class, Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tassertThat(component.value()).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid findClassAnnotationOnMetaMetaAnnotatedClass() {\n\t\tComponent component = findAnnotation(MetaMetaAnnotatedClass.class, Component.class);\n\t\tassertThat(component).as(\"Should find meta-annotation on composed annotation on class\").isNotNull();\n\t\tassertThat(component.value()).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid findClassAnnotationOnMetaMetaMetaAnnotatedClass() {\n\t\tComponent component = findAnnotation(MetaMetaMetaAnnotatedClass.class, Component.class);\n\t\tassertThat(component).as(\"Should find meta-annotation on meta-annotation on composed annotation on class\").isNotNull();\n\t\tassertThat(component.value()).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid findClassAnnotationOnAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\t// TransactionalClass is NOT annotated or meta-annotated with @Component\n\t\tComponent component = findAnnotation(TransactionalClass.class, Component.class);\n\t\tassertThat(component).as(\"Should not find @Component on TransactionalClass\").isNull();\n\t}\n\n\t@Test\n\tvoid findClassAnnotationOnMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\tComponent component = findAnnotation(MetaCycleAnnotatedClass.class, Component.class);\n\t\tassertThat(component).as(\"Should not find @Component on MetaCycleAnnotatedClass\").isNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnInheritedAnnotationInterface() {\n\t\tTransactional tx = findAnnotation(InheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(tx).as(\"Should find @Transactional on InheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnSubInheritedAnnotationInterface() {\n\t\tTransactional tx = findAnnotation(SubInheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(tx).as(\"Should find @Transactional on SubInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnSubSubInheritedAnnotationInterface() {\n\t\tTransactional tx = findAnnotation(SubSubInheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(tx).as(\"Should find @Transactional on SubSubInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnNonInheritedAnnotationInterface() {\n\t\tOrder order = findAnnotation(NonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(order).as(\"Should find @Order on NonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnSubNonInheritedAnnotationInterface() {\n\t\tOrder order = findAnnotation(SubNonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(order).as(\"Should find @Order on SubNonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnSubSubNonInheritedAnnotationInterface() {\n\t\tOrder order = findAnnotation(SubSubNonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(order).as(\"Should find @Order on SubSubNonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findAnnotationDeclaringClassForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, NonAnnotatedInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, NonAnnotatedClass.class)).isNull();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, InheritedAnnotationInterface.class)).isEqualTo(InheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, SubInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, InheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, SubInheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but findAnnotationDeclaringClass() should still find it on classes.\n\t\tassertThat(findAnnotationDeclaringClass(Order.class, NonInheritedAnnotationInterface.class)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClass(Order.class, SubNonInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClass(Order.class, NonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClass(Order.class, SubNonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t}\n\n\t@Test\n\tvoid findAnnotationDeclaringClassForTypesWithSingleCandidateType() {\n\t\t// no class-level annotation\n\t\tList<Class<? extends Annotation>> transactionalCandidateList = Collections.singletonList(Transactional.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, NonAnnotatedInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, NonAnnotatedClass.class)).isNull();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, InheritedAnnotationInterface.class)).isEqualTo(InheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, SubInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, InheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, SubInheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but findAnnotationDeclaringClassForTypes() should still find it on classes.\n\t\tList<Class<? extends Annotation>> orderCandidateList = Collections.singletonList(Order.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, NonInheritedAnnotationInterface.class)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, SubNonInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, NonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, SubNonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t}\n\n\t@Test\n\tvoid findAnnotationDeclaringClassForTypesWithMultipleCandidateTypes() {\n\t\tList<Class<? extends Annotation>> candidates = asList(Transactional.class, Order.class);\n\n\t\t// no class-level annotation\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, NonAnnotatedInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, NonAnnotatedClass.class)).isNull();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, InheritedAnnotationInterface.class)).isEqualTo(InheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, InheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubInheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but findAnnotationDeclaringClassForTypes() should still find it on classes.\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, NonInheritedAnnotationInterface.class)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubNonInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, NonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubNonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\n\t\t// class hierarchy mixed with @Transactional and @Order declarations\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, TransactionalClass.class)).isEqualTo(TransactionalClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, TransactionalAndOrderedClass.class)).isEqualTo(TransactionalAndOrderedClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubTransactionalAndOrderedClass.class)).isEqualTo(TransactionalAndOrderedClass.class);\n\t}\n\n\t@Test\n\tvoid isAnnotationDeclaredLocallyForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, NonAnnotatedInterface.class)).isFalse();\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, NonAnnotatedClass.class)).isFalse();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, InheritedAnnotationInterface.class)).isTrue();\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, SubInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, InheritedAnnotationClass.class)).isTrue();\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, SubInheritedAnnotationClass.class)).isFalse();\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited\n\t\tassertThat(isAnnotationDeclaredLocally(Order.class, NonInheritedAnnotationInterface.class)).isTrue();\n\t\tassertThat(isAnnotationDeclaredLocally(Order.class, SubNonInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationDeclaredLocally(Order.class, NonInheritedAnnotationClass.class)).isTrue();\n\t\tassertThat(isAnnotationDeclaredLocally(Order.class, SubNonInheritedAnnotationClass.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotationInheritedForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(isAnnotationInherited(Transactional.class, NonAnnotatedInterface.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Transactional.class, NonAnnotatedClass.class)).isFalse();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(isAnnotationInherited(Transactional.class, InheritedAnnotationInterface.class)).isFalse();\n\t\t// isAnnotationInherited() does not currently traverse interface hierarchies.\n\t\t// Thus the following, though perhaps counterintuitive, must be false:\n\t\tassertThat(isAnnotationInherited(Transactional.class, SubInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Transactional.class, InheritedAnnotationClass.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Transactional.class, SubInheritedAnnotationClass.class)).isTrue();\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited\n\t\tassertThat(isAnnotationInherited(Order.class, NonInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Order.class, SubNonInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Order.class, NonInheritedAnnotationClass.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Order.class, SubNonInheritedAnnotationClass.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotationMetaPresentForPlainType() {\n\t\tassertThat(isAnnotationMetaPresent(Order.class, Documented.class)).isTrue();\n\t\tassertThat(isAnnotationMetaPresent(ParametersAreNonnullByDefault.class, Documented.class)).isTrue();\n\t\tassertThat(isAnnotationMetaPresent(ParametersAreNonnullByDefault.class, Nonnull.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributesWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\n\t\tAnnotationAttributes attributes = (AnnotationAttributes) getAnnotationAttributes(component);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.getString(VALUE)).as(\"value attribute: \").isEqualTo(\"webController\");\n\t\tassertThat(attributes.annotationType()).isEqualTo(Component.class);\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributesWithNestedAnnotations() {\n\t\tComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class);\n\t\tassertThat(componentScan).isNotNull();\n\n\t\tAnnotationAttributes attributes = getAnnotationAttributes(ComponentScanClass.class, componentScan);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(ComponentScan.class);\n\n\t\tFilter[] filters = attributes.getAnnotationArray(\"excludeFilters\", Filter.class);\n\t\tassertThat(filters).isNotNull();\n\n\t\tList<String> patterns = stream(filters).map(Filter::pattern).collect(toList());\n\t\tassertThat(patterns).isEqualTo(asList(\"*Foo\", \"*Bar\"));\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributesWithAttributeAliases() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\t\tWebMapping webMapping = method.getAnnotation(WebMapping.class);\n\t\tAnnotationAttributes attributes = (AnnotationAttributes) getAnnotationAttributes(webMapping);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(WebMapping.class);\n\t\tassertThat(attributes.getString(\"name\")).as(\"name attribute: \").isEqualTo(\"foo\");\n\t\tassertThat(attributes.getStringArray(VALUE)).as(\"value attribute: \").isEqualTo(asArray(\"/test\"));\n\t\tassertThat(attributes.getStringArray(\"path\")).as(\"path attribute: \").isEqualTo(asArray(\"/test\"));\n\n\t\tmethod = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\twebMapping = method.getAnnotation(WebMapping.class);\n\t\tattributes = (AnnotationAttributes) getAnnotationAttributes(webMapping);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(WebMapping.class);\n\t\tassertThat(attributes.getString(\"name\")).as(\"name attribute: \").isEqualTo(\"bar\");\n\t\tassertThat(attributes.getStringArray(VALUE)).as(\"value attribute: \").isEqualTo(asArray(\"/test\"));\n\t\tassertThat(attributes.getStringArray(\"path\")).as(\"path attribute: \").isEqualTo(asArray(\"/test\"));\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributesWithAttributeAliasesWithDifferentValues() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithDifferentPathAndValueAttributes\");\n\t\tWebMapping webMapping = method.getAnnotation(WebMapping.class);\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tgetAnnotationAttributes(webMapping))\n\t\t\t.withMessageContaining(\"attribute 'path' and its alias 'value'\")\n\t\t\t.withMessageContaining(\"values of [{/test}] and [{/enigma}]\");\n\t}\n\n\t@Test\n\tvoid getValueFromAnnotation() throws Exception {\n\t\tMethod method = SimpleFoo.class.getMethod(\"something\", Object.class);\n\t\tOrder order = findAnnotation(method, Order.class);\n\n\t\tassertThat(getValue(order, VALUE)).isEqualTo(1);\n\t\tassertThat(getValue(order)).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getValueFromNonPublicAnnotation() {\n\t\tAnnotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\n\t\tassertThat(declaredAnnotations).hasSize(1);\n\t\tAnnotation annotation = declaredAnnotations[0];\n\t\tassertThat(annotation).isNotNull();\n\t\tassertThat(annotation.annotationType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\n\t\tassertThat(getValue(annotation, VALUE)).isEqualTo(42);\n\t\tassertThat(getValue(annotation)).isEqualTo(42);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromAnnotation() throws Exception {\n\t\tMethod method = SimpleFoo.class.getMethod(\"something\", Object.class);\n\t\tOrder order = findAnnotation(method, Order.class);\n\n\t\tassertThat(getDefaultValue(order, VALUE)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\n\t\tassertThat(getDefaultValue(order)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromNonPublicAnnotation() {\n\t\tAnnotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\n\t\tassertThat(declaredAnnotations).hasSize(1);\n\t\tAnnotation annotation = declaredAnnotations[0];\n\t\tassertThat(annotation).isNotNull();\n\t\tassertThat(annotation.annotationType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\n\t\tassertThat(getDefaultValue(annotation, VALUE)).isEqualTo(-1);\n\t\tassertThat(getDefaultValue(annotation)).isEqualTo(-1);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromAnnotationType() {\n\t\tassertThat(getDefaultValue(Order.class, VALUE)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\n\t\tassertThat(getDefaultValue(Order.class)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Test\n\tvoid findRepeatableAnnotation() {\n\t\tRepeatable repeatable = findAnnotation(MyRepeatable.class, Repeatable.class);\n\t\tassertThat(repeatable).isNotNull();\n\t\tassertThat(repeatable.value()).isEqualTo(MyRepeatableContainer.class);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnMethod() throws Exception {\n\t\tMethod method = InterfaceWithRepeated.class.getMethod(\"foo\");\n\t\tSet<MyRepeatable> annotations = getRepeatableAnnotations(method, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(annotations).isNotNull();\n\t\tList<String> values = annotations.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(asList(\"A\", \"B\", \"C\", \"meta1\"));\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnClassWithAttributeAliases() {\n\t\tfinal List<String> expectedLocations = asList(\"A\", \"B\");\n\n\t\tSet<ContextConfig> annotations = getRepeatableAnnotations(ConfigHierarchyTestCase.class, ContextConfig.class, null);\n\t\tassertThat(annotations).isNotNull();\n\t\tassertThat(annotations).as(\"size if container type is omitted: \").isEmpty();\n\n\t\tannotations = getRepeatableAnnotations(ConfigHierarchyTestCase.class, ContextConfig.class, Hierarchy.class);\n\t\tassertThat(annotations).isNotNull();\n\n\t\tList<String> locations = annotations.stream().map(ContextConfig::location).collect(toList());\n\t\tassertThat(locations).isEqualTo(expectedLocations);\n\n\t\tList<String> values = annotations.stream().map(ContextConfig::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedLocations);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnClass() {\n\t\tfinal List<String> expectedValuesJava = asList(\"A\", \"B\", \"C\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"A\", \"B\", \"C\", \"meta1\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = MyRepeatableClass.class.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnSuperclass() {\n\t\tfinal Class<?> clazz = SubMyRepeatableClass.class;\n\t\tfinal List<String> expectedValuesJava = asList(\"A\", \"B\", \"C\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"A\", \"B\", \"C\", \"meta1\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getRepeatableAnnotations(clazz, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnClassAndSuperclass() {\n\t\tfinal Class<?> clazz = SubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\n\t\tfinal List<String> expectedValuesJava = asList(\"X\", \"Y\", \"Z\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"X\", \"Y\", \"Z\", \"meta2\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getRepeatableAnnotations(clazz, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnMultipleSuperclasses() {\n\t\tfinal Class<?> clazz = SubSubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\n\t\tfinal List<String> expectedValuesJava = asList(\"X\", \"Y\", \"Z\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"X\", \"Y\", \"Z\", \"meta2\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getRepeatableAnnotations(clazz, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getDeclaredRepeatableAnnotationsDeclaredOnClass() {\n\t\tfinal List<String> expectedValuesJava = asList(\"A\", \"B\", \"C\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"A\", \"B\", \"C\", \"meta1\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = MyRepeatableClass.class.getDeclaredAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getDeclaredRepeatableAnnotations(\n\t\t\t\tMyRepeatableClass.class, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getDeclaredRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getDeclaredRepeatableAnnotationsDeclaredOnSuperclass() {\n\t\tfinal Class<?> clazz = SubMyRepeatableClass.class;\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = clazz.getDeclaredAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tassertThat(array).isEmpty();\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getDeclaredRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tassertThat(set).isEmpty();\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getDeclaredRepeatableAnnotations(clazz, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tassertThat(set).isEmpty();\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationWithImplicitAliasesWithMissingDefaultValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithMissingDefaultValuesContextConfigClass.class;\n\t\tClass<ImplicitAliasesWithMissingDefaultValuesContextConfig> annotationType =\n\t\t\t\tImplicitAliasesWithMissingDefaultValuesContextConfig.class;\n\t\tImplicitAliasesWithMissingDefaultValuesContextConfig config = clazz.getAnnotation(annotationType);\n\t\tassertThat(config).isNotNull();\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(config, clazz))\n\t\t\t.withMessageStartingWith(\"Misconfigured aliases:\")\n\t\t\t.withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t.withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t.withMessageContaining(\"default values\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationWithImplicitAliasesWithDifferentDefaultValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithDifferentDefaultValuesContextConfigClass.class;\n\t\tClass<ImplicitAliasesWithDifferentDefaultValuesContextConfig> annotationType =\n\t\t\t\tImplicitAliasesWithDifferentDefaultValuesContextConfig.class;\n\t\tImplicitAliasesWithDifferentDefaultValuesContextConfig config = clazz.getAnnotation(annotationType);\n\t\tassertThat(config).isNotNull();\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(config, clazz))\n\t\t\t.withMessageStartingWith(\"Misconfigured aliases:\")\n\t\t\t.withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t.withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t.withMessageContaining(\"same default value\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationWithImplicitAliasesWithDuplicateValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithDuplicateValuesContextConfigClass.class;\n\t\tClass<ImplicitAliasesWithDuplicateValuesContextConfig> annotationType =\n\t\t\t\tImplicitAliasesWithDuplicateValuesContextConfig.class;\n\t\tImplicitAliasesWithDuplicateValuesContextConfig config = clazz.getAnnotation(annotationType);\n\t\tassertThat(config).isNotNull();\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(config, clazz).location1())\n\t\t\t.withMessageStartingWith(\"Different @AliasFor mirror values\")\n\t\t\t.withMessageContaining(annotationType.getName())\n\t\t\t.withMessageContaining(\"declared on class\")\n\t\t\t.withMessageContaining(clazz.getName())\n\t\t\t.withMessageContaining(\"attribute 'location1' and its alias 'location2'\")\n\t\t\t.withMessageContaining(\"with values of [1] and [2]\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\n\t\tMap<String, Object> map = Collections.singletonMap(VALUE, \"webController\");\n\t\tComponent synthesizedComponent = synthesizeAnnotation(map, Component.class, WebController.class);\n\t\tassertThat(synthesizedComponent).isNotNull();\n\n\t\tassertThat(synthesizedComponent).isNotSameAs(component);\n\t\tassertThat(component.value()).as(\"value from component: \").isEqualTo(\"webController\");\n\t\tassertThat(synthesizedComponent.value()).as(\"value from synthesized component: \").isEqualTo(\"webController\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeAnnotationFromMapWithNestedMap() {\n\t\tComponentScanSingleFilter componentScan =\n\t\t\t\tComponentScanSingleFilterClass.class.getAnnotation(ComponentScanSingleFilter.class);\n\t\tassertThat(componentScan).isNotNull();\n\t\tassertThat(componentScan.value().pattern()).as(\"value from ComponentScan: \").isEqualTo(\"*Foo\");\n\n\t\tAnnotationAttributes attributes = getAnnotationAttributes(\n\t\t\t\tComponentScanSingleFilterClass.class, componentScan, false, true);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(ComponentScanSingleFilter.class);\n\n\t\tMap<String, Object> filterMap = (Map<String, Object>) attributes.get(\"value\");\n\t\tassertThat(filterMap).isNotNull();\n\t\tassertThat(filterMap.get(\"pattern\")).isEqualTo(\"*Foo\");\n\n\t\t// Modify nested map\n\t\tfilterMap.put(\"pattern\", \"newFoo\");\n\t\tfilterMap.put(\"enigma\", 42);\n\n\t\tComponentScanSingleFilter synthesizedComponentScan = synthesizeAnnotation(\n\t\t\t\tattributes, ComponentScanSingleFilter.class, ComponentScanSingleFilterClass.class);\n\t\tassertThat(synthesizedComponentScan).isNotNull();\n\n\t\tassertThat(synthesizedComponentScan).isNotSameAs(componentScan);\n\t\tassertThat(synthesizedComponentScan.value().pattern()).as(\"value from synthesized ComponentScan: \").isEqualTo(\"newFoo\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeAnnotationFromMapWithNestedArrayOfMaps() {\n\t\tComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class);\n\t\tassertThat(componentScan).isNotNull();\n\n\t\tAnnotationAttributes attributes = getAnnotationAttributes(ComponentScanClass.class, componentScan, false, true);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(ComponentScan.class);\n\n\t\tMap<String, Object>[] filters = (Map[]) attributes.get(\"excludeFilters\");\n\t\tassertThat(filters).isNotNull();\n\n\t\tList<String> patterns = stream(filters).map(m -> (String) m.get(\"pattern\")).collect(toList());\n\t\tassertThat(patterns).isEqualTo(asList(\"*Foo\", \"*Bar\"));\n\n\t\t// Modify nested maps\n\t\tfilters[0].put(\"pattern\", \"newFoo\");\n\t\tfilters[0].put(\"enigma\", 42);\n\t\tfilters[1].put(\"pattern\", \"newBar\");\n\t\tfilters[1].put(\"enigma\", 42);\n\n\t\tComponentScan synthesizedComponentScan =\n\t\t\t\tsynthesizeAnnotation(attributes, ComponentScan.class, ComponentScanClass.class);\n\t\tassertThat(synthesizedComponentScan).isNotNull();\n\n\t\tassertThat(synthesizedComponentScan).isNotSameAs(componentScan);\n\t\tpatterns = stream(synthesizedComponentScan.excludeFilters()).map(Filter::pattern).collect(toList());\n\t\tassertThat(patterns).isEqualTo(asList(\"newFoo\", \"newBar\"));\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromDefaultsWithoutAttributeAliases() {\n\t\tAnnotationWithDefaults annotationWithDefaults = synthesizeAnnotation(AnnotationWithDefaults.class);\n\t\tassertThat(annotationWithDefaults).isNotNull();\n\t\tassertThat(annotationWithDefaults.text()).as(\"text: \").isEqualTo(\"enigma\");\n\t\tassertThat(annotationWithDefaults.predicate()).as(\"predicate: \").isTrue();\n\t\tassertThat(annotationWithDefaults.characters()).as(\"characters: \").isEqualTo(new char[] { 'a', 'b', 'c' });\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromDefaultsWithAttributeAliases() {\n\t\tContextConfig contextConfig = synthesizeAnnotation(ContextConfig.class);\n\t\tassertThat(contextConfig).isNotNull();\n\t\tassertThat(contextConfig.value()).as(\"value: \").isEmpty();\n\t\tassertThat(contextConfig.location()).as(\"location: \").isEmpty();\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithMinimalAttributesWithAttributeAliases() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"location\", \"test.xml\");\n\t\tContextConfig contextConfig = synthesizeAnnotation(map, ContextConfig.class, null);\n\t\tassertThat(contextConfig).isNotNull();\n\t\tassertThat(contextConfig.value()).as(\"value: \").isEqualTo(\"test.xml\");\n\t\tassertThat(contextConfig.location()).as(\"location: \").isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"value\", \"/foo\");\n\t\tGet get = synthesizeAnnotation(map, Get.class, null);\n\t\tassertThat(get).isNotNull();\n\t\tassertThat(get.value()).as(\"value: \").isEqualTo(\"/foo\");\n\t\tassertThat(get.path()).as(\"path: \").isEqualTo(\"/foo\");\n\n\t\tmap = Collections.singletonMap(\"path\", \"/foo\");\n\t\tget = synthesizeAnnotation(map, Get.class, null);\n\t\tassertThat(get).isNotNull();\n\t\tassertThat(get.value()).as(\"value: \").isEqualTo(\"/foo\");\n\t\tassertThat(get.path()).as(\"path: \").isEqualTo(\"/foo\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithImplicitAttributeAliases() {\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"value\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"location1\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"location2\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"location3\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"xmlFile\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"groovyScript\");\n\t}\n\n\tprivate void assertAnnotationSynthesisFromMapWithImplicitAliases(String attributeNameAndValue) {\n\t\tMap<String, Object> map = Collections.singletonMap(attributeNameAndValue, attributeNameAndValue);\n\t\tImplicitAliasesContextConfig config = synthesizeAnnotation(map, ImplicitAliasesContextConfig.class, null);\n\t\tassertThat(config).isNotNull();\n\t\tassertThat(config.value()).as(\"value: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.location1()).as(\"location1: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.location2()).as(\"location2: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.location3()).as(\"location3: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.xmlFile()).as(\"xmlFile: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.groovyScript()).as(\"groovyScript: \").isEqualTo(attributeNameAndValue);\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithMissingAttributeValue() {\n\t\tassertMissingTextAttribute(Collections.emptyMap());\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithNullAttributeValue() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"text\", null);\n\t\tassertThat(map.containsKey(\"text\")).isTrue();\n\t\tassertMissingTextAttribute(map);\n\t}\n\n\tprivate void assertMissingTextAttribute(Map<String, Object> attributes) {\n\t\tassertThatExceptionOfType(NoSuchElementException.class).isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(attributes, AnnotationWithoutDefaults.class, null).text())\n\t\t\t.withMessageContaining(\"No value found for attribute named 'text' in merged annotation\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithAttributeOfIncorrectType() {\n\t\tMap<String, Object> map = Collections.singletonMap(VALUE, 42L);\n\t\tassertThatIllegalStateException().isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(map, Component.class, null).value())\n\t\t\t.withMessageContaining(\"Attribute 'value' in annotation org.springframework.core.testfixture.stereotype.Component \"\n\t\t\t\t\t+ \"should be compatible with java.lang.String but a java.lang.Long value was returned\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromAnnotationAttributesWithoutAttributeAliases() {\n\t\t// 1) Get an annotation\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\n\t\t// 2) Convert the annotation into AnnotationAttributes\n\t\tAnnotationAttributes attributes = getAnnotationAttributes(WebController.class, component);\n\t\tassertThat(attributes).isNotNull();\n\n\t\t// 3) Synthesize the AnnotationAttributes back into an annotation\n\t\tComponent synthesizedComponent = synthesizeAnnotation(attributes, Component.class, WebController.class);\n\t\tassertThat(synthesizedComponent).isNotNull();\n\n\t\t// 4) Verify that the original and synthesized annotations are equivalent\n\t\tassertThat(synthesizedComponent).isNotSameAs(component);\n\t\tassertThat(synthesizedComponent).isEqualTo(component);\n\t\tassertThat(component.value()).as(\"value from component: \").isEqualTo(\"webController\");\n\t\tassertThat(synthesizedComponent.value()).as(\"value from synthesized component: \").isEqualTo(\"webController\");\n\t}\n\n\t@Test  // gh-22702\n\tvoid findAnnotationWithRepeatablesElements() {\n\t\tassertThat(AnnotationUtils.findAnnotation(TestRepeatablesClass.class,\n\t\t\t\tTestRepeatable.class)).isNull();\n\t\tassertThat(AnnotationUtils.findAnnotation(TestRepeatablesClass.class,\n\t\tTestRepeatableContainer.class)).isNotNull();\n\t}\n\n\t@Test  // gh-23856\n\tvoid findAnnotationFindsRepeatableContainerOnComposedAnnotationMetaAnnotatedWithRepeatableAnnotations() {\n\t\tMyRepeatableContainer annotation = AnnotationUtils.findAnnotation(MyRepeatableMeta1And2.class, MyRepeatableContainer.class);\n\n\t\tassertThat(annotation).isNotNull();\n\t\tassertThat(annotation.value()).extracting(MyRepeatable::value).containsExactly(\"meta1\", \"meta2\");\n\t}\n\n\t@Test  // gh-23856\n\tvoid findAnnotationFindsRepeatableContainerOnComposedAnnotationMetaAnnotatedWithRepeatableAnnotationsOnMethod() throws Exception {\n\t\tMethod method = getClass().getDeclaredMethod(\"methodWithComposedAnnotationMetaAnnotatedWithRepeatableAnnotations\");\n\t\tMyRepeatableContainer annotation = AnnotationUtils.findAnnotation(method, MyRepeatableContainer.class);\n\n\t\tassertThat(annotation).isNotNull();\n\t\tassertThat(annotation.value()).extracting(MyRepeatable::value).containsExactly(\"meta1\", \"meta2\");\n\t}\n\n\t@Test  // gh-23929\n\tvoid findDeprecatedAnnotation() {\n\t\tassertThat(getAnnotation(DeprecatedClass.class, Deprecated.class)).isNotNull();\n\t\tassertThat(getAnnotation(SubclassOfDeprecatedClass.class, Deprecated.class)).isNull();\n\t\tassertThat(findAnnotation(DeprecatedClass.class, Deprecated.class)).isNotNull();\n\t\tassertThat(findAnnotation(SubclassOfDeprecatedClass.class, Deprecated.class)).isNotNull();\n\t}\n\n\n\t@SafeVarargs\n\tstatic <T> T[] asArray(T... arr) {\n\t\treturn arr;\n\t}\n\n\n\t@Component(\"meta1\")\n\t@Order\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Meta1 {\n\t}\n\n\t@Component(\"meta2\")\n\t@Transactional(readOnly = true)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Meta2 {\n\t}\n\n\t@Meta2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMeta {\n\t}\n\n\t@MetaMeta\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMetaMeta {\n\t}\n\n\t@MetaCycle3\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle1 {\n\t}\n\n\t@MetaCycle1\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle2 {\n\t}\n\n\t@MetaCycle2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle3 {\n\t}\n\n\t@Meta1\n\tinterface InterfaceWithMetaAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface implements InterfaceWithMetaAnnotation {\n\t}\n\n\t@Meta1\n\tstatic class ClassWithInheritedMetaAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class SubClassWithInheritedMetaAnnotation extends ClassWithInheritedMetaAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedMetaAnnotation extends SubClassWithInheritedMetaAnnotation {\n\t}\n\n\t@Transactional\n\tstatic class ClassWithInheritedAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class SubClassWithInheritedAnnotation extends ClassWithInheritedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedAnnotation extends SubClassWithInheritedAnnotation {\n\t}\n\n\t@MetaMeta\n\tstatic class MetaMetaAnnotatedClass {\n\t}\n\n\t@MetaMetaMeta\n\tstatic class MetaMetaMetaAnnotatedClass {\n\t}\n\n\t@MetaCycle3\n\tstatic class MetaCycleAnnotatedClass {\n\t}\n\n\tpublic interface AnnotatedInterface {\n\n\t\t@Order(0)\n\t\tvoid fromInterfaceImplementedByRoot();\n\t}\n\n\tpublic static class Root implements AnnotatedInterface {\n\n\t\t@Order(27)\n\t\tpublic void annotatedOnRoot() {\n\t\t}\n\n\t\t@Meta1\n\t\tpublic void metaAnnotatedOnRoot() {\n\t\t}\n\n\t\tpublic void overrideToAnnotate() {\n\t\t}\n\n\t\t@Order(27)\n\t\tpublic void overrideWithoutNewAnnotation() {\n\t\t}\n\n\t\tpublic void notAnnotated() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void fromInterfaceImplementedByRoot() {\n\t\t}\n\t}\n\n\tpublic static class Leaf extends Root {\n\n\t\t@Order(25)\n\t\tpublic void annotatedOnLeaf() {\n\t\t}\n\n\t\t@Meta1\n\t\tpublic void metaAnnotatedOnLeaf() {\n\t\t}\n\n\t\t@MetaMeta\n\t\tpublic void metaMetaAnnotatedOnLeaf() {\n\t\t}\n\n\t\t@Override\n\t\t@Order(1)\n\t\tpublic void overrideToAnnotate() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void overrideWithoutNewAnnotation() {\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Transactional {\n\n\t\tboolean readOnly() default false;\n\t}\n\n\tpublic abstract static class Foo<T> {\n\n\t\t@Order(1)\n\t\tpublic abstract void something(T arg);\n\t}\n\n\tpublic static class SimpleFoo extends Foo<String> {\n\n\t\t@Override\n\t\t@Transactional\n\t\tpublic void something(final String arg) {\n\t\t}\n\t}\n\n\t@Transactional\n\tpublic interface InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubInheritedAnnotationInterface extends InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubInheritedAnnotationInterface extends SubInheritedAnnotationInterface {\n\t}\n\n\t@Order\n\tpublic interface NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubNonInheritedAnnotationInterface extends NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubNonInheritedAnnotationInterface extends SubNonInheritedAnnotationInterface {\n\t}\n\n\tpublic static class NonAnnotatedClass {\n\t}\n\n\tpublic interface NonAnnotatedInterface {\n\t}\n\n\t@Transactional\n\tpublic static class InheritedAnnotationClass {\n\t}\n\n\tpublic static class SubInheritedAnnotationClass extends InheritedAnnotationClass {\n\t}\n\n\t@Order\n\tpublic static class NonInheritedAnnotationClass {\n\t}\n\n\tpublic static class SubNonInheritedAnnotationClass extends NonInheritedAnnotationClass {\n\t}\n\n\t@Transactional\n\tpublic static class TransactionalClass {\n\t}\n\n\t@Order\n\tpublic static class TransactionalAndOrderedClass extends TransactionalClass {\n\t}\n\n\tpublic static class SubTransactionalAndOrderedClass extends TransactionalAndOrderedClass {\n\t}\n\n\tpublic interface InterfaceWithAnnotatedMethod {\n\n\t\t@Order\n\t\tvoid foo();\n\t}\n\n\tpublic static class ImplementsInterfaceWithAnnotatedMethod implements InterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic static class SubOfImplementsInterfaceWithAnnotatedMethod extends ImplementsInterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic abstract static class AbstractDoesNotImplementInterfaceWithAnnotatedMethod\n\t\t\timplements InterfaceWithAnnotatedMethod {\n\t}\n\n\tpublic static class SubOfAbstractImplementsInterfaceWithAnnotatedMethod\n\t\t\textends AbstractDoesNotImplementInterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic interface InterfaceWithGenericAnnotatedMethod<T> {\n\n\t\t@Order\n\t\tvoid foo(T t);\n\t}\n\n\tpublic static class ImplementsInterfaceWithGenericAnnotatedMethod implements InterfaceWithGenericAnnotatedMethod<String> {\n\n\t\t@Override\n\t\tpublic void foo(String t) {\n\t\t}\n\t}\n\n\tpublic abstract static class BaseClassWithGenericAnnotatedMethod<T> {\n\n\t\t@Order\n\t\tabstract void foo(T t);\n\t}\n\n\tpublic static class ExtendsBaseClassWithGenericAnnotatedMethod extends BaseClassWithGenericAnnotatedMethod<String> {\n\n\t\t@Override\n\t\tpublic void foo(String t) {\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface MyRepeatableContainer {\n\n\t\tMyRepeatable[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@Repeatable(MyRepeatableContainer.class)\n\t@interface MyRepeatable {\n\n\t\tString value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta1\")\n\t@interface MyRepeatableMeta1 {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta2\")\n\t@interface MyRepeatableMeta2 {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta1\")\n\t@MyRepeatable(\"meta2\")\n\t@interface MyRepeatableMeta1And2 {\n\t}\n\n\t@MyRepeatableMeta1And2\n\tvoid methodWithComposedAnnotationMetaAnnotatedWithRepeatableAnnotations() {\n\t}\n\n\tinterface InterfaceWithRepeated {\n\n\t\t@MyRepeatable(\"A\")\n\t\t@MyRepeatableContainer({@MyRepeatable(\"B\"), @MyRepeatable(\"C\")})\n\t\t@MyRepeatableMeta1\n\t\tvoid foo();\n\t}\n\n\t@MyRepeatable(\"A\")\n\t@MyRepeatableContainer({@MyRepeatable(\"B\"), @MyRepeatable(\"C\")})\n\t@MyRepeatableMeta1\n\tstatic class MyRepeatableClass {\n\t}\n\n\tstatic class SubMyRepeatableClass extends MyRepeatableClass {\n\t}\n\n\t@MyRepeatable(\"X\")\n\t@MyRepeatableContainer({@MyRepeatable(\"Y\"), @MyRepeatable(\"Z\")})\n\t@MyRepeatableMeta2\n\tstatic class SubMyRepeatableWithAdditionalLocalDeclarationsClass extends MyRepeatableClass {\n\t}\n\n\tstatic class SubSubMyRepeatableWithAdditionalLocalDeclarationsClass extends\n\t\t\tSubMyRepeatableWithAdditionalLocalDeclarationsClass {\n\t}\n\n\tenum RequestMethod {\n\t\tGET, POST\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.web.bind.annotation.RequestMapping}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface WebMapping {\n\n\t\tString name();\n\n\t\t@AliasFor(\"path\")\n\t\tString[] value() default \"\";\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tString[] path() default \"\";\n\n\t\tRequestMethod[] method() default {};\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.web.bind.annotation.GetMapping}, except\n\t * that the String arrays are overridden with single String elements.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@WebMapping(method = RequestMethod.GET, name = \"\")\n\t@interface Get {\n\n\t\t@AliasFor(annotation = WebMapping.class)\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = WebMapping.class)\n\t\tString path() default \"\";\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.web.bind.annotation.PostMapping}, except\n\t * that the path is overridden by convention with single String element.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@WebMapping(method = RequestMethod.POST, name = \"\")\n\t@interface Post {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = WebMapping.class)\n\t\tString path() default \"\";\n\t}\n\n\t@Component(\"webController\")\n\tstatic class WebController {\n\n\t\t@WebMapping(value = \"/test\", name = \"foo\")\n\t\tpublic void handleMappedWithValueAttribute() {\n\t\t}\n\n\t\t@WebMapping(path = \"/test\", name = \"bar\", method = { RequestMethod.GET, RequestMethod.POST })\n\t\tpublic void handleMappedWithPathAttribute() {\n\t\t}\n\n\t\t@Get(\"/test\")\n\t\tpublic void getMappedWithValueAttribute() {\n\t\t}\n\n\t\t@Get(path = \"/test\")\n\t\tpublic void getMappedWithPathAttribute() {\n\t\t}\n\n\t\t@Post(path = \"/test\")\n\t\tpublic void postMappedWithPathAttribute() {\n\t\t}\n\n\t\t/**\n\t\t * mapping is logically \"equal\" to handleMappedWithPathAttribute().\n\t\t */\n\t\t@WebMapping(value = \"/test\", path = \"/test\", name = \"bar\", method = { RequestMethod.GET, RequestMethod.POST })\n\t\tpublic void handleMappedWithSamePathAndValueAttributes() {\n\t\t}\n\n\t\t@WebMapping(value = \"/enigma\", path = \"/test\", name = \"baz\")\n\t\tpublic void handleMappedWithDifferentPathAndValueAttributes() {\n\t\t}\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.test.context.ContextConfiguration}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContextConfig {\n\n\t\t@AliasFor(\"location\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString location() default \"\";\n\n\t\tClass<?> klass() default Object.class;\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.test.context.ContextHierarchy}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Hierarchy {\n\t\tContextConfig[] value();\n\t}\n\n\t@Hierarchy({@ContextConfig(\"A\"), @ContextConfig(location = \"B\")})\n\tstatic class ConfigHierarchyTestCase {\n\t}\n\n\t@ContextConfig(\"simple.xml\")\n\tstatic class SimpleConfigTestCase {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface CharsContainer {\n\n\t\t@AliasFor(attribute = \"chars\")\n\t\tchar[] value() default {};\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tchar[] chars() default {};\n\t}\n\n\t@CharsContainer(chars = { 'x', 'y', 'z' })\n\tstatic class GroupOfCharsClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMissingAttributeDeclaration {\n\n\t\t@AliasFor\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForWithMissingAttributeDeclaration\n\tstatic class AliasForWithMissingAttributeDeclarationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithDuplicateAttributeDeclaration {\n\n\t\t@AliasFor(value = \"bar\", attribute = \"baz\")\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForWithDuplicateAttributeDeclaration\n\tstatic class AliasForWithDuplicateAttributeDeclarationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForNonexistentAttribute {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForNonexistentAttribute\n\tstatic class AliasForNonexistentAttributeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithoutMirroredAliasFor {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"\";\n\n\t\tString bar() default \"\";\n\t}\n\n\t@AliasForWithoutMirroredAliasFor\n\tstatic class AliasForWithoutMirroredAliasForClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMirroredAliasForWrongAttribute {\n\n\t\t@AliasFor(attribute = \"bar\")\n\t\tString[] foo() default \"\";\n\n\t\t@AliasFor(attribute = \"quux\")\n\t\tString[] bar() default \"\";\n\t}\n\n\t@AliasForWithMirroredAliasForWrongAttribute\n\tstatic class AliasForWithMirroredAliasForWrongAttributeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForAttributeOfDifferentType {\n\n\t\t@AliasFor(\"bar\")\n\t\tString[] foo() default \"\";\n\n\t\t@AliasFor(\"foo\")\n\t\tboolean bar() default true;\n\t}\n\n\t@AliasForAttributeOfDifferentType\n\tstatic class AliasForAttributeOfDifferentTypeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMissingDefaultValues {\n\n\t\t@AliasFor(attribute = \"bar\")\n\t\tString foo();\n\n\t\t@AliasFor(attribute = \"foo\")\n\t\tString bar();\n\t}\n\n\t@AliasForWithMissingDefaultValues(foo = \"foo\", bar = \"bar\")\n\tstatic class AliasForWithMissingDefaultValuesClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForAttributeWithDifferentDefaultValue {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"X\";\n\n\t\t@AliasFor(\"foo\")\n\t\tString bar() default \"Z\";\n\t}\n\n\t@AliasForAttributeWithDifferentDefaultValue\n\tstatic class AliasForAttributeWithDifferentDefaultValueClass {\n\t}\n\n\t// @ContextConfig --> Intentionally NOT meta-present\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfigNotMetaPresent {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlConfigFile();\n\t}\n\n\t@AliasedComposedContextConfigNotMetaPresent(xmlConfigFile = \"test.xml\")\n\tstatic class AliasedComposedContextConfigNotMetaPresentClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlConfigFile();\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface ImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString groovyScript() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location1() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location2() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location3() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"klass\")\n\t\tClass<?> configClass() default Object.class;\n\n\t\tString nonAliasedAttribute() default \"\";\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(groovyScript = \"groovyScript\")\n\tstatic class GroovyImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(xmlFile = \"xmlFile\")\n\tstatic class XmlImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(\"value\")\n\tstatic class ValueImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(location1 = \"location1\")\n\tstatic class Location1ImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(location2 = \"location2\")\n\tstatic class Location2ImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(location3 = \"location3\")\n\tstatic class Location3ImplicitAliasesContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig {\n\n\t\t// intentionally omitted: attribute = \"value\"\n\t\t@AliasFor(annotation = ContextConfig.class)\n\t\tString value() default \"\";\n\n\t\t// intentionally omitted: attribute = \"locations\"\n\t\t@AliasFor(annotation = ContextConfig.class)\n\t\tString location() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesWithImpliedAliasNamesOmittedContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig.class, attribute = \"location\")\n\t\tString groovy() default \"\";\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig(\"value\")\n\tstatic class ValueImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig(location = \"location\")\n\tstatic class LocationsImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig(xmlFile = \"xmlFile\")\n\tstatic class XmlFilesImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithMissingDefaultValuesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location1();\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location2();\n\t}\n\n\t@ImplicitAliasesWithMissingDefaultValuesContextConfig(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithMissingDefaultValuesContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithDifferentDefaultValuesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location1() default \"foo\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location2() default \"bar\";\n\t}\n\n\t@ImplicitAliasesWithDifferentDefaultValuesContextConfig(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithDifferentDefaultValuesContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithDuplicateValuesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location1() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location2() default \"\";\n\t}\n\n\t@ImplicitAliasesWithDuplicateValuesContextConfig(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithDuplicateValuesContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesForAliasPairContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, value = \"value\")\n\t\tString groovyScript() default \"\";\n\t}\n\n\t@ImplicitAliasesForAliasPairContextConfig(xmlFile = \"test.xml\")\n\tstatic class ImplicitAliasesForAliasPairContextConfigClass {\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScript\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@TransitiveImplicitAliasesContextConfig(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesContextConfigClass {\n\t}\n\n\t@ImplicitAliasesForAliasPairContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesForAliasPairContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesForAliasPairContextConfig.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesForAliasPairContextConfig.class, attribute = \"groovyScript\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@TransitiveImplicitAliasesForAliasPairContextConfig(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesForAliasPairContextConfigClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({})\n\t@interface Filter {\n\t\tString pattern();\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.context.annotation.ComponentScan}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScan {\n\t\tFilter[] excludeFilters() default {};\n\t}\n\n\t@ComponentScan(excludeFilters = {@Filter(pattern = \"*Foo\"), @Filter(pattern = \"*Bar\")})\n\tstatic class ComponentScanClass {\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.context.annotation.ComponentScan}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScanSingleFilter {\n\t\tFilter value();\n\t}\n\n\t@ComponentScanSingleFilter(@Filter(pattern = \"*Foo\"))\n\tstatic class ComponentScanSingleFilterClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnotationWithDefaults {\n\t\tString text() default \"enigma\";\n\t\tboolean predicate() default true;\n\t\tchar[] characters() default {'a', 'b', 'c'};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnotationWithoutDefaults {\n\t\tString text();\n\t}\n\n\t@ContextConfig(value = \"foo\", location = \"bar\")\n\tinterface ContextConfigMismatch {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(TestRepeatableContainer.class)\n\t@interface TestRepeatable {\n\n\t\tString value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestRepeatableContainer {\n\n\t\tTestRepeatable[] value();\n\t}\n\n\t@TestRepeatable(\"a\")\n\t@TestRepeatable(\"b\")\n\tstatic class TestRepeatablesClass {\n\t}\n\n\t@Deprecated\n\tstatic class DeprecatedClass {\n\t}\n\n\tstatic class SubclassOfDeprecatedClass extends DeprecatedClass {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.AliasForWithMissingDefaultValuesClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.AliasForWithMissingDefaultValuesClass",
    "headType": "class",
    "relation": "use",
    "tail": "@AliasForWithMissingDefaultValues",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AliasForWithMissingDefaultValuesClass",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Method;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.ParametersAreNonnullByDefault;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.subpackage.NonPublicAnnotatedClass;\nimport org.springframework.core.testfixture.ide.IdeUtils;\nimport org.springframework.core.testfixture.stereotype.Component;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Collectors.toList;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalStateException;\nimport static org.springframework.core.annotation.AnnotationUtils.VALUE;\nimport static org.springframework.core.annotation.AnnotationUtils.findAnnotation;\nimport static org.springframework.core.annotation.AnnotationUtils.findAnnotationDeclaringClass;\nimport static org.springframework.core.annotation.AnnotationUtils.findAnnotationDeclaringClassForTypes;\nimport static org.springframework.core.annotation.AnnotationUtils.getAnnotation;\nimport static org.springframework.core.annotation.AnnotationUtils.getAnnotationAttributes;\nimport static org.springframework.core.annotation.AnnotationUtils.getDeclaredRepeatableAnnotations;\nimport static org.springframework.core.annotation.AnnotationUtils.getDefaultValue;\nimport static org.springframework.core.annotation.AnnotationUtils.getRepeatableAnnotations;\nimport static org.springframework.core.annotation.AnnotationUtils.getValue;\nimport static org.springframework.core.annotation.AnnotationUtils.isAnnotationDeclaredLocally;\nimport static org.springframework.core.annotation.AnnotationUtils.isAnnotationInherited;\nimport static org.springframework.core.annotation.AnnotationUtils.isAnnotationMetaPresent;\nimport static org.springframework.core.annotation.AnnotationUtils.synthesizeAnnotation;\n\n/**\n * Tests for {@link AnnotationUtils}.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Chris Beams\n * @author Phillip Webb\n * @author Oleg Zhurakousky\n */\n@SuppressWarnings(\"deprecation\")\nclass AnnotationUtilsTests {\n\n\t@BeforeEach\n\tvoid clearCacheBeforeTests() {\n\t\tAnnotationUtils.clearCache();\n\t}\n\n\n\t@Test\n\tvoid findMethodAnnotationOnLeaf() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"annotatedOnLeaf\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNotNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNotNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findMethodAnnotationWithAnnotationOnMethodInInterface() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"fromInterfaceImplementedByRoot\");\n\t\t// @Order is not @Inherited\n\t\tassertThat(m.getAnnotation(Order.class)).isNull();\n\t\t// getAnnotation() does not search on interfaces\n\t\tassertThat(getAnnotation(m, Order.class)).isNull();\n\t\t// findAnnotation() does search on interfaces\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findMethodAnnotationWithMetaAnnotationOnLeaf() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"metaAnnotatedOnLeaf\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNotNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findMethodAnnotationWithMetaMetaAnnotationOnLeaf() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"metaMetaAnnotatedOnLeaf\");\n\t\tassertThat(m.getAnnotation(Component.class)).isNull();\n\t\tassertThat(getAnnotation(m, Component.class)).isNull();\n\t\tassertThat(findAnnotation(m, Component.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationOnRoot() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"annotatedOnRoot\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNotNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNotNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findMethodAnnotationWithMetaAnnotationOnRoot() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"metaAnnotatedOnRoot\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNotNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationOnRootButOverridden() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"overrideWithoutNewAnnotation\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationNotAnnotated() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"notAnnotated\");\n\t\tassertThat(findAnnotation(m, Order.class)).isNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationOnBridgeMethod() throws Exception {\n\t\tMethod bridgeMethod = SimpleFoo.class.getMethod(\"something\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(bridgeMethod.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(bridgeMethod, Order.class)).isNull();\n\t\tassertThat(findAnnotation(bridgeMethod, Order.class)).isNotNull();\n\n\t\t// As of JDK 8, invoking getAnnotation() on a bridge method actually finds an\n\t\t// annotation on its 'bridged' method [1]; however, the Eclipse compiler does\n\t\t// not support this [2]. Thus, we effectively ignore the following\n\t\t// assertion if the test is currently executing within the Eclipse IDE.\n\t\t//\n\t\t// [1] https://bugs.openjdk.java.net/browse/JDK-6695379\n\t\t// [2] https://bugs.eclipse.org/bugs/show_bug.cgi?id=495396\n\t\t//\n\t\tif (!IdeUtils.runningInEclipse()) {\n\t\t\tassertThat(bridgeMethod.getAnnotation(Transactional.class)).isNotNull();\n\t\t}\n\t\tassertThat(getAnnotation(bridgeMethod, Transactional.class)).isNotNull();\n\t\tassertThat(findAnnotation(bridgeMethod, Transactional.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationOnBridgedMethod() throws Exception {\n\t\tMethod bridgedMethod = SimpleFoo.class.getMethod(\"something\", String.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tassertThat(bridgedMethod.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(bridgedMethod, Order.class)).isNull();\n\t\tassertThat(findAnnotation(bridgedMethod, Order.class)).isNotNull();\n\n\t\tassertThat(bridgedMethod.getAnnotation(Transactional.class)).isNotNull();\n\t\tassertThat(getAnnotation(bridgedMethod, Transactional.class)).isNotNull();\n\t\tassertThat(findAnnotation(bridgedMethod, Transactional.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationFromInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test  // SPR-16060\n\tvoid findMethodAnnotationFromGenericInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test  // SPR-17146\n\tvoid findMethodAnnotationFromGenericSuperclass() throws Exception {\n\t\tMethod method = ExtendsBaseClassWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationFromInterfaceOnSuper() throws Exception {\n\t\tMethod method = SubOfImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationFromInterfaceWhenSuperDoesNotImplementMethod() throws Exception {\n\t\tMethod method = SubOfAbstractImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t// @since 4.1.2\n\t@Test\n\tvoid findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverAnnotationsOnInterfaces() {\n\t\tComponent component = findAnnotation(ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface.class, Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tassertThat(component.value()).isEqualTo(\"meta2\");\n\t}\n\n\t// @since 4.0.3\n\t@Test\n\tvoid findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedAnnotations() {\n\t\tTransactional transactional = findAnnotation(SubSubClassWithInheritedAnnotation.class, Transactional.class);\n\t\tassertThat(transactional).isNotNull();\n\t\tassertThat(transactional.readOnly()).as(\"readOnly flag for SubSubClassWithInheritedAnnotation\").isTrue();\n\t}\n\n\t// @since 4.0.3\n\t@Test\n\tvoid findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedComposedAnnotations() {\n\t\tComponent component = findAnnotation(SubSubClassWithInheritedMetaAnnotation.class, Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tassertThat(component.value()).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid findClassAnnotationOnMetaMetaAnnotatedClass() {\n\t\tComponent component = findAnnotation(MetaMetaAnnotatedClass.class, Component.class);\n\t\tassertThat(component).as(\"Should find meta-annotation on composed annotation on class\").isNotNull();\n\t\tassertThat(component.value()).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid findClassAnnotationOnMetaMetaMetaAnnotatedClass() {\n\t\tComponent component = findAnnotation(MetaMetaMetaAnnotatedClass.class, Component.class);\n\t\tassertThat(component).as(\"Should find meta-annotation on meta-annotation on composed annotation on class\").isNotNull();\n\t\tassertThat(component.value()).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid findClassAnnotationOnAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\t// TransactionalClass is NOT annotated or meta-annotated with @Component\n\t\tComponent component = findAnnotation(TransactionalClass.class, Component.class);\n\t\tassertThat(component).as(\"Should not find @Component on TransactionalClass\").isNull();\n\t}\n\n\t@Test\n\tvoid findClassAnnotationOnMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\tComponent component = findAnnotation(MetaCycleAnnotatedClass.class, Component.class);\n\t\tassertThat(component).as(\"Should not find @Component on MetaCycleAnnotatedClass\").isNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnInheritedAnnotationInterface() {\n\t\tTransactional tx = findAnnotation(InheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(tx).as(\"Should find @Transactional on InheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnSubInheritedAnnotationInterface() {\n\t\tTransactional tx = findAnnotation(SubInheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(tx).as(\"Should find @Transactional on SubInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnSubSubInheritedAnnotationInterface() {\n\t\tTransactional tx = findAnnotation(SubSubInheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(tx).as(\"Should find @Transactional on SubSubInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnNonInheritedAnnotationInterface() {\n\t\tOrder order = findAnnotation(NonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(order).as(\"Should find @Order on NonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnSubNonInheritedAnnotationInterface() {\n\t\tOrder order = findAnnotation(SubNonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(order).as(\"Should find @Order on SubNonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnSubSubNonInheritedAnnotationInterface() {\n\t\tOrder order = findAnnotation(SubSubNonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(order).as(\"Should find @Order on SubSubNonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findAnnotationDeclaringClassForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, NonAnnotatedInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, NonAnnotatedClass.class)).isNull();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, InheritedAnnotationInterface.class)).isEqualTo(InheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, SubInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, InheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, SubInheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but findAnnotationDeclaringClass() should still find it on classes.\n\t\tassertThat(findAnnotationDeclaringClass(Order.class, NonInheritedAnnotationInterface.class)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClass(Order.class, SubNonInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClass(Order.class, NonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClass(Order.class, SubNonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t}\n\n\t@Test\n\tvoid findAnnotationDeclaringClassForTypesWithSingleCandidateType() {\n\t\t// no class-level annotation\n\t\tList<Class<? extends Annotation>> transactionalCandidateList = Collections.singletonList(Transactional.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, NonAnnotatedInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, NonAnnotatedClass.class)).isNull();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, InheritedAnnotationInterface.class)).isEqualTo(InheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, SubInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, InheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, SubInheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but findAnnotationDeclaringClassForTypes() should still find it on classes.\n\t\tList<Class<? extends Annotation>> orderCandidateList = Collections.singletonList(Order.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, NonInheritedAnnotationInterface.class)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, SubNonInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, NonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, SubNonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t}\n\n\t@Test\n\tvoid findAnnotationDeclaringClassForTypesWithMultipleCandidateTypes() {\n\t\tList<Class<? extends Annotation>> candidates = asList(Transactional.class, Order.class);\n\n\t\t// no class-level annotation\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, NonAnnotatedInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, NonAnnotatedClass.class)).isNull();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, InheritedAnnotationInterface.class)).isEqualTo(InheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, InheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubInheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but findAnnotationDeclaringClassForTypes() should still find it on classes.\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, NonInheritedAnnotationInterface.class)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubNonInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, NonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubNonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\n\t\t// class hierarchy mixed with @Transactional and @Order declarations\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, TransactionalClass.class)).isEqualTo(TransactionalClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, TransactionalAndOrderedClass.class)).isEqualTo(TransactionalAndOrderedClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubTransactionalAndOrderedClass.class)).isEqualTo(TransactionalAndOrderedClass.class);\n\t}\n\n\t@Test\n\tvoid isAnnotationDeclaredLocallyForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, NonAnnotatedInterface.class)).isFalse();\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, NonAnnotatedClass.class)).isFalse();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, InheritedAnnotationInterface.class)).isTrue();\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, SubInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, InheritedAnnotationClass.class)).isTrue();\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, SubInheritedAnnotationClass.class)).isFalse();\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited\n\t\tassertThat(isAnnotationDeclaredLocally(Order.class, NonInheritedAnnotationInterface.class)).isTrue();\n\t\tassertThat(isAnnotationDeclaredLocally(Order.class, SubNonInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationDeclaredLocally(Order.class, NonInheritedAnnotationClass.class)).isTrue();\n\t\tassertThat(isAnnotationDeclaredLocally(Order.class, SubNonInheritedAnnotationClass.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotationInheritedForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(isAnnotationInherited(Transactional.class, NonAnnotatedInterface.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Transactional.class, NonAnnotatedClass.class)).isFalse();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(isAnnotationInherited(Transactional.class, InheritedAnnotationInterface.class)).isFalse();\n\t\t// isAnnotationInherited() does not currently traverse interface hierarchies.\n\t\t// Thus the following, though perhaps counterintuitive, must be false:\n\t\tassertThat(isAnnotationInherited(Transactional.class, SubInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Transactional.class, InheritedAnnotationClass.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Transactional.class, SubInheritedAnnotationClass.class)).isTrue();\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited\n\t\tassertThat(isAnnotationInherited(Order.class, NonInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Order.class, SubNonInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Order.class, NonInheritedAnnotationClass.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Order.class, SubNonInheritedAnnotationClass.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotationMetaPresentForPlainType() {\n\t\tassertThat(isAnnotationMetaPresent(Order.class, Documented.class)).isTrue();\n\t\tassertThat(isAnnotationMetaPresent(ParametersAreNonnullByDefault.class, Documented.class)).isTrue();\n\t\tassertThat(isAnnotationMetaPresent(ParametersAreNonnullByDefault.class, Nonnull.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributesWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\n\t\tAnnotationAttributes attributes = (AnnotationAttributes) getAnnotationAttributes(component);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.getString(VALUE)).as(\"value attribute: \").isEqualTo(\"webController\");\n\t\tassertThat(attributes.annotationType()).isEqualTo(Component.class);\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributesWithNestedAnnotations() {\n\t\tComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class);\n\t\tassertThat(componentScan).isNotNull();\n\n\t\tAnnotationAttributes attributes = getAnnotationAttributes(ComponentScanClass.class, componentScan);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(ComponentScan.class);\n\n\t\tFilter[] filters = attributes.getAnnotationArray(\"excludeFilters\", Filter.class);\n\t\tassertThat(filters).isNotNull();\n\n\t\tList<String> patterns = stream(filters).map(Filter::pattern).collect(toList());\n\t\tassertThat(patterns).isEqualTo(asList(\"*Foo\", \"*Bar\"));\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributesWithAttributeAliases() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\t\tWebMapping webMapping = method.getAnnotation(WebMapping.class);\n\t\tAnnotationAttributes attributes = (AnnotationAttributes) getAnnotationAttributes(webMapping);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(WebMapping.class);\n\t\tassertThat(attributes.getString(\"name\")).as(\"name attribute: \").isEqualTo(\"foo\");\n\t\tassertThat(attributes.getStringArray(VALUE)).as(\"value attribute: \").isEqualTo(asArray(\"/test\"));\n\t\tassertThat(attributes.getStringArray(\"path\")).as(\"path attribute: \").isEqualTo(asArray(\"/test\"));\n\n\t\tmethod = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\twebMapping = method.getAnnotation(WebMapping.class);\n\t\tattributes = (AnnotationAttributes) getAnnotationAttributes(webMapping);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(WebMapping.class);\n\t\tassertThat(attributes.getString(\"name\")).as(\"name attribute: \").isEqualTo(\"bar\");\n\t\tassertThat(attributes.getStringArray(VALUE)).as(\"value attribute: \").isEqualTo(asArray(\"/test\"));\n\t\tassertThat(attributes.getStringArray(\"path\")).as(\"path attribute: \").isEqualTo(asArray(\"/test\"));\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributesWithAttributeAliasesWithDifferentValues() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithDifferentPathAndValueAttributes\");\n\t\tWebMapping webMapping = method.getAnnotation(WebMapping.class);\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tgetAnnotationAttributes(webMapping))\n\t\t\t.withMessageContaining(\"attribute 'path' and its alias 'value'\")\n\t\t\t.withMessageContaining(\"values of [{/test}] and [{/enigma}]\");\n\t}\n\n\t@Test\n\tvoid getValueFromAnnotation() throws Exception {\n\t\tMethod method = SimpleFoo.class.getMethod(\"something\", Object.class);\n\t\tOrder order = findAnnotation(method, Order.class);\n\n\t\tassertThat(getValue(order, VALUE)).isEqualTo(1);\n\t\tassertThat(getValue(order)).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getValueFromNonPublicAnnotation() {\n\t\tAnnotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\n\t\tassertThat(declaredAnnotations).hasSize(1);\n\t\tAnnotation annotation = declaredAnnotations[0];\n\t\tassertThat(annotation).isNotNull();\n\t\tassertThat(annotation.annotationType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\n\t\tassertThat(getValue(annotation, VALUE)).isEqualTo(42);\n\t\tassertThat(getValue(annotation)).isEqualTo(42);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromAnnotation() throws Exception {\n\t\tMethod method = SimpleFoo.class.getMethod(\"something\", Object.class);\n\t\tOrder order = findAnnotation(method, Order.class);\n\n\t\tassertThat(getDefaultValue(order, VALUE)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\n\t\tassertThat(getDefaultValue(order)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromNonPublicAnnotation() {\n\t\tAnnotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\n\t\tassertThat(declaredAnnotations).hasSize(1);\n\t\tAnnotation annotation = declaredAnnotations[0];\n\t\tassertThat(annotation).isNotNull();\n\t\tassertThat(annotation.annotationType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\n\t\tassertThat(getDefaultValue(annotation, VALUE)).isEqualTo(-1);\n\t\tassertThat(getDefaultValue(annotation)).isEqualTo(-1);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromAnnotationType() {\n\t\tassertThat(getDefaultValue(Order.class, VALUE)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\n\t\tassertThat(getDefaultValue(Order.class)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Test\n\tvoid findRepeatableAnnotation() {\n\t\tRepeatable repeatable = findAnnotation(MyRepeatable.class, Repeatable.class);\n\t\tassertThat(repeatable).isNotNull();\n\t\tassertThat(repeatable.value()).isEqualTo(MyRepeatableContainer.class);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnMethod() throws Exception {\n\t\tMethod method = InterfaceWithRepeated.class.getMethod(\"foo\");\n\t\tSet<MyRepeatable> annotations = getRepeatableAnnotations(method, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(annotations).isNotNull();\n\t\tList<String> values = annotations.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(asList(\"A\", \"B\", \"C\", \"meta1\"));\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnClassWithAttributeAliases() {\n\t\tfinal List<String> expectedLocations = asList(\"A\", \"B\");\n\n\t\tSet<ContextConfig> annotations = getRepeatableAnnotations(ConfigHierarchyTestCase.class, ContextConfig.class, null);\n\t\tassertThat(annotations).isNotNull();\n\t\tassertThat(annotations).as(\"size if container type is omitted: \").isEmpty();\n\n\t\tannotations = getRepeatableAnnotations(ConfigHierarchyTestCase.class, ContextConfig.class, Hierarchy.class);\n\t\tassertThat(annotations).isNotNull();\n\n\t\tList<String> locations = annotations.stream().map(ContextConfig::location).collect(toList());\n\t\tassertThat(locations).isEqualTo(expectedLocations);\n\n\t\tList<String> values = annotations.stream().map(ContextConfig::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedLocations);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnClass() {\n\t\tfinal List<String> expectedValuesJava = asList(\"A\", \"B\", \"C\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"A\", \"B\", \"C\", \"meta1\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = MyRepeatableClass.class.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnSuperclass() {\n\t\tfinal Class<?> clazz = SubMyRepeatableClass.class;\n\t\tfinal List<String> expectedValuesJava = asList(\"A\", \"B\", \"C\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"A\", \"B\", \"C\", \"meta1\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getRepeatableAnnotations(clazz, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnClassAndSuperclass() {\n\t\tfinal Class<?> clazz = SubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\n\t\tfinal List<String> expectedValuesJava = asList(\"X\", \"Y\", \"Z\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"X\", \"Y\", \"Z\", \"meta2\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getRepeatableAnnotations(clazz, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnMultipleSuperclasses() {\n\t\tfinal Class<?> clazz = SubSubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\n\t\tfinal List<String> expectedValuesJava = asList(\"X\", \"Y\", \"Z\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"X\", \"Y\", \"Z\", \"meta2\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getRepeatableAnnotations(clazz, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getDeclaredRepeatableAnnotationsDeclaredOnClass() {\n\t\tfinal List<String> expectedValuesJava = asList(\"A\", \"B\", \"C\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"A\", \"B\", \"C\", \"meta1\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = MyRepeatableClass.class.getDeclaredAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getDeclaredRepeatableAnnotations(\n\t\t\t\tMyRepeatableClass.class, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getDeclaredRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getDeclaredRepeatableAnnotationsDeclaredOnSuperclass() {\n\t\tfinal Class<?> clazz = SubMyRepeatableClass.class;\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = clazz.getDeclaredAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tassertThat(array).isEmpty();\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getDeclaredRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tassertThat(set).isEmpty();\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getDeclaredRepeatableAnnotations(clazz, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tassertThat(set).isEmpty();\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationWithImplicitAliasesWithMissingDefaultValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithMissingDefaultValuesContextConfigClass.class;\n\t\tClass<ImplicitAliasesWithMissingDefaultValuesContextConfig> annotationType =\n\t\t\t\tImplicitAliasesWithMissingDefaultValuesContextConfig.class;\n\t\tImplicitAliasesWithMissingDefaultValuesContextConfig config = clazz.getAnnotation(annotationType);\n\t\tassertThat(config).isNotNull();\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(config, clazz))\n\t\t\t.withMessageStartingWith(\"Misconfigured aliases:\")\n\t\t\t.withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t.withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t.withMessageContaining(\"default values\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationWithImplicitAliasesWithDifferentDefaultValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithDifferentDefaultValuesContextConfigClass.class;\n\t\tClass<ImplicitAliasesWithDifferentDefaultValuesContextConfig> annotationType =\n\t\t\t\tImplicitAliasesWithDifferentDefaultValuesContextConfig.class;\n\t\tImplicitAliasesWithDifferentDefaultValuesContextConfig config = clazz.getAnnotation(annotationType);\n\t\tassertThat(config).isNotNull();\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(config, clazz))\n\t\t\t.withMessageStartingWith(\"Misconfigured aliases:\")\n\t\t\t.withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t.withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t.withMessageContaining(\"same default value\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationWithImplicitAliasesWithDuplicateValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithDuplicateValuesContextConfigClass.class;\n\t\tClass<ImplicitAliasesWithDuplicateValuesContextConfig> annotationType =\n\t\t\t\tImplicitAliasesWithDuplicateValuesContextConfig.class;\n\t\tImplicitAliasesWithDuplicateValuesContextConfig config = clazz.getAnnotation(annotationType);\n\t\tassertThat(config).isNotNull();\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(config, clazz).location1())\n\t\t\t.withMessageStartingWith(\"Different @AliasFor mirror values\")\n\t\t\t.withMessageContaining(annotationType.getName())\n\t\t\t.withMessageContaining(\"declared on class\")\n\t\t\t.withMessageContaining(clazz.getName())\n\t\t\t.withMessageContaining(\"attribute 'location1' and its alias 'location2'\")\n\t\t\t.withMessageContaining(\"with values of [1] and [2]\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\n\t\tMap<String, Object> map = Collections.singletonMap(VALUE, \"webController\");\n\t\tComponent synthesizedComponent = synthesizeAnnotation(map, Component.class, WebController.class);\n\t\tassertThat(synthesizedComponent).isNotNull();\n\n\t\tassertThat(synthesizedComponent).isNotSameAs(component);\n\t\tassertThat(component.value()).as(\"value from component: \").isEqualTo(\"webController\");\n\t\tassertThat(synthesizedComponent.value()).as(\"value from synthesized component: \").isEqualTo(\"webController\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeAnnotationFromMapWithNestedMap() {\n\t\tComponentScanSingleFilter componentScan =\n\t\t\t\tComponentScanSingleFilterClass.class.getAnnotation(ComponentScanSingleFilter.class);\n\t\tassertThat(componentScan).isNotNull();\n\t\tassertThat(componentScan.value().pattern()).as(\"value from ComponentScan: \").isEqualTo(\"*Foo\");\n\n\t\tAnnotationAttributes attributes = getAnnotationAttributes(\n\t\t\t\tComponentScanSingleFilterClass.class, componentScan, false, true);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(ComponentScanSingleFilter.class);\n\n\t\tMap<String, Object> filterMap = (Map<String, Object>) attributes.get(\"value\");\n\t\tassertThat(filterMap).isNotNull();\n\t\tassertThat(filterMap.get(\"pattern\")).isEqualTo(\"*Foo\");\n\n\t\t// Modify nested map\n\t\tfilterMap.put(\"pattern\", \"newFoo\");\n\t\tfilterMap.put(\"enigma\", 42);\n\n\t\tComponentScanSingleFilter synthesizedComponentScan = synthesizeAnnotation(\n\t\t\t\tattributes, ComponentScanSingleFilter.class, ComponentScanSingleFilterClass.class);\n\t\tassertThat(synthesizedComponentScan).isNotNull();\n\n\t\tassertThat(synthesizedComponentScan).isNotSameAs(componentScan);\n\t\tassertThat(synthesizedComponentScan.value().pattern()).as(\"value from synthesized ComponentScan: \").isEqualTo(\"newFoo\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeAnnotationFromMapWithNestedArrayOfMaps() {\n\t\tComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class);\n\t\tassertThat(componentScan).isNotNull();\n\n\t\tAnnotationAttributes attributes = getAnnotationAttributes(ComponentScanClass.class, componentScan, false, true);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(ComponentScan.class);\n\n\t\tMap<String, Object>[] filters = (Map[]) attributes.get(\"excludeFilters\");\n\t\tassertThat(filters).isNotNull();\n\n\t\tList<String> patterns = stream(filters).map(m -> (String) m.get(\"pattern\")).collect(toList());\n\t\tassertThat(patterns).isEqualTo(asList(\"*Foo\", \"*Bar\"));\n\n\t\t// Modify nested maps\n\t\tfilters[0].put(\"pattern\", \"newFoo\");\n\t\tfilters[0].put(\"enigma\", 42);\n\t\tfilters[1].put(\"pattern\", \"newBar\");\n\t\tfilters[1].put(\"enigma\", 42);\n\n\t\tComponentScan synthesizedComponentScan =\n\t\t\t\tsynthesizeAnnotation(attributes, ComponentScan.class, ComponentScanClass.class);\n\t\tassertThat(synthesizedComponentScan).isNotNull();\n\n\t\tassertThat(synthesizedComponentScan).isNotSameAs(componentScan);\n\t\tpatterns = stream(synthesizedComponentScan.excludeFilters()).map(Filter::pattern).collect(toList());\n\t\tassertThat(patterns).isEqualTo(asList(\"newFoo\", \"newBar\"));\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromDefaultsWithoutAttributeAliases() {\n\t\tAnnotationWithDefaults annotationWithDefaults = synthesizeAnnotation(AnnotationWithDefaults.class);\n\t\tassertThat(annotationWithDefaults).isNotNull();\n\t\tassertThat(annotationWithDefaults.text()).as(\"text: \").isEqualTo(\"enigma\");\n\t\tassertThat(annotationWithDefaults.predicate()).as(\"predicate: \").isTrue();\n\t\tassertThat(annotationWithDefaults.characters()).as(\"characters: \").isEqualTo(new char[] { 'a', 'b', 'c' });\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromDefaultsWithAttributeAliases() {\n\t\tContextConfig contextConfig = synthesizeAnnotation(ContextConfig.class);\n\t\tassertThat(contextConfig).isNotNull();\n\t\tassertThat(contextConfig.value()).as(\"value: \").isEmpty();\n\t\tassertThat(contextConfig.location()).as(\"location: \").isEmpty();\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithMinimalAttributesWithAttributeAliases() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"location\", \"test.xml\");\n\t\tContextConfig contextConfig = synthesizeAnnotation(map, ContextConfig.class, null);\n\t\tassertThat(contextConfig).isNotNull();\n\t\tassertThat(contextConfig.value()).as(\"value: \").isEqualTo(\"test.xml\");\n\t\tassertThat(contextConfig.location()).as(\"location: \").isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"value\", \"/foo\");\n\t\tGet get = synthesizeAnnotation(map, Get.class, null);\n\t\tassertThat(get).isNotNull();\n\t\tassertThat(get.value()).as(\"value: \").isEqualTo(\"/foo\");\n\t\tassertThat(get.path()).as(\"path: \").isEqualTo(\"/foo\");\n\n\t\tmap = Collections.singletonMap(\"path\", \"/foo\");\n\t\tget = synthesizeAnnotation(map, Get.class, null);\n\t\tassertThat(get).isNotNull();\n\t\tassertThat(get.value()).as(\"value: \").isEqualTo(\"/foo\");\n\t\tassertThat(get.path()).as(\"path: \").isEqualTo(\"/foo\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithImplicitAttributeAliases() {\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"value\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"location1\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"location2\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"location3\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"xmlFile\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"groovyScript\");\n\t}\n\n\tprivate void assertAnnotationSynthesisFromMapWithImplicitAliases(String attributeNameAndValue) {\n\t\tMap<String, Object> map = Collections.singletonMap(attributeNameAndValue, attributeNameAndValue);\n\t\tImplicitAliasesContextConfig config = synthesizeAnnotation(map, ImplicitAliasesContextConfig.class, null);\n\t\tassertThat(config).isNotNull();\n\t\tassertThat(config.value()).as(\"value: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.location1()).as(\"location1: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.location2()).as(\"location2: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.location3()).as(\"location3: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.xmlFile()).as(\"xmlFile: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.groovyScript()).as(\"groovyScript: \").isEqualTo(attributeNameAndValue);\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithMissingAttributeValue() {\n\t\tassertMissingTextAttribute(Collections.emptyMap());\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithNullAttributeValue() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"text\", null);\n\t\tassertThat(map.containsKey(\"text\")).isTrue();\n\t\tassertMissingTextAttribute(map);\n\t}\n\n\tprivate void assertMissingTextAttribute(Map<String, Object> attributes) {\n\t\tassertThatExceptionOfType(NoSuchElementException.class).isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(attributes, AnnotationWithoutDefaults.class, null).text())\n\t\t\t.withMessageContaining(\"No value found for attribute named 'text' in merged annotation\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithAttributeOfIncorrectType() {\n\t\tMap<String, Object> map = Collections.singletonMap(VALUE, 42L);\n\t\tassertThatIllegalStateException().isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(map, Component.class, null).value())\n\t\t\t.withMessageContaining(\"Attribute 'value' in annotation org.springframework.core.testfixture.stereotype.Component \"\n\t\t\t\t\t+ \"should be compatible with java.lang.String but a java.lang.Long value was returned\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromAnnotationAttributesWithoutAttributeAliases() {\n\t\t// 1) Get an annotation\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\n\t\t// 2) Convert the annotation into AnnotationAttributes\n\t\tAnnotationAttributes attributes = getAnnotationAttributes(WebController.class, component);\n\t\tassertThat(attributes).isNotNull();\n\n\t\t// 3) Synthesize the AnnotationAttributes back into an annotation\n\t\tComponent synthesizedComponent = synthesizeAnnotation(attributes, Component.class, WebController.class);\n\t\tassertThat(synthesizedComponent).isNotNull();\n\n\t\t// 4) Verify that the original and synthesized annotations are equivalent\n\t\tassertThat(synthesizedComponent).isNotSameAs(component);\n\t\tassertThat(synthesizedComponent).isEqualTo(component);\n\t\tassertThat(component.value()).as(\"value from component: \").isEqualTo(\"webController\");\n\t\tassertThat(synthesizedComponent.value()).as(\"value from synthesized component: \").isEqualTo(\"webController\");\n\t}\n\n\t@Test  // gh-22702\n\tvoid findAnnotationWithRepeatablesElements() {\n\t\tassertThat(AnnotationUtils.findAnnotation(TestRepeatablesClass.class,\n\t\t\t\tTestRepeatable.class)).isNull();\n\t\tassertThat(AnnotationUtils.findAnnotation(TestRepeatablesClass.class,\n\t\tTestRepeatableContainer.class)).isNotNull();\n\t}\n\n\t@Test  // gh-23856\n\tvoid findAnnotationFindsRepeatableContainerOnComposedAnnotationMetaAnnotatedWithRepeatableAnnotations() {\n\t\tMyRepeatableContainer annotation = AnnotationUtils.findAnnotation(MyRepeatableMeta1And2.class, MyRepeatableContainer.class);\n\n\t\tassertThat(annotation).isNotNull();\n\t\tassertThat(annotation.value()).extracting(MyRepeatable::value).containsExactly(\"meta1\", \"meta2\");\n\t}\n\n\t@Test  // gh-23856\n\tvoid findAnnotationFindsRepeatableContainerOnComposedAnnotationMetaAnnotatedWithRepeatableAnnotationsOnMethod() throws Exception {\n\t\tMethod method = getClass().getDeclaredMethod(\"methodWithComposedAnnotationMetaAnnotatedWithRepeatableAnnotations\");\n\t\tMyRepeatableContainer annotation = AnnotationUtils.findAnnotation(method, MyRepeatableContainer.class);\n\n\t\tassertThat(annotation).isNotNull();\n\t\tassertThat(annotation.value()).extracting(MyRepeatable::value).containsExactly(\"meta1\", \"meta2\");\n\t}\n\n\t@Test  // gh-23929\n\tvoid findDeprecatedAnnotation() {\n\t\tassertThat(getAnnotation(DeprecatedClass.class, Deprecated.class)).isNotNull();\n\t\tassertThat(getAnnotation(SubclassOfDeprecatedClass.class, Deprecated.class)).isNull();\n\t\tassertThat(findAnnotation(DeprecatedClass.class, Deprecated.class)).isNotNull();\n\t\tassertThat(findAnnotation(SubclassOfDeprecatedClass.class, Deprecated.class)).isNotNull();\n\t}\n\n\n\t@SafeVarargs\n\tstatic <T> T[] asArray(T... arr) {\n\t\treturn arr;\n\t}\n\n\n\t@Component(\"meta1\")\n\t@Order\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Meta1 {\n\t}\n\n\t@Component(\"meta2\")\n\t@Transactional(readOnly = true)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Meta2 {\n\t}\n\n\t@Meta2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMeta {\n\t}\n\n\t@MetaMeta\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMetaMeta {\n\t}\n\n\t@MetaCycle3\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle1 {\n\t}\n\n\t@MetaCycle1\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle2 {\n\t}\n\n\t@MetaCycle2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle3 {\n\t}\n\n\t@Meta1\n\tinterface InterfaceWithMetaAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface implements InterfaceWithMetaAnnotation {\n\t}\n\n\t@Meta1\n\tstatic class ClassWithInheritedMetaAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class SubClassWithInheritedMetaAnnotation extends ClassWithInheritedMetaAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedMetaAnnotation extends SubClassWithInheritedMetaAnnotation {\n\t}\n\n\t@Transactional\n\tstatic class ClassWithInheritedAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class SubClassWithInheritedAnnotation extends ClassWithInheritedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedAnnotation extends SubClassWithInheritedAnnotation {\n\t}\n\n\t@MetaMeta\n\tstatic class MetaMetaAnnotatedClass {\n\t}\n\n\t@MetaMetaMeta\n\tstatic class MetaMetaMetaAnnotatedClass {\n\t}\n\n\t@MetaCycle3\n\tstatic class MetaCycleAnnotatedClass {\n\t}\n\n\tpublic interface AnnotatedInterface {\n\n\t\t@Order(0)\n\t\tvoid fromInterfaceImplementedByRoot();\n\t}\n\n\tpublic static class Root implements AnnotatedInterface {\n\n\t\t@Order(27)\n\t\tpublic void annotatedOnRoot() {\n\t\t}\n\n\t\t@Meta1\n\t\tpublic void metaAnnotatedOnRoot() {\n\t\t}\n\n\t\tpublic void overrideToAnnotate() {\n\t\t}\n\n\t\t@Order(27)\n\t\tpublic void overrideWithoutNewAnnotation() {\n\t\t}\n\n\t\tpublic void notAnnotated() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void fromInterfaceImplementedByRoot() {\n\t\t}\n\t}\n\n\tpublic static class Leaf extends Root {\n\n\t\t@Order(25)\n\t\tpublic void annotatedOnLeaf() {\n\t\t}\n\n\t\t@Meta1\n\t\tpublic void metaAnnotatedOnLeaf() {\n\t\t}\n\n\t\t@MetaMeta\n\t\tpublic void metaMetaAnnotatedOnLeaf() {\n\t\t}\n\n\t\t@Override\n\t\t@Order(1)\n\t\tpublic void overrideToAnnotate() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void overrideWithoutNewAnnotation() {\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Transactional {\n\n\t\tboolean readOnly() default false;\n\t}\n\n\tpublic abstract static class Foo<T> {\n\n\t\t@Order(1)\n\t\tpublic abstract void something(T arg);\n\t}\n\n\tpublic static class SimpleFoo extends Foo<String> {\n\n\t\t@Override\n\t\t@Transactional\n\t\tpublic void something(final String arg) {\n\t\t}\n\t}\n\n\t@Transactional\n\tpublic interface InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubInheritedAnnotationInterface extends InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubInheritedAnnotationInterface extends SubInheritedAnnotationInterface {\n\t}\n\n\t@Order\n\tpublic interface NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubNonInheritedAnnotationInterface extends NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubNonInheritedAnnotationInterface extends SubNonInheritedAnnotationInterface {\n\t}\n\n\tpublic static class NonAnnotatedClass {\n\t}\n\n\tpublic interface NonAnnotatedInterface {\n\t}\n\n\t@Transactional\n\tpublic static class InheritedAnnotationClass {\n\t}\n\n\tpublic static class SubInheritedAnnotationClass extends InheritedAnnotationClass {\n\t}\n\n\t@Order\n\tpublic static class NonInheritedAnnotationClass {\n\t}\n\n\tpublic static class SubNonInheritedAnnotationClass extends NonInheritedAnnotationClass {\n\t}\n\n\t@Transactional\n\tpublic static class TransactionalClass {\n\t}\n\n\t@Order\n\tpublic static class TransactionalAndOrderedClass extends TransactionalClass {\n\t}\n\n\tpublic static class SubTransactionalAndOrderedClass extends TransactionalAndOrderedClass {\n\t}\n\n\tpublic interface InterfaceWithAnnotatedMethod {\n\n\t\t@Order\n\t\tvoid foo();\n\t}\n\n\tpublic static class ImplementsInterfaceWithAnnotatedMethod implements InterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic static class SubOfImplementsInterfaceWithAnnotatedMethod extends ImplementsInterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic abstract static class AbstractDoesNotImplementInterfaceWithAnnotatedMethod\n\t\t\timplements InterfaceWithAnnotatedMethod {\n\t}\n\n\tpublic static class SubOfAbstractImplementsInterfaceWithAnnotatedMethod\n\t\t\textends AbstractDoesNotImplementInterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic interface InterfaceWithGenericAnnotatedMethod<T> {\n\n\t\t@Order\n\t\tvoid foo(T t);\n\t}\n\n\tpublic static class ImplementsInterfaceWithGenericAnnotatedMethod implements InterfaceWithGenericAnnotatedMethod<String> {\n\n\t\t@Override\n\t\tpublic void foo(String t) {\n\t\t}\n\t}\n\n\tpublic abstract static class BaseClassWithGenericAnnotatedMethod<T> {\n\n\t\t@Order\n\t\tabstract void foo(T t);\n\t}\n\n\tpublic static class ExtendsBaseClassWithGenericAnnotatedMethod extends BaseClassWithGenericAnnotatedMethod<String> {\n\n\t\t@Override\n\t\tpublic void foo(String t) {\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface MyRepeatableContainer {\n\n\t\tMyRepeatable[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@Repeatable(MyRepeatableContainer.class)\n\t@interface MyRepeatable {\n\n\t\tString value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta1\")\n\t@interface MyRepeatableMeta1 {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta2\")\n\t@interface MyRepeatableMeta2 {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta1\")\n\t@MyRepeatable(\"meta2\")\n\t@interface MyRepeatableMeta1And2 {\n\t}\n\n\t@MyRepeatableMeta1And2\n\tvoid methodWithComposedAnnotationMetaAnnotatedWithRepeatableAnnotations() {\n\t}\n\n\tinterface InterfaceWithRepeated {\n\n\t\t@MyRepeatable(\"A\")\n\t\t@MyRepeatableContainer({@MyRepeatable(\"B\"), @MyRepeatable(\"C\")})\n\t\t@MyRepeatableMeta1\n\t\tvoid foo();\n\t}\n\n\t@MyRepeatable(\"A\")\n\t@MyRepeatableContainer({@MyRepeatable(\"B\"), @MyRepeatable(\"C\")})\n\t@MyRepeatableMeta1\n\tstatic class MyRepeatableClass {\n\t}\n\n\tstatic class SubMyRepeatableClass extends MyRepeatableClass {\n\t}\n\n\t@MyRepeatable(\"X\")\n\t@MyRepeatableContainer({@MyRepeatable(\"Y\"), @MyRepeatable(\"Z\")})\n\t@MyRepeatableMeta2\n\tstatic class SubMyRepeatableWithAdditionalLocalDeclarationsClass extends MyRepeatableClass {\n\t}\n\n\tstatic class SubSubMyRepeatableWithAdditionalLocalDeclarationsClass extends\n\t\t\tSubMyRepeatableWithAdditionalLocalDeclarationsClass {\n\t}\n\n\tenum RequestMethod {\n\t\tGET, POST\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.web.bind.annotation.RequestMapping}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface WebMapping {\n\n\t\tString name();\n\n\t\t@AliasFor(\"path\")\n\t\tString[] value() default \"\";\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tString[] path() default \"\";\n\n\t\tRequestMethod[] method() default {};\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.web.bind.annotation.GetMapping}, except\n\t * that the String arrays are overridden with single String elements.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@WebMapping(method = RequestMethod.GET, name = \"\")\n\t@interface Get {\n\n\t\t@AliasFor(annotation = WebMapping.class)\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = WebMapping.class)\n\t\tString path() default \"\";\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.web.bind.annotation.PostMapping}, except\n\t * that the path is overridden by convention with single String element.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@WebMapping(method = RequestMethod.POST, name = \"\")\n\t@interface Post {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = WebMapping.class)\n\t\tString path() default \"\";\n\t}\n\n\t@Component(\"webController\")\n\tstatic class WebController {\n\n\t\t@WebMapping(value = \"/test\", name = \"foo\")\n\t\tpublic void handleMappedWithValueAttribute() {\n\t\t}\n\n\t\t@WebMapping(path = \"/test\", name = \"bar\", method = { RequestMethod.GET, RequestMethod.POST })\n\t\tpublic void handleMappedWithPathAttribute() {\n\t\t}\n\n\t\t@Get(\"/test\")\n\t\tpublic void getMappedWithValueAttribute() {\n\t\t}\n\n\t\t@Get(path = \"/test\")\n\t\tpublic void getMappedWithPathAttribute() {\n\t\t}\n\n\t\t@Post(path = \"/test\")\n\t\tpublic void postMappedWithPathAttribute() {\n\t\t}\n\n\t\t/**\n\t\t * mapping is logically \"equal\" to handleMappedWithPathAttribute().\n\t\t */\n\t\t@WebMapping(value = \"/test\", path = \"/test\", name = \"bar\", method = { RequestMethod.GET, RequestMethod.POST })\n\t\tpublic void handleMappedWithSamePathAndValueAttributes() {\n\t\t}\n\n\t\t@WebMapping(value = \"/enigma\", path = \"/test\", name = \"baz\")\n\t\tpublic void handleMappedWithDifferentPathAndValueAttributes() {\n\t\t}\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.test.context.ContextConfiguration}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContextConfig {\n\n\t\t@AliasFor(\"location\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString location() default \"\";\n\n\t\tClass<?> klass() default Object.class;\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.test.context.ContextHierarchy}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Hierarchy {\n\t\tContextConfig[] value();\n\t}\n\n\t@Hierarchy({@ContextConfig(\"A\"), @ContextConfig(location = \"B\")})\n\tstatic class ConfigHierarchyTestCase {\n\t}\n\n\t@ContextConfig(\"simple.xml\")\n\tstatic class SimpleConfigTestCase {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface CharsContainer {\n\n\t\t@AliasFor(attribute = \"chars\")\n\t\tchar[] value() default {};\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tchar[] chars() default {};\n\t}\n\n\t@CharsContainer(chars = { 'x', 'y', 'z' })\n\tstatic class GroupOfCharsClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMissingAttributeDeclaration {\n\n\t\t@AliasFor\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForWithMissingAttributeDeclaration\n\tstatic class AliasForWithMissingAttributeDeclarationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithDuplicateAttributeDeclaration {\n\n\t\t@AliasFor(value = \"bar\", attribute = \"baz\")\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForWithDuplicateAttributeDeclaration\n\tstatic class AliasForWithDuplicateAttributeDeclarationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForNonexistentAttribute {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForNonexistentAttribute\n\tstatic class AliasForNonexistentAttributeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithoutMirroredAliasFor {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"\";\n\n\t\tString bar() default \"\";\n\t}\n\n\t@AliasForWithoutMirroredAliasFor\n\tstatic class AliasForWithoutMirroredAliasForClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMirroredAliasForWrongAttribute {\n\n\t\t@AliasFor(attribute = \"bar\")\n\t\tString[] foo() default \"\";\n\n\t\t@AliasFor(attribute = \"quux\")\n\t\tString[] bar() default \"\";\n\t}\n\n\t@AliasForWithMirroredAliasForWrongAttribute\n\tstatic class AliasForWithMirroredAliasForWrongAttributeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForAttributeOfDifferentType {\n\n\t\t@AliasFor(\"bar\")\n\t\tString[] foo() default \"\";\n\n\t\t@AliasFor(\"foo\")\n\t\tboolean bar() default true;\n\t}\n\n\t@AliasForAttributeOfDifferentType\n\tstatic class AliasForAttributeOfDifferentTypeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMissingDefaultValues {\n\n\t\t@AliasFor(attribute = \"bar\")\n\t\tString foo();\n\n\t\t@AliasFor(attribute = \"foo\")\n\t\tString bar();\n\t}\n\n\t@AliasForWithMissingDefaultValues(foo = \"foo\", bar = \"bar\")\n\tstatic class AliasForWithMissingDefaultValuesClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForAttributeWithDifferentDefaultValue {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"X\";\n\n\t\t@AliasFor(\"foo\")\n\t\tString bar() default \"Z\";\n\t}\n\n\t@AliasForAttributeWithDifferentDefaultValue\n\tstatic class AliasForAttributeWithDifferentDefaultValueClass {\n\t}\n\n\t// @ContextConfig --> Intentionally NOT meta-present\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfigNotMetaPresent {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlConfigFile();\n\t}\n\n\t@AliasedComposedContextConfigNotMetaPresent(xmlConfigFile = \"test.xml\")\n\tstatic class AliasedComposedContextConfigNotMetaPresentClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlConfigFile();\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface ImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString groovyScript() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location1() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location2() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location3() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"klass\")\n\t\tClass<?> configClass() default Object.class;\n\n\t\tString nonAliasedAttribute() default \"\";\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(groovyScript = \"groovyScript\")\n\tstatic class GroovyImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(xmlFile = \"xmlFile\")\n\tstatic class XmlImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(\"value\")\n\tstatic class ValueImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(location1 = \"location1\")\n\tstatic class Location1ImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(location2 = \"location2\")\n\tstatic class Location2ImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(location3 = \"location3\")\n\tstatic class Location3ImplicitAliasesContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig {\n\n\t\t// intentionally omitted: attribute = \"value\"\n\t\t@AliasFor(annotation = ContextConfig.class)\n\t\tString value() default \"\";\n\n\t\t// intentionally omitted: attribute = \"locations\"\n\t\t@AliasFor(annotation = ContextConfig.class)\n\t\tString location() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesWithImpliedAliasNamesOmittedContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig.class, attribute = \"location\")\n\t\tString groovy() default \"\";\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig(\"value\")\n\tstatic class ValueImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig(location = \"location\")\n\tstatic class LocationsImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig(xmlFile = \"xmlFile\")\n\tstatic class XmlFilesImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithMissingDefaultValuesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location1();\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location2();\n\t}\n\n\t@ImplicitAliasesWithMissingDefaultValuesContextConfig(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithMissingDefaultValuesContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithDifferentDefaultValuesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location1() default \"foo\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location2() default \"bar\";\n\t}\n\n\t@ImplicitAliasesWithDifferentDefaultValuesContextConfig(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithDifferentDefaultValuesContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithDuplicateValuesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location1() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location2() default \"\";\n\t}\n\n\t@ImplicitAliasesWithDuplicateValuesContextConfig(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithDuplicateValuesContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesForAliasPairContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, value = \"value\")\n\t\tString groovyScript() default \"\";\n\t}\n\n\t@ImplicitAliasesForAliasPairContextConfig(xmlFile = \"test.xml\")\n\tstatic class ImplicitAliasesForAliasPairContextConfigClass {\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScript\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@TransitiveImplicitAliasesContextConfig(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesContextConfigClass {\n\t}\n\n\t@ImplicitAliasesForAliasPairContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesForAliasPairContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesForAliasPairContextConfig.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesForAliasPairContextConfig.class, attribute = \"groovyScript\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@TransitiveImplicitAliasesForAliasPairContextConfig(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesForAliasPairContextConfigClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({})\n\t@interface Filter {\n\t\tString pattern();\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.context.annotation.ComponentScan}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScan {\n\t\tFilter[] excludeFilters() default {};\n\t}\n\n\t@ComponentScan(excludeFilters = {@Filter(pattern = \"*Foo\"), @Filter(pattern = \"*Bar\")})\n\tstatic class ComponentScanClass {\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.context.annotation.ComponentScan}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScanSingleFilter {\n\t\tFilter value();\n\t}\n\n\t@ComponentScanSingleFilter(@Filter(pattern = \"*Foo\"))\n\tstatic class ComponentScanSingleFilterClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnotationWithDefaults {\n\t\tString text() default \"enigma\";\n\t\tboolean predicate() default true;\n\t\tchar[] characters() default {'a', 'b', 'c'};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnotationWithoutDefaults {\n\t\tString text();\n\t}\n\n\t@ContextConfig(value = \"foo\", location = \"bar\")\n\tinterface ContextConfigMismatch {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(TestRepeatableContainer.class)\n\t@interface TestRepeatable {\n\n\t\tString value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestRepeatableContainer {\n\n\t\tTestRepeatable[] value();\n\t}\n\n\t@TestRepeatable(\"a\")\n\t@TestRepeatable(\"b\")\n\tstatic class TestRepeatablesClass {\n\t}\n\n\t@Deprecated\n\tstatic class DeprecatedClass {\n\t}\n\n\tstatic class SubclassOfDeprecatedClass extends DeprecatedClass {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.AliasForAttributeWithDifferentDefaultValueClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.AliasForAttributeWithDifferentDefaultValueClass",
    "headType": "class",
    "relation": "use",
    "tail": "@AliasForAttributeWithDifferentDefaultValue",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AliasForAttributeWithDifferentDefaultValueClass",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Method;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.ParametersAreNonnullByDefault;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.subpackage.NonPublicAnnotatedClass;\nimport org.springframework.core.testfixture.ide.IdeUtils;\nimport org.springframework.core.testfixture.stereotype.Component;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Collectors.toList;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalStateException;\nimport static org.springframework.core.annotation.AnnotationUtils.VALUE;\nimport static org.springframework.core.annotation.AnnotationUtils.findAnnotation;\nimport static org.springframework.core.annotation.AnnotationUtils.findAnnotationDeclaringClass;\nimport static org.springframework.core.annotation.AnnotationUtils.findAnnotationDeclaringClassForTypes;\nimport static org.springframework.core.annotation.AnnotationUtils.getAnnotation;\nimport static org.springframework.core.annotation.AnnotationUtils.getAnnotationAttributes;\nimport static org.springframework.core.annotation.AnnotationUtils.getDeclaredRepeatableAnnotations;\nimport static org.springframework.core.annotation.AnnotationUtils.getDefaultValue;\nimport static org.springframework.core.annotation.AnnotationUtils.getRepeatableAnnotations;\nimport static org.springframework.core.annotation.AnnotationUtils.getValue;\nimport static org.springframework.core.annotation.AnnotationUtils.isAnnotationDeclaredLocally;\nimport static org.springframework.core.annotation.AnnotationUtils.isAnnotationInherited;\nimport static org.springframework.core.annotation.AnnotationUtils.isAnnotationMetaPresent;\nimport static org.springframework.core.annotation.AnnotationUtils.synthesizeAnnotation;\n\n/**\n * Tests for {@link AnnotationUtils}.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Chris Beams\n * @author Phillip Webb\n * @author Oleg Zhurakousky\n */\n@SuppressWarnings(\"deprecation\")\nclass AnnotationUtilsTests {\n\n\t@BeforeEach\n\tvoid clearCacheBeforeTests() {\n\t\tAnnotationUtils.clearCache();\n\t}\n\n\n\t@Test\n\tvoid findMethodAnnotationOnLeaf() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"annotatedOnLeaf\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNotNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNotNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findMethodAnnotationWithAnnotationOnMethodInInterface() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"fromInterfaceImplementedByRoot\");\n\t\t// @Order is not @Inherited\n\t\tassertThat(m.getAnnotation(Order.class)).isNull();\n\t\t// getAnnotation() does not search on interfaces\n\t\tassertThat(getAnnotation(m, Order.class)).isNull();\n\t\t// findAnnotation() does search on interfaces\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findMethodAnnotationWithMetaAnnotationOnLeaf() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"metaAnnotatedOnLeaf\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNotNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findMethodAnnotationWithMetaMetaAnnotationOnLeaf() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"metaMetaAnnotatedOnLeaf\");\n\t\tassertThat(m.getAnnotation(Component.class)).isNull();\n\t\tassertThat(getAnnotation(m, Component.class)).isNull();\n\t\tassertThat(findAnnotation(m, Component.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationOnRoot() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"annotatedOnRoot\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNotNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNotNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findMethodAnnotationWithMetaAnnotationOnRoot() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"metaAnnotatedOnRoot\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNotNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationOnRootButOverridden() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"overrideWithoutNewAnnotation\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationNotAnnotated() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"notAnnotated\");\n\t\tassertThat(findAnnotation(m, Order.class)).isNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationOnBridgeMethod() throws Exception {\n\t\tMethod bridgeMethod = SimpleFoo.class.getMethod(\"something\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(bridgeMethod.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(bridgeMethod, Order.class)).isNull();\n\t\tassertThat(findAnnotation(bridgeMethod, Order.class)).isNotNull();\n\n\t\t// As of JDK 8, invoking getAnnotation() on a bridge method actually finds an\n\t\t// annotation on its 'bridged' method [1]; however, the Eclipse compiler does\n\t\t// not support this [2]. Thus, we effectively ignore the following\n\t\t// assertion if the test is currently executing within the Eclipse IDE.\n\t\t//\n\t\t// [1] https://bugs.openjdk.java.net/browse/JDK-6695379\n\t\t// [2] https://bugs.eclipse.org/bugs/show_bug.cgi?id=495396\n\t\t//\n\t\tif (!IdeUtils.runningInEclipse()) {\n\t\t\tassertThat(bridgeMethod.getAnnotation(Transactional.class)).isNotNull();\n\t\t}\n\t\tassertThat(getAnnotation(bridgeMethod, Transactional.class)).isNotNull();\n\t\tassertThat(findAnnotation(bridgeMethod, Transactional.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationOnBridgedMethod() throws Exception {\n\t\tMethod bridgedMethod = SimpleFoo.class.getMethod(\"something\", String.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tassertThat(bridgedMethod.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(bridgedMethod, Order.class)).isNull();\n\t\tassertThat(findAnnotation(bridgedMethod, Order.class)).isNotNull();\n\n\t\tassertThat(bridgedMethod.getAnnotation(Transactional.class)).isNotNull();\n\t\tassertThat(getAnnotation(bridgedMethod, Transactional.class)).isNotNull();\n\t\tassertThat(findAnnotation(bridgedMethod, Transactional.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationFromInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test  // SPR-16060\n\tvoid findMethodAnnotationFromGenericInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test  // SPR-17146\n\tvoid findMethodAnnotationFromGenericSuperclass() throws Exception {\n\t\tMethod method = ExtendsBaseClassWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationFromInterfaceOnSuper() throws Exception {\n\t\tMethod method = SubOfImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationFromInterfaceWhenSuperDoesNotImplementMethod() throws Exception {\n\t\tMethod method = SubOfAbstractImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t// @since 4.1.2\n\t@Test\n\tvoid findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverAnnotationsOnInterfaces() {\n\t\tComponent component = findAnnotation(ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface.class, Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tassertThat(component.value()).isEqualTo(\"meta2\");\n\t}\n\n\t// @since 4.0.3\n\t@Test\n\tvoid findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedAnnotations() {\n\t\tTransactional transactional = findAnnotation(SubSubClassWithInheritedAnnotation.class, Transactional.class);\n\t\tassertThat(transactional).isNotNull();\n\t\tassertThat(transactional.readOnly()).as(\"readOnly flag for SubSubClassWithInheritedAnnotation\").isTrue();\n\t}\n\n\t// @since 4.0.3\n\t@Test\n\tvoid findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedComposedAnnotations() {\n\t\tComponent component = findAnnotation(SubSubClassWithInheritedMetaAnnotation.class, Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tassertThat(component.value()).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid findClassAnnotationOnMetaMetaAnnotatedClass() {\n\t\tComponent component = findAnnotation(MetaMetaAnnotatedClass.class, Component.class);\n\t\tassertThat(component).as(\"Should find meta-annotation on composed annotation on class\").isNotNull();\n\t\tassertThat(component.value()).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid findClassAnnotationOnMetaMetaMetaAnnotatedClass() {\n\t\tComponent component = findAnnotation(MetaMetaMetaAnnotatedClass.class, Component.class);\n\t\tassertThat(component).as(\"Should find meta-annotation on meta-annotation on composed annotation on class\").isNotNull();\n\t\tassertThat(component.value()).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid findClassAnnotationOnAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\t// TransactionalClass is NOT annotated or meta-annotated with @Component\n\t\tComponent component = findAnnotation(TransactionalClass.class, Component.class);\n\t\tassertThat(component).as(\"Should not find @Component on TransactionalClass\").isNull();\n\t}\n\n\t@Test\n\tvoid findClassAnnotationOnMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\tComponent component = findAnnotation(MetaCycleAnnotatedClass.class, Component.class);\n\t\tassertThat(component).as(\"Should not find @Component on MetaCycleAnnotatedClass\").isNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnInheritedAnnotationInterface() {\n\t\tTransactional tx = findAnnotation(InheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(tx).as(\"Should find @Transactional on InheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnSubInheritedAnnotationInterface() {\n\t\tTransactional tx = findAnnotation(SubInheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(tx).as(\"Should find @Transactional on SubInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnSubSubInheritedAnnotationInterface() {\n\t\tTransactional tx = findAnnotation(SubSubInheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(tx).as(\"Should find @Transactional on SubSubInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnNonInheritedAnnotationInterface() {\n\t\tOrder order = findAnnotation(NonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(order).as(\"Should find @Order on NonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnSubNonInheritedAnnotationInterface() {\n\t\tOrder order = findAnnotation(SubNonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(order).as(\"Should find @Order on SubNonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnSubSubNonInheritedAnnotationInterface() {\n\t\tOrder order = findAnnotation(SubSubNonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(order).as(\"Should find @Order on SubSubNonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findAnnotationDeclaringClassForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, NonAnnotatedInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, NonAnnotatedClass.class)).isNull();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, InheritedAnnotationInterface.class)).isEqualTo(InheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, SubInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, InheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, SubInheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but findAnnotationDeclaringClass() should still find it on classes.\n\t\tassertThat(findAnnotationDeclaringClass(Order.class, NonInheritedAnnotationInterface.class)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClass(Order.class, SubNonInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClass(Order.class, NonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClass(Order.class, SubNonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t}\n\n\t@Test\n\tvoid findAnnotationDeclaringClassForTypesWithSingleCandidateType() {\n\t\t// no class-level annotation\n\t\tList<Class<? extends Annotation>> transactionalCandidateList = Collections.singletonList(Transactional.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, NonAnnotatedInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, NonAnnotatedClass.class)).isNull();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, InheritedAnnotationInterface.class)).isEqualTo(InheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, SubInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, InheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, SubInheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but findAnnotationDeclaringClassForTypes() should still find it on classes.\n\t\tList<Class<? extends Annotation>> orderCandidateList = Collections.singletonList(Order.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, NonInheritedAnnotationInterface.class)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, SubNonInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, NonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, SubNonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t}\n\n\t@Test\n\tvoid findAnnotationDeclaringClassForTypesWithMultipleCandidateTypes() {\n\t\tList<Class<? extends Annotation>> candidates = asList(Transactional.class, Order.class);\n\n\t\t// no class-level annotation\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, NonAnnotatedInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, NonAnnotatedClass.class)).isNull();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, InheritedAnnotationInterface.class)).isEqualTo(InheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, InheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubInheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but findAnnotationDeclaringClassForTypes() should still find it on classes.\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, NonInheritedAnnotationInterface.class)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubNonInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, NonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubNonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\n\t\t// class hierarchy mixed with @Transactional and @Order declarations\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, TransactionalClass.class)).isEqualTo(TransactionalClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, TransactionalAndOrderedClass.class)).isEqualTo(TransactionalAndOrderedClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubTransactionalAndOrderedClass.class)).isEqualTo(TransactionalAndOrderedClass.class);\n\t}\n\n\t@Test\n\tvoid isAnnotationDeclaredLocallyForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, NonAnnotatedInterface.class)).isFalse();\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, NonAnnotatedClass.class)).isFalse();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, InheritedAnnotationInterface.class)).isTrue();\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, SubInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, InheritedAnnotationClass.class)).isTrue();\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, SubInheritedAnnotationClass.class)).isFalse();\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited\n\t\tassertThat(isAnnotationDeclaredLocally(Order.class, NonInheritedAnnotationInterface.class)).isTrue();\n\t\tassertThat(isAnnotationDeclaredLocally(Order.class, SubNonInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationDeclaredLocally(Order.class, NonInheritedAnnotationClass.class)).isTrue();\n\t\tassertThat(isAnnotationDeclaredLocally(Order.class, SubNonInheritedAnnotationClass.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotationInheritedForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(isAnnotationInherited(Transactional.class, NonAnnotatedInterface.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Transactional.class, NonAnnotatedClass.class)).isFalse();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(isAnnotationInherited(Transactional.class, InheritedAnnotationInterface.class)).isFalse();\n\t\t// isAnnotationInherited() does not currently traverse interface hierarchies.\n\t\t// Thus the following, though perhaps counterintuitive, must be false:\n\t\tassertThat(isAnnotationInherited(Transactional.class, SubInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Transactional.class, InheritedAnnotationClass.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Transactional.class, SubInheritedAnnotationClass.class)).isTrue();\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited\n\t\tassertThat(isAnnotationInherited(Order.class, NonInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Order.class, SubNonInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Order.class, NonInheritedAnnotationClass.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Order.class, SubNonInheritedAnnotationClass.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotationMetaPresentForPlainType() {\n\t\tassertThat(isAnnotationMetaPresent(Order.class, Documented.class)).isTrue();\n\t\tassertThat(isAnnotationMetaPresent(ParametersAreNonnullByDefault.class, Documented.class)).isTrue();\n\t\tassertThat(isAnnotationMetaPresent(ParametersAreNonnullByDefault.class, Nonnull.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributesWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\n\t\tAnnotationAttributes attributes = (AnnotationAttributes) getAnnotationAttributes(component);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.getString(VALUE)).as(\"value attribute: \").isEqualTo(\"webController\");\n\t\tassertThat(attributes.annotationType()).isEqualTo(Component.class);\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributesWithNestedAnnotations() {\n\t\tComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class);\n\t\tassertThat(componentScan).isNotNull();\n\n\t\tAnnotationAttributes attributes = getAnnotationAttributes(ComponentScanClass.class, componentScan);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(ComponentScan.class);\n\n\t\tFilter[] filters = attributes.getAnnotationArray(\"excludeFilters\", Filter.class);\n\t\tassertThat(filters).isNotNull();\n\n\t\tList<String> patterns = stream(filters).map(Filter::pattern).collect(toList());\n\t\tassertThat(patterns).isEqualTo(asList(\"*Foo\", \"*Bar\"));\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributesWithAttributeAliases() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\t\tWebMapping webMapping = method.getAnnotation(WebMapping.class);\n\t\tAnnotationAttributes attributes = (AnnotationAttributes) getAnnotationAttributes(webMapping);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(WebMapping.class);\n\t\tassertThat(attributes.getString(\"name\")).as(\"name attribute: \").isEqualTo(\"foo\");\n\t\tassertThat(attributes.getStringArray(VALUE)).as(\"value attribute: \").isEqualTo(asArray(\"/test\"));\n\t\tassertThat(attributes.getStringArray(\"path\")).as(\"path attribute: \").isEqualTo(asArray(\"/test\"));\n\n\t\tmethod = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\twebMapping = method.getAnnotation(WebMapping.class);\n\t\tattributes = (AnnotationAttributes) getAnnotationAttributes(webMapping);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(WebMapping.class);\n\t\tassertThat(attributes.getString(\"name\")).as(\"name attribute: \").isEqualTo(\"bar\");\n\t\tassertThat(attributes.getStringArray(VALUE)).as(\"value attribute: \").isEqualTo(asArray(\"/test\"));\n\t\tassertThat(attributes.getStringArray(\"path\")).as(\"path attribute: \").isEqualTo(asArray(\"/test\"));\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributesWithAttributeAliasesWithDifferentValues() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithDifferentPathAndValueAttributes\");\n\t\tWebMapping webMapping = method.getAnnotation(WebMapping.class);\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tgetAnnotationAttributes(webMapping))\n\t\t\t.withMessageContaining(\"attribute 'path' and its alias 'value'\")\n\t\t\t.withMessageContaining(\"values of [{/test}] and [{/enigma}]\");\n\t}\n\n\t@Test\n\tvoid getValueFromAnnotation() throws Exception {\n\t\tMethod method = SimpleFoo.class.getMethod(\"something\", Object.class);\n\t\tOrder order = findAnnotation(method, Order.class);\n\n\t\tassertThat(getValue(order, VALUE)).isEqualTo(1);\n\t\tassertThat(getValue(order)).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getValueFromNonPublicAnnotation() {\n\t\tAnnotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\n\t\tassertThat(declaredAnnotations).hasSize(1);\n\t\tAnnotation annotation = declaredAnnotations[0];\n\t\tassertThat(annotation).isNotNull();\n\t\tassertThat(annotation.annotationType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\n\t\tassertThat(getValue(annotation, VALUE)).isEqualTo(42);\n\t\tassertThat(getValue(annotation)).isEqualTo(42);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromAnnotation() throws Exception {\n\t\tMethod method = SimpleFoo.class.getMethod(\"something\", Object.class);\n\t\tOrder order = findAnnotation(method, Order.class);\n\n\t\tassertThat(getDefaultValue(order, VALUE)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\n\t\tassertThat(getDefaultValue(order)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromNonPublicAnnotation() {\n\t\tAnnotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\n\t\tassertThat(declaredAnnotations).hasSize(1);\n\t\tAnnotation annotation = declaredAnnotations[0];\n\t\tassertThat(annotation).isNotNull();\n\t\tassertThat(annotation.annotationType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\n\t\tassertThat(getDefaultValue(annotation, VALUE)).isEqualTo(-1);\n\t\tassertThat(getDefaultValue(annotation)).isEqualTo(-1);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromAnnotationType() {\n\t\tassertThat(getDefaultValue(Order.class, VALUE)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\n\t\tassertThat(getDefaultValue(Order.class)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Test\n\tvoid findRepeatableAnnotation() {\n\t\tRepeatable repeatable = findAnnotation(MyRepeatable.class, Repeatable.class);\n\t\tassertThat(repeatable).isNotNull();\n\t\tassertThat(repeatable.value()).isEqualTo(MyRepeatableContainer.class);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnMethod() throws Exception {\n\t\tMethod method = InterfaceWithRepeated.class.getMethod(\"foo\");\n\t\tSet<MyRepeatable> annotations = getRepeatableAnnotations(method, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(annotations).isNotNull();\n\t\tList<String> values = annotations.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(asList(\"A\", \"B\", \"C\", \"meta1\"));\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnClassWithAttributeAliases() {\n\t\tfinal List<String> expectedLocations = asList(\"A\", \"B\");\n\n\t\tSet<ContextConfig> annotations = getRepeatableAnnotations(ConfigHierarchyTestCase.class, ContextConfig.class, null);\n\t\tassertThat(annotations).isNotNull();\n\t\tassertThat(annotations).as(\"size if container type is omitted: \").isEmpty();\n\n\t\tannotations = getRepeatableAnnotations(ConfigHierarchyTestCase.class, ContextConfig.class, Hierarchy.class);\n\t\tassertThat(annotations).isNotNull();\n\n\t\tList<String> locations = annotations.stream().map(ContextConfig::location).collect(toList());\n\t\tassertThat(locations).isEqualTo(expectedLocations);\n\n\t\tList<String> values = annotations.stream().map(ContextConfig::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedLocations);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnClass() {\n\t\tfinal List<String> expectedValuesJava = asList(\"A\", \"B\", \"C\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"A\", \"B\", \"C\", \"meta1\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = MyRepeatableClass.class.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnSuperclass() {\n\t\tfinal Class<?> clazz = SubMyRepeatableClass.class;\n\t\tfinal List<String> expectedValuesJava = asList(\"A\", \"B\", \"C\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"A\", \"B\", \"C\", \"meta1\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getRepeatableAnnotations(clazz, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnClassAndSuperclass() {\n\t\tfinal Class<?> clazz = SubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\n\t\tfinal List<String> expectedValuesJava = asList(\"X\", \"Y\", \"Z\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"X\", \"Y\", \"Z\", \"meta2\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getRepeatableAnnotations(clazz, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnMultipleSuperclasses() {\n\t\tfinal Class<?> clazz = SubSubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\n\t\tfinal List<String> expectedValuesJava = asList(\"X\", \"Y\", \"Z\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"X\", \"Y\", \"Z\", \"meta2\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getRepeatableAnnotations(clazz, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getDeclaredRepeatableAnnotationsDeclaredOnClass() {\n\t\tfinal List<String> expectedValuesJava = asList(\"A\", \"B\", \"C\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"A\", \"B\", \"C\", \"meta1\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = MyRepeatableClass.class.getDeclaredAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getDeclaredRepeatableAnnotations(\n\t\t\t\tMyRepeatableClass.class, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getDeclaredRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getDeclaredRepeatableAnnotationsDeclaredOnSuperclass() {\n\t\tfinal Class<?> clazz = SubMyRepeatableClass.class;\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = clazz.getDeclaredAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tassertThat(array).isEmpty();\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getDeclaredRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tassertThat(set).isEmpty();\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getDeclaredRepeatableAnnotations(clazz, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tassertThat(set).isEmpty();\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationWithImplicitAliasesWithMissingDefaultValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithMissingDefaultValuesContextConfigClass.class;\n\t\tClass<ImplicitAliasesWithMissingDefaultValuesContextConfig> annotationType =\n\t\t\t\tImplicitAliasesWithMissingDefaultValuesContextConfig.class;\n\t\tImplicitAliasesWithMissingDefaultValuesContextConfig config = clazz.getAnnotation(annotationType);\n\t\tassertThat(config).isNotNull();\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(config, clazz))\n\t\t\t.withMessageStartingWith(\"Misconfigured aliases:\")\n\t\t\t.withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t.withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t.withMessageContaining(\"default values\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationWithImplicitAliasesWithDifferentDefaultValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithDifferentDefaultValuesContextConfigClass.class;\n\t\tClass<ImplicitAliasesWithDifferentDefaultValuesContextConfig> annotationType =\n\t\t\t\tImplicitAliasesWithDifferentDefaultValuesContextConfig.class;\n\t\tImplicitAliasesWithDifferentDefaultValuesContextConfig config = clazz.getAnnotation(annotationType);\n\t\tassertThat(config).isNotNull();\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(config, clazz))\n\t\t\t.withMessageStartingWith(\"Misconfigured aliases:\")\n\t\t\t.withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t.withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t.withMessageContaining(\"same default value\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationWithImplicitAliasesWithDuplicateValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithDuplicateValuesContextConfigClass.class;\n\t\tClass<ImplicitAliasesWithDuplicateValuesContextConfig> annotationType =\n\t\t\t\tImplicitAliasesWithDuplicateValuesContextConfig.class;\n\t\tImplicitAliasesWithDuplicateValuesContextConfig config = clazz.getAnnotation(annotationType);\n\t\tassertThat(config).isNotNull();\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(config, clazz).location1())\n\t\t\t.withMessageStartingWith(\"Different @AliasFor mirror values\")\n\t\t\t.withMessageContaining(annotationType.getName())\n\t\t\t.withMessageContaining(\"declared on class\")\n\t\t\t.withMessageContaining(clazz.getName())\n\t\t\t.withMessageContaining(\"attribute 'location1' and its alias 'location2'\")\n\t\t\t.withMessageContaining(\"with values of [1] and [2]\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\n\t\tMap<String, Object> map = Collections.singletonMap(VALUE, \"webController\");\n\t\tComponent synthesizedComponent = synthesizeAnnotation(map, Component.class, WebController.class);\n\t\tassertThat(synthesizedComponent).isNotNull();\n\n\t\tassertThat(synthesizedComponent).isNotSameAs(component);\n\t\tassertThat(component.value()).as(\"value from component: \").isEqualTo(\"webController\");\n\t\tassertThat(synthesizedComponent.value()).as(\"value from synthesized component: \").isEqualTo(\"webController\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeAnnotationFromMapWithNestedMap() {\n\t\tComponentScanSingleFilter componentScan =\n\t\t\t\tComponentScanSingleFilterClass.class.getAnnotation(ComponentScanSingleFilter.class);\n\t\tassertThat(componentScan).isNotNull();\n\t\tassertThat(componentScan.value().pattern()).as(\"value from ComponentScan: \").isEqualTo(\"*Foo\");\n\n\t\tAnnotationAttributes attributes = getAnnotationAttributes(\n\t\t\t\tComponentScanSingleFilterClass.class, componentScan, false, true);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(ComponentScanSingleFilter.class);\n\n\t\tMap<String, Object> filterMap = (Map<String, Object>) attributes.get(\"value\");\n\t\tassertThat(filterMap).isNotNull();\n\t\tassertThat(filterMap.get(\"pattern\")).isEqualTo(\"*Foo\");\n\n\t\t// Modify nested map\n\t\tfilterMap.put(\"pattern\", \"newFoo\");\n\t\tfilterMap.put(\"enigma\", 42);\n\n\t\tComponentScanSingleFilter synthesizedComponentScan = synthesizeAnnotation(\n\t\t\t\tattributes, ComponentScanSingleFilter.class, ComponentScanSingleFilterClass.class);\n\t\tassertThat(synthesizedComponentScan).isNotNull();\n\n\t\tassertThat(synthesizedComponentScan).isNotSameAs(componentScan);\n\t\tassertThat(synthesizedComponentScan.value().pattern()).as(\"value from synthesized ComponentScan: \").isEqualTo(\"newFoo\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeAnnotationFromMapWithNestedArrayOfMaps() {\n\t\tComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class);\n\t\tassertThat(componentScan).isNotNull();\n\n\t\tAnnotationAttributes attributes = getAnnotationAttributes(ComponentScanClass.class, componentScan, false, true);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(ComponentScan.class);\n\n\t\tMap<String, Object>[] filters = (Map[]) attributes.get(\"excludeFilters\");\n\t\tassertThat(filters).isNotNull();\n\n\t\tList<String> patterns = stream(filters).map(m -> (String) m.get(\"pattern\")).collect(toList());\n\t\tassertThat(patterns).isEqualTo(asList(\"*Foo\", \"*Bar\"));\n\n\t\t// Modify nested maps\n\t\tfilters[0].put(\"pattern\", \"newFoo\");\n\t\tfilters[0].put(\"enigma\", 42);\n\t\tfilters[1].put(\"pattern\", \"newBar\");\n\t\tfilters[1].put(\"enigma\", 42);\n\n\t\tComponentScan synthesizedComponentScan =\n\t\t\t\tsynthesizeAnnotation(attributes, ComponentScan.class, ComponentScanClass.class);\n\t\tassertThat(synthesizedComponentScan).isNotNull();\n\n\t\tassertThat(synthesizedComponentScan).isNotSameAs(componentScan);\n\t\tpatterns = stream(synthesizedComponentScan.excludeFilters()).map(Filter::pattern).collect(toList());\n\t\tassertThat(patterns).isEqualTo(asList(\"newFoo\", \"newBar\"));\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromDefaultsWithoutAttributeAliases() {\n\t\tAnnotationWithDefaults annotationWithDefaults = synthesizeAnnotation(AnnotationWithDefaults.class);\n\t\tassertThat(annotationWithDefaults).isNotNull();\n\t\tassertThat(annotationWithDefaults.text()).as(\"text: \").isEqualTo(\"enigma\");\n\t\tassertThat(annotationWithDefaults.predicate()).as(\"predicate: \").isTrue();\n\t\tassertThat(annotationWithDefaults.characters()).as(\"characters: \").isEqualTo(new char[] { 'a', 'b', 'c' });\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromDefaultsWithAttributeAliases() {\n\t\tContextConfig contextConfig = synthesizeAnnotation(ContextConfig.class);\n\t\tassertThat(contextConfig).isNotNull();\n\t\tassertThat(contextConfig.value()).as(\"value: \").isEmpty();\n\t\tassertThat(contextConfig.location()).as(\"location: \").isEmpty();\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithMinimalAttributesWithAttributeAliases() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"location\", \"test.xml\");\n\t\tContextConfig contextConfig = synthesizeAnnotation(map, ContextConfig.class, null);\n\t\tassertThat(contextConfig).isNotNull();\n\t\tassertThat(contextConfig.value()).as(\"value: \").isEqualTo(\"test.xml\");\n\t\tassertThat(contextConfig.location()).as(\"location: \").isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"value\", \"/foo\");\n\t\tGet get = synthesizeAnnotation(map, Get.class, null);\n\t\tassertThat(get).isNotNull();\n\t\tassertThat(get.value()).as(\"value: \").isEqualTo(\"/foo\");\n\t\tassertThat(get.path()).as(\"path: \").isEqualTo(\"/foo\");\n\n\t\tmap = Collections.singletonMap(\"path\", \"/foo\");\n\t\tget = synthesizeAnnotation(map, Get.class, null);\n\t\tassertThat(get).isNotNull();\n\t\tassertThat(get.value()).as(\"value: \").isEqualTo(\"/foo\");\n\t\tassertThat(get.path()).as(\"path: \").isEqualTo(\"/foo\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithImplicitAttributeAliases() {\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"value\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"location1\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"location2\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"location3\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"xmlFile\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"groovyScript\");\n\t}\n\n\tprivate void assertAnnotationSynthesisFromMapWithImplicitAliases(String attributeNameAndValue) {\n\t\tMap<String, Object> map = Collections.singletonMap(attributeNameAndValue, attributeNameAndValue);\n\t\tImplicitAliasesContextConfig config = synthesizeAnnotation(map, ImplicitAliasesContextConfig.class, null);\n\t\tassertThat(config).isNotNull();\n\t\tassertThat(config.value()).as(\"value: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.location1()).as(\"location1: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.location2()).as(\"location2: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.location3()).as(\"location3: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.xmlFile()).as(\"xmlFile: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.groovyScript()).as(\"groovyScript: \").isEqualTo(attributeNameAndValue);\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithMissingAttributeValue() {\n\t\tassertMissingTextAttribute(Collections.emptyMap());\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithNullAttributeValue() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"text\", null);\n\t\tassertThat(map.containsKey(\"text\")).isTrue();\n\t\tassertMissingTextAttribute(map);\n\t}\n\n\tprivate void assertMissingTextAttribute(Map<String, Object> attributes) {\n\t\tassertThatExceptionOfType(NoSuchElementException.class).isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(attributes, AnnotationWithoutDefaults.class, null).text())\n\t\t\t.withMessageContaining(\"No value found for attribute named 'text' in merged annotation\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithAttributeOfIncorrectType() {\n\t\tMap<String, Object> map = Collections.singletonMap(VALUE, 42L);\n\t\tassertThatIllegalStateException().isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(map, Component.class, null).value())\n\t\t\t.withMessageContaining(\"Attribute 'value' in annotation org.springframework.core.testfixture.stereotype.Component \"\n\t\t\t\t\t+ \"should be compatible with java.lang.String but a java.lang.Long value was returned\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromAnnotationAttributesWithoutAttributeAliases() {\n\t\t// 1) Get an annotation\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\n\t\t// 2) Convert the annotation into AnnotationAttributes\n\t\tAnnotationAttributes attributes = getAnnotationAttributes(WebController.class, component);\n\t\tassertThat(attributes).isNotNull();\n\n\t\t// 3) Synthesize the AnnotationAttributes back into an annotation\n\t\tComponent synthesizedComponent = synthesizeAnnotation(attributes, Component.class, WebController.class);\n\t\tassertThat(synthesizedComponent).isNotNull();\n\n\t\t// 4) Verify that the original and synthesized annotations are equivalent\n\t\tassertThat(synthesizedComponent).isNotSameAs(component);\n\t\tassertThat(synthesizedComponent).isEqualTo(component);\n\t\tassertThat(component.value()).as(\"value from component: \").isEqualTo(\"webController\");\n\t\tassertThat(synthesizedComponent.value()).as(\"value from synthesized component: \").isEqualTo(\"webController\");\n\t}\n\n\t@Test  // gh-22702\n\tvoid findAnnotationWithRepeatablesElements() {\n\t\tassertThat(AnnotationUtils.findAnnotation(TestRepeatablesClass.class,\n\t\t\t\tTestRepeatable.class)).isNull();\n\t\tassertThat(AnnotationUtils.findAnnotation(TestRepeatablesClass.class,\n\t\tTestRepeatableContainer.class)).isNotNull();\n\t}\n\n\t@Test  // gh-23856\n\tvoid findAnnotationFindsRepeatableContainerOnComposedAnnotationMetaAnnotatedWithRepeatableAnnotations() {\n\t\tMyRepeatableContainer annotation = AnnotationUtils.findAnnotation(MyRepeatableMeta1And2.class, MyRepeatableContainer.class);\n\n\t\tassertThat(annotation).isNotNull();\n\t\tassertThat(annotation.value()).extracting(MyRepeatable::value).containsExactly(\"meta1\", \"meta2\");\n\t}\n\n\t@Test  // gh-23856\n\tvoid findAnnotationFindsRepeatableContainerOnComposedAnnotationMetaAnnotatedWithRepeatableAnnotationsOnMethod() throws Exception {\n\t\tMethod method = getClass().getDeclaredMethod(\"methodWithComposedAnnotationMetaAnnotatedWithRepeatableAnnotations\");\n\t\tMyRepeatableContainer annotation = AnnotationUtils.findAnnotation(method, MyRepeatableContainer.class);\n\n\t\tassertThat(annotation).isNotNull();\n\t\tassertThat(annotation.value()).extracting(MyRepeatable::value).containsExactly(\"meta1\", \"meta2\");\n\t}\n\n\t@Test  // gh-23929\n\tvoid findDeprecatedAnnotation() {\n\t\tassertThat(getAnnotation(DeprecatedClass.class, Deprecated.class)).isNotNull();\n\t\tassertThat(getAnnotation(SubclassOfDeprecatedClass.class, Deprecated.class)).isNull();\n\t\tassertThat(findAnnotation(DeprecatedClass.class, Deprecated.class)).isNotNull();\n\t\tassertThat(findAnnotation(SubclassOfDeprecatedClass.class, Deprecated.class)).isNotNull();\n\t}\n\n\n\t@SafeVarargs\n\tstatic <T> T[] asArray(T... arr) {\n\t\treturn arr;\n\t}\n\n\n\t@Component(\"meta1\")\n\t@Order\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Meta1 {\n\t}\n\n\t@Component(\"meta2\")\n\t@Transactional(readOnly = true)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Meta2 {\n\t}\n\n\t@Meta2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMeta {\n\t}\n\n\t@MetaMeta\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMetaMeta {\n\t}\n\n\t@MetaCycle3\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle1 {\n\t}\n\n\t@MetaCycle1\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle2 {\n\t}\n\n\t@MetaCycle2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle3 {\n\t}\n\n\t@Meta1\n\tinterface InterfaceWithMetaAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface implements InterfaceWithMetaAnnotation {\n\t}\n\n\t@Meta1\n\tstatic class ClassWithInheritedMetaAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class SubClassWithInheritedMetaAnnotation extends ClassWithInheritedMetaAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedMetaAnnotation extends SubClassWithInheritedMetaAnnotation {\n\t}\n\n\t@Transactional\n\tstatic class ClassWithInheritedAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class SubClassWithInheritedAnnotation extends ClassWithInheritedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedAnnotation extends SubClassWithInheritedAnnotation {\n\t}\n\n\t@MetaMeta\n\tstatic class MetaMetaAnnotatedClass {\n\t}\n\n\t@MetaMetaMeta\n\tstatic class MetaMetaMetaAnnotatedClass {\n\t}\n\n\t@MetaCycle3\n\tstatic class MetaCycleAnnotatedClass {\n\t}\n\n\tpublic interface AnnotatedInterface {\n\n\t\t@Order(0)\n\t\tvoid fromInterfaceImplementedByRoot();\n\t}\n\n\tpublic static class Root implements AnnotatedInterface {\n\n\t\t@Order(27)\n\t\tpublic void annotatedOnRoot() {\n\t\t}\n\n\t\t@Meta1\n\t\tpublic void metaAnnotatedOnRoot() {\n\t\t}\n\n\t\tpublic void overrideToAnnotate() {\n\t\t}\n\n\t\t@Order(27)\n\t\tpublic void overrideWithoutNewAnnotation() {\n\t\t}\n\n\t\tpublic void notAnnotated() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void fromInterfaceImplementedByRoot() {\n\t\t}\n\t}\n\n\tpublic static class Leaf extends Root {\n\n\t\t@Order(25)\n\t\tpublic void annotatedOnLeaf() {\n\t\t}\n\n\t\t@Meta1\n\t\tpublic void metaAnnotatedOnLeaf() {\n\t\t}\n\n\t\t@MetaMeta\n\t\tpublic void metaMetaAnnotatedOnLeaf() {\n\t\t}\n\n\t\t@Override\n\t\t@Order(1)\n\t\tpublic void overrideToAnnotate() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void overrideWithoutNewAnnotation() {\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Transactional {\n\n\t\tboolean readOnly() default false;\n\t}\n\n\tpublic abstract static class Foo<T> {\n\n\t\t@Order(1)\n\t\tpublic abstract void something(T arg);\n\t}\n\n\tpublic static class SimpleFoo extends Foo<String> {\n\n\t\t@Override\n\t\t@Transactional\n\t\tpublic void something(final String arg) {\n\t\t}\n\t}\n\n\t@Transactional\n\tpublic interface InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubInheritedAnnotationInterface extends InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubInheritedAnnotationInterface extends SubInheritedAnnotationInterface {\n\t}\n\n\t@Order\n\tpublic interface NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubNonInheritedAnnotationInterface extends NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubNonInheritedAnnotationInterface extends SubNonInheritedAnnotationInterface {\n\t}\n\n\tpublic static class NonAnnotatedClass {\n\t}\n\n\tpublic interface NonAnnotatedInterface {\n\t}\n\n\t@Transactional\n\tpublic static class InheritedAnnotationClass {\n\t}\n\n\tpublic static class SubInheritedAnnotationClass extends InheritedAnnotationClass {\n\t}\n\n\t@Order\n\tpublic static class NonInheritedAnnotationClass {\n\t}\n\n\tpublic static class SubNonInheritedAnnotationClass extends NonInheritedAnnotationClass {\n\t}\n\n\t@Transactional\n\tpublic static class TransactionalClass {\n\t}\n\n\t@Order\n\tpublic static class TransactionalAndOrderedClass extends TransactionalClass {\n\t}\n\n\tpublic static class SubTransactionalAndOrderedClass extends TransactionalAndOrderedClass {\n\t}\n\n\tpublic interface InterfaceWithAnnotatedMethod {\n\n\t\t@Order\n\t\tvoid foo();\n\t}\n\n\tpublic static class ImplementsInterfaceWithAnnotatedMethod implements InterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic static class SubOfImplementsInterfaceWithAnnotatedMethod extends ImplementsInterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic abstract static class AbstractDoesNotImplementInterfaceWithAnnotatedMethod\n\t\t\timplements InterfaceWithAnnotatedMethod {\n\t}\n\n\tpublic static class SubOfAbstractImplementsInterfaceWithAnnotatedMethod\n\t\t\textends AbstractDoesNotImplementInterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic interface InterfaceWithGenericAnnotatedMethod<T> {\n\n\t\t@Order\n\t\tvoid foo(T t);\n\t}\n\n\tpublic static class ImplementsInterfaceWithGenericAnnotatedMethod implements InterfaceWithGenericAnnotatedMethod<String> {\n\n\t\t@Override\n\t\tpublic void foo(String t) {\n\t\t}\n\t}\n\n\tpublic abstract static class BaseClassWithGenericAnnotatedMethod<T> {\n\n\t\t@Order\n\t\tabstract void foo(T t);\n\t}\n\n\tpublic static class ExtendsBaseClassWithGenericAnnotatedMethod extends BaseClassWithGenericAnnotatedMethod<String> {\n\n\t\t@Override\n\t\tpublic void foo(String t) {\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface MyRepeatableContainer {\n\n\t\tMyRepeatable[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@Repeatable(MyRepeatableContainer.class)\n\t@interface MyRepeatable {\n\n\t\tString value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta1\")\n\t@interface MyRepeatableMeta1 {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta2\")\n\t@interface MyRepeatableMeta2 {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta1\")\n\t@MyRepeatable(\"meta2\")\n\t@interface MyRepeatableMeta1And2 {\n\t}\n\n\t@MyRepeatableMeta1And2\n\tvoid methodWithComposedAnnotationMetaAnnotatedWithRepeatableAnnotations() {\n\t}\n\n\tinterface InterfaceWithRepeated {\n\n\t\t@MyRepeatable(\"A\")\n\t\t@MyRepeatableContainer({@MyRepeatable(\"B\"), @MyRepeatable(\"C\")})\n\t\t@MyRepeatableMeta1\n\t\tvoid foo();\n\t}\n\n\t@MyRepeatable(\"A\")\n\t@MyRepeatableContainer({@MyRepeatable(\"B\"), @MyRepeatable(\"C\")})\n\t@MyRepeatableMeta1\n\tstatic class MyRepeatableClass {\n\t}\n\n\tstatic class SubMyRepeatableClass extends MyRepeatableClass {\n\t}\n\n\t@MyRepeatable(\"X\")\n\t@MyRepeatableContainer({@MyRepeatable(\"Y\"), @MyRepeatable(\"Z\")})\n\t@MyRepeatableMeta2\n\tstatic class SubMyRepeatableWithAdditionalLocalDeclarationsClass extends MyRepeatableClass {\n\t}\n\n\tstatic class SubSubMyRepeatableWithAdditionalLocalDeclarationsClass extends\n\t\t\tSubMyRepeatableWithAdditionalLocalDeclarationsClass {\n\t}\n\n\tenum RequestMethod {\n\t\tGET, POST\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.web.bind.annotation.RequestMapping}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface WebMapping {\n\n\t\tString name();\n\n\t\t@AliasFor(\"path\")\n\t\tString[] value() default \"\";\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tString[] path() default \"\";\n\n\t\tRequestMethod[] method() default {};\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.web.bind.annotation.GetMapping}, except\n\t * that the String arrays are overridden with single String elements.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@WebMapping(method = RequestMethod.GET, name = \"\")\n\t@interface Get {\n\n\t\t@AliasFor(annotation = WebMapping.class)\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = WebMapping.class)\n\t\tString path() default \"\";\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.web.bind.annotation.PostMapping}, except\n\t * that the path is overridden by convention with single String element.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@WebMapping(method = RequestMethod.POST, name = \"\")\n\t@interface Post {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = WebMapping.class)\n\t\tString path() default \"\";\n\t}\n\n\t@Component(\"webController\")\n\tstatic class WebController {\n\n\t\t@WebMapping(value = \"/test\", name = \"foo\")\n\t\tpublic void handleMappedWithValueAttribute() {\n\t\t}\n\n\t\t@WebMapping(path = \"/test\", name = \"bar\", method = { RequestMethod.GET, RequestMethod.POST })\n\t\tpublic void handleMappedWithPathAttribute() {\n\t\t}\n\n\t\t@Get(\"/test\")\n\t\tpublic void getMappedWithValueAttribute() {\n\t\t}\n\n\t\t@Get(path = \"/test\")\n\t\tpublic void getMappedWithPathAttribute() {\n\t\t}\n\n\t\t@Post(path = \"/test\")\n\t\tpublic void postMappedWithPathAttribute() {\n\t\t}\n\n\t\t/**\n\t\t * mapping is logically \"equal\" to handleMappedWithPathAttribute().\n\t\t */\n\t\t@WebMapping(value = \"/test\", path = \"/test\", name = \"bar\", method = { RequestMethod.GET, RequestMethod.POST })\n\t\tpublic void handleMappedWithSamePathAndValueAttributes() {\n\t\t}\n\n\t\t@WebMapping(value = \"/enigma\", path = \"/test\", name = \"baz\")\n\t\tpublic void handleMappedWithDifferentPathAndValueAttributes() {\n\t\t}\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.test.context.ContextConfiguration}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContextConfig {\n\n\t\t@AliasFor(\"location\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString location() default \"\";\n\n\t\tClass<?> klass() default Object.class;\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.test.context.ContextHierarchy}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Hierarchy {\n\t\tContextConfig[] value();\n\t}\n\n\t@Hierarchy({@ContextConfig(\"A\"), @ContextConfig(location = \"B\")})\n\tstatic class ConfigHierarchyTestCase {\n\t}\n\n\t@ContextConfig(\"simple.xml\")\n\tstatic class SimpleConfigTestCase {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface CharsContainer {\n\n\t\t@AliasFor(attribute = \"chars\")\n\t\tchar[] value() default {};\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tchar[] chars() default {};\n\t}\n\n\t@CharsContainer(chars = { 'x', 'y', 'z' })\n\tstatic class GroupOfCharsClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMissingAttributeDeclaration {\n\n\t\t@AliasFor\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForWithMissingAttributeDeclaration\n\tstatic class AliasForWithMissingAttributeDeclarationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithDuplicateAttributeDeclaration {\n\n\t\t@AliasFor(value = \"bar\", attribute = \"baz\")\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForWithDuplicateAttributeDeclaration\n\tstatic class AliasForWithDuplicateAttributeDeclarationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForNonexistentAttribute {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForNonexistentAttribute\n\tstatic class AliasForNonexistentAttributeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithoutMirroredAliasFor {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"\";\n\n\t\tString bar() default \"\";\n\t}\n\n\t@AliasForWithoutMirroredAliasFor\n\tstatic class AliasForWithoutMirroredAliasForClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMirroredAliasForWrongAttribute {\n\n\t\t@AliasFor(attribute = \"bar\")\n\t\tString[] foo() default \"\";\n\n\t\t@AliasFor(attribute = \"quux\")\n\t\tString[] bar() default \"\";\n\t}\n\n\t@AliasForWithMirroredAliasForWrongAttribute\n\tstatic class AliasForWithMirroredAliasForWrongAttributeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForAttributeOfDifferentType {\n\n\t\t@AliasFor(\"bar\")\n\t\tString[] foo() default \"\";\n\n\t\t@AliasFor(\"foo\")\n\t\tboolean bar() default true;\n\t}\n\n\t@AliasForAttributeOfDifferentType\n\tstatic class AliasForAttributeOfDifferentTypeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMissingDefaultValues {\n\n\t\t@AliasFor(attribute = \"bar\")\n\t\tString foo();\n\n\t\t@AliasFor(attribute = \"foo\")\n\t\tString bar();\n\t}\n\n\t@AliasForWithMissingDefaultValues(foo = \"foo\", bar = \"bar\")\n\tstatic class AliasForWithMissingDefaultValuesClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForAttributeWithDifferentDefaultValue {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"X\";\n\n\t\t@AliasFor(\"foo\")\n\t\tString bar() default \"Z\";\n\t}\n\n\t@AliasForAttributeWithDifferentDefaultValue\n\tstatic class AliasForAttributeWithDifferentDefaultValueClass {\n\t}\n\n\t// @ContextConfig --> Intentionally NOT meta-present\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfigNotMetaPresent {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlConfigFile();\n\t}\n\n\t@AliasedComposedContextConfigNotMetaPresent(xmlConfigFile = \"test.xml\")\n\tstatic class AliasedComposedContextConfigNotMetaPresentClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlConfigFile();\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface ImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString groovyScript() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location1() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location2() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location3() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"klass\")\n\t\tClass<?> configClass() default Object.class;\n\n\t\tString nonAliasedAttribute() default \"\";\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(groovyScript = \"groovyScript\")\n\tstatic class GroovyImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(xmlFile = \"xmlFile\")\n\tstatic class XmlImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(\"value\")\n\tstatic class ValueImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(location1 = \"location1\")\n\tstatic class Location1ImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(location2 = \"location2\")\n\tstatic class Location2ImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(location3 = \"location3\")\n\tstatic class Location3ImplicitAliasesContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig {\n\n\t\t// intentionally omitted: attribute = \"value\"\n\t\t@AliasFor(annotation = ContextConfig.class)\n\t\tString value() default \"\";\n\n\t\t// intentionally omitted: attribute = \"locations\"\n\t\t@AliasFor(annotation = ContextConfig.class)\n\t\tString location() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesWithImpliedAliasNamesOmittedContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig.class, attribute = \"location\")\n\t\tString groovy() default \"\";\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig(\"value\")\n\tstatic class ValueImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig(location = \"location\")\n\tstatic class LocationsImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig(xmlFile = \"xmlFile\")\n\tstatic class XmlFilesImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithMissingDefaultValuesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location1();\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location2();\n\t}\n\n\t@ImplicitAliasesWithMissingDefaultValuesContextConfig(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithMissingDefaultValuesContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithDifferentDefaultValuesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location1() default \"foo\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location2() default \"bar\";\n\t}\n\n\t@ImplicitAliasesWithDifferentDefaultValuesContextConfig(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithDifferentDefaultValuesContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithDuplicateValuesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location1() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location2() default \"\";\n\t}\n\n\t@ImplicitAliasesWithDuplicateValuesContextConfig(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithDuplicateValuesContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesForAliasPairContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, value = \"value\")\n\t\tString groovyScript() default \"\";\n\t}\n\n\t@ImplicitAliasesForAliasPairContextConfig(xmlFile = \"test.xml\")\n\tstatic class ImplicitAliasesForAliasPairContextConfigClass {\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScript\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@TransitiveImplicitAliasesContextConfig(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesContextConfigClass {\n\t}\n\n\t@ImplicitAliasesForAliasPairContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesForAliasPairContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesForAliasPairContextConfig.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesForAliasPairContextConfig.class, attribute = \"groovyScript\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@TransitiveImplicitAliasesForAliasPairContextConfig(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesForAliasPairContextConfigClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({})\n\t@interface Filter {\n\t\tString pattern();\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.context.annotation.ComponentScan}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScan {\n\t\tFilter[] excludeFilters() default {};\n\t}\n\n\t@ComponentScan(excludeFilters = {@Filter(pattern = \"*Foo\"), @Filter(pattern = \"*Bar\")})\n\tstatic class ComponentScanClass {\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.context.annotation.ComponentScan}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScanSingleFilter {\n\t\tFilter value();\n\t}\n\n\t@ComponentScanSingleFilter(@Filter(pattern = \"*Foo\"))\n\tstatic class ComponentScanSingleFilterClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnotationWithDefaults {\n\t\tString text() default \"enigma\";\n\t\tboolean predicate() default true;\n\t\tchar[] characters() default {'a', 'b', 'c'};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnotationWithoutDefaults {\n\t\tString text();\n\t}\n\n\t@ContextConfig(value = \"foo\", location = \"bar\")\n\tinterface ContextConfigMismatch {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(TestRepeatableContainer.class)\n\t@interface TestRepeatable {\n\n\t\tString value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestRepeatableContainer {\n\n\t\tTestRepeatable[] value();\n\t}\n\n\t@TestRepeatable(\"a\")\n\t@TestRepeatable(\"b\")\n\tstatic class TestRepeatablesClass {\n\t}\n\n\t@Deprecated\n\tstatic class DeprecatedClass {\n\t}\n\n\tstatic class SubclassOfDeprecatedClass extends DeprecatedClass {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.AliasedComposedContextConfigNotMetaPresentClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.AliasedComposedContextConfigNotMetaPresentClass",
    "headType": "class",
    "relation": "use",
    "tail": "@AliasedComposedContextConfigNotMetaPresent",
    "tailType": "annotation"
  }
]