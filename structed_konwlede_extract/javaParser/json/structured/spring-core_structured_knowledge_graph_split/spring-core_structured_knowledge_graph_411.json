[
  {
    "head": "org.springframework.util.xml.StaxSourceTests",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.xml.StaxSourceTests#inputFactory",
    "tailType": "field"
  },
  {
    "head": "org.springframework.util.xml.StaxSourceTests#inputFactory",
    "headType": "field",
    "relation": "haveType",
    "tail": "XMLInputFactory",
    "tailType": "type"
  },
  {
    "head": "org.springframework.util.xml.StaxSourceTests",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.xml.StaxSourceTests#documentBuilder",
    "tailType": "field"
  },
  {
    "head": "org.springframework.util.xml.StaxSourceTests#documentBuilder",
    "headType": "field",
    "relation": "haveType",
    "tail": "DocumentBuilder",
    "tailType": "type"
  },
  {
    "head": "org.springframework.util.xml.StaxSourceTests#setUp()",
    "headType": "method",
    "relation": "provide",
    "tail": "@BeforeEach\r\nvoid setUp() throws Exception {\r\n    TransformerFactory transformerFactory = TransformerFactory.newInstance();\r\n    transformer = transformerFactory.newTransformer();\r\n    inputFactory = XMLInputFactory.newInstance();\r\n    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\r\n    documentBuilderFactory.setNamespaceAware(true);\r\n    documentBuilder = documentBuilderFactory.newDocumentBuilder();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.xml.StaxSourceTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.xml.StaxSourceTests#setUp()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.xml.StaxSourceTests#setUp()",
    "headType": "method",
    "relation": "use",
    "tail": "@BeforeEach",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.xml.StaxSourceTests#streamReaderSourceToStreamResult()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid streamReaderSourceToStreamResult() throws Exception {\r\n    XMLStreamReader streamReader = inputFactory.createXMLStreamReader(new StringReader(XML));\r\n    StaxSource source = new StaxSource(streamReader);\r\n    assertThat(source.getXMLStreamReader()).as(\"Invalid streamReader returned\").isEqualTo(streamReader);\r\n    assertThat(source.getXMLEventReader()).as(\"EventReader returned\").isNull();\r\n    StringWriter writer = new StringWriter();\r\n    transformer.transform(source, new StreamResult(writer));\r\n    assertThat(XmlContent.from(writer)).as(\"Invalid result\").isSimilarTo(XML);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.xml.StaxSourceTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.xml.StaxSourceTests#streamReaderSourceToStreamResult()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.xml.StaxSourceTests#streamReaderSourceToStreamResult()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.xml.StaxSourceTests#streamReaderSourceToDOMResult()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid streamReaderSourceToDOMResult() throws Exception {\r\n    XMLStreamReader streamReader = inputFactory.createXMLStreamReader(new StringReader(XML));\r\n    StaxSource source = new StaxSource(streamReader);\r\n    assertThat(source.getXMLStreamReader()).as(\"Invalid streamReader returned\").isEqualTo(streamReader);\r\n    assertThat(source.getXMLEventReader()).as(\"EventReader returned\").isNull();\r\n    Document expected = documentBuilder.parse(new InputSource(new StringReader(XML)));\r\n    Document result = documentBuilder.newDocument();\r\n    transformer.transform(source, new DOMResult(result));\r\n    assertThat(XmlContent.of(result)).as(\"Invalid result\").isSimilarTo(expected);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.xml.StaxSourceTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.xml.StaxSourceTests#streamReaderSourceToDOMResult()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.xml.StaxSourceTests#streamReaderSourceToDOMResult()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.xml.StaxSourceTests#eventReaderSourceToStreamResult()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid eventReaderSourceToStreamResult() throws Exception {\r\n    XMLEventReader eventReader = inputFactory.createXMLEventReader(new StringReader(XML));\r\n    StaxSource source = new StaxSource(eventReader);\r\n    assertThat(source.getXMLEventReader()).as(\"Invalid eventReader returned\").isEqualTo(eventReader);\r\n    assertThat(source.getXMLStreamReader()).as(\"StreamReader returned\").isNull();\r\n    StringWriter writer = new StringWriter();\r\n    transformer.transform(source, new StreamResult(writer));\r\n    assertThat(XmlContent.from(writer)).as(\"Invalid result\").isSimilarTo(XML);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.xml.StaxSourceTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.xml.StaxSourceTests#eventReaderSourceToStreamResult()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.xml.StaxSourceTests#eventReaderSourceToStreamResult()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.xml.StaxSourceTests#eventReaderSourceToDOMResult()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid eventReaderSourceToDOMResult() throws Exception {\r\n    XMLEventReader eventReader = inputFactory.createXMLEventReader(new StringReader(XML));\r\n    StaxSource source = new StaxSource(eventReader);\r\n    assertThat(source.getXMLEventReader()).as(\"Invalid eventReader returned\").isEqualTo(eventReader);\r\n    assertThat(source.getXMLStreamReader()).as(\"StreamReader returned\").isNull();\r\n    Document expected = documentBuilder.parse(new InputSource(new StringReader(XML)));\r\n    Document result = documentBuilder.newDocument();\r\n    transformer.transform(source, new DOMResult(result));\r\n    assertThat(XmlContent.of(result)).as(\"Invalid result\").isSimilarTo(expected);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.xml.StaxSourceTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.xml.StaxSourceTests#eventReaderSourceToDOMResult()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.xml.StaxSourceTests#eventReaderSourceToDOMResult()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.asm.Frame",
    "headType": "class",
    "relation": "provide",
    "tail": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage org.springframework.asm;\n\n/**\n * The input and output stack map frames of a basic block.\n *\n * <p>Stack map frames are computed in two steps:\n *\n * <ul>\n *   <li>During the visit of each instruction in MethodWriter, the state of the frame at the end of\n *       the current basic block is updated by simulating the action of the instruction on the\n *       previous state of this so called \"output frame\".\n *   <li>After all instructions have been visited, a fix point algorithm is used in MethodWriter to\n *       compute the \"input frame\" of each basic block (i.e. the stack map frame at the beginning of\n *       the basic block). See {@link MethodWriter#computeAllFrames}.\n * </ul>\n *\n * <p>Output stack map frames are computed relatively to the input frame of the basic block, which\n * is not yet known when output frames are computed. It is therefore necessary to be able to\n * represent abstract types such as \"the type at position x in the input frame locals\" or \"the type\n * at position x from the top of the input frame stack\" or even \"the type at position x in the input\n * frame, with y more (or less) array dimensions\". This explains the rather complicated type format\n * used in this class, explained below.\n *\n * <p>The local variables and the operand stack of input and output frames contain values called\n * \"abstract types\" hereafter. An abstract type is represented with 4 fields named DIM, KIND, FLAGS\n * and VALUE, packed in a single int value for better performance and memory efficiency:\n *\n * <pre>\n *   =====================================\n *   |...DIM|KIND|.F|...............VALUE|\n *   =====================================\n * </pre>\n *\n * <ul>\n *   <li>the DIM field, stored in the 6 most significant bits, is a signed number of array\n *       dimensions (from -32 to 31, included). It can be retrieved with {@link #DIM_MASK} and a\n *       right shift of {@link #DIM_SHIFT}.\n *   <li>the KIND field, stored in 4 bits, indicates the kind of VALUE used. These 4 bits can be\n *       retrieved with {@link #KIND_MASK} and, without any shift, must be equal to {@link\n *       #CONSTANT_KIND}, {@link #REFERENCE_KIND}, {@link #UNINITIALIZED_KIND}, {@link\n *       #FORWARD_UNINITIALIZED_KIND},{@link #LOCAL_KIND} or {@link #STACK_KIND}.\n *   <li>the FLAGS field, stored in 2 bits, contains up to 2 boolean flags. Currently only one flag\n *       is defined, namely {@link #TOP_IF_LONG_OR_DOUBLE_FLAG}.\n *   <li>the VALUE field, stored in the remaining 20 bits, contains either\n *       <ul>\n *         <li>one of the constants {@link #ITEM_TOP}, {@link #ITEM_ASM_BOOLEAN}, {@link\n *             #ITEM_ASM_BYTE}, {@link #ITEM_ASM_CHAR} or {@link #ITEM_ASM_SHORT}, {@link\n *             #ITEM_INTEGER}, {@link #ITEM_FLOAT}, {@link #ITEM_LONG}, {@link #ITEM_DOUBLE}, {@link\n *             #ITEM_NULL} or {@link #ITEM_UNINITIALIZED_THIS}, if KIND is equal to {@link\n *             #CONSTANT_KIND}.\n *         <li>the index of a {@link Symbol#TYPE_TAG} {@link Symbol} in the type table of a {@link\n *             SymbolTable}, if KIND is equal to {@link #REFERENCE_KIND}.\n *         <li>the index of an {@link Symbol#UNINITIALIZED_TYPE_TAG} {@link Symbol} in the type\n *             table of a {@link SymbolTable}, if KIND is equal to {@link #UNINITIALIZED_KIND}.\n *         <li>the index of a {@link Symbol#FORWARD_UNINITIALIZED_TYPE_TAG} {@link Symbol} in the\n *             type table of a {@link SymbolTable}, if KIND is equal to {@link\n *             #FORWARD_UNINITIALIZED_KIND}.\n *         <li>the index of a local variable in the input stack frame, if KIND is equal to {@link\n *             #LOCAL_KIND}.\n *         <li>a position relatively to the top of the stack of the input stack frame, if KIND is\n *             equal to {@link #STACK_KIND},\n *       </ul>\n * </ul>\n *\n * <p>Output frames can contain abstract types of any kind and with a positive or negative array\n * dimension (and even unassigned types, represented by 0 - which does not correspond to any valid\n * abstract type value). Input frames can only contain CONSTANT_KIND, REFERENCE_KIND,\n * UNINITIALIZED_KIND or FORWARD_UNINITIALIZED_KIND abstract types of positive or {@literal null}\n * array dimension. In all cases the type table contains only internal type names (array type\n * descriptors are forbidden - array dimensions must be represented through the DIM field).\n *\n * <p>The LONG and DOUBLE types are always represented by using two slots (LONG + TOP or DOUBLE +\n * TOP), for local variables as well as in the operand stack. This is necessary to be able to\n * simulate DUPx_y instructions, whose effect would be dependent on the concrete types represented\n * by the abstract types in the stack (which are not always known).\n *\n * @author Eric Bruneton\n */\nclass Frame {\n\n  // Constants used in the StackMapTable attribute.\n  // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.4.\n\n  static final int SAME_FRAME = 0;\n  static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64;\n  static final int RESERVED = 128;\n  static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247;\n  static final int CHOP_FRAME = 248;\n  static final int SAME_FRAME_EXTENDED = 251;\n  static final int APPEND_FRAME = 252;\n  static final int FULL_FRAME = 255;\n\n  static final int ITEM_TOP = 0;\n  static final int ITEM_INTEGER = 1;\n  static final int ITEM_FLOAT = 2;\n  static final int ITEM_DOUBLE = 3;\n  static final int ITEM_LONG = 4;\n  static final int ITEM_NULL = 5;\n  static final int ITEM_UNINITIALIZED_THIS = 6;\n  static final int ITEM_OBJECT = 7;\n  static final int ITEM_UNINITIALIZED = 8;\n  // Additional, ASM specific constants used in abstract types below.\n  private static final int ITEM_ASM_BOOLEAN = 9;\n  private static final int ITEM_ASM_BYTE = 10;\n  private static final int ITEM_ASM_CHAR = 11;\n  private static final int ITEM_ASM_SHORT = 12;\n\n  // The size and offset in bits of each field of an abstract type.\n\n  private static final int DIM_SIZE = 6;\n  private static final int KIND_SIZE = 4;\n  private static final int FLAGS_SIZE = 2;\n  private static final int VALUE_SIZE = 32 - DIM_SIZE - KIND_SIZE - FLAGS_SIZE;\n\n  private static final int DIM_SHIFT = KIND_SIZE + FLAGS_SIZE + VALUE_SIZE;\n  private static final int KIND_SHIFT = FLAGS_SIZE + VALUE_SIZE;\n  private static final int FLAGS_SHIFT = VALUE_SIZE;\n\n  // Bitmasks to get each field of an abstract type.\n\n  private static final int DIM_MASK = ((1 << DIM_SIZE) - 1) << DIM_SHIFT;\n  private static final int KIND_MASK = ((1 << KIND_SIZE) - 1) << KIND_SHIFT;\n  private static final int VALUE_MASK = (1 << VALUE_SIZE) - 1;\n\n  // Constants to manipulate the DIM field of an abstract type.\n\n  /** The constant to be added to an abstract type to get one with one more array dimension. */\n  private static final int ARRAY_OF = +1 << DIM_SHIFT;\n\n  /** The constant to be added to an abstract type to get one with one less array dimension. */\n  private static final int ELEMENT_OF = -1 << DIM_SHIFT;\n\n  // Possible values for the KIND field of an abstract type.\n\n  private static final int CONSTANT_KIND = 1 << KIND_SHIFT;\n  private static final int REFERENCE_KIND = 2 << KIND_SHIFT;\n  private static final int UNINITIALIZED_KIND = 3 << KIND_SHIFT;\n  private static final int FORWARD_UNINITIALIZED_KIND = 4 << KIND_SHIFT;\n  private static final int LOCAL_KIND = 5 << KIND_SHIFT;\n  private static final int STACK_KIND = 6 << KIND_SHIFT;\n\n  // Possible flags for the FLAGS field of an abstract type.\n\n  /**\n   * A flag used for LOCAL_KIND and STACK_KIND abstract types, indicating that if the resolved,\n   * concrete type is LONG or DOUBLE, TOP should be used instead (because the value has been\n   * partially overridden with an xSTORE instruction).\n   */\n  private static final int TOP_IF_LONG_OR_DOUBLE_FLAG = 1 << FLAGS_SHIFT;\n\n  // Useful predefined abstract types (all the possible CONSTANT_KIND types).\n\n  private static final int TOP = CONSTANT_KIND | ITEM_TOP;\n  private static final int BOOLEAN = CONSTANT_KIND | ITEM_ASM_BOOLEAN;\n  private static final int BYTE = CONSTANT_KIND | ITEM_ASM_BYTE;\n  private static final int CHAR = CONSTANT_KIND | ITEM_ASM_CHAR;\n  private static final int SHORT = CONSTANT_KIND | ITEM_ASM_SHORT;\n  private static final int INTEGER = CONSTANT_KIND | ITEM_INTEGER;\n  private static final int FLOAT = CONSTANT_KIND | ITEM_FLOAT;\n  private static final int LONG = CONSTANT_KIND | ITEM_LONG;\n  private static final int DOUBLE = CONSTANT_KIND | ITEM_DOUBLE;\n  private static final int NULL = CONSTANT_KIND | ITEM_NULL;\n  private static final int UNINITIALIZED_THIS = CONSTANT_KIND | ITEM_UNINITIALIZED_THIS;\n\n  // -----------------------------------------------------------------------------------------------\n  // Instance fields\n  // -----------------------------------------------------------------------------------------------\n\n  /** The basic block to which these input and output stack map frames correspond. */\n  Label owner;\n\n  /** The input stack map frame locals. This is an array of abstract types. */\n  private int[] inputLocals;\n\n  /** The input stack map frame stack. This is an array of abstract types. */\n  private int[] inputStack;\n\n  /** The output stack map frame locals. This is an array of abstract types. */\n  private int[] outputLocals;\n\n  /** The output stack map frame stack. This is an array of abstract types. */\n  private int[] outputStack;\n\n  /**\n   * The start of the output stack, relatively to the input stack. This offset is always negative or\n   * null. A null offset means that the output stack must be appended to the input stack. A -n\n   * offset means that the first n output stack elements must replace the top n input stack\n   * elements, and that the other elements must be appended to the input stack.\n   */\n  private short outputStackStart;\n\n  /** The index of the top stack element in {@link #outputStack}. */\n  private short outputStackTop;\n\n  /** The number of types that are initialized in the basic block. See {@link #initializations}. */\n  private int initializationCount;\n\n  /**\n   * The abstract types that are initialized in the basic block. A constructor invocation on an\n   * UNINITIALIZED, FORWARD_UNINITIALIZED or UNINITIALIZED_THIS abstract type must replace <i>every\n   * occurrence</i> of this type in the local variables and in the operand stack. This cannot be\n   * done during the first step of the algorithm since, during this step, the local variables and\n   * the operand stack types are still abstract. It is therefore necessary to store the abstract\n   * types of the constructors which are invoked in the basic block, in order to do this replacement\n   * during the second step of the algorithm, where the frames are fully computed. Note that this\n   * array can contain abstract types that are relative to the input locals or to the input stack.\n   */\n  private int[] initializations;\n\n  // -----------------------------------------------------------------------------------------------\n  // Constructor\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Constructs a new Frame.\n   *\n   * @param owner the basic block to which these input and output stack map frames correspond.\n   */\n  Frame(final Label owner) {\n    this.owner = owner;\n  }\n\n  /**\n   * Sets this frame to the value of the given frame.\n   *\n   * <p>WARNING: after this method is called the two frames share the same data structures. It is\n   * recommended to discard the given frame to avoid unexpected side effects.\n   *\n   * @param frame The new frame value.\n   */\n  final void copyFrom(final Frame frame) {\n    inputLocals = frame.inputLocals;\n    inputStack = frame.inputStack;\n    outputStackStart = 0;\n    outputLocals = frame.outputLocals;\n    outputStack = frame.outputStack;\n    outputStackTop = frame.outputStackTop;\n    initializationCount = frame.initializationCount;\n    initializations = frame.initializations;\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Static methods to get abstract types from other type formats\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Returns the abstract type corresponding to the given public API frame element type.\n   *\n   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n   * @param type a frame element type described using the same format as in {@link\n   *     MethodVisitor#visitFrame}, i.e. either {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link\n   *     Opcodes#FLOAT}, {@link Opcodes#LONG}, {@link Opcodes#DOUBLE}, {@link Opcodes#NULL}, or\n   *     {@link Opcodes#UNINITIALIZED_THIS}, or the internal name of a class, or a Label designating\n   *     a NEW instruction (for uninitialized types).\n   * @return the abstract type corresponding to the given frame element type.\n   */\n  static int getAbstractTypeFromApiFormat(final SymbolTable symbolTable, final Object type) {\n    if (type instanceof Integer) {\n      return CONSTANT_KIND | ((Integer) type).intValue();\n    } else if (type instanceof String) {\n      String descriptor = Type.getObjectType((String) type).getDescriptor();\n      return getAbstractTypeFromDescriptor(symbolTable, descriptor, 0);\n    } else {\n      Label label = (Label) type;\n      if ((label.flags & Label.FLAG_RESOLVED) != 0) {\n        return UNINITIALIZED_KIND | symbolTable.addUninitializedType(\"\", label.bytecodeOffset);\n      } else {\n        return FORWARD_UNINITIALIZED_KIND | symbolTable.addForwardUninitializedType(\"\", label);\n      }\n    }\n  }\n\n  /**\n   * Returns the abstract type corresponding to the internal name of a class.\n   *\n   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n   * @param internalName the internal name of a class. This must <i>not</i> be an array type\n   *     descriptor.\n   * @return the abstract type value corresponding to the given internal name.\n   */\n  static int getAbstractTypeFromInternalName(\n      final SymbolTable symbolTable, final String internalName) {\n    return REFERENCE_KIND | symbolTable.addType(internalName);\n  }\n\n  /**\n   * Returns the abstract type corresponding to the given type descriptor.\n   *\n   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n   * @param buffer a string ending with a type descriptor.\n   * @param offset the start offset of the type descriptor in buffer.\n   * @return the abstract type corresponding to the given type descriptor.\n   */\n  private static int getAbstractTypeFromDescriptor(\n      final SymbolTable symbolTable, final String buffer, final int offset) {\n    String internalName;\n    switch (buffer.charAt(offset)) {\n      case 'V':\n        return 0;\n      case 'Z':\n      case 'C':\n      case 'B':\n      case 'S':\n      case 'I':\n        return INTEGER;\n      case 'F':\n        return FLOAT;\n      case 'J':\n        return LONG;\n      case 'D':\n        return DOUBLE;\n      case 'L':\n        internalName = buffer.substring(offset + 1, buffer.length() - 1);\n        return REFERENCE_KIND | symbolTable.addType(internalName);\n      case '[':\n        int elementDescriptorOffset = offset + 1;\n        while (buffer.charAt(elementDescriptorOffset) == '[') {\n          ++elementDescriptorOffset;\n        }\n        int typeValue;\n        switch (buffer.charAt(elementDescriptorOffset)) {\n          case 'Z':\n            typeValue = BOOLEAN;\n            break;\n          case 'C':\n            typeValue = CHAR;\n            break;\n          case 'B':\n            typeValue = BYTE;\n            break;\n          case 'S':\n            typeValue = SHORT;\n            break;\n          case 'I':\n            typeValue = INTEGER;\n            break;\n          case 'F':\n            typeValue = FLOAT;\n            break;\n          case 'J':\n            typeValue = LONG;\n            break;\n          case 'D':\n            typeValue = DOUBLE;\n            break;\n          case 'L':\n            internalName = buffer.substring(elementDescriptorOffset + 1, buffer.length() - 1);\n            typeValue = REFERENCE_KIND | symbolTable.addType(internalName);\n            break;\n          default:\n            throw new IllegalArgumentException(\n                \"Invalid descriptor fragment: \" + buffer.substring(elementDescriptorOffset));\n        }\n        return ((elementDescriptorOffset - offset) << DIM_SHIFT) | typeValue;\n      default:\n        throw new IllegalArgumentException(\"Invalid descriptor: \" + buffer.substring(offset));\n    }\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Methods related to the input frame\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Sets the input frame from the given method description. This method is used to initialize the\n   * first frame of a method, which is implicit (i.e. not stored explicitly in the StackMapTable\n   * attribute).\n   *\n   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n   * @param access the method's access flags.\n   * @param descriptor the method descriptor.\n   * @param maxLocals the maximum number of local variables of the method.\n   */\n  final void setInputFrameFromDescriptor(\n      final SymbolTable symbolTable,\n      final int access,\n      final String descriptor,\n      final int maxLocals) {\n    inputLocals = new int[maxLocals];\n    inputStack = new int[0];\n    int inputLocalIndex = 0;\n    if ((access & Opcodes.ACC_STATIC) == 0) {\n      if ((access & Constants.ACC_CONSTRUCTOR) == 0) {\n        inputLocals[inputLocalIndex++] =\n            REFERENCE_KIND | symbolTable.addType(symbolTable.getClassName());\n      } else {\n        inputLocals[inputLocalIndex++] = UNINITIALIZED_THIS;\n      }\n    }\n    for (Type argumentType : Type.getArgumentTypes(descriptor)) {\n      int abstractType =\n          getAbstractTypeFromDescriptor(symbolTable, argumentType.getDescriptor(), 0);\n      inputLocals[inputLocalIndex++] = abstractType;\n      if (abstractType == LONG || abstractType == DOUBLE) {\n        inputLocals[inputLocalIndex++] = TOP;\n      }\n    }\n    while (inputLocalIndex < maxLocals) {\n      inputLocals[inputLocalIndex++] = TOP;\n    }\n  }\n\n  /**\n   * Sets the input frame from the given public API frame description.\n   *\n   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n   * @param numLocal the number of local variables.\n   * @param local the local variable types, described using the same format as in {@link\n   *     MethodVisitor#visitFrame}.\n   * @param numStack the number of operand stack elements.\n   * @param stack the operand stack types, described using the same format as in {@link\n   *     MethodVisitor#visitFrame}.\n   */\n  final void setInputFrameFromApiFormat(\n      final SymbolTable symbolTable,\n      final int numLocal,\n      final Object[] local,\n      final int numStack,\n      final Object[] stack) {\n    int inputLocalIndex = 0;\n    for (int i = 0; i < numLocal; ++i) {\n      inputLocals[inputLocalIndex++] = getAbstractTypeFromApiFormat(symbolTable, local[i]);\n      if (local[i] == Opcodes.LONG || local[i] == Opcodes.DOUBLE) {\n        inputLocals[inputLocalIndex++] = TOP;\n      }\n    }\n    while (inputLocalIndex < inputLocals.length) {\n      inputLocals[inputLocalIndex++] = TOP;\n    }\n    int numStackTop = 0;\n    for (int i = 0; i < numStack; ++i) {\n      if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) {\n        ++numStackTop;\n      }\n    }\n    inputStack = new int[numStack + numStackTop];\n    int inputStackIndex = 0;\n    for (int i = 0; i < numStack; ++i) {\n      inputStack[inputStackIndex++] = getAbstractTypeFromApiFormat(symbolTable, stack[i]);\n      if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) {\n        inputStack[inputStackIndex++] = TOP;\n      }\n    }\n    outputStackTop = 0;\n    initializationCount = 0;\n  }\n\n  final int getInputStackSize() {\n    return inputStack.length;\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Methods related to the output frame\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Returns the abstract type stored at the given local variable index in the output frame.\n   *\n   * @param localIndex the index of the local variable whose value must be returned.\n   * @return the abstract type stored at the given local variable index in the output frame.\n   */\n  private int getLocal(final int localIndex) {\n    if (outputLocals == null || localIndex >= outputLocals.length) {\n      // If this local has never been assigned in this basic block, it is still equal to its value\n      // in the input frame.\n      return LOCAL_KIND | localIndex;\n    } else {\n      int abstractType = outputLocals[localIndex];\n      if (abstractType == 0) {\n        // If this local has never been assigned in this basic block, so it is still equal to its\n        // value in the input frame.\n        abstractType = outputLocals[localIndex] = LOCAL_KIND | localIndex;\n      }\n      return abstractType;\n    }\n  }\n\n  /**\n   * Replaces the abstract type stored at the given local variable index in the output frame.\n   *\n   * @param localIndex the index of the output frame local variable that must be set.\n   * @param abstractType the value that must be set.\n   */\n  private void setLocal(final int localIndex, final int abstractType) {\n    // Create and/or resize the output local variables array if necessary.\n    if (outputLocals == null) {\n      outputLocals = new int[10];\n    }\n    int outputLocalsLength = outputLocals.length;\n    if (localIndex >= outputLocalsLength) {\n      int[] newOutputLocals = new int[Math.max(localIndex + 1, 2 * outputLocalsLength)];\n      System.arraycopy(outputLocals, 0, newOutputLocals, 0, outputLocalsLength);\n      outputLocals = newOutputLocals;\n    }\n    // Set the local variable.\n    outputLocals[localIndex] = abstractType;\n  }\n\n  /**\n   * Pushes the given abstract type on the output frame stack.\n   *\n   * @param abstractType an abstract type.\n   */\n  private void push(final int abstractType) {\n    // Create and/or resize the output stack array if necessary.\n    if (outputStack == null) {\n      outputStack = new int[10];\n    }\n    int outputStackLength = outputStack.length;\n    if (outputStackTop >= outputStackLength) {\n      int[] newOutputStack = new int[Math.max(outputStackTop + 1, 2 * outputStackLength)];\n      System.arraycopy(outputStack, 0, newOutputStack, 0, outputStackLength);\n      outputStack = newOutputStack;\n    }\n    // Pushes the abstract type on the output stack.\n    outputStack[outputStackTop++] = abstractType;\n    // Updates the maximum size reached by the output stack, if needed (note that this size is\n    // relative to the input stack size, which is not known yet).\n    short outputStackSize = (short) (outputStackStart + outputStackTop);\n    if (outputStackSize > owner.outputStackMax) {\n      owner.outputStackMax = outputStackSize;\n    }\n  }\n\n  /**\n   * Pushes the abstract type corresponding to the given descriptor on the output frame stack.\n   *\n   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n   * @param descriptor a type or method descriptor (in which case its return type is pushed).\n   */\n  private void push(final SymbolTable symbolTable, final String descriptor) {\n    int typeDescriptorOffset =\n        descriptor.charAt(0) == '(' ? Type.getReturnTypeOffset(descriptor) : 0;\n    int abstractType = getAbstractTypeFromDescriptor(symbolTable, descriptor, typeDescriptorOffset);\n    if (abstractType != 0) {\n      push(abstractType);\n      if (abstractType == LONG || abstractType == DOUBLE) {\n        push(TOP);\n      }\n    }\n  }\n\n  /**\n   * Pops an abstract type from the output frame stack and returns its value.\n   *\n   * @return the abstract type that has been popped from the output frame stack.\n   */\n  private int pop() {\n    if (outputStackTop > 0) {\n      return outputStack[--outputStackTop];\n    } else {\n      // If the output frame stack is empty, pop from the input stack.\n      return STACK_KIND | -(--outputStackStart);\n    }\n  }\n\n  /**\n   * Pops the given number of abstract types from the output frame stack.\n   *\n   * @param elements the number of abstract types that must be popped.\n   */\n  private void pop(final int elements) {\n    if (outputStackTop >= elements) {\n      outputStackTop -= elements;\n    } else {\n      // If the number of elements to be popped is greater than the number of elements in the output\n      // stack, clear it, and pop the remaining elements from the input stack.\n      outputStackStart -= elements - outputStackTop;\n      outputStackTop = 0;\n    }\n  }\n\n  /**\n   * Pops as many abstract types from the output frame stack as described by the given descriptor.\n   *\n   * @param descriptor a type or method descriptor (in which case its argument types are popped).\n   */\n  private void pop(final String descriptor) {\n    char firstDescriptorChar = descriptor.charAt(0);\n    if (firstDescriptorChar == '(') {\n      pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1);\n    } else if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') {\n      pop(2);\n    } else {\n      pop(1);\n    }\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Methods to handle uninitialized types\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Adds an abstract type to the list of types on which a constructor is invoked in the basic\n   * block.\n   *\n   * @param abstractType an abstract type on a which a constructor is invoked.\n   */\n  private void addInitializedType(final int abstractType) {\n    // Create and/or resize the initializations array if necessary.\n    if (initializations == null) {\n      initializations = new int[2];\n    }\n    int initializationsLength = initializations.length;\n    if (initializationCount >= initializationsLength) {\n      int[] newInitializations =\n          new int[Math.max(initializationCount + 1, 2 * initializationsLength)];\n      System.arraycopy(initializations, 0, newInitializations, 0, initializationsLength);\n      initializations = newInitializations;\n    }\n    // Store the abstract type.\n    initializations[initializationCount++] = abstractType;\n  }\n\n  /**\n   * Returns the \"initialized\" abstract type corresponding to the given abstract type.\n   *\n   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n   * @param abstractType an abstract type.\n   * @return the REFERENCE_KIND abstract type corresponding to abstractType if it is\n   *     UNINITIALIZED_THIS or an UNINITIALIZED_KIND or FORWARD_UNINITIALIZED_KIND abstract type for\n   *     one of the types on which a constructor is invoked in the basic block. Otherwise returns\n   *     abstractType.\n   */\n  private int getInitializedType(final SymbolTable symbolTable, final int abstractType) {\n    if (abstractType == UNINITIALIZED_THIS\n        || (abstractType & (DIM_MASK | KIND_MASK)) == UNINITIALIZED_KIND\n        || (abstractType & (DIM_MASK | KIND_MASK)) == FORWARD_UNINITIALIZED_KIND) {\n      for (int i = 0; i < initializationCount; ++i) {\n        int initializedType = initializations[i];\n        int dim = initializedType & DIM_MASK;\n        int kind = initializedType & KIND_MASK;\n        int value = initializedType & VALUE_MASK;\n        if (kind == LOCAL_KIND) {\n          initializedType = dim + inputLocals[value];\n        } else if (kind == STACK_KIND) {\n          initializedType = dim + inputStack[inputStack.length - value];\n        }\n        if (abstractType == initializedType) {\n          if (abstractType == UNINITIALIZED_THIS) {\n            return REFERENCE_KIND | symbolTable.addType(symbolTable.getClassName());\n          } else {\n            return REFERENCE_KIND\n                | symbolTable.addType(symbolTable.getType(abstractType & VALUE_MASK).value);\n          }\n        }\n      }\n    }\n    return abstractType;\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Main method, to simulate the execution of each instruction on the output frame\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Simulates the action of the given instruction on the output stack frame.\n   *\n   * @param opcode the opcode of the instruction.\n   * @param arg the numeric operand of the instruction, if any.\n   * @param argSymbol the Symbol operand of the instruction, if any.\n   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n   */\n  void execute(\n      final int opcode, final int arg, final Symbol argSymbol, final SymbolTable symbolTable) {\n    // Abstract types popped from the stack or read from local variables.\n    int abstractType1;\n    int abstractType2;\n    int abstractType3;\n    int abstractType4;\n    switch (opcode) {\n      case Opcodes.NOP:\n      case Opcodes.INEG:\n      case Opcodes.LNEG:\n      case Opcodes.FNEG:\n      case Opcodes.DNEG:\n      case Opcodes.I2B:\n      case Opcodes.I2C:\n      case Opcodes.I2S:\n      case Opcodes.GOTO:\n      case Opcodes.RETURN:\n        break;\n      case Opcodes.ACONST_NULL:\n        push(NULL);\n        break;\n      case Opcodes.ICONST_M1:\n      case Opcodes.ICONST_0:\n      case Opcodes.ICONST_1:\n      case Opcodes.ICONST_2:\n      case Opcodes.ICONST_3:\n      case Opcodes.ICONST_4:\n      case Opcodes.ICONST_5:\n      case Opcodes.BIPUSH:\n      case Opcodes.SIPUSH:\n      case Opcodes.ILOAD:\n        push(INTEGER);\n        break;\n      case Opcodes.LCONST_0:\n      case Opcodes.LCONST_1:\n      case Opcodes.LLOAD:\n        push(LONG);\n        push(TOP);\n        break;\n      case Opcodes.FCONST_0:\n      case Opcodes.FCONST_1:\n      case Opcodes.FCONST_2:\n      case Opcodes.FLOAD:\n        push(FLOAT);\n        break;\n      case Opcodes.DCONST_0:\n      case Opcodes.DCONST_1:\n      case Opcodes.DLOAD:\n        push(DOUBLE);\n        push(TOP);\n        break;\n      case Opcodes.LDC:\n        switch (argSymbol.tag) {\n          case Symbol.CONSTANT_INTEGER_TAG:\n            push(INTEGER);\n            break;\n          case Symbol.CONSTANT_LONG_TAG:\n            push(LONG);\n            push(TOP);\n            break;\n          case Symbol.CONSTANT_FLOAT_TAG:\n            push(FLOAT);\n            break;\n          case Symbol.CONSTANT_DOUBLE_TAG:\n            push(DOUBLE);\n            push(TOP);\n            break;\n          case Symbol.CONSTANT_CLASS_TAG:\n            push(REFERENCE_KIND | symbolTable.addType(\"java/lang/Class\"));\n            break;\n          case Symbol.CONSTANT_STRING_TAG:\n            push(REFERENCE_KIND | symbolTable.addType(\"java/lang/String\"));\n            break;\n          case Symbol.CONSTANT_METHOD_TYPE_TAG:\n            push(REFERENCE_KIND | symbolTable.addType(\"java/lang/invoke/MethodType\"));\n            break;\n          case Symbol.CONSTANT_METHOD_HANDLE_TAG:\n            push(REFERENCE_KIND | symbolTable.addType(\"java/lang/invoke/MethodHandle\"));\n            break;\n          case Symbol.CONSTANT_DYNAMIC_TAG:\n            push(symbolTable, argSymbol.value);\n            break;\n          default:\n            throw new AssertionError();\n        }\n        break;\n      case Opcodes.ALOAD:\n        push(getLocal(arg));\n        break;\n      case Opcodes.LALOAD:\n      case Opcodes.D2L:\n        pop(2);\n        push(LONG);\n        push(TOP);\n        break;\n      case Opcodes.DALOAD:\n      case Opcodes.L2D:\n        pop(2);\n        push(DOUBLE);\n        push(TOP);\n        break;\n      case Opcodes.AALOAD:\n        pop(1);\n        abstractType1 = pop();\n        push(abstractType1 == NULL ? abstractType1 : ELEMENT_OF + abstractType1);\n        break;\n      case Opcodes.ISTORE:\n      case Opcodes.FSTORE:\n      case Opcodes.ASTORE:\n        abstractType1 = pop();\n        setLocal(arg, abstractType1);\n        if (arg > 0) {\n          int previousLocalType = getLocal(arg - 1);\n          if (previousLocalType == LONG || previousLocalType == DOUBLE) {\n            setLocal(arg - 1, TOP);\n          } else if ((previousLocalType & KIND_MASK) == LOCAL_KIND\n              || (previousLocalType & KIND_MASK) == STACK_KIND) {\n            // The type of the previous local variable is not known yet, but if it later appears\n            // to be LONG or DOUBLE, we should then use TOP instead.\n            setLocal(arg - 1, previousLocalType | TOP_IF_LONG_OR_DOUBLE_FLAG);\n          }\n        }\n        break;\n      case Opcodes.LSTORE:\n      case Opcodes.DSTORE:\n        pop(1);\n        abstractType1 = pop();\n        setLocal(arg, abstractType1);\n        setLocal(arg + 1, TOP);\n        if (arg > 0) {\n          int previousLocalType = getLocal(arg - 1);\n          if (previousLocalType == LONG || previousLocalType == DOUBLE) {\n            setLocal(arg - 1, TOP);\n          } else if ((previousLocalType & KIND_MASK) == LOCAL_KIND\n              || (previousLocalType & KIND_MASK) == STACK_KIND) {\n            // The type of the previous local variable is not known yet, but if it later appears\n            // to be LONG or DOUBLE, we should then use TOP instead.\n            setLocal(arg - 1, previousLocalType | TOP_IF_LONG_OR_DOUBLE_FLAG);\n          }\n        }\n        break;\n      case Opcodes.IASTORE:\n      case Opcodes.BASTORE:\n      case Opcodes.CASTORE:\n      case Opcodes.SASTORE:\n      case Opcodes.FASTORE:\n      case Opcodes.AASTORE:\n        pop(3);\n        break;\n      case Opcodes.LASTORE:\n      case Opcodes.DASTORE:\n        pop(4);\n        break;\n      case Opcodes.POP:\n      case Opcodes.IFEQ:\n      case Opcodes.IFNE:\n      case Opcodes.IFLT:\n      case Opcodes.IFGE:\n      case Opcodes.IFGT:\n      case Opcodes.IFLE:\n      case Opcodes.IRETURN:\n      case Opcodes.FRETURN:\n      case Opcodes.ARETURN:\n      case Opcodes.TABLESWITCH:\n      case Opcodes.LOOKUPSWITCH:\n      case Opcodes.ATHROW:\n      case Opcodes.MONITORENTER:\n      case Opcodes.MONITOREXIT:\n      case Opcodes.IFNULL:\n      case Opcodes.IFNONNULL:\n        pop(1);\n        break;\n      case Opcodes.POP2:\n      case Opcodes.IF_ICMPEQ:\n      case Opcodes.IF_ICMPNE:\n      case Opcodes.IF_ICMPLT:\n      case Opcodes.IF_ICMPGE:\n      case Opcodes.IF_ICMPGT:\n      case Opcodes.IF_ICMPLE:\n      case Opcodes.IF_ACMPEQ:\n      case Opcodes.IF_ACMPNE:\n      case Opcodes.LRETURN:\n      case Opcodes.DRETURN:\n        pop(2);\n        break;\n      case Opcodes.DUP:\n        abstractType1 = pop();\n        push(abstractType1);\n        push(abstractType1);\n        break;\n      case Opcodes.DUP_X1:\n        abstractType1 = pop();\n        abstractType2 = pop();\n        push(abstractType1);\n        push(abstractType2);\n        push(abstractType1);\n        break;\n      case Opcodes.DUP_X2:\n        abstractType1 = pop();\n        abstractType2 = pop();\n        abstractType3 = pop();\n        push(abstractType1);\n        push(abstractType3);\n        push(abstractType2);\n        push(abstractType1);\n        break;\n      case Opcodes.DUP2:\n        abstractType1 = pop();\n        abstractType2 = pop();\n        push(abstractType2);\n        push(abstractType1);\n        push(abstractType2);\n        push(abstractType1);\n        break;\n      case Opcodes.DUP2_X1:\n        abstractType1 = pop();\n        abstractType2 = pop();\n        abstractType3 = pop();\n        push(abstractType2);\n        push(abstractType1);\n        push(abstractType3);\n        push(abstractType2);\n        push(abstractType1);\n        break;\n      case Opcodes.DUP2_X2:\n        abstractType1 = pop();\n        abstractType2 = pop();\n        abstractType3 = pop();\n        abstractType4 = pop();\n        push(abstractType2);\n        push(abstractType1);\n        push(abstractType4);\n        push(abstractType3);\n        push(abstractType2);\n        push(abstractType1);\n        break;\n      case Opcodes.SWAP:\n        abstractType1 = pop();\n        abstractType2 = pop();\n        push(abstractType1);\n        push(abstractType2);\n        break;\n      case Opcodes.IALOAD:\n      case Opcodes.BALOAD:\n      case Opcodes.CALOAD:\n      case Opcodes.SALOAD:\n      case Opcodes.IADD:\n      case Opcodes.ISUB:\n      case Opcodes.IMUL:\n      case Opcodes.IDIV:\n      case Opcodes.IREM:\n      case Opcodes.IAND:\n      case Opcodes.IOR:\n      case Opcodes.IXOR:\n      case Opcodes.ISHL:\n      case Opcodes.ISHR:\n      case Opcodes.IUSHR:\n      case Opcodes.L2I:\n      case Opcodes.D2I:\n      case Opcodes.FCMPL:\n      case Opcodes.FCMPG:\n        pop(2);\n        push(INTEGER);\n        break;\n      case Opcodes.LADD:\n      case Opcodes.LSUB:\n      case Opcodes.LMUL:\n      case Opcodes.LDIV:\n      case Opcodes.LREM:\n      case Opcodes.LAND:\n      case Opcodes.LOR:\n      case Opcodes.LXOR:\n        pop(4);\n        push(LONG);\n        push(TOP);\n        break;\n      case Opcodes.FALOAD:\n      case Opcodes.FADD:\n      case Opcodes.FSUB:\n      case Opcodes.FMUL:\n      case Opcodes.FDIV:\n      case Opcodes.FREM:\n      case Opcodes.L2F:\n      case Opcodes.D2F:\n        pop(2);\n        push(FLOAT);\n        break;\n      case Opcodes.DADD:\n      case Opcodes.DSUB:\n      case Opcodes.DMUL:\n      case Opcodes.DDIV:\n      case Opcodes.DREM:\n        pop(4);\n        push(DOUBLE);\n        push(TOP);\n        break;\n      case Opcodes.LSHL:\n      case Opcodes.LSHR:\n      case Opcodes.LUSHR:\n        pop(3);\n        push(LONG);\n        push(TOP);\n        break;\n      case Opcodes.IINC:\n        setLocal(arg, INTEGER);\n        break;\n      case Opcodes.I2L:\n      case Opcodes.F2L:\n        pop(1);\n        push(LONG);\n        push(TOP);\n        break;\n      case Opcodes.I2F:\n        pop(1);\n        push(FLOAT);\n        break;\n      case Opcodes.I2D:\n      case Opcodes.F2D:\n        pop(1);\n        push(DOUBLE);\n        push(TOP);\n        break;\n      case Opcodes.F2I:\n      case Opcodes.ARRAYLENGTH:\n      case Opcodes.INSTANCEOF:\n        pop(1);\n        push(INTEGER);\n        break;\n      case Opcodes.LCMP:\n      case Opcodes.DCMPL:\n      case Opcodes.DCMPG:\n        pop(4);\n        push(INTEGER);\n        break;\n      case Opcodes.JSR:\n      case Opcodes.RET:\n        throw new IllegalArgumentException(\"JSR/RET are not supported with computeFrames option\");\n      case Opcodes.GETSTATIC:\n        push(symbolTable, argSymbol.value);\n        break;\n      case Opcodes.PUTSTATIC:\n        pop(argSymbol.value);\n        break;\n      case Opcodes.GETFIELD:\n        pop(1);\n        push(symbolTable, argSymbol.value);\n        break;\n      case Opcodes.PUTFIELD:\n        pop(argSymbol.value);\n        pop();\n        break;\n      case Opcodes.INVOKEVIRTUAL:\n      case Opcodes.INVOKESPECIAL:\n      case Opcodes.INVOKESTATIC:\n      case Opcodes.INVOKEINTERFACE:\n        pop(argSymbol.value);\n        if (opcode != Opcodes.INVOKESTATIC) {\n          abstractType1 = pop();\n          if (opcode == Opcodes.INVOKESPECIAL && argSymbol.name.charAt(0) == '<') {\n            addInitializedType(abstractType1);\n          }\n        }\n        push(symbolTable, argSymbol.value);\n        break;\n      case Opcodes.INVOKEDYNAMIC:\n        pop(argSymbol.value);\n        push(symbolTable, argSymbol.value);\n        break;\n      case Opcodes.NEW:\n        push(UNINITIALIZED_KIND | symbolTable.addUninitializedType(argSymbol.value, arg));\n        break;\n      case Opcodes.NEWARRAY:\n        pop();\n        switch (arg) {\n          case Opcodes.T_BOOLEAN:\n            push(ARRAY_OF | BOOLEAN);\n            break;\n          case Opcodes.T_CHAR:\n            push(ARRAY_OF | CHAR);\n            break;\n          case Opcodes.T_BYTE:\n            push(ARRAY_OF | BYTE);\n            break;\n          case Opcodes.T_SHORT:\n            push(ARRAY_OF | SHORT);\n            break;\n          case Opcodes.T_INT:\n            push(ARRAY_OF | INTEGER);\n            break;\n          case Opcodes.T_FLOAT:\n            push(ARRAY_OF | FLOAT);\n            break;\n          case Opcodes.T_DOUBLE:\n            push(ARRAY_OF | DOUBLE);\n            break;\n          case Opcodes.T_LONG:\n            push(ARRAY_OF | LONG);\n            break;\n          default:\n            throw new IllegalArgumentException();\n        }\n        break;\n      case Opcodes.ANEWARRAY:\n        String arrayElementType = argSymbol.value;\n        pop();\n        if (arrayElementType.charAt(0) == '[') {\n          push(symbolTable, '[' + arrayElementType);\n        } else {\n          push(ARRAY_OF | REFERENCE_KIND | symbolTable.addType(arrayElementType));\n        }\n        break;\n      case Opcodes.CHECKCAST:\n        String castType = argSymbol.value;\n        pop();\n        if (castType.charAt(0) == '[') {\n          push(symbolTable, castType);\n        } else {\n          push(REFERENCE_KIND | symbolTable.addType(castType));\n        }\n        break;\n      case Opcodes.MULTIANEWARRAY:\n        pop(arg);\n        push(symbolTable, argSymbol.value);\n        break;\n      default:\n        throw new IllegalArgumentException();\n    }\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Frame merging methods, used in the second step of the stack map frame computation algorithm\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Computes the concrete output type corresponding to a given abstract output type.\n   *\n   * @param abstractOutputType an abstract output type.\n   * @param numStack the size of the input stack, used to resolve abstract output types of\n   *     STACK_KIND kind.\n   * @return the concrete output type corresponding to 'abstractOutputType'.\n   */\n  private int getConcreteOutputType(final int abstractOutputType, final int numStack) {\n    int dim = abstractOutputType & DIM_MASK;\n    int kind = abstractOutputType & KIND_MASK;\n    if (kind == LOCAL_KIND) {\n      // By definition, a LOCAL_KIND type designates the concrete type of a local variable at\n      // the beginning of the basic block corresponding to this frame (which is known when\n      // this method is called, but was not when the abstract type was computed).\n      int concreteOutputType = dim + inputLocals[abstractOutputType & VALUE_MASK];\n      if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0\n          && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {\n        concreteOutputType = TOP;\n      }\n      return concreteOutputType;\n    } else if (kind == STACK_KIND) {\n      // By definition, a STACK_KIND type designates the concrete type of a local variable at\n      // the beginning of the basic block corresponding to this frame (which is known when\n      // this method is called, but was not when the abstract type was computed).\n      int concreteOutputType = dim + inputStack[numStack - (abstractOutputType & VALUE_MASK)];\n      if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0\n          && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {\n        concreteOutputType = TOP;\n      }\n      return concreteOutputType;\n    } else {\n      return abstractOutputType;\n    }\n  }\n\n  /**\n   * Merges the input frame of the given {@link Frame} with the input and output frames of this\n   * {@link Frame}. Returns {@literal true} if the given frame has been changed by this operation\n   * (the input and output frames of this {@link Frame} are never changed).\n   *\n   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n   * @param dstFrame the {@link Frame} whose input frame must be updated. This should be the frame\n   *     of a successor, in the control flow graph, of the basic block corresponding to this frame.\n   * @param catchTypeIndex if 'frame' corresponds to an exception handler basic block, the type\n   *     table index of the caught exception type, otherwise 0.\n   * @return {@literal true} if the input frame of 'frame' has been changed by this operation.\n   */\n  final boolean merge(\n      final SymbolTable symbolTable, final Frame dstFrame, final int catchTypeIndex) {\n    boolean frameChanged = false;\n\n    // Compute the concrete types of the local variables at the end of the basic block corresponding\n    // to this frame, by resolving its abstract output types, and merge these concrete types with\n    // those of the local variables in the input frame of dstFrame.\n    int numLocal = inputLocals.length;\n    int numStack = inputStack.length;\n    if (dstFrame.inputLocals == null) {\n      dstFrame.inputLocals = new int[numLocal];\n      frameChanged = true;\n    }\n    for (int i = 0; i < numLocal; ++i) {\n      int concreteOutputType;\n      if (outputLocals != null && i < outputLocals.length) {\n        int abstractOutputType = outputLocals[i];\n        if (abstractOutputType == 0) {\n          // If the local variable has never been assigned in this basic block, it is equal to its\n          // value at the beginning of the block.\n          concreteOutputType = inputLocals[i];\n        } else {\n          concreteOutputType = getConcreteOutputType(abstractOutputType, numStack);\n        }\n      } else {\n        // If the local variable has never been assigned in this basic block, it is equal to its\n        // value at the beginning of the block.\n        concreteOutputType = inputLocals[i];\n      }\n      // concreteOutputType might be an uninitialized type from the input locals or from the input\n      // stack. However, if a constructor has been called for this class type in the basic block,\n      // then this type is no longer uninitialized at the end of basic block.\n      if (initializations != null) {\n        concreteOutputType = getInitializedType(symbolTable, concreteOutputType);\n      }\n      frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputLocals, i);\n    }\n\n    // If dstFrame is an exception handler block, it can be reached from any instruction of the\n    // basic block corresponding to this frame, in particular from the first one. Therefore, the\n    // input locals of dstFrame should be compatible (i.e. merged) with the input locals of this\n    // frame (and the input stack of dstFrame should be compatible, i.e. merged, with a one\n    // element stack containing the caught exception type).\n    if (catchTypeIndex > 0) {\n      for (int i = 0; i < numLocal; ++i) {\n        frameChanged |= merge(symbolTable, inputLocals[i], dstFrame.inputLocals, i);\n      }\n      if (dstFrame.inputStack == null) {\n        dstFrame.inputStack = new int[1];\n        frameChanged = true;\n      }\n      frameChanged |= merge(symbolTable, catchTypeIndex, dstFrame.inputStack, 0);\n      return frameChanged;\n    }\n\n    // Compute the concrete types of the stack operands at the end of the basic block corresponding\n    // to this frame, by resolving its abstract output types, and merge these concrete types with\n    // those of the stack operands in the input frame of dstFrame.\n    int numInputStack = inputStack.length + outputStackStart;\n    if (dstFrame.inputStack == null) {\n      dstFrame.inputStack = new int[numInputStack + outputStackTop];\n      frameChanged = true;\n    }\n    // First, do this for the stack operands that have not been popped in the basic block\n    // corresponding to this frame, and which are therefore equal to their value in the input\n    // frame (except for uninitialized types, which may have been initialized).\n    for (int i = 0; i < numInputStack; ++i) {\n      int concreteOutputType = inputStack[i];\n      if (initializations != null) {\n        concreteOutputType = getInitializedType(symbolTable, concreteOutputType);\n      }\n      frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputStack, i);\n    }\n    // Then, do this for the stack operands that have pushed in the basic block (this code is the\n    // same as the one above for local variables).\n    for (int i = 0; i < outputStackTop; ++i) {\n      int abstractOutputType = outputStack[i];\n      int concreteOutputType = getConcreteOutputType(abstractOutputType, numStack);\n      if (initializations != null) {\n        concreteOutputType = getInitializedType(symbolTable, concreteOutputType);\n      }\n      frameChanged |=\n          merge(symbolTable, concreteOutputType, dstFrame.inputStack, numInputStack + i);\n    }\n    return frameChanged;\n  }\n\n  /**\n   * Merges the type at the given index in the given abstract type array with the given type.\n   * Returns {@literal true} if the type array has been modified by this operation.\n   *\n   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n   * @param sourceType the abstract type with which the abstract type array element must be merged.\n   *     This type should be of {@link #CONSTANT_KIND}, {@link #REFERENCE_KIND}, {@link\n   *     #UNINITIALIZED_KIND} or {@link #FORWARD_UNINITIALIZED_KIND} kind, with positive or\n   *     {@literal null} array dimensions.\n   * @param dstTypes an array of abstract types. These types should be of {@link #CONSTANT_KIND},\n   *     {@link #REFERENCE_KIND}, {@link #UNINITIALIZED_KIND} or {@link #FORWARD_UNINITIALIZED_KIND}\n   *     kind, with positive or {@literal null} array dimensions.\n   * @param dstIndex the index of the type that must be merged in dstTypes.\n   * @return {@literal true} if the type array has been modified by this operation.\n   */\n  private static boolean merge(\n      final SymbolTable symbolTable,\n      final int sourceType,\n      final int[] dstTypes,\n      final int dstIndex) {\n    int dstType = dstTypes[dstIndex];\n    if (dstType == sourceType) {\n      // If the types are equal, merge(sourceType, dstType) = dstType, so there is no change.\n      return false;\n    }\n    int srcType = sourceType;\n    if ((sourceType & ~DIM_MASK) == NULL) {\n      if (dstType == NULL) {\n        return false;\n      }\n      srcType = NULL;\n    }\n    if (dstType == 0) {\n      // If dstTypes[dstIndex] has never been assigned, merge(srcType, dstType) = srcType.\n      dstTypes[dstIndex] = srcType;\n      return true;\n    }\n    int mergedType;\n    if ((dstType & DIM_MASK) != 0 || (dstType & KIND_MASK) == REFERENCE_KIND) {\n      // If dstType is a reference type of any array dimension.\n      if (srcType == NULL) {\n        // If srcType is the NULL type, merge(srcType, dstType) = dstType, so there is no change.\n        return false;\n      } else if ((srcType & (DIM_MASK | KIND_MASK)) == (dstType & (DIM_MASK | KIND_MASK))) {\n        // If srcType has the same array dimension and the same kind as dstType.\n        if ((dstType & KIND_MASK) == REFERENCE_KIND) {\n          // If srcType and dstType are reference types with the same array dimension,\n          // merge(srcType, dstType) = dim(srcType) | common super class of srcType and dstType.\n          mergedType =\n              (srcType & DIM_MASK)\n                  | REFERENCE_KIND\n                  | symbolTable.addMergedType(srcType & VALUE_MASK, dstType & VALUE_MASK);\n        } else {\n          // If srcType and dstType are array types of equal dimension but different element types,\n          // merge(srcType, dstType) = dim(srcType) - 1 | java/lang/Object.\n          int mergedDim = ELEMENT_OF + (srcType & DIM_MASK);\n          mergedType = mergedDim | REFERENCE_KIND | symbolTable.addType(\"java/lang/Object\");\n        }\n      } else if ((srcType & DIM_MASK) != 0 || (srcType & KIND_MASK) == REFERENCE_KIND) {\n        // If srcType is any other reference or array type,\n        // merge(srcType, dstType) = min(srcDdim, dstDim) | java/lang/Object\n        // where srcDim is the array dimension of srcType, minus 1 if srcType is an array type\n        // with a non reference element type (and similarly for dstDim).\n        int srcDim = srcType & DIM_MASK;\n        if (srcDim != 0 && (srcType & KIND_MASK) != REFERENCE_KIND) {\n          srcDim = ELEMENT_OF + srcDim;\n        }\n        int dstDim = dstType & DIM_MASK;\n        if (dstDim != 0 && (dstType & KIND_MASK) != REFERENCE_KIND) {\n          dstDim = ELEMENT_OF + dstDim;\n        }\n        mergedType =\n            Math.min(srcDim, dstDim) | REFERENCE_KIND | symbolTable.addType(\"java/lang/Object\");\n      } else {\n        // If srcType is any other type, merge(srcType, dstType) = TOP.\n        mergedType = TOP;\n      }\n    } else if (dstType == NULL) {\n      // If dstType is the NULL type, merge(srcType, dstType) = srcType, or TOP if srcType is not a\n      // an array type or a reference type.\n      mergedType =\n          (srcType & DIM_MASK) != 0 || (srcType & KIND_MASK) == REFERENCE_KIND ? srcType : TOP;\n    } else {\n      // If dstType is any other type, merge(srcType, dstType) = TOP whatever srcType.\n      mergedType = TOP;\n    }\n    if (mergedType != dstType) {\n      dstTypes[dstIndex] = mergedType;\n      return true;\n    }\n    return false;\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Frame output methods, to generate StackMapFrame attributes\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Makes the given {@link MethodWriter} visit the input frame of this {@link Frame}. The visit is\n   * done with the {@link MethodWriter#visitFrameStart}, {@link MethodWriter#visitAbstractType} and\n   * {@link MethodWriter#visitFrameEnd} methods.\n   *\n   * @param methodWriter the {@link MethodWriter} that should visit the input frame of this {@link\n   *     Frame}.\n   */\n  final void accept(final MethodWriter methodWriter) {\n    // Compute the number of locals, ignoring TOP types that are just after a LONG or a DOUBLE, and\n    // all trailing TOP types.\n    int[] localTypes = inputLocals;\n    int numLocal = 0;\n    int numTrailingTop = 0;\n    int i = 0;\n    while (i < localTypes.length) {\n      int localType = localTypes[i];\n      i += (localType == LONG || localType == DOUBLE) ? 2 : 1;\n      if (localType == TOP) {\n        numTrailingTop++;\n      } else {\n        numLocal += numTrailingTop + 1;\n        numTrailingTop = 0;\n      }\n    }\n    // Compute the stack size, ignoring TOP types that are just after a LONG or a DOUBLE.\n    int[] stackTypes = inputStack;\n    int numStack = 0;\n    i = 0;\n    while (i < stackTypes.length) {\n      int stackType = stackTypes[i];\n      i += (stackType == LONG || stackType == DOUBLE) ? 2 : 1;\n      numStack++;\n    }\n    // Visit the frame and its content.\n    int frameIndex = methodWriter.visitFrameStart(owner.bytecodeOffset, numLocal, numStack);\n    i = 0;\n    while (numLocal-- > 0) {\n      int localType = localTypes[i];\n      i += (localType == LONG || localType == DOUBLE) ? 2 : 1;\n      methodWriter.visitAbstractType(frameIndex++, localType);\n    }\n    i = 0;\n    while (numStack-- > 0) {\n      int stackType = stackTypes[i];\n      i += (stackType == LONG || stackType == DOUBLE) ? 2 : 1;\n      methodWriter.visitAbstractType(frameIndex++, stackType);\n    }\n    methodWriter.visitFrameEnd();\n  }\n\n  /**\n   * Put the given abstract type in the given ByteVector, using the JVMS verification_type_info\n   * format used in StackMapTable attributes.\n   *\n   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n   * @param abstractType an abstract type, restricted to {@link Frame#CONSTANT_KIND}, {@link\n   *     Frame#REFERENCE_KIND}, {@link Frame#UNINITIALIZED_KIND} or {@link\n   *     Frame#FORWARD_UNINITIALIZED_KIND} types.\n   * @param output where the abstract type must be put.\n   * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.4\">JVMS\n   *     4.7.4</a>\n   */\n  static void putAbstractType(\n      final SymbolTable symbolTable, final int abstractType, final ByteVector output) {\n    int arrayDimensions = (abstractType & Frame.DIM_MASK) >> DIM_SHIFT;\n    if (arrayDimensions == 0) {\n      int typeValue = abstractType & VALUE_MASK;\n      switch (abstractType & KIND_MASK) {\n        case CONSTANT_KIND:\n          output.putByte(typeValue);\n          break;\n        case REFERENCE_KIND:\n          output\n              .putByte(ITEM_OBJECT)\n              .putShort(symbolTable.addConstantClass(symbolTable.getType(typeValue).value).index);\n          break;\n        case UNINITIALIZED_KIND:\n          output.putByte(ITEM_UNINITIALIZED).putShort((int) symbolTable.getType(typeValue).data);\n          break;\n        case FORWARD_UNINITIALIZED_KIND:\n          output.putByte(ITEM_UNINITIALIZED);\n          symbolTable.getForwardUninitializedLabel(typeValue).put(output);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    } else {\n      // Case of an array type, we need to build its descriptor first.\n      StringBuilder typeDescriptor = new StringBuilder(32);  // SPRING PATCH: larger initial size\n      while (arrayDimensions-- > 0) {\n        typeDescriptor.append('[');\n      }\n      if ((abstractType & KIND_MASK) == REFERENCE_KIND) {\n        typeDescriptor\n            .append('L')\n            .append(symbolTable.getType(abstractType & VALUE_MASK).value)\n            .append(';');\n      } else {\n        switch (abstractType & VALUE_MASK) {\n          case Frame.ITEM_ASM_BOOLEAN:\n            typeDescriptor.append('Z');\n            break;\n          case Frame.ITEM_ASM_BYTE:\n            typeDescriptor.append('B');\n            break;\n          case Frame.ITEM_ASM_CHAR:\n            typeDescriptor.append('C');\n            break;\n          case Frame.ITEM_ASM_SHORT:\n            typeDescriptor.append('S');\n            break;\n          case Frame.ITEM_INTEGER:\n            typeDescriptor.append('I');\n            break;\n          case Frame.ITEM_FLOAT:\n            typeDescriptor.append('F');\n            break;\n          case Frame.ITEM_LONG:\n            typeDescriptor.append('J');\n            break;\n          case Frame.ITEM_DOUBLE:\n            typeDescriptor.append('D');\n            break;\n          default:\n            throw new AssertionError();\n        }\n      }\n      output\n          .putByte(ITEM_OBJECT)\n          .putShort(symbolTable.addConstantClass(typeDescriptor.toString()).index);\n    }\n  }\n}\n",
    "tailType": "class_code"
  }
]