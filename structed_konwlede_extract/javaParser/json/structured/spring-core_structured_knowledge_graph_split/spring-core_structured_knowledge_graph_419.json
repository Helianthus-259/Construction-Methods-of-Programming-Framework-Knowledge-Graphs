[
  {
    "head": "org.springframework.asm.Frame#push(SymbolTable,String)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Pushes the abstract type corresponding to the given descriptor on the output frame stack.\r\n *\r\n * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\r\n * @param descriptor a type or method descriptor (in which case its return type is pushed).\r\n */\r\nprivate void push(final SymbolTable symbolTable, final String descriptor) {\r\n    int typeDescriptorOffset = descriptor.charAt(0) == '(' ? Type.getReturnTypeOffset(descriptor) : 0;\r\n    int abstractType = getAbstractTypeFromDescriptor(symbolTable, descriptor, typeDescriptorOffset);\r\n    if (abstractType != 0) {\r\n        push(abstractType);\r\n        if (abstractType == LONG || abstractType == DOUBLE) {\r\n            push(TOP);\r\n        }\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.Frame",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.Frame#push(SymbolTable,String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.Frame#pop()",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Pops an abstract type from the output frame stack and returns its value.\r\n *\r\n * @return the abstract type that has been popped from the output frame stack.\r\n */\r\nprivate int pop() {\r\n    if (outputStackTop > 0) {\r\n        return outputStack[--outputStackTop];\r\n    } else {\r\n        // If the output frame stack is empty, pop from the input stack.\r\n        return STACK_KIND | -(--outputStackStart);\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.Frame",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.Frame#pop()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.Frame#pop(int)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Pops the given number of abstract types from the output frame stack.\r\n *\r\n * @param elements the number of abstract types that must be popped.\r\n */\r\nprivate void pop(final int elements) {\r\n    if (outputStackTop >= elements) {\r\n        outputStackTop -= elements;\r\n    } else {\r\n        // If the number of elements to be popped is greater than the number of elements in the output\r\n        // stack, clear it, and pop the remaining elements from the input stack.\r\n        outputStackStart -= elements - outputStackTop;\r\n        outputStackTop = 0;\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.Frame",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.Frame#pop(int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.Frame#pop(String)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Pops as many abstract types from the output frame stack as described by the given descriptor.\r\n *\r\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\r\n */\r\nprivate void pop(final String descriptor) {\r\n    char firstDescriptorChar = descriptor.charAt(0);\r\n    if (firstDescriptorChar == '(') {\r\n        pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1);\r\n    } else if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') {\r\n        pop(2);\r\n    } else {\r\n        pop(1);\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.Frame",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.Frame#pop(String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.Frame#addInitializedType(int)",
    "headType": "method",
    "relation": "provide",
    "tail": "// -----------------------------------------------------------------------------------------------\r\n// Methods to handle uninitialized types\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Adds an abstract type to the list of types on which a constructor is invoked in the basic\r\n * block.\r\n *\r\n * @param abstractType an abstract type on a which a constructor is invoked.\r\n */\r\nprivate void addInitializedType(final int abstractType) {\r\n    // Create and/or resize the initializations array if necessary.\r\n    if (initializations == null) {\r\n        initializations = new int[2];\r\n    }\r\n    int initializationsLength = initializations.length;\r\n    if (initializationCount >= initializationsLength) {\r\n        int[] newInitializations = new int[Math.max(initializationCount + 1, 2 * initializationsLength)];\r\n        System.arraycopy(initializations, 0, newInitializations, 0, initializationsLength);\r\n        initializations = newInitializations;\r\n    }\r\n    // Store the abstract type.\r\n    initializations[initializationCount++] = abstractType;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.Frame",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.Frame#addInitializedType(int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.Frame#getInitializedType(SymbolTable,int)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Returns the \"initialized\" abstract type corresponding to the given abstract type.\r\n *\r\n * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\r\n * @param abstractType an abstract type.\r\n * @return the REFERENCE_KIND abstract type corresponding to abstractType if it is\r\n *     UNINITIALIZED_THIS or an UNINITIALIZED_KIND or FORWARD_UNINITIALIZED_KIND abstract type for\r\n *     one of the types on which a constructor is invoked in the basic block. Otherwise returns\r\n *     abstractType.\r\n */\r\nprivate int getInitializedType(final SymbolTable symbolTable, final int abstractType) {\r\n    if (abstractType == UNINITIALIZED_THIS || (abstractType & (DIM_MASK | KIND_MASK)) == UNINITIALIZED_KIND || (abstractType & (DIM_MASK | KIND_MASK)) == FORWARD_UNINITIALIZED_KIND) {\r\n        for (int i = 0; i < initializationCount; ++i) {\r\n            int initializedType = initializations[i];\r\n            int dim = initializedType & DIM_MASK;\r\n            int kind = initializedType & KIND_MASK;\r\n            int value = initializedType & VALUE_MASK;\r\n            if (kind == LOCAL_KIND) {\r\n                initializedType = dim + inputLocals[value];\r\n            } else if (kind == STACK_KIND) {\r\n                initializedType = dim + inputStack[inputStack.length - value];\r\n            }\r\n            if (abstractType == initializedType) {\r\n                if (abstractType == UNINITIALIZED_THIS) {\r\n                    return REFERENCE_KIND | symbolTable.addType(symbolTable.getClassName());\r\n                } else {\r\n                    return REFERENCE_KIND | symbolTable.addType(symbolTable.getType(abstractType & VALUE_MASK).value);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return abstractType;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.Frame",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.Frame#getInitializedType(SymbolTable,int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.Frame#execute(int,int,Symbol,SymbolTable)",
    "headType": "method",
    "relation": "provide",
    "tail": "// -----------------------------------------------------------------------------------------------\r\n// Main method, to simulate the execution of each instruction on the output frame\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Simulates the action of the given instruction on the output stack frame.\r\n *\r\n * @param opcode the opcode of the instruction.\r\n * @param arg the numeric operand of the instruction, if any.\r\n * @param argSymbol the Symbol operand of the instruction, if any.\r\n * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\r\n */\r\nvoid execute(final int opcode, final int arg, final Symbol argSymbol, final SymbolTable symbolTable) {\r\n    // Abstract types popped from the stack or read from local variables.\r\n    int abstractType1;\r\n    int abstractType2;\r\n    int abstractType3;\r\n    int abstractType4;\r\n    switch(opcode) {\r\n        case Opcodes.NOP:\r\n        case Opcodes.INEG:\r\n        case Opcodes.LNEG:\r\n        case Opcodes.FNEG:\r\n        case Opcodes.DNEG:\r\n        case Opcodes.I2B:\r\n        case Opcodes.I2C:\r\n        case Opcodes.I2S:\r\n        case Opcodes.GOTO:\r\n        case Opcodes.RETURN:\r\n            break;\r\n        case Opcodes.ACONST_NULL:\r\n            push(NULL);\r\n            break;\r\n        case Opcodes.ICONST_M1:\r\n        case Opcodes.ICONST_0:\r\n        case Opcodes.ICONST_1:\r\n        case Opcodes.ICONST_2:\r\n        case Opcodes.ICONST_3:\r\n        case Opcodes.ICONST_4:\r\n        case Opcodes.ICONST_5:\r\n        case Opcodes.BIPUSH:\r\n        case Opcodes.SIPUSH:\r\n        case Opcodes.ILOAD:\r\n            push(INTEGER);\r\n            break;\r\n        case Opcodes.LCONST_0:\r\n        case Opcodes.LCONST_1:\r\n        case Opcodes.LLOAD:\r\n            push(LONG);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.FCONST_0:\r\n        case Opcodes.FCONST_1:\r\n        case Opcodes.FCONST_2:\r\n        case Opcodes.FLOAD:\r\n            push(FLOAT);\r\n            break;\r\n        case Opcodes.DCONST_0:\r\n        case Opcodes.DCONST_1:\r\n        case Opcodes.DLOAD:\r\n            push(DOUBLE);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.LDC:\r\n            switch(argSymbol.tag) {\r\n                case Symbol.CONSTANT_INTEGER_TAG:\r\n                    push(INTEGER);\r\n                    break;\r\n                case Symbol.CONSTANT_LONG_TAG:\r\n                    push(LONG);\r\n                    push(TOP);\r\n                    break;\r\n                case Symbol.CONSTANT_FLOAT_TAG:\r\n                    push(FLOAT);\r\n                    break;\r\n                case Symbol.CONSTANT_DOUBLE_TAG:\r\n                    push(DOUBLE);\r\n                    push(TOP);\r\n                    break;\r\n                case Symbol.CONSTANT_CLASS_TAG:\r\n                    push(REFERENCE_KIND | symbolTable.addType(\"java/lang/Class\"));\r\n                    break;\r\n                case Symbol.CONSTANT_STRING_TAG:\r\n                    push(REFERENCE_KIND | symbolTable.addType(\"java/lang/String\"));\r\n                    break;\r\n                case Symbol.CONSTANT_METHOD_TYPE_TAG:\r\n                    push(REFERENCE_KIND | symbolTable.addType(\"java/lang/invoke/MethodType\"));\r\n                    break;\r\n                case Symbol.CONSTANT_METHOD_HANDLE_TAG:\r\n                    push(REFERENCE_KIND | symbolTable.addType(\"java/lang/invoke/MethodHandle\"));\r\n                    break;\r\n                case Symbol.CONSTANT_DYNAMIC_TAG:\r\n                    push(symbolTable, argSymbol.value);\r\n                    break;\r\n                default:\r\n                    throw new AssertionError();\r\n            }\r\n            break;\r\n        case Opcodes.ALOAD:\r\n            push(getLocal(arg));\r\n            break;\r\n        case Opcodes.LALOAD:\r\n        case Opcodes.D2L:\r\n            pop(2);\r\n            push(LONG);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.DALOAD:\r\n        case Opcodes.L2D:\r\n            pop(2);\r\n            push(DOUBLE);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.AALOAD:\r\n            pop(1);\r\n            abstractType1 = pop();\r\n            push(abstractType1 == NULL ? abstractType1 : ELEMENT_OF + abstractType1);\r\n            break;\r\n        case Opcodes.ISTORE:\r\n        case Opcodes.FSTORE:\r\n        case Opcodes.ASTORE:\r\n            abstractType1 = pop();\r\n            setLocal(arg, abstractType1);\r\n            if (arg > 0) {\r\n                int previousLocalType = getLocal(arg - 1);\r\n                if (previousLocalType == LONG || previousLocalType == DOUBLE) {\r\n                    setLocal(arg - 1, TOP);\r\n                } else if ((previousLocalType & KIND_MASK) == LOCAL_KIND || (previousLocalType & KIND_MASK) == STACK_KIND) {\r\n                    // The type of the previous local variable is not known yet, but if it later appears\r\n                    // to be LONG or DOUBLE, we should then use TOP instead.\r\n                    setLocal(arg - 1, previousLocalType | TOP_IF_LONG_OR_DOUBLE_FLAG);\r\n                }\r\n            }\r\n            break;\r\n        case Opcodes.LSTORE:\r\n        case Opcodes.DSTORE:\r\n            pop(1);\r\n            abstractType1 = pop();\r\n            setLocal(arg, abstractType1);\r\n            setLocal(arg + 1, TOP);\r\n            if (arg > 0) {\r\n                int previousLocalType = getLocal(arg - 1);\r\n                if (previousLocalType == LONG || previousLocalType == DOUBLE) {\r\n                    setLocal(arg - 1, TOP);\r\n                } else if ((previousLocalType & KIND_MASK) == LOCAL_KIND || (previousLocalType & KIND_MASK) == STACK_KIND) {\r\n                    // The type of the previous local variable is not known yet, but if it later appears\r\n                    // to be LONG or DOUBLE, we should then use TOP instead.\r\n                    setLocal(arg - 1, previousLocalType | TOP_IF_LONG_OR_DOUBLE_FLAG);\r\n                }\r\n            }\r\n            break;\r\n        case Opcodes.IASTORE:\r\n        case Opcodes.BASTORE:\r\n        case Opcodes.CASTORE:\r\n        case Opcodes.SASTORE:\r\n        case Opcodes.FASTORE:\r\n        case Opcodes.AASTORE:\r\n            pop(3);\r\n            break;\r\n        case Opcodes.LASTORE:\r\n        case Opcodes.DASTORE:\r\n            pop(4);\r\n            break;\r\n        case Opcodes.POP:\r\n        case Opcodes.IFEQ:\r\n        case Opcodes.IFNE:\r\n        case Opcodes.IFLT:\r\n        case Opcodes.IFGE:\r\n        case Opcodes.IFGT:\r\n        case Opcodes.IFLE:\r\n        case Opcodes.IRETURN:\r\n        case Opcodes.FRETURN:\r\n        case Opcodes.ARETURN:\r\n        case Opcodes.TABLESWITCH:\r\n        case Opcodes.LOOKUPSWITCH:\r\n        case Opcodes.ATHROW:\r\n        case Opcodes.MONITORENTER:\r\n        case Opcodes.MONITOREXIT:\r\n        case Opcodes.IFNULL:\r\n        case Opcodes.IFNONNULL:\r\n            pop(1);\r\n            break;\r\n        case Opcodes.POP2:\r\n        case Opcodes.IF_ICMPEQ:\r\n        case Opcodes.IF_ICMPNE:\r\n        case Opcodes.IF_ICMPLT:\r\n        case Opcodes.IF_ICMPGE:\r\n        case Opcodes.IF_ICMPGT:\r\n        case Opcodes.IF_ICMPLE:\r\n        case Opcodes.IF_ACMPEQ:\r\n        case Opcodes.IF_ACMPNE:\r\n        case Opcodes.LRETURN:\r\n        case Opcodes.DRETURN:\r\n            pop(2);\r\n            break;\r\n        case Opcodes.DUP:\r\n            abstractType1 = pop();\r\n            push(abstractType1);\r\n            push(abstractType1);\r\n            break;\r\n        case Opcodes.DUP_X1:\r\n            abstractType1 = pop();\r\n            abstractType2 = pop();\r\n            push(abstractType1);\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            break;\r\n        case Opcodes.DUP_X2:\r\n            abstractType1 = pop();\r\n            abstractType2 = pop();\r\n            abstractType3 = pop();\r\n            push(abstractType1);\r\n            push(abstractType3);\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            break;\r\n        case Opcodes.DUP2:\r\n            abstractType1 = pop();\r\n            abstractType2 = pop();\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            break;\r\n        case Opcodes.DUP2_X1:\r\n            abstractType1 = pop();\r\n            abstractType2 = pop();\r\n            abstractType3 = pop();\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            push(abstractType3);\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            break;\r\n        case Opcodes.DUP2_X2:\r\n            abstractType1 = pop();\r\n            abstractType2 = pop();\r\n            abstractType3 = pop();\r\n            abstractType4 = pop();\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            push(abstractType4);\r\n            push(abstractType3);\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            break;\r\n        case Opcodes.SWAP:\r\n            abstractType1 = pop();\r\n            abstractType2 = pop();\r\n            push(abstractType1);\r\n            push(abstractType2);\r\n            break;\r\n        case Opcodes.IALOAD:\r\n        case Opcodes.BALOAD:\r\n        case Opcodes.CALOAD:\r\n        case Opcodes.SALOAD:\r\n        case Opcodes.IADD:\r\n        case Opcodes.ISUB:\r\n        case Opcodes.IMUL:\r\n        case Opcodes.IDIV:\r\n        case Opcodes.IREM:\r\n        case Opcodes.IAND:\r\n        case Opcodes.IOR:\r\n        case Opcodes.IXOR:\r\n        case Opcodes.ISHL:\r\n        case Opcodes.ISHR:\r\n        case Opcodes.IUSHR:\r\n        case Opcodes.L2I:\r\n        case Opcodes.D2I:\r\n        case Opcodes.FCMPL:\r\n        case Opcodes.FCMPG:\r\n            pop(2);\r\n            push(INTEGER);\r\n            break;\r\n        case Opcodes.LADD:\r\n        case Opcodes.LSUB:\r\n        case Opcodes.LMUL:\r\n        case Opcodes.LDIV:\r\n        case Opcodes.LREM:\r\n        case Opcodes.LAND:\r\n        case Opcodes.LOR:\r\n        case Opcodes.LXOR:\r\n            pop(4);\r\n            push(LONG);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.FALOAD:\r\n        case Opcodes.FADD:\r\n        case Opcodes.FSUB:\r\n        case Opcodes.FMUL:\r\n        case Opcodes.FDIV:\r\n        case Opcodes.FREM:\r\n        case Opcodes.L2F:\r\n        case Opcodes.D2F:\r\n            pop(2);\r\n            push(FLOAT);\r\n            break;\r\n        case Opcodes.DADD:\r\n        case Opcodes.DSUB:\r\n        case Opcodes.DMUL:\r\n        case Opcodes.DDIV:\r\n        case Opcodes.DREM:\r\n            pop(4);\r\n            push(DOUBLE);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.LSHL:\r\n        case Opcodes.LSHR:\r\n        case Opcodes.LUSHR:\r\n            pop(3);\r\n            push(LONG);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.IINC:\r\n            setLocal(arg, INTEGER);\r\n            break;\r\n        case Opcodes.I2L:\r\n        case Opcodes.F2L:\r\n            pop(1);\r\n            push(LONG);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.I2F:\r\n            pop(1);\r\n            push(FLOAT);\r\n            break;\r\n        case Opcodes.I2D:\r\n        case Opcodes.F2D:\r\n            pop(1);\r\n            push(DOUBLE);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.F2I:\r\n        case Opcodes.ARRAYLENGTH:\r\n        case Opcodes.INSTANCEOF:\r\n            pop(1);\r\n            push(INTEGER);\r\n            break;\r\n        case Opcodes.LCMP:\r\n        case Opcodes.DCMPL:\r\n        case Opcodes.DCMPG:\r\n            pop(4);\r\n            push(INTEGER);\r\n            break;\r\n        case Opcodes.JSR:\r\n        case Opcodes.RET:\r\n            throw new IllegalArgumentException(\"JSR/RET are not supported with computeFrames option\");\r\n        case Opcodes.GETSTATIC:\r\n            push(symbolTable, argSymbol.value);\r\n            break;\r\n        case Opcodes.PUTSTATIC:\r\n            pop(argSymbol.value);\r\n            break;\r\n        case Opcodes.GETFIELD:\r\n            pop(1);\r\n            push(symbolTable, argSymbol.value);\r\n            break;\r\n        case Opcodes.PUTFIELD:\r\n            pop(argSymbol.value);\r\n            pop();\r\n            break;\r\n        case Opcodes.INVOKEVIRTUAL:\r\n        case Opcodes.INVOKESPECIAL:\r\n        case Opcodes.INVOKESTATIC:\r\n        case Opcodes.INVOKEINTERFACE:\r\n            pop(argSymbol.value);\r\n            if (opcode != Opcodes.INVOKESTATIC) {\r\n                abstractType1 = pop();\r\n                if (opcode == Opcodes.INVOKESPECIAL && argSymbol.name.charAt(0) == '<') {\r\n                    addInitializedType(abstractType1);\r\n                }\r\n            }\r\n            push(symbolTable, argSymbol.value);\r\n            break;\r\n        case Opcodes.INVOKEDYNAMIC:\r\n            pop(argSymbol.value);\r\n            push(symbolTable, argSymbol.value);\r\n            break;\r\n        case Opcodes.NEW:\r\n            push(UNINITIALIZED_KIND | symbolTable.addUninitializedType(argSymbol.value, arg));\r\n            break;\r\n        case Opcodes.NEWARRAY:\r\n            pop();\r\n            switch(arg) {\r\n                case Opcodes.T_BOOLEAN:\r\n                    push(ARRAY_OF | BOOLEAN);\r\n                    break;\r\n                case Opcodes.T_CHAR:\r\n                    push(ARRAY_OF | CHAR);\r\n                    break;\r\n                case Opcodes.T_BYTE:\r\n                    push(ARRAY_OF | BYTE);\r\n                    break;\r\n                case Opcodes.T_SHORT:\r\n                    push(ARRAY_OF | SHORT);\r\n                    break;\r\n                case Opcodes.T_INT:\r\n                    push(ARRAY_OF | INTEGER);\r\n                    break;\r\n                case Opcodes.T_FLOAT:\r\n                    push(ARRAY_OF | FLOAT);\r\n                    break;\r\n                case Opcodes.T_DOUBLE:\r\n                    push(ARRAY_OF | DOUBLE);\r\n                    break;\r\n                case Opcodes.T_LONG:\r\n                    push(ARRAY_OF | LONG);\r\n                    break;\r\n                default:\r\n                    throw new IllegalArgumentException();\r\n            }\r\n            break;\r\n        case Opcodes.ANEWARRAY:\r\n            String arrayElementType = argSymbol.value;\r\n            pop();\r\n            if (arrayElementType.charAt(0) == '[') {\r\n                push(symbolTable, '[' + arrayElementType);\r\n            } else {\r\n                push(ARRAY_OF | REFERENCE_KIND | symbolTable.addType(arrayElementType));\r\n            }\r\n            break;\r\n        case Opcodes.CHECKCAST:\r\n            String castType = argSymbol.value;\r\n            pop();\r\n            if (castType.charAt(0) == '[') {\r\n                push(symbolTable, castType);\r\n            } else {\r\n                push(REFERENCE_KIND | symbolTable.addType(castType));\r\n            }\r\n            break;\r\n        case Opcodes.MULTIANEWARRAY:\r\n            pop(arg);\r\n            push(symbolTable, argSymbol.value);\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException();\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.Frame",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.Frame#execute(int,int,Symbol,SymbolTable)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.Frame#getConcreteOutputType(int,int)",
    "headType": "method",
    "relation": "provide",
    "tail": "// -----------------------------------------------------------------------------------------------\r\n// Frame merging methods, used in the second step of the stack map frame computation algorithm\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Computes the concrete output type corresponding to a given abstract output type.\r\n *\r\n * @param abstractOutputType an abstract output type.\r\n * @param numStack the size of the input stack, used to resolve abstract output types of\r\n *     STACK_KIND kind.\r\n * @return the concrete output type corresponding to 'abstractOutputType'.\r\n */\r\nprivate int getConcreteOutputType(final int abstractOutputType, final int numStack) {\r\n    int dim = abstractOutputType & DIM_MASK;\r\n    int kind = abstractOutputType & KIND_MASK;\r\n    if (kind == LOCAL_KIND) {\r\n        // By definition, a LOCAL_KIND type designates the concrete type of a local variable at\r\n        // the beginning of the basic block corresponding to this frame (which is known when\r\n        // this method is called, but was not when the abstract type was computed).\r\n        int concreteOutputType = dim + inputLocals[abstractOutputType & VALUE_MASK];\r\n        if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0 && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {\r\n            concreteOutputType = TOP;\r\n        }\r\n        return concreteOutputType;\r\n    } else if (kind == STACK_KIND) {\r\n        // By definition, a STACK_KIND type designates the concrete type of a local variable at\r\n        // the beginning of the basic block corresponding to this frame (which is known when\r\n        // this method is called, but was not when the abstract type was computed).\r\n        int concreteOutputType = dim + inputStack[numStack - (abstractOutputType & VALUE_MASK)];\r\n        if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0 && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {\r\n            concreteOutputType = TOP;\r\n        }\r\n        return concreteOutputType;\r\n    } else {\r\n        return abstractOutputType;\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.Frame",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.Frame#getConcreteOutputType(int,int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.Frame#merge(SymbolTable,Frame,int)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Merges the input frame of the given {@link Frame} with the input and output frames of this\r\n * {@link Frame}. Returns {@literal true} if the given frame has been changed by this operation\r\n * (the input and output frames of this {@link Frame} are never changed).\r\n *\r\n * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\r\n * @param dstFrame the {@link Frame} whose input frame must be updated. This should be the frame\r\n *     of a successor, in the control flow graph, of the basic block corresponding to this frame.\r\n * @param catchTypeIndex if 'frame' corresponds to an exception handler basic block, the type\r\n *     table index of the caught exception type, otherwise 0.\r\n * @return {@literal true} if the input frame of 'frame' has been changed by this operation.\r\n */\r\nfinal boolean merge(final SymbolTable symbolTable, final Frame dstFrame, final int catchTypeIndex) {\r\n    boolean frameChanged = false;\r\n    // Compute the concrete types of the local variables at the end of the basic block corresponding\r\n    // to this frame, by resolving its abstract output types, and merge these concrete types with\r\n    // those of the local variables in the input frame of dstFrame.\r\n    int numLocal = inputLocals.length;\r\n    int numStack = inputStack.length;\r\n    if (dstFrame.inputLocals == null) {\r\n        dstFrame.inputLocals = new int[numLocal];\r\n        frameChanged = true;\r\n    }\r\n    for (int i = 0; i < numLocal; ++i) {\r\n        int concreteOutputType;\r\n        if (outputLocals != null && i < outputLocals.length) {\r\n            int abstractOutputType = outputLocals[i];\r\n            if (abstractOutputType == 0) {\r\n                // If the local variable has never been assigned in this basic block, it is equal to its\r\n                // value at the beginning of the block.\r\n                concreteOutputType = inputLocals[i];\r\n            } else {\r\n                concreteOutputType = getConcreteOutputType(abstractOutputType, numStack);\r\n            }\r\n        } else {\r\n            // If the local variable has never been assigned in this basic block, it is equal to its\r\n            // value at the beginning of the block.\r\n            concreteOutputType = inputLocals[i];\r\n        }\r\n        // concreteOutputType might be an uninitialized type from the input locals or from the input\r\n        // stack. However, if a constructor has been called for this class type in the basic block,\r\n        // then this type is no longer uninitialized at the end of basic block.\r\n        if (initializations != null) {\r\n            concreteOutputType = getInitializedType(symbolTable, concreteOutputType);\r\n        }\r\n        frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputLocals, i);\r\n    }\r\n    // If dstFrame is an exception handler block, it can be reached from any instruction of the\r\n    // basic block corresponding to this frame, in particular from the first one. Therefore, the\r\n    // input locals of dstFrame should be compatible (i.e. merged) with the input locals of this\r\n    // frame (and the input stack of dstFrame should be compatible, i.e. merged, with a one\r\n    // element stack containing the caught exception type).\r\n    if (catchTypeIndex > 0) {\r\n        for (int i = 0; i < numLocal; ++i) {\r\n            frameChanged |= merge(symbolTable, inputLocals[i], dstFrame.inputLocals, i);\r\n        }\r\n        if (dstFrame.inputStack == null) {\r\n            dstFrame.inputStack = new int[1];\r\n            frameChanged = true;\r\n        }\r\n        frameChanged |= merge(symbolTable, catchTypeIndex, dstFrame.inputStack, 0);\r\n        return frameChanged;\r\n    }\r\n    // Compute the concrete types of the stack operands at the end of the basic block corresponding\r\n    // to this frame, by resolving its abstract output types, and merge these concrete types with\r\n    // those of the stack operands in the input frame of dstFrame.\r\n    int numInputStack = inputStack.length + outputStackStart;\r\n    if (dstFrame.inputStack == null) {\r\n        dstFrame.inputStack = new int[numInputStack + outputStackTop];\r\n        frameChanged = true;\r\n    }\r\n    // First, do this for the stack operands that have not been popped in the basic block\r\n    // corresponding to this frame, and which are therefore equal to their value in the input\r\n    // frame (except for uninitialized types, which may have been initialized).\r\n    for (int i = 0; i < numInputStack; ++i) {\r\n        int concreteOutputType = inputStack[i];\r\n        if (initializations != null) {\r\n            concreteOutputType = getInitializedType(symbolTable, concreteOutputType);\r\n        }\r\n        frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputStack, i);\r\n    }\r\n    // Then, do this for the stack operands that have pushed in the basic block (this code is the\r\n    // same as the one above for local variables).\r\n    for (int i = 0; i < outputStackTop; ++i) {\r\n        int abstractOutputType = outputStack[i];\r\n        int concreteOutputType = getConcreteOutputType(abstractOutputType, numStack);\r\n        if (initializations != null) {\r\n            concreteOutputType = getInitializedType(symbolTable, concreteOutputType);\r\n        }\r\n        frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputStack, numInputStack + i);\r\n    }\r\n    return frameChanged;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.Frame",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.Frame#merge(SymbolTable,Frame,int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.Frame#merge(SymbolTable,int,int[],int)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Merges the type at the given index in the given abstract type array with the given type.\r\n * Returns {@literal true} if the type array has been modified by this operation.\r\n *\r\n * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\r\n * @param sourceType the abstract type with which the abstract type array element must be merged.\r\n *     This type should be of {@link #CONSTANT_KIND}, {@link #REFERENCE_KIND}, {@link\r\n *     #UNINITIALIZED_KIND} or {@link #FORWARD_UNINITIALIZED_KIND} kind, with positive or\r\n *     {@literal null} array dimensions.\r\n * @param dstTypes an array of abstract types. These types should be of {@link #CONSTANT_KIND},\r\n *     {@link #REFERENCE_KIND}, {@link #UNINITIALIZED_KIND} or {@link #FORWARD_UNINITIALIZED_KIND}\r\n *     kind, with positive or {@literal null} array dimensions.\r\n * @param dstIndex the index of the type that must be merged in dstTypes.\r\n * @return {@literal true} if the type array has been modified by this operation.\r\n */\r\nprivate static boolean merge(final SymbolTable symbolTable, final int sourceType, final int[] dstTypes, final int dstIndex) {\r\n    int dstType = dstTypes[dstIndex];\r\n    if (dstType == sourceType) {\r\n        // If the types are equal, merge(sourceType, dstType) = dstType, so there is no change.\r\n        return false;\r\n    }\r\n    int srcType = sourceType;\r\n    if ((sourceType & ~DIM_MASK) == NULL) {\r\n        if (dstType == NULL) {\r\n            return false;\r\n        }\r\n        srcType = NULL;\r\n    }\r\n    if (dstType == 0) {\r\n        // If dstTypes[dstIndex] has never been assigned, merge(srcType, dstType) = srcType.\r\n        dstTypes[dstIndex] = srcType;\r\n        return true;\r\n    }\r\n    int mergedType;\r\n    if ((dstType & DIM_MASK) != 0 || (dstType & KIND_MASK) == REFERENCE_KIND) {\r\n        // If dstType is a reference type of any array dimension.\r\n        if (srcType == NULL) {\r\n            // If srcType is the NULL type, merge(srcType, dstType) = dstType, so there is no change.\r\n            return false;\r\n        } else if ((srcType & (DIM_MASK | KIND_MASK)) == (dstType & (DIM_MASK | KIND_MASK))) {\r\n            // If srcType has the same array dimension and the same kind as dstType.\r\n            if ((dstType & KIND_MASK) == REFERENCE_KIND) {\r\n                // If srcType and dstType are reference types with the same array dimension,\r\n                // merge(srcType, dstType) = dim(srcType) | common super class of srcType and dstType.\r\n                mergedType = (srcType & DIM_MASK) | REFERENCE_KIND | symbolTable.addMergedType(srcType & VALUE_MASK, dstType & VALUE_MASK);\r\n            } else {\r\n                // If srcType and dstType are array types of equal dimension but different element types,\r\n                // merge(srcType, dstType) = dim(srcType) - 1 | java/lang/Object.\r\n                int mergedDim = ELEMENT_OF + (srcType & DIM_MASK);\r\n                mergedType = mergedDim | REFERENCE_KIND | symbolTable.addType(\"java/lang/Object\");\r\n            }\r\n        } else if ((srcType & DIM_MASK) != 0 || (srcType & KIND_MASK) == REFERENCE_KIND) {\r\n            // If srcType is any other reference or array type,\r\n            // merge(srcType, dstType) = min(srcDdim, dstDim) | java/lang/Object\r\n            // where srcDim is the array dimension of srcType, minus 1 if srcType is an array type\r\n            // with a non reference element type (and similarly for dstDim).\r\n            int srcDim = srcType & DIM_MASK;\r\n            if (srcDim != 0 && (srcType & KIND_MASK) != REFERENCE_KIND) {\r\n                srcDim = ELEMENT_OF + srcDim;\r\n            }\r\n            int dstDim = dstType & DIM_MASK;\r\n            if (dstDim != 0 && (dstType & KIND_MASK) != REFERENCE_KIND) {\r\n                dstDim = ELEMENT_OF + dstDim;\r\n            }\r\n            mergedType = Math.min(srcDim, dstDim) | REFERENCE_KIND | symbolTable.addType(\"java/lang/Object\");\r\n        } else {\r\n            // If srcType is any other type, merge(srcType, dstType) = TOP.\r\n            mergedType = TOP;\r\n        }\r\n    } else if (dstType == NULL) {\r\n        // If dstType is the NULL type, merge(srcType, dstType) = srcType, or TOP if srcType is not a\r\n        // an array type or a reference type.\r\n        mergedType = (srcType & DIM_MASK) != 0 || (srcType & KIND_MASK) == REFERENCE_KIND ? srcType : TOP;\r\n    } else {\r\n        // If dstType is any other type, merge(srcType, dstType) = TOP whatever srcType.\r\n        mergedType = TOP;\r\n    }\r\n    if (mergedType != dstType) {\r\n        dstTypes[dstIndex] = mergedType;\r\n        return true;\r\n    }\r\n    return false;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.Frame",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.Frame#merge(SymbolTable,int,int[],int)",
    "tailType": "method"
  }
]