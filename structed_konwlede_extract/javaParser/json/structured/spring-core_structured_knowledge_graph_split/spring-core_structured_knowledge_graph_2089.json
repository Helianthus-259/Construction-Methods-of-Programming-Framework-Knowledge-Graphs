[
  {
    "head": "org.springframework.core.RxJava3#fromCompletable()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid fromCompletable() {\r\n    Object source = io.reactivex.rxjava3.core.Completable.complete();\r\n    Object target = getAdapter(io.reactivex.rxjava3.core.Completable.class).toPublisher(source);\r\n    assertThat(target).as(\"Expected Mono Publisher: \" + target.getClass().getName()).isInstanceOf(Mono.class);\r\n    ((Mono<Void>) target).block(FIVE_SECONDS);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.RxJava3",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.RxJava3#fromCompletable()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.RxJava3#fromCompletable()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.Kotlin",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.Kotlin",
    "headType": "class",
    "relation": "use",
    "tail": "@Nested",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.Kotlin",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.time.Duration;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.Flow;\n\nimport io.smallrye.mutiny.Multi;\nimport io.smallrye.mutiny.Uni;\nimport kotlinx.coroutines.Deferred;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.reactivestreams.Publisher;\nimport reactor.adapter.JdkFlowAdapter;\nimport reactor.core.CoreSubscriber;\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Mono;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Tests for {@link ReactiveAdapterRegistry}.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n */\n@SuppressWarnings(\"unchecked\")\nclass ReactiveAdapterRegistryTests {\n\n\tprivate static final Duration FIVE_SECONDS = Duration.ofSeconds(5);\n\n\tprivate final ReactiveAdapterRegistry registry = ReactiveAdapterRegistry.getSharedInstance();\n\n\n\t@Test\n\tvoid getAdapterForReactiveSubType() {\n\t\tReactiveAdapter adapter1 = getAdapter(Flux.class);\n\t\tReactiveAdapter adapter2 = getAdapter(ExtendedFlux.class);\n\t\tassertThat(adapter2).isSameAs(adapter1);\n\n\t\t// Register regular reactive type (after existing adapters)\n\t\tthis.registry.registerReactiveType(\n\t\t\t\tReactiveTypeDescriptor.multiValue(ExtendedFlux.class, ExtendedFlux::empty),\n\t\t\t\to -> (ExtendedFlux<?>) o,\n\t\t\t\tExtendedFlux::from);\n\n\t\t// Matches for ExtendedFlux itself\n\t\tReactiveAdapter adapter3 = getAdapter(ExtendedFlux.class);\n\t\tassertThat(adapter3).isNotNull();\n\t\tassertThat(adapter3).isNotSameAs(adapter1);\n\n\t\t// Does not match for ExtendedFlux subclass since the default Flux adapter\n\t\t// is being assignability-checked first when no specific match was found\n\t\tReactiveAdapter adapter4 = getAdapter(ExtendedExtendedFlux.class);\n\t\tassertThat(adapter4).isSameAs(adapter1);\n\n\t\t// Register reactive type override (before existing adapters)\n\t\tthis.registry.registerReactiveTypeOverride(\n\t\t\t\tReactiveTypeDescriptor.multiValue(Flux.class, ExtendedFlux::empty),\n\t\t\t\to -> (ExtendedFlux<?>) o,\n\t\t\t\tExtendedFlux::from);\n\n\t\t// Override match for Flux\n\t\tReactiveAdapter adapter5 = getAdapter(Flux.class);\n\t\tassertThat(adapter5).isNotNull();\n\t\tassertThat(adapter5).isNotSameAs(adapter1);\n\n\t\t// Initially registered adapter specifically matches for ExtendedFlux\n\t\tReactiveAdapter adapter6 = getAdapter(ExtendedFlux.class);\n\t\tassertThat(adapter6).isSameAs(adapter3);\n\n\t\t// Override match for ExtendedFlux subclass\n\t\tReactiveAdapter adapter7 = getAdapter(ExtendedExtendedFlux.class);\n\t\tassertThat(adapter7).isSameAs(adapter5);\n\t}\n\n\n\tprivate ReactiveAdapter getAdapter(Class<?> reactiveType) {\n\t\tReactiveAdapter adapter = this.registry.getAdapter(reactiveType);\n\t\tassertThat(adapter).isNotNull();\n\t\treturn adapter;\n\t}\n\n\n\tprivate static class ExtendedFlux<T> extends Flux<T> {\n\n\t\t@Override\n\t\tpublic void subscribe(CoreSubscriber<? super T> actual) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\tprivate static class ExtendedExtendedFlux<T> extends ExtendedFlux<T> {\n\t}\n\n\n\t@Nested\n\tclass Reactor {\n\n\t\t@Test\n\t\tvoid defaultAdapterRegistrations() {\n\t\t\t// Reactor\n\t\t\tassertThat(getAdapter(Mono.class)).isNotNull();\n\t\t\tassertThat(getAdapter(Flux.class)).isNotNull();\n\n\t\t\t// Publisher\n\t\t\tassertThat(getAdapter(Publisher.class)).isNotNull();\n\n\t\t\t// Completable\n\t\t\tassertThat(getAdapter(CompletableFuture.class)).isNotNull();\n\t\t}\n\n\t\t@Test\n\t\tvoid toFlux() {\n\t\t\tList<Integer> sequence = Arrays.asList(1, 2, 3);\n\t\t\tPublisher<Integer> source = io.reactivex.rxjava3.core.Flowable.fromIterable(sequence);\n\t\t\tObject target = getAdapter(Flux.class).fromPublisher(source);\n\t\t\tassertThat(target).isInstanceOf(Flux.class);\n\t\t\tassertThat(((Flux<Integer>) target).collectList().block(FIVE_SECONDS)).isEqualTo(sequence);\n\t\t}\n\n\t\t@Test\n\t\tvoid toMono() {\n\t\t\tPublisher<Integer> source = io.reactivex.rxjava3.core.Flowable.fromArray(1, 2, 3);\n\t\t\tObject target = getAdapter(Mono.class).fromPublisher(source);\n\t\t\tassertThat(target).isInstanceOf(Mono.class);\n\t\t\tassertThat(((Mono<Integer>) target).block(FIVE_SECONDS)).isEqualTo(Integer.valueOf(1));\n\t\t}\n\n\t\t@Test\n\t\tvoid toFlowPublisher() {\n\t\t\tList<Integer> sequence = Arrays.asList(1, 2, 3);\n\t\t\tPublisher<Integer> source = io.reactivex.rxjava3.core.Flowable.fromIterable(sequence);\n\t\t\tObject target = getAdapter(Flow.Publisher.class).fromPublisher(source);\n\t\t\tassertThat(target).isInstanceOf(Flow.Publisher.class);\n\t\t\tassertThat(JdkFlowAdapter.flowPublisherToFlux((Flow.Publisher<Integer>) target)\n\t\t\t\t\t.collectList().block(FIVE_SECONDS)).isEqualTo(sequence);\n\t\t}\n\n\t\t@Test\n\t\tvoid toCompletableFuture() throws Exception {\n\t\t\tPublisher<Integer> source = Flux.fromArray(new Integer[] {1, 2, 3});\n\t\t\tObject target = getAdapter(CompletableFuture.class).fromPublisher(source);\n\t\t\tassertThat(target).isInstanceOf(CompletableFuture.class);\n\t\t\tassertThat(((CompletableFuture<Integer>) target).get()).isEqualTo(Integer.valueOf(1));\n\t\t}\n\n\t\t@Test\n\t\tvoid fromCompletableFuture() {\n\t\t\tCompletableFuture<Integer> future = new CompletableFuture<>();\n\t\t\tfuture.complete(1);\n\t\t\tObject target = getAdapter(CompletableFuture.class).toPublisher(future);\n\t\t\tassertThat(target).as(\"Expected Mono Publisher: \" + target.getClass().getName()).isInstanceOf(Mono.class);\n\t\t\tassertThat(((Mono<Integer>) target).block(FIVE_SECONDS)).isEqualTo(Integer.valueOf(1));\n\t\t}\n\t}\n\n\n\t@Nested\n\tclass RxJava3 {\n\n\t\t@Test\n\t\tvoid defaultAdapterRegistrations() {\n\t\t\t// RxJava 3\n\t\t\tassertThat(getAdapter(io.reactivex.rxjava3.core.Flowable.class)).isNotNull();\n\t\t\tassertThat(getAdapter(io.reactivex.rxjava3.core.Observable.class)).isNotNull();\n\t\t\tassertThat(getAdapter(io.reactivex.rxjava3.core.Single.class)).isNotNull();\n\t\t\tassertThat(getAdapter(io.reactivex.rxjava3.core.Maybe.class)).isNotNull();\n\t\t\tassertThat(getAdapter(io.reactivex.rxjava3.core.Completable.class)).isNotNull();\n\t\t}\n\n\t\t@Test\n\t\tvoid toFlowable() {\n\t\t\tList<Integer> sequence = Arrays.asList(1, 2, 3);\n\t\t\tPublisher<Integer> source = Flux.fromIterable(sequence);\n\t\t\tObject target = getAdapter(io.reactivex.rxjava3.core.Flowable.class).fromPublisher(source);\n\t\t\tassertThat(target).isInstanceOf(io.reactivex.rxjava3.core.Flowable.class);\n\t\t\tassertThat(((io.reactivex.rxjava3.core.Flowable<?>) target).toList().blockingGet()).isEqualTo(sequence);\n\t\t}\n\n\t\t@Test\n\t\tvoid toObservable() {\n\t\t\tList<Integer> sequence = Arrays.asList(1, 2, 3);\n\t\t\tPublisher<Integer> source = Flux.fromIterable(sequence);\n\t\t\tObject target = getAdapter(io.reactivex.rxjava3.core.Observable.class).fromPublisher(source);\n\t\t\tassertThat(target).isInstanceOf(io.reactivex.rxjava3.core.Observable.class);\n\t\t\tassertThat(((io.reactivex.rxjava3.core.Observable<?>) target).toList().blockingGet()).isEqualTo(sequence);\n\t\t}\n\n\t\t@Test\n\t\tvoid toSingle() {\n\t\t\tPublisher<Integer> source = Flux.fromArray(new Integer[] {1});\n\t\t\tObject target = getAdapter(io.reactivex.rxjava3.core.Single.class).fromPublisher(source);\n\t\t\tassertThat(target).isInstanceOf(io.reactivex.rxjava3.core.Single.class);\n\t\t\tassertThat(((io.reactivex.rxjava3.core.Single<Integer>) target).blockingGet()).isEqualTo(Integer.valueOf(1));\n\t\t}\n\n\t\t@Test\n\t\tvoid toCompletable() {\n\t\t\tPublisher<Integer> source = Flux.fromArray(new Integer[] {1, 2, 3});\n\t\t\tObject target = getAdapter(io.reactivex.rxjava3.core.Completable.class).fromPublisher(source);\n\t\t\tassertThat(target).isInstanceOf(io.reactivex.rxjava3.core.Completable.class);\n\t\t\t((io.reactivex.rxjava3.core.Completable) target).blockingAwait();\n\t\t}\n\n\t\t@Test\n\t\tvoid fromFlowable() {\n\t\t\tList<Integer> sequence = Arrays.asList(1, 2, 3);\n\t\t\tObject source = io.reactivex.rxjava3.core.Flowable.fromIterable(sequence);\n\t\t\tObject target = getAdapter(io.reactivex.rxjava3.core.Flowable.class).toPublisher(source);\n\t\t\tassertThat(target).as(\"Expected Flux Publisher: \" + target.getClass().getName()).isInstanceOf(Flux.class);\n\t\t\tassertThat(((Flux<Integer>) target).collectList().block(FIVE_SECONDS)).isEqualTo(sequence);\n\t\t}\n\n\t\t@Test\n\t\tvoid fromObservable() {\n\t\t\tList<Integer> sequence = Arrays.asList(1, 2, 3);\n\t\t\tObject source = io.reactivex.rxjava3.core.Observable.fromIterable(sequence);\n\t\t\tObject target = getAdapter(io.reactivex.rxjava3.core.Observable.class).toPublisher(source);\n\t\t\tassertThat(target).as(\"Expected Flux Publisher: \" + target.getClass().getName()).isInstanceOf(Flux.class);\n\t\t\tassertThat(((Flux<Integer>) target).collectList().block(FIVE_SECONDS)).isEqualTo(sequence);\n\t\t}\n\n\t\t@Test\n\t\tvoid fromSingle() {\n\t\t\tObject source = io.reactivex.rxjava3.core.Single.just(1);\n\t\t\tObject target = getAdapter(io.reactivex.rxjava3.core.Single.class).toPublisher(source);\n\t\t\tassertThat(target).as(\"Expected Mono Publisher: \" + target.getClass().getName()).isInstanceOf(Mono.class);\n\t\t\tassertThat(((Mono<Integer>) target).block(FIVE_SECONDS)).isEqualTo(Integer.valueOf(1));\n\t\t}\n\n\t\t@Test\n\t\tvoid fromCompletable() {\n\t\t\tObject source = io.reactivex.rxjava3.core.Completable.complete();\n\t\t\tObject target = getAdapter(io.reactivex.rxjava3.core.Completable.class).toPublisher(source);\n\t\t\tassertThat(target).as(\"Expected Mono Publisher: \" + target.getClass().getName()).isInstanceOf(Mono.class);\n\t\t\t((Mono<Void>) target).block(FIVE_SECONDS);\n\t\t}\n\t}\n\n\n\t@Nested\n\tclass Kotlin {\n\n\t\t@Test\n\t\tvoid defaultAdapterRegistrations() {\n\t\t\t// Coroutines\n\t\t\tassertThat(getAdapter(Deferred.class)).isNotNull();\n\t\t}\n\n\t\t@Test\n\t\tvoid deferred() {\n\t\t\tassertThat(getAdapter(CompletableFuture.class).getDescriptor().isDeferred()).isFalse();\n\t\t\tassertThat(getAdapter(Deferred.class).getDescriptor().isDeferred()).isTrue();\n\t\t\tassertThat(getAdapter(kotlinx.coroutines.flow.Flow.class).getDescriptor().isDeferred()).isTrue();\n\t\t}\n\t}\n\n\n\t@Nested\n\tclass Mutiny {\n\n\t\t@Test\n\t\tvoid defaultAdapterRegistrations() {\n\t\t\tassertThat(getAdapter(io.smallrye.mutiny.Uni.class)).isNotNull();\n\t\t\tassertThat(getAdapter(io.smallrye.mutiny.Multi.class)).isNotNull();\n\t\t}\n\n\t\t@Test\n\t\tvoid toUni() {\n\t\t\tPublisher<Integer> source = Mono.just(1);\n\t\t\tObject target = getAdapter(Uni.class).fromPublisher(source);\n\t\t\tassertThat(target).isInstanceOf(Uni.class);\n\t\t\tassertThat(((Uni<Integer>) target).await().atMost(FIVE_SECONDS)).isEqualTo(Integer.valueOf(1));\n\t\t}\n\n\t\t@Test\n\t\tvoid fromUni() {\n\t\t\tUni<Integer> source = Uni.createFrom().item(1);\n\t\t\tObject target = getAdapter(Uni.class).toPublisher(source);\n\t\t\tassertThat(target).isInstanceOf(Mono.class);\n\t\t\tassertThat(((Mono<Integer>) target).block(FIVE_SECONDS)).isEqualTo(Integer.valueOf(1));\n\t\t}\n\n\t\t@Test\n\t\tvoid toMulti() {\n\t\t\tList<Integer> sequence = Arrays.asList(1, 2, 3);\n\t\t\tPublisher<Integer> source = Flux.fromIterable(sequence);\n\t\t\tObject target = getAdapter(Multi.class).fromPublisher(source);\n\t\t\tassertThat(target).isInstanceOf(Multi.class);\n\t\t\tassertThat(((Multi<Integer>) target).collect().asList().await().atMost(FIVE_SECONDS)).isEqualTo(sequence);\n\t\t}\n\n\t\t@Test\n\t\tvoid fromMulti() {\n\t\t\tList<Integer> sequence = Arrays.asList(1, 2, 3);\n\t\t\tMulti<Integer> source = Multi.createFrom().iterable(sequence);\n\t\t\tObject target = getAdapter(Multi.class).toPublisher(source);\n\t\t\tassertThat(target).isInstanceOf(Flux.class);\n\t\t\tassertThat(((Flux<Integer>) target).blockLast(FIVE_SECONDS)).isEqualTo(Integer.valueOf(3));\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.Kotlin#defaultAdapterRegistrations()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid defaultAdapterRegistrations() {\r\n    // Coroutines\r\n    assertThat(getAdapter(Deferred.class)).isNotNull();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.Kotlin",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.Kotlin#defaultAdapterRegistrations()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.Kotlin#defaultAdapterRegistrations()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.Kotlin#deferred()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid deferred() {\r\n    assertThat(getAdapter(CompletableFuture.class).getDescriptor().isDeferred()).isFalse();\r\n    assertThat(getAdapter(Deferred.class).getDescriptor().isDeferred()).isTrue();\r\n    assertThat(getAdapter(kotlinx.coroutines.flow.Flow.class).getDescriptor().isDeferred()).isTrue();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.Kotlin",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.Kotlin#deferred()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.Kotlin#deferred()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.Mutiny",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.Mutiny",
    "headType": "class",
    "relation": "use",
    "tail": "@Nested",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.Mutiny",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.time.Duration;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.Flow;\n\nimport io.smallrye.mutiny.Multi;\nimport io.smallrye.mutiny.Uni;\nimport kotlinx.coroutines.Deferred;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.reactivestreams.Publisher;\nimport reactor.adapter.JdkFlowAdapter;\nimport reactor.core.CoreSubscriber;\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Mono;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Tests for {@link ReactiveAdapterRegistry}.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n */\n@SuppressWarnings(\"unchecked\")\nclass ReactiveAdapterRegistryTests {\n\n\tprivate static final Duration FIVE_SECONDS = Duration.ofSeconds(5);\n\n\tprivate final ReactiveAdapterRegistry registry = ReactiveAdapterRegistry.getSharedInstance();\n\n\n\t@Test\n\tvoid getAdapterForReactiveSubType() {\n\t\tReactiveAdapter adapter1 = getAdapter(Flux.class);\n\t\tReactiveAdapter adapter2 = getAdapter(ExtendedFlux.class);\n\t\tassertThat(adapter2).isSameAs(adapter1);\n\n\t\t// Register regular reactive type (after existing adapters)\n\t\tthis.registry.registerReactiveType(\n\t\t\t\tReactiveTypeDescriptor.multiValue(ExtendedFlux.class, ExtendedFlux::empty),\n\t\t\t\to -> (ExtendedFlux<?>) o,\n\t\t\t\tExtendedFlux::from);\n\n\t\t// Matches for ExtendedFlux itself\n\t\tReactiveAdapter adapter3 = getAdapter(ExtendedFlux.class);\n\t\tassertThat(adapter3).isNotNull();\n\t\tassertThat(adapter3).isNotSameAs(adapter1);\n\n\t\t// Does not match for ExtendedFlux subclass since the default Flux adapter\n\t\t// is being assignability-checked first when no specific match was found\n\t\tReactiveAdapter adapter4 = getAdapter(ExtendedExtendedFlux.class);\n\t\tassertThat(adapter4).isSameAs(adapter1);\n\n\t\t// Register reactive type override (before existing adapters)\n\t\tthis.registry.registerReactiveTypeOverride(\n\t\t\t\tReactiveTypeDescriptor.multiValue(Flux.class, ExtendedFlux::empty),\n\t\t\t\to -> (ExtendedFlux<?>) o,\n\t\t\t\tExtendedFlux::from);\n\n\t\t// Override match for Flux\n\t\tReactiveAdapter adapter5 = getAdapter(Flux.class);\n\t\tassertThat(adapter5).isNotNull();\n\t\tassertThat(adapter5).isNotSameAs(adapter1);\n\n\t\t// Initially registered adapter specifically matches for ExtendedFlux\n\t\tReactiveAdapter adapter6 = getAdapter(ExtendedFlux.class);\n\t\tassertThat(adapter6).isSameAs(adapter3);\n\n\t\t// Override match for ExtendedFlux subclass\n\t\tReactiveAdapter adapter7 = getAdapter(ExtendedExtendedFlux.class);\n\t\tassertThat(adapter7).isSameAs(adapter5);\n\t}\n\n\n\tprivate ReactiveAdapter getAdapter(Class<?> reactiveType) {\n\t\tReactiveAdapter adapter = this.registry.getAdapter(reactiveType);\n\t\tassertThat(adapter).isNotNull();\n\t\treturn adapter;\n\t}\n\n\n\tprivate static class ExtendedFlux<T> extends Flux<T> {\n\n\t\t@Override\n\t\tpublic void subscribe(CoreSubscriber<? super T> actual) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n\n\n\tprivate static class ExtendedExtendedFlux<T> extends ExtendedFlux<T> {\n\t}\n\n\n\t@Nested\n\tclass Reactor {\n\n\t\t@Test\n\t\tvoid defaultAdapterRegistrations() {\n\t\t\t// Reactor\n\t\t\tassertThat(getAdapter(Mono.class)).isNotNull();\n\t\t\tassertThat(getAdapter(Flux.class)).isNotNull();\n\n\t\t\t// Publisher\n\t\t\tassertThat(getAdapter(Publisher.class)).isNotNull();\n\n\t\t\t// Completable\n\t\t\tassertThat(getAdapter(CompletableFuture.class)).isNotNull();\n\t\t}\n\n\t\t@Test\n\t\tvoid toFlux() {\n\t\t\tList<Integer> sequence = Arrays.asList(1, 2, 3);\n\t\t\tPublisher<Integer> source = io.reactivex.rxjava3.core.Flowable.fromIterable(sequence);\n\t\t\tObject target = getAdapter(Flux.class).fromPublisher(source);\n\t\t\tassertThat(target).isInstanceOf(Flux.class);\n\t\t\tassertThat(((Flux<Integer>) target).collectList().block(FIVE_SECONDS)).isEqualTo(sequence);\n\t\t}\n\n\t\t@Test\n\t\tvoid toMono() {\n\t\t\tPublisher<Integer> source = io.reactivex.rxjava3.core.Flowable.fromArray(1, 2, 3);\n\t\t\tObject target = getAdapter(Mono.class).fromPublisher(source);\n\t\t\tassertThat(target).isInstanceOf(Mono.class);\n\t\t\tassertThat(((Mono<Integer>) target).block(FIVE_SECONDS)).isEqualTo(Integer.valueOf(1));\n\t\t}\n\n\t\t@Test\n\t\tvoid toFlowPublisher() {\n\t\t\tList<Integer> sequence = Arrays.asList(1, 2, 3);\n\t\t\tPublisher<Integer> source = io.reactivex.rxjava3.core.Flowable.fromIterable(sequence);\n\t\t\tObject target = getAdapter(Flow.Publisher.class).fromPublisher(source);\n\t\t\tassertThat(target).isInstanceOf(Flow.Publisher.class);\n\t\t\tassertThat(JdkFlowAdapter.flowPublisherToFlux((Flow.Publisher<Integer>) target)\n\t\t\t\t\t.collectList().block(FIVE_SECONDS)).isEqualTo(sequence);\n\t\t}\n\n\t\t@Test\n\t\tvoid toCompletableFuture() throws Exception {\n\t\t\tPublisher<Integer> source = Flux.fromArray(new Integer[] {1, 2, 3});\n\t\t\tObject target = getAdapter(CompletableFuture.class).fromPublisher(source);\n\t\t\tassertThat(target).isInstanceOf(CompletableFuture.class);\n\t\t\tassertThat(((CompletableFuture<Integer>) target).get()).isEqualTo(Integer.valueOf(1));\n\t\t}\n\n\t\t@Test\n\t\tvoid fromCompletableFuture() {\n\t\t\tCompletableFuture<Integer> future = new CompletableFuture<>();\n\t\t\tfuture.complete(1);\n\t\t\tObject target = getAdapter(CompletableFuture.class).toPublisher(future);\n\t\t\tassertThat(target).as(\"Expected Mono Publisher: \" + target.getClass().getName()).isInstanceOf(Mono.class);\n\t\t\tassertThat(((Mono<Integer>) target).block(FIVE_SECONDS)).isEqualTo(Integer.valueOf(1));\n\t\t}\n\t}\n\n\n\t@Nested\n\tclass RxJava3 {\n\n\t\t@Test\n\t\tvoid defaultAdapterRegistrations() {\n\t\t\t// RxJava 3\n\t\t\tassertThat(getAdapter(io.reactivex.rxjava3.core.Flowable.class)).isNotNull();\n\t\t\tassertThat(getAdapter(io.reactivex.rxjava3.core.Observable.class)).isNotNull();\n\t\t\tassertThat(getAdapter(io.reactivex.rxjava3.core.Single.class)).isNotNull();\n\t\t\tassertThat(getAdapter(io.reactivex.rxjava3.core.Maybe.class)).isNotNull();\n\t\t\tassertThat(getAdapter(io.reactivex.rxjava3.core.Completable.class)).isNotNull();\n\t\t}\n\n\t\t@Test\n\t\tvoid toFlowable() {\n\t\t\tList<Integer> sequence = Arrays.asList(1, 2, 3);\n\t\t\tPublisher<Integer> source = Flux.fromIterable(sequence);\n\t\t\tObject target = getAdapter(io.reactivex.rxjava3.core.Flowable.class).fromPublisher(source);\n\t\t\tassertThat(target).isInstanceOf(io.reactivex.rxjava3.core.Flowable.class);\n\t\t\tassertThat(((io.reactivex.rxjava3.core.Flowable<?>) target).toList().blockingGet()).isEqualTo(sequence);\n\t\t}\n\n\t\t@Test\n\t\tvoid toObservable() {\n\t\t\tList<Integer> sequence = Arrays.asList(1, 2, 3);\n\t\t\tPublisher<Integer> source = Flux.fromIterable(sequence);\n\t\t\tObject target = getAdapter(io.reactivex.rxjava3.core.Observable.class).fromPublisher(source);\n\t\t\tassertThat(target).isInstanceOf(io.reactivex.rxjava3.core.Observable.class);\n\t\t\tassertThat(((io.reactivex.rxjava3.core.Observable<?>) target).toList().blockingGet()).isEqualTo(sequence);\n\t\t}\n\n\t\t@Test\n\t\tvoid toSingle() {\n\t\t\tPublisher<Integer> source = Flux.fromArray(new Integer[] {1});\n\t\t\tObject target = getAdapter(io.reactivex.rxjava3.core.Single.class).fromPublisher(source);\n\t\t\tassertThat(target).isInstanceOf(io.reactivex.rxjava3.core.Single.class);\n\t\t\tassertThat(((io.reactivex.rxjava3.core.Single<Integer>) target).blockingGet()).isEqualTo(Integer.valueOf(1));\n\t\t}\n\n\t\t@Test\n\t\tvoid toCompletable() {\n\t\t\tPublisher<Integer> source = Flux.fromArray(new Integer[] {1, 2, 3});\n\t\t\tObject target = getAdapter(io.reactivex.rxjava3.core.Completable.class).fromPublisher(source);\n\t\t\tassertThat(target).isInstanceOf(io.reactivex.rxjava3.core.Completable.class);\n\t\t\t((io.reactivex.rxjava3.core.Completable) target).blockingAwait();\n\t\t}\n\n\t\t@Test\n\t\tvoid fromFlowable() {\n\t\t\tList<Integer> sequence = Arrays.asList(1, 2, 3);\n\t\t\tObject source = io.reactivex.rxjava3.core.Flowable.fromIterable(sequence);\n\t\t\tObject target = getAdapter(io.reactivex.rxjava3.core.Flowable.class).toPublisher(source);\n\t\t\tassertThat(target).as(\"Expected Flux Publisher: \" + target.getClass().getName()).isInstanceOf(Flux.class);\n\t\t\tassertThat(((Flux<Integer>) target).collectList().block(FIVE_SECONDS)).isEqualTo(sequence);\n\t\t}\n\n\t\t@Test\n\t\tvoid fromObservable() {\n\t\t\tList<Integer> sequence = Arrays.asList(1, 2, 3);\n\t\t\tObject source = io.reactivex.rxjava3.core.Observable.fromIterable(sequence);\n\t\t\tObject target = getAdapter(io.reactivex.rxjava3.core.Observable.class).toPublisher(source);\n\t\t\tassertThat(target).as(\"Expected Flux Publisher: \" + target.getClass().getName()).isInstanceOf(Flux.class);\n\t\t\tassertThat(((Flux<Integer>) target).collectList().block(FIVE_SECONDS)).isEqualTo(sequence);\n\t\t}\n\n\t\t@Test\n\t\tvoid fromSingle() {\n\t\t\tObject source = io.reactivex.rxjava3.core.Single.just(1);\n\t\t\tObject target = getAdapter(io.reactivex.rxjava3.core.Single.class).toPublisher(source);\n\t\t\tassertThat(target).as(\"Expected Mono Publisher: \" + target.getClass().getName()).isInstanceOf(Mono.class);\n\t\t\tassertThat(((Mono<Integer>) target).block(FIVE_SECONDS)).isEqualTo(Integer.valueOf(1));\n\t\t}\n\n\t\t@Test\n\t\tvoid fromCompletable() {\n\t\t\tObject source = io.reactivex.rxjava3.core.Completable.complete();\n\t\t\tObject target = getAdapter(io.reactivex.rxjava3.core.Completable.class).toPublisher(source);\n\t\t\tassertThat(target).as(\"Expected Mono Publisher: \" + target.getClass().getName()).isInstanceOf(Mono.class);\n\t\t\t((Mono<Void>) target).block(FIVE_SECONDS);\n\t\t}\n\t}\n\n\n\t@Nested\n\tclass Kotlin {\n\n\t\t@Test\n\t\tvoid defaultAdapterRegistrations() {\n\t\t\t// Coroutines\n\t\t\tassertThat(getAdapter(Deferred.class)).isNotNull();\n\t\t}\n\n\t\t@Test\n\t\tvoid deferred() {\n\t\t\tassertThat(getAdapter(CompletableFuture.class).getDescriptor().isDeferred()).isFalse();\n\t\t\tassertThat(getAdapter(Deferred.class).getDescriptor().isDeferred()).isTrue();\n\t\t\tassertThat(getAdapter(kotlinx.coroutines.flow.Flow.class).getDescriptor().isDeferred()).isTrue();\n\t\t}\n\t}\n\n\n\t@Nested\n\tclass Mutiny {\n\n\t\t@Test\n\t\tvoid defaultAdapterRegistrations() {\n\t\t\tassertThat(getAdapter(io.smallrye.mutiny.Uni.class)).isNotNull();\n\t\t\tassertThat(getAdapter(io.smallrye.mutiny.Multi.class)).isNotNull();\n\t\t}\n\n\t\t@Test\n\t\tvoid toUni() {\n\t\t\tPublisher<Integer> source = Mono.just(1);\n\t\t\tObject target = getAdapter(Uni.class).fromPublisher(source);\n\t\t\tassertThat(target).isInstanceOf(Uni.class);\n\t\t\tassertThat(((Uni<Integer>) target).await().atMost(FIVE_SECONDS)).isEqualTo(Integer.valueOf(1));\n\t\t}\n\n\t\t@Test\n\t\tvoid fromUni() {\n\t\t\tUni<Integer> source = Uni.createFrom().item(1);\n\t\t\tObject target = getAdapter(Uni.class).toPublisher(source);\n\t\t\tassertThat(target).isInstanceOf(Mono.class);\n\t\t\tassertThat(((Mono<Integer>) target).block(FIVE_SECONDS)).isEqualTo(Integer.valueOf(1));\n\t\t}\n\n\t\t@Test\n\t\tvoid toMulti() {\n\t\t\tList<Integer> sequence = Arrays.asList(1, 2, 3);\n\t\t\tPublisher<Integer> source = Flux.fromIterable(sequence);\n\t\t\tObject target = getAdapter(Multi.class).fromPublisher(source);\n\t\t\tassertThat(target).isInstanceOf(Multi.class);\n\t\t\tassertThat(((Multi<Integer>) target).collect().asList().await().atMost(FIVE_SECONDS)).isEqualTo(sequence);\n\t\t}\n\n\t\t@Test\n\t\tvoid fromMulti() {\n\t\t\tList<Integer> sequence = Arrays.asList(1, 2, 3);\n\t\t\tMulti<Integer> source = Multi.createFrom().iterable(sequence);\n\t\t\tObject target = getAdapter(Multi.class).toPublisher(source);\n\t\t\tassertThat(target).isInstanceOf(Flux.class);\n\t\t\tassertThat(((Flux<Integer>) target).blockLast(FIVE_SECONDS)).isEqualTo(Integer.valueOf(3));\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.Mutiny#defaultAdapterRegistrations()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid defaultAdapterRegistrations() {\r\n    assertThat(getAdapter(io.smallrye.mutiny.Uni.class)).isNotNull();\r\n    assertThat(getAdapter(io.smallrye.mutiny.Multi.class)).isNotNull();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.Mutiny",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.Mutiny#defaultAdapterRegistrations()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.Mutiny#defaultAdapterRegistrations()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.Mutiny#toUni()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid toUni() {\r\n    Publisher<Integer> source = Mono.just(1);\r\n    Object target = getAdapter(Uni.class).fromPublisher(source);\r\n    assertThat(target).isInstanceOf(Uni.class);\r\n    assertThat(((Uni<Integer>) target).await().atMost(FIVE_SECONDS)).isEqualTo(Integer.valueOf(1));\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.Mutiny",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.Mutiny#toUni()",
    "tailType": "method"
  }
]