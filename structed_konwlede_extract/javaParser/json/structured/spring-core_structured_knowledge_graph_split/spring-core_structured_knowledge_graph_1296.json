[
  {
    "head": "org.springframework.util.SoftEntryReference#nextReference",
    "headType": "field",
    "relation": "haveType",
    "tail": "Reference<K, V>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.util.SoftEntryReference#getHash()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic int getHash() {\r\n    return this.hash;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.SoftEntryReference",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.SoftEntryReference#getHash()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.SoftEntryReference#getHash()",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.SoftEntryReference#getNext()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\n@Nullable\r\npublic Reference<K, V> getNext() {\r\n    return this.nextReference;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.SoftEntryReference",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.SoftEntryReference#getNext()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.SoftEntryReference#getNext()",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.SoftEntryReference#getNext()",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.SoftEntryReference#release()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic void release() {\r\n    enqueue();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.SoftEntryReference",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.SoftEntryReference#release()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.SoftEntryReference#release()",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.SoftEntryReference",
    "headType": "class",
    "relation": "extend",
    "tail": "SoftReference",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.WeakEntryReference",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.WeakEntryReference",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.lang.ref.ReferenceQueue;\nimport java.lang.ref.SoftReference;\nimport java.lang.ref.WeakReference;\nimport java.lang.reflect.Array;\nimport java.util.AbstractMap;\nimport java.util.AbstractSet;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.locks.ReentrantLock;\n\nimport org.jspecify.annotations.Nullable;\n\n/**\n * A {@link ConcurrentHashMap} that uses {@link ReferenceType#SOFT soft} or\n * {@linkplain ReferenceType#WEAK weak} references for both {@code keys} and {@code values}.\n *\n * <p>This class can be used as an alternative to\n * {@code Collections.synchronizedMap(new WeakHashMap<K, Reference<V>>())} in order to\n * support better performance when accessed concurrently. This implementation follows the\n * same design constraints as {@link ConcurrentHashMap} with the exception that\n * {@code null} values and {@code null} keys are supported.\n *\n * <p><b>NOTE:</b> The use of references means that there is no guarantee that items\n * placed into the map will be subsequently available. The garbage collector may discard\n * references at any time, so it may appear that an unknown thread is silently removing\n * entries.\n *\n * <p>If not explicitly specified, this implementation will use\n * {@linkplain SoftReference soft entry references}.\n *\n * @author Phillip Webb\n * @author Juergen Hoeller\n * @author Brian Clozel\n * @since 3.2\n * @param <K> the key type\n * @param <V> the value type\n */\npublic class ConcurrentReferenceHashMap<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V> {\n\n\tprivate static final int DEFAULT_INITIAL_CAPACITY = 16;\n\n\tprivate static final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n\tprivate static final int DEFAULT_CONCURRENCY_LEVEL = 16;\n\n\tprivate static final ReferenceType DEFAULT_REFERENCE_TYPE = ReferenceType.SOFT;\n\n\tprivate static final int MAXIMUM_CONCURRENCY_LEVEL = 1 << 16;\n\n\tprivate static final int MAXIMUM_SEGMENT_SIZE = 1 << 30;\n\n\n\t/**\n\t * Array of segments indexed using the high order bits from the hash.\n\t */\n\tprivate final Segment[] segments;\n\n\t/**\n\t * When the average number of references per table exceeds this value resize will be attempted.\n\t */\n\tprivate final float loadFactor;\n\n\t/**\n\t * The reference type: SOFT or WEAK.\n\t */\n\tprivate final ReferenceType referenceType;\n\n\t/**\n\t * The shift value used to calculate the size of the segments array and an index from the hash.\n\t */\n\tprivate final int shift;\n\n\t/**\n\t * Late binding entry set.\n\t */\n\tprivate volatile @Nullable Set<Map.Entry<K, V>> entrySet;\n\n\n\t/**\n\t * Create a new {@code ConcurrentReferenceHashMap} instance.\n\t */\n\tpublic ConcurrentReferenceHashMap() {\n\t\tthis(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE);\n\t}\n\n\t/**\n\t * Create a new {@code ConcurrentReferenceHashMap} instance.\n\t * @param initialCapacity the initial capacity of the map\n\t */\n\tpublic ConcurrentReferenceHashMap(int initialCapacity) {\n\t\tthis(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE);\n\t}\n\n\t/**\n\t * Create a new {@code ConcurrentReferenceHashMap} instance.\n\t * @param initialCapacity the initial capacity of the map\n\t * @param loadFactor the load factor. When the average number of references per table\n\t * exceeds this value resize will be attempted\n\t */\n\tpublic ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {\n\t\tthis(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE);\n\t}\n\n\t/**\n\t * Create a new {@code ConcurrentReferenceHashMap} instance.\n\t * @param initialCapacity the initial capacity of the map\n\t * @param concurrencyLevel the expected number of threads that will concurrently\n\t * write to the map\n\t */\n\tpublic ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {\n\t\tthis(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE);\n\t}\n\n\t/**\n\t * Create a new {@code ConcurrentReferenceHashMap} instance.\n\t * @param initialCapacity the initial capacity of the map\n\t * @param referenceType the reference type used for entries (soft or weak)\n\t */\n\tpublic ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType) {\n\t\tthis(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, referenceType);\n\t}\n\n\t/**\n\t * Create a new {@code ConcurrentReferenceHashMap} instance.\n\t * @param initialCapacity the initial capacity of the map\n\t * @param loadFactor the load factor. When the average number of references per\n\t * table exceeds this value, resize will be attempted.\n\t * @param concurrencyLevel the expected number of threads that will concurrently\n\t * write to the map\n\t */\n\tpublic ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {\n\t\tthis(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE);\n\t}\n\n\t/**\n\t * Create a new {@code ConcurrentReferenceHashMap} instance.\n\t * @param initialCapacity the initial capacity of the map\n\t * @param loadFactor the load factor. When the average number of references per\n\t * table exceeds this value, resize will be attempted.\n\t * @param concurrencyLevel the expected number of threads that will concurrently\n\t * write to the map\n\t * @param referenceType the reference type used for entries (soft or weak)\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic ConcurrentReferenceHashMap(\n\t\t\tint initialCapacity, float loadFactor, int concurrencyLevel, ReferenceType referenceType) {\n\n\t\tAssert.isTrue(initialCapacity >= 0, \"Initial capacity must not be negative\");\n\t\tAssert.isTrue(loadFactor > 0f, \"Load factor must be positive\");\n\t\tAssert.isTrue(concurrencyLevel > 0, \"Concurrency level must be positive\");\n\t\tAssert.notNull(referenceType, \"Reference type must not be null\");\n\t\tthis.loadFactor = loadFactor;\n\t\tthis.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL);\n\t\tint size = 1 << this.shift;\n\t\tthis.referenceType = referenceType;\n\t\tint roundedUpSegmentCapacity = (int) ((initialCapacity + size - 1L) / size);\n\t\tint initialSize = 1 << calculateShift(roundedUpSegmentCapacity, MAXIMUM_SEGMENT_SIZE);\n\t\tSegment[] segments = (Segment[]) Array.newInstance(Segment.class, size);\n\t\tint resizeThreshold = (int) (initialSize * getLoadFactor());\n\t\tfor (int i = 0; i < segments.length; i++) {\n\t\t\tsegments[i] = new Segment(initialSize, resizeThreshold);\n\t\t}\n\t\tthis.segments = segments;\n\t}\n\n\n\tprotected final float getLoadFactor() {\n\t\treturn this.loadFactor;\n\t}\n\n\tprotected final int getSegmentsSize() {\n\t\treturn this.segments.length;\n\t}\n\n\tprotected final Segment getSegment(int index) {\n\t\treturn this.segments[index];\n\t}\n\n\t/**\n\t * Factory method that returns the {@link ReferenceManager}.\n\t * This method will be called once for each {@link Segment}.\n\t * @return a new reference manager\n\t */\n\tprotected ReferenceManager createReferenceManager() {\n\t\treturn new ReferenceManager();\n\t}\n\n\t/**\n\t * Get the hash for a given object, apply an additional hash function to reduce\n\t * collisions. This implementation uses the same Wang/Jenkins algorithm as\n\t * {@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing.\n\t * @param o the object to hash (may be null)\n\t * @return the resulting hash code\n\t */\n\tprotected int getHash(@Nullable Object o) {\n\t\tint hash = (o != null ? o.hashCode() : 0);\n\t\thash += (hash << 15) ^ 0xffffcd7d;\n\t\thash ^= (hash >>> 10);\n\t\thash += (hash << 3);\n\t\thash ^= (hash >>> 6);\n\t\thash += (hash << 2) + (hash << 14);\n\t\thash ^= (hash >>> 16);\n\t\treturn hash;\n\t}\n\n\t@Override\n\tpublic @Nullable V get(@Nullable Object key) {\n\t\tReference<K, V> ref = getReference(key, Restructure.WHEN_NECESSARY);\n\t\tEntry<K, V> entry = (ref != null ? ref.get() : null);\n\t\treturn (entry != null ? entry.getValue() : null);\n\t}\n\n\t@Override\n\tpublic @Nullable V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {\n\t\tReference<K, V> ref = getReference(key, Restructure.WHEN_NECESSARY);\n\t\tEntry<K, V> entry = (ref != null ? ref.get() : null);\n\t\treturn (entry != null ? entry.getValue() : defaultValue);\n\t}\n\n\t@Override\n\tpublic boolean containsKey(@Nullable Object key) {\n\t\tReference<K, V> ref = getReference(key, Restructure.WHEN_NECESSARY);\n\t\tEntry<K, V> entry = (ref != null ? ref.get() : null);\n\t\treturn (entry != null && ObjectUtils.nullSafeEquals(entry.getKey(), key));\n\t}\n\n\t/**\n\t * Return a {@link Reference} to the {@link Entry} for the specified {@code key},\n\t * or {@code null} if not found.\n\t * @param key the key (can be {@code null})\n\t * @param restructure types of restructure allowed during this call\n\t * @return the reference, or {@code null} if not found\n\t */\n\tprotected final @Nullable Reference<K, V> getReference(@Nullable Object key, Restructure restructure) {\n\t\tint hash = getHash(key);\n\t\treturn getSegmentForHash(hash).getReference(key, hash, restructure);\n\t}\n\n\t@Override\n\tpublic @Nullable V put(@Nullable K key, @Nullable V value) {\n\t\treturn put(key, value, true);\n\t}\n\n\t@Override\n\tpublic @Nullable V putIfAbsent(@Nullable K key, @Nullable V value) {\n\t\treturn put(key, value, false);\n\t}\n\n\tprivate @Nullable V put(final @Nullable K key, final @Nullable V value, final boolean overwriteExisting) {\n\t\treturn doTask(key, new Task<V>(TaskOption.RESTRUCTURE_BEFORE, TaskOption.RESIZE) {\n\t\t\t@Override\n\t\t\tprotected @Nullable V execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries<V> entries) {\n\t\t\t\tif (entry != null) {\n\t\t\t\t\tV oldValue = entry.getValue();\n\t\t\t\t\tif (overwriteExisting) {\n\t\t\t\t\t\tentry.setValue(value);\n\t\t\t\t\t}\n\t\t\t\t\treturn oldValue;\n\t\t\t\t}\n\t\t\t\tAssert.state(entries != null, \"No entries segment\");\n\t\t\t\tentries.add(value);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\tpublic @Nullable V remove(@Nullable Object key) {\n\t\treturn doTask(key, new Task<V>(TaskOption.RESTRUCTURE_AFTER, TaskOption.SKIP_IF_EMPTY) {\n\t\t\t@Override\n\t\t\tprotected @Nullable V execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {\n\t\t\t\tif (entry != null) {\n\t\t\t\t\tif (ref != null) {\n\t\t\t\t\t\tref.release();\n\t\t\t\t\t}\n\t\t\t\t\treturn entry.value;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\tpublic boolean remove(@Nullable Object key, final @Nullable Object value) {\n\t\tBoolean result = doTask(key, new Task<Boolean>(TaskOption.RESTRUCTURE_AFTER, TaskOption.SKIP_IF_EMPTY) {\n\t\t\t@Override\n\t\t\tprotected Boolean execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {\n\t\t\t\tif (entry != null && ObjectUtils.nullSafeEquals(entry.getValue(), value)) {\n\t\t\t\t\tif (ref != null) {\n\t\t\t\t\t\tref.release();\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\treturn (Boolean.TRUE.equals(result));\n\t}\n\n\t@Override\n\tpublic boolean replace(@Nullable K key, final @Nullable V oldValue, final @Nullable V newValue) {\n\t\tBoolean result = doTask(key, new Task<Boolean>(TaskOption.RESTRUCTURE_BEFORE, TaskOption.SKIP_IF_EMPTY) {\n\t\t\t@Override\n\t\t\tprotected Boolean execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {\n\t\t\t\tif (entry != null && ObjectUtils.nullSafeEquals(entry.getValue(), oldValue)) {\n\t\t\t\t\tentry.setValue(newValue);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\treturn (Boolean.TRUE.equals(result));\n\t}\n\n\t@Override\n\tpublic @Nullable V replace(@Nullable K key, final @Nullable V value) {\n\t\treturn doTask(key, new Task<V>(TaskOption.RESTRUCTURE_BEFORE, TaskOption.SKIP_IF_EMPTY) {\n\t\t\t@Override\n\t\t\tprotected @Nullable V execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {\n\t\t\t\tif (entry != null) {\n\t\t\t\t\tV oldValue = entry.getValue();\n\t\t\t\t\tentry.setValue(value);\n\t\t\t\t\treturn oldValue;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tfor (Segment segment : this.segments) {\n\t\t\tsegment.clear();\n\t\t}\n\t}\n\n\t/**\n\t * Remove any entries that have been garbage collected and are no longer referenced.\n\t * Under normal circumstances garbage collected entries are automatically purged as\n\t * items are added or removed from the Map. This method can be used to force a purge,\n\t * and is useful when the Map is read frequently but updated less often.\n\t */\n\tpublic void purgeUnreferencedEntries() {\n\t\tfor (Segment segment : this.segments) {\n\t\t\tsegment.restructureIfNecessary(false);\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic int size() {\n\t\tint size = 0;\n\t\tfor (Segment segment : this.segments) {\n\t\t\tsize += segment.getCount();\n\t\t}\n\t\treturn size;\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\tfor (Segment segment : this.segments) {\n\t\t\tif (segment.getCount() > 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic Set<Map.Entry<K, V>> entrySet() {\n\t\tSet<Map.Entry<K, V>> entrySet = this.entrySet;\n\t\tif (entrySet == null) {\n\t\t\tentrySet = new EntrySet();\n\t\t\tthis.entrySet = entrySet;\n\t\t}\n\t\treturn entrySet;\n\t}\n\n\tprivate <T> @Nullable T doTask(@Nullable Object key, Task<T> task) {\n\t\tint hash = getHash(key);\n\t\treturn getSegmentForHash(hash).doTask(hash, key, task);\n\t}\n\n\tprivate Segment getSegmentForHash(int hash) {\n\t\treturn this.segments[(hash >>> (32 - this.shift)) & (this.segments.length - 1)];\n\t}\n\n\t/**\n\t * Calculate a shift value that can be used to create a power-of-two value between\n\t * the specified maximum and minimum values.\n\t * @param minimumValue the minimum value\n\t * @param maximumValue the maximum value\n\t * @return the calculated shift (use {@code 1 << shift} to obtain a value)\n\t */\n\tprotected static int calculateShift(int minimumValue, int maximumValue) {\n\t\tint shift = 0;\n\t\tint value = 1;\n\t\twhile (value < minimumValue && value < maximumValue) {\n\t\t\tvalue <<= 1;\n\t\t\tshift++;\n\t\t}\n\t\treturn shift;\n\t}\n\n\n\t/**\n\t * Various reference types supported by this map.\n\t */\n\tpublic enum ReferenceType {\n\n\t\t/** Use {@link SoftReference SoftReferences}. */\n\t\tSOFT,\n\n\t\t/** Use {@link WeakReference WeakReferences}. */\n\t\tWEAK\n\t}\n\n\n\t/**\n\t * A single segment used to divide the map to allow better concurrent performance.\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprotected final class Segment extends ReentrantLock {\n\n\t\tprivate final ReferenceManager referenceManager;\n\n\t\tprivate final int initialSize;\n\n\t\t/**\n\t\t * Array of references indexed using the low order bits from the hash.\n\t\t * This property should only be set along with {@code resizeThreshold}.\n\t\t */\n\t\tprivate volatile @Nullable Reference<K, V>[] references;\n\n\t\t/**\n\t\t * The total number of references contained in this segment. This includes chained\n\t\t * references and references that have been garbage collected but not purged.\n\t\t */\n\t\tprivate final AtomicInteger count = new AtomicInteger();\n\n\t\t/**\n\t\t * The threshold when resizing of the references should occur. When {@code count}\n\t\t * exceeds this value references will be resized.\n\t\t */\n\t\tprivate int resizeThreshold;\n\n\t\tpublic Segment(int initialSize, int resizeThreshold) {\n\t\t\tthis.referenceManager = createReferenceManager();\n\t\t\tthis.initialSize = initialSize;\n\t\t\tthis.references = createReferenceArray(initialSize);\n\t\t\tthis.resizeThreshold = resizeThreshold;\n\t\t}\n\n\t\tpublic @Nullable Reference<K, V> getReference(@Nullable Object key, int hash, Restructure restructure) {\n\t\t\tif (restructure == Restructure.WHEN_NECESSARY) {\n\t\t\t\trestructureIfNecessary(false);\n\t\t\t}\n\t\t\tif (this.count.get() == 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// Use a local copy to protect against other threads writing\n\t\t\t@Nullable Reference<K, V>[] references = this.references;\n\t\t\tint index = getIndex(hash, references);\n\t\t\tReference<K, V> head = references[index];\n\t\t\treturn findInChain(head, key, hash);\n\t\t}\n\n\t\t/**\n\t\t * Apply an update operation to this segment.\n\t\t * The segment will be locked during the update.\n\t\t * @param hash the hash of the key\n\t\t * @param key the key\n\t\t * @param task the update operation\n\t\t * @return the result of the operation\n\t\t */\n\t\tpublic <T> @Nullable T doTask(final int hash, final @Nullable Object key, final Task<T> task) {\n\t\t\tboolean resize = task.hasOption(TaskOption.RESIZE);\n\t\t\tif (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {\n\t\t\t\trestructureIfNecessary(resize);\n\t\t\t}\n\t\t\tif (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count.get() == 0) {\n\t\t\t\treturn task.execute(null, null, null);\n\t\t\t}\n\t\t\tlock();\n\t\t\ttry {\n\t\t\t\tfinal int index = getIndex(hash, this.references);\n\t\t\t\tfinal Reference<K, V> head = this.references[index];\n\t\t\t\tReference<K, V> ref = findInChain(head, key, hash);\n\t\t\t\tEntry<K, V> entry = (ref != null ? ref.get() : null);\n\t\t\t\tEntries<V> entries = value -> {\n\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\tEntry<K, V> newEntry = new Entry<>((K) key, value);\n\t\t\t\t\tReference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head);\n\t\t\t\t\tSegment.this.references[index] = newReference;\n\t\t\t\t\tSegment.this.count.incrementAndGet();\n\t\t\t\t};\n\t\t\t\treturn task.execute(ref, entry, entries);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tunlock();\n\t\t\t\tif (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {\n\t\t\t\t\trestructureIfNecessary(resize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Clear all items from this segment.\n\t\t */\n\t\tpublic void clear() {\n\t\t\tif (this.count.get() == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlock();\n\t\t\ttry {\n\t\t\t\tthis.references = createReferenceArray(this.initialSize);\n\t\t\t\tthis.resizeThreshold = (int) (this.references.length * getLoadFactor());\n\t\t\t\tthis.count.set(0);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tunlock();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Restructure the underlying data structure when it becomes necessary. This\n\t\t * method can increase the size of the references table as well as purge any\n\t\t * references that have been garbage collected.\n\t\t * @param allowResize if resizing is permitted\n\t\t */\n\t\tvoid restructureIfNecessary(boolean allowResize) {\n\t\t\tint currCount = this.count.get();\n\t\t\tboolean needsResize = allowResize && (currCount > 0 && currCount >= this.resizeThreshold);\n\t\t\tReference<K, V> ref = this.referenceManager.pollForPurge();\n\t\t\tif (ref != null || (needsResize)) {\n\t\t\t\trestructure(allowResize, ref);\n\t\t\t}\n\t\t}\n\n\t\tprivate void restructure(boolean allowResize, @Nullable Reference<K, V> ref) {\n\t\t\tboolean needsResize;\n\t\t\tlock();\n\t\t\ttry {\n\t\t\t\tint expectedCount = this.count.get();\n\t\t\t\tSet<Reference<K, V>> toPurge = Collections.emptySet();\n\t\t\t\tif (ref != null) {\n\t\t\t\t\ttoPurge = new HashSet<>();\n\t\t\t\t\twhile (ref != null) {\n\t\t\t\t\t\ttoPurge.add(ref);\n\t\t\t\t\t\tref = this.referenceManager.pollForPurge();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\texpectedCount -= toPurge.size();\n\n\t\t\t\t// Estimate new count, taking into account count inside lock and items that\n\t\t\t\t// will be purged.\n\t\t\t\tneedsResize = (expectedCount > 0 && expectedCount >= this.resizeThreshold);\n\t\t\t\tboolean resizing = false;\n\t\t\t\tint restructureSize = this.references.length;\n\t\t\t\tif (allowResize && needsResize && restructureSize < MAXIMUM_SEGMENT_SIZE) {\n\t\t\t\t\trestructureSize <<= 1;\n\t\t\t\t\tresizing = true;\n\t\t\t\t}\n\n\t\t\t\tint newCount = 0;\n\t\t\t\t// Restructure the resized reference array\n\t\t\t\tif (resizing) {\n\t\t\t\t\tReference<K, V>[] restructured = createReferenceArray(restructureSize);\n\t\t\t\t\tfor (Reference<K, V> reference : this.references) {\n\t\t\t\t\t\tref = reference;\n\t\t\t\t\t\twhile (ref != null) {\n\t\t\t\t\t\t\tif (!toPurge.contains(ref)) {\n\t\t\t\t\t\t\t\tEntry<K, V> entry = ref.get();\n\t\t\t\t\t\t\t\t// Also filter out null references that are now null\n\t\t\t\t\t\t\t\t// they should be polled from the queue in a later restructure call.\n\t\t\t\t\t\t\t\tif (entry != null) {\n\t\t\t\t\t\t\t\t\tint index = getIndex(ref.getHash(), restructured);\n\t\t\t\t\t\t\t\t\trestructured[index] = this.referenceManager.createReference(\n\t\t\t\t\t\t\t\t\t\t\tentry, ref.getHash(), restructured[index]);\n\t\t\t\t\t\t\t\t\tnewCount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tref = ref.getNext();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Replace volatile members\n\t\t\t\t\tthis.references = restructured;\n\t\t\t\t\tthis.resizeThreshold = (int) (this.references.length * getLoadFactor());\n\t\t\t\t}\n\t\t\t\t// Restructure the existing reference array \"in place\"\n\t\t\t\telse {\n\t\t\t\t\tfor (int i = 0; i < this.references.length; i++) {\n\t\t\t\t\t\tReference<K, V> purgedRef = null;\n\t\t\t\t\t\tref = this.references[i];\n\t\t\t\t\t\twhile (ref != null) {\n\t\t\t\t\t\t\tif (!toPurge.contains(ref)) {\n\t\t\t\t\t\t\t\tEntry<K, V> entry = ref.get();\n\t\t\t\t\t\t\t\t// Also filter out null references that are now null\n\t\t\t\t\t\t\t\t// they should be polled from the queue in a later restructure call.\n\t\t\t\t\t\t\t\tif (entry != null) {\n\t\t\t\t\t\t\t\t\tpurgedRef = this.referenceManager.createReference(\n\t\t\t\t\t\t\t\t\t\t\tentry, ref.getHash(), purgedRef);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnewCount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tref = ref.getNext();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.references[i] = purgedRef;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.count.set(Math.max(newCount, 0));\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tunlock();\n\t\t\t}\n\t\t}\n\n\t\tprivate @Nullable Reference<K, V> findInChain(@Nullable Reference<K, V> ref, @Nullable Object key, int hash) {\n\t\t\tReference<K, V> currRef = ref;\n\t\t\twhile (currRef != null) {\n\t\t\t\tif (currRef.getHash() == hash) {\n\t\t\t\t\tEntry<K, V> entry = currRef.get();\n\t\t\t\t\tif (entry != null) {\n\t\t\t\t\t\tK entryKey = entry.getKey();\n\t\t\t\t\t\tif (ObjectUtils.nullSafeEquals(entryKey, key)) {\n\t\t\t\t\t\t\treturn currRef;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcurrRef = currRef.getNext();\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n\t\tprivate Reference<K, V>[] createReferenceArray(int size) {\n\t\t\treturn new Reference[size];\n\t\t}\n\n\t\tprivate int getIndex(int hash, @Nullable Reference<K, V>[] references) {\n\t\t\treturn (hash & (references.length - 1));\n\t\t}\n\n\t\t/**\n\t\t * Return the size of the current references array.\n\t\t */\n\t\tpublic int getSize() {\n\t\t\treturn this.references.length;\n\t\t}\n\n\t\t/**\n\t\t * Return the total number of references in this segment.\n\t\t */\n\t\tpublic int getCount() {\n\t\t\treturn this.count.get();\n\t\t}\n\t}\n\n\n\t/**\n\t * A reference to an {@link Entry} contained in the map. Implementations are usually\n\t * wrappers around specific Java reference implementations (for example, {@link SoftReference}).\n\t * @param <K> the key type\n\t * @param <V> the value type\n\t */\n\tprotected interface Reference<K, V> {\n\n\t\t/**\n\t\t * Return the referenced entry, or {@code null} if the entry is no longer available.\n\t\t */\n\t\t@Nullable Entry<K, V> get();\n\n\t\t/**\n\t\t * Return the hash for the reference.\n\t\t */\n\t\tint getHash();\n\n\t\t/**\n\t\t * Return the next reference in the chain, or {@code null} if none.\n\t\t */\n\t\t@Nullable Reference<K, V> getNext();\n\n\t\t/**\n\t\t * Release this entry and ensure that it will be returned from\n\t\t * {@code ReferenceManager#pollForPurge()}.\n\t\t */\n\t\tvoid release();\n\t}\n\n\n\t/**\n\t * A single map entry.\n\t * @param <K> the key type\n\t * @param <V> the value type\n\t */\n\tprotected static final class Entry<K, V> implements Map.Entry<K, V> {\n\n\t\tprivate final @Nullable K key;\n\n\t\tprivate volatile @Nullable V value;\n\n\t\tpublic Entry(@Nullable K key, @Nullable V value) {\n\t\t\tthis.key = key;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable K getKey() {\n\t\t\treturn this.key;\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable V getValue() {\n\t\t\treturn this.value;\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable V setValue(@Nullable V value) {\n\t\t\tV previous = this.value;\n\t\t\tthis.value = value;\n\t\t\treturn previous;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || (other instanceof Map.Entry<?, ?> that &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(getKey(), that.getKey()) &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(getValue(), that.getValue())));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn (ObjectUtils.nullSafeHashCode(this.key) ^ ObjectUtils.nullSafeHashCode(this.value));\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn (this.key + \"=\" + this.value);\n\t\t}\n\t}\n\n\n\t/**\n\t * A task that can be {@link Segment#doTask run} against a {@link Segment}.\n\t */\n\tprivate abstract class Task<T> {\n\n\t\tprivate final EnumSet<TaskOption> options;\n\n\t\tpublic Task(TaskOption... options) {\n\t\t\tthis.options = (options.length == 0 ? EnumSet.noneOf(TaskOption.class) : EnumSet.of(options[0], options));\n\t\t}\n\n\t\tpublic boolean hasOption(TaskOption option) {\n\t\t\treturn this.options.contains(option);\n\t\t}\n\n\t\t/**\n\t\t * Execute the task.\n\t\t * @param ref the found reference (or {@code null})\n\t\t * @param entry the found entry (or {@code null})\n\t\t * @param entries access to the underlying entries\n\t\t * @return the result of the task\n\t\t * @see #execute(Reference, Entry)\n\t\t */\n\t\tprotected @Nullable T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries<V> entries) {\n\t\t\treturn execute(ref, entry);\n\t\t}\n\n\t\t/**\n\t\t * Convenience method that can be used for tasks that do not need access to {@link Entries}.\n\t\t * @param ref the found reference (or {@code null})\n\t\t * @param entry the found entry (or {@code null})\n\t\t * @return the result of the task\n\t\t * @see #execute(Reference, Entry, Entries)\n\t\t */\n\t\tprotected @Nullable T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t/**\n\t * Various options supported by a {@code Task}.\n\t */\n\tprivate enum TaskOption {\n\n\t\tRESTRUCTURE_BEFORE, RESTRUCTURE_AFTER, SKIP_IF_EMPTY, RESIZE\n\t}\n\n\n\t/**\n\t * Allows a task access to {@link ConcurrentReferenceHashMap.Segment} entries.\n\t */\n\tprivate interface Entries<V> {\n\n\t\t/**\n\t\t * Add a new entry with the specified value.\n\t\t * @param value the value to add\n\t\t */\n\t\tvoid add(@Nullable V value);\n\t}\n\n\n\t/**\n\t * Internal entry-set implementation.\n\t */\n\tprivate class EntrySet extends AbstractSet<Map.Entry<K, V>> {\n\n\t\t@Override\n\t\tpublic Iterator<Map.Entry<K, V>> iterator() {\n\t\t\treturn new EntryIterator();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(@Nullable Object o) {\n\t\t\tif (o instanceof Map.Entry<?, ?> entry) {\n\t\t\t\tReference<K, V> ref = ConcurrentReferenceHashMap.this.getReference(entry.getKey(), Restructure.NEVER);\n\t\t\t\tEntry<K, V> otherEntry = (ref != null ? ref.get() : null);\n\t\t\t\tif (otherEntry != null) {\n\t\t\t\t\treturn ObjectUtils.nullSafeEquals(entry.getValue(), otherEntry.getValue());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\tif (o instanceof Map.Entry<?, ?> entry) {\n\t\t\t\treturn ConcurrentReferenceHashMap.this.remove(entry.getKey(), entry.getValue());\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn ConcurrentReferenceHashMap.this.size();\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tConcurrentReferenceHashMap.this.clear();\n\t\t}\n\t}\n\n\n\t/**\n\t * Internal entry iterator implementation.\n\t */\n\tprivate class EntryIterator implements Iterator<Map.Entry<K, V>> {\n\n\t\tprivate int segmentIndex;\n\n\t\tprivate int referenceIndex;\n\n\t\tprivate @Nullable Reference<K, V> @Nullable [] references;\n\n\t\tprivate @Nullable Reference<K, V> reference;\n\n\t\tprivate @Nullable Entry<K, V> next;\n\n\t\tprivate @Nullable Entry<K, V> last;\n\n\t\tpublic EntryIterator() {\n\t\t\tmoveToNextSegment();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\tgetNextIfNecessary();\n\t\t\treturn (this.next != null);\n\t\t}\n\n\t\t@Override\n\t\tpublic Entry<K, V> next() {\n\t\t\tgetNextIfNecessary();\n\t\t\tif (this.next == null) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t\tthis.last = this.next;\n\t\t\tthis.next = null;\n\t\t\treturn this.last;\n\t\t}\n\n\t\tprivate void getNextIfNecessary() {\n\t\t\twhile (this.next == null) {\n\t\t\t\tmoveToNextReference();\n\t\t\t\tif (this.reference == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.next = this.reference.get();\n\t\t\t}\n\t\t}\n\n\t\tprivate void moveToNextReference() {\n\t\t\tif (this.reference != null) {\n\t\t\t\tthis.reference = this.reference.getNext();\n\t\t\t}\n\t\t\twhile (this.reference == null && this.references != null) {\n\t\t\t\tif (this.referenceIndex >= this.references.length) {\n\t\t\t\t\tmoveToNextSegment();\n\t\t\t\t\tthis.referenceIndex = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.reference = this.references[this.referenceIndex];\n\t\t\t\t\tthis.referenceIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void moveToNextSegment() {\n\t\t\tthis.reference = null;\n\t\t\tthis.references = null;\n\t\t\tif (this.segmentIndex < ConcurrentReferenceHashMap.this.segments.length) {\n\t\t\t\tthis.references = ConcurrentReferenceHashMap.this.segments[this.segmentIndex].references;\n\t\t\t\tthis.segmentIndex++;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tAssert.state(this.last != null, \"No element to remove\");\n\t\t\tConcurrentReferenceHashMap.this.remove(this.last.getKey());\n\t\t\tthis.last = null;\n\t\t}\n\t}\n\n\n\t/**\n\t * The types of restructuring that can be performed.\n\t */\n\tprotected enum Restructure {\n\n\t\tWHEN_NECESSARY, NEVER\n\t}\n\n\n\t/**\n\t * Strategy class used to manage {@link Reference References}.\n\t * This class can be overridden if alternative reference types need to be supported.\n\t */\n\tprotected class ReferenceManager {\n\n\t\tprivate final ReferenceQueue<Entry<K, V>> queue = new ReferenceQueue<>();\n\n\t\t/**\n\t\t * Factory method used to create a new {@link Reference}.\n\t\t * @param entry the entry contained in the reference\n\t\t * @param hash the hash\n\t\t * @param next the next reference in the chain, or {@code null} if none\n\t\t * @return a new {@link Reference}\n\t\t */\n\t\tpublic Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {\n\t\t\tif (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {\n\t\t\t\treturn new WeakEntryReference<>(entry, hash, next, this.queue);\n\t\t\t}\n\t\t\treturn new SoftEntryReference<>(entry, hash, next, this.queue);\n\t\t}\n\n\t\t/**\n\t\t * Return any reference that has been garbage collected and can be purged from the\n\t\t * underlying structure or {@code null} if no references need purging. This\n\t\t * method must be thread safe and ideally should not block when returning\n\t\t * {@code null}. References should be returned once and only once.\n\t\t * @return a reference to purge or {@code null}\n\t\t */\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic @Nullable Reference<K, V> pollForPurge() {\n\t\t\treturn (Reference<K, V>) this.queue.poll();\n\t\t}\n\t}\n\n\n\t/**\n\t * Internal {@link Reference} implementation for {@link SoftReference SoftReferences}.\n\t */\n\tprivate static final class SoftEntryReference<K, V> extends SoftReference<Entry<K, V>> implements Reference<K, V> {\n\n\t\tprivate final int hash;\n\n\t\tprivate final @Nullable Reference<K, V> nextReference;\n\n\t\tpublic SoftEntryReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next,\n\t\t\t\tReferenceQueue<Entry<K, V>> queue) {\n\n\t\t\tsuper(entry, queue);\n\t\t\tthis.hash = hash;\n\t\t\tthis.nextReference = next;\n\t\t}\n\n\t\t@Override\n\t\tpublic int getHash() {\n\t\t\treturn this.hash;\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable Reference<K, V> getNext() {\n\t\t\treturn this.nextReference;\n\t\t}\n\n\t\t@Override\n\t\tpublic void release() {\n\t\t\tenqueue();\n\t\t}\n\t}\n\n\n\t/**\n\t * Internal {@link Reference} implementation for {@link WeakReference WeakReferences}.\n\t */\n\tprivate static final class WeakEntryReference<K, V> extends WeakReference<Entry<K, V>> implements Reference<K, V> {\n\n\t\tprivate final int hash;\n\n\t\tprivate final @Nullable Reference<K, V> nextReference;\n\n\t\tpublic WeakEntryReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next,\n\t\t\t\tReferenceQueue<Entry<K, V>> queue) {\n\n\t\t\tsuper(entry, queue);\n\t\t\tthis.hash = hash;\n\t\t\tthis.nextReference = next;\n\t\t}\n\n\t\t@Override\n\t\tpublic int getHash() {\n\t\t\treturn this.hash;\n\t\t}\n\n\t\t@Override\n\t\tpublic @Nullable Reference<K, V> getNext() {\n\t\t\treturn this.nextReference;\n\t\t}\n\n\t\t@Override\n\t\tpublic void release() {\n\t\t\tenqueue();\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.WeakEntryReference",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.WeakEntryReference#hash",
    "tailType": "field"
  },
  {
    "head": "org.springframework.util.WeakEntryReference#hash",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.util.WeakEntryReference",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.WeakEntryReference#nextReference",
    "tailType": "field"
  },
  {
    "head": "org.springframework.util.WeakEntryReference#nextReference",
    "headType": "field",
    "relation": "haveType",
    "tail": "Reference<K, V>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.util.WeakEntryReference#getHash()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic int getHash() {\r\n    return this.hash;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.WeakEntryReference",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.WeakEntryReference#getHash()",
    "tailType": "method"
  }
]