[
  {
    "head": "org.springframework.core.testfixture.aot.generator.visibility",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.testfixture.aot.generator.visibility.ProtectedType",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.testfixture.aot.generator.visibility.ProtectedType",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2022 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.testfixture.aot.generator.visibility;\n\nclass ProtectedType {\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.asm",
    "tailType": "package"
  },
  {
    "head": "org.springframework.asm",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.asm.MethodWriter",
    "tailType": "class"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.testfixture.aot.generator.visibility",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core.testfixture.aot.generator.visibility",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.testfixture.aot.generator.visibility.PublicFactoryBean",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.testfixture.aot.generator.visibility.PublicFactoryBean",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2022 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.testfixture.aot.generator.visibility;\n\nimport org.springframework.core.ResolvableType;\n\npublic class PublicFactoryBean<T> {\n\n\tPublicFactoryBean(Class<T> type) {\n\t}\n\n\tpublic static PublicFactoryBean<ProtectedType> protectedTypeFactoryBean() {\n\t\treturn new PublicFactoryBean<>(ProtectedType.class);\n\t}\n\n\tpublic static ResolvableType resolveToProtectedGenericParameter() {\n\t\treturn ResolvableType.forClassWithGenerics(PublicFactoryBean.class, ProtectedType.class);\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.testfixture.aot.generator.visibility.PublicFactoryBean#protectedTypeFactoryBean()",
    "headType": "method",
    "relation": "provide",
    "tail": "public static PublicFactoryBean<ProtectedType> protectedTypeFactoryBean() {\r\n    return new PublicFactoryBean<>(ProtectedType.class);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.testfixture.aot.generator.visibility.PublicFactoryBean",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.testfixture.aot.generator.visibility.PublicFactoryBean#protectedTypeFactoryBean()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.testfixture.aot.generator.visibility.PublicFactoryBean#resolveToProtectedGenericParameter()",
    "headType": "method",
    "relation": "provide",
    "tail": "public static ResolvableType resolveToProtectedGenericParameter() {\r\n    return ResolvableType.forClassWithGenerics(PublicFactoryBean.class, ProtectedType.class);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.testfixture.aot.generator.visibility.PublicFactoryBean",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.testfixture.aot.generator.visibility.PublicFactoryBean#resolveToProtectedGenericParameter()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.MethodWriter",
    "headType": "class",
    "relation": "provide",
    "tail": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage org.springframework.asm;\n\n/**\n * A {@link MethodVisitor} that generates a corresponding 'method_info' structure, as defined in the\n * Java Virtual Machine Specification (JVMS).\n *\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.6\">JVMS\n *     4.6</a>\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n */\nfinal class MethodWriter extends MethodVisitor {\n\n  /** Indicates that nothing must be computed. */\n  static final int COMPUTE_NOTHING = 0;\n\n  /**\n   * Indicates that the maximum stack size and the maximum number of local variables must be\n   * computed, from scratch.\n   */\n  static final int COMPUTE_MAX_STACK_AND_LOCAL = 1;\n\n  /**\n   * Indicates that the maximum stack size and the maximum number of local variables must be\n   * computed, from the existing stack map frames. This can be done more efficiently than with the\n   * control flow graph algorithm used for {@link #COMPUTE_MAX_STACK_AND_LOCAL}, by using a linear\n   * scan of the bytecode instructions.\n   */\n  static final int COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES = 2;\n\n  /**\n   * Indicates that the stack map frames of type F_INSERT must be computed. The other frames are not\n   * computed. They should all be of type F_NEW and should be sufficient to compute the content of\n   * the F_INSERT frames, together with the bytecode instructions between a F_NEW and a F_INSERT\n   * frame - and without any knowledge of the type hierarchy (by definition of F_INSERT).\n   */\n  static final int COMPUTE_INSERTED_FRAMES = 3;\n\n  /**\n   * Indicates that all the stack map frames must be computed. In this case the maximum stack size\n   * and the maximum number of local variables is also computed.\n   */\n  static final int COMPUTE_ALL_FRAMES = 4;\n\n  /** Indicates that {@link #STACK_SIZE_DELTA} is not applicable (not constant or never used). */\n  private static final int NA = 0;\n\n  /**\n   * The stack size variation corresponding to each JVM opcode. The stack size variation for opcode\n   * 'o' is given by the array element at index 'o'.\n   *\n   * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-6.html\">JVMS 6</a>\n   */\n  private static final int[] STACK_SIZE_DELTA = {\n    0, // nop = 0 (0x0)\n    1, // aconst_null = 1 (0x1)\n    1, // iconst_m1 = 2 (0x2)\n    1, // iconst_0 = 3 (0x3)\n    1, // iconst_1 = 4 (0x4)\n    1, // iconst_2 = 5 (0x5)\n    1, // iconst_3 = 6 (0x6)\n    1, // iconst_4 = 7 (0x7)\n    1, // iconst_5 = 8 (0x8)\n    2, // lconst_0 = 9 (0x9)\n    2, // lconst_1 = 10 (0xa)\n    1, // fconst_0 = 11 (0xb)\n    1, // fconst_1 = 12 (0xc)\n    1, // fconst_2 = 13 (0xd)\n    2, // dconst_0 = 14 (0xe)\n    2, // dconst_1 = 15 (0xf)\n    1, // bipush = 16 (0x10)\n    1, // sipush = 17 (0x11)\n    1, // ldc = 18 (0x12)\n    NA, // ldc_w = 19 (0x13)\n    NA, // ldc2_w = 20 (0x14)\n    1, // iload = 21 (0x15)\n    2, // lload = 22 (0x16)\n    1, // fload = 23 (0x17)\n    2, // dload = 24 (0x18)\n    1, // aload = 25 (0x19)\n    NA, // iload_0 = 26 (0x1a)\n    NA, // iload_1 = 27 (0x1b)\n    NA, // iload_2 = 28 (0x1c)\n    NA, // iload_3 = 29 (0x1d)\n    NA, // lload_0 = 30 (0x1e)\n    NA, // lload_1 = 31 (0x1f)\n    NA, // lload_2 = 32 (0x20)\n    NA, // lload_3 = 33 (0x21)\n    NA, // fload_0 = 34 (0x22)\n    NA, // fload_1 = 35 (0x23)\n    NA, // fload_2 = 36 (0x24)\n    NA, // fload_3 = 37 (0x25)\n    NA, // dload_0 = 38 (0x26)\n    NA, // dload_1 = 39 (0x27)\n    NA, // dload_2 = 40 (0x28)\n    NA, // dload_3 = 41 (0x29)\n    NA, // aload_0 = 42 (0x2a)\n    NA, // aload_1 = 43 (0x2b)\n    NA, // aload_2 = 44 (0x2c)\n    NA, // aload_3 = 45 (0x2d)\n    -1, // iaload = 46 (0x2e)\n    0, // laload = 47 (0x2f)\n    -1, // faload = 48 (0x30)\n    0, // daload = 49 (0x31)\n    -1, // aaload = 50 (0x32)\n    -1, // baload = 51 (0x33)\n    -1, // caload = 52 (0x34)\n    -1, // saload = 53 (0x35)\n    -1, // istore = 54 (0x36)\n    -2, // lstore = 55 (0x37)\n    -1, // fstore = 56 (0x38)\n    -2, // dstore = 57 (0x39)\n    -1, // astore = 58 (0x3a)\n    NA, // istore_0 = 59 (0x3b)\n    NA, // istore_1 = 60 (0x3c)\n    NA, // istore_2 = 61 (0x3d)\n    NA, // istore_3 = 62 (0x3e)\n    NA, // lstore_0 = 63 (0x3f)\n    NA, // lstore_1 = 64 (0x40)\n    NA, // lstore_2 = 65 (0x41)\n    NA, // lstore_3 = 66 (0x42)\n    NA, // fstore_0 = 67 (0x43)\n    NA, // fstore_1 = 68 (0x44)\n    NA, // fstore_2 = 69 (0x45)\n    NA, // fstore_3 = 70 (0x46)\n    NA, // dstore_0 = 71 (0x47)\n    NA, // dstore_1 = 72 (0x48)\n    NA, // dstore_2 = 73 (0x49)\n    NA, // dstore_3 = 74 (0x4a)\n    NA, // astore_0 = 75 (0x4b)\n    NA, // astore_1 = 76 (0x4c)\n    NA, // astore_2 = 77 (0x4d)\n    NA, // astore_3 = 78 (0x4e)\n    -3, // iastore = 79 (0x4f)\n    -4, // lastore = 80 (0x50)\n    -3, // fastore = 81 (0x51)\n    -4, // dastore = 82 (0x52)\n    -3, // aastore = 83 (0x53)\n    -3, // bastore = 84 (0x54)\n    -3, // castore = 85 (0x55)\n    -3, // sastore = 86 (0x56)\n    -1, // pop = 87 (0x57)\n    -2, // pop2 = 88 (0x58)\n    1, // dup = 89 (0x59)\n    1, // dup_x1 = 90 (0x5a)\n    1, // dup_x2 = 91 (0x5b)\n    2, // dup2 = 92 (0x5c)\n    2, // dup2_x1 = 93 (0x5d)\n    2, // dup2_x2 = 94 (0x5e)\n    0, // swap = 95 (0x5f)\n    -1, // iadd = 96 (0x60)\n    -2, // ladd = 97 (0x61)\n    -1, // fadd = 98 (0x62)\n    -2, // dadd = 99 (0x63)\n    -1, // isub = 100 (0x64)\n    -2, // lsub = 101 (0x65)\n    -1, // fsub = 102 (0x66)\n    -2, // dsub = 103 (0x67)\n    -1, // imul = 104 (0x68)\n    -2, // lmul = 105 (0x69)\n    -1, // fmul = 106 (0x6a)\n    -2, // dmul = 107 (0x6b)\n    -1, // idiv = 108 (0x6c)\n    -2, // ldiv = 109 (0x6d)\n    -1, // fdiv = 110 (0x6e)\n    -2, // ddiv = 111 (0x6f)\n    -1, // irem = 112 (0x70)\n    -2, // lrem = 113 (0x71)\n    -1, // frem = 114 (0x72)\n    -2, // drem = 115 (0x73)\n    0, // ineg = 116 (0x74)\n    0, // lneg = 117 (0x75)\n    0, // fneg = 118 (0x76)\n    0, // dneg = 119 (0x77)\n    -1, // ishl = 120 (0x78)\n    -1, // lshl = 121 (0x79)\n    -1, // ishr = 122 (0x7a)\n    -1, // lshr = 123 (0x7b)\n    -1, // iushr = 124 (0x7c)\n    -1, // lushr = 125 (0x7d)\n    -1, // iand = 126 (0x7e)\n    -2, // land = 127 (0x7f)\n    -1, // ior = 128 (0x80)\n    -2, // lor = 129 (0x81)\n    -1, // ixor = 130 (0x82)\n    -2, // lxor = 131 (0x83)\n    0, // iinc = 132 (0x84)\n    1, // i2l = 133 (0x85)\n    0, // i2f = 134 (0x86)\n    1, // i2d = 135 (0x87)\n    -1, // l2i = 136 (0x88)\n    -1, // l2f = 137 (0x89)\n    0, // l2d = 138 (0x8a)\n    0, // f2i = 139 (0x8b)\n    1, // f2l = 140 (0x8c)\n    1, // f2d = 141 (0x8d)\n    -1, // d2i = 142 (0x8e)\n    0, // d2l = 143 (0x8f)\n    -1, // d2f = 144 (0x90)\n    0, // i2b = 145 (0x91)\n    0, // i2c = 146 (0x92)\n    0, // i2s = 147 (0x93)\n    -3, // lcmp = 148 (0x94)\n    -1, // fcmpl = 149 (0x95)\n    -1, // fcmpg = 150 (0x96)\n    -3, // dcmpl = 151 (0x97)\n    -3, // dcmpg = 152 (0x98)\n    -1, // ifeq = 153 (0x99)\n    -1, // ifne = 154 (0x9a)\n    -1, // iflt = 155 (0x9b)\n    -1, // ifge = 156 (0x9c)\n    -1, // ifgt = 157 (0x9d)\n    -1, // ifle = 158 (0x9e)\n    -2, // if_icmpeq = 159 (0x9f)\n    -2, // if_icmpne = 160 (0xa0)\n    -2, // if_icmplt = 161 (0xa1)\n    -2, // if_icmpge = 162 (0xa2)\n    -2, // if_icmpgt = 163 (0xa3)\n    -2, // if_icmple = 164 (0xa4)\n    -2, // if_acmpeq = 165 (0xa5)\n    -2, // if_acmpne = 166 (0xa6)\n    0, // goto = 167 (0xa7)\n    1, // jsr = 168 (0xa8)\n    0, // ret = 169 (0xa9)\n    -1, // tableswitch = 170 (0xaa)\n    -1, // lookupswitch = 171 (0xab)\n    -1, // ireturn = 172 (0xac)\n    -2, // lreturn = 173 (0xad)\n    -1, // freturn = 174 (0xae)\n    -2, // dreturn = 175 (0xaf)\n    -1, // areturn = 176 (0xb0)\n    0, // return = 177 (0xb1)\n    NA, // getstatic = 178 (0xb2)\n    NA, // putstatic = 179 (0xb3)\n    NA, // getfield = 180 (0xb4)\n    NA, // putfield = 181 (0xb5)\n    NA, // invokevirtual = 182 (0xb6)\n    NA, // invokespecial = 183 (0xb7)\n    NA, // invokestatic = 184 (0xb8)\n    NA, // invokeinterface = 185 (0xb9)\n    NA, // invokedynamic = 186 (0xba)\n    1, // new = 187 (0xbb)\n    0, // newarray = 188 (0xbc)\n    0, // anewarray = 189 (0xbd)\n    0, // arraylength = 190 (0xbe)\n    NA, // athrow = 191 (0xbf)\n    0, // checkcast = 192 (0xc0)\n    0, // instanceof = 193 (0xc1)\n    -1, // monitorenter = 194 (0xc2)\n    -1, // monitorexit = 195 (0xc3)\n    NA, // wide = 196 (0xc4)\n    NA, // multianewarray = 197 (0xc5)\n    -1, // ifnull = 198 (0xc6)\n    -1, // ifnonnull = 199 (0xc7)\n    NA, // goto_w = 200 (0xc8)\n    NA // jsr_w = 201 (0xc9)\n  };\n\n  /** Where the constants used in this MethodWriter must be stored. */\n  private final SymbolTable symbolTable;\n\n  // Note: fields are ordered as in the method_info structure, and those related to attributes are\n  // ordered as in Section 4.7 of the JVMS.\n\n  /**\n   * The access_flags field of the method_info JVMS structure. This field can contain ASM specific\n   * access flags, such as {@link Opcodes#ACC_DEPRECATED}, which are removed when generating the\n   * ClassFile structure.\n   */\n  private final int accessFlags;\n\n  /** The name_index field of the method_info JVMS structure. */\n  private final int nameIndex;\n\n  /** The name of this method. */\n  private final String name;\n\n  /** The descriptor_index field of the method_info JVMS structure. */\n  private final int descriptorIndex;\n\n  /** The descriptor of this method. */\n  private final String descriptor;\n\n  // Code attribute fields and sub attributes:\n\n  /** The max_stack field of the Code attribute. */\n  private int maxStack;\n\n  /** The max_locals field of the Code attribute. */\n  private int maxLocals;\n\n  /** The 'code' field of the Code attribute. */\n  private final ByteVector code = new ByteVector();\n\n  /**\n   * The first element in the exception handler list (used to generate the exception_table of the\n   * Code attribute). The next ones can be accessed with the {@link Handler#nextHandler} field. May\n   * be {@literal null}.\n   */\n  private Handler firstHandler;\n\n  /**\n   * The last element in the exception handler list (used to generate the exception_table of the\n   * Code attribute). The next ones can be accessed with the {@link Handler#nextHandler} field. May\n   * be {@literal null}.\n   */\n  private Handler lastHandler;\n\n  /** The line_number_table_length field of the LineNumberTable code attribute. */\n  private int lineNumberTableLength;\n\n  /** The line_number_table array of the LineNumberTable code attribute, or {@literal null}. */\n  private ByteVector lineNumberTable;\n\n  /** The local_variable_table_length field of the LocalVariableTable code attribute. */\n  private int localVariableTableLength;\n\n  /**\n   * The local_variable_table array of the LocalVariableTable code attribute, or {@literal null}.\n   */\n  private ByteVector localVariableTable;\n\n  /** The local_variable_type_table_length field of the LocalVariableTypeTable code attribute. */\n  private int localVariableTypeTableLength;\n\n  /**\n   * The local_variable_type_table array of the LocalVariableTypeTable code attribute, or {@literal\n   * null}.\n   */\n  private ByteVector localVariableTypeTable;\n\n  /** The number_of_entries field of the StackMapTable code attribute. */\n  private int stackMapTableNumberOfEntries;\n\n  /** The 'entries' array of the StackMapTable code attribute. */\n  private ByteVector stackMapTableEntries;\n\n  /**\n   * The last runtime visible type annotation of the Code attribute. The previous ones can be\n   * accessed with the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\n   */\n  private AnnotationWriter lastCodeRuntimeVisibleTypeAnnotation;\n\n  /**\n   * The last runtime invisible type annotation of the Code attribute. The previous ones can be\n   * accessed with the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\n   */\n  private AnnotationWriter lastCodeRuntimeInvisibleTypeAnnotation;\n\n  /**\n   * The first non standard attribute of the Code attribute. The next ones can be accessed with the\n   * {@link Attribute#nextAttribute} field. May be {@literal null}.\n   *\n   * <p><b>WARNING</b>: this list stores the attributes in the <i>reverse</i> order of their visit.\n   * firstAttribute is actually the last attribute visited in {@link #visitAttribute}. The {@link\n   * #putMethodInfo} method writes the attributes in the order defined by this list, i.e. in the\n   * reverse order specified by the user.\n   */\n  private Attribute firstCodeAttribute;\n\n  // Other method_info attributes:\n\n  /** The number_of_exceptions field of the Exceptions attribute. */\n  private final int numberOfExceptions;\n\n  /** The exception_index_table array of the Exceptions attribute, or {@literal null}. */\n  private final int[] exceptionIndexTable;\n\n  /** The signature_index field of the Signature attribute. */\n  private final int signatureIndex;\n\n  /**\n   * The last runtime visible annotation of this method. The previous ones can be accessed with the\n   * {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\n   */\n  private AnnotationWriter lastRuntimeVisibleAnnotation;\n\n  /**\n   * The last runtime invisible annotation of this method. The previous ones can be accessed with\n   * the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\n   */\n  private AnnotationWriter lastRuntimeInvisibleAnnotation;\n\n  /** The number of method parameters that can have runtime visible annotations, or 0. */\n  private int visibleAnnotableParameterCount;\n\n  /**\n   * The runtime visible parameter annotations of this method. Each array element contains the last\n   * annotation of a parameter (which can be {@literal null} - the previous ones can be accessed\n   * with the {@link AnnotationWriter#previousAnnotation} field). May be {@literal null}.\n   */\n  private AnnotationWriter[] lastRuntimeVisibleParameterAnnotations;\n\n  /** The number of method parameters that can have runtime visible annotations, or 0. */\n  private int invisibleAnnotableParameterCount;\n\n  /**\n   * The runtime invisible parameter annotations of this method. Each array element contains the\n   * last annotation of a parameter (which can be {@literal null} - the previous ones can be\n   * accessed with the {@link AnnotationWriter#previousAnnotation} field). May be {@literal null}.\n   */\n  private AnnotationWriter[] lastRuntimeInvisibleParameterAnnotations;\n\n  /**\n   * The last runtime visible type annotation of this method. The previous ones can be accessed with\n   * the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\n   */\n  private AnnotationWriter lastRuntimeVisibleTypeAnnotation;\n\n  /**\n   * The last runtime invisible type annotation of this method. The previous ones can be accessed\n   * with the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\n   */\n  private AnnotationWriter lastRuntimeInvisibleTypeAnnotation;\n\n  /** The default_value field of the AnnotationDefault attribute, or {@literal null}. */\n  private ByteVector defaultValue;\n\n  /** The parameters_count field of the MethodParameters attribute. */\n  private int parametersCount;\n\n  /** The 'parameters' array of the MethodParameters attribute, or {@literal null}. */\n  private ByteVector parameters;\n\n  /**\n   * The first non standard attribute of this method. The next ones can be accessed with the {@link\n   * Attribute#nextAttribute} field. May be {@literal null}.\n   *\n   * <p><b>WARNING</b>: this list stores the attributes in the <i>reverse</i> order of their visit.\n   * firstAttribute is actually the last attribute visited in {@link #visitAttribute}. The {@link\n   * #putMethodInfo} method writes the attributes in the order defined by this list, i.e. in the\n   * reverse order specified by the user.\n   */\n  private Attribute firstAttribute;\n\n  // -----------------------------------------------------------------------------------------------\n  // Fields used to compute the maximum stack size and number of locals, and the stack map frames\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Indicates what must be computed. Must be one of {@link #COMPUTE_ALL_FRAMES}, {@link\n   * #COMPUTE_INSERTED_FRAMES}, {@link COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES}, {@link\n   * #COMPUTE_MAX_STACK_AND_LOCAL} or {@link #COMPUTE_NOTHING}.\n   */\n  private final int compute;\n\n  /**\n   * The first basic block of the method. The next ones (in bytecode offset order) can be accessed\n   * with the {@link Label#nextBasicBlock} field.\n   */\n  private Label firstBasicBlock;\n\n  /**\n   * The last basic block of the method (in bytecode offset order). This field is updated each time\n   * a basic block is encountered, and is used to append it at the end of the basic block list.\n   */\n  private Label lastBasicBlock;\n\n  /**\n   * The current basic block, i.e. the basic block of the last visited instruction. When {@link\n   * #compute} is equal to {@link #COMPUTE_MAX_STACK_AND_LOCAL} or {@link #COMPUTE_ALL_FRAMES}, this\n   * field is {@literal null} for unreachable code. When {@link #compute} is equal to {@link\n   * #COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES} or {@link #COMPUTE_INSERTED_FRAMES}, this field stays\n   * unchanged throughout the whole method (i.e. the whole code is seen as a single basic block;\n   * indeed, the existing frames are sufficient by hypothesis to compute any intermediate frame -\n   * and the maximum stack size as well - without using any control flow graph).\n   */\n  private Label currentBasicBlock;\n\n  /**\n   * The relative stack size after the last visited instruction. This size is relative to the\n   * beginning of {@link #currentBasicBlock}, i.e. the true stack size after the last visited\n   * instruction is equal to the {@link Label#inputStackSize} of the current basic block plus {@link\n   * #relativeStackSize}. When {@link #compute} is equal to {@link\n   * #COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES}, {@link #currentBasicBlock} is always the start of\n   * the method, so this relative size is also equal to the absolute stack size after the last\n   * visited instruction.\n   */\n  private int relativeStackSize;\n\n  /**\n   * The maximum relative stack size after the last visited instruction. This size is relative to\n   * the beginning of {@link #currentBasicBlock}, i.e. the true maximum stack size after the last\n   * visited instruction is equal to the {@link Label#inputStackSize} of the current basic block\n   * plus {@link #maxRelativeStackSize}.When {@link #compute} is equal to {@link\n   * #COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES}, {@link #currentBasicBlock} is always the start of\n   * the method, so this relative size is also equal to the absolute maximum stack size after the\n   * last visited instruction.\n   */\n  private int maxRelativeStackSize;\n\n  /** The number of local variables in the last visited stack map frame. */\n  private int currentLocals;\n\n  /** The bytecode offset of the last frame that was written in {@link #stackMapTableEntries}. */\n  private int previousFrameOffset;\n\n  /**\n   * The last frame that was written in {@link #stackMapTableEntries}. This field has the same\n   * format as {@link #currentFrame}.\n   */\n  private int[] previousFrame;\n\n  /**\n   * The current stack map frame. The first element contains the bytecode offset of the instruction\n   * to which the frame corresponds, the second element is the number of locals and the third one is\n   * the number of stack elements. The local variables start at index 3 and are followed by the\n   * operand stack elements. In summary frame[0] = offset, frame[1] = numLocal, frame[2] = numStack.\n   * Local variables and operand stack entries contain abstract types, as defined in {@link Frame},\n   * but restricted to {@link Frame#CONSTANT_KIND}, {@link Frame#REFERENCE_KIND}, {@link\n   * Frame#UNINITIALIZED_KIND} or {@link Frame#FORWARD_UNINITIALIZED_KIND} abstract types. Long and\n   * double types use only one array entry.\n   */\n  private int[] currentFrame;\n\n  /** Whether this method contains subroutines. */\n  private boolean hasSubroutines;\n\n  // -----------------------------------------------------------------------------------------------\n  // Other miscellaneous status fields\n  // -----------------------------------------------------------------------------------------------\n\n  /** Whether the bytecode of this method contains ASM specific instructions. */\n  private boolean hasAsmInstructions;\n\n  /**\n   * The start offset of the last visited instruction. Used to set the offset field of type\n   * annotations of type 'offset_target' (see <a\n   * href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20.1\">JVMS\n   * 4.7.20.1</a>).\n   */\n  private int lastBytecodeOffset;\n\n  /**\n   * The offset in bytes in {@link SymbolTable#getSource} from which the method_info for this method\n   * (excluding its first 6 bytes) must be copied, or 0.\n   */\n  private int sourceOffset;\n\n  /**\n   * The length in bytes in {@link SymbolTable#getSource} which must be copied to get the\n   * method_info for this method (excluding its first 6 bytes for access_flags, name_index and\n   * descriptor_index).\n   */\n  private int sourceLength;\n\n  // -----------------------------------------------------------------------------------------------\n  // Constructor and accessors\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Constructs a new {@link MethodWriter}.\n   *\n   * @param symbolTable where the constants used in this AnnotationWriter must be stored.\n   * @param access the method's access flags (see {@link Opcodes}).\n   * @param name the method's name.\n   * @param descriptor the method's descriptor (see {@link Type}).\n   * @param signature the method's signature. May be {@literal null}.\n   * @param exceptions the internal names of the method's exceptions. May be {@literal null}.\n   * @param compute indicates what must be computed (see #compute).\n   */\n  MethodWriter(\n      final SymbolTable symbolTable,\n      final int access,\n      final String name,\n      final String descriptor,\n      final String signature,\n      final String[] exceptions,\n      final int compute) {\n    super(/* latest api = */ Opcodes.ASM9);\n    this.symbolTable = symbolTable;\n    this.accessFlags = \"<init>\".equals(name) ? access | Constants.ACC_CONSTRUCTOR : access;\n    this.nameIndex = symbolTable.addConstantUtf8(name);\n    this.name = name;\n    this.descriptorIndex = symbolTable.addConstantUtf8(descriptor);\n    this.descriptor = descriptor;\n    this.signatureIndex = signature == null ? 0 : symbolTable.addConstantUtf8(signature);\n    if (exceptions != null && exceptions.length > 0) {\n      numberOfExceptions = exceptions.length;\n      this.exceptionIndexTable = new int[numberOfExceptions];\n      for (int i = 0; i < numberOfExceptions; ++i) {\n        this.exceptionIndexTable[i] = symbolTable.addConstantClass(exceptions[i]).index;\n      }\n    } else {\n      numberOfExceptions = 0;\n      this.exceptionIndexTable = null;\n    }\n    this.compute = compute;\n    if (compute != COMPUTE_NOTHING) {\n      // Update maxLocals and currentLocals.\n      int argumentsSize = Type.getArgumentsAndReturnSizes(descriptor) >> 2;\n      if ((access & Opcodes.ACC_STATIC) != 0) {\n        --argumentsSize;\n      }\n      maxLocals = argumentsSize;\n      currentLocals = argumentsSize;\n      // Create and visit the label for the first basic block.\n      firstBasicBlock = new Label();\n      visitLabel(firstBasicBlock);\n    }\n  }\n\n  boolean hasFrames() {\n    return stackMapTableNumberOfEntries > 0;\n  }\n\n  boolean hasAsmInstructions() {\n    return hasAsmInstructions;\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Implementation of the MethodVisitor abstract class\n  // -----------------------------------------------------------------------------------------------\n\n  @Override\n  public void visitParameter(final String name, final int access) {\n    if (parameters == null) {\n      parameters = new ByteVector();\n    }\n    ++parametersCount;\n    parameters.putShort((name == null) ? 0 : symbolTable.addConstantUtf8(name)).putShort(access);\n  }\n\n  @Override\n  public AnnotationVisitor visitAnnotationDefault() {\n    defaultValue = new ByteVector();\n    return new AnnotationWriter(symbolTable, /* useNamedValues= */ false, defaultValue, null);\n  }\n\n  @Override\n  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\n    if (visible) {\n      return lastRuntimeVisibleAnnotation =\n          AnnotationWriter.create(symbolTable, descriptor, lastRuntimeVisibleAnnotation);\n    } else {\n      return lastRuntimeInvisibleAnnotation =\n          AnnotationWriter.create(symbolTable, descriptor, lastRuntimeInvisibleAnnotation);\n    }\n  }\n\n  @Override\n  public AnnotationVisitor visitTypeAnnotation(\n      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\n    if (visible) {\n      return lastRuntimeVisibleTypeAnnotation =\n          AnnotationWriter.create(\n              symbolTable, typeRef, typePath, descriptor, lastRuntimeVisibleTypeAnnotation);\n    } else {\n      return lastRuntimeInvisibleTypeAnnotation =\n          AnnotationWriter.create(\n              symbolTable, typeRef, typePath, descriptor, lastRuntimeInvisibleTypeAnnotation);\n    }\n  }\n\n  @Override\n  public void visitAnnotableParameterCount(final int parameterCount, final boolean visible) {\n    if (visible) {\n      visibleAnnotableParameterCount = parameterCount;\n    } else {\n      invisibleAnnotableParameterCount = parameterCount;\n    }\n  }\n\n  @Override\n  public AnnotationVisitor visitParameterAnnotation(\n      final int parameter, final String annotationDescriptor, final boolean visible) {\n    if (visible) {\n      if (lastRuntimeVisibleParameterAnnotations == null) {\n        lastRuntimeVisibleParameterAnnotations =\n            new AnnotationWriter[Type.getArgumentCount(descriptor)];\n      }\n      return lastRuntimeVisibleParameterAnnotations[parameter] =\n          AnnotationWriter.create(\n              symbolTable, annotationDescriptor, lastRuntimeVisibleParameterAnnotations[parameter]);\n    } else {\n      if (lastRuntimeInvisibleParameterAnnotations == null) {\n        lastRuntimeInvisibleParameterAnnotations =\n            new AnnotationWriter[Type.getArgumentCount(descriptor)];\n      }\n      return lastRuntimeInvisibleParameterAnnotations[parameter] =\n          AnnotationWriter.create(\n              symbolTable,\n              annotationDescriptor,\n              lastRuntimeInvisibleParameterAnnotations[parameter]);\n    }\n  }\n\n  @Override\n  public void visitAttribute(final Attribute attribute) {\n    // Store the attributes in the <i>reverse</i> order of their visit by this method.\n    if (attribute.isCodeAttribute()) {\n      attribute.nextAttribute = firstCodeAttribute;\n      firstCodeAttribute = attribute;\n    } else {\n      attribute.nextAttribute = firstAttribute;\n      firstAttribute = attribute;\n    }\n  }\n\n  @Override\n  public void visitCode() {\n    // Nothing to do.\n  }\n\n  @Override\n  public void visitFrame(\n      final int type,\n      final int numLocal,\n      final Object[] local,\n      final int numStack,\n      final Object[] stack) {\n    if (compute == COMPUTE_ALL_FRAMES) {\n      return;\n    }\n\n    if (compute == COMPUTE_INSERTED_FRAMES) {\n      if (currentBasicBlock.frame == null) {\n        // This should happen only once, for the implicit first frame (which is explicitly visited\n        // in ClassReader if the EXPAND_ASM_INSNS option is used - and COMPUTE_INSERTED_FRAMES\n        // can't be set if EXPAND_ASM_INSNS is not used).\n        currentBasicBlock.frame = new CurrentFrame(currentBasicBlock);\n        currentBasicBlock.frame.setInputFrameFromDescriptor(\n            symbolTable, accessFlags, descriptor, numLocal);\n        currentBasicBlock.frame.accept(this);\n      } else {\n        if (type == Opcodes.F_NEW) {\n          currentBasicBlock.frame.setInputFrameFromApiFormat(\n              symbolTable, numLocal, local, numStack, stack);\n        }\n        // If type is not F_NEW then it is F_INSERT by hypothesis, and currentBlock.frame contains\n        // the stack map frame at the current instruction, computed from the last F_NEW frame and\n        // the bytecode instructions in between (via calls to CurrentFrame#execute).\n        currentBasicBlock.frame.accept(this);\n      }\n    } else if (type == Opcodes.F_NEW) {\n      if (previousFrame == null) {\n        int argumentsSize = Type.getArgumentsAndReturnSizes(descriptor) >> 2;\n        Frame implicitFirstFrame = new Frame(new Label());\n        implicitFirstFrame.setInputFrameFromDescriptor(\n            symbolTable, accessFlags, descriptor, argumentsSize);\n        implicitFirstFrame.accept(this);\n      }\n      currentLocals = numLocal;\n      int frameIndex = visitFrameStart(code.length, numLocal, numStack);\n      for (int i = 0; i < numLocal; ++i) {\n        currentFrame[frameIndex++] = Frame.getAbstractTypeFromApiFormat(symbolTable, local[i]);\n      }\n      for (int i = 0; i < numStack; ++i) {\n        currentFrame[frameIndex++] = Frame.getAbstractTypeFromApiFormat(symbolTable, stack[i]);\n      }\n      visitFrameEnd();\n    } else {\n      if (symbolTable.getMajorVersion() < Opcodes.V1_6) {\n        throw new IllegalArgumentException(\"Class versions V1_5 or less must use F_NEW frames.\");\n      }\n      int offsetDelta;\n      if (stackMapTableEntries == null) {\n        stackMapTableEntries = new ByteVector();\n        offsetDelta = code.length;\n      } else {\n        offsetDelta = code.length - previousFrameOffset - 1;\n        if (offsetDelta < 0) {\n          if (type == Opcodes.F_SAME) {\n            return;\n          } else {\n            throw new IllegalStateException();\n          }\n        }\n      }\n\n      switch (type) {\n        case Opcodes.F_FULL:\n          currentLocals = numLocal;\n          stackMapTableEntries.putByte(Frame.FULL_FRAME).putShort(offsetDelta).putShort(numLocal);\n          for (int i = 0; i < numLocal; ++i) {\n            putFrameType(local[i]);\n          }\n          stackMapTableEntries.putShort(numStack);\n          for (int i = 0; i < numStack; ++i) {\n            putFrameType(stack[i]);\n          }\n          break;\n        case Opcodes.F_APPEND:\n          currentLocals += numLocal;\n          stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED + numLocal).putShort(offsetDelta);\n          for (int i = 0; i < numLocal; ++i) {\n            putFrameType(local[i]);\n          }\n          break;\n        case Opcodes.F_CHOP:\n          currentLocals -= numLocal;\n          stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED - numLocal).putShort(offsetDelta);\n          break;\n        case Opcodes.F_SAME:\n          if (offsetDelta < 64) {\n            stackMapTableEntries.putByte(offsetDelta);\n          } else {\n            stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED).putShort(offsetDelta);\n          }\n          break;\n        case Opcodes.F_SAME1:\n          if (offsetDelta < 64) {\n            stackMapTableEntries.putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME + offsetDelta);\n          } else {\n            stackMapTableEntries\n                .putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED)\n                .putShort(offsetDelta);\n          }\n          putFrameType(stack[0]);\n          break;\n        default:\n          throw new IllegalArgumentException();\n      }\n\n      previousFrameOffset = code.length;\n      ++stackMapTableNumberOfEntries;\n    }\n\n    if (compute == COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES) {\n      relativeStackSize = numStack;\n      for (int i = 0; i < numStack; ++i) {\n        if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) {\n          relativeStackSize++;\n        }\n      }\n      if (relativeStackSize > maxRelativeStackSize) {\n        maxRelativeStackSize = relativeStackSize;\n      }\n    }\n\n    maxStack = Math.max(maxStack, numStack);\n    maxLocals = Math.max(maxLocals, currentLocals);\n  }\n\n  @Override\n  public void visitInsn(final int opcode) {\n    lastBytecodeOffset = code.length;\n    // Add the instruction to the bytecode of the method.\n    code.putByte(opcode);\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\n    if (currentBasicBlock != null) {\n      if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\n        currentBasicBlock.frame.execute(opcode, 0, null, null);\n      } else {\n        int size = relativeStackSize + STACK_SIZE_DELTA[opcode];\n        if (size > maxRelativeStackSize) {\n          maxRelativeStackSize = size;\n        }\n        relativeStackSize = size;\n      }\n      if ((opcode >= Opcodes.IRETURN && opcode <= Opcodes.RETURN) || opcode == Opcodes.ATHROW) {\n        endCurrentBasicBlockWithNoSuccessor();\n      }\n    }\n  }\n\n  @Override\n  public void visitIntInsn(final int opcode, final int operand) {\n    lastBytecodeOffset = code.length;\n    // Add the instruction to the bytecode of the method.\n    if (opcode == Opcodes.SIPUSH) {\n      code.put12(opcode, operand);\n    } else { // BIPUSH or NEWARRAY\n      code.put11(opcode, operand);\n    }\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\n    if (currentBasicBlock != null) {\n      if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\n        currentBasicBlock.frame.execute(opcode, operand, null, null);\n      } else if (opcode != Opcodes.NEWARRAY) {\n        // The stack size delta is 1 for BIPUSH or SIPUSH, and 0 for NEWARRAY.\n        int size = relativeStackSize + 1;\n        if (size > maxRelativeStackSize) {\n          maxRelativeStackSize = size;\n        }\n        relativeStackSize = size;\n      }\n    }\n  }\n\n  @Override\n  public void visitVarInsn(final int opcode, final int varIndex) {\n    lastBytecodeOffset = code.length;\n    // Add the instruction to the bytecode of the method.\n    if (varIndex < 4 && opcode != Opcodes.RET) {\n      int optimizedOpcode;\n      if (opcode < Opcodes.ISTORE) {\n        optimizedOpcode = Constants.ILOAD_0 + ((opcode - Opcodes.ILOAD) << 2) + varIndex;\n      } else {\n        optimizedOpcode = Constants.ISTORE_0 + ((opcode - Opcodes.ISTORE) << 2) + varIndex;\n      }\n      code.putByte(optimizedOpcode);\n    } else if (varIndex >= 256) {\n      code.putByte(Constants.WIDE).put12(opcode, varIndex);\n    } else {\n      code.put11(opcode, varIndex);\n    }\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\n    if (currentBasicBlock != null) {\n      if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\n        currentBasicBlock.frame.execute(opcode, varIndex, null, null);\n      } else {\n        if (opcode == Opcodes.RET) {\n          // No stack size delta.\n          currentBasicBlock.flags |= Label.FLAG_SUBROUTINE_END;\n          currentBasicBlock.outputStackSize = (short) relativeStackSize;\n          endCurrentBasicBlockWithNoSuccessor();\n        } else { // xLOAD or xSTORE\n          int size = relativeStackSize + STACK_SIZE_DELTA[opcode];\n          if (size > maxRelativeStackSize) {\n            maxRelativeStackSize = size;\n          }\n          relativeStackSize = size;\n        }\n      }\n    }\n    if (compute != COMPUTE_NOTHING) {\n      int currentMaxLocals;\n      if (opcode == Opcodes.LLOAD\n          || opcode == Opcodes.DLOAD\n          || opcode == Opcodes.LSTORE\n          || opcode == Opcodes.DSTORE) {\n        currentMaxLocals = varIndex + 2;\n      } else {\n        currentMaxLocals = varIndex + 1;\n      }\n      if (currentMaxLocals > maxLocals) {\n        maxLocals = currentMaxLocals;\n      }\n    }\n    if (opcode >= Opcodes.ISTORE && compute == COMPUTE_ALL_FRAMES && firstHandler != null) {\n      // If there are exception handler blocks, each instruction within a handler range is, in\n      // theory, a basic block (since execution can jump from this instruction to the exception\n      // handler). As a consequence, the local variable types at the beginning of the handler\n      // block should be the merge of the local variable types at all the instructions within the\n      // handler range. However, instead of creating a basic block for each instruction, we can\n      // get the same result in a more efficient way. Namely, by starting a new basic block after\n      // each xSTORE instruction, which is what we do here.\n      visitLabel(new Label());\n    }\n  }\n\n  @Override\n  public void visitTypeInsn(final int opcode, final String type) {\n    lastBytecodeOffset = code.length;\n    // Add the instruction to the bytecode of the method.\n    Symbol typeSymbol = symbolTable.addConstantClass(type);\n    code.put12(opcode, typeSymbol.index);\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\n    if (currentBasicBlock != null) {\n      if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\n        currentBasicBlock.frame.execute(opcode, lastBytecodeOffset, typeSymbol, symbolTable);\n      } else if (opcode == Opcodes.NEW) {\n        // The stack size delta is 1 for NEW, and 0 for ANEWARRAY, CHECKCAST, or INSTANCEOF.\n        int size = relativeStackSize + 1;\n        if (size > maxRelativeStackSize) {\n          maxRelativeStackSize = size;\n        }\n        relativeStackSize = size;\n      }\n    }\n  }\n\n  @Override\n  public void visitFieldInsn(\n      final int opcode, final String owner, final String name, final String descriptor) {\n    lastBytecodeOffset = code.length;\n    // Add the instruction to the bytecode of the method.\n    Symbol fieldrefSymbol = symbolTable.addConstantFieldref(owner, name, descriptor);\n    code.put12(opcode, fieldrefSymbol.index);\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\n    if (currentBasicBlock != null) {\n      if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\n        currentBasicBlock.frame.execute(opcode, 0, fieldrefSymbol, symbolTable);\n      } else {\n        int size;\n        char firstDescChar = descriptor.charAt(0);\n        switch (opcode) {\n          case Opcodes.GETSTATIC:\n            size = relativeStackSize + (firstDescChar == 'D' || firstDescChar == 'J' ? 2 : 1);\n            break;\n          case Opcodes.PUTSTATIC:\n            size = relativeStackSize + (firstDescChar == 'D' || firstDescChar == 'J' ? -2 : -1);\n            break;\n          case Opcodes.GETFIELD:\n            size = relativeStackSize + (firstDescChar == 'D' || firstDescChar == 'J' ? 1 : 0);\n            break;\n          case Opcodes.PUTFIELD:\n          default:\n            size = relativeStackSize + (firstDescChar == 'D' || firstDescChar == 'J' ? -3 : -2);\n            break;\n        }\n        if (size > maxRelativeStackSize) {\n          maxRelativeStackSize = size;\n        }\n        relativeStackSize = size;\n      }\n    }\n  }\n\n  @Override\n  public void visitMethodInsn(\n      final int opcode,\n      final String owner,\n      final String name,\n      final String descriptor,\n      final boolean isInterface) {\n    lastBytecodeOffset = code.length;\n    // Add the instruction to the bytecode of the method.\n    Symbol methodrefSymbol = symbolTable.addConstantMethodref(owner, name, descriptor, isInterface);\n    if (opcode == Opcodes.INVOKEINTERFACE) {\n      code.put12(Opcodes.INVOKEINTERFACE, methodrefSymbol.index)\n          .put11(methodrefSymbol.getArgumentsAndReturnSizes() >> 2, 0);\n    } else {\n      code.put12(opcode, methodrefSymbol.index);\n    }\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\n    if (currentBasicBlock != null) {\n      if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\n        currentBasicBlock.frame.execute(opcode, 0, methodrefSymbol, symbolTable);\n      } else {\n        int argumentsAndReturnSize = methodrefSymbol.getArgumentsAndReturnSizes();\n        int stackSizeDelta = (argumentsAndReturnSize & 3) - (argumentsAndReturnSize >> 2);\n        int size;\n        if (opcode == Opcodes.INVOKESTATIC) {\n          size = relativeStackSize + stackSizeDelta + 1;\n        } else {\n          size = relativeStackSize + stackSizeDelta;\n        }\n        if (size > maxRelativeStackSize) {\n          maxRelativeStackSize = size;\n        }\n        relativeStackSize = size;\n      }\n    }\n  }\n\n  @Override\n  public void visitInvokeDynamicInsn(\n      final String name,\n      final String descriptor,\n      final Handle bootstrapMethodHandle,\n      final Object... bootstrapMethodArguments) {\n    lastBytecodeOffset = code.length;\n    // Add the instruction to the bytecode of the method.\n    Symbol invokeDynamicSymbol =\n        symbolTable.addConstantInvokeDynamic(\n            name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);\n    code.put12(Opcodes.INVOKEDYNAMIC, invokeDynamicSymbol.index);\n    code.putShort(0);\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\n    if (currentBasicBlock != null) {\n      if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\n        currentBasicBlock.frame.execute(Opcodes.INVOKEDYNAMIC, 0, invokeDynamicSymbol, symbolTable);\n      } else {\n        int argumentsAndReturnSize = invokeDynamicSymbol.getArgumentsAndReturnSizes();\n        int stackSizeDelta = (argumentsAndReturnSize & 3) - (argumentsAndReturnSize >> 2) + 1;\n        int size = relativeStackSize + stackSizeDelta;\n        if (size > maxRelativeStackSize) {\n          maxRelativeStackSize = size;\n        }\n        relativeStackSize = size;\n      }\n    }\n  }\n\n  @Override\n  public void visitJumpInsn(final int opcode, final Label label) {\n    lastBytecodeOffset = code.length;\n    // Add the instruction to the bytecode of the method.\n    // Compute the 'base' opcode, i.e. GOTO or JSR if opcode is GOTO_W or JSR_W, otherwise opcode.\n    int baseOpcode =\n        opcode >= Constants.GOTO_W ? opcode - Constants.WIDE_JUMP_OPCODE_DELTA : opcode;\n    boolean nextInsnIsJumpTarget = false;\n    if ((label.flags & Label.FLAG_RESOLVED) != 0\n        && label.bytecodeOffset - code.length < Short.MIN_VALUE) {\n      // Case of a backward jump with an offset < -32768. In this case we automatically replace GOTO\n      // with GOTO_W, JSR with JSR_W and IFxxx <l> with IFNOTxxx <L> GOTO_W <l> L:..., where\n      // IFNOTxxx is the \"opposite\" opcode of IFxxx (for example, IFNE for IFEQ) and where <L> designates\n      // the instruction just after the GOTO_W.\n      if (baseOpcode == Opcodes.GOTO) {\n        code.putByte(Constants.GOTO_W);\n      } else if (baseOpcode == Opcodes.JSR) {\n        code.putByte(Constants.JSR_W);\n      } else {\n        // Put the \"opposite\" opcode of baseOpcode. This can be done by flipping the least\n        // significant bit for IFNULL and IFNONNULL, and similarly for IFEQ ... IF_ACMPEQ (with a\n        // pre and post offset by 1). The jump offset is 8 bytes (3 for IFNOTxxx, 5 for GOTO_W).\n        code.putByte(baseOpcode >= Opcodes.IFNULL ? baseOpcode ^ 1 : ((baseOpcode + 1) ^ 1) - 1);\n        code.putShort(8);\n        // Here we could put a GOTO_W in theory, but if ASM specific instructions are used in this\n        // method or another one, and if the class has frames, we will need to insert a frame after\n        // this GOTO_W during the additional ClassReader -> ClassWriter round trip to remove the ASM\n        // specific instructions. To not miss this additional frame, we need to use an ASM_GOTO_W\n        // here, which has the unfortunate effect of forcing this additional round trip (which in\n        // some case would not have been really necessary, but we can't know this at this point).\n        code.putByte(Constants.ASM_GOTO_W);\n        hasAsmInstructions = true;\n        // The instruction after the GOTO_W becomes the target of the IFNOT instruction.\n        nextInsnIsJumpTarget = true;\n      }\n      label.put(code, code.length - 1, true);\n    } else if (baseOpcode != opcode) {\n      // Case of a GOTO_W or JSR_W specified by the user (normally ClassReader when used to remove\n      // ASM specific instructions). In this case we keep the original instruction.\n      code.putByte(opcode);\n      label.put(code, code.length - 1, true);\n    } else {\n      // Case of a jump with an offset >= -32768, or of a jump with an unknown offset. In these\n      // cases we store the offset in 2 bytes (which will be increased via a ClassReader ->\n      // ClassWriter round trip if it turns out that 2 bytes are not sufficient).\n      code.putByte(baseOpcode);\n      label.put(code, code.length - 1, false);\n    }\n\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\n    if (currentBasicBlock != null) {\n      Label nextBasicBlock = null;\n      if (compute == COMPUTE_ALL_FRAMES) {\n        currentBasicBlock.frame.execute(baseOpcode, 0, null, null);\n        // Record the fact that 'label' is the target of a jump instruction.\n        label.getCanonicalInstance().flags |= Label.FLAG_JUMP_TARGET;\n        // Add 'label' as a successor of the current basic block.\n        addSuccessorToCurrentBasicBlock(Edge.JUMP, label);\n        if (baseOpcode != Opcodes.GOTO) {\n          // The next instruction starts a new basic block (except for GOTO: by default the code\n          // following a goto is unreachable - unless there is an explicit label for it - and we\n          // should not compute stack frame types for its instructions).\n          nextBasicBlock = new Label();\n        }\n      } else if (compute == COMPUTE_INSERTED_FRAMES) {\n        currentBasicBlock.frame.execute(baseOpcode, 0, null, null);\n      } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES) {\n        // No need to update maxRelativeStackSize (the stack size delta is always negative).\n        relativeStackSize += STACK_SIZE_DELTA[baseOpcode];\n      } else {\n        if (baseOpcode == Opcodes.JSR) {\n          // Record the fact that 'label' designates a subroutine, if not already done.\n          if ((label.flags & Label.FLAG_SUBROUTINE_START) == 0) {\n            label.flags |= Label.FLAG_SUBROUTINE_START;\n            hasSubroutines = true;\n          }\n          currentBasicBlock.flags |= Label.FLAG_SUBROUTINE_CALLER;\n          // Note that, by construction in this method, a block which calls a subroutine has at\n          // least two successors in the control flow graph: the first one (added below) leads to\n          // the instruction after the JSR, while the second one (added here) leads to the JSR\n          // target. Note that the first successor is virtual (it does not correspond to a possible\n          // execution path): it is only used to compute the successors of the basic blocks ending\n          // with a ret, in {@link Label#addSubroutineRetSuccessors}.\n          addSuccessorToCurrentBasicBlock(relativeStackSize + 1, label);\n          // The instruction after the JSR starts a new basic block.\n          nextBasicBlock = new Label();\n        } else {\n          // No need to update maxRelativeStackSize (the stack size delta is always negative).\n          relativeStackSize += STACK_SIZE_DELTA[baseOpcode];\n          addSuccessorToCurrentBasicBlock(relativeStackSize, label);\n        }\n      }\n      // If the next instruction starts a new basic block, call visitLabel to add the label of this\n      // instruction as a successor of the current block, and to start a new basic block.\n      if (nextBasicBlock != null) {\n        if (nextInsnIsJumpTarget) {\n          nextBasicBlock.flags |= Label.FLAG_JUMP_TARGET;\n        }\n        visitLabel(nextBasicBlock);\n      }\n      if (baseOpcode == Opcodes.GOTO) {\n        endCurrentBasicBlockWithNoSuccessor();\n      }\n    }\n  }\n\n  @Override\n  public void visitLabel(final Label label) {\n    // Resolve the forward references to this label, if any.\n    hasAsmInstructions |= label.resolve(code.data, stackMapTableEntries, code.length);\n    // visitLabel starts a new basic block (except for debug only labels), so we need to update the\n    // previous and current block references and list of successors.\n    if ((label.flags & Label.FLAG_DEBUG_ONLY) != 0) {\n      return;\n    }\n    if (compute == COMPUTE_ALL_FRAMES) {\n      if (currentBasicBlock != null) {\n        if (label.bytecodeOffset == currentBasicBlock.bytecodeOffset) {\n          // We use {@link Label#getCanonicalInstance} to store the state of a basic block in only\n          // one place, but this does not work for labels which have not been visited yet.\n          // Therefore, when we detect here two labels having the same bytecode offset, we need to\n          // - consolidate the state scattered in these two instances into the canonical instance:\n          currentBasicBlock.flags |= (label.flags & Label.FLAG_JUMP_TARGET);\n          // - make sure the two instances share the same Frame instance (the implementation of\n          // {@link Label#getCanonicalInstance} relies on this property; here label.frame should be\n          // null):\n          label.frame = currentBasicBlock.frame;\n          // - and make sure to NOT assign 'label' into 'currentBasicBlock' or 'lastBasicBlock', so\n          // that they still refer to the canonical instance for this bytecode offset.\n          return;\n        }\n        // End the current basic block (with one new successor).\n        addSuccessorToCurrentBasicBlock(Edge.JUMP, label);\n      }\n      // Append 'label' at the end of the basic block list.\n      if (lastBasicBlock != null) {\n        if (label.bytecodeOffset == lastBasicBlock.bytecodeOffset) {\n          // Same comment as above.\n          lastBasicBlock.flags |= (label.flags & Label.FLAG_JUMP_TARGET);\n          // Here label.frame should be null.\n          label.frame = lastBasicBlock.frame;\n          currentBasicBlock = lastBasicBlock;\n          return;\n        }\n        lastBasicBlock.nextBasicBlock = label;\n      }\n      lastBasicBlock = label;\n      // Make it the new current basic block.\n      currentBasicBlock = label;\n      // Here label.frame should be null.\n      label.frame = new Frame(label);\n    } else if (compute == COMPUTE_INSERTED_FRAMES) {\n      if (currentBasicBlock == null) {\n        // This case should happen only once, for the visitLabel call in the constructor. Indeed, if\n        // compute is equal to COMPUTE_INSERTED_FRAMES, currentBasicBlock stays unchanged.\n        currentBasicBlock = label;\n      } else {\n        // Update the frame owner so that a correct frame offset is computed in Frame.accept().\n        currentBasicBlock.frame.owner = label;\n      }\n    } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) {\n      if (currentBasicBlock != null) {\n        // End the current basic block (with one new successor).\n        currentBasicBlock.outputStackMax = (short) maxRelativeStackSize;\n        addSuccessorToCurrentBasicBlock(relativeStackSize, label);\n      }\n      // Start a new current basic block, and reset the current and maximum relative stack sizes.\n      currentBasicBlock = label;\n      relativeStackSize = 0;\n      maxRelativeStackSize = 0;\n      // Append the new basic block at the end of the basic block list.\n      if (lastBasicBlock != null) {\n        lastBasicBlock.nextBasicBlock = label;\n      }\n      lastBasicBlock = label;\n    } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES && currentBasicBlock == null) {\n      // This case should happen only once, for the visitLabel call in the constructor. Indeed, if\n      // compute is equal to COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES, currentBasicBlock stays\n      // unchanged.\n      currentBasicBlock = label;\n    }\n  }\n\n  @Override\n  public void visitLdcInsn(final Object value) {\n    lastBytecodeOffset = code.length;\n    // Add the instruction to the bytecode of the method.\n    Symbol constantSymbol = symbolTable.addConstant(value);\n    int constantIndex = constantSymbol.index;\n    char firstDescriptorChar;\n    boolean isLongOrDouble =\n        constantSymbol.tag == Symbol.CONSTANT_LONG_TAG\n            || constantSymbol.tag == Symbol.CONSTANT_DOUBLE_TAG\n            || (constantSymbol.tag == Symbol.CONSTANT_DYNAMIC_TAG\n                && ((firstDescriptorChar = constantSymbol.value.charAt(0)) == 'J'\n                    || firstDescriptorChar == 'D'));\n    if (isLongOrDouble) {\n      code.put12(Constants.LDC2_W, constantIndex);\n    } else if (constantIndex >= 256) {\n      code.put12(Constants.LDC_W, constantIndex);\n    } else {\n      code.put11(Opcodes.LDC, constantIndex);\n    }\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\n    if (currentBasicBlock != null) {\n      if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\n        currentBasicBlock.frame.execute(Opcodes.LDC, 0, constantSymbol, symbolTable);\n      } else {\n        int size = relativeStackSize + (isLongOrDouble ? 2 : 1);\n        if (size > maxRelativeStackSize) {\n          maxRelativeStackSize = size;\n        }\n        relativeStackSize = size;\n      }\n    }\n  }\n\n  @Override\n  public void visitIincInsn(final int varIndex, final int increment) {\n    lastBytecodeOffset = code.length;\n    // Add the instruction to the bytecode of the method.\n    if ((varIndex > 255) || (increment > 127) || (increment < -128)) {\n      code.putByte(Constants.WIDE).put12(Opcodes.IINC, varIndex).putShort(increment);\n    } else {\n      code.putByte(Opcodes.IINC).put11(varIndex, increment);\n    }\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\n    if (currentBasicBlock != null\n        && (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES)) {\n      currentBasicBlock.frame.execute(Opcodes.IINC, varIndex, null, null);\n    }\n    if (compute != COMPUTE_NOTHING) {\n      int currentMaxLocals = varIndex + 1;\n      if (currentMaxLocals > maxLocals) {\n        maxLocals = currentMaxLocals;\n      }\n    }\n  }\n\n  @Override\n  public void visitTableSwitchInsn(\n      final int min, final int max, final Label dflt, final Label... labels) {\n    lastBytecodeOffset = code.length;\n    // Add the instruction to the bytecode of the method.\n    code.putByte(Opcodes.TABLESWITCH).putByteArray(null, 0, (4 - code.length % 4) % 4);\n    dflt.put(code, lastBytecodeOffset, true);\n    code.putInt(min).putInt(max);\n    for (Label label : labels) {\n      label.put(code, lastBytecodeOffset, true);\n    }\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\n    visitSwitchInsn(dflt, labels);\n  }\n\n  @Override\n  public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {\n    lastBytecodeOffset = code.length;\n    // Add the instruction to the bytecode of the method.\n    code.putByte(Opcodes.LOOKUPSWITCH).putByteArray(null, 0, (4 - code.length % 4) % 4);\n    dflt.put(code, lastBytecodeOffset, true);\n    code.putInt(labels.length);\n    for (int i = 0; i < labels.length; ++i) {\n      code.putInt(keys[i]);\n      labels[i].put(code, lastBytecodeOffset, true);\n    }\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\n    visitSwitchInsn(dflt, labels);\n  }\n\n  private void visitSwitchInsn(final Label dflt, final Label[] labels) {\n    if (currentBasicBlock != null) {\n      if (compute == COMPUTE_ALL_FRAMES) {\n        currentBasicBlock.frame.execute(Opcodes.LOOKUPSWITCH, 0, null, null);\n        // Add all the labels as successors of the current basic block.\n        addSuccessorToCurrentBasicBlock(Edge.JUMP, dflt);\n        dflt.getCanonicalInstance().flags |= Label.FLAG_JUMP_TARGET;\n        for (Label label : labels) {\n          addSuccessorToCurrentBasicBlock(Edge.JUMP, label);\n          label.getCanonicalInstance().flags |= Label.FLAG_JUMP_TARGET;\n        }\n      } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) {\n        // No need to update maxRelativeStackSize (the stack size delta is always negative).\n        --relativeStackSize;\n        // Add all the labels as successors of the current basic block.\n        addSuccessorToCurrentBasicBlock(relativeStackSize, dflt);\n        for (Label label : labels) {\n          addSuccessorToCurrentBasicBlock(relativeStackSize, label);\n        }\n      }\n      // End the current basic block.\n      endCurrentBasicBlockWithNoSuccessor();\n    }\n  }\n\n  @Override\n  public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {\n    lastBytecodeOffset = code.length;\n    // Add the instruction to the bytecode of the method.\n    Symbol descSymbol = symbolTable.addConstantClass(descriptor);\n    code.put12(Opcodes.MULTIANEWARRAY, descSymbol.index).putByte(numDimensions);\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\n    if (currentBasicBlock != null) {\n      if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\n        currentBasicBlock.frame.execute(\n            Opcodes.MULTIANEWARRAY, numDimensions, descSymbol, symbolTable);\n      } else {\n        // No need to update maxRelativeStackSize (the stack size delta is always negative).\n        relativeStackSize += 1 - numDimensions;\n      }\n    }\n  }\n\n  @Override\n  public AnnotationVisitor visitInsnAnnotation(\n      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\n    if (visible) {\n      return lastCodeRuntimeVisibleTypeAnnotation =\n          AnnotationWriter.create(\n              symbolTable,\n              (typeRef & 0xFF0000FF) | (lastBytecodeOffset << 8),\n              typePath,\n              descriptor,\n              lastCodeRuntimeVisibleTypeAnnotation);\n    } else {\n      return lastCodeRuntimeInvisibleTypeAnnotation =\n          AnnotationWriter.create(\n              symbolTable,\n              (typeRef & 0xFF0000FF) | (lastBytecodeOffset << 8),\n              typePath,\n              descriptor,\n              lastCodeRuntimeInvisibleTypeAnnotation);\n    }\n  }\n\n  @Override\n  public void visitTryCatchBlock(\n      final Label start, final Label end, final Label handler, final String type) {\n    Handler newHandler =\n        new Handler(\n            start, end, handler, type != null ? symbolTable.addConstantClass(type).index : 0, type);\n    if (firstHandler == null) {\n      firstHandler = newHandler;\n    } else {\n      lastHandler.nextHandler = newHandler;\n    }\n    lastHandler = newHandler;\n  }\n\n  @Override\n  public AnnotationVisitor visitTryCatchAnnotation(\n      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\n    if (visible) {\n      return lastCodeRuntimeVisibleTypeAnnotation =\n          AnnotationWriter.create(\n              symbolTable, typeRef, typePath, descriptor, lastCodeRuntimeVisibleTypeAnnotation);\n    } else {\n      return lastCodeRuntimeInvisibleTypeAnnotation =\n          AnnotationWriter.create(\n              symbolTable, typeRef, typePath, descriptor, lastCodeRuntimeInvisibleTypeAnnotation);\n    }\n  }\n\n  @Override\n  public void visitLocalVariable(\n      final String name,\n      final String descriptor,\n      final String signature,\n      final Label start,\n      final Label end,\n      final int index) {\n    if (signature != null) {\n      if (localVariableTypeTable == null) {\n        localVariableTypeTable = new ByteVector();\n      }\n      ++localVariableTypeTableLength;\n      localVariableTypeTable\n          .putShort(start.bytecodeOffset)\n          .putShort(end.bytecodeOffset - start.bytecodeOffset)\n          .putShort(symbolTable.addConstantUtf8(name))\n          .putShort(symbolTable.addConstantUtf8(signature))\n          .putShort(index);\n    }\n    if (localVariableTable == null) {\n      localVariableTable = new ByteVector();\n    }\n    ++localVariableTableLength;\n    localVariableTable\n        .putShort(start.bytecodeOffset)\n        .putShort(end.bytecodeOffset - start.bytecodeOffset)\n        .putShort(symbolTable.addConstantUtf8(name))\n        .putShort(symbolTable.addConstantUtf8(descriptor))\n        .putShort(index);\n    if (compute != COMPUTE_NOTHING) {\n      char firstDescChar = descriptor.charAt(0);\n      int currentMaxLocals = index + (firstDescChar == 'J' || firstDescChar == 'D' ? 2 : 1);\n      if (currentMaxLocals > maxLocals) {\n        maxLocals = currentMaxLocals;\n      }\n    }\n  }\n\n  @Override\n  public AnnotationVisitor visitLocalVariableAnnotation(\n      final int typeRef,\n      final TypePath typePath,\n      final Label[] start,\n      final Label[] end,\n      final int[] index,\n      final String descriptor,\n      final boolean visible) {\n    // Create a ByteVector to hold a 'type_annotation' JVMS structure.\n    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20.\n    ByteVector typeAnnotation = new ByteVector();\n    // Write target_type, target_info, and target_path.\n    typeAnnotation.putByte(typeRef >>> 24).putShort(start.length);\n    for (int i = 0; i < start.length; ++i) {\n      typeAnnotation\n          .putShort(start[i].bytecodeOffset)\n          .putShort(end[i].bytecodeOffset - start[i].bytecodeOffset)\n          .putShort(index[i]);\n    }\n    TypePath.put(typePath, typeAnnotation);\n    // Write type_index and reserve space for num_element_value_pairs.\n    typeAnnotation.putShort(symbolTable.addConstantUtf8(descriptor)).putShort(0);\n    if (visible) {\n      return lastCodeRuntimeVisibleTypeAnnotation =\n          new AnnotationWriter(\n              symbolTable,\n              /* useNamedValues= */ true,\n              typeAnnotation,\n              lastCodeRuntimeVisibleTypeAnnotation);\n    } else {\n      return lastCodeRuntimeInvisibleTypeAnnotation =\n          new AnnotationWriter(\n              symbolTable,\n              /* useNamedValues= */ true,\n              typeAnnotation,\n              lastCodeRuntimeInvisibleTypeAnnotation);\n    }\n  }\n\n  @Override\n  public void visitLineNumber(final int line, final Label start) {\n    if (lineNumberTable == null) {\n      lineNumberTable = new ByteVector();\n    }\n    ++lineNumberTableLength;\n    lineNumberTable.putShort(start.bytecodeOffset);\n    lineNumberTable.putShort(line);\n  }\n\n  @Override\n  public void visitMaxs(final int maxStack, final int maxLocals) {\n    if (compute == COMPUTE_ALL_FRAMES) {\n      computeAllFrames();\n    } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) {\n      computeMaxStackAndLocal();\n    } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES) {\n      this.maxStack = maxRelativeStackSize;\n    } else {\n      this.maxStack = maxStack;\n      this.maxLocals = maxLocals;\n    }\n  }\n\n  /** Computes all the stack map frames of the method, from scratch. */\n  private void computeAllFrames() {\n    // Complete the control flow graph with exception handler blocks.\n    Handler handler = firstHandler;\n    while (handler != null) {\n      String catchTypeDescriptor =\n          handler.catchTypeDescriptor == null ? \"java/lang/Throwable\" : handler.catchTypeDescriptor;\n      int catchType = Frame.getAbstractTypeFromInternalName(symbolTable, catchTypeDescriptor);\n      // Mark handlerBlock as an exception handler.\n      Label handlerBlock = handler.handlerPc.getCanonicalInstance();\n      handlerBlock.flags |= Label.FLAG_JUMP_TARGET;\n      // Add handlerBlock as a successor of all the basic blocks in the exception handler range.\n      Label handlerRangeBlock = handler.startPc.getCanonicalInstance();\n      Label handlerRangeEnd = handler.endPc.getCanonicalInstance();\n      while (handlerRangeBlock != handlerRangeEnd) {\n        handlerRangeBlock.outgoingEdges =\n            new Edge(catchType, handlerBlock, handlerRangeBlock.outgoingEdges);\n        handlerRangeBlock = handlerRangeBlock.nextBasicBlock;\n      }\n      handler = handler.nextHandler;\n    }\n\n    // Create and visit the first (implicit) frame.\n    Frame firstFrame = firstBasicBlock.frame;\n    firstFrame.setInputFrameFromDescriptor(symbolTable, accessFlags, descriptor, this.maxLocals);\n    firstFrame.accept(this);\n\n    // Fix point algorithm: add the first basic block to a list of blocks to process (i.e. blocks\n    // whose stack map frame has changed) and, while there are blocks to process, remove one from\n    // the list and update the stack map frames of its successor blocks in the control flow graph\n    // (which might change them, in which case these blocks must be processed too, and are thus\n    // added to the list of blocks to process). Also compute the maximum stack size of the method,\n    // as a by-product.\n    Label listOfBlocksToProcess = firstBasicBlock;\n    listOfBlocksToProcess.nextListElement = Label.EMPTY_LIST;\n    int maxStackSize = 0;\n    while (listOfBlocksToProcess != Label.EMPTY_LIST) {\n      // Remove a basic block from the list of blocks to process.\n      Label basicBlock = listOfBlocksToProcess;\n      listOfBlocksToProcess = listOfBlocksToProcess.nextListElement;\n      basicBlock.nextListElement = null;\n      // By definition, basicBlock is reachable.\n      basicBlock.flags |= Label.FLAG_REACHABLE;\n      // Update the (absolute) maximum stack size.\n      int maxBlockStackSize = basicBlock.frame.getInputStackSize() + basicBlock.outputStackMax;\n      if (maxBlockStackSize > maxStackSize) {\n        maxStackSize = maxBlockStackSize;\n      }\n      // Update the successor blocks of basicBlock in the control flow graph.\n      Edge outgoingEdge = basicBlock.outgoingEdges;\n      while (outgoingEdge != null) {\n        Label successorBlock = outgoingEdge.successor.getCanonicalInstance();\n        boolean successorBlockChanged =\n            basicBlock.frame.merge(symbolTable, successorBlock.frame, outgoingEdge.info);\n        if (successorBlockChanged && successorBlock.nextListElement == null) {\n          // If successorBlock has changed it must be processed. Thus, if it is not already in the\n          // list of blocks to process, add it to this list.\n          successorBlock.nextListElement = listOfBlocksToProcess;\n          listOfBlocksToProcess = successorBlock;\n        }\n        outgoingEdge = outgoingEdge.nextEdge;\n      }\n    }\n\n    // Loop over all the basic blocks and visit the stack map frames that must be stored in the\n    // StackMapTable attribute. Also replace unreachable code with NOP* ATHROW, and remove it from\n    // exception handler ranges.\n    Label basicBlock = firstBasicBlock;\n    while (basicBlock != null) {\n      if ((basicBlock.flags & (Label.FLAG_JUMP_TARGET | Label.FLAG_REACHABLE))\n          == (Label.FLAG_JUMP_TARGET | Label.FLAG_REACHABLE)) {\n        basicBlock.frame.accept(this);\n      }\n      if ((basicBlock.flags & Label.FLAG_REACHABLE) == 0) {\n        // Find the start and end bytecode offsets of this unreachable block.\n        Label nextBasicBlock = basicBlock.nextBasicBlock;\n        int startOffset = basicBlock.bytecodeOffset;\n        int endOffset = (nextBasicBlock == null ? code.length : nextBasicBlock.bytecodeOffset) - 1;\n        if (endOffset >= startOffset) {\n          // Replace its instructions with NOP ... NOP ATHROW.\n          for (int i = startOffset; i < endOffset; ++i) {\n            code.data[i] = Opcodes.NOP;\n          }\n          code.data[endOffset] = (byte) Opcodes.ATHROW;\n          // Emit a frame for this unreachable block, with no local and a Throwable on the stack\n          // (so that the ATHROW could consume this Throwable if it were reachable).\n          int frameIndex = visitFrameStart(startOffset, /* numLocal = */ 0, /* numStack = */ 1);\n          currentFrame[frameIndex] =\n              Frame.getAbstractTypeFromInternalName(symbolTable, \"java/lang/Throwable\");\n          visitFrameEnd();\n          // Remove this unreachable basic block from the exception handler ranges.\n          firstHandler = Handler.removeRange(firstHandler, basicBlock, nextBasicBlock);\n          // The maximum stack size is now at least one, because of the Throwable declared above.\n          maxStackSize = Math.max(maxStackSize, 1);\n        }\n      }\n      basicBlock = basicBlock.nextBasicBlock;\n    }\n\n    this.maxStack = maxStackSize;\n  }\n\n  /** Computes the maximum stack size of the method. */\n  private void computeMaxStackAndLocal() {\n    // Complete the control flow graph with exception handler blocks.\n    Handler handler = firstHandler;\n    while (handler != null) {\n      Label handlerBlock = handler.handlerPc;\n      Label handlerRangeBlock = handler.startPc;\n      Label handlerRangeEnd = handler.endPc;\n      // Add handlerBlock as a successor of all the basic blocks in the exception handler range.\n      while (handlerRangeBlock != handlerRangeEnd) {\n        if ((handlerRangeBlock.flags & Label.FLAG_SUBROUTINE_CALLER) == 0) {\n          handlerRangeBlock.outgoingEdges =\n              new Edge(Edge.EXCEPTION, handlerBlock, handlerRangeBlock.outgoingEdges);\n        } else {\n          // If handlerRangeBlock is a JSR block, add handlerBlock after the first two outgoing\n          // edges to preserve the hypothesis about JSR block successors order (see\n          // {@link #visitJumpInsn}).\n          handlerRangeBlock.outgoingEdges.nextEdge.nextEdge =\n              new Edge(\n                  Edge.EXCEPTION, handlerBlock, handlerRangeBlock.outgoingEdges.nextEdge.nextEdge);\n        }\n        handlerRangeBlock = handlerRangeBlock.nextBasicBlock;\n      }\n      handler = handler.nextHandler;\n    }\n\n    // Complete the control flow graph with the successor blocks of subroutines, if needed.\n    if (hasSubroutines) {\n      // First step: find the subroutines. This step determines, for each basic block, to which\n      // subroutine(s) it belongs. Start with the main \"subroutine\":\n      short numSubroutines = 1;\n      firstBasicBlock.markSubroutine(numSubroutines);\n      // Then, mark the subroutines called by the main subroutine, then the subroutines called by\n      // those called by the main subroutine, etc.\n      for (short currentSubroutine = 1; currentSubroutine <= numSubroutines; ++currentSubroutine) {\n        Label basicBlock = firstBasicBlock;\n        while (basicBlock != null) {\n          if ((basicBlock.flags & Label.FLAG_SUBROUTINE_CALLER) != 0\n              && basicBlock.subroutineId == currentSubroutine) {\n            Label jsrTarget = basicBlock.outgoingEdges.nextEdge.successor;\n            if (jsrTarget.subroutineId == 0) {\n              // If this subroutine has not been marked yet, find its basic blocks.\n              jsrTarget.markSubroutine(++numSubroutines);\n            }\n          }\n          basicBlock = basicBlock.nextBasicBlock;\n        }\n      }\n      // Second step: find the successors in the control flow graph of each subroutine basic block\n      // 'r' ending with a RET instruction. These successors are the virtual successors of the basic\n      // blocks ending with JSR instructions (see {@link #visitJumpInsn)} that can reach 'r'.\n      Label basicBlock = firstBasicBlock;\n      while (basicBlock != null) {\n        if ((basicBlock.flags & Label.FLAG_SUBROUTINE_CALLER) != 0) {\n          // By construction, jsr targets are stored in the second outgoing edge of basic blocks\n          // that ends with a jsr instruction (see {@link #FLAG_SUBROUTINE_CALLER}).\n          Label subroutine = basicBlock.outgoingEdges.nextEdge.successor;\n          subroutine.addSubroutineRetSuccessors(basicBlock);\n        }\n        basicBlock = basicBlock.nextBasicBlock;\n      }\n    }\n\n    // Data flow algorithm: put the first basic block in a list of blocks to process (i.e. blocks\n    // whose input stack size has changed) and, while there are blocks to process, remove one\n    // from the list, update the input stack size of its successor blocks in the control flow\n    // graph, and add these blocks to the list of blocks to process (if not already done).\n    Label listOfBlocksToProcess = firstBasicBlock;\n    listOfBlocksToProcess.nextListElement = Label.EMPTY_LIST;\n    int maxStackSize = maxStack;\n    while (listOfBlocksToProcess != Label.EMPTY_LIST) {\n      // Remove a basic block from the list of blocks to process. Note that we don't reset\n      // basicBlock.nextListElement to null on purpose, to make sure we don't reprocess already\n      // processed basic blocks.\n      Label basicBlock = listOfBlocksToProcess;\n      listOfBlocksToProcess = listOfBlocksToProcess.nextListElement;\n      // Compute the (absolute) input stack size and maximum stack size of this block.\n      int inputStackTop = basicBlock.inputStackSize;\n      int maxBlockStackSize = inputStackTop + basicBlock.outputStackMax;\n      // Update the absolute maximum stack size of the method.\n      if (maxBlockStackSize > maxStackSize) {\n        maxStackSize = maxBlockStackSize;\n      }\n      // Update the input stack size of the successor blocks of basicBlock in the control flow\n      // graph, and add these blocks to the list of blocks to process, if not already done.\n      Edge outgoingEdge = basicBlock.outgoingEdges;\n      if ((basicBlock.flags & Label.FLAG_SUBROUTINE_CALLER) != 0) {\n        // Ignore the first outgoing edge of the basic blocks ending with a jsr: these are virtual\n        // edges which lead to the instruction just after the jsr, and do not correspond to a\n        // possible execution path (see {@link #visitJumpInsn} and\n        // {@link Label#FLAG_SUBROUTINE_CALLER}).\n        outgoingEdge = outgoingEdge.nextEdge;\n      }\n      while (outgoingEdge != null) {\n        Label successorBlock = outgoingEdge.successor;\n        if (successorBlock.nextListElement == null) {\n          successorBlock.inputStackSize =\n              (short) (outgoingEdge.info == Edge.EXCEPTION ? 1 : inputStackTop + outgoingEdge.info);\n          successorBlock.nextListElement = listOfBlocksToProcess;\n          listOfBlocksToProcess = successorBlock;\n        }\n        outgoingEdge = outgoingEdge.nextEdge;\n      }\n    }\n    this.maxStack = maxStackSize;\n  }\n\n  @Override\n  public void visitEnd() {\n    // Nothing to do.\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Utility methods: control flow analysis algorithm\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Adds a successor to {@link #currentBasicBlock} in the control flow graph.\n   *\n   * @param info information about the control flow edge to be added.\n   * @param successor the successor block to be added to the current basic block.\n   */\n  private void addSuccessorToCurrentBasicBlock(final int info, final Label successor) {\n    currentBasicBlock.outgoingEdges = new Edge(info, successor, currentBasicBlock.outgoingEdges);\n  }\n\n  /**\n   * Ends the current basic block. This method must be used in the case where the current basic\n   * block does not have any successor.\n   *\n   * <p>WARNING: this method must be called after the currently visited instruction has been put in\n   * {@link #code} (if frames are computed, this method inserts a new Label to start a new basic\n   * block after the current instruction).\n   */\n  private void endCurrentBasicBlockWithNoSuccessor() {\n    if (compute == COMPUTE_ALL_FRAMES) {\n      Label nextBasicBlock = new Label();\n      nextBasicBlock.frame = new Frame(nextBasicBlock);\n      nextBasicBlock.resolve(code.data, stackMapTableEntries, code.length);\n      lastBasicBlock.nextBasicBlock = nextBasicBlock;\n      lastBasicBlock = nextBasicBlock;\n      currentBasicBlock = null;\n    } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) {\n      currentBasicBlock.outputStackMax = (short) maxRelativeStackSize;\n      currentBasicBlock = null;\n    }\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Utility methods: stack map frames\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Starts the visit of a new stack map frame, stored in {@link #currentFrame}.\n   *\n   * @param offset the bytecode offset of the instruction to which the frame corresponds.\n   * @param numLocal the number of local variables in the frame.\n   * @param numStack the number of stack elements in the frame.\n   * @return the index of the next element to be written in this frame.\n   */\n  int visitFrameStart(final int offset, final int numLocal, final int numStack) {\n    int frameLength = 3 + numLocal + numStack;\n    if (currentFrame == null || currentFrame.length < frameLength) {\n      currentFrame = new int[frameLength];\n    }\n    currentFrame[0] = offset;\n    currentFrame[1] = numLocal;\n    currentFrame[2] = numStack;\n    return 3;\n  }\n\n  /**\n   * Sets an abstract type in {@link #currentFrame}.\n   *\n   * @param frameIndex the index of the element to be set in {@link #currentFrame}.\n   * @param abstractType an abstract type.\n   */\n  void visitAbstractType(final int frameIndex, final int abstractType) {\n    currentFrame[frameIndex] = abstractType;\n  }\n\n  /**\n   * Ends the visit of {@link #currentFrame} by writing it in the StackMapTable entries and by\n   * updating the StackMapTable number_of_entries (except if the current frame is the first one,\n   * which is implicit in StackMapTable). Then resets {@link #currentFrame} to {@literal null}.\n   */\n  void visitFrameEnd() {\n    if (previousFrame != null) {\n      if (stackMapTableEntries == null) {\n        stackMapTableEntries = new ByteVector();\n      }\n      putFrame();\n      ++stackMapTableNumberOfEntries;\n    }\n    previousFrame = currentFrame;\n    currentFrame = null;\n  }\n\n  /** Compresses and writes {@link #currentFrame} in a new StackMapTable entry. */\n  private void putFrame() {\n    final int numLocal = currentFrame[1];\n    final int numStack = currentFrame[2];\n    if (symbolTable.getMajorVersion() < Opcodes.V1_6) {\n      // Generate a StackMap attribute entry, which are always uncompressed.\n      stackMapTableEntries.putShort(currentFrame[0]).putShort(numLocal);\n      putAbstractTypes(3, 3 + numLocal);\n      stackMapTableEntries.putShort(numStack);\n      putAbstractTypes(3 + numLocal, 3 + numLocal + numStack);\n      return;\n    }\n    final int offsetDelta =\n        stackMapTableNumberOfEntries == 0\n            ? currentFrame[0]\n            : currentFrame[0] - previousFrame[0] - 1;\n    final int previousNumlocal = previousFrame[1];\n    final int numLocalDelta = numLocal - previousNumlocal;\n    int type = Frame.FULL_FRAME;\n    if (numStack == 0) {\n      switch (numLocalDelta) {\n        case -3:\n        case -2:\n        case -1:\n          type = Frame.CHOP_FRAME;\n          break;\n        case 0:\n          type = offsetDelta < 64 ? Frame.SAME_FRAME : Frame.SAME_FRAME_EXTENDED;\n          break;\n        case 1:\n        case 2:\n        case 3:\n          type = Frame.APPEND_FRAME;\n          break;\n        default:\n          // Keep the FULL_FRAME type.\n          break;\n      }\n    } else if (numLocalDelta == 0 && numStack == 1) {\n      type =\n          offsetDelta < 63\n              ? Frame.SAME_LOCALS_1_STACK_ITEM_FRAME\n              : Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;\n    }\n    if (type != Frame.FULL_FRAME) {\n      // Verify if locals are the same as in the previous frame.\n      int frameIndex = 3;\n      for (int i = 0; i < previousNumlocal && i < numLocal; i++) {\n        if (currentFrame[frameIndex] != previousFrame[frameIndex]) {\n          type = Frame.FULL_FRAME;\n          break;\n        }\n        frameIndex++;\n      }\n    }\n    switch (type) {\n      case Frame.SAME_FRAME:\n        stackMapTableEntries.putByte(offsetDelta);\n        break;\n      case Frame.SAME_LOCALS_1_STACK_ITEM_FRAME:\n        stackMapTableEntries.putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME + offsetDelta);\n        putAbstractTypes(3 + numLocal, 4 + numLocal);\n        break;\n      case Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED:\n        stackMapTableEntries\n            .putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED)\n            .putShort(offsetDelta);\n        putAbstractTypes(3 + numLocal, 4 + numLocal);\n        break;\n      case Frame.SAME_FRAME_EXTENDED:\n        stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED).putShort(offsetDelta);\n        break;\n      case Frame.CHOP_FRAME:\n        stackMapTableEntries\n            .putByte(Frame.SAME_FRAME_EXTENDED + numLocalDelta)\n            .putShort(offsetDelta);\n        break;\n      case Frame.APPEND_FRAME:\n        stackMapTableEntries\n            .putByte(Frame.SAME_FRAME_EXTENDED + numLocalDelta)\n            .putShort(offsetDelta);\n        putAbstractTypes(3 + previousNumlocal, 3 + numLocal);\n        break;\n      case Frame.FULL_FRAME:\n      default:\n        stackMapTableEntries.putByte(Frame.FULL_FRAME).putShort(offsetDelta).putShort(numLocal);\n        putAbstractTypes(3, 3 + numLocal);\n        stackMapTableEntries.putShort(numStack);\n        putAbstractTypes(3 + numLocal, 3 + numLocal + numStack);\n        break;\n    }\n  }\n\n  /**\n   * Puts some abstract types of {@link #currentFrame} in {@link #stackMapTableEntries} , using the\n   * JVMS verification_type_info format used in StackMapTable attributes.\n   *\n   * @param start index of the first type in {@link #currentFrame} to write.\n   * @param end index of last type in {@link #currentFrame} to write (exclusive).\n   */\n  private void putAbstractTypes(final int start, final int end) {\n    for (int i = start; i < end; ++i) {\n      Frame.putAbstractType(symbolTable, currentFrame[i], stackMapTableEntries);\n    }\n  }\n\n  /**\n   * Puts the given public API frame element type in {@link #stackMapTableEntries} , using the JVMS\n   * verification_type_info format used in StackMapTable attributes.\n   *\n   * @param type a frame element type described using the same format as in {@link\n   *     MethodVisitor#visitFrame}, i.e. either {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link\n   *     Opcodes#FLOAT}, {@link Opcodes#LONG}, {@link Opcodes#DOUBLE}, {@link Opcodes#NULL}, or\n   *     {@link Opcodes#UNINITIALIZED_THIS}, or the internal name of a class, or a Label designating\n   *     a NEW instruction (for uninitialized types).\n   */\n  private void putFrameType(final Object type) {\n    if (type instanceof Integer) {\n      stackMapTableEntries.putByte(((Integer) type).intValue());\n    } else if (type instanceof String) {\n      stackMapTableEntries\n          .putByte(Frame.ITEM_OBJECT)\n          .putShort(symbolTable.addConstantClass((String) type).index);\n    } else {\n      stackMapTableEntries.putByte(Frame.ITEM_UNINITIALIZED);\n      ((Label) type).put(stackMapTableEntries);\n    }\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Utility methods\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Returns whether the attributes of this method can be copied from the attributes of the given\n   * method (assuming there is no method visitor between the given ClassReader and this\n   * MethodWriter). This method should only be called just after this MethodWriter has been created,\n   * and before any content is visited. It returns true if the attributes corresponding to the\n   * constructor arguments (at most a Signature, an Exception, a Deprecated and a Synthetic\n   * attribute) are the same as the corresponding attributes in the given method.\n   *\n   * @param source the source ClassReader from which the attributes of this method might be copied.\n   * @param hasSyntheticAttribute whether the method_info JVMS structure from which the attributes\n   *     of this method might be copied contains a Synthetic attribute.\n   * @param hasDeprecatedAttribute whether the method_info JVMS structure from which the attributes\n   *     of this method might be copied contains a Deprecated attribute.\n   * @param descriptorIndex the descriptor_index field of the method_info JVMS structure from which\n   *     the attributes of this method might be copied.\n   * @param signatureIndex the constant pool index contained in the Signature attribute of the\n   *     method_info JVMS structure from which the attributes of this method might be copied, or 0.\n   * @param exceptionsOffset the offset in 'source.b' of the Exceptions attribute of the method_info\n   *     JVMS structure from which the attributes of this method might be copied, or 0.\n   * @return whether the attributes of this method can be copied from the attributes of the\n   *     method_info JVMS structure in 'source.b', between 'methodInfoOffset' and 'methodInfoOffset'\n   *     + 'methodInfoLength'.\n   */\n  boolean canCopyMethodAttributes(\n      final ClassReader source,\n      final boolean hasSyntheticAttribute,\n      final boolean hasDeprecatedAttribute,\n      final int descriptorIndex,\n      final int signatureIndex,\n      final int exceptionsOffset) {\n    // If the method descriptor has changed, with more locals than the max_locals field of the\n    // original Code attribute, if any, then the original method attributes can't be copied. A\n    // conservative check on the descriptor changes alone ensures this (being more precise is not\n    // worth the additional complexity, because these cases should be rare -- if a transform changes\n    // a method descriptor, most of the time it needs to change the method's code too).\n    if (source != symbolTable.getSource()\n        || descriptorIndex != this.descriptorIndex\n        || signatureIndex != this.signatureIndex\n        || hasDeprecatedAttribute != ((accessFlags & Opcodes.ACC_DEPRECATED) != 0)) {\n      return false;\n    }\n    boolean needSyntheticAttribute =\n        symbolTable.getMajorVersion() < Opcodes.V1_5 && (accessFlags & Opcodes.ACC_SYNTHETIC) != 0;\n    if (hasSyntheticAttribute != needSyntheticAttribute) {\n      return false;\n    }\n    if (exceptionsOffset == 0) {\n      if (numberOfExceptions != 0) {\n        return false;\n      }\n    } else if (source.readUnsignedShort(exceptionsOffset) == numberOfExceptions) {\n      int currentExceptionOffset = exceptionsOffset + 2;\n      for (int i = 0; i < numberOfExceptions; ++i) {\n        if (source.readUnsignedShort(currentExceptionOffset) != exceptionIndexTable[i]) {\n          return false;\n        }\n        currentExceptionOffset += 2;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Sets the source from which the attributes of this method will be copied.\n   *\n   * @param methodInfoOffset the offset in 'symbolTable.getSource()' of the method_info JVMS\n   *     structure from which the attributes of this method will be copied.\n   * @param methodInfoLength the length in 'symbolTable.getSource()' of the method_info JVMS\n   *     structure from which the attributes of this method will be copied.\n   */\n  void setMethodAttributesSource(final int methodInfoOffset, final int methodInfoLength) {\n    // Don't copy the attributes yet, instead store their location in the source class reader so\n    // they can be copied later, in {@link #putMethodInfo}. Note that we skip the 6 header bytes\n    // of the method_info JVMS structure.\n    this.sourceOffset = methodInfoOffset + 6;\n    this.sourceLength = methodInfoLength - 6;\n  }\n\n  /**\n   * Returns the size of the method_info JVMS structure generated by this MethodWriter. Also add the\n   * names of the attributes of this method in the constant pool.\n   *\n   * @return the size in bytes of the method_info JVMS structure.\n   */\n  int computeMethodInfoSize() {\n    // If this method_info must be copied from an existing one, the size computation is trivial.\n    if (sourceOffset != 0) {\n      // sourceLength excludes the first 6 bytes for access_flags, name_index and descriptor_index.\n      return 6 + sourceLength;\n    }\n    // 2 bytes each for access_flags, name_index, descriptor_index and attributes_count.\n    int size = 8;\n    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\n    if (code.length > 0) {\n      if (code.length > 65535) {\n        throw new MethodTooLargeException(\n            symbolTable.getClassName(), name, descriptor, code.length);\n      }\n      symbolTable.addConstantUtf8(Constants.CODE);\n      // The Code attribute has 6 header bytes, plus 2, 2, 4 and 2 bytes respectively for max_stack,\n      // max_locals, code_length and attributes_count, plus the bytecode and the exception table.\n      size += 16 + code.length + Handler.getExceptionTableSize(firstHandler);\n      if (stackMapTableEntries != null) {\n        boolean useStackMapTable = symbolTable.getMajorVersion() >= Opcodes.V1_6;\n        symbolTable.addConstantUtf8(useStackMapTable ? Constants.STACK_MAP_TABLE : \"StackMap\");\n        // 6 header bytes and 2 bytes for number_of_entries.\n        size += 8 + stackMapTableEntries.length;\n      }\n      if (lineNumberTable != null) {\n        symbolTable.addConstantUtf8(Constants.LINE_NUMBER_TABLE);\n        // 6 header bytes and 2 bytes for line_number_table_length.\n        size += 8 + lineNumberTable.length;\n      }\n      if (localVariableTable != null) {\n        symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TABLE);\n        // 6 header bytes and 2 bytes for local_variable_table_length.\n        size += 8 + localVariableTable.length;\n      }\n      if (localVariableTypeTable != null) {\n        symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TYPE_TABLE);\n        // 6 header bytes and 2 bytes for local_variable_type_table_length.\n        size += 8 + localVariableTypeTable.length;\n      }\n      if (lastCodeRuntimeVisibleTypeAnnotation != null) {\n        size +=\n            lastCodeRuntimeVisibleTypeAnnotation.computeAnnotationsSize(\n                Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\n      }\n      if (lastCodeRuntimeInvisibleTypeAnnotation != null) {\n        size +=\n            lastCodeRuntimeInvisibleTypeAnnotation.computeAnnotationsSize(\n                Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\n      }\n      if (firstCodeAttribute != null) {\n        size +=\n            firstCodeAttribute.computeAttributesSize(\n                symbolTable, code.data, code.length, maxStack, maxLocals);\n      }\n    }\n    if (numberOfExceptions > 0) {\n      symbolTable.addConstantUtf8(Constants.EXCEPTIONS);\n      size += 8 + 2 * numberOfExceptions;\n    }\n    size += Attribute.computeAttributesSize(symbolTable, accessFlags, signatureIndex);\n    size +=\n        AnnotationWriter.computeAnnotationsSize(\n            lastRuntimeVisibleAnnotation,\n            lastRuntimeInvisibleAnnotation,\n            lastRuntimeVisibleTypeAnnotation,\n            lastRuntimeInvisibleTypeAnnotation);\n    if (lastRuntimeVisibleParameterAnnotations != null) {\n      size +=\n          AnnotationWriter.computeParameterAnnotationsSize(\n              Constants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS,\n              lastRuntimeVisibleParameterAnnotations,\n              visibleAnnotableParameterCount == 0\n                  ? lastRuntimeVisibleParameterAnnotations.length\n                  : visibleAnnotableParameterCount);\n    }\n    if (lastRuntimeInvisibleParameterAnnotations != null) {\n      size +=\n          AnnotationWriter.computeParameterAnnotationsSize(\n              Constants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS,\n              lastRuntimeInvisibleParameterAnnotations,\n              invisibleAnnotableParameterCount == 0\n                  ? lastRuntimeInvisibleParameterAnnotations.length\n                  : invisibleAnnotableParameterCount);\n    }\n    if (defaultValue != null) {\n      symbolTable.addConstantUtf8(Constants.ANNOTATION_DEFAULT);\n      size += 6 + defaultValue.length;\n    }\n    if (parameters != null) {\n      symbolTable.addConstantUtf8(Constants.METHOD_PARAMETERS);\n      // 6 header bytes and 1 byte for parameters_count.\n      size += 7 + parameters.length;\n    }\n    if (firstAttribute != null) {\n      size += firstAttribute.computeAttributesSize(symbolTable);\n    }\n    return size;\n  }\n\n  /**\n   * Puts the content of the method_info JVMS structure generated by this MethodWriter into the\n   * given ByteVector.\n   *\n   * @param output where the method_info structure must be put.\n   */\n  void putMethodInfo(final ByteVector output) {\n    boolean useSyntheticAttribute = symbolTable.getMajorVersion() < Opcodes.V1_5;\n    int mask = useSyntheticAttribute ? Opcodes.ACC_SYNTHETIC : 0;\n    output.putShort(accessFlags & ~mask).putShort(nameIndex).putShort(descriptorIndex);\n    // If this method_info must be copied from an existing one, copy it now and return early.\n    if (sourceOffset != 0) {\n      output.putByteArray(symbolTable.getSource().classFileBuffer, sourceOffset, sourceLength);\n      return;\n    }\n    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\n    int attributeCount = 0;\n    if (code.length > 0) {\n      ++attributeCount;\n    }\n    if (numberOfExceptions > 0) {\n      ++attributeCount;\n    }\n    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && useSyntheticAttribute) {\n      ++attributeCount;\n    }\n    if (signatureIndex != 0) {\n      ++attributeCount;\n    }\n    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {\n      ++attributeCount;\n    }\n    if (lastRuntimeVisibleAnnotation != null) {\n      ++attributeCount;\n    }\n    if (lastRuntimeInvisibleAnnotation != null) {\n      ++attributeCount;\n    }\n    if (lastRuntimeVisibleParameterAnnotations != null) {\n      ++attributeCount;\n    }\n    if (lastRuntimeInvisibleParameterAnnotations != null) {\n      ++attributeCount;\n    }\n    if (lastRuntimeVisibleTypeAnnotation != null) {\n      ++attributeCount;\n    }\n    if (lastRuntimeInvisibleTypeAnnotation != null) {\n      ++attributeCount;\n    }\n    if (defaultValue != null) {\n      ++attributeCount;\n    }\n    if (parameters != null) {\n      ++attributeCount;\n    }\n    if (firstAttribute != null) {\n      attributeCount += firstAttribute.getAttributeCount();\n    }\n    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\n    output.putShort(attributeCount);\n    if (code.length > 0) {\n      // 2, 2, 4 and 2 bytes respectively for max_stack, max_locals, code_length and\n      // attributes_count, plus the bytecode and the exception table.\n      int size = 10 + code.length + Handler.getExceptionTableSize(firstHandler);\n      int codeAttributeCount = 0;\n      if (stackMapTableEntries != null) {\n        // 6 header bytes and 2 bytes for number_of_entries.\n        size += 8 + stackMapTableEntries.length;\n        ++codeAttributeCount;\n      }\n      if (lineNumberTable != null) {\n        // 6 header bytes and 2 bytes for line_number_table_length.\n        size += 8 + lineNumberTable.length;\n        ++codeAttributeCount;\n      }\n      if (localVariableTable != null) {\n        // 6 header bytes and 2 bytes for local_variable_table_length.\n        size += 8 + localVariableTable.length;\n        ++codeAttributeCount;\n      }\n      if (localVariableTypeTable != null) {\n        // 6 header bytes and 2 bytes for local_variable_type_table_length.\n        size += 8 + localVariableTypeTable.length;\n        ++codeAttributeCount;\n      }\n      if (lastCodeRuntimeVisibleTypeAnnotation != null) {\n        size +=\n            lastCodeRuntimeVisibleTypeAnnotation.computeAnnotationsSize(\n                Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\n        ++codeAttributeCount;\n      }\n      if (lastCodeRuntimeInvisibleTypeAnnotation != null) {\n        size +=\n            lastCodeRuntimeInvisibleTypeAnnotation.computeAnnotationsSize(\n                Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\n        ++codeAttributeCount;\n      }\n      if (firstCodeAttribute != null) {\n        size +=\n            firstCodeAttribute.computeAttributesSize(\n                symbolTable, code.data, code.length, maxStack, maxLocals);\n        codeAttributeCount += firstCodeAttribute.getAttributeCount();\n      }\n      output\n          .putShort(symbolTable.addConstantUtf8(Constants.CODE))\n          .putInt(size)\n          .putShort(maxStack)\n          .putShort(maxLocals)\n          .putInt(code.length)\n          .putByteArray(code.data, 0, code.length);\n      Handler.putExceptionTable(firstHandler, output);\n      output.putShort(codeAttributeCount);\n      if (stackMapTableEntries != null) {\n        boolean useStackMapTable = symbolTable.getMajorVersion() >= Opcodes.V1_6;\n        output\n            .putShort(\n                symbolTable.addConstantUtf8(\n                    useStackMapTable ? Constants.STACK_MAP_TABLE : \"StackMap\"))\n            .putInt(2 + stackMapTableEntries.length)\n            .putShort(stackMapTableNumberOfEntries)\n            .putByteArray(stackMapTableEntries.data, 0, stackMapTableEntries.length);\n      }\n      if (lineNumberTable != null) {\n        output\n            .putShort(symbolTable.addConstantUtf8(Constants.LINE_NUMBER_TABLE))\n            .putInt(2 + lineNumberTable.length)\n            .putShort(lineNumberTableLength)\n            .putByteArray(lineNumberTable.data, 0, lineNumberTable.length);\n      }\n      if (localVariableTable != null) {\n        output\n            .putShort(symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TABLE))\n            .putInt(2 + localVariableTable.length)\n            .putShort(localVariableTableLength)\n            .putByteArray(localVariableTable.data, 0, localVariableTable.length);\n      }\n      if (localVariableTypeTable != null) {\n        output\n            .putShort(symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TYPE_TABLE))\n            .putInt(2 + localVariableTypeTable.length)\n            .putShort(localVariableTypeTableLength)\n            .putByteArray(localVariableTypeTable.data, 0, localVariableTypeTable.length);\n      }\n      if (lastCodeRuntimeVisibleTypeAnnotation != null) {\n        lastCodeRuntimeVisibleTypeAnnotation.putAnnotations(\n            symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS), output);\n      }\n      if (lastCodeRuntimeInvisibleTypeAnnotation != null) {\n        lastCodeRuntimeInvisibleTypeAnnotation.putAnnotations(\n            symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS), output);\n      }\n      if (firstCodeAttribute != null) {\n        firstCodeAttribute.putAttributes(\n            symbolTable, code.data, code.length, maxStack, maxLocals, output);\n      }\n    }\n    if (numberOfExceptions > 0) {\n      output\n          .putShort(symbolTable.addConstantUtf8(Constants.EXCEPTIONS))\n          .putInt(2 + 2 * numberOfExceptions)\n          .putShort(numberOfExceptions);\n      for (int exceptionIndex : exceptionIndexTable) {\n        output.putShort(exceptionIndex);\n      }\n    }\n    Attribute.putAttributes(symbolTable, accessFlags, signatureIndex, output);\n    AnnotationWriter.putAnnotations(\n        symbolTable,\n        lastRuntimeVisibleAnnotation,\n        lastRuntimeInvisibleAnnotation,\n        lastRuntimeVisibleTypeAnnotation,\n        lastRuntimeInvisibleTypeAnnotation,\n        output);\n    if (lastRuntimeVisibleParameterAnnotations != null) {\n      AnnotationWriter.putParameterAnnotations(\n          symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS),\n          lastRuntimeVisibleParameterAnnotations,\n          visibleAnnotableParameterCount == 0\n              ? lastRuntimeVisibleParameterAnnotations.length\n              : visibleAnnotableParameterCount,\n          output);\n    }\n    if (lastRuntimeInvisibleParameterAnnotations != null) {\n      AnnotationWriter.putParameterAnnotations(\n          symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS),\n          lastRuntimeInvisibleParameterAnnotations,\n          invisibleAnnotableParameterCount == 0\n              ? lastRuntimeInvisibleParameterAnnotations.length\n              : invisibleAnnotableParameterCount,\n          output);\n    }\n    if (defaultValue != null) {\n      output\n          .putShort(symbolTable.addConstantUtf8(Constants.ANNOTATION_DEFAULT))\n          .putInt(defaultValue.length)\n          .putByteArray(defaultValue.data, 0, defaultValue.length);\n    }\n    if (parameters != null) {\n      output\n          .putShort(symbolTable.addConstantUtf8(Constants.METHOD_PARAMETERS))\n          .putInt(1 + parameters.length)\n          .putByte(parametersCount)\n          .putByteArray(parameters.data, 0, parameters.length);\n    }\n    if (firstAttribute != null) {\n      firstAttribute.putAttributes(symbolTable, output);\n    }\n  }\n\n  /**\n   * Collects the attributes of this method into the given set of attribute prototypes.\n   *\n   * @param attributePrototypes a set of attribute prototypes.\n   */\n  final void collectAttributePrototypes(final Attribute.Set attributePrototypes) {\n    attributePrototypes.addAttributes(firstAttribute);\n    attributePrototypes.addAttributes(firstCodeAttribute);\n  }\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.asm.MethodWriter",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.MethodWriter#COMPUTE_NOTHING",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.MethodWriter#COMPUTE_NOTHING",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.MethodWriter",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.MethodWriter#COMPUTE_MAX_STACK_AND_LOCAL",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.MethodWriter#COMPUTE_MAX_STACK_AND_LOCAL",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.MethodWriter",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.MethodWriter#COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.MethodWriter#COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.MethodWriter",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.MethodWriter#COMPUTE_INSERTED_FRAMES",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.MethodWriter#COMPUTE_INSERTED_FRAMES",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  }
]