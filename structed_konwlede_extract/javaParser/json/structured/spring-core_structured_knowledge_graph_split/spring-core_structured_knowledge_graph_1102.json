[
  {
    "head": "org.springframework.core.MetadataLookup",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.ReflectionUtils;\n\n/**\n * Defines the algorithm for searching for metadata-associated methods exhaustively\n * including interfaces and parent classes while also dealing with parameterized methods\n * as well as common scenarios encountered with interface and class-based proxies.\n *\n * <p>Typically, but not necessarily, used for finding annotated handler methods.\n *\n * @author Juergen Hoeller\n * @author Rossen Stoyanchev\n * @author Sam Brannen\n * @since 4.2.3\n */\npublic final class MethodIntrospector {\n\n\tprivate MethodIntrospector() {\n\t}\n\n\n\t/**\n\t * Select methods on the given target type based on the lookup of associated metadata.\n\t * <p>Callers define methods of interest through the {@link MetadataLookup} parameter,\n\t * allowing to collect the associated metadata into the result map.\n\t * @param targetType the target type to search methods on\n\t * @param metadataLookup a {@link MetadataLookup} callback to inspect methods of interest,\n\t * returning non-null metadata to be associated with a given method if there is a match,\n\t * or {@code null} for no match\n\t * @return the selected methods associated with their metadata (in the order of retrieval),\n\t * or an empty map in case of no match\n\t */\n\tpublic static <T> Map<Method, T> selectMethods(Class<?> targetType, final MetadataLookup<T> metadataLookup) {\n\t\tfinal Map<Method, T> methodMap = new LinkedHashMap<>();\n\t\tSet<Class<?>> handlerTypes = new LinkedHashSet<>();\n\t\tClass<?> specificHandlerType = null;\n\n\t\tif (!Proxy.isProxyClass(targetType)) {\n\t\t\tspecificHandlerType = ClassUtils.getUserClass(targetType);\n\t\t\thandlerTypes.add(specificHandlerType);\n\t\t}\n\t\thandlerTypes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetType));\n\n\t\tfor (Class<?> currentHandlerType : handlerTypes) {\n\t\t\tfinal Class<?> targetClass = (specificHandlerType != null ? specificHandlerType : currentHandlerType);\n\n\t\t\tReflectionUtils.doWithMethods(currentHandlerType, method -> {\n\t\t\t\tMethod specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass);\n\t\t\t\tT result = metadataLookup.inspect(specificMethod);\n\t\t\t\tif (result != null) {\n\t\t\t\t\tMethod bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);\n\t\t\t\t\tif (bridgedMethod == specificMethod || bridgedMethod == method ||\n\t\t\t\t\t\t\tbridgedMethod.equals(specificMethod) || bridgedMethod.equals(method) ||\n\t\t\t\t\t\t\tmetadataLookup.inspect(bridgedMethod) == null) {\n\t\t\t\t\t\tmethodMap.put(specificMethod, result);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, ReflectionUtils.USER_DECLARED_METHODS);\n\t\t}\n\n\t\treturn methodMap;\n\t}\n\n\t/**\n\t * Select methods on the given target type based on a filter.\n\t * <p>Callers define methods of interest through the {@code MethodFilter} parameter.\n\t * @param targetType the target type to search methods on\n\t * @param methodFilter a {@code MethodFilter} to help\n\t * recognize handler methods of interest\n\t * @return the selected methods, or an empty set in case of no match\n\t */\n\tpublic static Set<Method> selectMethods(Class<?> targetType, final ReflectionUtils.MethodFilter methodFilter) {\n\t\treturn selectMethods(targetType,\n\t\t\t\t(MetadataLookup<Boolean>) method -> (methodFilter.matches(method) ? Boolean.TRUE : null)).keySet();\n\t}\n\n\t/**\n\t * Select an invocable method on the target type: either the given method itself\n\t * if actually exposed on the target type, or otherwise a corresponding method\n\t * on one of the target type's interfaces or on the target type itself.\n\t * <p>Matches on user-declared interfaces will be preferred since they are likely\n\t * to contain relevant metadata that corresponds to the method on the target class.\n\t * @param method the method to check\n\t * @param targetType the target type to search methods on\n\t * (typically an interface-based JDK proxy)\n\t * @return a corresponding invocable method on the target type\n\t * @throws IllegalStateException if the given method is not invocable on the given\n\t * target type (typically due to a proxy mismatch)\n\t */\n\tpublic static Method selectInvocableMethod(Method method, Class<?> targetType) {\n\t\tif (method.getDeclaringClass().isAssignableFrom(targetType)) {\n\t\t\treturn method;\n\t\t}\n\t\ttry {\n\t\t\tString methodName = method.getName();\n\t\t\tClass<?>[] parameterTypes = method.getParameterTypes();\n\t\t\tfor (Class<?> ifc : targetType.getInterfaces()) {\n\t\t\t\ttry {\n\t\t\t\t\treturn ifc.getMethod(methodName, parameterTypes);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t// Alright, not on this interface then...\n\t\t\t\t}\n\t\t\t}\n\t\t\t// A final desperate attempt on the proxy class itself...\n\t\t\treturn targetType.getMethod(methodName, parameterTypes);\n\t\t}\n\t\tcatch (NoSuchMethodException ex) {\n\t\t\tthrow new IllegalStateException(String.format(\n\t\t\t\t\t\"Need to invoke method '%s' declared on target class '%s', \" +\n\t\t\t\t\t\"but not found in any interface(s) of the exposed proxy type. \" +\n\t\t\t\t\t\"Either pull the method up to an interface or switch to CGLIB \" +\n\t\t\t\t\t\"proxies by enforcing proxy-target-class mode in your configuration.\",\n\t\t\t\t\tmethod.getName(), method.getDeclaringClass().getSimpleName()));\n\t\t}\n\t}\n\n\n\t/**\n\t * A callback interface for metadata lookup on a given method.\n\t * @param <T> the type of metadata returned\n\t */\n\t@FunctionalInterface\n\tpublic interface MetadataLookup<T> {\n\n\t\t/**\n\t\t * Perform a lookup on the given method and return associated metadata, if any.\n\t\t * @param method the method to inspect\n\t\t * @return non-null metadata to be associated with a method if there is a match,\n\t\t * or {@code null} for no match\n\t\t */\n\t\t@Nullable T inspect(Method method);\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.MetadataLookup#inspect(Method)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Perform a lookup on the given method and return associated metadata, if any.\r\n * @param method the method to inspect\r\n * @return non-null metadata to be associated with a method if there is a match,\r\n * or {@code null} for no match\r\n */\r\n@Nullable\r\nT inspect(Method method);",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.MetadataLookup",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.MetadataLookup#inspect(Method)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.MetadataLookup#inspect(Method)",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.MethodParameter",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.MethodParameter",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Executable;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.function.Predicate;\n\nimport kotlin.Unit;\nimport kotlin.reflect.KFunction;\nimport kotlin.reflect.KParameter;\nimport kotlin.reflect.jvm.ReflectJvmMapping;\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.ObjectUtils;\n\n/**\n * Helper class that encapsulates the specification of a method parameter, i.e. a {@link Method}\n * or {@link Constructor} plus a parameter index and a nested type index for a declared generic\n * type. Useful as a specification object to pass along.\n *\n * <p>As of 4.2, there is a {@link org.springframework.core.annotation.SynthesizingMethodParameter}\n * subclass available which synthesizes annotations with attribute aliases. That subclass is used\n * for web and message endpoint processing, in particular.\n *\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Andy Clement\n * @author Sam Brannen\n * @author Sebastien Deleuze\n * @author Phillip Webb\n * @since 2.0\n * @see org.springframework.core.annotation.SynthesizingMethodParameter\n */\npublic class MethodParameter {\n\n\tprivate static final Annotation[] EMPTY_ANNOTATION_ARRAY = new Annotation[0];\n\n\n\tprivate final Executable executable;\n\n\tprivate final int parameterIndex;\n\n\tprivate volatile @Nullable Parameter parameter;\n\n\tprivate int nestingLevel;\n\n\t/** Map from Integer level to Integer type index. */\n\t@Nullable Map<Integer, Integer> typeIndexesPerLevel;\n\n\t/** The containing class. Could also be supplied by overriding {@link #getContainingClass()} */\n\tprivate volatile @Nullable Class<?> containingClass;\n\n\tprivate volatile @Nullable Class<?> parameterType;\n\n\tprivate volatile @Nullable Type genericParameterType;\n\n\tprivate volatile Annotation @Nullable [] parameterAnnotations;\n\n\tprivate volatile @Nullable ParameterNameDiscoverer parameterNameDiscoverer;\n\n\tvolatile @Nullable String parameterName;\n\n\tprivate volatile @Nullable MethodParameter nestedMethodParameter;\n\n\n\t/**\n\t * Create a new {@code MethodParameter} for the given method, with nesting level 1.\n\t * @param method the Method to specify a parameter for\n\t * @param parameterIndex the index of the parameter: -1 for the method\n\t * return type; 0 for the first method parameter; 1 for the second method\n\t * parameter, etc.\n\t */\n\tpublic MethodParameter(Method method, int parameterIndex) {\n\t\tthis(method, parameterIndex, 1);\n\t}\n\n\t/**\n\t * Create a new {@code MethodParameter} for the given method.\n\t * @param method the Method to specify a parameter for\n\t * @param parameterIndex the index of the parameter: -1 for the method\n\t * return type; 0 for the first method parameter; 1 for the second method\n\t * parameter, etc.\n\t * @param nestingLevel the nesting level of the target type\n\t * (typically 1; for example, in case of a List of Lists, 1 would indicate the\n\t * nested List, whereas 2 would indicate the element of the nested List)\n\t */\n\tpublic MethodParameter(Method method, int parameterIndex, int nestingLevel) {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\tthis.executable = method;\n\t\tthis.parameterIndex = validateIndex(method, parameterIndex);\n\t\tthis.nestingLevel = nestingLevel;\n\t}\n\n\t/**\n\t * Create a new MethodParameter for the given constructor, with nesting level 1.\n\t * @param constructor the Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t */\n\tpublic MethodParameter(Constructor<?> constructor, int parameterIndex) {\n\t\tthis(constructor, parameterIndex, 1);\n\t}\n\n\t/**\n\t * Create a new MethodParameter for the given constructor.\n\t * @param constructor the Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @param nestingLevel the nesting level of the target type\n\t * (typically 1; for example, in case of a List of Lists, 1 would indicate the\n\t * nested List, whereas 2 would indicate the element of the nested List)\n\t */\n\tpublic MethodParameter(Constructor<?> constructor, int parameterIndex, int nestingLevel) {\n\t\tAssert.notNull(constructor, \"Constructor must not be null\");\n\t\tthis.executable = constructor;\n\t\tthis.parameterIndex = validateIndex(constructor, parameterIndex);\n\t\tthis.nestingLevel = nestingLevel;\n\t}\n\n\t/**\n\t * Internal constructor used to create a {@link MethodParameter} with a\n\t * containing class already set.\n\t * @param executable the Executable to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @param containingClass the containing class\n\t * @since 5.2\n\t */\n\tMethodParameter(Executable executable, int parameterIndex, @Nullable Class<?> containingClass) {\n\t\tAssert.notNull(executable, \"Executable must not be null\");\n\t\tthis.executable = executable;\n\t\tthis.parameterIndex = validateIndex(executable, parameterIndex);\n\t\tthis.nestingLevel = 1;\n\t\tthis.containingClass = containingClass;\n\t}\n\n\t/**\n\t * Copy constructor, resulting in an independent MethodParameter object\n\t * based on the same metadata and cache state that the original object was in.\n\t * @param original the original MethodParameter object to copy from\n\t */\n\tpublic MethodParameter(MethodParameter original) {\n\t\tAssert.notNull(original, \"Original must not be null\");\n\t\tthis.executable = original.executable;\n\t\tthis.parameterIndex = original.parameterIndex;\n\t\tthis.parameter = original.parameter;\n\t\tthis.nestingLevel = original.nestingLevel;\n\t\tthis.typeIndexesPerLevel = original.typeIndexesPerLevel;\n\t\tthis.containingClass = original.containingClass;\n\t\tthis.parameterType = original.parameterType;\n\t\tthis.genericParameterType = original.genericParameterType;\n\t\tthis.parameterAnnotations = original.parameterAnnotations;\n\t\tthis.parameterNameDiscoverer = original.parameterNameDiscoverer;\n\t\tthis.parameterName = original.parameterName;\n\t}\n\n\n\t/**\n\t * Return the wrapped Method, if any.\n\t * <p>Note: Either Method or Constructor is available.\n\t * @return the Method, or {@code null} if none\n\t */\n\tpublic @Nullable Method getMethod() {\n\t\treturn (this.executable instanceof Method method ? method : null);\n\t}\n\n\t/**\n\t * Return the wrapped Constructor, if any.\n\t * <p>Note: Either Method or Constructor is available.\n\t * @return the Constructor, or {@code null} if none\n\t */\n\tpublic @Nullable Constructor<?> getConstructor() {\n\t\treturn (this.executable instanceof Constructor<?> constructor ? constructor : null);\n\t}\n\n\t/**\n\t * Return the class that declares the underlying Method or Constructor.\n\t */\n\tpublic Class<?> getDeclaringClass() {\n\t\treturn this.executable.getDeclaringClass();\n\t}\n\n\t/**\n\t * Return the wrapped member.\n\t * @return the Method or Constructor as Member\n\t */\n\tpublic Member getMember() {\n\t\treturn this.executable;\n\t}\n\n\t/**\n\t * Return the wrapped annotated element.\n\t * <p>Note: This method exposes the annotations declared on the method/constructor\n\t * itself (i.e. at the method/constructor level, not at the parameter level).\n\t * <p>To get the {@link AnnotatedElement} at the parameter level, use\n\t * {@link #getParameter()}.\n\t * @return the Method or Constructor as AnnotatedElement\n\t */\n\tpublic AnnotatedElement getAnnotatedElement() {\n\t\treturn this.executable;\n\t}\n\n\t/**\n\t * Return the wrapped executable.\n\t * @return the Method or Constructor as Executable\n\t * @since 5.0\n\t */\n\tpublic Executable getExecutable() {\n\t\treturn this.executable;\n\t}\n\n\t/**\n\t * Return the {@link Parameter} descriptor for method/constructor parameter.\n\t * @since 5.0\n\t */\n\tpublic Parameter getParameter() {\n\t\tif (this.parameterIndex < 0) {\n\t\t\tthrow new IllegalStateException(\"Cannot retrieve Parameter descriptor for method return type\");\n\t\t}\n\t\tParameter parameter = this.parameter;\n\t\tif (parameter == null) {\n\t\t\tparameter = getExecutable().getParameters()[this.parameterIndex];\n\t\t\tthis.parameter = parameter;\n\t\t}\n\t\treturn parameter;\n\t}\n\n\t/**\n\t * Return the index of the method/constructor parameter.\n\t * @return the parameter index (-1 in case of the return type)\n\t */\n\tpublic int getParameterIndex() {\n\t\treturn this.parameterIndex;\n\t}\n\n\t/**\n\t * Increase this parameter's nesting level.\n\t * @see #getNestingLevel()\n\t * @deprecated since 5.2 in favor of {@link #nested(Integer)}\n\t */\n\t@Deprecated\n\tpublic void increaseNestingLevel() {\n\t\tthis.nestingLevel++;\n\t}\n\n\t/**\n\t * Decrease this parameter's nesting level.\n\t * @see #getNestingLevel()\n\t * @deprecated since 5.2 in favor of retaining the original MethodParameter and\n\t * using {@link #nested(Integer)} if nesting is required\n\t */\n\t@Deprecated\n\tpublic void decreaseNestingLevel() {\n\t\tgetTypeIndexesPerLevel().remove(this.nestingLevel);\n\t\tthis.nestingLevel--;\n\t}\n\n\t/**\n\t * Return the nesting level of the target type\n\t * (typically 1; for example, in case of a List of Lists, 1 would indicate the\n\t * nested List, whereas 2 would indicate the element of the nested List).\n\t */\n\tpublic int getNestingLevel() {\n\t\treturn this.nestingLevel;\n\t}\n\n\t/**\n\t * Return a variant of this {@code MethodParameter} with the type\n\t * for the current level set to the specified value.\n\t * @param typeIndex the new type index\n\t * @since 5.2\n\t */\n\tpublic MethodParameter withTypeIndex(int typeIndex) {\n\t\treturn nested(this.nestingLevel, typeIndex);\n\t}\n\n\t/**\n\t * Set the type index for the current nesting level.\n\t * @param typeIndex the corresponding type index\n\t * (or {@code null} for the default type index)\n\t * @see #getNestingLevel()\n\t * @deprecated since 5.2 in favor of {@link #withTypeIndex}\n\t */\n\t@Deprecated\n\tpublic void setTypeIndexForCurrentLevel(int typeIndex) {\n\t\tgetTypeIndexesPerLevel().put(this.nestingLevel, typeIndex);\n\t}\n\n\t/**\n\t * Return the type index for the current nesting level.\n\t * @return the corresponding type index, or {@code null}\n\t * if none specified (indicating the default type index)\n\t * @see #getNestingLevel()\n\t */\n\tpublic @Nullable Integer getTypeIndexForCurrentLevel() {\n\t\treturn getTypeIndexForLevel(this.nestingLevel);\n\t}\n\n\t/**\n\t * Return the type index for the specified nesting level.\n\t * @param nestingLevel the nesting level to check\n\t * @return the corresponding type index, or {@code null}\n\t * if none specified (indicating the default type index)\n\t */\n\tpublic @Nullable Integer getTypeIndexForLevel(int nestingLevel) {\n\t\treturn getTypeIndexesPerLevel().get(nestingLevel);\n\t}\n\n\t/**\n\t * Obtain the (lazily constructed) type-indexes-per-level Map.\n\t */\n\tprivate Map<Integer, Integer> getTypeIndexesPerLevel() {\n\t\tif (this.typeIndexesPerLevel == null) {\n\t\t\tthis.typeIndexesPerLevel = new HashMap<>(4);\n\t\t}\n\t\treturn this.typeIndexesPerLevel;\n\t}\n\n\t/**\n\t * Return a variant of this {@code MethodParameter} which points to the\n\t * same parameter but one nesting level deeper.\n\t * @since 4.3\n\t */\n\tpublic MethodParameter nested() {\n\t\treturn nested(null);\n\t}\n\n\t/**\n\t * Return a variant of this {@code MethodParameter} which points to the\n\t * same parameter but one nesting level deeper.\n\t * @param typeIndex the type index for the new nesting level\n\t * @since 5.2\n\t */\n\tpublic MethodParameter nested(@Nullable Integer typeIndex) {\n\t\tMethodParameter nestedParam = this.nestedMethodParameter;\n\t\tif (nestedParam != null && typeIndex == null) {\n\t\t\treturn nestedParam;\n\t\t}\n\t\tnestedParam = nested(this.nestingLevel + 1, typeIndex);\n\t\tif (typeIndex == null) {\n\t\t\tthis.nestedMethodParameter = nestedParam;\n\t\t}\n\t\treturn nestedParam;\n\t}\n\n\tprivate MethodParameter nested(int nestingLevel, @Nullable Integer typeIndex) {\n\t\tMethodParameter copy = clone();\n\t\tcopy.nestingLevel = nestingLevel;\n\t\tif (this.typeIndexesPerLevel != null) {\n\t\t\tcopy.typeIndexesPerLevel = new HashMap<>(this.typeIndexesPerLevel);\n\t\t}\n\t\tif (typeIndex != null) {\n\t\t\tcopy.getTypeIndexesPerLevel().put(copy.nestingLevel, typeIndex);\n\t\t}\n\t\tcopy.parameterType = null;\n\t\tcopy.genericParameterType = null;\n\t\treturn copy;\n\t}\n\n\t/**\n\t * Return whether this method indicates a parameter which is not required:\n\t * either in the form of Java 8's {@link java.util.Optional}, JSpecify annotations,\n\t * any variant of a parameter-level {@code @Nullable} annotation (such as from Spring,\n\t * JSR-305 or Jakarta set of annotations), a language-level nullable type\n\t * declaration or {@code Continuation} parameter in Kotlin.\n\t * @since 4.3\n\t * @see Nullness#forMethodParameter(MethodParameter)\n\t */\n\tpublic boolean isOptional() {\n\t\treturn (getParameterType() == Optional.class || Nullness.forMethodParameter(this) == Nullness.NULLABLE ||\n\t\t\t\t(KotlinDetector.isKotlinType(getContainingClass()) && KotlinDelegate.isOptional(this)));\n\t}\n\n\t/**\n\t * Return a variant of this {@code MethodParameter} which points to\n\t * the same parameter but one nesting level deeper in case of a\n\t * {@link java.util.Optional} declaration.\n\t * @since 4.3\n\t * @see #isOptional()\n\t * @see #nested()\n\t */\n\tpublic MethodParameter nestedIfOptional() {\n\t\treturn (getParameterType() == Optional.class ? nested() : this);\n\t}\n\n\t/**\n\t * Return a variant of this {@code MethodParameter} which refers to the\n\t * given containing class.\n\t * @param containingClass a specific containing class (potentially a\n\t * subclass of the declaring class, for example, substituting a type variable)\n\t * @since 5.2\n\t * @see #getParameterType()\n\t */\n\tpublic MethodParameter withContainingClass(@Nullable Class<?> containingClass) {\n\t\tMethodParameter result = clone();\n\t\tresult.containingClass = containingClass;\n\t\tresult.parameterType = null;\n\t\treturn result;\n\t}\n\n\t/**\n\t * Set a containing class to resolve the parameter type against.\n\t */\n\t@Deprecated\n\tvoid setContainingClass(Class<?> containingClass) {\n\t\tthis.containingClass = containingClass;\n\t\tthis.parameterType = null;\n\t}\n\n\t/**\n\t * Return the containing class for this method parameter.\n\t * @return a specific containing class (potentially a subclass of the\n\t * declaring class), or otherwise simply the declaring class itself\n\t * @see #getDeclaringClass()\n\t */\n\tpublic Class<?> getContainingClass() {\n\t\tClass<?> containingClass = this.containingClass;\n\t\treturn (containingClass != null ? containingClass : getDeclaringClass());\n\t}\n\n\t/**\n\t * Set a resolved (generic) parameter type.\n\t */\n\t@Deprecated\n\tvoid setParameterType(@Nullable Class<?> parameterType) {\n\t\tthis.parameterType = parameterType;\n\t}\n\n\t/**\n\t * Return the type of the method/constructor parameter.\n\t * @return the parameter type (never {@code null})\n\t */\n\tpublic Class<?> getParameterType() {\n\t\tClass<?> paramType = this.parameterType;\n\t\tif (paramType != null) {\n\t\t\treturn paramType;\n\t\t}\n\t\tif (getContainingClass() != getDeclaringClass()) {\n\t\t\tparamType = ResolvableType.forMethodParameter(this, null, 1).resolve();\n\t\t}\n\t\tif (paramType == null) {\n\t\t\tparamType = computeParameterType();\n\t\t}\n\t\tthis.parameterType = paramType;\n\t\treturn paramType;\n\t}\n\n\t/**\n\t * Return the generic type of the method/constructor parameter.\n\t * @return the parameter type (never {@code null})\n\t * @since 3.0\n\t */\n\tpublic Type getGenericParameterType() {\n\t\tType paramType = this.genericParameterType;\n\t\tif (paramType == null) {\n\t\t\tif (this.parameterIndex < 0) {\n\t\t\t\tMethod method = getMethod();\n\t\t\t\tparamType = (method != null ?\n\t\t\t\t\t\t(KotlinDetector.isKotlinType(getContainingClass()) ?\n\t\t\t\t\t\t\t\tKotlinDelegate.getGenericReturnType(method) : method.getGenericReturnType()) : void.class);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tType[] genericParameterTypes = this.executable.getGenericParameterTypes();\n\t\t\t\tint index = this.parameterIndex;\n\t\t\t\tif (this.executable instanceof Constructor &&\n\t\t\t\t\t\tClassUtils.isInnerClass(this.executable.getDeclaringClass()) &&\n\t\t\t\t\t\tgenericParameterTypes.length == this.executable.getParameterCount() - 1) {\n\t\t\t\t\t// Bug in javac: type array excludes enclosing instance parameter\n\t\t\t\t\t// for inner classes with at least one generic constructor parameter,\n\t\t\t\t\t// so access it with the actual parameter index lowered by 1\n\t\t\t\t\tindex = this.parameterIndex - 1;\n\t\t\t\t}\n\t\t\t\tparamType = (index >= 0 && index < genericParameterTypes.length ?\n\t\t\t\t\t\tgenericParameterTypes[index] : computeParameterType());\n\t\t\t}\n\t\t\tthis.genericParameterType = paramType;\n\t\t}\n\t\treturn paramType;\n\t}\n\n\tprivate Class<?> computeParameterType() {\n\t\tif (this.parameterIndex < 0) {\n\t\t\tMethod method = getMethod();\n\t\t\tif (method == null) {\n\t\t\t\treturn void.class;\n\t\t\t}\n\t\t\tif (KotlinDetector.isKotlinType(getContainingClass())) {\n\t\t\t\treturn KotlinDelegate.getReturnType(method);\n\t\t\t}\n\t\t\treturn method.getReturnType();\n\t\t}\n\t\treturn this.executable.getParameterTypes()[this.parameterIndex];\n\t}\n\n\t/**\n\t * Return the nested type of the method/constructor parameter.\n\t * @return the parameter type (never {@code null})\n\t * @since 3.1\n\t * @see #getNestingLevel()\n\t */\n\tpublic Class<?> getNestedParameterType() {\n\t\tif (this.nestingLevel > 1) {\n\t\t\tType type = getGenericParameterType();\n\t\t\tfor (int i = 2; i <= this.nestingLevel; i++) {\n\t\t\t\tif (type instanceof ParameterizedType parameterizedType) {\n\t\t\t\t\tType[] args = parameterizedType.getActualTypeArguments();\n\t\t\t\t\tInteger index = getTypeIndexForLevel(i);\n\t\t\t\t\ttype = args[index != null ? index : args.length - 1];\n\t\t\t\t}\n\t\t\t\t// TODO: Object.class if unresolvable\n\t\t\t}\n\t\t\tif (type instanceof Class<?> clazz) {\n\t\t\t\treturn clazz;\n\t\t\t}\n\t\t\telse if (type instanceof ParameterizedType parameterizedType) {\n\t\t\t\tType arg = parameterizedType.getRawType();\n\t\t\t\tif (arg instanceof Class<?> clazz) {\n\t\t\t\t\treturn clazz;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Object.class;\n\t\t}\n\t\telse {\n\t\t\treturn getParameterType();\n\t\t}\n\t}\n\n\t/**\n\t * Return the nested generic type of the method/constructor parameter.\n\t * @return the parameter type (never {@code null})\n\t * @since 4.2\n\t * @see #getNestingLevel()\n\t */\n\tpublic Type getNestedGenericParameterType() {\n\t\tif (this.nestingLevel > 1) {\n\t\t\tType type = getGenericParameterType();\n\t\t\tfor (int i = 2; i <= this.nestingLevel; i++) {\n\t\t\t\tif (type instanceof ParameterizedType parameterizedType) {\n\t\t\t\t\tType[] args = parameterizedType.getActualTypeArguments();\n\t\t\t\t\tInteger index = getTypeIndexForLevel(i);\n\t\t\t\t\ttype = args[index != null ? index : args.length - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn type;\n\t\t}\n\t\telse {\n\t\t\treturn getGenericParameterType();\n\t\t}\n\t}\n\n\t/**\n\t * Return the annotations associated with the target method/constructor itself.\n\t */\n\tpublic Annotation[] getMethodAnnotations() {\n\t\treturn adaptAnnotationArray(getAnnotatedElement().getAnnotations());\n\t}\n\n\t/**\n\t * Return the method/constructor annotation of the given type, if available.\n\t * @param annotationType the annotation type to look for\n\t * @return the annotation object, or {@code null} if not found\n\t */\n\tpublic <A extends Annotation> @Nullable A getMethodAnnotation(Class<A> annotationType) {\n\t\tA annotation = getAnnotatedElement().getAnnotation(annotationType);\n\t\treturn (annotation != null ? adaptAnnotation(annotation) : null);\n\t}\n\n\t/**\n\t * Return whether the method/constructor is annotated with the given type.\n\t * @param annotationType the annotation type to look for\n\t * @since 4.3\n\t * @see #getMethodAnnotation(Class)\n\t */\n\tpublic <A extends Annotation> boolean hasMethodAnnotation(Class<A> annotationType) {\n\t\treturn getAnnotatedElement().isAnnotationPresent(annotationType);\n\t}\n\n\t/**\n\t * Return the annotations associated with the specific method/constructor parameter.\n\t */\n\tpublic Annotation[] getParameterAnnotations() {\n\t\tAnnotation[] paramAnns = this.parameterAnnotations;\n\t\tif (paramAnns == null) {\n\t\t\tAnnotation[][] annotationArray = this.executable.getParameterAnnotations();\n\t\t\tint index = this.parameterIndex;\n\t\t\tif (this.executable instanceof Constructor &&\n\t\t\t\t\tClassUtils.isInnerClass(this.executable.getDeclaringClass()) &&\n\t\t\t\t\tannotationArray.length == this.executable.getParameterCount() - 1) {\n\t\t\t\t// Bug in javac in JDK <9: annotation array excludes enclosing instance parameter\n\t\t\t\t// for inner classes, so access it with the actual parameter index lowered by 1\n\t\t\t\tindex = this.parameterIndex - 1;\n\t\t\t}\n\t\t\tparamAnns = (index >= 0 && index < annotationArray.length && annotationArray[index].length > 0 ?\n\t\t\t\t\tadaptAnnotationArray(annotationArray[index]) : EMPTY_ANNOTATION_ARRAY);\n\t\t\tthis.parameterAnnotations = paramAnns;\n\t\t}\n\t\treturn paramAnns;\n\t}\n\n\t/**\n\t * Return {@code true} if the parameter has at least one annotation,\n\t * {@code false} if it has none.\n\t * @see #getParameterAnnotations()\n\t */\n\tpublic boolean hasParameterAnnotations() {\n\t\treturn (getParameterAnnotations().length != 0);\n\t}\n\n\t/**\n\t * Return the parameter annotation of the given type, if available.\n\t * @param annotationType the annotation type to look for\n\t * @return the annotation object, or {@code null} if not found\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <A extends Annotation> @Nullable A getParameterAnnotation(Class<A> annotationType) {\n\t\tAnnotation[] anns = getParameterAnnotations();\n\t\tfor (Annotation ann : anns) {\n\t\t\tif (annotationType.isInstance(ann)) {\n\t\t\t\treturn (A) ann;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Return whether the parameter is declared with the given annotation type.\n\t * @param annotationType the annotation type to look for\n\t * @see #getParameterAnnotation(Class)\n\t */\n\tpublic <A extends Annotation> boolean hasParameterAnnotation(Class<A> annotationType) {\n\t\treturn (getParameterAnnotation(annotationType) != null);\n\t}\n\n\t/**\n\t * Initialize parameter name discovery for this method parameter.\n\t * <p>This method does not actually try to retrieve the parameter name at\n\t * this point; it just allows discovery to happen when the application calls\n\t * {@link #getParameterName()} (if ever).\n\t */\n\tpublic void initParameterNameDiscovery(@Nullable ParameterNameDiscoverer parameterNameDiscoverer) {\n\t\tthis.parameterNameDiscoverer = parameterNameDiscoverer;\n\t}\n\n\t/**\n\t * Return the name of the method/constructor parameter.\n\t * @return the parameter name (may be {@code null} if no\n\t * parameter name metadata is contained in the class file or no\n\t * {@link #initParameterNameDiscovery ParameterNameDiscoverer}\n\t * has been set to begin with)\n\t */\n\tpublic @Nullable String getParameterName() {\n\t\tif (this.parameterIndex < 0) {\n\t\t\treturn null;\n\t\t}\n\t\tParameterNameDiscoverer discoverer = this.parameterNameDiscoverer;\n\t\tif (discoverer != null) {\n\t\t\t@Nullable String[] parameterNames = null;\n\t\t\tif (this.executable instanceof Method method) {\n\t\t\t\tparameterNames = discoverer.getParameterNames(method);\n\t\t\t}\n\t\t\telse if (this.executable instanceof Constructor<?> constructor) {\n\t\t\t\tparameterNames = discoverer.getParameterNames(constructor);\n\t\t\t}\n\t\t\tif (parameterNames != null && this.parameterIndex < parameterNames.length) {\n\t\t\t\tthis.parameterName = parameterNames[this.parameterIndex];\n\t\t\t}\n\t\t\tthis.parameterNameDiscoverer = null;\n\t\t}\n\t\treturn this.parameterName;\n\t}\n\n\n\t/**\n\t * A template method to post-process a given annotation instance before\n\t * returning it to the caller.\n\t * <p>The default implementation simply returns the given annotation as-is.\n\t * @param annotation the annotation about to be returned\n\t * @return the post-processed annotation (or simply the original one)\n\t * @since 4.2\n\t */\n\tprotected <A extends Annotation> A adaptAnnotation(A annotation) {\n\t\treturn annotation;\n\t}\n\n\t/**\n\t * A template method to post-process a given annotation array before\n\t * returning it to the caller.\n\t * <p>The default implementation simply returns the given annotation array as-is.\n\t * @param annotations the annotation array about to be returned\n\t * @return the post-processed annotation array (or simply the original one)\n\t * @since 4.2\n\t */\n\tprotected Annotation[] adaptAnnotationArray(Annotation[] annotations) {\n\t\treturn annotations;\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || (other instanceof MethodParameter that &&\n\t\t\t\tgetContainingClass() == that.getContainingClass() &&\n\t\t\t\tObjectUtils.nullSafeEquals(this.typeIndexesPerLevel, that.typeIndexesPerLevel) &&\n\t\t\t\tthis.nestingLevel == that.nestingLevel &&\n\t\t\t\tthis.parameterIndex == that.parameterIndex &&\n\t\t\t\tthis.executable.equals(that.executable)));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn (31 * this.executable.hashCode() + this.parameterIndex);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tMethod method = getMethod();\n\t\treturn (method != null ? \"method '\" + method.getName() + \"'\" : \"constructor\") +\n\t\t\t\t\" parameter \" + this.parameterIndex;\n\t}\n\n\t@Override\n\tpublic MethodParameter clone() {\n\t\treturn new MethodParameter(this);\n\t}\n\n\n\t/**\n\t * Create a new MethodParameter for the given method or constructor.\n\t * <p>This is a convenience factory method for scenarios where a\n\t * Method or Constructor reference is treated in a generic fashion.\n\t * @param methodOrConstructor the Method or Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @return the corresponding MethodParameter instance\n\t * @deprecated as of 5.0, in favor of {@link #forExecutable}\n\t */\n\t@Deprecated\n\tpublic static MethodParameter forMethodOrConstructor(Object methodOrConstructor, int parameterIndex) {\n\t\tif (!(methodOrConstructor instanceof Executable executable)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Given object [\" + methodOrConstructor + \"] is neither a Method nor a Constructor\");\n\t\t}\n\t\treturn forExecutable(executable, parameterIndex);\n\t}\n\n\t/**\n\t * Create a new MethodParameter for the given method or constructor.\n\t * <p>This is a convenience factory method for scenarios where a\n\t * Method or Constructor reference is treated in a generic fashion.\n\t * @param executable the Method or Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @return the corresponding MethodParameter instance\n\t * @since 5.0\n\t */\n\tpublic static MethodParameter forExecutable(Executable executable, int parameterIndex) {\n\t\tif (executable instanceof Method method) {\n\t\t\treturn new MethodParameter(method, parameterIndex);\n\t\t}\n\t\telse if (executable instanceof Constructor<?> constructor) {\n\t\t\treturn new MethodParameter(constructor, parameterIndex);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Not a Method/Constructor: \" + executable);\n\t\t}\n\t}\n\n\t/**\n\t * Create a new MethodParameter for the given parameter descriptor.\n\t * <p>This is a convenience factory method for scenarios where a\n\t * Java 8 {@link Parameter} descriptor is already available.\n\t * @param parameter the parameter descriptor\n\t * @return the corresponding MethodParameter instance\n\t * @since 5.0\n\t */\n\tpublic static MethodParameter forParameter(Parameter parameter) {\n\t\treturn forExecutable(parameter.getDeclaringExecutable(), findParameterIndex(parameter));\n\t}\n\n\tprotected static int findParameterIndex(Parameter parameter) {\n\t\tExecutable executable = parameter.getDeclaringExecutable();\n\t\tParameter[] allParams = executable.getParameters();\n\t\t// Try first with identity checks for greater performance.\n\t\tfor (int i = 0; i < allParams.length; i++) {\n\t\t\tif (parameter == allParams[i]) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\t// Potentially try again with object equality checks in order to avoid race\n\t\t// conditions while invoking java.lang.reflect.Executable.getParameters().\n\t\tfor (int i = 0; i < allParams.length; i++) {\n\t\t\tif (parameter.equals(allParams[i])) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Given parameter [\" + parameter +\n\t\t\t\t\"] does not match any parameter in the declaring executable\");\n\t}\n\n\tprivate static int validateIndex(Executable executable, int parameterIndex) {\n\t\tint count = executable.getParameterCount();\n\t\tAssert.isTrue(parameterIndex >= -1 && parameterIndex < count,\n\t\t\t\t() -> \"Parameter index needs to be between -1 and \" + (count - 1));\n\t\treturn parameterIndex;\n\t}\n\n\t/**\n\t * Create a new MethodParameter for the given field-aware constructor,\n\t * for example, on a data class or record type.\n\t * <p>A field-aware method parameter will detect field annotations as well,\n\t * as long as the field name matches the parameter name.\n\t * @param ctor the Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @param fieldName the name of the underlying field,\n\t * matching the constructor's parameter name\n\t * @return the corresponding MethodParameter instance\n\t * @since 6.1\n\t */\n\tpublic static MethodParameter forFieldAwareConstructor(Constructor<?> ctor, int parameterIndex, @Nullable String fieldName) {\n\t\treturn new FieldAwareConstructorParameter(ctor, parameterIndex, fieldName);\n\t}\n\n\n\t/**\n\t * {@link MethodParameter} subclass which detects field annotations as well.\n\t */\n\tprivate static class FieldAwareConstructorParameter extends MethodParameter {\n\n\t\tprivate volatile Annotation @Nullable [] combinedAnnotations;\n\n\t\tpublic FieldAwareConstructorParameter(Constructor<?> constructor, int parameterIndex, @Nullable String fieldName) {\n\t\t\tsuper(constructor, parameterIndex);\n\t\t\tthis.parameterName = fieldName;\n\t\t}\n\n\t\t@Override\n\t\tpublic Annotation[] getParameterAnnotations() {\n\t\t\tString parameterName = this.parameterName;\n\t\t\tAssert.state(parameterName != null, \"Parameter name not initialized\");\n\n\t\t\tAnnotation[] anns = this.combinedAnnotations;\n\t\t\tif (anns == null) {\n\t\t\t\tanns = super.getParameterAnnotations();\n\t\t\t\ttry {\n\t\t\t\t\tField field = getDeclaringClass().getDeclaredField(parameterName);\n\t\t\t\t\tAnnotation[] fieldAnns = field.getAnnotations();\n\t\t\t\t\tif (fieldAnns.length > 0) {\n\t\t\t\t\t\tList<Annotation> merged = new ArrayList<>(anns.length + fieldAnns.length);\n\t\t\t\t\t\tmerged.addAll(Arrays.asList(anns));\n\t\t\t\t\t\tfor (Annotation fieldAnn : fieldAnns) {\n\t\t\t\t\t\t\tboolean existingType = false;\n\t\t\t\t\t\t\tfor (Annotation ann : anns) {\n\t\t\t\t\t\t\t\tif (ann.annotationType() == fieldAnn.annotationType()) {\n\t\t\t\t\t\t\t\t\texistingType = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!existingType) {\n\t\t\t\t\t\t\t\tmerged.add(fieldAnn);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tanns = merged.toArray(EMPTY_ANNOTATION_ARRAY);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFieldException | SecurityException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t\tthis.combinedAnnotations = anns;\n\t\t\t}\n\t\t\treturn anns;\n\t\t}\n\t}\n\n\n\t/**\n\t * Inner class to avoid a hard dependency on Kotlin at runtime.\n\t */\n\tprivate static class KotlinDelegate {\n\n\t\t/**\n\t\t * Check whether the specified {@link MethodParameter} represents a nullable Kotlin type,\n\t\t * an optional parameter (with a default value in the Kotlin declaration) or a\n\t\t * {@code Continuation} parameter used in suspending functions.\n\t\t */\n\t\tpublic static boolean isOptional(MethodParameter param) {\n\t\t\tMethod method = param.getMethod();\n\t\t\tint index = param.getParameterIndex();\n\t\t\tif (method != null && index == -1) {\n\t\t\t\tKFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\n\t\t\t\treturn (function != null && function.getReturnType().isMarkedNullable());\n\t\t\t}\n\t\t\tKFunction<?> function;\n\t\t\tPredicate<KParameter> predicate;\n\t\t\tif (method != null) {\n\t\t\t\tif (param.getParameterType().getName().equals(\"kotlin.coroutines.Continuation\")) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tfunction = ReflectJvmMapping.getKotlinFunction(method);\n\t\t\t\tpredicate = p -> KParameter.Kind.VALUE.equals(p.getKind());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tConstructor<?> ctor = param.getConstructor();\n\t\t\t\tAssert.state(ctor != null, \"Neither method nor constructor found\");\n\t\t\t\tfunction = ReflectJvmMapping.getKotlinFunction(ctor);\n\t\t\t\tpredicate = p -> (KParameter.Kind.VALUE.equals(p.getKind()) ||\n\t\t\t\t\t\tKParameter.Kind.INSTANCE.equals(p.getKind()));\n\t\t\t}\n\t\t\tif (function != null) {\n\t\t\t\tint i = 0;\n\t\t\t\tfor (KParameter kParameter : function.getParameters()) {\n\t\t\t\t\tif (predicate.test(kParameter)) {\n\t\t\t\t\t\tif (index == i++) {\n\t\t\t\t\t\t\treturn (kParameter.getType().isMarkedNullable() || kParameter.isOptional());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * Return the generic return type of the method, with support of suspending\n\t\t * functions via Kotlin reflection.\n\t\t */\n\t\tprivate static Type getGenericReturnType(Method method) {\n\t\t\ttry {\n\t\t\t\tKFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\n\t\t\t\tif (function != null && function.isSuspend()) {\n\t\t\t\t\treturn ReflectJvmMapping.getJavaType(function.getReturnType());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (UnsupportedOperationException ex) {\n\t\t\t\t// probably a synthetic class - let's use java reflection instead\n\t\t\t}\n\t\t\treturn method.getGenericReturnType();\n\t\t}\n\n\t\t/**\n\t\t * Return the return type of the method, with support of suspending\n\t\t * functions via Kotlin reflection.\n\t\t */\n\t\tprivate static Class<?> getReturnType(Method method) {\n\t\t\ttry {\n\t\t\t\tKFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\n\t\t\t\tif (function != null && function.isSuspend()) {\n\t\t\t\t\tType paramType = ReflectJvmMapping.getJavaType(function.getReturnType());\n\t\t\t\t\tif (paramType == Unit.class) {\n\t\t\t\t\t\tparamType = void.class;\n\t\t\t\t\t}\n\t\t\t\t\treturn ResolvableType.forType(paramType).resolve(method.getReturnType());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (UnsupportedOperationException ex) {\n\t\t\t\t// probably a synthetic class - let's use java reflection instead\n\t\t\t}\n\t\t\treturn method.getReturnType();\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.MethodParameter",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.MethodParameter#EMPTY_ANNOTATION_ARRAY",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.MethodParameter#EMPTY_ANNOTATION_ARRAY",
    "headType": "field",
    "relation": "haveType",
    "tail": "Annotation",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.MethodParameter",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.MethodParameter#executable",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.MethodParameter#executable",
    "headType": "field",
    "relation": "haveType",
    "tail": "Executable",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.MethodParameter",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.MethodParameter#parameterIndex",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.MethodParameter#parameterIndex",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.MethodParameter",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.MethodParameter#parameter",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.MethodParameter#parameter",
    "headType": "field",
    "relation": "haveType",
    "tail": "Parameter",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.MethodParameter",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.MethodParameter#nestingLevel",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.MethodParameter#nestingLevel",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.MethodParameter",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.MethodParameter#typeIndexesPerLevel",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.MethodParameter#typeIndexesPerLevel",
    "headType": "field",
    "relation": "haveType",
    "tail": "Map<Integer, Integer>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.MethodParameter",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.MethodParameter#containingClass",
    "tailType": "field"
  }
]