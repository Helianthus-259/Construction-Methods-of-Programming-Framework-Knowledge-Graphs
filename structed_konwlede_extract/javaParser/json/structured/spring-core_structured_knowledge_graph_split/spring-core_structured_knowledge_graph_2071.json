[
  {
    "head": "org.springframework.core.MethodParameterTests#springNullableMethod(String,String)",
    "headType": "method",
    "relation": "provide",
    "tail": "@SuppressWarnings(\"deprecation\")\r\n@org.springframework.lang.Nullable\r\npublic String springNullableMethod(@org.springframework.lang.Nullable String nullableParameter, String nonNullParameter) {\r\n    return nullableParameter;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.MethodParameterTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.MethodParameterTests#springNullableMethod(String,String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.MethodParameterTests#springNullableMethod(String,String)",
    "headType": "method",
    "relation": "use",
    "tail": "@SuppressWarnings",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.MethodParameterTests#springNullableMethod(String,String)",
    "headType": "method",
    "relation": "use",
    "tail": "@org.springframework.lang.Nullable",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.NestedClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.NestedClass",
    "headType": "class",
    "relation": "use",
    "tail": "@SuppressWarnings",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.NestedClass",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.concurrent.Callable;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n\n/**\n * Tests for {@link MethodParameter}.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Phillip Webb\n * @author Sebastien Deleuze\n */\nclass MethodParameterTests {\n\n\tprivate Method method;\n\n\tprivate MethodParameter stringParameter;\n\n\tprivate MethodParameter longParameter;\n\n\tprivate MethodParameter intReturnType;\n\n\tprivate MethodParameter jspecifyNullableParameter;\n\n\tprivate MethodParameter jspecifyNonNullParameter;\n\n\tprivate MethodParameter springNullableParameter;\n\n\tprivate MethodParameter springNonNullParameter;\n\n\n\t@BeforeEach\n\tvoid setup() throws NoSuchMethodException {\n\t\tmethod = getClass().getMethod(\"method\", String.class, long.class);\n\t\tstringParameter = new MethodParameter(method, 0);\n\t\tlongParameter = new MethodParameter(method, 1);\n\t\tintReturnType = new MethodParameter(method, -1);\n\t\tMethod jspecifyNullableMethod = getClass().getMethod(\"jspecifyNullableMethod\", String.class, String.class);\n\t\tjspecifyNullableParameter = new MethodParameter(jspecifyNullableMethod, 0);\n\t\tjspecifyNonNullParameter = new MethodParameter(jspecifyNullableMethod, 1);\n\t\tMethod springNullableMethod = getClass().getMethod(\"springNullableMethod\", String.class, String.class);\n\t\tspringNullableParameter = new MethodParameter(springNullableMethod, 0);\n\t\tspringNonNullParameter = new MethodParameter(springNullableMethod, 1);\n\t}\n\n\n\t@Test\n\tvoid equals() throws NoSuchMethodException {\n\t\tassertThat(stringParameter).isEqualTo(stringParameter);\n\t\tassertThat(longParameter).isEqualTo(longParameter);\n\t\tassertThat(intReturnType).isEqualTo(intReturnType);\n\n\t\tassertThat(stringParameter).isNotEqualTo(longParameter);\n\t\tassertThat(stringParameter).isNotEqualTo(intReturnType);\n\t\tassertThat(longParameter).isNotEqualTo(stringParameter);\n\t\tassertThat(longParameter).isNotEqualTo(intReturnType);\n\t\tassertThat(intReturnType).isNotEqualTo(stringParameter);\n\t\tassertThat(intReturnType).isNotEqualTo(longParameter);\n\n\t\tMethod method = getClass().getMethod(\"method\", String.class, long.class);\n\t\tMethodParameter methodParameter = new MethodParameter(method, 0);\n\t\tassertThat(methodParameter).isEqualTo(stringParameter);\n\t\tassertThat(stringParameter).isEqualTo(methodParameter);\n\t\tassertThat(methodParameter).isNotEqualTo(longParameter);\n\t\tassertThat(longParameter).isNotEqualTo(methodParameter);\n\t}\n\n\t@Test\n\tvoid testHashCode() throws NoSuchMethodException {\n\t\tassertThat(stringParameter.hashCode()).isEqualTo(stringParameter.hashCode());\n\t\tassertThat(longParameter.hashCode()).isEqualTo(longParameter.hashCode());\n\t\tassertThat(intReturnType.hashCode()).isEqualTo(intReturnType.hashCode());\n\n\t\tMethod method = getClass().getMethod(\"method\", String.class, long.class);\n\t\tMethodParameter methodParameter = new MethodParameter(method, 0);\n\t\tassertThat(methodParameter.hashCode()).isEqualTo(stringParameter.hashCode());\n\t\tassertThat(methodParameter.hashCode()).isNotEqualTo(longParameter.hashCode());\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid testFactoryMethods() {\n\t\tassertThat(MethodParameter.forMethodOrConstructor(method, 0)).isEqualTo(stringParameter);\n\t\tassertThat(MethodParameter.forMethodOrConstructor(method, 1)).isEqualTo(longParameter);\n\n\t\tassertThat(MethodParameter.forExecutable(method, 0)).isEqualTo(stringParameter);\n\t\tassertThat(MethodParameter.forExecutable(method, 1)).isEqualTo(longParameter);\n\n\t\tassertThat(MethodParameter.forParameter(method.getParameters()[0])).isEqualTo(stringParameter);\n\t\tassertThat(MethodParameter.forParameter(method.getParameters()[1])).isEqualTo(longParameter);\n\t}\n\n\t@Test\n\tvoid indexValidation() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tnew MethodParameter(method, 2));\n\t}\n\n\t@Test\n\tvoid annotatedConstructorParameterInStaticNestedClass() throws Exception {\n\t\tConstructor<?> constructor = NestedClass.class.getDeclaredConstructor(String.class);\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(constructor, 0);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(String.class);\n\t\tassertThat(methodParameter.getParameterAnnotation(Param.class)).as(\"Failed to find @Param annotation\").isNotNull();\n\t}\n\n\t@Test  // SPR-16652\n\tvoid annotatedConstructorParameterInInnerClass() throws Exception {\n\t\tConstructor<?> constructor = InnerClass.class.getConstructor(getClass(), String.class, Callable.class);\n\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(constructor, 0);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(getClass());\n\t\tassertThat(methodParameter.getParameterAnnotation(Param.class)).isNull();\n\n\t\tmethodParameter = MethodParameter.forExecutable(constructor, 1);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(String.class);\n\t\tassertThat(methodParameter.getParameterAnnotation(Param.class)).as(\"Failed to find @Param annotation\").isNotNull();\n\n\t\tmethodParameter = MethodParameter.forExecutable(constructor, 2);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(Callable.class);\n\t\tassertThat(methodParameter.getParameterAnnotation(Param.class)).isNull();\n\t}\n\n\t@Test  // SPR-16734\n\tvoid genericConstructorParameterInInnerClass() throws Exception {\n\t\tConstructor<?> constructor = InnerClass.class.getConstructor(getClass(), String.class, Callable.class);\n\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(constructor, 0);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(getClass());\n\t\tassertThat(methodParameter.getGenericParameterType()).isEqualTo(getClass());\n\n\t\tmethodParameter = MethodParameter.forExecutable(constructor, 1);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(String.class);\n\t\tassertThat(methodParameter.getGenericParameterType()).isEqualTo(String.class);\n\n\t\tmethodParameter = MethodParameter.forExecutable(constructor, 2);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(Callable.class);\n\t\tassertThat(methodParameter.getGenericParameterType()).isEqualTo(ResolvableType.forClassWithGenerics(Callable.class, Integer.class).getType());\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid multipleResolveParameterTypeCalls() throws Exception {\n\t\tMethod method = ArrayList.class.getMethod(\"get\", int.class);\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(method, -1);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(Object.class);\n\t\tGenericTypeResolver.resolveParameterType(methodParameter, StringList.class);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(String.class);\n\t\tGenericTypeResolver.resolveParameterType(methodParameter, IntegerList.class);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid equalsAndHashCodeConsidersContainingClass() throws Exception {\n\t\tMethod method = ArrayList.class.getMethod(\"get\", int.class);\n\t\tMethodParameter m1 = MethodParameter.forExecutable(method, -1);\n\t\tMethodParameter m2 = MethodParameter.forExecutable(method, -1);\n\t\tMethodParameter m3 = MethodParameter.forExecutable(method, -1).nested();\n\t\tassertThat(m1).isEqualTo(m2).isNotEqualTo(m3);\n\t\tassertThat(m1.hashCode()).isEqualTo(m2.hashCode());\n\t}\n\n\t@Test\n\tvoid equalsAndHashCodeConsidersNesting() throws Exception {\n\t\tMethod method = ArrayList.class.getMethod(\"get\", int.class);\n\t\tMethodParameter m1 = MethodParameter.forExecutable(method, -1)\n\t\t\t\t.withContainingClass(StringList.class);\n\t\tMethodParameter m2 = MethodParameter.forExecutable(method, -1)\n\t\t\t\t.withContainingClass(StringList.class);\n\t\tMethodParameter m3 = MethodParameter.forExecutable(method, -1)\n\t\t\t\t.withContainingClass(IntegerList.class);\n\t\tMethodParameter m4 = MethodParameter.forExecutable(method, -1);\n\t\tassertThat(m1).isEqualTo(m2).isNotEqualTo(m3).isNotEqualTo(m4);\n\t\tassertThat(m1.hashCode()).isEqualTo(m2.hashCode());\n\t}\n\n\t@Test\n\tvoid withContainingClassReturnsNewInstance() throws Exception {\n\t\tMethod method = ArrayList.class.getMethod(\"get\", int.class);\n\t\tMethodParameter m1 = MethodParameter.forExecutable(method, -1);\n\t\tMethodParameter m2 = m1.withContainingClass(StringList.class);\n\t\tMethodParameter m3 = m1.withContainingClass(IntegerList.class);\n\t\tassertThat(m1).isNotSameAs(m2).isNotSameAs(m3);\n\t\tassertThat(m1.getParameterType()).isEqualTo(Object.class);\n\t\tassertThat(m2.getParameterType()).isEqualTo(String.class);\n\t\tassertThat(m3.getParameterType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid withTypeIndexReturnsNewInstance() throws Exception {\n\t\tMethod method = ArrayList.class.getMethod(\"get\", int.class);\n\t\tMethodParameter m1 = MethodParameter.forExecutable(method, -1);\n\t\tMethodParameter m2 = m1.withTypeIndex(2);\n\t\tMethodParameter m3 = m1.withTypeIndex(3);\n\t\tassertThat(m1).isNotSameAs(m2).isNotSameAs(m3);\n\t\tassertThat(m1.getTypeIndexForCurrentLevel()).isNull();\n\t\tassertThat(m2.getTypeIndexForCurrentLevel()).isEqualTo(2);\n\t\tassertThat(m3.getTypeIndexForCurrentLevel()).isEqualTo(3);\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid mutatingNestingLevelShouldNotChangeNewInstance() throws Exception {\n\t\tMethod method = ArrayList.class.getMethod(\"get\", int.class);\n\t\tMethodParameter m1 = MethodParameter.forExecutable(method, -1);\n\t\tMethodParameter m2 = m1.withTypeIndex(2);\n\t\tassertThat(m2.getTypeIndexForCurrentLevel()).isEqualTo(2);\n\t\tm1.setTypeIndexForCurrentLevel(1);\n\t\tm2.decreaseNestingLevel();\n\t\tassertThat(m2.getTypeIndexForCurrentLevel()).isNull();\n\t}\n\n\t@Test\n\tvoid nestedWithTypeIndexReturnsNewInstance() throws Exception {\n\t\tMethod method = ArrayList.class.getMethod(\"get\", int.class);\n\t\tMethodParameter m1 = MethodParameter.forExecutable(method, -1);\n\t\tMethodParameter m2 = m1.nested(2);\n\t\tMethodParameter m3 = m1.nested(3);\n\t\tassertThat(m1).isNotSameAs(m2).isNotSameAs(m3);\n\t\tassertThat(m1.getTypeIndexForCurrentLevel()).isNull();\n\t\tassertThat(m2.getTypeIndexForCurrentLevel()).isEqualTo(2);\n\t\tassertThat(m3.getTypeIndexForCurrentLevel()).isEqualTo(3);\n\t}\n\n\t@Test\n\tvoid jspecifyNullableParameter() {\n\t\tassertThat(jspecifyNullableParameter.isOptional()).isTrue();\n\t}\n\n\t@Test\n\tvoid jspecifyNonNullParameter() {\n\t\tassertThat(jspecifyNonNullParameter.isOptional()).isFalse();\n\t}\n\n\t@Test\n\tvoid springNullableParameter() {\n\t\tassertThat(springNullableParameter.isOptional()).isTrue();\n\t}\n\n\t@Test\n\tvoid springNonNullParameter() {\n\t\tassertThat(springNonNullParameter.isOptional()).isFalse();\n\t}\n\n\tpublic int method(String p1, long p2) {\n\t\treturn 42;\n\t}\n\n\tpublic @org.jspecify.annotations.Nullable String jspecifyNullableMethod(@org.jspecify.annotations.Nullable String nullableParameter, String nonNullParameter) {\n\t\treturn nullableParameter;\n\t}\n\n\t@SuppressWarnings(\"deprecation\")\n\t@org.springframework.lang.Nullable\n\tpublic String springNullableMethod(@org.springframework.lang.Nullable String nullableParameter, String nonNullParameter) {\n\t\treturn nullableParameter;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class NestedClass {\n\n\t\tNestedClass(@Param String s) {\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate class InnerClass {\n\n\t\tpublic InnerClass(@Param String s, Callable<Integer> i) {\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.PARAMETER)\n\tprivate @interface Param {\n\t}\n\n\t@SuppressWarnings(\"serial\")\n\tprivate static class StringList extends ArrayList<String> {\n\t}\n\n\t@SuppressWarnings(\"serial\")\n\tprivate static class IntegerList extends ArrayList<Integer> {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.InnerClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.InnerClass",
    "headType": "class",
    "relation": "use",
    "tail": "@SuppressWarnings",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.InnerClass",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.concurrent.Callable;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n\n/**\n * Tests for {@link MethodParameter}.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Phillip Webb\n * @author Sebastien Deleuze\n */\nclass MethodParameterTests {\n\n\tprivate Method method;\n\n\tprivate MethodParameter stringParameter;\n\n\tprivate MethodParameter longParameter;\n\n\tprivate MethodParameter intReturnType;\n\n\tprivate MethodParameter jspecifyNullableParameter;\n\n\tprivate MethodParameter jspecifyNonNullParameter;\n\n\tprivate MethodParameter springNullableParameter;\n\n\tprivate MethodParameter springNonNullParameter;\n\n\n\t@BeforeEach\n\tvoid setup() throws NoSuchMethodException {\n\t\tmethod = getClass().getMethod(\"method\", String.class, long.class);\n\t\tstringParameter = new MethodParameter(method, 0);\n\t\tlongParameter = new MethodParameter(method, 1);\n\t\tintReturnType = new MethodParameter(method, -1);\n\t\tMethod jspecifyNullableMethod = getClass().getMethod(\"jspecifyNullableMethod\", String.class, String.class);\n\t\tjspecifyNullableParameter = new MethodParameter(jspecifyNullableMethod, 0);\n\t\tjspecifyNonNullParameter = new MethodParameter(jspecifyNullableMethod, 1);\n\t\tMethod springNullableMethod = getClass().getMethod(\"springNullableMethod\", String.class, String.class);\n\t\tspringNullableParameter = new MethodParameter(springNullableMethod, 0);\n\t\tspringNonNullParameter = new MethodParameter(springNullableMethod, 1);\n\t}\n\n\n\t@Test\n\tvoid equals() throws NoSuchMethodException {\n\t\tassertThat(stringParameter).isEqualTo(stringParameter);\n\t\tassertThat(longParameter).isEqualTo(longParameter);\n\t\tassertThat(intReturnType).isEqualTo(intReturnType);\n\n\t\tassertThat(stringParameter).isNotEqualTo(longParameter);\n\t\tassertThat(stringParameter).isNotEqualTo(intReturnType);\n\t\tassertThat(longParameter).isNotEqualTo(stringParameter);\n\t\tassertThat(longParameter).isNotEqualTo(intReturnType);\n\t\tassertThat(intReturnType).isNotEqualTo(stringParameter);\n\t\tassertThat(intReturnType).isNotEqualTo(longParameter);\n\n\t\tMethod method = getClass().getMethod(\"method\", String.class, long.class);\n\t\tMethodParameter methodParameter = new MethodParameter(method, 0);\n\t\tassertThat(methodParameter).isEqualTo(stringParameter);\n\t\tassertThat(stringParameter).isEqualTo(methodParameter);\n\t\tassertThat(methodParameter).isNotEqualTo(longParameter);\n\t\tassertThat(longParameter).isNotEqualTo(methodParameter);\n\t}\n\n\t@Test\n\tvoid testHashCode() throws NoSuchMethodException {\n\t\tassertThat(stringParameter.hashCode()).isEqualTo(stringParameter.hashCode());\n\t\tassertThat(longParameter.hashCode()).isEqualTo(longParameter.hashCode());\n\t\tassertThat(intReturnType.hashCode()).isEqualTo(intReturnType.hashCode());\n\n\t\tMethod method = getClass().getMethod(\"method\", String.class, long.class);\n\t\tMethodParameter methodParameter = new MethodParameter(method, 0);\n\t\tassertThat(methodParameter.hashCode()).isEqualTo(stringParameter.hashCode());\n\t\tassertThat(methodParameter.hashCode()).isNotEqualTo(longParameter.hashCode());\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid testFactoryMethods() {\n\t\tassertThat(MethodParameter.forMethodOrConstructor(method, 0)).isEqualTo(stringParameter);\n\t\tassertThat(MethodParameter.forMethodOrConstructor(method, 1)).isEqualTo(longParameter);\n\n\t\tassertThat(MethodParameter.forExecutable(method, 0)).isEqualTo(stringParameter);\n\t\tassertThat(MethodParameter.forExecutable(method, 1)).isEqualTo(longParameter);\n\n\t\tassertThat(MethodParameter.forParameter(method.getParameters()[0])).isEqualTo(stringParameter);\n\t\tassertThat(MethodParameter.forParameter(method.getParameters()[1])).isEqualTo(longParameter);\n\t}\n\n\t@Test\n\tvoid indexValidation() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tnew MethodParameter(method, 2));\n\t}\n\n\t@Test\n\tvoid annotatedConstructorParameterInStaticNestedClass() throws Exception {\n\t\tConstructor<?> constructor = NestedClass.class.getDeclaredConstructor(String.class);\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(constructor, 0);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(String.class);\n\t\tassertThat(methodParameter.getParameterAnnotation(Param.class)).as(\"Failed to find @Param annotation\").isNotNull();\n\t}\n\n\t@Test  // SPR-16652\n\tvoid annotatedConstructorParameterInInnerClass() throws Exception {\n\t\tConstructor<?> constructor = InnerClass.class.getConstructor(getClass(), String.class, Callable.class);\n\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(constructor, 0);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(getClass());\n\t\tassertThat(methodParameter.getParameterAnnotation(Param.class)).isNull();\n\n\t\tmethodParameter = MethodParameter.forExecutable(constructor, 1);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(String.class);\n\t\tassertThat(methodParameter.getParameterAnnotation(Param.class)).as(\"Failed to find @Param annotation\").isNotNull();\n\n\t\tmethodParameter = MethodParameter.forExecutable(constructor, 2);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(Callable.class);\n\t\tassertThat(methodParameter.getParameterAnnotation(Param.class)).isNull();\n\t}\n\n\t@Test  // SPR-16734\n\tvoid genericConstructorParameterInInnerClass() throws Exception {\n\t\tConstructor<?> constructor = InnerClass.class.getConstructor(getClass(), String.class, Callable.class);\n\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(constructor, 0);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(getClass());\n\t\tassertThat(methodParameter.getGenericParameterType()).isEqualTo(getClass());\n\n\t\tmethodParameter = MethodParameter.forExecutable(constructor, 1);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(String.class);\n\t\tassertThat(methodParameter.getGenericParameterType()).isEqualTo(String.class);\n\n\t\tmethodParameter = MethodParameter.forExecutable(constructor, 2);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(Callable.class);\n\t\tassertThat(methodParameter.getGenericParameterType()).isEqualTo(ResolvableType.forClassWithGenerics(Callable.class, Integer.class).getType());\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid multipleResolveParameterTypeCalls() throws Exception {\n\t\tMethod method = ArrayList.class.getMethod(\"get\", int.class);\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(method, -1);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(Object.class);\n\t\tGenericTypeResolver.resolveParameterType(methodParameter, StringList.class);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(String.class);\n\t\tGenericTypeResolver.resolveParameterType(methodParameter, IntegerList.class);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid equalsAndHashCodeConsidersContainingClass() throws Exception {\n\t\tMethod method = ArrayList.class.getMethod(\"get\", int.class);\n\t\tMethodParameter m1 = MethodParameter.forExecutable(method, -1);\n\t\tMethodParameter m2 = MethodParameter.forExecutable(method, -1);\n\t\tMethodParameter m3 = MethodParameter.forExecutable(method, -1).nested();\n\t\tassertThat(m1).isEqualTo(m2).isNotEqualTo(m3);\n\t\tassertThat(m1.hashCode()).isEqualTo(m2.hashCode());\n\t}\n\n\t@Test\n\tvoid equalsAndHashCodeConsidersNesting() throws Exception {\n\t\tMethod method = ArrayList.class.getMethod(\"get\", int.class);\n\t\tMethodParameter m1 = MethodParameter.forExecutable(method, -1)\n\t\t\t\t.withContainingClass(StringList.class);\n\t\tMethodParameter m2 = MethodParameter.forExecutable(method, -1)\n\t\t\t\t.withContainingClass(StringList.class);\n\t\tMethodParameter m3 = MethodParameter.forExecutable(method, -1)\n\t\t\t\t.withContainingClass(IntegerList.class);\n\t\tMethodParameter m4 = MethodParameter.forExecutable(method, -1);\n\t\tassertThat(m1).isEqualTo(m2).isNotEqualTo(m3).isNotEqualTo(m4);\n\t\tassertThat(m1.hashCode()).isEqualTo(m2.hashCode());\n\t}\n\n\t@Test\n\tvoid withContainingClassReturnsNewInstance() throws Exception {\n\t\tMethod method = ArrayList.class.getMethod(\"get\", int.class);\n\t\tMethodParameter m1 = MethodParameter.forExecutable(method, -1);\n\t\tMethodParameter m2 = m1.withContainingClass(StringList.class);\n\t\tMethodParameter m3 = m1.withContainingClass(IntegerList.class);\n\t\tassertThat(m1).isNotSameAs(m2).isNotSameAs(m3);\n\t\tassertThat(m1.getParameterType()).isEqualTo(Object.class);\n\t\tassertThat(m2.getParameterType()).isEqualTo(String.class);\n\t\tassertThat(m3.getParameterType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid withTypeIndexReturnsNewInstance() throws Exception {\n\t\tMethod method = ArrayList.class.getMethod(\"get\", int.class);\n\t\tMethodParameter m1 = MethodParameter.forExecutable(method, -1);\n\t\tMethodParameter m2 = m1.withTypeIndex(2);\n\t\tMethodParameter m3 = m1.withTypeIndex(3);\n\t\tassertThat(m1).isNotSameAs(m2).isNotSameAs(m3);\n\t\tassertThat(m1.getTypeIndexForCurrentLevel()).isNull();\n\t\tassertThat(m2.getTypeIndexForCurrentLevel()).isEqualTo(2);\n\t\tassertThat(m3.getTypeIndexForCurrentLevel()).isEqualTo(3);\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid mutatingNestingLevelShouldNotChangeNewInstance() throws Exception {\n\t\tMethod method = ArrayList.class.getMethod(\"get\", int.class);\n\t\tMethodParameter m1 = MethodParameter.forExecutable(method, -1);\n\t\tMethodParameter m2 = m1.withTypeIndex(2);\n\t\tassertThat(m2.getTypeIndexForCurrentLevel()).isEqualTo(2);\n\t\tm1.setTypeIndexForCurrentLevel(1);\n\t\tm2.decreaseNestingLevel();\n\t\tassertThat(m2.getTypeIndexForCurrentLevel()).isNull();\n\t}\n\n\t@Test\n\tvoid nestedWithTypeIndexReturnsNewInstance() throws Exception {\n\t\tMethod method = ArrayList.class.getMethod(\"get\", int.class);\n\t\tMethodParameter m1 = MethodParameter.forExecutable(method, -1);\n\t\tMethodParameter m2 = m1.nested(2);\n\t\tMethodParameter m3 = m1.nested(3);\n\t\tassertThat(m1).isNotSameAs(m2).isNotSameAs(m3);\n\t\tassertThat(m1.getTypeIndexForCurrentLevel()).isNull();\n\t\tassertThat(m2.getTypeIndexForCurrentLevel()).isEqualTo(2);\n\t\tassertThat(m3.getTypeIndexForCurrentLevel()).isEqualTo(3);\n\t}\n\n\t@Test\n\tvoid jspecifyNullableParameter() {\n\t\tassertThat(jspecifyNullableParameter.isOptional()).isTrue();\n\t}\n\n\t@Test\n\tvoid jspecifyNonNullParameter() {\n\t\tassertThat(jspecifyNonNullParameter.isOptional()).isFalse();\n\t}\n\n\t@Test\n\tvoid springNullableParameter() {\n\t\tassertThat(springNullableParameter.isOptional()).isTrue();\n\t}\n\n\t@Test\n\tvoid springNonNullParameter() {\n\t\tassertThat(springNonNullParameter.isOptional()).isFalse();\n\t}\n\n\tpublic int method(String p1, long p2) {\n\t\treturn 42;\n\t}\n\n\tpublic @org.jspecify.annotations.Nullable String jspecifyNullableMethod(@org.jspecify.annotations.Nullable String nullableParameter, String nonNullParameter) {\n\t\treturn nullableParameter;\n\t}\n\n\t@SuppressWarnings(\"deprecation\")\n\t@org.springframework.lang.Nullable\n\tpublic String springNullableMethod(@org.springframework.lang.Nullable String nullableParameter, String nonNullParameter) {\n\t\treturn nullableParameter;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class NestedClass {\n\n\t\tNestedClass(@Param String s) {\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate class InnerClass {\n\n\t\tpublic InnerClass(@Param String s, Callable<Integer> i) {\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.PARAMETER)\n\tprivate @interface Param {\n\t}\n\n\t@SuppressWarnings(\"serial\")\n\tprivate static class StringList extends ArrayList<String> {\n\t}\n\n\t@SuppressWarnings(\"serial\")\n\tprivate static class IntegerList extends ArrayList<Integer> {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.StringList",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.StringList",
    "headType": "class",
    "relation": "use",
    "tail": "@SuppressWarnings",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.StringList",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.concurrent.Callable;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n\n/**\n * Tests for {@link MethodParameter}.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Phillip Webb\n * @author Sebastien Deleuze\n */\nclass MethodParameterTests {\n\n\tprivate Method method;\n\n\tprivate MethodParameter stringParameter;\n\n\tprivate MethodParameter longParameter;\n\n\tprivate MethodParameter intReturnType;\n\n\tprivate MethodParameter jspecifyNullableParameter;\n\n\tprivate MethodParameter jspecifyNonNullParameter;\n\n\tprivate MethodParameter springNullableParameter;\n\n\tprivate MethodParameter springNonNullParameter;\n\n\n\t@BeforeEach\n\tvoid setup() throws NoSuchMethodException {\n\t\tmethod = getClass().getMethod(\"method\", String.class, long.class);\n\t\tstringParameter = new MethodParameter(method, 0);\n\t\tlongParameter = new MethodParameter(method, 1);\n\t\tintReturnType = new MethodParameter(method, -1);\n\t\tMethod jspecifyNullableMethod = getClass().getMethod(\"jspecifyNullableMethod\", String.class, String.class);\n\t\tjspecifyNullableParameter = new MethodParameter(jspecifyNullableMethod, 0);\n\t\tjspecifyNonNullParameter = new MethodParameter(jspecifyNullableMethod, 1);\n\t\tMethod springNullableMethod = getClass().getMethod(\"springNullableMethod\", String.class, String.class);\n\t\tspringNullableParameter = new MethodParameter(springNullableMethod, 0);\n\t\tspringNonNullParameter = new MethodParameter(springNullableMethod, 1);\n\t}\n\n\n\t@Test\n\tvoid equals() throws NoSuchMethodException {\n\t\tassertThat(stringParameter).isEqualTo(stringParameter);\n\t\tassertThat(longParameter).isEqualTo(longParameter);\n\t\tassertThat(intReturnType).isEqualTo(intReturnType);\n\n\t\tassertThat(stringParameter).isNotEqualTo(longParameter);\n\t\tassertThat(stringParameter).isNotEqualTo(intReturnType);\n\t\tassertThat(longParameter).isNotEqualTo(stringParameter);\n\t\tassertThat(longParameter).isNotEqualTo(intReturnType);\n\t\tassertThat(intReturnType).isNotEqualTo(stringParameter);\n\t\tassertThat(intReturnType).isNotEqualTo(longParameter);\n\n\t\tMethod method = getClass().getMethod(\"method\", String.class, long.class);\n\t\tMethodParameter methodParameter = new MethodParameter(method, 0);\n\t\tassertThat(methodParameter).isEqualTo(stringParameter);\n\t\tassertThat(stringParameter).isEqualTo(methodParameter);\n\t\tassertThat(methodParameter).isNotEqualTo(longParameter);\n\t\tassertThat(longParameter).isNotEqualTo(methodParameter);\n\t}\n\n\t@Test\n\tvoid testHashCode() throws NoSuchMethodException {\n\t\tassertThat(stringParameter.hashCode()).isEqualTo(stringParameter.hashCode());\n\t\tassertThat(longParameter.hashCode()).isEqualTo(longParameter.hashCode());\n\t\tassertThat(intReturnType.hashCode()).isEqualTo(intReturnType.hashCode());\n\n\t\tMethod method = getClass().getMethod(\"method\", String.class, long.class);\n\t\tMethodParameter methodParameter = new MethodParameter(method, 0);\n\t\tassertThat(methodParameter.hashCode()).isEqualTo(stringParameter.hashCode());\n\t\tassertThat(methodParameter.hashCode()).isNotEqualTo(longParameter.hashCode());\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid testFactoryMethods() {\n\t\tassertThat(MethodParameter.forMethodOrConstructor(method, 0)).isEqualTo(stringParameter);\n\t\tassertThat(MethodParameter.forMethodOrConstructor(method, 1)).isEqualTo(longParameter);\n\n\t\tassertThat(MethodParameter.forExecutable(method, 0)).isEqualTo(stringParameter);\n\t\tassertThat(MethodParameter.forExecutable(method, 1)).isEqualTo(longParameter);\n\n\t\tassertThat(MethodParameter.forParameter(method.getParameters()[0])).isEqualTo(stringParameter);\n\t\tassertThat(MethodParameter.forParameter(method.getParameters()[1])).isEqualTo(longParameter);\n\t}\n\n\t@Test\n\tvoid indexValidation() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tnew MethodParameter(method, 2));\n\t}\n\n\t@Test\n\tvoid annotatedConstructorParameterInStaticNestedClass() throws Exception {\n\t\tConstructor<?> constructor = NestedClass.class.getDeclaredConstructor(String.class);\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(constructor, 0);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(String.class);\n\t\tassertThat(methodParameter.getParameterAnnotation(Param.class)).as(\"Failed to find @Param annotation\").isNotNull();\n\t}\n\n\t@Test  // SPR-16652\n\tvoid annotatedConstructorParameterInInnerClass() throws Exception {\n\t\tConstructor<?> constructor = InnerClass.class.getConstructor(getClass(), String.class, Callable.class);\n\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(constructor, 0);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(getClass());\n\t\tassertThat(methodParameter.getParameterAnnotation(Param.class)).isNull();\n\n\t\tmethodParameter = MethodParameter.forExecutable(constructor, 1);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(String.class);\n\t\tassertThat(methodParameter.getParameterAnnotation(Param.class)).as(\"Failed to find @Param annotation\").isNotNull();\n\n\t\tmethodParameter = MethodParameter.forExecutable(constructor, 2);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(Callable.class);\n\t\tassertThat(methodParameter.getParameterAnnotation(Param.class)).isNull();\n\t}\n\n\t@Test  // SPR-16734\n\tvoid genericConstructorParameterInInnerClass() throws Exception {\n\t\tConstructor<?> constructor = InnerClass.class.getConstructor(getClass(), String.class, Callable.class);\n\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(constructor, 0);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(getClass());\n\t\tassertThat(methodParameter.getGenericParameterType()).isEqualTo(getClass());\n\n\t\tmethodParameter = MethodParameter.forExecutable(constructor, 1);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(String.class);\n\t\tassertThat(methodParameter.getGenericParameterType()).isEqualTo(String.class);\n\n\t\tmethodParameter = MethodParameter.forExecutable(constructor, 2);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(Callable.class);\n\t\tassertThat(methodParameter.getGenericParameterType()).isEqualTo(ResolvableType.forClassWithGenerics(Callable.class, Integer.class).getType());\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid multipleResolveParameterTypeCalls() throws Exception {\n\t\tMethod method = ArrayList.class.getMethod(\"get\", int.class);\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(method, -1);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(Object.class);\n\t\tGenericTypeResolver.resolveParameterType(methodParameter, StringList.class);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(String.class);\n\t\tGenericTypeResolver.resolveParameterType(methodParameter, IntegerList.class);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid equalsAndHashCodeConsidersContainingClass() throws Exception {\n\t\tMethod method = ArrayList.class.getMethod(\"get\", int.class);\n\t\tMethodParameter m1 = MethodParameter.forExecutable(method, -1);\n\t\tMethodParameter m2 = MethodParameter.forExecutable(method, -1);\n\t\tMethodParameter m3 = MethodParameter.forExecutable(method, -1).nested();\n\t\tassertThat(m1).isEqualTo(m2).isNotEqualTo(m3);\n\t\tassertThat(m1.hashCode()).isEqualTo(m2.hashCode());\n\t}\n\n\t@Test\n\tvoid equalsAndHashCodeConsidersNesting() throws Exception {\n\t\tMethod method = ArrayList.class.getMethod(\"get\", int.class);\n\t\tMethodParameter m1 = MethodParameter.forExecutable(method, -1)\n\t\t\t\t.withContainingClass(StringList.class);\n\t\tMethodParameter m2 = MethodParameter.forExecutable(method, -1)\n\t\t\t\t.withContainingClass(StringList.class);\n\t\tMethodParameter m3 = MethodParameter.forExecutable(method, -1)\n\t\t\t\t.withContainingClass(IntegerList.class);\n\t\tMethodParameter m4 = MethodParameter.forExecutable(method, -1);\n\t\tassertThat(m1).isEqualTo(m2).isNotEqualTo(m3).isNotEqualTo(m4);\n\t\tassertThat(m1.hashCode()).isEqualTo(m2.hashCode());\n\t}\n\n\t@Test\n\tvoid withContainingClassReturnsNewInstance() throws Exception {\n\t\tMethod method = ArrayList.class.getMethod(\"get\", int.class);\n\t\tMethodParameter m1 = MethodParameter.forExecutable(method, -1);\n\t\tMethodParameter m2 = m1.withContainingClass(StringList.class);\n\t\tMethodParameter m3 = m1.withContainingClass(IntegerList.class);\n\t\tassertThat(m1).isNotSameAs(m2).isNotSameAs(m3);\n\t\tassertThat(m1.getParameterType()).isEqualTo(Object.class);\n\t\tassertThat(m2.getParameterType()).isEqualTo(String.class);\n\t\tassertThat(m3.getParameterType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid withTypeIndexReturnsNewInstance() throws Exception {\n\t\tMethod method = ArrayList.class.getMethod(\"get\", int.class);\n\t\tMethodParameter m1 = MethodParameter.forExecutable(method, -1);\n\t\tMethodParameter m2 = m1.withTypeIndex(2);\n\t\tMethodParameter m3 = m1.withTypeIndex(3);\n\t\tassertThat(m1).isNotSameAs(m2).isNotSameAs(m3);\n\t\tassertThat(m1.getTypeIndexForCurrentLevel()).isNull();\n\t\tassertThat(m2.getTypeIndexForCurrentLevel()).isEqualTo(2);\n\t\tassertThat(m3.getTypeIndexForCurrentLevel()).isEqualTo(3);\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid mutatingNestingLevelShouldNotChangeNewInstance() throws Exception {\n\t\tMethod method = ArrayList.class.getMethod(\"get\", int.class);\n\t\tMethodParameter m1 = MethodParameter.forExecutable(method, -1);\n\t\tMethodParameter m2 = m1.withTypeIndex(2);\n\t\tassertThat(m2.getTypeIndexForCurrentLevel()).isEqualTo(2);\n\t\tm1.setTypeIndexForCurrentLevel(1);\n\t\tm2.decreaseNestingLevel();\n\t\tassertThat(m2.getTypeIndexForCurrentLevel()).isNull();\n\t}\n\n\t@Test\n\tvoid nestedWithTypeIndexReturnsNewInstance() throws Exception {\n\t\tMethod method = ArrayList.class.getMethod(\"get\", int.class);\n\t\tMethodParameter m1 = MethodParameter.forExecutable(method, -1);\n\t\tMethodParameter m2 = m1.nested(2);\n\t\tMethodParameter m3 = m1.nested(3);\n\t\tassertThat(m1).isNotSameAs(m2).isNotSameAs(m3);\n\t\tassertThat(m1.getTypeIndexForCurrentLevel()).isNull();\n\t\tassertThat(m2.getTypeIndexForCurrentLevel()).isEqualTo(2);\n\t\tassertThat(m3.getTypeIndexForCurrentLevel()).isEqualTo(3);\n\t}\n\n\t@Test\n\tvoid jspecifyNullableParameter() {\n\t\tassertThat(jspecifyNullableParameter.isOptional()).isTrue();\n\t}\n\n\t@Test\n\tvoid jspecifyNonNullParameter() {\n\t\tassertThat(jspecifyNonNullParameter.isOptional()).isFalse();\n\t}\n\n\t@Test\n\tvoid springNullableParameter() {\n\t\tassertThat(springNullableParameter.isOptional()).isTrue();\n\t}\n\n\t@Test\n\tvoid springNonNullParameter() {\n\t\tassertThat(springNonNullParameter.isOptional()).isFalse();\n\t}\n\n\tpublic int method(String p1, long p2) {\n\t\treturn 42;\n\t}\n\n\tpublic @org.jspecify.annotations.Nullable String jspecifyNullableMethod(@org.jspecify.annotations.Nullable String nullableParameter, String nonNullParameter) {\n\t\treturn nullableParameter;\n\t}\n\n\t@SuppressWarnings(\"deprecation\")\n\t@org.springframework.lang.Nullable\n\tpublic String springNullableMethod(@org.springframework.lang.Nullable String nullableParameter, String nonNullParameter) {\n\t\treturn nullableParameter;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class NestedClass {\n\n\t\tNestedClass(@Param String s) {\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate class InnerClass {\n\n\t\tpublic InnerClass(@Param String s, Callable<Integer> i) {\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.PARAMETER)\n\tprivate @interface Param {\n\t}\n\n\t@SuppressWarnings(\"serial\")\n\tprivate static class StringList extends ArrayList<String> {\n\t}\n\n\t@SuppressWarnings(\"serial\")\n\tprivate static class IntegerList extends ArrayList<Integer> {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.StringList",
    "headType": "class",
    "relation": "extend",
    "tail": "ArrayList",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.IntegerList",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.IntegerList",
    "headType": "class",
    "relation": "use",
    "tail": "@SuppressWarnings",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.IntegerList",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.concurrent.Callable;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n\n/**\n * Tests for {@link MethodParameter}.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Phillip Webb\n * @author Sebastien Deleuze\n */\nclass MethodParameterTests {\n\n\tprivate Method method;\n\n\tprivate MethodParameter stringParameter;\n\n\tprivate MethodParameter longParameter;\n\n\tprivate MethodParameter intReturnType;\n\n\tprivate MethodParameter jspecifyNullableParameter;\n\n\tprivate MethodParameter jspecifyNonNullParameter;\n\n\tprivate MethodParameter springNullableParameter;\n\n\tprivate MethodParameter springNonNullParameter;\n\n\n\t@BeforeEach\n\tvoid setup() throws NoSuchMethodException {\n\t\tmethod = getClass().getMethod(\"method\", String.class, long.class);\n\t\tstringParameter = new MethodParameter(method, 0);\n\t\tlongParameter = new MethodParameter(method, 1);\n\t\tintReturnType = new MethodParameter(method, -1);\n\t\tMethod jspecifyNullableMethod = getClass().getMethod(\"jspecifyNullableMethod\", String.class, String.class);\n\t\tjspecifyNullableParameter = new MethodParameter(jspecifyNullableMethod, 0);\n\t\tjspecifyNonNullParameter = new MethodParameter(jspecifyNullableMethod, 1);\n\t\tMethod springNullableMethod = getClass().getMethod(\"springNullableMethod\", String.class, String.class);\n\t\tspringNullableParameter = new MethodParameter(springNullableMethod, 0);\n\t\tspringNonNullParameter = new MethodParameter(springNullableMethod, 1);\n\t}\n\n\n\t@Test\n\tvoid equals() throws NoSuchMethodException {\n\t\tassertThat(stringParameter).isEqualTo(stringParameter);\n\t\tassertThat(longParameter).isEqualTo(longParameter);\n\t\tassertThat(intReturnType).isEqualTo(intReturnType);\n\n\t\tassertThat(stringParameter).isNotEqualTo(longParameter);\n\t\tassertThat(stringParameter).isNotEqualTo(intReturnType);\n\t\tassertThat(longParameter).isNotEqualTo(stringParameter);\n\t\tassertThat(longParameter).isNotEqualTo(intReturnType);\n\t\tassertThat(intReturnType).isNotEqualTo(stringParameter);\n\t\tassertThat(intReturnType).isNotEqualTo(longParameter);\n\n\t\tMethod method = getClass().getMethod(\"method\", String.class, long.class);\n\t\tMethodParameter methodParameter = new MethodParameter(method, 0);\n\t\tassertThat(methodParameter).isEqualTo(stringParameter);\n\t\tassertThat(stringParameter).isEqualTo(methodParameter);\n\t\tassertThat(methodParameter).isNotEqualTo(longParameter);\n\t\tassertThat(longParameter).isNotEqualTo(methodParameter);\n\t}\n\n\t@Test\n\tvoid testHashCode() throws NoSuchMethodException {\n\t\tassertThat(stringParameter.hashCode()).isEqualTo(stringParameter.hashCode());\n\t\tassertThat(longParameter.hashCode()).isEqualTo(longParameter.hashCode());\n\t\tassertThat(intReturnType.hashCode()).isEqualTo(intReturnType.hashCode());\n\n\t\tMethod method = getClass().getMethod(\"method\", String.class, long.class);\n\t\tMethodParameter methodParameter = new MethodParameter(method, 0);\n\t\tassertThat(methodParameter.hashCode()).isEqualTo(stringParameter.hashCode());\n\t\tassertThat(methodParameter.hashCode()).isNotEqualTo(longParameter.hashCode());\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid testFactoryMethods() {\n\t\tassertThat(MethodParameter.forMethodOrConstructor(method, 0)).isEqualTo(stringParameter);\n\t\tassertThat(MethodParameter.forMethodOrConstructor(method, 1)).isEqualTo(longParameter);\n\n\t\tassertThat(MethodParameter.forExecutable(method, 0)).isEqualTo(stringParameter);\n\t\tassertThat(MethodParameter.forExecutable(method, 1)).isEqualTo(longParameter);\n\n\t\tassertThat(MethodParameter.forParameter(method.getParameters()[0])).isEqualTo(stringParameter);\n\t\tassertThat(MethodParameter.forParameter(method.getParameters()[1])).isEqualTo(longParameter);\n\t}\n\n\t@Test\n\tvoid indexValidation() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tnew MethodParameter(method, 2));\n\t}\n\n\t@Test\n\tvoid annotatedConstructorParameterInStaticNestedClass() throws Exception {\n\t\tConstructor<?> constructor = NestedClass.class.getDeclaredConstructor(String.class);\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(constructor, 0);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(String.class);\n\t\tassertThat(methodParameter.getParameterAnnotation(Param.class)).as(\"Failed to find @Param annotation\").isNotNull();\n\t}\n\n\t@Test  // SPR-16652\n\tvoid annotatedConstructorParameterInInnerClass() throws Exception {\n\t\tConstructor<?> constructor = InnerClass.class.getConstructor(getClass(), String.class, Callable.class);\n\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(constructor, 0);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(getClass());\n\t\tassertThat(methodParameter.getParameterAnnotation(Param.class)).isNull();\n\n\t\tmethodParameter = MethodParameter.forExecutable(constructor, 1);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(String.class);\n\t\tassertThat(methodParameter.getParameterAnnotation(Param.class)).as(\"Failed to find @Param annotation\").isNotNull();\n\n\t\tmethodParameter = MethodParameter.forExecutable(constructor, 2);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(Callable.class);\n\t\tassertThat(methodParameter.getParameterAnnotation(Param.class)).isNull();\n\t}\n\n\t@Test  // SPR-16734\n\tvoid genericConstructorParameterInInnerClass() throws Exception {\n\t\tConstructor<?> constructor = InnerClass.class.getConstructor(getClass(), String.class, Callable.class);\n\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(constructor, 0);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(getClass());\n\t\tassertThat(methodParameter.getGenericParameterType()).isEqualTo(getClass());\n\n\t\tmethodParameter = MethodParameter.forExecutable(constructor, 1);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(String.class);\n\t\tassertThat(methodParameter.getGenericParameterType()).isEqualTo(String.class);\n\n\t\tmethodParameter = MethodParameter.forExecutable(constructor, 2);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(Callable.class);\n\t\tassertThat(methodParameter.getGenericParameterType()).isEqualTo(ResolvableType.forClassWithGenerics(Callable.class, Integer.class).getType());\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid multipleResolveParameterTypeCalls() throws Exception {\n\t\tMethod method = ArrayList.class.getMethod(\"get\", int.class);\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(method, -1);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(Object.class);\n\t\tGenericTypeResolver.resolveParameterType(methodParameter, StringList.class);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(String.class);\n\t\tGenericTypeResolver.resolveParameterType(methodParameter, IntegerList.class);\n\t\tassertThat(methodParameter.getParameterType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid equalsAndHashCodeConsidersContainingClass() throws Exception {\n\t\tMethod method = ArrayList.class.getMethod(\"get\", int.class);\n\t\tMethodParameter m1 = MethodParameter.forExecutable(method, -1);\n\t\tMethodParameter m2 = MethodParameter.forExecutable(method, -1);\n\t\tMethodParameter m3 = MethodParameter.forExecutable(method, -1).nested();\n\t\tassertThat(m1).isEqualTo(m2).isNotEqualTo(m3);\n\t\tassertThat(m1.hashCode()).isEqualTo(m2.hashCode());\n\t}\n\n\t@Test\n\tvoid equalsAndHashCodeConsidersNesting() throws Exception {\n\t\tMethod method = ArrayList.class.getMethod(\"get\", int.class);\n\t\tMethodParameter m1 = MethodParameter.forExecutable(method, -1)\n\t\t\t\t.withContainingClass(StringList.class);\n\t\tMethodParameter m2 = MethodParameter.forExecutable(method, -1)\n\t\t\t\t.withContainingClass(StringList.class);\n\t\tMethodParameter m3 = MethodParameter.forExecutable(method, -1)\n\t\t\t\t.withContainingClass(IntegerList.class);\n\t\tMethodParameter m4 = MethodParameter.forExecutable(method, -1);\n\t\tassertThat(m1).isEqualTo(m2).isNotEqualTo(m3).isNotEqualTo(m4);\n\t\tassertThat(m1.hashCode()).isEqualTo(m2.hashCode());\n\t}\n\n\t@Test\n\tvoid withContainingClassReturnsNewInstance() throws Exception {\n\t\tMethod method = ArrayList.class.getMethod(\"get\", int.class);\n\t\tMethodParameter m1 = MethodParameter.forExecutable(method, -1);\n\t\tMethodParameter m2 = m1.withContainingClass(StringList.class);\n\t\tMethodParameter m3 = m1.withContainingClass(IntegerList.class);\n\t\tassertThat(m1).isNotSameAs(m2).isNotSameAs(m3);\n\t\tassertThat(m1.getParameterType()).isEqualTo(Object.class);\n\t\tassertThat(m2.getParameterType()).isEqualTo(String.class);\n\t\tassertThat(m3.getParameterType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid withTypeIndexReturnsNewInstance() throws Exception {\n\t\tMethod method = ArrayList.class.getMethod(\"get\", int.class);\n\t\tMethodParameter m1 = MethodParameter.forExecutable(method, -1);\n\t\tMethodParameter m2 = m1.withTypeIndex(2);\n\t\tMethodParameter m3 = m1.withTypeIndex(3);\n\t\tassertThat(m1).isNotSameAs(m2).isNotSameAs(m3);\n\t\tassertThat(m1.getTypeIndexForCurrentLevel()).isNull();\n\t\tassertThat(m2.getTypeIndexForCurrentLevel()).isEqualTo(2);\n\t\tassertThat(m3.getTypeIndexForCurrentLevel()).isEqualTo(3);\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid mutatingNestingLevelShouldNotChangeNewInstance() throws Exception {\n\t\tMethod method = ArrayList.class.getMethod(\"get\", int.class);\n\t\tMethodParameter m1 = MethodParameter.forExecutable(method, -1);\n\t\tMethodParameter m2 = m1.withTypeIndex(2);\n\t\tassertThat(m2.getTypeIndexForCurrentLevel()).isEqualTo(2);\n\t\tm1.setTypeIndexForCurrentLevel(1);\n\t\tm2.decreaseNestingLevel();\n\t\tassertThat(m2.getTypeIndexForCurrentLevel()).isNull();\n\t}\n\n\t@Test\n\tvoid nestedWithTypeIndexReturnsNewInstance() throws Exception {\n\t\tMethod method = ArrayList.class.getMethod(\"get\", int.class);\n\t\tMethodParameter m1 = MethodParameter.forExecutable(method, -1);\n\t\tMethodParameter m2 = m1.nested(2);\n\t\tMethodParameter m3 = m1.nested(3);\n\t\tassertThat(m1).isNotSameAs(m2).isNotSameAs(m3);\n\t\tassertThat(m1.getTypeIndexForCurrentLevel()).isNull();\n\t\tassertThat(m2.getTypeIndexForCurrentLevel()).isEqualTo(2);\n\t\tassertThat(m3.getTypeIndexForCurrentLevel()).isEqualTo(3);\n\t}\n\n\t@Test\n\tvoid jspecifyNullableParameter() {\n\t\tassertThat(jspecifyNullableParameter.isOptional()).isTrue();\n\t}\n\n\t@Test\n\tvoid jspecifyNonNullParameter() {\n\t\tassertThat(jspecifyNonNullParameter.isOptional()).isFalse();\n\t}\n\n\t@Test\n\tvoid springNullableParameter() {\n\t\tassertThat(springNullableParameter.isOptional()).isTrue();\n\t}\n\n\t@Test\n\tvoid springNonNullParameter() {\n\t\tassertThat(springNonNullParameter.isOptional()).isFalse();\n\t}\n\n\tpublic int method(String p1, long p2) {\n\t\treturn 42;\n\t}\n\n\tpublic @org.jspecify.annotations.Nullable String jspecifyNullableMethod(@org.jspecify.annotations.Nullable String nullableParameter, String nonNullParameter) {\n\t\treturn nullableParameter;\n\t}\n\n\t@SuppressWarnings(\"deprecation\")\n\t@org.springframework.lang.Nullable\n\tpublic String springNullableMethod(@org.springframework.lang.Nullable String nullableParameter, String nonNullParameter) {\n\t\treturn nullableParameter;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class NestedClass {\n\n\t\tNestedClass(@Param String s) {\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate class InnerClass {\n\n\t\tpublic InnerClass(@Param String s, Callable<Integer> i) {\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.PARAMETER)\n\tprivate @interface Param {\n\t}\n\n\t@SuppressWarnings(\"serial\")\n\tprivate static class StringList extends ArrayList<String> {\n\t}\n\n\t@SuppressWarnings(\"serial\")\n\tprivate static class IntegerList extends ArrayList<Integer> {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.IntegerList",
    "headType": "class",
    "relation": "extend",
    "tail": "ArrayList",
    "tailType": "class"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.NullnessTests",
    "tailType": "class"
  }
]