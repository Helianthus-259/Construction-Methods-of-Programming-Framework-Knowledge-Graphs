[
  {
    "head": "org.springframework.core.annotation.WithSameValueAliasPair",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.IntStream;\n\nimport javax.annotation.Nullable;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.AnnotationTypeMapping.MirrorSets;\nimport org.springframework.core.annotation.AnnotationTypeMapping.MirrorSets.MirrorSet;\nimport org.springframework.util.ReflectionUtils;\n\nimport static java.util.stream.Collectors.toList;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n\n/**\n * Tests for {@link AnnotationTypeMappings} and {@link AnnotationTypeMapping}.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n */\nclass AnnotationTypeMappingsTests {\n\n\t@Test\n\tvoid forAnnotationTypeWhenNoMetaAnnotationsReturnsMappings() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(SimpleAnnotation.class);\n\t\tassertThat(mappings.size()).isEqualTo(1);\n\t\tassertThat(mappings.get(0).getAnnotationType()).isEqualTo(SimpleAnnotation.class);\n\t\tassertThat(getAll(mappings)).flatExtracting(\n\t\t\t\tAnnotationTypeMapping::getAnnotationType).containsExactly(SimpleAnnotation.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenMetaAnnotationsReturnsMappings() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(MetaAnnotated.class);\n\t\tassertThat(mappings.size()).isEqualTo(6);\n\t\tassertThat(getAll(mappings)).flatExtracting(\n\t\t\t\tAnnotationTypeMapping::getAnnotationType).containsExactly(\n\t\t\t\t\t\tMetaAnnotated.class, A.class, B.class, AA.class, AB.class,\n\t\t\t\t\t\tABC.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenHasRepeatingMetaAnnotationReturnsMapping() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(WithRepeatedMetaAnnotations.class);\n\t\tassertThat(mappings.size()).isEqualTo(3);\n\t\tassertThat(getAll(mappings)).flatExtracting(\n\t\t\t\tAnnotationTypeMapping::getAnnotationType).containsExactly(\n\t\t\t\t\t\tWithRepeatedMetaAnnotations.class, Repeating.class, Repeating.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenRepeatableMetaAnnotationIsFiltered() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(WithRepeatedMetaAnnotations.class,\n\t\t\t\tRepeatableContainers.standardRepeatables(), Repeating.class.getName()::equals);\n\t\tassertThat(getAll(mappings)).flatExtracting(AnnotationTypeMapping::getAnnotationType)\n\t\t\t\t.containsExactly(WithRepeatedMetaAnnotations.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenSelfAnnotatedReturnsMapping() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(SelfAnnotated.class);\n\t\tassertThat(mappings.size()).isEqualTo(1);\n\t\tassertThat(getAll(mappings)).flatExtracting(\n\t\t\t\tAnnotationTypeMapping::getAnnotationType).containsExactly(SelfAnnotated.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenFormsLoopReturnsMapping() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(LoopA.class);\n\t\tassertThat(mappings.size()).isEqualTo(2);\n\t\tassertThat(getAll(mappings)).flatExtracting(\n\t\t\t\tAnnotationTypeMapping::getAnnotationType).containsExactly(LoopA.class, LoopB.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenHasAliasForWithBothValueAndAttributeThrowsException() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForWithBothValueAndAttribute.class))\n\t\t\t.withMessage(\"In @AliasFor declared on attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForWithBothValueAndAttribute.class.getName()\n\t\t\t\t\t\t\t\t+ \"], attribute 'attribute' and its alias 'value' are present with values of 'foo' and 'bar', but only one is permitted.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForToSelfNonExistingAttribute() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForToSelfNonExistingAttribute.class))\n\t\t\t.withMessage(\"@AliasFor declaration on attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForToSelfNonExistingAttribute.class.getName()\n\t\t\t\t\t\t\t\t+ \"] declares an alias for 'missing' which is not present.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForToOtherNonExistingAttribute() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForToOtherNonExistingAttribute.class))\n\t\t\t.withMessage(\"Attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForToOtherNonExistingAttribute.class.getName()\n\t\t\t\t\t\t\t\t+ \"] is declared as an @AliasFor nonexistent \"\n\t\t\t\t\t\t\t\t+ \"attribute 'missing' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForToOtherNonExistingAttributeTarget.class.getName()\n\t\t\t\t\t\t\t\t+ \"].\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForToSelf() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForToSelf.class))\n\t\t\t.withMessage(\"@AliasFor declaration on attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForToSelf.class.getName()\n\t\t\t\t\t\t\t\t+ \"] points to itself. Specify 'annotation' to point to \"\n\t\t\t\t\t\t\t\t+ \"a same-named attribute on a meta-annotation.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForWithArrayCompatibleReturnTypes() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(\n\t\t\t\tAliasForWithArrayCompatibleReturnTypes.class);\n\t\tAnnotationTypeMapping mapping = getMapping(mappings,\n\t\t\t\tAliasForWithArrayCompatibleReturnTypesTarget.class);\n\t\tassertThat(getAliasMapping(mapping, 0).getName()).isEqualTo(\"test\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForWithIncompatibleReturnTypes() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForWithIncompatibleReturnTypes.class))\n\t\t\t.withMessage(\"Misconfigured aliases: attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForWithIncompatibleReturnTypes.class.getName()\n\t\t\t\t\t\t\t\t+ \"] and attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForWithIncompatibleReturnTypesTarget.class.getName()\n\t\t\t\t\t\t\t\t+ \"] must declare the same return type.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForToSelfAnnotatedToOtherAttribute() {\n\t\tString annotationType = AliasForToSelfAnnotatedToOtherAttribute.class.getName();\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> AnnotationTypeMappings.forAnnotationType(AliasForToSelfAnnotatedToOtherAttribute.class))\n\t\t\t\t.withMessage(\"Attribute 'b' in annotation [\" + annotationType\n\t\t\t\t\t\t+ \"] must be declared as an @AliasFor attribute 'a' in annotation [\" + annotationType\n\t\t\t\t\t\t+ \"], not attribute 'c' in annotation [\" + annotationType + \"].\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForHasMixedImplicitAndExplicitAliases() {\n\t\tassertMixedImplicitAndExplicitAliases(AliasForWithMixedImplicitAndExplicitAliasesV1.class, \"b\");\n\t\tassertMixedImplicitAndExplicitAliases(AliasForWithMixedImplicitAndExplicitAliasesV2.class, \"a\");\n\t}\n\n\tprivate void assertMixedImplicitAndExplicitAliases(Class<? extends Annotation> annotationType, String overriddenAttribute) {\n\t\tString annotationName = annotationType.getName();\n\t\tString metaAnnotationName = AliasPair.class.getName();\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> AnnotationTypeMappings.forAnnotationType(annotationType))\n\t\t\t\t.withMessage(\"Attribute 'b' in annotation [\" + annotationName\n\t\t\t\t\t\t+ \"] must be declared as an @AliasFor attribute 'a' in annotation [\" + annotationName\n\t\t\t\t\t\t+ \"], not attribute '\" + overriddenAttribute + \"' in annotation [\" + metaAnnotationName + \"].\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForNonMetaAnnotated() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForNonMetaAnnotated.class))\n\t\t\t.withMessage(\"@AliasFor declaration on attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForNonMetaAnnotated.class.getName()\n\t\t\t\t\t\t\t\t+ \"] declares an alias for attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForNonMetaAnnotatedTarget.class.getName()\n\t\t\t\t\t\t\t\t+ \"] which is not meta-present.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForSelfWithDifferentDefaults() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForSelfWithDifferentDefaults.class))\n\t\t\t.withMessage(\"Misconfigured aliases: attribute 'a' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForSelfWithDifferentDefaults.class.getName()\n\t\t\t\t\t\t\t\t+ \"] and attribute 'b' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForSelfWithDifferentDefaults.class.getName()\n\t\t\t\t\t\t\t\t+ \"] must declare the same default value.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForSelfWithMissingDefault() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForSelfWithMissingDefault.class))\n\t\t\t.withMessage(\"Misconfigured aliases: attribute 'a' in annotation [\"\n\t\t\t\t\t\t\t\t\t+ AliasForSelfWithMissingDefault.class.getName()\n\t\t\t\t\t\t\t\t\t+ \"] and attribute 'b' in annotation [\"\n\t\t\t\t\t\t\t\t\t+ AliasForSelfWithMissingDefault.class.getName()\n\t\t\t\t\t\t\t\t\t+ \"] must declare default values.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasWithExplicitMirrorAndDifferentDefaults() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasWithExplicitMirrorAndDifferentDefaults.class))\n\t\t\t.withMessage(\"Misconfigured aliases: attribute 'a' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasWithExplicitMirrorAndDifferentDefaults.class.getName()\n\t\t\t\t\t\t\t\t+ \"] and attribute 'c' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasWithExplicitMirrorAndDifferentDefaults.class.getName()\n\t\t\t\t\t\t\t\t+ \"] must declare the same default value.\");\n\t}\n\n\t@Test\n\tvoid getDistanceReturnsDistance() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(Mapped.class);\n\t\tassertThat(mappings.get(0).getDistance()).isEqualTo(0);\n\t\tassertThat(mappings.get(1).getDistance()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getAnnotationTypeReturnsAnnotationType() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(Mapped.class);\n\t\tassertThat(mappings.get(0).getAnnotationType()).isEqualTo(Mapped.class);\n\t\tassertThat(mappings.get(1).getAnnotationType()).isEqualTo(MappedTarget.class);\n\t}\n\n\t@Test\n\tvoid getMetaTypeReturnsTypes() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(ThreeDeepA.class);\n\t\tAnnotationTypeMapping mappingC = mappings.get(2);\n\t\tassertThat(mappingC.getMetaTypes()).containsExactly(ThreeDeepA.class, ThreeDeepB.class, ThreeDeepC.class);\n\t}\n\n\t@Test\n\tvoid getAnnotationWhenRootReturnsNull() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(Mapped.class);\n\t\tassertThat(mappings.get(0).getAnnotation()).isNull();\n\t}\n\n\t@Test\n\tvoid getAnnotationWhenMetaAnnotationReturnsAnnotation() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(Mapped.class);\n\t\tassertThat(mappings.get(1).getAnnotation()).isEqualTo(Mapped.class.getAnnotation(MappedTarget.class));\n\t}\n\n\t@Test\n\tvoid getAttributesReturnsAttributes() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(Mapped.class).get(0);\n\t\tAttributeMethods attributes = mapping.getAttributes();\n\t\tassertThat(attributes.size()).isEqualTo(2);\n\t\tassertThat(attributes.get(0).getName()).isEqualTo(\"alias\");\n\t\tassertThat(attributes.get(1).getName()).isEqualTo(\"convention\");\n\t}\n\n\t@Test\n\tvoid getAliasMappingReturnsAttributes() throws Exception {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(Mapped.class).get(1);\n\t\tassertThat(getAliasMapping(mapping, 0)).isEqualTo(Mapped.class.getDeclaredMethod(\"alias\"));\n\t}\n\n\t@Test\n\tvoid getConventionMappingReturnsAttributes() throws Exception {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(Mapped.class).get(1);\n\t\tassertThat(getConventionMapping(mapping, 1)).isEqualTo(Mapped.class.getDeclaredMethod(\"convention\"));\n\t}\n\n\t@Test\n\tvoid getMirrorSetWhenAliasPairReturnsMirrors() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\n\t\tMirrorSets mirrorSets = mapping.getMirrorSets();\n\t\tassertThat(mirrorSets.size()).isEqualTo(1);\n\t\tassertThat(mirrorSets.get(0).size()).isEqualTo(2);\n\t\tassertThat(mirrorSets.get(0).get(0).getName()).isEqualTo(\"a\");\n\t\tassertThat(mirrorSets.get(0).get(1).getName()).isEqualTo(\"b\");\n\t}\n\n\t@Test\n\tvoid getMirrorSetWhenImplicitMirrorsReturnsMirrors() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ImplicitMirrors.class).get(0);\n\t\tMirrorSets mirrorSets = mapping.getMirrorSets();\n\t\tassertThat(mirrorSets.size()).isEqualTo(1);\n\t\tassertThat(mirrorSets.get(0).size()).isEqualTo(2);\n\t\tassertThat(mirrorSets.get(0).get(0).getName()).isEqualTo(\"a\");\n\t\tassertThat(mirrorSets.get(0).get(1).getName()).isEqualTo(\"b\");\n\t}\n\n\t@Test\n\tvoid getMirrorSetWhenThreeDeepReturnsMirrors() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(ThreeDeepA.class);\n\t\tAnnotationTypeMapping mappingA = mappings.get(0);\n\t\tMirrorSets mirrorSetsA = mappingA.getMirrorSets();\n\t\tassertThat(mirrorSetsA.size()).isEqualTo(2);\n\t\tassertThat(getNames(mirrorSetsA.get(0))).containsExactly(\"a1\", \"a2\", \"a3\");\n\t\tAnnotationTypeMapping mappingB = mappings.get(1);\n\t\tMirrorSets mirrorSetsB = mappingB.getMirrorSets();\n\t\tassertThat(mirrorSetsB.size()).isEqualTo(1);\n\t\tassertThat(getNames(mirrorSetsB.get(0))).containsExactly(\"b1\", \"b2\");\n\t\tAnnotationTypeMapping mappingC = mappings.get(2);\n\t\tMirrorSets mirrorSetsC = mappingC.getMirrorSets();\n\t\tassertThat(mirrorSetsC.size()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getAliasMappingWhenThreeDeepReturnsMappedAttributes() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(ThreeDeepA.class);\n\t\tAnnotationTypeMapping mappingA = mappings.get(0);\n\t\tassertThat(getAliasMapping(mappingA, 0)).isNull();\n\t\tassertThat(getAliasMapping(mappingA, 1)).isNull();\n\t\tassertThat(getAliasMapping(mappingA, 2)).isNull();\n\t\tassertThat(getAliasMapping(mappingA, 3)).isNull();\n\t\tassertThat(getAliasMapping(mappingA, 4)).isNull();\n\t\tAnnotationTypeMapping mappingB = mappings.get(1);\n\t\tassertThat(getAliasMapping(mappingB, 0).getName()).isEqualTo(\"a1\");\n\t\tassertThat(getAliasMapping(mappingB, 1).getName()).isEqualTo(\"a1\");\n\t\tAnnotationTypeMapping mappingC = mappings.get(2);\n\t\tassertThat(getAliasMapping(mappingC, 0).getName()).isEqualTo(\"a1\");\n\t\tassertThat(getAliasMapping(mappingC, 1).getName()).isEqualTo(\"a4\");\n\t}\n\n\t@Test\n\tvoid getAliasMappingsWhenHasDefinedAttributesReturnsMappedAttributes() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(DefinedAttributes.class).get(1);\n\t\tassertThat(getAliasMapping(mapping, 0)).isNull();\n\t\tassertThat(getAliasMapping(mapping, 1).getName()).isEqualTo(\"value\");\n\t}\n\n\t@Test\n\tvoid resolveMirrorsWhenAliasPairResolves() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\n\t\tMethod[] resolvedA = resolveMirrorSets(mapping, WithAliasPairA.class, AliasPair.class);\n\t\tassertThat(resolvedA[0].getName()).isEqualTo(\"a\");\n\t\tassertThat(resolvedA[1].getName()).isEqualTo(\"a\");\n\t\tMethod[] resolvedB = resolveMirrorSets(mapping, WithAliasPairB.class, AliasPair.class);\n\t\tassertThat(resolvedB[0].getName()).isEqualTo(\"b\");\n\t\tassertThat(resolvedB[1].getName()).isEqualTo(\"b\");\n\t}\n\n\t@Test\n\tvoid resolveMirrorsWhenHasSameValuesUsesFirst() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\n\t\tMethod[] resolved = resolveMirrorSets(mapping, WithSameValueAliasPair.class, AliasPair.class);\n\t\tassertThat(resolved[0].getName()).isEqualTo(\"a\");\n\t\tassertThat(resolved[1].getName()).isEqualTo(\"a\");\n\t}\n\n\t@Test\n\tvoid resolveMirrorsWhenOnlyHasDefaultValuesUsesFirst() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\n\t\tMethod[] resolved = resolveMirrorSets(mapping, WithDefaultValueAliasPair.class, AliasPair.class);\n\t\tassertThat(resolved[0].getName()).isEqualTo(\"a\");\n\t\tassertThat(resolved[1].getName()).isEqualTo(\"a\");\n\t}\n\n\t@Test\n\tvoid resolveMirrorsWhenHasDifferentValuesThrowsException() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tresolveMirrorSets(mapping, WithDifferentValueAliasPair.class, AliasPair.class))\n\t\t\t.withMessage(\"Different @AliasFor mirror values for annotation [\"\n\t\t\t\t\t\t\t\t+ AliasPair.class.getName() + \"] declared on \"\n\t\t\t\t\t\t\t\t+ WithDifferentValueAliasPair.class.getName()\n\t\t\t\t\t\t\t\t+ \"; attribute 'a' and its alias 'b' are declared with values of [test1] and [test2].\");\n\t}\n\n\t@Test\n\tvoid resolveMirrorsWhenHasWithMultipleRoutesToAliasReturnsMirrors() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(\n\t\t\t\tMultipleRoutesToAliasA.class);\n\t\tAnnotationTypeMapping mappingsA = getMapping(mappings, MultipleRoutesToAliasA.class);\n\t\tassertThat(mappingsA.getMirrorSets().size()).isZero();\n\t\tAnnotationTypeMapping mappingsB = getMapping(mappings, MultipleRoutesToAliasB.class);\n\t\tassertThat(getNames(mappingsB.getMirrorSets().get(0))).containsExactly(\"b1\", \"b2\", \"b3\");\n\t\tAnnotationTypeMapping mappingsC = getMapping(mappings, MultipleRoutesToAliasC.class);\n\t\tassertThat(getNames(mappingsC.getMirrorSets().get(0))).containsExactly(\"c1\", \"c2\");\n\t}\n\n\t@Test\n\tvoid getAliasMappingWhenHasWithMultipleRoutesToAliasReturnsMappedAttributes() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(\n\t\t\t\tMultipleRoutesToAliasA.class);\n\t\tAnnotationTypeMapping mappingsA = getMapping(mappings, MultipleRoutesToAliasA.class);\n\t\tassertThat(getAliasMapping(mappingsA, 0)).isNull();\n\t\tAnnotationTypeMapping mappingsB = getMapping(mappings, MultipleRoutesToAliasB.class);\n\t\tassertThat(getAliasMapping(mappingsB, 0).getName()).isEqualTo(\"a1\");\n\t\tassertThat(getAliasMapping(mappingsB, 1).getName()).isEqualTo(\"a1\");\n\t\tassertThat(getAliasMapping(mappingsB, 2).getName()).isEqualTo(\"a1\");\n\t\tAnnotationTypeMapping mappingsC = getMapping(mappings, MultipleRoutesToAliasC.class);\n\t\tassertThat(getAliasMapping(mappingsC, 0).getName()).isEqualTo(\"a1\");\n\t\tassertThat(getAliasMapping(mappingsC, 1).getName()).isEqualTo(\"a1\");\n\t}\n\n\t@Test\n\tvoid getConventionMappingWhenConventionToExplicitAliasesReturnsMappedAttributes() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(ConventionToExplicitAliases.class);\n\t\tAnnotationTypeMapping mapping = getMapping(mappings, ConventionToExplicitAliasesTarget.class);\n\t\tassertThat(mapping.getConventionMapping(0)).isEqualTo(0);\n\t\tassertThat(mapping.getConventionMapping(1)).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenValueAndDefaultAreNullReturnsTrue() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassValue.class).get(0);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, null, ReflectionUtils::invokeMethod)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenValueAndDefaultMatchReturnsTrue() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassValueWithDefault.class).get(0);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, InputStream.class, ReflectionUtils::invokeMethod)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenClassAndStringNamesMatchReturnsTrue() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassValueWithDefault.class).get(0);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, \"java.io.InputStream\", ReflectionUtils::invokeMethod)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenClassArrayAndStringArrayNamesMatchReturnsTrue() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassArrayValueWithDefault.class).get(0);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0,\n\t\t\t\tnew String[] { \"java.io.InputStream\", \"java.io.OutputStream\" },\n\t\t\t\tReflectionUtils::invokeMethod)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenNestedAnnotationAndExtractedValuesMatchReturnsTrueAndValueSuppliedAsMap() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(NestedValue.class).get(0);\n\t\tMap<String, Object> value = Collections.singletonMap(\"value\", \"java.io.InputStream\");\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, value, TypeMappedAnnotation::extractFromMap)).isTrue();\n\t}\n\n\t@Test // gh-24375\n\tvoid isEquivalentToDefaultValueWhenNestedAnnotationAndExtractedValuesMatchReturnsTrueAndValueSuppliedAsTypeMappedAnnotation() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(NestedValue.class).get(0);\n\t\tMap<String, String> attributes = Collections.singletonMap(\"value\", \"java.io.InputStream\");\n\t\tMergedAnnotation<ClassValue> value = TypeMappedAnnotation.of(getClass().getClassLoader(), null, ClassValue.class, attributes);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, value, TypeMappedAnnotation::extractFromMap)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenNotMatchingReturnsFalse() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassValueWithDefault.class).get(0);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, OutputStream.class, ReflectionUtils::invokeMethod)).isFalse();\n\t}\n\n\tprivate Method[] resolveMirrorSets(AnnotationTypeMapping mapping, Class<?> element,\n\t\t\tClass<? extends Annotation> annotationClass) {\n\t\tAnnotation annotation = element.getAnnotation(annotationClass);\n\t\tint[] resolved = mapping.getMirrorSets().resolve(element.getName(), annotation, ReflectionUtils::invokeMethod);\n\t\tMethod[] result = new Method[resolved.length];\n\t\tfor (int i = 0; i < resolved.length; i++) {\n\t\t\tresult[i] = resolved[i] != -1 ? mapping.getAttributes().get(resolved[i]) : null;\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate @Nullable Method getAliasMapping(AnnotationTypeMapping mapping, int attributeIndex) {\n\t\tint mapped = mapping.getAliasMapping(attributeIndex);\n\t\treturn mapped != -1 ? mapping.getRoot().getAttributes().get(mapped) : null;\n\t}\n\n\tprivate @Nullable Method getConventionMapping(AnnotationTypeMapping mapping, int attributeIndex) {\n\t\tint mapped = mapping.getConventionMapping(attributeIndex);\n\t\treturn mapped != -1 ? mapping.getRoot().getAttributes().get(mapped) : null;\n\t}\n\n\tprivate AnnotationTypeMapping getMapping(AnnotationTypeMappings mappings,\n\t\t\tClass<? extends Annotation> annotationType) {\n\n\t\tfor (AnnotationTypeMapping candidate : getAll(mappings)) {\n\t\t\tif (candidate.getAnnotationType() == annotationType) {\n\t\t\t\treturn candidate;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate List<AnnotationTypeMapping> getAll(AnnotationTypeMappings mappings) {\n\t\t// AnnotationTypeMappings does not implement Iterable so we don't create\n\t\t// too many garbage Iterators\n\t\treturn IntStream.range(0, mappings.size()).mapToObj(mappings::get).collect(toList());\n\t}\n\n\tprivate List<String> getNames(MirrorSet mirrorSet) {\n\t\tList<String> names = new ArrayList<>(mirrorSet.size());\n\t\tfor (int i = 0; i < mirrorSet.size(); i++) {\n\t\t\tnames.add(mirrorSet.get(i).getName());\n\t\t}\n\t\treturn names;\n\t}\n\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SimpleAnnotation {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AA {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ABC {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ABC\n\t@interface AB {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AA\n\t@AB\n\t@interface A {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface B {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@A\n\t@B\n\t@interface MetaAnnotated {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Repeatings {\n\n\t\tRepeating[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(Repeatings.class)\n\t@interface Repeating {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeating\n\t@Repeating\n\t@interface WithRepeatedMetaAnnotations {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@SelfAnnotated\n\t@interface SelfAnnotated {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@LoopB\n\t@interface LoopA {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@LoopA\n\t@interface LoopB {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithBothValueAndAttribute {\n\n\t\t@AliasFor(value = \"bar\", attribute = \"foo\")\n\t\tString test();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForToSelfNonExistingAttribute {\n\n\t\t@AliasFor(\"missing\")\n\t\tString test() default \"\";\n\n\t\tString other() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForToOtherNonExistingAttributeTarget {\n\n\t\tString other() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasForToOtherNonExistingAttributeTarget\n\t@interface AliasForToOtherNonExistingAttribute {\n\n\t\t@AliasFor(annotation = AliasForToOtherNonExistingAttributeTarget.class, attribute = \"missing\")\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForToSelf {\n\n\t\t@AliasFor(\"test\")\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithArrayCompatibleReturnTypesTarget {\n\n\t\tString[] test() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasForWithArrayCompatibleReturnTypesTarget\n\t@interface AliasForWithArrayCompatibleReturnTypes {\n\n\t\t@AliasFor(annotation = AliasForWithArrayCompatibleReturnTypesTarget.class)\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithIncompatibleReturnTypesTarget {\n\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithIncompatibleReturnTypes {\n\n\t\t@AliasFor(annotation = AliasForWithIncompatibleReturnTypesTarget.class)\n\t\tString[] test() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForToSelfAnnotatedToOtherAttribute {\n\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"\";\n\n\t\t@AliasFor(\"c\")\n\t\tString b() default \"\";\n\n\t\t@AliasFor(\"a\")\n\t\tString c() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasPair {\n\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"\";\n\n\t\t@AliasFor(\"a\")\n\t\tString b() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasPair\n\t@interface AliasForWithMixedImplicitAndExplicitAliasesV1 {\n\n\t\t// attempted implicit alias via attribute override\n\t\t@AliasFor(annotation = AliasPair.class, attribute = \"b\")\n\t\tString b() default \"\";\n\n\t\t// explicit local alias\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasPair\n\t@interface AliasForWithMixedImplicitAndExplicitAliasesV2 {\n\n\t\t// attempted implicit alias via attribute override\n\t\t@AliasFor(annotation = AliasPair.class, attribute = \"a\")\n\t\tString b() default \"\";\n\n\t\t// explicit local alias\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForNonMetaAnnotated {\n\n\t\t@AliasFor(annotation = AliasForNonMetaAnnotatedTarget.class)\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForNonMetaAnnotatedTarget {\n\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForSelfWithDifferentDefaults {\n\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"a\";\n\n\t\t@AliasFor(\"a\")\n\t\tString b() default \"b\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForSelfWithMissingDefault {\n\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"a\";\n\n\t\t@AliasFor(\"a\")\n\t\tString b();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasWithExplicitMirrorAndDifferentDefaultsTarget {\n\n\t\tString a() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasWithExplicitMirrorAndDifferentDefaultsTarget\n\t@interface AliasWithExplicitMirrorAndDifferentDefaults {\n\n\t\t@AliasFor(annotation = AliasWithExplicitMirrorAndDifferentDefaultsTarget.class, attribute = \"a\")\n\t\tString a() default \"x\";\n\n\t\t@AliasFor(annotation = AliasWithExplicitMirrorAndDifferentDefaultsTarget.class, attribute = \"a\")\n\t\tString b() default \"x\";\n\n\t\t@AliasFor(annotation = AliasWithExplicitMirrorAndDifferentDefaultsTarget.class, attribute = \"a\")\n\t\tString c() default \"y\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MappedTarget {\n\n\t\tString convention() default \"\";\n\n\t\tString aliasTarget() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@MappedTarget\n\t@interface Mapped {\n\n\t\tString convention() default \"\";\n\n\t\t@AliasFor(annotation = MappedTarget.class, attribute = \"aliasTarget\")\n\t\tString alias() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitMirrorsTarget {\n\n\t\t@AliasFor(\"d\")\n\t\tString c() default \"\";\n\n\t\t@AliasFor(\"c\")\n\t\tString d() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ImplicitMirrorsTarget\n\t@interface ImplicitMirrors {\n\n\t\t@AliasFor(annotation = ImplicitMirrorsTarget.class, attribute = \"c\")\n\t\tString a() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitMirrorsTarget.class, attribute = \"c\")\n\t\tString b() default \"\";\n\t}\n\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ThreeDeepC {\n\n\t\tString c1() default \"\";\n\n\t\tString c2() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ThreeDeepC\n\t@interface ThreeDeepB {\n\n\t\t@AliasFor(annotation = ThreeDeepC.class, attribute = \"c1\")\n\t\tString b1() default \"\";\n\n\t\t@AliasFor(annotation = ThreeDeepC.class, attribute = \"c1\")\n\t\tString b2() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ThreeDeepB\n\t@interface ThreeDeepA {\n\n\t\t@AliasFor(annotation = ThreeDeepB.class, attribute = \"b1\")\n\t\tString a1() default \"\";\n\n\t\t@AliasFor(annotation = ThreeDeepB.class, attribute = \"b2\")\n\t\tString a2() default \"\";\n\n\t\t@AliasFor(annotation = ThreeDeepC.class, attribute = \"c1\")\n\t\tString a3() default \"\";\n\n\t\t@AliasFor(annotation = ThreeDeepC.class, attribute = \"c2\")\n\t\tString a4() default \"\";\n\n\t\t@AliasFor(annotation = ThreeDeepC.class, attribute = \"c2\")\n\t\tString a5() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface DefinedAttributesTarget {\n\n\t\tString a();\n\n\t\tString b() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefinedAttributesTarget(a = \"test\")\n\t@interface DefinedAttributes {\n\n\t\t@AliasFor(annotation = DefinedAttributesTarget.class, attribute = \"b\")\n\t\tString value();\n\t}\n\n\t@AliasPair(a = \"test\")\n\tstatic class WithAliasPairA {\n\t}\n\n\t@AliasPair(b = \"test\")\n\tstatic class WithAliasPairB {\n\t}\n\n\t@AliasPair(a = \"test\", b = \"test\")\n\tstatic class WithSameValueAliasPair {\n\t}\n\n\t@AliasPair(a = \"test1\", b = \"test2\")\n\tstatic class WithDifferentValueAliasPair {\n\t}\n\n\t@AliasPair\n\tstatic class WithDefaultValueAliasPair {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MultipleRoutesToAliasC {\n\n\t\t@AliasFor(\"c2\")\n\t\tString c1() default \"\";\n\n\t\t@AliasFor(\"c1\")\n\t\tString c2() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@MultipleRoutesToAliasC\n\t@interface MultipleRoutesToAliasB {\n\n\t\t@AliasFor(annotation = MultipleRoutesToAliasC.class, attribute = \"c2\")\n\t\tString b1() default \"\";\n\n\t\t@AliasFor(annotation = MultipleRoutesToAliasC.class, attribute = \"c2\")\n\t\tString b2() default \"\";\n\n\t\t@AliasFor(annotation = MultipleRoutesToAliasC.class, attribute = \"c1\")\n\t\tString b3() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@MultipleRoutesToAliasB\n\t@interface MultipleRoutesToAliasA {\n\n\t\t@AliasFor(annotation = MultipleRoutesToAliasB.class, attribute = \"b2\")\n\t\tString a1() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionToExplicitAliasesTarget {\n\n\t\t@AliasFor(\"test\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ConventionToExplicitAliasesTarget\n\t@interface ConventionToExplicitAliases {\n\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ClassValue {\n\n\t\tClass<?> value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ClassValueWithDefault {\n\n\t\tClass<?> value() default InputStream.class;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ClassArrayValueWithDefault {\n\n\t\tClass<?>[] value() default { InputStream.class, OutputStream.class };\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface NestedValue {\n\n\t\tClassValue value() default @ClassValue(InputStream.class);\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.WithDifferentValueAliasPair",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.WithDifferentValueAliasPair",
    "headType": "class",
    "relation": "use",
    "tail": "@AliasPair",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.WithDifferentValueAliasPair",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.IntStream;\n\nimport javax.annotation.Nullable;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.AnnotationTypeMapping.MirrorSets;\nimport org.springframework.core.annotation.AnnotationTypeMapping.MirrorSets.MirrorSet;\nimport org.springframework.util.ReflectionUtils;\n\nimport static java.util.stream.Collectors.toList;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n\n/**\n * Tests for {@link AnnotationTypeMappings} and {@link AnnotationTypeMapping}.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n */\nclass AnnotationTypeMappingsTests {\n\n\t@Test\n\tvoid forAnnotationTypeWhenNoMetaAnnotationsReturnsMappings() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(SimpleAnnotation.class);\n\t\tassertThat(mappings.size()).isEqualTo(1);\n\t\tassertThat(mappings.get(0).getAnnotationType()).isEqualTo(SimpleAnnotation.class);\n\t\tassertThat(getAll(mappings)).flatExtracting(\n\t\t\t\tAnnotationTypeMapping::getAnnotationType).containsExactly(SimpleAnnotation.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenMetaAnnotationsReturnsMappings() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(MetaAnnotated.class);\n\t\tassertThat(mappings.size()).isEqualTo(6);\n\t\tassertThat(getAll(mappings)).flatExtracting(\n\t\t\t\tAnnotationTypeMapping::getAnnotationType).containsExactly(\n\t\t\t\t\t\tMetaAnnotated.class, A.class, B.class, AA.class, AB.class,\n\t\t\t\t\t\tABC.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenHasRepeatingMetaAnnotationReturnsMapping() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(WithRepeatedMetaAnnotations.class);\n\t\tassertThat(mappings.size()).isEqualTo(3);\n\t\tassertThat(getAll(mappings)).flatExtracting(\n\t\t\t\tAnnotationTypeMapping::getAnnotationType).containsExactly(\n\t\t\t\t\t\tWithRepeatedMetaAnnotations.class, Repeating.class, Repeating.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenRepeatableMetaAnnotationIsFiltered() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(WithRepeatedMetaAnnotations.class,\n\t\t\t\tRepeatableContainers.standardRepeatables(), Repeating.class.getName()::equals);\n\t\tassertThat(getAll(mappings)).flatExtracting(AnnotationTypeMapping::getAnnotationType)\n\t\t\t\t.containsExactly(WithRepeatedMetaAnnotations.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenSelfAnnotatedReturnsMapping() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(SelfAnnotated.class);\n\t\tassertThat(mappings.size()).isEqualTo(1);\n\t\tassertThat(getAll(mappings)).flatExtracting(\n\t\t\t\tAnnotationTypeMapping::getAnnotationType).containsExactly(SelfAnnotated.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenFormsLoopReturnsMapping() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(LoopA.class);\n\t\tassertThat(mappings.size()).isEqualTo(2);\n\t\tassertThat(getAll(mappings)).flatExtracting(\n\t\t\t\tAnnotationTypeMapping::getAnnotationType).containsExactly(LoopA.class, LoopB.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenHasAliasForWithBothValueAndAttributeThrowsException() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForWithBothValueAndAttribute.class))\n\t\t\t.withMessage(\"In @AliasFor declared on attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForWithBothValueAndAttribute.class.getName()\n\t\t\t\t\t\t\t\t+ \"], attribute 'attribute' and its alias 'value' are present with values of 'foo' and 'bar', but only one is permitted.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForToSelfNonExistingAttribute() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForToSelfNonExistingAttribute.class))\n\t\t\t.withMessage(\"@AliasFor declaration on attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForToSelfNonExistingAttribute.class.getName()\n\t\t\t\t\t\t\t\t+ \"] declares an alias for 'missing' which is not present.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForToOtherNonExistingAttribute() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForToOtherNonExistingAttribute.class))\n\t\t\t.withMessage(\"Attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForToOtherNonExistingAttribute.class.getName()\n\t\t\t\t\t\t\t\t+ \"] is declared as an @AliasFor nonexistent \"\n\t\t\t\t\t\t\t\t+ \"attribute 'missing' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForToOtherNonExistingAttributeTarget.class.getName()\n\t\t\t\t\t\t\t\t+ \"].\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForToSelf() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForToSelf.class))\n\t\t\t.withMessage(\"@AliasFor declaration on attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForToSelf.class.getName()\n\t\t\t\t\t\t\t\t+ \"] points to itself. Specify 'annotation' to point to \"\n\t\t\t\t\t\t\t\t+ \"a same-named attribute on a meta-annotation.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForWithArrayCompatibleReturnTypes() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(\n\t\t\t\tAliasForWithArrayCompatibleReturnTypes.class);\n\t\tAnnotationTypeMapping mapping = getMapping(mappings,\n\t\t\t\tAliasForWithArrayCompatibleReturnTypesTarget.class);\n\t\tassertThat(getAliasMapping(mapping, 0).getName()).isEqualTo(\"test\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForWithIncompatibleReturnTypes() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForWithIncompatibleReturnTypes.class))\n\t\t\t.withMessage(\"Misconfigured aliases: attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForWithIncompatibleReturnTypes.class.getName()\n\t\t\t\t\t\t\t\t+ \"] and attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForWithIncompatibleReturnTypesTarget.class.getName()\n\t\t\t\t\t\t\t\t+ \"] must declare the same return type.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForToSelfAnnotatedToOtherAttribute() {\n\t\tString annotationType = AliasForToSelfAnnotatedToOtherAttribute.class.getName();\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> AnnotationTypeMappings.forAnnotationType(AliasForToSelfAnnotatedToOtherAttribute.class))\n\t\t\t\t.withMessage(\"Attribute 'b' in annotation [\" + annotationType\n\t\t\t\t\t\t+ \"] must be declared as an @AliasFor attribute 'a' in annotation [\" + annotationType\n\t\t\t\t\t\t+ \"], not attribute 'c' in annotation [\" + annotationType + \"].\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForHasMixedImplicitAndExplicitAliases() {\n\t\tassertMixedImplicitAndExplicitAliases(AliasForWithMixedImplicitAndExplicitAliasesV1.class, \"b\");\n\t\tassertMixedImplicitAndExplicitAliases(AliasForWithMixedImplicitAndExplicitAliasesV2.class, \"a\");\n\t}\n\n\tprivate void assertMixedImplicitAndExplicitAliases(Class<? extends Annotation> annotationType, String overriddenAttribute) {\n\t\tString annotationName = annotationType.getName();\n\t\tString metaAnnotationName = AliasPair.class.getName();\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> AnnotationTypeMappings.forAnnotationType(annotationType))\n\t\t\t\t.withMessage(\"Attribute 'b' in annotation [\" + annotationName\n\t\t\t\t\t\t+ \"] must be declared as an @AliasFor attribute 'a' in annotation [\" + annotationName\n\t\t\t\t\t\t+ \"], not attribute '\" + overriddenAttribute + \"' in annotation [\" + metaAnnotationName + \"].\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForNonMetaAnnotated() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForNonMetaAnnotated.class))\n\t\t\t.withMessage(\"@AliasFor declaration on attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForNonMetaAnnotated.class.getName()\n\t\t\t\t\t\t\t\t+ \"] declares an alias for attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForNonMetaAnnotatedTarget.class.getName()\n\t\t\t\t\t\t\t\t+ \"] which is not meta-present.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForSelfWithDifferentDefaults() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForSelfWithDifferentDefaults.class))\n\t\t\t.withMessage(\"Misconfigured aliases: attribute 'a' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForSelfWithDifferentDefaults.class.getName()\n\t\t\t\t\t\t\t\t+ \"] and attribute 'b' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForSelfWithDifferentDefaults.class.getName()\n\t\t\t\t\t\t\t\t+ \"] must declare the same default value.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForSelfWithMissingDefault() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForSelfWithMissingDefault.class))\n\t\t\t.withMessage(\"Misconfigured aliases: attribute 'a' in annotation [\"\n\t\t\t\t\t\t\t\t\t+ AliasForSelfWithMissingDefault.class.getName()\n\t\t\t\t\t\t\t\t\t+ \"] and attribute 'b' in annotation [\"\n\t\t\t\t\t\t\t\t\t+ AliasForSelfWithMissingDefault.class.getName()\n\t\t\t\t\t\t\t\t\t+ \"] must declare default values.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasWithExplicitMirrorAndDifferentDefaults() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasWithExplicitMirrorAndDifferentDefaults.class))\n\t\t\t.withMessage(\"Misconfigured aliases: attribute 'a' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasWithExplicitMirrorAndDifferentDefaults.class.getName()\n\t\t\t\t\t\t\t\t+ \"] and attribute 'c' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasWithExplicitMirrorAndDifferentDefaults.class.getName()\n\t\t\t\t\t\t\t\t+ \"] must declare the same default value.\");\n\t}\n\n\t@Test\n\tvoid getDistanceReturnsDistance() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(Mapped.class);\n\t\tassertThat(mappings.get(0).getDistance()).isEqualTo(0);\n\t\tassertThat(mappings.get(1).getDistance()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getAnnotationTypeReturnsAnnotationType() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(Mapped.class);\n\t\tassertThat(mappings.get(0).getAnnotationType()).isEqualTo(Mapped.class);\n\t\tassertThat(mappings.get(1).getAnnotationType()).isEqualTo(MappedTarget.class);\n\t}\n\n\t@Test\n\tvoid getMetaTypeReturnsTypes() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(ThreeDeepA.class);\n\t\tAnnotationTypeMapping mappingC = mappings.get(2);\n\t\tassertThat(mappingC.getMetaTypes()).containsExactly(ThreeDeepA.class, ThreeDeepB.class, ThreeDeepC.class);\n\t}\n\n\t@Test\n\tvoid getAnnotationWhenRootReturnsNull() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(Mapped.class);\n\t\tassertThat(mappings.get(0).getAnnotation()).isNull();\n\t}\n\n\t@Test\n\tvoid getAnnotationWhenMetaAnnotationReturnsAnnotation() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(Mapped.class);\n\t\tassertThat(mappings.get(1).getAnnotation()).isEqualTo(Mapped.class.getAnnotation(MappedTarget.class));\n\t}\n\n\t@Test\n\tvoid getAttributesReturnsAttributes() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(Mapped.class).get(0);\n\t\tAttributeMethods attributes = mapping.getAttributes();\n\t\tassertThat(attributes.size()).isEqualTo(2);\n\t\tassertThat(attributes.get(0).getName()).isEqualTo(\"alias\");\n\t\tassertThat(attributes.get(1).getName()).isEqualTo(\"convention\");\n\t}\n\n\t@Test\n\tvoid getAliasMappingReturnsAttributes() throws Exception {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(Mapped.class).get(1);\n\t\tassertThat(getAliasMapping(mapping, 0)).isEqualTo(Mapped.class.getDeclaredMethod(\"alias\"));\n\t}\n\n\t@Test\n\tvoid getConventionMappingReturnsAttributes() throws Exception {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(Mapped.class).get(1);\n\t\tassertThat(getConventionMapping(mapping, 1)).isEqualTo(Mapped.class.getDeclaredMethod(\"convention\"));\n\t}\n\n\t@Test\n\tvoid getMirrorSetWhenAliasPairReturnsMirrors() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\n\t\tMirrorSets mirrorSets = mapping.getMirrorSets();\n\t\tassertThat(mirrorSets.size()).isEqualTo(1);\n\t\tassertThat(mirrorSets.get(0).size()).isEqualTo(2);\n\t\tassertThat(mirrorSets.get(0).get(0).getName()).isEqualTo(\"a\");\n\t\tassertThat(mirrorSets.get(0).get(1).getName()).isEqualTo(\"b\");\n\t}\n\n\t@Test\n\tvoid getMirrorSetWhenImplicitMirrorsReturnsMirrors() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ImplicitMirrors.class).get(0);\n\t\tMirrorSets mirrorSets = mapping.getMirrorSets();\n\t\tassertThat(mirrorSets.size()).isEqualTo(1);\n\t\tassertThat(mirrorSets.get(0).size()).isEqualTo(2);\n\t\tassertThat(mirrorSets.get(0).get(0).getName()).isEqualTo(\"a\");\n\t\tassertThat(mirrorSets.get(0).get(1).getName()).isEqualTo(\"b\");\n\t}\n\n\t@Test\n\tvoid getMirrorSetWhenThreeDeepReturnsMirrors() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(ThreeDeepA.class);\n\t\tAnnotationTypeMapping mappingA = mappings.get(0);\n\t\tMirrorSets mirrorSetsA = mappingA.getMirrorSets();\n\t\tassertThat(mirrorSetsA.size()).isEqualTo(2);\n\t\tassertThat(getNames(mirrorSetsA.get(0))).containsExactly(\"a1\", \"a2\", \"a3\");\n\t\tAnnotationTypeMapping mappingB = mappings.get(1);\n\t\tMirrorSets mirrorSetsB = mappingB.getMirrorSets();\n\t\tassertThat(mirrorSetsB.size()).isEqualTo(1);\n\t\tassertThat(getNames(mirrorSetsB.get(0))).containsExactly(\"b1\", \"b2\");\n\t\tAnnotationTypeMapping mappingC = mappings.get(2);\n\t\tMirrorSets mirrorSetsC = mappingC.getMirrorSets();\n\t\tassertThat(mirrorSetsC.size()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getAliasMappingWhenThreeDeepReturnsMappedAttributes() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(ThreeDeepA.class);\n\t\tAnnotationTypeMapping mappingA = mappings.get(0);\n\t\tassertThat(getAliasMapping(mappingA, 0)).isNull();\n\t\tassertThat(getAliasMapping(mappingA, 1)).isNull();\n\t\tassertThat(getAliasMapping(mappingA, 2)).isNull();\n\t\tassertThat(getAliasMapping(mappingA, 3)).isNull();\n\t\tassertThat(getAliasMapping(mappingA, 4)).isNull();\n\t\tAnnotationTypeMapping mappingB = mappings.get(1);\n\t\tassertThat(getAliasMapping(mappingB, 0).getName()).isEqualTo(\"a1\");\n\t\tassertThat(getAliasMapping(mappingB, 1).getName()).isEqualTo(\"a1\");\n\t\tAnnotationTypeMapping mappingC = mappings.get(2);\n\t\tassertThat(getAliasMapping(mappingC, 0).getName()).isEqualTo(\"a1\");\n\t\tassertThat(getAliasMapping(mappingC, 1).getName()).isEqualTo(\"a4\");\n\t}\n\n\t@Test\n\tvoid getAliasMappingsWhenHasDefinedAttributesReturnsMappedAttributes() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(DefinedAttributes.class).get(1);\n\t\tassertThat(getAliasMapping(mapping, 0)).isNull();\n\t\tassertThat(getAliasMapping(mapping, 1).getName()).isEqualTo(\"value\");\n\t}\n\n\t@Test\n\tvoid resolveMirrorsWhenAliasPairResolves() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\n\t\tMethod[] resolvedA = resolveMirrorSets(mapping, WithAliasPairA.class, AliasPair.class);\n\t\tassertThat(resolvedA[0].getName()).isEqualTo(\"a\");\n\t\tassertThat(resolvedA[1].getName()).isEqualTo(\"a\");\n\t\tMethod[] resolvedB = resolveMirrorSets(mapping, WithAliasPairB.class, AliasPair.class);\n\t\tassertThat(resolvedB[0].getName()).isEqualTo(\"b\");\n\t\tassertThat(resolvedB[1].getName()).isEqualTo(\"b\");\n\t}\n\n\t@Test\n\tvoid resolveMirrorsWhenHasSameValuesUsesFirst() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\n\t\tMethod[] resolved = resolveMirrorSets(mapping, WithSameValueAliasPair.class, AliasPair.class);\n\t\tassertThat(resolved[0].getName()).isEqualTo(\"a\");\n\t\tassertThat(resolved[1].getName()).isEqualTo(\"a\");\n\t}\n\n\t@Test\n\tvoid resolveMirrorsWhenOnlyHasDefaultValuesUsesFirst() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\n\t\tMethod[] resolved = resolveMirrorSets(mapping, WithDefaultValueAliasPair.class, AliasPair.class);\n\t\tassertThat(resolved[0].getName()).isEqualTo(\"a\");\n\t\tassertThat(resolved[1].getName()).isEqualTo(\"a\");\n\t}\n\n\t@Test\n\tvoid resolveMirrorsWhenHasDifferentValuesThrowsException() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tresolveMirrorSets(mapping, WithDifferentValueAliasPair.class, AliasPair.class))\n\t\t\t.withMessage(\"Different @AliasFor mirror values for annotation [\"\n\t\t\t\t\t\t\t\t+ AliasPair.class.getName() + \"] declared on \"\n\t\t\t\t\t\t\t\t+ WithDifferentValueAliasPair.class.getName()\n\t\t\t\t\t\t\t\t+ \"; attribute 'a' and its alias 'b' are declared with values of [test1] and [test2].\");\n\t}\n\n\t@Test\n\tvoid resolveMirrorsWhenHasWithMultipleRoutesToAliasReturnsMirrors() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(\n\t\t\t\tMultipleRoutesToAliasA.class);\n\t\tAnnotationTypeMapping mappingsA = getMapping(mappings, MultipleRoutesToAliasA.class);\n\t\tassertThat(mappingsA.getMirrorSets().size()).isZero();\n\t\tAnnotationTypeMapping mappingsB = getMapping(mappings, MultipleRoutesToAliasB.class);\n\t\tassertThat(getNames(mappingsB.getMirrorSets().get(0))).containsExactly(\"b1\", \"b2\", \"b3\");\n\t\tAnnotationTypeMapping mappingsC = getMapping(mappings, MultipleRoutesToAliasC.class);\n\t\tassertThat(getNames(mappingsC.getMirrorSets().get(0))).containsExactly(\"c1\", \"c2\");\n\t}\n\n\t@Test\n\tvoid getAliasMappingWhenHasWithMultipleRoutesToAliasReturnsMappedAttributes() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(\n\t\t\t\tMultipleRoutesToAliasA.class);\n\t\tAnnotationTypeMapping mappingsA = getMapping(mappings, MultipleRoutesToAliasA.class);\n\t\tassertThat(getAliasMapping(mappingsA, 0)).isNull();\n\t\tAnnotationTypeMapping mappingsB = getMapping(mappings, MultipleRoutesToAliasB.class);\n\t\tassertThat(getAliasMapping(mappingsB, 0).getName()).isEqualTo(\"a1\");\n\t\tassertThat(getAliasMapping(mappingsB, 1).getName()).isEqualTo(\"a1\");\n\t\tassertThat(getAliasMapping(mappingsB, 2).getName()).isEqualTo(\"a1\");\n\t\tAnnotationTypeMapping mappingsC = getMapping(mappings, MultipleRoutesToAliasC.class);\n\t\tassertThat(getAliasMapping(mappingsC, 0).getName()).isEqualTo(\"a1\");\n\t\tassertThat(getAliasMapping(mappingsC, 1).getName()).isEqualTo(\"a1\");\n\t}\n\n\t@Test\n\tvoid getConventionMappingWhenConventionToExplicitAliasesReturnsMappedAttributes() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(ConventionToExplicitAliases.class);\n\t\tAnnotationTypeMapping mapping = getMapping(mappings, ConventionToExplicitAliasesTarget.class);\n\t\tassertThat(mapping.getConventionMapping(0)).isEqualTo(0);\n\t\tassertThat(mapping.getConventionMapping(1)).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenValueAndDefaultAreNullReturnsTrue() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassValue.class).get(0);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, null, ReflectionUtils::invokeMethod)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenValueAndDefaultMatchReturnsTrue() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassValueWithDefault.class).get(0);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, InputStream.class, ReflectionUtils::invokeMethod)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenClassAndStringNamesMatchReturnsTrue() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassValueWithDefault.class).get(0);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, \"java.io.InputStream\", ReflectionUtils::invokeMethod)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenClassArrayAndStringArrayNamesMatchReturnsTrue() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassArrayValueWithDefault.class).get(0);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0,\n\t\t\t\tnew String[] { \"java.io.InputStream\", \"java.io.OutputStream\" },\n\t\t\t\tReflectionUtils::invokeMethod)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenNestedAnnotationAndExtractedValuesMatchReturnsTrueAndValueSuppliedAsMap() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(NestedValue.class).get(0);\n\t\tMap<String, Object> value = Collections.singletonMap(\"value\", \"java.io.InputStream\");\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, value, TypeMappedAnnotation::extractFromMap)).isTrue();\n\t}\n\n\t@Test // gh-24375\n\tvoid isEquivalentToDefaultValueWhenNestedAnnotationAndExtractedValuesMatchReturnsTrueAndValueSuppliedAsTypeMappedAnnotation() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(NestedValue.class).get(0);\n\t\tMap<String, String> attributes = Collections.singletonMap(\"value\", \"java.io.InputStream\");\n\t\tMergedAnnotation<ClassValue> value = TypeMappedAnnotation.of(getClass().getClassLoader(), null, ClassValue.class, attributes);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, value, TypeMappedAnnotation::extractFromMap)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenNotMatchingReturnsFalse() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassValueWithDefault.class).get(0);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, OutputStream.class, ReflectionUtils::invokeMethod)).isFalse();\n\t}\n\n\tprivate Method[] resolveMirrorSets(AnnotationTypeMapping mapping, Class<?> element,\n\t\t\tClass<? extends Annotation> annotationClass) {\n\t\tAnnotation annotation = element.getAnnotation(annotationClass);\n\t\tint[] resolved = mapping.getMirrorSets().resolve(element.getName(), annotation, ReflectionUtils::invokeMethod);\n\t\tMethod[] result = new Method[resolved.length];\n\t\tfor (int i = 0; i < resolved.length; i++) {\n\t\t\tresult[i] = resolved[i] != -1 ? mapping.getAttributes().get(resolved[i]) : null;\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate @Nullable Method getAliasMapping(AnnotationTypeMapping mapping, int attributeIndex) {\n\t\tint mapped = mapping.getAliasMapping(attributeIndex);\n\t\treturn mapped != -1 ? mapping.getRoot().getAttributes().get(mapped) : null;\n\t}\n\n\tprivate @Nullable Method getConventionMapping(AnnotationTypeMapping mapping, int attributeIndex) {\n\t\tint mapped = mapping.getConventionMapping(attributeIndex);\n\t\treturn mapped != -1 ? mapping.getRoot().getAttributes().get(mapped) : null;\n\t}\n\n\tprivate AnnotationTypeMapping getMapping(AnnotationTypeMappings mappings,\n\t\t\tClass<? extends Annotation> annotationType) {\n\n\t\tfor (AnnotationTypeMapping candidate : getAll(mappings)) {\n\t\t\tif (candidate.getAnnotationType() == annotationType) {\n\t\t\t\treturn candidate;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate List<AnnotationTypeMapping> getAll(AnnotationTypeMappings mappings) {\n\t\t// AnnotationTypeMappings does not implement Iterable so we don't create\n\t\t// too many garbage Iterators\n\t\treturn IntStream.range(0, mappings.size()).mapToObj(mappings::get).collect(toList());\n\t}\n\n\tprivate List<String> getNames(MirrorSet mirrorSet) {\n\t\tList<String> names = new ArrayList<>(mirrorSet.size());\n\t\tfor (int i = 0; i < mirrorSet.size(); i++) {\n\t\t\tnames.add(mirrorSet.get(i).getName());\n\t\t}\n\t\treturn names;\n\t}\n\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SimpleAnnotation {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AA {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ABC {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ABC\n\t@interface AB {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AA\n\t@AB\n\t@interface A {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface B {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@A\n\t@B\n\t@interface MetaAnnotated {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Repeatings {\n\n\t\tRepeating[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(Repeatings.class)\n\t@interface Repeating {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeating\n\t@Repeating\n\t@interface WithRepeatedMetaAnnotations {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@SelfAnnotated\n\t@interface SelfAnnotated {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@LoopB\n\t@interface LoopA {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@LoopA\n\t@interface LoopB {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithBothValueAndAttribute {\n\n\t\t@AliasFor(value = \"bar\", attribute = \"foo\")\n\t\tString test();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForToSelfNonExistingAttribute {\n\n\t\t@AliasFor(\"missing\")\n\t\tString test() default \"\";\n\n\t\tString other() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForToOtherNonExistingAttributeTarget {\n\n\t\tString other() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasForToOtherNonExistingAttributeTarget\n\t@interface AliasForToOtherNonExistingAttribute {\n\n\t\t@AliasFor(annotation = AliasForToOtherNonExistingAttributeTarget.class, attribute = \"missing\")\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForToSelf {\n\n\t\t@AliasFor(\"test\")\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithArrayCompatibleReturnTypesTarget {\n\n\t\tString[] test() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasForWithArrayCompatibleReturnTypesTarget\n\t@interface AliasForWithArrayCompatibleReturnTypes {\n\n\t\t@AliasFor(annotation = AliasForWithArrayCompatibleReturnTypesTarget.class)\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithIncompatibleReturnTypesTarget {\n\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithIncompatibleReturnTypes {\n\n\t\t@AliasFor(annotation = AliasForWithIncompatibleReturnTypesTarget.class)\n\t\tString[] test() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForToSelfAnnotatedToOtherAttribute {\n\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"\";\n\n\t\t@AliasFor(\"c\")\n\t\tString b() default \"\";\n\n\t\t@AliasFor(\"a\")\n\t\tString c() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasPair {\n\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"\";\n\n\t\t@AliasFor(\"a\")\n\t\tString b() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasPair\n\t@interface AliasForWithMixedImplicitAndExplicitAliasesV1 {\n\n\t\t// attempted implicit alias via attribute override\n\t\t@AliasFor(annotation = AliasPair.class, attribute = \"b\")\n\t\tString b() default \"\";\n\n\t\t// explicit local alias\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasPair\n\t@interface AliasForWithMixedImplicitAndExplicitAliasesV2 {\n\n\t\t// attempted implicit alias via attribute override\n\t\t@AliasFor(annotation = AliasPair.class, attribute = \"a\")\n\t\tString b() default \"\";\n\n\t\t// explicit local alias\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForNonMetaAnnotated {\n\n\t\t@AliasFor(annotation = AliasForNonMetaAnnotatedTarget.class)\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForNonMetaAnnotatedTarget {\n\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForSelfWithDifferentDefaults {\n\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"a\";\n\n\t\t@AliasFor(\"a\")\n\t\tString b() default \"b\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForSelfWithMissingDefault {\n\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"a\";\n\n\t\t@AliasFor(\"a\")\n\t\tString b();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasWithExplicitMirrorAndDifferentDefaultsTarget {\n\n\t\tString a() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasWithExplicitMirrorAndDifferentDefaultsTarget\n\t@interface AliasWithExplicitMirrorAndDifferentDefaults {\n\n\t\t@AliasFor(annotation = AliasWithExplicitMirrorAndDifferentDefaultsTarget.class, attribute = \"a\")\n\t\tString a() default \"x\";\n\n\t\t@AliasFor(annotation = AliasWithExplicitMirrorAndDifferentDefaultsTarget.class, attribute = \"a\")\n\t\tString b() default \"x\";\n\n\t\t@AliasFor(annotation = AliasWithExplicitMirrorAndDifferentDefaultsTarget.class, attribute = \"a\")\n\t\tString c() default \"y\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MappedTarget {\n\n\t\tString convention() default \"\";\n\n\t\tString aliasTarget() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@MappedTarget\n\t@interface Mapped {\n\n\t\tString convention() default \"\";\n\n\t\t@AliasFor(annotation = MappedTarget.class, attribute = \"aliasTarget\")\n\t\tString alias() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitMirrorsTarget {\n\n\t\t@AliasFor(\"d\")\n\t\tString c() default \"\";\n\n\t\t@AliasFor(\"c\")\n\t\tString d() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ImplicitMirrorsTarget\n\t@interface ImplicitMirrors {\n\n\t\t@AliasFor(annotation = ImplicitMirrorsTarget.class, attribute = \"c\")\n\t\tString a() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitMirrorsTarget.class, attribute = \"c\")\n\t\tString b() default \"\";\n\t}\n\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ThreeDeepC {\n\n\t\tString c1() default \"\";\n\n\t\tString c2() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ThreeDeepC\n\t@interface ThreeDeepB {\n\n\t\t@AliasFor(annotation = ThreeDeepC.class, attribute = \"c1\")\n\t\tString b1() default \"\";\n\n\t\t@AliasFor(annotation = ThreeDeepC.class, attribute = \"c1\")\n\t\tString b2() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ThreeDeepB\n\t@interface ThreeDeepA {\n\n\t\t@AliasFor(annotation = ThreeDeepB.class, attribute = \"b1\")\n\t\tString a1() default \"\";\n\n\t\t@AliasFor(annotation = ThreeDeepB.class, attribute = \"b2\")\n\t\tString a2() default \"\";\n\n\t\t@AliasFor(annotation = ThreeDeepC.class, attribute = \"c1\")\n\t\tString a3() default \"\";\n\n\t\t@AliasFor(annotation = ThreeDeepC.class, attribute = \"c2\")\n\t\tString a4() default \"\";\n\n\t\t@AliasFor(annotation = ThreeDeepC.class, attribute = \"c2\")\n\t\tString a5() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface DefinedAttributesTarget {\n\n\t\tString a();\n\n\t\tString b() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefinedAttributesTarget(a = \"test\")\n\t@interface DefinedAttributes {\n\n\t\t@AliasFor(annotation = DefinedAttributesTarget.class, attribute = \"b\")\n\t\tString value();\n\t}\n\n\t@AliasPair(a = \"test\")\n\tstatic class WithAliasPairA {\n\t}\n\n\t@AliasPair(b = \"test\")\n\tstatic class WithAliasPairB {\n\t}\n\n\t@AliasPair(a = \"test\", b = \"test\")\n\tstatic class WithSameValueAliasPair {\n\t}\n\n\t@AliasPair(a = \"test1\", b = \"test2\")\n\tstatic class WithDifferentValueAliasPair {\n\t}\n\n\t@AliasPair\n\tstatic class WithDefaultValueAliasPair {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MultipleRoutesToAliasC {\n\n\t\t@AliasFor(\"c2\")\n\t\tString c1() default \"\";\n\n\t\t@AliasFor(\"c1\")\n\t\tString c2() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@MultipleRoutesToAliasC\n\t@interface MultipleRoutesToAliasB {\n\n\t\t@AliasFor(annotation = MultipleRoutesToAliasC.class, attribute = \"c2\")\n\t\tString b1() default \"\";\n\n\t\t@AliasFor(annotation = MultipleRoutesToAliasC.class, attribute = \"c2\")\n\t\tString b2() default \"\";\n\n\t\t@AliasFor(annotation = MultipleRoutesToAliasC.class, attribute = \"c1\")\n\t\tString b3() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@MultipleRoutesToAliasB\n\t@interface MultipleRoutesToAliasA {\n\n\t\t@AliasFor(annotation = MultipleRoutesToAliasB.class, attribute = \"b2\")\n\t\tString a1() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionToExplicitAliasesTarget {\n\n\t\t@AliasFor(\"test\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ConventionToExplicitAliasesTarget\n\t@interface ConventionToExplicitAliases {\n\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ClassValue {\n\n\t\tClass<?> value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ClassValueWithDefault {\n\n\t\tClass<?> value() default InputStream.class;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ClassArrayValueWithDefault {\n\n\t\tClass<?>[] value() default { InputStream.class, OutputStream.class };\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface NestedValue {\n\n\t\tClassValue value() default @ClassValue(InputStream.class);\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.WithDefaultValueAliasPair",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.WithDefaultValueAliasPair",
    "headType": "class",
    "relation": "use",
    "tail": "@AliasPair",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.WithDefaultValueAliasPair",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.IntStream;\n\nimport javax.annotation.Nullable;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.AnnotationTypeMapping.MirrorSets;\nimport org.springframework.core.annotation.AnnotationTypeMapping.MirrorSets.MirrorSet;\nimport org.springframework.util.ReflectionUtils;\n\nimport static java.util.stream.Collectors.toList;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n\n/**\n * Tests for {@link AnnotationTypeMappings} and {@link AnnotationTypeMapping}.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n */\nclass AnnotationTypeMappingsTests {\n\n\t@Test\n\tvoid forAnnotationTypeWhenNoMetaAnnotationsReturnsMappings() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(SimpleAnnotation.class);\n\t\tassertThat(mappings.size()).isEqualTo(1);\n\t\tassertThat(mappings.get(0).getAnnotationType()).isEqualTo(SimpleAnnotation.class);\n\t\tassertThat(getAll(mappings)).flatExtracting(\n\t\t\t\tAnnotationTypeMapping::getAnnotationType).containsExactly(SimpleAnnotation.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenMetaAnnotationsReturnsMappings() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(MetaAnnotated.class);\n\t\tassertThat(mappings.size()).isEqualTo(6);\n\t\tassertThat(getAll(mappings)).flatExtracting(\n\t\t\t\tAnnotationTypeMapping::getAnnotationType).containsExactly(\n\t\t\t\t\t\tMetaAnnotated.class, A.class, B.class, AA.class, AB.class,\n\t\t\t\t\t\tABC.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenHasRepeatingMetaAnnotationReturnsMapping() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(WithRepeatedMetaAnnotations.class);\n\t\tassertThat(mappings.size()).isEqualTo(3);\n\t\tassertThat(getAll(mappings)).flatExtracting(\n\t\t\t\tAnnotationTypeMapping::getAnnotationType).containsExactly(\n\t\t\t\t\t\tWithRepeatedMetaAnnotations.class, Repeating.class, Repeating.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenRepeatableMetaAnnotationIsFiltered() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(WithRepeatedMetaAnnotations.class,\n\t\t\t\tRepeatableContainers.standardRepeatables(), Repeating.class.getName()::equals);\n\t\tassertThat(getAll(mappings)).flatExtracting(AnnotationTypeMapping::getAnnotationType)\n\t\t\t\t.containsExactly(WithRepeatedMetaAnnotations.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenSelfAnnotatedReturnsMapping() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(SelfAnnotated.class);\n\t\tassertThat(mappings.size()).isEqualTo(1);\n\t\tassertThat(getAll(mappings)).flatExtracting(\n\t\t\t\tAnnotationTypeMapping::getAnnotationType).containsExactly(SelfAnnotated.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenFormsLoopReturnsMapping() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(LoopA.class);\n\t\tassertThat(mappings.size()).isEqualTo(2);\n\t\tassertThat(getAll(mappings)).flatExtracting(\n\t\t\t\tAnnotationTypeMapping::getAnnotationType).containsExactly(LoopA.class, LoopB.class);\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenHasAliasForWithBothValueAndAttributeThrowsException() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForWithBothValueAndAttribute.class))\n\t\t\t.withMessage(\"In @AliasFor declared on attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForWithBothValueAndAttribute.class.getName()\n\t\t\t\t\t\t\t\t+ \"], attribute 'attribute' and its alias 'value' are present with values of 'foo' and 'bar', but only one is permitted.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForToSelfNonExistingAttribute() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForToSelfNonExistingAttribute.class))\n\t\t\t.withMessage(\"@AliasFor declaration on attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForToSelfNonExistingAttribute.class.getName()\n\t\t\t\t\t\t\t\t+ \"] declares an alias for 'missing' which is not present.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForToOtherNonExistingAttribute() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForToOtherNonExistingAttribute.class))\n\t\t\t.withMessage(\"Attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForToOtherNonExistingAttribute.class.getName()\n\t\t\t\t\t\t\t\t+ \"] is declared as an @AliasFor nonexistent \"\n\t\t\t\t\t\t\t\t+ \"attribute 'missing' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForToOtherNonExistingAttributeTarget.class.getName()\n\t\t\t\t\t\t\t\t+ \"].\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForToSelf() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForToSelf.class))\n\t\t\t.withMessage(\"@AliasFor declaration on attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForToSelf.class.getName()\n\t\t\t\t\t\t\t\t+ \"] points to itself. Specify 'annotation' to point to \"\n\t\t\t\t\t\t\t\t+ \"a same-named attribute on a meta-annotation.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForWithArrayCompatibleReturnTypes() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(\n\t\t\t\tAliasForWithArrayCompatibleReturnTypes.class);\n\t\tAnnotationTypeMapping mapping = getMapping(mappings,\n\t\t\t\tAliasForWithArrayCompatibleReturnTypesTarget.class);\n\t\tassertThat(getAliasMapping(mapping, 0).getName()).isEqualTo(\"test\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForWithIncompatibleReturnTypes() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForWithIncompatibleReturnTypes.class))\n\t\t\t.withMessage(\"Misconfigured aliases: attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForWithIncompatibleReturnTypes.class.getName()\n\t\t\t\t\t\t\t\t+ \"] and attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForWithIncompatibleReturnTypesTarget.class.getName()\n\t\t\t\t\t\t\t\t+ \"] must declare the same return type.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForToSelfAnnotatedToOtherAttribute() {\n\t\tString annotationType = AliasForToSelfAnnotatedToOtherAttribute.class.getName();\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> AnnotationTypeMappings.forAnnotationType(AliasForToSelfAnnotatedToOtherAttribute.class))\n\t\t\t\t.withMessage(\"Attribute 'b' in annotation [\" + annotationType\n\t\t\t\t\t\t+ \"] must be declared as an @AliasFor attribute 'a' in annotation [\" + annotationType\n\t\t\t\t\t\t+ \"], not attribute 'c' in annotation [\" + annotationType + \"].\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForHasMixedImplicitAndExplicitAliases() {\n\t\tassertMixedImplicitAndExplicitAliases(AliasForWithMixedImplicitAndExplicitAliasesV1.class, \"b\");\n\t\tassertMixedImplicitAndExplicitAliases(AliasForWithMixedImplicitAndExplicitAliasesV2.class, \"a\");\n\t}\n\n\tprivate void assertMixedImplicitAndExplicitAliases(Class<? extends Annotation> annotationType, String overriddenAttribute) {\n\t\tString annotationName = annotationType.getName();\n\t\tString metaAnnotationName = AliasPair.class.getName();\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> AnnotationTypeMappings.forAnnotationType(annotationType))\n\t\t\t\t.withMessage(\"Attribute 'b' in annotation [\" + annotationName\n\t\t\t\t\t\t+ \"] must be declared as an @AliasFor attribute 'a' in annotation [\" + annotationName\n\t\t\t\t\t\t+ \"], not attribute '\" + overriddenAttribute + \"' in annotation [\" + metaAnnotationName + \"].\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForNonMetaAnnotated() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForNonMetaAnnotated.class))\n\t\t\t.withMessage(\"@AliasFor declaration on attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForNonMetaAnnotated.class.getName()\n\t\t\t\t\t\t\t\t+ \"] declares an alias for attribute 'test' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForNonMetaAnnotatedTarget.class.getName()\n\t\t\t\t\t\t\t\t+ \"] which is not meta-present.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForSelfWithDifferentDefaults() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForSelfWithDifferentDefaults.class))\n\t\t\t.withMessage(\"Misconfigured aliases: attribute 'a' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForSelfWithDifferentDefaults.class.getName()\n\t\t\t\t\t\t\t\t+ \"] and attribute 'b' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasForSelfWithDifferentDefaults.class.getName()\n\t\t\t\t\t\t\t\t+ \"] must declare the same default value.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasForSelfWithMissingDefault() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasForSelfWithMissingDefault.class))\n\t\t\t.withMessage(\"Misconfigured aliases: attribute 'a' in annotation [\"\n\t\t\t\t\t\t\t\t\t+ AliasForSelfWithMissingDefault.class.getName()\n\t\t\t\t\t\t\t\t\t+ \"] and attribute 'b' in annotation [\"\n\t\t\t\t\t\t\t\t\t+ AliasForSelfWithMissingDefault.class.getName()\n\t\t\t\t\t\t\t\t\t+ \"] must declare default values.\");\n\t}\n\n\t@Test\n\tvoid forAnnotationTypeWhenAliasWithExplicitMirrorAndDifferentDefaults() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tAnnotationTypeMappings.forAnnotationType(AliasWithExplicitMirrorAndDifferentDefaults.class))\n\t\t\t.withMessage(\"Misconfigured aliases: attribute 'a' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasWithExplicitMirrorAndDifferentDefaults.class.getName()\n\t\t\t\t\t\t\t\t+ \"] and attribute 'c' in annotation [\"\n\t\t\t\t\t\t\t\t+ AliasWithExplicitMirrorAndDifferentDefaults.class.getName()\n\t\t\t\t\t\t\t\t+ \"] must declare the same default value.\");\n\t}\n\n\t@Test\n\tvoid getDistanceReturnsDistance() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(Mapped.class);\n\t\tassertThat(mappings.get(0).getDistance()).isEqualTo(0);\n\t\tassertThat(mappings.get(1).getDistance()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getAnnotationTypeReturnsAnnotationType() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(Mapped.class);\n\t\tassertThat(mappings.get(0).getAnnotationType()).isEqualTo(Mapped.class);\n\t\tassertThat(mappings.get(1).getAnnotationType()).isEqualTo(MappedTarget.class);\n\t}\n\n\t@Test\n\tvoid getMetaTypeReturnsTypes() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(ThreeDeepA.class);\n\t\tAnnotationTypeMapping mappingC = mappings.get(2);\n\t\tassertThat(mappingC.getMetaTypes()).containsExactly(ThreeDeepA.class, ThreeDeepB.class, ThreeDeepC.class);\n\t}\n\n\t@Test\n\tvoid getAnnotationWhenRootReturnsNull() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(Mapped.class);\n\t\tassertThat(mappings.get(0).getAnnotation()).isNull();\n\t}\n\n\t@Test\n\tvoid getAnnotationWhenMetaAnnotationReturnsAnnotation() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(Mapped.class);\n\t\tassertThat(mappings.get(1).getAnnotation()).isEqualTo(Mapped.class.getAnnotation(MappedTarget.class));\n\t}\n\n\t@Test\n\tvoid getAttributesReturnsAttributes() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(Mapped.class).get(0);\n\t\tAttributeMethods attributes = mapping.getAttributes();\n\t\tassertThat(attributes.size()).isEqualTo(2);\n\t\tassertThat(attributes.get(0).getName()).isEqualTo(\"alias\");\n\t\tassertThat(attributes.get(1).getName()).isEqualTo(\"convention\");\n\t}\n\n\t@Test\n\tvoid getAliasMappingReturnsAttributes() throws Exception {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(Mapped.class).get(1);\n\t\tassertThat(getAliasMapping(mapping, 0)).isEqualTo(Mapped.class.getDeclaredMethod(\"alias\"));\n\t}\n\n\t@Test\n\tvoid getConventionMappingReturnsAttributes() throws Exception {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(Mapped.class).get(1);\n\t\tassertThat(getConventionMapping(mapping, 1)).isEqualTo(Mapped.class.getDeclaredMethod(\"convention\"));\n\t}\n\n\t@Test\n\tvoid getMirrorSetWhenAliasPairReturnsMirrors() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\n\t\tMirrorSets mirrorSets = mapping.getMirrorSets();\n\t\tassertThat(mirrorSets.size()).isEqualTo(1);\n\t\tassertThat(mirrorSets.get(0).size()).isEqualTo(2);\n\t\tassertThat(mirrorSets.get(0).get(0).getName()).isEqualTo(\"a\");\n\t\tassertThat(mirrorSets.get(0).get(1).getName()).isEqualTo(\"b\");\n\t}\n\n\t@Test\n\tvoid getMirrorSetWhenImplicitMirrorsReturnsMirrors() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ImplicitMirrors.class).get(0);\n\t\tMirrorSets mirrorSets = mapping.getMirrorSets();\n\t\tassertThat(mirrorSets.size()).isEqualTo(1);\n\t\tassertThat(mirrorSets.get(0).size()).isEqualTo(2);\n\t\tassertThat(mirrorSets.get(0).get(0).getName()).isEqualTo(\"a\");\n\t\tassertThat(mirrorSets.get(0).get(1).getName()).isEqualTo(\"b\");\n\t}\n\n\t@Test\n\tvoid getMirrorSetWhenThreeDeepReturnsMirrors() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(ThreeDeepA.class);\n\t\tAnnotationTypeMapping mappingA = mappings.get(0);\n\t\tMirrorSets mirrorSetsA = mappingA.getMirrorSets();\n\t\tassertThat(mirrorSetsA.size()).isEqualTo(2);\n\t\tassertThat(getNames(mirrorSetsA.get(0))).containsExactly(\"a1\", \"a2\", \"a3\");\n\t\tAnnotationTypeMapping mappingB = mappings.get(1);\n\t\tMirrorSets mirrorSetsB = mappingB.getMirrorSets();\n\t\tassertThat(mirrorSetsB.size()).isEqualTo(1);\n\t\tassertThat(getNames(mirrorSetsB.get(0))).containsExactly(\"b1\", \"b2\");\n\t\tAnnotationTypeMapping mappingC = mappings.get(2);\n\t\tMirrorSets mirrorSetsC = mappingC.getMirrorSets();\n\t\tassertThat(mirrorSetsC.size()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getAliasMappingWhenThreeDeepReturnsMappedAttributes() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(ThreeDeepA.class);\n\t\tAnnotationTypeMapping mappingA = mappings.get(0);\n\t\tassertThat(getAliasMapping(mappingA, 0)).isNull();\n\t\tassertThat(getAliasMapping(mappingA, 1)).isNull();\n\t\tassertThat(getAliasMapping(mappingA, 2)).isNull();\n\t\tassertThat(getAliasMapping(mappingA, 3)).isNull();\n\t\tassertThat(getAliasMapping(mappingA, 4)).isNull();\n\t\tAnnotationTypeMapping mappingB = mappings.get(1);\n\t\tassertThat(getAliasMapping(mappingB, 0).getName()).isEqualTo(\"a1\");\n\t\tassertThat(getAliasMapping(mappingB, 1).getName()).isEqualTo(\"a1\");\n\t\tAnnotationTypeMapping mappingC = mappings.get(2);\n\t\tassertThat(getAliasMapping(mappingC, 0).getName()).isEqualTo(\"a1\");\n\t\tassertThat(getAliasMapping(mappingC, 1).getName()).isEqualTo(\"a4\");\n\t}\n\n\t@Test\n\tvoid getAliasMappingsWhenHasDefinedAttributesReturnsMappedAttributes() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(DefinedAttributes.class).get(1);\n\t\tassertThat(getAliasMapping(mapping, 0)).isNull();\n\t\tassertThat(getAliasMapping(mapping, 1).getName()).isEqualTo(\"value\");\n\t}\n\n\t@Test\n\tvoid resolveMirrorsWhenAliasPairResolves() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\n\t\tMethod[] resolvedA = resolveMirrorSets(mapping, WithAliasPairA.class, AliasPair.class);\n\t\tassertThat(resolvedA[0].getName()).isEqualTo(\"a\");\n\t\tassertThat(resolvedA[1].getName()).isEqualTo(\"a\");\n\t\tMethod[] resolvedB = resolveMirrorSets(mapping, WithAliasPairB.class, AliasPair.class);\n\t\tassertThat(resolvedB[0].getName()).isEqualTo(\"b\");\n\t\tassertThat(resolvedB[1].getName()).isEqualTo(\"b\");\n\t}\n\n\t@Test\n\tvoid resolveMirrorsWhenHasSameValuesUsesFirst() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\n\t\tMethod[] resolved = resolveMirrorSets(mapping, WithSameValueAliasPair.class, AliasPair.class);\n\t\tassertThat(resolved[0].getName()).isEqualTo(\"a\");\n\t\tassertThat(resolved[1].getName()).isEqualTo(\"a\");\n\t}\n\n\t@Test\n\tvoid resolveMirrorsWhenOnlyHasDefaultValuesUsesFirst() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\n\t\tMethod[] resolved = resolveMirrorSets(mapping, WithDefaultValueAliasPair.class, AliasPair.class);\n\t\tassertThat(resolved[0].getName()).isEqualTo(\"a\");\n\t\tassertThat(resolved[1].getName()).isEqualTo(\"a\");\n\t}\n\n\t@Test\n\tvoid resolveMirrorsWhenHasDifferentValuesThrowsException() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tresolveMirrorSets(mapping, WithDifferentValueAliasPair.class, AliasPair.class))\n\t\t\t.withMessage(\"Different @AliasFor mirror values for annotation [\"\n\t\t\t\t\t\t\t\t+ AliasPair.class.getName() + \"] declared on \"\n\t\t\t\t\t\t\t\t+ WithDifferentValueAliasPair.class.getName()\n\t\t\t\t\t\t\t\t+ \"; attribute 'a' and its alias 'b' are declared with values of [test1] and [test2].\");\n\t}\n\n\t@Test\n\tvoid resolveMirrorsWhenHasWithMultipleRoutesToAliasReturnsMirrors() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(\n\t\t\t\tMultipleRoutesToAliasA.class);\n\t\tAnnotationTypeMapping mappingsA = getMapping(mappings, MultipleRoutesToAliasA.class);\n\t\tassertThat(mappingsA.getMirrorSets().size()).isZero();\n\t\tAnnotationTypeMapping mappingsB = getMapping(mappings, MultipleRoutesToAliasB.class);\n\t\tassertThat(getNames(mappingsB.getMirrorSets().get(0))).containsExactly(\"b1\", \"b2\", \"b3\");\n\t\tAnnotationTypeMapping mappingsC = getMapping(mappings, MultipleRoutesToAliasC.class);\n\t\tassertThat(getNames(mappingsC.getMirrorSets().get(0))).containsExactly(\"c1\", \"c2\");\n\t}\n\n\t@Test\n\tvoid getAliasMappingWhenHasWithMultipleRoutesToAliasReturnsMappedAttributes() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(\n\t\t\t\tMultipleRoutesToAliasA.class);\n\t\tAnnotationTypeMapping mappingsA = getMapping(mappings, MultipleRoutesToAliasA.class);\n\t\tassertThat(getAliasMapping(mappingsA, 0)).isNull();\n\t\tAnnotationTypeMapping mappingsB = getMapping(mappings, MultipleRoutesToAliasB.class);\n\t\tassertThat(getAliasMapping(mappingsB, 0).getName()).isEqualTo(\"a1\");\n\t\tassertThat(getAliasMapping(mappingsB, 1).getName()).isEqualTo(\"a1\");\n\t\tassertThat(getAliasMapping(mappingsB, 2).getName()).isEqualTo(\"a1\");\n\t\tAnnotationTypeMapping mappingsC = getMapping(mappings, MultipleRoutesToAliasC.class);\n\t\tassertThat(getAliasMapping(mappingsC, 0).getName()).isEqualTo(\"a1\");\n\t\tassertThat(getAliasMapping(mappingsC, 1).getName()).isEqualTo(\"a1\");\n\t}\n\n\t@Test\n\tvoid getConventionMappingWhenConventionToExplicitAliasesReturnsMappedAttributes() {\n\t\tAnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(ConventionToExplicitAliases.class);\n\t\tAnnotationTypeMapping mapping = getMapping(mappings, ConventionToExplicitAliasesTarget.class);\n\t\tassertThat(mapping.getConventionMapping(0)).isEqualTo(0);\n\t\tassertThat(mapping.getConventionMapping(1)).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenValueAndDefaultAreNullReturnsTrue() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassValue.class).get(0);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, null, ReflectionUtils::invokeMethod)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenValueAndDefaultMatchReturnsTrue() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassValueWithDefault.class).get(0);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, InputStream.class, ReflectionUtils::invokeMethod)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenClassAndStringNamesMatchReturnsTrue() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassValueWithDefault.class).get(0);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, \"java.io.InputStream\", ReflectionUtils::invokeMethod)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenClassArrayAndStringArrayNamesMatchReturnsTrue() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassArrayValueWithDefault.class).get(0);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0,\n\t\t\t\tnew String[] { \"java.io.InputStream\", \"java.io.OutputStream\" },\n\t\t\t\tReflectionUtils::invokeMethod)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenNestedAnnotationAndExtractedValuesMatchReturnsTrueAndValueSuppliedAsMap() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(NestedValue.class).get(0);\n\t\tMap<String, Object> value = Collections.singletonMap(\"value\", \"java.io.InputStream\");\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, value, TypeMappedAnnotation::extractFromMap)).isTrue();\n\t}\n\n\t@Test // gh-24375\n\tvoid isEquivalentToDefaultValueWhenNestedAnnotationAndExtractedValuesMatchReturnsTrueAndValueSuppliedAsTypeMappedAnnotation() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(NestedValue.class).get(0);\n\t\tMap<String, String> attributes = Collections.singletonMap(\"value\", \"java.io.InputStream\");\n\t\tMergedAnnotation<ClassValue> value = TypeMappedAnnotation.of(getClass().getClassLoader(), null, ClassValue.class, attributes);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, value, TypeMappedAnnotation::extractFromMap)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEquivalentToDefaultValueWhenNotMatchingReturnsFalse() {\n\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassValueWithDefault.class).get(0);\n\t\tassertThat(mapping.isEquivalentToDefaultValue(0, OutputStream.class, ReflectionUtils::invokeMethod)).isFalse();\n\t}\n\n\tprivate Method[] resolveMirrorSets(AnnotationTypeMapping mapping, Class<?> element,\n\t\t\tClass<? extends Annotation> annotationClass) {\n\t\tAnnotation annotation = element.getAnnotation(annotationClass);\n\t\tint[] resolved = mapping.getMirrorSets().resolve(element.getName(), annotation, ReflectionUtils::invokeMethod);\n\t\tMethod[] result = new Method[resolved.length];\n\t\tfor (int i = 0; i < resolved.length; i++) {\n\t\t\tresult[i] = resolved[i] != -1 ? mapping.getAttributes().get(resolved[i]) : null;\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate @Nullable Method getAliasMapping(AnnotationTypeMapping mapping, int attributeIndex) {\n\t\tint mapped = mapping.getAliasMapping(attributeIndex);\n\t\treturn mapped != -1 ? mapping.getRoot().getAttributes().get(mapped) : null;\n\t}\n\n\tprivate @Nullable Method getConventionMapping(AnnotationTypeMapping mapping, int attributeIndex) {\n\t\tint mapped = mapping.getConventionMapping(attributeIndex);\n\t\treturn mapped != -1 ? mapping.getRoot().getAttributes().get(mapped) : null;\n\t}\n\n\tprivate AnnotationTypeMapping getMapping(AnnotationTypeMappings mappings,\n\t\t\tClass<? extends Annotation> annotationType) {\n\n\t\tfor (AnnotationTypeMapping candidate : getAll(mappings)) {\n\t\t\tif (candidate.getAnnotationType() == annotationType) {\n\t\t\t\treturn candidate;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate List<AnnotationTypeMapping> getAll(AnnotationTypeMappings mappings) {\n\t\t// AnnotationTypeMappings does not implement Iterable so we don't create\n\t\t// too many garbage Iterators\n\t\treturn IntStream.range(0, mappings.size()).mapToObj(mappings::get).collect(toList());\n\t}\n\n\tprivate List<String> getNames(MirrorSet mirrorSet) {\n\t\tList<String> names = new ArrayList<>(mirrorSet.size());\n\t\tfor (int i = 0; i < mirrorSet.size(); i++) {\n\t\t\tnames.add(mirrorSet.get(i).getName());\n\t\t}\n\t\treturn names;\n\t}\n\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SimpleAnnotation {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AA {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ABC {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ABC\n\t@interface AB {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AA\n\t@AB\n\t@interface A {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface B {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@A\n\t@B\n\t@interface MetaAnnotated {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Repeatings {\n\n\t\tRepeating[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(Repeatings.class)\n\t@interface Repeating {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeating\n\t@Repeating\n\t@interface WithRepeatedMetaAnnotations {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@SelfAnnotated\n\t@interface SelfAnnotated {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@LoopB\n\t@interface LoopA {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@LoopA\n\t@interface LoopB {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithBothValueAndAttribute {\n\n\t\t@AliasFor(value = \"bar\", attribute = \"foo\")\n\t\tString test();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForToSelfNonExistingAttribute {\n\n\t\t@AliasFor(\"missing\")\n\t\tString test() default \"\";\n\n\t\tString other() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForToOtherNonExistingAttributeTarget {\n\n\t\tString other() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasForToOtherNonExistingAttributeTarget\n\t@interface AliasForToOtherNonExistingAttribute {\n\n\t\t@AliasFor(annotation = AliasForToOtherNonExistingAttributeTarget.class, attribute = \"missing\")\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForToSelf {\n\n\t\t@AliasFor(\"test\")\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithArrayCompatibleReturnTypesTarget {\n\n\t\tString[] test() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasForWithArrayCompatibleReturnTypesTarget\n\t@interface AliasForWithArrayCompatibleReturnTypes {\n\n\t\t@AliasFor(annotation = AliasForWithArrayCompatibleReturnTypesTarget.class)\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithIncompatibleReturnTypesTarget {\n\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithIncompatibleReturnTypes {\n\n\t\t@AliasFor(annotation = AliasForWithIncompatibleReturnTypesTarget.class)\n\t\tString[] test() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForToSelfAnnotatedToOtherAttribute {\n\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"\";\n\n\t\t@AliasFor(\"c\")\n\t\tString b() default \"\";\n\n\t\t@AliasFor(\"a\")\n\t\tString c() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasPair {\n\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"\";\n\n\t\t@AliasFor(\"a\")\n\t\tString b() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasPair\n\t@interface AliasForWithMixedImplicitAndExplicitAliasesV1 {\n\n\t\t// attempted implicit alias via attribute override\n\t\t@AliasFor(annotation = AliasPair.class, attribute = \"b\")\n\t\tString b() default \"\";\n\n\t\t// explicit local alias\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasPair\n\t@interface AliasForWithMixedImplicitAndExplicitAliasesV2 {\n\n\t\t// attempted implicit alias via attribute override\n\t\t@AliasFor(annotation = AliasPair.class, attribute = \"a\")\n\t\tString b() default \"\";\n\n\t\t// explicit local alias\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForNonMetaAnnotated {\n\n\t\t@AliasFor(annotation = AliasForNonMetaAnnotatedTarget.class)\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForNonMetaAnnotatedTarget {\n\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForSelfWithDifferentDefaults {\n\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"a\";\n\n\t\t@AliasFor(\"a\")\n\t\tString b() default \"b\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForSelfWithMissingDefault {\n\n\t\t@AliasFor(\"b\")\n\t\tString a() default \"a\";\n\n\t\t@AliasFor(\"a\")\n\t\tString b();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasWithExplicitMirrorAndDifferentDefaultsTarget {\n\n\t\tString a() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasWithExplicitMirrorAndDifferentDefaultsTarget\n\t@interface AliasWithExplicitMirrorAndDifferentDefaults {\n\n\t\t@AliasFor(annotation = AliasWithExplicitMirrorAndDifferentDefaultsTarget.class, attribute = \"a\")\n\t\tString a() default \"x\";\n\n\t\t@AliasFor(annotation = AliasWithExplicitMirrorAndDifferentDefaultsTarget.class, attribute = \"a\")\n\t\tString b() default \"x\";\n\n\t\t@AliasFor(annotation = AliasWithExplicitMirrorAndDifferentDefaultsTarget.class, attribute = \"a\")\n\t\tString c() default \"y\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MappedTarget {\n\n\t\tString convention() default \"\";\n\n\t\tString aliasTarget() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@MappedTarget\n\t@interface Mapped {\n\n\t\tString convention() default \"\";\n\n\t\t@AliasFor(annotation = MappedTarget.class, attribute = \"aliasTarget\")\n\t\tString alias() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitMirrorsTarget {\n\n\t\t@AliasFor(\"d\")\n\t\tString c() default \"\";\n\n\t\t@AliasFor(\"c\")\n\t\tString d() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ImplicitMirrorsTarget\n\t@interface ImplicitMirrors {\n\n\t\t@AliasFor(annotation = ImplicitMirrorsTarget.class, attribute = \"c\")\n\t\tString a() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitMirrorsTarget.class, attribute = \"c\")\n\t\tString b() default \"\";\n\t}\n\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ThreeDeepC {\n\n\t\tString c1() default \"\";\n\n\t\tString c2() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ThreeDeepC\n\t@interface ThreeDeepB {\n\n\t\t@AliasFor(annotation = ThreeDeepC.class, attribute = \"c1\")\n\t\tString b1() default \"\";\n\n\t\t@AliasFor(annotation = ThreeDeepC.class, attribute = \"c1\")\n\t\tString b2() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ThreeDeepB\n\t@interface ThreeDeepA {\n\n\t\t@AliasFor(annotation = ThreeDeepB.class, attribute = \"b1\")\n\t\tString a1() default \"\";\n\n\t\t@AliasFor(annotation = ThreeDeepB.class, attribute = \"b2\")\n\t\tString a2() default \"\";\n\n\t\t@AliasFor(annotation = ThreeDeepC.class, attribute = \"c1\")\n\t\tString a3() default \"\";\n\n\t\t@AliasFor(annotation = ThreeDeepC.class, attribute = \"c2\")\n\t\tString a4() default \"\";\n\n\t\t@AliasFor(annotation = ThreeDeepC.class, attribute = \"c2\")\n\t\tString a5() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface DefinedAttributesTarget {\n\n\t\tString a();\n\n\t\tString b() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefinedAttributesTarget(a = \"test\")\n\t@interface DefinedAttributes {\n\n\t\t@AliasFor(annotation = DefinedAttributesTarget.class, attribute = \"b\")\n\t\tString value();\n\t}\n\n\t@AliasPair(a = \"test\")\n\tstatic class WithAliasPairA {\n\t}\n\n\t@AliasPair(b = \"test\")\n\tstatic class WithAliasPairB {\n\t}\n\n\t@AliasPair(a = \"test\", b = \"test\")\n\tstatic class WithSameValueAliasPair {\n\t}\n\n\t@AliasPair(a = \"test1\", b = \"test2\")\n\tstatic class WithDifferentValueAliasPair {\n\t}\n\n\t@AliasPair\n\tstatic class WithDefaultValueAliasPair {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MultipleRoutesToAliasC {\n\n\t\t@AliasFor(\"c2\")\n\t\tString c1() default \"\";\n\n\t\t@AliasFor(\"c1\")\n\t\tString c2() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@MultipleRoutesToAliasC\n\t@interface MultipleRoutesToAliasB {\n\n\t\t@AliasFor(annotation = MultipleRoutesToAliasC.class, attribute = \"c2\")\n\t\tString b1() default \"\";\n\n\t\t@AliasFor(annotation = MultipleRoutesToAliasC.class, attribute = \"c2\")\n\t\tString b2() default \"\";\n\n\t\t@AliasFor(annotation = MultipleRoutesToAliasC.class, attribute = \"c1\")\n\t\tString b3() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@MultipleRoutesToAliasB\n\t@interface MultipleRoutesToAliasA {\n\n\t\t@AliasFor(annotation = MultipleRoutesToAliasB.class, attribute = \"b2\")\n\t\tString a1() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionToExplicitAliasesTarget {\n\n\t\t@AliasFor(\"test\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ConventionToExplicitAliasesTarget\n\t@interface ConventionToExplicitAliases {\n\n\t\tString test() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ClassValue {\n\n\t\tClass<?> value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ClassValueWithDefault {\n\n\t\tClass<?> value() default InputStream.class;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ClassArrayValueWithDefault {\n\n\t\tClass<?>[] value() default { InputStream.class, OutputStream.class };\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface NestedValue {\n\n\t\tClassValue value() default @ClassValue(InputStream.class);\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.annotation",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.AnnotationUtilsTests",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtilsTests",
    "headType": "class",
    "relation": "use",
    "tail": "@SuppressWarnings",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtilsTests",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Method;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.ParametersAreNonnullByDefault;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.subpackage.NonPublicAnnotatedClass;\nimport org.springframework.core.testfixture.ide.IdeUtils;\nimport org.springframework.core.testfixture.stereotype.Component;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Collectors.toList;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalStateException;\nimport static org.springframework.core.annotation.AnnotationUtils.VALUE;\nimport static org.springframework.core.annotation.AnnotationUtils.findAnnotation;\nimport static org.springframework.core.annotation.AnnotationUtils.findAnnotationDeclaringClass;\nimport static org.springframework.core.annotation.AnnotationUtils.findAnnotationDeclaringClassForTypes;\nimport static org.springframework.core.annotation.AnnotationUtils.getAnnotation;\nimport static org.springframework.core.annotation.AnnotationUtils.getAnnotationAttributes;\nimport static org.springframework.core.annotation.AnnotationUtils.getDeclaredRepeatableAnnotations;\nimport static org.springframework.core.annotation.AnnotationUtils.getDefaultValue;\nimport static org.springframework.core.annotation.AnnotationUtils.getRepeatableAnnotations;\nimport static org.springframework.core.annotation.AnnotationUtils.getValue;\nimport static org.springframework.core.annotation.AnnotationUtils.isAnnotationDeclaredLocally;\nimport static org.springframework.core.annotation.AnnotationUtils.isAnnotationInherited;\nimport static org.springframework.core.annotation.AnnotationUtils.isAnnotationMetaPresent;\nimport static org.springframework.core.annotation.AnnotationUtils.synthesizeAnnotation;\n\n/**\n * Tests for {@link AnnotationUtils}.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Chris Beams\n * @author Phillip Webb\n * @author Oleg Zhurakousky\n */\n@SuppressWarnings(\"deprecation\")\nclass AnnotationUtilsTests {\n\n\t@BeforeEach\n\tvoid clearCacheBeforeTests() {\n\t\tAnnotationUtils.clearCache();\n\t}\n\n\n\t@Test\n\tvoid findMethodAnnotationOnLeaf() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"annotatedOnLeaf\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNotNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNotNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findMethodAnnotationWithAnnotationOnMethodInInterface() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"fromInterfaceImplementedByRoot\");\n\t\t// @Order is not @Inherited\n\t\tassertThat(m.getAnnotation(Order.class)).isNull();\n\t\t// getAnnotation() does not search on interfaces\n\t\tassertThat(getAnnotation(m, Order.class)).isNull();\n\t\t// findAnnotation() does search on interfaces\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findMethodAnnotationWithMetaAnnotationOnLeaf() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"metaAnnotatedOnLeaf\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNotNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findMethodAnnotationWithMetaMetaAnnotationOnLeaf() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"metaMetaAnnotatedOnLeaf\");\n\t\tassertThat(m.getAnnotation(Component.class)).isNull();\n\t\tassertThat(getAnnotation(m, Component.class)).isNull();\n\t\tassertThat(findAnnotation(m, Component.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationOnRoot() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"annotatedOnRoot\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNotNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNotNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findMethodAnnotationWithMetaAnnotationOnRoot() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"metaAnnotatedOnRoot\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNotNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationOnRootButOverridden() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"overrideWithoutNewAnnotation\");\n\t\tassertThat(m.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(m, Order.class)).isNull();\n\t\tassertThat(findAnnotation(m, Order.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationNotAnnotated() throws Exception {\n\t\tMethod m = Leaf.class.getMethod(\"notAnnotated\");\n\t\tassertThat(findAnnotation(m, Order.class)).isNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationOnBridgeMethod() throws Exception {\n\t\tMethod bridgeMethod = SimpleFoo.class.getMethod(\"something\", Object.class);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\n\t\tassertThat(bridgeMethod.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(bridgeMethod, Order.class)).isNull();\n\t\tassertThat(findAnnotation(bridgeMethod, Order.class)).isNotNull();\n\n\t\t// As of JDK 8, invoking getAnnotation() on a bridge method actually finds an\n\t\t// annotation on its 'bridged' method [1]; however, the Eclipse compiler does\n\t\t// not support this [2]. Thus, we effectively ignore the following\n\t\t// assertion if the test is currently executing within the Eclipse IDE.\n\t\t//\n\t\t// [1] https://bugs.openjdk.java.net/browse/JDK-6695379\n\t\t// [2] https://bugs.eclipse.org/bugs/show_bug.cgi?id=495396\n\t\t//\n\t\tif (!IdeUtils.runningInEclipse()) {\n\t\t\tassertThat(bridgeMethod.getAnnotation(Transactional.class)).isNotNull();\n\t\t}\n\t\tassertThat(getAnnotation(bridgeMethod, Transactional.class)).isNotNull();\n\t\tassertThat(findAnnotation(bridgeMethod, Transactional.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationOnBridgedMethod() throws Exception {\n\t\tMethod bridgedMethod = SimpleFoo.class.getMethod(\"something\", String.class);\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\n\t\tassertThat(bridgedMethod.getAnnotation(Order.class)).isNull();\n\t\tassertThat(getAnnotation(bridgedMethod, Order.class)).isNull();\n\t\tassertThat(findAnnotation(bridgedMethod, Order.class)).isNotNull();\n\n\t\tassertThat(bridgedMethod.getAnnotation(Transactional.class)).isNotNull();\n\t\tassertThat(getAnnotation(bridgedMethod, Transactional.class)).isNotNull();\n\t\tassertThat(findAnnotation(bridgedMethod, Transactional.class)).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationFromInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test  // SPR-16060\n\tvoid findMethodAnnotationFromGenericInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test  // SPR-17146\n\tvoid findMethodAnnotationFromGenericSuperclass() throws Exception {\n\t\tMethod method = ExtendsBaseClassWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationFromInterfaceOnSuper() throws Exception {\n\t\tMethod method = SubOfImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test\n\tvoid findMethodAnnotationFromInterfaceWhenSuperDoesNotImplementMethod() throws Exception {\n\t\tMethod method = SubOfAbstractImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tOrder order = findAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t// @since 4.1.2\n\t@Test\n\tvoid findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverAnnotationsOnInterfaces() {\n\t\tComponent component = findAnnotation(ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface.class, Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tassertThat(component.value()).isEqualTo(\"meta2\");\n\t}\n\n\t// @since 4.0.3\n\t@Test\n\tvoid findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedAnnotations() {\n\t\tTransactional transactional = findAnnotation(SubSubClassWithInheritedAnnotation.class, Transactional.class);\n\t\tassertThat(transactional).isNotNull();\n\t\tassertThat(transactional.readOnly()).as(\"readOnly flag for SubSubClassWithInheritedAnnotation\").isTrue();\n\t}\n\n\t// @since 4.0.3\n\t@Test\n\tvoid findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedComposedAnnotations() {\n\t\tComponent component = findAnnotation(SubSubClassWithInheritedMetaAnnotation.class, Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tassertThat(component.value()).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid findClassAnnotationOnMetaMetaAnnotatedClass() {\n\t\tComponent component = findAnnotation(MetaMetaAnnotatedClass.class, Component.class);\n\t\tassertThat(component).as(\"Should find meta-annotation on composed annotation on class\").isNotNull();\n\t\tassertThat(component.value()).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid findClassAnnotationOnMetaMetaMetaAnnotatedClass() {\n\t\tComponent component = findAnnotation(MetaMetaMetaAnnotatedClass.class, Component.class);\n\t\tassertThat(component).as(\"Should find meta-annotation on meta-annotation on composed annotation on class\").isNotNull();\n\t\tassertThat(component.value()).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid findClassAnnotationOnAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\t// TransactionalClass is NOT annotated or meta-annotated with @Component\n\t\tComponent component = findAnnotation(TransactionalClass.class, Component.class);\n\t\tassertThat(component).as(\"Should not find @Component on TransactionalClass\").isNull();\n\t}\n\n\t@Test\n\tvoid findClassAnnotationOnMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\tComponent component = findAnnotation(MetaCycleAnnotatedClass.class, Component.class);\n\t\tassertThat(component).as(\"Should not find @Component on MetaCycleAnnotatedClass\").isNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnInheritedAnnotationInterface() {\n\t\tTransactional tx = findAnnotation(InheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(tx).as(\"Should find @Transactional on InheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnSubInheritedAnnotationInterface() {\n\t\tTransactional tx = findAnnotation(SubInheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(tx).as(\"Should find @Transactional on SubInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnSubSubInheritedAnnotationInterface() {\n\t\tTransactional tx = findAnnotation(SubSubInheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(tx).as(\"Should find @Transactional on SubSubInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnNonInheritedAnnotationInterface() {\n\t\tOrder order = findAnnotation(NonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(order).as(\"Should find @Order on NonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnSubNonInheritedAnnotationInterface() {\n\t\tOrder order = findAnnotation(SubNonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(order).as(\"Should find @Order on SubNonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t// @since 4.2\n\t@Test\n\tvoid findClassAnnotationOnSubSubNonInheritedAnnotationInterface() {\n\t\tOrder order = findAnnotation(SubSubNonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(order).as(\"Should find @Order on SubSubNonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findAnnotationDeclaringClassForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, NonAnnotatedInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, NonAnnotatedClass.class)).isNull();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, InheritedAnnotationInterface.class)).isEqualTo(InheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, SubInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, InheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClass(Transactional.class, SubInheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but findAnnotationDeclaringClass() should still find it on classes.\n\t\tassertThat(findAnnotationDeclaringClass(Order.class, NonInheritedAnnotationInterface.class)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClass(Order.class, SubNonInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClass(Order.class, NonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClass(Order.class, SubNonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t}\n\n\t@Test\n\tvoid findAnnotationDeclaringClassForTypesWithSingleCandidateType() {\n\t\t// no class-level annotation\n\t\tList<Class<? extends Annotation>> transactionalCandidateList = Collections.singletonList(Transactional.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, NonAnnotatedInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, NonAnnotatedClass.class)).isNull();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, InheritedAnnotationInterface.class)).isEqualTo(InheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, SubInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, InheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, SubInheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but findAnnotationDeclaringClassForTypes() should still find it on classes.\n\t\tList<Class<? extends Annotation>> orderCandidateList = Collections.singletonList(Order.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, NonInheritedAnnotationInterface.class)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, SubNonInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, NonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, SubNonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t}\n\n\t@Test\n\tvoid findAnnotationDeclaringClassForTypesWithMultipleCandidateTypes() {\n\t\tList<Class<? extends Annotation>> candidates = asList(Transactional.class, Order.class);\n\n\t\t// no class-level annotation\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, NonAnnotatedInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, NonAnnotatedClass.class)).isNull();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, InheritedAnnotationInterface.class)).isEqualTo(InheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, InheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubInheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but findAnnotationDeclaringClassForTypes() should still find it on classes.\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, NonInheritedAnnotationInterface.class)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubNonInheritedAnnotationInterface.class)).isNull();\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, NonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubNonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\n\n\t\t// class hierarchy mixed with @Transactional and @Order declarations\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, TransactionalClass.class)).isEqualTo(TransactionalClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, TransactionalAndOrderedClass.class)).isEqualTo(TransactionalAndOrderedClass.class);\n\t\tassertThat(findAnnotationDeclaringClassForTypes(candidates, SubTransactionalAndOrderedClass.class)).isEqualTo(TransactionalAndOrderedClass.class);\n\t}\n\n\t@Test\n\tvoid isAnnotationDeclaredLocallyForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, NonAnnotatedInterface.class)).isFalse();\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, NonAnnotatedClass.class)).isFalse();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, InheritedAnnotationInterface.class)).isTrue();\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, SubInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, InheritedAnnotationClass.class)).isTrue();\n\t\tassertThat(isAnnotationDeclaredLocally(Transactional.class, SubInheritedAnnotationClass.class)).isFalse();\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited\n\t\tassertThat(isAnnotationDeclaredLocally(Order.class, NonInheritedAnnotationInterface.class)).isTrue();\n\t\tassertThat(isAnnotationDeclaredLocally(Order.class, SubNonInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationDeclaredLocally(Order.class, NonInheritedAnnotationClass.class)).isTrue();\n\t\tassertThat(isAnnotationDeclaredLocally(Order.class, SubNonInheritedAnnotationClass.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotationInheritedForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(isAnnotationInherited(Transactional.class, NonAnnotatedInterface.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Transactional.class, NonAnnotatedClass.class)).isFalse();\n\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(isAnnotationInherited(Transactional.class, InheritedAnnotationInterface.class)).isFalse();\n\t\t// isAnnotationInherited() does not currently traverse interface hierarchies.\n\t\t// Thus the following, though perhaps counterintuitive, must be false:\n\t\tassertThat(isAnnotationInherited(Transactional.class, SubInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Transactional.class, InheritedAnnotationClass.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Transactional.class, SubInheritedAnnotationClass.class)).isTrue();\n\n\t\t// non-inherited class-level annotation; note: @Order is not inherited\n\t\tassertThat(isAnnotationInherited(Order.class, NonInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Order.class, SubNonInheritedAnnotationInterface.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Order.class, NonInheritedAnnotationClass.class)).isFalse();\n\t\tassertThat(isAnnotationInherited(Order.class, SubNonInheritedAnnotationClass.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotationMetaPresentForPlainType() {\n\t\tassertThat(isAnnotationMetaPresent(Order.class, Documented.class)).isTrue();\n\t\tassertThat(isAnnotationMetaPresent(ParametersAreNonnullByDefault.class, Documented.class)).isTrue();\n\t\tassertThat(isAnnotationMetaPresent(ParametersAreNonnullByDefault.class, Nonnull.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributesWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\n\t\tAnnotationAttributes attributes = (AnnotationAttributes) getAnnotationAttributes(component);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.getString(VALUE)).as(\"value attribute: \").isEqualTo(\"webController\");\n\t\tassertThat(attributes.annotationType()).isEqualTo(Component.class);\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributesWithNestedAnnotations() {\n\t\tComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class);\n\t\tassertThat(componentScan).isNotNull();\n\n\t\tAnnotationAttributes attributes = getAnnotationAttributes(ComponentScanClass.class, componentScan);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(ComponentScan.class);\n\n\t\tFilter[] filters = attributes.getAnnotationArray(\"excludeFilters\", Filter.class);\n\t\tassertThat(filters).isNotNull();\n\n\t\tList<String> patterns = stream(filters).map(Filter::pattern).collect(toList());\n\t\tassertThat(patterns).isEqualTo(asList(\"*Foo\", \"*Bar\"));\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributesWithAttributeAliases() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\t\tWebMapping webMapping = method.getAnnotation(WebMapping.class);\n\t\tAnnotationAttributes attributes = (AnnotationAttributes) getAnnotationAttributes(webMapping);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(WebMapping.class);\n\t\tassertThat(attributes.getString(\"name\")).as(\"name attribute: \").isEqualTo(\"foo\");\n\t\tassertThat(attributes.getStringArray(VALUE)).as(\"value attribute: \").isEqualTo(asArray(\"/test\"));\n\t\tassertThat(attributes.getStringArray(\"path\")).as(\"path attribute: \").isEqualTo(asArray(\"/test\"));\n\n\t\tmethod = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\twebMapping = method.getAnnotation(WebMapping.class);\n\t\tattributes = (AnnotationAttributes) getAnnotationAttributes(webMapping);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(WebMapping.class);\n\t\tassertThat(attributes.getString(\"name\")).as(\"name attribute: \").isEqualTo(\"bar\");\n\t\tassertThat(attributes.getStringArray(VALUE)).as(\"value attribute: \").isEqualTo(asArray(\"/test\"));\n\t\tassertThat(attributes.getStringArray(\"path\")).as(\"path attribute: \").isEqualTo(asArray(\"/test\"));\n\t}\n\n\t@Test\n\tvoid getAnnotationAttributesWithAttributeAliasesWithDifferentValues() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithDifferentPathAndValueAttributes\");\n\t\tWebMapping webMapping = method.getAnnotation(WebMapping.class);\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tgetAnnotationAttributes(webMapping))\n\t\t\t.withMessageContaining(\"attribute 'path' and its alias 'value'\")\n\t\t\t.withMessageContaining(\"values of [{/test}] and [{/enigma}]\");\n\t}\n\n\t@Test\n\tvoid getValueFromAnnotation() throws Exception {\n\t\tMethod method = SimpleFoo.class.getMethod(\"something\", Object.class);\n\t\tOrder order = findAnnotation(method, Order.class);\n\n\t\tassertThat(getValue(order, VALUE)).isEqualTo(1);\n\t\tassertThat(getValue(order)).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getValueFromNonPublicAnnotation() {\n\t\tAnnotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\n\t\tassertThat(declaredAnnotations).hasSize(1);\n\t\tAnnotation annotation = declaredAnnotations[0];\n\t\tassertThat(annotation).isNotNull();\n\t\tassertThat(annotation.annotationType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\n\t\tassertThat(getValue(annotation, VALUE)).isEqualTo(42);\n\t\tassertThat(getValue(annotation)).isEqualTo(42);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromAnnotation() throws Exception {\n\t\tMethod method = SimpleFoo.class.getMethod(\"something\", Object.class);\n\t\tOrder order = findAnnotation(method, Order.class);\n\n\t\tassertThat(getDefaultValue(order, VALUE)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\n\t\tassertThat(getDefaultValue(order)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromNonPublicAnnotation() {\n\t\tAnnotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\n\t\tassertThat(declaredAnnotations).hasSize(1);\n\t\tAnnotation annotation = declaredAnnotations[0];\n\t\tassertThat(annotation).isNotNull();\n\t\tassertThat(annotation.annotationType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\n\t\tassertThat(getDefaultValue(annotation, VALUE)).isEqualTo(-1);\n\t\tassertThat(getDefaultValue(annotation)).isEqualTo(-1);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromAnnotationType() {\n\t\tassertThat(getDefaultValue(Order.class, VALUE)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\n\t\tassertThat(getDefaultValue(Order.class)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Test\n\tvoid findRepeatableAnnotation() {\n\t\tRepeatable repeatable = findAnnotation(MyRepeatable.class, Repeatable.class);\n\t\tassertThat(repeatable).isNotNull();\n\t\tassertThat(repeatable.value()).isEqualTo(MyRepeatableContainer.class);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnMethod() throws Exception {\n\t\tMethod method = InterfaceWithRepeated.class.getMethod(\"foo\");\n\t\tSet<MyRepeatable> annotations = getRepeatableAnnotations(method, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(annotations).isNotNull();\n\t\tList<String> values = annotations.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(asList(\"A\", \"B\", \"C\", \"meta1\"));\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnClassWithAttributeAliases() {\n\t\tfinal List<String> expectedLocations = asList(\"A\", \"B\");\n\n\t\tSet<ContextConfig> annotations = getRepeatableAnnotations(ConfigHierarchyTestCase.class, ContextConfig.class, null);\n\t\tassertThat(annotations).isNotNull();\n\t\tassertThat(annotations).as(\"size if container type is omitted: \").isEmpty();\n\n\t\tannotations = getRepeatableAnnotations(ConfigHierarchyTestCase.class, ContextConfig.class, Hierarchy.class);\n\t\tassertThat(annotations).isNotNull();\n\n\t\tList<String> locations = annotations.stream().map(ContextConfig::location).collect(toList());\n\t\tassertThat(locations).isEqualTo(expectedLocations);\n\n\t\tList<String> values = annotations.stream().map(ContextConfig::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedLocations);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnClass() {\n\t\tfinal List<String> expectedValuesJava = asList(\"A\", \"B\", \"C\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"A\", \"B\", \"C\", \"meta1\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = MyRepeatableClass.class.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnSuperclass() {\n\t\tfinal Class<?> clazz = SubMyRepeatableClass.class;\n\t\tfinal List<String> expectedValuesJava = asList(\"A\", \"B\", \"C\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"A\", \"B\", \"C\", \"meta1\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getRepeatableAnnotations(clazz, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnClassAndSuperclass() {\n\t\tfinal Class<?> clazz = SubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\n\t\tfinal List<String> expectedValuesJava = asList(\"X\", \"Y\", \"Z\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"X\", \"Y\", \"Z\", \"meta2\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getRepeatableAnnotations(clazz, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getRepeatableAnnotationsDeclaredOnMultipleSuperclasses() {\n\t\tfinal Class<?> clazz = SubSubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\n\t\tfinal List<String> expectedValuesJava = asList(\"X\", \"Y\", \"Z\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"X\", \"Y\", \"Z\", \"meta2\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getRepeatableAnnotations(clazz, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getDeclaredRepeatableAnnotationsDeclaredOnClass() {\n\t\tfinal List<String> expectedValuesJava = asList(\"A\", \"B\", \"C\");\n\t\tfinal List<String> expectedValuesSpring = asList(\"A\", \"B\", \"C\", \"meta1\");\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = MyRepeatableClass.class.getDeclaredAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tList<String> values = stream(array).map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesJava);\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getDeclaredRepeatableAnnotations(\n\t\t\t\tMyRepeatableClass.class, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getDeclaredRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tvalues = set.stream().map(MyRepeatable::value).collect(toList());\n\t\tassertThat(values).isEqualTo(expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid getDeclaredRepeatableAnnotationsDeclaredOnSuperclass() {\n\t\tfinal Class<?> clazz = SubMyRepeatableClass.class;\n\n\t\t// Java 8\n\t\tMyRepeatable[] array = clazz.getDeclaredAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(array).isNotNull();\n\t\tassertThat(array).isEmpty();\n\n\t\t// Spring\n\t\tSet<MyRepeatable> set = getDeclaredRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\n\t\tassertThat(set).isNotNull();\n\t\tassertThat(set).isEmpty();\n\n\t\t// When container type is omitted and therefore inferred from @Repeatable\n\t\tset = getDeclaredRepeatableAnnotations(clazz, MyRepeatable.class);\n\t\tassertThat(set).isNotNull();\n\t\tassertThat(set).isEmpty();\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationWithImplicitAliasesWithMissingDefaultValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithMissingDefaultValuesContextConfigClass.class;\n\t\tClass<ImplicitAliasesWithMissingDefaultValuesContextConfig> annotationType =\n\t\t\t\tImplicitAliasesWithMissingDefaultValuesContextConfig.class;\n\t\tImplicitAliasesWithMissingDefaultValuesContextConfig config = clazz.getAnnotation(annotationType);\n\t\tassertThat(config).isNotNull();\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(config, clazz))\n\t\t\t.withMessageStartingWith(\"Misconfigured aliases:\")\n\t\t\t.withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t.withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t.withMessageContaining(\"default values\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationWithImplicitAliasesWithDifferentDefaultValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithDifferentDefaultValuesContextConfigClass.class;\n\t\tClass<ImplicitAliasesWithDifferentDefaultValuesContextConfig> annotationType =\n\t\t\t\tImplicitAliasesWithDifferentDefaultValuesContextConfig.class;\n\t\tImplicitAliasesWithDifferentDefaultValuesContextConfig config = clazz.getAnnotation(annotationType);\n\t\tassertThat(config).isNotNull();\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(config, clazz))\n\t\t\t.withMessageStartingWith(\"Misconfigured aliases:\")\n\t\t\t.withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t.withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t.withMessageContaining(\"same default value\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationWithImplicitAliasesWithDuplicateValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithDuplicateValuesContextConfigClass.class;\n\t\tClass<ImplicitAliasesWithDuplicateValuesContextConfig> annotationType =\n\t\t\t\tImplicitAliasesWithDuplicateValuesContextConfig.class;\n\t\tImplicitAliasesWithDuplicateValuesContextConfig config = clazz.getAnnotation(annotationType);\n\t\tassertThat(config).isNotNull();\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(config, clazz).location1())\n\t\t\t.withMessageStartingWith(\"Different @AliasFor mirror values\")\n\t\t\t.withMessageContaining(annotationType.getName())\n\t\t\t.withMessageContaining(\"declared on class\")\n\t\t\t.withMessageContaining(clazz.getName())\n\t\t\t.withMessageContaining(\"attribute 'location1' and its alias 'location2'\")\n\t\t\t.withMessageContaining(\"with values of [1] and [2]\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\n\t\tMap<String, Object> map = Collections.singletonMap(VALUE, \"webController\");\n\t\tComponent synthesizedComponent = synthesizeAnnotation(map, Component.class, WebController.class);\n\t\tassertThat(synthesizedComponent).isNotNull();\n\n\t\tassertThat(synthesizedComponent).isNotSameAs(component);\n\t\tassertThat(component.value()).as(\"value from component: \").isEqualTo(\"webController\");\n\t\tassertThat(synthesizedComponent.value()).as(\"value from synthesized component: \").isEqualTo(\"webController\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeAnnotationFromMapWithNestedMap() {\n\t\tComponentScanSingleFilter componentScan =\n\t\t\t\tComponentScanSingleFilterClass.class.getAnnotation(ComponentScanSingleFilter.class);\n\t\tassertThat(componentScan).isNotNull();\n\t\tassertThat(componentScan.value().pattern()).as(\"value from ComponentScan: \").isEqualTo(\"*Foo\");\n\n\t\tAnnotationAttributes attributes = getAnnotationAttributes(\n\t\t\t\tComponentScanSingleFilterClass.class, componentScan, false, true);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(ComponentScanSingleFilter.class);\n\n\t\tMap<String, Object> filterMap = (Map<String, Object>) attributes.get(\"value\");\n\t\tassertThat(filterMap).isNotNull();\n\t\tassertThat(filterMap.get(\"pattern\")).isEqualTo(\"*Foo\");\n\n\t\t// Modify nested map\n\t\tfilterMap.put(\"pattern\", \"newFoo\");\n\t\tfilterMap.put(\"enigma\", 42);\n\n\t\tComponentScanSingleFilter synthesizedComponentScan = synthesizeAnnotation(\n\t\t\t\tattributes, ComponentScanSingleFilter.class, ComponentScanSingleFilterClass.class);\n\t\tassertThat(synthesizedComponentScan).isNotNull();\n\n\t\tassertThat(synthesizedComponentScan).isNotSameAs(componentScan);\n\t\tassertThat(synthesizedComponentScan.value().pattern()).as(\"value from synthesized ComponentScan: \").isEqualTo(\"newFoo\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeAnnotationFromMapWithNestedArrayOfMaps() {\n\t\tComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class);\n\t\tassertThat(componentScan).isNotNull();\n\n\t\tAnnotationAttributes attributes = getAnnotationAttributes(ComponentScanClass.class, componentScan, false, true);\n\t\tassertThat(attributes).isNotNull();\n\t\tassertThat(attributes.annotationType()).isEqualTo(ComponentScan.class);\n\n\t\tMap<String, Object>[] filters = (Map[]) attributes.get(\"excludeFilters\");\n\t\tassertThat(filters).isNotNull();\n\n\t\tList<String> patterns = stream(filters).map(m -> (String) m.get(\"pattern\")).collect(toList());\n\t\tassertThat(patterns).isEqualTo(asList(\"*Foo\", \"*Bar\"));\n\n\t\t// Modify nested maps\n\t\tfilters[0].put(\"pattern\", \"newFoo\");\n\t\tfilters[0].put(\"enigma\", 42);\n\t\tfilters[1].put(\"pattern\", \"newBar\");\n\t\tfilters[1].put(\"enigma\", 42);\n\n\t\tComponentScan synthesizedComponentScan =\n\t\t\t\tsynthesizeAnnotation(attributes, ComponentScan.class, ComponentScanClass.class);\n\t\tassertThat(synthesizedComponentScan).isNotNull();\n\n\t\tassertThat(synthesizedComponentScan).isNotSameAs(componentScan);\n\t\tpatterns = stream(synthesizedComponentScan.excludeFilters()).map(Filter::pattern).collect(toList());\n\t\tassertThat(patterns).isEqualTo(asList(\"newFoo\", \"newBar\"));\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromDefaultsWithoutAttributeAliases() {\n\t\tAnnotationWithDefaults annotationWithDefaults = synthesizeAnnotation(AnnotationWithDefaults.class);\n\t\tassertThat(annotationWithDefaults).isNotNull();\n\t\tassertThat(annotationWithDefaults.text()).as(\"text: \").isEqualTo(\"enigma\");\n\t\tassertThat(annotationWithDefaults.predicate()).as(\"predicate: \").isTrue();\n\t\tassertThat(annotationWithDefaults.characters()).as(\"characters: \").isEqualTo(new char[] { 'a', 'b', 'c' });\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromDefaultsWithAttributeAliases() {\n\t\tContextConfig contextConfig = synthesizeAnnotation(ContextConfig.class);\n\t\tassertThat(contextConfig).isNotNull();\n\t\tassertThat(contextConfig.value()).as(\"value: \").isEmpty();\n\t\tassertThat(contextConfig.location()).as(\"location: \").isEmpty();\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithMinimalAttributesWithAttributeAliases() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"location\", \"test.xml\");\n\t\tContextConfig contextConfig = synthesizeAnnotation(map, ContextConfig.class, null);\n\t\tassertThat(contextConfig).isNotNull();\n\t\tassertThat(contextConfig.value()).as(\"value: \").isEqualTo(\"test.xml\");\n\t\tassertThat(contextConfig.location()).as(\"location: \").isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"value\", \"/foo\");\n\t\tGet get = synthesizeAnnotation(map, Get.class, null);\n\t\tassertThat(get).isNotNull();\n\t\tassertThat(get.value()).as(\"value: \").isEqualTo(\"/foo\");\n\t\tassertThat(get.path()).as(\"path: \").isEqualTo(\"/foo\");\n\n\t\tmap = Collections.singletonMap(\"path\", \"/foo\");\n\t\tget = synthesizeAnnotation(map, Get.class, null);\n\t\tassertThat(get).isNotNull();\n\t\tassertThat(get.value()).as(\"value: \").isEqualTo(\"/foo\");\n\t\tassertThat(get.path()).as(\"path: \").isEqualTo(\"/foo\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithImplicitAttributeAliases() {\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"value\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"location1\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"location2\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"location3\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"xmlFile\");\n\t\tassertAnnotationSynthesisFromMapWithImplicitAliases(\"groovyScript\");\n\t}\n\n\tprivate void assertAnnotationSynthesisFromMapWithImplicitAliases(String attributeNameAndValue) {\n\t\tMap<String, Object> map = Collections.singletonMap(attributeNameAndValue, attributeNameAndValue);\n\t\tImplicitAliasesContextConfig config = synthesizeAnnotation(map, ImplicitAliasesContextConfig.class, null);\n\t\tassertThat(config).isNotNull();\n\t\tassertThat(config.value()).as(\"value: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.location1()).as(\"location1: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.location2()).as(\"location2: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.location3()).as(\"location3: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.xmlFile()).as(\"xmlFile: \").isEqualTo(attributeNameAndValue);\n\t\tassertThat(config.groovyScript()).as(\"groovyScript: \").isEqualTo(attributeNameAndValue);\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithMissingAttributeValue() {\n\t\tassertMissingTextAttribute(Collections.emptyMap());\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithNullAttributeValue() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"text\", null);\n\t\tassertThat(map.containsKey(\"text\")).isTrue();\n\t\tassertMissingTextAttribute(map);\n\t}\n\n\tprivate void assertMissingTextAttribute(Map<String, Object> attributes) {\n\t\tassertThatExceptionOfType(NoSuchElementException.class).isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(attributes, AnnotationWithoutDefaults.class, null).text())\n\t\t\t.withMessageContaining(\"No value found for attribute named 'text' in merged annotation\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromMapWithAttributeOfIncorrectType() {\n\t\tMap<String, Object> map = Collections.singletonMap(VALUE, 42L);\n\t\tassertThatIllegalStateException().isThrownBy(() ->\n\t\t\t\tsynthesizeAnnotation(map, Component.class, null).value())\n\t\t\t.withMessageContaining(\"Attribute 'value' in annotation org.springframework.core.testfixture.stereotype.Component \"\n\t\t\t\t\t+ \"should be compatible with java.lang.String but a java.lang.Long value was returned\");\n\t}\n\n\t@Test\n\tvoid synthesizeAnnotationFromAnnotationAttributesWithoutAttributeAliases() {\n\t\t// 1) Get an annotation\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\n\t\t// 2) Convert the annotation into AnnotationAttributes\n\t\tAnnotationAttributes attributes = getAnnotationAttributes(WebController.class, component);\n\t\tassertThat(attributes).isNotNull();\n\n\t\t// 3) Synthesize the AnnotationAttributes back into an annotation\n\t\tComponent synthesizedComponent = synthesizeAnnotation(attributes, Component.class, WebController.class);\n\t\tassertThat(synthesizedComponent).isNotNull();\n\n\t\t// 4) Verify that the original and synthesized annotations are equivalent\n\t\tassertThat(synthesizedComponent).isNotSameAs(component);\n\t\tassertThat(synthesizedComponent).isEqualTo(component);\n\t\tassertThat(component.value()).as(\"value from component: \").isEqualTo(\"webController\");\n\t\tassertThat(synthesizedComponent.value()).as(\"value from synthesized component: \").isEqualTo(\"webController\");\n\t}\n\n\t@Test  // gh-22702\n\tvoid findAnnotationWithRepeatablesElements() {\n\t\tassertThat(AnnotationUtils.findAnnotation(TestRepeatablesClass.class,\n\t\t\t\tTestRepeatable.class)).isNull();\n\t\tassertThat(AnnotationUtils.findAnnotation(TestRepeatablesClass.class,\n\t\tTestRepeatableContainer.class)).isNotNull();\n\t}\n\n\t@Test  // gh-23856\n\tvoid findAnnotationFindsRepeatableContainerOnComposedAnnotationMetaAnnotatedWithRepeatableAnnotations() {\n\t\tMyRepeatableContainer annotation = AnnotationUtils.findAnnotation(MyRepeatableMeta1And2.class, MyRepeatableContainer.class);\n\n\t\tassertThat(annotation).isNotNull();\n\t\tassertThat(annotation.value()).extracting(MyRepeatable::value).containsExactly(\"meta1\", \"meta2\");\n\t}\n\n\t@Test  // gh-23856\n\tvoid findAnnotationFindsRepeatableContainerOnComposedAnnotationMetaAnnotatedWithRepeatableAnnotationsOnMethod() throws Exception {\n\t\tMethod method = getClass().getDeclaredMethod(\"methodWithComposedAnnotationMetaAnnotatedWithRepeatableAnnotations\");\n\t\tMyRepeatableContainer annotation = AnnotationUtils.findAnnotation(method, MyRepeatableContainer.class);\n\n\t\tassertThat(annotation).isNotNull();\n\t\tassertThat(annotation.value()).extracting(MyRepeatable::value).containsExactly(\"meta1\", \"meta2\");\n\t}\n\n\t@Test  // gh-23929\n\tvoid findDeprecatedAnnotation() {\n\t\tassertThat(getAnnotation(DeprecatedClass.class, Deprecated.class)).isNotNull();\n\t\tassertThat(getAnnotation(SubclassOfDeprecatedClass.class, Deprecated.class)).isNull();\n\t\tassertThat(findAnnotation(DeprecatedClass.class, Deprecated.class)).isNotNull();\n\t\tassertThat(findAnnotation(SubclassOfDeprecatedClass.class, Deprecated.class)).isNotNull();\n\t}\n\n\n\t@SafeVarargs\n\tstatic <T> T[] asArray(T... arr) {\n\t\treturn arr;\n\t}\n\n\n\t@Component(\"meta1\")\n\t@Order\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Meta1 {\n\t}\n\n\t@Component(\"meta2\")\n\t@Transactional(readOnly = true)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Meta2 {\n\t}\n\n\t@Meta2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMeta {\n\t}\n\n\t@MetaMeta\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMetaMeta {\n\t}\n\n\t@MetaCycle3\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle1 {\n\t}\n\n\t@MetaCycle1\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle2 {\n\t}\n\n\t@MetaCycle2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle3 {\n\t}\n\n\t@Meta1\n\tinterface InterfaceWithMetaAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface implements InterfaceWithMetaAnnotation {\n\t}\n\n\t@Meta1\n\tstatic class ClassWithInheritedMetaAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class SubClassWithInheritedMetaAnnotation extends ClassWithInheritedMetaAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedMetaAnnotation extends SubClassWithInheritedMetaAnnotation {\n\t}\n\n\t@Transactional\n\tstatic class ClassWithInheritedAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class SubClassWithInheritedAnnotation extends ClassWithInheritedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedAnnotation extends SubClassWithInheritedAnnotation {\n\t}\n\n\t@MetaMeta\n\tstatic class MetaMetaAnnotatedClass {\n\t}\n\n\t@MetaMetaMeta\n\tstatic class MetaMetaMetaAnnotatedClass {\n\t}\n\n\t@MetaCycle3\n\tstatic class MetaCycleAnnotatedClass {\n\t}\n\n\tpublic interface AnnotatedInterface {\n\n\t\t@Order(0)\n\t\tvoid fromInterfaceImplementedByRoot();\n\t}\n\n\tpublic static class Root implements AnnotatedInterface {\n\n\t\t@Order(27)\n\t\tpublic void annotatedOnRoot() {\n\t\t}\n\n\t\t@Meta1\n\t\tpublic void metaAnnotatedOnRoot() {\n\t\t}\n\n\t\tpublic void overrideToAnnotate() {\n\t\t}\n\n\t\t@Order(27)\n\t\tpublic void overrideWithoutNewAnnotation() {\n\t\t}\n\n\t\tpublic void notAnnotated() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void fromInterfaceImplementedByRoot() {\n\t\t}\n\t}\n\n\tpublic static class Leaf extends Root {\n\n\t\t@Order(25)\n\t\tpublic void annotatedOnLeaf() {\n\t\t}\n\n\t\t@Meta1\n\t\tpublic void metaAnnotatedOnLeaf() {\n\t\t}\n\n\t\t@MetaMeta\n\t\tpublic void metaMetaAnnotatedOnLeaf() {\n\t\t}\n\n\t\t@Override\n\t\t@Order(1)\n\t\tpublic void overrideToAnnotate() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void overrideWithoutNewAnnotation() {\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Transactional {\n\n\t\tboolean readOnly() default false;\n\t}\n\n\tpublic abstract static class Foo<T> {\n\n\t\t@Order(1)\n\t\tpublic abstract void something(T arg);\n\t}\n\n\tpublic static class SimpleFoo extends Foo<String> {\n\n\t\t@Override\n\t\t@Transactional\n\t\tpublic void something(final String arg) {\n\t\t}\n\t}\n\n\t@Transactional\n\tpublic interface InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubInheritedAnnotationInterface extends InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubInheritedAnnotationInterface extends SubInheritedAnnotationInterface {\n\t}\n\n\t@Order\n\tpublic interface NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubNonInheritedAnnotationInterface extends NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubNonInheritedAnnotationInterface extends SubNonInheritedAnnotationInterface {\n\t}\n\n\tpublic static class NonAnnotatedClass {\n\t}\n\n\tpublic interface NonAnnotatedInterface {\n\t}\n\n\t@Transactional\n\tpublic static class InheritedAnnotationClass {\n\t}\n\n\tpublic static class SubInheritedAnnotationClass extends InheritedAnnotationClass {\n\t}\n\n\t@Order\n\tpublic static class NonInheritedAnnotationClass {\n\t}\n\n\tpublic static class SubNonInheritedAnnotationClass extends NonInheritedAnnotationClass {\n\t}\n\n\t@Transactional\n\tpublic static class TransactionalClass {\n\t}\n\n\t@Order\n\tpublic static class TransactionalAndOrderedClass extends TransactionalClass {\n\t}\n\n\tpublic static class SubTransactionalAndOrderedClass extends TransactionalAndOrderedClass {\n\t}\n\n\tpublic interface InterfaceWithAnnotatedMethod {\n\n\t\t@Order\n\t\tvoid foo();\n\t}\n\n\tpublic static class ImplementsInterfaceWithAnnotatedMethod implements InterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic static class SubOfImplementsInterfaceWithAnnotatedMethod extends ImplementsInterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic abstract static class AbstractDoesNotImplementInterfaceWithAnnotatedMethod\n\t\t\timplements InterfaceWithAnnotatedMethod {\n\t}\n\n\tpublic static class SubOfAbstractImplementsInterfaceWithAnnotatedMethod\n\t\t\textends AbstractDoesNotImplementInterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic interface InterfaceWithGenericAnnotatedMethod<T> {\n\n\t\t@Order\n\t\tvoid foo(T t);\n\t}\n\n\tpublic static class ImplementsInterfaceWithGenericAnnotatedMethod implements InterfaceWithGenericAnnotatedMethod<String> {\n\n\t\t@Override\n\t\tpublic void foo(String t) {\n\t\t}\n\t}\n\n\tpublic abstract static class BaseClassWithGenericAnnotatedMethod<T> {\n\n\t\t@Order\n\t\tabstract void foo(T t);\n\t}\n\n\tpublic static class ExtendsBaseClassWithGenericAnnotatedMethod extends BaseClassWithGenericAnnotatedMethod<String> {\n\n\t\t@Override\n\t\tpublic void foo(String t) {\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface MyRepeatableContainer {\n\n\t\tMyRepeatable[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@Repeatable(MyRepeatableContainer.class)\n\t@interface MyRepeatable {\n\n\t\tString value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta1\")\n\t@interface MyRepeatableMeta1 {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta2\")\n\t@interface MyRepeatableMeta2 {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta1\")\n\t@MyRepeatable(\"meta2\")\n\t@interface MyRepeatableMeta1And2 {\n\t}\n\n\t@MyRepeatableMeta1And2\n\tvoid methodWithComposedAnnotationMetaAnnotatedWithRepeatableAnnotations() {\n\t}\n\n\tinterface InterfaceWithRepeated {\n\n\t\t@MyRepeatable(\"A\")\n\t\t@MyRepeatableContainer({@MyRepeatable(\"B\"), @MyRepeatable(\"C\")})\n\t\t@MyRepeatableMeta1\n\t\tvoid foo();\n\t}\n\n\t@MyRepeatable(\"A\")\n\t@MyRepeatableContainer({@MyRepeatable(\"B\"), @MyRepeatable(\"C\")})\n\t@MyRepeatableMeta1\n\tstatic class MyRepeatableClass {\n\t}\n\n\tstatic class SubMyRepeatableClass extends MyRepeatableClass {\n\t}\n\n\t@MyRepeatable(\"X\")\n\t@MyRepeatableContainer({@MyRepeatable(\"Y\"), @MyRepeatable(\"Z\")})\n\t@MyRepeatableMeta2\n\tstatic class SubMyRepeatableWithAdditionalLocalDeclarationsClass extends MyRepeatableClass {\n\t}\n\n\tstatic class SubSubMyRepeatableWithAdditionalLocalDeclarationsClass extends\n\t\t\tSubMyRepeatableWithAdditionalLocalDeclarationsClass {\n\t}\n\n\tenum RequestMethod {\n\t\tGET, POST\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.web.bind.annotation.RequestMapping}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface WebMapping {\n\n\t\tString name();\n\n\t\t@AliasFor(\"path\")\n\t\tString[] value() default \"\";\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tString[] path() default \"\";\n\n\t\tRequestMethod[] method() default {};\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.web.bind.annotation.GetMapping}, except\n\t * that the String arrays are overridden with single String elements.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@WebMapping(method = RequestMethod.GET, name = \"\")\n\t@interface Get {\n\n\t\t@AliasFor(annotation = WebMapping.class)\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = WebMapping.class)\n\t\tString path() default \"\";\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.web.bind.annotation.PostMapping}, except\n\t * that the path is overridden by convention with single String element.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@WebMapping(method = RequestMethod.POST, name = \"\")\n\t@interface Post {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = WebMapping.class)\n\t\tString path() default \"\";\n\t}\n\n\t@Component(\"webController\")\n\tstatic class WebController {\n\n\t\t@WebMapping(value = \"/test\", name = \"foo\")\n\t\tpublic void handleMappedWithValueAttribute() {\n\t\t}\n\n\t\t@WebMapping(path = \"/test\", name = \"bar\", method = { RequestMethod.GET, RequestMethod.POST })\n\t\tpublic void handleMappedWithPathAttribute() {\n\t\t}\n\n\t\t@Get(\"/test\")\n\t\tpublic void getMappedWithValueAttribute() {\n\t\t}\n\n\t\t@Get(path = \"/test\")\n\t\tpublic void getMappedWithPathAttribute() {\n\t\t}\n\n\t\t@Post(path = \"/test\")\n\t\tpublic void postMappedWithPathAttribute() {\n\t\t}\n\n\t\t/**\n\t\t * mapping is logically \"equal\" to handleMappedWithPathAttribute().\n\t\t */\n\t\t@WebMapping(value = \"/test\", path = \"/test\", name = \"bar\", method = { RequestMethod.GET, RequestMethod.POST })\n\t\tpublic void handleMappedWithSamePathAndValueAttributes() {\n\t\t}\n\n\t\t@WebMapping(value = \"/enigma\", path = \"/test\", name = \"baz\")\n\t\tpublic void handleMappedWithDifferentPathAndValueAttributes() {\n\t\t}\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.test.context.ContextConfiguration}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContextConfig {\n\n\t\t@AliasFor(\"location\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString location() default \"\";\n\n\t\tClass<?> klass() default Object.class;\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.test.context.ContextHierarchy}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Hierarchy {\n\t\tContextConfig[] value();\n\t}\n\n\t@Hierarchy({@ContextConfig(\"A\"), @ContextConfig(location = \"B\")})\n\tstatic class ConfigHierarchyTestCase {\n\t}\n\n\t@ContextConfig(\"simple.xml\")\n\tstatic class SimpleConfigTestCase {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface CharsContainer {\n\n\t\t@AliasFor(attribute = \"chars\")\n\t\tchar[] value() default {};\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tchar[] chars() default {};\n\t}\n\n\t@CharsContainer(chars = { 'x', 'y', 'z' })\n\tstatic class GroupOfCharsClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMissingAttributeDeclaration {\n\n\t\t@AliasFor\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForWithMissingAttributeDeclaration\n\tstatic class AliasForWithMissingAttributeDeclarationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithDuplicateAttributeDeclaration {\n\n\t\t@AliasFor(value = \"bar\", attribute = \"baz\")\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForWithDuplicateAttributeDeclaration\n\tstatic class AliasForWithDuplicateAttributeDeclarationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForNonexistentAttribute {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForNonexistentAttribute\n\tstatic class AliasForNonexistentAttributeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithoutMirroredAliasFor {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"\";\n\n\t\tString bar() default \"\";\n\t}\n\n\t@AliasForWithoutMirroredAliasFor\n\tstatic class AliasForWithoutMirroredAliasForClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMirroredAliasForWrongAttribute {\n\n\t\t@AliasFor(attribute = \"bar\")\n\t\tString[] foo() default \"\";\n\n\t\t@AliasFor(attribute = \"quux\")\n\t\tString[] bar() default \"\";\n\t}\n\n\t@AliasForWithMirroredAliasForWrongAttribute\n\tstatic class AliasForWithMirroredAliasForWrongAttributeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForAttributeOfDifferentType {\n\n\t\t@AliasFor(\"bar\")\n\t\tString[] foo() default \"\";\n\n\t\t@AliasFor(\"foo\")\n\t\tboolean bar() default true;\n\t}\n\n\t@AliasForAttributeOfDifferentType\n\tstatic class AliasForAttributeOfDifferentTypeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMissingDefaultValues {\n\n\t\t@AliasFor(attribute = \"bar\")\n\t\tString foo();\n\n\t\t@AliasFor(attribute = \"foo\")\n\t\tString bar();\n\t}\n\n\t@AliasForWithMissingDefaultValues(foo = \"foo\", bar = \"bar\")\n\tstatic class AliasForWithMissingDefaultValuesClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForAttributeWithDifferentDefaultValue {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"X\";\n\n\t\t@AliasFor(\"foo\")\n\t\tString bar() default \"Z\";\n\t}\n\n\t@AliasForAttributeWithDifferentDefaultValue\n\tstatic class AliasForAttributeWithDifferentDefaultValueClass {\n\t}\n\n\t// @ContextConfig --> Intentionally NOT meta-present\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfigNotMetaPresent {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlConfigFile();\n\t}\n\n\t@AliasedComposedContextConfigNotMetaPresent(xmlConfigFile = \"test.xml\")\n\tstatic class AliasedComposedContextConfigNotMetaPresentClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlConfigFile();\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface ImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString groovyScript() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location1() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location2() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location3() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"klass\")\n\t\tClass<?> configClass() default Object.class;\n\n\t\tString nonAliasedAttribute() default \"\";\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(groovyScript = \"groovyScript\")\n\tstatic class GroovyImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(xmlFile = \"xmlFile\")\n\tstatic class XmlImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(\"value\")\n\tstatic class ValueImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(location1 = \"location1\")\n\tstatic class Location1ImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(location2 = \"location2\")\n\tstatic class Location2ImplicitAliasesContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesContextConfig(location3 = \"location3\")\n\tstatic class Location3ImplicitAliasesContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig {\n\n\t\t// intentionally omitted: attribute = \"value\"\n\t\t@AliasFor(annotation = ContextConfig.class)\n\t\tString value() default \"\";\n\n\t\t// intentionally omitted: attribute = \"locations\"\n\t\t@AliasFor(annotation = ContextConfig.class)\n\t\tString location() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesWithImpliedAliasNamesOmittedContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig.class, attribute = \"location\")\n\t\tString groovy() default \"\";\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig(\"value\")\n\tstatic class ValueImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig(location = \"location\")\n\tstatic class LocationsImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass {\n\t}\n\n\t// Attribute value intentionally matches attribute name:\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig(xmlFile = \"xmlFile\")\n\tstatic class XmlFilesImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithMissingDefaultValuesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location1();\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location2();\n\t}\n\n\t@ImplicitAliasesWithMissingDefaultValuesContextConfig(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithMissingDefaultValuesContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithDifferentDefaultValuesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location1() default \"foo\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location2() default \"bar\";\n\t}\n\n\t@ImplicitAliasesWithDifferentDefaultValuesContextConfig(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithDifferentDefaultValuesContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithDuplicateValuesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location1() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString location2() default \"\";\n\t}\n\n\t@ImplicitAliasesWithDuplicateValuesContextConfig(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithDuplicateValuesContextConfigClass {\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesForAliasPairContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\n\t\t@AliasFor(annotation = ContextConfig.class, value = \"value\")\n\t\tString groovyScript() default \"\";\n\t}\n\n\t@ImplicitAliasesForAliasPairContextConfig(xmlFile = \"test.xml\")\n\tstatic class ImplicitAliasesForAliasPairContextConfigClass {\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScript\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@TransitiveImplicitAliasesContextConfig(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesContextConfigClass {\n\t}\n\n\t@ImplicitAliasesForAliasPairContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesForAliasPairContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesForAliasPairContextConfig.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesForAliasPairContextConfig.class, attribute = \"groovyScript\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@TransitiveImplicitAliasesForAliasPairContextConfig(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesForAliasPairContextConfigClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({})\n\t@interface Filter {\n\t\tString pattern();\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.context.annotation.ComponentScan}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScan {\n\t\tFilter[] excludeFilters() default {};\n\t}\n\n\t@ComponentScan(excludeFilters = {@Filter(pattern = \"*Foo\"), @Filter(pattern = \"*Bar\")})\n\tstatic class ComponentScanClass {\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.context.annotation.ComponentScan}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScanSingleFilter {\n\t\tFilter value();\n\t}\n\n\t@ComponentScanSingleFilter(@Filter(pattern = \"*Foo\"))\n\tstatic class ComponentScanSingleFilterClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnotationWithDefaults {\n\t\tString text() default \"enigma\";\n\t\tboolean predicate() default true;\n\t\tchar[] characters() default {'a', 'b', 'c'};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnotationWithoutDefaults {\n\t\tString text();\n\t}\n\n\t@ContextConfig(value = \"foo\", location = \"bar\")\n\tinterface ContextConfigMismatch {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(TestRepeatableContainer.class)\n\t@interface TestRepeatable {\n\n\t\tString value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestRepeatableContainer {\n\n\t\tTestRepeatable[] value();\n\t}\n\n\t@TestRepeatable(\"a\")\n\t@TestRepeatable(\"b\")\n\tstatic class TestRepeatablesClass {\n\t}\n\n\t@Deprecated\n\tstatic class DeprecatedClass {\n\t}\n\n\tstatic class SubclassOfDeprecatedClass extends DeprecatedClass {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtilsTests#clearCacheBeforeTests()",
    "headType": "method",
    "relation": "provide",
    "tail": "@BeforeEach\r\nvoid clearCacheBeforeTests() {\r\n    AnnotationUtils.clearCache();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtilsTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotationUtilsTests#clearCacheBeforeTests()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtilsTests#clearCacheBeforeTests()",
    "headType": "method",
    "relation": "use",
    "tail": "@BeforeEach",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtilsTests#findMethodAnnotationOnLeaf()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid findMethodAnnotationOnLeaf() throws Exception {\r\n    Method m = Leaf.class.getMethod(\"annotatedOnLeaf\");\r\n    assertThat(m.getAnnotation(Order.class)).isNotNull();\r\n    assertThat(getAnnotation(m, Order.class)).isNotNull();\r\n    assertThat(findAnnotation(m, Order.class)).isNotNull();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtilsTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotationUtilsTests#findMethodAnnotationOnLeaf()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtilsTests#findMethodAnnotationOnLeaf()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtilsTests#findMethodAnnotationWithAnnotationOnMethodInInterface()",
    "headType": "method",
    "relation": "provide",
    "tail": "// @since 4.2\r\n@Test\r\nvoid findMethodAnnotationWithAnnotationOnMethodInInterface() throws Exception {\r\n    Method m = Leaf.class.getMethod(\"fromInterfaceImplementedByRoot\");\r\n    // @Order is not @Inherited\r\n    assertThat(m.getAnnotation(Order.class)).isNull();\r\n    // getAnnotation() does not search on interfaces\r\n    assertThat(getAnnotation(m, Order.class)).isNull();\r\n    // findAnnotation() does search on interfaces\r\n    assertThat(findAnnotation(m, Order.class)).isNotNull();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtilsTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotationUtilsTests#findMethodAnnotationWithAnnotationOnMethodInInterface()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtilsTests#findMethodAnnotationWithAnnotationOnMethodInInterface()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  }
]