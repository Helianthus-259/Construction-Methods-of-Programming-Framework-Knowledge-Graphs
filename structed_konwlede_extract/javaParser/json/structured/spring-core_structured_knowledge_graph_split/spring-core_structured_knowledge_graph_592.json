[
  {
    "head": "org.springframework.cglib.core.UnnecessaryBridgeFinder",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.core.UnnecessaryBridgeFinder#rejected",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.core.UnnecessaryBridgeFinder#rejected",
    "headType": "field",
    "relation": "haveType",
    "tail": "Set",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.core.UnnecessaryBridgeFinder",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.core.UnnecessaryBridgeFinder#currentMethodSig",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.core.UnnecessaryBridgeFinder#currentMethodSig",
    "headType": "field",
    "relation": "haveType",
    "tail": "Signature",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.core.UnnecessaryBridgeFinder",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.core.UnnecessaryBridgeFinder#methods",
    "tailType": "field"
  },
  {
    "head": "org.springframework.cglib.core.UnnecessaryBridgeFinder#methods",
    "headType": "field",
    "relation": "haveType",
    "tail": "Map",
    "tailType": "type"
  },
  {
    "head": "org.springframework.cglib.core.UnnecessaryBridgeFinder#addSuspectMethod(Method)",
    "headType": "method",
    "relation": "provide",
    "tail": "void addSuspectMethod(Method m) {\r\n    methods.put(ReflectUtils.getSignature(m), m);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.cglib.core.UnnecessaryBridgeFinder",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.cglib.core.UnnecessaryBridgeFinder#addSuspectMethod(Method)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.cglib.core.UnnecessaryBridgeFinder#visit(int,int,String,String,String,String[])",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic void visit(int version, int access, String name, String signature, String superName, String[] interfaces) ;",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.cglib.core.UnnecessaryBridgeFinder",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.cglib.core.UnnecessaryBridgeFinder#visit(int,int,String,String,String,String[])",
    "tailType": "method"
  },
  {
    "head": "org.springframework.cglib.core.UnnecessaryBridgeFinder#visit(int,int,String,String,String,String[])",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.cglib.core.UnnecessaryBridgeFinder#visitMethod(int,String,String,String,String[])",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\r\n    Signature sig = new Signature(name, desc);\r\n    final Method currentMethod = (Method) methods.remove(sig);\r\n    if (currentMethod != null) {\r\n        currentMethodSig = sig;\r\n        return new MethodVisitor(Constants.ASM_API) {\r\n\r\n            @Override\r\n            public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\r\n                if (opcode == Opcodes.INVOKESPECIAL && currentMethodSig != null) {\r\n                    Signature target = new Signature(name, desc);\r\n                    if (target.equals(currentMethodSig)) {\r\n                        rejected.add(currentMethod);\r\n                    }\r\n                    currentMethodSig = null;\r\n                }\r\n            }\r\n        };\r\n    } else {\r\n        return null;\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.cglib.core.UnnecessaryBridgeFinder",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.cglib.core.UnnecessaryBridgeFinder#visitMethod(int,String,String,String,String[])",
    "tailType": "method"
  },
  {
    "head": "org.springframework.cglib.core.UnnecessaryBridgeFinder#visitMethod(int,String,String,String,String[])",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.cglib.core.UnnecessaryBridgeFinder",
    "headType": "class",
    "relation": "extend",
    "tail": "ClassVisitor",
    "tailType": "class"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.cglib.core",
    "tailType": "package"
  },
  {
    "head": "org.springframework.cglib.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.cglib.core.EmitUtils",
    "tailType": "class"
  },
  {
    "head": "org.springframework.cglib.core.EmitUtils",
    "headType": "class",
    "relation": "use",
    "tail": "@SuppressWarnings",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.cglib.core.EmitUtils",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2003,2004 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.cglib.core;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.springframework.asm.Label;\nimport org.springframework.asm.Type;\nimport org.springframework.cglib.core.internal.CustomizerRegistry;\n\n@SuppressWarnings({\"rawtypes\", \"unchecked\", \"static\", \"fallthrough\", \"deprecation\"})\npublic class EmitUtils {\n    private static final Signature CSTRUCT_NULL =\n      TypeUtils.parseConstructor(\"\");\n    private static final Signature CSTRUCT_THROWABLE =\n      TypeUtils.parseConstructor(\"Throwable\");\n\n    private static final Signature GET_NAME =\n      TypeUtils.parseSignature(\"String getName()\");\n    private static final Signature HASH_CODE =\n      TypeUtils.parseSignature(\"int hashCode()\");\n    private static final Signature EQUALS =\n      TypeUtils.parseSignature(\"boolean equals(Object)\");\n    private static final Signature STRING_LENGTH =\n      TypeUtils.parseSignature(\"int length()\");\n    private static final Signature STRING_CHAR_AT =\n      TypeUtils.parseSignature(\"char charAt(int)\");\n    private static final Signature FOR_NAME =\n      TypeUtils.parseSignature(\"Class forName(String)\");\n    private static final Signature DOUBLE_TO_LONG_BITS =\n      TypeUtils.parseSignature(\"long doubleToLongBits(double)\");\n    private static final Signature FLOAT_TO_INT_BITS =\n      TypeUtils.parseSignature(\"int floatToIntBits(float)\");\n    private static final Signature TO_STRING =\n      TypeUtils.parseSignature(\"String toString()\");\n    private static final Signature APPEND_STRING =\n      TypeUtils.parseSignature(\"StringBuffer append(String)\");\n    private static final Signature APPEND_INT =\n      TypeUtils.parseSignature(\"StringBuffer append(int)\");\n    private static final Signature APPEND_DOUBLE =\n      TypeUtils.parseSignature(\"StringBuffer append(double)\");\n    private static final Signature APPEND_FLOAT =\n      TypeUtils.parseSignature(\"StringBuffer append(float)\");\n    private static final Signature APPEND_CHAR =\n      TypeUtils.parseSignature(\"StringBuffer append(char)\");\n    private static final Signature APPEND_LONG =\n      TypeUtils.parseSignature(\"StringBuffer append(long)\");\n    private static final Signature APPEND_BOOLEAN =\n      TypeUtils.parseSignature(\"StringBuffer append(boolean)\");\n    private static final Signature LENGTH =\n      TypeUtils.parseSignature(\"int length()\");\n    private static final Signature SET_LENGTH =\n      TypeUtils.parseSignature(\"void setLength(int)\");\n    private static final Signature GET_DECLARED_METHOD =\n      TypeUtils.parseSignature(\"java.lang.reflect.Method getDeclaredMethod(String, Class[])\");\n\n\n\n    public static final ArrayDelimiters DEFAULT_DELIMITERS = new ArrayDelimiters(\"{\", \", \", \"}\");\n\n    private EmitUtils() {\n    }\n\n    public static void factory_method(ClassEmitter ce, Signature sig) {\n        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, sig, null);\n        e.new_instance_this();\n        e.dup();\n        e.load_args();\n        e.invoke_constructor_this(TypeUtils.parseConstructor(sig.getArgumentTypes()));\n        e.return_value();\n        e.end_method();\n    }\n\n    public static void null_constructor(ClassEmitter ce) {\n        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, CSTRUCT_NULL, null);\n        e.load_this();\n        e.super_invoke_constructor();\n        e.return_value();\n        e.end_method();\n    }\n\n    /**\n     * Process an array on the stack. Assumes the top item on the stack\n     * is an array of the specified type. For each element in the array,\n     * puts the element on the stack and triggers the callback.\n     * @param type the type of the array (type.isArray() must be true)\n     * @param callback the callback triggered for each element\n     */\n    public static void process_array(CodeEmitter e, Type type, ProcessArrayCallback callback) {\n        Type componentType = TypeUtils.getComponentType(type);\n        Local array = e.make_local();\n        Local loopvar = e.make_local(Type.INT_TYPE);\n        Label loopbody = e.make_label();\n        Label checkloop = e.make_label();\n        e.store_local(array);\n        e.push(0);\n        e.store_local(loopvar);\n        e.goTo(checkloop);\n\n        e.mark(loopbody);\n        e.load_local(array);\n        e.load_local(loopvar);\n        e.array_load(componentType);\n        callback.processElement(componentType);\n        e.iinc(loopvar, 1);\n\n        e.mark(checkloop);\n        e.load_local(loopvar);\n        e.load_local(array);\n        e.arraylength();\n        e.if_icmp(CodeEmitter.LT, loopbody);\n    }\n\n    /**\n     * Process two arrays on the stack in parallel. Assumes the top two items on the stack\n     * are arrays of the specified class. The arrays must be the same length. For each pair\n     * of elements in the arrays, puts the pair on the stack and triggers the callback.\n     * @param type the type of the arrays (type.isArray() must be true)\n     * @param callback the callback triggered for each pair of elements\n     */\n    public static void process_arrays(CodeEmitter e, Type type, ProcessArrayCallback callback) {\n        Type componentType = TypeUtils.getComponentType(type);\n        Local array1 = e.make_local();\n        Local array2 = e.make_local();\n        Local loopvar = e.make_local(Type.INT_TYPE);\n        Label loopbody = e.make_label();\n        Label checkloop = e.make_label();\n        e.store_local(array1);\n        e.store_local(array2);\n        e.push(0);\n        e.store_local(loopvar);\n        e.goTo(checkloop);\n\n        e.mark(loopbody);\n        e.load_local(array1);\n        e.load_local(loopvar);\n        e.array_load(componentType);\n        e.load_local(array2);\n        e.load_local(loopvar);\n        e.array_load(componentType);\n        callback.processElement(componentType);\n        e.iinc(loopvar, 1);\n\n        e.mark(checkloop);\n        e.load_local(loopvar);\n        e.load_local(array1);\n        e.arraylength();\n        e.if_icmp(CodeEmitter.LT, loopbody);\n    }\n\n    public static void string_switch(CodeEmitter e, String[] strings, int switchStyle, ObjectSwitchCallback callback) {\n        try {\n            switch (switchStyle) {\n            case Constants.SWITCH_STYLE_TRIE:\n                string_switch_trie(e, strings, callback);\n                break;\n            case Constants.SWITCH_STYLE_HASH:\n                string_switch_hash(e, strings, callback, false);\n                break;\n            case Constants.SWITCH_STYLE_HASHONLY:\n                string_switch_hash(e, strings, callback, true);\n                break;\n            default:\n                throw new IllegalArgumentException(\"unknown switch style \" + switchStyle);\n            }\n        } catch (RuntimeException | Error ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new CodeGenerationException(ex);\n        }\n    }\n\n    private static void string_switch_trie(final CodeEmitter e,\n                                           String[] strings,\n                                           final ObjectSwitchCallback callback) throws Exception {\n        final Label def = e.make_label();\n        final Label end = e.make_label();\n        final Map buckets = CollectionUtils.bucket(Arrays.asList(strings), value -> ((String)value).length());\n        e.dup();\n        e.invoke_virtual(Constants.TYPE_STRING, STRING_LENGTH);\n        e.process_switch(getSwitchKeys(buckets), new ProcessSwitchCallback() {\n                @Override\n                public void processCase(int key, Label ignore_end) throws Exception {\n                    List bucket = (List)buckets.get(key);\n                    stringSwitchHelper(e, bucket, callback, def, end, 0);\n                }\n                @Override\n                public void processDefault() {\n                    e.goTo(def);\n                }\n            });\n        e.mark(def);\n        e.pop();\n        callback.processDefault();\n        e.mark(end);\n    }\n\n    private static void stringSwitchHelper(final CodeEmitter e,\n                                           List strings,\n                                           final ObjectSwitchCallback callback,\n                                           final Label def,\n                                           final Label end,\n                                           final int index) throws Exception {\n        final int len = ((String)strings.get(0)).length();\n        final Map buckets = CollectionUtils.bucket(strings, value -> ((String)value).charAt(index));\n        e.dup();\n        e.push(index);\n        e.invoke_virtual(Constants.TYPE_STRING, STRING_CHAR_AT);\n        e.process_switch(getSwitchKeys(buckets), new ProcessSwitchCallback() {\n                @Override\n                public void processCase(int key, Label ignore_end) throws Exception {\n                    List bucket = (List)buckets.get(key);\n                    if (index + 1 == len) {\n                        e.pop();\n                        callback.processCase(bucket.get(0), end);\n                    } else {\n                        stringSwitchHelper(e, bucket, callback, def, end, index + 1);\n                    }\n                }\n                @Override\n                public void processDefault() {\n                    e.goTo(def);\n                }\n            });\n    }\n\n    static int[] getSwitchKeys(Map buckets) {\n        int[] keys = new int[buckets.size()];\n        int index = 0;\n        for (Iterator it = buckets.keySet().iterator(); it.hasNext();) {\n            keys[index++] = ((Integer)it.next());\n        }\n        Arrays.sort(keys);\n        return keys;\n    }\n\n    private static void string_switch_hash(final CodeEmitter e,\n                                           final String[] strings,\n                                           final ObjectSwitchCallback callback,\n                                           final boolean skipEquals) throws Exception {\n        final Map buckets = CollectionUtils.bucket(Arrays.asList(strings), value -> value.hashCode());\n        final Label def = e.make_label();\n        final Label end = e.make_label();\n        e.dup();\n        e.invoke_virtual(Constants.TYPE_OBJECT, HASH_CODE);\n        e.process_switch(getSwitchKeys(buckets), new ProcessSwitchCallback() {\n            @Override\n            public void processCase(int key, Label ignore_end) throws Exception {\n                List bucket = (List)buckets.get(key);\n                Label next = null;\n                if (skipEquals && bucket.size() == 1) {\n                    if (skipEquals) {\n\t\t\t\t\t\te.pop();\n\t\t\t\t\t}\n                    callback.processCase(bucket.get(0), end);\n                } else {\n                    for (Iterator it = bucket.iterator(); it.hasNext();) {\n                        String string = (String)it.next();\n                        if (next != null) {\n                            e.mark(next);\n                        }\n                        if (it.hasNext()) {\n                            e.dup();\n                        }\n                        e.push(string);\n                        e.invoke_virtual(Constants.TYPE_OBJECT, EQUALS);\n                        if (it.hasNext()) {\n                            e.if_jump(CodeEmitter.EQ, next = e.make_label());\n                            e.pop();\n                        } else {\n                            e.if_jump(CodeEmitter.EQ, def);\n                        }\n                        callback.processCase(string, end);\n                    }\n                }\n            }\n            @Override\n            public void processDefault() {\n                e.pop();\n            }\n        });\n        e.mark(def);\n        callback.processDefault();\n        e.mark(end);\n    }\n\n    public static void load_class_this(CodeEmitter e) {\n        load_class_helper(e, e.getClassEmitter().getClassType());\n    }\n\n    public static void load_class(CodeEmitter e, Type type) {\n        if (TypeUtils.isPrimitive(type)) {\n            if (type == Type.VOID_TYPE) {\n                throw new IllegalArgumentException(\"cannot load void type\");\n            }\n            e.getstatic(TypeUtils.getBoxedType(type), \"TYPE\", Constants.TYPE_CLASS);\n        } else {\n            load_class_helper(e, type);\n        }\n    }\n\n    private static void load_class_helper(CodeEmitter e, final Type type) {\n        if (e.isStaticHook()) {\n            // have to fall back on non-optimized load\n            e.push(TypeUtils.emulateClassGetName(type));\n            e.invoke_static(Constants.TYPE_CLASS, FOR_NAME);\n        } else {\n            ClassEmitter ce = e.getClassEmitter();\n            String typeName = TypeUtils.emulateClassGetName(type);\n\n            // TODO: can end up with duplicated field names when using chained transformers; incorporate static hook # somehow\n            String fieldName = \"CGLIB$load_class$\" + TypeUtils.escapeType(typeName);\n            if (!ce.isFieldDeclared(fieldName)) {\n                ce.declare_field(Constants.PRIVATE_FINAL_STATIC, fieldName, Constants.TYPE_CLASS, null);\n                CodeEmitter hook = ce.getStaticHook();\n                hook.push(typeName);\n                hook.invoke_static(Constants.TYPE_CLASS, FOR_NAME);\n                hook.putstatic(ce.getClassType(), fieldName, Constants.TYPE_CLASS);\n            }\n            e.getfield(fieldName);\n        }\n    }\n\n    public static void push_array(CodeEmitter e, Object[] array) {\n        e.push(array.length);\n        e.newarray(Type.getType(remapComponentType(array.getClass().componentType())));\n        for (int i = 0; i < array.length; i++) {\n            e.dup();\n            e.push(i);\n            push_object(e, array[i]);\n            e.aastore();\n        }\n    }\n\n    private static Class remapComponentType(Class componentType) {\n        if (componentType.equals(Type.class)) {\n\t\t\treturn Class.class;\n\t\t}\n        return componentType;\n    }\n\n    public static void push_object(CodeEmitter e, Object obj) {\n        if (obj == null) {\n            e.aconst_null();\n        } else {\n            if (obj.getClass().isArray()) {\n                push_array(e, (Object[]) obj);\n            } else if (obj instanceof String text) {\n                e.push(text);\n            } else if (obj instanceof Type type) {\n                load_class(e, type);\n            } else if (obj instanceof Class<?> clazz) {\n                load_class(e, Type.getType(clazz));\n            } else if (obj instanceof BigInteger) {\n                e.new_instance(Constants.TYPE_BIG_INTEGER);\n                e.dup();\n                e.push(obj.toString());\n                e.invoke_constructor(Constants.TYPE_BIG_INTEGER);\n            } else if (obj instanceof BigDecimal) {\n                e.new_instance(Constants.TYPE_BIG_DECIMAL);\n                e.dup();\n                e.push(obj.toString());\n                e.invoke_constructor(Constants.TYPE_BIG_DECIMAL);\n            } else {\n                throw new IllegalArgumentException(\"unknown type: \" + obj.getClass());\n            }\n        }\n    }\n\n    /**\n     * @deprecated use {@link #hash_code(CodeEmitter, Type, int, CustomizerRegistry)} instead\n     */\n    @Deprecated\n    public static void hash_code(CodeEmitter e, Type type, int multiplier, final Customizer customizer) {\n        hash_code(e, type, multiplier, CustomizerRegistry.singleton(customizer));\n    }\n\n    public static void hash_code(CodeEmitter e, Type type, int multiplier, final CustomizerRegistry registry) {\n        if (TypeUtils.isArray(type)) {\n            hash_array(e, type, multiplier, registry);\n        } else {\n            e.swap(Type.INT_TYPE, type);\n            e.push(multiplier);\n            e.math(CodeEmitter.MUL, Type.INT_TYPE);\n            e.swap(type, Type.INT_TYPE);\n            if (TypeUtils.isPrimitive(type)) {\n                hash_primitive(e, type);\n            } else {\n                hash_object(e, type, registry);\n            }\n            e.math(CodeEmitter.ADD, Type.INT_TYPE);\n        }\n    }\n\n    private static void hash_array(final CodeEmitter e, Type type, final int multiplier, final CustomizerRegistry registry) {\n        Label skip = e.make_label();\n        Label end = e.make_label();\n        e.dup();\n        e.ifnull(skip);\n        EmitUtils.process_array(e, type, type1 -> hash_code(e, type1, multiplier, registry));\n        e.goTo(end);\n        e.mark(skip);\n        e.pop();\n        e.mark(end);\n    }\n\n    private static void hash_object(CodeEmitter e, Type type, CustomizerRegistry registry) {\n        // (f == null) ? 0 : f.hashCode();\n        Label skip = e.make_label();\n        Label end = e.make_label();\n        e.dup();\n        e.ifnull(skip);\n        boolean customHashCode = false;\n        for (HashCodeCustomizer customizer : registry.get(HashCodeCustomizer.class)) {\n            if (customizer.customize(e, type)) {\n                customHashCode = true;\n                break;\n            }\n        }\n        if (!customHashCode) {\n            for (Customizer customizer : registry.get(Customizer.class)) {\n                customizer.customize(e, type);\n            }\n            e.invoke_virtual(Constants.TYPE_OBJECT, HASH_CODE);\n        }\n        e.goTo(end);\n        e.mark(skip);\n        e.pop();\n        e.push(0);\n        e.mark(end);\n    }\n\n    private static void hash_primitive(CodeEmitter e, Type type) {\n        switch (type.getSort()) {\n        case Type.BOOLEAN:\n            // f ? 0 : 1\n            e.push(1);\n            e.math(CodeEmitter.XOR, Type.INT_TYPE);\n            break;\n        case Type.FLOAT:\n            // Float.floatToIntBits(f)\n            e.invoke_static(Constants.TYPE_FLOAT, FLOAT_TO_INT_BITS);\n            break;\n        case Type.DOUBLE:\n            // Double.doubleToLongBits(f), hash_code(Long.TYPE)\n            e.invoke_static(Constants.TYPE_DOUBLE, DOUBLE_TO_LONG_BITS);\n            // fall through\n        case Type.LONG:\n            hash_long(e);\n        }\n    }\n\n    private static void hash_long(CodeEmitter e) {\n        // (int)(f ^ (f >>> 32))\n        e.dup2();\n        e.push(32);\n        e.math(CodeEmitter.USHR, Type.LONG_TYPE);\n        e.math(CodeEmitter.XOR, Type.LONG_TYPE);\n        e.cast_numeric(Type.LONG_TYPE, Type.INT_TYPE);\n    }\n\n//     public static void not_equals(CodeEmitter e, Type type, Label notEquals) {\n//         not_equals(e, type, notEquals, null);\n//     }\n\n    /**\n     * @deprecated use {@link #not_equals(CodeEmitter, Type, Label, CustomizerRegistry)} instead\n     */\n    @Deprecated\n    public static void not_equals(CodeEmitter e, Type type, final Label notEquals, final Customizer customizer) {\n        not_equals(e, type, notEquals, CustomizerRegistry.singleton(customizer));\n    }\n\n    /**\n     * Branches to the specified label if the top two items on the stack\n     * are not equal. The items must both be of the specified\n     * class. Equality is determined by comparing primitive values\n     * directly and by invoking the <code>equals</code> method for\n     * Objects. Arrays are recursively processed in the same manner.\n     */\n    public static void not_equals(final CodeEmitter e, Type type, final Label notEquals, final CustomizerRegistry registry) {\n        (new ProcessArrayCallback() {\n            @Override\n            public void processElement(Type type) {\n                not_equals_helper(e, type, notEquals, registry, this);\n            }\n        }).processElement(type);\n    }\n\n    private static void not_equals_helper(CodeEmitter e,\n                                          Type type,\n                                          Label notEquals,\n                                          CustomizerRegistry registry,\n                                          ProcessArrayCallback callback) {\n        if (TypeUtils.isPrimitive(type)) {\n            e.if_cmp(type, CodeEmitter.NE, notEquals);\n        } else {\n            Label end = e.make_label();\n            nullcmp(e, notEquals, end);\n            if (TypeUtils.isArray(type)) {\n                Label checkContents = e.make_label();\n                e.dup2();\n                e.arraylength();\n                e.swap();\n                e.arraylength();\n                e.if_icmp(CodeEmitter.EQ, checkContents);\n                e.pop2();\n                e.goTo(notEquals);\n                e.mark(checkContents);\n                EmitUtils.process_arrays(e, type, callback);\n            } else {\n                List<Customizer> customizers = registry.get(Customizer.class);\n                if (!customizers.isEmpty()) {\n                    for (Customizer customizer : customizers) {\n                        customizer.customize(e, type);\n                    }\n                    e.swap();\n                    for (Customizer customizer : customizers) {\n                        customizer.customize(e, type);\n                    }\n                }\n                e.invoke_virtual(Constants.TYPE_OBJECT, EQUALS);\n                e.if_jump(CodeEmitter.EQ, notEquals);\n            }\n            e.mark(end);\n        }\n    }\n\n    /**\n     * If both objects on the top of the stack are non-null, does nothing.\n     * If one is null, or both are null, both are popped off and execution\n     * branches to the respective label.\n     * @param oneNull label to branch to if only one of the objects is null\n     * @param bothNull label to branch to if both of the objects are null\n     */\n    private static void nullcmp(CodeEmitter e, Label oneNull, Label bothNull) {\n        e.dup2();\n        Label nonNull = e.make_label();\n        Label oneNullHelper = e.make_label();\n        Label end = e.make_label();\n        e.ifnonnull(nonNull);\n        e.ifnonnull(oneNullHelper);\n        e.pop2();\n        e.goTo(bothNull);\n\n        e.mark(nonNull);\n        e.ifnull(oneNullHelper);\n        e.goTo(end);\n\n        e.mark(oneNullHelper);\n        e.pop2();\n        e.goTo(oneNull);\n\n        e.mark(end);\n    }\n\n    /*\n    public static void to_string(CodeEmitter e,\n                                 Type type,\n                                 ArrayDelimiters delims,\n                                 CustomizerRegistry registry) {\n        e.new_instance(Constants.TYPE_STRING_BUFFER);\n        e.dup();\n        e.invoke_constructor(Constants.TYPE_STRING_BUFFER);\n        e.swap();\n        append_string(e, type, delims, registry);\n        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, TO_STRING);\n    }\n    */\n\n    /**\n      * @deprecated use {@link #append_string(CodeEmitter, Type, ArrayDelimiters, CustomizerRegistry)} instead\n      */\n    @Deprecated\n    public static void append_string(final CodeEmitter e,\n                                     Type type,\n                                     final ArrayDelimiters delims,\n                                     final Customizer customizer) {\n        append_string(e, type, delims, CustomizerRegistry.singleton(customizer));\n    }\n\n    public static void append_string(final CodeEmitter e,\n                                     Type type,\n                                     final ArrayDelimiters delims,\n                                     final CustomizerRegistry registry) {\n        final ArrayDelimiters d = (delims != null) ? delims : DEFAULT_DELIMITERS;\n        ProcessArrayCallback callback = new ProcessArrayCallback() {\n            @Override\n            public void processElement(Type type) {\n                append_string_helper(e, type, d, registry, this);\n                e.push(d.inside);\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n            }\n        };\n        append_string_helper(e, type, d, registry, callback);\n    }\n\n    private static void append_string_helper(CodeEmitter e,\n                                             Type type,\n                                             ArrayDelimiters delims,\n                                             CustomizerRegistry registry,\n                                             ProcessArrayCallback callback) {\n        Label skip = e.make_label();\n        Label end = e.make_label();\n        if (TypeUtils.isPrimitive(type)) {\n            switch (type.getSort()) {\n            case Type.INT:\n            case Type.SHORT:\n            case Type.BYTE:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_INT);\n                break;\n            case Type.DOUBLE:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_DOUBLE);\n                break;\n            case Type.FLOAT:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_FLOAT);\n                break;\n            case Type.LONG:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_LONG);\n                break;\n            case Type.BOOLEAN:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_BOOLEAN);\n                break;\n            case Type.CHAR:\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_CHAR);\n                break;\n            }\n        } else if (TypeUtils.isArray(type)) {\n            e.dup();\n            e.ifnull(skip);\n            e.swap();\n            if (delims != null && delims.before != null && !delims.before.isEmpty()) {\n                e.push(delims.before);\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n                e.swap();\n            }\n            EmitUtils.process_array(e, type, callback);\n            shrinkStringBuffer(e, 2);\n            if (delims != null && delims.after != null && !delims.after.isEmpty()) {\n                e.push(delims.after);\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n            }\n        } else {\n            e.dup();\n            e.ifnull(skip);\n            for (Customizer customizer : registry.get(Customizer.class)) {\n                customizer.customize(e, type);\n            }\n            e.invoke_virtual(Constants.TYPE_OBJECT, TO_STRING);\n            e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n        }\n        e.goTo(end);\n        e.mark(skip);\n        e.pop();\n        e.push(\"null\");\n        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n        e.mark(end);\n    }\n\n    private static void shrinkStringBuffer(CodeEmitter e, int amt) {\n        e.dup();\n        e.dup();\n        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, LENGTH);\n        e.push(amt);\n        e.math(CodeEmitter.SUB, Type.INT_TYPE);\n        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, SET_LENGTH);\n    }\n\n    public static class ArrayDelimiters {\n        private String before;\n        private String inside;\n        private String after;\n\n        public ArrayDelimiters(String before, String inside, String after) {\n            this.before = before;\n            this.inside = inside;\n            this.after = after;\n        }\n    }\n\n    public static void load_method(CodeEmitter e, MethodInfo method) {\n        load_class(e, method.getClassInfo().getType());\n        e.push(method.getSignature().getName());\n        push_object(e, method.getSignature().getArgumentTypes());\n        e.invoke_virtual(Constants.TYPE_CLASS, GET_DECLARED_METHOD);\n    }\n\n    private interface ParameterTyper {\n        Type[] getParameterTypes(MethodInfo member);\n    }\n\n    public static void method_switch(CodeEmitter e,\n                                     List methods,\n                                     ObjectSwitchCallback callback) {\n        member_switch_helper(e, methods, callback, true);\n    }\n\n    public static void constructor_switch(CodeEmitter e,\n                                          List constructors,\n                                          ObjectSwitchCallback callback) {\n        member_switch_helper(e, constructors, callback, false);\n    }\n\n    private static void member_switch_helper(final CodeEmitter e,\n                                             List members,\n                                             final ObjectSwitchCallback callback,\n                                             boolean useName) {\n        try {\n            final Map cache = new HashMap();\n            final ParameterTyper cached = member -> {\n                Type[] types = (Type[]) cache.get(member);\n                if (types == null) {\n                    cache.put(member, types = member.getSignature().getArgumentTypes());\n                }\n                return types;\n            };\n            final Label def = e.make_label();\n            final Label end = e.make_label();\n            if (useName) {\n                e.swap();\n                final Map buckets = CollectionUtils.bucket(members, value -> ((MethodInfo)value).getSignature().getName());\n                String[] names = (String[])buckets.keySet().toArray(new String[buckets.size()]);\n                EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\n                        @Override\n                        public void processCase(Object key, Label dontUseEnd) throws Exception {\n                            member_helper_size(e, (List)buckets.get(key), callback, cached, def, end);\n                        }\n                        @Override\n                        public void processDefault() throws Exception {\n                            e.goTo(def);\n                        }\n                    });\n            } else {\n                member_helper_size(e, members, callback, cached, def, end);\n            }\n            e.mark(def);\n            e.pop();\n            callback.processDefault();\n            e.mark(end);\n        } catch (RuntimeException | Error ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new CodeGenerationException(ex);\n        }\n    }\n\n    private static void member_helper_size(final CodeEmitter e,\n                                           List members,\n                                           final ObjectSwitchCallback callback,\n                                           final ParameterTyper typer,\n                                           final Label def,\n                                           final Label end) throws Exception {\n        final Map buckets = CollectionUtils.bucket(members, value -> typer.getParameterTypes((MethodInfo)value).length);\n        e.dup();\n        e.arraylength();\n        e.process_switch(EmitUtils.getSwitchKeys(buckets), new ProcessSwitchCallback() {\n            @Override\n            public void processCase(int key, Label dontUseEnd) throws Exception {\n                List bucket = (List)buckets.get(key);\n                member_helper_type(e, bucket, callback, typer, def, end, new BitSet());\n            }\n            @Override\n            public void processDefault() throws Exception {\n                e.goTo(def);\n            }\n        });\n    }\n\n    private static void member_helper_type(final CodeEmitter e,\n                                           List members,\n                                           final ObjectSwitchCallback callback,\n                                           final ParameterTyper typer,\n                                           final Label def,\n                                           final Label end,\n                                           final BitSet checked) throws Exception {\n        if (members.size() == 1) {\n            MethodInfo member = (MethodInfo)members.get(0);\n            Type[] types = typer.getParameterTypes(member);\n            // need to check classes that have not already been checked via switches\n            for (int i = 0; i < types.length; i++) {\n                if (checked == null || !checked.get(i)) {\n                    e.dup();\n                    e.aaload(i);\n                    e.invoke_virtual(Constants.TYPE_CLASS, GET_NAME);\n                    e.push(TypeUtils.emulateClassGetName(types[i]));\n                    e.invoke_virtual(Constants.TYPE_OBJECT, EQUALS);\n                    e.if_jump(CodeEmitter.EQ, def);\n                }\n            }\n            e.pop();\n            callback.processCase(member, end);\n        } else {\n            // choose the index that has the best chance of uniquely identifying member\n            Type[] example = typer.getParameterTypes((MethodInfo)members.get(0));\n            Map buckets = null;\n            int index = -1;\n            for (int i = 0; i < example.length; i++) {\n                final int j = i;\n                Map test = CollectionUtils.bucket(members,\n                        value -> TypeUtils.emulateClassGetName(typer.getParameterTypes((MethodInfo)value)[j]));\n                if (buckets == null || test.size() > buckets.size()) {\n                    buckets = test;\n                    index = i;\n                }\n            }\n            if (buckets == null || buckets.size() == 1) {\n                // TODO: switch by returnType\n                // must have two methods with same name, types, and different return types\n                e.goTo(def);\n            } else {\n                checked.set(index);\n\n                e.dup();\n                e.aaload(index);\n                e.invoke_virtual(Constants.TYPE_CLASS, GET_NAME);\n\n                final Map fbuckets = buckets;\n                String[] names = (String[])buckets.keySet().toArray(new String[buckets.size()]);\n                EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\n                    @Override\n                    public void processCase(Object key, Label dontUseEnd) throws Exception {\n                        member_helper_type(e, (List)fbuckets.get(key), callback, typer, def, end, checked);\n                    }\n                    @Override\n                    public void processDefault() throws Exception {\n                        e.goTo(def);\n                    }\n                });\n            }\n        }\n    }\n\n    public static void wrap_throwable(Block block, Type wrapper) {\n        CodeEmitter e = block.getCodeEmitter();\n        e.catch_exception(block, Constants.TYPE_THROWABLE);\n        e.new_instance(wrapper);\n        e.dup_x1();\n        e.swap();\n        e.invoke_constructor(wrapper, CSTRUCT_THROWABLE);\n        e.athrow();\n    }\n\n    public static void add_properties(ClassEmitter ce, String[] names, Type[] types) {\n        for (int i = 0; i < names.length; i++) {\n            String fieldName = \"$cglib_prop_\" + names[i];\n            ce.declare_field(Constants.ACC_PRIVATE, fieldName, types[i], null);\n            EmitUtils.add_property(ce, names[i], types[i], fieldName);\n        }\n    }\n\n    public static void add_property(ClassEmitter ce, String name, Type type, String fieldName) {\n        String property = TypeUtils.upperFirst(name);\n        CodeEmitter e;\n        e = ce.begin_method(Constants.ACC_PUBLIC,\n                            new Signature(\"get\" + property,\n                                          type,\n                                          Constants.TYPES_EMPTY),\n                            null);\n        e.load_this();\n        e.getfield(fieldName);\n        e.return_value();\n        e.end_method();\n\n        e = ce.begin_method(Constants.ACC_PUBLIC,\n                            new Signature(\"set\" + property,\n                                          Type.VOID_TYPE,\n                                          new Type[]{ type }),\n                            null);\n        e.load_this();\n        e.load_arg(0);\n        e.putfield(fieldName);\n        e.return_value();\n        e.end_method();\n    }\n\n    /* generates:\n       } catch (RuntimeException e) {\n         throw e;\n       } catch (Error e) {\n         throw e;\n       } catch (<DeclaredException> e) {\n         throw e;\n       } catch (Throwable e) {\n         throw new <Wrapper>(e);\n       }\n    */\n    public static void wrap_undeclared_throwable(CodeEmitter e, Block handler, Type[] exceptions, Type wrapper) {\n        Set set = (exceptions == null) ? Collections.EMPTY_SET : new HashSet(Arrays.asList(exceptions));\n\n        if (set.contains(Constants.TYPE_THROWABLE)) {\n\t\t\treturn;\n\t\t}\n\n        boolean needThrow = exceptions != null;\n        if (!set.contains(Constants.TYPE_RUNTIME_EXCEPTION)) {\n            e.catch_exception(handler, Constants.TYPE_RUNTIME_EXCEPTION);\n            needThrow = true;\n        }\n        if (!set.contains(Constants.TYPE_ERROR)) {\n            e.catch_exception(handler, Constants.TYPE_ERROR);\n            needThrow = true;\n        }\n        if (exceptions != null) {\n            for (Type exception : exceptions) {\n                e.catch_exception(handler, exception);\n            }\n        }\n        if (needThrow) {\n            e.athrow();\n        }\n        // e -> eo -> oeo -> ooe -> o\n        e.catch_exception(handler, Constants.TYPE_THROWABLE);\n        e.new_instance(wrapper);\n        e.dup_x1();\n        e.swap();\n        e.invoke_constructor(wrapper, CSTRUCT_THROWABLE);\n        e.athrow();\n    }\n\n    public static CodeEmitter begin_method(ClassEmitter e, MethodInfo method) {\n        return begin_method(e, method, method.getModifiers());\n    }\n\n    public static CodeEmitter begin_method(ClassEmitter e, MethodInfo method, int access) {\n        return e.begin_method(access,\n                              method.getSignature(),\n                              method.getExceptionTypes());\n    }\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.cglib.core.EmitUtils",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.cglib.core.EmitUtils#CSTRUCT_NULL",
    "tailType": "field"
  }
]