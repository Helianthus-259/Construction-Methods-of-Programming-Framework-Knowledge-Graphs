[
  {
    "head": "org.springframework.core.annotation.AnnotationTypeMappings#clearCache()",
    "headType": "method",
    "relation": "provide",
    "tail": "static void clearCache() {\r\n    standardRepeatablesCache.clear();\r\n    noRepeatablesCache.clear();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationTypeMappings",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotationTypeMappings#clearCache()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.Cache",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.Cache",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.lang.Contract;\nimport org.springframework.util.ConcurrentReferenceHashMap;\n\n/**\n * Provides {@link AnnotationTypeMapping} information for a single source\n * annotation type. Performs a recursive breadth first crawl of all\n * meta-annotations to ultimately provide a quick way to map the attributes of\n * a root {@link Annotation}.\n *\n * <p>Supports convention based merging of meta-annotations as well as implicit\n * and explicit {@link AliasFor @AliasFor} aliases. Also provides information\n * about mirrored attributes.\n *\n * <p>This class is designed to be cached so that meta-annotations only need to\n * be searched once, regardless of how many times they are actually used.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n * @since 5.2\n * @see AnnotationTypeMapping\n */\nfinal class AnnotationTypeMappings {\n\n\tprivate static final IntrospectionFailureLogger failureLogger = IntrospectionFailureLogger.DEBUG;\n\n\tprivate static final Map<AnnotationFilter, Cache> standardRepeatablesCache = new ConcurrentReferenceHashMap<>();\n\n\tprivate static final Map<AnnotationFilter, Cache> noRepeatablesCache = new ConcurrentReferenceHashMap<>();\n\n\n\tprivate final RepeatableContainers repeatableContainers;\n\n\tprivate final AnnotationFilter filter;\n\n\tprivate final List<AnnotationTypeMapping> mappings;\n\n\n\tprivate AnnotationTypeMappings(RepeatableContainers repeatableContainers,\n\t\t\tAnnotationFilter filter, Class<? extends Annotation> annotationType,\n\t\t\tSet<Class<? extends Annotation>> visitedAnnotationTypes) {\n\n\t\tthis.repeatableContainers = repeatableContainers;\n\t\tthis.filter = filter;\n\t\tthis.mappings = new ArrayList<>();\n\t\taddAllMappings(annotationType, visitedAnnotationTypes);\n\t\tthis.mappings.forEach(AnnotationTypeMapping::afterAllMappingsSet);\n\t}\n\n\n\tprivate void addAllMappings(Class<? extends Annotation> annotationType,\n\t\t\tSet<Class<? extends Annotation>> visitedAnnotationTypes) {\n\t\tDeque<AnnotationTypeMapping> queue = new ArrayDeque<>();\n\t\taddIfPossible(queue, null, annotationType, null, visitedAnnotationTypes);\n\t\twhile (!queue.isEmpty()) {\n\t\t\tAnnotationTypeMapping mapping = queue.removeFirst();\n\t\t\tthis.mappings.add(mapping);\n\t\t\taddMetaAnnotationsToQueue(queue, mapping);\n\t\t}\n\t}\n\n\tprivate void addMetaAnnotationsToQueue(Deque<AnnotationTypeMapping> queue, AnnotationTypeMapping source) {\n\t\t@Nullable Annotation[] metaAnnotations = AnnotationsScanner.getDeclaredAnnotations(source.getAnnotationType(), false);\n\t\tfor (Annotation metaAnnotation : metaAnnotations) {\n\t\t\tif (!isMappable(source, metaAnnotation)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tAnnotation[] repeatedAnnotations = this.repeatableContainers.findRepeatedAnnotations(metaAnnotation);\n\t\t\tif (repeatedAnnotations != null) {\n\t\t\t\tfor (Annotation repeatedAnnotation : repeatedAnnotations) {\n\t\t\t\t\tif (!isMappable(source, repeatedAnnotation)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\taddIfPossible(queue, source, repeatedAnnotation);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddIfPossible(queue, source, metaAnnotation);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void addIfPossible(Deque<AnnotationTypeMapping> queue, AnnotationTypeMapping source, Annotation ann) {\n\t\taddIfPossible(queue, source, ann.annotationType(), ann, new HashSet<>());\n\t}\n\n\tprivate void addIfPossible(Deque<AnnotationTypeMapping> queue, @Nullable AnnotationTypeMapping source,\n\t\t\tClass<? extends Annotation> annotationType, @Nullable Annotation ann,\n\t\t\tSet<Class<? extends Annotation>> visitedAnnotationTypes) {\n\n\t\ttry {\n\t\t\tqueue.addLast(new AnnotationTypeMapping(source, annotationType, ann, visitedAnnotationTypes));\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tAnnotationUtils.rethrowAnnotationConfigurationException(ex);\n\t\t\tif (failureLogger.isEnabled()) {\n\t\t\t\tfailureLogger.log(\"Failed to introspect meta-annotation \" + annotationType.getName(),\n\t\t\t\t\t\t(source != null ? source.getAnnotationType() : null), ex);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Contract(\"_, null -> false\")\n\tprivate boolean isMappable(AnnotationTypeMapping source, @Nullable Annotation metaAnnotation) {\n\t\treturn (metaAnnotation != null && !this.filter.matches(metaAnnotation) &&\n\t\t\t\t!AnnotationFilter.PLAIN.matches(source.getAnnotationType()) &&\n\t\t\t\t!isAlreadyMapped(source, metaAnnotation));\n\t}\n\n\tprivate boolean isAlreadyMapped(AnnotationTypeMapping source, Annotation metaAnnotation) {\n\t\tClass<? extends Annotation> annotationType = metaAnnotation.annotationType();\n\t\tAnnotationTypeMapping mapping = source;\n\t\twhile (mapping != null) {\n\t\t\tif (mapping.getAnnotationType() == annotationType) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tmapping = mapping.getSource();\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Get the total number of contained mappings.\n\t * @return the total number of mappings\n\t */\n\tint size() {\n\t\treturn this.mappings.size();\n\t}\n\n\t/**\n\t * Get an individual mapping from this instance.\n\t * <p>Index {@code 0} will always return the root mapping; higher indexes\n\t * will return meta-annotation mappings.\n\t * @param index the index to return\n\t * @return the {@link AnnotationTypeMapping}\n\t * @throws IndexOutOfBoundsException if the index is out of range\n\t * ({@code index < 0 || index >= size()})\n\t */\n\tAnnotationTypeMapping get(int index) {\n\t\treturn this.mappings.get(index);\n\t}\n\n\n\t/**\n\t * Create {@link AnnotationTypeMappings} for the specified annotation type.\n\t * @param annotationType the source annotation type\n\t * @return type mappings for the annotation type\n\t */\n\tstatic AnnotationTypeMappings forAnnotationType(Class<? extends Annotation> annotationType) {\n\t\treturn forAnnotationType(annotationType, new HashSet<>());\n\t}\n\n\t/**\n\t * Create {@link AnnotationTypeMappings} for the specified annotation type.\n\t * @param annotationType the source annotation type\n\t * @param visitedAnnotationTypes the set of annotations that we have already\n\t * visited; used to avoid infinite recursion for recursive annotations which\n\t * some JVM languages support (such as Kotlin)\n\t * @return type mappings for the annotation type\n\t */\n\tstatic AnnotationTypeMappings forAnnotationType(Class<? extends Annotation> annotationType,\n\t\t\tSet<Class<? extends Annotation>> visitedAnnotationTypes) {\n\n\t\treturn forAnnotationType(annotationType, RepeatableContainers.standardRepeatables(),\n\t\t\t\tAnnotationFilter.PLAIN, visitedAnnotationTypes);\n\t}\n\n\t/**\n\t * Create {@link AnnotationTypeMappings} for the specified annotation type.\n\t * @param annotationType the source annotation type\n\t * @param repeatableContainers the repeatable containers that may be used by\n\t * the meta-annotations\n\t * @param annotationFilter the annotation filter used to limit which\n\t * annotations are considered\n\t * @return type mappings for the annotation type\n\t */\n\tstatic AnnotationTypeMappings forAnnotationType(Class<? extends Annotation> annotationType,\n\t\t\tRepeatableContainers repeatableContainers, AnnotationFilter annotationFilter) {\n\n\t\treturn forAnnotationType(annotationType, repeatableContainers, annotationFilter, new HashSet<>());\n\t}\n\n\t/**\n\t * Create {@link AnnotationTypeMappings} for the specified annotation type.\n\t * @param annotationType the source annotation type\n\t * @param repeatableContainers the repeatable containers that may be used by\n\t * the meta-annotations\n\t * @param annotationFilter the annotation filter used to limit which\n\t * annotations are considered\n\t * @param visitedAnnotationTypes the set of annotations that we have already\n\t * visited; used to avoid infinite recursion for recursive annotations which\n\t * some JVM languages support (such as Kotlin)\n\t * @return type mappings for the annotation type\n\t */\n\tstatic AnnotationTypeMappings forAnnotationType(Class<? extends Annotation> annotationType,\n\t\t\tRepeatableContainers repeatableContainers, AnnotationFilter annotationFilter,\n\t\t\tSet<Class<? extends Annotation>> visitedAnnotationTypes) {\n\n\t\tif (repeatableContainers == RepeatableContainers.standardRepeatables()) {\n\t\t\treturn standardRepeatablesCache.computeIfAbsent(annotationFilter,\n\t\t\t\t\tkey -> new Cache(repeatableContainers, key)).get(annotationType, visitedAnnotationTypes);\n\t\t}\n\t\tif (repeatableContainers == RepeatableContainers.none()) {\n\t\t\treturn noRepeatablesCache.computeIfAbsent(annotationFilter,\n\t\t\t\t\tkey -> new Cache(repeatableContainers, key)).get(annotationType, visitedAnnotationTypes);\n\t\t}\n\t\treturn new AnnotationTypeMappings(repeatableContainers, annotationFilter, annotationType,\n\t\t\t\tvisitedAnnotationTypes);\n\t}\n\n\tstatic void clearCache() {\n\t\tstandardRepeatablesCache.clear();\n\t\tnoRepeatablesCache.clear();\n\t}\n\n\n\t/**\n\t * Cache created per {@link AnnotationFilter}.\n\t */\n\tprivate static class Cache {\n\n\t\tprivate final RepeatableContainers repeatableContainers;\n\n\t\tprivate final AnnotationFilter filter;\n\n\t\tprivate final Map<Class<? extends Annotation>, AnnotationTypeMappings> mappings;\n\n\t\t/**\n\t\t * Create a cache instance with the specified filter.\n\t\t * @param filter the annotation filter\n\t\t */\n\t\tCache(RepeatableContainers repeatableContainers, AnnotationFilter filter) {\n\t\t\tthis.repeatableContainers = repeatableContainers;\n\t\t\tthis.filter = filter;\n\t\t\tthis.mappings = new ConcurrentReferenceHashMap<>();\n\t\t}\n\n\t\t/**\n\t\t * Get or create {@link AnnotationTypeMappings} for the specified annotation type.\n\t\t * @param annotationType the annotation type\n\t\t * @param visitedAnnotationTypes the set of annotations that we have already\n\t\t * visited; used to avoid infinite recursion for recursive annotations which\n\t\t * some JVM languages support (such as Kotlin)\n\t\t * @return a new or existing {@link AnnotationTypeMappings} instance\n\t\t */\n\t\tAnnotationTypeMappings get(Class<? extends Annotation> annotationType,\n\t\t\t\tSet<Class<? extends Annotation>> visitedAnnotationTypes) {\n\t\t\treturn this.mappings.computeIfAbsent(annotationType, key -> createMappings(key, visitedAnnotationTypes));\n\t\t}\n\n\t\tprivate AnnotationTypeMappings createMappings(Class<? extends Annotation> annotationType,\n\t\t\t\tSet<Class<? extends Annotation>> visitedAnnotationTypes) {\n\t\t\treturn new AnnotationTypeMappings(this.repeatableContainers, this.filter, annotationType,\n\t\t\t\t\tvisitedAnnotationTypes);\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation.Cache",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.Cache#repeatableContainers",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.Cache#repeatableContainers",
    "headType": "field",
    "relation": "haveType",
    "tail": "RepeatableContainers",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.Cache",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.Cache#filter",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.Cache#filter",
    "headType": "field",
    "relation": "haveType",
    "tail": "AnnotationFilter",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.Cache",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.Cache#mappings",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.Cache#mappings",
    "headType": "field",
    "relation": "haveType",
    "tail": "Map<Class<? extends Annotation>, AnnotationTypeMappings>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.Cache#get(Class<? extends Annotation>,Set<Class<? extends Annotation>>)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Get or create {@link AnnotationTypeMappings} for the specified annotation type.\r\n * @param annotationType the annotation type\r\n * @param visitedAnnotationTypes the set of annotations that we have already\r\n * visited; used to avoid infinite recursion for recursive annotations which\r\n * some JVM languages support (such as Kotlin)\r\n * @return a new or existing {@link AnnotationTypeMappings} instance\r\n */\r\nAnnotationTypeMappings get(Class<? extends Annotation> annotationType, Set<Class<? extends Annotation>> visitedAnnotationTypes) {\r\n    return this.mappings.computeIfAbsent(annotationType, key -> createMappings(key, visitedAnnotationTypes));\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.Cache",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.Cache#get(Class<? extends Annotation>,Set<Class<? extends Annotation>>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.Cache#createMappings(Class<? extends Annotation>,Set<Class<? extends Annotation>>)",
    "headType": "method",
    "relation": "provide",
    "tail": "private AnnotationTypeMappings createMappings(Class<? extends Annotation> annotationType, Set<Class<? extends Annotation>> visitedAnnotationTypes) {\r\n    return new AnnotationTypeMappings(this.repeatableContainers, this.filter, annotationType, visitedAnnotationTypes);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.Cache",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.Cache#createMappings(Class<? extends Annotation>,Set<Class<? extends Annotation>>)",
    "tailType": "method"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.annotation",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.AnnotationUtils",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Proxy;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.core.BridgeMethodResolver;\nimport org.springframework.core.annotation.AnnotationTypeMapping.MirrorSets.MirrorSet;\nimport org.springframework.core.annotation.MergedAnnotation.Adapt;\nimport org.springframework.core.annotation.MergedAnnotations.SearchStrategy;\nimport org.springframework.util.CollectionUtils;\nimport org.springframework.util.ConcurrentReferenceHashMap;\nimport org.springframework.util.ReflectionUtils;\nimport org.springframework.util.StringUtils;\n\n/**\n * General utility methods for working with annotations, handling meta-annotations,\n * bridge methods (which the compiler generates for generic declarations) as well\n * as super methods (for optional <em>annotation inheritance</em>).\n *\n * <p>Note that most of the features of this class are not provided by the\n * JDK's introspection facilities themselves.\n *\n * <p>As a general rule for runtime-retained application annotations (for example, for\n * transaction control, authorization, or service exposure), always use the\n * lookup methods on this class (for example, {@link #findAnnotation(Method, Class)} or\n * {@link #getAnnotation(Method, Class)}) instead of the plain annotation lookup\n * methods in the JDK. You can still explicitly choose between a <em>get</em>\n * lookup on the given class level only ({@link #getAnnotation(Method, Class)})\n * and a <em>find</em> lookup in the entire inheritance hierarchy of the given\n * method ({@link #findAnnotation(Method, Class)}).\n *\n * <h3>Terminology</h3>\n * The terms <em>directly present</em>, <em>indirectly present</em>, and\n * <em>present</em> have the same meanings as defined in the class-level\n * javadoc for {@link AnnotatedElement} (in Java 8).\n *\n * <p>An annotation is <em>meta-present</em> on an element if the annotation\n * is declared as a meta-annotation on some other annotation which is\n * <em>present</em> on the element. Annotation {@code A} is <em>meta-present</em>\n * on another annotation if {@code A} is either <em>directly present</em> or\n * <em>meta-present</em> on the other annotation.\n *\n * <h3>Meta-annotation Support</h3>\n * <p>Most {@code find*()} methods and some {@code get*()} methods in this class\n * provide support for finding annotations used as meta-annotations. Consult the\n * javadoc for each method in this class for details. For fine-grained support for\n * meta-annotations with <em>attribute overrides</em> in <em>composed annotations</em>,\n * consider using {@link AnnotatedElementUtils}'s more specific methods instead.\n *\n * <h3>Attribute Aliases</h3>\n * <p>All public methods in this class that return annotations, arrays of\n * annotations, or {@link AnnotationAttributes} transparently support attribute\n * aliases configured via {@link AliasFor @AliasFor}. Consult the various\n * {@code synthesizeAnnotation*(..)} methods for details.\n *\n * <h3>Search Scope</h3>\n * <p>The search algorithms used by methods in this class stop searching for\n * an annotation once the first annotation of the specified type has been\n * found. As a consequence, additional annotations of the specified type will\n * be silently ignored.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Mark Fisher\n * @author Chris Beams\n * @author Phillip Webb\n * @author Oleg Zhurakousky\n * @since 2.0\n * @see AliasFor\n * @see AnnotationAttributes\n * @see AnnotatedElementUtils\n * @see BridgeMethodResolver\n * @see java.lang.reflect.AnnotatedElement#getAnnotations()\n * @see java.lang.reflect.AnnotatedElement#getAnnotation(Class)\n * @see java.lang.reflect.AnnotatedElement#getDeclaredAnnotations()\n */\npublic abstract class AnnotationUtils {\n\n\t/**\n\t * The attribute name for annotations with a single element.\n\t */\n\tpublic static final String VALUE = MergedAnnotation.VALUE;\n\n\tprivate static final AnnotationFilter JAVA_LANG_ANNOTATION_FILTER =\n\t\t\tAnnotationFilter.packages(\"java.lang.annotation\");\n\n\tprivate static final Map<Class<? extends Annotation>, Map<String, DefaultValueHolder>> defaultValuesCache =\n\t\t\tnew ConcurrentReferenceHashMap<>();\n\n\n\t/**\n\t * Determine whether the given class is a candidate for carrying one of the specified\n\t * annotations (at type, method or field level).\n\t * @param clazz the class to introspect\n\t * @param annotationTypes the searchable annotation types\n\t * @return {@code false} if the class is known to have no such annotations at any level;\n\t * {@code true} otherwise. Callers will usually perform full method/field introspection\n\t * if {@code true} is being returned here.\n\t * @since 5.2\n\t * @see #isCandidateClass(Class, Class)\n\t * @see #isCandidateClass(Class, String)\n\t */\n\tpublic static boolean isCandidateClass(Class<?> clazz, Collection<Class<? extends Annotation>> annotationTypes) {\n\t\tfor (Class<? extends Annotation> annotationType : annotationTypes) {\n\t\t\tif (isCandidateClass(clazz, annotationType)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Determine whether the given class is a candidate for carrying the specified annotation\n\t * (at type, method or field level).\n\t * @param clazz the class to introspect\n\t * @param annotationType the searchable annotation type\n\t * @return {@code false} if the class is known to have no such annotations at any level;\n\t * {@code true} otherwise. Callers will usually perform full method/field introspection\n\t * if {@code true} is being returned here.\n\t * @since 5.2\n\t * @see #isCandidateClass(Class, String)\n\t */\n\tpublic static boolean isCandidateClass(Class<?> clazz, @Nullable Class<? extends Annotation> annotationType) {\n\t\treturn (annotationType != null && isCandidateClass(clazz, annotationType.getName()));\n\t}\n\n\t/**\n\t * Determine whether the given class is a candidate for carrying the specified annotation\n\t * (at type, method or field level).\n\t * @param clazz the class to introspect\n\t * @param annotationName the fully-qualified name of the searchable annotation type\n\t * @return {@code false} if the class is known to have no such annotations at any level;\n\t * {@code true} otherwise. Callers will usually perform full method/field introspection\n\t * if {@code true} is being returned here.\n\t * @since 5.2\n\t * @see #isCandidateClass(Class, Class)\n\t */\n\tpublic static boolean isCandidateClass(Class<?> clazz, String annotationName) {\n\t\tif (annotationName.startsWith(\"java.\")) {\n\t\t\treturn true;\n\t\t}\n\t\tif (AnnotationsScanner.hasPlainJavaAnnotationsOnly(clazz)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Get a single {@link Annotation} of {@code annotationType} from the supplied\n\t * annotation: either the given annotation itself or a direct meta-annotation\n\t * thereof.\n\t * <p>Note that this method supports only a single level of meta-annotations.\n\t * For support for arbitrary levels of meta-annotations, use one of the\n\t * {@code find*()} methods instead.\n\t * @param annotation the Annotation to check\n\t * @param annotationType the annotation type to look for, both locally and as a meta-annotation\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @since 4.0\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <A extends Annotation> @Nullable A getAnnotation(Annotation annotation, Class<A> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (annotationType.isInstance(annotation)) {\n\t\t\treturn synthesizeAnnotation((A) annotation, annotationType);\n\t\t}\n\t\t// Shortcut: no searchable annotations to be found on plain Java classes and core Spring types...\n\t\tif (AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotation)) {\n\t\t\treturn null;\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(annotation, new Annotation[] {annotation}, RepeatableContainers.none())\n\t\t\t\t.get(annotationType).withNonMergedAttributes()\n\t\t\t\t.synthesize(AnnotationUtils::isSingleLevelPresent).orElse(null);\n\t}\n\n\t/**\n\t * Get a single {@link Annotation} of {@code annotationType} from the supplied\n\t * {@link AnnotatedElement}, where the annotation is either <em>present</em> or\n\t * <em>meta-present</em> on the {@code AnnotatedElement}.\n\t * <p>Note that this method supports only a single level of meta-annotations.\n\t * For support for arbitrary levels of meta-annotations, use\n\t * {@link #findAnnotation(AnnotatedElement, Class)} instead.\n\t * @param annotatedElement the {@code AnnotatedElement} from which to get the annotation\n\t * @param annotationType the annotation type to look for, both locally and as a meta-annotation\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @since 3.1\n\t */\n\tpublic static <A extends Annotation> @Nullable A getAnnotation(AnnotatedElement annotatedElement, Class<A> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) {\n\t\t\treturn annotatedElement.getAnnotation(annotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(annotatedElement, SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none())\n\t\t\t\t.get(annotationType).withNonMergedAttributes()\n\t\t\t\t.synthesize(AnnotationUtils::isSingleLevelPresent).orElse(null);\n\t}\n\n\tprivate static <A extends Annotation> boolean isSingleLevelPresent(MergedAnnotation<A> mergedAnnotation) {\n\t\tint distance = mergedAnnotation.getDistance();\n\t\treturn (distance == 0 || distance == 1);\n\t}\n\n\t/**\n\t * Get a single {@link Annotation} of {@code annotationType} from the\n\t * supplied {@link Method}, where the annotation is either <em>present</em>\n\t * or <em>meta-present</em> on the method.\n\t * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.\n\t * <p>Note that this method supports only a single level of meta-annotations.\n\t * For support for arbitrary levels of meta-annotations, use\n\t * {@link #findAnnotation(Method, Class)} instead.\n\t * @param method the method to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod(Method)\n\t * @see #getAnnotation(AnnotatedElement, Class)\n\t */\n\tpublic static <A extends Annotation> @Nullable A getAnnotation(Method method, Class<A> annotationType) {\n\t\tMethod resolvedMethod = BridgeMethodResolver.findBridgedMethod(method);\n\t\treturn getAnnotation((AnnotatedElement) resolvedMethod, annotationType);\n\t}\n\n\t/**\n\t * Get all {@link Annotation Annotations} that are <em>present</em> on the\n\t * supplied {@link AnnotatedElement}.\n\t * <p>Meta-annotations will <em>not</em> be searched.\n\t * @param annotatedElement the Method, Constructor or Field to retrieve annotations from\n\t * @return the annotations found, an empty array, or {@code null} if not\n\t * resolvable (for example, because nested Class values in annotation attributes\n\t * failed to resolve at runtime)\n\t * @since 4.0.8\n\t * @see AnnotatedElement#getAnnotations()\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */\n\t@Deprecated\n\tpublic static Annotation @Nullable [] getAnnotations(AnnotatedElement annotatedElement) {\n\t\ttry {\n\t\t\treturn synthesizeAnnotationArray(annotatedElement.getAnnotations(), annotatedElement);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\thandleIntrospectionFailure(annotatedElement, ex);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Get all {@link Annotation Annotations} that are <em>present</em> on the\n\t * supplied {@link Method}.\n\t * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.\n\t * <p>Meta-annotations will <em>not</em> be searched.\n\t * @param method the Method to retrieve annotations from\n\t * @return the annotations found, an empty array, or {@code null} if not\n\t * resolvable (for example, because nested Class values in annotation attributes\n\t * failed to resolve at runtime)\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod(Method)\n\t * @see AnnotatedElement#getAnnotations()\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */\n\t@Deprecated\n\tpublic static Annotation @Nullable [] getAnnotations(Method method) {\n\t\ttry {\n\t\t\treturn synthesizeAnnotationArray(BridgeMethodResolver.findBridgedMethod(method).getAnnotations(), method);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\thandleIntrospectionFailure(method, ex);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Get the <em>repeatable</em> {@linkplain Annotation annotations} of\n\t * {@code annotationType} from the supplied {@link AnnotatedElement}, where\n\t * such annotations are either <em>present</em>, <em>indirectly present</em>,\n\t * or <em>meta-present</em> on the element.\n\t * <p>This method mimics the functionality of Java 8's\n\t * {@link java.lang.reflect.AnnotatedElement#getAnnotationsByType(Class)}\n\t * with support for automatic detection of a <em>container annotation</em>\n\t * declared via @{@link java.lang.annotation.Repeatable} (when running on\n\t * Java 8 or higher) and with additional support for meta-annotations.\n\t * <p>Handles both single annotations and annotations nested within a\n\t * <em>container annotation</em>.\n\t * <p>Correctly handles <em>bridge methods</em> generated by the\n\t * compiler if the supplied element is a {@link Method}.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>present</em> on the supplied element.\n\t * @param annotatedElement the element to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @return the annotations found or an empty set (never {@code null})\n\t * @since 4.2\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\n\t * @see java.lang.annotation.Repeatable\n\t * @see java.lang.reflect.AnnotatedElement#getAnnotationsByType\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */\n\t@Deprecated\n\tpublic static <A extends Annotation> Set<A> getRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType) {\n\n\t\treturn getRepeatableAnnotations(annotatedElement, annotationType, null);\n\t}\n\n\t/**\n\t * Get the <em>repeatable</em> {@linkplain Annotation annotations} of\n\t * {@code annotationType} from the supplied {@link AnnotatedElement}, where\n\t * such annotations are either <em>present</em>, <em>indirectly present</em>,\n\t * or <em>meta-present</em> on the element.\n\t * <p>This method mimics the functionality of Java 8's\n\t * {@link java.lang.reflect.AnnotatedElement#getAnnotationsByType(Class)}\n\t * with additional support for meta-annotations.\n\t * <p>Handles both single annotations and annotations nested within a\n\t * <em>container annotation</em>.\n\t * <p>Correctly handles <em>bridge methods</em> generated by the\n\t * compiler if the supplied element is a {@link Method}.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>present</em> on the supplied element.\n\t * @param annotatedElement the element to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @param containerAnnotationType the type of the container that holds\n\t * the annotations; may be {@code null} if a container is not supported\n\t * or if it should be looked up via @{@link java.lang.annotation.Repeatable}\n\t * when running on Java 8 or higher\n\t * @return the annotations found or an empty set (never {@code null})\n\t * @since 4.2\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\n\t * @see java.lang.annotation.Repeatable\n\t * @see java.lang.reflect.AnnotatedElement#getAnnotationsByType\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */\n\t@Deprecated\n\tpublic static <A extends Annotation> Set<A> getRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType, @Nullable Class<? extends Annotation> containerAnnotationType) {\n\n\t\tRepeatableContainers repeatableContainers = (containerAnnotationType != null ?\n\t\t\t\tRepeatableContainers.of(annotationType, containerAnnotationType) :\n\t\t\t\tRepeatableContainers.standardRepeatables());\n\n\t\treturn MergedAnnotations.from(annotatedElement, SearchStrategy.SUPERCLASS, repeatableContainers)\n\t\t\t\t.stream(annotationType)\n\t\t\t\t.filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex))\n\t\t\t\t.map(MergedAnnotation::withNonMergedAttributes)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}\n\n\t/**\n\t * Get the declared <em>repeatable</em> {@linkplain Annotation annotations}\n\t * of {@code annotationType} from the supplied {@link AnnotatedElement},\n\t * where such annotations are either <em>directly present</em>,\n\t * <em>indirectly present</em>, or <em>meta-present</em> on the element.\n\t * <p>This method mimics the functionality of Java 8's\n\t * {@link java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType(Class)}\n\t * with support for automatic detection of a <em>container annotation</em>\n\t * declared via @{@link java.lang.annotation.Repeatable} (when running on\n\t * Java 8 or higher) and with additional support for meta-annotations.\n\t * <p>Handles both single annotations and annotations nested within a\n\t * <em>container annotation</em>.\n\t * <p>Correctly handles <em>bridge methods</em> generated by the\n\t * compiler if the supplied element is a {@link Method}.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>present</em> on the supplied element.\n\t * @param annotatedElement the element to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @return the annotations found or an empty set (never {@code null})\n\t * @since 4.2\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\n\t * @see java.lang.annotation.Repeatable\n\t * @see java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */\n\t@Deprecated\n\tpublic static <A extends Annotation> Set<A> getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType) {\n\n\t\treturn getDeclaredRepeatableAnnotations(annotatedElement, annotationType, null);\n\t}\n\n\t/**\n\t * Get the declared <em>repeatable</em> {@linkplain Annotation annotations}\n\t * of {@code annotationType} from the supplied {@link AnnotatedElement},\n\t * where such annotations are either <em>directly present</em>,\n\t * <em>indirectly present</em>, or <em>meta-present</em> on the element.\n\t * <p>This method mimics the functionality of Java 8's\n\t * {@link java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType(Class)}\n\t * with additional support for meta-annotations.\n\t * <p>Handles both single annotations and annotations nested within a\n\t * <em>container annotation</em>.\n\t * <p>Correctly handles <em>bridge methods</em> generated by the\n\t * compiler if the supplied element is a {@link Method}.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>present</em> on the supplied element.\n\t * @param annotatedElement the element to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @param containerAnnotationType the type of the container that holds\n\t * the annotations; may be {@code null} if a container is not supported\n\t * or if it should be looked up via @{@link java.lang.annotation.Repeatable}\n\t * when running on Java 8 or higher\n\t * @return the annotations found or an empty set (never {@code null})\n\t * @since 4.2\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\n\t * @see java.lang.annotation.Repeatable\n\t * @see java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */\n\t@Deprecated\n\tpublic static <A extends Annotation> Set<A> getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement,\n\t\t\tClass<A> annotationType, @Nullable Class<? extends Annotation> containerAnnotationType) {\n\n\t\tRepeatableContainers repeatableContainers = containerAnnotationType != null ?\n\t\t\t\tRepeatableContainers.of(annotationType, containerAnnotationType) :\n\t\t\t\tRepeatableContainers.standardRepeatables();\n\n\t\treturn MergedAnnotations.from(annotatedElement, SearchStrategy.DIRECT, repeatableContainers)\n\t\t\t\t.stream(annotationType)\n\t\t\t\t.map(MergedAnnotation::withNonMergedAttributes)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}\n\n\t/**\n\t * Find a single {@link Annotation} of {@code annotationType} on the\n\t * supplied {@link AnnotatedElement}.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>directly present</em> on the supplied element.\n\t * <p><strong>Warning</strong>: this method operates generically on\n\t * annotated elements. In other words, this method does not execute\n\t * specialized search algorithms for classes or methods. If you require\n\t * the more specific semantics of {@link #findAnnotation(Class, Class)}\n\t * or {@link #findAnnotation(Method, Class)}, invoke one of those methods\n\t * instead.\n\t * @param annotatedElement the {@code AnnotatedElement} on which to find the annotation\n\t * @param annotationType the annotation type to look for, both locally and as a meta-annotation\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @since 4.2\n\t */\n\tpublic static <A extends Annotation> @Nullable A findAnnotation(\n\t\t\tAnnotatedElement annotatedElement, @Nullable Class<A> annotationType) {\n\n\t\tif (annotationType == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) {\n\t\t\treturn annotatedElement.getDeclaredAnnotation(annotationType);\n\t\t}\n\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(annotatedElement, SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none())\n\t\t\t\t.get(annotationType).withNonMergedAttributes()\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}\n\n\t/**\n\t * Find a single {@link Annotation} of {@code annotationType} on the supplied\n\t * {@link Method}, traversing its super methods (i.e. from superclasses and\n\t * interfaces) if the annotation is not <em>directly present</em> on the given\n\t * method itself.\n\t * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>directly present</em> on the method.\n\t * <p>Annotations on methods are not inherited by default, so we need to handle\n\t * this explicitly.\n\t * @param method the method to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @see #getAnnotation(Method, Class)\n\t */\n\tpublic static <A extends Annotation> @Nullable A findAnnotation(Method method, @Nullable Class<A> annotationType) {\n\t\tif (annotationType == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(method)) {\n\t\t\treturn method.getDeclaredAnnotation(annotationType);\n\t\t}\n\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none())\n\t\t\t\t.get(annotationType).withNonMergedAttributes()\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}\n\n\t/**\n\t * Find a single {@link Annotation} of {@code annotationType} on the\n\t * supplied {@link Class}, traversing its interfaces, annotations, and\n\t * superclasses if the annotation is not <em>directly present</em> on\n\t * the given class itself.\n\t * <p>This method explicitly handles class-level annotations which are not\n\t * declared as {@link java.lang.annotation.Inherited inherited} <em>as well\n\t * as meta-annotations and annotations on interfaces</em>.\n\t * <p>The algorithm operates as follows:\n\t * <ol>\n\t * <li>Search for the annotation on the given class and return it if found.\n\t * <li>Recursively search through all annotations that the given class declares.\n\t * <li>Recursively search through all interfaces that the given class declares.\n\t * <li>Recursively search through the superclass hierarchy of the given class.\n\t * </ol>\n\t * <p>Note: in this context, the term <em>recursively</em> means that the search\n\t * process continues by returning to step #1 with the current interface,\n\t * annotation, or superclass as the class to look for annotations on.\n\t * @param clazz the class to look for annotations on\n\t * @param annotationType the type of annotation to look for\n\t * @return the first matching annotation, or {@code null} if not found\n\t */\n\tpublic static <A extends Annotation> @Nullable A findAnnotation(Class<?> clazz, @Nullable Class<A> annotationType) {\n\t\tif (annotationType == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(clazz)) {\n\t\t\tA annotation = clazz.getDeclaredAnnotation(annotationType);\n\t\t\tif (annotation != null) {\n\t\t\t\treturn annotation;\n\t\t\t}\n\t\t\t// For backwards compatibility, perform a superclass search with plain annotations\n\t\t\t// even if not marked as @Inherited: for example, a findAnnotation search for @Deprecated\n\t\t\tClass<?> superclass = clazz.getSuperclass();\n\t\t\tif (superclass == null || superclass == Object.class) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn findAnnotation(superclass, annotationType);\n\t\t}\n\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(clazz, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none())\n\t\t\t\t.get(annotationType).withNonMergedAttributes()\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}\n\n\t/**\n\t * Find the first {@link Class} in the inheritance hierarchy of the\n\t * specified {@code clazz} (including the specified {@code clazz} itself)\n\t * on which an annotation of the specified {@code annotationType} is\n\t * <em>directly present</em>.\n\t * <p>If the supplied {@code clazz} is an interface, only the interface\n\t * itself will be checked; the inheritance hierarchy for interfaces will\n\t * not be traversed.\n\t * <p>Meta-annotations will <em>not</em> be searched.\n\t * <p>The standard {@link Class} API does not provide a mechanism for\n\t * determining which class in an inheritance hierarchy actually declares\n\t * an {@link Annotation}, so we need to handle this explicitly.\n\t * @param annotationType the annotation type to look for\n\t * @param clazz the class to check for the annotation on (may be {@code null})\n\t * @return the first {@link Class} in the inheritance hierarchy that\n\t * declares an annotation of the specified {@code annotationType},\n\t * or {@code null} if not found\n\t * @see Class#isAnnotationPresent(Class)\n\t * @see Class#getDeclaredAnnotations()\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */\n\t@Deprecated\n\tpublic static @Nullable Class<?> findAnnotationDeclaringClass(\n\t\t\tClass<? extends Annotation> annotationType, @Nullable Class<?> clazz) {\n\n\t\tif (clazz == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn (Class<?>) MergedAnnotations.from(clazz, SearchStrategy.SUPERCLASS)\n\t\t\t\t.get(annotationType, MergedAnnotation::isDirectlyPresent)\n\t\t\t\t.getSource();\n\t}\n\n\t/**\n\t * Find the first {@link Class} in the inheritance hierarchy of the\n\t * specified {@code clazz} (including the specified {@code clazz} itself)\n\t * on which at least one of the specified {@code annotationTypes} is\n\t * <em>directly present</em>.\n\t * <p>If the supplied {@code clazz} is an interface, only the interface\n\t * itself will be checked; the inheritance hierarchy for interfaces will\n\t * not be traversed.\n\t * <p>Meta-annotations will <em>not</em> be searched.\n\t * <p>The standard {@link Class} API does not provide a mechanism for\n\t * determining which class in an inheritance hierarchy actually declares\n\t * one of several candidate {@linkplain Annotation annotations}, so we\n\t * need to handle this explicitly.\n\t * @param annotationTypes the annotation types to look for\n\t * @param clazz the class to check for the annotation on (may be {@code null})\n\t * @return the first {@link Class} in the inheritance hierarchy that\n\t * declares an annotation of at least one of the specified\n\t * {@code annotationTypes}, or {@code null} if not found\n\t * @since 3.2.2\n\t * @see Class#isAnnotationPresent(Class)\n\t * @see Class#getDeclaredAnnotations()\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */\n\t@Deprecated\n\tpublic static @Nullable Class<?> findAnnotationDeclaringClassForTypes(\n\t\t\tList<Class<? extends Annotation>> annotationTypes, @Nullable Class<?> clazz) {\n\n\t\tif (clazz == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tMergedAnnotation<?> merged = MergedAnnotations.from(clazz, SearchStrategy.SUPERCLASS).stream()\n\t\t\t\t.filter(MergedAnnotationPredicates.typeIn(annotationTypes).and(MergedAnnotation::isDirectlyPresent))\n\t\t\t\t.findFirst().orElse(null);\n\t\treturn (merged != null && merged.getSource() instanceof Class<?> sourceClass ? sourceClass : null);\n\t}\n\n\t/**\n\t * Determine whether an annotation of the specified {@code annotationType}\n\t * is declared locally (i.e. <em>directly present</em>) on the supplied\n\t * {@code clazz}.\n\t * <p>The supplied {@link Class} may represent any type.\n\t * <p>Meta-annotations will <em>not</em> be searched.\n\t * <p>Note: This method does <strong>not</strong> determine if the annotation\n\t * is {@linkplain java.lang.annotation.Inherited inherited}.\n\t * @param annotationType the annotation type to look for\n\t * @param clazz the class to check for the annotation on\n\t * @return {@code true} if an annotation of the specified {@code annotationType}\n\t * is <em>directly present</em>\n\t * @see java.lang.Class#getDeclaredAnnotations()\n\t * @see java.lang.Class#getDeclaredAnnotation(Class)\n\t */\n\tpublic static boolean isAnnotationDeclaredLocally(Class<? extends Annotation> annotationType, Class<?> clazz) {\n\t\treturn MergedAnnotations.from(clazz).get(annotationType).isDirectlyPresent();\n\t}\n\n\t/**\n\t * Determine whether an annotation of the specified {@code annotationType}\n\t * is <em>present</em> on the supplied {@code clazz} and is\n\t * {@linkplain java.lang.annotation.Inherited inherited}\n\t * (i.e. not <em>directly present</em>).\n\t * <p>Meta-annotations will <em>not</em> be searched.\n\t * <p>If the supplied {@code clazz} is an interface, only the interface\n\t * itself will be checked. In accordance with standard meta-annotation\n\t * semantics in Java, the inheritance hierarchy for interfaces will not\n\t * be traversed. See the {@linkplain java.lang.annotation.Inherited javadoc}\n\t * for the {@code @Inherited} meta-annotation for further details regarding\n\t * annotation inheritance.\n\t * @param annotationType the annotation type to look for\n\t * @param clazz the class to check for the annotation on\n\t * @return {@code true} if an annotation of the specified {@code annotationType}\n\t * is <em>present</em> and <em>inherited</em>\n\t * @see Class#isAnnotationPresent(Class)\n\t * @see #isAnnotationDeclaredLocally(Class, Class)\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */\n\t@Deprecated\n\tpublic static boolean isAnnotationInherited(Class<? extends Annotation> annotationType, Class<?> clazz) {\n\t\treturn MergedAnnotations.from(clazz, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(annotationType)\n\t\t\t\t.filter(MergedAnnotation::isDirectlyPresent)\n\t\t\t\t.findFirst().orElseGet(MergedAnnotation::missing)\n\t\t\t\t.getAggregateIndex() > 0;\n\t}\n\n\t/**\n\t * Determine if an annotation of type {@code metaAnnotationType} is\n\t * <em>meta-present</em> on the supplied {@code annotationType}.\n\t * @param annotationType the annotation type to search on\n\t * @param metaAnnotationType the type of meta-annotation to search for\n\t * @return {@code true} if such an annotation is meta-present\n\t * @since 4.2.1\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t */\n\t@Deprecated\n\tpublic static boolean isAnnotationMetaPresent(Class<? extends Annotation> annotationType,\n\t\t\t@Nullable Class<? extends Annotation> metaAnnotationType) {\n\n\t\tif (metaAnnotationType == null) {\n\t\t\treturn false;\n\t\t}\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(metaAnnotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(annotationType)) {\n\t\t\treturn annotationType.isAnnotationPresent(metaAnnotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn MergedAnnotations.from(annotationType, SearchStrategy.INHERITED_ANNOTATIONS,\n\t\t\t\tRepeatableContainers.none()).isPresent(metaAnnotationType);\n\t}\n\n\t/**\n\t * Determine if the supplied {@link Annotation} is defined in the core JDK\n\t * {@code java.lang.annotation} package.\n\t * @param annotation the annotation to check\n\t * @return {@code true} if the annotation is in the {@code java.lang.annotation} package\n\t */\n\tpublic static boolean isInJavaLangAnnotationPackage(@Nullable Annotation annotation) {\n\t\treturn (annotation != null && JAVA_LANG_ANNOTATION_FILTER.matches(annotation));\n\t}\n\n\t/**\n\t * Determine if the {@link Annotation} with the supplied name is defined\n\t * in the core JDK {@code java.lang.annotation} package.\n\t * @param annotationType the name of the annotation type to check\n\t * @return {@code true} if the annotation is in the {@code java.lang.annotation} package\n\t * @since 4.2\n\t */\n\tpublic static boolean isInJavaLangAnnotationPackage(@Nullable String annotationType) {\n\t\treturn (annotationType != null && JAVA_LANG_ANNOTATION_FILTER.matches(annotationType));\n\t}\n\n\t/**\n\t * Check the declared attributes of the given annotation, in particular covering\n\t * Google App Engine's late arrival of {@code TypeNotPresentExceptionProxy} for\n\t * {@code Class} values (instead of early {@code Class.getAnnotations() failure}).\n\t * <p>This method not failing indicates that {@link #getAnnotationAttributes(Annotation)}\n\t * won't fail either (when attempted later on).\n\t * @param annotation the annotation to validate\n\t * @throws IllegalStateException if a declared {@code Class} attribute could not be read\n\t * @since 4.3.15\n\t * @see Class#getAnnotations()\n\t * @see #getAnnotationAttributes(Annotation)\n\t */\n\tpublic static void validateAnnotation(Annotation annotation) {\n\t\tAttributeMethods.forAnnotationType(annotation.annotationType()).validate(annotation);\n\t}\n\n\t/**\n\t * Retrieve the given annotation's attributes as a {@link Map}, preserving all\n\t * attribute types.\n\t * <p>Equivalent to calling {@link #getAnnotationAttributes(Annotation, boolean, boolean)}\n\t * with the {@code classValuesAsString} and {@code nestedAnnotationsAsMap} parameters\n\t * set to {@code false}.\n\t * <p>Note: This method actually returns an {@link AnnotationAttributes} instance.\n\t * However, the {@code Map} signature has been preserved for binary compatibility.\n\t * @param annotation the annotation to retrieve the attributes for\n\t * @return the Map of annotation attributes, with attribute names as keys and\n\t * corresponding attribute values as values (never {@code null})\n\t * @see #getAnnotationAttributes(AnnotatedElement, Annotation)\n\t * @see #getAnnotationAttributes(Annotation, boolean, boolean)\n\t * @see #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)\n\t */\n\tpublic static Map<String, @Nullable Object> getAnnotationAttributes(Annotation annotation) {\n\t\treturn getAnnotationAttributes(null, annotation);\n\t}\n\n\t/**\n\t * Retrieve the given annotation's attributes as a {@link Map}.\n\t * <p>Equivalent to calling {@link #getAnnotationAttributes(Annotation, boolean, boolean)}\n\t * with the {@code nestedAnnotationsAsMap} parameter set to {@code false}.\n\t * <p>Note: This method actually returns an {@link AnnotationAttributes} instance.\n\t * However, the {@code Map} signature has been preserved for binary compatibility.\n\t * @param annotation the annotation to retrieve the attributes for\n\t * @param classValuesAsString whether to convert Class references into Strings (for\n\t * compatibility with {@link org.springframework.core.type.AnnotationMetadata})\n\t * or to preserve them as Class references\n\t * @return the Map of annotation attributes, with attribute names as keys and\n\t * corresponding attribute values as values (never {@code null})\n\t * @see #getAnnotationAttributes(Annotation, boolean, boolean)\n\t */\n\tpublic static Map<String, @Nullable Object> getAnnotationAttributes(\n\t\t\tAnnotation annotation, boolean classValuesAsString) {\n\n\t\treturn getAnnotationAttributes(annotation, classValuesAsString, false);\n\t}\n\n\t/**\n\t * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.\n\t * <p>This method provides fully recursive annotation reading capabilities on par with\n\t * the reflection-based {@link org.springframework.core.type.StandardAnnotationMetadata}.\n\t * @param annotation the annotation to retrieve the attributes for\n\t * @param classValuesAsString whether to convert Class references into Strings (for\n\t * compatibility with {@link org.springframework.core.type.AnnotationMetadata})\n\t * or to preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested annotations into\n\t * {@link AnnotationAttributes} maps (for compatibility with\n\t * {@link org.springframework.core.type.AnnotationMetadata}) or to preserve them as\n\t * {@code Annotation} instances\n\t * @return the annotation attributes (a specialized Map) with attribute names as keys\n\t * and corresponding attribute values as values (never {@code null})\n\t * @since 3.1.1\n\t */\n\tpublic static AnnotationAttributes getAnnotationAttributes(\n\t\t\tAnnotation annotation, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {\n\n\t\treturn getAnnotationAttributes(null, annotation, classValuesAsString, nestedAnnotationsAsMap);\n\t}\n\n\t/**\n\t * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.\n\t * <p>Equivalent to calling {@link #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)}\n\t * with the {@code classValuesAsString} and {@code nestedAnnotationsAsMap} parameters\n\t * set to {@code false}.\n\t * @param annotatedElement the element that is annotated with the supplied annotation;\n\t * may be {@code null} if unknown\n\t * @param annotation the annotation to retrieve the attributes for\n\t * @return the annotation attributes (a specialized Map) with attribute names as keys\n\t * and corresponding attribute values as values (never {@code null})\n\t * @since 4.2\n\t * @see #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)\n\t */\n\tpublic static AnnotationAttributes getAnnotationAttributes(\n\t\t\t@Nullable AnnotatedElement annotatedElement, Annotation annotation) {\n\n\t\treturn getAnnotationAttributes(annotatedElement, annotation, false, false);\n\t}\n\n\t/**\n\t * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.\n\t * <p>This method provides fully recursive annotation reading capabilities on par with\n\t * the reflection-based {@link org.springframework.core.type.StandardAnnotationMetadata}.\n\t * @param annotatedElement the element that is annotated with the supplied annotation;\n\t * may be {@code null} if unknown\n\t * @param annotation the annotation to retrieve the attributes for\n\t * @param classValuesAsString whether to convert Class references into Strings (for\n\t * compatibility with {@link org.springframework.core.type.AnnotationMetadata})\n\t * or to preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested annotations into\n\t * {@link AnnotationAttributes} maps (for compatibility with\n\t * {@link org.springframework.core.type.AnnotationMetadata}) or to preserve them as\n\t * {@code Annotation} instances\n\t * @return the annotation attributes (a specialized Map) with attribute names as keys\n\t * and corresponding attribute values as values (never {@code null})\n\t * @since 4.2\n\t */\n\tpublic static AnnotationAttributes getAnnotationAttributes(\n\t\t\t@Nullable AnnotatedElement annotatedElement, Annotation annotation,\n\t\t\tboolean classValuesAsString, boolean nestedAnnotationsAsMap) {\n\n\t\tAdapt[] adaptations = Adapt.values(classValuesAsString, nestedAnnotationsAsMap);\n\t\treturn MergedAnnotation.from(annotatedElement, annotation)\n\t\t\t\t.withNonMergedAttributes()\n\t\t\t\t.asMap(mergedAnnotation ->\n\t\t\t\t\t\tnew AnnotationAttributes(mergedAnnotation.getType(), true), adaptations);\n\t}\n\n\t/**\n\t * Register the annotation-declared default values for the given attributes,\n\t * if available.\n\t * @param attributes the annotation attributes to process\n\t * @since 4.3.2\n\t */\n\tpublic static void registerDefaultValues(AnnotationAttributes attributes) {\n\t\tClass<? extends Annotation> annotationType = attributes.annotationType();\n\t\tif (annotationType != null && Modifier.isPublic(annotationType.getModifiers()) &&\n\t\t\t\t!AnnotationFilter.PLAIN.matches(annotationType)) {\n\t\t\tMap<String, DefaultValueHolder> defaultValues = getDefaultValues(annotationType);\n\t\t\tdefaultValues.forEach(attributes::putIfAbsent);\n\t\t}\n\t}\n\n\tprivate static Map<String, DefaultValueHolder> getDefaultValues(\n\t\t\tClass<? extends Annotation> annotationType) {\n\n\t\treturn defaultValuesCache.computeIfAbsent(annotationType,\n\t\t\t\tAnnotationUtils::computeDefaultValues);\n\t}\n\n\tprivate static Map<String, DefaultValueHolder> computeDefaultValues(\n\t\t\tClass<? extends Annotation> annotationType) {\n\n\t\tAttributeMethods methods = AttributeMethods.forAnnotationType(annotationType);\n\t\tif (!methods.hasDefaultValueMethod()) {\n\t\t\treturn Collections.emptyMap();\n\t\t}\n\t\tMap<String, DefaultValueHolder> result = CollectionUtils.newLinkedHashMap(methods.size());\n\t\tif (!methods.hasNestedAnnotation()) {\n\t\t\t// Use simpler method if there are no nested annotations\n\t\t\tfor (int i = 0; i < methods.size(); i++) {\n\t\t\t\tMethod method = methods.get(i);\n\t\t\t\tObject defaultValue = method.getDefaultValue();\n\t\t\t\tif (defaultValue != null) {\n\t\t\t\t\tresult.put(method.getName(), new DefaultValueHolder(defaultValue));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// If we have nested annotations, we need them as nested maps\n\t\t\tAnnotationAttributes attributes = MergedAnnotation.of(annotationType)\n\t\t\t\t\t.asMap(annotation ->\n\t\t\t\t\t\t\tnew AnnotationAttributes(annotation.getType(), true), Adapt.ANNOTATION_TO_MAP);\n\t\t\tfor (Map.Entry<String, Object> element : attributes.entrySet()) {\n\t\t\t\tresult.put(element.getKey(), new DefaultValueHolder(element.getValue()));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Post-process the supplied {@link AnnotationAttributes}, preserving nested\n\t * annotations as {@code Annotation} instances.\n\t * <p>Specifically, this method enforces <em>attribute alias</em> semantics\n\t * for annotation attributes that are annotated with {@link AliasFor @AliasFor}\n\t * and replaces default value placeholders with their original default values.\n\t * @param annotatedElement the element that is annotated with an annotation or\n\t * annotation hierarchy from which the supplied attributes were created;\n\t * may be {@code null} if unknown\n\t * @param attributes the annotation attributes to post-process\n\t * @param classValuesAsString whether to convert Class references into Strings (for\n\t * compatibility with {@link org.springframework.core.type.AnnotationMetadata})\n\t * or to preserve them as Class references\n\t * @since 4.3.2\n\t * @see #getDefaultValue(Class, String)\n\t */\n\tpublic static void postProcessAnnotationAttributes(@Nullable Object annotatedElement,\n\t\t\t@Nullable AnnotationAttributes attributes, boolean classValuesAsString) {\n\n\t\tif (attributes == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (!attributes.validated) {\n\t\t\tClass<? extends Annotation> annotationType = attributes.annotationType();\n\t\t\tif (annotationType == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(annotationType).get(0);\n\t\t\tfor (int i = 0; i < mapping.getMirrorSets().size(); i++) {\n\t\t\t\tMirrorSet mirrorSet = mapping.getMirrorSets().get(i);\n\t\t\t\tint resolved = mirrorSet.resolve(attributes.displayName, attributes,\n\t\t\t\t\t\tAnnotationUtils::getAttributeValueForMirrorResolution);\n\t\t\t\tif (resolved != -1) {\n\t\t\t\t\tMethod attribute = mapping.getAttributes().get(resolved);\n\t\t\t\t\tObject value = attributes.get(attribute.getName());\n\t\t\t\t\tfor (int j = 0; j < mirrorSet.size(); j++) {\n\t\t\t\t\t\tMethod mirror = mirrorSet.get(j);\n\t\t\t\t\t\tif (mirror != attribute) {\n\t\t\t\t\t\t\tattributes.put(mirror.getName(),\n\t\t\t\t\t\t\t\t\tadaptValue(annotatedElement, value, classValuesAsString));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (Map.Entry<String, Object> attributeEntry : attributes.entrySet()) {\n\t\t\tString attributeName = attributeEntry.getKey();\n\t\t\tObject value = attributeEntry.getValue();\n\t\t\tif (value instanceof DefaultValueHolder defaultValueHolder) {\n\t\t\t\tvalue = defaultValueHolder.defaultValue;\n\t\t\t\tattributes.put(attributeName,\n\t\t\t\t\t\tadaptValue(annotatedElement, value, classValuesAsString));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static @Nullable Object getAttributeValueForMirrorResolution(Method attribute, @Nullable Object attributes) {\n\t\tif (!(attributes instanceof AnnotationAttributes annotationAttributes)) {\n\t\t\treturn null;\n\t\t}\n\t\tObject result = annotationAttributes.get(attribute.getName());\n\t\treturn (result instanceof DefaultValueHolder defaultValueHolder ? defaultValueHolder.defaultValue : result);\n\t}\n\n\tprivate static @Nullable Object adaptValue(\n\t\t\t@Nullable Object annotatedElement, @Nullable Object value, boolean classValuesAsString) {\n\n\t\tif (classValuesAsString) {\n\t\t\tif (value instanceof Class<?> clazz) {\n\t\t\t\treturn clazz.getName();\n\t\t\t}\n\t\t\tif (value instanceof Class<?>[] classes) {\n\t\t\t\tString[] names = new String[classes.length];\n\t\t\t\tfor (int i = 0; i < classes.length; i++) {\n\t\t\t\t\tnames[i] = classes[i].getName();\n\t\t\t\t}\n\t\t\t\treturn names;\n\t\t\t}\n\t\t}\n\t\tif (value instanceof Annotation annotation) {\n\t\t\treturn MergedAnnotation.from(annotatedElement, annotation).synthesize();\n\t\t}\n\t\tif (value instanceof Annotation[] annotations) {\n\t\t\tAnnotation[] synthesized = (Annotation[]) Array.newInstance(\n\t\t\t\t\tannotations.getClass().componentType(), annotations.length);\n\t\t\tfor (int i = 0; i < annotations.length; i++) {\n\t\t\t\tsynthesized[i] = MergedAnnotation.from(annotatedElement, annotations[i]).synthesize();\n\t\t\t}\n\t\t\treturn synthesized;\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Retrieve the <em>value</em> of the {@code value} attribute of a\n\t * single-element Annotation, given an annotation instance.\n\t * @param annotation the annotation instance from which to retrieve the value\n\t * @return the attribute value, or {@code null} if not found unless the attribute\n\t * value cannot be retrieved due to an {@link AnnotationConfigurationException},\n\t * in which case such an exception will be rethrown\n\t * @see #getValue(Annotation, String)\n\t */\n\tpublic static @Nullable Object getValue(Annotation annotation) {\n\t\treturn getValue(annotation, VALUE);\n\t}\n\n\t/**\n\t * Retrieve the <em>value</em> of a named attribute, given an annotation instance.\n\t * @param annotation the annotation instance from which to retrieve the value\n\t * @param attributeName the name of the attribute value to retrieve\n\t * @return the attribute value, or {@code null} if not found unless the attribute\n\t * value cannot be retrieved due to an {@link AnnotationConfigurationException},\n\t * in which case such an exception will be rethrown\n\t * @see #getValue(Annotation)\n\t */\n\tpublic static @Nullable Object getValue(@Nullable Annotation annotation, @Nullable String attributeName) {\n\t\tif (annotation == null || !StringUtils.hasText(attributeName)) {\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\tfor (Method method : annotation.annotationType().getDeclaredMethods()) {\n\t\t\t\tif (method.getName().equals(attributeName) && method.getParameterCount() == 0) {\n\t\t\t\t\treturn invokeAnnotationMethod(method, annotation);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\thandleValueRetrievalFailure(annotation, ex);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Invoke the supplied annotation attribute {@link Method} on the supplied\n\t * {@link Annotation}.\n\t * <p>An attempt will first be made to invoke the method via the annotation's\n\t * {@link InvocationHandler} (if the annotation instance is a JDK dynamic proxy).\n\t * If that fails, an attempt will be made to invoke the method via reflection.\n\t * @param method the method to invoke\n\t * @param annotation the annotation on which to invoke the method\n\t * @return the value returned from the method invocation\n\t * @since 5.3.24\n\t */\n\tstatic @Nullable Object invokeAnnotationMethod(Method method, @Nullable Object annotation) {\n\t\tif (annotation == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (Proxy.isProxyClass(annotation.getClass())) {\n\t\t\ttry {\n\t\t\t\tInvocationHandler handler = Proxy.getInvocationHandler(annotation);\n\t\t\t\treturn handler.invoke(annotation, method, null);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// Ignore and fall back to reflection below\n\t\t\t}\n\t\t}\n\t\treturn ReflectionUtils.invokeMethod(method, annotation);\n\t}\n\n\t/**\n\t * If the supplied throwable is an {@link AnnotationConfigurationException},\n\t * it will be cast to an {@code AnnotationConfigurationException} and thrown,\n\t * allowing it to propagate to the caller.\n\t * <p>Otherwise, this method does nothing.\n\t * @param ex the throwable to inspect\n\t */\n\tstatic void rethrowAnnotationConfigurationException(Throwable ex) {\n\t\tif (ex instanceof AnnotationConfigurationException exception) {\n\t\t\tthrow exception;\n\t\t}\n\t}\n\n\t/**\n\t * Handle the supplied annotation introspection exception.\n\t * <p>If the supplied exception is an {@link AnnotationConfigurationException},\n\t * it will simply be thrown, allowing it to propagate to the caller, and\n\t * nothing will be logged.\n\t * <p>Otherwise, this method logs an introspection failure (in particular for\n\t * a {@link TypeNotPresentException}) before moving on, assuming nested\n\t * {@code Class} values were not resolvable within annotation attributes and\n\t * thereby effectively pretending there were no annotations on the specified\n\t * element.\n\t * @param element the element that we tried to introspect annotations on\n\t * @param ex the exception that we encountered\n\t * @see #rethrowAnnotationConfigurationException\n\t * @see IntrospectionFailureLogger\n\t */\n\tstatic void handleIntrospectionFailure(AnnotatedElement element, Throwable ex) {\n\t\trethrowAnnotationConfigurationException(ex);\n\t\tIntrospectionFailureLogger logger = IntrospectionFailureLogger.INFO;\n\t\tboolean meta = false;\n\t\tif (element instanceof Class<?> clazz && Annotation.class.isAssignableFrom(clazz)) {\n\t\t\t// Meta-annotation introspection failure\n\t\t\tlogger = IntrospectionFailureLogger.DEBUG;\n\t\t\tmeta = true;\n\t\t}\n\t\tif (logger.isEnabled()) {\n\t\t\tlogger.log(\"Failed to \" + (meta ? \"meta-introspect annotation \" : \"introspect annotations on \") +\n\t\t\t\t\telement + \": \" + ex);\n\t\t}\n\t}\n\n\t/**\n\t * Handle the supplied value retrieval exception.\n\t * @param annotation the annotation instance from which to retrieve the value\n\t * @param ex the exception that we encountered\n\t * @see #handleIntrospectionFailure\n\t */\n\tprivate static void handleValueRetrievalFailure(Annotation annotation, Throwable ex) {\n\t\trethrowAnnotationConfigurationException(ex);\n\t\tIntrospectionFailureLogger logger = IntrospectionFailureLogger.INFO;\n\t\tif (logger.isEnabled()) {\n\t\t\tlogger.log(\"Failed to retrieve value from \" + annotation + \": \" + ex);\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve the <em>default value</em> of the {@code value} attribute\n\t * of a single-element Annotation, given an annotation instance.\n\t * @param annotation the annotation instance from which to retrieve the default value\n\t * @return the default value, or {@code null} if not found\n\t * @see #getDefaultValue(Annotation, String)\n\t */\n\tpublic static @Nullable Object getDefaultValue(Annotation annotation) {\n\t\treturn getDefaultValue(annotation, VALUE);\n\t}\n\n\t/**\n\t * Retrieve the <em>default value</em> of a named attribute, given an annotation instance.\n\t * @param annotation the annotation instance from which to retrieve the default value\n\t * @param attributeName the name of the attribute value to retrieve\n\t * @return the default value of the named attribute, or {@code null} if not found\n\t * @see #getDefaultValue(Class, String)\n\t */\n\tpublic static @Nullable Object getDefaultValue(@Nullable Annotation annotation, @Nullable String attributeName) {\n\t\treturn (annotation != null ? getDefaultValue(annotation.annotationType(), attributeName) : null);\n\t}\n\n\t/**\n\t * Retrieve the <em>default value</em> of the {@code value} attribute\n\t * of a single-element Annotation, given the {@link Class annotation type}.\n\t * @param annotationType the <em>annotation type</em> for which the default value should be retrieved\n\t * @return the default value, or {@code null} if not found\n\t * @see #getDefaultValue(Class, String)\n\t */\n\tpublic static @Nullable Object getDefaultValue(Class<? extends Annotation> annotationType) {\n\t\treturn getDefaultValue(annotationType, VALUE);\n\t}\n\n\t/**\n\t * Retrieve the <em>default value</em> of a named attribute, given the\n\t * {@link Class annotation type}.\n\t * @param annotationType the <em>annotation type</em> for which the default value should be retrieved\n\t * @param attributeName the name of the attribute value to retrieve.\n\t * @return the default value of the named attribute, or {@code null} if not found\n\t * @see #getDefaultValue(Annotation, String)\n\t */\n\tpublic static @Nullable Object getDefaultValue(\n\t\t\t@Nullable Class<? extends Annotation> annotationType, @Nullable String attributeName) {\n\n\t\tif (annotationType == null || !StringUtils.hasText(attributeName)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn MergedAnnotation.of(annotationType).getDefaultValue(attributeName).orElse(null);\n\t}\n\n\t/**\n\t * <em>Synthesize</em> an annotation from the supplied {@code annotation}\n\t * by wrapping it in a dynamic proxy that transparently enforces\n\t * <em>attribute alias</em> semantics for annotation attributes that are\n\t * annotated with {@link AliasFor @AliasFor}.\n\t * @param annotation the annotation to synthesize\n\t * @param annotatedElement the element that is annotated with the supplied\n\t * annotation; may be {@code null} if unknown\n\t * @return the synthesized annotation if the supplied annotation is\n\t * <em>synthesizable</em>; {@code null} if the supplied annotation is\n\t * {@code null}; otherwise the supplied annotation unmodified\n\t * @throws AnnotationConfigurationException if invalid configuration of\n\t * {@code @AliasFor} is detected\n\t * @since 4.2\n\t * @see #synthesizeAnnotation(Map, Class, AnnotatedElement)\n\t * @see #synthesizeAnnotation(Class)\n\t */\n\tpublic static <A extends Annotation> A synthesizeAnnotation(\n\t\t\tA annotation, @Nullable AnnotatedElement annotatedElement) {\n\n\t\tif (isSynthesizedAnnotation(annotation) || AnnotationFilter.PLAIN.matches(annotation)) {\n\t\t\treturn annotation;\n\t\t}\n\t\treturn MergedAnnotation.from(annotatedElement, annotation).synthesize();\n\t}\n\n\t/**\n\t * <em>Synthesize</em> an annotation from its default attributes values.\n\t * <p>This method simply delegates to\n\t * {@link #synthesizeAnnotation(Map, Class, AnnotatedElement)},\n\t * supplying an empty map for the source attribute values and {@code null}\n\t * for the {@link AnnotatedElement}.\n\t * @param annotationType the type of annotation to synthesize\n\t * @return the synthesized annotation\n\t * @throws IllegalArgumentException if a required attribute is missing\n\t * @throws AnnotationConfigurationException if invalid configuration of\n\t * {@code @AliasFor} is detected\n\t * @since 4.2\n\t * @see #synthesizeAnnotation(Map, Class, AnnotatedElement)\n\t * @see #synthesizeAnnotation(Annotation, AnnotatedElement)\n\t */\n\tpublic static <A extends Annotation> A synthesizeAnnotation(Class<A> annotationType) {\n\t\treturn synthesizeAnnotation(Collections.emptyMap(), annotationType, null);\n\t}\n\n\t/**\n\t * <em>Synthesize</em> an annotation from the supplied map of annotation\n\t * attributes by wrapping the map in a dynamic proxy that implements an\n\t * annotation of the specified {@code annotationType} and transparently\n\t * enforces <em>attribute alias</em> semantics for annotation attributes\n\t * that are annotated with {@link AliasFor @AliasFor}.\n\t * <p>The supplied map must contain a key-value pair for every attribute\n\t * defined in the supplied {@code annotationType} that is not aliased or\n\t * does not have a default value. Nested maps and nested arrays of maps\n\t * will be recursively synthesized into nested annotations or nested\n\t * arrays of annotations, respectively.\n\t * <p>Note that {@link AnnotationAttributes} is a specialized type of\n\t * {@link Map} that is an ideal candidate for this method's\n\t * {@code attributes} argument.\n\t * @param attributes the map of annotation attributes to synthesize\n\t * @param annotationType the type of annotation to synthesize\n\t * @param annotatedElement the element that is annotated with the annotation\n\t * corresponding to the supplied attributes; may be {@code null} if unknown\n\t * @return the synthesized annotation\n\t * @throws IllegalArgumentException if a required attribute is missing or if an\n\t * attribute is not of the correct type\n\t * @throws AnnotationConfigurationException if invalid configuration of\n\t * {@code @AliasFor} is detected\n\t * @since 4.2\n\t * @see #synthesizeAnnotation(Annotation, AnnotatedElement)\n\t * @see #synthesizeAnnotation(Class)\n\t * @see #getAnnotationAttributes(AnnotatedElement, Annotation)\n\t * @see #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)\n\t */\n\tpublic static <A extends Annotation> A synthesizeAnnotation(Map<String, Object> attributes,\n\t\t\tClass<A> annotationType, @Nullable AnnotatedElement annotatedElement) {\n\n\t\ttry {\n\t\t\treturn MergedAnnotation.of(annotatedElement, annotationType, attributes).synthesize();\n\t\t}\n\t\tcatch (NoSuchElementException | IllegalStateException ex) {\n\t\t\tthrow new IllegalArgumentException(ex);\n\t\t}\n\t}\n\n\t/**\n\t * <em>Synthesize</em> an array of annotations from the supplied array\n\t * of {@code annotations} by creating a new array of the same size and\n\t * type and populating it with {@linkplain #synthesizeAnnotation(Annotation,\n\t * AnnotatedElement) synthesized} versions of the annotations from the input\n\t * array.\n\t * @param annotations the array of annotations to synthesize\n\t * @param annotatedElement the element that is annotated with the supplied\n\t * array of annotations; may be {@code null} if unknown\n\t * @return a new array of synthesized annotations, or {@code null} if\n\t * the supplied array is {@code null}\n\t * @throws AnnotationConfigurationException if invalid configuration of\n\t * {@code @AliasFor} is detected\n\t * @since 4.2\n\t * @see #synthesizeAnnotation(Annotation, AnnotatedElement)\n\t * @see #synthesizeAnnotation(Map, Class, AnnotatedElement)\n\t */\n\tstatic Annotation[] synthesizeAnnotationArray(Annotation[] annotations, AnnotatedElement annotatedElement) {\n\t\tif (AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) {\n\t\t\treturn annotations;\n\t\t}\n\t\tAnnotation[] synthesized = (Annotation[]) Array.newInstance(\n\t\t\t\tannotations.getClass().componentType(), annotations.length);\n\t\tfor (int i = 0; i < annotations.length; i++) {\n\t\t\tsynthesized[i] = synthesizeAnnotation(annotations[i], annotatedElement);\n\t\t}\n\t\treturn synthesized;\n\t}\n\n\t/**\n\t * Determine if the supplied {@link Annotation} has been <em>synthesized</em>\n\t * by Spring (i.e. wrapped in a dynamic proxy) with additional functionality\n\t * such as attribute alias handling.\n\t * @param annotation the annotation to check\n\t * @return {@code true} if the supplied annotation is a synthesized annotation\n\t * @since 5.3.23\n\t */\n\tpublic static boolean isSynthesizedAnnotation(@Nullable Annotation annotation) {\n\t\ttry {\n\t\t\treturn (annotation != null && Proxy.isProxyClass(annotation.getClass()) &&\n\t\t\t\t\tProxy.getInvocationHandler(annotation) instanceof SynthesizedMergedAnnotationInvocationHandler);\n\t\t}\n\t\tcatch (SecurityException ex) {\n\t\t\t// Security settings disallow reflective access to the InvocationHandler:\n\t\t\t// assume the annotation has not been synthesized by Spring.\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Clear the internal annotation metadata cache.\n\t * @since 4.3.15\n\t */\n\tpublic static void clearCache() {\n\t\tAnnotationTypeMappings.clearCache();\n\t\tAnnotationsScanner.clearCache();\n\t\tAttributeMethods.cache.clear();\n\t\tRepeatableContainers.cache.clear();\n\t\tOrderUtils.orderCache.clear();\n\t}\n\n\n\t/**\n\t * Internal holder used to wrap default values.\n\t */\n\tprivate static class DefaultValueHolder {\n\n\t\tfinal Object defaultValue;\n\n\t\tpublic DefaultValueHolder(Object defaultValue) {\n\t\t\tthis.defaultValue = defaultValue;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"*\" + this.defaultValue;\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.AnnotationUtils#VALUE",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils#VALUE",
    "headType": "field",
    "relation": "haveType",
    "tail": "String",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.AnnotationUtils#JAVA_LANG_ANNOTATION_FILTER",
    "tailType": "field"
  }
]