[
  {
    "head": "org.springframework.core.annotation.AnnotationUtils#getAnnotation(Method,Class<A>)",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils#getAnnotations(AnnotatedElement)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Get all {@link Annotation Annotations} that are <em>present</em> on the\r\n * supplied {@link AnnotatedElement}.\r\n * <p>Meta-annotations will <em>not</em> be searched.\r\n * @param annotatedElement the Method, Constructor or Field to retrieve annotations from\r\n * @return the annotations found, an empty array, or {@code null} if not\r\n * resolvable (for example, because nested Class values in annotation attributes\r\n * failed to resolve at runtime)\r\n * @since 4.0.8\r\n * @see AnnotatedElement#getAnnotations()\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\npublic static Annotation @Nullable [] getAnnotations(AnnotatedElement annotatedElement) {\r\n    try {\r\n        return synthesizeAnnotationArray(annotatedElement.getAnnotations(), annotatedElement);\r\n    } catch (Throwable ex) {\r\n        handleIntrospectionFailure(annotatedElement, ex);\r\n        return null;\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotationUtils#getAnnotations(AnnotatedElement)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils#getAnnotations(AnnotatedElement)",
    "headType": "method",
    "relation": "use",
    "tail": "@Deprecated",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils#getAnnotations(Method)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Get all {@link Annotation Annotations} that are <em>present</em> on the\r\n * supplied {@link Method}.\r\n * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.\r\n * <p>Meta-annotations will <em>not</em> be searched.\r\n * @param method the Method to retrieve annotations from\r\n * @return the annotations found, an empty array, or {@code null} if not\r\n * resolvable (for example, because nested Class values in annotation attributes\r\n * failed to resolve at runtime)\r\n * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod(Method)\r\n * @see AnnotatedElement#getAnnotations()\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\npublic static Annotation @Nullable [] getAnnotations(Method method) {\r\n    try {\r\n        return synthesizeAnnotationArray(BridgeMethodResolver.findBridgedMethod(method).getAnnotations(), method);\r\n    } catch (Throwable ex) {\r\n        handleIntrospectionFailure(method, ex);\r\n        return null;\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotationUtils#getAnnotations(Method)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils#getAnnotations(Method)",
    "headType": "method",
    "relation": "use",
    "tail": "@Deprecated",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils#getRepeatableAnnotations(AnnotatedElement,Class<A>)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Get the <em>repeatable</em> {@linkplain Annotation annotations} of\r\n * {@code annotationType} from the supplied {@link AnnotatedElement}, where\r\n * such annotations are either <em>present</em>, <em>indirectly present</em>,\r\n * or <em>meta-present</em> on the element.\r\n * <p>This method mimics the functionality of Java 8's\r\n * {@link java.lang.reflect.AnnotatedElement#getAnnotationsByType(Class)}\r\n * with support for automatic detection of a <em>container annotation</em>\r\n * declared via @{@link java.lang.annotation.Repeatable} (when running on\r\n * Java 8 or higher) and with additional support for meta-annotations.\r\n * <p>Handles both single annotations and annotations nested within a\r\n * <em>container annotation</em>.\r\n * <p>Correctly handles <em>bridge methods</em> generated by the\r\n * compiler if the supplied element is a {@link Method}.\r\n * <p>Meta-annotations will be searched if the annotation is not\r\n * <em>present</em> on the supplied element.\r\n * @param annotatedElement the element to look for annotations on\r\n * @param annotationType the annotation type to look for\r\n * @return the annotations found or an empty set (never {@code null})\r\n * @since 4.2\r\n * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)\r\n * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)\r\n * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class)\r\n * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\r\n * @see java.lang.annotation.Repeatable\r\n * @see java.lang.reflect.AnnotatedElement#getAnnotationsByType\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\npublic static <A extends Annotation> Set<A> getRepeatableAnnotations(AnnotatedElement annotatedElement, Class<A> annotationType) {\r\n    return getRepeatableAnnotations(annotatedElement, annotationType, null);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotationUtils#getRepeatableAnnotations(AnnotatedElement,Class<A>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils#getRepeatableAnnotations(AnnotatedElement,Class<A>)",
    "headType": "method",
    "relation": "use",
    "tail": "@Deprecated",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils#getRepeatableAnnotations(AnnotatedElement,Class<A>,Class<? extends Annotation>)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Get the <em>repeatable</em> {@linkplain Annotation annotations} of\r\n * {@code annotationType} from the supplied {@link AnnotatedElement}, where\r\n * such annotations are either <em>present</em>, <em>indirectly present</em>,\r\n * or <em>meta-present</em> on the element.\r\n * <p>This method mimics the functionality of Java 8's\r\n * {@link java.lang.reflect.AnnotatedElement#getAnnotationsByType(Class)}\r\n * with additional support for meta-annotations.\r\n * <p>Handles both single annotations and annotations nested within a\r\n * <em>container annotation</em>.\r\n * <p>Correctly handles <em>bridge methods</em> generated by the\r\n * compiler if the supplied element is a {@link Method}.\r\n * <p>Meta-annotations will be searched if the annotation is not\r\n * <em>present</em> on the supplied element.\r\n * @param annotatedElement the element to look for annotations on\r\n * @param annotationType the annotation type to look for\r\n * @param containerAnnotationType the type of the container that holds\r\n * the annotations; may be {@code null} if a container is not supported\r\n * or if it should be looked up via @{@link java.lang.annotation.Repeatable}\r\n * when running on Java 8 or higher\r\n * @return the annotations found or an empty set (never {@code null})\r\n * @since 4.2\r\n * @see #getRepeatableAnnotations(AnnotatedElement, Class)\r\n * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class)\r\n * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)\r\n * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\r\n * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\r\n * @see java.lang.annotation.Repeatable\r\n * @see java.lang.reflect.AnnotatedElement#getAnnotationsByType\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\npublic static <A extends Annotation> Set<A> getRepeatableAnnotations(AnnotatedElement annotatedElement, Class<A> annotationType, @Nullable Class<? extends Annotation> containerAnnotationType) {\r\n    RepeatableContainers repeatableContainers = (containerAnnotationType != null ? RepeatableContainers.of(annotationType, containerAnnotationType) : RepeatableContainers.standardRepeatables());\r\n    return MergedAnnotations.from(annotatedElement, SearchStrategy.SUPERCLASS, repeatableContainers).stream(annotationType).filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex)).map(MergedAnnotation::withNonMergedAttributes).collect(MergedAnnotationCollectors.toAnnotationSet());\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotationUtils#getRepeatableAnnotations(AnnotatedElement,Class<A>,Class<? extends Annotation>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils#getRepeatableAnnotations(AnnotatedElement,Class<A>,Class<? extends Annotation>)",
    "headType": "method",
    "relation": "use",
    "tail": "@Deprecated",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils#getDeclaredRepeatableAnnotations(AnnotatedElement,Class<A>)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Get the declared <em>repeatable</em> {@linkplain Annotation annotations}\r\n * of {@code annotationType} from the supplied {@link AnnotatedElement},\r\n * where such annotations are either <em>directly present</em>,\r\n * <em>indirectly present</em>, or <em>meta-present</em> on the element.\r\n * <p>This method mimics the functionality of Java 8's\r\n * {@link java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType(Class)}\r\n * with support for automatic detection of a <em>container annotation</em>\r\n * declared via @{@link java.lang.annotation.Repeatable} (when running on\r\n * Java 8 or higher) and with additional support for meta-annotations.\r\n * <p>Handles both single annotations and annotations nested within a\r\n * <em>container annotation</em>.\r\n * <p>Correctly handles <em>bridge methods</em> generated by the\r\n * compiler if the supplied element is a {@link Method}.\r\n * <p>Meta-annotations will be searched if the annotation is not\r\n * <em>present</em> on the supplied element.\r\n * @param annotatedElement the element to look for annotations on\r\n * @param annotationType the annotation type to look for\r\n * @return the annotations found or an empty set (never {@code null})\r\n * @since 4.2\r\n * @see #getRepeatableAnnotations(AnnotatedElement, Class)\r\n * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)\r\n * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)\r\n * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class)\r\n * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\r\n * @see java.lang.annotation.Repeatable\r\n * @see java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\npublic static <A extends Annotation> Set<A> getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement, Class<A> annotationType) {\r\n    return getDeclaredRepeatableAnnotations(annotatedElement, annotationType, null);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotationUtils#getDeclaredRepeatableAnnotations(AnnotatedElement,Class<A>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils#getDeclaredRepeatableAnnotations(AnnotatedElement,Class<A>)",
    "headType": "method",
    "relation": "use",
    "tail": "@Deprecated",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils#getDeclaredRepeatableAnnotations(AnnotatedElement,Class<A>,Class<? extends Annotation>)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Get the declared <em>repeatable</em> {@linkplain Annotation annotations}\r\n * of {@code annotationType} from the supplied {@link AnnotatedElement},\r\n * where such annotations are either <em>directly present</em>,\r\n * <em>indirectly present</em>, or <em>meta-present</em> on the element.\r\n * <p>This method mimics the functionality of Java 8's\r\n * {@link java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType(Class)}\r\n * with additional support for meta-annotations.\r\n * <p>Handles both single annotations and annotations nested within a\r\n * <em>container annotation</em>.\r\n * <p>Correctly handles <em>bridge methods</em> generated by the\r\n * compiler if the supplied element is a {@link Method}.\r\n * <p>Meta-annotations will be searched if the annotation is not\r\n * <em>present</em> on the supplied element.\r\n * @param annotatedElement the element to look for annotations on\r\n * @param annotationType the annotation type to look for\r\n * @param containerAnnotationType the type of the container that holds\r\n * the annotations; may be {@code null} if a container is not supported\r\n * or if it should be looked up via @{@link java.lang.annotation.Repeatable}\r\n * when running on Java 8 or higher\r\n * @return the annotations found or an empty set (never {@code null})\r\n * @since 4.2\r\n * @see #getRepeatableAnnotations(AnnotatedElement, Class)\r\n * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)\r\n * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class)\r\n * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\r\n * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\r\n * @see java.lang.annotation.Repeatable\r\n * @see java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\npublic static <A extends Annotation> Set<A> getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement, Class<A> annotationType, @Nullable Class<? extends Annotation> containerAnnotationType) {\r\n    RepeatableContainers repeatableContainers = containerAnnotationType != null ? RepeatableContainers.of(annotationType, containerAnnotationType) : RepeatableContainers.standardRepeatables();\r\n    return MergedAnnotations.from(annotatedElement, SearchStrategy.DIRECT, repeatableContainers).stream(annotationType).map(MergedAnnotation::withNonMergedAttributes).collect(MergedAnnotationCollectors.toAnnotationSet());\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotationUtils#getDeclaredRepeatableAnnotations(AnnotatedElement,Class<A>,Class<? extends Annotation>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils#getDeclaredRepeatableAnnotations(AnnotatedElement,Class<A>,Class<? extends Annotation>)",
    "headType": "method",
    "relation": "use",
    "tail": "@Deprecated",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationUtils#findAnnotation(AnnotatedElement,Class<A>)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Find a single {@link Annotation} of {@code annotationType} on the\r\n * supplied {@link AnnotatedElement}.\r\n * <p>Meta-annotations will be searched if the annotation is not\r\n * <em>directly present</em> on the supplied element.\r\n * <p><strong>Warning</strong>: this method operates generically on\r\n * annotated elements. In other words, this method does not execute\r\n * specialized search algorithms for classes or methods. If you require\r\n * the more specific semantics of {@link #findAnnotation(Class, Class)}\r\n * or {@link #findAnnotation(Method, Class)}, invoke one of those methods\r\n * instead.\r\n * @param annotatedElement the {@code AnnotatedElement} on which to find the annotation\r\n * @param annotationType the annotation type to look for, both locally and as a meta-annotation\r\n * @return the first matching annotation, or {@code null} if not found\r\n * @since 4.2\r\n */\r\n@Nullable\r\npublic static <A extends Annotation> A findAnnotation(AnnotatedElement annotatedElement, @Nullable Class<A> annotationType) {\r\n    if (annotationType == null) {\r\n        return null;\r\n    }\r\n    // Shortcut: directly present on the element, with no merging needed?\r\n    if (AnnotationFilter.PLAIN.matches(annotationType) || AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) {\r\n        return annotatedElement.getDeclaredAnnotation(annotationType);\r\n    }\r\n    // Exhaustive retrieval of merged annotations...\r\n    return MergedAnnotations.from(annotatedElement, SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none()).get(annotationType).withNonMergedAttributes().synthesize(MergedAnnotation::isPresent).orElse(null);\r\n}",
    "tailType": "method_code"
  }
]