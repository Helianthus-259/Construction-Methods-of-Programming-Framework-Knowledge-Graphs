[
  {
    "head": "org.springframework.util.NumberUtilsTests#parseNumber()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.NumberUtilsTests#parseNumberUsingNumberFormat()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid parseNumberUsingNumberFormat() {\r\n    NumberFormat nf = NumberFormat.getNumberInstance(Locale.US);\r\n    String aByte = \"\" + Byte.MAX_VALUE;\r\n    String aShort = \"\" + Short.MAX_VALUE;\r\n    String anInteger = \"\" + Integer.MAX_VALUE;\r\n    String aLong = \"\" + Long.MAX_VALUE;\r\n    String aFloat = \"\" + Float.MAX_VALUE;\r\n    String aDouble = \"\" + Double.MAX_VALUE;\r\n    assertThat(NumberUtils.parseNumber(aByte, Byte.class, nf)).as(\"Byte did not parse\").isEqualTo(Byte.valueOf(Byte.MAX_VALUE));\r\n    assertThat(NumberUtils.parseNumber(aShort, Short.class, nf)).as(\"Short did not parse\").isEqualTo(Short.valueOf(Short.MAX_VALUE));\r\n    assertThat(NumberUtils.parseNumber(anInteger, Integer.class, nf)).as(\"Integer did not parse\").isEqualTo(Integer.valueOf(Integer.MAX_VALUE));\r\n    assertThat(NumberUtils.parseNumber(aLong, Long.class, nf)).as(\"Long did not parse\").isEqualTo(Long.valueOf(Long.MAX_VALUE));\r\n    assertThat(NumberUtils.parseNumber(aFloat, Float.class, nf)).as(\"Float did not parse\").isEqualTo(Float.valueOf(Float.MAX_VALUE));\r\n    assertThat(NumberUtils.parseNumber(aDouble, Double.class, nf)).as(\"Double did not parse\").isEqualTo(Double.valueOf(Double.MAX_VALUE));\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.NumberUtilsTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.NumberUtilsTests#parseNumberUsingNumberFormat()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.NumberUtilsTests#parseNumberUsingNumberFormat()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.NumberUtilsTests#parseNumberRequiringTrim()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid parseNumberRequiringTrim() {\r\n    String aByte = \" \" + Byte.MAX_VALUE + \" \";\r\n    String aShort = \" \" + Short.MAX_VALUE + \" \";\r\n    String anInteger = \" \" + Integer.MAX_VALUE + \" \";\r\n    String aLong = \" \" + Long.MAX_VALUE + \" \";\r\n    String aFloat = \" \" + Float.MAX_VALUE + \" \";\r\n    String aDouble = \" \" + Double.MAX_VALUE + \" \";\r\n    assertThat(NumberUtils.parseNumber(aByte, Byte.class)).as(\"Byte did not parse\").isEqualTo(Byte.valueOf(Byte.MAX_VALUE));\r\n    assertThat(NumberUtils.parseNumber(aShort, Short.class)).as(\"Short did not parse\").isEqualTo(Short.valueOf(Short.MAX_VALUE));\r\n    assertThat(NumberUtils.parseNumber(anInteger, Integer.class)).as(\"Integer did not parse\").isEqualTo(Integer.valueOf(Integer.MAX_VALUE));\r\n    assertThat(NumberUtils.parseNumber(aLong, Long.class)).as(\"Long did not parse\").isEqualTo(Long.valueOf(Long.MAX_VALUE));\r\n    assertThat(NumberUtils.parseNumber(aFloat, Float.class)).as(\"Float did not parse\").isEqualTo(Float.valueOf(Float.MAX_VALUE));\r\n    assertThat(NumberUtils.parseNumber(aDouble, Double.class)).as(\"Double did not parse\").isEqualTo(Double.valueOf(Double.MAX_VALUE));\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.NumberUtilsTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.NumberUtilsTests#parseNumberRequiringTrim()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.NumberUtilsTests#parseNumberRequiringTrim()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.NumberUtilsTests#parseNumberRequiringTrimUsingNumberFormat()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid parseNumberRequiringTrimUsingNumberFormat() {\r\n    NumberFormat nf = NumberFormat.getNumberInstance(Locale.US);\r\n    String aByte = \" \" + Byte.MAX_VALUE + \" \";\r\n    String aShort = \" \" + Short.MAX_VALUE + \" \";\r\n    String anInteger = \" \" + Integer.MAX_VALUE + \" \";\r\n    String aLong = \" \" + Long.MAX_VALUE + \" \";\r\n    String aFloat = \" \" + Float.MAX_VALUE + \" \";\r\n    String aDouble = \" \" + Double.MAX_VALUE + \" \";\r\n    assertThat(NumberUtils.parseNumber(aByte, Byte.class, nf)).as(\"Byte did not parse\").isEqualTo(Byte.valueOf(Byte.MAX_VALUE));\r\n    assertThat(NumberUtils.parseNumber(aShort, Short.class, nf)).as(\"Short did not parse\").isEqualTo(Short.valueOf(Short.MAX_VALUE));\r\n    assertThat(NumberUtils.parseNumber(anInteger, Integer.class, nf)).as(\"Integer did not parse\").isEqualTo(Integer.valueOf(Integer.MAX_VALUE));\r\n    assertThat(NumberUtils.parseNumber(aLong, Long.class, nf)).as(\"Long did not parse\").isEqualTo(Long.valueOf(Long.MAX_VALUE));\r\n    assertThat(NumberUtils.parseNumber(aFloat, Float.class, nf)).as(\"Float did not parse\").isEqualTo(Float.valueOf(Float.MAX_VALUE));\r\n    assertThat(NumberUtils.parseNumber(aDouble, Double.class, nf)).as(\"Double did not parse\").isEqualTo(Double.valueOf(Double.MAX_VALUE));\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.NumberUtilsTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.NumberUtilsTests#parseNumberRequiringTrimUsingNumberFormat()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.NumberUtilsTests#parseNumberRequiringTrimUsingNumberFormat()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.NumberUtilsTests#parseNumberAsHex()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid parseNumberAsHex() {\r\n    String aByte = \"0x\" + Integer.toHexString(Byte.MAX_VALUE);\r\n    String aShort = \"0x\" + Integer.toHexString(Short.MAX_VALUE);\r\n    String anInteger = \"0x\" + Integer.toHexString(Integer.MAX_VALUE);\r\n    String aLong = \"0x\" + Long.toHexString(Long.MAX_VALUE);\r\n    String aReallyBigInt = \"FEBD4E677898DFEBFFEE44\";\r\n    assertByteEquals(aByte);\r\n    assertShortEquals(aShort);\r\n    assertIntegerEquals(anInteger);\r\n    assertLongEquals(aLong);\r\n    assertThat(NumberUtils.parseNumber(\"0x\" + aReallyBigInt, BigInteger.class)).as(\"BigInteger did not parse\").isEqualTo(new BigInteger(aReallyBigInt, 16));\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.NumberUtilsTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.NumberUtilsTests#parseNumberAsHex()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.NumberUtilsTests#parseNumberAsHex()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.NumberUtilsTests#parseNumberAsNegativeHex()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid parseNumberAsNegativeHex() {\r\n    String aByte = \"-0x80\";\r\n    String aShort = \"-0x8000\";\r\n    String anInteger = \"-0x80000000\";\r\n    String aLong = \"-0x8000000000000000\";\r\n    String aReallyBigInt = \"FEBD4E677898DFEBFFEE44\";\r\n    assertNegativeByteEquals(aByte);\r\n    assertNegativeShortEquals(aShort);\r\n    assertNegativeIntegerEquals(anInteger);\r\n    assertNegativeLongEquals(aLong);\r\n    assertThat(NumberUtils.parseNumber(\"-0x\" + aReallyBigInt, BigInteger.class)).as(\"BigInteger did not parse\").isEqualTo(new BigInteger(aReallyBigInt, 16).negate());\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.NumberUtilsTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.NumberUtilsTests#parseNumberAsNegativeHex()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.NumberUtilsTests#parseNumberAsNegativeHex()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.NumberUtilsTests#convertDoubleToBigInteger()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid convertDoubleToBigInteger() {\r\n    Double decimal = 3.14d;\r\n    assertThat(NumberUtils.convertNumberToTargetClass(decimal, BigInteger.class)).isEqualTo(new BigInteger(\"3\"));\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.NumberUtilsTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.NumberUtilsTests#convertDoubleToBigInteger()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.NumberUtilsTests#convertDoubleToBigInteger()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.NumberUtilsTests#convertBigDecimalToBigInteger()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid convertBigDecimalToBigInteger() {\r\n    String number = \"987459837583750387355346\";\r\n    BigDecimal decimal = new BigDecimal(number);\r\n    assertThat(NumberUtils.convertNumberToTargetClass(decimal, BigInteger.class)).isEqualTo(new BigInteger(number));\r\n}",
    "tailType": "method_code"
  }
]