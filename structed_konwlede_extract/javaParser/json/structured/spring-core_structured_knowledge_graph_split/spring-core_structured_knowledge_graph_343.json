[
  {
    "head": "org.springframework.asm.ClassReader#readElementValues(AnnotationVisitor,int,boolean,char[])",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Reads the element values of a JVMS 'annotation' structure and makes the given visitor visit\r\n * them. This method can also be used to read the values of the JVMS 'array_value' field of an\r\n * annotation's 'element_value'.\r\n *\r\n * @param annotationVisitor the visitor that must visit the values.\r\n * @param annotationOffset the start offset of an 'annotation' structure (excluding its type_index\r\n *     field) or of an 'array_value' structure.\r\n * @param named if the annotation values are named or not. This should be true to parse the values\r\n *     of a JVMS 'annotation' structure, and false to parse the JVMS 'array_value' of an\r\n *     annotation's element_value.\r\n * @param charBuffer the buffer used to read strings in the constant pool.\r\n * @return the end offset of the JVMS 'annotation' or 'array_value' structure.\r\n */\r\nprivate int readElementValues(final AnnotationVisitor annotationVisitor, final int annotationOffset, final boolean named, final char[] charBuffer) {\r\n    int currentOffset = annotationOffset;\r\n    // Read the num_element_value_pairs field (or num_values field for an array_value).\r\n    int numElementValuePairs = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    if (named) {\r\n        // Parse the element_value_pairs array.\r\n        while (numElementValuePairs-- > 0) {\r\n            String elementName = readUTF8(currentOffset, charBuffer);\r\n            currentOffset = readElementValue(annotationVisitor, currentOffset + 2, elementName, charBuffer);\r\n        }\r\n    } else {\r\n        // Parse the array_value array.\r\n        while (numElementValuePairs-- > 0) {\r\n            currentOffset = readElementValue(annotationVisitor, currentOffset, /* elementName= */\r\n            null, charBuffer);\r\n        }\r\n    }\r\n    if (annotationVisitor != null) {\r\n        annotationVisitor.visitEnd();\r\n    }\r\n    return currentOffset;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ClassReader#readElementValues(AnnotationVisitor,int,boolean,char[])",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ClassReader#readElementValue(AnnotationVisitor,int,String,char[])",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Reads a JVMS 'element_value' structure and makes the given visitor visit it.\r\n *\r\n * @param annotationVisitor the visitor that must visit the element_value structure.\r\n * @param elementValueOffset the start offset in {@link #classFileBuffer} of the element_value\r\n *     structure to be read.\r\n * @param elementName the name of the element_value structure to be read, or {@literal null}.\r\n * @param charBuffer the buffer used to read strings in the constant pool.\r\n * @return the end offset of the JVMS 'element_value' structure.\r\n */\r\nprivate int readElementValue(final AnnotationVisitor annotationVisitor, final int elementValueOffset, final String elementName, final char[] charBuffer) {\r\n    int currentOffset = elementValueOffset;\r\n    if (annotationVisitor == null) {\r\n        switch(classFileBuffer[currentOffset] & 0xFF) {\r\n            case // enum_const_value\r\n            'e':\r\n                return currentOffset + 5;\r\n            case // annotation_value\r\n            '@':\r\n                return readElementValues(null, currentOffset + 3, /* named= */\r\n                true, charBuffer);\r\n            case // array_value\r\n            '[':\r\n                return readElementValues(null, currentOffset + 1, /* named= */\r\n                false, charBuffer);\r\n            default:\r\n                return currentOffset + 3;\r\n        }\r\n    }\r\n    switch(classFileBuffer[currentOffset++] & 0xFF) {\r\n        case // const_value_index, CONSTANT_Integer\r\n        'B':\r\n            annotationVisitor.visit(elementName, (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));\r\n            currentOffset += 2;\r\n            break;\r\n        case // const_value_index, CONSTANT_Integer\r\n        'C':\r\n            annotationVisitor.visit(elementName, (char) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));\r\n            currentOffset += 2;\r\n            break;\r\n        // const_value_index, CONSTANT_Double\r\n        case 'D':\r\n        // const_value_index, CONSTANT_Float\r\n        case 'F':\r\n        // const_value_index, CONSTANT_Integer\r\n        case 'I':\r\n        case // const_value_index, CONSTANT_Long\r\n        'J':\r\n            annotationVisitor.visit(elementName, readConst(readUnsignedShort(currentOffset), charBuffer));\r\n            currentOffset += 2;\r\n            break;\r\n        case // const_value_index, CONSTANT_Integer\r\n        'S':\r\n            annotationVisitor.visit(elementName, (short) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));\r\n            currentOffset += 2;\r\n            break;\r\n        case // const_value_index, CONSTANT_Integer\r\n        'Z':\r\n            annotationVisitor.visit(elementName, readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]) == 0 ? Boolean.FALSE : Boolean.TRUE);\r\n            currentOffset += 2;\r\n            break;\r\n        case // const_value_index, CONSTANT_Utf8\r\n        's':\r\n            annotationVisitor.visit(elementName, readUTF8(currentOffset, charBuffer));\r\n            currentOffset += 2;\r\n            break;\r\n        case // enum_const_value\r\n        'e':\r\n            annotationVisitor.visitEnum(elementName, readUTF8(currentOffset, charBuffer), readUTF8(currentOffset + 2, charBuffer));\r\n            currentOffset += 4;\r\n            break;\r\n        case // class_info\r\n        'c':\r\n            annotationVisitor.visit(elementName, Type.getType(readUTF8(currentOffset, charBuffer)));\r\n            currentOffset += 2;\r\n            break;\r\n        case // annotation_value\r\n        '@':\r\n            currentOffset = readElementValues(annotationVisitor.visitAnnotation(elementName, readUTF8(currentOffset, charBuffer)), currentOffset + 2, true, charBuffer);\r\n            break;\r\n        case // array_value\r\n        '[':\r\n            int numValues = readUnsignedShort(currentOffset);\r\n            currentOffset += 2;\r\n            if (numValues == 0) {\r\n                return readElementValues(annotationVisitor.visitArray(elementName), currentOffset - 2, /* named= */\r\n                false, charBuffer);\r\n            }\r\n            switch(classFileBuffer[currentOffset] & 0xFF) {\r\n                case 'B':\r\n                    byte[] byteValues = new byte[numValues];\r\n                    for (int i = 0; i < numValues; i++) {\r\n                        byteValues[i] = (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\r\n                        currentOffset += 3;\r\n                    }\r\n                    annotationVisitor.visit(elementName, byteValues);\r\n                    break;\r\n                case 'Z':\r\n                    boolean[] booleanValues = new boolean[numValues];\r\n                    for (int i = 0; i < numValues; i++) {\r\n                        booleanValues[i] = readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]) != 0;\r\n                        currentOffset += 3;\r\n                    }\r\n                    annotationVisitor.visit(elementName, booleanValues);\r\n                    break;\r\n                case 'S':\r\n                    short[] shortValues = new short[numValues];\r\n                    for (int i = 0; i < numValues; i++) {\r\n                        shortValues[i] = (short) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\r\n                        currentOffset += 3;\r\n                    }\r\n                    annotationVisitor.visit(elementName, shortValues);\r\n                    break;\r\n                case 'C':\r\n                    char[] charValues = new char[numValues];\r\n                    for (int i = 0; i < numValues; i++) {\r\n                        charValues[i] = (char) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\r\n                        currentOffset += 3;\r\n                    }\r\n                    annotationVisitor.visit(elementName, charValues);\r\n                    break;\r\n                case 'I':\r\n                    int[] intValues = new int[numValues];\r\n                    for (int i = 0; i < numValues; i++) {\r\n                        intValues[i] = readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\r\n                        currentOffset += 3;\r\n                    }\r\n                    annotationVisitor.visit(elementName, intValues);\r\n                    break;\r\n                case 'J':\r\n                    long[] longValues = new long[numValues];\r\n                    for (int i = 0; i < numValues; i++) {\r\n                        longValues[i] = readLong(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\r\n                        currentOffset += 3;\r\n                    }\r\n                    annotationVisitor.visit(elementName, longValues);\r\n                    break;\r\n                case 'F':\r\n                    float[] floatValues = new float[numValues];\r\n                    for (int i = 0; i < numValues; i++) {\r\n                        floatValues[i] = Float.intBitsToFloat(readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]));\r\n                        currentOffset += 3;\r\n                    }\r\n                    annotationVisitor.visit(elementName, floatValues);\r\n                    break;\r\n                case 'D':\r\n                    double[] doubleValues = new double[numValues];\r\n                    for (int i = 0; i < numValues; i++) {\r\n                        doubleValues[i] = Double.longBitsToDouble(readLong(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]));\r\n                        currentOffset += 3;\r\n                    }\r\n                    annotationVisitor.visit(elementName, doubleValues);\r\n                    break;\r\n                default:\r\n                    currentOffset = readElementValues(annotationVisitor.visitArray(elementName), currentOffset - 2, /* named= */\r\n                    false, charBuffer);\r\n                    break;\r\n            }\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException();\r\n    }\r\n    return currentOffset;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ClassReader#readElementValue(AnnotationVisitor,int,String,char[])",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ClassReader#computeImplicitFrame(Context)",
    "headType": "method",
    "relation": "provide",
    "tail": "// ----------------------------------------------------------------------------------------------\r\n// Methods to parse stack map frames\r\n// ----------------------------------------------------------------------------------------------\r\n/**\r\n * Computes the implicit frame of the method currently being parsed (as defined in the given\r\n * {@link Context}) and stores it in the given context.\r\n *\r\n * @param context information about the class being parsed.\r\n */\r\nprivate void computeImplicitFrame(final Context context) {\r\n    String methodDescriptor = context.currentMethodDescriptor;\r\n    Object[] locals = context.currentFrameLocalTypes;\r\n    int numLocal = 0;\r\n    if ((context.currentMethodAccessFlags & Opcodes.ACC_STATIC) == 0) {\r\n        if (\"<init>\".equals(context.currentMethodName)) {\r\n            locals[numLocal++] = Opcodes.UNINITIALIZED_THIS;\r\n        } else {\r\n            locals[numLocal++] = readClass(header + 2, context.charBuffer);\r\n        }\r\n    }\r\n    // Parse the method descriptor, one argument type descriptor at each iteration. Start by\r\n    // skipping the first method descriptor character, which is always '('.\r\n    int currentMethodDescritorOffset = 1;\r\n    while (true) {\r\n        int currentArgumentDescriptorStartOffset = currentMethodDescritorOffset;\r\n        switch(methodDescriptor.charAt(currentMethodDescritorOffset++)) {\r\n            case 'Z':\r\n            case 'C':\r\n            case 'B':\r\n            case 'S':\r\n            case 'I':\r\n                locals[numLocal++] = Opcodes.INTEGER;\r\n                break;\r\n            case 'F':\r\n                locals[numLocal++] = Opcodes.FLOAT;\r\n                break;\r\n            case 'J':\r\n                locals[numLocal++] = Opcodes.LONG;\r\n                break;\r\n            case 'D':\r\n                locals[numLocal++] = Opcodes.DOUBLE;\r\n                break;\r\n            case '[':\r\n                while (methodDescriptor.charAt(currentMethodDescritorOffset) == '[') {\r\n                    ++currentMethodDescritorOffset;\r\n                }\r\n                if (methodDescriptor.charAt(currentMethodDescritorOffset) == 'L') {\r\n                    ++currentMethodDescritorOffset;\r\n                    while (methodDescriptor.charAt(currentMethodDescritorOffset) != ';') {\r\n                        ++currentMethodDescritorOffset;\r\n                    }\r\n                }\r\n                locals[numLocal++] = methodDescriptor.substring(currentArgumentDescriptorStartOffset, ++currentMethodDescritorOffset);\r\n                break;\r\n            case 'L':\r\n                while (methodDescriptor.charAt(currentMethodDescritorOffset) != ';') {\r\n                    ++currentMethodDescritorOffset;\r\n                }\r\n                locals[numLocal++] = methodDescriptor.substring(currentArgumentDescriptorStartOffset + 1, currentMethodDescritorOffset++);\r\n                break;\r\n            default:\r\n                context.currentFrameLocalCount = numLocal;\r\n                return;\r\n        }\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ClassReader#computeImplicitFrame(Context)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ClassReader#readStackMapFrame(int,boolean,boolean,Context)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Reads a JVMS 'stack_map_frame' structure and stores the result in the given {@link Context}\r\n * object. This method can also be used to read a full_frame structure, excluding its frame_type\r\n * field (this is used to parse the legacy StackMap attributes).\r\n *\r\n * @param stackMapFrameOffset the start offset in {@link #classFileBuffer} of the\r\n *     stack_map_frame_value structure to be read, or the start offset of a full_frame structure\r\n *     (excluding its frame_type field).\r\n * @param compressed true to read a 'stack_map_frame' structure, false to read a 'full_frame'\r\n *     structure without its frame_type field.\r\n * @param expand if the stack map frame must be expanded. See {@link #EXPAND_FRAMES}.\r\n * @param context where the parsed stack map frame must be stored.\r\n * @return the end offset of the JVMS 'stack_map_frame' or 'full_frame' structure.\r\n */\r\nprivate int readStackMapFrame(final int stackMapFrameOffset, final boolean compressed, final boolean expand, final Context context) {\r\n    int currentOffset = stackMapFrameOffset;\r\n    final char[] charBuffer = context.charBuffer;\r\n    final Label[] labels = context.currentMethodLabels;\r\n    int frameType;\r\n    if (compressed) {\r\n        // Read the frame_type field.\r\n        frameType = classFileBuffer[currentOffset++] & 0xFF;\r\n    } else {\r\n        frameType = Frame.FULL_FRAME;\r\n        context.currentFrameOffset = -1;\r\n    }\r\n    int offsetDelta;\r\n    context.currentFrameLocalCountDelta = 0;\r\n    if (frameType < Frame.SAME_LOCALS_1_STACK_ITEM_FRAME) {\r\n        offsetDelta = frameType;\r\n        context.currentFrameType = Opcodes.F_SAME;\r\n        context.currentFrameStackCount = 0;\r\n    } else if (frameType < Frame.RESERVED) {\r\n        offsetDelta = frameType - Frame.SAME_LOCALS_1_STACK_ITEM_FRAME;\r\n        currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameStackTypes, 0, charBuffer, labels);\r\n        context.currentFrameType = Opcodes.F_SAME1;\r\n        context.currentFrameStackCount = 1;\r\n    } else if (frameType >= Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\r\n        offsetDelta = readUnsignedShort(currentOffset);\r\n        currentOffset += 2;\r\n        if (frameType == Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\r\n            currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameStackTypes, 0, charBuffer, labels);\r\n            context.currentFrameType = Opcodes.F_SAME1;\r\n            context.currentFrameStackCount = 1;\r\n        } else if (frameType >= Frame.CHOP_FRAME && frameType < Frame.SAME_FRAME_EXTENDED) {\r\n            context.currentFrameType = Opcodes.F_CHOP;\r\n            context.currentFrameLocalCountDelta = Frame.SAME_FRAME_EXTENDED - frameType;\r\n            context.currentFrameLocalCount -= context.currentFrameLocalCountDelta;\r\n            context.currentFrameStackCount = 0;\r\n        } else if (frameType == Frame.SAME_FRAME_EXTENDED) {\r\n            context.currentFrameType = Opcodes.F_SAME;\r\n            context.currentFrameStackCount = 0;\r\n        } else if (frameType < Frame.FULL_FRAME) {\r\n            int local = expand ? context.currentFrameLocalCount : 0;\r\n            for (int k = frameType - Frame.SAME_FRAME_EXTENDED; k > 0; k--) {\r\n                currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameLocalTypes, local++, charBuffer, labels);\r\n            }\r\n            context.currentFrameType = Opcodes.F_APPEND;\r\n            context.currentFrameLocalCountDelta = frameType - Frame.SAME_FRAME_EXTENDED;\r\n            context.currentFrameLocalCount += context.currentFrameLocalCountDelta;\r\n            context.currentFrameStackCount = 0;\r\n        } else {\r\n            final int numberOfLocals = readUnsignedShort(currentOffset);\r\n            currentOffset += 2;\r\n            context.currentFrameType = Opcodes.F_FULL;\r\n            context.currentFrameLocalCountDelta = numberOfLocals;\r\n            context.currentFrameLocalCount = numberOfLocals;\r\n            for (int local = 0; local < numberOfLocals; ++local) {\r\n                currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameLocalTypes, local, charBuffer, labels);\r\n            }\r\n            final int numberOfStackItems = readUnsignedShort(currentOffset);\r\n            currentOffset += 2;\r\n            context.currentFrameStackCount = numberOfStackItems;\r\n            for (int stack = 0; stack < numberOfStackItems; ++stack) {\r\n                currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameStackTypes, stack, charBuffer, labels);\r\n            }\r\n        }\r\n    } else {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    context.currentFrameOffset += offsetDelta + 1;\r\n    createLabel(context.currentFrameOffset, labels);\r\n    return currentOffset;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ClassReader#readStackMapFrame(int,boolean,boolean,Context)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ClassReader#readVerificationTypeInfo(int,Object[],int,char[],Label[])",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Reads a JVMS 'verification_type_info' structure and stores it at the given index in the given\r\n * array.\r\n *\r\n * @param verificationTypeInfoOffset the start offset of the 'verification_type_info' structure to\r\n *     read.\r\n * @param frame the array where the parsed type must be stored.\r\n * @param index the index in 'frame' where the parsed type must be stored.\r\n * @param charBuffer the buffer used to read strings in the constant pool.\r\n * @param labels the labels of the method currently being parsed, indexed by their offset. If the\r\n *     parsed type is an ITEM_Uninitialized, a new label for the corresponding NEW instruction is\r\n *     stored in this array if it does not already exist.\r\n * @return the end offset of the JVMS 'verification_type_info' structure.\r\n */\r\nprivate int readVerificationTypeInfo(final int verificationTypeInfoOffset, final Object[] frame, final int index, final char[] charBuffer, final Label[] labels) {\r\n    int currentOffset = verificationTypeInfoOffset;\r\n    int tag = classFileBuffer[currentOffset++] & 0xFF;\r\n    switch(tag) {\r\n        case Frame.ITEM_TOP:\r\n            frame[index] = Opcodes.TOP;\r\n            break;\r\n        case Frame.ITEM_INTEGER:\r\n            frame[index] = Opcodes.INTEGER;\r\n            break;\r\n        case Frame.ITEM_FLOAT:\r\n            frame[index] = Opcodes.FLOAT;\r\n            break;\r\n        case Frame.ITEM_DOUBLE:\r\n            frame[index] = Opcodes.DOUBLE;\r\n            break;\r\n        case Frame.ITEM_LONG:\r\n            frame[index] = Opcodes.LONG;\r\n            break;\r\n        case Frame.ITEM_NULL:\r\n            frame[index] = Opcodes.NULL;\r\n            break;\r\n        case Frame.ITEM_UNINITIALIZED_THIS:\r\n            frame[index] = Opcodes.UNINITIALIZED_THIS;\r\n            break;\r\n        case Frame.ITEM_OBJECT:\r\n            frame[index] = readClass(currentOffset, charBuffer);\r\n            currentOffset += 2;\r\n            break;\r\n        case Frame.ITEM_UNINITIALIZED:\r\n            frame[index] = createLabel(readUnsignedShort(currentOffset), labels);\r\n            currentOffset += 2;\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException();\r\n    }\r\n    return currentOffset;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ClassReader#readVerificationTypeInfo(int,Object[],int,char[],Label[])",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ClassReader#getFirstAttributeOffset()",
    "headType": "method",
    "relation": "provide",
    "tail": "// ----------------------------------------------------------------------------------------------\r\n// Methods to parse attributes\r\n// ----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the offset in {@link #classFileBuffer} of the first ClassFile's 'attributes' array\r\n * field entry.\r\n *\r\n * @return the offset in {@link #classFileBuffer} of the first ClassFile's 'attributes' array\r\n *     field entry.\r\n */\r\nfinal int getFirstAttributeOffset() {\r\n    // Skip the access_flags, this_class, super_class, and interfaces_count fields (using 2 bytes\r\n    // each), as well as the interfaces array field (2 bytes per interface).\r\n    int currentOffset = header + 8 + readUnsignedShort(header + 6) * 2;\r\n    // Read the fields_count field.\r\n    int fieldsCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    // Skip the 'fields' array field.\r\n    while (fieldsCount-- > 0) {\r\n        // Invariant: currentOffset is the offset of a field_info structure.\r\n        // Skip the access_flags, name_index and descriptor_index fields (2 bytes each), and read the\r\n        // attributes_count field.\r\n        int attributesCount = readUnsignedShort(currentOffset + 6);\r\n        currentOffset += 8;\r\n        // Skip the 'attributes' array field.\r\n        while (attributesCount-- > 0) {\r\n            // Invariant: currentOffset is the offset of an attribute_info structure.\r\n            // Read the attribute_length field (2 bytes after the start of the attribute_info) and skip\r\n            // this many bytes, plus 6 for the attribute_name_index and attribute_length fields\r\n            // (yielding the total size of the attribute_info structure).\r\n            currentOffset += 6 + readInt(currentOffset + 2);\r\n        }\r\n    }\r\n    // Skip the methods_count and 'methods' fields, using the same method as above.\r\n    int methodsCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (methodsCount-- > 0) {\r\n        int attributesCount = readUnsignedShort(currentOffset + 6);\r\n        currentOffset += 8;\r\n        while (attributesCount-- > 0) {\r\n            currentOffset += 6 + readInt(currentOffset + 2);\r\n        }\r\n    }\r\n    // Skip the ClassFile's attributes_count field.\r\n    return currentOffset + 2;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ClassReader#getFirstAttributeOffset()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ClassReader#readBootstrapMethodsAttribute(int)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Reads the BootstrapMethods attribute to compute the offset of each bootstrap method.\r\n *\r\n * @param maxStringLength a conservative estimate of the maximum length of the strings contained\r\n *     in the constant pool of the class.\r\n * @return the offsets of the bootstrap methods.\r\n */\r\nprivate int[] readBootstrapMethodsAttribute(final int maxStringLength) {\r\n    char[] charBuffer = new char[maxStringLength];\r\n    int currentAttributeOffset = getFirstAttributeOffset();\r\n    for (int i = readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {\r\n        // Read the attribute_info's attribute_name and attribute_length fields.\r\n        String attributeName = readUTF8(currentAttributeOffset, charBuffer);\r\n        int attributeLength = readInt(currentAttributeOffset + 2);\r\n        currentAttributeOffset += 6;\r\n        if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\r\n            // Read the num_bootstrap_methods field and create an array of this size.\r\n            int[] result = new int[readUnsignedShort(currentAttributeOffset)];\r\n            // Compute and store the offset of each 'bootstrap_methods' array field entry.\r\n            int currentBootstrapMethodOffset = currentAttributeOffset + 2;\r\n            for (int j = 0; j < result.length; ++j) {\r\n                result[j] = currentBootstrapMethodOffset;\r\n                // Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),\r\n                // as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).\r\n                currentBootstrapMethodOffset += 4 + readUnsignedShort(currentBootstrapMethodOffset + 2) * 2;\r\n            }\r\n            return result;\r\n        }\r\n        currentAttributeOffset += attributeLength;\r\n    }\r\n    throw new IllegalArgumentException();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ClassReader#readBootstrapMethodsAttribute(int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ClassReader#readAttribute(Attribute[],String,int,int,char[],int,Label[])",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Reads a non standard JVMS 'attribute' structure in {@link #classFileBuffer}.\r\n *\r\n * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of\r\n *     the class. Any attribute whose type is not equal to the type of one the prototypes will not\r\n *     be parsed: its byte array value will be passed unchanged to the ClassWriter.\r\n * @param type the type of the attribute.\r\n * @param offset the start offset of the JVMS 'attribute' structure in {@link #classFileBuffer}.\r\n *     The 6 attribute header bytes (attribute_name_index and attribute_length) are not taken into\r\n *     account here.\r\n * @param length the length of the attribute's content (excluding the 6 attribute header bytes).\r\n * @param charBuffer the buffer to be used to read strings in the constant pool.\r\n * @param codeAttributeOffset the start offset of the enclosing Code attribute in {@link\r\n *     #classFileBuffer}, or -1 if the attribute to be read is not a code attribute. The 6\r\n *     attribute header bytes (attribute_name_index and attribute_length) are not taken into\r\n *     account here.\r\n * @param labels the labels of the method's code, or {@literal null} if the attribute to be read\r\n *     is not a code attribute.\r\n * @return the attribute that has been read.\r\n */\r\nprivate Attribute readAttribute(final Attribute[] attributePrototypes, final String type, final int offset, final int length, final char[] charBuffer, final int codeAttributeOffset, final Label[] labels) {\r\n    for (Attribute attributePrototype : attributePrototypes) {\r\n        if (attributePrototype.type.equals(type)) {\r\n            return attributePrototype.read(this, offset, length, charBuffer, codeAttributeOffset, labels);\r\n        }\r\n    }\r\n    return new Attribute(type).read(this, offset, length, null, -1, null);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ClassReader#readAttribute(Attribute[],String,int,int,char[],int,Label[])",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ClassReader#getItemCount()",
    "headType": "method",
    "relation": "provide",
    "tail": "// -----------------------------------------------------------------------------------------------\r\n// Utility methods: low level parsing\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the number of entries in the class's constant pool table.\r\n *\r\n * @return the number of entries in the class's constant pool table.\r\n */\r\npublic int getItemCount() {\r\n    return cpInfoOffsets.length;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ClassReader#getItemCount()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ClassReader#getItem(int)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Returns the start offset in this {@link ClassReader} of a JVMS 'cp_info' structure (i.e. a\r\n * constant pool entry), plus one. <i>This method is intended for {@link Attribute} sub classes,\r\n * and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param constantPoolEntryIndex the index a constant pool entry in the class's constant pool\r\n *     table.\r\n * @return the start offset in this {@link ClassReader} of the corresponding JVMS 'cp_info'\r\n *     structure, plus one.\r\n */\r\npublic int getItem(final int constantPoolEntryIndex) {\r\n    return cpInfoOffsets[constantPoolEntryIndex];\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ClassReader#getItem(int)",
    "tailType": "method"
  }
]