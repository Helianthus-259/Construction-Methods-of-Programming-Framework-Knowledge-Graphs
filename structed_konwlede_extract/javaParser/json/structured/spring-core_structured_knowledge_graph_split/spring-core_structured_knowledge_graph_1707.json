[
  {
    "head": "org.springframework.core.annotation.ComposedPlusLocalCachesClass",
    "headType": "class",
    "relation": "use",
    "tail": "@BarCache",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.ComposedPlusLocalCachesClass",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.MergedAnnotations.SearchStrategy;\nimport org.springframework.util.ReflectionUtils;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Unit tests that verify support for finding multiple composed annotations on a single\n * annotated element.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n */\nclass MergedAnnotationsComposedOnSingleAnnotatedElementTests {\n\n\t// See SPR-13486\n\n\t@Test\n\tvoid inheritedStrategyMultipleComposedAnnotationsOnClass() {\n\t\tassertInheritedStrategyBehavior(MultipleComposedCachesClass.class);\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleInheritedComposedAnnotationsOnSuperclass() {\n\t\tassertInheritedStrategyBehavior(SubMultipleComposedCachesClass.class);\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleNoninheritedComposedAnnotationsOnClass() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tMultipleNoninheritedComposedCachesClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS);\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"noninheritedCache1\",\n\t\t\t\t\"noninheritedCache2\");\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleNoninheritedComposedAnnotationsOnSuperclass() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tSubMultipleNoninheritedComposedCachesClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS);\n\t\tassertThat(annotations.stream(Cacheable.class)).isEmpty();\n\t}\n\n\t@Test\n\tvoid inheritedStrategyComposedPlusLocalAnnotationsOnClass() {\n\t\tassertInheritedStrategyBehavior(ComposedPlusLocalCachesClass.class);\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleComposedAnnotationsOnInterface() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tMultipleComposedCachesOnInterfaceClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS);\n\t\tassertThat(annotations.stream(Cacheable.class)).isEmpty();\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleComposedAnnotationsOnMethod() throws Exception {\n\t\tassertInheritedStrategyBehavior(\n\t\t\t\tgetClass().getDeclaredMethod(\"multipleComposedCachesMethod\"));\n\t}\n\n\t@Test\n\tvoid inheritedStrategyComposedPlusLocalAnnotationsOnMethod() throws Exception {\n\t\tassertInheritedStrategyBehavior(\n\t\t\t\tgetClass().getDeclaredMethod(\"composedPlusLocalCachesMethod\"));\n\t}\n\n\tprivate void assertInheritedStrategyBehavior(AnnotatedElement element) {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(element,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS);\n\t\tassertThat(stream(annotations, \"key\")).containsExactly(\"fooKey\", \"barKey\");\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"fooCache\", \"barCache\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleComposedAnnotationsOnClass() {\n\t\tassertTypeHierarchyStrategyBehavior(MultipleComposedCachesClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleInheritedComposedAnnotationsOnSuperclass() {\n\t\tassertTypeHierarchyStrategyBehavior(SubMultipleComposedCachesClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleNoninheritedComposedAnnotationsOnClass() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tMultipleNoninheritedComposedCachesClass.class, SearchStrategy.TYPE_HIERARCHY);\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"noninheritedCache1\",\n\t\t\t\t\"noninheritedCache2\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleNoninheritedComposedAnnotationsOnSuperclass() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tSubMultipleNoninheritedComposedCachesClass.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY);\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"noninheritedCache1\",\n\t\t\t\t\"noninheritedCache2\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyComposedPlusLocalAnnotationsOnClass() {\n\t\tassertTypeHierarchyStrategyBehavior(ComposedPlusLocalCachesClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleComposedAnnotationsOnInterface() {\n\t\tassertTypeHierarchyStrategyBehavior(MultipleComposedCachesOnInterfaceClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyComposedCacheOnInterfaceAndLocalCacheOnClass() {\n\t\tassertTypeHierarchyStrategyBehavior(\n\t\t\t\tComposedCacheOnInterfaceAndLocalCacheClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleComposedAnnotationsOnMethod() throws Exception {\n\t\tassertTypeHierarchyStrategyBehavior(\n\t\t\t\tgetClass().getDeclaredMethod(\"multipleComposedCachesMethod\"));\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyComposedPlusLocalAnnotationsOnMethod()\n\t\t\tthrows Exception {\n\t\tassertTypeHierarchyStrategyBehavior(\n\t\t\t\tgetClass().getDeclaredMethod(\"composedPlusLocalCachesMethod\"));\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleComposedAnnotationsOnBridgeMethod() {\n\t\tassertTypeHierarchyStrategyBehavior(getBridgeMethod());\n\t}\n\n\tprivate void assertTypeHierarchyStrategyBehavior(AnnotatedElement element) {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(element,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY);\n\t\tassertThat(stream(annotations, \"key\")).containsExactly(\"fooKey\", \"barKey\");\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"fooCache\", \"barCache\");\n\t}\n\n\tMethod getBridgeMethod() {\n\t\tList<Method> methods = new ArrayList<>();\n\t\tReflectionUtils.doWithLocalMethods(StringGenericParameter.class, method -> {\n\t\t\tif (\"getFor\".equals(method.getName())) {\n\t\t\t\tmethods.add(method);\n\t\t\t}\n\t\t});\n\t\tMethod bridgeMethod = methods.get(0).getReturnType() == Object.class ? methods.get(0) : methods.get(1);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\treturn bridgeMethod;\n\t}\n\n\tprivate Stream<String> stream(MergedAnnotations annotations, String attributeName) {\n\t\treturn annotations.stream(Cacheable.class).map(\n\t\t\t\tannotation -> annotation.getString(attributeName));\n\t}\n\n\t// @formatter:off\n\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Cacheable {\n\t\t@AliasFor(\"cacheName\")\n\t\tString value() default \"\";\n\t\t@AliasFor(\"value\")\n\t\tString cacheName() default \"\";\n\t\tString key() default \"\";\n\t}\n\n\t@Cacheable(\"fooCache\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface FooCache {\n\t\t@AliasFor(annotation = Cacheable.class)\n\t\tString key() default \"\";\n\t}\n\n\t@Cacheable(\"barCache\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface BarCache {\n\t\t@AliasFor(annotation = Cacheable.class)\n\t\tString key();\n\t}\n\n\t@Cacheable(\"noninheritedCache1\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface NoninheritedCache1 {\n\t\t@AliasFor(annotation = Cacheable.class)\n\t\tString key() default \"\";\n\t}\n\n\t@Cacheable(\"noninheritedCache2\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface NoninheritedCache2 {\n\t\t@AliasFor(annotation = Cacheable.class)\n\t\tString key() default \"\";\n\t}\n\n\t@FooCache(key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate static class MultipleComposedCachesClass {\n\t}\n\n\tprivate static class SubMultipleComposedCachesClass\n\t\t\textends MultipleComposedCachesClass {\n\t}\n\n\t@NoninheritedCache1\n\t@NoninheritedCache2\n\tprivate static class MultipleNoninheritedComposedCachesClass {\n\t}\n\n\tprivate static class SubMultipleNoninheritedComposedCachesClass\n\t\t\textends MultipleNoninheritedComposedCachesClass {\n\t}\n\n\t@Cacheable(cacheName = \"fooCache\", key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate static class ComposedPlusLocalCachesClass {\n\t}\n\n\t@FooCache(key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate interface MultipleComposedCachesInterface {\n\t}\n\n\tprivate static class MultipleComposedCachesOnInterfaceClass implements MultipleComposedCachesInterface {\n\t}\n\n\t@BarCache(key = \"barKey\")\n\tprivate interface ComposedCacheInterface {\n\t}\n\n\t@Cacheable(cacheName = \"fooCache\", key = \"fooKey\")\n\tprivate static class ComposedCacheOnInterfaceAndLocalCacheClass implements ComposedCacheInterface {\n\t}\n\n\t@FooCache(key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate void multipleComposedCachesMethod() {\n\t}\n\n\t@Cacheable(cacheName = \"fooCache\", key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate void composedPlusLocalCachesMethod() {\n\t}\n\n\tpublic interface GenericParameter<T> {\n\t\tT getFor(Class<T> cls);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class StringGenericParameter implements GenericParameter<String> {\n\t\t@FooCache(key = \"fooKey\")\n\t\t@BarCache(key = \"barKey\")\n\t\t@Override\n\t\tpublic String getFor(Class<String> cls) { return \"foo\"; }\n\t\tpublic String getFor(Integer integer) { return \"foo\"; }\n\t}\n\n\t// @formatter:on\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.MultipleComposedCachesInterface",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.MultipleComposedCachesInterface",
    "headType": "class",
    "relation": "use",
    "tail": "@FooCache",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.MultipleComposedCachesInterface",
    "headType": "class",
    "relation": "use",
    "tail": "@BarCache",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.MultipleComposedCachesInterface",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.MergedAnnotations.SearchStrategy;\nimport org.springframework.util.ReflectionUtils;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Unit tests that verify support for finding multiple composed annotations on a single\n * annotated element.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n */\nclass MergedAnnotationsComposedOnSingleAnnotatedElementTests {\n\n\t// See SPR-13486\n\n\t@Test\n\tvoid inheritedStrategyMultipleComposedAnnotationsOnClass() {\n\t\tassertInheritedStrategyBehavior(MultipleComposedCachesClass.class);\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleInheritedComposedAnnotationsOnSuperclass() {\n\t\tassertInheritedStrategyBehavior(SubMultipleComposedCachesClass.class);\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleNoninheritedComposedAnnotationsOnClass() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tMultipleNoninheritedComposedCachesClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS);\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"noninheritedCache1\",\n\t\t\t\t\"noninheritedCache2\");\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleNoninheritedComposedAnnotationsOnSuperclass() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tSubMultipleNoninheritedComposedCachesClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS);\n\t\tassertThat(annotations.stream(Cacheable.class)).isEmpty();\n\t}\n\n\t@Test\n\tvoid inheritedStrategyComposedPlusLocalAnnotationsOnClass() {\n\t\tassertInheritedStrategyBehavior(ComposedPlusLocalCachesClass.class);\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleComposedAnnotationsOnInterface() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tMultipleComposedCachesOnInterfaceClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS);\n\t\tassertThat(annotations.stream(Cacheable.class)).isEmpty();\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleComposedAnnotationsOnMethod() throws Exception {\n\t\tassertInheritedStrategyBehavior(\n\t\t\t\tgetClass().getDeclaredMethod(\"multipleComposedCachesMethod\"));\n\t}\n\n\t@Test\n\tvoid inheritedStrategyComposedPlusLocalAnnotationsOnMethod() throws Exception {\n\t\tassertInheritedStrategyBehavior(\n\t\t\t\tgetClass().getDeclaredMethod(\"composedPlusLocalCachesMethod\"));\n\t}\n\n\tprivate void assertInheritedStrategyBehavior(AnnotatedElement element) {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(element,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS);\n\t\tassertThat(stream(annotations, \"key\")).containsExactly(\"fooKey\", \"barKey\");\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"fooCache\", \"barCache\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleComposedAnnotationsOnClass() {\n\t\tassertTypeHierarchyStrategyBehavior(MultipleComposedCachesClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleInheritedComposedAnnotationsOnSuperclass() {\n\t\tassertTypeHierarchyStrategyBehavior(SubMultipleComposedCachesClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleNoninheritedComposedAnnotationsOnClass() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tMultipleNoninheritedComposedCachesClass.class, SearchStrategy.TYPE_HIERARCHY);\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"noninheritedCache1\",\n\t\t\t\t\"noninheritedCache2\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleNoninheritedComposedAnnotationsOnSuperclass() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tSubMultipleNoninheritedComposedCachesClass.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY);\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"noninheritedCache1\",\n\t\t\t\t\"noninheritedCache2\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyComposedPlusLocalAnnotationsOnClass() {\n\t\tassertTypeHierarchyStrategyBehavior(ComposedPlusLocalCachesClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleComposedAnnotationsOnInterface() {\n\t\tassertTypeHierarchyStrategyBehavior(MultipleComposedCachesOnInterfaceClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyComposedCacheOnInterfaceAndLocalCacheOnClass() {\n\t\tassertTypeHierarchyStrategyBehavior(\n\t\t\t\tComposedCacheOnInterfaceAndLocalCacheClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleComposedAnnotationsOnMethod() throws Exception {\n\t\tassertTypeHierarchyStrategyBehavior(\n\t\t\t\tgetClass().getDeclaredMethod(\"multipleComposedCachesMethod\"));\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyComposedPlusLocalAnnotationsOnMethod()\n\t\t\tthrows Exception {\n\t\tassertTypeHierarchyStrategyBehavior(\n\t\t\t\tgetClass().getDeclaredMethod(\"composedPlusLocalCachesMethod\"));\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleComposedAnnotationsOnBridgeMethod() {\n\t\tassertTypeHierarchyStrategyBehavior(getBridgeMethod());\n\t}\n\n\tprivate void assertTypeHierarchyStrategyBehavior(AnnotatedElement element) {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(element,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY);\n\t\tassertThat(stream(annotations, \"key\")).containsExactly(\"fooKey\", \"barKey\");\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"fooCache\", \"barCache\");\n\t}\n\n\tMethod getBridgeMethod() {\n\t\tList<Method> methods = new ArrayList<>();\n\t\tReflectionUtils.doWithLocalMethods(StringGenericParameter.class, method -> {\n\t\t\tif (\"getFor\".equals(method.getName())) {\n\t\t\t\tmethods.add(method);\n\t\t\t}\n\t\t});\n\t\tMethod bridgeMethod = methods.get(0).getReturnType() == Object.class ? methods.get(0) : methods.get(1);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\treturn bridgeMethod;\n\t}\n\n\tprivate Stream<String> stream(MergedAnnotations annotations, String attributeName) {\n\t\treturn annotations.stream(Cacheable.class).map(\n\t\t\t\tannotation -> annotation.getString(attributeName));\n\t}\n\n\t// @formatter:off\n\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Cacheable {\n\t\t@AliasFor(\"cacheName\")\n\t\tString value() default \"\";\n\t\t@AliasFor(\"value\")\n\t\tString cacheName() default \"\";\n\t\tString key() default \"\";\n\t}\n\n\t@Cacheable(\"fooCache\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface FooCache {\n\t\t@AliasFor(annotation = Cacheable.class)\n\t\tString key() default \"\";\n\t}\n\n\t@Cacheable(\"barCache\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface BarCache {\n\t\t@AliasFor(annotation = Cacheable.class)\n\t\tString key();\n\t}\n\n\t@Cacheable(\"noninheritedCache1\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface NoninheritedCache1 {\n\t\t@AliasFor(annotation = Cacheable.class)\n\t\tString key() default \"\";\n\t}\n\n\t@Cacheable(\"noninheritedCache2\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface NoninheritedCache2 {\n\t\t@AliasFor(annotation = Cacheable.class)\n\t\tString key() default \"\";\n\t}\n\n\t@FooCache(key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate static class MultipleComposedCachesClass {\n\t}\n\n\tprivate static class SubMultipleComposedCachesClass\n\t\t\textends MultipleComposedCachesClass {\n\t}\n\n\t@NoninheritedCache1\n\t@NoninheritedCache2\n\tprivate static class MultipleNoninheritedComposedCachesClass {\n\t}\n\n\tprivate static class SubMultipleNoninheritedComposedCachesClass\n\t\t\textends MultipleNoninheritedComposedCachesClass {\n\t}\n\n\t@Cacheable(cacheName = \"fooCache\", key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate static class ComposedPlusLocalCachesClass {\n\t}\n\n\t@FooCache(key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate interface MultipleComposedCachesInterface {\n\t}\n\n\tprivate static class MultipleComposedCachesOnInterfaceClass implements MultipleComposedCachesInterface {\n\t}\n\n\t@BarCache(key = \"barKey\")\n\tprivate interface ComposedCacheInterface {\n\t}\n\n\t@Cacheable(cacheName = \"fooCache\", key = \"fooKey\")\n\tprivate static class ComposedCacheOnInterfaceAndLocalCacheClass implements ComposedCacheInterface {\n\t}\n\n\t@FooCache(key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate void multipleComposedCachesMethod() {\n\t}\n\n\t@Cacheable(cacheName = \"fooCache\", key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate void composedPlusLocalCachesMethod() {\n\t}\n\n\tpublic interface GenericParameter<T> {\n\t\tT getFor(Class<T> cls);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class StringGenericParameter implements GenericParameter<String> {\n\t\t@FooCache(key = \"fooKey\")\n\t\t@BarCache(key = \"barKey\")\n\t\t@Override\n\t\tpublic String getFor(Class<String> cls) { return \"foo\"; }\n\t\tpublic String getFor(Integer integer) { return \"foo\"; }\n\t}\n\n\t// @formatter:on\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.MultipleComposedCachesOnInterfaceClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.MultipleComposedCachesOnInterfaceClass",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.MergedAnnotations.SearchStrategy;\nimport org.springframework.util.ReflectionUtils;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Unit tests that verify support for finding multiple composed annotations on a single\n * annotated element.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n */\nclass MergedAnnotationsComposedOnSingleAnnotatedElementTests {\n\n\t// See SPR-13486\n\n\t@Test\n\tvoid inheritedStrategyMultipleComposedAnnotationsOnClass() {\n\t\tassertInheritedStrategyBehavior(MultipleComposedCachesClass.class);\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleInheritedComposedAnnotationsOnSuperclass() {\n\t\tassertInheritedStrategyBehavior(SubMultipleComposedCachesClass.class);\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleNoninheritedComposedAnnotationsOnClass() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tMultipleNoninheritedComposedCachesClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS);\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"noninheritedCache1\",\n\t\t\t\t\"noninheritedCache2\");\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleNoninheritedComposedAnnotationsOnSuperclass() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tSubMultipleNoninheritedComposedCachesClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS);\n\t\tassertThat(annotations.stream(Cacheable.class)).isEmpty();\n\t}\n\n\t@Test\n\tvoid inheritedStrategyComposedPlusLocalAnnotationsOnClass() {\n\t\tassertInheritedStrategyBehavior(ComposedPlusLocalCachesClass.class);\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleComposedAnnotationsOnInterface() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tMultipleComposedCachesOnInterfaceClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS);\n\t\tassertThat(annotations.stream(Cacheable.class)).isEmpty();\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleComposedAnnotationsOnMethod() throws Exception {\n\t\tassertInheritedStrategyBehavior(\n\t\t\t\tgetClass().getDeclaredMethod(\"multipleComposedCachesMethod\"));\n\t}\n\n\t@Test\n\tvoid inheritedStrategyComposedPlusLocalAnnotationsOnMethod() throws Exception {\n\t\tassertInheritedStrategyBehavior(\n\t\t\t\tgetClass().getDeclaredMethod(\"composedPlusLocalCachesMethod\"));\n\t}\n\n\tprivate void assertInheritedStrategyBehavior(AnnotatedElement element) {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(element,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS);\n\t\tassertThat(stream(annotations, \"key\")).containsExactly(\"fooKey\", \"barKey\");\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"fooCache\", \"barCache\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleComposedAnnotationsOnClass() {\n\t\tassertTypeHierarchyStrategyBehavior(MultipleComposedCachesClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleInheritedComposedAnnotationsOnSuperclass() {\n\t\tassertTypeHierarchyStrategyBehavior(SubMultipleComposedCachesClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleNoninheritedComposedAnnotationsOnClass() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tMultipleNoninheritedComposedCachesClass.class, SearchStrategy.TYPE_HIERARCHY);\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"noninheritedCache1\",\n\t\t\t\t\"noninheritedCache2\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleNoninheritedComposedAnnotationsOnSuperclass() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tSubMultipleNoninheritedComposedCachesClass.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY);\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"noninheritedCache1\",\n\t\t\t\t\"noninheritedCache2\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyComposedPlusLocalAnnotationsOnClass() {\n\t\tassertTypeHierarchyStrategyBehavior(ComposedPlusLocalCachesClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleComposedAnnotationsOnInterface() {\n\t\tassertTypeHierarchyStrategyBehavior(MultipleComposedCachesOnInterfaceClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyComposedCacheOnInterfaceAndLocalCacheOnClass() {\n\t\tassertTypeHierarchyStrategyBehavior(\n\t\t\t\tComposedCacheOnInterfaceAndLocalCacheClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleComposedAnnotationsOnMethod() throws Exception {\n\t\tassertTypeHierarchyStrategyBehavior(\n\t\t\t\tgetClass().getDeclaredMethod(\"multipleComposedCachesMethod\"));\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyComposedPlusLocalAnnotationsOnMethod()\n\t\t\tthrows Exception {\n\t\tassertTypeHierarchyStrategyBehavior(\n\t\t\t\tgetClass().getDeclaredMethod(\"composedPlusLocalCachesMethod\"));\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleComposedAnnotationsOnBridgeMethod() {\n\t\tassertTypeHierarchyStrategyBehavior(getBridgeMethod());\n\t}\n\n\tprivate void assertTypeHierarchyStrategyBehavior(AnnotatedElement element) {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(element,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY);\n\t\tassertThat(stream(annotations, \"key\")).containsExactly(\"fooKey\", \"barKey\");\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"fooCache\", \"barCache\");\n\t}\n\n\tMethod getBridgeMethod() {\n\t\tList<Method> methods = new ArrayList<>();\n\t\tReflectionUtils.doWithLocalMethods(StringGenericParameter.class, method -> {\n\t\t\tif (\"getFor\".equals(method.getName())) {\n\t\t\t\tmethods.add(method);\n\t\t\t}\n\t\t});\n\t\tMethod bridgeMethod = methods.get(0).getReturnType() == Object.class ? methods.get(0) : methods.get(1);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\treturn bridgeMethod;\n\t}\n\n\tprivate Stream<String> stream(MergedAnnotations annotations, String attributeName) {\n\t\treturn annotations.stream(Cacheable.class).map(\n\t\t\t\tannotation -> annotation.getString(attributeName));\n\t}\n\n\t// @formatter:off\n\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Cacheable {\n\t\t@AliasFor(\"cacheName\")\n\t\tString value() default \"\";\n\t\t@AliasFor(\"value\")\n\t\tString cacheName() default \"\";\n\t\tString key() default \"\";\n\t}\n\n\t@Cacheable(\"fooCache\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface FooCache {\n\t\t@AliasFor(annotation = Cacheable.class)\n\t\tString key() default \"\";\n\t}\n\n\t@Cacheable(\"barCache\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface BarCache {\n\t\t@AliasFor(annotation = Cacheable.class)\n\t\tString key();\n\t}\n\n\t@Cacheable(\"noninheritedCache1\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface NoninheritedCache1 {\n\t\t@AliasFor(annotation = Cacheable.class)\n\t\tString key() default \"\";\n\t}\n\n\t@Cacheable(\"noninheritedCache2\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface NoninheritedCache2 {\n\t\t@AliasFor(annotation = Cacheable.class)\n\t\tString key() default \"\";\n\t}\n\n\t@FooCache(key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate static class MultipleComposedCachesClass {\n\t}\n\n\tprivate static class SubMultipleComposedCachesClass\n\t\t\textends MultipleComposedCachesClass {\n\t}\n\n\t@NoninheritedCache1\n\t@NoninheritedCache2\n\tprivate static class MultipleNoninheritedComposedCachesClass {\n\t}\n\n\tprivate static class SubMultipleNoninheritedComposedCachesClass\n\t\t\textends MultipleNoninheritedComposedCachesClass {\n\t}\n\n\t@Cacheable(cacheName = \"fooCache\", key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate static class ComposedPlusLocalCachesClass {\n\t}\n\n\t@FooCache(key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate interface MultipleComposedCachesInterface {\n\t}\n\n\tprivate static class MultipleComposedCachesOnInterfaceClass implements MultipleComposedCachesInterface {\n\t}\n\n\t@BarCache(key = \"barKey\")\n\tprivate interface ComposedCacheInterface {\n\t}\n\n\t@Cacheable(cacheName = \"fooCache\", key = \"fooKey\")\n\tprivate static class ComposedCacheOnInterfaceAndLocalCacheClass implements ComposedCacheInterface {\n\t}\n\n\t@FooCache(key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate void multipleComposedCachesMethod() {\n\t}\n\n\t@Cacheable(cacheName = \"fooCache\", key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate void composedPlusLocalCachesMethod() {\n\t}\n\n\tpublic interface GenericParameter<T> {\n\t\tT getFor(Class<T> cls);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class StringGenericParameter implements GenericParameter<String> {\n\t\t@FooCache(key = \"fooKey\")\n\t\t@BarCache(key = \"barKey\")\n\t\t@Override\n\t\tpublic String getFor(Class<String> cls) { return \"foo\"; }\n\t\tpublic String getFor(Integer integer) { return \"foo\"; }\n\t}\n\n\t// @formatter:on\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.ComposedCacheInterface",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.ComposedCacheInterface",
    "headType": "class",
    "relation": "use",
    "tail": "@BarCache",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.ComposedCacheInterface",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.MergedAnnotations.SearchStrategy;\nimport org.springframework.util.ReflectionUtils;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Unit tests that verify support for finding multiple composed annotations on a single\n * annotated element.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n */\nclass MergedAnnotationsComposedOnSingleAnnotatedElementTests {\n\n\t// See SPR-13486\n\n\t@Test\n\tvoid inheritedStrategyMultipleComposedAnnotationsOnClass() {\n\t\tassertInheritedStrategyBehavior(MultipleComposedCachesClass.class);\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleInheritedComposedAnnotationsOnSuperclass() {\n\t\tassertInheritedStrategyBehavior(SubMultipleComposedCachesClass.class);\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleNoninheritedComposedAnnotationsOnClass() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tMultipleNoninheritedComposedCachesClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS);\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"noninheritedCache1\",\n\t\t\t\t\"noninheritedCache2\");\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleNoninheritedComposedAnnotationsOnSuperclass() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tSubMultipleNoninheritedComposedCachesClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS);\n\t\tassertThat(annotations.stream(Cacheable.class)).isEmpty();\n\t}\n\n\t@Test\n\tvoid inheritedStrategyComposedPlusLocalAnnotationsOnClass() {\n\t\tassertInheritedStrategyBehavior(ComposedPlusLocalCachesClass.class);\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleComposedAnnotationsOnInterface() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tMultipleComposedCachesOnInterfaceClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS);\n\t\tassertThat(annotations.stream(Cacheable.class)).isEmpty();\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleComposedAnnotationsOnMethod() throws Exception {\n\t\tassertInheritedStrategyBehavior(\n\t\t\t\tgetClass().getDeclaredMethod(\"multipleComposedCachesMethod\"));\n\t}\n\n\t@Test\n\tvoid inheritedStrategyComposedPlusLocalAnnotationsOnMethod() throws Exception {\n\t\tassertInheritedStrategyBehavior(\n\t\t\t\tgetClass().getDeclaredMethod(\"composedPlusLocalCachesMethod\"));\n\t}\n\n\tprivate void assertInheritedStrategyBehavior(AnnotatedElement element) {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(element,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS);\n\t\tassertThat(stream(annotations, \"key\")).containsExactly(\"fooKey\", \"barKey\");\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"fooCache\", \"barCache\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleComposedAnnotationsOnClass() {\n\t\tassertTypeHierarchyStrategyBehavior(MultipleComposedCachesClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleInheritedComposedAnnotationsOnSuperclass() {\n\t\tassertTypeHierarchyStrategyBehavior(SubMultipleComposedCachesClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleNoninheritedComposedAnnotationsOnClass() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tMultipleNoninheritedComposedCachesClass.class, SearchStrategy.TYPE_HIERARCHY);\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"noninheritedCache1\",\n\t\t\t\t\"noninheritedCache2\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleNoninheritedComposedAnnotationsOnSuperclass() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tSubMultipleNoninheritedComposedCachesClass.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY);\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"noninheritedCache1\",\n\t\t\t\t\"noninheritedCache2\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyComposedPlusLocalAnnotationsOnClass() {\n\t\tassertTypeHierarchyStrategyBehavior(ComposedPlusLocalCachesClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleComposedAnnotationsOnInterface() {\n\t\tassertTypeHierarchyStrategyBehavior(MultipleComposedCachesOnInterfaceClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyComposedCacheOnInterfaceAndLocalCacheOnClass() {\n\t\tassertTypeHierarchyStrategyBehavior(\n\t\t\t\tComposedCacheOnInterfaceAndLocalCacheClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleComposedAnnotationsOnMethod() throws Exception {\n\t\tassertTypeHierarchyStrategyBehavior(\n\t\t\t\tgetClass().getDeclaredMethod(\"multipleComposedCachesMethod\"));\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyComposedPlusLocalAnnotationsOnMethod()\n\t\t\tthrows Exception {\n\t\tassertTypeHierarchyStrategyBehavior(\n\t\t\t\tgetClass().getDeclaredMethod(\"composedPlusLocalCachesMethod\"));\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleComposedAnnotationsOnBridgeMethod() {\n\t\tassertTypeHierarchyStrategyBehavior(getBridgeMethod());\n\t}\n\n\tprivate void assertTypeHierarchyStrategyBehavior(AnnotatedElement element) {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(element,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY);\n\t\tassertThat(stream(annotations, \"key\")).containsExactly(\"fooKey\", \"barKey\");\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"fooCache\", \"barCache\");\n\t}\n\n\tMethod getBridgeMethod() {\n\t\tList<Method> methods = new ArrayList<>();\n\t\tReflectionUtils.doWithLocalMethods(StringGenericParameter.class, method -> {\n\t\t\tif (\"getFor\".equals(method.getName())) {\n\t\t\t\tmethods.add(method);\n\t\t\t}\n\t\t});\n\t\tMethod bridgeMethod = methods.get(0).getReturnType() == Object.class ? methods.get(0) : methods.get(1);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\treturn bridgeMethod;\n\t}\n\n\tprivate Stream<String> stream(MergedAnnotations annotations, String attributeName) {\n\t\treturn annotations.stream(Cacheable.class).map(\n\t\t\t\tannotation -> annotation.getString(attributeName));\n\t}\n\n\t// @formatter:off\n\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Cacheable {\n\t\t@AliasFor(\"cacheName\")\n\t\tString value() default \"\";\n\t\t@AliasFor(\"value\")\n\t\tString cacheName() default \"\";\n\t\tString key() default \"\";\n\t}\n\n\t@Cacheable(\"fooCache\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface FooCache {\n\t\t@AliasFor(annotation = Cacheable.class)\n\t\tString key() default \"\";\n\t}\n\n\t@Cacheable(\"barCache\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface BarCache {\n\t\t@AliasFor(annotation = Cacheable.class)\n\t\tString key();\n\t}\n\n\t@Cacheable(\"noninheritedCache1\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface NoninheritedCache1 {\n\t\t@AliasFor(annotation = Cacheable.class)\n\t\tString key() default \"\";\n\t}\n\n\t@Cacheable(\"noninheritedCache2\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface NoninheritedCache2 {\n\t\t@AliasFor(annotation = Cacheable.class)\n\t\tString key() default \"\";\n\t}\n\n\t@FooCache(key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate static class MultipleComposedCachesClass {\n\t}\n\n\tprivate static class SubMultipleComposedCachesClass\n\t\t\textends MultipleComposedCachesClass {\n\t}\n\n\t@NoninheritedCache1\n\t@NoninheritedCache2\n\tprivate static class MultipleNoninheritedComposedCachesClass {\n\t}\n\n\tprivate static class SubMultipleNoninheritedComposedCachesClass\n\t\t\textends MultipleNoninheritedComposedCachesClass {\n\t}\n\n\t@Cacheable(cacheName = \"fooCache\", key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate static class ComposedPlusLocalCachesClass {\n\t}\n\n\t@FooCache(key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate interface MultipleComposedCachesInterface {\n\t}\n\n\tprivate static class MultipleComposedCachesOnInterfaceClass implements MultipleComposedCachesInterface {\n\t}\n\n\t@BarCache(key = \"barKey\")\n\tprivate interface ComposedCacheInterface {\n\t}\n\n\t@Cacheable(cacheName = \"fooCache\", key = \"fooKey\")\n\tprivate static class ComposedCacheOnInterfaceAndLocalCacheClass implements ComposedCacheInterface {\n\t}\n\n\t@FooCache(key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate void multipleComposedCachesMethod() {\n\t}\n\n\t@Cacheable(cacheName = \"fooCache\", key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate void composedPlusLocalCachesMethod() {\n\t}\n\n\tpublic interface GenericParameter<T> {\n\t\tT getFor(Class<T> cls);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class StringGenericParameter implements GenericParameter<String> {\n\t\t@FooCache(key = \"fooKey\")\n\t\t@BarCache(key = \"barKey\")\n\t\t@Override\n\t\tpublic String getFor(Class<String> cls) { return \"foo\"; }\n\t\tpublic String getFor(Integer integer) { return \"foo\"; }\n\t}\n\n\t// @formatter:on\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.ComposedCacheOnInterfaceAndLocalCacheClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.ComposedCacheOnInterfaceAndLocalCacheClass",
    "headType": "class",
    "relation": "use",
    "tail": "@Cacheable",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.ComposedCacheOnInterfaceAndLocalCacheClass",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.MergedAnnotations.SearchStrategy;\nimport org.springframework.util.ReflectionUtils;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Unit tests that verify support for finding multiple composed annotations on a single\n * annotated element.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n */\nclass MergedAnnotationsComposedOnSingleAnnotatedElementTests {\n\n\t// See SPR-13486\n\n\t@Test\n\tvoid inheritedStrategyMultipleComposedAnnotationsOnClass() {\n\t\tassertInheritedStrategyBehavior(MultipleComposedCachesClass.class);\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleInheritedComposedAnnotationsOnSuperclass() {\n\t\tassertInheritedStrategyBehavior(SubMultipleComposedCachesClass.class);\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleNoninheritedComposedAnnotationsOnClass() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tMultipleNoninheritedComposedCachesClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS);\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"noninheritedCache1\",\n\t\t\t\t\"noninheritedCache2\");\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleNoninheritedComposedAnnotationsOnSuperclass() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tSubMultipleNoninheritedComposedCachesClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS);\n\t\tassertThat(annotations.stream(Cacheable.class)).isEmpty();\n\t}\n\n\t@Test\n\tvoid inheritedStrategyComposedPlusLocalAnnotationsOnClass() {\n\t\tassertInheritedStrategyBehavior(ComposedPlusLocalCachesClass.class);\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleComposedAnnotationsOnInterface() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tMultipleComposedCachesOnInterfaceClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS);\n\t\tassertThat(annotations.stream(Cacheable.class)).isEmpty();\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleComposedAnnotationsOnMethod() throws Exception {\n\t\tassertInheritedStrategyBehavior(\n\t\t\t\tgetClass().getDeclaredMethod(\"multipleComposedCachesMethod\"));\n\t}\n\n\t@Test\n\tvoid inheritedStrategyComposedPlusLocalAnnotationsOnMethod() throws Exception {\n\t\tassertInheritedStrategyBehavior(\n\t\t\t\tgetClass().getDeclaredMethod(\"composedPlusLocalCachesMethod\"));\n\t}\n\n\tprivate void assertInheritedStrategyBehavior(AnnotatedElement element) {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(element,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS);\n\t\tassertThat(stream(annotations, \"key\")).containsExactly(\"fooKey\", \"barKey\");\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"fooCache\", \"barCache\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleComposedAnnotationsOnClass() {\n\t\tassertTypeHierarchyStrategyBehavior(MultipleComposedCachesClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleInheritedComposedAnnotationsOnSuperclass() {\n\t\tassertTypeHierarchyStrategyBehavior(SubMultipleComposedCachesClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleNoninheritedComposedAnnotationsOnClass() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tMultipleNoninheritedComposedCachesClass.class, SearchStrategy.TYPE_HIERARCHY);\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"noninheritedCache1\",\n\t\t\t\t\"noninheritedCache2\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleNoninheritedComposedAnnotationsOnSuperclass() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tSubMultipleNoninheritedComposedCachesClass.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY);\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"noninheritedCache1\",\n\t\t\t\t\"noninheritedCache2\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyComposedPlusLocalAnnotationsOnClass() {\n\t\tassertTypeHierarchyStrategyBehavior(ComposedPlusLocalCachesClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleComposedAnnotationsOnInterface() {\n\t\tassertTypeHierarchyStrategyBehavior(MultipleComposedCachesOnInterfaceClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyComposedCacheOnInterfaceAndLocalCacheOnClass() {\n\t\tassertTypeHierarchyStrategyBehavior(\n\t\t\t\tComposedCacheOnInterfaceAndLocalCacheClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleComposedAnnotationsOnMethod() throws Exception {\n\t\tassertTypeHierarchyStrategyBehavior(\n\t\t\t\tgetClass().getDeclaredMethod(\"multipleComposedCachesMethod\"));\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyComposedPlusLocalAnnotationsOnMethod()\n\t\t\tthrows Exception {\n\t\tassertTypeHierarchyStrategyBehavior(\n\t\t\t\tgetClass().getDeclaredMethod(\"composedPlusLocalCachesMethod\"));\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleComposedAnnotationsOnBridgeMethod() {\n\t\tassertTypeHierarchyStrategyBehavior(getBridgeMethod());\n\t}\n\n\tprivate void assertTypeHierarchyStrategyBehavior(AnnotatedElement element) {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(element,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY);\n\t\tassertThat(stream(annotations, \"key\")).containsExactly(\"fooKey\", \"barKey\");\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"fooCache\", \"barCache\");\n\t}\n\n\tMethod getBridgeMethod() {\n\t\tList<Method> methods = new ArrayList<>();\n\t\tReflectionUtils.doWithLocalMethods(StringGenericParameter.class, method -> {\n\t\t\tif (\"getFor\".equals(method.getName())) {\n\t\t\t\tmethods.add(method);\n\t\t\t}\n\t\t});\n\t\tMethod bridgeMethod = methods.get(0).getReturnType() == Object.class ? methods.get(0) : methods.get(1);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\treturn bridgeMethod;\n\t}\n\n\tprivate Stream<String> stream(MergedAnnotations annotations, String attributeName) {\n\t\treturn annotations.stream(Cacheable.class).map(\n\t\t\t\tannotation -> annotation.getString(attributeName));\n\t}\n\n\t// @formatter:off\n\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Cacheable {\n\t\t@AliasFor(\"cacheName\")\n\t\tString value() default \"\";\n\t\t@AliasFor(\"value\")\n\t\tString cacheName() default \"\";\n\t\tString key() default \"\";\n\t}\n\n\t@Cacheable(\"fooCache\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface FooCache {\n\t\t@AliasFor(annotation = Cacheable.class)\n\t\tString key() default \"\";\n\t}\n\n\t@Cacheable(\"barCache\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface BarCache {\n\t\t@AliasFor(annotation = Cacheable.class)\n\t\tString key();\n\t}\n\n\t@Cacheable(\"noninheritedCache1\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface NoninheritedCache1 {\n\t\t@AliasFor(annotation = Cacheable.class)\n\t\tString key() default \"\";\n\t}\n\n\t@Cacheable(\"noninheritedCache2\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface NoninheritedCache2 {\n\t\t@AliasFor(annotation = Cacheable.class)\n\t\tString key() default \"\";\n\t}\n\n\t@FooCache(key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate static class MultipleComposedCachesClass {\n\t}\n\n\tprivate static class SubMultipleComposedCachesClass\n\t\t\textends MultipleComposedCachesClass {\n\t}\n\n\t@NoninheritedCache1\n\t@NoninheritedCache2\n\tprivate static class MultipleNoninheritedComposedCachesClass {\n\t}\n\n\tprivate static class SubMultipleNoninheritedComposedCachesClass\n\t\t\textends MultipleNoninheritedComposedCachesClass {\n\t}\n\n\t@Cacheable(cacheName = \"fooCache\", key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate static class ComposedPlusLocalCachesClass {\n\t}\n\n\t@FooCache(key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate interface MultipleComposedCachesInterface {\n\t}\n\n\tprivate static class MultipleComposedCachesOnInterfaceClass implements MultipleComposedCachesInterface {\n\t}\n\n\t@BarCache(key = \"barKey\")\n\tprivate interface ComposedCacheInterface {\n\t}\n\n\t@Cacheable(cacheName = \"fooCache\", key = \"fooKey\")\n\tprivate static class ComposedCacheOnInterfaceAndLocalCacheClass implements ComposedCacheInterface {\n\t}\n\n\t@FooCache(key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate void multipleComposedCachesMethod() {\n\t}\n\n\t@Cacheable(cacheName = \"fooCache\", key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate void composedPlusLocalCachesMethod() {\n\t}\n\n\tpublic interface GenericParameter<T> {\n\t\tT getFor(Class<T> cls);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class StringGenericParameter implements GenericParameter<String> {\n\t\t@FooCache(key = \"fooKey\")\n\t\t@BarCache(key = \"barKey\")\n\t\t@Override\n\t\tpublic String getFor(Class<String> cls) { return \"foo\"; }\n\t\tpublic String getFor(Integer integer) { return \"foo\"; }\n\t}\n\n\t// @formatter:on\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.GenericParameter",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.GenericParameter",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.MergedAnnotations.SearchStrategy;\nimport org.springframework.util.ReflectionUtils;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Unit tests that verify support for finding multiple composed annotations on a single\n * annotated element.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n */\nclass MergedAnnotationsComposedOnSingleAnnotatedElementTests {\n\n\t// See SPR-13486\n\n\t@Test\n\tvoid inheritedStrategyMultipleComposedAnnotationsOnClass() {\n\t\tassertInheritedStrategyBehavior(MultipleComposedCachesClass.class);\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleInheritedComposedAnnotationsOnSuperclass() {\n\t\tassertInheritedStrategyBehavior(SubMultipleComposedCachesClass.class);\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleNoninheritedComposedAnnotationsOnClass() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tMultipleNoninheritedComposedCachesClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS);\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"noninheritedCache1\",\n\t\t\t\t\"noninheritedCache2\");\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleNoninheritedComposedAnnotationsOnSuperclass() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tSubMultipleNoninheritedComposedCachesClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS);\n\t\tassertThat(annotations.stream(Cacheable.class)).isEmpty();\n\t}\n\n\t@Test\n\tvoid inheritedStrategyComposedPlusLocalAnnotationsOnClass() {\n\t\tassertInheritedStrategyBehavior(ComposedPlusLocalCachesClass.class);\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleComposedAnnotationsOnInterface() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tMultipleComposedCachesOnInterfaceClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS);\n\t\tassertThat(annotations.stream(Cacheable.class)).isEmpty();\n\t}\n\n\t@Test\n\tvoid inheritedStrategyMultipleComposedAnnotationsOnMethod() throws Exception {\n\t\tassertInheritedStrategyBehavior(\n\t\t\t\tgetClass().getDeclaredMethod(\"multipleComposedCachesMethod\"));\n\t}\n\n\t@Test\n\tvoid inheritedStrategyComposedPlusLocalAnnotationsOnMethod() throws Exception {\n\t\tassertInheritedStrategyBehavior(\n\t\t\t\tgetClass().getDeclaredMethod(\"composedPlusLocalCachesMethod\"));\n\t}\n\n\tprivate void assertInheritedStrategyBehavior(AnnotatedElement element) {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(element,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS);\n\t\tassertThat(stream(annotations, \"key\")).containsExactly(\"fooKey\", \"barKey\");\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"fooCache\", \"barCache\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleComposedAnnotationsOnClass() {\n\t\tassertTypeHierarchyStrategyBehavior(MultipleComposedCachesClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleInheritedComposedAnnotationsOnSuperclass() {\n\t\tassertTypeHierarchyStrategyBehavior(SubMultipleComposedCachesClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleNoninheritedComposedAnnotationsOnClass() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tMultipleNoninheritedComposedCachesClass.class, SearchStrategy.TYPE_HIERARCHY);\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"noninheritedCache1\",\n\t\t\t\t\"noninheritedCache2\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleNoninheritedComposedAnnotationsOnSuperclass() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tSubMultipleNoninheritedComposedCachesClass.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY);\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"noninheritedCache1\",\n\t\t\t\t\"noninheritedCache2\");\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyComposedPlusLocalAnnotationsOnClass() {\n\t\tassertTypeHierarchyStrategyBehavior(ComposedPlusLocalCachesClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleComposedAnnotationsOnInterface() {\n\t\tassertTypeHierarchyStrategyBehavior(MultipleComposedCachesOnInterfaceClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyComposedCacheOnInterfaceAndLocalCacheOnClass() {\n\t\tassertTypeHierarchyStrategyBehavior(\n\t\t\t\tComposedCacheOnInterfaceAndLocalCacheClass.class);\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleComposedAnnotationsOnMethod() throws Exception {\n\t\tassertTypeHierarchyStrategyBehavior(\n\t\t\t\tgetClass().getDeclaredMethod(\"multipleComposedCachesMethod\"));\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyComposedPlusLocalAnnotationsOnMethod()\n\t\t\tthrows Exception {\n\t\tassertTypeHierarchyStrategyBehavior(\n\t\t\t\tgetClass().getDeclaredMethod(\"composedPlusLocalCachesMethod\"));\n\t}\n\n\t@Test\n\tvoid typeHierarchyStrategyMultipleComposedAnnotationsOnBridgeMethod() {\n\t\tassertTypeHierarchyStrategyBehavior(getBridgeMethod());\n\t}\n\n\tprivate void assertTypeHierarchyStrategyBehavior(AnnotatedElement element) {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(element,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY);\n\t\tassertThat(stream(annotations, \"key\")).containsExactly(\"fooKey\", \"barKey\");\n\t\tassertThat(stream(annotations, \"value\")).containsExactly(\"fooCache\", \"barCache\");\n\t}\n\n\tMethod getBridgeMethod() {\n\t\tList<Method> methods = new ArrayList<>();\n\t\tReflectionUtils.doWithLocalMethods(StringGenericParameter.class, method -> {\n\t\t\tif (\"getFor\".equals(method.getName())) {\n\t\t\t\tmethods.add(method);\n\t\t\t}\n\t\t});\n\t\tMethod bridgeMethod = methods.get(0).getReturnType() == Object.class ? methods.get(0) : methods.get(1);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\treturn bridgeMethod;\n\t}\n\n\tprivate Stream<String> stream(MergedAnnotations annotations, String attributeName) {\n\t\treturn annotations.stream(Cacheable.class).map(\n\t\t\t\tannotation -> annotation.getString(attributeName));\n\t}\n\n\t// @formatter:off\n\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Cacheable {\n\t\t@AliasFor(\"cacheName\")\n\t\tString value() default \"\";\n\t\t@AliasFor(\"value\")\n\t\tString cacheName() default \"\";\n\t\tString key() default \"\";\n\t}\n\n\t@Cacheable(\"fooCache\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface FooCache {\n\t\t@AliasFor(annotation = Cacheable.class)\n\t\tString key() default \"\";\n\t}\n\n\t@Cacheable(\"barCache\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface BarCache {\n\t\t@AliasFor(annotation = Cacheable.class)\n\t\tString key();\n\t}\n\n\t@Cacheable(\"noninheritedCache1\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface NoninheritedCache1 {\n\t\t@AliasFor(annotation = Cacheable.class)\n\t\tString key() default \"\";\n\t}\n\n\t@Cacheable(\"noninheritedCache2\")\n\t@Target({ ElementType.METHOD, ElementType.TYPE })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface NoninheritedCache2 {\n\t\t@AliasFor(annotation = Cacheable.class)\n\t\tString key() default \"\";\n\t}\n\n\t@FooCache(key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate static class MultipleComposedCachesClass {\n\t}\n\n\tprivate static class SubMultipleComposedCachesClass\n\t\t\textends MultipleComposedCachesClass {\n\t}\n\n\t@NoninheritedCache1\n\t@NoninheritedCache2\n\tprivate static class MultipleNoninheritedComposedCachesClass {\n\t}\n\n\tprivate static class SubMultipleNoninheritedComposedCachesClass\n\t\t\textends MultipleNoninheritedComposedCachesClass {\n\t}\n\n\t@Cacheable(cacheName = \"fooCache\", key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate static class ComposedPlusLocalCachesClass {\n\t}\n\n\t@FooCache(key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate interface MultipleComposedCachesInterface {\n\t}\n\n\tprivate static class MultipleComposedCachesOnInterfaceClass implements MultipleComposedCachesInterface {\n\t}\n\n\t@BarCache(key = \"barKey\")\n\tprivate interface ComposedCacheInterface {\n\t}\n\n\t@Cacheable(cacheName = \"fooCache\", key = \"fooKey\")\n\tprivate static class ComposedCacheOnInterfaceAndLocalCacheClass implements ComposedCacheInterface {\n\t}\n\n\t@FooCache(key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate void multipleComposedCachesMethod() {\n\t}\n\n\t@Cacheable(cacheName = \"fooCache\", key = \"fooKey\")\n\t@BarCache(key = \"barKey\")\n\tprivate void composedPlusLocalCachesMethod() {\n\t}\n\n\tpublic interface GenericParameter<T> {\n\t\tT getFor(Class<T> cls);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class StringGenericParameter implements GenericParameter<String> {\n\t\t@FooCache(key = \"fooKey\")\n\t\t@BarCache(key = \"barKey\")\n\t\t@Override\n\t\tpublic String getFor(Class<String> cls) { return \"foo\"; }\n\t\tpublic String getFor(Integer integer) { return \"foo\"; }\n\t}\n\n\t// @formatter:on\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation.GenericParameter#getFor(Class<T>)",
    "headType": "method",
    "relation": "provide",
    "tail": "T getFor(Class<T> cls);",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.GenericParameter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.GenericParameter#getFor(Class<T>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.StringGenericParameter",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.StringGenericParameter",
    "headType": "class",
    "relation": "use",
    "tail": "@SuppressWarnings",
    "tailType": "annotation"
  }
]