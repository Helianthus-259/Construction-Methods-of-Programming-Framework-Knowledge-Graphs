[
  {
    "head": "org.springframework.aot.hint.predicate.ReflectionOnConstructor#constructorInvocationMatchesInvokePublicConstructors()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid constructorInvocationMatchesInvokePublicConstructors() {\r\n    runtimeHints.reflection().registerType(SampleClass.class, MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS);\r\n    assertPredicateMatches(reflection.onConstructorInvocation(publicConstructor));\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.hint.predicate.ReflectionOnConstructor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.hint.predicate.ReflectionOnConstructor#constructorInvocationMatchesInvokePublicConstructors()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.aot.hint.predicate.ReflectionOnConstructor#constructorInvocationMatchesInvokePublicConstructors()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.aot.hint.predicate.ReflectionOnConstructor#constructorInvocationDoesNotMatchIntrospectDeclaredConstructors()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid constructorInvocationDoesNotMatchIntrospectDeclaredConstructors() {\r\n    runtimeHints.reflection().registerType(SampleClass.class, MemberCategory.INTROSPECT_DECLARED_CONSTRUCTORS);\r\n    assertPredicateDoesNotMatch(reflection.onConstructorInvocation(publicConstructor));\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.hint.predicate.ReflectionOnConstructor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.hint.predicate.ReflectionOnConstructor#constructorInvocationDoesNotMatchIntrospectDeclaredConstructors()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.aot.hint.predicate.ReflectionOnConstructor#constructorInvocationDoesNotMatchIntrospectDeclaredConstructors()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.aot.hint.predicate.ReflectionOnConstructor#constructorInvocationMatchesInvokeDeclaredConstructors()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid constructorInvocationMatchesInvokeDeclaredConstructors() {\r\n    runtimeHints.reflection().registerType(SampleClass.class, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);\r\n    assertPredicateMatches(reflection.onConstructorInvocation(publicConstructor));\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.hint.predicate.ReflectionOnConstructor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.hint.predicate.ReflectionOnConstructor#constructorInvocationMatchesInvokeDeclaredConstructors()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.aot.hint.predicate.ReflectionOnConstructor#constructorInvocationMatchesInvokeDeclaredConstructors()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.aot.hint.predicate.ReflectionOnConstructor#privateConstructorInvocationDoesNotMatchConstructorHint()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid privateConstructorInvocationDoesNotMatchConstructorHint() {\r\n    runtimeHints.reflection().registerType(SampleClass.class, typeHint -> typeHint.withConstructor(TypeReference.listOf(String.class), ExecutableMode.INTROSPECT));\r\n    assertPredicateDoesNotMatch(reflection.onConstructorInvocation(privateConstructor));\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.hint.predicate.ReflectionOnConstructor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.hint.predicate.ReflectionOnConstructor#privateConstructorInvocationDoesNotMatchConstructorHint()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.aot.hint.predicate.ReflectionOnConstructor#privateConstructorInvocationDoesNotMatchConstructorHint()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.aot.hint.predicate.ReflectionOnConstructor#privateConstructorInvocationMatchesConstructorInvocationHint()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid privateConstructorInvocationMatchesConstructorInvocationHint() {\r\n    runtimeHints.reflection().registerType(SampleClass.class, typeHint -> typeHint.withConstructor(TypeReference.listOf(String.class), ExecutableMode.INVOKE));\r\n    assertPredicateMatches(reflection.onConstructorInvocation(privateConstructor));\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.hint.predicate.ReflectionOnConstructor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.hint.predicate.ReflectionOnConstructor#privateConstructorInvocationMatchesConstructorInvocationHint()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.aot.hint.predicate.ReflectionOnConstructor#privateConstructorInvocationMatchesConstructorInvocationHint()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.aot.hint.predicate.ReflectionOnConstructor#privateConstructorInvocationDoesNotMatchIntrospectPublicConstructors()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid privateConstructorInvocationDoesNotMatchIntrospectPublicConstructors() {\r\n    runtimeHints.reflection().registerType(SampleClass.class, MemberCategory.INTROSPECT_PUBLIC_CONSTRUCTORS);\r\n    assertPredicateDoesNotMatch(reflection.onConstructorInvocation(privateConstructor));\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.hint.predicate.ReflectionOnConstructor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.hint.predicate.ReflectionOnConstructor#privateConstructorInvocationDoesNotMatchIntrospectPublicConstructors()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.aot.hint.predicate.ReflectionOnConstructor#privateConstructorInvocationDoesNotMatchIntrospectPublicConstructors()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.aot.hint.predicate.ReflectionOnConstructor#privateConstructorInvocationDoesNotMatchInvokePublicConstructors()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid privateConstructorInvocationDoesNotMatchInvokePublicConstructors() {\r\n    runtimeHints.reflection().registerType(SampleClass.class, MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS);\r\n    assertPredicateDoesNotMatch(reflection.onConstructorInvocation(privateConstructor));\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.hint.predicate.ReflectionOnConstructor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.hint.predicate.ReflectionOnConstructor#privateConstructorInvocationDoesNotMatchInvokePublicConstructors()",
    "tailType": "method"
  }
]