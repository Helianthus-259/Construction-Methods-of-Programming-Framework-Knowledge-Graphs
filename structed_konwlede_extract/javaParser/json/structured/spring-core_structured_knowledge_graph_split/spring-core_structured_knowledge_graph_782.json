[
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.UniquePredicate",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.UniquePredicate",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\n\nimport org.springframework.util.Assert;\nimport org.springframework.util.ObjectUtils;\n\n/**\n * Predicate implementations that provide various test operations for\n * {@link MergedAnnotation MergedAnnotations}.\n *\n * @author Phillip Webb\n * @since 5.2\n */\npublic abstract class MergedAnnotationPredicates {\n\n\tprivate MergedAnnotationPredicates() {\n\t}\n\n\n\t/**\n\t * Create a new {@link Predicate} that evaluates to {@code true} if the name of the\n\t * {@linkplain MergedAnnotation#getType() merged annotation type} is contained in\n\t * the specified array.\n\t * @param <A> the annotation type\n\t * @param typeNames the names that should be matched\n\t * @return a {@link Predicate} to test the annotation type\n\t */\n\tpublic static <A extends Annotation> Predicate<MergedAnnotation<? extends A>> typeIn(String... typeNames) {\n\t\treturn annotation -> ObjectUtils.containsElement(typeNames, annotation.getType().getName());\n\t}\n\n\t/**\n\t * Create a new {@link Predicate} that evaluates to {@code true} if the\n\t * {@linkplain MergedAnnotation#getType() merged annotation type} is contained in\n\t * the specified array.\n\t * @param <A> the annotation type\n\t * @param types the types that should be matched\n\t * @return a {@link Predicate} to test the annotation type\n\t */\n\tpublic static <A extends Annotation> Predicate<MergedAnnotation<? extends A>> typeIn(Class<?>... types) {\n\t\treturn annotation -> ObjectUtils.containsElement(types, annotation.getType());\n\t}\n\n\t/**\n\t * Create a new {@link Predicate} that evaluates to {@code true} if the\n\t * {@linkplain MergedAnnotation#getType() merged annotation type} is contained in\n\t * the specified collection.\n\t * @param <A> the annotation type\n\t * @param types the type names or classes that should be matched\n\t * @return a {@link Predicate} to test the annotation type\n\t */\n\tpublic static <A extends Annotation> Predicate<MergedAnnotation<? extends A>> typeIn(Collection<?> types) {\n\t\treturn annotation -> types.stream()\n\t\t\t\t.map(type -> type instanceof Class<?> clazz ? clazz.getName() : type.toString())\n\t\t\t\t.anyMatch(typeName -> typeName.equals(annotation.getType().getName()));\n\t}\n\n\t/**\n\t * Create a new stateful, single use {@link Predicate} that matches only\n\t * the first run of an extracted value. For example,\n\t * {@code MergedAnnotationPredicates.firstRunOf(MergedAnnotation::distance)}\n\t * will match the first annotation, and any subsequent runs that have the\n\t * same distance.\n\t * <p>NOTE: This predicate only matches the first run. Once the extracted\n\t * value changes, the predicate always returns {@code false}. For example,\n\t * if you have a set of annotations with distances {@code [1, 1, 2, 1]} then\n\t * only the first two will match.\n\t * @param valueExtractor function used to extract the value to check\n\t * @return a {@link Predicate} that matches the first run of the extracted\n\t * values\n\t */\n\tpublic static <A extends Annotation> Predicate<MergedAnnotation<A>> firstRunOf(\n\t\t\tFunction<? super MergedAnnotation<A>, ?> valueExtractor) {\n\n\t\treturn new FirstRunOfPredicate<>(valueExtractor);\n\t}\n\n\t/**\n\t * Create a new stateful, single use {@link Predicate} that matches\n\t * annotations that are unique based on the extracted key. For example\n\t * {@code MergedAnnotationPredicates.unique(MergedAnnotation::getType)} will\n\t * match the first time a unique type is encountered.\n\t * @param keyExtractor function used to extract the key used to test for\n\t * uniqueness\n\t * @return a {@link Predicate} that matches a unique annotation based on the\n\t * extracted key\n\t */\n\tpublic static <A extends Annotation, K> Predicate<MergedAnnotation<A>> unique(\n\t\t\tFunction<? super MergedAnnotation<A>, K> keyExtractor) {\n\n\t\treturn new UniquePredicate<>(keyExtractor);\n\t}\n\n\n\t/**\n\t * {@link Predicate} implementation used for\n\t * {@link MergedAnnotationPredicates#firstRunOf(Function)}.\n\t */\n\tprivate static class FirstRunOfPredicate<A extends Annotation> implements Predicate<MergedAnnotation<A>> {\n\n\t\tprivate final Function<? super MergedAnnotation<A>, ?> valueExtractor;\n\n\t\tprivate boolean hasLastValue;\n\n\t\t@SuppressWarnings(\"NullAway.Init\")\n\t\tprivate Object lastValue;\n\n\t\tFirstRunOfPredicate(Function<? super MergedAnnotation<A>, ?> valueExtractor) {\n\t\t\tAssert.notNull(valueExtractor, \"Value extractor must not be null\");\n\t\t\tthis.valueExtractor = valueExtractor;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(MergedAnnotation<A> annotation) {\n\t\t\tif (!this.hasLastValue) {\n\t\t\t\tthis.hasLastValue = true;\n\t\t\t\tthis.lastValue = this.valueExtractor.apply(annotation);\n\t\t\t}\n\t\t\tObject value = this.valueExtractor.apply(annotation);\n\t\t\treturn ObjectUtils.nullSafeEquals(value, this.lastValue);\n\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link Predicate} implementation used for\n\t * {@link MergedAnnotationPredicates#unique(Function)}.\n\t */\n\tprivate static class UniquePredicate<A extends Annotation, K> implements Predicate<MergedAnnotation<A>> {\n\n\t\tprivate final Function<? super MergedAnnotation<A>, K> keyExtractor;\n\n\t\tprivate final Set<K> seen = new HashSet<>();\n\n\t\tUniquePredicate(Function<? super MergedAnnotation<A>, K> keyExtractor) {\n\t\t\tAssert.notNull(keyExtractor, \"Key extractor must not be null\");\n\t\t\tthis.keyExtractor = keyExtractor;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(MergedAnnotation<A> annotation) {\n\t\t\tK key = this.keyExtractor.apply(annotation);\n\t\t\treturn this.seen.add(key);\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation.UniquePredicate",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.UniquePredicate#keyExtractor",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.UniquePredicate#keyExtractor",
    "headType": "field",
    "relation": "haveType",
    "tail": "Function<? super MergedAnnotation<A>, K>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.UniquePredicate",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.UniquePredicate#seen",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.UniquePredicate#seen",
    "headType": "field",
    "relation": "haveType",
    "tail": "Set<K>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.UniquePredicate#test(MergedAnnotation<A>)",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic boolean test(MergedAnnotation<A> annotation) {\r\n    K key = this.keyExtractor.apply(annotation);\r\n    return this.seen.add(key);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.UniquePredicate",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.UniquePredicate#test(MergedAnnotation<A>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.UniquePredicate#test(MergedAnnotation<A>)",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.annotation",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.MergedAnnotations",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotations",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Inherited;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\n\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.util.Assert;\n\n/**\n * Provides access to a collection of merged annotations, usually obtained\n * from a source such as a {@link Class} or {@link Method}.\n *\n * <p>Each merged annotation represents a view where the attribute values may be\n * \"merged\" from different source values, typically:\n *\n * <ul>\n * <li>Explicit and Implicit {@link AliasFor @AliasFor} declarations on one or\n * more attributes within the annotation</li>\n * <li>Explicit {@link AliasFor @AliasFor} declarations for a meta-annotation</li>\n * <li>Convention based attribute aliases for a meta-annotation</li>\n * <li>From a meta-annotation declaration</li>\n * </ul>\n *\n * <p>For example, a {@code @PostMapping} annotation might be defined as follows:\n *\n * <pre class=\"code\">\n * &#064;Retention(RetentionPolicy.RUNTIME)\n * &#064;RequestMapping(method = RequestMethod.POST)\n * public &#064;interface PostMapping {\n *\n *     &#064;AliasFor(attribute = \"path\")\n *     String[] value() default {};\n *\n *     &#064;AliasFor(attribute = \"value\")\n *     String[] path() default {};\n * }\n * </pre>\n *\n * <p>If a method is annotated with {@code @PostMapping(\"/home\")} it will contain\n * merged annotations for both {@code @PostMapping} and the meta-annotation\n * {@code @RequestMapping}. The merged view of the {@code @RequestMapping}\n * annotation will contain the following attributes:\n *\n * <p><table border=\"1\">\n * <tr>\n * <th>Name</th>\n * <th>Value</th>\n * <th>Source</th>\n * </tr>\n * <tr>\n * <td>value</td>\n * <td>\"/home\"</td>\n * <td>Declared in {@code @PostMapping}</td>\n * </tr>\n * <tr>\n * <td>path</td>\n * <td>\"/home\"</td>\n * <td>Explicit {@code @AliasFor}</td>\n * </tr>\n * <tr>\n * <td>method</td>\n * <td>RequestMethod.POST</td>\n * <td>Declared in meta-annotation</td>\n * </tr>\n * </table>\n *\n * <p>{@code MergedAnnotations} can be obtained {@linkplain #from(AnnotatedElement)\n * from} any Java {@link AnnotatedElement}. They may also be used for sources that\n * don't use reflection (such as those that directly parse bytecode).\n *\n * <p>Different {@linkplain SearchStrategy search strategies} can be used to locate\n * related source elements that contain the annotations to be aggregated. For\n * example, the following code uses {@link SearchStrategy#TYPE_HIERARCHY} to\n * search for annotations on {@code MyClass} as well as in superclasses and implemented\n * interfaces.\n *\n * <pre class=\"code\">\n * MergedAnnotations mergedAnnotations =\n *     MergedAnnotations.search(TYPE_HIERARCHY).from(MyClass.class);\n * </pre>\n *\n * <p>From a {@code MergedAnnotations} instance you can either\n * {@linkplain #get(String) get} a single annotation, or {@linkplain #stream()\n * stream all annotations} or just those that match {@linkplain #stream(String)\n * a specific type}. You can also quickly tell if an annotation\n * {@linkplain #isPresent(String) is present}.\n *\n * <p>Here are some typical examples:\n *\n * <pre class=\"code\">\n * // is an annotation present or meta-present?\n * mergedAnnotations.isPresent(ExampleAnnotation.class);\n *\n * // get the merged \"value\" attribute of ExampleAnnotation (either directly or\n * // meta-present)\n * mergedAnnotations.get(ExampleAnnotation.class).getString(\"value\");\n *\n * // get all meta-annotations but no directly present annotations\n * mergedAnnotations.stream().filter(MergedAnnotation::isMetaPresent);\n *\n * // get all ExampleAnnotation declarations (including any meta-annotations) and\n * // print the merged \"value\" attributes\n * mergedAnnotations.stream(ExampleAnnotation.class)\n *     .map(mergedAnnotation -&gt; mergedAnnotation.getString(\"value\"))\n *     .forEach(System.out::println);\n * </pre>\n *\n * <p><b>NOTE: The {@code MergedAnnotations} API and its underlying model have\n * been designed for composable annotations in Spring's common component model,\n * with a focus on attribute aliasing and meta-annotation relationships.</b>\n * There is no support for retrieving plain Java annotations with this API;\n * please use standard Java reflection or Spring's {@link AnnotationUtils}\n * for simple annotation retrieval purposes.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n * @since 5.2\n * @see MergedAnnotation\n * @see MergedAnnotationCollectors\n * @see MergedAnnotationPredicates\n * @see MergedAnnotationSelectors\n */\npublic interface MergedAnnotations extends Iterable<MergedAnnotation<Annotation>> {\n\n\t/**\n\t * Determine if the specified annotation type is either directly present or\n\t * meta-present.\n\t * <p>Equivalent to calling {@code get(annotationType).isPresent()}.\n\t * @param annotationType the annotation type to check\n\t * @return {@code true} if the annotation is present\n\t */\n\t<A extends Annotation> boolean isPresent(Class<A> annotationType);\n\n\t/**\n\t * Determine if the specified annotation type is either directly present or\n\t * meta-present.\n\t * <p>Equivalent to calling {@code get(annotationType).isPresent()}.\n\t * @param annotationType the fully qualified class name of the annotation type\n\t * to check\n\t * @return {@code true} if the annotation is present\n\t */\n\tboolean isPresent(String annotationType);\n\n\t/**\n\t * Determine if the specified annotation type is directly present.\n\t * <p>Equivalent to calling {@code get(annotationType).isDirectlyPresent()}.\n\t * @param annotationType the annotation type to check\n\t * @return {@code true} if the annotation is directly present\n\t */\n\t<A extends Annotation> boolean isDirectlyPresent(Class<A> annotationType);\n\n\t/**\n\t * Determine if the specified annotation type is directly present.\n\t * <p>Equivalent to calling {@code get(annotationType).isDirectlyPresent()}.\n\t * @param annotationType the fully qualified class name of the annotation type\n\t * to check\n\t * @return {@code true} if the annotation is directly present\n\t */\n\tboolean isDirectlyPresent(String annotationType);\n\n\t/**\n\t * Get the {@linkplain MergedAnnotationSelectors#nearest() nearest} matching\n\t * annotation or meta-annotation of the specified type, or\n\t * {@link MergedAnnotation#missing()} if none is present.\n\t * @param annotationType the annotation type to get\n\t * @return a {@link MergedAnnotation} instance\n\t */\n\t<A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType);\n\n\t/**\n\t * Get the {@linkplain MergedAnnotationSelectors#nearest() nearest} matching\n\t * annotation or meta-annotation of the specified type, or\n\t * {@link MergedAnnotation#missing()} if none is present.\n\t * @param annotationType the annotation type to get\n\t * @param predicate a predicate that must match, or {@code null} if only\n\t * type matching is required\n\t * @return a {@link MergedAnnotation} instance\n\t * @see MergedAnnotationPredicates\n\t */\n\t<A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType,\n\t\t\t@Nullable Predicate<? super MergedAnnotation<A>> predicate);\n\n\t/**\n\t * Get a matching annotation or meta-annotation of the specified type, or\n\t * {@link MergedAnnotation#missing()} if none is present.\n\t * @param annotationType the annotation type to get\n\t * @param predicate a predicate that must match, or {@code null} if only\n\t * type matching is required\n\t * @param selector a selector used to choose the most appropriate annotation\n\t * within an aggregate, or {@code null} to select the\n\t * {@linkplain MergedAnnotationSelectors#nearest() nearest}\n\t * @return a {@link MergedAnnotation} instance\n\t * @see MergedAnnotationPredicates\n\t * @see MergedAnnotationSelectors\n\t */\n\t<A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType,\n\t\t\t@Nullable Predicate<? super MergedAnnotation<A>> predicate,\n\t\t\t@Nullable MergedAnnotationSelector<A> selector);\n\n\t/**\n\t * Get the {@linkplain MergedAnnotationSelectors#nearest() nearest} matching\n\t * annotation or meta-annotation of the specified type, or\n\t * {@link MergedAnnotation#missing()} if none is present.\n\t * @param annotationType the fully qualified class name of the annotation type\n\t * to get\n\t * @return a {@link MergedAnnotation} instance\n\t */\n\t<A extends Annotation> MergedAnnotation<A> get(String annotationType);\n\n\t/**\n\t * Get the {@linkplain MergedAnnotationSelectors#nearest() nearest} matching\n\t * annotation or meta-annotation of the specified type, or\n\t * {@link MergedAnnotation#missing()} if none is present.\n\t * @param annotationType the fully qualified class name of the annotation type\n\t * to get\n\t * @param predicate a predicate that must match, or {@code null} if only\n\t * type matching is required\n\t * @return a {@link MergedAnnotation} instance\n\t * @see MergedAnnotationPredicates\n\t */\n\t<A extends Annotation> MergedAnnotation<A> get(String annotationType,\n\t\t\t@Nullable Predicate<? super MergedAnnotation<A>> predicate);\n\n\t/**\n\t * Get a matching annotation or meta-annotation of the specified type, or\n\t * {@link MergedAnnotation#missing()} if none is present.\n\t * @param annotationType the fully qualified class name of the annotation type\n\t * to get\n\t * @param predicate a predicate that must match, or {@code null} if only\n\t * type matching is required\n\t * @param selector a selector used to choose the most appropriate annotation\n\t * within an aggregate, or {@code null} to select the\n\t * {@linkplain MergedAnnotationSelectors#nearest() nearest}\n\t * @return a {@link MergedAnnotation} instance\n\t * @see MergedAnnotationPredicates\n\t * @see MergedAnnotationSelectors\n\t */\n\t<A extends Annotation> MergedAnnotation<A> get(String annotationType,\n\t\t\t@Nullable Predicate<? super MergedAnnotation<A>> predicate,\n\t\t\t@Nullable MergedAnnotationSelector<A> selector);\n\n\t/**\n\t * Stream all annotations and meta-annotations that match the specified\n\t * type.\n\t * <p>The resulting stream follows the same ordering rules as {@link #stream()}.\n\t * @param annotationType the annotation type to match\n\t * @return a stream of matching annotations\n\t */\n\t<A extends Annotation> Stream<MergedAnnotation<A>> stream(Class<A> annotationType);\n\n\t/**\n\t * Stream all annotations and meta-annotations that match the specified\n\t * type.\n\t * <p>The resulting stream follows the same ordering rules as {@link #stream()}.\n\t * @param annotationType the fully qualified class name of the annotation type\n\t * to match\n\t * @return a stream of matching annotations\n\t */\n\t<A extends Annotation> Stream<MergedAnnotation<A>> stream(String annotationType);\n\n\t/**\n\t * Stream all annotations and meta-annotations contained in this collection.\n\t * <p>The resulting stream is ordered first by the\n\t * {@linkplain MergedAnnotation#getAggregateIndex() aggregate index} and then\n\t * by the annotation distance (with the closest annotations first). This ordering\n\t * means that, for most use-cases, the most suitable annotations appear\n\t * earliest in the stream.\n\t * @return a stream of annotations\n\t */\n\tStream<MergedAnnotation<Annotation>> stream();\n\n\n\t/**\n\t * Create a new {@link MergedAnnotations} instance containing all\n\t * annotations and meta-annotations from the specified element.\n\t * <p>The resulting instance will not include any inherited annotations. If\n\t * you want to include those as well you should use\n\t * {@link #from(AnnotatedElement, SearchStrategy)} with an appropriate\n\t * {@link SearchStrategy}.\n\t * @param element the source element\n\t * @return a {@code MergedAnnotations} instance containing the element's\n\t * annotations\n\t * @see #search(SearchStrategy)\n\t */\n\tstatic MergedAnnotations from(AnnotatedElement element) {\n\t\treturn from(element, SearchStrategy.DIRECT);\n\t}\n\n\t/**\n\t * Create a new {@link MergedAnnotations} instance containing all\n\t * annotations and meta-annotations from the specified element and,\n\t * depending on the {@link SearchStrategy}, related inherited elements.\n\t * @param element the source element\n\t * @param searchStrategy the search strategy to use\n\t * @return a {@code MergedAnnotations} instance containing the merged\n\t * element annotations\n\t * @see #search(SearchStrategy)\n\t */\n\tstatic MergedAnnotations from(AnnotatedElement element, SearchStrategy searchStrategy) {\n\t\treturn from(element, searchStrategy, RepeatableContainers.standardRepeatables());\n\t}\n\n\t/**\n\t * Create a new {@link MergedAnnotations} instance containing all\n\t * annotations and meta-annotations from the specified element and,\n\t * depending on the {@link SearchStrategy}, related inherited elements.\n\t * @param element the source element\n\t * @param searchStrategy the search strategy to use\n\t * @param repeatableContainers the repeatable containers that may be used by\n\t * the element annotations or the meta-annotations\n\t * @return a {@code MergedAnnotations} instance containing the merged\n\t * element annotations\n\t * @see #search(SearchStrategy)\n\t */\n\tstatic MergedAnnotations from(AnnotatedElement element, SearchStrategy searchStrategy,\n\t\t\tRepeatableContainers repeatableContainers) {\n\n\t\treturn from(element, searchStrategy, repeatableContainers, AnnotationFilter.PLAIN);\n\t}\n\n\t/**\n\t * Create a new {@link MergedAnnotations} instance containing all\n\t * annotations and meta-annotations from the specified element and,\n\t * depending on the {@link SearchStrategy}, related inherited elements.\n\t * @param element the source element\n\t * @param searchStrategy the search strategy to use\n\t * @param repeatableContainers the repeatable containers that may be used by\n\t * the element annotations or the meta-annotations\n\t * @param annotationFilter an annotation filter used to restrict the\n\t * annotations considered\n\t * @return a {@code MergedAnnotations} instance containing the merged\n\t * annotations for the supplied element\n\t * @see #search(SearchStrategy)\n\t */\n\tstatic MergedAnnotations from(AnnotatedElement element, SearchStrategy searchStrategy,\n\t\t\tRepeatableContainers repeatableContainers, AnnotationFilter annotationFilter) {\n\n\t\treturn from(element, searchStrategy, Search.never, repeatableContainers, annotationFilter);\n\t}\n\n\tprivate static MergedAnnotations from(AnnotatedElement element, SearchStrategy searchStrategy,\n\t\t\tPredicate<Class<?>> searchEnclosingClass, RepeatableContainers repeatableContainers,\n\t\t\tAnnotationFilter annotationFilter) {\n\n\t\tAssert.notNull(element, \"AnnotatedElement must not be null\");\n\t\tAssert.notNull(searchStrategy, \"SearchStrategy must not be null\");\n\t\tAssert.notNull(searchEnclosingClass, \"Predicate must not be null\");\n\t\tAssert.notNull(repeatableContainers, \"RepeatableContainers must not be null\");\n\t\tAssert.notNull(annotationFilter, \"AnnotationFilter must not be null\");\n\t\treturn TypeMappedAnnotations.from(element, searchStrategy, searchEnclosingClass,\n\t\t\t\trepeatableContainers, annotationFilter);\n\t}\n\n\t/**\n\t * Create a new {@link MergedAnnotations} instance from the specified\n\t * annotations.\n\t * @param annotations the annotations to include\n\t * @return a {@code MergedAnnotations} instance containing the annotations\n\t * @see #from(Object, Annotation...)\n\t */\n\tstatic MergedAnnotations from(Annotation... annotations) {\n\t\treturn from(annotations, annotations);\n\t}\n\n\t/**\n\t * Create a new {@link MergedAnnotations} instance from the specified\n\t * annotations.\n\t * @param source the source for the annotations. This source is used only\n\t * for information and logging. It does not need to <em>actually</em>\n\t * contain the specified annotations, and it will not be searched.\n\t * @param annotations the annotations to include\n\t * @return a {@code MergedAnnotations} instance containing the annotations\n\t * @see #from(Annotation...)\n\t * @see #from(AnnotatedElement)\n\t */\n\tstatic MergedAnnotations from(Object source, Annotation... annotations) {\n\t\treturn from(source, annotations, RepeatableContainers.standardRepeatables());\n\t}\n\n\t/**\n\t * Create a new {@link MergedAnnotations} instance from the specified\n\t * annotations.\n\t * @param source the source for the annotations. This source is used only\n\t * for information and logging. It does not need to <em>actually</em>\n\t * contain the specified annotations, and it will not be searched.\n\t * @param annotations the annotations to include\n\t * @param repeatableContainers the repeatable containers that may be used by\n\t * meta-annotations\n\t * @return a {@code MergedAnnotations} instance containing the annotations\n\t */\n\tstatic MergedAnnotations from(Object source, Annotation[] annotations, RepeatableContainers repeatableContainers) {\n\t\treturn from(source, annotations, repeatableContainers, AnnotationFilter.PLAIN);\n\t}\n\n\t/**\n\t * Create a new {@link MergedAnnotations} instance from the specified\n\t * annotations.\n\t * @param source the source for the annotations. This source is used only\n\t * for information and logging. It does not need to <em>actually</em>\n\t * contain the specified annotations, and it will not be searched.\n\t * @param annotations the annotations to include\n\t * @param repeatableContainers the repeatable containers that may be used by\n\t * meta-annotations\n\t * @param annotationFilter an annotation filter used to restrict the\n\t * annotations considered\n\t * @return a {@code MergedAnnotations} instance containing the annotations\n\t */\n\tstatic MergedAnnotations from(Object source, Annotation[] annotations,\n\t\t\tRepeatableContainers repeatableContainers, AnnotationFilter annotationFilter) {\n\n\t\tAssert.notNull(repeatableContainers, \"RepeatableContainers must not be null\");\n\t\tAssert.notNull(annotationFilter, \"AnnotationFilter must not be null\");\n\t\treturn TypeMappedAnnotations.from(source, annotations, repeatableContainers, annotationFilter);\n\t}\n\n\t/**\n\t * Create a new {@link MergedAnnotations} instance from the specified\n\t * collection of directly present annotations. This method allows a\n\t * {@code MergedAnnotations} instance to be created from annotations that\n\t * are not necessarily loaded using reflection. The provided annotations\n\t * must all be {@link MergedAnnotation#isDirectlyPresent() directly present}\n\t * and must have an {@link MergedAnnotation#getAggregateIndex() aggregate\n\t * index} of {@code 0}.\n\t * <p>The resulting {@code MergedAnnotations} instance will contain both the\n\t * specified annotations and any meta-annotations that can be read using\n\t * reflection.\n\t * @param annotations the annotations to include\n\t * @return a {@code MergedAnnotations} instance containing the annotations\n\t * @see MergedAnnotation#of(ClassLoader, Object, Class, java.util.Map)\n\t */\n\tstatic MergedAnnotations of(Collection<MergedAnnotation<?>> annotations) {\n\t\treturn MergedAnnotationsCollection.of(annotations);\n\t}\n\n\t/**\n\t * Find merged annotations using the supplied {@link SearchStrategy} and a\n\t * fluent API for configuring and performing the search.\n\t * <p>See {@link Search} for details.\n\t * @param searchStrategy the search strategy to use\n\t * @return a {@code Search} instance to perform the search\n\t * @since 6.0\n\t */\n\tstatic Search search(SearchStrategy searchStrategy) {\n\t\tAssert.notNull(searchStrategy, \"SearchStrategy must not be null\");\n\t\treturn new Search(searchStrategy);\n\t}\n\n\n\t/**\n\t * Fluent API for configuring the search algorithm used in the\n\t * {@link MergedAnnotations} model and performing a search.\n\t *\n\t * <ul>\n\t * <li>Configuration starts with an invocation of\n\t * {@link MergedAnnotations#search(SearchStrategy)}, specifying which\n\t * {@link SearchStrategy} to use.</li>\n\t * <li>Optional configuration can be provided via one of the {@code with*()}\n\t * methods.</li>\n\t * <li>The actual search is performed by invoking {@link #from(AnnotatedElement)}\n\t * with the source element from which the search should begin.</li>\n\t * </ul>\n\t *\n\t * <p>For example, the following performs a search on {@code MyClass} within\n\t * the entire type hierarchy of that class while ignoring repeatable annotations.\n\t *\n\t * <pre class=\"code\">\n\t * MergedAnnotations mergedAnnotations =\n\t *     MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY)\n\t *         .withRepeatableContainers(RepeatableContainers.none())\n\t *         .from(MyClass.class);\n\t * </pre>\n\t *\n\t * <p>If you wish to reuse search configuration to perform the same type of search\n\t * on multiple elements, you can save the {@code Search} instance as demonstrated\n\t * in the following example.\n\t *\n\t * <pre class=\"code\">\n\t * Search search = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY)\n\t *                     .withRepeatableContainers(RepeatableContainers.none());\n\t *\n\t * MergedAnnotations mergedAnnotations = search.from(MyClass.class);\n\t * // do something with the MergedAnnotations for MyClass\n\t * mergedAnnotations = search.from(AnotherClass.class);\n\t * // do something with the MergedAnnotations for AnotherClass\n\t * </pre>\n\t *\n\t * @since 6.0\n\t */\n\tfinal class Search {\n\n\t\tstatic final Predicate<Class<?>> always = clazz -> true;\n\n\t\tstatic final Predicate<Class<?>> never = clazz -> false;\n\n\n\t\tprivate final SearchStrategy searchStrategy;\n\n\t\tprivate Predicate<Class<?>> searchEnclosingClass = never;\n\n\t\tprivate RepeatableContainers repeatableContainers = RepeatableContainers.standardRepeatables();\n\n\t\tprivate AnnotationFilter annotationFilter = AnnotationFilter.PLAIN;\n\n\n\t\tprivate Search(SearchStrategy searchStrategy) {\n\t\t\tthis.searchStrategy = searchStrategy;\n\t\t}\n\n\t\t/**\n\t\t * Configure whether the search algorithm should search on\n\t\t * {@linkplain Class#getEnclosingClass() enclosing classes}.\n\t\t * <p>This feature is disabled by default and is only supported when using\n\t\t * {@link SearchStrategy#TYPE_HIERARCHY}.\n\t\t * <p>Enclosing classes will be recursively searched if the supplied\n\t\t * {@link Predicate} evaluates to {@code true}. Typically, the predicate\n\t\t * will be used to differentiate between <em>inner classes</em> and\n\t\t * {@code static} nested classes.\n\t\t * <ul>\n\t\t * <li>To limit the enclosing class search to inner classes, provide\n\t\t * {@link org.springframework.util.ClassUtils#isInnerClass(Class) ClassUtils::isInnerClass}\n\t\t * as the predicate.</li>\n\t\t * <li>To limit the enclosing class search to static nested classes, provide\n\t\t * {@link org.springframework.util.ClassUtils#isStaticClass(Class) ClassUtils::isStaticClass}\n\t\t * as the predicate.</li>\n\t\t * <li>To force the algorithm to always search enclosing classes, provide\n\t\t * {@code clazz -> true} as the predicate.</li>\n\t\t * <li>For any other use case, provide a custom predicate.</li>\n\t\t * </ul>\n\t\t * <p><strong>WARNING:</strong> if the supplied predicate always evaluates\n\t\t * to {@code true}, the algorithm will search recursively for annotations\n\t\t * on an enclosing class for any source type, regardless whether the source\n\t\t * type is an <em>inner class</em>, a {@code static} nested class, or a\n\t\t * nested interface. Thus, it may find more annotations than you would expect.\n\t\t * @param searchEnclosingClass a predicate which evaluates to {@code true}\n\t\t * if a search should be performed on the enclosing class of the class\n\t\t * supplied to the predicate\n\t\t * @return this {@code Search} instance for chained method invocations\n\t\t * @see SearchStrategy#TYPE_HIERARCHY\n\t\t * @see #withRepeatableContainers(RepeatableContainers)\n\t\t * @see #withAnnotationFilter(AnnotationFilter)\n\t\t * @see #from(AnnotatedElement)\n\t\t */\n\t\tpublic Search withEnclosingClasses(Predicate<Class<?>> searchEnclosingClass) {\n\t\t\tAssert.notNull(searchEnclosingClass, \"Predicate must not be null\");\n\t\t\tAssert.state(this.searchStrategy == SearchStrategy.TYPE_HIERARCHY,\n\t\t\t\t\t\"A custom 'searchEnclosingClass' predicate can only be combined with SearchStrategy.TYPE_HIERARCHY\");\n\t\t\tthis.searchEnclosingClass = searchEnclosingClass;\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Configure the {@link RepeatableContainers} to use.\n\t\t * <p>Defaults to {@link RepeatableContainers#standardRepeatables()}.\n\t\t * @param repeatableContainers the repeatable containers that may be used\n\t\t * by annotations or meta-annotations\n\t\t * @return this {@code Search} instance for chained method invocations\n\t\t * @see #withAnnotationFilter(AnnotationFilter)\n\t\t * @see #from(AnnotatedElement)\n\t\t */\n\t\tpublic Search withRepeatableContainers(RepeatableContainers repeatableContainers) {\n\t\t\tAssert.notNull(repeatableContainers, \"RepeatableContainers must not be null\");\n\t\t\tthis.repeatableContainers = repeatableContainers;\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Configure the {@link AnnotationFilter} to use.\n\t\t * <p>Defaults to {@link AnnotationFilter#PLAIN}.\n\t\t * @param annotationFilter an annotation filter used to restrict the\n\t\t * annotations considered\n\t\t * @return this {@code Search} instance for chained method invocations\n\t\t * @see #withRepeatableContainers(RepeatableContainers)\n\t\t * @see #from(AnnotatedElement)\n\t\t */\n\t\tpublic Search withAnnotationFilter(AnnotationFilter annotationFilter) {\n\t\t\tAssert.notNull(annotationFilter, \"AnnotationFilter must not be null\");\n\t\t\tthis.annotationFilter = annotationFilter;\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Perform a search for merged annotations beginning with the supplied\n\t\t * {@link AnnotatedElement} (such as a {@link Class} or {@link Method}),\n\t\t * using the configuration in this {@code Search} instance.\n\t\t * @param element the source element\n\t\t * @return a new {@link MergedAnnotations} instance containing all\n\t\t * annotations and meta-annotations from the specified element and,\n\t\t * depending on the {@link SearchStrategy}, related inherited elements\n\t\t * @see #withEnclosingClasses(Predicate)\n\t\t * @see #withRepeatableContainers(RepeatableContainers)\n\t\t * @see #withAnnotationFilter(AnnotationFilter)\n\t\t * @see MergedAnnotations#from(AnnotatedElement, SearchStrategy, RepeatableContainers, AnnotationFilter)\n\t\t */\n\t\tpublic MergedAnnotations from(AnnotatedElement element) {\n\t\t\treturn MergedAnnotations.from(element, this.searchStrategy, this.searchEnclosingClass,\n\t\t\t\t\tthis.repeatableContainers, this.annotationFilter);\n\t\t}\n\n\t}\n\n\t/**\n\t * Search strategies supported by {@link MergedAnnotations#search(SearchStrategy)}\n\t * as well as {@link MergedAnnotations#from(AnnotatedElement, SearchStrategy)}\n\t * and variants of that method.\n\t *\n\t * <p>Each strategy creates a different set of aggregates that will be\n\t * combined to create the final {@link MergedAnnotations}.\n\t */\n\tenum SearchStrategy {\n\n\t\t/**\n\t\t * Find only directly declared annotations, without considering\n\t\t * {@link Inherited @Inherited} annotations and without searching\n\t\t * superclasses or implemented interfaces.\n\t\t */\n\t\tDIRECT,\n\n\t\t/**\n\t\t * Find all directly declared annotations as well as any\n\t\t * {@link Inherited @Inherited} superclass annotations.\n\t\t * <p>This strategy is only really useful when used with {@link Class}\n\t\t * types since the {@link Inherited @Inherited} annotation is ignored for\n\t\t * all other {@linkplain AnnotatedElement annotated elements}.\n\t\t * <p>This strategy does not search implemented interfaces.\n\t\t */\n\t\tINHERITED_ANNOTATIONS,\n\n\t\t/**\n\t\t * Find all directly declared and superclass annotations.\n\t\t * <p>This strategy is similar to {@link #INHERITED_ANNOTATIONS} except\n\t\t * the annotations do not need to be meta-annotated with\n\t\t * {@link Inherited @Inherited}.\n\t\t * <p>This strategy does not search implemented interfaces.\n\t\t */\n\t\tSUPERCLASS,\n\n\t\t/**\n\t\t * Perform a full search of the entire type hierarchy, including\n\t\t * superclasses and implemented interfaces.\n\t\t * <p>When combined with {@link Search#withEnclosingClasses(Predicate)},\n\t\t * {@linkplain Class#getEnclosingClass() enclosing classes} will also be\n\t\t * recursively searched if the supplied {@link Predicate} evaluates to\n\t\t * {@code true}.\n\t\t * <p>Superclass and enclosing class annotations do not need to be\n\t\t * meta-annotated with {@link Inherited @Inherited}.\n\t\t */\n\t\tTYPE_HIERARCHY\n\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotations#isPresent(Class<A>)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Determine if the specified annotation type is either directly present or\r\n * meta-present.\r\n * <p>Equivalent to calling {@code get(annotationType).isPresent()}.\r\n * @param annotationType the annotation type to check\r\n * @return {@code true} if the annotation is present\r\n */\r\n<A extends Annotation> boolean isPresent(Class<A> annotationType);",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotations",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.MergedAnnotations#isPresent(Class<A>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotations#isPresent(String)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Determine if the specified annotation type is either directly present or\r\n * meta-present.\r\n * <p>Equivalent to calling {@code get(annotationType).isPresent()}.\r\n * @param annotationType the fully qualified class name of the annotation type\r\n * to check\r\n * @return {@code true} if the annotation is present\r\n */\r\nboolean isPresent(String annotationType);",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotations",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.MergedAnnotations#isPresent(String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotations#isDirectlyPresent(Class<A>)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Determine if the specified annotation type is directly present.\r\n * <p>Equivalent to calling {@code get(annotationType).isDirectlyPresent()}.\r\n * @param annotationType the annotation type to check\r\n * @return {@code true} if the annotation is directly present\r\n */\r\n<A extends Annotation> boolean isDirectlyPresent(Class<A> annotationType);",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotations",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.MergedAnnotations#isDirectlyPresent(Class<A>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotations#isDirectlyPresent(String)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Determine if the specified annotation type is directly present.\r\n * <p>Equivalent to calling {@code get(annotationType).isDirectlyPresent()}.\r\n * @param annotationType the fully qualified class name of the annotation type\r\n * to check\r\n * @return {@code true} if the annotation is directly present\r\n */\r\nboolean isDirectlyPresent(String annotationType);",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotations",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.MergedAnnotations#isDirectlyPresent(String)",
    "tailType": "method"
  }
]