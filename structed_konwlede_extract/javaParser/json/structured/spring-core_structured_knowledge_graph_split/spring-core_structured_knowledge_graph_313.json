[
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.ExceptionTests",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.ExceptionTests",
    "headType": "class",
    "relation": "use",
    "tail": "@Nested",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.ExceptionTests",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.util.Properties;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\nimport org.mockito.InOrder;\n\nimport org.springframework.util.PlaceholderParser.ParsedValue;\nimport org.springframework.util.PlaceholderParser.TextPart;\nimport org.springframework.util.PropertyPlaceholderHelper.PlaceholderResolver;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\nimport static org.mockito.BDDMockito.given;\nimport static org.mockito.Mockito.inOrder;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.verifyNoMoreInteractions;\n\n/**\n * Tests for {@link PlaceholderParser}.\n *\n * @author Stephane Nicoll\n */\nclass PlaceholderParserTests {\n\n\t@Nested // Tests with only the basic placeholder feature enabled\n\tclass OnlyPlaceholderTests {\n\n\t\tprivate final PlaceholderParser parser = new PlaceholderParser(\"${\", \"}\", null, null, true);\n\n\t\t@ParameterizedTest(name = \"{0} -> {1}\")\n\t\t@MethodSource(\"placeholders\")\n\t\tvoid placeholderIsReplaced(String text, String expected) {\n\t\t\tProperties properties = new Properties();\n\t\t\tproperties.setProperty(\"firstName\", \"John\");\n\t\t\tproperties.setProperty(\"nested0\", \"first\");\n\t\t\tproperties.setProperty(\"nested1\", \"Name\");\n\t\t\tassertThat(this.parser.replacePlaceholders(text, properties::getProperty)).isEqualTo(expected);\n\t\t}\n\n\t\tstatic Stream<Arguments> placeholders() {\n\t\t\treturn Stream.of(\n\t\t\t\t\tArguments.of(\"${firstName}\", \"John\"),\n\t\t\t\t\tArguments.of(\"$${firstName}\", \"$John\"),\n\t\t\t\t\tArguments.of(\"}${firstName}\", \"}John\"),\n\t\t\t\t\tArguments.of(\"${firstName}$\", \"John$\"),\n\t\t\t\t\tArguments.of(\"${firstName}}\", \"John}\"),\n\t\t\t\t\tArguments.of(\"${firstName} ${firstName}\", \"John John\"),\n\t\t\t\t\tArguments.of(\"First name: ${firstName}\", \"First name: John\"),\n\t\t\t\t\tArguments.of(\"${firstName} is the first name\", \"John is the first name\"),\n\t\t\t\t\tArguments.of(\"${first${nested1}}\", \"John\"),\n\t\t\t\t\tArguments.of(\"${${nested0}${nested1}}\", \"John\")\n\t\t\t);\n\t\t}\n\n\t\t@ParameterizedTest(name = \"{0} -> {1}\")\n\t\t@MethodSource(\"nestedPlaceholders\")\n\t\tvoid nestedPlaceholdersAreReplaced(String text, String expected) {\n\t\t\tProperties properties = new Properties();\n\t\t\tproperties.setProperty(\"p1\", \"v1\");\n\t\t\tproperties.setProperty(\"p2\", \"v2\");\n\t\t\tproperties.setProperty(\"p3\", \"${p1}:${p2}\");              // nested placeholders\n\t\t\tproperties.setProperty(\"p4\", \"${p3}\");                    // deeply nested placeholders\n\t\t\tproperties.setProperty(\"p5\", \"${p1}:${p2}:${bogus}\");     // unresolvable placeholder\n\t\t\tassertThat(this.parser.replacePlaceholders(text, properties::getProperty)).isEqualTo(expected);\n\t\t}\n\n\t\tstatic Stream<Arguments> nestedPlaceholders() {\n\t\t\treturn Stream.of(\n\t\t\t\t\tArguments.of(\"${p1}:${p2}\", \"v1:v2\"),\n\t\t\t\t\tArguments.of(\"${p3}\", \"v1:v2\"),\n\t\t\t\t\tArguments.of(\"${p4}\", \"v1:v2\"),\n\t\t\t\t\tArguments.of(\"${p5}\", \"v1:v2:${bogus}\"),\n\t\t\t\t\tArguments.of(\"${p0${p0}}\", \"${p0${p0}}\")\n\t\t\t);\n\t\t}\n\n\t\t@Test\n\t\tvoid parseWithSinglePlaceholder() {\n\t\t\tPlaceholderResolver resolver = mockPlaceholderResolver(\"firstName\", \"John\");\n\t\t\tassertThat(this.parser.replacePlaceholders(\"${firstName}\", resolver))\n\t\t\t\t\t.isEqualTo(\"John\");\n\t\t\tverify(resolver).resolvePlaceholder(\"firstName\");\n\t\t\tverifyNoMoreInteractions(resolver);\n\t\t}\n\n\t\t@Test\n\t\tvoid parseWithPlaceholderAndPrefixText() {\n\t\t\tPlaceholderResolver resolver = mockPlaceholderResolver(\"firstName\", \"John\");\n\t\t\tassertThat(this.parser.replacePlaceholders(\"This is ${firstName}\", resolver))\n\t\t\t\t\t.isEqualTo(\"This is John\");\n\t\t\tverify(resolver).resolvePlaceholder(\"firstName\");\n\t\t\tverifyNoMoreInteractions(resolver);\n\t\t}\n\n\t\t@Test\n\t\tvoid parseWithMultiplePlaceholdersAndText() {\n\t\t\tPlaceholderResolver resolver = mockPlaceholderResolver(\"firstName\", \"John\", \"lastName\", \"Smith\");\n\t\t\tassertThat(this.parser.replacePlaceholders(\"User: ${firstName} - ${lastName}.\", resolver))\n\t\t\t\t\t.isEqualTo(\"User: John - Smith.\");\n\t\t\tverify(resolver).resolvePlaceholder(\"firstName\");\n\t\t\tverify(resolver).resolvePlaceholder(\"lastName\");\n\t\t\tverifyNoMoreInteractions(resolver);\n\t\t}\n\n\t\t@Test\n\t\tvoid parseWithNestedPlaceholderInKey() {\n\t\t\tPlaceholderResolver resolver = mockPlaceholderResolver(\n\t\t\t\t\t\"nested\", \"Name\", \"firstName\", \"John\");\n\t\t\tassertThat(this.parser.replacePlaceholders(\"${first${nested}}\", resolver))\n\t\t\t\t\t.isEqualTo(\"John\");\n\t\t\tverifyPlaceholderResolutions(resolver, \"nested\", \"firstName\");\n\t\t}\n\n\t\t@Test\n\t\tvoid parseWithMultipleNestedPlaceholdersInKey() {\n\t\t\tPlaceholderResolver resolver = mockPlaceholderResolver(\n\t\t\t\t\t\"nested0\", \"first\", \"nested1\", \"Name\", \"firstName\", \"John\");\n\t\t\tassertThat(this.parser.replacePlaceholders(\"${${nested0}${nested1}}\", resolver))\n\t\t\t\t\t.isEqualTo(\"John\");\n\t\t\tverifyPlaceholderResolutions(resolver, \"nested0\", \"nested1\", \"firstName\");\n\t\t}\n\n\t\t@Test\n\t\tvoid placeholdersWithSeparatorAreHandledAsIs() {\n\t\t\tPlaceholderResolver resolver = mockPlaceholderResolver(\"my:test\", \"value\");\n\t\t\tassertThat(this.parser.replacePlaceholders(\"${my:test}\", resolver)).isEqualTo(\"value\");\n\t\t\tverifyPlaceholderResolutions(resolver, \"my:test\");\n\t\t}\n\n\t\t@Test\n\t\tvoid placeholdersWithoutEscapeCharAreNotEscaped() {\n\t\t\tPlaceholderResolver resolver = mockPlaceholderResolver(\"test\", \"value\");\n\t\t\tassertThat(this.parser.replacePlaceholders(\"\\\\${test}\", resolver)).isEqualTo(\"\\\\value\");\n\t\t\tverifyPlaceholderResolutions(resolver, \"test\");\n\t\t}\n\n\t\t@Test\n\t\tvoid textWithInvalidPlaceholderIsMerged() {\n\t\t\tString text = \"test${of${with${and${\";\n\t\t\tParsedValue parsedValue = this.parser.parse(text);\n\t\t\tassertThat(parsedValue.parts()).singleElement().isInstanceOfSatisfying(\n\t\t\t\t\tTextPart.class, textPart -> assertThat(textPart.text()).isEqualTo(text));\n\t\t}\n\n\t}\n\n\t@Nested // Tests with the use of a separator\n\tclass DefaultValueTests {\n\n\t\tprivate final PlaceholderParser parser = new PlaceholderParser(\"${\", \"}\", \":\", null, true);\n\n\t\t@ParameterizedTest(name = \"{0} -> {1}\")\n\t\t@MethodSource(\"placeholders\")\n\t\tvoid placeholderIsReplaced(String text, String expected) {\n\t\t\tProperties properties = new Properties();\n\t\t\tproperties.setProperty(\"firstName\", \"John\");\n\t\t\tproperties.setProperty(\"nested0\", \"first\");\n\t\t\tproperties.setProperty(\"nested1\", \"Name\");\n\t\t\tassertThat(this.parser.replacePlaceholders(text, properties::getProperty)).isEqualTo(expected);\n\t\t}\n\n\t\tstatic Stream<Arguments> placeholders() {\n\t\t\treturn Stream.of(\n\t\t\t\t\tArguments.of(\"${invalid:John}\", \"John\"),\n\t\t\t\t\tArguments.of(\"${first${invalid:Name}}\", \"John\"),\n\t\t\t\t\tArguments.of(\"${invalid:${firstName}}\", \"John\"),\n\t\t\t\t\tArguments.of(\"${invalid:${${nested0}${nested1}}}\", \"John\"),\n\t\t\t\t\tArguments.of(\"${invalid:$${firstName}}\", \"$John\"),\n\t\t\t\t\tArguments.of(\"${invalid: }${firstName}\", \" John\"),\n\t\t\t\t\tArguments.of(\"${invalid:}\", \"\"),\n\t\t\t\t\tArguments.of(\"${:}\", \"\")\n\t\t\t);\n\t\t}\n\n\t\t@ParameterizedTest(name = \"{0} -> {1}\")\n\t\t@MethodSource(\"nestedPlaceholders\")\n\t\tvoid nestedPlaceholdersAreReplaced(String text, String expected) {\n\t\t\tProperties properties = new Properties();\n\t\t\tproperties.setProperty(\"p1\", \"v1\");\n\t\t\tproperties.setProperty(\"p2\", \"v2\");\n\t\t\tproperties.setProperty(\"p3\", \"${p1}:${p2}\");              // nested placeholders\n\t\t\tproperties.setProperty(\"p4\", \"${p3}\");                    // deeply nested placeholders\n\t\t\tproperties.setProperty(\"p5\", \"${p1}:${p2}:${bogus}\");     // unresolvable placeholder\n\t\t\tproperties.setProperty(\"p6\", \"${p1}:${p2}:${bogus:def}\"); // unresolvable w/ default\n\t\t\tassertThat(this.parser.replacePlaceholders(text, properties::getProperty)).isEqualTo(expected);\n\t\t}\n\n\t\tstatic Stream<Arguments> nestedPlaceholders() {\n\t\t\treturn Stream.of(\n\t\t\t\t\tArguments.of(\"${p6}\", \"v1:v2:def\"),\n\t\t\t\t\tArguments.of(\"${p6:not-used}\", \"v1:v2:def\"),\n\t\t\t\t\tArguments.of(\"${p6:${invalid}}\", \"v1:v2:def\"),\n\t\t\t\t\tArguments.of(\"${invalid:${p1}:${p2}}\", \"v1:v2\"),\n\t\t\t\t\tArguments.of(\"${invalid:${p3}}\", \"v1:v2\"),\n\t\t\t\t\tArguments.of(\"${invalid:${p4}}\", \"v1:v2\"),\n\t\t\t\t\tArguments.of(\"${invalid:${p5}}\", \"v1:v2:${bogus}\"),\n\t\t\t\t\tArguments.of(\"${invalid:${p6}}\", \"v1:v2:def\")\n\t\t\t);\n\t\t}\n\n\t\t@ParameterizedTest(name = \"{0} -> {1}\")\n\t\t@MethodSource(\"exactMatchPlaceholders\")\n\t\tvoid placeholdersWithExactMatchAreConsidered(String text, String expected) {\n\t\t\tProperties properties = new Properties();\n\t\t\tproperties.setProperty(\"prefix://my-service\", \"example-service\");\n\t\t\tproperties.setProperty(\"px\", \"prefix\");\n\t\t\tproperties.setProperty(\"p1\", \"${prefix://my-service}\");\n\t\t\tassertThat(this.parser.replacePlaceholders(text, properties::getProperty)).isEqualTo(expected);\n\t\t}\n\n\t\tstatic Stream<Arguments> exactMatchPlaceholders() {\n\t\t\treturn Stream.of(\n\t\t\t\t\tArguments.of(\"${prefix://my-service}\", \"example-service\"),\n\t\t\t\t\tArguments.of(\"${p1}\", \"example-service\")\n\t\t\t);\n\t\t}\n\n\t\t@Test\n\t\tvoid parseWithKeyEqualsToText() {\n\t\t\tPlaceholderResolver resolver = mockPlaceholderResolver(\"firstName\", \"Steve\");\n\t\t\tassertThat(this.parser.replacePlaceholders(\"${firstName}\", resolver))\n\t\t\t\t\t.isEqualTo(\"Steve\");\n\t\t\tverifyPlaceholderResolutions(resolver, \"firstName\");\n\t\t}\n\n\t\t@Test\n\t\tvoid parseWithHardcodedFallback() {\n\t\t\tPlaceholderResolver resolver = mockPlaceholderResolver();\n\t\t\tassertThat(this.parser.replacePlaceholders(\"${firstName:Steve}\", resolver))\n\t\t\t\t\t.isEqualTo(\"Steve\");\n\t\t\tverifyPlaceholderResolutions(resolver, \"firstName:Steve\", \"firstName\");\n\t\t}\n\n\t\t@Test\n\t\tvoid parseWithNestedPlaceholderInKeyUsingFallback() {\n\t\t\tPlaceholderResolver resolver = mockPlaceholderResolver(\"firstName\", \"John\");\n\t\t\tassertThat(this.parser.replacePlaceholders(\"${first${invalid:Name}}\", resolver))\n\t\t\t\t\t.isEqualTo(\"John\");\n\t\t\tverifyPlaceholderResolutions(resolver, \"invalid:Name\", \"invalid\", \"firstName\");\n\t\t}\n\n\t\t@Test\n\t\tvoid parseWithFallbackUsingPlaceholder() {\n\t\t\tPlaceholderResolver resolver = mockPlaceholderResolver(\"firstName\", \"John\");\n\t\t\tassertThat(this.parser.replacePlaceholders(\"${invalid:${firstName}}\", resolver))\n\t\t\t\t\t.isEqualTo(\"John\");\n\t\t\tverifyPlaceholderResolutions(resolver, \"invalid\", \"firstName\");\n\t\t}\n\n\t}\n\n\t@Nested // Tests with the use of the escape character\n\tclass EscapedTests {\n\n\t\tprivate final PlaceholderParser parser = new PlaceholderParser(\"${\", \"}\", \":\", '\\\\', true);\n\n\t\t@ParameterizedTest(name = \"{0} -> {1}\")\n\t\t@MethodSource(\"escapedInNestedPlaceholders\")\n\t\tvoid escapedSeparatorInNestedPlaceholder(String text, String expected) {\n\t\t\tProperties properties = new Properties();\n\t\t\tproperties.setProperty(\"app.environment\", \"qa\");\n\t\t\tproperties.setProperty(\"app.service\", \"protocol\");\n\t\t\tproperties.setProperty(\"protocol://host/qa/name\", \"protocol://example.com/qa/name\");\n\t\t\tproperties.setProperty(\"service/host/qa/name\", \"https://example.com/qa/name\");\n\t\t\tproperties.setProperty(\"service/host/qa/name:value\", \"https://example.com/qa/name-value\");\n\t\t\tassertThat(this.parser.replacePlaceholders(text, properties::getProperty)).isEqualTo(expected);\n\t\t}\n\n\t\tstatic Stream<Arguments> escapedInNestedPlaceholders() {\n\t\t\treturn Stream.of(\n\t\t\t\t\tArguments.of(\"${protocol\\\\://host/${app.environment}/name}\", \"protocol://example.com/qa/name\"),\n\t\t\t\t\tArguments.of(\"${${app.service}\\\\://host/${app.environment}/name}\", \"protocol://example.com/qa/name\"),\n\t\t\t\t\tArguments.of(\"${service/host/${app.environment}/name:\\\\value}\", \"https://example.com/qa/name\"),\n\t\t\t\t\tArguments.of(\"${service/host/${name\\\\:value}/}\", \"${service/host/${name:value}/}\"));\n\t\t}\n\n\t\t@ParameterizedTest(name = \"{0} -> {1}\")\n\t\t@MethodSource(\"escapedPlaceholders\")\n\t\tvoid escapedPlaceholderIsNotReplaced(String text, String expected) {\n\t\t\tPlaceholderResolver resolver = mockPlaceholderResolver(\n\t\t\t\t\t\"firstName\", \"John\", \"nested0\", \"first\", \"nested1\", \"Name\",\n\t\t\t\t\t\"${test}\", \"John\",\n\t\t\t\t\t\"p1\", \"v1\", \"p2\", \"\\\\${p1:default}\", \"p3\", \"${p2}\",\n\t\t\t\t\t\"p4\", \"adc${p0:\\\\${p1}}\",\n\t\t\t\t\t\"p5\", \"adc${\\\\${p0}:${p1}}\",\n\t\t\t\t\t\"p6\", \"adc${p0:def\\\\${p1}}\",\n\t\t\t\t\t\"p7\", \"adc\\\\${\");\n\t\t\tassertThat(this.parser.replacePlaceholders(text, resolver)).isEqualTo(expected);\n\t\t}\n\n\t\tstatic Stream<Arguments> escapedPlaceholders() {\n\t\t\treturn Stream.of(\n\t\t\t\t\tArguments.of(\"\\\\${firstName}\", \"${firstName}\"),\n\t\t\t\t\tArguments.of(\"First name: \\\\${firstName}\", \"First name: ${firstName}\"),\n\t\t\t\t\tArguments.of(\"$\\\\${firstName}\", \"$${firstName}\"),\n\t\t\t\t\tArguments.of(\"\\\\}${firstName}\", \"\\\\}John\"),\n\t\t\t\t\tArguments.of(\"${\\\\${test}}\", \"John\"),\n\t\t\t\t\tArguments.of(\"${p2}\", \"${p1:default}\"),\n\t\t\t\t\tArguments.of(\"${p3}\", \"${p1:default}\"),\n\t\t\t\t\tArguments.of(\"${p4}\", \"adc${p1}\"),\n\t\t\t\t\tArguments.of(\"${p5}\", \"adcv1\"),\n\t\t\t\t\tArguments.of(\"${p6}\", \"adcdef${p1}\"),\n\t\t\t\t\tArguments.of(\"${p7}\", \"adc\\\\${\"));\n\n\t\t}\n\n\t\t@ParameterizedTest(name = \"{0} -> {1}\")\n\t\t@MethodSource(\"escapedSeparators\")\n\t\tvoid escapedSeparatorIsNotReplaced(String text, String expected) {\n\t\t\tProperties properties = new Properties();\n\t\t\tproperties.setProperty(\"first:Name\", \"John\");\n\t\t\tproperties.setProperty(\"nested0\", \"first\");\n\t\t\tproperties.setProperty(\"nested1\", \"Name\");\n\t\t\tassertThat(this.parser.replacePlaceholders(text, properties::getProperty)).isEqualTo(expected);\n\t\t}\n\n\t\tstatic Stream<Arguments> escapedSeparators() {\n\t\t\treturn Stream.of(\n\t\t\t\t\tArguments.of(\"${first\\\\:Name}\", \"John\"),\n\t\t\t\t\tArguments.of(\"${last\\\\:Name}\", \"${last:Name}\")\n\t\t\t);\n\t\t}\n\n\t}\n\n\t@Nested\n\tclass ExceptionTests {\n\n\t\tprivate final PlaceholderParser parser = new PlaceholderParser(\"${\", \"}\", \":\", null, false);\n\n\t\t@Test\n\t\tvoid textWithCircularReference() {\n\t\t\tPlaceholderResolver resolver = mockPlaceholderResolver(\"pL\", \"${pR}\", \"pR\", \"${pL}\");\n\t\t\tassertThatThrownBy(() -> this.parser.replacePlaceholders(\"${pL}\", resolver))\n\t\t\t\t\t.isInstanceOf(PlaceholderResolutionException.class)\n\t\t\t\t\t.hasMessage(\"Circular placeholder reference 'pL' in value \\\"${pL}\\\" <-- \\\"${pR}\\\" <-- \\\"${pL}\\\"\");\n\t\t}\n\n\t\t@Test\n\t\tvoid unresolvablePlaceholderIsReported() {\n\t\t\tPlaceholderResolver resolver = mockPlaceholderResolver();\n\t\t\tassertThatExceptionOfType(PlaceholderResolutionException.class)\n\t\t\t\t\t.isThrownBy(() -> this.parser.replacePlaceholders(\"${bogus}\", resolver))\n\t\t\t\t\t.withMessage(\"Could not resolve placeholder 'bogus' in value \\\"${bogus}\\\"\")\n\t\t\t\t\t.withNoCause();\n\t\t}\n\n\t\t@Test\n\t\tvoid unresolvablePlaceholderInNestedPlaceholderIsReportedWithChain() {\n\t\t\tPlaceholderResolver resolver = mockPlaceholderResolver(\"p1\", \"v1\", \"p2\", \"v2\",\n\t\t\t\t\t\"p3\", \"${p1}:${p2}:${bogus}\");\n\t\t\tassertThatExceptionOfType(PlaceholderResolutionException.class)\n\t\t\t\t\t.isThrownBy(() -> this.parser.replacePlaceholders(\"${p3}\", resolver))\n\t\t\t\t\t.withMessage(\"Could not resolve placeholder 'bogus' in value \\\"${p1}:${p2}:${bogus}\\\" <-- \\\"${p3}\\\"\")\n\t\t\t\t\t.withNoCause();\n\t\t}\n\n\t}\n\n\tPlaceholderResolver mockPlaceholderResolver(String... pairs) {\n\t\tif (pairs.length % 2 == 1) {\n\t\t\tthrow new IllegalArgumentException(\"size must be even, it is a set of key=value pairs\");\n\t\t}\n\t\tPlaceholderResolver resolver = mock();\n\t\tfor (int i = 0; i < pairs.length; i += 2) {\n\t\t\tString key = pairs[i];\n\t\t\tString value = pairs[i + 1];\n\t\t\tgiven(resolver.resolvePlaceholder(key)).willReturn(value);\n\t\t}\n\t\treturn resolver;\n\t}\n\n\tvoid verifyPlaceholderResolutions(PlaceholderResolver mock, String... placeholders) {\n\t\tInOrder ordered = inOrder(mock);\n\t\tfor (String placeholder : placeholders) {\n\t\t\tordered.verify(mock).resolvePlaceholder(placeholder);\n\t\t}\n\t\tverifyNoMoreInteractions(mock);\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.ExceptionTests",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.ExceptionTests#parser",
    "tailType": "field"
  },
  {
    "head": "org.springframework.util.ExceptionTests#parser",
    "headType": "field",
    "relation": "haveType",
    "tail": "PlaceholderParser",
    "tailType": "type"
  },
  {
    "head": "org.springframework.util.ExceptionTests#textWithCircularReference()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid textWithCircularReference() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver(\"pL\", \"${pR}\", \"pR\", \"${pL}\");\r\n    assertThatThrownBy(() -> this.parser.replacePlaceholders(\"${pL}\", resolver)).isInstanceOf(PlaceholderResolutionException.class).hasMessage(\"Circular placeholder reference 'pL' in value \\\"${pL}\\\" <-- \\\"${pR}\\\" <-- \\\"${pL}\\\"\");\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.ExceptionTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.ExceptionTests#textWithCircularReference()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.ExceptionTests#textWithCircularReference()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.ExceptionTests#unresolvablePlaceholderIsReported()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid unresolvablePlaceholderIsReported() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver();\r\n    assertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(() -> this.parser.replacePlaceholders(\"${bogus}\", resolver)).withMessage(\"Could not resolve placeholder 'bogus' in value \\\"${bogus}\\\"\").withNoCause();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.ExceptionTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.ExceptionTests#unresolvablePlaceholderIsReported()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.ExceptionTests#unresolvablePlaceholderIsReported()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.ExceptionTests#unresolvablePlaceholderInNestedPlaceholderIsReportedWithChain()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid unresolvablePlaceholderInNestedPlaceholderIsReportedWithChain() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver(\"p1\", \"v1\", \"p2\", \"v2\", \"p3\", \"${p1}:${p2}:${bogus}\");\r\n    assertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(() -> this.parser.replacePlaceholders(\"${p3}\", resolver)).withMessage(\"Could not resolve placeholder 'bogus' in value \\\"${p1}:${p2}:${bogus}\\\" <-- \\\"${p3}\\\"\").withNoCause();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.ExceptionTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.ExceptionTests#unresolvablePlaceholderInNestedPlaceholderIsReportedWithChain()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.ExceptionTests#unresolvablePlaceholderInNestedPlaceholderIsReportedWithChain()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.asm",
    "tailType": "package"
  },
  {
    "head": "org.springframework.asm",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.asm.ByteVector",
    "tailType": "class"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.util",
    "tailType": "package"
  },
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.PropertiesPersisterTests",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.PropertiesPersisterTests",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.util.Properties;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * @author Juergen Hoeller\n * @since 11.01.2005\n */\nclass PropertiesPersisterTests {\n\n\t@Test\n\tvoid propertiesPersister() throws IOException {\n\t\tString propString = \"code1=message1\\ncode2:message2\";\n\t\tProperties props = loadProperties(propString, false);\n\t\tString propCopy = storeProperties(props, null, false);\n\t\tloadProperties(propCopy, false);\n\t}\n\n\t@Test\n\tvoid propertiesPersisterWithWhitespace() throws IOException {\n\t\tString propString = \" code1\\t= \\tmessage1\\n  code2 \\t  :\\t mess\\\\\\n \\t  age2\";\n\t\tProperties props = loadProperties(propString, false);\n\t\tString propCopy = storeProperties(props, null, false);\n\t\tloadProperties(propCopy, false);\n\t}\n\n\t@Test\n\tvoid propertiesPersisterWithHeader() throws IOException {\n\t\tString propString = \"code1=message1\\ncode2:message2\";\n\t\tProperties props = loadProperties(propString, false);\n\t\tString propCopy = storeProperties(props, \"myHeader\", false);\n\t\tloadProperties(propCopy, false);\n\t}\n\n\t@Test\n\tvoid propertiesPersisterWithEmptyValue() throws IOException {\n\t\tString propString = \"code1=message1\\ncode2:message2\\ncode3=\";\n\t\tProperties props = loadProperties(propString, false);\n\t\tString propCopy = storeProperties(props, null, false);\n\t\tloadProperties(propCopy, false);\n\t}\n\n\t@Test\n\tvoid propertiesPersisterWithReader() throws IOException {\n\t\tString propString = \"code1=message1\\ncode2:message2\";\n\t\tProperties props = loadProperties(propString, true);\n\t\tString propCopy = storeProperties(props, null, true);\n\t\tloadProperties(propCopy, false);\n\t}\n\n\t@Test\n\tvoid propertiesPersisterWithReaderAndWhitespace() throws IOException {\n\t\tString propString = \" code1\\t= \\tmessage1\\n  code2 \\t  :\\t mess\\\\\\n \\t  age2\";\n\t\tProperties props = loadProperties(propString, true);\n\t\tString propCopy = storeProperties(props, null, true);\n\t\tloadProperties(propCopy, false);\n\t}\n\n\t@Test\n\tvoid propertiesPersisterWithReaderAndHeader() throws IOException {\n\t\tString propString = \"code1\\t=\\tmessage1\\n  code2 \\t  : \\t message2\";\n\t\tProperties props = loadProperties(propString, true);\n\t\tString propCopy = storeProperties(props, \"myHeader\", true);\n\t\tloadProperties(propCopy, false);\n\t}\n\n\t@Test\n\tvoid propertiesPersisterWithReaderAndEmptyValue() throws IOException {\n\t\tString propString = \"code1=message1\\ncode2:message2\\ncode3=\";\n\t\tProperties props = loadProperties(propString, true);\n\t\tString propCopy = storeProperties(props, null, true);\n\t\tloadProperties(propCopy, false);\n\t}\n\n\tprivate Properties loadProperties(String propString, boolean useReader) throws IOException {\n\t\tDefaultPropertiesPersister persister = new DefaultPropertiesPersister();\n\t\tProperties props = new Properties();\n\t\tif (useReader) {\n\t\t\tpersister.load(props, new StringReader(propString));\n\t\t}\n\t\telse {\n\t\t\tpersister.load(props, new ByteArrayInputStream(propString.getBytes()));\n\t\t}\n\t\tassertThat(props.getProperty(\"code1\")).isEqualTo(\"message1\");\n\t\tassertThat(props.getProperty(\"code2\")).isEqualTo(\"message2\");\n\t\treturn props;\n\t}\n\n\tprivate String storeProperties(Properties props, String header, boolean useWriter) throws IOException {\n\t\tDefaultPropertiesPersister persister = new DefaultPropertiesPersister();\n\t\tString propCopy;\n\t\tif (useWriter) {\n\t\t\tStringWriter propWriter = new StringWriter();\n\t\t\tpersister.store(props, propWriter, header);\n\t\t\tpropCopy = propWriter.toString();\n\t\t}\n\t\telse {\n\t\t\tByteArrayOutputStream propOut = new ByteArrayOutputStream();\n\t\t\tpersister.store(props, propOut, header);\n\t\t\tpropCopy = new String(propOut.toByteArray());\n\t\t}\n\t\tif (header != null) {\n\t\t\tassertThat(propCopy).contains(header);\n\t\t}\n\t\tassertThat(propCopy).contains(\"\\ncode1=message1\");\n\t\tassertThat(propCopy).contains(\"\\ncode2=message2\");\n\t\treturn propCopy;\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.asm.ByteVector",
    "headType": "class",
    "relation": "provide",
    "tail": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage org.springframework.asm;\n\n/**\n * A dynamically extensible vector of bytes. This class is roughly equivalent to a DataOutputStream\n * on top of a ByteArrayOutputStream, but is more efficient.\n *\n * @author Eric Bruneton\n */\npublic class ByteVector {\n\n  /** The content of this vector. Only the first {@link #length} bytes contain real data. */\n  byte[] data;\n\n  /** The actual number of bytes in this vector. */\n  int length;\n\n  /** Constructs a new {@link ByteVector} with a default initial capacity. */\n  public ByteVector() {\n    data = new byte[64];\n  }\n\n  /**\n   * Constructs a new {@link ByteVector} with the given initial capacity.\n   *\n   * @param initialCapacity the initial capacity of the byte vector to be constructed.\n   */\n  public ByteVector(final int initialCapacity) {\n    data = new byte[initialCapacity];\n  }\n\n  /**\n   * Constructs a new {@link ByteVector} from the given initial data.\n   *\n   * @param data the initial data of the new byte vector.\n   */\n  ByteVector(final byte[] data) {\n    this.data = data;\n    this.length = data.length;\n  }\n\n  /**\n   * Returns the actual number of bytes in this vector.\n   *\n   * @return the actual number of bytes in this vector.\n   */\n  public int size() {\n    return length;\n  }\n\n  /**\n   * Puts a byte into this byte vector. The byte vector is automatically enlarged if necessary.\n   *\n   * @param byteValue a byte.\n   * @return this byte vector.\n   */\n  public ByteVector putByte(final int byteValue) {\n    int currentLength = length;\n    if (currentLength + 1 > data.length) {\n      enlarge(1);\n    }\n    data[currentLength++] = (byte) byteValue;\n    length = currentLength;\n    return this;\n  }\n\n  /**\n   * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n   *\n   * @param byteValue1 a byte.\n   * @param byteValue2 another byte.\n   * @return this byte vector.\n   */\n  final ByteVector put11(final int byteValue1, final int byteValue2) {\n    int currentLength = length;\n    if (currentLength + 2 > data.length) {\n      enlarge(2);\n    }\n    byte[] currentData = data;\n    currentData[currentLength++] = (byte) byteValue1;\n    currentData[currentLength++] = (byte) byteValue2;\n    length = currentLength;\n    return this;\n  }\n\n  /**\n   * Puts a short into this byte vector. The byte vector is automatically enlarged if necessary.\n   *\n   * @param shortValue a short.\n   * @return this byte vector.\n   */\n  public ByteVector putShort(final int shortValue) {\n    int currentLength = length;\n    if (currentLength + 2 > data.length) {\n      enlarge(2);\n    }\n    byte[] currentData = data;\n    currentData[currentLength++] = (byte) (shortValue >>> 8);\n    currentData[currentLength++] = (byte) shortValue;\n    length = currentLength;\n    return this;\n  }\n\n  /**\n   * Puts a byte and a short into this byte vector. The byte vector is automatically enlarged if\n   * necessary.\n   *\n   * @param byteValue a byte.\n   * @param shortValue a short.\n   * @return this byte vector.\n   */\n  final ByteVector put12(final int byteValue, final int shortValue) {\n    int currentLength = length;\n    if (currentLength + 3 > data.length) {\n      enlarge(3);\n    }\n    byte[] currentData = data;\n    currentData[currentLength++] = (byte) byteValue;\n    currentData[currentLength++] = (byte) (shortValue >>> 8);\n    currentData[currentLength++] = (byte) shortValue;\n    length = currentLength;\n    return this;\n  }\n\n  /**\n   * Puts two bytes and a short into this byte vector. The byte vector is automatically enlarged if\n   * necessary.\n   *\n   * @param byteValue1 a byte.\n   * @param byteValue2 another byte.\n   * @param shortValue a short.\n   * @return this byte vector.\n   */\n  final ByteVector put112(final int byteValue1, final int byteValue2, final int shortValue) {\n    int currentLength = length;\n    if (currentLength + 4 > data.length) {\n      enlarge(4);\n    }\n    byte[] currentData = data;\n    currentData[currentLength++] = (byte) byteValue1;\n    currentData[currentLength++] = (byte) byteValue2;\n    currentData[currentLength++] = (byte) (shortValue >>> 8);\n    currentData[currentLength++] = (byte) shortValue;\n    length = currentLength;\n    return this;\n  }\n\n  /**\n   * Puts an int into this byte vector. The byte vector is automatically enlarged if necessary.\n   *\n   * @param intValue an int.\n   * @return this byte vector.\n   */\n  public ByteVector putInt(final int intValue) {\n    int currentLength = length;\n    if (currentLength + 4 > data.length) {\n      enlarge(4);\n    }\n    byte[] currentData = data;\n    currentData[currentLength++] = (byte) (intValue >>> 24);\n    currentData[currentLength++] = (byte) (intValue >>> 16);\n    currentData[currentLength++] = (byte) (intValue >>> 8);\n    currentData[currentLength++] = (byte) intValue;\n    length = currentLength;\n    return this;\n  }\n\n  /**\n   * Puts one byte and two shorts into this byte vector. The byte vector is automatically enlarged\n   * if necessary.\n   *\n   * @param byteValue a byte.\n   * @param shortValue1 a short.\n   * @param shortValue2 another short.\n   * @return this byte vector.\n   */\n  final ByteVector put122(final int byteValue, final int shortValue1, final int shortValue2) {\n    int currentLength = length;\n    if (currentLength + 5 > data.length) {\n      enlarge(5);\n    }\n    byte[] currentData = data;\n    currentData[currentLength++] = (byte) byteValue;\n    currentData[currentLength++] = (byte) (shortValue1 >>> 8);\n    currentData[currentLength++] = (byte) shortValue1;\n    currentData[currentLength++] = (byte) (shortValue2 >>> 8);\n    currentData[currentLength++] = (byte) shortValue2;\n    length = currentLength;\n    return this;\n  }\n\n  /**\n   * Puts a long into this byte vector. The byte vector is automatically enlarged if necessary.\n   *\n   * @param longValue a long.\n   * @return this byte vector.\n   */\n  public ByteVector putLong(final long longValue) {\n    int currentLength = length;\n    if (currentLength + 8 > data.length) {\n      enlarge(8);\n    }\n    byte[] currentData = data;\n    int intValue = (int) (longValue >>> 32);\n    currentData[currentLength++] = (byte) (intValue >>> 24);\n    currentData[currentLength++] = (byte) (intValue >>> 16);\n    currentData[currentLength++] = (byte) (intValue >>> 8);\n    currentData[currentLength++] = (byte) intValue;\n    intValue = (int) longValue;\n    currentData[currentLength++] = (byte) (intValue >>> 24);\n    currentData[currentLength++] = (byte) (intValue >>> 16);\n    currentData[currentLength++] = (byte) (intValue >>> 8);\n    currentData[currentLength++] = (byte) intValue;\n    length = currentLength;\n    return this;\n  }\n\n  /**\n   * Puts an UTF8 string into this byte vector. The byte vector is automatically enlarged if\n   * necessary.\n   *\n   * @param stringValue a String whose UTF8 encoded length must be less than 65536.\n   * @return this byte vector.\n   */\n  // DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).\n  public ByteVector putUTF8(final String stringValue) {\n    int charLength = stringValue.length();\n    if (charLength > 65535) {\n      throw new IllegalArgumentException(\"UTF8 string too large\");\n    }\n    int currentLength = length;\n    if (currentLength + 2 + charLength > data.length) {\n      enlarge(2 + charLength);\n    }\n    byte[] currentData = data;\n    // Optimistic algorithm: instead of computing the byte length and then serializing the string\n    // (which requires two loops), we assume the byte length is equal to char length (which is the\n    // most frequent case), and we start serializing the string right away. During the\n    // serialization, if we find that this assumption is wrong, we continue with the general method.\n    currentData[currentLength++] = (byte) (charLength >>> 8);\n    currentData[currentLength++] = (byte) charLength;\n    for (int i = 0; i < charLength; ++i) {\n      char charValue = stringValue.charAt(i);\n      if (charValue >= '\\u0001' && charValue <= '\\u007F') {\n        currentData[currentLength++] = (byte) charValue;\n      } else {\n        length = currentLength;\n        return encodeUtf8(stringValue, i, 65535);\n      }\n    }\n    length = currentLength;\n    return this;\n  }\n\n  /**\n   * Puts an UTF8 string into this byte vector. The byte vector is automatically enlarged if\n   * necessary. The string length is encoded in two bytes before the encoded characters, if there is\n   * space for that (i.e. if this.length - offset - 2 &gt;= 0).\n   *\n   * @param stringValue the String to encode.\n   * @param offset the index of the first character to encode. The previous characters are supposed\n   *     to have already been encoded, using only one byte per character.\n   * @param maxByteLength the maximum byte length of the encoded string, including the already\n   *     encoded characters.\n   * @return this byte vector.\n   */\n  final ByteVector encodeUtf8(final String stringValue, final int offset, final int maxByteLength) {\n    int charLength = stringValue.length();\n    int byteLength = offset;\n    for (int i = offset; i < charLength; ++i) {\n      char charValue = stringValue.charAt(i);\n      if (charValue >= 0x0001 && charValue <= 0x007F) {\n        byteLength++;\n      } else if (charValue <= 0x07FF) {\n        byteLength += 2;\n      } else {\n        byteLength += 3;\n      }\n    }\n    if (byteLength > maxByteLength) {\n      throw new IllegalArgumentException(\"UTF8 string too large\");\n    }\n    // Compute where 'byteLength' must be stored in 'data', and store it at this location.\n    int byteLengthOffset = length - offset - 2;\n    if (byteLengthOffset >= 0) {\n      data[byteLengthOffset] = (byte) (byteLength >>> 8);\n      data[byteLengthOffset + 1] = (byte) byteLength;\n    }\n    if (length + byteLength - offset > data.length) {\n      enlarge(byteLength - offset);\n    }\n    int currentLength = length;\n    for (int i = offset; i < charLength; ++i) {\n      char charValue = stringValue.charAt(i);\n      if (charValue >= 0x0001 && charValue <= 0x007F) {\n        data[currentLength++] = (byte) charValue;\n      } else if (charValue <= 0x07FF) {\n        data[currentLength++] = (byte) (0xC0 | charValue >> 6 & 0x1F);\n        data[currentLength++] = (byte) (0x80 | charValue & 0x3F);\n      } else {\n        data[currentLength++] = (byte) (0xE0 | charValue >> 12 & 0xF);\n        data[currentLength++] = (byte) (0x80 | charValue >> 6 & 0x3F);\n        data[currentLength++] = (byte) (0x80 | charValue & 0x3F);\n      }\n    }\n    length = currentLength;\n    return this;\n  }\n\n  /**\n   * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if\n   * necessary.\n   *\n   * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} null\n   *     bytes into this byte vector.\n   * @param byteOffset index of the first byte of byteArrayValue that must be copied.\n   * @param byteLength number of bytes of byteArrayValue that must be copied.\n   * @return this byte vector.\n   */\n  public ByteVector putByteArray(\n      final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\n    if (length + byteLength > data.length) {\n      enlarge(byteLength);\n    }\n    if (byteArrayValue != null) {\n      System.arraycopy(byteArrayValue, byteOffset, data, length, byteLength);\n    }\n    length += byteLength;\n    return this;\n  }\n\n  /**\n   * Enlarges this byte vector so that it can receive 'size' more bytes.\n   *\n   * @param size number of additional bytes that this byte vector should be able to receive.\n   */\n  private void enlarge(final int size) {\n    if (length > data.length) {\n      throw new AssertionError(\"Internal error\");\n    }\n    int doubleCapacity = 2 * data.length;\n    int minimalCapacity = length + size;\n    byte[] newData = new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];\n    System.arraycopy(data, 0, newData, 0, length);\n    data = newData;\n  }\n}\n",
    "tailType": "class_code"
  }
]