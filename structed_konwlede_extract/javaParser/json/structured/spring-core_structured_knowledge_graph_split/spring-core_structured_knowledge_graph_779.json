[
  {
    "head": "org.springframework.core.annotation.MergedAnnotation",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.MergedAnnotation#missing()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotation#from(A)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Create a new {@link MergedAnnotation} instance from the specified\r\n * annotation.\r\n * @param annotation the annotation to include\r\n * @return a {@link MergedAnnotation} instance containing the annotation\r\n */\r\nstatic <A extends Annotation> MergedAnnotation<A> from(A annotation) {\r\n    return from(null, annotation);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotation",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.MergedAnnotation#from(A)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotation#from(Object,A)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Create a new {@link MergedAnnotation} instance from the specified\r\n * annotation.\r\n * @param source the source for the annotation. This source is used only for\r\n * information and logging. It does not need to <em>actually</em> contain\r\n * the specified annotations, and it will not be searched.\r\n * @param annotation the annotation to include\r\n * @return a {@link MergedAnnotation} instance for the annotation\r\n */\r\nstatic <A extends Annotation> MergedAnnotation<A> from(@Nullable Object source, A annotation) {\r\n    return TypeMappedAnnotation.from(source, annotation);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotation",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.MergedAnnotation#from(Object,A)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotation#of(Class<A>)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Create a new {@link MergedAnnotation} instance of the specified\r\n * annotation type. The resulting annotation will not have any attribute\r\n * values but may still be used to query default values.\r\n * @param annotationType the annotation type\r\n * @return a {@link MergedAnnotation} instance for the annotation\r\n */\r\nstatic <A extends Annotation> MergedAnnotation<A> of(Class<A> annotationType) {\r\n    return of(null, annotationType, null);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotation",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.MergedAnnotation#of(Class<A>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotation#of(Class<A>,Map<String,?>)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Create a new {@link MergedAnnotation} instance of the specified\r\n * annotation type with attribute values supplied by a map.\r\n * @param annotationType the annotation type\r\n * @param attributes the annotation attributes or {@code null} if just default\r\n * values should be used\r\n * @return a {@link MergedAnnotation} instance for the annotation and attributes\r\n * @see #of(AnnotatedElement, Class, Map)\r\n */\r\nstatic <A extends Annotation> MergedAnnotation<A> of(Class<A> annotationType, @Nullable Map<String, ?> attributes) {\r\n    return of(null, annotationType, attributes);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotation",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.MergedAnnotation#of(Class<A>,Map<String,?>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotation#of(AnnotatedElement,Class<A>,Map<String,?>)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Create a new {@link MergedAnnotation} instance of the specified\r\n * annotation type with attribute values supplied by a map.\r\n * @param source the source for the annotation. This source is used only for\r\n * information and logging. It does not need to <em>actually</em> contain\r\n * the specified annotations and it will not be searched.\r\n * @param annotationType the annotation type\r\n * @param attributes the annotation attributes or {@code null} if just default\r\n * values should be used\r\n * @return a {@link MergedAnnotation} instance for the annotation and attributes\r\n */\r\nstatic <A extends Annotation> MergedAnnotation<A> of(@Nullable AnnotatedElement source, Class<A> annotationType, @Nullable Map<String, ?> attributes) {\r\n    return of(null, source, annotationType, attributes);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotation",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.MergedAnnotation#of(AnnotatedElement,Class<A>,Map<String,?>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotation#of(ClassLoader,Object,Class<A>,Map<String,?>)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Create a new {@link MergedAnnotation} instance of the specified\r\n * annotation type with attribute values supplied by a map.\r\n * @param classLoader the class loader used to resolve class attributes\r\n * @param source the source for the annotation. This source is used only for\r\n * information and logging. It does not need to <em>actually</em> contain\r\n * the specified annotations and it will not be searched.\r\n * @param annotationType the annotation type\r\n * @param attributes the annotation attributes or {@code null} if just default\r\n * values should be used\r\n * @return a {@link MergedAnnotation} instance for the annotation and attributes\r\n */\r\nstatic <A extends Annotation> MergedAnnotation<A> of(@Nullable ClassLoader classLoader, @Nullable Object source, Class<A> annotationType, @Nullable Map<String, ?> attributes) {\r\n    return TypeMappedAnnotation.of(classLoader, source, annotationType, attributes);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotation",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.MergedAnnotation#of(ClassLoader,Object,Class<A>,Map<String,?>)",
    "tailType": "method"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.annotation",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.MergedAnnotationCollectors",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotationCollectors",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\nimport java.util.function.Function;\nimport java.util.function.IntFunction;\nimport java.util.stream.Collector;\nimport java.util.stream.Collector.Characteristics;\n\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.core.annotation.MergedAnnotation.Adapt;\nimport org.springframework.util.LinkedMultiValueMap;\nimport org.springframework.util.MultiValueMap;\n\n/**\n * {@link Collector} implementations that provide various reduction operations for\n * {@link MergedAnnotation} instances.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n * @since 5.2\n */\npublic abstract class MergedAnnotationCollectors {\n\n\tprivate static final Characteristics[] NO_CHARACTERISTICS = {};\n\n\tprivate static final Characteristics[] IDENTITY_FINISH_CHARACTERISTICS = {Characteristics.IDENTITY_FINISH};\n\n\n\tprivate MergedAnnotationCollectors() {\n\t}\n\n\n\t/**\n\t * Create a new {@link Collector} that accumulates merged annotations to a\n\t * {@link LinkedHashSet} containing {@linkplain MergedAnnotation#synthesize()\n\t * synthesized} versions.\n\t * <p>The collector returned by this method is effectively equivalent to\n\t * {@code Collectors.mapping(MergedAnnotation::synthesize, Collectors.toCollection(LinkedHashSet::new))}\n\t * but avoids the creation of a composite collector.\n\t * @param <A> the annotation type\n\t * @return a {@link Collector} which collects and synthesizes the\n\t * annotations into a {@link Set}\n\t */\n\tpublic static <A extends Annotation> Collector<MergedAnnotation<A>, ?, Set<A>> toAnnotationSet() {\n\t\treturn Collector.of(LinkedHashSet::new, (set, annotation) -> set.add(annotation.synthesize()),\n\t\t\t\tMergedAnnotationCollectors::combiner);\n\t}\n\n\t/**\n\t * Create a new {@link Collector} that accumulates merged annotations to an\n\t * {@link Annotation} array containing {@linkplain MergedAnnotation#synthesize()\n\t * synthesized} versions.\n\t * @param <A> the annotation type\n\t * @return a {@link Collector} which collects and synthesizes the\n\t * annotations into an {@code Annotation[]}\n\t * @see #toAnnotationArray(IntFunction)\n\t */\n\tpublic static <A extends Annotation> Collector<MergedAnnotation<A>, ?, Annotation[]> toAnnotationArray() {\n\t\treturn toAnnotationArray(Annotation[]::new);\n\t}\n\n\t/**\n\t * Create a new {@link Collector} that accumulates merged annotations to an\n\t * {@link Annotation} array containing {@linkplain MergedAnnotation#synthesize()\n\t * synthesized} versions.\n\t * @param <A> the annotation type\n\t * @param <R> the resulting array type\n\t * @param generator a function which produces a new array of the desired\n\t * type and the provided length\n\t * @return a {@link Collector} which collects and synthesizes the\n\t * annotations into an annotation array\n\t * @see #toAnnotationArray\n\t */\n\tpublic static <R extends Annotation, A extends R> Collector<MergedAnnotation<A>, ?, R[]> toAnnotationArray(\n\t\t\tIntFunction<R[]> generator) {\n\n\t\treturn Collector.of(ArrayList::new, (list, annotation) -> list.add(annotation.synthesize()),\n\t\t\t\tMergedAnnotationCollectors::combiner, list -> list.toArray(generator.apply(list.size())));\n\t}\n\n\t/**\n\t * Create a new {@link Collector} that accumulates merged annotations to a\n\t * {@link MultiValueMap} with items {@linkplain MultiValueMap#add(Object, Object)\n\t * added} from each merged annotation\n\t * {@linkplain MergedAnnotation#asMap(Adapt...) as a map}.\n\t * @param <A> the annotation type\n\t * @param adaptations the adaptations that should be applied to the annotation values\n\t * @return a {@link Collector} which collects and synthesizes the\n\t * annotations into a {@link LinkedMultiValueMap}\n\t * @see #toMultiValueMap(Function, MergedAnnotation.Adapt...)\n\t */\n\tpublic static <A extends Annotation> Collector<MergedAnnotation<A>, ? extends @Nullable Object, @Nullable MultiValueMap<String, @Nullable Object>> toMultiValueMap(\n\t\t\tAdapt... adaptations) {\n\n\t\treturn toMultiValueMap((MultiValueMap<String, @Nullable Object> t) -> t, adaptations);\n\t}\n\n\t/**\n\t * Create a new {@link Collector} that accumulates merged annotations to a\n\t * {@link MultiValueMap} with items {@linkplain MultiValueMap#add(Object, Object)\n\t * added} from each merged annotation\n\t * {@linkplain MergedAnnotation#asMap(Adapt...) as a map}.\n\t * @param <A> the annotation type\n\t * @param finisher the finisher function for the new {@link MultiValueMap}\n\t * @param adaptations the adaptations that should be applied to the annotation values\n\t * @return a {@link Collector} which collects and synthesizes the\n\t * annotations into a {@link LinkedMultiValueMap}\n\t * @see #toMultiValueMap(MergedAnnotation.Adapt...)\n\t */\n\tpublic static <A extends Annotation> Collector<MergedAnnotation<A>, ? extends @Nullable Object, @Nullable MultiValueMap<String, @Nullable Object>> toMultiValueMap(\n\t\t\tFunction<MultiValueMap<String, @Nullable Object>, @Nullable MultiValueMap<String, @Nullable Object>> finisher,\n\t\t\tAdapt... adaptations) {\n\n\t\tCharacteristics[] characteristics = (isSameInstance(finisher, Function.identity()) ?\n\t\t\t\tIDENTITY_FINISH_CHARACTERISTICS : NO_CHARACTERISTICS);\n\t\treturn Collector.of(LinkedMultiValueMap::new,\n\t\t\t\t(MultiValueMap<String, @Nullable Object> map, MergedAnnotation<A> annotation) -> annotation.asMap(adaptations).forEach(map::add),\n\t\t\t\tMergedAnnotationCollectors::combiner, finisher, characteristics);\n\t}\n\n\n\tprivate static boolean isSameInstance(Object instance, Object candidate) {\n\t\treturn instance == candidate;\n\t}\n\n\t/**\n\t * {@link Collector#combiner() Combiner} for collections.\n\t * <p>This method is only invoked if the {@link java.util.stream.Stream} is\n\t * processed in {@linkplain java.util.stream.Stream#parallel() parallel}.\n\t */\n\tprivate static <E, C extends Collection<E>> C combiner(C collection, C additions) {\n\t\tcollection.addAll(additions);\n\t\treturn collection;\n\t}\n\n\t/**\n\t * {@link Collector#combiner() Combiner} for multi-value maps.\n\t * <p>This method is only invoked if the {@link java.util.stream.Stream} is\n\t * processed in {@linkplain java.util.stream.Stream#parallel() parallel}.\n\t */\n\tprivate static <K, V> MultiValueMap<K, @Nullable V> combiner(MultiValueMap<K, @Nullable V> map, MultiValueMap<K, @Nullable V> additions) {\n\t\tmap.addAll(additions);\n\t\treturn map;\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotationCollectors",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.MergedAnnotationCollectors#NO_CHARACTERISTICS",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotationCollectors#NO_CHARACTERISTICS",
    "headType": "field",
    "relation": "haveType",
    "tail": "Characteristics",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotationCollectors",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.MergedAnnotationCollectors#IDENTITY_FINISH_CHARACTERISTICS",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.MergedAnnotationCollectors#IDENTITY_FINISH_CHARACTERISTICS",
    "headType": "field",
    "relation": "haveType",
    "tail": "Characteristics",
    "tailType": "type"
  }
]