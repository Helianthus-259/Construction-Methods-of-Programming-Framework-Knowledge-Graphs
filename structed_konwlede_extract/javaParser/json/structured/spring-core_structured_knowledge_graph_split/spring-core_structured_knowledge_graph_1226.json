[
  {
    "head": "org.springframework.util.AntPathMatcher#extractUriTemplateVariables(String,String)",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic Map<String, String> extractUriTemplateVariables(String pattern, String path) {\r\n    Map<String, String> variables = new LinkedHashMap<>();\r\n    boolean result = doMatch(pattern, path, true, variables);\r\n    if (!result) {\r\n        throw new IllegalStateException(\"Pattern \\\"\" + pattern + \"\\\" is not a match for \\\"\" + path + \"\\\"\");\r\n    }\r\n    return variables;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.AntPathMatcher",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.AntPathMatcher#extractUriTemplateVariables(String,String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.AntPathMatcher#extractUriTemplateVariables(String,String)",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.AntPathMatcher#combine(String,String)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Combine two patterns into a new pattern.\r\n * <p>This implementation simply concatenates the two patterns, unless\r\n * the first pattern contains a file extension match (for example, {@code *.html}).\r\n * In that case, the second pattern will be merged into the first. Otherwise,\r\n * an {@code IllegalArgumentException} will be thrown.\r\n * <h4>Examples</h4>\r\n * <table border=\"1\">\r\n * <tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr>\r\n * <tr><td>{@code null}</td><td>{@code null}</td><td>&nbsp;</td></tr>\r\n * <tr><td>/hotels</td><td>{@code null}</td><td>/hotels</td></tr>\r\n * <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>\r\n * <tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr>\r\n * <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>\r\n * <tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr>\r\n * <tr><td>/hotels/&#42;&#42;</td><td>/bookings</td><td>/hotels/&#42;&#42;/bookings</td></tr>\r\n * <tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>\r\n * <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>\r\n * <tr><td>/hotels/&#42;&#42;</td><td>{hotel}</td><td>/hotels/&#42;&#42;/{hotel}</td></tr>\r\n * <tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr>\r\n * <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>\r\n * <tr><td>/*.html</td><td>/*.txt</td><td>{@code IllegalArgumentException}</td></tr>\r\n * </table>\r\n * @param pattern1 the first pattern\r\n * @param pattern2 the second pattern\r\n * @return the combination of the two patterns\r\n * @throws IllegalArgumentException if the two patterns cannot be combined\r\n */\r\n@Override\r\npublic String combine(String pattern1, String pattern2) {\r\n    if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {\r\n        return \"\";\r\n    }\r\n    if (!StringUtils.hasText(pattern1)) {\r\n        return pattern2;\r\n    }\r\n    if (!StringUtils.hasText(pattern2)) {\r\n        return pattern1;\r\n    }\r\n    boolean pattern1ContainsUriVar = (pattern1.indexOf('{') != -1);\r\n    if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {\r\n        // /* + /hotel -> /hotel ; \"/*.*\" + \"/*.html\" -> /*.html\r\n        // However /user + /user -> /usr/user ; /{foo} + /bar -> /{foo}/bar\r\n        return pattern2;\r\n    }\r\n    // /hotels/* + /booking -> /hotels/booking\r\n    // /hotels/* + booking -> /hotels/booking\r\n    if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {\r\n        return concat(pattern1.substring(0, pattern1.length() - 2), pattern2);\r\n    }\r\n    // /hotels/** + /booking -> /hotels/**/booking\r\n    // /hotels/** + booking -> /hotels/**/booking\r\n    if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {\r\n        return concat(pattern1, pattern2);\r\n    }\r\n    int starDotPos1 = pattern1.indexOf(\"*.\");\r\n    if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(\".\")) {\r\n        // simply concatenate the two patterns\r\n        return concat(pattern1, pattern2);\r\n    }\r\n    String ext1 = pattern1.substring(starDotPos1 + 1);\r\n    int dotPos2 = pattern2.indexOf('.');\r\n    String file2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2));\r\n    String ext2 = (dotPos2 == -1 ? \"\" : pattern2.substring(dotPos2));\r\n    boolean ext1All = (ext1.equals(\".*\") || ext1.isEmpty());\r\n    boolean ext2All = (ext2.equals(\".*\") || ext2.isEmpty());\r\n    if (!ext1All && !ext2All) {\r\n        throw new IllegalArgumentException(\"Cannot combine patterns: \" + pattern1 + \" vs \" + pattern2);\r\n    }\r\n    String ext = (ext1All ? ext2 : ext1);\r\n    return file2 + ext;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.AntPathMatcher",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.AntPathMatcher#combine(String,String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.AntPathMatcher#combine(String,String)",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.AntPathMatcher#concat(String,String)",
    "headType": "method",
    "relation": "provide",
    "tail": "private String concat(String path1, String path2) {\r\n    boolean path1EndsWithSeparator = path1.endsWith(this.pathSeparator);\r\n    boolean path2StartsWithSeparator = path2.startsWith(this.pathSeparator);\r\n    if (path1EndsWithSeparator && path2StartsWithSeparator) {\r\n        return path1 + path2.substring(1);\r\n    } else if (path1EndsWithSeparator || path2StartsWithSeparator) {\r\n        return path1 + path2;\r\n    } else {\r\n        return path1 + this.pathSeparator + path2;\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.AntPathMatcher",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.AntPathMatcher#concat(String,String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.AntPathMatcher#getPatternComparator(String)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of\r\n * explicitness.\r\n * <p>This {@code Comparator} will {@linkplain java.util.List#sort(Comparator) sort}\r\n * a list so that more specific patterns (without URI templates or wild cards) come before\r\n * generic patterns. So given a list with the following patterns, the returned comparator\r\n * will sort this list so that the order will be as indicated.\r\n * <ol>\r\n * <li>{@code /hotels/new}</li>\r\n * <li>{@code /hotels/{hotel}}</li>\r\n * <li>{@code /hotels/*}</li>\r\n * </ol>\r\n * <p>The full path given as parameter is used to test for exact matches. So when the given path\r\n * is {@code /hotels/2}, the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}.\r\n * @param path the full path to use for comparison\r\n * @return a comparator capable of sorting patterns in order of explicitness\r\n */\r\n@Override\r\npublic Comparator<String> getPatternComparator(String path) {\r\n    return new AntPatternComparator(path, this.pathSeparator);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.AntPathMatcher",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.AntPathMatcher#getPatternComparator(String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.AntPathMatcher#getPatternComparator(String)",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.AntPathStringMatcher",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.AntPathStringMatcher",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.jspecify.annotations.Nullable;\n\n/**\n * {@link PathMatcher} implementation for Ant-style path patterns.\n *\n * <p>Part of this mapping code has been kindly borrowed from <a href=\"https://ant.apache.org\">Apache Ant</a>.\n *\n * <p>The mapping matches URLs using the following rules:<br>\n * <ul>\n * <li>{@code ?} matches one character</li>\n * <li>{@code *} matches zero or more characters</li>\n * <li>{@code **} matches zero or more <em>directories</em> in a path</li>\n * <li>{@code {spring:[a-z]+}} matches the regexp {@code [a-z]+} as a path variable named \"spring\"</li>\n * </ul>\n *\n * <h3>Examples</h3>\n * <ul>\n * <li>{@code com/t?st.jsp} &mdash; matches {@code com/test.jsp} but also\n * {@code com/tast.jsp} or {@code com/txst.jsp}</li>\n * <li>{@code com/*.jsp} &mdash; matches all {@code .jsp} files in the\n * {@code com} directory</li>\n * <li><code>com/&#42;&#42;/test.jsp</code> &mdash; matches all {@code test.jsp}\n * files underneath the {@code com} path</li>\n * <li><code>org/springframework/&#42;&#42;/*.jsp</code> &mdash; matches all\n * {@code .jsp} files underneath the {@code org/springframework} path</li>\n * <li><code>org/&#42;&#42;/servlet/bla.jsp</code> &mdash; matches\n * {@code org/springframework/servlet/bla.jsp} but also\n * {@code org/springframework/testing/servlet/bla.jsp} and {@code org/servlet/bla.jsp}</li>\n * <li>{@code com/{filename:\\\\w+}.jsp} will match {@code com/test.jsp} and assign the value {@code test}\n * to the {@code filename} variable</li>\n * </ul>\n *\n * <p><strong>Note:</strong> a pattern and a path must both be absolute or must\n * both be relative in order for the two to match. Therefore, it is recommended\n * that users of this implementation to sanitize patterns in order to prefix\n * them with \"/\" as it makes sense in the context in which they're used.\n *\n * @author Alef Arendsen\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Arjen Poutsma\n * @author Rossen Stoyanchev\n * @author Sam Brannen\n * @author Vladislav Kisel\n * @since 16.07.2003\n */\npublic class AntPathMatcher implements PathMatcher {\n\n\t/** Default path separator: \"/\". */\n\tpublic static final String DEFAULT_PATH_SEPARATOR = \"/\";\n\n\tprivate static final int CACHE_TURNOFF_THRESHOLD = 65536;\n\n\tprivate static final Pattern VARIABLE_PATTERN = Pattern.compile(\"\\\\{[^/]+?\\\\}\");\n\n\tprivate static final char[] WILDCARD_CHARS = {'*', '?', '{'};\n\n\n\tprivate String pathSeparator;\n\n\tprivate PathSeparatorPatternCache pathSeparatorPatternCache;\n\n\tprivate boolean caseSensitive = true;\n\n\tprivate boolean trimTokens = false;\n\n\tprivate volatile @Nullable Boolean cachePatterns;\n\n\tprivate final Map<String, String[]> tokenizedPatternCache = new ConcurrentHashMap<>(256);\n\n\tfinal Map<String, AntPathStringMatcher> stringMatcherCache = new ConcurrentHashMap<>(256);\n\n\n\t/**\n\t * Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}.\n\t */\n\tpublic AntPathMatcher() {\n\t\tthis.pathSeparator = DEFAULT_PATH_SEPARATOR;\n\t\tthis.pathSeparatorPatternCache = new PathSeparatorPatternCache(DEFAULT_PATH_SEPARATOR);\n\t}\n\n\t/**\n\t * A convenient, alternative constructor to use with a custom path separator.\n\t * @param pathSeparator the path separator to use, must not be {@code null}.\n\t * @since 4.1\n\t */\n\tpublic AntPathMatcher(String pathSeparator) {\n\t\tAssert.notNull(pathSeparator, \"'pathSeparator' must not be null\");\n\t\tthis.pathSeparator = pathSeparator;\n\t\tthis.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator);\n\t}\n\n\n\t/**\n\t * Set the path separator to use for pattern parsing.\n\t * <p>Default is \"/\", as in Ant.\n\t */\n\tpublic void setPathSeparator(@Nullable String pathSeparator) {\n\t\tthis.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR);\n\t\tthis.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator);\n\t}\n\n\t/**\n\t * Specify whether to perform pattern matching in a case-sensitive fashion.\n\t * <p>Default is {@code true}. Switch this to {@code false} for case-insensitive matching.\n\t * @since 4.2\n\t */\n\tpublic void setCaseSensitive(boolean caseSensitive) {\n\t\tthis.caseSensitive = caseSensitive;\n\t}\n\n\t/**\n\t * Specify whether to trim tokenized paths and patterns.\n\t * <p>Default is {@code false}.\n\t */\n\tpublic void setTrimTokens(boolean trimTokens) {\n\t\tthis.trimTokens = trimTokens;\n\t}\n\n\t/**\n\t * Specify whether to cache parsed pattern metadata for patterns passed\n\t * into this matcher's {@link #match} method. A value of {@code true}\n\t * activates an unlimited pattern cache; a value of {@code false} turns\n\t * the pattern cache off completely.\n\t * <p>Default is for the cache to be on, but with the variant to automatically\n\t * turn it off when encountering too many patterns to cache at runtime\n\t * (the threshold is 65536), assuming that arbitrary permutations of patterns\n\t * are coming in, with little chance for encountering a recurring pattern.\n\t * @since 4.0.1\n\t * @see #getStringMatcher(String)\n\t */\n\tpublic void setCachePatterns(boolean cachePatterns) {\n\t\tthis.cachePatterns = cachePatterns;\n\t}\n\n\tprivate void deactivatePatternCache() {\n\t\tthis.cachePatterns = false;\n\t\tthis.tokenizedPatternCache.clear();\n\t\tthis.stringMatcherCache.clear();\n\t}\n\n\n\t@Override\n\tpublic boolean isPattern(@Nullable String path) {\n\t\tif (path == null) {\n\t\t\treturn false;\n\t\t}\n\t\tboolean uriVar = false;\n\t\tfor (int i = 0; i < path.length(); i++) {\n\t\t\tchar c = path.charAt(i);\n\t\t\tif (c == '*' || c == '?') {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (c == '{') {\n\t\t\t\turiVar = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (c == '}' && uriVar) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean match(String pattern, String path) {\n\t\treturn doMatch(pattern, path, true, null);\n\t}\n\n\t@Override\n\tpublic boolean matchStart(String pattern, String path) {\n\t\treturn doMatch(pattern, path, false, null);\n\t}\n\n\t/**\n\t * Actually match the given {@code path} against the given {@code pattern}.\n\t * @param pattern the pattern to match against\n\t * @param path the path to test\n\t * @param fullMatch whether a full pattern match is required (else a pattern match\n\t * as far as the given base path goes is sufficient)\n\t * @return {@code true} if the supplied {@code path} matched, {@code false} if it didn't\n\t */\n\tprotected boolean doMatch(String pattern, @Nullable String path, boolean fullMatch,\n\t\t\t@Nullable Map<String, String> uriTemplateVariables) {\n\n\t\tif (path == null || path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tString[] pattDirs = tokenizePattern(pattern);\n\t\tif (fullMatch && this.caseSensitive && !isPotentialMatch(path, pattDirs)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tString[] pathDirs = tokenizePath(path);\n\t\tint pattIdxStart = 0;\n\t\tint pattIdxEnd = pattDirs.length - 1;\n\t\tint pathIdxStart = 0;\n\t\tint pathIdxEnd = pathDirs.length - 1;\n\n\t\t// Match all elements up to the first **\n\t\twhile (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {\n\t\t\tString pattDir = pattDirs[pattIdxStart];\n\t\t\tif (\"**\".equals(pattDir)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpattIdxStart++;\n\t\t\tpathIdxStart++;\n\t\t}\n\n\t\tif (pathIdxStart > pathIdxEnd) {\n\t\t\t// Path is exhausted, only match if rest of pattern is * or **'s\n\t\t\tif (pattIdxStart > pattIdxEnd) {\n\t\t\t\treturn (pattern.endsWith(this.pathSeparator) == path.endsWith(this.pathSeparator));\n\t\t\t}\n\t\t\tif (!fullMatch) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals(\"*\") && path.endsWith(this.pathSeparator)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (int i = pattIdxStart; i <= pattIdxEnd; i++) {\n\t\t\t\tif (!pattDirs[i].equals(\"**\")) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\telse if (pattIdxStart > pattIdxEnd) {\n\t\t\t// String not exhausted, but pattern is. Failure.\n\t\t\treturn false;\n\t\t}\n\t\telse if (!fullMatch && \"**\".equals(pattDirs[pattIdxStart])) {\n\t\t\t// Path start definitely matches due to \"**\" part in pattern.\n\t\t\treturn true;\n\t\t}\n\n\t\t// up to last '**'\n\t\twhile (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {\n\t\t\tString pattDir = pattDirs[pattIdxEnd];\n\t\t\tif (pattDir.equals(\"**\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (pattIdxEnd == (pattDirs.length - 1)\n\t\t\t\t\t&& pattern.endsWith(this.pathSeparator) != path.endsWith(this.pathSeparator)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpattIdxEnd--;\n\t\t\tpathIdxEnd--;\n\t\t}\n\t\tif (pathIdxStart > pathIdxEnd) {\n\t\t\t// String is exhausted\n\t\t\tfor (int i = pattIdxStart; i <= pattIdxEnd; i++) {\n\t\t\t\tif (!pattDirs[i].equals(\"**\")) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\twhile (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {\n\t\t\tint patIdxTmp = -1;\n\t\t\tfor (int i = pattIdxStart + 1; i <= pattIdxEnd; i++) {\n\t\t\t\tif (pattDirs[i].equals(\"**\")) {\n\t\t\t\t\tpatIdxTmp = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (patIdxTmp == pattIdxStart + 1) {\n\t\t\t\t// '**/**' situation, so skip one\n\t\t\t\tpattIdxStart++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Find the pattern between padIdxStart & padIdxTmp in str between\n\t\t\t// strIdxStart & strIdxEnd\n\t\t\tint patLength = (patIdxTmp - pattIdxStart - 1);\n\t\t\tint strLength = (pathIdxEnd - pathIdxStart + 1);\n\t\t\tint foundIdx = -1;\n\n\t\t\tstrLoop:\n\t\t\tfor (int i = 0; i <= strLength - patLength; i++) {\n\t\t\t\tfor (int j = 0; j < patLength; j++) {\n\t\t\t\t\tString subPat = pattDirs[pattIdxStart + j + 1];\n\t\t\t\t\tString subStr = pathDirs[pathIdxStart + i + j];\n\t\t\t\t\tif (!matchStrings(subPat, subStr, uriTemplateVariables)) {\n\t\t\t\t\t\tcontinue strLoop;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfoundIdx = pathIdxStart + i;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (foundIdx == -1) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tpattIdxStart = patIdxTmp;\n\t\t\tpathIdxStart = foundIdx + patLength;\n\t\t}\n\n\t\tfor (int i = pattIdxStart; i <= pattIdxEnd; i++) {\n\t\t\tif (!pattDirs[i].equals(\"**\")) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate boolean isPotentialMatch(String path, String[] pattDirs) {\n\t\tif (!this.trimTokens) {\n\t\t\tint pos = 0;\n\t\t\tfor (String pattDir : pattDirs) {\n\t\t\t\tint skipped = skipSeparator(path, pos, this.pathSeparator);\n\t\t\t\tpos += skipped;\n\t\t\t\tskipped = skipSegment(path, pos, pattDir);\n\t\t\t\tif (skipped < pattDir.length()) {\n\t\t\t\t\treturn (skipped > 0 || (pattDir.length() > 0 && isWildcardChar(pattDir.charAt(0))));\n\t\t\t\t}\n\t\t\t\tpos += skipped;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int skipSegment(String path, int pos, String prefix) {\n\t\tint skipped = 0;\n\t\tfor (int i = 0; i < prefix.length(); i++) {\n\t\t\tchar c = prefix.charAt(i);\n\t\t\tif (isWildcardChar(c)) {\n\t\t\t\treturn skipped;\n\t\t\t}\n\t\t\tint currPos = pos + skipped;\n\t\t\tif (currPos >= path.length()) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (c == path.charAt(currPos)) {\n\t\t\t\tskipped++;\n\t\t\t}\n\t\t}\n\t\treturn skipped;\n\t}\n\n\tprivate int skipSeparator(String path, int pos, String separator) {\n\t\tint skipped = 0;\n\t\twhile (path.startsWith(separator, pos + skipped)) {\n\t\t\tskipped += separator.length();\n\t\t}\n\t\treturn skipped;\n\t}\n\n\tprivate boolean isWildcardChar(char c) {\n\t\tfor (char candidate : WILDCARD_CHARS) {\n\t\t\tif (c == candidate) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Tokenize the given path pattern into parts, based on this matcher's settings.\n\t * <p>Performs caching based on {@link #setCachePatterns}, delegating to\n\t * {@link #tokenizePath(String)} for the actual tokenization algorithm.\n\t * @param pattern the pattern to tokenize\n\t * @return the tokenized pattern parts\n\t */\n\tprotected String[] tokenizePattern(String pattern) {\n\t\tString[] tokenized = null;\n\t\tBoolean cachePatterns = this.cachePatterns;\n\t\tif (cachePatterns == null || cachePatterns) {\n\t\t\ttokenized = this.tokenizedPatternCache.get(pattern);\n\t\t}\n\t\tif (tokenized == null) {\n\t\t\ttokenized = tokenizePath(pattern);\n\t\t\tif (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {\n\t\t\t\t// Try to adapt to the runtime situation that we're encountering:\n\t\t\t\t// There are obviously too many different patterns coming in here...\n\t\t\t\t// So let's turn off the cache since the patterns are unlikely to be reoccurring.\n\t\t\t\tdeactivatePatternCache();\n\t\t\t\treturn tokenized;\n\t\t\t}\n\t\t\tif (cachePatterns == null || cachePatterns) {\n\t\t\t\tthis.tokenizedPatternCache.put(pattern, tokenized);\n\t\t\t}\n\t\t}\n\t\treturn tokenized;\n\t}\n\n\t/**\n\t * Tokenize the given path into parts, based on this matcher's settings.\n\t * @param path the path to tokenize\n\t * @return the tokenized path parts\n\t */\n\tprotected String[] tokenizePath(String path) {\n\t\treturn StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true);\n\t}\n\n\t/**\n\t * Test whether a string matches against a pattern.\n\t * @param pattern the pattern to match against (never {@code null})\n\t * @param str the String which must be matched against the pattern (never {@code null})\n\t * @return {@code true} if the string matches against the pattern, or {@code false} otherwise\n\t */\n\tprivate boolean matchStrings(String pattern, String str,\n\t\t\t@Nullable Map<String, String> uriTemplateVariables) {\n\n\t\treturn getStringMatcher(pattern).matchStrings(str, uriTemplateVariables);\n\t}\n\n\t/**\n\t * Build or retrieve an {@link AntPathStringMatcher} for the given pattern.\n\t * <p>The default implementation checks this AntPathMatcher's internal cache\n\t * (see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance\n\t * if no cached copy is found.\n\t * <p>When encountering too many patterns to cache at runtime (the threshold is 65536),\n\t * it turns the default cache off, assuming that arbitrary permutations of patterns\n\t * are coming in, with little chance for encountering a recurring pattern.\n\t * <p>This method may be overridden to implement a custom cache strategy.\n\t * @param pattern the pattern to match against (never {@code null})\n\t * @return a corresponding AntPathStringMatcher (never {@code null})\n\t * @see #setCachePatterns\n\t */\n\tprotected AntPathStringMatcher getStringMatcher(String pattern) {\n\t\tAntPathStringMatcher matcher = null;\n\t\tBoolean cachePatterns = this.cachePatterns;\n\t\tif (cachePatterns == null || cachePatterns) {\n\t\t\tmatcher = this.stringMatcherCache.get(pattern);\n\t\t}\n\t\tif (matcher == null) {\n\t\t\tmatcher = new AntPathStringMatcher(pattern, this.pathSeparator, this.caseSensitive);\n\t\t\tif (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {\n\t\t\t\t// Try to adapt to the runtime situation that we're encountering:\n\t\t\t\t// There are obviously too many different patterns coming in here...\n\t\t\t\t// So let's turn off the cache since the patterns are unlikely to be reoccurring.\n\t\t\t\tdeactivatePatternCache();\n\t\t\t\treturn matcher;\n\t\t\t}\n\t\t\tif (cachePatterns == null || cachePatterns) {\n\t\t\t\tthis.stringMatcherCache.put(pattern, matcher);\n\t\t\t}\n\t\t}\n\t\treturn matcher;\n\t}\n\n\t/**\n\t * Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>\n\t * <li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} &rarr; ''</li>\n\t * <li>'{@code /docs/*}' and '{@code /docs/cvs/commit} &rarr; '{@code cvs/commit}'</li>\n\t * <li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} &rarr; '{@code commit.html}'</li>\n\t * <li>'{@code /docs/**}' and '{@code /docs/cvs/commit} &rarr; '{@code cvs/commit}'</li>\n\t * <li>'{@code /docs/**\\/*.html}' and '{@code /docs/cvs/commit.html} &rarr; '{@code cvs/commit.html}'</li>\n\t * <li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} &rarr; '{@code docs/cvs/commit.html}'</li>\n\t * <li>'{@code *.html}' and '{@code /docs/cvs/commit.html} &rarr; '{@code /docs/cvs/commit.html}'</li>\n\t * <li>'{@code *}' and '{@code /docs/cvs/commit.html} &rarr; '{@code /docs/cvs/commit.html}'</li> </ul>\n\t * <p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but\n\t * does <strong>not</strong> enforce this.\n\t */\n\t@Override\n\tpublic String extractPathWithinPattern(String pattern, String path) {\n\t\tString[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true);\n\t\tString[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true);\n\t\tStringBuilder builder = new StringBuilder();\n\t\tboolean pathStarted = false;\n\n\t\tfor (int segment = 0; segment < patternParts.length; segment++) {\n\t\t\tString patternPart = patternParts[segment];\n\t\t\tif (patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) {\n\t\t\t\tfor (; segment < pathParts.length; segment++) {\n\t\t\t\t\tif (pathStarted || (segment == 0 && !pattern.startsWith(this.pathSeparator))) {\n\t\t\t\t\t\tbuilder.append(this.pathSeparator);\n\t\t\t\t\t}\n\t\t\t\t\tbuilder.append(pathParts[segment]);\n\t\t\t\t\tpathStarted = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn builder.toString();\n\t}\n\n\t@Override\n\tpublic Map<String, String> extractUriTemplateVariables(String pattern, String path) {\n\t\tMap<String, String> variables = new LinkedHashMap<>();\n\t\tboolean result = doMatch(pattern, path, true, variables);\n\t\tif (!result) {\n\t\t\tthrow new IllegalStateException(\"Pattern \\\"\" + pattern + \"\\\" is not a match for \\\"\" + path + \"\\\"\");\n\t\t}\n\t\treturn variables;\n\t}\n\n\t/**\n\t * Combine two patterns into a new pattern.\n\t * <p>This implementation simply concatenates the two patterns, unless\n\t * the first pattern contains a file extension match (for example, {@code *.html}).\n\t * In that case, the second pattern will be merged into the first. Otherwise,\n\t * an {@code IllegalArgumentException} will be thrown.\n\t * <h4>Examples</h4>\n\t * <table border=\"1\">\n\t * <tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr>\n\t * <tr><td>{@code null}</td><td>{@code null}</td><td>&nbsp;</td></tr>\n\t * <tr><td>/hotels</td><td>{@code null}</td><td>/hotels</td></tr>\n\t * <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>\n\t * <tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr>\n\t * <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>\n\t * <tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr>\n\t * <tr><td>/hotels/&#42;&#42;</td><td>/bookings</td><td>/hotels/&#42;&#42;/bookings</td></tr>\n\t * <tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>\n\t * <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>\n\t * <tr><td>/hotels/&#42;&#42;</td><td>{hotel}</td><td>/hotels/&#42;&#42;/{hotel}</td></tr>\n\t * <tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr>\n\t * <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>\n\t * <tr><td>/*.html</td><td>/*.txt</td><td>{@code IllegalArgumentException}</td></tr>\n\t * </table>\n\t * @param pattern1 the first pattern\n\t * @param pattern2 the second pattern\n\t * @return the combination of the two patterns\n\t * @throws IllegalArgumentException if the two patterns cannot be combined\n\t */\n\t@Override\n\tpublic String combine(String pattern1, String pattern2) {\n\t\tif (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {\n\t\t\treturn \"\";\n\t\t}\n\t\tif (!StringUtils.hasText(pattern1)) {\n\t\t\treturn pattern2;\n\t\t}\n\t\tif (!StringUtils.hasText(pattern2)) {\n\t\t\treturn pattern1;\n\t\t}\n\n\t\tboolean pattern1ContainsUriVar = (pattern1.indexOf('{') != -1);\n\t\tif (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {\n\t\t\t// /* + /hotel -> /hotel ; \"/*.*\" + \"/*.html\" -> /*.html\n\t\t\t// However /user + /user -> /usr/user ; /{foo} + /bar -> /{foo}/bar\n\t\t\treturn pattern2;\n\t\t}\n\n\t\t// /hotels/* + /booking -> /hotels/booking\n\t\t// /hotels/* + booking -> /hotels/booking\n\t\tif (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {\n\t\t\treturn concat(pattern1.substring(0, pattern1.length() - 2), pattern2);\n\t\t}\n\n\t\t// /hotels/** + /booking -> /hotels/**/booking\n\t\t// /hotels/** + booking -> /hotels/**/booking\n\t\tif (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {\n\t\t\treturn concat(pattern1, pattern2);\n\t\t}\n\n\t\tint starDotPos1 = pattern1.indexOf(\"*.\");\n\t\tif (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(\".\")) {\n\t\t\t// simply concatenate the two patterns\n\t\t\treturn concat(pattern1, pattern2);\n\t\t}\n\n\t\tString ext1 = pattern1.substring(starDotPos1 + 1);\n\t\tint dotPos2 = pattern2.indexOf('.');\n\t\tString file2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2));\n\t\tString ext2 = (dotPos2 == -1 ? \"\" : pattern2.substring(dotPos2));\n\t\tboolean ext1All = (ext1.equals(\".*\") || ext1.isEmpty());\n\t\tboolean ext2All = (ext2.equals(\".*\") || ext2.isEmpty());\n\t\tif (!ext1All && !ext2All) {\n\t\t\tthrow new IllegalArgumentException(\"Cannot combine patterns: \" + pattern1 + \" vs \" + pattern2);\n\t\t}\n\t\tString ext = (ext1All ? ext2 : ext1);\n\t\treturn file2 + ext;\n\t}\n\n\tprivate String concat(String path1, String path2) {\n\t\tboolean path1EndsWithSeparator = path1.endsWith(this.pathSeparator);\n\t\tboolean path2StartsWithSeparator = path2.startsWith(this.pathSeparator);\n\n\t\tif (path1EndsWithSeparator && path2StartsWithSeparator) {\n\t\t\treturn path1 + path2.substring(1);\n\t\t}\n\t\telse if (path1EndsWithSeparator || path2StartsWithSeparator) {\n\t\t\treturn path1 + path2;\n\t\t}\n\t\telse {\n\t\t\treturn path1 + this.pathSeparator + path2;\n\t\t}\n\t}\n\n\t/**\n\t * Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of\n\t * explicitness.\n\t * <p>This {@code Comparator} will {@linkplain java.util.List#sort(Comparator) sort}\n\t * a list so that more specific patterns (without URI templates or wild cards) come before\n\t * generic patterns. So given a list with the following patterns, the returned comparator\n\t * will sort this list so that the order will be as indicated.\n\t * <ol>\n\t * <li>{@code /hotels/new}</li>\n\t * <li>{@code /hotels/{hotel}}</li>\n\t * <li>{@code /hotels/*}</li>\n\t * </ol>\n\t * <p>The full path given as parameter is used to test for exact matches. So when the given path\n\t * is {@code /hotels/2}, the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}.\n\t * @param path the full path to use for comparison\n\t * @return a comparator capable of sorting patterns in order of explicitness\n\t */\n\t@Override\n\tpublic Comparator<String> getPatternComparator(String path) {\n\t\treturn new AntPatternComparator(path, this.pathSeparator);\n\t}\n\n\n\t/**\n\t * Tests whether a string matches against a pattern via a {@link Pattern}.\n\t * <p>The pattern may contain special characters: '*' means zero or more characters; '?' means one and\n\t * only one character; '{' and '}' indicate a URI template pattern. For example {@code /users/{user}}.\n\t */\n\tprotected static class AntPathStringMatcher {\n\n\t\tprivate static final String DEFAULT_VARIABLE_PATTERN = \"((?s).*)\";\n\n\t\tprivate final String rawPattern;\n\n\t\tprivate final boolean caseSensitive;\n\n\t\tprivate final boolean exactMatch;\n\n\t\tprivate final @Nullable Pattern pattern;\n\n\t\tprivate final List<String> variableNames = new ArrayList<>();\n\n\t\tprotected AntPathStringMatcher(String pattern, String pathSeparator, boolean caseSensitive) {\n\t\t\tthis.rawPattern = pattern;\n\t\t\tthis.caseSensitive = caseSensitive;\n\t\t\tStringBuilder patternBuilder = new StringBuilder();\n\t\t\tMatcher matcher = getGlobPattern(pathSeparator).matcher(pattern);\n\t\t\tint end = 0;\n\t\t\twhile (matcher.find()) {\n\t\t\t\tpatternBuilder.append(quote(pattern, end, matcher.start()));\n\t\t\t\tString match = matcher.group();\n\t\t\t\tif (\"?\".equals(match)) {\n\t\t\t\t\tpatternBuilder.append('.');\n\t\t\t\t}\n\t\t\t\telse if (\"*\".equals(match)) {\n\t\t\t\t\tpatternBuilder.append(\".*\");\n\t\t\t\t}\n\t\t\t\telse if (match.startsWith(\"{\") && match.endsWith(\"}\")) {\n\t\t\t\t\tint colonIdx = match.indexOf(':');\n\t\t\t\t\tif (colonIdx == -1) {\n\t\t\t\t\t\tpatternBuilder.append(DEFAULT_VARIABLE_PATTERN);\n\t\t\t\t\t\tthis.variableNames.add(matcher.group(1));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tString variablePattern = match.substring(colonIdx + 1, match.length() - 1);\n\t\t\t\t\t\tpatternBuilder.append('(');\n\t\t\t\t\t\tpatternBuilder.append(variablePattern);\n\t\t\t\t\t\tpatternBuilder.append(')');\n\t\t\t\t\t\tString variableName = match.substring(1, colonIdx);\n\t\t\t\t\t\tthis.variableNames.add(variableName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tend = matcher.end();\n\t\t\t}\n\t\t\t// No glob pattern was found, this is an exact String match\n\t\t\tif (end == 0) {\n\t\t\t\tthis.exactMatch = true;\n\t\t\t\tthis.pattern = null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.exactMatch = false;\n\t\t\t\tpatternBuilder.append(quote(pattern, end, pattern.length()));\n\t\t\t\tthis.pattern = Pattern.compile(patternBuilder.toString(),\n\t\t\t\t\t\tPattern.DOTALL | (this.caseSensitive ? 0 : Pattern.CASE_INSENSITIVE));\n\t\t\t}\n\t\t}\n\n\t\tprivate static Pattern getGlobPattern(String pathSeparator) {\n\t\t\tString pattern = \"\\\\?|\\\\*|\\\\{((?:\\\\{[^\" + pathSeparator + \"]+?\\\\}|[^\" + pathSeparator + \"{}]|\\\\\\\\[{}])+?)\\\\}\";\n\t\t\treturn Pattern.compile(pattern);\n\t\t}\n\n\t\tprivate String quote(String s, int start, int end) {\n\t\t\tif (start == end) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\treturn Pattern.quote(s.substring(start, end));\n\t\t}\n\n\t\t/**\n\t\t * Main entry point.\n\t\t * @return {@code true} if the string matches against the pattern, or {@code false} otherwise.\n\t\t */\n\t\tpublic boolean matchStrings(String str, @Nullable Map<String, String> uriTemplateVariables) {\n\t\t\tif (this.exactMatch) {\n\t\t\t\treturn this.caseSensitive ? this.rawPattern.equals(str) : this.rawPattern.equalsIgnoreCase(str);\n\t\t\t}\n\t\t\telse if (this.pattern != null) {\n\t\t\t\tMatcher matcher = this.pattern.matcher(str);\n\t\t\t\tif (matcher.matches()) {\n\t\t\t\t\tif (uriTemplateVariables != null) {\n\t\t\t\t\t\tif (this.variableNames.size() != matcher.groupCount()) {\n\t\t\t\t\t\t\tthrow new IllegalArgumentException(\"The number of capturing groups in the pattern segment \" +\n\t\t\t\t\t\t\t\t\tthis.pattern + \" does not match the number of URI template variables it defines, \" +\n\t\t\t\t\t\t\t\t\t\"which can occur if capturing groups are used in a URI template regex. \" +\n\t\t\t\t\t\t\t\t\t\"Use non-capturing groups instead.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int i = 1; i <= matcher.groupCount(); i++) {\n\t\t\t\t\t\t\tString name = this.variableNames.get(i - 1);\n\t\t\t\t\t\t\tif (name.startsWith(\"*\")) {\n\t\t\t\t\t\t\t\tthrow new IllegalArgumentException(\"Capturing patterns (\" + name + \") are not \" +\n\t\t\t\t\t\t\t\t\t\t\"supported by the AntPathMatcher. Use the PathPatternParser instead.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tString value = matcher.group(i);\n\t\t\t\t\t\t\turiTemplateVariables.put(name, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t}\n\n\n\t/**\n\t * The default {@link Comparator} implementation returned by\n\t * {@link #getPatternComparator(String)}.\n\t * <p>In order, the most \"generic\" pattern is determined by the following:\n\t * <ul>\n\t * <li>if it's null or a capture all pattern (i.e. it is equal to \"/**\")</li>\n\t * <li>if the other pattern is an actual match</li>\n\t * <li>if it's a catch-all pattern (i.e. it ends with \"**\"</li>\n\t * <li>if it's got more \"*\" than the other pattern</li>\n\t * <li>if it's got more \"{foo}\" than the other pattern</li>\n\t * <li>if it's shorter than the other pattern</li>\n\t * </ul>\n\t */\n\tprotected static class AntPatternComparator implements Comparator<String> {\n\n\t\tprivate final String path;\n\n\t\tprivate final String pathSeparator;\n\n\t\tpublic AntPatternComparator(String path) {\n\t\t\tthis(path, DEFAULT_PATH_SEPARATOR);\n\t\t}\n\n\t\tpublic AntPatternComparator(String path, String pathSeparator) {\n\t\t\tthis.path = path;\n\t\t\tthis.pathSeparator = pathSeparator;\n\t\t}\n\n\t\t/**\n\t\t * Compare two patterns to determine which should match first, i.e. which\n\t\t * is the most specific regarding the current path.\n\t\t * @return a negative integer, zero, or a positive integer as pattern1 is\n\t\t * more specific, equally specific, or less specific than pattern2.\n\t\t */\n\t\t@Override\n\t\tpublic int compare(String pattern1, String pattern2) {\n\t\t\tPatternInfo info1 = new PatternInfo(pattern1, this.pathSeparator);\n\t\t\tPatternInfo info2 = new PatternInfo(pattern2, this.pathSeparator);\n\n\t\t\tif (info1.isLeastSpecific() && info2.isLeastSpecific()) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse if (info1.isLeastSpecific()) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if (info2.isLeastSpecific()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tboolean pattern1EqualsPath = pattern1.equals(this.path);\n\t\t\tboolean pattern2EqualsPath = pattern2.equals(this.path);\n\t\t\tif (pattern1EqualsPath && pattern2EqualsPath) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse if (pattern1EqualsPath) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if (pattern2EqualsPath) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif (info1.isPrefixPattern() && info2.isPrefixPattern()) {\n\t\t\t\treturn info2.getLength() - info1.getLength();\n\t\t\t}\n\t\t\telse if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (info1.getTotalCount() != info2.getTotalCount()) {\n\t\t\t\treturn info1.getTotalCount() - info2.getTotalCount();\n\t\t\t}\n\n\t\t\tif (info1.getLength() != info2.getLength()) {\n\t\t\t\treturn info2.getLength() - info1.getLength();\n\t\t\t}\n\n\t\t\tif (info1.getSingleWildcards() < info2.getSingleWildcards()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if (info2.getSingleWildcards() < info1.getSingleWildcards()) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif (info1.getUriVars() < info2.getUriVars()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if (info2.getUriVars() < info1.getUriVars()) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\n\t\t/**\n\t\t * Value class that holds information about the pattern, for example, number of\n\t\t * occurrences of \"*\", \"**\", and \"{\" pattern elements.\n\t\t */\n\t\tprivate static class PatternInfo {\n\n\n\t\t\tprivate final @Nullable String pattern;\n\n\t\t\tprivate int uriVars;\n\n\t\t\tprivate int singleWildcards;\n\n\t\t\tprivate int doubleWildcards;\n\n\t\t\tprivate boolean catchAllPattern;\n\n\t\t\tprivate boolean prefixPattern;\n\n\t\t\tprivate @Nullable Integer length;\n\n\t\t\tPatternInfo(@Nullable String pattern, String pathSeparator) {\n\t\t\t\tthis.pattern = pattern;\n\t\t\t\tif (this.pattern != null) {\n\t\t\t\t\tinitCounters();\n\t\t\t\t\tthis.catchAllPattern = this.pattern.equals(pathSeparator + \"**\");\n\t\t\t\t\tthis.prefixPattern = !this.catchAllPattern && this.pattern.endsWith(pathSeparator + \"**\");\n\t\t\t\t}\n\t\t\t\tif (this.uriVars == 0) {\n\t\t\t\t\tthis.length = (this.pattern != null ? this.pattern.length() : 0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprotected void initCounters() {\n\t\t\t\tint pos = 0;\n\t\t\t\tif (this.pattern != null) {\n\t\t\t\t\twhile (pos < this.pattern.length()) {\n\t\t\t\t\t\tif (this.pattern.charAt(pos) == '{') {\n\t\t\t\t\t\t\tthis.uriVars++;\n\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (this.pattern.charAt(pos) == '*') {\n\t\t\t\t\t\t\tif (pos + 1 < this.pattern.length() && this.pattern.charAt(pos + 1) == '*') {\n\t\t\t\t\t\t\t\tthis.doubleWildcards++;\n\t\t\t\t\t\t\t\tpos += 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (pos > 0 && !this.pattern.substring(pos - 1).equals(\".*\")) {\n\t\t\t\t\t\t\t\tthis.singleWildcards++;\n\t\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic int getUriVars() {\n\t\t\t\treturn this.uriVars;\n\t\t\t}\n\n\t\t\tpublic int getSingleWildcards() {\n\t\t\t\treturn this.singleWildcards;\n\t\t\t}\n\n\t\t\tpublic int getDoubleWildcards() {\n\t\t\t\treturn this.doubleWildcards;\n\t\t\t}\n\n\t\t\tpublic boolean isLeastSpecific() {\n\t\t\t\treturn (this.pattern == null || this.catchAllPattern);\n\t\t\t}\n\n\t\t\tpublic boolean isPrefixPattern() {\n\t\t\t\treturn this.prefixPattern;\n\t\t\t}\n\n\t\t\tpublic int getTotalCount() {\n\t\t\t\treturn this.uriVars + this.singleWildcards + (2 * this.doubleWildcards);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Returns the length of the given pattern, where template variables are considered to be 1 long.\n\t\t\t */\n\t\t\tpublic int getLength() {\n\t\t\t\tif (this.length == null) {\n\t\t\t\t\tthis.length = (this.pattern != null ?\n\t\t\t\t\t\t\tVARIABLE_PATTERN.matcher(this.pattern).replaceAll(\"#\").length() : 0);\n\t\t\t\t}\n\t\t\t\treturn this.length;\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * A simple cache for patterns that depend on the configured path separator.\n\t */\n\tprivate static class PathSeparatorPatternCache {\n\n\t\tprivate final String endsOnWildCard;\n\n\t\tprivate final String endsOnDoubleWildCard;\n\n\t\tpublic PathSeparatorPatternCache(String pathSeparator) {\n\t\t\tthis.endsOnWildCard = pathSeparator + \"*\";\n\t\t\tthis.endsOnDoubleWildCard = pathSeparator + \"**\";\n\t\t}\n\n\t\tpublic String getEndsOnWildCard() {\n\t\t\treturn this.endsOnWildCard;\n\t\t}\n\n\t\tpublic String getEndsOnDoubleWildCard() {\n\t\t\treturn this.endsOnDoubleWildCard;\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.AntPathStringMatcher",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.AntPathStringMatcher#DEFAULT_VARIABLE_PATTERN",
    "tailType": "field"
  },
  {
    "head": "org.springframework.util.AntPathStringMatcher#DEFAULT_VARIABLE_PATTERN",
    "headType": "field",
    "relation": "haveType",
    "tail": "String",
    "tailType": "type"
  },
  {
    "head": "org.springframework.util.AntPathStringMatcher",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.AntPathStringMatcher#rawPattern",
    "tailType": "field"
  },
  {
    "head": "org.springframework.util.AntPathStringMatcher#rawPattern",
    "headType": "field",
    "relation": "haveType",
    "tail": "String",
    "tailType": "type"
  },
  {
    "head": "org.springframework.util.AntPathStringMatcher",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.AntPathStringMatcher#caseSensitive",
    "tailType": "field"
  },
  {
    "head": "org.springframework.util.AntPathStringMatcher#caseSensitive",
    "headType": "field",
    "relation": "haveType",
    "tail": "boolean",
    "tailType": "type"
  },
  {
    "head": "org.springframework.util.AntPathStringMatcher",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.AntPathStringMatcher#exactMatch",
    "tailType": "field"
  }
]