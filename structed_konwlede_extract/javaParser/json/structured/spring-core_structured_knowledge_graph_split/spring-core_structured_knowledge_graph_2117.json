[
  {
    "head": "org.springframework.core.Fields",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.Fields#otherPrivateField",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.Fields#otherPrivateField",
    "headType": "field",
    "relation": "haveType",
    "tail": "List<String>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.Fields",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.Fields#nested",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.Fields#nested",
    "headType": "field",
    "relation": "haveType",
    "tail": "Map<Map<String, Integer>, Map<Byte, Long>>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.Fields",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.Fields#variableTypeGenericArray",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.Fields#variableTypeGenericArray",
    "headType": "field",
    "relation": "haveType",
    "tail": "T",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.Fields",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.Fields#integerArray",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.Fields#integerArray",
    "headType": "field",
    "relation": "haveType",
    "tail": "Integer",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.Fields",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.Fields#intArray",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.Fields#intArray",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.Fields",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.Fields#repository",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.Fields#repository",
    "headType": "field",
    "relation": "haveType",
    "tail": "SomeRepository<? extends Serializable>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.Fields",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.Fields#stringRepository",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.Fields#stringRepository",
    "headType": "field",
    "relation": "haveType",
    "tail": "SomeRepository<String>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.Fields",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.Fields#arrayRepository",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.Fields#arrayRepository",
    "headType": "field",
    "relation": "haveType",
    "tail": "SomeRepository<String[]>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.TypedFields",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.TypedFields",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.WildcardType;\nimport java.util.AbstractCollection;\nimport java.util.AbstractList;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport java.util.concurrent.Callable;\n\nimport org.assertj.core.api.AbstractAssert;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.ArgumentCaptor;\nimport org.mockito.Captor;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\nimport org.springframework.core.ResolvableType.VariableResolver;\nimport org.springframework.util.MultiValueMap;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.BDDMockito.given;\nimport static org.mockito.Mockito.atLeastOnce;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\n\n/**\n * Tests for {@link ResolvableType}.\n *\n * @author Phillip Webb\n * @author Juergen Hoeller\n * @author Sebastien Deleuze\n * @author Yanming Zhou\n */\n@SuppressWarnings(\"rawtypes\")\n@ExtendWith(MockitoExtension.class)\nclass ResolvableTypeTests {\n\n\t@Captor\n\tprivate ArgumentCaptor<TypeVariable<?>> typeVariableCaptor;\n\n\n\t@Test\n\tvoid noneReturnValues() {\n\t\tResolvableType none = ResolvableType.NONE;\n\t\tassertThat(none.as(Object.class)).isEqualTo(ResolvableType.NONE);\n\t\tassertThat(none.asCollection()).isEqualTo(ResolvableType.NONE);\n\t\tassertThat(none.asMap()).isEqualTo(ResolvableType.NONE);\n\t\tassertThat(none.getComponentType()).isEqualTo(ResolvableType.NONE);\n\t\tassertThat(none.getGeneric(0)).isEqualTo(ResolvableType.NONE);\n\t\tassertThat(none.getGenerics()).isEmpty();\n\t\tassertThat(none.getInterfaces()).isEmpty();\n\t\tassertThat(none.getSuperType()).isEqualTo(ResolvableType.NONE);\n\t\tassertThat(none.getType()).isEqualTo(ResolvableType.EmptyType.INSTANCE);\n\t\tassertThat(none.hasGenerics()).isFalse();\n\t\tassertThat(none.isArray()).isFalse();\n\t\tassertThat(none.resolve()).isNull();\n\t\tassertThat(none.resolve(String.class)).isEqualTo(String.class);\n\t\tassertThat(none.resolveGeneric(0)).isNull();\n\t\tassertThat(none.resolveGenerics()).isEmpty();\n\t\tassertThat(none.toString()).isEqualTo(\"?\");\n\t\tassertThat(none.hasUnresolvableGenerics()).isFalse();\n\t\tassertThat(none.isAssignableFrom(ResolvableType.forClass(Object.class))).isFalse();\n\t}\n\n\t@Test\n\tvoid forClass() {\n\t\tResolvableType type = ResolvableType.forClass(ExtendsList.class);\n\t\tassertThat(type.getType()).isEqualTo(ExtendsList.class);\n\t\tassertThat(type.getRawClass()).isEqualTo(ExtendsList.class);\n\t\tassertThat(type.isAssignableFrom(ExtendsList.class)).isTrue();\n\t\tassertThat(type.isAssignableFrom(ArrayList.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid forClassWithNull() {\n\t\tResolvableType type = ResolvableType.forClass(null);\n\t\tassertThat(type.getType()).isEqualTo(Object.class);\n\t\tassertThat(type.getRawClass()).isEqualTo(Object.class);\n\t\tassertThat(type.isAssignableFrom(Object.class)).isTrue();\n\t\tassertThat(type.isAssignableFrom(String.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid forRawClass() {\n\t\tResolvableType type = ResolvableType.forRawClass(ExtendsList.class);\n\t\tassertThat(type.getType()).isEqualTo(ExtendsList.class);\n\t\tassertThat(type.getRawClass()).isEqualTo(ExtendsList.class);\n\t\tassertThat(type.isAssignableFrom(ExtendsList.class)).isTrue();\n\t\tassertThat(type.isAssignableFrom(ArrayList.class)).isFalse();\n\t\tassertThat(type).isNotEqualTo(ResolvableType.forClass(ExtendsList.class));\n\t}\n\n\t@Test\n\tvoid forRawClassWithNull() {\n\t\tResolvableType type = ResolvableType.forRawClass(null);\n\t\tassertThat(type.getType()).isEqualTo(Object.class);\n\t\tassertThat(type.getRawClass()).isEqualTo(Object.class);\n\t\tassertThat(type.isAssignableFrom(Object.class)).isTrue();\n\t\tassertThat(type.isAssignableFrom(String.class)).isTrue();\n\t\tassertThat(type).isNotEqualTo(ResolvableType.forClass(null));\n\t}\n\n\t@Test  // gh-23321\n\tvoid forRawClassAssignableFromTypeVariable() {\n\t\tResolvableType typeVariable = ResolvableType.forClass(ExtendsList.class).as(List.class).getGeneric();\n\t\tResolvableType raw = ResolvableType.forRawClass(CharSequence.class);\n\t\tassertThat(raw.resolve()).isEqualTo(CharSequence.class);\n\t\tassertThat(typeVariable.resolve()).isEqualTo(CharSequence.class);\n\t\tassertThat(raw.resolve().isAssignableFrom(typeVariable.resolve())).isTrue();\n\t\tassertThat(typeVariable.resolve().isAssignableFrom(raw.resolve())).isTrue();\n\t\tassertThat(raw.isAssignableFrom(typeVariable)).isTrue();\n\t\tassertThat(typeVariable.isAssignableFrom(raw)).isTrue();\n\t}\n\n\t@Test  // gh-28776\n\tvoid forInstanceNull() {\n\t\tassertThat(ResolvableType.forInstance(null)).isEqualTo(ResolvableType.NONE);\n\t}\n\n\t@Test\n\tvoid forInstanceNoProvider() {\n\t\tResolvableType type = ResolvableType.forInstance(new Object());\n\t\tassertThat(type.getType()).isEqualTo(Object.class);\n\t\tassertThat(type.resolve()).isEqualTo(Object.class);\n\t}\n\n\t@Test\n\tvoid forInstanceProvider() {\n\t\tResolvableType type = ResolvableType.forInstance(new MyGenericInterfaceType<>(String.class));\n\t\tassertThat(type.getRawClass()).isEqualTo(MyGenericInterfaceType.class);\n\t\tassertThat(type.getGeneric().resolve()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid forInstanceProviderNull() {\n\t\tResolvableType type = ResolvableType.forInstance(new MyGenericInterfaceType<>(null));\n\t\tassertThat(type.getType()).isEqualTo(MyGenericInterfaceType.class);\n\t\tassertThat(type.resolve()).isEqualTo(MyGenericInterfaceType.class);\n\t}\n\n\t@Test\n\tvoid forField() throws Exception {\n\t\tField field = Fields.class.getField(\"charSequenceList\");\n\t\tResolvableType type = ResolvableType.forField(field);\n\t\tassertThat(type.getType()).isEqualTo(field.getGenericType());\n\t}\n\n\t@Test\n\tvoid forPrivateField() throws Exception {\n\t\tField field = Fields.class.getDeclaredField(\"privateField\");\n\t\tResolvableType type = ResolvableType.forField(field);\n\t\tassertThat(type.getType()).isEqualTo(field.getGenericType());\n\t\tassertThat(type.resolve()).isEqualTo(List.class);\n\t\tassertThat(type.getSource()).isSameAs(field);\n\n\t\tField field2 = Fields.class.getDeclaredField(\"otherPrivateField\");\n\t\tResolvableType type2 = ResolvableType.forField(field2);\n\t\tassertThat(type2.getType()).isEqualTo(field2.getGenericType());\n\t\tassertThat(type2.resolve()).isEqualTo(List.class);\n\t\tassertThat(type2.getSource()).isSameAs(field2);\n\n\t\tassertThat(type2).isEqualTo(type);\n\t\tassertThat(type2.hashCode()).isEqualTo(type.hashCode());\n\t}\n\n\t@Test\n\tvoid forFieldMustNotBeNull() {\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> ResolvableType.forField(null))\n\t\t\t\t.withMessage(\"Field must not be null\");\n\t}\n\n\t@Test\n\tvoid forConstructorParameter() throws Exception {\n\t\tConstructor<Constructors> constructor = Constructors.class.getConstructor(List.class);\n\t\tResolvableType type = ResolvableType.forConstructorParameter(constructor, 0);\n\t\tassertThat(type.getType()).isEqualTo(constructor.getGenericParameterTypes()[0]);\n\t}\n\n\t@Test\n\tvoid forConstructorParameterMustNotBeNull() {\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> ResolvableType.forConstructorParameter(null, 0))\n\t\t\t\t.withMessage(\"Constructor must not be null\");\n\t}\n\n\t@Test\n\tvoid forMethodParameterByIndex() throws Exception {\n\t\tMethod method = Methods.class.getMethod(\"charSequenceParameter\", List.class);\n\t\tResolvableType type = ResolvableType.forMethodParameter(method, 0);\n\t\tassertThat(type.getType()).isEqualTo(method.getGenericParameterTypes()[0]);\n\t}\n\n\t@Test\n\tvoid forMethodParameterByIndexMustNotBeNull() {\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> ResolvableType.forMethodParameter(null, 0))\n\t\t\t\t.withMessage(\"Method must not be null\");\n\t}\n\n\t@Test\n\tvoid forMethodParameter() throws Exception {\n\t\tMethod method = Methods.class.getMethod(\"charSequenceParameter\", List.class);\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(method, 0);\n\t\tResolvableType type = ResolvableType.forMethodParameter(methodParameter);\n\t\tassertThat(type.getType()).isEqualTo(method.getGenericParameterTypes()[0]);\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid forMethodParameterWithNesting() throws Exception {\n\t\tMethod method = Methods.class.getMethod(\"nested\", Map.class);\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(method, 0);\n\t\tmethodParameter.increaseNestingLevel();\n\t\tResolvableType type = ResolvableType.forMethodParameter(methodParameter);\n\t\tassertThat(type.resolve()).isEqualTo(Map.class);\n\t\tassertThat(type.getGeneric(0).resolve()).isEqualTo(Byte.class);\n\t\tassertThat(type.getGeneric(1).resolve()).isEqualTo(Long.class);\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid forMethodParameterWithNestingAndLevels() throws Exception {\n\t\tMethod method = Methods.class.getMethod(\"nested\", Map.class);\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(method, 0);\n\t\tmethodParameter.increaseNestingLevel();\n\t\tmethodParameter.setTypeIndexForCurrentLevel(0);\n\t\tResolvableType type = ResolvableType.forMethodParameter(methodParameter);\n\t\tassertThat(type.resolve()).isEqualTo(Map.class);\n\t\tassertThat(type.getGeneric(0).resolve()).isEqualTo(String.class);\n\t\tassertThat(type.getGeneric(1).resolve()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid forMethodParameterMustNotBeNull() {\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> ResolvableType.forMethodParameter(null))\n\t\t\t\t.withMessage(\"MethodParameter must not be null\");\n\t}\n\n\t@Test  // SPR-16210\n\tvoid forMethodParameterWithSameSignatureAndGenerics() throws Exception {\n\t\tMethod method = Methods.class.getMethod(\"list1\");\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(method, -1);\n\t\tResolvableType type = ResolvableType.forMethodParameter(methodParameter);\n\t\tassertThat(((MethodParameter)type.getSource()).getMethod()).isEqualTo(method);\n\n\t\tmethod = Methods.class.getMethod(\"list2\");\n\t\tmethodParameter = MethodParameter.forExecutable(method, -1);\n\t\ttype = ResolvableType.forMethodParameter(methodParameter);\n\t\tassertThat(((MethodParameter)type.getSource()).getMethod()).isEqualTo(method);\n\t}\n\n\t@Test\n\tvoid forMethodReturn() throws Exception {\n\t\tMethod method = Methods.class.getMethod(\"charSequenceReturn\");\n\t\tResolvableType type = ResolvableType.forMethodReturnType(method);\n\t\tassertThat(type.getType()).isEqualTo(method.getGenericReturnType());\n\t}\n\n\t@Test\n\tvoid forMethodReturnMustNotBeNull() {\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> ResolvableType.forMethodReturnType(null))\n\t\t\t\t.withMessage(\"Method must not be null\");\n\t}\n\n\t@Test  // gh-27748\n\tvoid genericMatchesReturnType() throws Exception {\n\t\tMethod method = SomeRepository.class.getMethod(\"someMethod\", Class.class, Class.class, Class.class);\n\n\t\tResolvableType returnType = ResolvableType.forMethodReturnType(method, SomeRepository.class);\n\n\t\tResolvableType arg0 = ResolvableType.forMethodParameter(method, 0, SomeRepository.class); // generic[0]=T\n\t\tResolvableType arg1 = ResolvableType.forMethodParameter(method, 1, SomeRepository.class); // generic[0]=?\n\t\tResolvableType arg2 = ResolvableType.forMethodParameter(method, 2, SomeRepository.class); // generic[0]=java.lang.Object\n\n\t\tassertThat(returnType.equalsType(arg0.as(Class.class).getGeneric(0))).isTrue();\n\t\tassertThat(returnType.equalsType(arg1.as(Class.class).getGeneric(0))).isFalse();\n\t\tassertThat(returnType.equalsType(arg2.as(Class.class).getGeneric(0))).isFalse();\n\t}\n\n\t@Test\n\tvoid classType() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"classType\"));\n\t\tassertThat(type.getType().getClass()).isEqualTo(Class.class);\n\t}\n\n\t@Test\n\tvoid parameterizedType() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"parameterizedType\"));\n\t\tassertThat(type.getType()).isInstanceOf(ParameterizedType.class);\n\t}\n\n\t@Test\n\tvoid arrayClassType() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"arrayClassType\"));\n\t\tassertThat(type.getType()).isInstanceOf(Class.class);\n\t\tassertThat(((Class) type.getType()).isArray()).isTrue();\n\t}\n\n\t@Test\n\tvoid genericArrayType() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"genericArrayType\"));\n\t\tassertThat(type.getType()).isInstanceOf(GenericArrayType.class);\n\t}\n\n\t@Test\n\tvoid wildcardType() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"wildcardType\"));\n\t\tassertThat(type.getType()).isInstanceOf(ParameterizedType.class);\n\t\tassertThat(type.getGeneric().getType()).isInstanceOf(WildcardType.class);\n\t}\n\n\t@Test\n\tvoid typeVariableType() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"typeVariableType\"));\n\t\tassertThat(type.getType()).isInstanceOf(TypeVariable.class);\n\t}\n\n\t@Test\n\tvoid getComponentTypeForClassArray() throws Exception {\n\t\tField field = Fields.class.getField(\"arrayClassType\");\n\t\tResolvableType type = ResolvableType.forField(field);\n\t\tassertThat(type.isArray()).isTrue();\n\t\tassertThat(type.getComponentType().getType())\n\t\t\t\t.isEqualTo(((Class) field.getGenericType()).componentType());\n\t}\n\n\t@Test\n\tvoid getComponentTypeForGenericArrayType() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"genericArrayType\"));\n\t\tassertThat(type.isArray()).isTrue();\n\t\tassertThat(type.getComponentType().getType()).isEqualTo(\n\t\t\t\t((GenericArrayType) type.getType()).getGenericComponentType());\n\t}\n\n\t@Test\n\tvoid getComponentTypeForVariableThatResolvesToGenericArray() {\n\t\tResolvableType type = ResolvableType.forClass(ListOfGenericArray.class).asCollection().getGeneric();\n\t\tassertThat(type.isArray()).isTrue();\n\t\tassertThat(type.getType()).isInstanceOf(TypeVariable.class);\n\t\tassertThat(type.getComponentType().getType().toString()).isEqualTo(\n\t\t\t\t\"java.util.List<java.lang.String>\");\n\t}\n\n\t@Test\n\tvoid getComponentTypeForNonArray() {\n\t\tResolvableType type = ResolvableType.forClass(String.class);\n\t\tassertThat(type.isArray()).isFalse();\n\t\tassertThat(type.getComponentType()).isEqualTo(ResolvableType.NONE);\n\t}\n\n\t@Test\n\tvoid asCollection() {\n\t\tResolvableType type = ResolvableType.forClass(ExtendsList.class).asCollection();\n\t\tassertThat(type.resolve()).isEqualTo(Collection.class);\n\t\tassertThat(type.resolveGeneric()).isEqualTo(CharSequence.class);\n\t}\n\n\t@Test\n\tvoid asMap() {\n\t\tResolvableType type = ResolvableType.forClass(ExtendsMap.class).asMap();\n\t\tassertThat(type.resolve()).isEqualTo(Map.class);\n\t\tassertThat(type.resolveGeneric(0)).isEqualTo(String.class);\n\t\tassertThat(type.resolveGeneric(1)).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid asFromInterface() {\n\t\tResolvableType type = ResolvableType.forClass(ExtendsList.class).as(List.class);\n\t\tassertThat(type.getType().toString()).isEqualTo(\"java.util.List<E>\");\n\t}\n\n\t@Test\n\tvoid asFromInheritedInterface() {\n\t\tResolvableType type = ResolvableType.forClass(ExtendsList.class).as(Collection.class);\n\t\tassertThat(type.getType().toString()).isEqualTo(\"java.util.Collection<E>\");\n\t}\n\n\t@Test\n\tvoid asFromSuperType() {\n\t\tResolvableType type = ResolvableType.forClass(ExtendsList.class).as(ArrayList.class);\n\t\tassertThat(type.getType().toString()).isEqualTo(\"java.util.ArrayList<java.lang.CharSequence>\");\n\t}\n\n\t@Test\n\tvoid asFromInheritedSuperType() {\n\t\tResolvableType type = ResolvableType.forClass(ExtendsList.class).as(List.class);\n\t\tassertThat(type.getType().toString()).isEqualTo(\"java.util.List<E>\");\n\t}\n\n\t@Test\n\tvoid asNotFound() {\n\t\tResolvableType type = ResolvableType.forClass(ExtendsList.class).as(Map.class);\n\t\tassertThat(type).isSameAs(ResolvableType.NONE);\n\t}\n\n\t@Test\n\tvoid asSelf() {\n\t\tResolvableType type = ResolvableType.forClass(ExtendsList.class);\n\t\tassertThat(type.as(ExtendsList.class)).isEqualTo(type);\n\t}\n\n\t@Test\n\tvoid getSuperType() {\n\t\tResolvableType type = ResolvableType.forClass(ExtendsList.class).getSuperType();\n\t\tassertThat(type.resolve()).isEqualTo(ArrayList.class);\n\t\ttype = type.getSuperType();\n\t\tassertThat(type.resolve()).isEqualTo(AbstractList.class);\n\t\ttype = type.getSuperType();\n\t\tassertThat(type.resolve()).isEqualTo(AbstractCollection.class);\n\t\ttype = type.getSuperType();\n\t\tassertThat(type.resolve()).isEqualTo(Object.class);\n\t}\n\n\t@Test\n\tvoid getInterfaces() {\n\t\tResolvableType type = ResolvableType.forClass(ExtendsList.class);\n\t\tassertThat(type.getInterfaces()).isEmpty();\n\t\tSortedSet<String> interfaces = new TreeSet<>();\n\t\tfor (ResolvableType interfaceType : type.getSuperType().getInterfaces()) {\n\t\t\tinterfaces.add(interfaceType.toString());\n\t\t}\n\t\tassertThat(interfaces.toString()).isEqualTo(\n\t\t\t\t\"[java.io.Serializable, java.lang.Cloneable, \" +\n\t\t\t\t\"java.util.List<java.lang.CharSequence>, java.util.RandomAccess]\");\n\t}\n\n\t@Test\n\tvoid noSuperType() {\n\t\tassertThat(ResolvableType.forClass(Object.class).getSuperType())\n\t\t\t\t.isEqualTo(ResolvableType.NONE);\n\t}\n\n\t@Test\n\tvoid noInterfaces() {\n\t\tassertThat(ResolvableType.forClass(Object.class).getInterfaces()).isEmpty();\n\t}\n\n\t@Test\n\tvoid nested() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"nested\"));\n\t\ttype = type.getNested(2);\n\t\tassertThat(type.resolve()).isEqualTo(Map.class);\n\t\tassertThat(type.getGeneric(0).resolve()).isEqualTo(Byte.class);\n\t\tassertThat(type.getGeneric(1).resolve()).isEqualTo(Long.class);\n\t}\n\n\t@Test\n\tvoid nestedWithIndexes() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"nested\"));\n\t\ttype = type.getNested(2, Collections.singletonMap(2, 0));\n\t\tassertThat(type.resolve()).isEqualTo(Map.class);\n\t\tassertThat(type.getGeneric(0).resolve()).isEqualTo(String.class);\n\t\tassertThat(type.getGeneric(1).resolve()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid nestedWithArray() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"genericArrayType\"));\n\t\ttype = type.getNested(2);\n\t\tassertThat(type.resolve()).isEqualTo(List.class);\n\t\tassertThat(type.resolveGeneric()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid getGeneric() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringList\"));\n\t\tassertThat(type.getGeneric().getType()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid getGenericByIndex() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringIntegerMultiValueMap\"));\n\t\tassertThat(type.getGeneric(0).getType()).isEqualTo(String.class);\n\t\tassertThat(type.getGeneric(1).getType()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid getGenericOfGeneric() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringListList\"));\n\t\tassertThat(type.getGeneric().getType().toString()).isEqualTo(\"java.util.List<java.lang.String>\");\n\t\tassertThat(type.getGeneric().getGeneric().getType()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid genericOfGenericWithAs() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringListList\")).asCollection();\n\t\tassertThat(type.toString()).isEqualTo(\"java.util.Collection<java.util.List<java.lang.String>>\");\n\t\tassertThat(type.getGeneric().asCollection().toString()).isEqualTo(\"java.util.Collection<java.lang.String>\");\n\t}\n\n\t@Test\n\tvoid getGenericOfGenericByIndexes() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringListList\"));\n\t\tassertThat(type.getGeneric(0, 0).getType()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid getGenericOutOfBounds() {\n\t\tResolvableType type = ResolvableType.forClass(List.class, ExtendsList.class);\n\t\tassertThat(type.getGeneric(0)).isNotEqualTo(ResolvableType.NONE);\n\t\tassertThat(type.getGeneric(1)).isEqualTo(ResolvableType.NONE);\n\t\tassertThat(type.getGeneric(0, 1)).isEqualTo(ResolvableType.NONE);\n\t}\n\n\t@Test\n\tvoid hasGenerics() {\n\t\tResolvableType type = ResolvableType.forClass(ExtendsList.class);\n\t\tassertThat(type.hasGenerics()).isFalse();\n\t\tassertThat(type.asCollection().hasGenerics()).isTrue();\n\t}\n\n\t@Test\n\tvoid getGenericsFromParameterizedType() {\n\t\tResolvableType type = ResolvableType.forClass(List.class, ExtendsList.class);\n\t\tResolvableType[] generics = type.getGenerics();\n\t\tassertThat(generics).hasSize(1);\n\t\tassertThat(generics[0].resolve()).isEqualTo(CharSequence.class);\n\t}\n\n\t@Test\n\tvoid getGenericsFromClass() {\n\t\tResolvableType type = ResolvableType.forClass(List.class);\n\t\tResolvableType[] generics = type.getGenerics();\n\t\tassertThat(generics).hasSize(1);\n\t\tassertThat(generics[0].getType().toString()).isEqualTo(\"E\");\n\t}\n\n\t@Test\n\tvoid noGetGenerics() {\n\t\tResolvableType type = ResolvableType.forClass(ExtendsList.class);\n\t\tResolvableType[] generics = type.getGenerics();\n\t\tassertThat(generics).isEmpty();\n\t}\n\n\t@Test\n\tvoid getResolvedGenerics() {\n\t\tResolvableType type = ResolvableType.forClass(List.class, ExtendsList.class);\n\t\tClass<?>[] generics = type.resolveGenerics();\n\t\tassertThat(generics).hasSize(1);\n\t\tassertThat(generics[0]).isEqualTo(CharSequence.class);\n\t}\n\n\t@Test\n\tvoid resolveClassType() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"classType\"));\n\t\tassertThat(type.resolve()).isEqualTo(List.class);\n\t}\n\n\t@Test\n\tvoid resolveParameterizedType() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"parameterizedType\"));\n\t\tassertThat(type.resolve()).isEqualTo(List.class);\n\t}\n\n\t@Test\n\tvoid resolveArrayClassType() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"arrayClassType\"));\n\t\tassertThat(type.resolve()).isEqualTo(List[].class);\n\t}\n\n\t@Test\n\tvoid resolveGenericArrayType() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"genericArrayType\"));\n\t\tassertThat(type.resolve()).isEqualTo(List[].class);\n\t\tassertThat(type.getComponentType().resolve()).isEqualTo(List.class);\n\t\tassertThat(type.getComponentType().getGeneric().resolve()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid resolveGenericMultiArrayType() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"genericMultiArrayType\"));\n\t\tassertThat(type.resolve()).isEqualTo(List[][][].class);\n\t\tassertThat(type.getComponentType().resolve()).isEqualTo(List[][].class);\n\t}\n\n\t@Test\n\tvoid resolveGenericArrayFromGeneric() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringArrayList\"));\n\t\tResolvableType generic = type.asCollection().getGeneric();\n\t\tassertThat(generic.getType().toString()).isEqualTo(\"E\");\n\t\tassertThat(generic.isArray()).isTrue();\n\t\tassertThat(generic.resolve()).isEqualTo(String[].class);\n\t}\n\n\t@Test\n\tvoid resolveVariableGenericArray() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"variableTypeGenericArray\"), TypedFields.class);\n\t\tassertThat(type.getType().toString()).isEqualTo(\"T[]\");\n\t\tassertThat(type.isArray()).isTrue();\n\t\tassertThat(type.resolve()).isEqualTo(String[].class);\n\t}\n\n\t@Test\n\tvoid resolveVariableGenericArrayUnknown() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"variableTypeGenericArray\"));\n\t\tassertThat(type.getType().toString()).isEqualTo(\"T[]\");\n\t\tassertThat(type.isArray()).isTrue();\n\t\tassertThat(type.resolve()).isNull();\n\t}\n\n\t@Test\n\tvoid resolveVariableGenericArrayUnknownWithFallback() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"variableTypeGenericArray\"));\n\t\tassertThat(type.getType().toString()).isEqualTo(\"T[]\");\n\t\tassertThat(type.isArray()).isTrue();\n\t\tassertThat(type.toClass()).isEqualTo(Object.class);\n\t}\n\n\t@Test\n\tvoid resolveWildcardTypeUpperBounds() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"wildcardType\"));\n\t\tassertThat(type.getGeneric().resolve()).isEqualTo(Number.class);\n\t}\n\n\t@Test\n\tvoid resolveWildcardLowerBounds() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"wildcardSuperType\"));\n\t\tassertThat(type.getGeneric().resolve()).isEqualTo(Number.class);\n\t}\n\n\t@Test\n\tvoid resolveVariableFromFieldType() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringList\"));\n\t\tassertThat(type.resolve()).isEqualTo(List.class);\n\t\tassertThat(type.getGeneric().resolve()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid resolveVariableFromFieldTypeUnknown() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"parameterizedType\"));\n\t\tassertThat(type.resolve()).isEqualTo(List.class);\n\t\tassertThat(type.getGeneric().resolve()).isNull();\n\t}\n\n\t@Test\n\tvoid resolveVariableFromInheritedField() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(\n\t\t\t\tFields.class.getField(\"stringIntegerMultiValueMap\")).as(Map.class);\n\t\tassertThat(type.getGeneric(0).resolve()).isEqualTo(String.class);\n\t\tassertThat(type.getGeneric(1).resolve()).isEqualTo(List.class);\n\t\tassertThat(type.getGeneric(1, 0).resolve()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid resolveVariableFromInheritedFieldSwitched() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(\n\t\t\t\tFields.class.getField(\"stringIntegerMultiValueMapSwitched\")).as(Map.class);\n\t\tassertThat(type.getGeneric(0).resolve()).isEqualTo(String.class);\n\t\tassertThat(type.getGeneric(1).resolve()).isEqualTo(List.class);\n\t\tassertThat(type.getGeneric(1, 0).resolve()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid doesResolveFromOuterOwner() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(\n\t\t\t\tFields.class.getField(\"listOfListOfUnknown\")).as(Collection.class);\n\t\tassertThat(type.getGeneric(0).resolve()).isEqualTo(List.class);\n\t\tassertThat(type.getGeneric(0).as(Collection.class).getGeneric(0).as(Collection.class).resolve()).isNull();\n\t}\n\n\t@Test\n\tvoid intArrayNotAssignableToIntegerArray() throws Exception {\n\t\tResolvableType integerArray = ResolvableType.forField(Fields.class.getField(\"integerArray\"));\n\t\tResolvableType intArray = ResolvableType.forField(Fields.class.getField(\"intArray\"));\n\t\tassertThat(integerArray.isAssignableFrom(intArray)).isFalse();\n\t\tassertThat(intArray.isAssignableFrom(integerArray)).isFalse();\n\t}\n\n\t@Test\n\tvoid resolveBoundedTypeVariableResult() throws Exception {\n\t\tResolvableType type = ResolvableType.forMethodReturnType(Methods.class.getMethod(\"boundedTypeVariableResult\"));\n\t\tassertThat(type.resolve()).isEqualTo(CharSequence.class);\n\t}\n\n\t@Test\n\tvoid resolveBoundedTypeVariableWildcardResult() throws Exception {\n\t\tResolvableType type = ResolvableType.forMethodReturnType(Methods.class.getMethod(\"boundedTypeVariableWildcardResult\"));\n\t\tassertThat(type.getGeneric(1).asCollection().resolveGeneric()).isEqualTo(CharSequence.class);\n\t}\n\n\t@Test\n\tvoid resolveVariableNotFound() throws Exception {\n\t\tResolvableType type = ResolvableType.forMethodReturnType(Methods.class.getMethod(\"typedReturn\"));\n\t\tassertThat(type.resolve()).isNull();\n\t}\n\n\t@Test\n\tvoid resolveTypeVariableFromSimpleInterfaceType() {\n\t\tResolvableType type = ResolvableType.forClass(MySimpleInterfaceType.class).as(MyInterfaceType.class);\n\t\tassertThat(type.resolveGeneric()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeVariableFromSimpleCollectionInterfaceType() {\n\t\tResolvableType type = ResolvableType.forClass(MyCollectionInterfaceType.class).as(MyInterfaceType.class);\n\t\tassertThat(type.resolveGeneric()).isEqualTo(Collection.class);\n\t\tassertThat(type.resolveGeneric(0, 0)).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeVariableFromSimpleSuperclassType() {\n\t\tResolvableType type = ResolvableType.forClass(MySimpleSuperclassType.class).as(MySuperclassType.class);\n\t\tassertThat(type.resolveGeneric()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeVariableFromSimpleCollectionSuperclassType() {\n\t\tResolvableType type = ResolvableType.forClass(MyCollectionSuperclassType.class).as(MySuperclassType.class);\n\t\tassertThat(type.resolveGeneric()).isEqualTo(Collection.class);\n\t\tassertThat(type.resolveGeneric(0, 0)).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeVariableFromFieldTypeWithImplementsClass() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(\n\t\t\t\tFields.class.getField(\"parameterizedType\"), TypedFields.class);\n\t\tassertThat(type.resolve()).isEqualTo(List.class);\n\t\tassertThat(type.getGeneric().resolve()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeVariableFromFieldTypeWithImplementsType() throws Exception {\n\t\tResolvableType implementationType = ResolvableType.forClassWithGenerics(\n\t\t\t\tFields.class, Integer.class);\n\t\tResolvableType type = ResolvableType.forField(\n\t\t\t\tFields.class.getField(\"parameterizedType\"), implementationType);\n\t\tassertThat(type.resolve()).isEqualTo(List.class);\n\t\tassertThat(type.getGeneric().resolve()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeVariableFromSuperType() {\n\t\tResolvableType type = ResolvableType.forClass(ExtendsList.class);\n\t\tassertThat(type.resolve()).isEqualTo(ExtendsList.class);\n\t\tassertThat(type.asCollection().resolveGeneric()).isEqualTo(CharSequence.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeVariableFromClassWithImplementsClass() {\n\t\tResolvableType type = ResolvableType.forClass(\n\t\t\t\tMySuperclassType.class, MyCollectionSuperclassType.class);\n\t\tassertThat(type.resolveGeneric()).isEqualTo(Collection.class);\n\t\tassertThat(type.resolveGeneric(0, 0)).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeVariableFromConstructorParameter() throws Exception {\n\t\tConstructor<?> constructor = Constructors.class.getConstructor(List.class);\n\t\tResolvableType type = ResolvableType.forConstructorParameter(constructor, 0);\n\t\tassertThat(type.resolve()).isEqualTo(List.class);\n\t\tassertThat(type.resolveGeneric(0)).isEqualTo(CharSequence.class);\n\t}\n\n\t@Test\n\tvoid resolveUnknownTypeVariableFromConstructorParameter() throws Exception {\n\t\tConstructor<?> constructor = Constructors.class.getConstructor(Map.class);\n\t\tResolvableType type = ResolvableType.forConstructorParameter(constructor, 0);\n\t\tassertThat(type.resolve()).isEqualTo(Map.class);\n\t\tassertThat(type.resolveGeneric(0)).isNull();\n\t}\n\n\t@Test\n\tvoid resolveTypeVariableFromConstructorParameterWithImplementsClass() throws Exception {\n\t\tConstructor<?> constructor = Constructors.class.getConstructor(Map.class);\n\t\tResolvableType type = ResolvableType.forConstructorParameter(\n\t\t\t\tconstructor, 0, TypedConstructors.class);\n\t\tassertThat(type.resolve()).isEqualTo(Map.class);\n\t\tassertThat(type.resolveGeneric(0)).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeVariableFromMethodParameter() throws Exception {\n\t\tMethod method = Methods.class.getMethod(\"typedParameter\", Object.class);\n\t\tResolvableType type = ResolvableType.forMethodParameter(method, 0);\n\t\tassertThat(type.resolve()).isNull();\n\t\tassertThat(type.getType().toString()).isEqualTo(\"T\");\n\t}\n\n\t@Test\n\tvoid resolveTypeVariableFromMethodParameterWithImplementsClass() throws Exception {\n\t\tMethod method = Methods.class.getMethod(\"typedParameter\", Object.class);\n\t\tResolvableType type = ResolvableType.forMethodParameter(method, 0, TypedMethods.class);\n\t\tassertThat(type.resolve()).isEqualTo(String.class);\n\t\tassertThat(type.getType().toString()).isEqualTo(\"T\");\n\t}\n\n\t@Test\n\tvoid resolveTypeVariableFromMethodParameterType() throws Exception {\n\t\tMethod method = Methods.class.getMethod(\"typedParameter\", Object.class);\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(method, 0);\n\t\tResolvableType type = ResolvableType.forMethodParameter(methodParameter);\n\t\tassertThat(type.resolve()).isNull();\n\t\tassertThat(type.getType().toString()).isEqualTo(\"T\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid resolveTypeVariableFromMethodParameterTypeWithImplementsClass() throws Exception {\n\t\tMethod method = Methods.class.getMethod(\"typedParameter\", Object.class);\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(method, 0);\n\t\tmethodParameter.setContainingClass(TypedMethods.class);\n\t\tResolvableType type = ResolvableType.forMethodParameter(methodParameter);\n\t\tassertThat(type.resolve()).isEqualTo(String.class);\n\t\tassertThat(type.getType().toString()).isEqualTo(\"T\");\n\t}\n\n\t@Test\n\tvoid resolveTypeVariableFromMethodParameterTypeWithImplementsType() throws Exception {\n\t\tMethod method = Methods.class.getMethod(\"typedParameter\", Object.class);\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(method, 0);\n\t\tResolvableType implementationType = ResolvableType.forClassWithGenerics(Methods.class, Integer.class);\n\t\tResolvableType type = ResolvableType.forMethodParameter(methodParameter, implementationType);\n\t\tassertThat(type.resolve()).isEqualTo(Integer.class);\n\t\tassertThat(type.getType().toString()).isEqualTo(\"T\");\n\t}\n\n\t@Test\n\tvoid resolveTypeVariableFromMethodReturn() throws Exception {\n\t\tMethod method = Methods.class.getMethod(\"typedReturn\");\n\t\tResolvableType type = ResolvableType.forMethodReturnType(method);\n\t\tassertThat(type.resolve()).isNull();\n\t\tassertThat(type.getType().toString()).isEqualTo(\"T\");\n\t}\n\n\t@Test\n\tvoid resolveTypeVariableFromMethodReturnWithImplementsClass() throws Exception {\n\t\tMethod method = Methods.class.getMethod(\"typedReturn\");\n\t\tResolvableType type = ResolvableType.forMethodReturnType(method, TypedMethods.class);\n\t\tassertThat(type.resolve()).isEqualTo(String.class);\n\t\tassertThat(type.getType().toString()).isEqualTo(\"T\");\n\t}\n\n\t@Test\n\tvoid resolveTypeVariableFromType() throws Exception {\n\t\tType sourceType = Methods.class.getMethod(\"typedReturn\").getGenericReturnType();\n\t\tResolvableType type = ResolvableType.forType(sourceType);\n\t\tassertThat(type.resolve()).isNull();\n\t\tassertThat(type.getType().toString()).isEqualTo(\"T\");\n\t}\n\n\t@Test\n\tvoid resolveTypeVariableFromTypeWithVariableResolver() throws Exception {\n\t\tType sourceType = Methods.class.getMethod(\"typedReturn\").getGenericReturnType();\n\t\tResolvableType type = ResolvableType.forType(\n\t\t\t\tsourceType, ResolvableType.forClass(TypedMethods.class).as(Methods.class).asVariableResolver());\n\t\tassertThat(type.resolve()).isEqualTo(String.class);\n\t\tassertThat(type.getType().toString()).isEqualTo(\"T\");\n\t}\n\n\t@Test\n\tvoid resolveTypeWithCustomVariableResolver() throws Exception {\n\t\tVariableResolver variableResolver = mock();\n\t\tgiven(variableResolver.getSource()).willReturn(this);\n\t\tResolvableType longType = ResolvableType.forClass(Long.class);\n\t\tgiven(variableResolver.resolveVariable(any())).willReturn(longType);\n\n\t\tResolvableType variable = ResolvableType.forType(\n\t\t\t\tFields.class.getField(\"typeVariableType\").getGenericType(), variableResolver);\n\t\tResolvableType parameterized = ResolvableType.forType(\n\t\t\t\tFields.class.getField(\"parameterizedType\").getGenericType(), variableResolver);\n\n\t\tassertThat(variable.resolve()).isEqualTo(Long.class);\n\t\tassertThat(parameterized.resolve()).isEqualTo(List.class);\n\t\tassertThat(parameterized.resolveGeneric()).isEqualTo(Long.class);\n\t\tverify(variableResolver, atLeastOnce()).resolveVariable(this.typeVariableCaptor.capture());\n\t\tassertThat(this.typeVariableCaptor.getValue().getName()).isEqualTo(\"T\");\n\t}\n\n\t@Test\n\tvoid resolveTypeVariableFromReflectiveParameterizedTypeReference() throws Exception {\n\t\tType sourceType = Methods.class.getMethod(\"typedReturn\").getGenericReturnType();\n\t\tResolvableType type = ResolvableType.forType(ParameterizedTypeReference.forType(sourceType));\n\t\tassertThat(type.resolve()).isNull();\n\t\tassertThat(type.getType().toString()).isEqualTo(\"T\");\n\t}\n\n\t@Test\n\tvoid resolveTypeVariableFromDeclaredParameterizedTypeReference() throws Exception {\n\t\tType sourceType = Methods.class.getMethod(\"charSequenceReturn\").getGenericReturnType();\n\t\tResolvableType reflectiveType = ResolvableType.forType(sourceType);\n\t\tResolvableType declaredType = ResolvableType.forType(new ParameterizedTypeReference<List<CharSequence>>() {});\n\t\tassertThat(declaredType).isEqualTo(reflectiveType);\n\t}\n\n\t@Test\n\tvoid toStrings() throws Exception {\n\t\tassertThat(ResolvableType.NONE.toString()).isEqualTo(\"?\");\n\n\t\tassertThat(forField(\"classType\")).hasToString(\"java.util.List<?>\");\n\t\tassertThat(forField(\"typeVariableType\")).hasToString(\"?\");\n\t\tassertThat(forField(\"parameterizedType\")).hasToString(\"java.util.List<?>\");\n\t\tassertThat(forField(\"arrayClassType\")).hasToString(\"java.util.List<?>[]\");\n\t\tassertThat(forField(\"genericArrayType\")).hasToString(\"java.util.List<java.lang.String>[]\");\n\t\tassertThat(forField(\"genericMultiArrayType\")).hasToString(\"java.util.List<java.lang.String>[][][]\");\n\t\tassertThat(forField(\"wildcardType\")).hasToString(\"java.util.List<java.lang.Number>\");\n\t\tassertThat(forField(\"wildcardSuperType\")).hasToString(\"java.util.List<java.lang.Number>\");\n\t\tassertThat(forField(\"charSequenceList\")).hasToString(\"java.util.List<java.lang.CharSequence>\");\n\t\tassertThat(forField(\"stringList\")).hasToString(\"java.util.List<java.lang.String>\");\n\t\tassertThat(forField(\"stringListList\")).hasToString(\"java.util.List<java.util.List<java.lang.String>>\");\n\t\tassertThat(forField(\"stringArrayList\")).hasToString(\"java.util.List<java.lang.String[]>\");\n\t\tassertThat(forField(\"stringIntegerMultiValueMap\")).hasToString(\"org.springframework.util.MultiValueMap<java.lang.String, java.lang.Integer>\");\n\t\tassertThat(forField(\"stringIntegerMultiValueMapSwitched\")).hasToString(VariableNameSwitch.class.getName() + \"<java.lang.Integer, java.lang.String>\");\n\t\tassertThat(forField(\"listOfListOfUnknown\")).hasToString(\"java.util.List<java.util.List<?>>\");\n\n\t\tassertThat(forTypedField(\"typeVariableType\")).hasToString(\"java.lang.String\");\n\t\tassertThat(forTypedField(\"parameterizedType\")).hasToString(\"java.util.List<java.lang.String>\");\n\n\t\tassertThat(ResolvableType.forClass(ListOfGenericArray.class).toString()).isEqualTo(ListOfGenericArray.class.getName());\n\t\tassertThat(ResolvableType.forClass(List.class, ListOfGenericArray.class).toString()).isEqualTo(\"java.util.List<java.util.List<java.lang.String>[]>\");\n\t}\n\n\t@Test\n\tvoid getSource() throws Exception {\n\t\tClass<?> classType = MySimpleInterfaceType.class;\n\t\tField basicField = Fields.class.getField(\"classType\");\n\t\tField field = Fields.class.getField(\"charSequenceList\");\n\t\tMethod method = Methods.class.getMethod(\"charSequenceParameter\", List.class);\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(method, 0);\n\t\tassertThat(ResolvableType.forField(basicField).getSource()).isEqualTo(basicField);\n\t\tassertThat(ResolvableType.forField(field).getSource()).isEqualTo(field);\n\t\tassertThat(ResolvableType.forMethodParameter(methodParameter).getSource()).isEqualTo(methodParameter);\n\t\tassertThat(ResolvableType.forMethodParameter(method, 0).getSource()).isEqualTo(methodParameter);\n\t\tassertThat(ResolvableType.forClass(classType).getSource()).isEqualTo(classType);\n\t\tassertThat(ResolvableType.forClass(classType).getSuperType().getSource()).isEqualTo(classType.getGenericSuperclass());\n\t}\n\n\t@Test\n\tvoid resolveFromOuterClass() throws Exception {\n\t\tField field = EnclosedInParameterizedType.InnerTyped.class.getField(\"field\");\n\t\tResolvableType type = ResolvableType.forField(field, TypedEnclosedInParameterizedType.TypedInnerTyped.class);\n\t\tassertThat(type.resolve()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid resolveFromClassWithGenerics() {\n\t\tResolvableType type = ResolvableType.forClassWithGenerics(List.class, ResolvableType.forClassWithGenerics(List.class, String.class));\n\t\tassertThat(type.asCollection().toString()).isEqualTo(\"java.util.Collection<java.util.List<java.lang.String>>\");\n\t\tassertThat(type.asCollection().getGeneric().toString()).isEqualTo(\"java.util.List<java.lang.String>\");\n\t\tassertThat(type.asCollection().getGeneric().asCollection().toString()).isEqualTo(\"java.util.Collection<java.lang.String>\");\n\t\tassertThat(type.toString()).isEqualTo(\"java.util.List<java.util.List<java.lang.String>>\");\n\t\tassertThat(type.asCollection().getGeneric().getGeneric().resolve()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid isAssignableFromMustNotBeNull() {\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> ResolvableType.forClass(Object.class).isAssignableFrom((ResolvableType) null))\n\t\t\t\t.withMessage(\"ResolvableType must not be null\");\n\t}\n\n\t@Test\n\tvoid isAssignableFromForNone() {\n\t\tResolvableType objectType = ResolvableType.forClass(Object.class);\n\t\tassertThat(objectType.isAssignableFrom(ResolvableType.NONE)).isFalse();\n\t\tassertThat(ResolvableType.NONE.isAssignableFrom(objectType)).isFalse();\n\t}\n\n\t@Test\n\tvoid isAssignableFromForClassAndClass() {\n\t\tResolvableType objectType = ResolvableType.forClass(Object.class);\n\t\tResolvableType charSequenceType = ResolvableType.forClass(CharSequence.class);\n\t\tResolvableType stringType = ResolvableType.forClass(String.class);\n\n\t\tassertThatResolvableType(objectType).isAssignableFrom(objectType, charSequenceType, stringType);\n\t\tassertThatResolvableType(charSequenceType).isAssignableFrom(charSequenceType, stringType).isNotAssignableFrom(objectType);\n\t\tassertThatResolvableType(stringType).isAssignableFrom(stringType).isNotAssignableFrom(objectType, charSequenceType);\n\n\t\tassertThat(objectType.isAssignableFrom(String.class)).isTrue();\n\t\tassertThat(objectType.isAssignableFrom(StringBuilder.class)).isTrue();\n\t\tassertThat(charSequenceType.isAssignableFrom(String.class)).isTrue();\n\t\tassertThat(charSequenceType.isAssignableFrom(StringBuilder.class)).isTrue();\n\t\tassertThat(stringType.isAssignableFrom(String.class)).isTrue();\n\t\tassertThat(stringType.isAssignableFrom(StringBuilder.class)).isFalse();\n\n\t\tassertThat(objectType.isInstance(\"a String\")).isTrue();\n\t\tassertThat(objectType.isInstance(new StringBuilder(\"a StringBuilder\"))).isTrue();\n\t\tassertThat(charSequenceType.isInstance(\"a String\")).isTrue();\n\t\tassertThat(charSequenceType.isInstance(new StringBuilder(\"a StringBuilder\"))).isTrue();\n\t\tassertThat(stringType.isInstance(\"a String\")).isTrue();\n\t\tassertThat(stringType.isInstance(new StringBuilder(\"a StringBuilder\"))).isFalse();\n\t}\n\n\t@Test\n\tvoid isAssignableFromCannotBeResolved() throws Exception {\n\t\tResolvableType objectType = ResolvableType.forClass(Object.class);\n\t\tResolvableType unresolvableVariable1 = ResolvableType.forField(AssignmentBase.class.getField(\"o\"));\n\t\tResolvableType unresolvableVariable2 = ResolvableType.forField(AssignmentBase.class.getField(\"c\"));\n\t\tResolvableType unresolvableVariable3 = ResolvableType.forField(AssignmentBase.class.getField(\"s\"));\n\n\t\tassertThat(unresolvableVariable1.resolve()).isNull();\n\t\tassertThatResolvableType(objectType).isAssignableFrom(unresolvableVariable1);\n\t\tassertThatResolvableType(unresolvableVariable1).isAssignableFrom(objectType);\n\n\t\tassertThat(unresolvableVariable2.resolve()).isNull();\n\t\tassertThatResolvableType(objectType).isAssignableFrom(unresolvableVariable2);\n\t\tassertThatResolvableType(unresolvableVariable2).isAssignableFrom(objectType);\n\n\t\tassertThat(unresolvableVariable3.resolve()).isEqualTo(Serializable.class);\n\t\tassertThatResolvableType(objectType).isAssignableFrom(unresolvableVariable3);\n\t\tassertThatResolvableType(unresolvableVariable3).isNotAssignableFrom(objectType);\n\t}\n\n\t@Test\n\tvoid isAssignableFromForClassAndSimpleVariable() throws Exception {\n\t\tResolvableType objectType = ResolvableType.forClass(Object.class);\n\t\tResolvableType charSequenceType = ResolvableType.forClass(CharSequence.class);\n\t\tResolvableType stringType = ResolvableType.forClass(String.class);\n\n\t\tResolvableType objectVariable = ResolvableType.forField(AssignmentBase.class.getField(\"o\"), Assignment.class);\n\t\tResolvableType charSequenceVariable = ResolvableType.forField(AssignmentBase.class.getField(\"c\"), Assignment.class);\n\t\tResolvableType stringVariable = ResolvableType.forField(AssignmentBase.class.getField(\"s\"), Assignment.class);\n\n\t\tassertThatResolvableType(objectType).isAssignableFrom(objectVariable, charSequenceVariable, stringVariable);\n\t\tassertThatResolvableType(charSequenceType).isAssignableFrom(charSequenceVariable, stringVariable).isNotAssignableFrom(objectVariable);\n\t\tassertThatResolvableType(stringType).isAssignableFrom(stringVariable).isNotAssignableFrom(objectVariable, charSequenceVariable);\n\n\t\tassertThatResolvableType(objectVariable).isAssignableFrom(objectType, charSequenceType, stringType);\n\t\tassertThatResolvableType(charSequenceVariable).isAssignableFrom(charSequenceType, stringType).isNotAssignableFrom(objectType);\n\t\tassertThatResolvableType(stringVariable).isAssignableFrom(stringType).isNotAssignableFrom(objectType, charSequenceType);\n\n\t\tassertThatResolvableType(objectVariable).isAssignableFrom(objectVariable, charSequenceVariable, stringVariable);\n\t\tassertThatResolvableType(charSequenceVariable).isAssignableFrom(charSequenceVariable, stringVariable).isNotAssignableFrom(objectVariable);\n\t\tassertThatResolvableType(stringVariable).isAssignableFrom(stringVariable).isNotAssignableFrom(objectVariable, charSequenceVariable);\n\t}\n\n\t@Test\n\tvoid isAssignableFromForSameClassNonExtendsGenerics() throws Exception {\n\t\tResolvableType objectList = ResolvableType.forField(AssignmentBase.class.getField(\"listo\"), Assignment.class);\n\t\tResolvableType stringList = ResolvableType.forField(AssignmentBase.class.getField(\"lists\"), Assignment.class);\n\n\t\tassertThatResolvableType(stringList).isNotAssignableFrom(objectList);\n\t\tassertThatResolvableType(objectList).isNotAssignableFrom(stringList);\n\t\tassertThatResolvableType(stringList).isAssignableFrom(stringList);\n\t}\n\n\t@Test\n\tvoid isAssignableFromForSameClassExtendsGenerics() throws Exception {\n\n\t\t// Generic assignment can be a little confusing, given:\n\t\t//\n\t\t// List<CharSequence> c1, List<? extends CharSequence> c2, List<String> s;\n\t\t//\n\t\t// c2 = s; is allowed and is often used for argument input, for example\n\t\t// see List.addAll(). You can get items from c2 but you cannot add items without\n\t\t// getting a generic type 'is not applicable for the arguments' error. This makes\n\t\t// sense since if you added a StringBuffer to c2 it would break the rules on s.\n\t\t//\n\t\t// c1 = s; not allowed. Since there is no '? extends' to cause the generic\n\t\t// 'is not applicable for the arguments' error when adding (which would pollute\n\t\t// s).\n\n\t\tResolvableType objectList = ResolvableType.forField(AssignmentBase.class.getField(\"listo\"), Assignment.class);\n\t\tResolvableType charSequenceList = ResolvableType.forField(AssignmentBase.class.getField(\"listc\"), Assignment.class);\n\t\tResolvableType stringList = ResolvableType.forField(AssignmentBase.class.getField(\"lists\"), Assignment.class);\n\t\tResolvableType extendsObjectList = ResolvableType.forField(AssignmentBase.class.getField(\"listxo\"), Assignment.class);\n\t\tResolvableType extendsCharSequenceList = ResolvableType.forField(AssignmentBase.class.getField(\"listxc\"), Assignment.class);\n\t\tResolvableType extendsStringList = ResolvableType.forField(AssignmentBase.class.getField(\"listxs\"), Assignment.class);\n\n\t\tassertThatResolvableType(objectList).isNotAssignableFrom(extendsObjectList, extendsCharSequenceList, extendsStringList);\n\t\tassertThatResolvableType(charSequenceList).isNotAssignableFrom(extendsObjectList, extendsCharSequenceList, extendsStringList);\n\t\tassertThatResolvableType(stringList).isNotAssignableFrom(extendsObjectList, extendsCharSequenceList, extendsStringList);\n\t\tassertThatResolvableType(extendsObjectList).isAssignableFrom(objectList, charSequenceList, stringList);\n\t\tassertThatResolvableType(extendsObjectList).isAssignableFrom(extendsObjectList, extendsCharSequenceList, extendsStringList);\n\t\tassertThatResolvableType(extendsCharSequenceList).isAssignableFrom(extendsCharSequenceList, extendsStringList).isNotAssignableFrom(extendsObjectList);\n\t\tassertThatResolvableType(extendsCharSequenceList).isAssignableFrom(charSequenceList, stringList).isNotAssignableFrom(objectList);\n\t\tassertThatResolvableType(extendsStringList).isAssignableFrom(extendsStringList).isNotAssignableFrom(extendsObjectList, extendsCharSequenceList);\n\t\tassertThatResolvableType(extendsStringList).isAssignableFrom(stringList).isNotAssignableFrom(objectList, charSequenceList);\n\t}\n\n\t@Test\n\tvoid isAssignableFromForDifferentClassesWithGenerics() throws Exception {\n\t\tResolvableType extendsCharSequenceCollection = ResolvableType.forField(AssignmentBase.class.getField(\"collectionxc\"), Assignment.class);\n\t\tResolvableType charSequenceCollection = ResolvableType.forField(AssignmentBase.class.getField(\"collectionc\"), Assignment.class);\n\t\tResolvableType charSequenceList = ResolvableType.forField(AssignmentBase.class.getField(\"listc\"), Assignment.class);\n\t\tResolvableType extendsCharSequenceList = ResolvableType.forField(AssignmentBase.class.getField(\"listxc\"), Assignment.class);\n\t\tResolvableType extendsStringList = ResolvableType.forField(AssignmentBase.class.getField(\"listxs\"), Assignment.class);\n\n\t\tassertThatResolvableType(extendsCharSequenceCollection).isAssignableFrom(charSequenceCollection, charSequenceList, extendsCharSequenceList, extendsStringList);\n\t\tassertThatResolvableType(charSequenceCollection).isAssignableFrom(charSequenceList).isNotAssignableFrom(extendsCharSequenceList, extendsStringList);\n\t\tassertThatResolvableType(charSequenceList).isNotAssignableFrom(extendsCharSequenceCollection, charSequenceCollection);\n\t\tassertThatResolvableType(extendsCharSequenceList).isNotAssignableFrom(extendsCharSequenceCollection, charSequenceCollection);\n\t\tassertThatResolvableType(extendsStringList).isNotAssignableFrom(charSequenceCollection, charSequenceList, extendsCharSequenceList);\n\t}\n\n\t@Test\n\tvoid isAssignableFromForArrays() throws Exception {\n\t\tResolvableType object = ResolvableType.forField(AssignmentBase.class.getField(\"o\"), Assignment.class);\n\t\tResolvableType objectArray = ResolvableType.forField(AssignmentBase.class.getField(\"oarray\"), Assignment.class);\n\t\tResolvableType charSequenceArray = ResolvableType.forField(AssignmentBase.class.getField(\"carray\"), Assignment.class);\n\t\tResolvableType stringArray = ResolvableType.forField(AssignmentBase.class.getField(\"sarray\"), Assignment.class);\n\n\t\tassertThatResolvableType(object).isAssignableFrom(objectArray, charSequenceArray, stringArray);\n\t\tassertThatResolvableType(objectArray).isAssignableFrom(objectArray, charSequenceArray, stringArray).isNotAssignableFrom(object);\n\t\tassertThatResolvableType(charSequenceArray).isAssignableFrom(charSequenceArray, stringArray).isNotAssignableFrom(object, objectArray);\n\t\tassertThatResolvableType(stringArray).isAssignableFrom(stringArray).isNotAssignableFrom(object, objectArray, charSequenceArray);\n\t}\n\n\t@Test\n\tvoid isAssignableFromForWildcards() throws Exception {\n\t\tResolvableType object = ResolvableType.forClass(Object.class);\n\t\tResolvableType charSequence = ResolvableType.forClass(CharSequence.class);\n\t\tResolvableType string = ResolvableType.forClass(String.class);\n\t\tResolvableType extendsAnon = ResolvableType.forField(AssignmentBase.class.getField(\"listAnon\"), Assignment.class).getGeneric();\n\t\tResolvableType extendsObject = ResolvableType.forField(AssignmentBase.class.getField(\"listxo\"), Assignment.class).getGeneric();\n\t\tResolvableType extendsCharSequence = ResolvableType.forField(AssignmentBase.class.getField(\"listxc\"), Assignment.class).getGeneric();\n\t\tResolvableType extendsString = ResolvableType.forField(AssignmentBase.class.getField(\"listxs\"), Assignment.class).getGeneric();\n\t\tResolvableType superObject = ResolvableType.forField(AssignmentBase.class.getField(\"listso\"), Assignment.class).getGeneric();\n\t\tResolvableType superCharSequence = ResolvableType.forField(AssignmentBase.class.getField(\"listsc\"), Assignment.class).getGeneric();\n\t\tResolvableType superString = ResolvableType.forField(AssignmentBase.class.getField(\"listss\"), Assignment.class).getGeneric();\n\n\t\t// Language Spec 4.5.1. Type Arguments and Wildcards\n\n\t\t// ? extends T <= ? extends S if T <: S\n\t\tassertThatResolvableType(extendsCharSequence).isAssignableFrom(extendsCharSequence, extendsString).isNotAssignableFrom(extendsObject);\n\t\tassertThatResolvableType(extendsCharSequence).isAssignableFrom(charSequence, string).isNotAssignableFrom(object);\n\n\t\t// ? super T <= ? super S if S <: T\n\t\tassertThatResolvableType(superCharSequence).isAssignableFrom(superObject, superCharSequence).isNotAssignableFrom(superString);\n\t\tassertThatResolvableType(superCharSequence).isAssignableFrom(object, charSequence).isNotAssignableFrom(string);\n\n\t\t// [Implied] super / extends cannot be mixed\n\t\tassertThatResolvableType(superCharSequence).isNotAssignableFrom(extendsObject, extendsCharSequence, extendsString);\n\t\tassertThatResolvableType(extendsCharSequence).isNotAssignableFrom(superObject, superCharSequence, superString);\n\n\t\t// T <= T\n\t\tassertThatResolvableType(charSequence).isAssignableFrom(charSequence, string).isNotAssignableFrom(object);\n\n\t\t// T <= ? extends T\n\t\tassertThatResolvableType(extendsCharSequence).isAssignableFrom(charSequence, string).isNotAssignableFrom(object);\n\t\tassertThatResolvableType(charSequence).isAssignableFrom(extendsCharSequence, extendsString).isNotAssignableFrom(extendsObject);\n\t\tassertThatResolvableType(extendsAnon).isAssignableFrom(object, charSequence, string);\n\n\t\t// T <= ? super T\n\t\tassertThatResolvableType(superCharSequence).isAssignableFrom(object, charSequence).isNotAssignableFrom(string);\n\t\tassertThatResolvableType(charSequence).isNotAssignableFrom(superObject, superCharSequence, superString);\n\t}\n\n\t@Test\n\tvoid isAssignableFromForComplexWildcards() throws Exception {\n\t\tResolvableType complex1 = ResolvableType.forField(AssignmentBase.class.getField(\"complexWildcard1\"));\n\t\tResolvableType complex2 = ResolvableType.forField(AssignmentBase.class.getField(\"complexWildcard2\"));\n\t\tResolvableType complex3 = ResolvableType.forField(AssignmentBase.class.getField(\"complexWildcard3\"));\n\t\tResolvableType complex4 = ResolvableType.forField(AssignmentBase.class.getField(\"complexWildcard4\"));\n\n\t\tassertThatResolvableType(complex1).isAssignableFrom(complex2);\n\t\tassertThatResolvableType(complex2).isNotAssignableFrom(complex1);\n\t\tassertThatResolvableType(complex3).isAssignableFrom(complex4);\n\t\tassertThatResolvableType(complex4).isNotAssignableFrom(complex3);\n\t}\n\n\t@Test\n\tvoid isAssignableFromForUnresolvedWildcard() {\n\t\tResolvableType wildcard = ResolvableType.forInstance(new Wildcard<>());\n\t\tResolvableType wildcardFixed = ResolvableType.forInstance(new WildcardFixed());\n\t\tResolvableType wildcardConcrete = ResolvableType.forClassWithGenerics(Wildcard.class, CharSequence.class);\n\t\tResolvableType wildcardConsumer = ResolvableType.forInstance(new WildcardConsumer<>());\n\n\t\tassertThat(wildcard.isAssignableFrom(wildcardFixed)).isTrue();\n\t\tassertThat(wildcard.isAssignableFromResolvedPart(wildcardFixed)).isTrue();\n\t\tassertThat(wildcard.isAssignableFrom(wildcardConcrete)).isTrue();\n\t\tassertThat(wildcard.isAssignableFromResolvedPart(wildcardConcrete)).isTrue();\n\t\tassertThat(wildcardFixed.isAssignableFrom(wildcard)).isFalse();\n\t\tassertThat(wildcardFixed.isAssignableFromResolvedPart(wildcard)).isFalse();\n\t\tassertThat(wildcardFixed.isAssignableFrom(wildcardConcrete)).isFalse();\n\t\tassertThat(wildcardFixed.isAssignableFromResolvedPart(wildcardConcrete)).isFalse();\n\t\tassertThat(wildcardConcrete.isAssignableFrom(wildcard)).isTrue();\n\t\tassertThat(wildcardConcrete.isAssignableFromResolvedPart(wildcard)).isTrue();\n\t\tassertThat(wildcardConcrete.isAssignableFrom(wildcardFixed)).isFalse();\n\t\tassertThat(wildcardConcrete.isAssignableFromResolvedPart(wildcardFixed)).isFalse();\n\t\tassertThat(wildcardConsumer.as(Consumer.class).getGeneric().isAssignableFrom(wildcard)).isFalse();\n\t\tassertThat(wildcardConsumer.as(Consumer.class).getGeneric().isAssignableFromResolvedPart(wildcard)).isTrue();\n\t}\n\n\t@Test\n\tvoid isAssignableFromForUnresolvedDoubleWildcard() {\n\t\tResolvableType wildcard = ResolvableType.forInstance(new DoubleWildcard<>());\n\t\tResolvableType wildcardFixed = ResolvableType.forInstance(new DoubleWildcardFixed());\n\t\tResolvableType wildcardConsumer = ResolvableType.forInstance(new DoubleWildcardConsumer<>());\n\n\t\tassertThat(wildcard.isAssignableFrom(wildcardFixed)).isTrue();\n\t\tassertThat(wildcard.isAssignableFromResolvedPart(wildcardFixed)).isTrue();\n\t\tassertThat(wildcardFixed.isAssignableFrom(wildcard)).isFalse();\n\t\tassertThat(wildcardFixed.isAssignableFromResolvedPart(wildcard)).isFalse();\n\t\tassertThat(wildcardConsumer.as(Consumer.class).getGeneric().isAssignableFrom(wildcard)).isTrue();\n\t\tassertThat(wildcardConsumer.as(Consumer.class).getGeneric().isAssignableFromResolvedPart(wildcard)).isTrue();\n\t}\n\n\t@Test\n\tvoid strictGenericsMatching() {\n\t\tResolvableType consumerUnresolved = ResolvableType.forClass(Consumer.class);\n\t\tResolvableType consumerObject = ResolvableType.forClassWithGenerics(Consumer.class, Object.class);\n\t\tResolvableType consumerNestedUnresolved = ResolvableType.forClassWithGenerics(Consumer.class, ResolvableType.forClass(Consumer.class));\n\t\tResolvableType consumerNumber = ResolvableType.forClassWithGenerics(Consumer.class, Number.class);\n\t\tResolvableType consumerExtendsNumber = ResolvableType.forClass(SubConsumer.class);\n\n\t\tassertThat(consumerUnresolved.isAssignableFrom(consumerObject)).isTrue();\n\t\tassertThat(consumerUnresolved.isAssignableFromResolvedPart(consumerObject)).isTrue();\n\t\tassertThat(consumerObject.isAssignableFrom(consumerUnresolved)).isTrue();\n\t\tassertThat(consumerObject.isAssignableFromResolvedPart(consumerUnresolved)).isTrue();\n\t\tassertThat(consumerUnresolved.isAssignableFrom(consumerNestedUnresolved)).isTrue();\n\t\tassertThat(consumerUnresolved.isAssignableFromResolvedPart(consumerNestedUnresolved)).isTrue();\n\t\tassertThat(consumerObject.isAssignableFrom(consumerNestedUnresolved)).isFalse();\n\t\tassertThat(consumerObject.isAssignableFromResolvedPart(consumerNestedUnresolved)).isFalse();\n\t\tassertThat(consumerObject.isAssignableFrom(consumerNumber)).isFalse();\n\t\tassertThat(consumerObject.isAssignableFromResolvedPart(consumerNumber)).isFalse();\n\t\tassertThat(consumerObject.isAssignableFrom(consumerExtendsNumber)).isFalse();\n\t\tassertThat(consumerObject.isAssignableFromResolvedPart(consumerExtendsNumber)).isTrue();\n\t}\n\n\t@Test\n\tvoid identifyTypeVariable() throws Exception {\n\t\tMethod method = ClassArguments.class.getMethod(\"typedArgumentFirst\", Class.class, Class.class, Class.class);\n\t\tResolvableType returnType = ResolvableType.forMethodReturnType(method, ClassArguments.class);\n\n\t\tResolvableType arg0 = ResolvableType.forMethodParameter(method, 0, ClassArguments.class);\n\t\tResolvableType arg1 = ResolvableType.forMethodParameter(method, 1, ClassArguments.class);\n\t\tResolvableType arg2 = ResolvableType.forMethodParameter(method, 2, ClassArguments.class);\n\n\t\tassertThat(returnType.getType().equals(arg0.as(Class.class).getGeneric(0).getType())).isTrue();\n\t\tassertThat(returnType.getType().equals(arg1.as(Class.class).getGeneric(0).getType())).isFalse();\n\t\tassertThat(returnType.getType().equals(arg2.as(Class.class).getGeneric(0).getType())).isFalse();\n\t}\n\n\t@Test\n\tvoid hashCodeAndEquals() throws Exception {\n\t\tResolvableType forClass = ResolvableType.forClass(List.class);\n\t\tResolvableType forFieldDirect = ResolvableType.forField(Fields.class.getDeclaredField(\"stringList\"));\n\t\tResolvableType forFieldViaType = ResolvableType.forType(Fields.class.getDeclaredField(\"stringList\").getGenericType(), (VariableResolver) null);\n\t\tResolvableType forFieldWithImplementation = ResolvableType.forField(Fields.class.getDeclaredField(\"stringList\"), TypedFields.class);\n\n\t\tassertThat(forClass).isEqualTo(forClass);\n\t\tassertThat(forClass.hashCode()).isEqualTo(forClass.hashCode());\n\t\tassertThat(forClass).isNotEqualTo(forFieldDirect);\n\t\tassertThat(forClass).isNotEqualTo(forFieldWithImplementation);\n\n\t\tassertThat(forFieldDirect).isEqualTo(forFieldDirect);\n\t\tassertThat(forFieldDirect).isNotEqualTo(forFieldViaType);\n\t\tassertThat(forFieldDirect).isNotEqualTo(forFieldWithImplementation);\n\t}\n\n\t@Test\n\tvoid javaDocSample() throws Exception {\n\t\tResolvableType t = ResolvableType.forField(getClass().getDeclaredField(\"myMap\"));\n\t\tassertThat(t.toString()).isEqualTo(\"java.util.HashMap<java.lang.Integer, java.util.List<java.lang.String>>\");\n\t\tassertThat(t.getType().getTypeName()).isEqualTo(\"java.util.HashMap<java.lang.Integer, java.util.List<java.lang.String>>\");\n\t\tassertThat(t.getType().toString()).isEqualTo(\"java.util.HashMap<java.lang.Integer, java.util.List<java.lang.String>>\");\n\t\tassertThat(t.getSuperType().toString()).isEqualTo(\"java.util.AbstractMap<java.lang.Integer, java.util.List<java.lang.String>>\");\n\t\tassertThat(t.asMap().toString()).isEqualTo(\"java.util.Map<java.lang.Integer, java.util.List<java.lang.String>>\");\n\t\tassertThat(t.getGeneric(0).resolve()).isEqualTo(Integer.class);\n\t\tassertThat(t.getGeneric(1).resolve()).isEqualTo(List.class);\n\t\tassertThat(t.getGeneric(1).toString()).isEqualTo(\"java.util.List<java.lang.String>\");\n\t\tassertThat(t.resolveGeneric(1, 0)).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid forClassWithGenerics() {\n\t\tResolvableType elementType = ResolvableType.forClassWithGenerics(Map.class, Integer.class, String.class);\n\t\tResolvableType listType = ResolvableType.forClassWithGenerics(List.class, elementType);\n\t\tassertThat(listType.toString()).isEqualTo(\"java.util.List<java.util.Map<java.lang.Integer, java.lang.String>>\");\n\t\tassertThat(listType.getType().getTypeName()).isEqualTo(\"java.util.List<java.util.Map<java.lang.Integer, java.lang.String>>\");\n\t\tassertThat(listType.getType().toString()).isEqualTo(\"java.util.List<java.util.Map<java.lang.Integer, java.lang.String>>\");\n\t}\n\n\t@Test\n\tvoid classWithGenericsAs() {\n\t\tResolvableType type = ResolvableType.forClassWithGenerics(MultiValueMap.class, Integer.class, String.class);\n\t\tassertThat(type.asMap().toString()).isEqualTo(\"java.util.Map<java.lang.Integer, java.util.List<java.lang.String>>\");\n\t}\n\n\t@Test\n\tvoid forClassWithMismatchedGenerics() {\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> ResolvableType.forClassWithGenerics(Map.class, Integer.class))\n\t\t\t\t.withMessageContaining(\"Mismatched number of generics specified for\")\n\t\t\t\t.withMessageContaining(\"java.util.Map<K,V>\");\n\t}\n\n\t@Test\n\tvoid forArrayComponent() throws Exception {\n\t\tResolvableType elementType = ResolvableType.forField(Fields.class.getField(\"stringList\"));\n\t\tResolvableType type = ResolvableType.forArrayComponent(elementType);\n\t\tassertThat(type.toString()).isEqualTo(\"java.util.List<java.lang.String>[]\");\n\t\tassertThat(type.resolve()).isEqualTo(List[].class);\n\t}\n\n\t@Test\n\tvoid serialize() throws Exception {\n\t\ttestSerialization(ResolvableType.forClass(List.class));\n\t\ttestSerialization(ResolvableType.forField(Fields.class.getField(\"charSequenceList\")));\n\t\ttestSerialization(ResolvableType.forMethodParameter(Methods.class.getMethod(\"charSequenceParameter\", List.class), 0));\n\t\ttestSerialization(ResolvableType.forMethodReturnType(Methods.class.getMethod(\"charSequenceReturn\")));\n\t\ttestSerialization(ResolvableType.forConstructorParameter(Constructors.class.getConstructor(List.class), 0));\n\t\ttestSerialization(ResolvableType.forField(Fields.class.getField(\"charSequenceList\")).getGeneric());\n\t\tResolvableType deserializedNone = testSerialization(ResolvableType.NONE);\n\t\tassertThat(deserializedNone).isSameAs(ResolvableType.NONE);\n\t}\n\n\t@Test\n\tvoid canResolveVoid() {\n\t\tResolvableType type = ResolvableType.forClass(void.class);\n\t\tassertThat(type.resolve()).isEqualTo(void.class);\n\t}\n\n\t@Test\n\tvoid narrow() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringList\"));\n\t\tResolvableType narrow = ResolvableType.forType(ArrayList.class, type);\n\t\tassertThat(narrow.getGeneric().resolve()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid hasResolvableGenerics() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringList\"));\n\t\tassertThat(type.hasResolvableGenerics()).isTrue();\n\t}\n\n\t@Test\n\tvoid hasResolvableGenericsWithSingleBoundedWildcard() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"wildcardType\"));\n\t\tassertThat(type.hasResolvableGenerics()).isTrue();\n\t}\n\n\t@Test\n\tvoid hasResolvableGenericsWithSingleParameterizedType() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"parameterizedType\"));\n\t\tassertThat(type.hasResolvableGenerics()).isFalse();\n\t}\n\n\t@Test\n\tvoid hasResolvableGenericsWithSingleWildcard() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"anyListElement\"));\n\t\tassertThat(type.hasResolvableGenerics()).isFalse();\n\t}\n\n\t@Test\n\tvoid hasUnresolvableGenerics() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringList\"));\n\t\tassertThat(type.hasUnresolvableGenerics()).isFalse();\n\t}\n\n\t@Test\n\tvoid hasUnresolvableGenericsBasedOnOwnGenerics() {\n\t\tResolvableType type = ResolvableType.forClass(List.class);\n\t\tassertThat(type.hasUnresolvableGenerics()).isTrue();\n\t}\n\n\t@Test\n\tvoid hasUnresolvableGenericsWhenSelfNotResolvable() {\n\t\tResolvableType type = ResolvableType.forClass(List.class).getGeneric();\n\t\tassertThat(type.hasUnresolvableGenerics()).isFalse();\n\t}\n\n\t@Test\n\tvoid hasUnresolvableGenericsWhenImplementingRawInterface() {\n\t\tResolvableType type = ResolvableType.forClass(MySimpleInterfaceTypeWithImplementsRaw.class);\n\t\tfor (ResolvableType generic : type.getGenerics()) {\n\t\t\tassertThat(generic.resolve()).isNotNull();\n\t\t}\n\t\tassertThat(type.hasUnresolvableGenerics()).isTrue();\n\t}\n\n\t@Test\n\tvoid hasUnresolvableGenericsWhenExtends() {\n\t\tResolvableType type = ResolvableType.forClass(ExtendsMySimpleInterfaceTypeWithImplementsRaw.class);\n\t\tfor (ResolvableType generic : type.getGenerics()) {\n\t\t\tassertThat(generic.resolve()).isNotNull();\n\t\t}\n\t\tassertThat(type.hasUnresolvableGenerics()).isTrue();\n\t}\n\n\t@Test\n\tvoid hasUnresolvableGenericsWhenNested() throws Exception {\n\t\tResolvableType type = ResolvableType.forMethodReturnType(ListOfListSupplier.class.getMethod(\"get\"));\n\t\tassertThat(type.hasUnresolvableGenerics()).isTrue();\n\t}\n\n\t@Test\n\tvoid hasUnresolvableGenericsWhenSelfReferring() {\n\t\tResolvableType type = ResolvableType.forInstance(new Bar());\n\t\tassertThat(type.hasUnresolvableGenerics()).isFalse();\n\t}\n\n\t@Test\n\tvoid hasUnresolvableGenericsWithEnum() {\n\t\tResolvableType type = ResolvableType.forType(SimpleEnum.class.getGenericSuperclass());\n\t\tassertThat(type.hasUnresolvableGenerics()).isFalse();\n\t}\n\n\t@Test  // gh-33932\n\tvoid recursiveType() {\n\t\tassertThat(ResolvableType.forClass(RecursiveMap.class)).isEqualTo(\n\t\t\t\tResolvableType.forClass(RecursiveMap.class));\n\n\t\tResolvableType resolvableType1 = ResolvableType.forClassWithGenerics(Map.class,\n\t\t\t\tString.class, RecursiveMap.class);\n\t\tResolvableType resolvableType2 = ResolvableType.forClassWithGenerics(Map.class,\n\t\t\t\tString.class, RecursiveMap.class);\n\t\tassertThat(resolvableType1).isEqualTo(resolvableType2);\n\t}\n\n\t@Test  // gh-33932\n\tvoid recursiveTypeWithInterface() {\n\t\tassertThat(ResolvableType.forClass(RecursiveMapWithInterface.class)).isEqualTo(\n\t\t\t\tResolvableType.forClass(RecursiveMapWithInterface.class));\n\n\t\tResolvableType resolvableType1 = ResolvableType.forClassWithGenerics(Map.class,\n\t\t\t\tString.class, RecursiveMapWithInterface.class);\n\t\tResolvableType resolvableType2 = ResolvableType.forClassWithGenerics(Map.class,\n\t\t\t\tString.class, RecursiveMapWithInterface.class);\n\t\tassertThat(resolvableType1).isEqualTo(resolvableType2);\n\t}\n\n\t@Test\n\tvoid spr11219() throws Exception {\n\t\tResolvableType type = ResolvableType.forField(BaseProvider.class.getField(\"stuff\"), BaseProvider.class);\n\t\tassertThat(type.getNested(2).isAssignableFrom(ResolvableType.forClass(BaseImplementation.class))).isTrue();\n\t\tassertThat(type.toString()).isEqualTo(\"java.util.Collection<org.springframework.core.ResolvableTypeTests$IBase<?>>\");\n\t}\n\n\t@Test\n\tvoid spr12701() {\n\t\tResolvableType resolvableType = ResolvableType.forClassWithGenerics(Callable.class, String.class);\n\t\tType type = resolvableType.getType();\n\t\tassertThat(type).isInstanceOf(ParameterizedType.class);\n\t\tassertThat(((ParameterizedType) type).getRawType()).isEqualTo(Callable.class);\n\t\tassertThat(((ParameterizedType) type).getActualTypeArguments()).hasSize(1);\n\t\tassertThat(((ParameterizedType) type).getActualTypeArguments()[0]).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid spr14648() throws Exception {\n\t\tResolvableType collectionClass = ResolvableType.forRawClass(Collection.class);\n\t\tResolvableType setClass = ResolvableType.forRawClass(Set.class);\n\t\tResolvableType fromReturnType = ResolvableType.forMethodReturnType(Methods.class.getMethod(\"wildcardSet\"));\n\t\tassertThat(collectionClass.isAssignableFrom(fromReturnType)).isTrue();\n\t\tassertThat(setClass.isAssignableFrom(fromReturnType)).isTrue();\n\t}\n\n\t@Test\n\tvoid spr16456() throws Exception {\n\t\tResolvableType genericType = ResolvableType.forField(\n\t\t\t\tUnresolvedWithGenerics.class.getDeclaredField(\"set\")).asCollection();\n\t\tResolvableType type = ResolvableType.forClassWithGenerics(ArrayList.class, genericType.getGeneric());\n\t\tassertThat(type.resolveGeneric()).isEqualTo(Integer.class);\n\t}\n\n\t@Test\n\tvoid gh22902() throws Exception {\n\t\tResolvableType ab = ResolvableType.forField(ABClient.class.getField(\"field\"));\n\t\tassertThat(ab.isAssignableFrom(Object.class)).isFalse();\n\t\tassertThat(ab.isAssignableFrom(AwithB.class)).isTrue();\n\t\tassertThat(ab.isAssignableFrom(AwithoutB.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid gh32327() throws Exception {\n\t\tResolvableType repository1 = ResolvableType.forField(Fields.class.getField(\"repository\"));\n\t\tResolvableType repository2 = ResolvableType.forMethodReturnType(Methods.class.getMethod(\"someRepository\"));\n\t\tResolvableType repository3 = ResolvableType.forMethodReturnType(Methods.class.getMethod(\"subRepository\"));\n\t\tassertThat(repository1.hasUnresolvableGenerics()).isFalse();\n\t\tassertThat(repository1.isAssignableFrom(repository2)).isFalse();\n\t\tassertThat(repository1.isAssignableFromResolvedPart(repository2)).isTrue();\n\t\tassertThat(repository1.isAssignableFrom(repository3)).isTrue();\n\t\tassertThat(repository1.isAssignableFromResolvedPart(repository3)).isTrue();\n\t\tassertThat(repository2.hasUnresolvableGenerics()).isTrue();\n\t\tassertThat(repository2.isAssignableFrom(repository1)).isTrue();\n\t\tassertThat(repository2.isAssignableFromResolvedPart(repository1)).isTrue();\n\t\tassertThat(repository3.hasUnresolvableGenerics()).isTrue();\n\t\tassertThat(repository3.isAssignableFrom(repository1)).isFalse();\n\t\tassertThat(repository3.isAssignableFromResolvedPart(repository1)).isFalse();\n\t}\n\n\t@Test\n\tvoid gh33535() throws Exception {\n\t\tResolvableType repository1 = ResolvableType.forField(Fields.class.getField(\"stringRepository\"));\n\t\tResolvableType repository2 = ResolvableType.forField(Fields.class.getField(\"arrayRepository\"));\n\t\tResolvableType repository3 = ResolvableType.forMethodReturnType(Methods.class.getMethod(\"someRepository\"));\n\t\tassertThat(repository1.hasUnresolvableGenerics()).isFalse();\n\t\tassertThat(repository1.isAssignableFrom(repository3)).isFalse();\n\t\tassertThat(repository1.isAssignableFromResolvedPart(repository3)).isTrue();\n\t\tassertThat(repository3.isAssignableFrom(repository1)).isTrue();\n\t\tassertThat(repository3.isAssignableFromResolvedPart(repository1)).isTrue();\n\t\tassertThat(repository2.hasUnresolvableGenerics()).isFalse();\n\t\tassertThat(repository2.isAssignableFrom(repository3)).isFalse();\n\t\tassertThat(repository2.isAssignableFromResolvedPart(repository3)).isTrue();\n\t\tassertThat(repository3.isAssignableFrom(repository2)).isTrue();\n\t\tassertThat(repository3.isAssignableFromResolvedPart(repository2)).isTrue();\n\t}\n\n\n\tprivate ResolvableType testSerialization(ResolvableType type) throws Exception {\n\t\tByteArrayOutputStream bos = new ByteArrayOutputStream();\n\t\tObjectOutputStream oos = new ObjectOutputStream(bos);\n\t\toos.writeObject(type);\n\t\toos.close();\n\t\tObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));\n\t\tResolvableType read = (ResolvableType) ois.readObject();\n\t\tassertThat(read).isEqualTo(type);\n\t\tassertThat(read.getType()).isEqualTo(type.getType());\n\t\tassertThat(read.resolve()).isEqualTo(type.resolve());\n\t\treturn read;\n\t}\n\n\tprivate ResolvableType forField(String field) throws NoSuchFieldException {\n\t\treturn ResolvableType.forField(Fields.class.getField(field));\n\t}\n\n\tprivate ResolvableType forTypedField(String field) throws NoSuchFieldException {\n\t\treturn ResolvableType.forField(Fields.class.getField(field), TypedFields.class);\n\t}\n\n\tprivate static ResolvableTypeAssert assertThatResolvableType(ResolvableType type) {\n\t\treturn new ResolvableTypeAssert(type);\n\t}\n\n\n\t@SuppressWarnings(\"unused\")\n\tprivate HashMap<Integer, List<String>> myMap;\n\n\n\t@SuppressWarnings(\"serial\")\n\tstatic class ExtendsList extends ArrayList<CharSequence> {\n\t}\n\n\t@SuppressWarnings(\"serial\")\n\tstatic class ExtendsMap extends HashMap<String, Integer> {\n\t}\n\n\n\tinterface SomeRepository<S extends Serializable> {\n\n\t\t<T> T someMethod(Class<T> arg0, Class<?> arg1, Class<Object> arg2);\n\t}\n\n\tinterface SubRepository<S extends Serializable> extends SomeRepository {\n\t}\n\n\n\tstatic class Fields<T> {\n\n\t\tpublic List classType;\n\n\t\tpublic T typeVariableType;\n\n\t\tpublic List<T> parameterizedType;\n\n\t\tpublic List[] arrayClassType;\n\n\t\tpublic List<String>[] genericArrayType;\n\n\t\tpublic List<String>[][][] genericMultiArrayType;\n\n\t\tpublic List<?> anyListElement;\n\n\t\tpublic List<? extends Number> wildcardType;\n\n\t\tpublic List<? super Number> wildcardSuperType = new ArrayList<Object>();\n\n\t\tpublic List<CharSequence> charSequenceList;\n\n\t\tpublic List<String> stringList;\n\n\t\tpublic List<List<String>> stringListList;\n\n\t\tpublic List<String[]> stringArrayList;\n\n\t\tpublic MultiValueMap<String, Integer> stringIntegerMultiValueMap;\n\n\t\tpublic VariableNameSwitch<Integer, String> stringIntegerMultiValueMapSwitched;\n\n\t\tpublic List<List> listOfListOfUnknown;\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tprivate List<String> privateField;\n\n\t\t@SuppressWarnings(\"unused\")\n\t\tprivate List<String> otherPrivateField;\n\n\t\tpublic Map<Map<String, Integer>, Map<Byte, Long>> nested;\n\n\t\tpublic T[] variableTypeGenericArray;\n\n\t\tpublic Integer[] integerArray;\n\n\t\tpublic int[] intArray;\n\n\t\tpublic SomeRepository<? extends Serializable> repository;\n\n\t\tpublic SomeRepository<String> stringRepository;\n\n\t\tpublic SomeRepository<String[]> arrayRepository;\n\t}\n\n\n\tstatic class TypedFields extends Fields<String> {\n\t}\n\n\n\tinterface Methods<T> {\n\n\t\tList<CharSequence> charSequenceReturn();\n\n\t\tvoid charSequenceParameter(List<CharSequence> cs);\n\n\t\t<R extends CharSequence & Serializable> R boundedTypeVariableResult();\n\n\t\tMap<String, ? extends List<? extends CharSequence>> boundedTypeVariableWildcardResult();\n\n\t\tvoid nested(Map<Map<String, Integer>, Map<Byte, Long>> p);\n\n\t\tvoid typedParameter(T p);\n\n\t\tT typedReturn();\n\n\t\tSet<?> wildcardSet();\n\n\t\tList<String> list1();\n\n\t\tList<String> list2();\n\n\t\tSomeRepository<?> someRepository();\n\n\t\tSubRepository<?> subRepository();\n\t}\n\n\n\tinterface TypedMethods extends Methods<String> {\n\t}\n\n\n\tstatic class AssignmentBase<O, C, S extends Serializable> {\n\n\t\tpublic O o;\n\n\t\tpublic C c;\n\n\t\tpublic S s;\n\n\t\tpublic List<O> listo;\n\n\t\tpublic List<C> listc;\n\n\t\tpublic List<S> lists;\n\n\t\tpublic List<?> listAnon;\n\n\t\tpublic List<? extends O> listxo;\n\n\t\tpublic List<? extends C> listxc;\n\n\t\tpublic List<? extends S> listxs;\n\n\t\tpublic List<? super O> listso;\n\n\t\tpublic List<? super C> listsc;\n\n\t\tpublic List<? super S> listss;\n\n\t\tpublic O[] oarray;\n\n\t\tpublic C[] carray;\n\n\t\tpublic S[] sarray;\n\n\t\tpublic Collection<C> collectionc;\n\n\t\tpublic Collection<? extends C> collectionxc;\n\n\t\tpublic Map<? super Integer, List<String>> complexWildcard1;\n\n\t\tpublic MultiValueMap<Number, String> complexWildcard2;\n\n\t\tpublic Collection<? extends Collection<? extends CharSequence>> complexWildcard3;\n\n\t\tpublic List<List<String>> complexWildcard4;\n\t}\n\n\n\tstatic class Assignment extends AssignmentBase<Object, CharSequence, String> {\n\t}\n\n\n\tinterface ClassArguments {\n\n\t\t<T> T typedArgumentFirst(Class<T> arg0, Class<?> arg1, Class<Object> arg2);\n\t}\n\n\n\tstatic class Constructors<T> {\n\n\t\tpublic Constructors(List<CharSequence> p) {\n\t\t}\n\n\t\tpublic Constructors(Map<T, Long> p) {\n\t\t}\n\t}\n\n\n\tstatic class TypedConstructors extends Constructors<String> {\n\n\t\tpublic TypedConstructors(List<CharSequence> p) {\n\t\t\tsuper(p);\n\t\t}\n\n\t\tpublic TypedConstructors(Map<String, Long> p) {\n\t\t\tsuper(p);\n\t\t}\n\t}\n\n\n\tpublic interface MyInterfaceType<T> {\n\t}\n\n\tpublic class MyGenericInterfaceType<T> implements MyInterfaceType<T>, ResolvableTypeProvider {\n\n\t\tprivate final Class<T> type;\n\n\t\tpublic MyGenericInterfaceType(Class<T> type) {\n\t\t\tthis.type = type;\n\t\t}\n\n\t\t@Override\n\t\tpublic ResolvableType getResolvableType() {\n\t\t\tif (this.type == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn ResolvableType.forClassWithGenerics(getClass(), this.type);\n\t\t}\n\t}\n\n\tpublic class MySimpleInterfaceType implements MyInterfaceType<String> {\n\t}\n\n\tpublic abstract class MySimpleInterfaceTypeWithImplementsRaw implements MyInterfaceType<String>, List {\n\t}\n\n\tpublic abstract class ExtendsMySimpleInterfaceTypeWithImplementsRaw extends MySimpleInterfaceTypeWithImplementsRaw {\n\t}\n\n\tpublic class MyCollectionInterfaceType implements MyInterfaceType<Collection<String>> {\n\t}\n\n\n\tpublic abstract class MySuperclassType<T> {\n\t}\n\n\tpublic class MySimpleSuperclassType extends MySuperclassType<String> {\n\t}\n\n\tpublic class MyCollectionSuperclassType extends MySuperclassType<Collection<String>> {\n\t}\n\n\n\tpublic interface Consumer<T> {\n\t}\n\n\tprivate static class SubConsumer<N extends Number> implements Consumer<N> {\n\t}\n\n\tpublic class Wildcard<T extends CharSequence> {\n\t}\n\n\tpublic class WildcardFixed extends Wildcard<String> {\n\t}\n\n\tpublic class WildcardConsumer<T extends CharSequence & Serializable> implements Consumer<Wildcard<T>> {\n\t}\n\n\tpublic class DoubleWildcard<T extends CharSequence & Serializable> {\n\t}\n\n\tpublic class DoubleWildcardFixed extends DoubleWildcard<String> {\n\t}\n\n\tpublic class DoubleWildcardConsumer<T extends CharSequence & Serializable> implements Consumer<DoubleWildcard<T>> {\n\t}\n\n\n\n\tinterface VariableNameSwitch<V, K> extends MultiValueMap<K, V> {\n\t}\n\n\n\tinterface ListOfGenericArray extends List<List<String>[]> {\n\t}\n\n\n\tinterface ListOfListSupplier<T> {\n\n\t\tList<List<T>> get();\n\t}\n\n\n\tclass Foo<T extends Foo<T>> {\n\t}\n\n\tclass Bar extends Foo<Bar> {\n\t}\n\n\n\tenum SimpleEnum { VALUE }\n\n\n\tstatic class EnclosedInParameterizedType<T> {\n\n\t\tstatic class InnerRaw {\n\t\t}\n\n\t\tclass InnerTyped<Y> {\n\n\t\t\tpublic T field;\n\t\t}\n\t}\n\n\n\tstatic class TypedEnclosedInParameterizedType extends EnclosedInParameterizedType<Integer> {\n\n\t\tclass TypedInnerTyped extends InnerTyped<Long> {\n\t\t}\n\t}\n\n\n\tpublic interface IProvider<P> {\n\t}\n\n\tpublic interface IBase<BT extends IBase<BT>> {\n\t}\n\n\tpublic abstract class AbstractBase<BT extends IBase<BT>> implements IBase<BT> {\n\t}\n\n\tpublic class BaseImplementation extends AbstractBase<BaseImplementation> {\n\t}\n\n\tpublic class BaseProvider<BT extends IBase<BT>> implements IProvider<IBase<BT>> {\n\n\t\tpublic Collection<IBase<BT>> stuff;\n\t}\n\n\n\tpublic abstract class UnresolvedWithGenerics {\n\n\t\tSet<Integer> set;\n\t}\n\n\n\tinterface A {\n\n\t\tvoid doA();\n\t}\n\n\tinterface B {\n\n\t\tvoid doB();\n\t}\n\n\tstatic class ABClient<T extends A & B> {\n\n\t\tpublic T field;\n\t}\n\n\tstatic class AwithB implements A, B {\n\n\t\t@Override\n\t\tpublic void doA() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void doB() {\n\t\t}\n\t}\n\n\tstatic class AwithoutB implements A {\n\n\t\t@Override\n\t\tpublic void doA() {\n\t\t}\n\t}\n\n\n\t@SuppressWarnings(\"serial\")\n\tstatic class RecursiveMap extends HashMap<String, RecursiveMap> {\n\t}\n\n\t@SuppressWarnings(\"serial\")\n\tstatic class RecursiveMapWithInterface extends HashMap<String, RecursiveMapWithInterface>\n\t\t\timplements Map<String, RecursiveMapWithInterface> {\n\t}\n\n\n\tprivate static class ResolvableTypeAssert extends AbstractAssert<ResolvableTypeAssert, ResolvableType>{\n\n\t\tpublic ResolvableTypeAssert(ResolvableType actual) {\n\t\t\tsuper(actual, ResolvableTypeAssert.class);\n\t\t}\n\n\t\tpublic ResolvableTypeAssert isAssignableFrom(ResolvableType... types) {\n\t\t\tfor (ResolvableType type : types) {\n\t\t\t\tif (!actual.isAssignableFrom(type)) {\n\t\t\t\t\tthrow new AssertionError(\"Expecting \" + describe(actual) + \" to be assignable from \" + describe(type));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ResolvableTypeAssert isNotAssignableFrom(ResolvableType... types) {\n\t\t\tfor (ResolvableType type : types) {\n\t\t\t\tif (actual.isAssignableFrom(type)) {\n\t\t\t\t\tthrow new AssertionError(\"Expecting \" + describe(actual) + \" to not be assignable from \" + describe(type));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tprivate String describe(ResolvableType type) {\n\t\t\tif (type == ResolvableType.NONE) {\n\t\t\t\treturn \"NONE\";\n\t\t\t}\n\t\t\tif (type.getType().getClass().equals(Class.class)) {\n\t\t\t\treturn type.toString();\n\t\t\t}\n\t\t\treturn type.getType() + \":\" + type;\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.TypedFields",
    "headType": "class",
    "relation": "extend",
    "tail": "Fields",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.Methods",
    "tailType": "class"
  }
]