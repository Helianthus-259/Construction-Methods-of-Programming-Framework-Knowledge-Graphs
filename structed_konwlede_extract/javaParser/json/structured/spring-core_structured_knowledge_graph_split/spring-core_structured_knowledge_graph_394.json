[
  {
    "head": "org.springframework.util.xml.PartialAttributesAdapter",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util.xml;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\n\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMResult;\nimport javax.xml.transform.sax.SAXSource;\n\nimport org.jspecify.annotations.Nullable;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\nimport org.w3c.dom.Node;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.ContentHandler;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.Locator;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.ext.LexicalHandler;\nimport org.xml.sax.helpers.AttributesImpl;\n\nimport org.springframework.core.io.ClassPathResource;\nimport org.springframework.core.io.Resource;\nimport org.springframework.tests.MockitoUtils;\nimport org.springframework.tests.MockitoUtils.InvocationArgumentsAdapter;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.anyInt;\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.mockito.BDDMockito.willAnswer;\nimport static org.mockito.Mockito.mock;\n\n/**\n * @author Arjen Poutsma\n */\nabstract class AbstractStaxXMLReaderTests {\n\n\tprotected static XMLInputFactory inputFactory;\n\n\tprivate XMLReader standardReader;\n\n\tprivate ContentHandler standardContentHandler;\n\n\n\t@BeforeEach\n\tvoid setUp() throws Exception {\n\t\tinputFactory = XMLInputFactory.newInstance();\n\t\tSAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\n\t\tsaxParserFactory.setNamespaceAware(true);\n\t\tSAXParser saxParser = saxParserFactory.newSAXParser();\n\t\tstandardReader = saxParser.getXMLReader();\n\t\tstandardContentHandler = mockContentHandler();\n\t\tstandardReader.setContentHandler(standardContentHandler);\n\t}\n\n\n\t@Test\n\tvoid contentHandlerNamespacesNoPrefixes() throws Exception {\n\t\tstandardReader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n\t\tstandardReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", false);\n\t\tstandardReader.parse(new InputSource(createTestInputStream()));\n\n\t\tAbstractStaxXMLReader staxXmlReader = createStaxXmlReader(createTestInputStream());\n\t\tContentHandler contentHandler = mockContentHandler();\n\t\tstaxXmlReader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n\t\tstaxXmlReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", false);\n\t\tstaxXmlReader.setContentHandler(contentHandler);\n\t\tstaxXmlReader.parse(new InputSource());\n\n\t\tverifyIdenticalInvocations(standardContentHandler, contentHandler);\n\t}\n\n\t@Test\n\tvoid contentHandlerNamespacesPrefixes() throws Exception {\n\t\tstandardReader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n\t\tstandardReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", true);\n\t\tstandardReader.parse(new InputSource(createTestInputStream()));\n\n\t\tAbstractStaxXMLReader staxXmlReader = createStaxXmlReader(createTestInputStream());\n\t\tContentHandler contentHandler = mockContentHandler();\n\t\tstaxXmlReader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n\t\tstaxXmlReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", true);\n\t\tstaxXmlReader.setContentHandler(contentHandler);\n\t\tstaxXmlReader.parse(new InputSource());\n\n\t\tverifyIdenticalInvocations(standardContentHandler, contentHandler);\n\t}\n\n\t@Test\n\tvoid contentHandlerNoNamespacesPrefixes() throws Exception {\n\t\tstandardReader.setFeature(\"http://xml.org/sax/features/namespaces\", false);\n\t\tstandardReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", true);\n\t\tstandardReader.parse(new InputSource(createTestInputStream()));\n\n\t\tAbstractStaxXMLReader staxXmlReader = createStaxXmlReader(createTestInputStream());\n\t\tContentHandler contentHandler = mockContentHandler();\n\t\tstaxXmlReader.setFeature(\"http://xml.org/sax/features/namespaces\", false);\n\t\tstaxXmlReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", true);\n\t\tstaxXmlReader.setContentHandler(contentHandler);\n\t\tstaxXmlReader.parse(new InputSource());\n\n\t\tverifyIdenticalInvocations(standardContentHandler, contentHandler);\n\t}\n\n\t@Test\n\tvoid whitespace() throws Exception {\n\t\tString xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><test><node1> </node1><node2> Some text </node2></test>\";\n\n\t\tTransformer transformer = TransformerFactory.newInstance().newTransformer();\n\n\t\tAbstractStaxXMLReader staxXmlReader = createStaxXmlReader(\n\t\t\t\tnew ByteArrayInputStream(xml.getBytes(StandardCharsets.UTF_8)));\n\n\t\tSAXSource source = new SAXSource(staxXmlReader, new InputSource());\n\t\tDOMResult result = new DOMResult();\n\n\t\ttransformer.transform(source, result);\n\n\t\tNode node1 = result.getNode().getFirstChild().getFirstChild();\n\t\tassertThat(node1.getTextContent()).isEqualTo(\" \");\n\t\tassertThat(node1.getNextSibling().getTextContent()).isEqualTo(\" Some text \");\n\t}\n\n\t@Test\n\tvoid lexicalHandler() throws Exception {\n\t\tResource testLexicalHandlerXml = new ClassPathResource(\"testLexicalHandler.xml\", getClass());\n\n\t\tLexicalHandler expectedLexicalHandler = mockLexicalHandler();\n\t\tstandardReader.setContentHandler(null);\n\t\tstandardReader.setProperty(\"http://xml.org/sax/properties/lexical-handler\", expectedLexicalHandler);\n\t\tstandardReader.parse(new InputSource(testLexicalHandlerXml.getInputStream()));\n\t\tinputFactory.setProperty(\"javax.xml.stream.isCoalescing\", Boolean.FALSE);\n\t\tinputFactory.setProperty(\"http://java.sun.com/xml/stream/properties/report-cdata-event\", Boolean.TRUE);\n\t\tinputFactory.setProperty(\"javax.xml.stream.isReplacingEntityReferences\", Boolean.FALSE);\n\t\tinputFactory.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", Boolean.FALSE);\n\n\t\tLexicalHandler actualLexicalHandler = mockLexicalHandler();\n\t\twillAnswer(invocation -> invocation.getArguments()[0] = \"element\").\n\t\t\t\tgiven(actualLexicalHandler).startDTD(anyString(), anyString(), anyString());\n\t\tAbstractStaxXMLReader staxXmlReader = createStaxXmlReader(testLexicalHandlerXml.getInputStream());\n\t\tstaxXmlReader.setProperty(\"http://xml.org/sax/properties/lexical-handler\", actualLexicalHandler);\n\t\tstaxXmlReader.parse(new InputSource());\n\n\t\t// TODO: broken comparison since Mockito 2.2 upgrade\n\t\t// verifyIdenticalInvocations(expectedLexicalHandler, actualLexicalHandler);\n\t}\n\n\n\tprivate LexicalHandler mockLexicalHandler() throws Exception {\n\t\tLexicalHandler lexicalHandler = mock();\n\t\twillAnswer(new CopyCharsAnswer()).given(lexicalHandler).comment(any(char[].class), anyInt(), anyInt());\n\t\treturn lexicalHandler;\n\t}\n\n\tprivate InputStream createTestInputStream() {\n\t\treturn getClass().getResourceAsStream(\"testContentHandler.xml\");\n\t}\n\n\tprotected final ContentHandler mockContentHandler() throws Exception {\n\t\tContentHandler contentHandler = mock();\n\t\twillAnswer(new CopyCharsAnswer()).given(contentHandler).characters(any(char[].class), anyInt(), anyInt());\n\t\twillAnswer(new CopyCharsAnswer()).given(contentHandler).ignorableWhitespace(any(char[].class), anyInt(), anyInt());\n\t\twillAnswer(invocation -> {\n\t\t\tinvocation.getArguments()[3] = new AttributesImpl((Attributes) invocation.getArguments()[3]);\n\t\t\treturn null;\n\t\t}).given(contentHandler).startElement(anyString(), anyString(), anyString(), any(Attributes.class));\n\t\treturn contentHandler;\n\t}\n\n\tprotected <T> void verifyIdenticalInvocations(T expected, T actual) {\n\t\tMockitoUtils.verifySameInvocations(expected, actual,\n\t\t\t\tnew SkipLocatorArgumentsAdapter(), new CharArrayToStringAdapter(), new PartialAttributesAdapter());\n\t}\n\n\tprotected abstract AbstractStaxXMLReader createStaxXmlReader(InputStream inputStream) throws XMLStreamException;\n\n\n\tprivate static class SkipLocatorArgumentsAdapter implements InvocationArgumentsAdapter {\n\n\t\t@Override\n\t\tpublic Object[] adaptArguments(Object[] arguments) {\n\t\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\t\tif (arguments[i] instanceof Locator) {\n\t\t\t\t\targuments[i] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn arguments;\n\t\t}\n\t}\n\n\n\tprivate static class CharArrayToStringAdapter implements InvocationArgumentsAdapter {\n\n\t\t@Override\n\t\tpublic Object[] adaptArguments(Object[] arguments) {\n\t\t\tif (arguments.length == 3 && arguments[0] instanceof char[]\n\t\t\t\t\t&& arguments[1] instanceof Integer && arguments[2] instanceof Integer) {\n\t\t\t\treturn new Object[] {new String((char[]) arguments[0], (Integer) arguments[1], (Integer) arguments[2])};\n\t\t\t}\n\t\t\treturn arguments;\n\t\t}\n\t}\n\n\n\tprivate static class PartialAttributesAdapter implements InvocationArgumentsAdapter {\n\n\t\t@Override\n\t\tpublic Object[] adaptArguments(Object[] arguments) {\n\t\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\t\tif (arguments[i] instanceof Attributes) {\n\t\t\t\t\targuments[i] = new PartialAttributes((Attributes) arguments[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn arguments;\n\t\t}\n\t}\n\n\n\tprivate static class CopyCharsAnswer implements Answer<Object> {\n\n\t\t@Override\n\t\tpublic Object answer(InvocationOnMock invocation) {\n\t\t\tchar[] chars = (char[]) invocation.getArguments()[0];\n\t\t\tchar[] copy = new char[chars.length];\n\t\t\tSystem.arraycopy(chars, 0, copy, 0, chars.length);\n\t\t\tinvocation.getArguments()[0] = copy;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\tprivate static class PartialAttributes {\n\n\t\tprivate final Attributes attributes;\n\n\t\tpublic PartialAttributes(Attributes attributes) {\n\t\t\tthis.attributes = attributes;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(@Nullable Object obj) {\n\t\t\tAttributes other = ((PartialAttributes) obj).attributes;\n\t\t\tif (this.attributes.getLength() != other.getLength()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (int i = 0; i < other.getLength(); i++) {\n\t\t\t\tboolean found = false;\n\t\t\t\tfor (int j = 0; j < attributes.getLength(); j++) {\n\t\t\t\t\tif (other.getURI(i).equals(attributes.getURI(j))\n\t\t\t\t\t\t\t&& other.getQName(i).equals(attributes.getQName(j))\n\t\t\t\t\t\t\t&& other.getType(i).equals(attributes.getType(j))\n\t\t\t\t\t\t\t&& other.getValue(i).equals(attributes.getValue(j))) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.xml.PartialAttributesAdapter#adaptArguments(Object[])",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic Object[] adaptArguments(Object[] arguments) {\r\n    for (int i = 0; i < arguments.length; i++) {\r\n        if (arguments[i] instanceof Attributes) {\r\n            arguments[i] = new PartialAttributes((Attributes) arguments[i]);\r\n        }\r\n    }\r\n    return arguments;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.xml.PartialAttributesAdapter",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.xml.PartialAttributesAdapter#adaptArguments(Object[])",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.xml.PartialAttributesAdapter#adaptArguments(Object[])",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.xml",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.xml.CopyCharsAnswer",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.xml.CopyCharsAnswer",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util.xml;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\n\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMResult;\nimport javax.xml.transform.sax.SAXSource;\n\nimport org.jspecify.annotations.Nullable;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\nimport org.w3c.dom.Node;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.ContentHandler;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.Locator;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.ext.LexicalHandler;\nimport org.xml.sax.helpers.AttributesImpl;\n\nimport org.springframework.core.io.ClassPathResource;\nimport org.springframework.core.io.Resource;\nimport org.springframework.tests.MockitoUtils;\nimport org.springframework.tests.MockitoUtils.InvocationArgumentsAdapter;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.anyInt;\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.mockito.BDDMockito.willAnswer;\nimport static org.mockito.Mockito.mock;\n\n/**\n * @author Arjen Poutsma\n */\nabstract class AbstractStaxXMLReaderTests {\n\n\tprotected static XMLInputFactory inputFactory;\n\n\tprivate XMLReader standardReader;\n\n\tprivate ContentHandler standardContentHandler;\n\n\n\t@BeforeEach\n\tvoid setUp() throws Exception {\n\t\tinputFactory = XMLInputFactory.newInstance();\n\t\tSAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\n\t\tsaxParserFactory.setNamespaceAware(true);\n\t\tSAXParser saxParser = saxParserFactory.newSAXParser();\n\t\tstandardReader = saxParser.getXMLReader();\n\t\tstandardContentHandler = mockContentHandler();\n\t\tstandardReader.setContentHandler(standardContentHandler);\n\t}\n\n\n\t@Test\n\tvoid contentHandlerNamespacesNoPrefixes() throws Exception {\n\t\tstandardReader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n\t\tstandardReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", false);\n\t\tstandardReader.parse(new InputSource(createTestInputStream()));\n\n\t\tAbstractStaxXMLReader staxXmlReader = createStaxXmlReader(createTestInputStream());\n\t\tContentHandler contentHandler = mockContentHandler();\n\t\tstaxXmlReader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n\t\tstaxXmlReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", false);\n\t\tstaxXmlReader.setContentHandler(contentHandler);\n\t\tstaxXmlReader.parse(new InputSource());\n\n\t\tverifyIdenticalInvocations(standardContentHandler, contentHandler);\n\t}\n\n\t@Test\n\tvoid contentHandlerNamespacesPrefixes() throws Exception {\n\t\tstandardReader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n\t\tstandardReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", true);\n\t\tstandardReader.parse(new InputSource(createTestInputStream()));\n\n\t\tAbstractStaxXMLReader staxXmlReader = createStaxXmlReader(createTestInputStream());\n\t\tContentHandler contentHandler = mockContentHandler();\n\t\tstaxXmlReader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n\t\tstaxXmlReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", true);\n\t\tstaxXmlReader.setContentHandler(contentHandler);\n\t\tstaxXmlReader.parse(new InputSource());\n\n\t\tverifyIdenticalInvocations(standardContentHandler, contentHandler);\n\t}\n\n\t@Test\n\tvoid contentHandlerNoNamespacesPrefixes() throws Exception {\n\t\tstandardReader.setFeature(\"http://xml.org/sax/features/namespaces\", false);\n\t\tstandardReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", true);\n\t\tstandardReader.parse(new InputSource(createTestInputStream()));\n\n\t\tAbstractStaxXMLReader staxXmlReader = createStaxXmlReader(createTestInputStream());\n\t\tContentHandler contentHandler = mockContentHandler();\n\t\tstaxXmlReader.setFeature(\"http://xml.org/sax/features/namespaces\", false);\n\t\tstaxXmlReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", true);\n\t\tstaxXmlReader.setContentHandler(contentHandler);\n\t\tstaxXmlReader.parse(new InputSource());\n\n\t\tverifyIdenticalInvocations(standardContentHandler, contentHandler);\n\t}\n\n\t@Test\n\tvoid whitespace() throws Exception {\n\t\tString xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><test><node1> </node1><node2> Some text </node2></test>\";\n\n\t\tTransformer transformer = TransformerFactory.newInstance().newTransformer();\n\n\t\tAbstractStaxXMLReader staxXmlReader = createStaxXmlReader(\n\t\t\t\tnew ByteArrayInputStream(xml.getBytes(StandardCharsets.UTF_8)));\n\n\t\tSAXSource source = new SAXSource(staxXmlReader, new InputSource());\n\t\tDOMResult result = new DOMResult();\n\n\t\ttransformer.transform(source, result);\n\n\t\tNode node1 = result.getNode().getFirstChild().getFirstChild();\n\t\tassertThat(node1.getTextContent()).isEqualTo(\" \");\n\t\tassertThat(node1.getNextSibling().getTextContent()).isEqualTo(\" Some text \");\n\t}\n\n\t@Test\n\tvoid lexicalHandler() throws Exception {\n\t\tResource testLexicalHandlerXml = new ClassPathResource(\"testLexicalHandler.xml\", getClass());\n\n\t\tLexicalHandler expectedLexicalHandler = mockLexicalHandler();\n\t\tstandardReader.setContentHandler(null);\n\t\tstandardReader.setProperty(\"http://xml.org/sax/properties/lexical-handler\", expectedLexicalHandler);\n\t\tstandardReader.parse(new InputSource(testLexicalHandlerXml.getInputStream()));\n\t\tinputFactory.setProperty(\"javax.xml.stream.isCoalescing\", Boolean.FALSE);\n\t\tinputFactory.setProperty(\"http://java.sun.com/xml/stream/properties/report-cdata-event\", Boolean.TRUE);\n\t\tinputFactory.setProperty(\"javax.xml.stream.isReplacingEntityReferences\", Boolean.FALSE);\n\t\tinputFactory.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", Boolean.FALSE);\n\n\t\tLexicalHandler actualLexicalHandler = mockLexicalHandler();\n\t\twillAnswer(invocation -> invocation.getArguments()[0] = \"element\").\n\t\t\t\tgiven(actualLexicalHandler).startDTD(anyString(), anyString(), anyString());\n\t\tAbstractStaxXMLReader staxXmlReader = createStaxXmlReader(testLexicalHandlerXml.getInputStream());\n\t\tstaxXmlReader.setProperty(\"http://xml.org/sax/properties/lexical-handler\", actualLexicalHandler);\n\t\tstaxXmlReader.parse(new InputSource());\n\n\t\t// TODO: broken comparison since Mockito 2.2 upgrade\n\t\t// verifyIdenticalInvocations(expectedLexicalHandler, actualLexicalHandler);\n\t}\n\n\n\tprivate LexicalHandler mockLexicalHandler() throws Exception {\n\t\tLexicalHandler lexicalHandler = mock();\n\t\twillAnswer(new CopyCharsAnswer()).given(lexicalHandler).comment(any(char[].class), anyInt(), anyInt());\n\t\treturn lexicalHandler;\n\t}\n\n\tprivate InputStream createTestInputStream() {\n\t\treturn getClass().getResourceAsStream(\"testContentHandler.xml\");\n\t}\n\n\tprotected final ContentHandler mockContentHandler() throws Exception {\n\t\tContentHandler contentHandler = mock();\n\t\twillAnswer(new CopyCharsAnswer()).given(contentHandler).characters(any(char[].class), anyInt(), anyInt());\n\t\twillAnswer(new CopyCharsAnswer()).given(contentHandler).ignorableWhitespace(any(char[].class), anyInt(), anyInt());\n\t\twillAnswer(invocation -> {\n\t\t\tinvocation.getArguments()[3] = new AttributesImpl((Attributes) invocation.getArguments()[3]);\n\t\t\treturn null;\n\t\t}).given(contentHandler).startElement(anyString(), anyString(), anyString(), any(Attributes.class));\n\t\treturn contentHandler;\n\t}\n\n\tprotected <T> void verifyIdenticalInvocations(T expected, T actual) {\n\t\tMockitoUtils.verifySameInvocations(expected, actual,\n\t\t\t\tnew SkipLocatorArgumentsAdapter(), new CharArrayToStringAdapter(), new PartialAttributesAdapter());\n\t}\n\n\tprotected abstract AbstractStaxXMLReader createStaxXmlReader(InputStream inputStream) throws XMLStreamException;\n\n\n\tprivate static class SkipLocatorArgumentsAdapter implements InvocationArgumentsAdapter {\n\n\t\t@Override\n\t\tpublic Object[] adaptArguments(Object[] arguments) {\n\t\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\t\tif (arguments[i] instanceof Locator) {\n\t\t\t\t\targuments[i] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn arguments;\n\t\t}\n\t}\n\n\n\tprivate static class CharArrayToStringAdapter implements InvocationArgumentsAdapter {\n\n\t\t@Override\n\t\tpublic Object[] adaptArguments(Object[] arguments) {\n\t\t\tif (arguments.length == 3 && arguments[0] instanceof char[]\n\t\t\t\t\t&& arguments[1] instanceof Integer && arguments[2] instanceof Integer) {\n\t\t\t\treturn new Object[] {new String((char[]) arguments[0], (Integer) arguments[1], (Integer) arguments[2])};\n\t\t\t}\n\t\t\treturn arguments;\n\t\t}\n\t}\n\n\n\tprivate static class PartialAttributesAdapter implements InvocationArgumentsAdapter {\n\n\t\t@Override\n\t\tpublic Object[] adaptArguments(Object[] arguments) {\n\t\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\t\tif (arguments[i] instanceof Attributes) {\n\t\t\t\t\targuments[i] = new PartialAttributes((Attributes) arguments[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn arguments;\n\t\t}\n\t}\n\n\n\tprivate static class CopyCharsAnswer implements Answer<Object> {\n\n\t\t@Override\n\t\tpublic Object answer(InvocationOnMock invocation) {\n\t\t\tchar[] chars = (char[]) invocation.getArguments()[0];\n\t\t\tchar[] copy = new char[chars.length];\n\t\t\tSystem.arraycopy(chars, 0, copy, 0, chars.length);\n\t\t\tinvocation.getArguments()[0] = copy;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\tprivate static class PartialAttributes {\n\n\t\tprivate final Attributes attributes;\n\n\t\tpublic PartialAttributes(Attributes attributes) {\n\t\t\tthis.attributes = attributes;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(@Nullable Object obj) {\n\t\t\tAttributes other = ((PartialAttributes) obj).attributes;\n\t\t\tif (this.attributes.getLength() != other.getLength()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (int i = 0; i < other.getLength(); i++) {\n\t\t\t\tboolean found = false;\n\t\t\t\tfor (int j = 0; j < attributes.getLength(); j++) {\n\t\t\t\t\tif (other.getURI(i).equals(attributes.getURI(j))\n\t\t\t\t\t\t\t&& other.getQName(i).equals(attributes.getQName(j))\n\t\t\t\t\t\t\t&& other.getType(i).equals(attributes.getType(j))\n\t\t\t\t\t\t\t&& other.getValue(i).equals(attributes.getValue(j))) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.xml.CopyCharsAnswer#answer(InvocationOnMock)",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic Object answer(InvocationOnMock invocation) {\r\n    char[] chars = (char[]) invocation.getArguments()[0];\r\n    char[] copy = new char[chars.length];\r\n    System.arraycopy(chars, 0, copy, 0, chars.length);\r\n    invocation.getArguments()[0] = copy;\r\n    return null;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.xml.CopyCharsAnswer",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.xml.CopyCharsAnswer#answer(InvocationOnMock)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.xml.CopyCharsAnswer#answer(InvocationOnMock)",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.xml",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.xml.PartialAttributes",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.xml.PartialAttributes",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util.xml;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\n\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMResult;\nimport javax.xml.transform.sax.SAXSource;\n\nimport org.jspecify.annotations.Nullable;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\nimport org.w3c.dom.Node;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.ContentHandler;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.Locator;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.ext.LexicalHandler;\nimport org.xml.sax.helpers.AttributesImpl;\n\nimport org.springframework.core.io.ClassPathResource;\nimport org.springframework.core.io.Resource;\nimport org.springframework.tests.MockitoUtils;\nimport org.springframework.tests.MockitoUtils.InvocationArgumentsAdapter;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.anyInt;\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.mockito.BDDMockito.willAnswer;\nimport static org.mockito.Mockito.mock;\n\n/**\n * @author Arjen Poutsma\n */\nabstract class AbstractStaxXMLReaderTests {\n\n\tprotected static XMLInputFactory inputFactory;\n\n\tprivate XMLReader standardReader;\n\n\tprivate ContentHandler standardContentHandler;\n\n\n\t@BeforeEach\n\tvoid setUp() throws Exception {\n\t\tinputFactory = XMLInputFactory.newInstance();\n\t\tSAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\n\t\tsaxParserFactory.setNamespaceAware(true);\n\t\tSAXParser saxParser = saxParserFactory.newSAXParser();\n\t\tstandardReader = saxParser.getXMLReader();\n\t\tstandardContentHandler = mockContentHandler();\n\t\tstandardReader.setContentHandler(standardContentHandler);\n\t}\n\n\n\t@Test\n\tvoid contentHandlerNamespacesNoPrefixes() throws Exception {\n\t\tstandardReader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n\t\tstandardReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", false);\n\t\tstandardReader.parse(new InputSource(createTestInputStream()));\n\n\t\tAbstractStaxXMLReader staxXmlReader = createStaxXmlReader(createTestInputStream());\n\t\tContentHandler contentHandler = mockContentHandler();\n\t\tstaxXmlReader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n\t\tstaxXmlReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", false);\n\t\tstaxXmlReader.setContentHandler(contentHandler);\n\t\tstaxXmlReader.parse(new InputSource());\n\n\t\tverifyIdenticalInvocations(standardContentHandler, contentHandler);\n\t}\n\n\t@Test\n\tvoid contentHandlerNamespacesPrefixes() throws Exception {\n\t\tstandardReader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n\t\tstandardReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", true);\n\t\tstandardReader.parse(new InputSource(createTestInputStream()));\n\n\t\tAbstractStaxXMLReader staxXmlReader = createStaxXmlReader(createTestInputStream());\n\t\tContentHandler contentHandler = mockContentHandler();\n\t\tstaxXmlReader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n\t\tstaxXmlReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", true);\n\t\tstaxXmlReader.setContentHandler(contentHandler);\n\t\tstaxXmlReader.parse(new InputSource());\n\n\t\tverifyIdenticalInvocations(standardContentHandler, contentHandler);\n\t}\n\n\t@Test\n\tvoid contentHandlerNoNamespacesPrefixes() throws Exception {\n\t\tstandardReader.setFeature(\"http://xml.org/sax/features/namespaces\", false);\n\t\tstandardReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", true);\n\t\tstandardReader.parse(new InputSource(createTestInputStream()));\n\n\t\tAbstractStaxXMLReader staxXmlReader = createStaxXmlReader(createTestInputStream());\n\t\tContentHandler contentHandler = mockContentHandler();\n\t\tstaxXmlReader.setFeature(\"http://xml.org/sax/features/namespaces\", false);\n\t\tstaxXmlReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", true);\n\t\tstaxXmlReader.setContentHandler(contentHandler);\n\t\tstaxXmlReader.parse(new InputSource());\n\n\t\tverifyIdenticalInvocations(standardContentHandler, contentHandler);\n\t}\n\n\t@Test\n\tvoid whitespace() throws Exception {\n\t\tString xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><test><node1> </node1><node2> Some text </node2></test>\";\n\n\t\tTransformer transformer = TransformerFactory.newInstance().newTransformer();\n\n\t\tAbstractStaxXMLReader staxXmlReader = createStaxXmlReader(\n\t\t\t\tnew ByteArrayInputStream(xml.getBytes(StandardCharsets.UTF_8)));\n\n\t\tSAXSource source = new SAXSource(staxXmlReader, new InputSource());\n\t\tDOMResult result = new DOMResult();\n\n\t\ttransformer.transform(source, result);\n\n\t\tNode node1 = result.getNode().getFirstChild().getFirstChild();\n\t\tassertThat(node1.getTextContent()).isEqualTo(\" \");\n\t\tassertThat(node1.getNextSibling().getTextContent()).isEqualTo(\" Some text \");\n\t}\n\n\t@Test\n\tvoid lexicalHandler() throws Exception {\n\t\tResource testLexicalHandlerXml = new ClassPathResource(\"testLexicalHandler.xml\", getClass());\n\n\t\tLexicalHandler expectedLexicalHandler = mockLexicalHandler();\n\t\tstandardReader.setContentHandler(null);\n\t\tstandardReader.setProperty(\"http://xml.org/sax/properties/lexical-handler\", expectedLexicalHandler);\n\t\tstandardReader.parse(new InputSource(testLexicalHandlerXml.getInputStream()));\n\t\tinputFactory.setProperty(\"javax.xml.stream.isCoalescing\", Boolean.FALSE);\n\t\tinputFactory.setProperty(\"http://java.sun.com/xml/stream/properties/report-cdata-event\", Boolean.TRUE);\n\t\tinputFactory.setProperty(\"javax.xml.stream.isReplacingEntityReferences\", Boolean.FALSE);\n\t\tinputFactory.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", Boolean.FALSE);\n\n\t\tLexicalHandler actualLexicalHandler = mockLexicalHandler();\n\t\twillAnswer(invocation -> invocation.getArguments()[0] = \"element\").\n\t\t\t\tgiven(actualLexicalHandler).startDTD(anyString(), anyString(), anyString());\n\t\tAbstractStaxXMLReader staxXmlReader = createStaxXmlReader(testLexicalHandlerXml.getInputStream());\n\t\tstaxXmlReader.setProperty(\"http://xml.org/sax/properties/lexical-handler\", actualLexicalHandler);\n\t\tstaxXmlReader.parse(new InputSource());\n\n\t\t// TODO: broken comparison since Mockito 2.2 upgrade\n\t\t// verifyIdenticalInvocations(expectedLexicalHandler, actualLexicalHandler);\n\t}\n\n\n\tprivate LexicalHandler mockLexicalHandler() throws Exception {\n\t\tLexicalHandler lexicalHandler = mock();\n\t\twillAnswer(new CopyCharsAnswer()).given(lexicalHandler).comment(any(char[].class), anyInt(), anyInt());\n\t\treturn lexicalHandler;\n\t}\n\n\tprivate InputStream createTestInputStream() {\n\t\treturn getClass().getResourceAsStream(\"testContentHandler.xml\");\n\t}\n\n\tprotected final ContentHandler mockContentHandler() throws Exception {\n\t\tContentHandler contentHandler = mock();\n\t\twillAnswer(new CopyCharsAnswer()).given(contentHandler).characters(any(char[].class), anyInt(), anyInt());\n\t\twillAnswer(new CopyCharsAnswer()).given(contentHandler).ignorableWhitespace(any(char[].class), anyInt(), anyInt());\n\t\twillAnswer(invocation -> {\n\t\t\tinvocation.getArguments()[3] = new AttributesImpl((Attributes) invocation.getArguments()[3]);\n\t\t\treturn null;\n\t\t}).given(contentHandler).startElement(anyString(), anyString(), anyString(), any(Attributes.class));\n\t\treturn contentHandler;\n\t}\n\n\tprotected <T> void verifyIdenticalInvocations(T expected, T actual) {\n\t\tMockitoUtils.verifySameInvocations(expected, actual,\n\t\t\t\tnew SkipLocatorArgumentsAdapter(), new CharArrayToStringAdapter(), new PartialAttributesAdapter());\n\t}\n\n\tprotected abstract AbstractStaxXMLReader createStaxXmlReader(InputStream inputStream) throws XMLStreamException;\n\n\n\tprivate static class SkipLocatorArgumentsAdapter implements InvocationArgumentsAdapter {\n\n\t\t@Override\n\t\tpublic Object[] adaptArguments(Object[] arguments) {\n\t\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\t\tif (arguments[i] instanceof Locator) {\n\t\t\t\t\targuments[i] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn arguments;\n\t\t}\n\t}\n\n\n\tprivate static class CharArrayToStringAdapter implements InvocationArgumentsAdapter {\n\n\t\t@Override\n\t\tpublic Object[] adaptArguments(Object[] arguments) {\n\t\t\tif (arguments.length == 3 && arguments[0] instanceof char[]\n\t\t\t\t\t&& arguments[1] instanceof Integer && arguments[2] instanceof Integer) {\n\t\t\t\treturn new Object[] {new String((char[]) arguments[0], (Integer) arguments[1], (Integer) arguments[2])};\n\t\t\t}\n\t\t\treturn arguments;\n\t\t}\n\t}\n\n\n\tprivate static class PartialAttributesAdapter implements InvocationArgumentsAdapter {\n\n\t\t@Override\n\t\tpublic Object[] adaptArguments(Object[] arguments) {\n\t\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\t\tif (arguments[i] instanceof Attributes) {\n\t\t\t\t\targuments[i] = new PartialAttributes((Attributes) arguments[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn arguments;\n\t\t}\n\t}\n\n\n\tprivate static class CopyCharsAnswer implements Answer<Object> {\n\n\t\t@Override\n\t\tpublic Object answer(InvocationOnMock invocation) {\n\t\t\tchar[] chars = (char[]) invocation.getArguments()[0];\n\t\t\tchar[] copy = new char[chars.length];\n\t\t\tSystem.arraycopy(chars, 0, copy, 0, chars.length);\n\t\t\tinvocation.getArguments()[0] = copy;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\tprivate static class PartialAttributes {\n\n\t\tprivate final Attributes attributes;\n\n\t\tpublic PartialAttributes(Attributes attributes) {\n\t\t\tthis.attributes = attributes;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(@Nullable Object obj) {\n\t\t\tAttributes other = ((PartialAttributes) obj).attributes;\n\t\t\tif (this.attributes.getLength() != other.getLength()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (int i = 0; i < other.getLength(); i++) {\n\t\t\t\tboolean found = false;\n\t\t\t\tfor (int j = 0; j < attributes.getLength(); j++) {\n\t\t\t\t\tif (other.getURI(i).equals(attributes.getURI(j))\n\t\t\t\t\t\t\t&& other.getQName(i).equals(attributes.getQName(j))\n\t\t\t\t\t\t\t&& other.getType(i).equals(attributes.getType(j))\n\t\t\t\t\t\t\t&& other.getValue(i).equals(attributes.getValue(j))) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.xml.PartialAttributes",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.xml.PartialAttributes#attributes",
    "tailType": "field"
  },
  {
    "head": "org.springframework.util.xml.PartialAttributes#attributes",
    "headType": "field",
    "relation": "haveType",
    "tail": "Attributes",
    "tailType": "type"
  },
  {
    "head": "org.springframework.util.xml.PartialAttributes#equals(Object)",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic boolean equals(@Nullable Object obj) {\r\n    Attributes other = ((PartialAttributes) obj).attributes;\r\n    if (this.attributes.getLength() != other.getLength()) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < other.getLength(); i++) {\r\n        boolean found = false;\r\n        for (int j = 0; j < attributes.getLength(); j++) {\r\n            if (other.getURI(i).equals(attributes.getURI(j)) && other.getQName(i).equals(attributes.getQName(j)) && other.getType(i).equals(attributes.getType(j)) && other.getValue(i).equals(attributes.getValue(j))) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!found) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.xml.PartialAttributes",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.xml.PartialAttributes#equals(Object)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.xml.PartialAttributes#equals(Object)",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.xml.PartialAttributes#hashCode()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic int hashCode() {\r\n    return 1;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.xml.PartialAttributes",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.xml.PartialAttributes#hashCode()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.xml.PartialAttributes#hashCode()",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.asm",
    "tailType": "package"
  }
]