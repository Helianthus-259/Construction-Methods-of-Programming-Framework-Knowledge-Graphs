[
  {
    "head": "org.springframework.util.ExplosiveType",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URL;\nimport java.net.UnknownHostException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.sql.SQLException;\nimport java.time.LocalDate;\nimport java.time.ZoneId;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.TimeZone;\nimport java.util.UUID;\nimport java.util.regex.Pattern;\n\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.springframework.util.ObjectUtils.isEmpty;\n\n/**\n * Tests for {@link ObjectUtils}.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Rick Evans\n * @author Sam Brannen\n * @author Hyunjin Choi\n * @author Ngoc Nhan\n */\nclass ObjectUtilsTests {\n\n\t@Test\n\tvoid isCheckedException() {\n\t\tassertThat(ObjectUtils.isCheckedException(new Exception())).isTrue();\n\t\tassertThat(ObjectUtils.isCheckedException(new SQLException())).isTrue();\n\n\t\tassertThat(ObjectUtils.isCheckedException(new RuntimeException())).isFalse();\n\t\tassertThat(ObjectUtils.isCheckedException(new IllegalArgumentException(\"\"))).isFalse();\n\n\t\t// Any Throwable other than RuntimeException and Error\n\t\t// has to be considered checked according to the JLS.\n\t\tassertThat(ObjectUtils.isCheckedException(new Throwable())).isTrue();\n\t}\n\n\t@Test\n\tvoid isCompatibleWithThrowsClause() {\n\t\tClass<?>[] empty = new Class<?>[0];\n\t\tClass<?>[] exception = new Class<?>[] {Exception.class};\n\t\tClass<?>[] sqlAndIO = new Class<?>[] {SQLException.class, IOException.class};\n\t\tClass<?>[] throwable = new Class<?>[] {Throwable.class};\n\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new RuntimeException())).isTrue();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new RuntimeException(), empty)).isTrue();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new RuntimeException(), exception)).isTrue();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new RuntimeException(), sqlAndIO)).isTrue();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new RuntimeException(), throwable)).isTrue();\n\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new Exception())).isFalse();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new Exception(), empty)).isFalse();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new Exception(), exception)).isTrue();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new Exception(), sqlAndIO)).isFalse();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new Exception(), throwable)).isTrue();\n\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new SQLException())).isFalse();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new SQLException(), empty)).isFalse();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new SQLException(), exception)).isTrue();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new SQLException(), sqlAndIO)).isTrue();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new SQLException(), throwable)).isTrue();\n\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new Throwable())).isFalse();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new Throwable(), empty)).isFalse();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new Throwable(), exception)).isFalse();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new Throwable(), sqlAndIO)).isFalse();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new Throwable(), throwable)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEmptyNull() {\n\t\tassertThat(isEmpty(null)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEmptyArray() {\n\t\tassertThat(isEmpty(new char[0])).isTrue();\n\t\tassertThat(isEmpty(new Object[0])).isTrue();\n\t\tassertThat(isEmpty(new Integer[0])).isTrue();\n\n\t\tassertThat(isEmpty(new int[] {42})).isFalse();\n\t\tassertThat(isEmpty(new Integer[] {42})).isFalse();\n\t}\n\n\t@Test\n\tvoid isEmptyCollection() {\n\t\tassertThat(isEmpty(Collections.emptyList())).isTrue();\n\t\tassertThat(isEmpty(Collections.emptySet())).isTrue();\n\n\t\tSet<String> set = new HashSet<>();\n\t\tset.add(\"foo\");\n\t\tassertThat(isEmpty(set)).isFalse();\n\t\tassertThat(isEmpty(Collections.singletonList(\"foo\"))).isFalse();\n\t}\n\n\t@Test\n\tvoid isEmptyMap() {\n\t\tassertThat(isEmpty(Collections.emptyMap())).isTrue();\n\n\t\tHashMap<String, Object> map = new HashMap<>();\n\t\tmap.put(\"foo\", 42L);\n\t\tassertThat(isEmpty(map)).isFalse();\n\t}\n\n\t@Test\n\tvoid isEmptyCharSequence() {\n\t\tassertThat(isEmpty(new StringBuilder())).isTrue();\n\t\tassertThat(isEmpty(\"\")).isTrue();\n\n\t\tassertThat(isEmpty(new StringBuilder(\"foo\"))).isFalse();\n\t\tassertThat(isEmpty(\"   \")).isFalse();\n\t\tassertThat(isEmpty(\"\\t\")).isFalse();\n\t\tassertThat(isEmpty(\"foo\")).isFalse();\n\t}\n\n\t@Test\n\tvoid isEmptyUnsupportedObjectType() {\n\t\tassertThat(isEmpty(42L)).isFalse();\n\t\tassertThat(isEmpty(new Object())).isFalse();\n\t}\n\n\t@Test\n\tvoid toObjectArray() {\n\t\tint[] a = new int[] {1, 2, 3, 4, 5};\n\t\tInteger[] wrapper = (Integer[]) ObjectUtils.toObjectArray(a);\n\t\tassertThat(wrapper).hasSize(5);\n\t\tfor (int i = 0; i < wrapper.length; i++) {\n\t\t\tassertThat(wrapper[i]).isEqualTo(a[i]);\n\t\t}\n\t}\n\n\t@Test\n\tvoid toObjectArrayWithNull() {\n\t\tObject[] objects = ObjectUtils.toObjectArray(null);\n\t\tassertThat(objects).isNotNull();\n\t\tassertThat(objects).isEmpty();\n\t}\n\n\t@Test\n\tvoid toObjectArrayWithEmptyPrimitiveArray() {\n\t\tObject[] objects = ObjectUtils.toObjectArray(new byte[] {});\n\t\tassertThat(objects).isNotNull();\n\t\tassertThat(objects).isEmpty();\n\t}\n\n\t@Test\n\tvoid toObjectArrayWithNonArrayType() {\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> ObjectUtils.toObjectArray(\"Not an []\"))\n\t\t\t\t.withMessageStartingWith(\"Source is not an array\");\n\t}\n\n\t@Test\n\tvoid toObjectArrayWithNonPrimitiveArray() {\n\t\tString[] source = {\"Bingo\"};\n\t\tassertThat(ObjectUtils.toObjectArray(source)).isSameAs(source);\n\t}\n\n\t@Test\n\tvoid addObjectToArraySunnyDay() {\n\t\tString[] array = {\"foo\", \"bar\"};\n\t\tString newElement = \"baz\";\n\t\tObject[] newArray = ObjectUtils.addObjectToArray(array, newElement);\n\t\tassertThat(newArray).hasSize(3);\n\t\tassertThat(newArray[2]).isEqualTo(newElement);\n\t}\n\n\t@Test\n\tvoid addObjectToArraysAtPosition() {\n\t\tString[] array = {\"foo\", \"bar\", \"baz\"};\n\t\tassertThat(ObjectUtils.addObjectToArray(array, \"bat\", 3)).containsExactly(\"foo\", \"bar\", \"baz\", \"bat\");\n\t\tassertThat(ObjectUtils.addObjectToArray(array, \"bat\", 2)).containsExactly(\"foo\", \"bar\", \"bat\", \"baz\");\n\t\tassertThat(ObjectUtils.addObjectToArray(array, \"bat\", 1)).containsExactly(\"foo\", \"bat\", \"bar\", \"baz\");\n\t\tassertThat(ObjectUtils.addObjectToArray(array, \"bat\", 0)).containsExactly(\"bat\", \"foo\", \"bar\", \"baz\");\n\t}\n\n\t@Test\n\tvoid addObjectToArrayWhenEmpty() {\n\t\tString[] array = new String[0];\n\t\tString newElement = \"foo\";\n\t\tString[] newArray = ObjectUtils.addObjectToArray(array, newElement);\n\t\tassertThat(newArray).hasSize(1);\n\t\tassertThat(newArray[0]).isEqualTo(newElement);\n\t}\n\n\t@Test\n\tvoid addObjectToSingleNonNullElementArray() {\n\t\tString existingElement = \"foo\";\n\t\tString[] array = {existingElement};\n\t\tString newElement = \"bar\";\n\t\tString[] newArray = ObjectUtils.addObjectToArray(array, newElement);\n\t\tassertThat(newArray).hasSize(2);\n\t\tassertThat(newArray[0]).isEqualTo(existingElement);\n\t\tassertThat(newArray[1]).isEqualTo(newElement);\n\t}\n\n\t@Test\n\tvoid addObjectToSingleNullElementArray() {\n\t\tString[] array = {null};\n\t\tString newElement = \"bar\";\n\t\tString[] newArray = ObjectUtils.addObjectToArray(array, newElement);\n\t\tassertThat(newArray).hasSize(2);\n\t\tassertThat(newArray[0]).isNull();\n\t\tassertThat(newArray[1]).isEqualTo(newElement);\n\t}\n\n\t@Test\n\tvoid addObjectToNullArray() {\n\t\tString newElement = \"foo\";\n\t\tString[] newArray = ObjectUtils.addObjectToArray(null, newElement);\n\t\tassertThat(newArray).hasSize(1);\n\t\tassertThat(newArray[0]).isEqualTo(newElement);\n\t}\n\n\t@Test\n\tvoid addNullObjectToNullArray() {\n\t\tObject[] newArray = ObjectUtils.addObjectToArray(null, null);\n\t\tassertThat(newArray).hasSize(1);\n\t\tassertThat(newArray[0]).isNull();\n\t}\n\n\t@Test\n\tvoid nullSafeEqualsWithArrays() {\n\t\tassertThat(ObjectUtils.nullSafeEquals(new String[] {\"a\", \"b\", \"c\"}, new String[] {\"a\", \"b\", \"c\"})).isTrue();\n\t\tassertThat(ObjectUtils.nullSafeEquals(new int[] {1, 2, 3}, new int[] {1, 2, 3})).isTrue();\n\t}\n\n\t@Test\n\tvoid identityToString() {\n\t\tObject obj = new Object();\n\t\tString expected = obj.getClass().getName() + \"@\" + ObjectUtils.getIdentityHexString(obj);\n\t\tString actual = ObjectUtils.identityToString(obj);\n\t\tassertThat(actual).isEqualTo(expected);\n\t}\n\n\t@Test\n\tvoid identityToStringWithNullObject() {\n\t\tassertThat(ObjectUtils.identityToString(null)).isEmpty();\n\t}\n\n\t@Test\n\tvoid isArrayOfPrimitivesWithBooleanArray() {\n\t\tassertThat(ClassUtils.isPrimitiveArray(boolean[].class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isArrayOfPrimitivesWithObjectArray() {\n\t\tassertThat(ClassUtils.isPrimitiveArray(Object[].class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isArrayOfPrimitivesWithNonArray() {\n\t\tassertThat(ClassUtils.isPrimitiveArray(String.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithBooleanPrimitiveClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(boolean.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithBooleanWrapperClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(Boolean.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithBytePrimitiveClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(byte.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithByteWrapperClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(Byte.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithCharacterClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(Character.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithCharClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(char.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithDoublePrimitiveClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(double.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithDoubleWrapperClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(Double.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithFloatPrimitiveClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(float.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithFloatWrapperClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(Float.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithIntClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(int.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithIntegerClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(Integer.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithLongPrimitiveClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(long.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithLongWrapperClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(Long.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithNonPrimitiveOrWrapperClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(Object.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithShortPrimitiveClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(short.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithShortWrapperClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(Short.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid nullSafeHashWithNull() {\n\t\tassertThat(ObjectUtils.nullSafeHash((Object[]) null)).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid nullSafeHashWithIntermediateNullElements() {\n\t\tassertThat(ObjectUtils.nullSafeHash(3, null, 5)).isEqualTo(Objects.hash(3, null, 5));\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithNullBooleanArray() {\n\t\tboolean[] array = null;\n\t\tassertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithBooleanArray() {\n\t\tboolean[] array = {true, false};\n\t\tint actual = ObjectUtils.nullSafeHashCode(array);\n\t\tassertThat(actual).isEqualTo(Arrays.hashCode(array));\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithObjectBeingBooleanArray() {\n\t\tObject array = new boolean[] {true, false};\n\t\tint expected = ObjectUtils.nullSafeHashCode((boolean[]) array);\n\t\tassertEqualHashCodes(expected, array);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithNullByteArray() {\n\t\tbyte[] array = null;\n\t\tassertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithByteArray() {\n\t\tbyte[] array = {8, 10};\n\t\tint actual = ObjectUtils.nullSafeHashCode(array);\n\t\tassertThat(actual).isEqualTo(Arrays.hashCode(array));\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithObjectBeingByteArray() {\n\t\tObject array = new byte[] {6, 39};\n\t\tint expected = ObjectUtils.nullSafeHashCode((byte[]) array);\n\t\tassertEqualHashCodes(expected, array);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithNullCharArray() {\n\t\tchar[] array = null;\n\t\tassertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithCharArray() {\n\t\tchar[] array = {'a', 'E'};\n\t\tint actual = ObjectUtils.nullSafeHashCode(array);\n\t\tassertThat(actual).isEqualTo(Arrays.hashCode(array));\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithObjectBeingCharArray() {\n\t\tObject array = new char[] {'l', 'M'};\n\t\tint expected = ObjectUtils.nullSafeHashCode((char[]) array);\n\t\tassertEqualHashCodes(expected, array);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithNullDoubleArray() {\n\t\tdouble[] array = null;\n\t\tassertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithDoubleArray() {\n\t\tdouble[] array = {8449.65, 9944.923};\n\t\tint actual = ObjectUtils.nullSafeHashCode(array);\n\t\tassertThat(actual).isEqualTo(Arrays.hashCode(array));\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithObjectBeingDoubleArray() {\n\t\tObject array = new double[] {68930.993, 9022.009};\n\t\tint expected = ObjectUtils.nullSafeHashCode((double[]) array);\n\t\tassertEqualHashCodes(expected, array);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithNullFloatArray() {\n\t\tfloat[] array = null;\n\t\tassertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithFloatArray() {\n\t\tfloat[] array = {9.6f, 7.4f};\n\t\tint actual = ObjectUtils.nullSafeHashCode(array);\n\t\tassertThat(actual).isEqualTo(Arrays.hashCode(array));\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithObjectBeingFloatArray() {\n\t\tObject array = new float[] {9.9f, 9.54f};\n\t\tint expected = ObjectUtils.nullSafeHashCode((float[]) array);\n\t\tassertEqualHashCodes(expected, array);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithNullIntArray() {\n\t\tint[] array = null;\n\t\tassertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithIntArray() {\n\t\tint[] array = {884, 340};\n\t\tint actual = ObjectUtils.nullSafeHashCode(array);\n\t\tassertThat(actual).isEqualTo(Arrays.hashCode(array));\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithObjectBeingIntArray() {\n\t\tObject array = new int[] {89, 32};\n\t\tint expected = ObjectUtils.nullSafeHashCode((int[]) array);\n\t\tassertEqualHashCodes(expected, array);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithNullLongArray() {\n\t\tlong[] array = null;\n\t\tassertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithLongArray() {\n\t\tlong[] array = {7993L, 84320L};\n\t\tint actual = ObjectUtils.nullSafeHashCode(array);\n\t\tassertThat(actual).isEqualTo(Arrays.hashCode(array));\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithObjectBeingLongArray() {\n\t\tObject array = new long[] {4389, 320};\n\t\tint expected = ObjectUtils.nullSafeHashCode((long[]) array);\n\t\tassertEqualHashCodes(expected, array);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithNullShortArray() {\n\t\tshort[] array = null;\n\t\tassertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithShortArray() {\n\t\tshort[] array = {4, 25};\n\t\tint actual = ObjectUtils.nullSafeHashCode(array);\n\t\tassertThat(actual).isEqualTo(Arrays.hashCode(array));\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithObjectBeingShortArray() {\n\t\tObject array = new short[] {5, 3};\n\t\tint expected = ObjectUtils.nullSafeHashCode((short[]) array);\n\t\tassertEqualHashCodes(expected, array);\n\t}\n\n\t@Test\n\tvoid nullSafeHashCodeWithObject() {\n\t\tString str = \"Luke\";\n\t\tassertThat(ObjectUtils.nullSafeHashCode(str)).isEqualTo(str.hashCode());\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithObjectArray() {\n\t\tObject[] array = {\"Leia\", \"Han\"};\n\t\tint actual = ObjectUtils.nullSafeHashCode(array);\n\t\tassertThat(actual).isEqualTo(Arrays.hashCode(array));\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithObjectArrayEqualToNull() {\n\t\tassertThat(ObjectUtils.nullSafeHashCode((Object[]) null)).isEqualTo(0);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithObjectBeingObjectArray() {\n\t\tObject array = new Object[] {\"Luke\", \"Anakin\"};\n\t\tint expected = ObjectUtils.nullSafeHashCode((Object[]) array);\n\t\tassertEqualHashCodes(expected, array);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithObjectEqualToNull() {\n\t\tObject[] array = null;\n\t\tassertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithBooleanArray() {\n\t\tboolean[] array = {true, false};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{true, false}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithBooleanArrayBeingEmpty() {\n\t\tboolean[] array = {};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithBooleanArrayEqualToNull() {\n\t\tassertThat(ObjectUtils.nullSafeToString((boolean[]) null)).isEqualTo(\"null\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithByteArray() {\n\t\tbyte[] array = {5, 8};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{5, 8}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithByteArrayBeingEmpty() {\n\t\tbyte[] array = {};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithByteArrayEqualToNull() {\n\t\tassertThat(ObjectUtils.nullSafeToString((byte[]) null)).isEqualTo(\"null\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithCharArray() {\n\t\tchar[] array = {'A', 'B'};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{'A', 'B'}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithCharArrayBeingEmpty() {\n\t\tchar[] array = {};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithCharArrayEqualToNull() {\n\t\tassertThat(ObjectUtils.nullSafeToString((char[]) null)).isEqualTo(\"null\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithDoubleArray() {\n\t\tdouble[] array = {8594.93, 8594023.95};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{8594.93, 8594023.95}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithDoubleArrayBeingEmpty() {\n\t\tdouble[] array = {};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithDoubleArrayEqualToNull() {\n\t\tassertThat(ObjectUtils.nullSafeToString((double[]) null)).isEqualTo(\"null\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithFloatArray() {\n\t\tfloat[] array = {8.6f, 43.8f};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{8.6, 43.8}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithFloatArrayBeingEmpty() {\n\t\tfloat[] array = {};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithFloatArrayEqualToNull() {\n\t\tassertThat(ObjectUtils.nullSafeToString((float[]) null)).isEqualTo(\"null\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithIntArray() {\n\t\tint[] array = {9, 64};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{9, 64}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithIntArrayBeingEmpty() {\n\t\tint[] array = {};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithIntArrayEqualToNull() {\n\t\tassertThat(ObjectUtils.nullSafeToString((int[]) null)).isEqualTo(\"null\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithLongArray() {\n\t\tlong[] array = {434L, 23423L};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{434, 23423}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithLongArrayBeingEmpty() {\n\t\tlong[] array = {};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithLongArrayEqualToNull() {\n\t\tassertThat(ObjectUtils.nullSafeToString((long[]) null)).isEqualTo(\"null\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithPlainOldString() {\n\t\tassertThat(ObjectUtils.nullSafeToString(\"I shoh love tha taste of mangoes\")).isEqualTo(\"I shoh love tha taste of mangoes\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithObjectArray() {\n\t\tObject[] array = {\"Han\", 43L};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{Han, 43}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithObjectArrayBeingEmpty() {\n\t\tObject[] array = {};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithObjectArrayEqualToNull() {\n\t\tassertThat(ObjectUtils.nullSafeToString((Object[]) null)).isEqualTo(\"null\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithShortArray() {\n\t\tshort[] array = {7, 9};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{7, 9}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithShortArrayBeingEmpty() {\n\t\tshort[] array = {};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithShortArrayEqualToNull() {\n\t\tassertThat(ObjectUtils.nullSafeToString((short[]) null)).isEqualTo(\"null\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithStringArray() {\n\t\tString[] array = {\"Luke\", \"Anakin\"};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{Luke, Anakin}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithStringArrayBeingEmpty() {\n\t\tString[] array = {};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithStringArrayEqualToNull() {\n\t\tassertThat(ObjectUtils.nullSafeToString((String[]) null)).isEqualTo(\"null\");\n\t}\n\n\t@Test\n\tvoid containsConstant() {\n\t\tassertThat(ObjectUtils.containsConstant(Tropes.values(), \"FOO\")).isTrue();\n\t\tassertThat(ObjectUtils.containsConstant(Tropes.values(), \"foo\")).isTrue();\n\t\tassertThat(ObjectUtils.containsConstant(Tropes.values(), \"BaR\")).isTrue();\n\t\tassertThat(ObjectUtils.containsConstant(Tropes.values(), \"bar\")).isTrue();\n\t\tassertThat(ObjectUtils.containsConstant(Tropes.values(), \"BAZ\")).isTrue();\n\t\tassertThat(ObjectUtils.containsConstant(Tropes.values(), \"baz\")).isTrue();\n\n\t\tassertThat(ObjectUtils.containsConstant(Tropes.values(), \"BOGUS\")).isFalse();\n\n\t\tassertThat(ObjectUtils.containsConstant(Tropes.values(), \"FOO\", true)).isTrue();\n\t\tassertThat(ObjectUtils.containsConstant(Tropes.values(), \"foo\", true)).isFalse();\n\t}\n\n\t@Test\n\tvoid containsElement() {\n\t\tObject[] array = {\"foo\", \"bar\", 42, new String[] {\"baz\", \"quux\"}};\n\n\t\tassertThat(ObjectUtils.containsElement(null, \"foo\")).isFalse();\n\t\tassertThat(ObjectUtils.containsElement(array, null)).isFalse();\n\t\tassertThat(ObjectUtils.containsElement(array, \"bogus\")).isFalse();\n\n\t\tassertThat(ObjectUtils.containsElement(array, \"foo\")).isTrue();\n\t\tassertThat(ObjectUtils.containsElement(array, \"bar\")).isTrue();\n\t\tassertThat(ObjectUtils.containsElement(array, 42)).isTrue();\n\t\tassertThat(ObjectUtils.containsElement(array, new String[] {\"baz\", \"quux\"})).isTrue();\n\t}\n\n\t@Test\n\tvoid caseInsensitiveValueOf() {\n\t\tassertThat(ObjectUtils.caseInsensitiveValueOf(Tropes.values(), \"foo\")).isEqualTo(Tropes.FOO);\n\t\tassertThat(ObjectUtils.caseInsensitiveValueOf(Tropes.values(), \"BAR\")).isEqualTo(Tropes.BAR);\n\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tObjectUtils.caseInsensitiveValueOf(Tropes.values(), \"bogus\"))\n\t\t\t.withMessage(\"Constant [bogus] does not exist in enum type org.springframework.util.ObjectUtilsTests$Tropes\");\n\t}\n\n\n\tprivate static void assertEqualHashCodes(int expected, Object array) {\n\t\tint actual = ObjectUtils.nullSafeHashCode(array);\n\t\tassertThat(actual).isEqualTo(expected);\n\t\tassertThat(array.hashCode()).isNotEqualTo(actual);\n\t}\n\n\n\tenum Tropes {FOO, BAR, baz}\n\n\n\t@Nested\n\tclass NullSafeConciseToStringTests {\n\n\t\tprivate static final String truncated = \" (truncated)...\";\n\t\tprivate static final int truncatedLength = 100 + truncated.length();\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForNull() {\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(null)).isEqualTo(\"null\");\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForEmptyOptional() {\n\t\t\tOptional<String> optional = Optional.empty();\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(optional)).isEqualTo(\"Optional.empty\");\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForNonEmptyOptionals() {\n\t\t\tOptional<Tropes> optionalEnum = Optional.of(Tropes.BAR);\n\t\t\tString expected = \"Optional[BAR]\";\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(optionalEnum)).isEqualTo(expected);\n\n\t\t\tString repeat100 = \"X\".repeat(100);\n\t\t\tString repeat101 = \"X\".repeat(101);\n\n\t\t\tOptional<String> optionalString = Optional.of(repeat100);\n\t\t\texpected = \"Optional[%s]\".formatted(repeat100);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(optionalString)).isEqualTo(expected);\n\n\t\t\toptionalString = Optional.of(repeat101);\n\t\t\texpected = \"Optional[%s]\".formatted(repeat100 + truncated);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(optionalString)).isEqualTo(expected);\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForNonEmptyOptionalCustomType() {\n\t\t\tclass CustomType {\n\t\t\t}\n\n\t\t\tCustomType customType = new CustomType();\n\t\t\tOptional<CustomType> optional = Optional.of(customType);\n\t\t\tString expected = \"Optional[%s]\".formatted(ObjectUtils.nullSafeConciseToString(customType));\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(optional)).isEqualTo(expected);\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForClass() {\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(String.class)).isEqualTo(\"java.lang.String\");\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForStrings() {\n\t\t\tString repeat100 = \"X\".repeat(100);\n\t\t\tString repeat101 = \"X\".repeat(101);\n\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(\"\")).isEqualTo(\"\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(\"foo\")).isEqualTo(\"foo\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(repeat100)).isEqualTo(repeat100);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(repeat101)).hasSize(truncatedLength).endsWith(truncated);\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForStringBuilders() {\n\t\t\tString repeat100 = \"X\".repeat(100);\n\t\t\tString repeat101 = \"X\".repeat(101);\n\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new StringBuilder(\"foo\"))).isEqualTo(\"foo\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new StringBuilder(repeat100))).isEqualTo(repeat100);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new StringBuilder(repeat101))).hasSize(truncatedLength).endsWith(truncated);\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForEnum() {\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(Tropes.FOO)).isEqualTo(\"FOO\");\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForPrimitivesAndWrappers() {\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(true)).isEqualTo(\"true\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString('X')).isEqualTo(\"X\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(42L)).isEqualTo(\"42\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(99.1234D)).isEqualTo(\"99.1234\");\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForBigNumbers() {\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(BigInteger.valueOf(42L))).isEqualTo(\"42\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(BigDecimal.valueOf(99.1234D))).isEqualTo(\"99.1234\");\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForDate() {\n\t\t\tDate date = new Date();\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(date)).isEqualTo(date.toString());\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForTemporal() {\n\t\t\tLocalDate localDate = LocalDate.now();\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(localDate)).isEqualTo(localDate.toString());\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForUUID() {\n\t\t\tUUID id = UUID.randomUUID();\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(id)).isEqualTo(id.toString());\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForFile() {\n\t\t\tString path = \"/tmp/file.txt\".replace('/', File.separatorChar);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new File(path))).isEqualTo(path);\n\n\t\t\tpath = (\"/tmp/\" + \"xyz\".repeat(32)).replace('/', File.separatorChar);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new File(path)))\n\t\t\t\t\t.hasSize(truncatedLength)\n\t\t\t\t\t.startsWith(path.subSequence(0, 100))\n\t\t\t\t\t.endsWith(truncated);\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForPath() {\n\t\t\tString path = \"/tmp/file.txt\".replace('/', File.separatorChar);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(Path.of(path))).isEqualTo(path);\n\n\t\t\tpath = (\"/tmp/\" + \"xyz\".repeat(32)).replace('/', File.separatorChar);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(Path.of(path)))\n\t\t\t\t\t.hasSize(truncatedLength)\n\t\t\t\t\t.startsWith(path.subSequence(0, 100))\n\t\t\t\t\t.endsWith(truncated);\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForURI() {\n\t\t\tString uri = \"https://www.example.com/?foo=1&bar=2&baz=3\";\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(URI.create(uri))).isEqualTo(uri);\n\n\t\t\turi += \"&qux=\" + \"4\".repeat(60);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(URI.create(uri)))\n\t\t\t\t\t.hasSize(truncatedLength)\n\t\t\t\t\t.startsWith(uri.subSequence(0, 100))\n\t\t\t\t\t.endsWith(truncated);\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForURL() throws Exception {\n\t\t\tString url = \"https://www.example.com/?foo=1&bar=2&baz=3\";\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new URL(url))).isEqualTo(url);\n\n\t\t\turl += \"&qux=\" + \"4\".repeat(60);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new URL(url)))\n\t\t\t\t\t.hasSize(truncatedLength)\n\t\t\t\t\t.startsWith(url.subSequence(0, 100))\n\t\t\t\t\t.endsWith(truncated);\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForInetAddress() {\n\t\t\tInetAddress localhost = getLocalhost();\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(localhost)).isEqualTo(localhost.toString());\n\t\t}\n\n\t\tprivate static InetAddress getLocalhost() {\n\t\t\ttry {\n\t\t\t\treturn InetAddress.getLocalHost();\n\t\t\t}\n\t\t\tcatch (UnknownHostException ex) {\n\t\t\t\treturn InetAddress.getLoopbackAddress();\n\t\t\t}\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForCharset() {\n\t\t\tCharset charset = StandardCharsets.UTF_8;\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(charset)).isEqualTo(charset.name());\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForCurrency() {\n\t\t\tCurrency currency = Currency.getInstance(Locale.US);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(currency)).isEqualTo(currency.toString());\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForLocale() {\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(Locale.GERMANY)).isEqualTo(\"de_DE\");\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForRegExPattern() {\n\t\t\tPattern pattern = Pattern.compile(\"^(foo|bar)$\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(pattern)).isEqualTo(pattern.toString());\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForTimeZone() {\n\t\t\tTimeZone timeZone = TimeZone.getDefault();\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(timeZone)).isEqualTo(timeZone.getID());\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForZoneId() {\n\t\t\tZoneId zoneId = ZoneId.systemDefault();\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(zoneId)).isEqualTo(zoneId.getId());\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForEmptyArrays() {\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new char[] {})).isEqualTo(\"{}\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new int[][] {})).isEqualTo(\"{}\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new String[] {})).isEqualTo(\"{}\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new Integer[][] {})).isEqualTo(\"{}\");\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForNonEmptyArrays() {\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new char[] {'a'})).isEqualTo(\"{...}\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new int[][] {{1}, {2}})).isEqualTo(\"{...}\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new String[] {\"enigma\"})).isEqualTo(\"{...}\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new Integer[][] {{1}, {2}})).isEqualTo(\"{...}\");\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForEmptyCollections() {\n\t\t\tList<String> list = List.of();\n\t\t\tSet<Integer> set = Set.of();\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(list)).isEqualTo(\"[...]\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(set)).isEqualTo(\"[...]\");\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForNonEmptyCollections() {\n\t\t\tList<String> list = List.of(\"a\", \"b\");\n\t\t\tSet<Integer> set = Set.of(1);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(list)).isEqualTo(\"[...]\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(set)).isEqualTo(\"[...]\");\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForEmptyMaps() {\n\t\t\tMap<String, String> map = Map.of();\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(map)).isEqualTo(\"{...}\");\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForNonEmptyMaps() {\n\t\t\tMap<String, Integer> map = Map.of(\"a\", 1, \"b\", 2, \"c\", 3);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(map)).isEqualTo(\"{...}\");\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForCustomTypes() {\n\t\t\tclass ExplosiveType {\n\t\t\t\t@Override\n\t\t\t\tpublic String toString() {\n\t\t\t\t\tthrow new UnsupportedOperationException(\"no-go\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tExplosiveType explosiveType = new ExplosiveType();\n\t\t\tassertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(explosiveType::toString);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(explosiveType)).startsWith(prefix(ExplosiveType.class));\n\n\t\t\tclass WordyType {\n\t\t\t\t@Override\n\t\t\t\tpublic String toString() {\n\t\t\t\t\treturn \"blah blah\".repeat(20);\n\t\t\t\t}\n\t\t\t}\n\t\t\tWordyType wordyType = new WordyType();\n\t\t\tassertThat(wordyType).asString().hasSizeGreaterThanOrEqualTo(180 /* 9x20 */);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(wordyType)).startsWith(prefix(WordyType.class));\n\t\t}\n\n\t\tprivate static String prefix(Class<?> clazz) {\n\t\t\treturn clazz.getTypeName() + \"@\";\n\t\t}\n\t}\n\n\t@Test\n\tvoid unwrapOptional() {\n\n\t\tassertThat(ObjectUtils.unwrapOptional(null)).isNull();\n\t\tassertThat(ObjectUtils.unwrapOptional(\"some value\")).isEqualTo(\"some value\");\n\t\tassertThat(ObjectUtils.unwrapOptional(Optional.empty())).isNull();\n\t\tassertThat(ObjectUtils.unwrapOptional(Optional.of(\"some value\"))).isEqualTo(\"some value\");\n\n\t\tOptional<Optional<Object>> nestedEmptyOptional = Optional.of(Optional.empty());\n\t\tassertThatIllegalArgumentException()\n\t\t\t.isThrownBy(() -> ObjectUtils.unwrapOptional(nestedEmptyOptional))\n\t\t\t.withMessage(\"Multi-level Optional usage not supported\");\n\n\t\tOptional<Optional<String>> nestedStringOptional = Optional.of(Optional.of(\"some value\"));\n\t\tassertThatIllegalArgumentException()\n\t\t\t.isThrownBy(() -> ObjectUtils.unwrapOptional(nestedStringOptional))\n\t\t\t.withMessage(\"Multi-level Optional usage not supported\");\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.ExplosiveType#toString()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic String toString() {\r\n    throw new UnsupportedOperationException(\"no-go\");\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.ExplosiveType",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.ExplosiveType#toString()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.ExplosiveType#toString()",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.WordyType",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.WordyType",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URL;\nimport java.net.UnknownHostException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.sql.SQLException;\nimport java.time.LocalDate;\nimport java.time.ZoneId;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.TimeZone;\nimport java.util.UUID;\nimport java.util.regex.Pattern;\n\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.springframework.util.ObjectUtils.isEmpty;\n\n/**\n * Tests for {@link ObjectUtils}.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Rick Evans\n * @author Sam Brannen\n * @author Hyunjin Choi\n * @author Ngoc Nhan\n */\nclass ObjectUtilsTests {\n\n\t@Test\n\tvoid isCheckedException() {\n\t\tassertThat(ObjectUtils.isCheckedException(new Exception())).isTrue();\n\t\tassertThat(ObjectUtils.isCheckedException(new SQLException())).isTrue();\n\n\t\tassertThat(ObjectUtils.isCheckedException(new RuntimeException())).isFalse();\n\t\tassertThat(ObjectUtils.isCheckedException(new IllegalArgumentException(\"\"))).isFalse();\n\n\t\t// Any Throwable other than RuntimeException and Error\n\t\t// has to be considered checked according to the JLS.\n\t\tassertThat(ObjectUtils.isCheckedException(new Throwable())).isTrue();\n\t}\n\n\t@Test\n\tvoid isCompatibleWithThrowsClause() {\n\t\tClass<?>[] empty = new Class<?>[0];\n\t\tClass<?>[] exception = new Class<?>[] {Exception.class};\n\t\tClass<?>[] sqlAndIO = new Class<?>[] {SQLException.class, IOException.class};\n\t\tClass<?>[] throwable = new Class<?>[] {Throwable.class};\n\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new RuntimeException())).isTrue();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new RuntimeException(), empty)).isTrue();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new RuntimeException(), exception)).isTrue();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new RuntimeException(), sqlAndIO)).isTrue();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new RuntimeException(), throwable)).isTrue();\n\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new Exception())).isFalse();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new Exception(), empty)).isFalse();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new Exception(), exception)).isTrue();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new Exception(), sqlAndIO)).isFalse();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new Exception(), throwable)).isTrue();\n\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new SQLException())).isFalse();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new SQLException(), empty)).isFalse();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new SQLException(), exception)).isTrue();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new SQLException(), sqlAndIO)).isTrue();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new SQLException(), throwable)).isTrue();\n\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new Throwable())).isFalse();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new Throwable(), empty)).isFalse();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new Throwable(), exception)).isFalse();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new Throwable(), sqlAndIO)).isFalse();\n\t\tassertThat(ObjectUtils.isCompatibleWithThrowsClause(new Throwable(), throwable)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEmptyNull() {\n\t\tassertThat(isEmpty(null)).isTrue();\n\t}\n\n\t@Test\n\tvoid isEmptyArray() {\n\t\tassertThat(isEmpty(new char[0])).isTrue();\n\t\tassertThat(isEmpty(new Object[0])).isTrue();\n\t\tassertThat(isEmpty(new Integer[0])).isTrue();\n\n\t\tassertThat(isEmpty(new int[] {42})).isFalse();\n\t\tassertThat(isEmpty(new Integer[] {42})).isFalse();\n\t}\n\n\t@Test\n\tvoid isEmptyCollection() {\n\t\tassertThat(isEmpty(Collections.emptyList())).isTrue();\n\t\tassertThat(isEmpty(Collections.emptySet())).isTrue();\n\n\t\tSet<String> set = new HashSet<>();\n\t\tset.add(\"foo\");\n\t\tassertThat(isEmpty(set)).isFalse();\n\t\tassertThat(isEmpty(Collections.singletonList(\"foo\"))).isFalse();\n\t}\n\n\t@Test\n\tvoid isEmptyMap() {\n\t\tassertThat(isEmpty(Collections.emptyMap())).isTrue();\n\n\t\tHashMap<String, Object> map = new HashMap<>();\n\t\tmap.put(\"foo\", 42L);\n\t\tassertThat(isEmpty(map)).isFalse();\n\t}\n\n\t@Test\n\tvoid isEmptyCharSequence() {\n\t\tassertThat(isEmpty(new StringBuilder())).isTrue();\n\t\tassertThat(isEmpty(\"\")).isTrue();\n\n\t\tassertThat(isEmpty(new StringBuilder(\"foo\"))).isFalse();\n\t\tassertThat(isEmpty(\"   \")).isFalse();\n\t\tassertThat(isEmpty(\"\\t\")).isFalse();\n\t\tassertThat(isEmpty(\"foo\")).isFalse();\n\t}\n\n\t@Test\n\tvoid isEmptyUnsupportedObjectType() {\n\t\tassertThat(isEmpty(42L)).isFalse();\n\t\tassertThat(isEmpty(new Object())).isFalse();\n\t}\n\n\t@Test\n\tvoid toObjectArray() {\n\t\tint[] a = new int[] {1, 2, 3, 4, 5};\n\t\tInteger[] wrapper = (Integer[]) ObjectUtils.toObjectArray(a);\n\t\tassertThat(wrapper).hasSize(5);\n\t\tfor (int i = 0; i < wrapper.length; i++) {\n\t\t\tassertThat(wrapper[i]).isEqualTo(a[i]);\n\t\t}\n\t}\n\n\t@Test\n\tvoid toObjectArrayWithNull() {\n\t\tObject[] objects = ObjectUtils.toObjectArray(null);\n\t\tassertThat(objects).isNotNull();\n\t\tassertThat(objects).isEmpty();\n\t}\n\n\t@Test\n\tvoid toObjectArrayWithEmptyPrimitiveArray() {\n\t\tObject[] objects = ObjectUtils.toObjectArray(new byte[] {});\n\t\tassertThat(objects).isNotNull();\n\t\tassertThat(objects).isEmpty();\n\t}\n\n\t@Test\n\tvoid toObjectArrayWithNonArrayType() {\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> ObjectUtils.toObjectArray(\"Not an []\"))\n\t\t\t\t.withMessageStartingWith(\"Source is not an array\");\n\t}\n\n\t@Test\n\tvoid toObjectArrayWithNonPrimitiveArray() {\n\t\tString[] source = {\"Bingo\"};\n\t\tassertThat(ObjectUtils.toObjectArray(source)).isSameAs(source);\n\t}\n\n\t@Test\n\tvoid addObjectToArraySunnyDay() {\n\t\tString[] array = {\"foo\", \"bar\"};\n\t\tString newElement = \"baz\";\n\t\tObject[] newArray = ObjectUtils.addObjectToArray(array, newElement);\n\t\tassertThat(newArray).hasSize(3);\n\t\tassertThat(newArray[2]).isEqualTo(newElement);\n\t}\n\n\t@Test\n\tvoid addObjectToArraysAtPosition() {\n\t\tString[] array = {\"foo\", \"bar\", \"baz\"};\n\t\tassertThat(ObjectUtils.addObjectToArray(array, \"bat\", 3)).containsExactly(\"foo\", \"bar\", \"baz\", \"bat\");\n\t\tassertThat(ObjectUtils.addObjectToArray(array, \"bat\", 2)).containsExactly(\"foo\", \"bar\", \"bat\", \"baz\");\n\t\tassertThat(ObjectUtils.addObjectToArray(array, \"bat\", 1)).containsExactly(\"foo\", \"bat\", \"bar\", \"baz\");\n\t\tassertThat(ObjectUtils.addObjectToArray(array, \"bat\", 0)).containsExactly(\"bat\", \"foo\", \"bar\", \"baz\");\n\t}\n\n\t@Test\n\tvoid addObjectToArrayWhenEmpty() {\n\t\tString[] array = new String[0];\n\t\tString newElement = \"foo\";\n\t\tString[] newArray = ObjectUtils.addObjectToArray(array, newElement);\n\t\tassertThat(newArray).hasSize(1);\n\t\tassertThat(newArray[0]).isEqualTo(newElement);\n\t}\n\n\t@Test\n\tvoid addObjectToSingleNonNullElementArray() {\n\t\tString existingElement = \"foo\";\n\t\tString[] array = {existingElement};\n\t\tString newElement = \"bar\";\n\t\tString[] newArray = ObjectUtils.addObjectToArray(array, newElement);\n\t\tassertThat(newArray).hasSize(2);\n\t\tassertThat(newArray[0]).isEqualTo(existingElement);\n\t\tassertThat(newArray[1]).isEqualTo(newElement);\n\t}\n\n\t@Test\n\tvoid addObjectToSingleNullElementArray() {\n\t\tString[] array = {null};\n\t\tString newElement = \"bar\";\n\t\tString[] newArray = ObjectUtils.addObjectToArray(array, newElement);\n\t\tassertThat(newArray).hasSize(2);\n\t\tassertThat(newArray[0]).isNull();\n\t\tassertThat(newArray[1]).isEqualTo(newElement);\n\t}\n\n\t@Test\n\tvoid addObjectToNullArray() {\n\t\tString newElement = \"foo\";\n\t\tString[] newArray = ObjectUtils.addObjectToArray(null, newElement);\n\t\tassertThat(newArray).hasSize(1);\n\t\tassertThat(newArray[0]).isEqualTo(newElement);\n\t}\n\n\t@Test\n\tvoid addNullObjectToNullArray() {\n\t\tObject[] newArray = ObjectUtils.addObjectToArray(null, null);\n\t\tassertThat(newArray).hasSize(1);\n\t\tassertThat(newArray[0]).isNull();\n\t}\n\n\t@Test\n\tvoid nullSafeEqualsWithArrays() {\n\t\tassertThat(ObjectUtils.nullSafeEquals(new String[] {\"a\", \"b\", \"c\"}, new String[] {\"a\", \"b\", \"c\"})).isTrue();\n\t\tassertThat(ObjectUtils.nullSafeEquals(new int[] {1, 2, 3}, new int[] {1, 2, 3})).isTrue();\n\t}\n\n\t@Test\n\tvoid identityToString() {\n\t\tObject obj = new Object();\n\t\tString expected = obj.getClass().getName() + \"@\" + ObjectUtils.getIdentityHexString(obj);\n\t\tString actual = ObjectUtils.identityToString(obj);\n\t\tassertThat(actual).isEqualTo(expected);\n\t}\n\n\t@Test\n\tvoid identityToStringWithNullObject() {\n\t\tassertThat(ObjectUtils.identityToString(null)).isEmpty();\n\t}\n\n\t@Test\n\tvoid isArrayOfPrimitivesWithBooleanArray() {\n\t\tassertThat(ClassUtils.isPrimitiveArray(boolean[].class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isArrayOfPrimitivesWithObjectArray() {\n\t\tassertThat(ClassUtils.isPrimitiveArray(Object[].class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isArrayOfPrimitivesWithNonArray() {\n\t\tassertThat(ClassUtils.isPrimitiveArray(String.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithBooleanPrimitiveClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(boolean.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithBooleanWrapperClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(Boolean.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithBytePrimitiveClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(byte.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithByteWrapperClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(Byte.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithCharacterClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(Character.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithCharClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(char.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithDoublePrimitiveClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(double.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithDoubleWrapperClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(Double.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithFloatPrimitiveClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(float.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithFloatWrapperClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(Float.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithIntClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(int.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithIntegerClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(Integer.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithLongPrimitiveClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(long.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithLongWrapperClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(Long.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithNonPrimitiveOrWrapperClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(Object.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithShortPrimitiveClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(short.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPrimitiveOrWrapperWithShortWrapperClass() {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(Short.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid nullSafeHashWithNull() {\n\t\tassertThat(ObjectUtils.nullSafeHash((Object[]) null)).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid nullSafeHashWithIntermediateNullElements() {\n\t\tassertThat(ObjectUtils.nullSafeHash(3, null, 5)).isEqualTo(Objects.hash(3, null, 5));\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithNullBooleanArray() {\n\t\tboolean[] array = null;\n\t\tassertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithBooleanArray() {\n\t\tboolean[] array = {true, false};\n\t\tint actual = ObjectUtils.nullSafeHashCode(array);\n\t\tassertThat(actual).isEqualTo(Arrays.hashCode(array));\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithObjectBeingBooleanArray() {\n\t\tObject array = new boolean[] {true, false};\n\t\tint expected = ObjectUtils.nullSafeHashCode((boolean[]) array);\n\t\tassertEqualHashCodes(expected, array);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithNullByteArray() {\n\t\tbyte[] array = null;\n\t\tassertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithByteArray() {\n\t\tbyte[] array = {8, 10};\n\t\tint actual = ObjectUtils.nullSafeHashCode(array);\n\t\tassertThat(actual).isEqualTo(Arrays.hashCode(array));\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithObjectBeingByteArray() {\n\t\tObject array = new byte[] {6, 39};\n\t\tint expected = ObjectUtils.nullSafeHashCode((byte[]) array);\n\t\tassertEqualHashCodes(expected, array);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithNullCharArray() {\n\t\tchar[] array = null;\n\t\tassertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithCharArray() {\n\t\tchar[] array = {'a', 'E'};\n\t\tint actual = ObjectUtils.nullSafeHashCode(array);\n\t\tassertThat(actual).isEqualTo(Arrays.hashCode(array));\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithObjectBeingCharArray() {\n\t\tObject array = new char[] {'l', 'M'};\n\t\tint expected = ObjectUtils.nullSafeHashCode((char[]) array);\n\t\tassertEqualHashCodes(expected, array);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithNullDoubleArray() {\n\t\tdouble[] array = null;\n\t\tassertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithDoubleArray() {\n\t\tdouble[] array = {8449.65, 9944.923};\n\t\tint actual = ObjectUtils.nullSafeHashCode(array);\n\t\tassertThat(actual).isEqualTo(Arrays.hashCode(array));\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithObjectBeingDoubleArray() {\n\t\tObject array = new double[] {68930.993, 9022.009};\n\t\tint expected = ObjectUtils.nullSafeHashCode((double[]) array);\n\t\tassertEqualHashCodes(expected, array);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithNullFloatArray() {\n\t\tfloat[] array = null;\n\t\tassertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithFloatArray() {\n\t\tfloat[] array = {9.6f, 7.4f};\n\t\tint actual = ObjectUtils.nullSafeHashCode(array);\n\t\tassertThat(actual).isEqualTo(Arrays.hashCode(array));\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithObjectBeingFloatArray() {\n\t\tObject array = new float[] {9.9f, 9.54f};\n\t\tint expected = ObjectUtils.nullSafeHashCode((float[]) array);\n\t\tassertEqualHashCodes(expected, array);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithNullIntArray() {\n\t\tint[] array = null;\n\t\tassertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithIntArray() {\n\t\tint[] array = {884, 340};\n\t\tint actual = ObjectUtils.nullSafeHashCode(array);\n\t\tassertThat(actual).isEqualTo(Arrays.hashCode(array));\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithObjectBeingIntArray() {\n\t\tObject array = new int[] {89, 32};\n\t\tint expected = ObjectUtils.nullSafeHashCode((int[]) array);\n\t\tassertEqualHashCodes(expected, array);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithNullLongArray() {\n\t\tlong[] array = null;\n\t\tassertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithLongArray() {\n\t\tlong[] array = {7993L, 84320L};\n\t\tint actual = ObjectUtils.nullSafeHashCode(array);\n\t\tassertThat(actual).isEqualTo(Arrays.hashCode(array));\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithObjectBeingLongArray() {\n\t\tObject array = new long[] {4389, 320};\n\t\tint expected = ObjectUtils.nullSafeHashCode((long[]) array);\n\t\tassertEqualHashCodes(expected, array);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithNullShortArray() {\n\t\tshort[] array = null;\n\t\tassertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithShortArray() {\n\t\tshort[] array = {4, 25};\n\t\tint actual = ObjectUtils.nullSafeHashCode(array);\n\t\tassertThat(actual).isEqualTo(Arrays.hashCode(array));\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithObjectBeingShortArray() {\n\t\tObject array = new short[] {5, 3};\n\t\tint expected = ObjectUtils.nullSafeHashCode((short[]) array);\n\t\tassertEqualHashCodes(expected, array);\n\t}\n\n\t@Test\n\tvoid nullSafeHashCodeWithObject() {\n\t\tString str = \"Luke\";\n\t\tassertThat(ObjectUtils.nullSafeHashCode(str)).isEqualTo(str.hashCode());\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithObjectArray() {\n\t\tObject[] array = {\"Leia\", \"Han\"};\n\t\tint actual = ObjectUtils.nullSafeHashCode(array);\n\t\tassertThat(actual).isEqualTo(Arrays.hashCode(array));\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithObjectArrayEqualToNull() {\n\t\tassertThat(ObjectUtils.nullSafeHashCode((Object[]) null)).isEqualTo(0);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithObjectBeingObjectArray() {\n\t\tObject array = new Object[] {\"Luke\", \"Anakin\"};\n\t\tint expected = ObjectUtils.nullSafeHashCode((Object[]) array);\n\t\tassertEqualHashCodes(expected, array);\n\t}\n\n\t@Test\n\t@Deprecated\n\tvoid nullSafeHashCodeWithObjectEqualToNull() {\n\t\tObject[] array = null;\n\t\tassertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithBooleanArray() {\n\t\tboolean[] array = {true, false};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{true, false}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithBooleanArrayBeingEmpty() {\n\t\tboolean[] array = {};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithBooleanArrayEqualToNull() {\n\t\tassertThat(ObjectUtils.nullSafeToString((boolean[]) null)).isEqualTo(\"null\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithByteArray() {\n\t\tbyte[] array = {5, 8};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{5, 8}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithByteArrayBeingEmpty() {\n\t\tbyte[] array = {};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithByteArrayEqualToNull() {\n\t\tassertThat(ObjectUtils.nullSafeToString((byte[]) null)).isEqualTo(\"null\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithCharArray() {\n\t\tchar[] array = {'A', 'B'};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{'A', 'B'}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithCharArrayBeingEmpty() {\n\t\tchar[] array = {};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithCharArrayEqualToNull() {\n\t\tassertThat(ObjectUtils.nullSafeToString((char[]) null)).isEqualTo(\"null\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithDoubleArray() {\n\t\tdouble[] array = {8594.93, 8594023.95};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{8594.93, 8594023.95}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithDoubleArrayBeingEmpty() {\n\t\tdouble[] array = {};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithDoubleArrayEqualToNull() {\n\t\tassertThat(ObjectUtils.nullSafeToString((double[]) null)).isEqualTo(\"null\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithFloatArray() {\n\t\tfloat[] array = {8.6f, 43.8f};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{8.6, 43.8}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithFloatArrayBeingEmpty() {\n\t\tfloat[] array = {};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithFloatArrayEqualToNull() {\n\t\tassertThat(ObjectUtils.nullSafeToString((float[]) null)).isEqualTo(\"null\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithIntArray() {\n\t\tint[] array = {9, 64};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{9, 64}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithIntArrayBeingEmpty() {\n\t\tint[] array = {};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithIntArrayEqualToNull() {\n\t\tassertThat(ObjectUtils.nullSafeToString((int[]) null)).isEqualTo(\"null\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithLongArray() {\n\t\tlong[] array = {434L, 23423L};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{434, 23423}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithLongArrayBeingEmpty() {\n\t\tlong[] array = {};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithLongArrayEqualToNull() {\n\t\tassertThat(ObjectUtils.nullSafeToString((long[]) null)).isEqualTo(\"null\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithPlainOldString() {\n\t\tassertThat(ObjectUtils.nullSafeToString(\"I shoh love tha taste of mangoes\")).isEqualTo(\"I shoh love tha taste of mangoes\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithObjectArray() {\n\t\tObject[] array = {\"Han\", 43L};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{Han, 43}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithObjectArrayBeingEmpty() {\n\t\tObject[] array = {};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithObjectArrayEqualToNull() {\n\t\tassertThat(ObjectUtils.nullSafeToString((Object[]) null)).isEqualTo(\"null\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithShortArray() {\n\t\tshort[] array = {7, 9};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{7, 9}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithShortArrayBeingEmpty() {\n\t\tshort[] array = {};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithShortArrayEqualToNull() {\n\t\tassertThat(ObjectUtils.nullSafeToString((short[]) null)).isEqualTo(\"null\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithStringArray() {\n\t\tString[] array = {\"Luke\", \"Anakin\"};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{Luke, Anakin}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithStringArrayBeingEmpty() {\n\t\tString[] array = {};\n\t\tassertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{}\");\n\t}\n\n\t@Test\n\tvoid nullSafeToStringWithStringArrayEqualToNull() {\n\t\tassertThat(ObjectUtils.nullSafeToString((String[]) null)).isEqualTo(\"null\");\n\t}\n\n\t@Test\n\tvoid containsConstant() {\n\t\tassertThat(ObjectUtils.containsConstant(Tropes.values(), \"FOO\")).isTrue();\n\t\tassertThat(ObjectUtils.containsConstant(Tropes.values(), \"foo\")).isTrue();\n\t\tassertThat(ObjectUtils.containsConstant(Tropes.values(), \"BaR\")).isTrue();\n\t\tassertThat(ObjectUtils.containsConstant(Tropes.values(), \"bar\")).isTrue();\n\t\tassertThat(ObjectUtils.containsConstant(Tropes.values(), \"BAZ\")).isTrue();\n\t\tassertThat(ObjectUtils.containsConstant(Tropes.values(), \"baz\")).isTrue();\n\n\t\tassertThat(ObjectUtils.containsConstant(Tropes.values(), \"BOGUS\")).isFalse();\n\n\t\tassertThat(ObjectUtils.containsConstant(Tropes.values(), \"FOO\", true)).isTrue();\n\t\tassertThat(ObjectUtils.containsConstant(Tropes.values(), \"foo\", true)).isFalse();\n\t}\n\n\t@Test\n\tvoid containsElement() {\n\t\tObject[] array = {\"foo\", \"bar\", 42, new String[] {\"baz\", \"quux\"}};\n\n\t\tassertThat(ObjectUtils.containsElement(null, \"foo\")).isFalse();\n\t\tassertThat(ObjectUtils.containsElement(array, null)).isFalse();\n\t\tassertThat(ObjectUtils.containsElement(array, \"bogus\")).isFalse();\n\n\t\tassertThat(ObjectUtils.containsElement(array, \"foo\")).isTrue();\n\t\tassertThat(ObjectUtils.containsElement(array, \"bar\")).isTrue();\n\t\tassertThat(ObjectUtils.containsElement(array, 42)).isTrue();\n\t\tassertThat(ObjectUtils.containsElement(array, new String[] {\"baz\", \"quux\"})).isTrue();\n\t}\n\n\t@Test\n\tvoid caseInsensitiveValueOf() {\n\t\tassertThat(ObjectUtils.caseInsensitiveValueOf(Tropes.values(), \"foo\")).isEqualTo(Tropes.FOO);\n\t\tassertThat(ObjectUtils.caseInsensitiveValueOf(Tropes.values(), \"BAR\")).isEqualTo(Tropes.BAR);\n\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tObjectUtils.caseInsensitiveValueOf(Tropes.values(), \"bogus\"))\n\t\t\t.withMessage(\"Constant [bogus] does not exist in enum type org.springframework.util.ObjectUtilsTests$Tropes\");\n\t}\n\n\n\tprivate static void assertEqualHashCodes(int expected, Object array) {\n\t\tint actual = ObjectUtils.nullSafeHashCode(array);\n\t\tassertThat(actual).isEqualTo(expected);\n\t\tassertThat(array.hashCode()).isNotEqualTo(actual);\n\t}\n\n\n\tenum Tropes {FOO, BAR, baz}\n\n\n\t@Nested\n\tclass NullSafeConciseToStringTests {\n\n\t\tprivate static final String truncated = \" (truncated)...\";\n\t\tprivate static final int truncatedLength = 100 + truncated.length();\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForNull() {\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(null)).isEqualTo(\"null\");\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForEmptyOptional() {\n\t\t\tOptional<String> optional = Optional.empty();\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(optional)).isEqualTo(\"Optional.empty\");\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForNonEmptyOptionals() {\n\t\t\tOptional<Tropes> optionalEnum = Optional.of(Tropes.BAR);\n\t\t\tString expected = \"Optional[BAR]\";\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(optionalEnum)).isEqualTo(expected);\n\n\t\t\tString repeat100 = \"X\".repeat(100);\n\t\t\tString repeat101 = \"X\".repeat(101);\n\n\t\t\tOptional<String> optionalString = Optional.of(repeat100);\n\t\t\texpected = \"Optional[%s]\".formatted(repeat100);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(optionalString)).isEqualTo(expected);\n\n\t\t\toptionalString = Optional.of(repeat101);\n\t\t\texpected = \"Optional[%s]\".formatted(repeat100 + truncated);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(optionalString)).isEqualTo(expected);\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForNonEmptyOptionalCustomType() {\n\t\t\tclass CustomType {\n\t\t\t}\n\n\t\t\tCustomType customType = new CustomType();\n\t\t\tOptional<CustomType> optional = Optional.of(customType);\n\t\t\tString expected = \"Optional[%s]\".formatted(ObjectUtils.nullSafeConciseToString(customType));\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(optional)).isEqualTo(expected);\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForClass() {\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(String.class)).isEqualTo(\"java.lang.String\");\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForStrings() {\n\t\t\tString repeat100 = \"X\".repeat(100);\n\t\t\tString repeat101 = \"X\".repeat(101);\n\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(\"\")).isEqualTo(\"\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(\"foo\")).isEqualTo(\"foo\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(repeat100)).isEqualTo(repeat100);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(repeat101)).hasSize(truncatedLength).endsWith(truncated);\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForStringBuilders() {\n\t\t\tString repeat100 = \"X\".repeat(100);\n\t\t\tString repeat101 = \"X\".repeat(101);\n\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new StringBuilder(\"foo\"))).isEqualTo(\"foo\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new StringBuilder(repeat100))).isEqualTo(repeat100);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new StringBuilder(repeat101))).hasSize(truncatedLength).endsWith(truncated);\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForEnum() {\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(Tropes.FOO)).isEqualTo(\"FOO\");\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForPrimitivesAndWrappers() {\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(true)).isEqualTo(\"true\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString('X')).isEqualTo(\"X\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(42L)).isEqualTo(\"42\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(99.1234D)).isEqualTo(\"99.1234\");\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForBigNumbers() {\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(BigInteger.valueOf(42L))).isEqualTo(\"42\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(BigDecimal.valueOf(99.1234D))).isEqualTo(\"99.1234\");\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForDate() {\n\t\t\tDate date = new Date();\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(date)).isEqualTo(date.toString());\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForTemporal() {\n\t\t\tLocalDate localDate = LocalDate.now();\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(localDate)).isEqualTo(localDate.toString());\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForUUID() {\n\t\t\tUUID id = UUID.randomUUID();\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(id)).isEqualTo(id.toString());\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForFile() {\n\t\t\tString path = \"/tmp/file.txt\".replace('/', File.separatorChar);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new File(path))).isEqualTo(path);\n\n\t\t\tpath = (\"/tmp/\" + \"xyz\".repeat(32)).replace('/', File.separatorChar);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new File(path)))\n\t\t\t\t\t.hasSize(truncatedLength)\n\t\t\t\t\t.startsWith(path.subSequence(0, 100))\n\t\t\t\t\t.endsWith(truncated);\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForPath() {\n\t\t\tString path = \"/tmp/file.txt\".replace('/', File.separatorChar);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(Path.of(path))).isEqualTo(path);\n\n\t\t\tpath = (\"/tmp/\" + \"xyz\".repeat(32)).replace('/', File.separatorChar);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(Path.of(path)))\n\t\t\t\t\t.hasSize(truncatedLength)\n\t\t\t\t\t.startsWith(path.subSequence(0, 100))\n\t\t\t\t\t.endsWith(truncated);\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForURI() {\n\t\t\tString uri = \"https://www.example.com/?foo=1&bar=2&baz=3\";\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(URI.create(uri))).isEqualTo(uri);\n\n\t\t\turi += \"&qux=\" + \"4\".repeat(60);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(URI.create(uri)))\n\t\t\t\t\t.hasSize(truncatedLength)\n\t\t\t\t\t.startsWith(uri.subSequence(0, 100))\n\t\t\t\t\t.endsWith(truncated);\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForURL() throws Exception {\n\t\t\tString url = \"https://www.example.com/?foo=1&bar=2&baz=3\";\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new URL(url))).isEqualTo(url);\n\n\t\t\turl += \"&qux=\" + \"4\".repeat(60);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new URL(url)))\n\t\t\t\t\t.hasSize(truncatedLength)\n\t\t\t\t\t.startsWith(url.subSequence(0, 100))\n\t\t\t\t\t.endsWith(truncated);\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForInetAddress() {\n\t\t\tInetAddress localhost = getLocalhost();\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(localhost)).isEqualTo(localhost.toString());\n\t\t}\n\n\t\tprivate static InetAddress getLocalhost() {\n\t\t\ttry {\n\t\t\t\treturn InetAddress.getLocalHost();\n\t\t\t}\n\t\t\tcatch (UnknownHostException ex) {\n\t\t\t\treturn InetAddress.getLoopbackAddress();\n\t\t\t}\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForCharset() {\n\t\t\tCharset charset = StandardCharsets.UTF_8;\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(charset)).isEqualTo(charset.name());\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForCurrency() {\n\t\t\tCurrency currency = Currency.getInstance(Locale.US);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(currency)).isEqualTo(currency.toString());\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForLocale() {\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(Locale.GERMANY)).isEqualTo(\"de_DE\");\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForRegExPattern() {\n\t\t\tPattern pattern = Pattern.compile(\"^(foo|bar)$\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(pattern)).isEqualTo(pattern.toString());\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForTimeZone() {\n\t\t\tTimeZone timeZone = TimeZone.getDefault();\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(timeZone)).isEqualTo(timeZone.getID());\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForZoneId() {\n\t\t\tZoneId zoneId = ZoneId.systemDefault();\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(zoneId)).isEqualTo(zoneId.getId());\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForEmptyArrays() {\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new char[] {})).isEqualTo(\"{}\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new int[][] {})).isEqualTo(\"{}\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new String[] {})).isEqualTo(\"{}\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new Integer[][] {})).isEqualTo(\"{}\");\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForNonEmptyArrays() {\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new char[] {'a'})).isEqualTo(\"{...}\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new int[][] {{1}, {2}})).isEqualTo(\"{...}\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new String[] {\"enigma\"})).isEqualTo(\"{...}\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(new Integer[][] {{1}, {2}})).isEqualTo(\"{...}\");\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForEmptyCollections() {\n\t\t\tList<String> list = List.of();\n\t\t\tSet<Integer> set = Set.of();\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(list)).isEqualTo(\"[...]\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(set)).isEqualTo(\"[...]\");\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForNonEmptyCollections() {\n\t\t\tList<String> list = List.of(\"a\", \"b\");\n\t\t\tSet<Integer> set = Set.of(1);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(list)).isEqualTo(\"[...]\");\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(set)).isEqualTo(\"[...]\");\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForEmptyMaps() {\n\t\t\tMap<String, String> map = Map.of();\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(map)).isEqualTo(\"{...}\");\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForNonEmptyMaps() {\n\t\t\tMap<String, Integer> map = Map.of(\"a\", 1, \"b\", 2, \"c\", 3);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(map)).isEqualTo(\"{...}\");\n\t\t}\n\n\t\t@Test\n\t\tvoid nullSafeConciseToStringForCustomTypes() {\n\t\t\tclass ExplosiveType {\n\t\t\t\t@Override\n\t\t\t\tpublic String toString() {\n\t\t\t\t\tthrow new UnsupportedOperationException(\"no-go\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tExplosiveType explosiveType = new ExplosiveType();\n\t\t\tassertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(explosiveType::toString);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(explosiveType)).startsWith(prefix(ExplosiveType.class));\n\n\t\t\tclass WordyType {\n\t\t\t\t@Override\n\t\t\t\tpublic String toString() {\n\t\t\t\t\treturn \"blah blah\".repeat(20);\n\t\t\t\t}\n\t\t\t}\n\t\t\tWordyType wordyType = new WordyType();\n\t\t\tassertThat(wordyType).asString().hasSizeGreaterThanOrEqualTo(180 /* 9x20 */);\n\t\t\tassertThat(ObjectUtils.nullSafeConciseToString(wordyType)).startsWith(prefix(WordyType.class));\n\t\t}\n\n\t\tprivate static String prefix(Class<?> clazz) {\n\t\t\treturn clazz.getTypeName() + \"@\";\n\t\t}\n\t}\n\n\t@Test\n\tvoid unwrapOptional() {\n\n\t\tassertThat(ObjectUtils.unwrapOptional(null)).isNull();\n\t\tassertThat(ObjectUtils.unwrapOptional(\"some value\")).isEqualTo(\"some value\");\n\t\tassertThat(ObjectUtils.unwrapOptional(Optional.empty())).isNull();\n\t\tassertThat(ObjectUtils.unwrapOptional(Optional.of(\"some value\"))).isEqualTo(\"some value\");\n\n\t\tOptional<Optional<Object>> nestedEmptyOptional = Optional.of(Optional.empty());\n\t\tassertThatIllegalArgumentException()\n\t\t\t.isThrownBy(() -> ObjectUtils.unwrapOptional(nestedEmptyOptional))\n\t\t\t.withMessage(\"Multi-level Optional usage not supported\");\n\n\t\tOptional<Optional<String>> nestedStringOptional = Optional.of(Optional.of(\"some value\"));\n\t\tassertThatIllegalArgumentException()\n\t\t\t.isThrownBy(() -> ObjectUtils.unwrapOptional(nestedStringOptional))\n\t\t\t.withMessage(\"Multi-level Optional usage not supported\");\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.WordyType#toString()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic String toString() {\r\n    return \"blah blah\".repeat(20);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.WordyType",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.WordyType#toString()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.WordyType#toString()",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.asm",
    "tailType": "package"
  },
  {
    "head": "org.springframework.asm",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.asm.AnnotationWriter",
    "tailType": "class"
  },
  {
    "head": "org.springframework.asm.AnnotationWriter",
    "headType": "class",
    "relation": "provide",
    "tail": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage org.springframework.asm;\n\n/**\n * An {@link AnnotationVisitor} that generates a corresponding 'annotation' or 'type_annotation'\n * structure, as defined in the Java Virtual Machine Specification (JVMS). AnnotationWriter\n * instances can be chained in a doubly linked list, from which Runtime[In]Visible[Type]Annotations\n * attributes can be generated with the {@link #putAnnotations} method. Similarly, arrays of such\n * lists can be used to generate Runtime[In]VisibleParameterAnnotations attributes.\n *\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16\">JVMS\n *     4.7.16</a>\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20\">JVMS\n *     4.7.20</a>\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n */\nfinal class AnnotationWriter extends AnnotationVisitor {\n\n  /** Where the constants used in this AnnotationWriter must be stored. */\n  private final SymbolTable symbolTable;\n\n  /**\n   * Whether values are named or not. AnnotationWriter instances used for annotation default and\n   * annotation arrays use unnamed values (i.e. they generate an 'element_value' structure for each\n   * value, instead of an element_name_index followed by an element_value).\n   */\n  private final boolean useNamedValues;\n\n  /**\n   * The 'annotation' or 'type_annotation' JVMS structure corresponding to the annotation values\n   * visited so far. All the fields of these structures, except the last one - the\n   * element_value_pairs array, must be set before this ByteVector is passed to the constructor\n   * (num_element_value_pairs can be set to 0, it is reset to the correct value in {@link\n   * #visitEnd()}). The element_value_pairs array is filled incrementally in the various visit()\n   * methods.\n   *\n   * <p>Note: as an exception to the above rules, for AnnotationDefault attributes (which contain a\n   * single element_value by definition), this ByteVector is initially empty when passed to the\n   * constructor, and {@link #numElementValuePairsOffset} is set to -1.\n   */\n  private final ByteVector annotation;\n\n  /**\n   * The offset in {@link #annotation} where {@link #numElementValuePairs} must be stored (or -1 for\n   * the case of AnnotationDefault attributes).\n   */\n  private final int numElementValuePairsOffset;\n\n  /** The number of element value pairs visited so far. */\n  private int numElementValuePairs;\n\n  /**\n   * The previous AnnotationWriter. This field is used to store the list of annotations of a\n   * Runtime[In]Visible[Type]Annotations attribute. It is unused for nested or array annotations\n   * (annotation values of annotation type), or for AnnotationDefault attributes.\n   */\n  private final AnnotationWriter previousAnnotation;\n\n  /**\n   * The next AnnotationWriter. This field is used to store the list of annotations of a\n   * Runtime[In]Visible[Type]Annotations attribute. It is unused for nested or array annotations\n   * (annotation values of annotation type), or for AnnotationDefault attributes.\n   */\n  private AnnotationWriter nextAnnotation;\n\n  // -----------------------------------------------------------------------------------------------\n  // Constructors and factories\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Constructs a new {@link AnnotationWriter}.\n   *\n   * @param symbolTable where the constants used in this AnnotationWriter must be stored.\n   * @param useNamedValues whether values are named or not. AnnotationDefault and annotation arrays\n   *     use unnamed values.\n   * @param annotation where the 'annotation' or 'type_annotation' JVMS structure corresponding to\n   *     the visited content must be stored. This ByteVector must already contain all the fields of\n   *     the structure except the last one (the element_value_pairs array).\n   * @param previousAnnotation the previously visited annotation of the\n   *     Runtime[In]Visible[Type]Annotations attribute to which this annotation belongs, or\n   *     {@literal null} in other cases (for example, nested or array annotations).\n   */\n  AnnotationWriter(\n      final SymbolTable symbolTable,\n      final boolean useNamedValues,\n      final ByteVector annotation,\n      final AnnotationWriter previousAnnotation) {\n    super(/* latest api = */ Opcodes.ASM9);\n    this.symbolTable = symbolTable;\n    this.useNamedValues = useNamedValues;\n    this.annotation = annotation;\n    // By hypothesis, num_element_value_pairs is stored in the last unsigned short of 'annotation'.\n    this.numElementValuePairsOffset = annotation.length == 0 ? -1 : annotation.length - 2;\n    this.previousAnnotation = previousAnnotation;\n    if (previousAnnotation != null) {\n      previousAnnotation.nextAnnotation = this;\n    }\n  }\n\n  /**\n   * Creates a new {@link AnnotationWriter} using named values.\n   *\n   * @param symbolTable where the constants used in this AnnotationWriter must be stored.\n   * @param descriptor the class descriptor of the annotation class.\n   * @param previousAnnotation the previously visited annotation of the\n   *     Runtime[In]Visible[Type]Annotations attribute to which this annotation belongs, or\n   *     {@literal null} in other cases (for example, nested or array annotations).\n   * @return a new {@link AnnotationWriter} for the given annotation descriptor.\n   */\n  static AnnotationWriter create(\n      final SymbolTable symbolTable,\n      final String descriptor,\n      final AnnotationWriter previousAnnotation) {\n    // Create a ByteVector to hold an 'annotation' JVMS structure.\n    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16.\n    ByteVector annotation = new ByteVector();\n    // Write type_index and reserve space for num_element_value_pairs.\n    annotation.putShort(symbolTable.addConstantUtf8(descriptor)).putShort(0);\n    return new AnnotationWriter(\n        symbolTable, /* useNamedValues= */ true, annotation, previousAnnotation);\n  }\n\n  /**\n   * Creates a new {@link AnnotationWriter} using named values.\n   *\n   * @param symbolTable where the constants used in this AnnotationWriter must be stored.\n   * @param typeRef a reference to the annotated type. The sort of this type reference must be\n   *     {@link TypeReference#CLASS_TYPE_PARAMETER}, {@link\n   *     TypeReference#CLASS_TYPE_PARAMETER_BOUND} or {@link TypeReference#CLASS_EXTENDS}. See\n   *     {@link TypeReference}.\n   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\n   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\n   *     'typeRef' as a whole.\n   * @param descriptor the class descriptor of the annotation class.\n   * @param previousAnnotation the previously visited annotation of the\n   *     Runtime[In]Visible[Type]Annotations attribute to which this annotation belongs, or\n   *     {@literal null} in other cases (for example, nested or array annotations).\n   * @return a new {@link AnnotationWriter} for the given type annotation reference and descriptor.\n   */\n  static AnnotationWriter create(\n      final SymbolTable symbolTable,\n      final int typeRef,\n      final TypePath typePath,\n      final String descriptor,\n      final AnnotationWriter previousAnnotation) {\n    // Create a ByteVector to hold a 'type_annotation' JVMS structure.\n    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20.\n    ByteVector typeAnnotation = new ByteVector();\n    // Write target_type, target_info, and target_path.\n    TypeReference.putTarget(typeRef, typeAnnotation);\n    TypePath.put(typePath, typeAnnotation);\n    // Write type_index and reserve space for num_element_value_pairs.\n    typeAnnotation.putShort(symbolTable.addConstantUtf8(descriptor)).putShort(0);\n    return new AnnotationWriter(\n        symbolTable, /* useNamedValues= */ true, typeAnnotation, previousAnnotation);\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Implementation of the AnnotationVisitor abstract class\n  // -----------------------------------------------------------------------------------------------\n\n  @Override\n  public void visit(final String name, final Object value) {\n    // Case of an element_value with a const_value_index, class_info_index or array_index field.\n    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16.1.\n    ++numElementValuePairs;\n    if (useNamedValues) {\n      annotation.putShort(symbolTable.addConstantUtf8(name));\n    }\n    if (value instanceof String) {\n      annotation.put12('s', symbolTable.addConstantUtf8((String) value));\n    } else if (value instanceof Byte) {\n      annotation.put12('B', symbolTable.addConstantInteger(((Byte) value).byteValue()).index);\n    } else if (value instanceof Boolean) {\n      int booleanValue = ((Boolean) value).booleanValue() ? 1 : 0;\n      annotation.put12('Z', symbolTable.addConstantInteger(booleanValue).index);\n    } else if (value instanceof Character) {\n      annotation.put12('C', symbolTable.addConstantInteger(((Character) value).charValue()).index);\n    } else if (value instanceof Short) {\n      annotation.put12('S', symbolTable.addConstantInteger(((Short) value).shortValue()).index);\n    } else if (value instanceof Type) {\n      annotation.put12('c', symbolTable.addConstantUtf8(((Type) value).getDescriptor()));\n    } else if (value instanceof byte[]) {\n      byte[] byteArray = (byte[]) value;\n      annotation.put12('[', byteArray.length);\n      for (byte byteValue : byteArray) {\n        annotation.put12('B', symbolTable.addConstantInteger(byteValue).index);\n      }\n    } else if (value instanceof boolean[]) {\n      boolean[] booleanArray = (boolean[]) value;\n      annotation.put12('[', booleanArray.length);\n      for (boolean booleanValue : booleanArray) {\n        annotation.put12('Z', symbolTable.addConstantInteger(booleanValue ? 1 : 0).index);\n      }\n    } else if (value instanceof short[]) {\n      short[] shortArray = (short[]) value;\n      annotation.put12('[', shortArray.length);\n      for (short shortValue : shortArray) {\n        annotation.put12('S', symbolTable.addConstantInteger(shortValue).index);\n      }\n    } else if (value instanceof char[]) {\n      char[] charArray = (char[]) value;\n      annotation.put12('[', charArray.length);\n      for (char charValue : charArray) {\n        annotation.put12('C', symbolTable.addConstantInteger(charValue).index);\n      }\n    } else if (value instanceof int[]) {\n      int[] intArray = (int[]) value;\n      annotation.put12('[', intArray.length);\n      for (int intValue : intArray) {\n        annotation.put12('I', symbolTable.addConstantInteger(intValue).index);\n      }\n    } else if (value instanceof long[]) {\n      long[] longArray = (long[]) value;\n      annotation.put12('[', longArray.length);\n      for (long longValue : longArray) {\n        annotation.put12('J', symbolTable.addConstantLong(longValue).index);\n      }\n    } else if (value instanceof float[]) {\n      float[] floatArray = (float[]) value;\n      annotation.put12('[', floatArray.length);\n      for (float floatValue : floatArray) {\n        annotation.put12('F', symbolTable.addConstantFloat(floatValue).index);\n      }\n    } else if (value instanceof double[]) {\n      double[] doubleArray = (double[]) value;\n      annotation.put12('[', doubleArray.length);\n      for (double doubleValue : doubleArray) {\n        annotation.put12('D', symbolTable.addConstantDouble(doubleValue).index);\n      }\n    } else {\n      Symbol symbol = symbolTable.addConstant(value);\n      annotation.put12(\".s.IFJDCS\".charAt(symbol.tag), symbol.index);\n    }\n  }\n\n  @Override\n  public void visitEnum(final String name, final String descriptor, final String value) {\n    // Case of an element_value with an enum_const_value field.\n    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16.1.\n    ++numElementValuePairs;\n    if (useNamedValues) {\n      annotation.putShort(symbolTable.addConstantUtf8(name));\n    }\n    annotation\n        .put12('e', symbolTable.addConstantUtf8(descriptor))\n        .putShort(symbolTable.addConstantUtf8(value));\n  }\n\n  @Override\n  public AnnotationVisitor visitAnnotation(final String name, final String descriptor) {\n    // Case of an element_value with an annotation_value field.\n    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16.1.\n    ++numElementValuePairs;\n    if (useNamedValues) {\n      annotation.putShort(symbolTable.addConstantUtf8(name));\n    }\n    // Write tag and type_index, and reserve 2 bytes for num_element_value_pairs.\n    annotation.put12('@', symbolTable.addConstantUtf8(descriptor)).putShort(0);\n    return new AnnotationWriter(symbolTable, /* useNamedValues= */ true, annotation, null);\n  }\n\n  @Override\n  public AnnotationVisitor visitArray(final String name) {\n    // Case of an element_value with an array_value field.\n    // https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16.1\n    ++numElementValuePairs;\n    if (useNamedValues) {\n      annotation.putShort(symbolTable.addConstantUtf8(name));\n    }\n    // Write tag, and reserve 2 bytes for num_values. Here we take advantage of the fact that the\n    // end of an element_value of array type is similar to the end of an 'annotation' structure: an\n    // unsigned short num_values followed by num_values element_value, versus an unsigned short\n    // num_element_value_pairs, followed by num_element_value_pairs { element_name_index,\n    // element_value } tuples. This allows us to use an AnnotationWriter with unnamed values to\n    // visit the array elements. Its num_element_value_pairs will correspond to the number of array\n    // elements and will be stored in what is in fact num_values.\n    annotation.put12('[', 0);\n    return new AnnotationWriter(symbolTable, /* useNamedValues= */ false, annotation, null);\n  }\n\n  @Override\n  public void visitEnd() {\n    if (numElementValuePairsOffset != -1) {\n      byte[] data = annotation.data;\n      data[numElementValuePairsOffset] = (byte) (numElementValuePairs >>> 8);\n      data[numElementValuePairsOffset + 1] = (byte) numElementValuePairs;\n    }\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Utility methods\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Returns the size of a Runtime[In]Visible[Type]Annotations attribute containing this annotation\n   * and all its <i>predecessors</i> (see {@link #previousAnnotation}. Also adds the attribute name\n   * to the constant pool of the class (if not null).\n   *\n   * @param attributeName one of \"Runtime[In]Visible[Type]Annotations\", or {@literal null}.\n   * @return the size in bytes of a Runtime[In]Visible[Type]Annotations attribute containing this\n   *     annotation and all its predecessors. This includes the size of the attribute_name_index and\n   *     attribute_length fields.\n   */\n  int computeAnnotationsSize(final String attributeName) {\n    if (attributeName != null) {\n      symbolTable.addConstantUtf8(attributeName);\n    }\n    // The attribute_name_index, attribute_length and num_annotations fields use 8 bytes.\n    int attributeSize = 8;\n    AnnotationWriter annotationWriter = this;\n    while (annotationWriter != null) {\n      attributeSize += annotationWriter.annotation.length;\n      annotationWriter = annotationWriter.previousAnnotation;\n    }\n    return attributeSize;\n  }\n\n  /**\n   * Returns the size of the Runtime[In]Visible[Type]Annotations attributes containing the given\n   * annotations and all their <i>predecessors</i> (see {@link #previousAnnotation}. Also adds the\n   * attribute names to the constant pool of the class (if not null).\n   *\n   * @param lastRuntimeVisibleAnnotation The last runtime visible annotation of a field, method or\n   *     class. The previous ones can be accessed with the {@link #previousAnnotation} field. May be\n   *     {@literal null}.\n   * @param lastRuntimeInvisibleAnnotation The last runtime invisible annotation of this a field,\n   *     method or class. The previous ones can be accessed with the {@link #previousAnnotation}\n   *     field. May be {@literal null}.\n   * @param lastRuntimeVisibleTypeAnnotation The last runtime visible type annotation of this a\n   *     field, method or class. The previous ones can be accessed with the {@link\n   *     #previousAnnotation} field. May be {@literal null}.\n   * @param lastRuntimeInvisibleTypeAnnotation The last runtime invisible type annotation of a\n   *     field, method or class field. The previous ones can be accessed with the {@link\n   *     #previousAnnotation} field. May be {@literal null}.\n   * @return the size in bytes of a Runtime[In]Visible[Type]Annotations attribute containing the\n   *     given annotations and all their predecessors. This includes the size of the\n   *     attribute_name_index and attribute_length fields.\n   */\n  static int computeAnnotationsSize(\n      final AnnotationWriter lastRuntimeVisibleAnnotation,\n      final AnnotationWriter lastRuntimeInvisibleAnnotation,\n      final AnnotationWriter lastRuntimeVisibleTypeAnnotation,\n      final AnnotationWriter lastRuntimeInvisibleTypeAnnotation) {\n    int size = 0;\n    if (lastRuntimeVisibleAnnotation != null) {\n      size +=\n          lastRuntimeVisibleAnnotation.computeAnnotationsSize(\n              Constants.RUNTIME_VISIBLE_ANNOTATIONS);\n    }\n    if (lastRuntimeInvisibleAnnotation != null) {\n      size +=\n          lastRuntimeInvisibleAnnotation.computeAnnotationsSize(\n              Constants.RUNTIME_INVISIBLE_ANNOTATIONS);\n    }\n    if (lastRuntimeVisibleTypeAnnotation != null) {\n      size +=\n          lastRuntimeVisibleTypeAnnotation.computeAnnotationsSize(\n              Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\n    }\n    if (lastRuntimeInvisibleTypeAnnotation != null) {\n      size +=\n          lastRuntimeInvisibleTypeAnnotation.computeAnnotationsSize(\n              Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\n    }\n    return size;\n  }\n\n  /**\n   * Puts a Runtime[In]Visible[Type]Annotations attribute containing this annotations and all its\n   * <i>predecessors</i> (see {@link #previousAnnotation} in the given ByteVector. Annotations are\n   * put in the same order they have been visited.\n   *\n   * @param attributeNameIndex the constant pool index of the attribute name (one of\n   *     \"Runtime[In]Visible[Type]Annotations\").\n   * @param output where the attribute must be put.\n   */\n  void putAnnotations(final int attributeNameIndex, final ByteVector output) {\n    int attributeLength = 2; // For num_annotations.\n    int numAnnotations = 0;\n    AnnotationWriter annotationWriter = this;\n    AnnotationWriter firstAnnotation = null;\n    while (annotationWriter != null) {\n      // In case the user forgot to call visitEnd().\n      annotationWriter.visitEnd();\n      attributeLength += annotationWriter.annotation.length;\n      numAnnotations++;\n      firstAnnotation = annotationWriter;\n      annotationWriter = annotationWriter.previousAnnotation;\n    }\n    output.putShort(attributeNameIndex);\n    output.putInt(attributeLength);\n    output.putShort(numAnnotations);\n    annotationWriter = firstAnnotation;\n    while (annotationWriter != null) {\n      output.putByteArray(annotationWriter.annotation.data, 0, annotationWriter.annotation.length);\n      annotationWriter = annotationWriter.nextAnnotation;\n    }\n  }\n\n  /**\n   * Puts the Runtime[In]Visible[Type]Annotations attributes containing the given annotations and\n   * all their <i>predecessors</i> (see {@link #previousAnnotation} in the given ByteVector.\n   * Annotations are put in the same order they have been visited.\n   *\n   * @param symbolTable where the constants used in the AnnotationWriter instances are stored.\n   * @param lastRuntimeVisibleAnnotation The last runtime visible annotation of a field, method or\n   *     class. The previous ones can be accessed with the {@link #previousAnnotation} field. May be\n   *     {@literal null}.\n   * @param lastRuntimeInvisibleAnnotation The last runtime invisible annotation of this a field,\n   *     method or class. The previous ones can be accessed with the {@link #previousAnnotation}\n   *     field. May be {@literal null}.\n   * @param lastRuntimeVisibleTypeAnnotation The last runtime visible type annotation of this a\n   *     field, method or class. The previous ones can be accessed with the {@link\n   *     #previousAnnotation} field. May be {@literal null}.\n   * @param lastRuntimeInvisibleTypeAnnotation The last runtime invisible type annotation of a\n   *     field, method or class field. The previous ones can be accessed with the {@link\n   *     #previousAnnotation} field. May be {@literal null}.\n   * @param output where the attributes must be put.\n   */\n  static void putAnnotations(\n      final SymbolTable symbolTable,\n      final AnnotationWriter lastRuntimeVisibleAnnotation,\n      final AnnotationWriter lastRuntimeInvisibleAnnotation,\n      final AnnotationWriter lastRuntimeVisibleTypeAnnotation,\n      final AnnotationWriter lastRuntimeInvisibleTypeAnnotation,\n      final ByteVector output) {\n    if (lastRuntimeVisibleAnnotation != null) {\n      lastRuntimeVisibleAnnotation.putAnnotations(\n          symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_ANNOTATIONS), output);\n    }\n    if (lastRuntimeInvisibleAnnotation != null) {\n      lastRuntimeInvisibleAnnotation.putAnnotations(\n          symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_ANNOTATIONS), output);\n    }\n    if (lastRuntimeVisibleTypeAnnotation != null) {\n      lastRuntimeVisibleTypeAnnotation.putAnnotations(\n          symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS), output);\n    }\n    if (lastRuntimeInvisibleTypeAnnotation != null) {\n      lastRuntimeInvisibleTypeAnnotation.putAnnotations(\n          symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS), output);\n    }\n  }\n\n  /**\n   * Returns the size of a Runtime[In]VisibleParameterAnnotations attribute containing all the\n   * annotation lists from the given AnnotationWriter sub-array. Also adds the attribute name to the\n   * constant pool of the class.\n   *\n   * @param attributeName one of \"Runtime[In]VisibleParameterAnnotations\".\n   * @param annotationWriters an array of AnnotationWriter lists (designated by their <i>last</i>\n   *     element).\n   * @param annotableParameterCount the number of elements in annotationWriters to take into account\n   *     (elements [0..annotableParameterCount[ are taken into account).\n   * @return the size in bytes of a Runtime[In]VisibleParameterAnnotations attribute corresponding\n   *     to the given sub-array of AnnotationWriter lists. This includes the size of the\n   *     attribute_name_index and attribute_length fields.\n   */\n  static int computeParameterAnnotationsSize(\n      final String attributeName,\n      final AnnotationWriter[] annotationWriters,\n      final int annotableParameterCount) {\n    // Note: attributeName is added to the constant pool by the call to computeAnnotationsSize\n    // below. This assumes that there is at least one non-null element in the annotationWriters\n    // sub-array (which is ensured by the lazy instantiation of this array in MethodWriter).\n    // The attribute_name_index, attribute_length and num_parameters fields use 7 bytes, and each\n    // element of the parameter_annotations array uses 2 bytes for its num_annotations field.\n    int attributeSize = 7 + 2 * annotableParameterCount;\n    for (int i = 0; i < annotableParameterCount; ++i) {\n      AnnotationWriter annotationWriter = annotationWriters[i];\n      attributeSize +=\n          annotationWriter == null ? 0 : annotationWriter.computeAnnotationsSize(attributeName) - 8;\n    }\n    return attributeSize;\n  }\n\n  /**\n   * Puts a Runtime[In]VisibleParameterAnnotations attribute containing all the annotation lists\n   * from the given AnnotationWriter sub-array in the given ByteVector.\n   *\n   * @param attributeNameIndex constant pool index of the attribute name (one of\n   *     Runtime[In]VisibleParameterAnnotations).\n   * @param annotationWriters an array of AnnotationWriter lists (designated by their <i>last</i>\n   *     element).\n   * @param annotableParameterCount the number of elements in annotationWriters to put (elements\n   *     [0..annotableParameterCount[ are put).\n   * @param output where the attribute must be put.\n   */\n  static void putParameterAnnotations(\n      final int attributeNameIndex,\n      final AnnotationWriter[] annotationWriters,\n      final int annotableParameterCount,\n      final ByteVector output) {\n    // The num_parameters field uses 1 byte, and each element of the parameter_annotations array\n    // uses 2 bytes for its num_annotations field.\n    int attributeLength = 1 + 2 * annotableParameterCount;\n    for (int i = 0; i < annotableParameterCount; ++i) {\n      AnnotationWriter annotationWriter = annotationWriters[i];\n      attributeLength +=\n          annotationWriter == null ? 0 : annotationWriter.computeAnnotationsSize(null) - 8;\n    }\n    output.putShort(attributeNameIndex);\n    output.putInt(attributeLength);\n    output.putByte(annotableParameterCount);\n    for (int i = 0; i < annotableParameterCount; ++i) {\n      AnnotationWriter annotationWriter = annotationWriters[i];\n      AnnotationWriter firstAnnotation = null;\n      int numAnnotations = 0;\n      while (annotationWriter != null) {\n        // In case user the forgot to call visitEnd().\n        annotationWriter.visitEnd();\n        numAnnotations++;\n        firstAnnotation = annotationWriter;\n        annotationWriter = annotationWriter.previousAnnotation;\n      }\n      output.putShort(numAnnotations);\n      annotationWriter = firstAnnotation;\n      while (annotationWriter != null) {\n        output.putByteArray(\n            annotationWriter.annotation.data, 0, annotationWriter.annotation.length);\n        annotationWriter = annotationWriter.nextAnnotation;\n      }\n    }\n  }\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.asm.AnnotationWriter",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.AnnotationWriter#symbolTable",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.AnnotationWriter#symbolTable",
    "headType": "field",
    "relation": "haveType",
    "tail": "SymbolTable",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.AnnotationWriter",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.AnnotationWriter#useNamedValues",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.AnnotationWriter#useNamedValues",
    "headType": "field",
    "relation": "haveType",
    "tail": "boolean",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.AnnotationWriter",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.AnnotationWriter#annotation",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.AnnotationWriter#annotation",
    "headType": "field",
    "relation": "haveType",
    "tail": "ByteVector",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.AnnotationWriter",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.AnnotationWriter#numElementValuePairsOffset",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.AnnotationWriter#numElementValuePairsOffset",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  }
]