[
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.testfixture.env",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core.testfixture.env",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.testfixture.env.MockPropertySource",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.testfixture.env.MockPropertySource",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.testfixture.env;\n\nimport java.util.Properties;\n\nimport org.springframework.core.env.PropertiesPropertySource;\nimport org.springframework.core.env.PropertySource;\n\n/**\n * Simple {@link PropertySource} implementation for use in testing. Accepts\n * a user-provided {@link Properties} object, or if omitted during construction,\n * the implementation will initialize its own.\n *\n * The {@link #setProperty} and {@link #withProperty} methods are exposed for\n * convenience, for example:\n * <pre class=\"code\">\n * {@code\n *   PropertySource<?> source = new MockPropertySource().withProperty(\"foo\", \"bar\");\n * }\n * </pre>\n *\n * @author Chris Beams\n * @since 3.1\n * @see org.springframework.mock.env.MockEnvironment\n */\npublic class MockPropertySource extends PropertiesPropertySource {\n\n\t/**\n\t * {@value} is the default name for {@link MockPropertySource} instances not\n\t * otherwise given an explicit name.\n\t * @see #MockPropertySource()\n\t * @see #MockPropertySource(String)\n\t */\n\tpublic static final String MOCK_PROPERTIES_PROPERTY_SOURCE_NAME = \"mockProperties\";\n\n\n\t/**\n\t * Create a new {@code MockPropertySource} named {@value #MOCK_PROPERTIES_PROPERTY_SOURCE_NAME}\n\t * that will maintain its own internal {@link Properties} instance.\n\t */\n\tpublic MockPropertySource() {\n\t\tthis(new Properties());\n\t}\n\n\t/**\n\t * Create a new {@code MockPropertySource} with the given name that will\n\t * maintain its own internal {@link Properties} instance.\n\t * @param name the {@linkplain #getName() name} of the property source\n\t */\n\tpublic MockPropertySource(String name) {\n\t\tthis(name, new Properties());\n\t}\n\n\t/**\n\t * Create a new {@code MockPropertySource} named {@value #MOCK_PROPERTIES_PROPERTY_SOURCE_NAME}\n\t * and backed by the given {@link Properties} object.\n\t * @param properties the properties to use\n\t */\n\tpublic MockPropertySource(Properties properties) {\n\t\tthis(MOCK_PROPERTIES_PROPERTY_SOURCE_NAME, properties);\n\t}\n\n\t/**\n\t * Create a new {@code MockPropertySource} with the given name and backed by the given\n\t * {@link Properties} object.\n\t * @param name the {@linkplain #getName() name} of the property source\n\t * @param properties the properties to use\n\t */\n\tpublic MockPropertySource(String name, Properties properties) {\n\t\tsuper(name, properties);\n\t}\n\n\n\t/**\n\t * Set the given property on the underlying {@link Properties} object.\n\t */\n\tpublic void setProperty(String name, Object value) {\n\t\tthis.source.put(name, value);\n\t}\n\n\t/**\n\t * Convenient synonym for {@link #setProperty} that returns the current instance.\n\t * Useful for method chaining and fluent-style use.\n\t * @return this {@link MockPropertySource} instance\n\t */\n\tpublic MockPropertySource withProperty(String name, Object value) {\n\t\tsetProperty(name, value);\n\t\treturn this;\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.testfixture.env.MockPropertySource",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.testfixture.env.MockPropertySource#MOCK_PROPERTIES_PROPERTY_SOURCE_NAME",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.testfixture.env.MockPropertySource#MOCK_PROPERTIES_PROPERTY_SOURCE_NAME",
    "headType": "field",
    "relation": "haveType",
    "tail": "String",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.testfixture.env.MockPropertySource#setProperty(String,Object)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Set the given property on the underlying {@link Properties} object.\r\n */\r\npublic void setProperty(String name, Object value) {\r\n    this.source.put(name, value);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.testfixture.env.MockPropertySource",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.testfixture.env.MockPropertySource#setProperty(String,Object)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.testfixture.env.MockPropertySource#withProperty(String,Object)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Convenient synonym for {@link #setProperty} that returns the current instance.\r\n * Useful for method chaining and fluent-style use.\r\n * @return this {@link MockPropertySource} instance\r\n */\r\npublic MockPropertySource withProperty(String name, Object value) {\r\n    setProperty(name, value);\r\n    return this;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.testfixture.env.MockPropertySource",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.testfixture.env.MockPropertySource#withProperty(String,Object)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.testfixture.env.MockPropertySource",
    "headType": "class",
    "relation": "extend",
    "tail": "PropertiesPropertySource",
    "tailType": "class"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.asm",
    "tailType": "package"
  },
  {
    "head": "org.springframework.asm",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.asm.Opcodes",
    "tailType": "class"
  },
  {
    "head": "org.springframework.asm.Opcodes",
    "headType": "class",
    "relation": "provide",
    "tail": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage org.springframework.asm;\n\n/**\n * The JVM opcodes, access flags and array type codes. This interface does not define all the JVM\n * opcodes because some opcodes are automatically handled. For example, the xLOAD and xSTORE opcodes\n * are automatically replaced by xLOAD_n and xSTORE_n opcodes when possible. The xLOAD_n and\n * xSTORE_n opcodes are therefore not defined in this interface. Likewise for LDC, automatically\n * replaced by LDC_W or LDC2_W when necessary, WIDE, GOTO_W and JSR_W.\n *\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html\">JVMS 6</a>\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n */\n// DontCheck(InterfaceIsType): can't be fixed (for backward binary compatibility).\npublic interface Opcodes {\n\n  // ASM API versions.\n\n  int ASM4 = 4 << 16 | 0 << 8;\n  int ASM5 = 5 << 16 | 0 << 8;\n  int ASM6 = 6 << 16 | 0 << 8;\n  int ASM7 = 7 << 16 | 0 << 8;\n  int ASM8 = 8 << 16 | 0 << 8;\n  int ASM9 = 9 << 16 | 0 << 8;\n\n  /**\n   * <i>Experimental, use at your own risk. This field will be renamed when it becomes stable, this\n   * will break existing code using it. Only code compiled with --enable-preview can use this.</i>\n   * <p>SPRING PATCH: no preview mode check for ASM 10 experimental, enabling it by default.\n   */\n  int ASM10_EXPERIMENTAL = 1 << 24 | 10 << 16 | 0 << 8;\n\n  /*\n   * Internal flags used to redirect calls to deprecated methods. For instance, if a visitOldStuff\n   * method in API_OLD is deprecated and replaced with visitNewStuff in API_NEW, then the\n   * redirection should be done as follows:\n   *\n   * <pre>\n   * public class StuffVisitor {\n   *   ...\n   *\n   *   &#64;Deprecated public void visitOldStuff(int arg, ...) {\n   *     // SOURCE_DEPRECATED means \"a call from a deprecated method using the old 'api' value\".\n   *     visitNewStuf(arg | (api &#60; API_NEW ? SOURCE_DEPRECATED : 0), ...);\n   *   }\n   *\n   *   public void visitNewStuff(int argAndSource, ...) {\n   *     if (api &#60; API_NEW &#38;&#38; (argAndSource &#38; SOURCE_DEPRECATED) == 0) {\n   *       visitOldStuff(argAndSource, ...);\n   *     } else {\n   *       int arg = argAndSource &#38; ~SOURCE_MASK;\n   *       [ do stuff ]\n   *     }\n   *   }\n   * }\n   * </pre>\n   *\n   * <p>If 'api' is equal to API_NEW, there are two cases:\n   *\n   * <ul>\n   *   <li>call visitNewStuff: the redirection test is skipped and 'do stuff' is executed directly.\n   *   <li>call visitOldSuff: the source is not set to SOURCE_DEPRECATED before calling\n   *       visitNewStuff, but the redirection test is skipped anyway in visitNewStuff, which\n   *       directly executes 'do stuff'.\n   * </ul>\n   *\n   * <p>If 'api' is equal to API_OLD, there are two cases:\n   *\n   * <ul>\n   *   <li>call visitOldSuff: the source is set to SOURCE_DEPRECATED before calling visitNewStuff.\n   *       Because of this visitNewStuff does not redirect back to visitOldStuff, and instead\n   *       executes 'do stuff'.\n   *   <li>call visitNewStuff: the call is redirected to visitOldStuff because the source is 0.\n   *       visitOldStuff now sets the source to SOURCE_DEPRECATED and calls visitNewStuff back. This\n   *       time visitNewStuff does not redirect the call, and instead executes 'do stuff'.\n   * </ul>\n   *\n   * <h1>User subclasses</h1>\n   *\n   * <p>If a user subclass overrides one of these methods, there are only two cases: either 'api' is\n   * API_OLD and visitOldStuff is overridden (and visitNewStuff is not), or 'api' is API_NEW or\n   * more, and visitNewStuff is overridden (and visitOldStuff is not). Any other case is a user\n   * programming error.\n   *\n   * <p>If 'api' is equal to API_NEW, the class hierarchy is equivalent to\n   *\n   * <pre>\n   * public class StuffVisitor {\n   *   &#64;Deprecated public void visitOldStuff(int arg, ...) { visitNewStuf(arg, ...); }\n   *   public void visitNewStuff(int arg, ...) { [ do stuff ] }\n   * }\n   * class UserStuffVisitor extends StuffVisitor {\n   *   &#64;Override public void visitNewStuff(int arg, ...) {\n   *     super.visitNewStuff(int arg, ...); // optional\n   *     [ do user stuff ]\n   *   }\n   * }\n   * </pre>\n   *\n   * <p>It is then obvious that whether visitNewStuff or visitOldStuff is called, 'do stuff' and 'do\n   * user stuff' will be executed, in this order.\n   *\n   * <p>If 'api' is equal to API_OLD, the class hierarchy is equivalent to\n   *\n   * <pre>\n   * public class StuffVisitor {\n   *   &#64;Deprecated public void visitOldStuff(int arg, ...) {\n   *     visitNewStuff(arg | SOURCE_DEPRECATED, ...);\n   *   }\n   *   public void visitNewStuff(int argAndSource...) {\n   *     if ((argAndSource & SOURCE_DEPRECATED) == 0) {\n   *       visitOldStuff(argAndSource, ...);\n   *     } else {\n   *       int arg = argAndSource &#38; ~SOURCE_MASK;\n   *       [ do stuff ]\n   *     }\n   *   }\n   * }\n   * class UserStuffVisitor extends StuffVisitor {\n   *   &#64;Override public void visitOldStuff(int arg, ...) {\n   *     super.visitOldStuff(int arg, ...); // optional\n   *     [ do user stuff ]\n   *   }\n   * }\n   * </pre>\n   *\n   * <p>and there are two cases:\n   *\n   * <ul>\n   *   <li>call visitOldStuff: in the call to super.visitOldStuff, the source is set to\n   *       SOURCE_DEPRECATED and visitNewStuff is called. Here 'do stuff' is run because the source\n   *       was previously set to SOURCE_DEPRECATED, and execution eventually returns to\n   *       UserStuffVisitor.visitOldStuff, where 'do user stuff' is run.\n   *   <li>call visitNewStuff: the call is redirected to UserStuffVisitor.visitOldStuff because the\n   *       source is 0. Execution continues as in the previous case, resulting in 'do stuff' and 'do\n   *       user stuff' being executed, in this order.\n   * </ul>\n   *\n   * <h1>ASM subclasses</h1>\n   *\n   * <p>In ASM packages, subclasses of StuffVisitor can typically be sub classed again by the user,\n   * and can be used with API_OLD or API_NEW. Because of this, if such a subclass must override\n   * visitNewStuff, it must do so in the following way (and must not override visitOldStuff):\n   *\n   * <pre>\n   * public class AsmStuffVisitor extends StuffVisitor {\n   *   &#64;Override public void visitNewStuff(int argAndSource, ...) {\n   *     if (api &#60; API_NEW &#38;&#38; (argAndSource &#38; SOURCE_DEPRECATED) == 0) {\n   *       super.visitNewStuff(argAndSource, ...);\n   *       return;\n   *     }\n   *     super.visitNewStuff(argAndSource, ...); // optional\n   *     int arg = argAndSource &#38; ~SOURCE_MASK;\n   *     [ do other stuff ]\n   *   }\n   * }\n   * </pre>\n   *\n   * <p>If a user class extends this with 'api' equal to API_NEW, the class hierarchy is equivalent\n   * to\n   *\n   * <pre>\n   * public class StuffVisitor {\n   *   &#64;Deprecated public void visitOldStuff(int arg, ...) { visitNewStuf(arg, ...); }\n   *   public void visitNewStuff(int arg, ...) { [ do stuff ] }\n   * }\n   * public class AsmStuffVisitor extends StuffVisitor {\n   *   &#64;Override public void visitNewStuff(int arg, ...) {\n   *     super.visitNewStuff(arg, ...);\n   *     [ do other stuff ]\n   *   }\n   * }\n   * class UserStuffVisitor extends StuffVisitor {\n   *   &#64;Override public void visitNewStuff(int arg, ...) {\n   *     super.visitNewStuff(int arg, ...);\n   *     [ do user stuff ]\n   *   }\n   * }\n   * </pre>\n   *\n   * <p>It is then obvious that whether visitNewStuff or visitOldStuff is called, 'do stuff', 'do\n   * other stuff' and 'do user stuff' will be executed, in this order. If, on the other hand, a user\n   * class extends AsmStuffVisitor with 'api' equal to API_OLD, the class hierarchy is equivalent to\n   *\n   * <pre>\n   * public class StuffVisitor {\n   *   &#64;Deprecated public void visitOldStuff(int arg, ...) {\n   *     visitNewStuf(arg | SOURCE_DEPRECATED, ...);\n   *   }\n   *   public void visitNewStuff(int argAndSource, ...) {\n   *     if ((argAndSource & SOURCE_DEPRECATED) == 0) {\n   *       visitOldStuff(argAndSource, ...);\n   *     } else {\n   *       int arg = argAndSource &#38; ~SOURCE_MASK;\n   *       [ do stuff ]\n   *     }\n   *   }\n   * }\n   * public class AsmStuffVisitor extends StuffVisitor {\n   *   &#64;Override public void visitNewStuff(int argAndSource, ...) {\n   *     if ((argAndSource &#38; SOURCE_DEPRECATED) == 0) {\n   *       super.visitNewStuff(argAndSource, ...);\n   *       return;\n   *     }\n   *     super.visitNewStuff(argAndSource, ...); // optional\n   *     int arg = argAndSource &#38; ~SOURCE_MASK;\n   *     [ do other stuff ]\n   *   }\n   * }\n   * class UserStuffVisitor extends StuffVisitor {\n   *   &#64;Override public void visitOldStuff(int arg, ...) {\n   *     super.visitOldStuff(arg, ...);\n   *     [ do user stuff ]\n   *   }\n   * }\n   * </pre>\n   *\n   * <p>and, here again, whether visitNewStuff or visitOldStuff is called, 'do stuff', 'do other\n   * stuff' and 'do user stuff' will be executed, in this order (exercise left to the reader).\n   *\n   * <h1>Notes</h1>\n   *\n   * <ul>\n   *   <li>the SOURCE_DEPRECATED flag is set only if 'api' is API_OLD, just before calling\n   *       visitNewStuff. By hypothesis, this method is not overridden by the user. Therefore, user\n   *       classes can never see this flag. Only ASM subclasses must take care of extracting the\n   *       actual argument value by clearing the source flags.\n   *   <li>because the SOURCE_DEPRECATED flag is immediately cleared in the caller, the caller can\n   *       call visitOldStuff or visitNewStuff (in 'do stuff' and 'do user stuff') on a delegate\n   *       visitor without any risks (breaking the redirection logic, \"leaking\" the flag, etc).\n   *   <li>all the scenarios discussed above are unit tested in MethodVisitorTest.\n   * </ul>\n   */\n\n  int SOURCE_DEPRECATED = 0x100;\n  int SOURCE_MASK = SOURCE_DEPRECATED;\n\n  // Java ClassFile versions (the minor version is stored in the 16 most significant bits, and the\n  // major version in the 16 least significant bits).\n\n  int V1_1 = 3 << 16 | 45;\n  int V1_2 = 0 << 16 | 46;\n  int V1_3 = 0 << 16 | 47;\n  int V1_4 = 0 << 16 | 48;\n  int V1_5 = 0 << 16 | 49;\n  int V1_6 = 0 << 16 | 50;\n  int V1_7 = 0 << 16 | 51;\n  int V1_8 = 0 << 16 | 52;\n  int V9 = 0 << 16 | 53;\n  int V10 = 0 << 16 | 54;\n  int V11 = 0 << 16 | 55;\n  int V12 = 0 << 16 | 56;\n  int V13 = 0 << 16 | 57;\n  int V14 = 0 << 16 | 58;\n  int V15 = 0 << 16 | 59;\n  int V16 = 0 << 16 | 60;\n  int V17 = 0 << 16 | 61;\n  int V18 = 0 << 16 | 62;\n  int V19 = 0 << 16 | 63;\n  int V20 = 0 << 16 | 64;\n  int V21 = 0 << 16 | 65;\n  int V22 = 0 << 16 | 66;\n  int V23 = 0 << 16 | 67;\n  int V24 = 0 << 16 | 68;\n\n  /**\n   * Version flag indicating that the class is using 'preview' features.\n   *\n   * <p>{@code version & V_PREVIEW == V_PREVIEW} tests if a version is flagged with {@code\n   * V_PREVIEW}.\n   */\n  int V_PREVIEW = 0xFFFF0000;\n\n  // Access flags values, defined in\n  // - https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.1-200-E.1\n  // - https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.5-200-A.1\n  // - https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.6-200-A.1\n  // - https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.25\n\n  int ACC_PUBLIC = 0x0001; // class, field, method\n  int ACC_PRIVATE = 0x0002; // class, field, method\n  int ACC_PROTECTED = 0x0004; // class, field, method\n  int ACC_STATIC = 0x0008; // field, method\n  int ACC_FINAL = 0x0010; // class, field, method, parameter\n  int ACC_SUPER = 0x0020; // class\n  int ACC_SYNCHRONIZED = 0x0020; // method\n  int ACC_OPEN = 0x0020; // module\n  int ACC_TRANSITIVE = 0x0020; // module requires\n  int ACC_VOLATILE = 0x0040; // field\n  int ACC_BRIDGE = 0x0040; // method\n  int ACC_STATIC_PHASE = 0x0040; // module requires\n  int ACC_VARARGS = 0x0080; // method\n  int ACC_TRANSIENT = 0x0080; // field\n  int ACC_NATIVE = 0x0100; // method\n  int ACC_INTERFACE = 0x0200; // class\n  int ACC_ABSTRACT = 0x0400; // class, method\n  int ACC_STRICT = 0x0800; // method\n  int ACC_SYNTHETIC = 0x1000; // class, field, method, parameter, module *\n  int ACC_ANNOTATION = 0x2000; // class\n  int ACC_ENUM = 0x4000; // class(?) field inner\n  int ACC_MANDATED = 0x8000; // field, method, parameter, module, module *\n  int ACC_MODULE = 0x8000; // class\n\n  // ASM specific access flags.\n  // WARNING: the 16 least significant bits must NOT be used, to avoid conflicts with standard\n  // access flags, and also to make sure that these flags are automatically filtered out when\n  // written in class files (because access flags are stored using 16 bits only).\n\n  int ACC_RECORD = 0x10000; // class\n  int ACC_DEPRECATED = 0x20000; // class, field, method\n\n  // Possible values for the type operand of the NEWARRAY instruction.\n  // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-6.html#jvms-6.5.newarray.\n\n  int T_BOOLEAN = 4;\n  int T_CHAR = 5;\n  int T_FLOAT = 6;\n  int T_DOUBLE = 7;\n  int T_BYTE = 8;\n  int T_SHORT = 9;\n  int T_INT = 10;\n  int T_LONG = 11;\n\n  // Possible values for the reference_kind field of CONSTANT_MethodHandle_info structures.\n  // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.4.8.\n\n  int H_GETFIELD = 1;\n  int H_GETSTATIC = 2;\n  int H_PUTFIELD = 3;\n  int H_PUTSTATIC = 4;\n  int H_INVOKEVIRTUAL = 5;\n  int H_INVOKESTATIC = 6;\n  int H_INVOKESPECIAL = 7;\n  int H_NEWINVOKESPECIAL = 8;\n  int H_INVOKEINTERFACE = 9;\n\n  // ASM specific stack map frame types, used in {@link ClassVisitor#visitFrame}.\n\n  /** An expanded frame. See {@link ClassReader#EXPAND_FRAMES}. */\n  int F_NEW = -1;\n\n  /** A compressed frame with complete frame data. */\n  int F_FULL = 0;\n\n  /**\n   * A compressed frame where locals are the same as the locals in the previous frame, except that\n   * additional 1-3 locals are defined, and with an empty stack.\n   */\n  int F_APPEND = 1;\n\n  /**\n   * A compressed frame where locals are the same as the locals in the previous frame, except that\n   * the last 1-3 locals are absent and with an empty stack.\n   */\n  int F_CHOP = 2;\n\n  /**\n   * A compressed frame with exactly the same locals as the previous frame and with an empty stack.\n   */\n  int F_SAME = 3;\n\n  /**\n   * A compressed frame with exactly the same locals as the previous frame and with a single value\n   * on the stack.\n   */\n  int F_SAME1 = 4;\n\n  // Standard stack map frame element types, used in {@link ClassVisitor#visitFrame}.\n\n  Integer TOP = Frame.ITEM_TOP;\n  Integer INTEGER = Frame.ITEM_INTEGER;\n  Integer FLOAT = Frame.ITEM_FLOAT;\n  Integer DOUBLE = Frame.ITEM_DOUBLE;\n  Integer LONG = Frame.ITEM_LONG;\n  Integer NULL = Frame.ITEM_NULL;\n  Integer UNINITIALIZED_THIS = Frame.ITEM_UNINITIALIZED_THIS;\n\n  // The JVM opcode values (with the MethodVisitor method name used to visit them in comment, and\n  // where '-' means 'same method name as on the previous line').\n  // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-6.html.\n\n  int NOP = 0; // visitInsn\n  int ACONST_NULL = 1; // -\n  int ICONST_M1 = 2; // -\n  int ICONST_0 = 3; // -\n  int ICONST_1 = 4; // -\n  int ICONST_2 = 5; // -\n  int ICONST_3 = 6; // -\n  int ICONST_4 = 7; // -\n  int ICONST_5 = 8; // -\n  int LCONST_0 = 9; // -\n  int LCONST_1 = 10; // -\n  int FCONST_0 = 11; // -\n  int FCONST_1 = 12; // -\n  int FCONST_2 = 13; // -\n  int DCONST_0 = 14; // -\n  int DCONST_1 = 15; // -\n  int BIPUSH = 16; // visitIntInsn\n  int SIPUSH = 17; // -\n  int LDC = 18; // visitLdcInsn\n  int ILOAD = 21; // visitVarInsn\n  int LLOAD = 22; // -\n  int FLOAD = 23; // -\n  int DLOAD = 24; // -\n  int ALOAD = 25; // -\n  int IALOAD = 46; // visitInsn\n  int LALOAD = 47; // -\n  int FALOAD = 48; // -\n  int DALOAD = 49; // -\n  int AALOAD = 50; // -\n  int BALOAD = 51; // -\n  int CALOAD = 52; // -\n  int SALOAD = 53; // -\n  int ISTORE = 54; // visitVarInsn\n  int LSTORE = 55; // -\n  int FSTORE = 56; // -\n  int DSTORE = 57; // -\n  int ASTORE = 58; // -\n  int IASTORE = 79; // visitInsn\n  int LASTORE = 80; // -\n  int FASTORE = 81; // -\n  int DASTORE = 82; // -\n  int AASTORE = 83; // -\n  int BASTORE = 84; // -\n  int CASTORE = 85; // -\n  int SASTORE = 86; // -\n  int POP = 87; // -\n  int POP2 = 88; // -\n  int DUP = 89; // -\n  int DUP_X1 = 90; // -\n  int DUP_X2 = 91; // -\n  int DUP2 = 92; // -\n  int DUP2_X1 = 93; // -\n  int DUP2_X2 = 94; // -\n  int SWAP = 95; // -\n  int IADD = 96; // -\n  int LADD = 97; // -\n  int FADD = 98; // -\n  int DADD = 99; // -\n  int ISUB = 100; // -\n  int LSUB = 101; // -\n  int FSUB = 102; // -\n  int DSUB = 103; // -\n  int IMUL = 104; // -\n  int LMUL = 105; // -\n  int FMUL = 106; // -\n  int DMUL = 107; // -\n  int IDIV = 108; // -\n  int LDIV = 109; // -\n  int FDIV = 110; // -\n  int DDIV = 111; // -\n  int IREM = 112; // -\n  int LREM = 113; // -\n  int FREM = 114; // -\n  int DREM = 115; // -\n  int INEG = 116; // -\n  int LNEG = 117; // -\n  int FNEG = 118; // -\n  int DNEG = 119; // -\n  int ISHL = 120; // -\n  int LSHL = 121; // -\n  int ISHR = 122; // -\n  int LSHR = 123; // -\n  int IUSHR = 124; // -\n  int LUSHR = 125; // -\n  int IAND = 126; // -\n  int LAND = 127; // -\n  int IOR = 128; // -\n  int LOR = 129; // -\n  int IXOR = 130; // -\n  int LXOR = 131; // -\n  int IINC = 132; // visitIincInsn\n  int I2L = 133; // visitInsn\n  int I2F = 134; // -\n  int I2D = 135; // -\n  int L2I = 136; // -\n  int L2F = 137; // -\n  int L2D = 138; // -\n  int F2I = 139; // -\n  int F2L = 140; // -\n  int F2D = 141; // -\n  int D2I = 142; // -\n  int D2L = 143; // -\n  int D2F = 144; // -\n  int I2B = 145; // -\n  int I2C = 146; // -\n  int I2S = 147; // -\n  int LCMP = 148; // -\n  int FCMPL = 149; // -\n  int FCMPG = 150; // -\n  int DCMPL = 151; // -\n  int DCMPG = 152; // -\n  int IFEQ = 153; // visitJumpInsn\n  int IFNE = 154; // -\n  int IFLT = 155; // -\n  int IFGE = 156; // -\n  int IFGT = 157; // -\n  int IFLE = 158; // -\n  int IF_ICMPEQ = 159; // -\n  int IF_ICMPNE = 160; // -\n  int IF_ICMPLT = 161; // -\n  int IF_ICMPGE = 162; // -\n  int IF_ICMPGT = 163; // -\n  int IF_ICMPLE = 164; // -\n  int IF_ACMPEQ = 165; // -\n  int IF_ACMPNE = 166; // -\n  int GOTO = 167; // -\n  int JSR = 168; // -\n  int RET = 169; // visitVarInsn\n  int TABLESWITCH = 170; // visiTableSwitchInsn\n  int LOOKUPSWITCH = 171; // visitLookupSwitch\n  int IRETURN = 172; // visitInsn\n  int LRETURN = 173; // -\n  int FRETURN = 174; // -\n  int DRETURN = 175; // -\n  int ARETURN = 176; // -\n  int RETURN = 177; // -\n  int GETSTATIC = 178; // visitFieldInsn\n  int PUTSTATIC = 179; // -\n  int GETFIELD = 180; // -\n  int PUTFIELD = 181; // -\n  int INVOKEVIRTUAL = 182; // visitMethodInsn\n  int INVOKESPECIAL = 183; // -\n  int INVOKESTATIC = 184; // -\n  int INVOKEINTERFACE = 185; // -\n  int INVOKEDYNAMIC = 186; // visitInvokeDynamicInsn\n  int NEW = 187; // visitTypeInsn\n  int NEWARRAY = 188; // visitIntInsn\n  int ANEWARRAY = 189; // visitTypeInsn\n  int ARRAYLENGTH = 190; // visitInsn\n  int ATHROW = 191; // -\n  int CHECKCAST = 192; // visitTypeInsn\n  int INSTANCEOF = 193; // -\n  int MONITORENTER = 194; // visitInsn\n  int MONITOREXIT = 195; // -\n  int MULTIANEWARRAY = 197; // visitMultiANewArrayInsn\n  int IFNULL = 198; // visitJumpInsn\n  int IFNONNULL = 199; // -\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.asm.Opcodes",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.Opcodes#ASM4",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.Opcodes#ASM4",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.Opcodes",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.Opcodes#ASM5",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.Opcodes#ASM5",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.Opcodes",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.Opcodes#ASM6",
    "tailType": "field"
  },
  {
    "head": "org.springframework.asm.Opcodes#ASM6",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.asm.Opcodes",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.asm.Opcodes#ASM7",
    "tailType": "field"
  }
]