[
  {
    "head": "org.springframework.core.type.AnnotatedTypeMetadata",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.type;\n\nimport java.lang.annotation.Annotation;\nimport java.util.Comparator;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.core.annotation.AnnotationAttributes;\nimport org.springframework.core.annotation.MergedAnnotation;\nimport org.springframework.core.annotation.MergedAnnotation.Adapt;\nimport org.springframework.core.annotation.MergedAnnotationCollectors;\nimport org.springframework.core.annotation.MergedAnnotationPredicates;\nimport org.springframework.core.annotation.MergedAnnotationSelectors;\nimport org.springframework.core.annotation.MergedAnnotations;\nimport org.springframework.util.MultiValueMap;\n\n/**\n * Defines access to the annotations of a specific type ({@link AnnotationMetadata class}\n * or {@link MethodMetadata method}), in a form that does not necessarily require\n * class loading of the types being inspected. Note, however, that classes for\n * encountered annotations will be loaded.\n *\n * @author Juergen Hoeller\n * @author Mark Fisher\n * @author Mark Pollack\n * @author Chris Beams\n * @author Phillip Webb\n * @author Sam Brannen\n * @since 4.0\n * @see AnnotationMetadata\n * @see MethodMetadata\n */\npublic interface AnnotatedTypeMetadata {\n\n\t/**\n\t * Get annotation details based on the direct annotations and meta-annotations\n\t * of the underlying element.\n\t * @return merged annotations based on the direct annotations and meta-annotations\n\t * @since 5.2\n\t */\n\tMergedAnnotations getAnnotations();\n\n\t/**\n\t * Determine whether the underlying element has an annotation or meta-annotation\n\t * of the given type defined.\n\t * <p>If this method returns {@code true}, then\n\t * {@link #getAnnotationAttributes} will return a non-null Map.\n\t * @param annotationName the fully-qualified class name of the annotation\n\t * type to look for\n\t * @return whether a matching annotation is defined\n\t */\n\tdefault boolean isAnnotated(String annotationName) {\n\t\treturn getAnnotations().isPresent(annotationName);\n\t}\n\n\t/**\n\t * Retrieve the attributes of the annotation of the given type, if any (i.e. if\n\t * defined on the underlying element, as direct annotation or meta-annotation).\n\t * <p>{@link org.springframework.core.annotation.AliasFor @AliasFor} semantics\n\t * are fully supported, both within a single annotation and within annotation\n\t * hierarchies.\n\t * @param annotationName the fully-qualified class name of the annotation\n\t * type to look for\n\t * @return a {@link Map} of attributes, with each annotation attribute name\n\t * as map key (for example, \"location\") and the attribute's value as map value; or\n\t * {@code null} if no matching annotation is found\n\t */\n\tdefault @Nullable Map<String, @Nullable Object> getAnnotationAttributes(String annotationName) {\n\t\treturn getAnnotationAttributes(annotationName, false);\n\t}\n\n\t/**\n\t * Retrieve the attributes of the annotation of the given type, if any (i.e. if\n\t * defined on the underlying element, as direct annotation or meta-annotation).\n\t * <p>{@link org.springframework.core.annotation.AliasFor @AliasFor} semantics\n\t * are fully supported, both within a single annotation and within annotation\n\t * hierarchies.\n\t * @param annotationName the fully-qualified class name of the annotation\n\t * type to look for\n\t * @param classValuesAsString whether to convert class references to String\n\t * class names for exposure as values in the returned Map, instead of Class\n\t * references which might potentially have to be loaded first\n\t * @return a {@link Map} of attributes, with each annotation attribute name\n\t * as map key (for example, \"location\") and the attribute's value as map value; or\n\t * {@code null} if no matching annotation is found\n\t */\n\tdefault @Nullable Map<String, @Nullable Object> getAnnotationAttributes(String annotationName,\n\t\t\tboolean classValuesAsString) {\n\n\t\tMergedAnnotation<Annotation> annotation = getAnnotations().get(annotationName,\n\t\t\t\tnull, MergedAnnotationSelectors.firstDirectlyDeclared());\n\t\tif (!annotation.isPresent()) {\n\t\t\treturn null;\n\t\t}\n\t\treturn annotation.asAnnotationAttributes(Adapt.values(classValuesAsString, true));\n\t}\n\n\t/**\n\t * Retrieve all attributes of all annotations of the given type, if any (i.e. if\n\t * defined on the underlying element, as direct annotation or meta-annotation).\n\t * <p>Note: this method does <i>not</i> take attribute overrides on composed\n\t * annotations into account.\n\t * @param annotationName the fully-qualified class name of the annotation\n\t * type to look for\n\t * @return a {@link MultiValueMap} of attributes, with each annotation attribute\n\t * name as map key (for example, \"location\") and a list of the attribute's values as\n\t * map value; or {@code null} if no matching annotation is found\n\t * @see #getAllAnnotationAttributes(String, boolean)\n\t */\n\tdefault @Nullable MultiValueMap<String, @Nullable Object> getAllAnnotationAttributes(String annotationName) {\n\t\treturn getAllAnnotationAttributes(annotationName, false);\n\t}\n\n\t/**\n\t * Retrieve all attributes of all annotations of the given type, if any (i.e. if\n\t * defined on the underlying element, as direct annotation or meta-annotation).\n\t * <p>Note: this method does <i>not</i> take attribute overrides on composed\n\t * annotations into account.\n\t * @param annotationName the fully-qualified class name of the annotation\n\t * type to look for\n\t * @param classValuesAsString whether to convert class references to String\n\t * class names for exposure as values in the returned Map, instead of Class\n\t * references which might potentially have to be loaded first\n\t * @return a {@link MultiValueMap} of attributes, with each annotation attribute\n\t * name as map key (for example, \"location\") and a list of the attribute's values as\n\t * map value; or {@code null} if no matching annotation is found\n\t * @see #getAllAnnotationAttributes(String)\n\t */\n\tdefault @Nullable MultiValueMap<String, @Nullable Object> getAllAnnotationAttributes(\n\t\t\tString annotationName, boolean classValuesAsString) {\n\n\t\tAdapt[] adaptations = Adapt.values(classValuesAsString, true);\n\t\treturn getAnnotations().stream(annotationName)\n\t\t\t\t.filter(MergedAnnotationPredicates.unique(MergedAnnotation::getMetaTypes))\n\t\t\t\t.map(MergedAnnotation::withNonMergedAttributes)\n\t\t\t\t.collect(MergedAnnotationCollectors.toMultiValueMap(\n\t\t\t\t\t\t(MultiValueMap<String, @Nullable Object> map) -> (map.isEmpty() ? null : map), adaptations));\n\t}\n\n\t/**\n\t * Retrieve all <em>repeatable annotations</em> of the given type within the\n\t * annotation hierarchy <em>above</em> the underlying element (as direct\n\t * annotation or meta-annotation); and for each annotation found, merge that\n\t * annotation's attributes with <em>matching</em> attributes from annotations\n\t * in lower levels of the annotation hierarchy and store the results in an\n\t * instance of {@link AnnotationAttributes}.\n\t * <p>{@link org.springframework.core.annotation.AliasFor @AliasFor} semantics\n\t * are fully supported, both within a single annotation and within annotation\n\t * hierarchies.\n\t * @param annotationType the annotation type to find\n\t * @param containerType the type of the container that holds the annotations\n\t * @param classValuesAsString whether to convert class references to {@code String}\n\t * class names for exposure as values in the returned {@code AnnotationAttributes},\n\t * instead of {@code Class} references which might potentially have to be loaded\n\t * first\n\t * @return the set of all merged repeatable {@code AnnotationAttributes} found,\n\t * or an empty set if none were found\n\t * @since 6.1\n\t * @see #getMergedRepeatableAnnotationAttributes(Class, Class, boolean, boolean)\n\t * @see #getMergedRepeatableAnnotationAttributes(Class, Class, Predicate, boolean, boolean)\n\t */\n\tdefault Set<AnnotationAttributes> getMergedRepeatableAnnotationAttributes(\n\t\t\tClass<? extends Annotation> annotationType, Class<? extends Annotation> containerType,\n\t\t\tboolean classValuesAsString) {\n\n\t\treturn getMergedRepeatableAnnotationAttributes(annotationType, containerType, classValuesAsString, false);\n\t}\n\n\t/**\n\t * Retrieve all <em>repeatable annotations</em> of the given type within the\n\t * annotation hierarchy <em>above</em> the underlying element (as direct\n\t * annotation or meta-annotation); and for each annotation found, merge that\n\t * annotation's attributes with <em>matching</em> attributes from annotations\n\t * in lower levels of the annotation hierarchy and store the results in an\n\t * instance of {@link AnnotationAttributes}.\n\t * <p>{@link org.springframework.core.annotation.AliasFor @AliasFor} semantics\n\t * are fully supported, both within a single annotation and within annotation\n\t * hierarchies.\n\t * <p>If the {@code sortByReversedMetaDistance} flag is set to {@code true},\n\t * the results will be sorted in {@link Comparator#reversed() reversed} order\n\t * based on each annotation's {@linkplain MergedAnnotation#getDistance()\n\t * meta distance}, which effectively orders meta-annotations before annotations\n\t * that are declared directly on the underlying element.\n\t * @param annotationType the annotation type to find\n\t * @param containerType the type of the container that holds the annotations\n\t * @param classValuesAsString whether to convert class references to {@code String}\n\t * class names for exposure as values in the returned {@code AnnotationAttributes},\n\t * instead of {@code Class} references which might potentially have to be loaded\n\t * first\n\t * @param sortByReversedMetaDistance {@code true} if the results should be\n\t * sorted in reversed order based on each annotation's meta distance\n\t * @return the set of all merged repeatable {@code AnnotationAttributes} found,\n\t * or an empty set if none were found\n\t * @since 6.1\n\t * @see #getMergedRepeatableAnnotationAttributes(Class, Class, boolean)\n\t * @see #getMergedRepeatableAnnotationAttributes(Class, Class, Predicate, boolean, boolean)\n\t */\n\tdefault Set<AnnotationAttributes> getMergedRepeatableAnnotationAttributes(\n\t\t\tClass<? extends Annotation> annotationType, Class<? extends Annotation> containerType,\n\t\t\tboolean classValuesAsString, boolean sortByReversedMetaDistance) {\n\n\t\treturn getMergedRepeatableAnnotationAttributes(annotationType, containerType,\n\t\t\t\tmergedAnnotation -> true, classValuesAsString, sortByReversedMetaDistance);\n\t}\n\n\t/**\n\t * Retrieve all <em>repeatable annotations</em> of the given type within the\n\t * annotation hierarchy <em>above</em> the underlying element (as direct\n\t * annotation or meta-annotation); and for each annotation found, merge that\n\t * annotation's attributes with <em>matching</em> attributes from annotations\n\t * in lower levels of the annotation hierarchy and store the results in an\n\t * instance of {@link AnnotationAttributes}.\n\t * <p>{@link org.springframework.core.annotation.AliasFor @AliasFor} semantics\n\t * are fully supported, both within a single annotation and within annotation\n\t * hierarchies.\n\t * <p>The supplied {@link Predicate} will be used to filter the results. For\n\t * example, supply {@code mergedAnnotation -> true} to include all annotations\n\t * in the results; supply {@code MergedAnnotation::isDirectlyPresent} to limit\n\t * the results to directly declared annotations, etc.\n\t * <p>If the {@code sortByReversedMetaDistance} flag is set to {@code true},\n\t * the results will be sorted in {@link Comparator#reversed() reversed} order\n\t * based on each annotation's {@linkplain MergedAnnotation#getDistance()\n\t * meta distance}, which effectively orders meta-annotations before annotations\n\t * that are declared directly on the underlying element.\n\t * @param annotationType the annotation type to find\n\t * @param containerType the type of the container that holds the annotations\n\t * @param predicate a {@code Predicate} to apply to each {@code MergedAnnotation}\n\t * to determine if it should be included in the results\n\t * @param classValuesAsString whether to convert class references to {@code String}\n\t * class names for exposure as values in the returned {@code AnnotationAttributes},\n\t * instead of {@code Class} references which might potentially have to be loaded\n\t * first\n\t * @param sortByReversedMetaDistance {@code true} if the results should be\n\t * sorted in reversed order based on each annotation's meta distance\n\t * @return the set of all merged repeatable {@code AnnotationAttributes} found,\n\t * or an empty set if none were found\n\t * @since 6.1.2\n\t * @see #getMergedRepeatableAnnotationAttributes(Class, Class, boolean)\n\t * @see #getMergedRepeatableAnnotationAttributes(Class, Class, boolean, boolean)\n\t */\n\tdefault Set<AnnotationAttributes> getMergedRepeatableAnnotationAttributes(\n\t\t\tClass<? extends Annotation> annotationType, Class<? extends Annotation> containerType,\n\t\t\tPredicate<MergedAnnotation<? extends Annotation>> predicate, boolean classValuesAsString,\n\t\t\tboolean sortByReversedMetaDistance) {\n\n\t\tStream<MergedAnnotation<Annotation>> stream = getAnnotations().stream()\n\t\t\t\t.filter(predicate)\n\t\t\t\t.filter(MergedAnnotationPredicates.typeIn(containerType, annotationType));\n\n\t\tif (sortByReversedMetaDistance) {\n\t\t\tstream = stream.sorted(reversedMetaDistance());\n\t\t}\n\n\t\tAdapt[] adaptations = Adapt.values(classValuesAsString, true);\n\t\treturn stream\n\t\t\t\t.map(annotation -> annotation.asAnnotationAttributes(adaptations))\n\t\t\t\t.flatMap(attributes -> {\n\t\t\t\t\tif (containerType.equals(attributes.annotationType())) {\n\t\t\t\t\t\treturn Stream.of(attributes.getAnnotationArray(MergedAnnotation.VALUE));\n\t\t\t\t\t}\n\t\t\t\t\treturn Stream.of(attributes);\n\t\t\t\t})\n\t\t\t\t.collect(Collectors.toCollection(LinkedHashSet::new));\n\t}\n\n\n\tprivate static Comparator<MergedAnnotation<Annotation>> reversedMetaDistance() {\n\t\treturn Comparator.<MergedAnnotation<Annotation>> comparingInt(MergedAnnotation::getDistance).reversed();\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.type.AnnotatedTypeMetadata#getAnnotations()",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Get annotation details based on the direct annotations and meta-annotations\r\n * of the underlying element.\r\n * @return merged annotations based on the direct annotations and meta-annotations\r\n * @since 5.2\r\n */\r\nMergedAnnotations getAnnotations();",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.type.AnnotatedTypeMetadata",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.type.AnnotatedTypeMetadata#getAnnotations()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.type.AnnotatedTypeMetadata#isAnnotated(String)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Determine whether the underlying element has an annotation or meta-annotation\r\n * of the given type defined.\r\n * <p>If this method returns {@code true}, then\r\n * {@link #getAnnotationAttributes} will return a non-null Map.\r\n * @param annotationName the fully-qualified class name of the annotation\r\n * type to look for\r\n * @return whether a matching annotation is defined\r\n */\r\ndefault boolean isAnnotated(String annotationName) {\r\n    return getAnnotations().isPresent(annotationName);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.type.AnnotatedTypeMetadata",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.type.AnnotatedTypeMetadata#isAnnotated(String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.type.AnnotatedTypeMetadata#getAnnotationAttributes(String)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Retrieve the attributes of the annotation of the given type, if any (i.e. if\r\n * defined on the underlying element, as direct annotation or meta-annotation).\r\n * <p>{@link org.springframework.core.annotation.AliasFor @AliasFor} semantics\r\n * are fully supported, both within a single annotation and within annotation\r\n * hierarchies.\r\n * @param annotationName the fully-qualified class name of the annotation\r\n * type to look for\r\n * @return a {@link Map} of attributes, with each annotation attribute name\r\n * as map key (for example, \"location\") and the attribute's value as map value; or\r\n * {@code null} if no matching annotation is found\r\n */\r\n@Nullable\r\ndefault Map<String, @Nullable Object> getAnnotationAttributes(String annotationName) {\r\n    return getAnnotationAttributes(annotationName, false);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.type.AnnotatedTypeMetadata",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.type.AnnotatedTypeMetadata#getAnnotationAttributes(String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.type.AnnotatedTypeMetadata#getAnnotationAttributes(String)",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.type.AnnotatedTypeMetadata#getAnnotationAttributes(String,boolean)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Retrieve the attributes of the annotation of the given type, if any (i.e. if\r\n * defined on the underlying element, as direct annotation or meta-annotation).\r\n * <p>{@link org.springframework.core.annotation.AliasFor @AliasFor} semantics\r\n * are fully supported, both within a single annotation and within annotation\r\n * hierarchies.\r\n * @param annotationName the fully-qualified class name of the annotation\r\n * type to look for\r\n * @param classValuesAsString whether to convert class references to String\r\n * class names for exposure as values in the returned Map, instead of Class\r\n * references which might potentially have to be loaded first\r\n * @return a {@link Map} of attributes, with each annotation attribute name\r\n * as map key (for example, \"location\") and the attribute's value as map value; or\r\n * {@code null} if no matching annotation is found\r\n */\r\n@Nullable\r\ndefault Map<String, @Nullable Object> getAnnotationAttributes(String annotationName, boolean classValuesAsString) {\r\n    MergedAnnotation<Annotation> annotation = getAnnotations().get(annotationName, null, MergedAnnotationSelectors.firstDirectlyDeclared());\r\n    if (!annotation.isPresent()) {\r\n        return null;\r\n    }\r\n    return annotation.asAnnotationAttributes(Adapt.values(classValuesAsString, true));\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.type.AnnotatedTypeMetadata",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.type.AnnotatedTypeMetadata#getAnnotationAttributes(String,boolean)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.type.AnnotatedTypeMetadata#getAnnotationAttributes(String,boolean)",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.type.AnnotatedTypeMetadata#getAllAnnotationAttributes(String)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Retrieve all attributes of all annotations of the given type, if any (i.e. if\r\n * defined on the underlying element, as direct annotation or meta-annotation).\r\n * <p>Note: this method does <i>not</i> take attribute overrides on composed\r\n * annotations into account.\r\n * @param annotationName the fully-qualified class name of the annotation\r\n * type to look for\r\n * @return a {@link MultiValueMap} of attributes, with each annotation attribute\r\n * name as map key (for example, \"location\") and a list of the attribute's values as\r\n * map value; or {@code null} if no matching annotation is found\r\n * @see #getAllAnnotationAttributes(String, boolean)\r\n */\r\n@Nullable\r\ndefault MultiValueMap<String, @Nullable Object> getAllAnnotationAttributes(String annotationName) {\r\n    return getAllAnnotationAttributes(annotationName, false);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.type.AnnotatedTypeMetadata",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.type.AnnotatedTypeMetadata#getAllAnnotationAttributes(String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.type.AnnotatedTypeMetadata#getAllAnnotationAttributes(String)",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.type.AnnotatedTypeMetadata#getAllAnnotationAttributes(String,boolean)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Retrieve all attributes of all annotations of the given type, if any (i.e. if\r\n * defined on the underlying element, as direct annotation or meta-annotation).\r\n * <p>Note: this method does <i>not</i> take attribute overrides on composed\r\n * annotations into account.\r\n * @param annotationName the fully-qualified class name of the annotation\r\n * type to look for\r\n * @param classValuesAsString whether to convert class references to String\r\n * class names for exposure as values in the returned Map, instead of Class\r\n * references which might potentially have to be loaded first\r\n * @return a {@link MultiValueMap} of attributes, with each annotation attribute\r\n * name as map key (for example, \"location\") and a list of the attribute's values as\r\n * map value; or {@code null} if no matching annotation is found\r\n * @see #getAllAnnotationAttributes(String)\r\n */\r\n@Nullable\r\ndefault MultiValueMap<String, @Nullable Object> getAllAnnotationAttributes(String annotationName, boolean classValuesAsString) {\r\n    Adapt[] adaptations = Adapt.values(classValuesAsString, true);\r\n    return getAnnotations().stream(annotationName).filter(MergedAnnotationPredicates.unique(MergedAnnotation::getMetaTypes)).map(MergedAnnotation::withNonMergedAttributes).collect(MergedAnnotationCollectors.toMultiValueMap((MultiValueMap<String, @Nullable Object> map) -> (map.isEmpty() ? null : map), adaptations));\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.type.AnnotatedTypeMetadata",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.type.AnnotatedTypeMetadata#getAllAnnotationAttributes(String,boolean)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.type.AnnotatedTypeMetadata#getAllAnnotationAttributes(String,boolean)",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.type.AnnotatedTypeMetadata#getMergedRepeatableAnnotationAttributes(Class<? extends Annotation>,Class<? extends Annotation>,boolean)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Retrieve all <em>repeatable annotations</em> of the given type within the\r\n * annotation hierarchy <em>above</em> the underlying element (as direct\r\n * annotation or meta-annotation); and for each annotation found, merge that\r\n * annotation's attributes with <em>matching</em> attributes from annotations\r\n * in lower levels of the annotation hierarchy and store the results in an\r\n * instance of {@link AnnotationAttributes}.\r\n * <p>{@link org.springframework.core.annotation.AliasFor @AliasFor} semantics\r\n * are fully supported, both within a single annotation and within annotation\r\n * hierarchies.\r\n * @param annotationType the annotation type to find\r\n * @param containerType the type of the container that holds the annotations\r\n * @param classValuesAsString whether to convert class references to {@code String}\r\n * class names for exposure as values in the returned {@code AnnotationAttributes},\r\n * instead of {@code Class} references which might potentially have to be loaded\r\n * first\r\n * @return the set of all merged repeatable {@code AnnotationAttributes} found,\r\n * or an empty set if none were found\r\n * @since 6.1\r\n * @see #getMergedRepeatableAnnotationAttributes(Class, Class, boolean, boolean)\r\n * @see #getMergedRepeatableAnnotationAttributes(Class, Class, Predicate, boolean, boolean)\r\n */\r\ndefault Set<AnnotationAttributes> getMergedRepeatableAnnotationAttributes(Class<? extends Annotation> annotationType, Class<? extends Annotation> containerType, boolean classValuesAsString) {\r\n    return getMergedRepeatableAnnotationAttributes(annotationType, containerType, classValuesAsString, false);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.type.AnnotatedTypeMetadata",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.type.AnnotatedTypeMetadata#getMergedRepeatableAnnotationAttributes(Class<? extends Annotation>,Class<? extends Annotation>,boolean)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.type.AnnotatedTypeMetadata#getMergedRepeatableAnnotationAttributes(Class<? extends Annotation>,Class<? extends Annotation>,boolean,boolean)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Retrieve all <em>repeatable annotations</em> of the given type within the\r\n * annotation hierarchy <em>above</em> the underlying element (as direct\r\n * annotation or meta-annotation); and for each annotation found, merge that\r\n * annotation's attributes with <em>matching</em> attributes from annotations\r\n * in lower levels of the annotation hierarchy and store the results in an\r\n * instance of {@link AnnotationAttributes}.\r\n * <p>{@link org.springframework.core.annotation.AliasFor @AliasFor} semantics\r\n * are fully supported, both within a single annotation and within annotation\r\n * hierarchies.\r\n * <p>If the {@code sortByReversedMetaDistance} flag is set to {@code true},\r\n * the results will be sorted in {@link Comparator#reversed() reversed} order\r\n * based on each annotation's {@linkplain MergedAnnotation#getDistance()\r\n * meta distance}, which effectively orders meta-annotations before annotations\r\n * that are declared directly on the underlying element.\r\n * @param annotationType the annotation type to find\r\n * @param containerType the type of the container that holds the annotations\r\n * @param classValuesAsString whether to convert class references to {@code String}\r\n * class names for exposure as values in the returned {@code AnnotationAttributes},\r\n * instead of {@code Class} references which might potentially have to be loaded\r\n * first\r\n * @param sortByReversedMetaDistance {@code true} if the results should be\r\n * sorted in reversed order based on each annotation's meta distance\r\n * @return the set of all merged repeatable {@code AnnotationAttributes} found,\r\n * or an empty set if none were found\r\n * @since 6.1\r\n * @see #getMergedRepeatableAnnotationAttributes(Class, Class, boolean)\r\n * @see #getMergedRepeatableAnnotationAttributes(Class, Class, Predicate, boolean, boolean)\r\n */\r\ndefault Set<AnnotationAttributes> getMergedRepeatableAnnotationAttributes(Class<? extends Annotation> annotationType, Class<? extends Annotation> containerType, boolean classValuesAsString, boolean sortByReversedMetaDistance) {\r\n    return getMergedRepeatableAnnotationAttributes(annotationType, containerType, mergedAnnotation -> true, classValuesAsString, sortByReversedMetaDistance);\r\n}",
    "tailType": "method_code"
  }
]