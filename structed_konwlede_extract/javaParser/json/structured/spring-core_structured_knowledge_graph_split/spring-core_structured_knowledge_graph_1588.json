[
  {
    "head": "org.springframework.aot.nativex",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.aot.nativex.RuntimeHintsWriterTests",
    "tailType": "class"
  },
  {
    "head": "org.springframework.aot.nativex.RuntimeHintsWriterTests",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.aot.nativex;\n\nimport java.io.StringWriter;\nimport java.nio.charset.Charset;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\nimport com.networknt.schema.InputFormat;\nimport com.networknt.schema.JsonSchema;\nimport com.networknt.schema.JsonSchemaFactory;\nimport com.networknt.schema.SchemaLocation;\nimport com.networknt.schema.SchemaValidatorsConfig;\nimport com.networknt.schema.SpecVersion;\nimport com.networknt.schema.ValidationMessage;\nimport org.json.JSONException;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.skyscreamer.jsonassert.JSONAssert;\nimport org.skyscreamer.jsonassert.JSONCompareMode;\n\nimport org.springframework.aot.hint.ExecutableMode;\nimport org.springframework.aot.hint.MemberCategory;\nimport org.springframework.aot.hint.RuntimeHints;\nimport org.springframework.aot.hint.TypeReference;\nimport org.springframework.core.codec.StringDecoder;\nimport org.springframework.core.env.Environment;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Tests for {@link RuntimeHintsWriter}.\n *\n * @author Brian Clozel\n * @author Sebastien Deleuze\n * @author Stephane Nicoll\n */\nclass RuntimeHintsWriterTests {\n\n\tprivate static JsonSchema JSON_SCHEMA;\n\n\t@BeforeAll\n\tstatic void setupSchemaValidator() {\n\t\tJsonSchemaFactory jsonSchemaFactory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V201909, builder ->\n\t\t\t\tbuilder.schemaMappers(schemaMappers -> schemaMappers.mapPrefix(\"https://www.graalvm.org/\", \"classpath:org/springframework/aot/nativex/\"))\n\t\t);\n\t\tSchemaValidatorsConfig config = SchemaValidatorsConfig.builder().build();\n\t\tJSON_SCHEMA = jsonSchemaFactory.getSchema(SchemaLocation.of(\"https://www.graalvm.org/reachability-metadata-schema-v1.0.0.json\"), config);\n\t}\n\n\t@Nested\n\tclass ReflectionHintsTests {\n\n\t\t@Test\n\t\tvoid empty() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\tassertEquals(\"{}\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid one() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.reflection().registerType(StringDecoder.class, builder -> builder\n\t\t\t\t\t.onReachableType(String.class)\n\t\t\t\t\t.withMembers(MemberCategory.ACCESS_PUBLIC_FIELDS, MemberCategory.ACCESS_DECLARED_FIELDS,\n\t\t\t\t\t\t\tMemberCategory.INVOKE_PUBLIC_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS,\n\t\t\t\t\t\t\tMemberCategory.INVOKE_PUBLIC_METHODS, MemberCategory.INVOKE_DECLARED_METHODS,\n\t\t\t\t\t\t\tMemberCategory.UNSAFE_ALLOCATED)\n\t\t\t\t\t.withField(\"DEFAULT_CHARSET\")\n\t\t\t\t\t.withField(\"defaultCharset\")\n\t\t\t\t\t.withField(\"aScore\")\n\t\t\t\t\t.withMethod(\"setDefaultCharset\", List.of(TypeReference.of(Charset.class)), ExecutableMode.INVOKE));\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"reflection\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": \"org.springframework.core.codec.StringDecoder\",\n\t\t\t\t\t\t\t\"condition\": { \"typeReached\": \"java.lang.String\" },\n\t\t\t\t\t\t\t\"allPublicFields\": true,\n\t\t\t\t\t\t\t\"allDeclaredFields\": true,\n\t\t\t\t\t\t\t\"allPublicConstructors\": true,\n\t\t\t\t\t\t\t\"allDeclaredConstructors\": true,\n\t\t\t\t\t\t\t\"allPublicMethods\": true,\n\t\t\t\t\t\t\t\"allDeclaredMethods\": true,\n\t\t\t\t\t\t\t\"unsafeAllocated\": true,\n\t\t\t\t\t\t\t\"fields\": [\n\t\t\t\t\t\t\t\t{ \"name\": \"aScore\" },\n\t\t\t\t\t\t\t\t{ \"name\": \"DEFAULT_CHARSET\" },\n\t\t\t\t\t\t\t\t{ \"name\": \"defaultCharset\" }\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\"methods\": [\n\t\t\t\t\t\t\t\t{ \"name\": \"setDefaultCharset\", \"parameterTypes\": [ \"java.nio.charset.Charset\" ] }\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid two() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.reflection().registerType(Integer.class, builder -> {\n\t\t\t});\n\t\t\thints.reflection().registerType(Long.class, builder -> {\n\t\t\t});\n\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"reflection\": [\n\t\t\t\t\t\t{ \"type\": \"java.lang.Integer\" },\n\t\t\t\t\t\t{ \"type\": \"java.lang.Long\" }\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid methods() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.reflection().registerType(Integer.class, builder -> builder.withMethod(\"parseInt\",\n\t\t\t\t\tTypeReference.listOf(String.class), ExecutableMode.INVOKE));\n\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"reflection\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": \"java.lang.Integer\",\n\t\t\t\t\t\t\t\"methods\": [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"name\": \"parseInt\",\n\t\t\t\t\t\t\t\t\t\"parameterTypes\": [\"java.lang.String\"]\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid methodWithInnerClassParameter() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.reflection().registerType(Integer.class, builder -> builder.withMethod(\"test\",\n\t\t\t\t\tTypeReference.listOf(InnerClass.class), ExecutableMode.INVOKE));\n\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"reflection\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": \"java.lang.Integer\",\n\t\t\t\t\t\t\t\"methods\": [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"name\": \"test\",\n\t\t\t\t\t\t\t\t\t\"parameterTypes\": [\"org.springframework.aot.nativex.RuntimeHintsWriterTests$InnerClass\"]\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid methodAndQueriedMethods() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.reflection().registerType(Integer.class, builder -> builder.withMethod(\"parseInt\",\n\t\t\t\t\tTypeReference.listOf(String.class), ExecutableMode.INVOKE));\n\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"reflection\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": \"java.lang.Integer\",\n\t\t\t\t\t\t\t\"methods\": [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"name\": \"parseInt\",\n\t\t\t\t\t\t\t\t\t\"parameterTypes\": [\"java.lang.String\"]\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid ignoreLambda() throws JSONException {\n\t\t\tRunnable anonymousRunnable = () -> {};\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.reflection().registerType(anonymousRunnable.getClass());\n\t\t\tassertEquals(\"{}\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid sortTypeHints() {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.reflection().registerType(Integer.class, builder -> {});\n\t\t\thints.reflection().registerType(Long.class, builder -> {});\n\n\t\t\tRuntimeHints hints2 = new RuntimeHints();\n\t\t\thints2.reflection().registerType(Long.class, builder -> {});\n\t\t\thints2.reflection().registerType(Integer.class, builder -> {});\n\n\t\t\tassertThat(writeJson(hints)).isEqualTo(writeJson(hints2));\n\t\t}\n\n\t\t@Test\n\t\tvoid sortFieldHints() {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.reflection().registerType(Integer.class, builder -> {\n\t\t\t\tbuilder.withField(\"first\");\n\t\t\t\tbuilder.withField(\"second\");\n\t\t\t});\n\t\t\tRuntimeHints hints2 = new RuntimeHints();\n\t\t\thints2.reflection().registerType(Integer.class, builder -> {\n\t\t\t\tbuilder.withField(\"second\");\n\t\t\t\tbuilder.withField(\"first\");\n\t\t\t});\n\t\t\tassertThat(writeJson(hints)).isEqualTo(writeJson(hints2));\n\t\t}\n\n\t\t@Test\n\t\tvoid sortConstructorHints() {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.reflection().registerType(Integer.class, builder -> {\n\t\t\t\tbuilder.withConstructor(List.of(TypeReference.of(String.class)), ExecutableMode.INVOKE);\n\t\t\t\tbuilder.withConstructor(List.of(TypeReference.of(String.class),\n\t\t\t\t\t\tTypeReference.of(Integer.class)), ExecutableMode.INVOKE);\n\t\t\t});\n\n\t\t\tRuntimeHints hints2 = new RuntimeHints();\n\t\t\thints2.reflection().registerType(Integer.class, builder -> {\n\t\t\t\tbuilder.withConstructor(List.of(TypeReference.of(String.class),\n\t\t\t\t\t\tTypeReference.of(Integer.class)), ExecutableMode.INVOKE);\n\t\t\t\tbuilder.withConstructor(List.of(TypeReference.of(String.class)), ExecutableMode.INVOKE);\n\t\t\t});\n\t\t\tassertThat(writeJson(hints)).isEqualTo(writeJson(hints2));\n\t\t}\n\n\t\t@Test\n\t\tvoid sortMethodHints() {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.reflection().registerType(Integer.class, builder -> {\n\t\t\t\tbuilder.withMethod(\"test\", Collections.emptyList(), ExecutableMode.INVOKE);\n\t\t\t\tbuilder.withMethod(\"another\", Collections.emptyList(), ExecutableMode.INVOKE);\n\t\t\t});\n\n\t\t\tRuntimeHints hints2 = new RuntimeHints();\n\t\t\thints2.reflection().registerType(Integer.class, builder -> {\n\t\t\t\tbuilder.withMethod(\"another\", Collections.emptyList(), ExecutableMode.INVOKE);\n\t\t\t\tbuilder.withMethod(\"test\", Collections.emptyList(), ExecutableMode.INVOKE);\n\t\t\t});\n\t\t\tassertThat(writeJson(hints)).isEqualTo(writeJson(hints2));\n\t\t}\n\n\t}\n\n\n\t@Nested\n\tclass JniHints {\n\n\t\t// TODO\n\n\t}\n\n\n\t@Nested\n\tclass ResourceHintsTests {\n\n\t\t@Test\n\t\tvoid empty() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\tassertEquals(\"{}\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid registerExactMatch() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.resources().registerPattern(\"com/example/test.properties\");\n\t\t\thints.resources().registerPattern(\"com/example/another.properties\");\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"resources\": [\n\t\t\t\t\t\t{ \"glob\": \"/\" },\n\t\t\t\t\t\t{ \"glob\": \"com\"},\n\t\t\t\t\t\t{ \"glob\": \"com/example\"},\n\t\t\t\t\t\t{ \"glob\": \"com/example/another.properties\"},\n\t\t\t\t\t\t{ \"glob\": \"com/example/test.properties\"}\n\t\t\t\t\t]\n\t\t\t\t}\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid registerWildcardAtTheBeginningPattern() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.resources().registerPattern(\"*.properties\");\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"resources\": [\n\t\t\t\t\t\t{ \"glob\": \"*.properties\"},\n\t\t\t\t\t\t{ \"glob\": \"/\"}\n\t\t\t\t\t]\n\t\t\t\t}\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid registerWildcardInTheMiddlePattern() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.resources().registerPattern(\"com/example/*.properties\");\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"resources\": [\n\t\t\t\t\t\t{ \"glob\": \"/\" },\n\t\t\t\t\t\t{ \"glob\": \"com\"},\n\t\t\t\t\t\t{ \"glob\": \"com/example\"},\n\t\t\t\t\t\t{ \"glob\": \"com/example/*.properties\"}\n\t\t\t\t\t]\n\t\t\t\t}\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid registerWildcardAtTheEndPattern() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.resources().registerPattern(\"static/*\");\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"resources\": [\n\t\t\t\t\t\t{ \"glob\": \"/\" },\n\t\t\t\t\t\t{ \"glob\": \"static\"},\n\t\t\t\t\t\t{ \"glob\": \"static/*\"}\n\t\t\t\t\t]\n\t\t\t\t}\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid registerPatternWithIncludesAndExcludes() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.resources().registerPattern(hint -> hint.includes(\"com/example/*.properties\"));\n\t\t\thints.resources().registerPattern(hint -> hint.includes(\"org/other/*.properties\"));\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"resources\": [\n\t\t\t\t\t\t{ \"glob\": \"/\"},\n\t\t\t\t\t\t{ \"glob\": \"com\"},\n\t\t\t\t\t\t{ \"glob\": \"com/example\"},\n\t\t\t\t\t\t{ \"glob\": \"com/example/*.properties\"},\n\t\t\t\t\t\t{ \"glob\": \"org\"},\n\t\t\t\t\t\t{ \"glob\": \"org/other\"},\n\t\t\t\t\t\t{ \"glob\": \"org/other/*.properties\"}\n\t\t\t\t\t]\n\t\t\t\t}\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid registerWithReachableTypeCondition() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.resources().registerPattern(builder -> builder.includes(TypeReference.of(\"com.example.Test\"), \"com/example/test.properties\"));\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"resources\": [\n\t\t\t\t\t\t{ \"condition\": { \"typeReached\": \"com.example.Test\"}, \"glob\": \"/\"},\n\t\t\t\t\t\t{ \"condition\": { \"typeReached\": \"com.example.Test\"}, \"glob\": \"com\"},\n\t\t\t\t\t\t{ \"condition\": { \"typeReached\": \"com.example.Test\"}, \"glob\": \"com/example\"},\n\t\t\t\t\t\t{ \"condition\": { \"typeReached\": \"com.example.Test\"}, \"glob\": \"com/example/test.properties\"}\n\t\t\t\t\t]\n\t\t\t\t}\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid registerType() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.resources().registerType(String.class);\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"resources\": [\n\t\t\t\t\t\t{ \"glob\": \"/\" },\n\t\t\t\t\t\t{ \"glob\": \"java\" },\n\t\t\t\t\t\t{ \"glob\": \"java/lang\" },\n\t\t\t\t\t\t{ \"glob\": \"java/lang/String.class\" }\n\t\t\t\t\t]\n\t\t\t\t}\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid registerResourceBundle() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.resources().registerResourceBundle(\"com.example.message2\");\n\t\t\thints.resources().registerResourceBundle(\"com.example.message\");\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"bundles\": [\n\t\t\t\t\t\t{ \"name\": \"com.example.message\"},\n\t\t\t\t\t\t{ \"name\": \"com.example.message2\"}\n\t\t\t\t\t]\n\t\t\t\t}\"\"\", hints);\n\t\t}\n\t}\n\n\t@Nested\n\tclass SerializationHintsTests {\n\n\t\t@Test\n\t\tvoid shouldWriteEmptyHint() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\tassertEquals(\"{}\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid shouldWriteSingleHint() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.serialization().registerType(TypeReference.of(String.class));\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"serialization\": [\n\t\t\t\t\t\t{ \"type\": \"java.lang.String\" }\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid shouldWriteMultipleHints() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.serialization()\n\t\t\t\t\t.registerType(TypeReference.of(Environment.class))\n\t\t\t\t\t.registerType(TypeReference.of(String.class));\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"serialization\": [\n\t\t\t\t\t\t{ \"type\": \"java.lang.String\" },\n\t\t\t\t\t\t{ \"type\": \"org.springframework.core.env.Environment\" }\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid shouldWriteSingleHintWithCondition() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.serialization().registerType(TypeReference.of(String.class),\n\t\t\t\t\tbuilder -> builder.onReachableType(TypeReference.of(\"org.example.Test\")));\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"serialization\": [\n\t\t\t\t\t\t{ \"condition\": { \"typeReached\": \"org.example.Test\" }, \"type\": \"java.lang.String\" }\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t\"\"\", hints);\n\t\t}\n\n\t}\n\n\t@Nested\n\tclass ProxyHintsTests {\n\n\t\t@Test\n\t\tvoid empty() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\tassertEquals(\"{}\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid shouldWriteOneEntry() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.proxies().registerJdkProxy(Function.class);\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"reflection\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\"proxy\": [\"java.util.function.Function\"]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid shouldWriteMultipleEntries() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.proxies().registerJdkProxy(Function.class)\n\t\t\t\t\t.registerJdkProxy(Function.class, Consumer.class);\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"reflection\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": { \"proxy\": [\"java.util.function.Function\"] }\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": { \"proxy\": [\"java.util.function.Function\", \"java.util.function.Consumer\"] }\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid shouldWriteEntriesInNaturalOrder() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.proxies().registerJdkProxy(Supplier.class)\n\t\t\t\t\t.registerJdkProxy(Function.class);\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"reflection\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": { \"proxy\": [\"java.util.function.Function\"] }\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": { \"proxy\": [\"java.util.function.Supplier\"] }\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid shouldWriteInnerClass() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.proxies().registerJdkProxy(InnerInterface.class);\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"reflection\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": { \"proxy\": [\"org.springframework.aot.nativex.RuntimeHintsWriterTests$InnerInterface\"] }\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid shouldWriteCondition() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.proxies().registerJdkProxy(builder -> builder.proxiedInterfaces(Function.class)\n\t\t\t\t\t.onReachableType(TypeReference.of(\"org.example.Test\")));\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"reflection\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": { \"proxy\": [\"java.util.function.Function\"] },\n\t\t\t\t\t\t\t\"condition\": { \"typeReached\": \"org.example.Test\" }\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t\"\"\", hints);\n\t\t}\n\n\t}\n\n\tprivate void assertEquals(String expectedString, RuntimeHints hints) throws JSONException {\n\t\tString json = writeJson(hints);\n\t\tJSONAssert.assertEquals(expectedString, json, JSONCompareMode.LENIENT);\n\t\tSet<ValidationMessage> validationMessages = JSON_SCHEMA.validate(json, InputFormat.JSON, executionContext ->\n\t\t\t\texecutionContext.getExecutionConfig().setFormatAssertionsEnabled(true));\n\t\tassertThat(validationMessages).isEmpty();\n\t}\n\n\tprivate String writeJson(RuntimeHints hints) {\n\t\tStringWriter out = new StringWriter();\n\t\tBasicJsonWriter writer = new BasicJsonWriter(out, \"\\t\");\n\t\tnew RuntimeHintsWriter().write(writer, hints);\n\t\treturn out.toString();\n\t}\n\n\n\tstatic class InnerClass {\n\n\t}\n\n\tinterface InnerInterface {\n\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.aot.nativex.RuntimeHintsWriterTests",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.aot.nativex.RuntimeHintsWriterTests#JSON_SCHEMA",
    "tailType": "field"
  },
  {
    "head": "org.springframework.aot.nativex.RuntimeHintsWriterTests#JSON_SCHEMA",
    "headType": "field",
    "relation": "haveType",
    "tail": "JsonSchema",
    "tailType": "type"
  },
  {
    "head": "org.springframework.aot.nativex.RuntimeHintsWriterTests#setupSchemaValidator()",
    "headType": "method",
    "relation": "provide",
    "tail": "@BeforeAll\r\nstatic void setupSchemaValidator() {\r\n    JsonSchemaFactory jsonSchemaFactory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V201909, builder -> builder.schemaMappers(schemaMappers -> schemaMappers.mapPrefix(\"https://www.graalvm.org/\", \"classpath:org/springframework/aot/nativex/\")));\r\n    SchemaValidatorsConfig config = SchemaValidatorsConfig.builder().build();\r\n    JSON_SCHEMA = jsonSchemaFactory.getSchema(SchemaLocation.of(\"https://www.graalvm.org/reachability-metadata-schema-v1.0.0.json\"), config);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.nativex.RuntimeHintsWriterTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.nativex.RuntimeHintsWriterTests#setupSchemaValidator()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.aot.nativex.RuntimeHintsWriterTests#setupSchemaValidator()",
    "headType": "method",
    "relation": "use",
    "tail": "@BeforeAll",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.aot.nativex.RuntimeHintsWriterTests#assertEquals(String,RuntimeHints)",
    "headType": "method",
    "relation": "provide",
    "tail": "private void assertEquals(String expectedString, RuntimeHints hints) throws JSONException {\r\n    String json = writeJson(hints);\r\n    JSONAssert.assertEquals(expectedString, json, JSONCompareMode.LENIENT);\r\n    Set<ValidationMessage> validationMessages = JSON_SCHEMA.validate(json, InputFormat.JSON, executionContext -> executionContext.getExecutionConfig().setFormatAssertionsEnabled(true));\r\n    assertThat(validationMessages).isEmpty();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.nativex.RuntimeHintsWriterTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.nativex.RuntimeHintsWriterTests#assertEquals(String,RuntimeHints)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.aot.nativex.RuntimeHintsWriterTests#writeJson(RuntimeHints)",
    "headType": "method",
    "relation": "provide",
    "tail": "private String writeJson(RuntimeHints hints) {\r\n    StringWriter out = new StringWriter();\r\n    BasicJsonWriter writer = new BasicJsonWriter(out, \"\\t\");\r\n    new RuntimeHintsWriter().write(writer, hints);\r\n    return out.toString();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.nativex.RuntimeHintsWriterTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.nativex.RuntimeHintsWriterTests#writeJson(RuntimeHints)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.aot.nativex",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.aot.nativex.ReflectionHintsTests",
    "tailType": "class"
  },
  {
    "head": "org.springframework.aot.nativex.ReflectionHintsTests",
    "headType": "class",
    "relation": "use",
    "tail": "@Nested",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.aot.nativex.ReflectionHintsTests",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.aot.nativex;\n\nimport java.io.StringWriter;\nimport java.nio.charset.Charset;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\nimport com.networknt.schema.InputFormat;\nimport com.networknt.schema.JsonSchema;\nimport com.networknt.schema.JsonSchemaFactory;\nimport com.networknt.schema.SchemaLocation;\nimport com.networknt.schema.SchemaValidatorsConfig;\nimport com.networknt.schema.SpecVersion;\nimport com.networknt.schema.ValidationMessage;\nimport org.json.JSONException;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.skyscreamer.jsonassert.JSONAssert;\nimport org.skyscreamer.jsonassert.JSONCompareMode;\n\nimport org.springframework.aot.hint.ExecutableMode;\nimport org.springframework.aot.hint.MemberCategory;\nimport org.springframework.aot.hint.RuntimeHints;\nimport org.springframework.aot.hint.TypeReference;\nimport org.springframework.core.codec.StringDecoder;\nimport org.springframework.core.env.Environment;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Tests for {@link RuntimeHintsWriter}.\n *\n * @author Brian Clozel\n * @author Sebastien Deleuze\n * @author Stephane Nicoll\n */\nclass RuntimeHintsWriterTests {\n\n\tprivate static JsonSchema JSON_SCHEMA;\n\n\t@BeforeAll\n\tstatic void setupSchemaValidator() {\n\t\tJsonSchemaFactory jsonSchemaFactory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V201909, builder ->\n\t\t\t\tbuilder.schemaMappers(schemaMappers -> schemaMappers.mapPrefix(\"https://www.graalvm.org/\", \"classpath:org/springframework/aot/nativex/\"))\n\t\t);\n\t\tSchemaValidatorsConfig config = SchemaValidatorsConfig.builder().build();\n\t\tJSON_SCHEMA = jsonSchemaFactory.getSchema(SchemaLocation.of(\"https://www.graalvm.org/reachability-metadata-schema-v1.0.0.json\"), config);\n\t}\n\n\t@Nested\n\tclass ReflectionHintsTests {\n\n\t\t@Test\n\t\tvoid empty() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\tassertEquals(\"{}\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid one() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.reflection().registerType(StringDecoder.class, builder -> builder\n\t\t\t\t\t.onReachableType(String.class)\n\t\t\t\t\t.withMembers(MemberCategory.ACCESS_PUBLIC_FIELDS, MemberCategory.ACCESS_DECLARED_FIELDS,\n\t\t\t\t\t\t\tMemberCategory.INVOKE_PUBLIC_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS,\n\t\t\t\t\t\t\tMemberCategory.INVOKE_PUBLIC_METHODS, MemberCategory.INVOKE_DECLARED_METHODS,\n\t\t\t\t\t\t\tMemberCategory.UNSAFE_ALLOCATED)\n\t\t\t\t\t.withField(\"DEFAULT_CHARSET\")\n\t\t\t\t\t.withField(\"defaultCharset\")\n\t\t\t\t\t.withField(\"aScore\")\n\t\t\t\t\t.withMethod(\"setDefaultCharset\", List.of(TypeReference.of(Charset.class)), ExecutableMode.INVOKE));\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"reflection\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": \"org.springframework.core.codec.StringDecoder\",\n\t\t\t\t\t\t\t\"condition\": { \"typeReached\": \"java.lang.String\" },\n\t\t\t\t\t\t\t\"allPublicFields\": true,\n\t\t\t\t\t\t\t\"allDeclaredFields\": true,\n\t\t\t\t\t\t\t\"allPublicConstructors\": true,\n\t\t\t\t\t\t\t\"allDeclaredConstructors\": true,\n\t\t\t\t\t\t\t\"allPublicMethods\": true,\n\t\t\t\t\t\t\t\"allDeclaredMethods\": true,\n\t\t\t\t\t\t\t\"unsafeAllocated\": true,\n\t\t\t\t\t\t\t\"fields\": [\n\t\t\t\t\t\t\t\t{ \"name\": \"aScore\" },\n\t\t\t\t\t\t\t\t{ \"name\": \"DEFAULT_CHARSET\" },\n\t\t\t\t\t\t\t\t{ \"name\": \"defaultCharset\" }\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\"methods\": [\n\t\t\t\t\t\t\t\t{ \"name\": \"setDefaultCharset\", \"parameterTypes\": [ \"java.nio.charset.Charset\" ] }\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid two() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.reflection().registerType(Integer.class, builder -> {\n\t\t\t});\n\t\t\thints.reflection().registerType(Long.class, builder -> {\n\t\t\t});\n\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"reflection\": [\n\t\t\t\t\t\t{ \"type\": \"java.lang.Integer\" },\n\t\t\t\t\t\t{ \"type\": \"java.lang.Long\" }\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid methods() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.reflection().registerType(Integer.class, builder -> builder.withMethod(\"parseInt\",\n\t\t\t\t\tTypeReference.listOf(String.class), ExecutableMode.INVOKE));\n\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"reflection\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": \"java.lang.Integer\",\n\t\t\t\t\t\t\t\"methods\": [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"name\": \"parseInt\",\n\t\t\t\t\t\t\t\t\t\"parameterTypes\": [\"java.lang.String\"]\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid methodWithInnerClassParameter() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.reflection().registerType(Integer.class, builder -> builder.withMethod(\"test\",\n\t\t\t\t\tTypeReference.listOf(InnerClass.class), ExecutableMode.INVOKE));\n\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"reflection\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": \"java.lang.Integer\",\n\t\t\t\t\t\t\t\"methods\": [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"name\": \"test\",\n\t\t\t\t\t\t\t\t\t\"parameterTypes\": [\"org.springframework.aot.nativex.RuntimeHintsWriterTests$InnerClass\"]\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid methodAndQueriedMethods() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.reflection().registerType(Integer.class, builder -> builder.withMethod(\"parseInt\",\n\t\t\t\t\tTypeReference.listOf(String.class), ExecutableMode.INVOKE));\n\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"reflection\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": \"java.lang.Integer\",\n\t\t\t\t\t\t\t\"methods\": [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"name\": \"parseInt\",\n\t\t\t\t\t\t\t\t\t\"parameterTypes\": [\"java.lang.String\"]\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid ignoreLambda() throws JSONException {\n\t\t\tRunnable anonymousRunnable = () -> {};\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.reflection().registerType(anonymousRunnable.getClass());\n\t\t\tassertEquals(\"{}\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid sortTypeHints() {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.reflection().registerType(Integer.class, builder -> {});\n\t\t\thints.reflection().registerType(Long.class, builder -> {});\n\n\t\t\tRuntimeHints hints2 = new RuntimeHints();\n\t\t\thints2.reflection().registerType(Long.class, builder -> {});\n\t\t\thints2.reflection().registerType(Integer.class, builder -> {});\n\n\t\t\tassertThat(writeJson(hints)).isEqualTo(writeJson(hints2));\n\t\t}\n\n\t\t@Test\n\t\tvoid sortFieldHints() {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.reflection().registerType(Integer.class, builder -> {\n\t\t\t\tbuilder.withField(\"first\");\n\t\t\t\tbuilder.withField(\"second\");\n\t\t\t});\n\t\t\tRuntimeHints hints2 = new RuntimeHints();\n\t\t\thints2.reflection().registerType(Integer.class, builder -> {\n\t\t\t\tbuilder.withField(\"second\");\n\t\t\t\tbuilder.withField(\"first\");\n\t\t\t});\n\t\t\tassertThat(writeJson(hints)).isEqualTo(writeJson(hints2));\n\t\t}\n\n\t\t@Test\n\t\tvoid sortConstructorHints() {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.reflection().registerType(Integer.class, builder -> {\n\t\t\t\tbuilder.withConstructor(List.of(TypeReference.of(String.class)), ExecutableMode.INVOKE);\n\t\t\t\tbuilder.withConstructor(List.of(TypeReference.of(String.class),\n\t\t\t\t\t\tTypeReference.of(Integer.class)), ExecutableMode.INVOKE);\n\t\t\t});\n\n\t\t\tRuntimeHints hints2 = new RuntimeHints();\n\t\t\thints2.reflection().registerType(Integer.class, builder -> {\n\t\t\t\tbuilder.withConstructor(List.of(TypeReference.of(String.class),\n\t\t\t\t\t\tTypeReference.of(Integer.class)), ExecutableMode.INVOKE);\n\t\t\t\tbuilder.withConstructor(List.of(TypeReference.of(String.class)), ExecutableMode.INVOKE);\n\t\t\t});\n\t\t\tassertThat(writeJson(hints)).isEqualTo(writeJson(hints2));\n\t\t}\n\n\t\t@Test\n\t\tvoid sortMethodHints() {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.reflection().registerType(Integer.class, builder -> {\n\t\t\t\tbuilder.withMethod(\"test\", Collections.emptyList(), ExecutableMode.INVOKE);\n\t\t\t\tbuilder.withMethod(\"another\", Collections.emptyList(), ExecutableMode.INVOKE);\n\t\t\t});\n\n\t\t\tRuntimeHints hints2 = new RuntimeHints();\n\t\t\thints2.reflection().registerType(Integer.class, builder -> {\n\t\t\t\tbuilder.withMethod(\"another\", Collections.emptyList(), ExecutableMode.INVOKE);\n\t\t\t\tbuilder.withMethod(\"test\", Collections.emptyList(), ExecutableMode.INVOKE);\n\t\t\t});\n\t\t\tassertThat(writeJson(hints)).isEqualTo(writeJson(hints2));\n\t\t}\n\n\t}\n\n\n\t@Nested\n\tclass JniHints {\n\n\t\t// TODO\n\n\t}\n\n\n\t@Nested\n\tclass ResourceHintsTests {\n\n\t\t@Test\n\t\tvoid empty() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\tassertEquals(\"{}\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid registerExactMatch() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.resources().registerPattern(\"com/example/test.properties\");\n\t\t\thints.resources().registerPattern(\"com/example/another.properties\");\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"resources\": [\n\t\t\t\t\t\t{ \"glob\": \"/\" },\n\t\t\t\t\t\t{ \"glob\": \"com\"},\n\t\t\t\t\t\t{ \"glob\": \"com/example\"},\n\t\t\t\t\t\t{ \"glob\": \"com/example/another.properties\"},\n\t\t\t\t\t\t{ \"glob\": \"com/example/test.properties\"}\n\t\t\t\t\t]\n\t\t\t\t}\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid registerWildcardAtTheBeginningPattern() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.resources().registerPattern(\"*.properties\");\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"resources\": [\n\t\t\t\t\t\t{ \"glob\": \"*.properties\"},\n\t\t\t\t\t\t{ \"glob\": \"/\"}\n\t\t\t\t\t]\n\t\t\t\t}\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid registerWildcardInTheMiddlePattern() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.resources().registerPattern(\"com/example/*.properties\");\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"resources\": [\n\t\t\t\t\t\t{ \"glob\": \"/\" },\n\t\t\t\t\t\t{ \"glob\": \"com\"},\n\t\t\t\t\t\t{ \"glob\": \"com/example\"},\n\t\t\t\t\t\t{ \"glob\": \"com/example/*.properties\"}\n\t\t\t\t\t]\n\t\t\t\t}\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid registerWildcardAtTheEndPattern() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.resources().registerPattern(\"static/*\");\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"resources\": [\n\t\t\t\t\t\t{ \"glob\": \"/\" },\n\t\t\t\t\t\t{ \"glob\": \"static\"},\n\t\t\t\t\t\t{ \"glob\": \"static/*\"}\n\t\t\t\t\t]\n\t\t\t\t}\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid registerPatternWithIncludesAndExcludes() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.resources().registerPattern(hint -> hint.includes(\"com/example/*.properties\"));\n\t\t\thints.resources().registerPattern(hint -> hint.includes(\"org/other/*.properties\"));\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"resources\": [\n\t\t\t\t\t\t{ \"glob\": \"/\"},\n\t\t\t\t\t\t{ \"glob\": \"com\"},\n\t\t\t\t\t\t{ \"glob\": \"com/example\"},\n\t\t\t\t\t\t{ \"glob\": \"com/example/*.properties\"},\n\t\t\t\t\t\t{ \"glob\": \"org\"},\n\t\t\t\t\t\t{ \"glob\": \"org/other\"},\n\t\t\t\t\t\t{ \"glob\": \"org/other/*.properties\"}\n\t\t\t\t\t]\n\t\t\t\t}\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid registerWithReachableTypeCondition() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.resources().registerPattern(builder -> builder.includes(TypeReference.of(\"com.example.Test\"), \"com/example/test.properties\"));\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"resources\": [\n\t\t\t\t\t\t{ \"condition\": { \"typeReached\": \"com.example.Test\"}, \"glob\": \"/\"},\n\t\t\t\t\t\t{ \"condition\": { \"typeReached\": \"com.example.Test\"}, \"glob\": \"com\"},\n\t\t\t\t\t\t{ \"condition\": { \"typeReached\": \"com.example.Test\"}, \"glob\": \"com/example\"},\n\t\t\t\t\t\t{ \"condition\": { \"typeReached\": \"com.example.Test\"}, \"glob\": \"com/example/test.properties\"}\n\t\t\t\t\t]\n\t\t\t\t}\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid registerType() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.resources().registerType(String.class);\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"resources\": [\n\t\t\t\t\t\t{ \"glob\": \"/\" },\n\t\t\t\t\t\t{ \"glob\": \"java\" },\n\t\t\t\t\t\t{ \"glob\": \"java/lang\" },\n\t\t\t\t\t\t{ \"glob\": \"java/lang/String.class\" }\n\t\t\t\t\t]\n\t\t\t\t}\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid registerResourceBundle() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.resources().registerResourceBundle(\"com.example.message2\");\n\t\t\thints.resources().registerResourceBundle(\"com.example.message\");\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"bundles\": [\n\t\t\t\t\t\t{ \"name\": \"com.example.message\"},\n\t\t\t\t\t\t{ \"name\": \"com.example.message2\"}\n\t\t\t\t\t]\n\t\t\t\t}\"\"\", hints);\n\t\t}\n\t}\n\n\t@Nested\n\tclass SerializationHintsTests {\n\n\t\t@Test\n\t\tvoid shouldWriteEmptyHint() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\tassertEquals(\"{}\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid shouldWriteSingleHint() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.serialization().registerType(TypeReference.of(String.class));\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"serialization\": [\n\t\t\t\t\t\t{ \"type\": \"java.lang.String\" }\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid shouldWriteMultipleHints() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.serialization()\n\t\t\t\t\t.registerType(TypeReference.of(Environment.class))\n\t\t\t\t\t.registerType(TypeReference.of(String.class));\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"serialization\": [\n\t\t\t\t\t\t{ \"type\": \"java.lang.String\" },\n\t\t\t\t\t\t{ \"type\": \"org.springframework.core.env.Environment\" }\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid shouldWriteSingleHintWithCondition() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.serialization().registerType(TypeReference.of(String.class),\n\t\t\t\t\tbuilder -> builder.onReachableType(TypeReference.of(\"org.example.Test\")));\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"serialization\": [\n\t\t\t\t\t\t{ \"condition\": { \"typeReached\": \"org.example.Test\" }, \"type\": \"java.lang.String\" }\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t\"\"\", hints);\n\t\t}\n\n\t}\n\n\t@Nested\n\tclass ProxyHintsTests {\n\n\t\t@Test\n\t\tvoid empty() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\tassertEquals(\"{}\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid shouldWriteOneEntry() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.proxies().registerJdkProxy(Function.class);\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"reflection\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\"proxy\": [\"java.util.function.Function\"]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid shouldWriteMultipleEntries() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.proxies().registerJdkProxy(Function.class)\n\t\t\t\t\t.registerJdkProxy(Function.class, Consumer.class);\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"reflection\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": { \"proxy\": [\"java.util.function.Function\"] }\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": { \"proxy\": [\"java.util.function.Function\", \"java.util.function.Consumer\"] }\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid shouldWriteEntriesInNaturalOrder() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.proxies().registerJdkProxy(Supplier.class)\n\t\t\t\t\t.registerJdkProxy(Function.class);\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"reflection\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": { \"proxy\": [\"java.util.function.Function\"] }\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": { \"proxy\": [\"java.util.function.Supplier\"] }\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid shouldWriteInnerClass() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.proxies().registerJdkProxy(InnerInterface.class);\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"reflection\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": { \"proxy\": [\"org.springframework.aot.nativex.RuntimeHintsWriterTests$InnerInterface\"] }\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t\"\"\", hints);\n\t\t}\n\n\t\t@Test\n\t\tvoid shouldWriteCondition() throws JSONException {\n\t\t\tRuntimeHints hints = new RuntimeHints();\n\t\t\thints.proxies().registerJdkProxy(builder -> builder.proxiedInterfaces(Function.class)\n\t\t\t\t\t.onReachableType(TypeReference.of(\"org.example.Test\")));\n\t\t\tassertEquals(\"\"\"\n\t\t\t\t{\n\t\t\t\t\t\"reflection\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"type\": { \"proxy\": [\"java.util.function.Function\"] },\n\t\t\t\t\t\t\t\"condition\": { \"typeReached\": \"org.example.Test\" }\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t\"\"\", hints);\n\t\t}\n\n\t}\n\n\tprivate void assertEquals(String expectedString, RuntimeHints hints) throws JSONException {\n\t\tString json = writeJson(hints);\n\t\tJSONAssert.assertEquals(expectedString, json, JSONCompareMode.LENIENT);\n\t\tSet<ValidationMessage> validationMessages = JSON_SCHEMA.validate(json, InputFormat.JSON, executionContext ->\n\t\t\t\texecutionContext.getExecutionConfig().setFormatAssertionsEnabled(true));\n\t\tassertThat(validationMessages).isEmpty();\n\t}\n\n\tprivate String writeJson(RuntimeHints hints) {\n\t\tStringWriter out = new StringWriter();\n\t\tBasicJsonWriter writer = new BasicJsonWriter(out, \"\\t\");\n\t\tnew RuntimeHintsWriter().write(writer, hints);\n\t\treturn out.toString();\n\t}\n\n\n\tstatic class InnerClass {\n\n\t}\n\n\tinterface InnerInterface {\n\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.aot.nativex.ReflectionHintsTests#empty()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid empty() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    assertEquals(\";\", hints);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.nativex.ReflectionHintsTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.nativex.ReflectionHintsTests#empty()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.aot.nativex.ReflectionHintsTests#empty()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.aot.nativex.ReflectionHintsTests#one()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Test\r\nvoid one() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.reflection().registerType(StringDecoder.class, builder -> builder.onReachableType(String.class).withMembers(MemberCategory.ACCESS_PUBLIC_FIELDS, MemberCategory.ACCESS_DECLARED_FIELDS, MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_PUBLIC_METHODS, MemberCategory.INVOKE_DECLARED_METHODS, MemberCategory.UNSAFE_ALLOCATED).withField(\"DEFAULT_CHARSET\").withField(\"defaultCharset\").withField(\"aScore\").withMethod(\"setDefaultCharset\", List.of(TypeReference.of(Charset.class)), ExecutableMode.INVOKE));\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"reflection\": [\r\n        \t\t{\r\n        \t\t\t\"type\": \"org.springframework.core.codec.StringDecoder\",\r\n        \t\t\t\"condition\": { \"typeReached\": \"java.lang.String\" },\r\n        \t\t\t\"allPublicFields\": true,\r\n        \t\t\t\"allDeclaredFields\": true,\r\n        \t\t\t\"allPublicConstructors\": true,\r\n        \t\t\t\"allDeclaredConstructors\": true,\r\n        \t\t\t\"allPublicMethods\": true,\r\n        \t\t\t\"allDeclaredMethods\": true,\r\n        \t\t\t\"unsafeAllocated\": true,\r\n        \t\t\t\"fields\": [\r\n        \t\t\t\t{ \"name\": \"aScore\" },\r\n        \t\t\t\t{ \"name\": \"DEFAULT_CHARSET\" },\r\n        \t\t\t\t{ \"name\": \"defaultCharset\" }\r\n        \t\t\t],\r\n        \t\t\t\"methods\": [\r\n        \t\t\t\t{ \"name\": \"setDefaultCharset\", \"parameterTypes\": [ \"java.nio.charset.Charset\" ] }\r\n        \t\t\t]\r\n        \t\t}\r\n        \t]\r\n        }\r\n        \"\"\", hints);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.nativex.ReflectionHintsTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.nativex.ReflectionHintsTests#one()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.aot.nativex.ReflectionHintsTests#one()",
    "headType": "method",
    "relation": "use",
    "tail": "@Test",
    "tailType": "annotation"
  }
]