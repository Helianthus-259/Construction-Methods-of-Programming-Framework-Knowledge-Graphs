[
  {
    "head": "org.springframework.core.annotation.AnnotationsScanner#hasPlainJavaAnnotationsOnly(Class<?>)",
    "headType": "method",
    "relation": "provide",
    "tail": "static boolean hasPlainJavaAnnotationsOnly(Class<?> type) {\r\n    return (type.getName().startsWith(\"java.\") || type == Ordered.class);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationsScanner",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotationsScanner#hasPlainJavaAnnotationsOnly(Class<?>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationsScanner#isWithoutHierarchy(AnnotatedElement,Predicate<Class<?>>)",
    "headType": "method",
    "relation": "provide",
    "tail": "private static boolean isWithoutHierarchy(AnnotatedElement source, Predicate<Class<?>> searchEnclosingClass) {\r\n    if (source == Object.class) {\r\n        return true;\r\n    }\r\n    if (source instanceof Class<?> sourceClass) {\r\n        boolean noSuperTypes = (sourceClass.getSuperclass() == Object.class && sourceClass.getInterfaces().length == 0);\r\n        return (searchEnclosingClass.test(sourceClass) ? noSuperTypes && sourceClass.getEnclosingClass() == null : noSuperTypes);\r\n    }\r\n    if (source instanceof Method sourceMethod) {\r\n        return (Modifier.isPrivate(sourceMethod.getModifiers()) || isWithoutHierarchy(sourceMethod.getDeclaringClass(), searchEnclosingClass));\r\n    }\r\n    return true;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationsScanner",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotationsScanner#isWithoutHierarchy(AnnotatedElement,Predicate<Class<?>>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationsScanner#clearCache()",
    "headType": "method",
    "relation": "provide",
    "tail": "static void clearCache() {\r\n    declaredAnnotationCache.clear();\r\n    baseTypeMethodsCache.clear();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationsScanner",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotationsScanner#clearCache()",
    "tailType": "method"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.annotation",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.AnnotationTypeMapping",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationTypeMapping",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.Predicate;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.core.annotation.AnnotationTypeMapping.MirrorSets.MirrorSet;\nimport org.springframework.util.ObjectUtils;\nimport org.springframework.util.StringUtils;\n\n/**\n * Provides mapping information for a single annotation (or meta-annotation) in\n * the context of a root annotation type.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n * @author Juergen Hoeller\n * @since 5.2\n * @see AnnotationTypeMappings\n */\nfinal class AnnotationTypeMapping {\n\n\tprivate static final Log logger = LogFactory.getLog(AnnotationTypeMapping.class);\n\n\tprivate static final Predicate<? super Annotation> isBeanValidationConstraint = annotation ->\n\t\t\tannotation.annotationType().getName().equals(\"jakarta.validation.Constraint\");\n\n\t/**\n\t * Set used to track which convention-based annotation attribute overrides\n\t * have already been checked. Each key is the combination of the fully\n\t * qualified class name of a composed annotation and a meta-annotation\n\t * that it is either present or meta-present on the composed annotation,\n\t * separated by a dash.\n\t * @since 6.0\n\t * @see #addConventionMappings()\n\t */\n\tprivate static final Set<String> conventionBasedOverrideCheckCache = ConcurrentHashMap.newKeySet();\n\n\tprivate static final MirrorSet[] EMPTY_MIRROR_SETS = new MirrorSet[0];\n\n\tprivate static final int[] EMPTY_INT_ARRAY = new int[0];\n\n\n\tprivate final @Nullable AnnotationTypeMapping source;\n\n\tprivate final AnnotationTypeMapping root;\n\n\tprivate final int distance;\n\n\tprivate final Class<? extends Annotation> annotationType;\n\n\tprivate final List<Class<? extends Annotation>> metaTypes;\n\n\tprivate final @Nullable Annotation annotation;\n\n\tprivate final AttributeMethods attributes;\n\n\tprivate final MirrorSets mirrorSets;\n\n\tprivate final int[] aliasMappings;\n\n\tprivate final int[] conventionMappings;\n\n\tprivate final int[] annotationValueMappings;\n\n\tprivate final AnnotationTypeMapping[] annotationValueSource;\n\n\tprivate final Map<Method, List<Method>> aliasedBy;\n\n\tprivate final boolean synthesizable;\n\n\tprivate final Set<Method> claimedAliases = new HashSet<>();\n\n\n\tAnnotationTypeMapping(@Nullable AnnotationTypeMapping source, Class<? extends Annotation> annotationType,\n\t\t\t@Nullable Annotation annotation, Set<Class<? extends Annotation>> visitedAnnotationTypes) {\n\n\t\tthis.source = source;\n\t\tthis.root = (source != null ? source.getRoot() : this);\n\t\tthis.distance = (source == null ? 0 : source.getDistance() + 1);\n\t\tthis.annotationType = annotationType;\n\t\tthis.metaTypes = merge(\n\t\t\t\tsource != null ? source.getMetaTypes() : null,\n\t\t\t\tannotationType);\n\t\tthis.annotation = annotation;\n\t\tthis.attributes = AttributeMethods.forAnnotationType(annotationType);\n\t\tthis.mirrorSets = new MirrorSets();\n\t\tthis.aliasMappings = filledIntArray(this.attributes.size());\n\t\tthis.conventionMappings = filledIntArray(this.attributes.size());\n\t\tthis.annotationValueMappings = filledIntArray(this.attributes.size());\n\t\tthis.annotationValueSource = new AnnotationTypeMapping[this.attributes.size()];\n\t\tthis.aliasedBy = resolveAliasedForTargets();\n\t\tprocessAliases();\n\t\taddConventionMappings();\n\t\taddConventionAnnotationValues();\n\t\tthis.synthesizable = computeSynthesizableFlag(visitedAnnotationTypes);\n\t}\n\n\n\tprivate static <T> List<T> merge(@Nullable List<T> existing, T element) {\n\t\tif (existing == null) {\n\t\t\treturn Collections.singletonList(element);\n\t\t}\n\t\tList<T> merged = new ArrayList<>(existing.size() + 1);\n\t\tmerged.addAll(existing);\n\t\tmerged.add(element);\n\t\treturn Collections.unmodifiableList(merged);\n\t}\n\n\tprivate Map<Method, List<Method>> resolveAliasedForTargets() {\n\t\tMap<Method, List<Method>> aliasedBy = new HashMap<>();\n\t\tfor (int i = 0; i < this.attributes.size(); i++) {\n\t\t\tMethod attribute = this.attributes.get(i);\n\t\t\tAliasFor aliasFor = AnnotationsScanner.getDeclaredAnnotation(attribute, AliasFor.class);\n\t\t\tif (aliasFor != null) {\n\t\t\t\tMethod target = resolveAliasTarget(attribute, aliasFor);\n\t\t\t\taliasedBy.computeIfAbsent(target, key -> new ArrayList<>()).add(attribute);\n\t\t\t}\n\t\t}\n\t\treturn Collections.unmodifiableMap(aliasedBy);\n\t}\n\n\tprivate Method resolveAliasTarget(Method attribute, AliasFor aliasFor) {\n\t\treturn resolveAliasTarget(attribute, aliasFor, true);\n\t}\n\n\tprivate Method resolveAliasTarget(Method attribute, AliasFor aliasFor, boolean checkAliasPair) {\n\t\tif (StringUtils.hasText(aliasFor.value()) && StringUtils.hasText(aliasFor.attribute())) {\n\t\t\tthrow new AnnotationConfigurationException(String.format(\n\t\t\t\t\t\"In @AliasFor declared on %s, attribute 'attribute' and its alias 'value' \" +\n\t\t\t\t\t\"are present with values of '%s' and '%s', but only one is permitted.\",\n\t\t\t\t\tAttributeMethods.describe(attribute), aliasFor.attribute(),\n\t\t\t\t\taliasFor.value()));\n\t\t}\n\t\tClass<? extends Annotation> targetAnnotation = aliasFor.annotation();\n\t\tif (targetAnnotation == Annotation.class) {\n\t\t\ttargetAnnotation = this.annotationType;\n\t\t}\n\t\tString targetAttributeName = aliasFor.attribute();\n\t\tif (!StringUtils.hasLength(targetAttributeName)) {\n\t\t\ttargetAttributeName = aliasFor.value();\n\t\t}\n\t\tif (!StringUtils.hasLength(targetAttributeName)) {\n\t\t\ttargetAttributeName = attribute.getName();\n\t\t}\n\t\tMethod target = AttributeMethods.forAnnotationType(targetAnnotation).get(targetAttributeName);\n\t\tif (target == null) {\n\t\t\tif (targetAnnotation == this.annotationType) {\n\t\t\t\tthrow new AnnotationConfigurationException(String.format(\n\t\t\t\t\t\t\"@AliasFor declaration on %s declares an alias for '%s' which is not present.\",\n\t\t\t\t\t\tAttributeMethods.describe(attribute), targetAttributeName));\n\t\t\t}\n\t\t\tthrow new AnnotationConfigurationException(String.format(\n\t\t\t\t\t\"%s is declared as an @AliasFor nonexistent %s.\",\n\t\t\t\t\tStringUtils.capitalize(AttributeMethods.describe(attribute)),\n\t\t\t\t\tAttributeMethods.describe(targetAnnotation, targetAttributeName)));\n\t\t}\n\t\tif (target.equals(attribute)) {\n\t\t\tthrow new AnnotationConfigurationException(String.format(\n\t\t\t\t\t\"@AliasFor declaration on %s points to itself. \" +\n\t\t\t\t\t\"Specify 'annotation' to point to a same-named attribute on a meta-annotation.\",\n\t\t\t\t\tAttributeMethods.describe(attribute)));\n\t\t}\n\t\tif (!isCompatibleReturnType(attribute.getReturnType(), target.getReturnType())) {\n\t\t\tthrow new AnnotationConfigurationException(String.format(\n\t\t\t\t\t\"Misconfigured aliases: %s and %s must declare the same return type.\",\n\t\t\t\t\tAttributeMethods.describe(attribute),\n\t\t\t\t\tAttributeMethods.describe(target)));\n\t\t}\n\t\tif (isAliasPair(target) && checkAliasPair) {\n\t\t\tAliasFor targetAliasFor = target.getAnnotation(AliasFor.class);\n\t\t\tif (targetAliasFor != null) {\n\t\t\t\tMethod mirror = resolveAliasTarget(target, targetAliasFor, false);\n\t\t\t\tif (!mirror.equals(attribute)) {\n\t\t\t\t\tthrow new AnnotationConfigurationException(String.format(\n\t\t\t\t\t\t\t\"%s must be declared as an @AliasFor %s, not %s.\",\n\t\t\t\t\t\t\tStringUtils.capitalize(AttributeMethods.describe(target)),\n\t\t\t\t\t\t\tAttributeMethods.describe(attribute), AttributeMethods.describe(mirror)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn target;\n\t}\n\n\tprivate boolean isAliasPair(Method target) {\n\t\treturn (this.annotationType == target.getDeclaringClass());\n\t}\n\n\tprivate boolean isCompatibleReturnType(Class<?> attributeType, Class<?> targetType) {\n\t\treturn (attributeType == targetType || attributeType == targetType.componentType());\n\t}\n\n\tprivate void processAliases() {\n\t\tList<Method> aliases = new ArrayList<>();\n\t\tfor (int i = 0; i < this.attributes.size(); i++) {\n\t\t\taliases.clear();\n\t\t\taliases.add(this.attributes.get(i));\n\t\t\tcollectAliases(aliases);\n\t\t\tif (aliases.size() > 1) {\n\t\t\t\tprocessAliases(i, aliases);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void collectAliases(List<Method> aliases) {\n\t\tAnnotationTypeMapping mapping = this;\n\t\twhile (mapping != null) {\n\t\t\tint size = aliases.size();\n\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\tList<Method> additional = mapping.aliasedBy.get(aliases.get(j));\n\t\t\t\tif (additional != null) {\n\t\t\t\t\taliases.addAll(additional);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmapping = mapping.source;\n\t\t}\n\t}\n\n\tprivate void processAliases(int attributeIndex, List<Method> aliases) {\n\t\tint rootAttributeIndex = getFirstRootAttributeIndex(aliases);\n\t\tAnnotationTypeMapping mapping = this;\n\t\twhile (mapping != null) {\n\t\t\tif (rootAttributeIndex != -1 && mapping != this.root) {\n\t\t\t\tfor (int i = 0; i < mapping.attributes.size(); i++) {\n\t\t\t\t\tif (aliases.contains(mapping.attributes.get(i))) {\n\t\t\t\t\t\tmapping.aliasMappings[i] = rootAttributeIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmapping.mirrorSets.updateFrom(aliases);\n\t\t\tmapping.claimedAliases.addAll(aliases);\n\t\t\tif (mapping.annotation != null) {\n\t\t\t\tint[] resolvedMirrors = mapping.mirrorSets.resolve(null,\n\t\t\t\t\t\tmapping.annotation, AnnotationUtils::invokeAnnotationMethod);\n\t\t\t\tfor (int i = 0; i < mapping.attributes.size(); i++) {\n\t\t\t\t\tif (aliases.contains(mapping.attributes.get(i))) {\n\t\t\t\t\t\tthis.annotationValueMappings[attributeIndex] = resolvedMirrors[i];\n\t\t\t\t\t\tthis.annotationValueSource[attributeIndex] = mapping;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmapping = mapping.source;\n\t\t}\n\t}\n\n\tprivate int getFirstRootAttributeIndex(Collection<Method> aliases) {\n\t\tAttributeMethods rootAttributes = this.root.getAttributes();\n\t\tfor (int i = 0; i < rootAttributes.size(); i++) {\n\t\t\tif (aliases.contains(rootAttributes.get(i))) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tprivate void addConventionMappings() {\n\t\tif (this.distance == 0) {\n\t\t\treturn;\n\t\t}\n\t\tAttributeMethods rootAttributes = this.root.getAttributes();\n\t\tint[] mappings = this.conventionMappings;\n\t\tSet<String> conventionMappedAttributes = new HashSet<>();\n\t\tfor (int i = 0; i < mappings.length; i++) {\n\t\t\tString name = this.attributes.get(i).getName();\n\t\t\tint mapped = rootAttributes.indexOf(name);\n\t\t\tif (!MergedAnnotation.VALUE.equals(name) && mapped != -1 && !isExplicitAttributeOverride(name)) {\n\t\t\t\tconventionMappedAttributes.add(name);\n\t\t\t\tmappings[i] = mapped;\n\t\t\t\tMirrorSet mirrors = getMirrorSets().getAssigned(i);\n\t\t\t\tif (mirrors != null) {\n\t\t\t\t\tfor (int j = 0; j < mirrors.size(); j++) {\n\t\t\t\t\t\tmappings[mirrors.getAttributeIndex(j)] = mapped;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tString rootAnnotationTypeName = this.root.annotationType.getName();\n\t\tString cacheKey = rootAnnotationTypeName + '-' + this.annotationType.getName();\n\t\t// We want to avoid duplicate log warnings as much as possible, without full synchronization,\n\t\t// and we intentionally invoke add() before checking if any convention-based overrides were\n\t\t// actually encountered in order to ensure that we add a \"tracked\" entry for the current cache\n\t\t// key in any case.\n\t\t// In addition, we do NOT want to log warnings for custom Java Bean Validation constraint\n\t\t// annotations that are meta-annotated with other constraint annotations -- for example,\n\t\t// @org.hibernate.validator.constraints.URL which overrides attributes in\n\t\t// @jakarta.validation.constraints.Pattern.\n\t\tif (conventionBasedOverrideCheckCache.add(cacheKey) && !conventionMappedAttributes.isEmpty() &&\n\t\t\t\tArrays.stream(this.annotationType.getAnnotations()).noneMatch(isBeanValidationConstraint) &&\n\t\t\t\tlogger.isWarnEnabled()) {\n\t\t\tlogger.warn(\"\"\"\n\t\t\t\t\tSupport for convention-based annotation attribute overrides is deprecated \\\n\t\t\t\t\tand will be removed in Spring Framework 7.0. Please annotate the following \\\n\t\t\t\t\tattributes in @%s with appropriate @AliasFor declarations: %s\"\"\"\n\t\t\t\t\t\t.formatted(rootAnnotationTypeName, conventionMappedAttributes));\n\t\t}\n\t}\n\n\t/**\n\t * Determine if the given annotation attribute in the {@linkplain #getRoot()\n\t * root annotation} is an explicit annotation attribute override for an\n\t * attribute in a meta-annotation, explicit in the sense that the override\n\t * is declared via {@link AliasFor @AliasFor}.\n\t * <p>If the named attribute does not exist in the root annotation, this\n\t * method returns {@code false}.\n\t * @param name the name of the annotation attribute to check\n\t * @since 6.0\n\t */\n\tprivate boolean isExplicitAttributeOverride(String name) {\n\t\tMethod attribute = this.root.getAttributes().get(name);\n\t\tif (attribute != null) {\n\t\t\tAliasFor aliasFor = AnnotationsScanner.getDeclaredAnnotation(attribute, AliasFor.class);\n\t\t\treturn ((aliasFor != null) &&\n\t\t\t\t\t(aliasFor.annotation() != Annotation.class) &&\n\t\t\t\t\t(aliasFor.annotation() != this.root.annotationType));\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate void addConventionAnnotationValues() {\n\t\tfor (int i = 0; i < this.attributes.size(); i++) {\n\t\t\tMethod attribute = this.attributes.get(i);\n\t\t\tboolean isValueAttribute = MergedAnnotation.VALUE.equals(attribute.getName());\n\t\t\tAnnotationTypeMapping mapping = this;\n\t\t\twhile (mapping != null && mapping.distance > 0) {\n\t\t\t\tint mapped = mapping.getAttributes().indexOf(attribute.getName());\n\t\t\t\tif (mapped != -1 && isBetterConventionAnnotationValue(i, isValueAttribute, mapping)) {\n\t\t\t\t\tthis.annotationValueMappings[i] = mapped;\n\t\t\t\t\tthis.annotationValueSource[i] = mapping;\n\t\t\t\t}\n\t\t\t\tmapping = mapping.source;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean isBetterConventionAnnotationValue(int index, boolean isValueAttribute,\n\t\t\tAnnotationTypeMapping mapping) {\n\n\t\tif (this.annotationValueMappings[index] == -1) {\n\t\t\treturn true;\n\t\t}\n\t\tint existingDistance = this.annotationValueSource[index].distance;\n\t\treturn !isValueAttribute && existingDistance > mapping.distance;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate boolean computeSynthesizableFlag(Set<Class<? extends Annotation>> visitedAnnotationTypes) {\n\t\t// Track that we have visited the current annotation type.\n\t\tvisitedAnnotationTypes.add(this.annotationType);\n\n\t\t// Uses @AliasFor for local aliases?\n\t\tfor (int index : this.aliasMappings) {\n\t\t\tif (index != -1) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Uses @AliasFor for attribute overrides in meta-annotations?\n\t\tif (!this.aliasedBy.isEmpty()) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Uses convention-based attribute overrides in meta-annotations?\n\t\tfor (int index : this.conventionMappings) {\n\t\t\tif (index != -1) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Has nested annotations or arrays of annotations that are synthesizable?\n\t\tif (getAttributes().hasNestedAnnotation()) {\n\t\t\tAttributeMethods attributeMethods = getAttributes();\n\t\t\tfor (int i = 0; i < attributeMethods.size(); i++) {\n\t\t\t\tMethod method = attributeMethods.get(i);\n\t\t\t\tClass<?> type = method.getReturnType();\n\t\t\t\tif (type.isAnnotation() || (type.isArray() && type.componentType().isAnnotation())) {\n\t\t\t\t\tClass<? extends Annotation> annotationType =\n\t\t\t\t\t\t\t(Class<? extends Annotation>) (type.isAnnotation() ? type : type.componentType());\n\t\t\t\t\t// Ensure we have not yet visited the current nested annotation type, in order\n\t\t\t\t\t// to avoid infinite recursion for JVM languages other than Java that support\n\t\t\t\t\t// recursive annotation definitions.\n\t\t\t\t\tif (visitedAnnotationTypes.add(annotationType)) {\n\t\t\t\t\t\tAnnotationTypeMapping mapping =\n\t\t\t\t\t\t\t\tAnnotationTypeMappings.forAnnotationType(annotationType, visitedAnnotationTypes).get(0);\n\t\t\t\t\t\tif (mapping.isSynthesizable()) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Method called after all mappings have been set. At this point no further\n\t * lookups from child mappings will occur.\n\t */\n\tvoid afterAllMappingsSet() {\n\t\tvalidateAllAliasesClaimed();\n\t\tfor (int i = 0; i < this.mirrorSets.size(); i++) {\n\t\t\tvalidateMirrorSet(this.mirrorSets.get(i));\n\t\t}\n\t\tthis.claimedAliases.clear();\n\t}\n\n\tprivate void validateAllAliasesClaimed() {\n\t\tfor (int i = 0; i < this.attributes.size(); i++) {\n\t\t\tMethod attribute = this.attributes.get(i);\n\t\t\tAliasFor aliasFor = AnnotationsScanner.getDeclaredAnnotation(attribute, AliasFor.class);\n\t\t\tif (aliasFor != null && !this.claimedAliases.contains(attribute)) {\n\t\t\t\tMethod target = resolveAliasTarget(attribute, aliasFor);\n\t\t\t\tthrow new AnnotationConfigurationException(String.format(\n\t\t\t\t\t\t\"@AliasFor declaration on %s declares an alias for %s which is not meta-present.\",\n\t\t\t\t\t\tAttributeMethods.describe(attribute), AttributeMethods.describe(target)));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void validateMirrorSet(MirrorSet mirrorSet) {\n\t\tMethod firstAttribute = mirrorSet.get(0);\n\t\tObject firstDefaultValue = firstAttribute.getDefaultValue();\n\t\tfor (int i = 1; i <= mirrorSet.size() - 1; i++) {\n\t\t\tMethod mirrorAttribute = mirrorSet.get(i);\n\t\t\tObject mirrorDefaultValue = mirrorAttribute.getDefaultValue();\n\t\t\tif (firstDefaultValue == null || mirrorDefaultValue == null) {\n\t\t\t\tthrow new AnnotationConfigurationException(String.format(\n\t\t\t\t\t\t\"Misconfigured aliases: %s and %s must declare default values.\",\n\t\t\t\t\t\tAttributeMethods.describe(firstAttribute), AttributeMethods.describe(mirrorAttribute)));\n\t\t\t}\n\t\t\tif (!ObjectUtils.nullSafeEquals(firstDefaultValue, mirrorDefaultValue)) {\n\t\t\t\tthrow new AnnotationConfigurationException(String.format(\n\t\t\t\t\t\t\"Misconfigured aliases: %s and %s must declare the same default value.\",\n\t\t\t\t\t\tAttributeMethods.describe(firstAttribute), AttributeMethods.describe(mirrorAttribute)));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the root mapping.\n\t * @return the root mapping\n\t */\n\tAnnotationTypeMapping getRoot() {\n\t\treturn this.root;\n\t}\n\n\t/**\n\t * Get the source of the mapping or {@code null}.\n\t * @return the source of the mapping\n\t */\n\t@Nullable AnnotationTypeMapping getSource() {\n\t\treturn this.source;\n\t}\n\n\t/**\n\t * Get the distance of this mapping.\n\t * @return the distance of the mapping\n\t */\n\tint getDistance() {\n\t\treturn this.distance;\n\t}\n\n\t/**\n\t * Get the type of the mapped annotation.\n\t * @return the annotation type\n\t */\n\tClass<? extends Annotation> getAnnotationType() {\n\t\treturn this.annotationType;\n\t}\n\n\tList<Class<? extends Annotation>> getMetaTypes() {\n\t\treturn this.metaTypes;\n\t}\n\n\t/**\n\t * Get the source annotation for this mapping. This will be the\n\t * meta-annotation, or {@code null} if this is the root mapping.\n\t * @return the source annotation of the mapping\n\t */\n\t@Nullable Annotation getAnnotation() {\n\t\treturn this.annotation;\n\t}\n\n\t/**\n\t * Get the annotation attributes for the mapping annotation type.\n\t * @return the attribute methods\n\t */\n\tAttributeMethods getAttributes() {\n\t\treturn this.attributes;\n\t}\n\n\t/**\n\t * Get the related index of an alias mapped attribute, or {@code -1} if\n\t * there is no mapping. The resulting value is the index of the attribute on\n\t * the root annotation that can be invoked in order to obtain the actual\n\t * value.\n\t * @param attributeIndex the attribute index of the source attribute\n\t * @return the mapped attribute index or {@code -1}\n\t */\n\tint getAliasMapping(int attributeIndex) {\n\t\treturn this.aliasMappings[attributeIndex];\n\t}\n\n\t/**\n\t * Get the related index of a convention mapped attribute, or {@code -1}\n\t * if there is no mapping. The resulting value is the index of the attribute\n\t * on the root annotation that can be invoked in order to obtain the actual\n\t * value.\n\t * @param attributeIndex the attribute index of the source attribute\n\t * @return the mapped attribute index or {@code -1}\n\t */\n\tint getConventionMapping(int attributeIndex) {\n\t\treturn this.conventionMappings[attributeIndex];\n\t}\n\n\t/**\n\t * Get a mapped attribute value from the most suitable\n\t * {@link #getAnnotation() meta-annotation}.\n\t * <p>The resulting value is obtained from the closest meta-annotation,\n\t * taking into consideration both convention and alias based mapping rules.\n\t * For root mappings, this method will always return {@code null}.\n\t * @param attributeIndex the attribute index of the source attribute\n\t * @param metaAnnotationsOnly if only meta annotations should be considered.\n\t * If this parameter is {@code false} then aliases within the annotation will\n\t * also be considered.\n\t * @return the mapped annotation value, or {@code null}\n\t */\n\t@Nullable Object getMappedAnnotationValue(int attributeIndex, boolean metaAnnotationsOnly) {\n\t\tint mappedIndex = this.annotationValueMappings[attributeIndex];\n\t\tif (mappedIndex == -1) {\n\t\t\treturn null;\n\t\t}\n\t\tAnnotationTypeMapping source = this.annotationValueSource[attributeIndex];\n\t\tif (source == this && metaAnnotationsOnly) {\n\t\t\treturn null;\n\t\t}\n\t\treturn AnnotationUtils.invokeAnnotationMethod(source.attributes.get(mappedIndex), source.annotation);\n\t}\n\n\t/**\n\t * Determine if the specified value is equivalent to the default value of the\n\t * attribute at the given index.\n\t * @param attributeIndex the attribute index of the source attribute\n\t * @param value the value to check\n\t * @param valueExtractor the value extractor used to extract values from any\n\t * nested annotations\n\t * @return {@code true} if the value is equivalent to the default value\n\t */\n\tboolean isEquivalentToDefaultValue(int attributeIndex, Object value, ValueExtractor valueExtractor) {\n\t\tMethod attribute = this.attributes.get(attributeIndex);\n\t\treturn isEquivalentToDefaultValue(attribute, value, valueExtractor);\n\t}\n\n\t/**\n\t * Get the mirror sets for this type mapping.\n\t * @return the attribute mirror sets\n\t */\n\tMirrorSets getMirrorSets() {\n\t\treturn this.mirrorSets;\n\t}\n\n\t/**\n\t * Determine if the mapped annotation is <em>synthesizable</em>.\n\t * <p>Consult the documentation for {@link MergedAnnotation#synthesize()}\n\t * for an explanation of what is considered synthesizable.\n\t * @return {@code true} if the mapped annotation is synthesizable\n\t * @since 5.2.6\n\t */\n\tboolean isSynthesizable() {\n\t\treturn this.synthesizable;\n\t}\n\n\n\tprivate static int[] filledIntArray(int size) {\n\t\tif (size == 0) {\n\t\t\treturn EMPTY_INT_ARRAY;\n\t\t}\n\t\tint[] array = new int[size];\n\t\tArrays.fill(array, -1);\n\t\treturn array;\n\t}\n\n\tprivate static boolean isEquivalentToDefaultValue(Method attribute, Object value,\n\t\t\tValueExtractor valueExtractor) {\n\n\t\treturn areEquivalent(attribute.getDefaultValue(), value, valueExtractor);\n\t}\n\n\tprivate static boolean areEquivalent(@Nullable Object value, @Nullable Object extractedValue,\n\t\t\tValueExtractor valueExtractor) {\n\n\t\tif (ObjectUtils.nullSafeEquals(value, extractedValue)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (value instanceof Class<?> clazz && extractedValue instanceof String string) {\n\t\t\treturn areEquivalent(clazz, string);\n\t\t}\n\t\tif (value instanceof Class<?>[] classes && extractedValue instanceof String[] strings) {\n\t\t\treturn areEquivalent(classes, strings);\n\t\t}\n\t\tif (value instanceof Annotation annotation) {\n\t\t\treturn areEquivalent(annotation, extractedValue, valueExtractor);\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate static boolean areEquivalent(Class<?>[] value, String[] extractedValue) {\n\t\tif (value.length != extractedValue.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < value.length; i++) {\n\t\t\tif (!areEquivalent(value[i], extractedValue[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static boolean areEquivalent(Class<?> value, String extractedValue) {\n\t\treturn value.getName().equals(extractedValue);\n\t}\n\n\tprivate static boolean areEquivalent(Annotation annotation, @Nullable Object extractedValue,\n\t\t\tValueExtractor valueExtractor) {\n\n\t\tAttributeMethods attributes = AttributeMethods.forAnnotationType(annotation.annotationType());\n\t\tfor (int i = 0; i < attributes.size(); i++) {\n\t\t\tMethod attribute = attributes.get(i);\n\t\t\tObject value1 = AnnotationUtils.invokeAnnotationMethod(attribute, annotation);\n\t\t\tObject value2;\n\t\t\tif (extractedValue instanceof TypeMappedAnnotation<?> typeMappedAnnotation) {\n\t\t\t\tvalue2 = typeMappedAnnotation.getValue(attribute.getName()).orElse(null);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue2 = valueExtractor.extract(attribute, extractedValue);\n\t\t\t}\n\t\t\tif (!areEquivalent(value1, value2, valueExtractor)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\n\t/**\n\t * A collection of {@link MirrorSet} instances that provides details of all\n\t * defined mirrors.\n\t */\n\tclass MirrorSets {\n\n\t\tprivate MirrorSet[] mirrorSets;\n\n\t\tprivate final MirrorSet[] assigned;\n\n\t\tMirrorSets() {\n\t\t\tthis.assigned = attributes.size() > 0 ? new MirrorSet[attributes.size()] : EMPTY_MIRROR_SETS;\n\t\t\tthis.mirrorSets = EMPTY_MIRROR_SETS;\n\t\t}\n\n\t\tvoid updateFrom(Collection<Method> aliases) {\n\t\t\tMirrorSet mirrorSet = null;\n\t\t\tint size = 0;\n\t\t\tint last = -1;\n\t\t\tfor (int i = 0; i < attributes.size(); i++) {\n\t\t\t\tMethod attribute = attributes.get(i);\n\t\t\t\tif (aliases.contains(attribute)) {\n\t\t\t\t\tsize++;\n\t\t\t\t\tif (size > 1) {\n\t\t\t\t\t\tif (mirrorSet == null) {\n\t\t\t\t\t\t\tmirrorSet = new MirrorSet();\n\t\t\t\t\t\t\tthis.assigned[last] = mirrorSet;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.assigned[i] = mirrorSet;\n\t\t\t\t\t}\n\t\t\t\t\tlast = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mirrorSet != null) {\n\t\t\t\tmirrorSet.update();\n\t\t\t\tSet<MirrorSet> unique = new LinkedHashSet<>(Arrays.asList(this.assigned));\n\t\t\t\tunique.remove(null);\n\t\t\t\tthis.mirrorSets = unique.toArray(EMPTY_MIRROR_SETS);\n\t\t\t}\n\t\t}\n\n\t\tint size() {\n\t\t\treturn this.mirrorSets.length;\n\t\t}\n\n\t\tMirrorSet get(int index) {\n\t\t\treturn this.mirrorSets[index];\n\t\t}\n\n\t\t@Nullable MirrorSet getAssigned(int attributeIndex) {\n\t\t\treturn this.assigned[attributeIndex];\n\t\t}\n\n\t\tint[] resolve(@Nullable Object source, @Nullable Object annotation, ValueExtractor valueExtractor) {\n\t\t\tif (attributes.size() == 0) {\n\t\t\t\treturn EMPTY_INT_ARRAY;\n\t\t\t}\n\t\t\tint[] result = new int[attributes.size()];\n\t\t\tfor (int i = 0; i < result.length; i++) {\n\t\t\t\tresult[i] = i;\n\t\t\t}\n\t\t\tfor (int i = 0; i < size(); i++) {\n\t\t\t\tMirrorSet mirrorSet = get(i);\n\t\t\t\tint resolved = mirrorSet.resolve(source, annotation, valueExtractor);\n\t\t\t\tfor (int j = 0; j < mirrorSet.size; j++) {\n\t\t\t\t\tresult[mirrorSet.indexes[j]] = resolved;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\n\t\t/**\n\t\t * A single set of mirror attributes.\n\t\t */\n\t\tclass MirrorSet {\n\n\t\t\tprivate int size;\n\n\t\t\tprivate final int[] indexes = new int[attributes.size()];\n\n\t\t\tvoid update() {\n\t\t\t\tthis.size = 0;\n\t\t\t\tArrays.fill(this.indexes, -1);\n\t\t\t\tfor (int i = 0; i < MirrorSets.this.assigned.length; i++) {\n\t\t\t\t\tif (MirrorSets.this.assigned[i] == this) {\n\t\t\t\t\t\tthis.indexes[this.size] = i;\n\t\t\t\t\t\tthis.size++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t<A> int resolve(@Nullable Object source, @Nullable A annotation, ValueExtractor valueExtractor) {\n\t\t\t\tint result = -1;\n\t\t\t\tObject lastValue = null;\n\t\t\t\tfor (int i = 0; i < this.size; i++) {\n\t\t\t\t\tMethod attribute = attributes.get(this.indexes[i]);\n\t\t\t\t\tObject value = valueExtractor.extract(attribute, annotation);\n\t\t\t\t\tboolean isDefaultValue = (value == null ||\n\t\t\t\t\t\t\tisEquivalentToDefaultValue(attribute, value, valueExtractor));\n\t\t\t\t\tif (isDefaultValue || ObjectUtils.nullSafeEquals(lastValue, value)) {\n\t\t\t\t\t\tif (result == -1) {\n\t\t\t\t\t\t\tresult = this.indexes[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (lastValue != null && !ObjectUtils.nullSafeEquals(lastValue, value)) {\n\t\t\t\t\t\tString on = (source != null) ? \" declared on \" + source : \"\";\n\t\t\t\t\t\tthrow new AnnotationConfigurationException(String.format(\n\t\t\t\t\t\t\t\t\"Different @AliasFor mirror values for annotation [%s]%s; attribute '%s' \" +\n\t\t\t\t\t\t\t\t\"and its alias '%s' are declared with values of [%s] and [%s].\",\n\t\t\t\t\t\t\t\tgetAnnotationType().getName(), on,\n\t\t\t\t\t\t\t\tattributes.get(result).getName(),\n\t\t\t\t\t\t\t\tattribute.getName(),\n\t\t\t\t\t\t\t\tObjectUtils.nullSafeToString(lastValue),\n\t\t\t\t\t\t\t\tObjectUtils.nullSafeToString(value)));\n\t\t\t\t\t}\n\t\t\t\t\tresult = this.indexes[i];\n\t\t\t\t\tlastValue = value;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tint size() {\n\t\t\t\treturn this.size;\n\t\t\t}\n\n\t\t\tMethod get(int index) {\n\t\t\t\tint attributeIndex = this.indexes[index];\n\t\t\t\treturn attributes.get(attributeIndex);\n\t\t\t}\n\n\t\t\tint getAttributeIndex(int index) {\n\t\t\t\treturn this.indexes[index];\n\t\t\t}\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationTypeMapping",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.AnnotationTypeMapping#logger",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationTypeMapping#logger",
    "headType": "field",
    "relation": "haveType",
    "tail": "Log",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationTypeMapping",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.AnnotationTypeMapping#isBeanValidationConstraint",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationTypeMapping#isBeanValidationConstraint",
    "headType": "field",
    "relation": "haveType",
    "tail": "Predicate<? super Annotation>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationTypeMapping",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.AnnotationTypeMapping#conventionBasedOverrideCheckCache",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationTypeMapping#conventionBasedOverrideCheckCache",
    "headType": "field",
    "relation": "haveType",
    "tail": "Set<String>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationTypeMapping",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.AnnotationTypeMapping#EMPTY_MIRROR_SETS",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationTypeMapping#EMPTY_MIRROR_SETS",
    "headType": "field",
    "relation": "haveType",
    "tail": "MirrorSet",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationTypeMapping",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.AnnotationTypeMapping#EMPTY_INT_ARRAY",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationTypeMapping#EMPTY_INT_ARRAY",
    "headType": "field",
    "relation": "haveType",
    "tail": "int",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.AnnotationTypeMapping",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.AnnotationTypeMapping#source",
    "tailType": "field"
  }
]