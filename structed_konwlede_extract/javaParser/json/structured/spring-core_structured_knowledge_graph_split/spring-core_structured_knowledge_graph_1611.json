[
  {
    "head": "org.springframework.core.annotation.ClassWithInheritedComposedAnnotation",
    "headType": "class",
    "relation": "use",
    "tail": "@InheritedComposed",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.ClassWithInheritedComposedAnnotation",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Set;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.ParametersAreNonnullByDefault;\nimport javax.annotation.meta.When;\n\nimport jakarta.annotation.Resource;\nimport org.jspecify.annotations.Nullable;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.AnnotationUtilsTests.ExtendsBaseClassWithGenericAnnotatedMethod;\nimport org.springframework.core.annotation.AnnotationUtilsTests.ImplementsInterfaceWithGenericAnnotatedMethod;\nimport org.springframework.core.annotation.AnnotationUtilsTests.WebController;\nimport org.springframework.core.annotation.AnnotationUtilsTests.WebMapping;\nimport org.springframework.core.testfixture.stereotype.Component;\nimport org.springframework.core.testfixture.stereotype.Indexed;\nimport org.springframework.util.MultiValueMap;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.Collectors.toSet;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.findAllMergedAnnotations;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.findMergedAnnotation;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getAllAnnotationAttributes;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getAllMergedAnnotations;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getMergedAnnotation;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getMergedAnnotationAttributes;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getMetaAnnotationTypes;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.hasAnnotation;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.hasMetaAnnotationTypes;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.isAnnotated;\nimport static org.springframework.core.annotation.AnnotationUtilsTests.asArray;\n\n/**\n * Tests for {@link AnnotatedElementUtils}.\n *\n * @author Sam Brannen\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 4.0.3\n * @see AnnotationUtilsTests\n * @see MultipleComposedAnnotationsOnSingleAnnotatedElementTests\n * @see ComposedRepeatableAnnotationsTests\n * @see NestedRepeatableAnnotationsTests\n */\nclass AnnotatedElementUtilsTests {\n\n\tprivate static final String TX_NAME = Transactional.class.getName();\n\n\n\t@Nested\n\tclass ConventionBasedAnnotationAttributeOverrideTests {\n\n\t\t@Test\n\t\tvoid getMergedAnnotationAttributesWithConventionBasedComposedAnnotation() {\n\t\t\tClass<?> element = ConventionBasedComposedContextConfigClass.class;\n\t\t\tString name = ContextConfig.class.getName();\n\t\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\n\t\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").containsExactly(\"explicitDeclaration\");\n\t\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").containsExactly(\"explicitDeclaration\");\n\n\t\t\t// Verify contracts between utility methods:\n\t\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t\t}\n\n\t\t/**\n\t\t * This test should never pass, simply because Spring does not support a hybrid\n\t\t * approach for annotation attribute overrides with transitive implicit aliases.\n\t\t * See SPR-13554 for details.\n\t\t * <p>Furthermore, if you choose to execute this test, it can fail for either\n\t\t * the first test class or the second one (with different exceptions), depending\n\t\t * on the order in which the JVM returns the attribute methods via reflection.\n\t\t */\n\t\t@Disabled(\"Permanently disabled but left in place for illustrative purposes\")\n\t\t@Test\n\t\tvoid getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation() {\n\t\t\tfor (Class<?> clazz : asList(HalfConventionBasedAndHalfAliasedComposedContextConfigClassV1.class,\n\t\t\t\t\tHalfConventionBasedAndHalfAliasedComposedContextConfigClassV2.class)) {\n\t\t\t\tgetMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation(clazz);\n\t\t\t}\n\t\t}\n\n\t\tprivate void getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation(Class<?> clazz) {\n\t\t\tString name = ContextConfig.class.getName();\n\t\t\tString simpleName = clazz.getSimpleName();\n\t\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(clazz, name);\n\n\t\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + simpleName).isNotNull();\n\t\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations for class [\" + simpleName + \"]\")\n\t\t\t\t.containsExactly(\"explicitDeclaration\");\n\t\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value for class [\" + simpleName + \"]\")\n\t\t\t\t.containsExactly(\"explicitDeclaration\");\n\n\t\t\t// Verify contracts between utility methods:\n\t\t\tassertThat(isAnnotated(clazz, name)).isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid getMergedAnnotationAttributesWithInvalidConventionBasedComposedAnnotation() {\n\t\t\tClass<?> element = InvalidConventionBasedComposedContextConfigClass.class;\n\t\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\t\tgetMergedAnnotationAttributes(element, ContextConfig.class))\n\t\t\t\t\t.withMessageContaining(\"Different @AliasFor mirror values for annotation\")\n\t\t\t\t\t.withMessageContaining(\"attribute 'locations' and its alias 'value'\")\n\t\t\t\t\t.withMessageContaining(\"values of [{requiredLocationsDeclaration}] and [{duplicateDeclaration}]\");\n\t\t}\n\n\t\t@Test\n\t\tvoid findMergedAnnotationAttributesWithSingleElementOverridingAnArrayViaConvention() {\n\t\t\tassertComponentScanAttributes(ConventionBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\n\t\t}\n\n\t\t@Test\n\t\tvoid findMergedAnnotationWithLocalAliasesThatConflictWithAttributesInMetaAnnotationByConvention() {\n\t\t\tClass<?> element = SpringAppConfigClass.class;\n\t\t\tContextConfig contextConfig = findMergedAnnotation(element, ContextConfig.class);\n\n\t\t\tassertThat(contextConfig).as(\"Should find @ContextConfig on \" + element).isNotNull();\n\t\t\tassertThat(contextConfig.locations()).as(\"locations for \" + element).isEmpty();\n\t\t\t// 'value' in @SpringAppConfig should not override 'value' in @ContextConfig\n\t\t\tassertThat(contextConfig.value()).as(\"value for \" + element).isEmpty();\n\t\t\tassertThat(contextConfig.classes()).as(\"classes for \" + element).containsExactly(Number.class);\n\t\t}\n\n\t\t@Test\n\t\tvoid findMergedAnnotationWithSingleElementOverridingAnArrayViaConvention() throws Exception {\n\t\t\tassertWebMapping(WebController.class.getMethod(\"postMappedWithPathAttribute\"));\n\t\t}\n\n\t}\n\n\n\t@Test\n\tvoid getMetaAnnotationTypesOnNonAnnotatedClass() {\n\t\tassertThat(getMetaAnnotationTypes(NonAnnotatedClass.class, TransactionalComponent.class)).isEmpty();\n\t\tassertThat(getMetaAnnotationTypes(NonAnnotatedClass.class, TransactionalComponent.class.getName())).isEmpty();\n\t}\n\n\t@Test\n\tvoid getMetaAnnotationTypesOnClassWithMetaDepth1() {\n\t\tSet<String> names = getMetaAnnotationTypes(TransactionalComponentClass.class, TransactionalComponent.class);\n\t\tassertThat(names).isEqualTo(names(Transactional.class, Component.class, Indexed.class));\n\n\t\tnames = getMetaAnnotationTypes(TransactionalComponentClass.class, TransactionalComponent.class.getName());\n\t\tassertThat(names).isEqualTo(names(Transactional.class, Component.class, Indexed.class));\n\t}\n\n\t@Test\n\tvoid getMetaAnnotationTypesOnClassWithMetaDepth2() {\n\t\tSet<String> names = getMetaAnnotationTypes(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class);\n\t\tassertThat(names).isEqualTo(names(TransactionalComponent.class, Transactional.class, Component.class, Indexed.class));\n\n\t\tnames = getMetaAnnotationTypes(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class.getName());\n\t\tassertThat(names).isEqualTo(names(TransactionalComponent.class, Transactional.class, Component.class, Indexed.class));\n\t}\n\n\tprivate Set<String> names(Class<?>... classes) {\n\t\treturn stream(classes).map(Class::getName).collect(toSet());\n\t}\n\n\t@Test\n\tvoid hasMetaAnnotationTypesOnNonAnnotatedClass() {\n\t\tassertThat(hasMetaAnnotationTypes(NonAnnotatedClass.class, TX_NAME)).isFalse();\n\t}\n\n\t@Test\n\tvoid hasMetaAnnotationTypesOnClassWithMetaDepth0() {\n\t\tassertThat(hasMetaAnnotationTypes(TransactionalComponentClass.class, TransactionalComponent.class.getName())).isFalse();\n\t}\n\n\t@Test\n\tvoid hasMetaAnnotationTypesOnClassWithMetaDepth1() {\n\t\tassertThat(hasMetaAnnotationTypes(TransactionalComponentClass.class, TX_NAME)).isTrue();\n\t\tassertThat(hasMetaAnnotationTypes(TransactionalComponentClass.class, Component.class.getName())).isTrue();\n\t}\n\n\t@Test\n\tvoid hasMetaAnnotationTypesOnClassWithMetaDepth2() {\n\t\tassertThat(hasMetaAnnotationTypes(ComposedTransactionalComponentClass.class, TX_NAME)).isTrue();\n\t\tassertThat(hasMetaAnnotationTypes(ComposedTransactionalComponentClass.class, Component.class.getName())).isTrue();\n\t\tassertThat(hasMetaAnnotationTypes(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class.getName())).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotatedOnNonAnnotatedClass() {\n\t\tassertThat(isAnnotated(NonAnnotatedClass.class, Transactional.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotatedOnClassWithMetaDepth() {\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, TransactionalComponent.class)).isTrue();\n\t\tassertThat(isAnnotated(SubTransactionalComponentClass.class, TransactionalComponent.class)).as(\"isAnnotated() does not search the class hierarchy.\").isFalse();\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, Transactional.class)).isTrue();\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, Component.class)).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, Transactional.class)).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, Component.class)).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class)).isTrue();\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid isAnnotatedForPlainTypes() {\n\t\tassertThat(isAnnotated(Order.class, Documented.class)).isTrue();\n\t\tassertThat(isAnnotated(org.springframework.lang.NonNullApi.class, Documented.class)).isTrue();\n\t\tassertThat(isAnnotated(org.springframework.lang.NonNullApi.class, Nonnull.class)).isTrue();\n\t\tassertThat(isAnnotated(ParametersAreNonnullByDefault.class, Nonnull.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isAnnotatedWithNameOnNonAnnotatedClass() {\n\t\tassertThat(isAnnotated(NonAnnotatedClass.class, TX_NAME)).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotatedWithNameOnClassWithMetaDepth() {\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, TransactionalComponent.class.getName())).isTrue();\n\t\tassertThat(isAnnotated(SubTransactionalComponentClass.class, TransactionalComponent.class.getName())).as(\"isAnnotated() does not search the class hierarchy.\").isFalse();\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, TX_NAME)).isTrue();\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, Component.class.getName())).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, TX_NAME)).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, Component.class.getName())).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class.getName())).isTrue();\n\t}\n\n\t@Test\n\tvoid hasAnnotationOnNonAnnotatedClass() {\n\t\tassertThat(hasAnnotation(NonAnnotatedClass.class, Transactional.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid hasAnnotationOnClassWithMetaDepth() {\n\t\tassertThat(hasAnnotation(TransactionalComponentClass.class, TransactionalComponent.class)).isTrue();\n\t\tassertThat(hasAnnotation(SubTransactionalComponentClass.class, TransactionalComponent.class)).isTrue();\n\t\tassertThat(hasAnnotation(TransactionalComponentClass.class, Transactional.class)).isTrue();\n\t\tassertThat(hasAnnotation(TransactionalComponentClass.class, Component.class)).isTrue();\n\t\tassertThat(hasAnnotation(ComposedTransactionalComponentClass.class, Transactional.class)).isTrue();\n\t\tassertThat(hasAnnotation(ComposedTransactionalComponentClass.class, Component.class)).isTrue();\n\t\tassertThat(hasAnnotation(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class)).isTrue();\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid hasAnnotationForPlainTypes() {\n\t\tassertThat(hasAnnotation(Order.class, Documented.class)).isTrue();\n\t\tassertThat(hasAnnotation(org.springframework.lang.NonNullApi.class, Documented.class)).isTrue();\n\t\tassertThat(hasAnnotation(org.springframework.lang.NonNullApi.class, Nonnull.class)).isTrue();\n\t\tassertThat(hasAnnotation(ParametersAreNonnullByDefault.class, Nonnull.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesOnNonAnnotatedClass() {\n\t\tassertThat(getAllAnnotationAttributes(NonAnnotatedClass.class, TX_NAME)).isNull();\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesOnClassWithLocalAnnotation() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxConfig.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on TxConfig\").isNotNull();\n\t\tassertThat(attributes.get(\"value\")).as(\"value for TxConfig\").isEqualTo(List.of(\"TxConfig\"));\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesOnClassWithLocalComposedAnnotationAndInheritedAnnotation() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(SubClassWithInheritedAnnotation.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on SubClassWithInheritedAnnotation\").isNotNull();\n\t\tassertThat(attributes.get(\"qualifier\")).isEqualTo(asList(\"composed2\", \"transactionManager\"));\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(SubSubClassWithInheritedAnnotation.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on SubSubClassWithInheritedAnnotation\").isNotNull();\n\t\tassertThat(attributes.get(\"qualifier\")).isEqualTo(List.of(\"transactionManager\"));\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes( SubSubClassWithInheritedComposedAnnotation.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on SubSubClassWithInheritedComposedAnnotation\").isNotNull();\n\t\tassertThat(attributes.get(\"qualifier\")).isEqualTo(List.of(\"composed1\"));\n\t}\n\n\t/**\n\t * If the \"value\" entry contains both \"DerivedTxConfig\" AND \"TxConfig\", then\n\t * the algorithm is accidentally picking up shadowed annotations of the same\n\t * type within the class hierarchy. Such undesirable behavior would cause the\n\t * logic in {@code org.springframework.context.annotation.ProfileCondition}\n\t * to fail.\n\t */\n\t@Test\n\tvoid getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\n\t\t// See org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on DerivedTxConfig\").isNotNull();\n\t\tassertThat(attributes.get(\"value\")).as(\"value for DerivedTxConfig\").isEqualTo(List.of(\"DerivedTxConfig\"));\n\t}\n\n\t/**\n\t * Note: this functionality is required by {@code org.springframework.context.annotation.ProfileCondition}.\n\t */\n\t@Test\n\tvoid getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {\n\t\t// See org.springframework.core.env.EnvironmentSystemIntegrationTests\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations\").isNotNull();\n\t\tassertThat(attributes.get(\"value\")).as(\"value for TxFromMultipleComposedAnnotations.\").isEqualTo(asList(\"TxInheritedComposed\", \"TxComposed\"));\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid getAllAnnotationAttributesOnLangType() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(\n\t\t\t\torg.springframework.lang.NonNullApi.class, Nonnull.class.getName());\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Nonnull on NonNullApi\").isNotNull();\n\t\tassertThat(attributes.get(\"when\")).as(\"value for NonNullApi\").isEqualTo(List.of(When.ALWAYS));\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesOnJavaxType() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(\n\t\t\t\tParametersAreNonnullByDefault.class, Nonnull.class.getName());\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Nonnull on NonNullApi\").isNotNull();\n\t\tassertThat(attributes.get(\"when\")).as(\"value for NonNullApi\").isEqualTo(List.of(When.ALWAYS));\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnClassWithLocalAnnotation() {\n\t\tClass<?> element = TxConfig.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Annotation attributes for @Transactional on TxConfig\").isNotNull();\n\t\tassertThat(attributes.getString(\"value\")).as(\"value for TxConfig\").isEqualTo(\"TxConfig\");\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\n\t\tClass<?> element = DerivedTxConfig.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Annotation attributes for @Transactional on DerivedTxConfig\").isNotNull();\n\t\tassertThat(attributes.getString(\"value\")).as(\"value for DerivedTxConfig\").isEqualTo(\"DerivedTxConfig\");\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(MetaCycleAnnotatedClass.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Should not find annotation attributes for @Transactional on MetaCycleAnnotatedClass\").isNull();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesFavorsLocalComposedAnnotationOverInheritedAnnotation() {\n\t\tClass<?> element = SubClassWithInheritedAnnotation.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"AnnotationAttributes for @Transactional on SubClassWithInheritedAnnotation\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t\tassertThat(attributes.getBoolean(\"readOnly\")).as(\"readOnly flag for SubClassWithInheritedAnnotation.\").isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tClass<?> element = SubSubClassWithInheritedAnnotation.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"AnnotationAttributes for @Transactional on SubSubClassWithInheritedAnnotation\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t\tassertThat(attributes.getBoolean(\"readOnly\")).as(\"readOnly flag for SubSubClassWithInheritedAnnotation.\").isFalse();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tClass<?> element = SubSubClassWithInheritedComposedAnnotation.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"AnnotationAttributes for @Transactional on SubSubClassWithInheritedComposedAnnotation.\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t\tassertThat(attributes.getBoolean(\"readOnly\")).as(\"readOnly flag for SubSubClassWithInheritedComposedAnnotation.\").isFalse();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesFromInterfaceImplementedBySuperclass() {\n\t\tClass<?> element = ConcreteClassWithInheritedAnnotation.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Should not find @Transactional on ConcreteClassWithInheritedAnnotation\").isNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isFalse();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnInheritedAnnotationInterface() {\n\t\tClass<?> element = InheritedAnnotationInterface.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Should find @Transactional on InheritedAnnotationInterface\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnNonInheritedAnnotationInterface() {\n\t\tClass<?> element = NonInheritedAnnotationInterface.class;\n\t\tString name = Order.class.getName();\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Should find @Order on NonInheritedAnnotationInterface\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesWithAliasedComposedAnnotation() {\n\t\tClass<?> element = AliasedComposedContextConfigClass.class;\n\t\tString name = ContextConfig.class.getName();\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\n\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(asArray(\"test.xml\"));\n\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(asArray(\"test.xml\"));\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesWithAliasedValueComposedAnnotation() {\n\t\tClass<?> element = AliasedValueComposedContextConfigClass.class;\n\t\tString name = ContextConfig.class.getName();\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\n\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(asArray(\"test.xml\"));\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(asArray(\"test.xml\"));\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesWithImplicitAliasesInMetaAnnotationOnComposedAnnotation() {\n\t\tClass<?> element = ComposedImplicitAliasesContextConfigClass.class;\n\t\tString name = ImplicitAliasesContextConfig.class.getName();\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tString[] expected = asArray(\"A.xml\", \"B.xml\");\n\n\t\tassertThat(attributes).as(\"Should find @ImplicitAliasesContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"groovyScripts\")).as(\"groovyScripts\").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"xmlFiles\")).as(\"xmlFiles\").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(expected);\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithAliasedValueComposedAnnotation() {\n\t\tassertGetMergedAnnotation(AliasedValueComposedContextConfigClass.class, \"test.xml\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithImplicitAliasesForSameAttributeInComposedAnnotation() {\n\t\tassertGetMergedAnnotation(ImplicitAliasesContextConfigClass1.class, \"foo.xml\");\n\t\tassertGetMergedAnnotation(ImplicitAliasesContextConfigClass2.class, \"bar.xml\");\n\t\tassertGetMergedAnnotation(ImplicitAliasesContextConfigClass3.class, \"baz.xml\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithTransitiveImplicitAliases() {\n\t\tassertGetMergedAnnotation(TransitiveImplicitAliasesContextConfigClass.class, \"test.groovy\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithTransitiveImplicitAliasesWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\tassertGetMergedAnnotation(SingleLocationTransitiveImplicitAliasesContextConfigClass.class, \"test.groovy\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithTransitiveImplicitAliasesWithSkippedLevel() {\n\t\tassertGetMergedAnnotation(TransitiveImplicitAliasesWithSkippedLevelContextConfigClass.class, \"test.xml\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithTransitiveImplicitAliasesWithSkippedLevelWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\tassertGetMergedAnnotation(SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigClass.class, \"test.xml\");\n\t}\n\n\tprivate void assertGetMergedAnnotation(Class<?> element, String... expected) {\n\t\tString name = ContextConfig.class.getName();\n\t\tContextConfig contextConfig = getMergedAnnotation(element, ContextConfig.class);\n\n\t\tassertThat(contextConfig).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(contextConfig.locations()).as(\"locations\").isEqualTo(expected);\n\t\tassertThat(contextConfig.value()).as(\"value\").isEqualTo(expected);\n\t\tObject[] expecteds = new Class<?>[0];\n\t\tassertThat(contextConfig.classes()).as(\"classes\").isEqualTo(expecteds);\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithImplicitAliasesInMetaAnnotationOnComposedAnnotation() {\n\t\tClass<?> element = ComposedImplicitAliasesContextConfigClass.class;\n\t\tString name = ImplicitAliasesContextConfig.class.getName();\n\t\tImplicitAliasesContextConfig config = getMergedAnnotation(element, ImplicitAliasesContextConfig.class);\n\t\tString[] expected = asArray(\"A.xml\", \"B.xml\");\n\n\t\tassertThat(config).as(\"Should find @ImplicitAliasesContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(config.groovyScripts()).as(\"groovyScripts\").isEqualTo(expected);\n\t\tassertThat(config.xmlFiles()).as(\"xmlFiles\").isEqualTo(expected);\n\t\tassertThat(config.locations()).as(\"locations\").isEqualTo(expected);\n\t\tassertThat(config.value()).as(\"value\").isEqualTo(expected);\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithImplicitAliasesWithDefaultsInMetaAnnotationOnComposedAnnotation() {\n\t\tClass<?> element = ImplicitAliasesWithDefaultsClass.class;\n\t\tString name = AliasesWithDefaults.class.getName();\n\t\tAliasesWithDefaults annotation = getMergedAnnotation(element, AliasesWithDefaults.class);\n\n\t\tassertThat(annotation).as(\"Should find @AliasesWithDefaults on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(annotation.a1()).as(\"a1\").isEqualTo(\"ImplicitAliasesWithDefaults\");\n\t\tassertThat(annotation.a2()).as(\"a2\").isEqualTo(\"ImplicitAliasesWithDefaults\");\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesWithShadowedAliasComposedAnnotation() {\n\t\tClass<?> element = ShadowedAliasComposedContextConfigClass.class;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, ContextConfig.class);\n\n\t\tString[] expected = asArray(\"test.xml\");\n\n\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(expected);\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(InheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on InheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnSubInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(SubInheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on SubInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnSubSubInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(SubSubInheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on SubSubInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnNonInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(NonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on NonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnSubNonInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(SubNonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on SubNonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnSubSubNonInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(SubSubNonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on SubSubNonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesInheritedFromInterfaceMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleFromInterface\");\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(method, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on ConcreteClassWithInheritedAnnotation.handleFromInterface() method\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesInheritedFromAbstractMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handle\");\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on ConcreteClassWithInheritedAnnotation.handle() method\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleParameterized\", String.class);\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()\").isNotNull();\n\t}\n\n\t/**\n\t * Bridge/bridged method setup code copied from\n\t * {@link org.springframework.core.BridgeMethodResolverTests#withGenericParameter()}.\n\t * @since 4.2\n\t */\n\t@Test\n\tvoid findMergedAnnotationAttributesFromBridgeMethod() {\n\t\tMethod[] methods = StringGenericParameter.class.getMethods();\n\t\tMethod bridgeMethod = null;\n\t\tMethod bridgedMethod = null;\n\n\t\tfor (Method method : methods) {\n\t\t\tif (\"getFor\".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {\n\t\t\t\tif (method.getReturnType().equals(Object.class)) {\n\t\t\t\t\tbridgeMethod = method;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbridgedMethod = method;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\n\t\tboolean condition = bridgedMethod != null && !bridgedMethod.isBridge();\n\t\tassertThat(condition).isTrue();\n\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on StringGenericParameter.getFor() bridge method\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnClassWithMetaAndLocalTxConfig() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(MetaAndLocalTxConfigClass.class, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on MetaAndLocalTxConfigClass\").isNotNull();\n\t\tassertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier for MetaAndLocalTxConfigClass.\").isEqualTo(\"localTxMgr\");\n\t}\n\n\t@Test\n\tvoid findAndSynthesizeAnnotationAttributesOnClassWithAttributeAliasesInTargetAnnotation() {\n\t\tString qualifier = \"aliasForQualifier\";\n\n\t\t// 1) Find and merge AnnotationAttributes from the annotation hierarchy\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(\n\t\t\t\tAliasedTransactionalComponentClass.class, AliasedTransactional.class);\n\t\tassertThat(attributes).as(\"@AliasedTransactional on AliasedTransactionalComponentClass.\").isNotNull();\n\n\t\t// 2) Synthesize the AnnotationAttributes back into the target annotation\n\t\tAliasedTransactional annotation = AnnotationUtils.synthesizeAnnotation(attributes,\n\t\t\t\tAliasedTransactional.class, AliasedTransactionalComponentClass.class);\n\t\tassertThat(annotation).isNotNull();\n\n\t\t// 3) Verify that the AnnotationAttributes and synthesized annotation are equivalent\n\t\tassertThat(attributes.getString(\"value\")).as(\"TX value via attributes.\").isEqualTo(qualifier);\n\t\tassertThat(annotation.value()).as(\"TX value via synthesized annotation.\").isEqualTo(qualifier);\n\t\tassertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier via attributes.\").isEqualTo(qualifier);\n\t\tassertThat(annotation.qualifier()).as(\"TX qualifier via synthesized annotation.\").isEqualTo(qualifier);\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnClassWithAttributeAliasInComposedAnnotationAndNestedAnnotationsInTargetAnnotation() {\n\t\tAnnotationAttributes attributes = assertComponentScanAttributes(TestComponentScanClass.class, \"com.example.app.test\");\n\n\t\tFilter[] excludeFilters = attributes.getAnnotationArray(\"excludeFilters\", Filter.class);\n\t\tassertThat(excludeFilters).isNotNull();\n\n\t\tList<String> patterns = stream(excludeFilters).map(Filter::pattern).collect(toList());\n\t\tassertThat(patterns).isEqualTo(asList(\"*Test\", \"*Tests\"));\n\t}\n\n\t/**\n\t * This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}\n\t * uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation\n\t * attributes since attributes may be arrays.\n\t */\n\t@Test\n\tvoid findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {\n\t\tassertComponentScanAttributes(ComponentScanWithBasePackagesAndValueAliasClass.class, \"com.example.app.test\");\n\t}\n\n\t/**\n\t * @since 5.2.1\n\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\n\t */\n\t@Test\n\tvoid findMergedAnnotationAttributesOnMethodWithComposedMetaTransactionalAnnotation() throws Exception {\n\t\tMethod method = getClass().getDeclaredMethod(\"composedTransactionalMethod\");\n\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(method, AliasedTransactional.class);\n\t\tassertThat(attributes).as(\"Should find @AliasedTransactional on \" + method).isNotNull();\n\t\tassertThat(attributes.getString(\"value\")).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t/**\n\t * @since 5.2.1\n\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\n\t */\n\t@Test\n\tvoid findMergedAnnotationOnMethodWithComposedMetaTransactionalAnnotation() throws Exception {\n\t\tMethod method = getClass().getDeclaredMethod(\"composedTransactionalMethod\");\n\n\t\tAliasedTransactional annotation = findMergedAnnotation(method, AliasedTransactional.class);\n\t\tassertThat(annotation).as(\"Should find @AliasedTransactional on \" + method).isNotNull();\n\t\tassertThat(annotation.value()).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(annotation.qualifier()).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t/**\n\t * @since 5.2.1\n\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\n\t */\n\t@Test\n\tvoid findMergedAnnotationAttributesOnClassWithComposedMetaTransactionalAnnotation() {\n\t\tClass<?> clazz = ComposedTransactionalClass.class;\n\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(clazz, AliasedTransactional.class);\n\t\tassertThat(attributes).as(\"Should find @AliasedTransactional on \" + clazz).isNotNull();\n\t\tassertThat(attributes.getString(\"value\")).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t/**\n\t * @since 5.2.1\n\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\n\t */\n\t@Test\n\tvoid findMergedAnnotationOnClassWithComposedMetaTransactionalAnnotation() {\n\t\tClass<?> clazz = ComposedTransactionalClass.class;\n\n\t\tAliasedTransactional annotation = findMergedAnnotation(clazz, AliasedTransactional.class);\n\t\tassertThat(annotation).as(\"Should find @AliasedTransactional on \" + clazz).isNotNull();\n\t\tassertThat(annotation.value()).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(annotation.qualifier()).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\tassertComponentScanAttributes(AliasForBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\n\t}\n\n\tprivate AnnotationAttributes assertComponentScanAttributes(Class<?> element, String... expected) {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(element, ComponentScan.class);\n\n\t\tassertThat(attributes).as(\"Should find @ComponentScan on \" + element).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value: \").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"basePackages\")).as(\"basePackages: \").isEqualTo(expected);\n\n\t\treturn attributes;\n\t}\n\n\tprivate AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element, Class<? extends Annotation> annotationType) {\n\t\treturn AnnotatedElementUtils.findMergedAnnotationAttributes(element, annotationType.getName(), false, false);\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationWithAttributeAliasesInTargetAnnotation() {\n\t\tClass<?> element = AliasedTransactionalComponentClass.class;\n\t\tAliasedTransactional annotation = findMergedAnnotation(element, AliasedTransactional.class);\n\t\tassertThat(annotation).as(\"@AliasedTransactional on \" + element).isNotNull();\n\t\tassertThat(annotation.value()).as(\"TX value via synthesized annotation.\").isEqualTo(\"aliasForQualifier\");\n\t\tassertThat(annotation.qualifier()).as(\"TX qualifier via synthesized annotation.\").isEqualTo(\"aliasForQualifier\");\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationForMultipleMetaAnnotationsWithClashingAttributeNames() {\n\t\tString[] xmlLocations = asArray(\"test.xml\");\n\t\tString[] propFiles = asArray(\"test.properties\");\n\n\t\tClass<?> element = AliasedComposedContextConfigAndTestPropSourceClass.class;\n\n\t\tContextConfig contextConfig = findMergedAnnotation(element, ContextConfig.class);\n\t\tassertThat(contextConfig).as(\"@ContextConfig on \" + element).isNotNull();\n\t\tassertThat(contextConfig.locations()).as(\"locations\").isEqualTo(xmlLocations);\n\t\tassertThat(contextConfig.value()).as(\"value\").isEqualTo(xmlLocations);\n\n\t\t// Synthesized annotation\n\t\tTestPropSource testPropSource = AnnotationUtils.findAnnotation(element, TestPropSource.class);\n\t\tassertThat(testPropSource.locations()).as(\"locations\").isEqualTo(propFiles);\n\t\tassertThat(testPropSource.value()).as(\"value\").isEqualTo(propFiles);\n\n\t\t// Merged annotation\n\t\ttestPropSource = findMergedAnnotation(element, TestPropSource.class);\n\t\tassertThat(testPropSource).as(\"@TestPropSource on \" + element).isNotNull();\n\t\tassertThat(testPropSource.locations()).as(\"locations\").isEqualTo(propFiles);\n\t\tassertThat(testPropSource.value()).as(\"value\").isEqualTo(propFiles);\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationWithSingleElementOverridingAnArrayViaAliasFor() throws Exception {\n\t\tassertWebMapping(WebController.class.getMethod(\"getMappedWithValueAttribute\"));\n\t\tassertWebMapping(WebController.class.getMethod(\"getMappedWithPathAttribute\"));\n\t}\n\n\tprivate void assertWebMapping(AnnotatedElement element) {\n\t\tWebMapping webMapping = findMergedAnnotation(element, WebMapping.class);\n\t\tassertThat(webMapping).isNotNull();\n\t\tassertThat(webMapping.value()).as(\"value attribute: \").isEqualTo(asArray(\"/test\"));\n\t\tassertThat(webMapping.path()).as(\"path attribute: \").isEqualTo(asArray(\"/test\"));\n\t}\n\n\t@Test\n\tvoid javaLangAnnotationTypeViaFindMergedAnnotation() throws Exception {\n\t\tConstructor<?> deprecatedCtor = Date.class.getConstructor(String.class);\n\t\tassertThat(findMergedAnnotation(deprecatedCtor, Deprecated.class)).isEqualTo(deprecatedCtor.getAnnotation(Deprecated.class));\n\t\tassertThat(findMergedAnnotation(Date.class, Deprecated.class)).isEqualTo(Date.class.getAnnotation(Deprecated.class));\n\t}\n\n\t@Test\n\tvoid javaxAnnotationTypeViaFindMergedAnnotation() {\n\t\tassertThat(findMergedAnnotation(ResourceHolder.class, Resource.class)).isEqualTo(ResourceHolder.class.getAnnotation(Resource.class));\n\t\tassertThat(findMergedAnnotation(SpringAppConfigClass.class, Resource.class)).isEqualTo(SpringAppConfigClass.class.getAnnotation(Resource.class));\n\t}\n\n\t@Test\n\tvoid javaxMetaAnnotationTypeViaFindMergedAnnotation() {\n\t\tassertThat(findMergedAnnotation(ParametersAreNonnullByDefault.class, Nonnull.class)).isEqualTo(ParametersAreNonnullByDefault.class.getAnnotation(Nonnull.class));\n\t\tassertThat(findMergedAnnotation(ResourceHolder.class, Nonnull.class)).isEqualTo(ParametersAreNonnullByDefault.class.getAnnotation(Nonnull.class));\n\t}\n\n\t@Test\n\tvoid nullableAnnotationTypeViaFindMergedAnnotation() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tassertThat(findMergedAnnotation(method, Resource.class)).isEqualTo(method.getAnnotation(Resource.class));\n\t}\n\n\t@Test\n\tvoid getAllMergedAnnotationsOnClassWithInterface() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tSet<Transactional> allMergedAnnotations = getAllMergedAnnotations(method, Transactional.class);\n\t\tassertThat(allMergedAnnotations).isEmpty();\n\t}\n\n\t@Test\n\tvoid findAllMergedAnnotationsOnClassWithInterface() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tSet<Transactional> allMergedAnnotations = findAllMergedAnnotations(method, Transactional.class);\n\t\tassertThat(allMergedAnnotations).hasSize(1);\n\t}\n\n\t@Test  // SPR-16060\n\tvoid findMethodAnnotationFromGenericInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tOrder order = findMergedAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test  // SPR-17146\n\tvoid findMethodAnnotationFromGenericSuperclass() throws Exception {\n\t\tMethod method = ExtendsBaseClassWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tOrder order = findMergedAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test // gh-22655\n\tvoid forAnnotationsCreatesCopyOfArrayOnEachCall() {\n\t\tAnnotatedElement element = AnnotatedElementUtils.forAnnotations(ForAnnotationsClass.class.getDeclaredAnnotations());\n\t\t// Trigger the NPE as originally reported in the bug\n\t\tAnnotationsScanner.getDeclaredAnnotations(element, false);\n\t\tAnnotationsScanner.getDeclaredAnnotations(element, false);\n\t\t// Also specifically test we get different instances\n\t\tassertThat(element.getDeclaredAnnotations()).isNotSameAs(element.getDeclaredAnnotations());\n\t}\n\n\t@Test // gh-22703\n\tvoid getMergedAnnotationOnThreeDeepMetaWithValue() {\n\t\tValueAttribute annotation = AnnotatedElementUtils.getMergedAnnotation(\n\t\t\t\tValueAttributeMetaMetaClass.class, ValueAttribute.class);\n\t\tassertThat(annotation.value()).containsExactly(\"FromValueAttributeMeta\");\n\t}\n\n\t/**\n\t * @since 5.3.25\n\t */\n\t@Test // gh-29685\n\tvoid getMergedRepeatableAnnotationsWithContainerWithMultipleAttributes() {\n\t\tSet<StandardRepeatableWithContainerWithMultipleAttributes> repeatableAnnotations =\n\t\t\t\tAnnotatedElementUtils.getMergedRepeatableAnnotations(\n\t\t\t\t\t\tStandardRepeatablesWithContainerWithMultipleAttributesTestCase.class,\n\t\t\t\t\t\tStandardRepeatableWithContainerWithMultipleAttributes.class);\n\t\tassertThat(repeatableAnnotations).map(StandardRepeatableWithContainerWithMultipleAttributes::value)\n\t\t\t\t.containsExactly(\"a\", \"b\");\n\t}\n\n\t/**\n\t * @since 5.3.25\n\t */\n\t@Test // gh-29685\n\tvoid findMergedRepeatableAnnotationsWithContainerWithMultipleAttributes() {\n\t\tSet<StandardRepeatableWithContainerWithMultipleAttributes> repeatableAnnotations =\n\t\t\t\tAnnotatedElementUtils.findMergedRepeatableAnnotations(\n\t\t\t\t\t\tStandardRepeatablesWithContainerWithMultipleAttributesTestCase.class,\n\t\t\t\t\t\tStandardRepeatableWithContainerWithMultipleAttributes.class);\n\t\tassertThat(repeatableAnnotations).map(StandardRepeatableWithContainerWithMultipleAttributes::value)\n\t\t\t\t.containsExactly(\"a\", \"b\");\n\t}\n\n\t// -------------------------------------------------------------------------\n\n\t@MetaCycle3\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.ANNOTATION_TYPE)\n\t@interface MetaCycle1 {\n\t}\n\n\t@MetaCycle1\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.ANNOTATION_TYPE)\n\t@interface MetaCycle2 {\n\t}\n\n\t@MetaCycle2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface MetaCycle3 {\n\t}\n\n\t@MetaCycle3\n\tstatic class MetaCycleAnnotatedClass {\n\t}\n\n\t// -------------------------------------------------------------------------\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Inherited\n\t@interface Transactional {\n\n\t\tString value() default \"\";\n\n\t\tString qualifier() default \"transactionManager\";\n\n\t\tboolean readOnly() default false;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Inherited\n\t@interface AliasedTransactional {\n\n\t\t@AliasFor(\"qualifier\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString qualifier() default \"\";\n\t}\n\n\t@AliasedTransactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@interface MyAliasedTransactional {\n\n\t\t@AliasFor(annotation = AliasedTransactional.class, attribute = \"value\")\n\t\tString value() default \"defaultTransactionManager\";\n\t}\n\n\t@MyAliasedTransactional(\"anotherTransactionManager\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@interface ComposedMyAliasedTransactional {\n\t}\n\n\t@Transactional(qualifier = \"composed1\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@Inherited\n\t@interface InheritedComposed {\n\t}\n\n\t@Transactional(qualifier = \"composed2\", readOnly = true)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface Composed {\n\t}\n\n\t@Transactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxComposedWithOverride {\n\n\t\tString qualifier() default \"txMgr\";\n\t}\n\n\t@Transactional(\"TxInheritedComposed\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxInheritedComposed {\n\t}\n\n\t@Transactional(\"TxComposed\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxComposed {\n\t}\n\n\t@Transactional\n\t@Component\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransactionalComponent {\n\t}\n\n\t@TransactionalComponent\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedTransactionalComponent {\n\t}\n\n\t@AliasedTransactional(value = \"aliasForQualifier\")\n\t@Component\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedTransactionalComponent {\n\t}\n\n\t@TxComposedWithOverride\n\t// Override default \"txMgr\" from @TxComposedWithOverride with \"localTxMgr\"\n\t@Transactional(qualifier = \"localTxMgr\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface MetaAndLocalTxConfig {\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.test.context.TestPropertySource}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestPropSource {\n\n\t\t@AliasFor(\"locations\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] locations() default {};\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.test.context.ContextConfiguration}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContextConfig {\n\n\t\t@AliasFor(\"locations\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] locations() default {};\n\n\t\tClass<?>[] classes() default {};\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionBasedComposedContextConfig {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfig.class)\n\t\tString[] locations() default {};\n\t}\n\n\t@ContextConfig(value = \"duplicateDeclaration\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface InvalidConventionBasedComposedContextConfig {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfig.class)\n\t\tString[] locations();\n\t}\n\n\t/**\n\t * This hybrid approach for annotation attribute overrides with transitive implicit\n\t * aliases is unsupported. See SPR-13554 for details.\n\t */\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface HalfConventionBasedAndHalfAliasedComposedContextConfig {\n\n\t\tString[] locations() default {};\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles() default {};\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles();\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedValueComposedContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"value\")\n\t\tString[] locations();\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] groovyScripts() default {};\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlFiles() default {};\n\n\t\t// intentionally omitted: attribute = \"locations\"\n\t\t@AliasFor(annotation = ContextConfig.class)\n\t\tString[] locations() default {};\n\n\t\t// intentionally omitted: attribute = \"locations\" (SPR-14069)\n\t\t@AliasFor(annotation = ContextConfig.class)\n\t\tString[] value() default {};\n\t}\n\n\t@ImplicitAliasesContextConfig(xmlFiles = {\"A.xml\", \"B.xml\"})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedImplicitAliasesContextConfig {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasesWithDefaults {\n\n\t\t@AliasFor(\"a2\")\n\t\tString a1() default \"AliasesWithDefaults\";\n\n\t\t@AliasFor(\"a1\")\n\t\tString a2() default \"AliasesWithDefaults\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasesWithDefaults\n\t@interface ImplicitAliasesWithDefaults {\n\n\t\t@AliasFor(annotation = AliasesWithDefaults.class, attribute = \"a1\")\n\t\tString b1() default \"ImplicitAliasesWithDefaults\";\n\n\t\t@AliasFor(annotation = AliasesWithDefaults.class, attribute = \"a2\")\n\t\tString b2() default \"ImplicitAliasesWithDefaults\";\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"xmlFiles\")\n\t\tString[] xml() default {};\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScripts\")\n\t\tString[] groovy() default {};\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SingleLocationTransitiveImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"xmlFiles\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScripts\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesWithSkippedLevelContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xml() default {};\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScripts\")\n\t\tString[] groovy() default {};\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScripts\")\n\t\tString groovy() default \"\";\n\t}\n\n\t/**\n\t * Although the configuration declares an explicit value for 'value' and\n\t * requires a value for the aliased 'locations', this does not result in\n\t * an error since 'locations' effectively <em>shadows</em> the 'value'\n\t * attribute (which cannot be set via the composed annotation anyway).\n\t *\n\t * If 'value' were not shadowed, such a declaration would not make sense.\n\t */\n\t@ContextConfig(value = \"duplicateDeclaration\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ShadowedAliasComposedContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles();\n\t}\n\n\t@ContextConfig(locations = \"shadowed.xml\")\n\t@TestPropSource(locations = \"test.properties\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfigAndTestPropSource {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles() default \"default.xml\";\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.boot.test.SpringApplicationConfiguration}.\n\t */\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SpringAppConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] locations() default {};\n\n\t\t// Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfig.class, attribute = \"classes\")\n\t\t@AliasFor(\"value\")\n\t\tClass<?>[] classes() default {};\n\n\t\t// Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfig.class, attribute = \"classes\")\n\t\t@AliasFor(\"classes\")\n\t\tClass<?>[] value() default {};\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.context.annotation.ComponentScan}\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScan {\n\n\t\t@AliasFor(\"basePackages\")\n\t\tString[] value() default {};\n\n\t\t// Intentionally no alias declaration for \"value\"\n\t\tString[] basePackages() default {};\n\n\t\tFilter[] excludeFilters() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({})\n\t@interface Filter {\n\n\t\tString pattern();\n\t}\n\n\t@ComponentScan(excludeFilters = {@Filter(pattern = \"*Test\"), @Filter(pattern = \"*Tests\")})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestComponentScan {\n\n\t\t@AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\n\t\tString[] packages();\n\t}\n\n\t@ComponentScan\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionBasedSinglePackageComponentScan {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ComponentScan.class)\n\t\tString basePackages();\n\t}\n\n\t@ComponentScan\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForBasedSinglePackageComponentScan {\n\n\t\t@AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\n\t\tString pkg();\n\t}\n\n\t// -------------------------------------------------------------------------\n\n\tstatic class NonAnnotatedClass {\n\t}\n\n\t@TransactionalComponent\n\tstatic class TransactionalComponentClass {\n\t}\n\n\tstatic class SubTransactionalComponentClass extends TransactionalComponentClass {\n\t}\n\n\t@ComposedTransactionalComponent\n\tstatic class ComposedTransactionalComponentClass {\n\t}\n\n\t@AliasedTransactionalComponent\n\tstatic class AliasedTransactionalComponentClass {\n\t}\n\n\t@ComposedMyAliasedTransactional\n\tvoid composedTransactionalMethod() {\n\t}\n\n\t@ComposedMyAliasedTransactional\n\tstatic class ComposedTransactionalClass {\n\t}\n\n\t@Transactional\n\tstatic class ClassWithInheritedAnnotation {\n\t}\n\n\t@Composed\n\tstatic class SubClassWithInheritedAnnotation extends ClassWithInheritedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedAnnotation extends SubClassWithInheritedAnnotation {\n\t}\n\n\t@InheritedComposed\n\tstatic class ClassWithInheritedComposedAnnotation {\n\t}\n\n\t@Composed\n\tstatic class SubClassWithInheritedComposedAnnotation extends ClassWithInheritedComposedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedComposedAnnotation extends SubClassWithInheritedComposedAnnotation {\n\t}\n\n\t@MetaAndLocalTxConfig\n\tstatic class MetaAndLocalTxConfigClass {\n\t}\n\n\t@Transactional(\"TxConfig\")\n\tstatic class TxConfig {\n\t}\n\n\t@Transactional(\"DerivedTxConfig\")\n\tstatic class DerivedTxConfig extends TxConfig {\n\t}\n\n\t@TxInheritedComposed\n\t@TxComposed\n\tstatic class TxFromMultipleComposedAnnotations {\n\t}\n\n\t@Transactional\n\tinterface InterfaceWithInheritedAnnotation {\n\n\t\t@Order\n\t\tvoid handleFromInterface();\n\t}\n\n\tabstract static class AbstractClassWithInheritedAnnotation<T> implements InterfaceWithInheritedAnnotation {\n\n\t\t@Transactional\n\t\tpublic abstract void handle();\n\n\t\t@Transactional\n\t\tpublic void handleParameterized(T t) {\n\t\t}\n\t}\n\n\tstatic class ConcreteClassWithInheritedAnnotation extends AbstractClassWithInheritedAnnotation<String> {\n\n\t\t@Override\n\t\tpublic void handle() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleParameterized(String s) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleFromInterface() {\n\t\t}\n\t}\n\n\tpublic interface GenericParameter<T> {\n\n\t\tT getFor(Class<T> cls);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class StringGenericParameter implements GenericParameter<String> {\n\n\t\t@Order\n\t\t@Override\n\t\tpublic String getFor(Class<String> cls) {\n\t\t\treturn \"foo\";\n\t\t}\n\n\t\tpublic String getFor(Integer integer) {\n\t\t\treturn \"foo\";\n\t\t}\n\t}\n\n\t@Transactional\n\tpublic interface InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubInheritedAnnotationInterface extends InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubInheritedAnnotationInterface extends SubInheritedAnnotationInterface {\n\t}\n\n\t@Order\n\tpublic interface NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubNonInheritedAnnotationInterface extends NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubNonInheritedAnnotationInterface extends SubNonInheritedAnnotationInterface {\n\t}\n\n\t@ConventionBasedComposedContextConfig(locations = \"explicitDeclaration\")\n\tstatic class ConventionBasedComposedContextConfigClass {\n\t}\n\n\t@InvalidConventionBasedComposedContextConfig(locations = \"requiredLocationsDeclaration\")\n\tstatic class InvalidConventionBasedComposedContextConfigClass {\n\t}\n\n\t@HalfConventionBasedAndHalfAliasedComposedContextConfig(xmlConfigFiles = \"explicitDeclaration\")\n\tstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigClassV1 {\n\t}\n\n\t@HalfConventionBasedAndHalfAliasedComposedContextConfig(locations = \"explicitDeclaration\")\n\tstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigClassV2 {\n\t}\n\n\t@AliasedComposedContextConfig(xmlConfigFiles = \"test.xml\")\n\tstatic class AliasedComposedContextConfigClass {\n\t}\n\n\t@AliasedValueComposedContextConfig(locations = \"test.xml\")\n\tstatic class AliasedValueComposedContextConfigClass {\n\t}\n\n\t@ImplicitAliasesContextConfig(\"foo.xml\")\n\tstatic class ImplicitAliasesContextConfigClass1 {\n\t}\n\n\t@ImplicitAliasesContextConfig(locations = \"bar.xml\")\n\tstatic class ImplicitAliasesContextConfigClass2 {\n\t}\n\n\t@ImplicitAliasesContextConfig(xmlFiles = \"baz.xml\")\n\tstatic class ImplicitAliasesContextConfigClass3 {\n\t}\n\n\t@ImplicitAliasesWithDefaults\n\tstatic class ImplicitAliasesWithDefaultsClass {\n\t}\n\n\t@TransitiveImplicitAliasesContextConfig(groovy = \"test.groovy\")\n\tstatic class TransitiveImplicitAliasesContextConfigClass {\n\t}\n\n\t@SingleLocationTransitiveImplicitAliasesContextConfig(groovy = \"test.groovy\")\n\tstatic class SingleLocationTransitiveImplicitAliasesContextConfigClass {\n\t}\n\n\t@TransitiveImplicitAliasesWithSkippedLevelContextConfig(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesWithSkippedLevelContextConfigClass {\n\t}\n\n\t@SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfig(xml = \"test.xml\")\n\tstatic class SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigClass {\n\t}\n\n\t@ComposedImplicitAliasesContextConfig\n\tstatic class ComposedImplicitAliasesContextConfigClass {\n\t}\n\n\t@ShadowedAliasComposedContextConfig(xmlConfigFiles = \"test.xml\")\n\tstatic class ShadowedAliasComposedContextConfigClass {\n\t}\n\n\t@AliasedComposedContextConfigAndTestPropSource(xmlConfigFiles = \"test.xml\")\n\tstatic class AliasedComposedContextConfigAndTestPropSourceClass {\n\t}\n\n\t@ComponentScan(value = \"com.example.app.test\", basePackages = \"com.example.app.test\")\n\tstatic class ComponentScanWithBasePackagesAndValueAliasClass {\n\t}\n\n\t@TestComponentScan(packages = \"com.example.app.test\")\n\tstatic class TestComponentScanClass {\n\t}\n\n\t@ConventionBasedSinglePackageComponentScan(basePackages = \"com.example.app.test\")\n\tstatic class ConventionBasedSinglePackageComponentScanClass {\n\t}\n\n\t@AliasForBasedSinglePackageComponentScan(pkg = \"com.example.app.test\")\n\tstatic class AliasForBasedSinglePackageComponentScanClass {\n\t}\n\n\t@SpringAppConfig(Number.class)\n\tstatic class SpringAppConfigClass {\n\t}\n\n\t@Resource(name = \"x\")\n\t@ParametersAreNonnullByDefault\n\tstatic class ResourceHolder {\n\t}\n\n\tinterface TransactionalService {\n\n\t\t@Transactional\n\t\t@Nullable Object doIt();\n\t}\n\n\tclass TransactionalServiceImpl implements TransactionalService {\n\n\t\t@Override\n\t\tpublic @Nullable Object doIt() {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Deprecated\n\t@ComponentScan\n\tclass ForAnnotationsClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ValueAttribute {\n\n\t\tString[] value();\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueAttribute(\"FromValueAttributeMeta\")\n\t@interface ValueAttributeMeta {\n\n\t\t@AliasFor(\"alias\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] alias() default {};\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueAttributeMeta(\"FromValueAttributeMetaMeta\")\n\t@interface ValueAttributeMetaMeta {\n\t}\n\n\t@ValueAttributeMetaMeta\n\tstatic class ValueAttributeMetaMetaClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface StandardContainerWithMultipleAttributes {\n\n\t\tStandardRepeatableWithContainerWithMultipleAttributes[] value();\n\n\t\tString name() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(StandardContainerWithMultipleAttributes.class)\n\t@interface StandardRepeatableWithContainerWithMultipleAttributes {\n\n\t\tString value() default \"\";\n\t}\n\n\t@StandardRepeatableWithContainerWithMultipleAttributes(\"a\")\n\t@StandardRepeatableWithContainerWithMultipleAttributes(\"b\")\n\tstatic class StandardRepeatablesWithContainerWithMultipleAttributesTestCase {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.SubClassWithInheritedComposedAnnotation",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.SubClassWithInheritedComposedAnnotation",
    "headType": "class",
    "relation": "use",
    "tail": "@Composed",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.SubClassWithInheritedComposedAnnotation",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Set;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.ParametersAreNonnullByDefault;\nimport javax.annotation.meta.When;\n\nimport jakarta.annotation.Resource;\nimport org.jspecify.annotations.Nullable;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.AnnotationUtilsTests.ExtendsBaseClassWithGenericAnnotatedMethod;\nimport org.springframework.core.annotation.AnnotationUtilsTests.ImplementsInterfaceWithGenericAnnotatedMethod;\nimport org.springframework.core.annotation.AnnotationUtilsTests.WebController;\nimport org.springframework.core.annotation.AnnotationUtilsTests.WebMapping;\nimport org.springframework.core.testfixture.stereotype.Component;\nimport org.springframework.core.testfixture.stereotype.Indexed;\nimport org.springframework.util.MultiValueMap;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.Collectors.toSet;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.findAllMergedAnnotations;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.findMergedAnnotation;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getAllAnnotationAttributes;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getAllMergedAnnotations;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getMergedAnnotation;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getMergedAnnotationAttributes;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getMetaAnnotationTypes;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.hasAnnotation;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.hasMetaAnnotationTypes;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.isAnnotated;\nimport static org.springframework.core.annotation.AnnotationUtilsTests.asArray;\n\n/**\n * Tests for {@link AnnotatedElementUtils}.\n *\n * @author Sam Brannen\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 4.0.3\n * @see AnnotationUtilsTests\n * @see MultipleComposedAnnotationsOnSingleAnnotatedElementTests\n * @see ComposedRepeatableAnnotationsTests\n * @see NestedRepeatableAnnotationsTests\n */\nclass AnnotatedElementUtilsTests {\n\n\tprivate static final String TX_NAME = Transactional.class.getName();\n\n\n\t@Nested\n\tclass ConventionBasedAnnotationAttributeOverrideTests {\n\n\t\t@Test\n\t\tvoid getMergedAnnotationAttributesWithConventionBasedComposedAnnotation() {\n\t\t\tClass<?> element = ConventionBasedComposedContextConfigClass.class;\n\t\t\tString name = ContextConfig.class.getName();\n\t\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\n\t\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").containsExactly(\"explicitDeclaration\");\n\t\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").containsExactly(\"explicitDeclaration\");\n\n\t\t\t// Verify contracts between utility methods:\n\t\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t\t}\n\n\t\t/**\n\t\t * This test should never pass, simply because Spring does not support a hybrid\n\t\t * approach for annotation attribute overrides with transitive implicit aliases.\n\t\t * See SPR-13554 for details.\n\t\t * <p>Furthermore, if you choose to execute this test, it can fail for either\n\t\t * the first test class or the second one (with different exceptions), depending\n\t\t * on the order in which the JVM returns the attribute methods via reflection.\n\t\t */\n\t\t@Disabled(\"Permanently disabled but left in place for illustrative purposes\")\n\t\t@Test\n\t\tvoid getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation() {\n\t\t\tfor (Class<?> clazz : asList(HalfConventionBasedAndHalfAliasedComposedContextConfigClassV1.class,\n\t\t\t\t\tHalfConventionBasedAndHalfAliasedComposedContextConfigClassV2.class)) {\n\t\t\t\tgetMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation(clazz);\n\t\t\t}\n\t\t}\n\n\t\tprivate void getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation(Class<?> clazz) {\n\t\t\tString name = ContextConfig.class.getName();\n\t\t\tString simpleName = clazz.getSimpleName();\n\t\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(clazz, name);\n\n\t\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + simpleName).isNotNull();\n\t\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations for class [\" + simpleName + \"]\")\n\t\t\t\t.containsExactly(\"explicitDeclaration\");\n\t\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value for class [\" + simpleName + \"]\")\n\t\t\t\t.containsExactly(\"explicitDeclaration\");\n\n\t\t\t// Verify contracts between utility methods:\n\t\t\tassertThat(isAnnotated(clazz, name)).isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid getMergedAnnotationAttributesWithInvalidConventionBasedComposedAnnotation() {\n\t\t\tClass<?> element = InvalidConventionBasedComposedContextConfigClass.class;\n\t\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\t\tgetMergedAnnotationAttributes(element, ContextConfig.class))\n\t\t\t\t\t.withMessageContaining(\"Different @AliasFor mirror values for annotation\")\n\t\t\t\t\t.withMessageContaining(\"attribute 'locations' and its alias 'value'\")\n\t\t\t\t\t.withMessageContaining(\"values of [{requiredLocationsDeclaration}] and [{duplicateDeclaration}]\");\n\t\t}\n\n\t\t@Test\n\t\tvoid findMergedAnnotationAttributesWithSingleElementOverridingAnArrayViaConvention() {\n\t\t\tassertComponentScanAttributes(ConventionBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\n\t\t}\n\n\t\t@Test\n\t\tvoid findMergedAnnotationWithLocalAliasesThatConflictWithAttributesInMetaAnnotationByConvention() {\n\t\t\tClass<?> element = SpringAppConfigClass.class;\n\t\t\tContextConfig contextConfig = findMergedAnnotation(element, ContextConfig.class);\n\n\t\t\tassertThat(contextConfig).as(\"Should find @ContextConfig on \" + element).isNotNull();\n\t\t\tassertThat(contextConfig.locations()).as(\"locations for \" + element).isEmpty();\n\t\t\t// 'value' in @SpringAppConfig should not override 'value' in @ContextConfig\n\t\t\tassertThat(contextConfig.value()).as(\"value for \" + element).isEmpty();\n\t\t\tassertThat(contextConfig.classes()).as(\"classes for \" + element).containsExactly(Number.class);\n\t\t}\n\n\t\t@Test\n\t\tvoid findMergedAnnotationWithSingleElementOverridingAnArrayViaConvention() throws Exception {\n\t\t\tassertWebMapping(WebController.class.getMethod(\"postMappedWithPathAttribute\"));\n\t\t}\n\n\t}\n\n\n\t@Test\n\tvoid getMetaAnnotationTypesOnNonAnnotatedClass() {\n\t\tassertThat(getMetaAnnotationTypes(NonAnnotatedClass.class, TransactionalComponent.class)).isEmpty();\n\t\tassertThat(getMetaAnnotationTypes(NonAnnotatedClass.class, TransactionalComponent.class.getName())).isEmpty();\n\t}\n\n\t@Test\n\tvoid getMetaAnnotationTypesOnClassWithMetaDepth1() {\n\t\tSet<String> names = getMetaAnnotationTypes(TransactionalComponentClass.class, TransactionalComponent.class);\n\t\tassertThat(names).isEqualTo(names(Transactional.class, Component.class, Indexed.class));\n\n\t\tnames = getMetaAnnotationTypes(TransactionalComponentClass.class, TransactionalComponent.class.getName());\n\t\tassertThat(names).isEqualTo(names(Transactional.class, Component.class, Indexed.class));\n\t}\n\n\t@Test\n\tvoid getMetaAnnotationTypesOnClassWithMetaDepth2() {\n\t\tSet<String> names = getMetaAnnotationTypes(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class);\n\t\tassertThat(names).isEqualTo(names(TransactionalComponent.class, Transactional.class, Component.class, Indexed.class));\n\n\t\tnames = getMetaAnnotationTypes(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class.getName());\n\t\tassertThat(names).isEqualTo(names(TransactionalComponent.class, Transactional.class, Component.class, Indexed.class));\n\t}\n\n\tprivate Set<String> names(Class<?>... classes) {\n\t\treturn stream(classes).map(Class::getName).collect(toSet());\n\t}\n\n\t@Test\n\tvoid hasMetaAnnotationTypesOnNonAnnotatedClass() {\n\t\tassertThat(hasMetaAnnotationTypes(NonAnnotatedClass.class, TX_NAME)).isFalse();\n\t}\n\n\t@Test\n\tvoid hasMetaAnnotationTypesOnClassWithMetaDepth0() {\n\t\tassertThat(hasMetaAnnotationTypes(TransactionalComponentClass.class, TransactionalComponent.class.getName())).isFalse();\n\t}\n\n\t@Test\n\tvoid hasMetaAnnotationTypesOnClassWithMetaDepth1() {\n\t\tassertThat(hasMetaAnnotationTypes(TransactionalComponentClass.class, TX_NAME)).isTrue();\n\t\tassertThat(hasMetaAnnotationTypes(TransactionalComponentClass.class, Component.class.getName())).isTrue();\n\t}\n\n\t@Test\n\tvoid hasMetaAnnotationTypesOnClassWithMetaDepth2() {\n\t\tassertThat(hasMetaAnnotationTypes(ComposedTransactionalComponentClass.class, TX_NAME)).isTrue();\n\t\tassertThat(hasMetaAnnotationTypes(ComposedTransactionalComponentClass.class, Component.class.getName())).isTrue();\n\t\tassertThat(hasMetaAnnotationTypes(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class.getName())).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotatedOnNonAnnotatedClass() {\n\t\tassertThat(isAnnotated(NonAnnotatedClass.class, Transactional.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotatedOnClassWithMetaDepth() {\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, TransactionalComponent.class)).isTrue();\n\t\tassertThat(isAnnotated(SubTransactionalComponentClass.class, TransactionalComponent.class)).as(\"isAnnotated() does not search the class hierarchy.\").isFalse();\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, Transactional.class)).isTrue();\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, Component.class)).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, Transactional.class)).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, Component.class)).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class)).isTrue();\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid isAnnotatedForPlainTypes() {\n\t\tassertThat(isAnnotated(Order.class, Documented.class)).isTrue();\n\t\tassertThat(isAnnotated(org.springframework.lang.NonNullApi.class, Documented.class)).isTrue();\n\t\tassertThat(isAnnotated(org.springframework.lang.NonNullApi.class, Nonnull.class)).isTrue();\n\t\tassertThat(isAnnotated(ParametersAreNonnullByDefault.class, Nonnull.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isAnnotatedWithNameOnNonAnnotatedClass() {\n\t\tassertThat(isAnnotated(NonAnnotatedClass.class, TX_NAME)).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotatedWithNameOnClassWithMetaDepth() {\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, TransactionalComponent.class.getName())).isTrue();\n\t\tassertThat(isAnnotated(SubTransactionalComponentClass.class, TransactionalComponent.class.getName())).as(\"isAnnotated() does not search the class hierarchy.\").isFalse();\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, TX_NAME)).isTrue();\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, Component.class.getName())).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, TX_NAME)).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, Component.class.getName())).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class.getName())).isTrue();\n\t}\n\n\t@Test\n\tvoid hasAnnotationOnNonAnnotatedClass() {\n\t\tassertThat(hasAnnotation(NonAnnotatedClass.class, Transactional.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid hasAnnotationOnClassWithMetaDepth() {\n\t\tassertThat(hasAnnotation(TransactionalComponentClass.class, TransactionalComponent.class)).isTrue();\n\t\tassertThat(hasAnnotation(SubTransactionalComponentClass.class, TransactionalComponent.class)).isTrue();\n\t\tassertThat(hasAnnotation(TransactionalComponentClass.class, Transactional.class)).isTrue();\n\t\tassertThat(hasAnnotation(TransactionalComponentClass.class, Component.class)).isTrue();\n\t\tassertThat(hasAnnotation(ComposedTransactionalComponentClass.class, Transactional.class)).isTrue();\n\t\tassertThat(hasAnnotation(ComposedTransactionalComponentClass.class, Component.class)).isTrue();\n\t\tassertThat(hasAnnotation(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class)).isTrue();\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid hasAnnotationForPlainTypes() {\n\t\tassertThat(hasAnnotation(Order.class, Documented.class)).isTrue();\n\t\tassertThat(hasAnnotation(org.springframework.lang.NonNullApi.class, Documented.class)).isTrue();\n\t\tassertThat(hasAnnotation(org.springframework.lang.NonNullApi.class, Nonnull.class)).isTrue();\n\t\tassertThat(hasAnnotation(ParametersAreNonnullByDefault.class, Nonnull.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesOnNonAnnotatedClass() {\n\t\tassertThat(getAllAnnotationAttributes(NonAnnotatedClass.class, TX_NAME)).isNull();\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesOnClassWithLocalAnnotation() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxConfig.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on TxConfig\").isNotNull();\n\t\tassertThat(attributes.get(\"value\")).as(\"value for TxConfig\").isEqualTo(List.of(\"TxConfig\"));\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesOnClassWithLocalComposedAnnotationAndInheritedAnnotation() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(SubClassWithInheritedAnnotation.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on SubClassWithInheritedAnnotation\").isNotNull();\n\t\tassertThat(attributes.get(\"qualifier\")).isEqualTo(asList(\"composed2\", \"transactionManager\"));\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(SubSubClassWithInheritedAnnotation.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on SubSubClassWithInheritedAnnotation\").isNotNull();\n\t\tassertThat(attributes.get(\"qualifier\")).isEqualTo(List.of(\"transactionManager\"));\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes( SubSubClassWithInheritedComposedAnnotation.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on SubSubClassWithInheritedComposedAnnotation\").isNotNull();\n\t\tassertThat(attributes.get(\"qualifier\")).isEqualTo(List.of(\"composed1\"));\n\t}\n\n\t/**\n\t * If the \"value\" entry contains both \"DerivedTxConfig\" AND \"TxConfig\", then\n\t * the algorithm is accidentally picking up shadowed annotations of the same\n\t * type within the class hierarchy. Such undesirable behavior would cause the\n\t * logic in {@code org.springframework.context.annotation.ProfileCondition}\n\t * to fail.\n\t */\n\t@Test\n\tvoid getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\n\t\t// See org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on DerivedTxConfig\").isNotNull();\n\t\tassertThat(attributes.get(\"value\")).as(\"value for DerivedTxConfig\").isEqualTo(List.of(\"DerivedTxConfig\"));\n\t}\n\n\t/**\n\t * Note: this functionality is required by {@code org.springframework.context.annotation.ProfileCondition}.\n\t */\n\t@Test\n\tvoid getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {\n\t\t// See org.springframework.core.env.EnvironmentSystemIntegrationTests\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations\").isNotNull();\n\t\tassertThat(attributes.get(\"value\")).as(\"value for TxFromMultipleComposedAnnotations.\").isEqualTo(asList(\"TxInheritedComposed\", \"TxComposed\"));\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid getAllAnnotationAttributesOnLangType() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(\n\t\t\t\torg.springframework.lang.NonNullApi.class, Nonnull.class.getName());\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Nonnull on NonNullApi\").isNotNull();\n\t\tassertThat(attributes.get(\"when\")).as(\"value for NonNullApi\").isEqualTo(List.of(When.ALWAYS));\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesOnJavaxType() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(\n\t\t\t\tParametersAreNonnullByDefault.class, Nonnull.class.getName());\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Nonnull on NonNullApi\").isNotNull();\n\t\tassertThat(attributes.get(\"when\")).as(\"value for NonNullApi\").isEqualTo(List.of(When.ALWAYS));\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnClassWithLocalAnnotation() {\n\t\tClass<?> element = TxConfig.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Annotation attributes for @Transactional on TxConfig\").isNotNull();\n\t\tassertThat(attributes.getString(\"value\")).as(\"value for TxConfig\").isEqualTo(\"TxConfig\");\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\n\t\tClass<?> element = DerivedTxConfig.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Annotation attributes for @Transactional on DerivedTxConfig\").isNotNull();\n\t\tassertThat(attributes.getString(\"value\")).as(\"value for DerivedTxConfig\").isEqualTo(\"DerivedTxConfig\");\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(MetaCycleAnnotatedClass.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Should not find annotation attributes for @Transactional on MetaCycleAnnotatedClass\").isNull();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesFavorsLocalComposedAnnotationOverInheritedAnnotation() {\n\t\tClass<?> element = SubClassWithInheritedAnnotation.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"AnnotationAttributes for @Transactional on SubClassWithInheritedAnnotation\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t\tassertThat(attributes.getBoolean(\"readOnly\")).as(\"readOnly flag for SubClassWithInheritedAnnotation.\").isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tClass<?> element = SubSubClassWithInheritedAnnotation.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"AnnotationAttributes for @Transactional on SubSubClassWithInheritedAnnotation\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t\tassertThat(attributes.getBoolean(\"readOnly\")).as(\"readOnly flag for SubSubClassWithInheritedAnnotation.\").isFalse();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tClass<?> element = SubSubClassWithInheritedComposedAnnotation.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"AnnotationAttributes for @Transactional on SubSubClassWithInheritedComposedAnnotation.\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t\tassertThat(attributes.getBoolean(\"readOnly\")).as(\"readOnly flag for SubSubClassWithInheritedComposedAnnotation.\").isFalse();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesFromInterfaceImplementedBySuperclass() {\n\t\tClass<?> element = ConcreteClassWithInheritedAnnotation.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Should not find @Transactional on ConcreteClassWithInheritedAnnotation\").isNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isFalse();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnInheritedAnnotationInterface() {\n\t\tClass<?> element = InheritedAnnotationInterface.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Should find @Transactional on InheritedAnnotationInterface\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnNonInheritedAnnotationInterface() {\n\t\tClass<?> element = NonInheritedAnnotationInterface.class;\n\t\tString name = Order.class.getName();\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Should find @Order on NonInheritedAnnotationInterface\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesWithAliasedComposedAnnotation() {\n\t\tClass<?> element = AliasedComposedContextConfigClass.class;\n\t\tString name = ContextConfig.class.getName();\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\n\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(asArray(\"test.xml\"));\n\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(asArray(\"test.xml\"));\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesWithAliasedValueComposedAnnotation() {\n\t\tClass<?> element = AliasedValueComposedContextConfigClass.class;\n\t\tString name = ContextConfig.class.getName();\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\n\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(asArray(\"test.xml\"));\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(asArray(\"test.xml\"));\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesWithImplicitAliasesInMetaAnnotationOnComposedAnnotation() {\n\t\tClass<?> element = ComposedImplicitAliasesContextConfigClass.class;\n\t\tString name = ImplicitAliasesContextConfig.class.getName();\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tString[] expected = asArray(\"A.xml\", \"B.xml\");\n\n\t\tassertThat(attributes).as(\"Should find @ImplicitAliasesContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"groovyScripts\")).as(\"groovyScripts\").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"xmlFiles\")).as(\"xmlFiles\").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(expected);\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithAliasedValueComposedAnnotation() {\n\t\tassertGetMergedAnnotation(AliasedValueComposedContextConfigClass.class, \"test.xml\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithImplicitAliasesForSameAttributeInComposedAnnotation() {\n\t\tassertGetMergedAnnotation(ImplicitAliasesContextConfigClass1.class, \"foo.xml\");\n\t\tassertGetMergedAnnotation(ImplicitAliasesContextConfigClass2.class, \"bar.xml\");\n\t\tassertGetMergedAnnotation(ImplicitAliasesContextConfigClass3.class, \"baz.xml\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithTransitiveImplicitAliases() {\n\t\tassertGetMergedAnnotation(TransitiveImplicitAliasesContextConfigClass.class, \"test.groovy\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithTransitiveImplicitAliasesWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\tassertGetMergedAnnotation(SingleLocationTransitiveImplicitAliasesContextConfigClass.class, \"test.groovy\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithTransitiveImplicitAliasesWithSkippedLevel() {\n\t\tassertGetMergedAnnotation(TransitiveImplicitAliasesWithSkippedLevelContextConfigClass.class, \"test.xml\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithTransitiveImplicitAliasesWithSkippedLevelWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\tassertGetMergedAnnotation(SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigClass.class, \"test.xml\");\n\t}\n\n\tprivate void assertGetMergedAnnotation(Class<?> element, String... expected) {\n\t\tString name = ContextConfig.class.getName();\n\t\tContextConfig contextConfig = getMergedAnnotation(element, ContextConfig.class);\n\n\t\tassertThat(contextConfig).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(contextConfig.locations()).as(\"locations\").isEqualTo(expected);\n\t\tassertThat(contextConfig.value()).as(\"value\").isEqualTo(expected);\n\t\tObject[] expecteds = new Class<?>[0];\n\t\tassertThat(contextConfig.classes()).as(\"classes\").isEqualTo(expecteds);\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithImplicitAliasesInMetaAnnotationOnComposedAnnotation() {\n\t\tClass<?> element = ComposedImplicitAliasesContextConfigClass.class;\n\t\tString name = ImplicitAliasesContextConfig.class.getName();\n\t\tImplicitAliasesContextConfig config = getMergedAnnotation(element, ImplicitAliasesContextConfig.class);\n\t\tString[] expected = asArray(\"A.xml\", \"B.xml\");\n\n\t\tassertThat(config).as(\"Should find @ImplicitAliasesContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(config.groovyScripts()).as(\"groovyScripts\").isEqualTo(expected);\n\t\tassertThat(config.xmlFiles()).as(\"xmlFiles\").isEqualTo(expected);\n\t\tassertThat(config.locations()).as(\"locations\").isEqualTo(expected);\n\t\tassertThat(config.value()).as(\"value\").isEqualTo(expected);\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithImplicitAliasesWithDefaultsInMetaAnnotationOnComposedAnnotation() {\n\t\tClass<?> element = ImplicitAliasesWithDefaultsClass.class;\n\t\tString name = AliasesWithDefaults.class.getName();\n\t\tAliasesWithDefaults annotation = getMergedAnnotation(element, AliasesWithDefaults.class);\n\n\t\tassertThat(annotation).as(\"Should find @AliasesWithDefaults on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(annotation.a1()).as(\"a1\").isEqualTo(\"ImplicitAliasesWithDefaults\");\n\t\tassertThat(annotation.a2()).as(\"a2\").isEqualTo(\"ImplicitAliasesWithDefaults\");\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesWithShadowedAliasComposedAnnotation() {\n\t\tClass<?> element = ShadowedAliasComposedContextConfigClass.class;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, ContextConfig.class);\n\n\t\tString[] expected = asArray(\"test.xml\");\n\n\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(expected);\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(InheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on InheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnSubInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(SubInheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on SubInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnSubSubInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(SubSubInheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on SubSubInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnNonInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(NonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on NonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnSubNonInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(SubNonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on SubNonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnSubSubNonInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(SubSubNonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on SubSubNonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesInheritedFromInterfaceMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleFromInterface\");\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(method, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on ConcreteClassWithInheritedAnnotation.handleFromInterface() method\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesInheritedFromAbstractMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handle\");\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on ConcreteClassWithInheritedAnnotation.handle() method\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleParameterized\", String.class);\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()\").isNotNull();\n\t}\n\n\t/**\n\t * Bridge/bridged method setup code copied from\n\t * {@link org.springframework.core.BridgeMethodResolverTests#withGenericParameter()}.\n\t * @since 4.2\n\t */\n\t@Test\n\tvoid findMergedAnnotationAttributesFromBridgeMethod() {\n\t\tMethod[] methods = StringGenericParameter.class.getMethods();\n\t\tMethod bridgeMethod = null;\n\t\tMethod bridgedMethod = null;\n\n\t\tfor (Method method : methods) {\n\t\t\tif (\"getFor\".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {\n\t\t\t\tif (method.getReturnType().equals(Object.class)) {\n\t\t\t\t\tbridgeMethod = method;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbridgedMethod = method;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\n\t\tboolean condition = bridgedMethod != null && !bridgedMethod.isBridge();\n\t\tassertThat(condition).isTrue();\n\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on StringGenericParameter.getFor() bridge method\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnClassWithMetaAndLocalTxConfig() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(MetaAndLocalTxConfigClass.class, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on MetaAndLocalTxConfigClass\").isNotNull();\n\t\tassertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier for MetaAndLocalTxConfigClass.\").isEqualTo(\"localTxMgr\");\n\t}\n\n\t@Test\n\tvoid findAndSynthesizeAnnotationAttributesOnClassWithAttributeAliasesInTargetAnnotation() {\n\t\tString qualifier = \"aliasForQualifier\";\n\n\t\t// 1) Find and merge AnnotationAttributes from the annotation hierarchy\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(\n\t\t\t\tAliasedTransactionalComponentClass.class, AliasedTransactional.class);\n\t\tassertThat(attributes).as(\"@AliasedTransactional on AliasedTransactionalComponentClass.\").isNotNull();\n\n\t\t// 2) Synthesize the AnnotationAttributes back into the target annotation\n\t\tAliasedTransactional annotation = AnnotationUtils.synthesizeAnnotation(attributes,\n\t\t\t\tAliasedTransactional.class, AliasedTransactionalComponentClass.class);\n\t\tassertThat(annotation).isNotNull();\n\n\t\t// 3) Verify that the AnnotationAttributes and synthesized annotation are equivalent\n\t\tassertThat(attributes.getString(\"value\")).as(\"TX value via attributes.\").isEqualTo(qualifier);\n\t\tassertThat(annotation.value()).as(\"TX value via synthesized annotation.\").isEqualTo(qualifier);\n\t\tassertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier via attributes.\").isEqualTo(qualifier);\n\t\tassertThat(annotation.qualifier()).as(\"TX qualifier via synthesized annotation.\").isEqualTo(qualifier);\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnClassWithAttributeAliasInComposedAnnotationAndNestedAnnotationsInTargetAnnotation() {\n\t\tAnnotationAttributes attributes = assertComponentScanAttributes(TestComponentScanClass.class, \"com.example.app.test\");\n\n\t\tFilter[] excludeFilters = attributes.getAnnotationArray(\"excludeFilters\", Filter.class);\n\t\tassertThat(excludeFilters).isNotNull();\n\n\t\tList<String> patterns = stream(excludeFilters).map(Filter::pattern).collect(toList());\n\t\tassertThat(patterns).isEqualTo(asList(\"*Test\", \"*Tests\"));\n\t}\n\n\t/**\n\t * This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}\n\t * uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation\n\t * attributes since attributes may be arrays.\n\t */\n\t@Test\n\tvoid findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {\n\t\tassertComponentScanAttributes(ComponentScanWithBasePackagesAndValueAliasClass.class, \"com.example.app.test\");\n\t}\n\n\t/**\n\t * @since 5.2.1\n\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\n\t */\n\t@Test\n\tvoid findMergedAnnotationAttributesOnMethodWithComposedMetaTransactionalAnnotation() throws Exception {\n\t\tMethod method = getClass().getDeclaredMethod(\"composedTransactionalMethod\");\n\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(method, AliasedTransactional.class);\n\t\tassertThat(attributes).as(\"Should find @AliasedTransactional on \" + method).isNotNull();\n\t\tassertThat(attributes.getString(\"value\")).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t/**\n\t * @since 5.2.1\n\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\n\t */\n\t@Test\n\tvoid findMergedAnnotationOnMethodWithComposedMetaTransactionalAnnotation() throws Exception {\n\t\tMethod method = getClass().getDeclaredMethod(\"composedTransactionalMethod\");\n\n\t\tAliasedTransactional annotation = findMergedAnnotation(method, AliasedTransactional.class);\n\t\tassertThat(annotation).as(\"Should find @AliasedTransactional on \" + method).isNotNull();\n\t\tassertThat(annotation.value()).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(annotation.qualifier()).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t/**\n\t * @since 5.2.1\n\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\n\t */\n\t@Test\n\tvoid findMergedAnnotationAttributesOnClassWithComposedMetaTransactionalAnnotation() {\n\t\tClass<?> clazz = ComposedTransactionalClass.class;\n\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(clazz, AliasedTransactional.class);\n\t\tassertThat(attributes).as(\"Should find @AliasedTransactional on \" + clazz).isNotNull();\n\t\tassertThat(attributes.getString(\"value\")).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t/**\n\t * @since 5.2.1\n\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\n\t */\n\t@Test\n\tvoid findMergedAnnotationOnClassWithComposedMetaTransactionalAnnotation() {\n\t\tClass<?> clazz = ComposedTransactionalClass.class;\n\n\t\tAliasedTransactional annotation = findMergedAnnotation(clazz, AliasedTransactional.class);\n\t\tassertThat(annotation).as(\"Should find @AliasedTransactional on \" + clazz).isNotNull();\n\t\tassertThat(annotation.value()).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(annotation.qualifier()).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\tassertComponentScanAttributes(AliasForBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\n\t}\n\n\tprivate AnnotationAttributes assertComponentScanAttributes(Class<?> element, String... expected) {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(element, ComponentScan.class);\n\n\t\tassertThat(attributes).as(\"Should find @ComponentScan on \" + element).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value: \").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"basePackages\")).as(\"basePackages: \").isEqualTo(expected);\n\n\t\treturn attributes;\n\t}\n\n\tprivate AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element, Class<? extends Annotation> annotationType) {\n\t\treturn AnnotatedElementUtils.findMergedAnnotationAttributes(element, annotationType.getName(), false, false);\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationWithAttributeAliasesInTargetAnnotation() {\n\t\tClass<?> element = AliasedTransactionalComponentClass.class;\n\t\tAliasedTransactional annotation = findMergedAnnotation(element, AliasedTransactional.class);\n\t\tassertThat(annotation).as(\"@AliasedTransactional on \" + element).isNotNull();\n\t\tassertThat(annotation.value()).as(\"TX value via synthesized annotation.\").isEqualTo(\"aliasForQualifier\");\n\t\tassertThat(annotation.qualifier()).as(\"TX qualifier via synthesized annotation.\").isEqualTo(\"aliasForQualifier\");\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationForMultipleMetaAnnotationsWithClashingAttributeNames() {\n\t\tString[] xmlLocations = asArray(\"test.xml\");\n\t\tString[] propFiles = asArray(\"test.properties\");\n\n\t\tClass<?> element = AliasedComposedContextConfigAndTestPropSourceClass.class;\n\n\t\tContextConfig contextConfig = findMergedAnnotation(element, ContextConfig.class);\n\t\tassertThat(contextConfig).as(\"@ContextConfig on \" + element).isNotNull();\n\t\tassertThat(contextConfig.locations()).as(\"locations\").isEqualTo(xmlLocations);\n\t\tassertThat(contextConfig.value()).as(\"value\").isEqualTo(xmlLocations);\n\n\t\t// Synthesized annotation\n\t\tTestPropSource testPropSource = AnnotationUtils.findAnnotation(element, TestPropSource.class);\n\t\tassertThat(testPropSource.locations()).as(\"locations\").isEqualTo(propFiles);\n\t\tassertThat(testPropSource.value()).as(\"value\").isEqualTo(propFiles);\n\n\t\t// Merged annotation\n\t\ttestPropSource = findMergedAnnotation(element, TestPropSource.class);\n\t\tassertThat(testPropSource).as(\"@TestPropSource on \" + element).isNotNull();\n\t\tassertThat(testPropSource.locations()).as(\"locations\").isEqualTo(propFiles);\n\t\tassertThat(testPropSource.value()).as(\"value\").isEqualTo(propFiles);\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationWithSingleElementOverridingAnArrayViaAliasFor() throws Exception {\n\t\tassertWebMapping(WebController.class.getMethod(\"getMappedWithValueAttribute\"));\n\t\tassertWebMapping(WebController.class.getMethod(\"getMappedWithPathAttribute\"));\n\t}\n\n\tprivate void assertWebMapping(AnnotatedElement element) {\n\t\tWebMapping webMapping = findMergedAnnotation(element, WebMapping.class);\n\t\tassertThat(webMapping).isNotNull();\n\t\tassertThat(webMapping.value()).as(\"value attribute: \").isEqualTo(asArray(\"/test\"));\n\t\tassertThat(webMapping.path()).as(\"path attribute: \").isEqualTo(asArray(\"/test\"));\n\t}\n\n\t@Test\n\tvoid javaLangAnnotationTypeViaFindMergedAnnotation() throws Exception {\n\t\tConstructor<?> deprecatedCtor = Date.class.getConstructor(String.class);\n\t\tassertThat(findMergedAnnotation(deprecatedCtor, Deprecated.class)).isEqualTo(deprecatedCtor.getAnnotation(Deprecated.class));\n\t\tassertThat(findMergedAnnotation(Date.class, Deprecated.class)).isEqualTo(Date.class.getAnnotation(Deprecated.class));\n\t}\n\n\t@Test\n\tvoid javaxAnnotationTypeViaFindMergedAnnotation() {\n\t\tassertThat(findMergedAnnotation(ResourceHolder.class, Resource.class)).isEqualTo(ResourceHolder.class.getAnnotation(Resource.class));\n\t\tassertThat(findMergedAnnotation(SpringAppConfigClass.class, Resource.class)).isEqualTo(SpringAppConfigClass.class.getAnnotation(Resource.class));\n\t}\n\n\t@Test\n\tvoid javaxMetaAnnotationTypeViaFindMergedAnnotation() {\n\t\tassertThat(findMergedAnnotation(ParametersAreNonnullByDefault.class, Nonnull.class)).isEqualTo(ParametersAreNonnullByDefault.class.getAnnotation(Nonnull.class));\n\t\tassertThat(findMergedAnnotation(ResourceHolder.class, Nonnull.class)).isEqualTo(ParametersAreNonnullByDefault.class.getAnnotation(Nonnull.class));\n\t}\n\n\t@Test\n\tvoid nullableAnnotationTypeViaFindMergedAnnotation() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tassertThat(findMergedAnnotation(method, Resource.class)).isEqualTo(method.getAnnotation(Resource.class));\n\t}\n\n\t@Test\n\tvoid getAllMergedAnnotationsOnClassWithInterface() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tSet<Transactional> allMergedAnnotations = getAllMergedAnnotations(method, Transactional.class);\n\t\tassertThat(allMergedAnnotations).isEmpty();\n\t}\n\n\t@Test\n\tvoid findAllMergedAnnotationsOnClassWithInterface() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tSet<Transactional> allMergedAnnotations = findAllMergedAnnotations(method, Transactional.class);\n\t\tassertThat(allMergedAnnotations).hasSize(1);\n\t}\n\n\t@Test  // SPR-16060\n\tvoid findMethodAnnotationFromGenericInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tOrder order = findMergedAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test  // SPR-17146\n\tvoid findMethodAnnotationFromGenericSuperclass() throws Exception {\n\t\tMethod method = ExtendsBaseClassWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tOrder order = findMergedAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test // gh-22655\n\tvoid forAnnotationsCreatesCopyOfArrayOnEachCall() {\n\t\tAnnotatedElement element = AnnotatedElementUtils.forAnnotations(ForAnnotationsClass.class.getDeclaredAnnotations());\n\t\t// Trigger the NPE as originally reported in the bug\n\t\tAnnotationsScanner.getDeclaredAnnotations(element, false);\n\t\tAnnotationsScanner.getDeclaredAnnotations(element, false);\n\t\t// Also specifically test we get different instances\n\t\tassertThat(element.getDeclaredAnnotations()).isNotSameAs(element.getDeclaredAnnotations());\n\t}\n\n\t@Test // gh-22703\n\tvoid getMergedAnnotationOnThreeDeepMetaWithValue() {\n\t\tValueAttribute annotation = AnnotatedElementUtils.getMergedAnnotation(\n\t\t\t\tValueAttributeMetaMetaClass.class, ValueAttribute.class);\n\t\tassertThat(annotation.value()).containsExactly(\"FromValueAttributeMeta\");\n\t}\n\n\t/**\n\t * @since 5.3.25\n\t */\n\t@Test // gh-29685\n\tvoid getMergedRepeatableAnnotationsWithContainerWithMultipleAttributes() {\n\t\tSet<StandardRepeatableWithContainerWithMultipleAttributes> repeatableAnnotations =\n\t\t\t\tAnnotatedElementUtils.getMergedRepeatableAnnotations(\n\t\t\t\t\t\tStandardRepeatablesWithContainerWithMultipleAttributesTestCase.class,\n\t\t\t\t\t\tStandardRepeatableWithContainerWithMultipleAttributes.class);\n\t\tassertThat(repeatableAnnotations).map(StandardRepeatableWithContainerWithMultipleAttributes::value)\n\t\t\t\t.containsExactly(\"a\", \"b\");\n\t}\n\n\t/**\n\t * @since 5.3.25\n\t */\n\t@Test // gh-29685\n\tvoid findMergedRepeatableAnnotationsWithContainerWithMultipleAttributes() {\n\t\tSet<StandardRepeatableWithContainerWithMultipleAttributes> repeatableAnnotations =\n\t\t\t\tAnnotatedElementUtils.findMergedRepeatableAnnotations(\n\t\t\t\t\t\tStandardRepeatablesWithContainerWithMultipleAttributesTestCase.class,\n\t\t\t\t\t\tStandardRepeatableWithContainerWithMultipleAttributes.class);\n\t\tassertThat(repeatableAnnotations).map(StandardRepeatableWithContainerWithMultipleAttributes::value)\n\t\t\t\t.containsExactly(\"a\", \"b\");\n\t}\n\n\t// -------------------------------------------------------------------------\n\n\t@MetaCycle3\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.ANNOTATION_TYPE)\n\t@interface MetaCycle1 {\n\t}\n\n\t@MetaCycle1\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.ANNOTATION_TYPE)\n\t@interface MetaCycle2 {\n\t}\n\n\t@MetaCycle2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface MetaCycle3 {\n\t}\n\n\t@MetaCycle3\n\tstatic class MetaCycleAnnotatedClass {\n\t}\n\n\t// -------------------------------------------------------------------------\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Inherited\n\t@interface Transactional {\n\n\t\tString value() default \"\";\n\n\t\tString qualifier() default \"transactionManager\";\n\n\t\tboolean readOnly() default false;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Inherited\n\t@interface AliasedTransactional {\n\n\t\t@AliasFor(\"qualifier\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString qualifier() default \"\";\n\t}\n\n\t@AliasedTransactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@interface MyAliasedTransactional {\n\n\t\t@AliasFor(annotation = AliasedTransactional.class, attribute = \"value\")\n\t\tString value() default \"defaultTransactionManager\";\n\t}\n\n\t@MyAliasedTransactional(\"anotherTransactionManager\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@interface ComposedMyAliasedTransactional {\n\t}\n\n\t@Transactional(qualifier = \"composed1\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@Inherited\n\t@interface InheritedComposed {\n\t}\n\n\t@Transactional(qualifier = \"composed2\", readOnly = true)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface Composed {\n\t}\n\n\t@Transactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxComposedWithOverride {\n\n\t\tString qualifier() default \"txMgr\";\n\t}\n\n\t@Transactional(\"TxInheritedComposed\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxInheritedComposed {\n\t}\n\n\t@Transactional(\"TxComposed\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxComposed {\n\t}\n\n\t@Transactional\n\t@Component\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransactionalComponent {\n\t}\n\n\t@TransactionalComponent\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedTransactionalComponent {\n\t}\n\n\t@AliasedTransactional(value = \"aliasForQualifier\")\n\t@Component\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedTransactionalComponent {\n\t}\n\n\t@TxComposedWithOverride\n\t// Override default \"txMgr\" from @TxComposedWithOverride with \"localTxMgr\"\n\t@Transactional(qualifier = \"localTxMgr\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface MetaAndLocalTxConfig {\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.test.context.TestPropertySource}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestPropSource {\n\n\t\t@AliasFor(\"locations\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] locations() default {};\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.test.context.ContextConfiguration}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContextConfig {\n\n\t\t@AliasFor(\"locations\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] locations() default {};\n\n\t\tClass<?>[] classes() default {};\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionBasedComposedContextConfig {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfig.class)\n\t\tString[] locations() default {};\n\t}\n\n\t@ContextConfig(value = \"duplicateDeclaration\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface InvalidConventionBasedComposedContextConfig {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfig.class)\n\t\tString[] locations();\n\t}\n\n\t/**\n\t * This hybrid approach for annotation attribute overrides with transitive implicit\n\t * aliases is unsupported. See SPR-13554 for details.\n\t */\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface HalfConventionBasedAndHalfAliasedComposedContextConfig {\n\n\t\tString[] locations() default {};\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles() default {};\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles();\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedValueComposedContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"value\")\n\t\tString[] locations();\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] groovyScripts() default {};\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlFiles() default {};\n\n\t\t// intentionally omitted: attribute = \"locations\"\n\t\t@AliasFor(annotation = ContextConfig.class)\n\t\tString[] locations() default {};\n\n\t\t// intentionally omitted: attribute = \"locations\" (SPR-14069)\n\t\t@AliasFor(annotation = ContextConfig.class)\n\t\tString[] value() default {};\n\t}\n\n\t@ImplicitAliasesContextConfig(xmlFiles = {\"A.xml\", \"B.xml\"})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedImplicitAliasesContextConfig {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasesWithDefaults {\n\n\t\t@AliasFor(\"a2\")\n\t\tString a1() default \"AliasesWithDefaults\";\n\n\t\t@AliasFor(\"a1\")\n\t\tString a2() default \"AliasesWithDefaults\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasesWithDefaults\n\t@interface ImplicitAliasesWithDefaults {\n\n\t\t@AliasFor(annotation = AliasesWithDefaults.class, attribute = \"a1\")\n\t\tString b1() default \"ImplicitAliasesWithDefaults\";\n\n\t\t@AliasFor(annotation = AliasesWithDefaults.class, attribute = \"a2\")\n\t\tString b2() default \"ImplicitAliasesWithDefaults\";\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"xmlFiles\")\n\t\tString[] xml() default {};\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScripts\")\n\t\tString[] groovy() default {};\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SingleLocationTransitiveImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"xmlFiles\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScripts\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesWithSkippedLevelContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xml() default {};\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScripts\")\n\t\tString[] groovy() default {};\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScripts\")\n\t\tString groovy() default \"\";\n\t}\n\n\t/**\n\t * Although the configuration declares an explicit value for 'value' and\n\t * requires a value for the aliased 'locations', this does not result in\n\t * an error since 'locations' effectively <em>shadows</em> the 'value'\n\t * attribute (which cannot be set via the composed annotation anyway).\n\t *\n\t * If 'value' were not shadowed, such a declaration would not make sense.\n\t */\n\t@ContextConfig(value = \"duplicateDeclaration\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ShadowedAliasComposedContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles();\n\t}\n\n\t@ContextConfig(locations = \"shadowed.xml\")\n\t@TestPropSource(locations = \"test.properties\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfigAndTestPropSource {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles() default \"default.xml\";\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.boot.test.SpringApplicationConfiguration}.\n\t */\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SpringAppConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] locations() default {};\n\n\t\t// Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfig.class, attribute = \"classes\")\n\t\t@AliasFor(\"value\")\n\t\tClass<?>[] classes() default {};\n\n\t\t// Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfig.class, attribute = \"classes\")\n\t\t@AliasFor(\"classes\")\n\t\tClass<?>[] value() default {};\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.context.annotation.ComponentScan}\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScan {\n\n\t\t@AliasFor(\"basePackages\")\n\t\tString[] value() default {};\n\n\t\t// Intentionally no alias declaration for \"value\"\n\t\tString[] basePackages() default {};\n\n\t\tFilter[] excludeFilters() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({})\n\t@interface Filter {\n\n\t\tString pattern();\n\t}\n\n\t@ComponentScan(excludeFilters = {@Filter(pattern = \"*Test\"), @Filter(pattern = \"*Tests\")})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestComponentScan {\n\n\t\t@AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\n\t\tString[] packages();\n\t}\n\n\t@ComponentScan\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionBasedSinglePackageComponentScan {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ComponentScan.class)\n\t\tString basePackages();\n\t}\n\n\t@ComponentScan\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForBasedSinglePackageComponentScan {\n\n\t\t@AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\n\t\tString pkg();\n\t}\n\n\t// -------------------------------------------------------------------------\n\n\tstatic class NonAnnotatedClass {\n\t}\n\n\t@TransactionalComponent\n\tstatic class TransactionalComponentClass {\n\t}\n\n\tstatic class SubTransactionalComponentClass extends TransactionalComponentClass {\n\t}\n\n\t@ComposedTransactionalComponent\n\tstatic class ComposedTransactionalComponentClass {\n\t}\n\n\t@AliasedTransactionalComponent\n\tstatic class AliasedTransactionalComponentClass {\n\t}\n\n\t@ComposedMyAliasedTransactional\n\tvoid composedTransactionalMethod() {\n\t}\n\n\t@ComposedMyAliasedTransactional\n\tstatic class ComposedTransactionalClass {\n\t}\n\n\t@Transactional\n\tstatic class ClassWithInheritedAnnotation {\n\t}\n\n\t@Composed\n\tstatic class SubClassWithInheritedAnnotation extends ClassWithInheritedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedAnnotation extends SubClassWithInheritedAnnotation {\n\t}\n\n\t@InheritedComposed\n\tstatic class ClassWithInheritedComposedAnnotation {\n\t}\n\n\t@Composed\n\tstatic class SubClassWithInheritedComposedAnnotation extends ClassWithInheritedComposedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedComposedAnnotation extends SubClassWithInheritedComposedAnnotation {\n\t}\n\n\t@MetaAndLocalTxConfig\n\tstatic class MetaAndLocalTxConfigClass {\n\t}\n\n\t@Transactional(\"TxConfig\")\n\tstatic class TxConfig {\n\t}\n\n\t@Transactional(\"DerivedTxConfig\")\n\tstatic class DerivedTxConfig extends TxConfig {\n\t}\n\n\t@TxInheritedComposed\n\t@TxComposed\n\tstatic class TxFromMultipleComposedAnnotations {\n\t}\n\n\t@Transactional\n\tinterface InterfaceWithInheritedAnnotation {\n\n\t\t@Order\n\t\tvoid handleFromInterface();\n\t}\n\n\tabstract static class AbstractClassWithInheritedAnnotation<T> implements InterfaceWithInheritedAnnotation {\n\n\t\t@Transactional\n\t\tpublic abstract void handle();\n\n\t\t@Transactional\n\t\tpublic void handleParameterized(T t) {\n\t\t}\n\t}\n\n\tstatic class ConcreteClassWithInheritedAnnotation extends AbstractClassWithInheritedAnnotation<String> {\n\n\t\t@Override\n\t\tpublic void handle() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleParameterized(String s) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleFromInterface() {\n\t\t}\n\t}\n\n\tpublic interface GenericParameter<T> {\n\n\t\tT getFor(Class<T> cls);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class StringGenericParameter implements GenericParameter<String> {\n\n\t\t@Order\n\t\t@Override\n\t\tpublic String getFor(Class<String> cls) {\n\t\t\treturn \"foo\";\n\t\t}\n\n\t\tpublic String getFor(Integer integer) {\n\t\t\treturn \"foo\";\n\t\t}\n\t}\n\n\t@Transactional\n\tpublic interface InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubInheritedAnnotationInterface extends InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubInheritedAnnotationInterface extends SubInheritedAnnotationInterface {\n\t}\n\n\t@Order\n\tpublic interface NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubNonInheritedAnnotationInterface extends NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubNonInheritedAnnotationInterface extends SubNonInheritedAnnotationInterface {\n\t}\n\n\t@ConventionBasedComposedContextConfig(locations = \"explicitDeclaration\")\n\tstatic class ConventionBasedComposedContextConfigClass {\n\t}\n\n\t@InvalidConventionBasedComposedContextConfig(locations = \"requiredLocationsDeclaration\")\n\tstatic class InvalidConventionBasedComposedContextConfigClass {\n\t}\n\n\t@HalfConventionBasedAndHalfAliasedComposedContextConfig(xmlConfigFiles = \"explicitDeclaration\")\n\tstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigClassV1 {\n\t}\n\n\t@HalfConventionBasedAndHalfAliasedComposedContextConfig(locations = \"explicitDeclaration\")\n\tstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigClassV2 {\n\t}\n\n\t@AliasedComposedContextConfig(xmlConfigFiles = \"test.xml\")\n\tstatic class AliasedComposedContextConfigClass {\n\t}\n\n\t@AliasedValueComposedContextConfig(locations = \"test.xml\")\n\tstatic class AliasedValueComposedContextConfigClass {\n\t}\n\n\t@ImplicitAliasesContextConfig(\"foo.xml\")\n\tstatic class ImplicitAliasesContextConfigClass1 {\n\t}\n\n\t@ImplicitAliasesContextConfig(locations = \"bar.xml\")\n\tstatic class ImplicitAliasesContextConfigClass2 {\n\t}\n\n\t@ImplicitAliasesContextConfig(xmlFiles = \"baz.xml\")\n\tstatic class ImplicitAliasesContextConfigClass3 {\n\t}\n\n\t@ImplicitAliasesWithDefaults\n\tstatic class ImplicitAliasesWithDefaultsClass {\n\t}\n\n\t@TransitiveImplicitAliasesContextConfig(groovy = \"test.groovy\")\n\tstatic class TransitiveImplicitAliasesContextConfigClass {\n\t}\n\n\t@SingleLocationTransitiveImplicitAliasesContextConfig(groovy = \"test.groovy\")\n\tstatic class SingleLocationTransitiveImplicitAliasesContextConfigClass {\n\t}\n\n\t@TransitiveImplicitAliasesWithSkippedLevelContextConfig(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesWithSkippedLevelContextConfigClass {\n\t}\n\n\t@SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfig(xml = \"test.xml\")\n\tstatic class SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigClass {\n\t}\n\n\t@ComposedImplicitAliasesContextConfig\n\tstatic class ComposedImplicitAliasesContextConfigClass {\n\t}\n\n\t@ShadowedAliasComposedContextConfig(xmlConfigFiles = \"test.xml\")\n\tstatic class ShadowedAliasComposedContextConfigClass {\n\t}\n\n\t@AliasedComposedContextConfigAndTestPropSource(xmlConfigFiles = \"test.xml\")\n\tstatic class AliasedComposedContextConfigAndTestPropSourceClass {\n\t}\n\n\t@ComponentScan(value = \"com.example.app.test\", basePackages = \"com.example.app.test\")\n\tstatic class ComponentScanWithBasePackagesAndValueAliasClass {\n\t}\n\n\t@TestComponentScan(packages = \"com.example.app.test\")\n\tstatic class TestComponentScanClass {\n\t}\n\n\t@ConventionBasedSinglePackageComponentScan(basePackages = \"com.example.app.test\")\n\tstatic class ConventionBasedSinglePackageComponentScanClass {\n\t}\n\n\t@AliasForBasedSinglePackageComponentScan(pkg = \"com.example.app.test\")\n\tstatic class AliasForBasedSinglePackageComponentScanClass {\n\t}\n\n\t@SpringAppConfig(Number.class)\n\tstatic class SpringAppConfigClass {\n\t}\n\n\t@Resource(name = \"x\")\n\t@ParametersAreNonnullByDefault\n\tstatic class ResourceHolder {\n\t}\n\n\tinterface TransactionalService {\n\n\t\t@Transactional\n\t\t@Nullable Object doIt();\n\t}\n\n\tclass TransactionalServiceImpl implements TransactionalService {\n\n\t\t@Override\n\t\tpublic @Nullable Object doIt() {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Deprecated\n\t@ComponentScan\n\tclass ForAnnotationsClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ValueAttribute {\n\n\t\tString[] value();\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueAttribute(\"FromValueAttributeMeta\")\n\t@interface ValueAttributeMeta {\n\n\t\t@AliasFor(\"alias\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] alias() default {};\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueAttributeMeta(\"FromValueAttributeMetaMeta\")\n\t@interface ValueAttributeMetaMeta {\n\t}\n\n\t@ValueAttributeMetaMeta\n\tstatic class ValueAttributeMetaMetaClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface StandardContainerWithMultipleAttributes {\n\n\t\tStandardRepeatableWithContainerWithMultipleAttributes[] value();\n\n\t\tString name() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(StandardContainerWithMultipleAttributes.class)\n\t@interface StandardRepeatableWithContainerWithMultipleAttributes {\n\n\t\tString value() default \"\";\n\t}\n\n\t@StandardRepeatableWithContainerWithMultipleAttributes(\"a\")\n\t@StandardRepeatableWithContainerWithMultipleAttributes(\"b\")\n\tstatic class StandardRepeatablesWithContainerWithMultipleAttributesTestCase {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation.SubClassWithInheritedComposedAnnotation",
    "headType": "class",
    "relation": "extend",
    "tail": "ClassWithInheritedComposedAnnotation",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.SubSubClassWithInheritedComposedAnnotation",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.SubSubClassWithInheritedComposedAnnotation",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Set;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.ParametersAreNonnullByDefault;\nimport javax.annotation.meta.When;\n\nimport jakarta.annotation.Resource;\nimport org.jspecify.annotations.Nullable;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.AnnotationUtilsTests.ExtendsBaseClassWithGenericAnnotatedMethod;\nimport org.springframework.core.annotation.AnnotationUtilsTests.ImplementsInterfaceWithGenericAnnotatedMethod;\nimport org.springframework.core.annotation.AnnotationUtilsTests.WebController;\nimport org.springframework.core.annotation.AnnotationUtilsTests.WebMapping;\nimport org.springframework.core.testfixture.stereotype.Component;\nimport org.springframework.core.testfixture.stereotype.Indexed;\nimport org.springframework.util.MultiValueMap;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.Collectors.toSet;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.findAllMergedAnnotations;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.findMergedAnnotation;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getAllAnnotationAttributes;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getAllMergedAnnotations;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getMergedAnnotation;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getMergedAnnotationAttributes;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getMetaAnnotationTypes;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.hasAnnotation;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.hasMetaAnnotationTypes;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.isAnnotated;\nimport static org.springframework.core.annotation.AnnotationUtilsTests.asArray;\n\n/**\n * Tests for {@link AnnotatedElementUtils}.\n *\n * @author Sam Brannen\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 4.0.3\n * @see AnnotationUtilsTests\n * @see MultipleComposedAnnotationsOnSingleAnnotatedElementTests\n * @see ComposedRepeatableAnnotationsTests\n * @see NestedRepeatableAnnotationsTests\n */\nclass AnnotatedElementUtilsTests {\n\n\tprivate static final String TX_NAME = Transactional.class.getName();\n\n\n\t@Nested\n\tclass ConventionBasedAnnotationAttributeOverrideTests {\n\n\t\t@Test\n\t\tvoid getMergedAnnotationAttributesWithConventionBasedComposedAnnotation() {\n\t\t\tClass<?> element = ConventionBasedComposedContextConfigClass.class;\n\t\t\tString name = ContextConfig.class.getName();\n\t\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\n\t\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").containsExactly(\"explicitDeclaration\");\n\t\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").containsExactly(\"explicitDeclaration\");\n\n\t\t\t// Verify contracts between utility methods:\n\t\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t\t}\n\n\t\t/**\n\t\t * This test should never pass, simply because Spring does not support a hybrid\n\t\t * approach for annotation attribute overrides with transitive implicit aliases.\n\t\t * See SPR-13554 for details.\n\t\t * <p>Furthermore, if you choose to execute this test, it can fail for either\n\t\t * the first test class or the second one (with different exceptions), depending\n\t\t * on the order in which the JVM returns the attribute methods via reflection.\n\t\t */\n\t\t@Disabled(\"Permanently disabled but left in place for illustrative purposes\")\n\t\t@Test\n\t\tvoid getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation() {\n\t\t\tfor (Class<?> clazz : asList(HalfConventionBasedAndHalfAliasedComposedContextConfigClassV1.class,\n\t\t\t\t\tHalfConventionBasedAndHalfAliasedComposedContextConfigClassV2.class)) {\n\t\t\t\tgetMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation(clazz);\n\t\t\t}\n\t\t}\n\n\t\tprivate void getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation(Class<?> clazz) {\n\t\t\tString name = ContextConfig.class.getName();\n\t\t\tString simpleName = clazz.getSimpleName();\n\t\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(clazz, name);\n\n\t\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + simpleName).isNotNull();\n\t\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations for class [\" + simpleName + \"]\")\n\t\t\t\t.containsExactly(\"explicitDeclaration\");\n\t\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value for class [\" + simpleName + \"]\")\n\t\t\t\t.containsExactly(\"explicitDeclaration\");\n\n\t\t\t// Verify contracts between utility methods:\n\t\t\tassertThat(isAnnotated(clazz, name)).isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid getMergedAnnotationAttributesWithInvalidConventionBasedComposedAnnotation() {\n\t\t\tClass<?> element = InvalidConventionBasedComposedContextConfigClass.class;\n\t\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\t\tgetMergedAnnotationAttributes(element, ContextConfig.class))\n\t\t\t\t\t.withMessageContaining(\"Different @AliasFor mirror values for annotation\")\n\t\t\t\t\t.withMessageContaining(\"attribute 'locations' and its alias 'value'\")\n\t\t\t\t\t.withMessageContaining(\"values of [{requiredLocationsDeclaration}] and [{duplicateDeclaration}]\");\n\t\t}\n\n\t\t@Test\n\t\tvoid findMergedAnnotationAttributesWithSingleElementOverridingAnArrayViaConvention() {\n\t\t\tassertComponentScanAttributes(ConventionBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\n\t\t}\n\n\t\t@Test\n\t\tvoid findMergedAnnotationWithLocalAliasesThatConflictWithAttributesInMetaAnnotationByConvention() {\n\t\t\tClass<?> element = SpringAppConfigClass.class;\n\t\t\tContextConfig contextConfig = findMergedAnnotation(element, ContextConfig.class);\n\n\t\t\tassertThat(contextConfig).as(\"Should find @ContextConfig on \" + element).isNotNull();\n\t\t\tassertThat(contextConfig.locations()).as(\"locations for \" + element).isEmpty();\n\t\t\t// 'value' in @SpringAppConfig should not override 'value' in @ContextConfig\n\t\t\tassertThat(contextConfig.value()).as(\"value for \" + element).isEmpty();\n\t\t\tassertThat(contextConfig.classes()).as(\"classes for \" + element).containsExactly(Number.class);\n\t\t}\n\n\t\t@Test\n\t\tvoid findMergedAnnotationWithSingleElementOverridingAnArrayViaConvention() throws Exception {\n\t\t\tassertWebMapping(WebController.class.getMethod(\"postMappedWithPathAttribute\"));\n\t\t}\n\n\t}\n\n\n\t@Test\n\tvoid getMetaAnnotationTypesOnNonAnnotatedClass() {\n\t\tassertThat(getMetaAnnotationTypes(NonAnnotatedClass.class, TransactionalComponent.class)).isEmpty();\n\t\tassertThat(getMetaAnnotationTypes(NonAnnotatedClass.class, TransactionalComponent.class.getName())).isEmpty();\n\t}\n\n\t@Test\n\tvoid getMetaAnnotationTypesOnClassWithMetaDepth1() {\n\t\tSet<String> names = getMetaAnnotationTypes(TransactionalComponentClass.class, TransactionalComponent.class);\n\t\tassertThat(names).isEqualTo(names(Transactional.class, Component.class, Indexed.class));\n\n\t\tnames = getMetaAnnotationTypes(TransactionalComponentClass.class, TransactionalComponent.class.getName());\n\t\tassertThat(names).isEqualTo(names(Transactional.class, Component.class, Indexed.class));\n\t}\n\n\t@Test\n\tvoid getMetaAnnotationTypesOnClassWithMetaDepth2() {\n\t\tSet<String> names = getMetaAnnotationTypes(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class);\n\t\tassertThat(names).isEqualTo(names(TransactionalComponent.class, Transactional.class, Component.class, Indexed.class));\n\n\t\tnames = getMetaAnnotationTypes(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class.getName());\n\t\tassertThat(names).isEqualTo(names(TransactionalComponent.class, Transactional.class, Component.class, Indexed.class));\n\t}\n\n\tprivate Set<String> names(Class<?>... classes) {\n\t\treturn stream(classes).map(Class::getName).collect(toSet());\n\t}\n\n\t@Test\n\tvoid hasMetaAnnotationTypesOnNonAnnotatedClass() {\n\t\tassertThat(hasMetaAnnotationTypes(NonAnnotatedClass.class, TX_NAME)).isFalse();\n\t}\n\n\t@Test\n\tvoid hasMetaAnnotationTypesOnClassWithMetaDepth0() {\n\t\tassertThat(hasMetaAnnotationTypes(TransactionalComponentClass.class, TransactionalComponent.class.getName())).isFalse();\n\t}\n\n\t@Test\n\tvoid hasMetaAnnotationTypesOnClassWithMetaDepth1() {\n\t\tassertThat(hasMetaAnnotationTypes(TransactionalComponentClass.class, TX_NAME)).isTrue();\n\t\tassertThat(hasMetaAnnotationTypes(TransactionalComponentClass.class, Component.class.getName())).isTrue();\n\t}\n\n\t@Test\n\tvoid hasMetaAnnotationTypesOnClassWithMetaDepth2() {\n\t\tassertThat(hasMetaAnnotationTypes(ComposedTransactionalComponentClass.class, TX_NAME)).isTrue();\n\t\tassertThat(hasMetaAnnotationTypes(ComposedTransactionalComponentClass.class, Component.class.getName())).isTrue();\n\t\tassertThat(hasMetaAnnotationTypes(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class.getName())).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotatedOnNonAnnotatedClass() {\n\t\tassertThat(isAnnotated(NonAnnotatedClass.class, Transactional.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotatedOnClassWithMetaDepth() {\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, TransactionalComponent.class)).isTrue();\n\t\tassertThat(isAnnotated(SubTransactionalComponentClass.class, TransactionalComponent.class)).as(\"isAnnotated() does not search the class hierarchy.\").isFalse();\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, Transactional.class)).isTrue();\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, Component.class)).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, Transactional.class)).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, Component.class)).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class)).isTrue();\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid isAnnotatedForPlainTypes() {\n\t\tassertThat(isAnnotated(Order.class, Documented.class)).isTrue();\n\t\tassertThat(isAnnotated(org.springframework.lang.NonNullApi.class, Documented.class)).isTrue();\n\t\tassertThat(isAnnotated(org.springframework.lang.NonNullApi.class, Nonnull.class)).isTrue();\n\t\tassertThat(isAnnotated(ParametersAreNonnullByDefault.class, Nonnull.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isAnnotatedWithNameOnNonAnnotatedClass() {\n\t\tassertThat(isAnnotated(NonAnnotatedClass.class, TX_NAME)).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotatedWithNameOnClassWithMetaDepth() {\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, TransactionalComponent.class.getName())).isTrue();\n\t\tassertThat(isAnnotated(SubTransactionalComponentClass.class, TransactionalComponent.class.getName())).as(\"isAnnotated() does not search the class hierarchy.\").isFalse();\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, TX_NAME)).isTrue();\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, Component.class.getName())).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, TX_NAME)).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, Component.class.getName())).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class.getName())).isTrue();\n\t}\n\n\t@Test\n\tvoid hasAnnotationOnNonAnnotatedClass() {\n\t\tassertThat(hasAnnotation(NonAnnotatedClass.class, Transactional.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid hasAnnotationOnClassWithMetaDepth() {\n\t\tassertThat(hasAnnotation(TransactionalComponentClass.class, TransactionalComponent.class)).isTrue();\n\t\tassertThat(hasAnnotation(SubTransactionalComponentClass.class, TransactionalComponent.class)).isTrue();\n\t\tassertThat(hasAnnotation(TransactionalComponentClass.class, Transactional.class)).isTrue();\n\t\tassertThat(hasAnnotation(TransactionalComponentClass.class, Component.class)).isTrue();\n\t\tassertThat(hasAnnotation(ComposedTransactionalComponentClass.class, Transactional.class)).isTrue();\n\t\tassertThat(hasAnnotation(ComposedTransactionalComponentClass.class, Component.class)).isTrue();\n\t\tassertThat(hasAnnotation(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class)).isTrue();\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid hasAnnotationForPlainTypes() {\n\t\tassertThat(hasAnnotation(Order.class, Documented.class)).isTrue();\n\t\tassertThat(hasAnnotation(org.springframework.lang.NonNullApi.class, Documented.class)).isTrue();\n\t\tassertThat(hasAnnotation(org.springframework.lang.NonNullApi.class, Nonnull.class)).isTrue();\n\t\tassertThat(hasAnnotation(ParametersAreNonnullByDefault.class, Nonnull.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesOnNonAnnotatedClass() {\n\t\tassertThat(getAllAnnotationAttributes(NonAnnotatedClass.class, TX_NAME)).isNull();\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesOnClassWithLocalAnnotation() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxConfig.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on TxConfig\").isNotNull();\n\t\tassertThat(attributes.get(\"value\")).as(\"value for TxConfig\").isEqualTo(List.of(\"TxConfig\"));\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesOnClassWithLocalComposedAnnotationAndInheritedAnnotation() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(SubClassWithInheritedAnnotation.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on SubClassWithInheritedAnnotation\").isNotNull();\n\t\tassertThat(attributes.get(\"qualifier\")).isEqualTo(asList(\"composed2\", \"transactionManager\"));\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(SubSubClassWithInheritedAnnotation.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on SubSubClassWithInheritedAnnotation\").isNotNull();\n\t\tassertThat(attributes.get(\"qualifier\")).isEqualTo(List.of(\"transactionManager\"));\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes( SubSubClassWithInheritedComposedAnnotation.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on SubSubClassWithInheritedComposedAnnotation\").isNotNull();\n\t\tassertThat(attributes.get(\"qualifier\")).isEqualTo(List.of(\"composed1\"));\n\t}\n\n\t/**\n\t * If the \"value\" entry contains both \"DerivedTxConfig\" AND \"TxConfig\", then\n\t * the algorithm is accidentally picking up shadowed annotations of the same\n\t * type within the class hierarchy. Such undesirable behavior would cause the\n\t * logic in {@code org.springframework.context.annotation.ProfileCondition}\n\t * to fail.\n\t */\n\t@Test\n\tvoid getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\n\t\t// See org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on DerivedTxConfig\").isNotNull();\n\t\tassertThat(attributes.get(\"value\")).as(\"value for DerivedTxConfig\").isEqualTo(List.of(\"DerivedTxConfig\"));\n\t}\n\n\t/**\n\t * Note: this functionality is required by {@code org.springframework.context.annotation.ProfileCondition}.\n\t */\n\t@Test\n\tvoid getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {\n\t\t// See org.springframework.core.env.EnvironmentSystemIntegrationTests\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations\").isNotNull();\n\t\tassertThat(attributes.get(\"value\")).as(\"value for TxFromMultipleComposedAnnotations.\").isEqualTo(asList(\"TxInheritedComposed\", \"TxComposed\"));\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid getAllAnnotationAttributesOnLangType() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(\n\t\t\t\torg.springframework.lang.NonNullApi.class, Nonnull.class.getName());\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Nonnull on NonNullApi\").isNotNull();\n\t\tassertThat(attributes.get(\"when\")).as(\"value for NonNullApi\").isEqualTo(List.of(When.ALWAYS));\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesOnJavaxType() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(\n\t\t\t\tParametersAreNonnullByDefault.class, Nonnull.class.getName());\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Nonnull on NonNullApi\").isNotNull();\n\t\tassertThat(attributes.get(\"when\")).as(\"value for NonNullApi\").isEqualTo(List.of(When.ALWAYS));\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnClassWithLocalAnnotation() {\n\t\tClass<?> element = TxConfig.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Annotation attributes for @Transactional on TxConfig\").isNotNull();\n\t\tassertThat(attributes.getString(\"value\")).as(\"value for TxConfig\").isEqualTo(\"TxConfig\");\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\n\t\tClass<?> element = DerivedTxConfig.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Annotation attributes for @Transactional on DerivedTxConfig\").isNotNull();\n\t\tassertThat(attributes.getString(\"value\")).as(\"value for DerivedTxConfig\").isEqualTo(\"DerivedTxConfig\");\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(MetaCycleAnnotatedClass.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Should not find annotation attributes for @Transactional on MetaCycleAnnotatedClass\").isNull();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesFavorsLocalComposedAnnotationOverInheritedAnnotation() {\n\t\tClass<?> element = SubClassWithInheritedAnnotation.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"AnnotationAttributes for @Transactional on SubClassWithInheritedAnnotation\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t\tassertThat(attributes.getBoolean(\"readOnly\")).as(\"readOnly flag for SubClassWithInheritedAnnotation.\").isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tClass<?> element = SubSubClassWithInheritedAnnotation.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"AnnotationAttributes for @Transactional on SubSubClassWithInheritedAnnotation\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t\tassertThat(attributes.getBoolean(\"readOnly\")).as(\"readOnly flag for SubSubClassWithInheritedAnnotation.\").isFalse();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tClass<?> element = SubSubClassWithInheritedComposedAnnotation.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"AnnotationAttributes for @Transactional on SubSubClassWithInheritedComposedAnnotation.\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t\tassertThat(attributes.getBoolean(\"readOnly\")).as(\"readOnly flag for SubSubClassWithInheritedComposedAnnotation.\").isFalse();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesFromInterfaceImplementedBySuperclass() {\n\t\tClass<?> element = ConcreteClassWithInheritedAnnotation.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Should not find @Transactional on ConcreteClassWithInheritedAnnotation\").isNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isFalse();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnInheritedAnnotationInterface() {\n\t\tClass<?> element = InheritedAnnotationInterface.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Should find @Transactional on InheritedAnnotationInterface\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnNonInheritedAnnotationInterface() {\n\t\tClass<?> element = NonInheritedAnnotationInterface.class;\n\t\tString name = Order.class.getName();\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Should find @Order on NonInheritedAnnotationInterface\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesWithAliasedComposedAnnotation() {\n\t\tClass<?> element = AliasedComposedContextConfigClass.class;\n\t\tString name = ContextConfig.class.getName();\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\n\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(asArray(\"test.xml\"));\n\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(asArray(\"test.xml\"));\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesWithAliasedValueComposedAnnotation() {\n\t\tClass<?> element = AliasedValueComposedContextConfigClass.class;\n\t\tString name = ContextConfig.class.getName();\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\n\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(asArray(\"test.xml\"));\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(asArray(\"test.xml\"));\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesWithImplicitAliasesInMetaAnnotationOnComposedAnnotation() {\n\t\tClass<?> element = ComposedImplicitAliasesContextConfigClass.class;\n\t\tString name = ImplicitAliasesContextConfig.class.getName();\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tString[] expected = asArray(\"A.xml\", \"B.xml\");\n\n\t\tassertThat(attributes).as(\"Should find @ImplicitAliasesContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"groovyScripts\")).as(\"groovyScripts\").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"xmlFiles\")).as(\"xmlFiles\").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(expected);\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithAliasedValueComposedAnnotation() {\n\t\tassertGetMergedAnnotation(AliasedValueComposedContextConfigClass.class, \"test.xml\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithImplicitAliasesForSameAttributeInComposedAnnotation() {\n\t\tassertGetMergedAnnotation(ImplicitAliasesContextConfigClass1.class, \"foo.xml\");\n\t\tassertGetMergedAnnotation(ImplicitAliasesContextConfigClass2.class, \"bar.xml\");\n\t\tassertGetMergedAnnotation(ImplicitAliasesContextConfigClass3.class, \"baz.xml\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithTransitiveImplicitAliases() {\n\t\tassertGetMergedAnnotation(TransitiveImplicitAliasesContextConfigClass.class, \"test.groovy\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithTransitiveImplicitAliasesWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\tassertGetMergedAnnotation(SingleLocationTransitiveImplicitAliasesContextConfigClass.class, \"test.groovy\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithTransitiveImplicitAliasesWithSkippedLevel() {\n\t\tassertGetMergedAnnotation(TransitiveImplicitAliasesWithSkippedLevelContextConfigClass.class, \"test.xml\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithTransitiveImplicitAliasesWithSkippedLevelWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\tassertGetMergedAnnotation(SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigClass.class, \"test.xml\");\n\t}\n\n\tprivate void assertGetMergedAnnotation(Class<?> element, String... expected) {\n\t\tString name = ContextConfig.class.getName();\n\t\tContextConfig contextConfig = getMergedAnnotation(element, ContextConfig.class);\n\n\t\tassertThat(contextConfig).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(contextConfig.locations()).as(\"locations\").isEqualTo(expected);\n\t\tassertThat(contextConfig.value()).as(\"value\").isEqualTo(expected);\n\t\tObject[] expecteds = new Class<?>[0];\n\t\tassertThat(contextConfig.classes()).as(\"classes\").isEqualTo(expecteds);\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithImplicitAliasesInMetaAnnotationOnComposedAnnotation() {\n\t\tClass<?> element = ComposedImplicitAliasesContextConfigClass.class;\n\t\tString name = ImplicitAliasesContextConfig.class.getName();\n\t\tImplicitAliasesContextConfig config = getMergedAnnotation(element, ImplicitAliasesContextConfig.class);\n\t\tString[] expected = asArray(\"A.xml\", \"B.xml\");\n\n\t\tassertThat(config).as(\"Should find @ImplicitAliasesContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(config.groovyScripts()).as(\"groovyScripts\").isEqualTo(expected);\n\t\tassertThat(config.xmlFiles()).as(\"xmlFiles\").isEqualTo(expected);\n\t\tassertThat(config.locations()).as(\"locations\").isEqualTo(expected);\n\t\tassertThat(config.value()).as(\"value\").isEqualTo(expected);\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithImplicitAliasesWithDefaultsInMetaAnnotationOnComposedAnnotation() {\n\t\tClass<?> element = ImplicitAliasesWithDefaultsClass.class;\n\t\tString name = AliasesWithDefaults.class.getName();\n\t\tAliasesWithDefaults annotation = getMergedAnnotation(element, AliasesWithDefaults.class);\n\n\t\tassertThat(annotation).as(\"Should find @AliasesWithDefaults on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(annotation.a1()).as(\"a1\").isEqualTo(\"ImplicitAliasesWithDefaults\");\n\t\tassertThat(annotation.a2()).as(\"a2\").isEqualTo(\"ImplicitAliasesWithDefaults\");\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesWithShadowedAliasComposedAnnotation() {\n\t\tClass<?> element = ShadowedAliasComposedContextConfigClass.class;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, ContextConfig.class);\n\n\t\tString[] expected = asArray(\"test.xml\");\n\n\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(expected);\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(InheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on InheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnSubInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(SubInheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on SubInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnSubSubInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(SubSubInheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on SubSubInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnNonInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(NonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on NonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnSubNonInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(SubNonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on SubNonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnSubSubNonInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(SubSubNonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on SubSubNonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesInheritedFromInterfaceMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleFromInterface\");\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(method, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on ConcreteClassWithInheritedAnnotation.handleFromInterface() method\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesInheritedFromAbstractMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handle\");\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on ConcreteClassWithInheritedAnnotation.handle() method\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleParameterized\", String.class);\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()\").isNotNull();\n\t}\n\n\t/**\n\t * Bridge/bridged method setup code copied from\n\t * {@link org.springframework.core.BridgeMethodResolverTests#withGenericParameter()}.\n\t * @since 4.2\n\t */\n\t@Test\n\tvoid findMergedAnnotationAttributesFromBridgeMethod() {\n\t\tMethod[] methods = StringGenericParameter.class.getMethods();\n\t\tMethod bridgeMethod = null;\n\t\tMethod bridgedMethod = null;\n\n\t\tfor (Method method : methods) {\n\t\t\tif (\"getFor\".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {\n\t\t\t\tif (method.getReturnType().equals(Object.class)) {\n\t\t\t\t\tbridgeMethod = method;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbridgedMethod = method;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\n\t\tboolean condition = bridgedMethod != null && !bridgedMethod.isBridge();\n\t\tassertThat(condition).isTrue();\n\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on StringGenericParameter.getFor() bridge method\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnClassWithMetaAndLocalTxConfig() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(MetaAndLocalTxConfigClass.class, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on MetaAndLocalTxConfigClass\").isNotNull();\n\t\tassertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier for MetaAndLocalTxConfigClass.\").isEqualTo(\"localTxMgr\");\n\t}\n\n\t@Test\n\tvoid findAndSynthesizeAnnotationAttributesOnClassWithAttributeAliasesInTargetAnnotation() {\n\t\tString qualifier = \"aliasForQualifier\";\n\n\t\t// 1) Find and merge AnnotationAttributes from the annotation hierarchy\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(\n\t\t\t\tAliasedTransactionalComponentClass.class, AliasedTransactional.class);\n\t\tassertThat(attributes).as(\"@AliasedTransactional on AliasedTransactionalComponentClass.\").isNotNull();\n\n\t\t// 2) Synthesize the AnnotationAttributes back into the target annotation\n\t\tAliasedTransactional annotation = AnnotationUtils.synthesizeAnnotation(attributes,\n\t\t\t\tAliasedTransactional.class, AliasedTransactionalComponentClass.class);\n\t\tassertThat(annotation).isNotNull();\n\n\t\t// 3) Verify that the AnnotationAttributes and synthesized annotation are equivalent\n\t\tassertThat(attributes.getString(\"value\")).as(\"TX value via attributes.\").isEqualTo(qualifier);\n\t\tassertThat(annotation.value()).as(\"TX value via synthesized annotation.\").isEqualTo(qualifier);\n\t\tassertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier via attributes.\").isEqualTo(qualifier);\n\t\tassertThat(annotation.qualifier()).as(\"TX qualifier via synthesized annotation.\").isEqualTo(qualifier);\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnClassWithAttributeAliasInComposedAnnotationAndNestedAnnotationsInTargetAnnotation() {\n\t\tAnnotationAttributes attributes = assertComponentScanAttributes(TestComponentScanClass.class, \"com.example.app.test\");\n\n\t\tFilter[] excludeFilters = attributes.getAnnotationArray(\"excludeFilters\", Filter.class);\n\t\tassertThat(excludeFilters).isNotNull();\n\n\t\tList<String> patterns = stream(excludeFilters).map(Filter::pattern).collect(toList());\n\t\tassertThat(patterns).isEqualTo(asList(\"*Test\", \"*Tests\"));\n\t}\n\n\t/**\n\t * This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}\n\t * uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation\n\t * attributes since attributes may be arrays.\n\t */\n\t@Test\n\tvoid findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {\n\t\tassertComponentScanAttributes(ComponentScanWithBasePackagesAndValueAliasClass.class, \"com.example.app.test\");\n\t}\n\n\t/**\n\t * @since 5.2.1\n\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\n\t */\n\t@Test\n\tvoid findMergedAnnotationAttributesOnMethodWithComposedMetaTransactionalAnnotation() throws Exception {\n\t\tMethod method = getClass().getDeclaredMethod(\"composedTransactionalMethod\");\n\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(method, AliasedTransactional.class);\n\t\tassertThat(attributes).as(\"Should find @AliasedTransactional on \" + method).isNotNull();\n\t\tassertThat(attributes.getString(\"value\")).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t/**\n\t * @since 5.2.1\n\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\n\t */\n\t@Test\n\tvoid findMergedAnnotationOnMethodWithComposedMetaTransactionalAnnotation() throws Exception {\n\t\tMethod method = getClass().getDeclaredMethod(\"composedTransactionalMethod\");\n\n\t\tAliasedTransactional annotation = findMergedAnnotation(method, AliasedTransactional.class);\n\t\tassertThat(annotation).as(\"Should find @AliasedTransactional on \" + method).isNotNull();\n\t\tassertThat(annotation.value()).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(annotation.qualifier()).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t/**\n\t * @since 5.2.1\n\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\n\t */\n\t@Test\n\tvoid findMergedAnnotationAttributesOnClassWithComposedMetaTransactionalAnnotation() {\n\t\tClass<?> clazz = ComposedTransactionalClass.class;\n\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(clazz, AliasedTransactional.class);\n\t\tassertThat(attributes).as(\"Should find @AliasedTransactional on \" + clazz).isNotNull();\n\t\tassertThat(attributes.getString(\"value\")).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t/**\n\t * @since 5.2.1\n\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\n\t */\n\t@Test\n\tvoid findMergedAnnotationOnClassWithComposedMetaTransactionalAnnotation() {\n\t\tClass<?> clazz = ComposedTransactionalClass.class;\n\n\t\tAliasedTransactional annotation = findMergedAnnotation(clazz, AliasedTransactional.class);\n\t\tassertThat(annotation).as(\"Should find @AliasedTransactional on \" + clazz).isNotNull();\n\t\tassertThat(annotation.value()).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(annotation.qualifier()).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\tassertComponentScanAttributes(AliasForBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\n\t}\n\n\tprivate AnnotationAttributes assertComponentScanAttributes(Class<?> element, String... expected) {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(element, ComponentScan.class);\n\n\t\tassertThat(attributes).as(\"Should find @ComponentScan on \" + element).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value: \").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"basePackages\")).as(\"basePackages: \").isEqualTo(expected);\n\n\t\treturn attributes;\n\t}\n\n\tprivate AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element, Class<? extends Annotation> annotationType) {\n\t\treturn AnnotatedElementUtils.findMergedAnnotationAttributes(element, annotationType.getName(), false, false);\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationWithAttributeAliasesInTargetAnnotation() {\n\t\tClass<?> element = AliasedTransactionalComponentClass.class;\n\t\tAliasedTransactional annotation = findMergedAnnotation(element, AliasedTransactional.class);\n\t\tassertThat(annotation).as(\"@AliasedTransactional on \" + element).isNotNull();\n\t\tassertThat(annotation.value()).as(\"TX value via synthesized annotation.\").isEqualTo(\"aliasForQualifier\");\n\t\tassertThat(annotation.qualifier()).as(\"TX qualifier via synthesized annotation.\").isEqualTo(\"aliasForQualifier\");\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationForMultipleMetaAnnotationsWithClashingAttributeNames() {\n\t\tString[] xmlLocations = asArray(\"test.xml\");\n\t\tString[] propFiles = asArray(\"test.properties\");\n\n\t\tClass<?> element = AliasedComposedContextConfigAndTestPropSourceClass.class;\n\n\t\tContextConfig contextConfig = findMergedAnnotation(element, ContextConfig.class);\n\t\tassertThat(contextConfig).as(\"@ContextConfig on \" + element).isNotNull();\n\t\tassertThat(contextConfig.locations()).as(\"locations\").isEqualTo(xmlLocations);\n\t\tassertThat(contextConfig.value()).as(\"value\").isEqualTo(xmlLocations);\n\n\t\t// Synthesized annotation\n\t\tTestPropSource testPropSource = AnnotationUtils.findAnnotation(element, TestPropSource.class);\n\t\tassertThat(testPropSource.locations()).as(\"locations\").isEqualTo(propFiles);\n\t\tassertThat(testPropSource.value()).as(\"value\").isEqualTo(propFiles);\n\n\t\t// Merged annotation\n\t\ttestPropSource = findMergedAnnotation(element, TestPropSource.class);\n\t\tassertThat(testPropSource).as(\"@TestPropSource on \" + element).isNotNull();\n\t\tassertThat(testPropSource.locations()).as(\"locations\").isEqualTo(propFiles);\n\t\tassertThat(testPropSource.value()).as(\"value\").isEqualTo(propFiles);\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationWithSingleElementOverridingAnArrayViaAliasFor() throws Exception {\n\t\tassertWebMapping(WebController.class.getMethod(\"getMappedWithValueAttribute\"));\n\t\tassertWebMapping(WebController.class.getMethod(\"getMappedWithPathAttribute\"));\n\t}\n\n\tprivate void assertWebMapping(AnnotatedElement element) {\n\t\tWebMapping webMapping = findMergedAnnotation(element, WebMapping.class);\n\t\tassertThat(webMapping).isNotNull();\n\t\tassertThat(webMapping.value()).as(\"value attribute: \").isEqualTo(asArray(\"/test\"));\n\t\tassertThat(webMapping.path()).as(\"path attribute: \").isEqualTo(asArray(\"/test\"));\n\t}\n\n\t@Test\n\tvoid javaLangAnnotationTypeViaFindMergedAnnotation() throws Exception {\n\t\tConstructor<?> deprecatedCtor = Date.class.getConstructor(String.class);\n\t\tassertThat(findMergedAnnotation(deprecatedCtor, Deprecated.class)).isEqualTo(deprecatedCtor.getAnnotation(Deprecated.class));\n\t\tassertThat(findMergedAnnotation(Date.class, Deprecated.class)).isEqualTo(Date.class.getAnnotation(Deprecated.class));\n\t}\n\n\t@Test\n\tvoid javaxAnnotationTypeViaFindMergedAnnotation() {\n\t\tassertThat(findMergedAnnotation(ResourceHolder.class, Resource.class)).isEqualTo(ResourceHolder.class.getAnnotation(Resource.class));\n\t\tassertThat(findMergedAnnotation(SpringAppConfigClass.class, Resource.class)).isEqualTo(SpringAppConfigClass.class.getAnnotation(Resource.class));\n\t}\n\n\t@Test\n\tvoid javaxMetaAnnotationTypeViaFindMergedAnnotation() {\n\t\tassertThat(findMergedAnnotation(ParametersAreNonnullByDefault.class, Nonnull.class)).isEqualTo(ParametersAreNonnullByDefault.class.getAnnotation(Nonnull.class));\n\t\tassertThat(findMergedAnnotation(ResourceHolder.class, Nonnull.class)).isEqualTo(ParametersAreNonnullByDefault.class.getAnnotation(Nonnull.class));\n\t}\n\n\t@Test\n\tvoid nullableAnnotationTypeViaFindMergedAnnotation() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tassertThat(findMergedAnnotation(method, Resource.class)).isEqualTo(method.getAnnotation(Resource.class));\n\t}\n\n\t@Test\n\tvoid getAllMergedAnnotationsOnClassWithInterface() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tSet<Transactional> allMergedAnnotations = getAllMergedAnnotations(method, Transactional.class);\n\t\tassertThat(allMergedAnnotations).isEmpty();\n\t}\n\n\t@Test\n\tvoid findAllMergedAnnotationsOnClassWithInterface() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tSet<Transactional> allMergedAnnotations = findAllMergedAnnotations(method, Transactional.class);\n\t\tassertThat(allMergedAnnotations).hasSize(1);\n\t}\n\n\t@Test  // SPR-16060\n\tvoid findMethodAnnotationFromGenericInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tOrder order = findMergedAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test  // SPR-17146\n\tvoid findMethodAnnotationFromGenericSuperclass() throws Exception {\n\t\tMethod method = ExtendsBaseClassWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tOrder order = findMergedAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test // gh-22655\n\tvoid forAnnotationsCreatesCopyOfArrayOnEachCall() {\n\t\tAnnotatedElement element = AnnotatedElementUtils.forAnnotations(ForAnnotationsClass.class.getDeclaredAnnotations());\n\t\t// Trigger the NPE as originally reported in the bug\n\t\tAnnotationsScanner.getDeclaredAnnotations(element, false);\n\t\tAnnotationsScanner.getDeclaredAnnotations(element, false);\n\t\t// Also specifically test we get different instances\n\t\tassertThat(element.getDeclaredAnnotations()).isNotSameAs(element.getDeclaredAnnotations());\n\t}\n\n\t@Test // gh-22703\n\tvoid getMergedAnnotationOnThreeDeepMetaWithValue() {\n\t\tValueAttribute annotation = AnnotatedElementUtils.getMergedAnnotation(\n\t\t\t\tValueAttributeMetaMetaClass.class, ValueAttribute.class);\n\t\tassertThat(annotation.value()).containsExactly(\"FromValueAttributeMeta\");\n\t}\n\n\t/**\n\t * @since 5.3.25\n\t */\n\t@Test // gh-29685\n\tvoid getMergedRepeatableAnnotationsWithContainerWithMultipleAttributes() {\n\t\tSet<StandardRepeatableWithContainerWithMultipleAttributes> repeatableAnnotations =\n\t\t\t\tAnnotatedElementUtils.getMergedRepeatableAnnotations(\n\t\t\t\t\t\tStandardRepeatablesWithContainerWithMultipleAttributesTestCase.class,\n\t\t\t\t\t\tStandardRepeatableWithContainerWithMultipleAttributes.class);\n\t\tassertThat(repeatableAnnotations).map(StandardRepeatableWithContainerWithMultipleAttributes::value)\n\t\t\t\t.containsExactly(\"a\", \"b\");\n\t}\n\n\t/**\n\t * @since 5.3.25\n\t */\n\t@Test // gh-29685\n\tvoid findMergedRepeatableAnnotationsWithContainerWithMultipleAttributes() {\n\t\tSet<StandardRepeatableWithContainerWithMultipleAttributes> repeatableAnnotations =\n\t\t\t\tAnnotatedElementUtils.findMergedRepeatableAnnotations(\n\t\t\t\t\t\tStandardRepeatablesWithContainerWithMultipleAttributesTestCase.class,\n\t\t\t\t\t\tStandardRepeatableWithContainerWithMultipleAttributes.class);\n\t\tassertThat(repeatableAnnotations).map(StandardRepeatableWithContainerWithMultipleAttributes::value)\n\t\t\t\t.containsExactly(\"a\", \"b\");\n\t}\n\n\t// -------------------------------------------------------------------------\n\n\t@MetaCycle3\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.ANNOTATION_TYPE)\n\t@interface MetaCycle1 {\n\t}\n\n\t@MetaCycle1\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.ANNOTATION_TYPE)\n\t@interface MetaCycle2 {\n\t}\n\n\t@MetaCycle2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface MetaCycle3 {\n\t}\n\n\t@MetaCycle3\n\tstatic class MetaCycleAnnotatedClass {\n\t}\n\n\t// -------------------------------------------------------------------------\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Inherited\n\t@interface Transactional {\n\n\t\tString value() default \"\";\n\n\t\tString qualifier() default \"transactionManager\";\n\n\t\tboolean readOnly() default false;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Inherited\n\t@interface AliasedTransactional {\n\n\t\t@AliasFor(\"qualifier\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString qualifier() default \"\";\n\t}\n\n\t@AliasedTransactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@interface MyAliasedTransactional {\n\n\t\t@AliasFor(annotation = AliasedTransactional.class, attribute = \"value\")\n\t\tString value() default \"defaultTransactionManager\";\n\t}\n\n\t@MyAliasedTransactional(\"anotherTransactionManager\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@interface ComposedMyAliasedTransactional {\n\t}\n\n\t@Transactional(qualifier = \"composed1\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@Inherited\n\t@interface InheritedComposed {\n\t}\n\n\t@Transactional(qualifier = \"composed2\", readOnly = true)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface Composed {\n\t}\n\n\t@Transactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxComposedWithOverride {\n\n\t\tString qualifier() default \"txMgr\";\n\t}\n\n\t@Transactional(\"TxInheritedComposed\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxInheritedComposed {\n\t}\n\n\t@Transactional(\"TxComposed\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxComposed {\n\t}\n\n\t@Transactional\n\t@Component\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransactionalComponent {\n\t}\n\n\t@TransactionalComponent\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedTransactionalComponent {\n\t}\n\n\t@AliasedTransactional(value = \"aliasForQualifier\")\n\t@Component\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedTransactionalComponent {\n\t}\n\n\t@TxComposedWithOverride\n\t// Override default \"txMgr\" from @TxComposedWithOverride with \"localTxMgr\"\n\t@Transactional(qualifier = \"localTxMgr\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface MetaAndLocalTxConfig {\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.test.context.TestPropertySource}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestPropSource {\n\n\t\t@AliasFor(\"locations\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] locations() default {};\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.test.context.ContextConfiguration}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContextConfig {\n\n\t\t@AliasFor(\"locations\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] locations() default {};\n\n\t\tClass<?>[] classes() default {};\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionBasedComposedContextConfig {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfig.class)\n\t\tString[] locations() default {};\n\t}\n\n\t@ContextConfig(value = \"duplicateDeclaration\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface InvalidConventionBasedComposedContextConfig {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfig.class)\n\t\tString[] locations();\n\t}\n\n\t/**\n\t * This hybrid approach for annotation attribute overrides with transitive implicit\n\t * aliases is unsupported. See SPR-13554 for details.\n\t */\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface HalfConventionBasedAndHalfAliasedComposedContextConfig {\n\n\t\tString[] locations() default {};\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles() default {};\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles();\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedValueComposedContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"value\")\n\t\tString[] locations();\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] groovyScripts() default {};\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlFiles() default {};\n\n\t\t// intentionally omitted: attribute = \"locations\"\n\t\t@AliasFor(annotation = ContextConfig.class)\n\t\tString[] locations() default {};\n\n\t\t// intentionally omitted: attribute = \"locations\" (SPR-14069)\n\t\t@AliasFor(annotation = ContextConfig.class)\n\t\tString[] value() default {};\n\t}\n\n\t@ImplicitAliasesContextConfig(xmlFiles = {\"A.xml\", \"B.xml\"})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedImplicitAliasesContextConfig {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasesWithDefaults {\n\n\t\t@AliasFor(\"a2\")\n\t\tString a1() default \"AliasesWithDefaults\";\n\n\t\t@AliasFor(\"a1\")\n\t\tString a2() default \"AliasesWithDefaults\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasesWithDefaults\n\t@interface ImplicitAliasesWithDefaults {\n\n\t\t@AliasFor(annotation = AliasesWithDefaults.class, attribute = \"a1\")\n\t\tString b1() default \"ImplicitAliasesWithDefaults\";\n\n\t\t@AliasFor(annotation = AliasesWithDefaults.class, attribute = \"a2\")\n\t\tString b2() default \"ImplicitAliasesWithDefaults\";\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"xmlFiles\")\n\t\tString[] xml() default {};\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScripts\")\n\t\tString[] groovy() default {};\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SingleLocationTransitiveImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"xmlFiles\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScripts\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesWithSkippedLevelContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xml() default {};\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScripts\")\n\t\tString[] groovy() default {};\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScripts\")\n\t\tString groovy() default \"\";\n\t}\n\n\t/**\n\t * Although the configuration declares an explicit value for 'value' and\n\t * requires a value for the aliased 'locations', this does not result in\n\t * an error since 'locations' effectively <em>shadows</em> the 'value'\n\t * attribute (which cannot be set via the composed annotation anyway).\n\t *\n\t * If 'value' were not shadowed, such a declaration would not make sense.\n\t */\n\t@ContextConfig(value = \"duplicateDeclaration\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ShadowedAliasComposedContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles();\n\t}\n\n\t@ContextConfig(locations = \"shadowed.xml\")\n\t@TestPropSource(locations = \"test.properties\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfigAndTestPropSource {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles() default \"default.xml\";\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.boot.test.SpringApplicationConfiguration}.\n\t */\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SpringAppConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] locations() default {};\n\n\t\t// Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfig.class, attribute = \"classes\")\n\t\t@AliasFor(\"value\")\n\t\tClass<?>[] classes() default {};\n\n\t\t// Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfig.class, attribute = \"classes\")\n\t\t@AliasFor(\"classes\")\n\t\tClass<?>[] value() default {};\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.context.annotation.ComponentScan}\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScan {\n\n\t\t@AliasFor(\"basePackages\")\n\t\tString[] value() default {};\n\n\t\t// Intentionally no alias declaration for \"value\"\n\t\tString[] basePackages() default {};\n\n\t\tFilter[] excludeFilters() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({})\n\t@interface Filter {\n\n\t\tString pattern();\n\t}\n\n\t@ComponentScan(excludeFilters = {@Filter(pattern = \"*Test\"), @Filter(pattern = \"*Tests\")})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestComponentScan {\n\n\t\t@AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\n\t\tString[] packages();\n\t}\n\n\t@ComponentScan\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionBasedSinglePackageComponentScan {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ComponentScan.class)\n\t\tString basePackages();\n\t}\n\n\t@ComponentScan\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForBasedSinglePackageComponentScan {\n\n\t\t@AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\n\t\tString pkg();\n\t}\n\n\t// -------------------------------------------------------------------------\n\n\tstatic class NonAnnotatedClass {\n\t}\n\n\t@TransactionalComponent\n\tstatic class TransactionalComponentClass {\n\t}\n\n\tstatic class SubTransactionalComponentClass extends TransactionalComponentClass {\n\t}\n\n\t@ComposedTransactionalComponent\n\tstatic class ComposedTransactionalComponentClass {\n\t}\n\n\t@AliasedTransactionalComponent\n\tstatic class AliasedTransactionalComponentClass {\n\t}\n\n\t@ComposedMyAliasedTransactional\n\tvoid composedTransactionalMethod() {\n\t}\n\n\t@ComposedMyAliasedTransactional\n\tstatic class ComposedTransactionalClass {\n\t}\n\n\t@Transactional\n\tstatic class ClassWithInheritedAnnotation {\n\t}\n\n\t@Composed\n\tstatic class SubClassWithInheritedAnnotation extends ClassWithInheritedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedAnnotation extends SubClassWithInheritedAnnotation {\n\t}\n\n\t@InheritedComposed\n\tstatic class ClassWithInheritedComposedAnnotation {\n\t}\n\n\t@Composed\n\tstatic class SubClassWithInheritedComposedAnnotation extends ClassWithInheritedComposedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedComposedAnnotation extends SubClassWithInheritedComposedAnnotation {\n\t}\n\n\t@MetaAndLocalTxConfig\n\tstatic class MetaAndLocalTxConfigClass {\n\t}\n\n\t@Transactional(\"TxConfig\")\n\tstatic class TxConfig {\n\t}\n\n\t@Transactional(\"DerivedTxConfig\")\n\tstatic class DerivedTxConfig extends TxConfig {\n\t}\n\n\t@TxInheritedComposed\n\t@TxComposed\n\tstatic class TxFromMultipleComposedAnnotations {\n\t}\n\n\t@Transactional\n\tinterface InterfaceWithInheritedAnnotation {\n\n\t\t@Order\n\t\tvoid handleFromInterface();\n\t}\n\n\tabstract static class AbstractClassWithInheritedAnnotation<T> implements InterfaceWithInheritedAnnotation {\n\n\t\t@Transactional\n\t\tpublic abstract void handle();\n\n\t\t@Transactional\n\t\tpublic void handleParameterized(T t) {\n\t\t}\n\t}\n\n\tstatic class ConcreteClassWithInheritedAnnotation extends AbstractClassWithInheritedAnnotation<String> {\n\n\t\t@Override\n\t\tpublic void handle() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleParameterized(String s) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleFromInterface() {\n\t\t}\n\t}\n\n\tpublic interface GenericParameter<T> {\n\n\t\tT getFor(Class<T> cls);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class StringGenericParameter implements GenericParameter<String> {\n\n\t\t@Order\n\t\t@Override\n\t\tpublic String getFor(Class<String> cls) {\n\t\t\treturn \"foo\";\n\t\t}\n\n\t\tpublic String getFor(Integer integer) {\n\t\t\treturn \"foo\";\n\t\t}\n\t}\n\n\t@Transactional\n\tpublic interface InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubInheritedAnnotationInterface extends InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubInheritedAnnotationInterface extends SubInheritedAnnotationInterface {\n\t}\n\n\t@Order\n\tpublic interface NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubNonInheritedAnnotationInterface extends NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubNonInheritedAnnotationInterface extends SubNonInheritedAnnotationInterface {\n\t}\n\n\t@ConventionBasedComposedContextConfig(locations = \"explicitDeclaration\")\n\tstatic class ConventionBasedComposedContextConfigClass {\n\t}\n\n\t@InvalidConventionBasedComposedContextConfig(locations = \"requiredLocationsDeclaration\")\n\tstatic class InvalidConventionBasedComposedContextConfigClass {\n\t}\n\n\t@HalfConventionBasedAndHalfAliasedComposedContextConfig(xmlConfigFiles = \"explicitDeclaration\")\n\tstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigClassV1 {\n\t}\n\n\t@HalfConventionBasedAndHalfAliasedComposedContextConfig(locations = \"explicitDeclaration\")\n\tstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigClassV2 {\n\t}\n\n\t@AliasedComposedContextConfig(xmlConfigFiles = \"test.xml\")\n\tstatic class AliasedComposedContextConfigClass {\n\t}\n\n\t@AliasedValueComposedContextConfig(locations = \"test.xml\")\n\tstatic class AliasedValueComposedContextConfigClass {\n\t}\n\n\t@ImplicitAliasesContextConfig(\"foo.xml\")\n\tstatic class ImplicitAliasesContextConfigClass1 {\n\t}\n\n\t@ImplicitAliasesContextConfig(locations = \"bar.xml\")\n\tstatic class ImplicitAliasesContextConfigClass2 {\n\t}\n\n\t@ImplicitAliasesContextConfig(xmlFiles = \"baz.xml\")\n\tstatic class ImplicitAliasesContextConfigClass3 {\n\t}\n\n\t@ImplicitAliasesWithDefaults\n\tstatic class ImplicitAliasesWithDefaultsClass {\n\t}\n\n\t@TransitiveImplicitAliasesContextConfig(groovy = \"test.groovy\")\n\tstatic class TransitiveImplicitAliasesContextConfigClass {\n\t}\n\n\t@SingleLocationTransitiveImplicitAliasesContextConfig(groovy = \"test.groovy\")\n\tstatic class SingleLocationTransitiveImplicitAliasesContextConfigClass {\n\t}\n\n\t@TransitiveImplicitAliasesWithSkippedLevelContextConfig(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesWithSkippedLevelContextConfigClass {\n\t}\n\n\t@SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfig(xml = \"test.xml\")\n\tstatic class SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigClass {\n\t}\n\n\t@ComposedImplicitAliasesContextConfig\n\tstatic class ComposedImplicitAliasesContextConfigClass {\n\t}\n\n\t@ShadowedAliasComposedContextConfig(xmlConfigFiles = \"test.xml\")\n\tstatic class ShadowedAliasComposedContextConfigClass {\n\t}\n\n\t@AliasedComposedContextConfigAndTestPropSource(xmlConfigFiles = \"test.xml\")\n\tstatic class AliasedComposedContextConfigAndTestPropSourceClass {\n\t}\n\n\t@ComponentScan(value = \"com.example.app.test\", basePackages = \"com.example.app.test\")\n\tstatic class ComponentScanWithBasePackagesAndValueAliasClass {\n\t}\n\n\t@TestComponentScan(packages = \"com.example.app.test\")\n\tstatic class TestComponentScanClass {\n\t}\n\n\t@ConventionBasedSinglePackageComponentScan(basePackages = \"com.example.app.test\")\n\tstatic class ConventionBasedSinglePackageComponentScanClass {\n\t}\n\n\t@AliasForBasedSinglePackageComponentScan(pkg = \"com.example.app.test\")\n\tstatic class AliasForBasedSinglePackageComponentScanClass {\n\t}\n\n\t@SpringAppConfig(Number.class)\n\tstatic class SpringAppConfigClass {\n\t}\n\n\t@Resource(name = \"x\")\n\t@ParametersAreNonnullByDefault\n\tstatic class ResourceHolder {\n\t}\n\n\tinterface TransactionalService {\n\n\t\t@Transactional\n\t\t@Nullable Object doIt();\n\t}\n\n\tclass TransactionalServiceImpl implements TransactionalService {\n\n\t\t@Override\n\t\tpublic @Nullable Object doIt() {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Deprecated\n\t@ComponentScan\n\tclass ForAnnotationsClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ValueAttribute {\n\n\t\tString[] value();\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueAttribute(\"FromValueAttributeMeta\")\n\t@interface ValueAttributeMeta {\n\n\t\t@AliasFor(\"alias\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] alias() default {};\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueAttributeMeta(\"FromValueAttributeMetaMeta\")\n\t@interface ValueAttributeMetaMeta {\n\t}\n\n\t@ValueAttributeMetaMeta\n\tstatic class ValueAttributeMetaMetaClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface StandardContainerWithMultipleAttributes {\n\n\t\tStandardRepeatableWithContainerWithMultipleAttributes[] value();\n\n\t\tString name() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(StandardContainerWithMultipleAttributes.class)\n\t@interface StandardRepeatableWithContainerWithMultipleAttributes {\n\n\t\tString value() default \"\";\n\t}\n\n\t@StandardRepeatableWithContainerWithMultipleAttributes(\"a\")\n\t@StandardRepeatableWithContainerWithMultipleAttributes(\"b\")\n\tstatic class StandardRepeatablesWithContainerWithMultipleAttributesTestCase {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation.SubSubClassWithInheritedComposedAnnotation",
    "headType": "class",
    "relation": "extend",
    "tail": "SubClassWithInheritedComposedAnnotation",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.MetaAndLocalTxConfigClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.MetaAndLocalTxConfigClass",
    "headType": "class",
    "relation": "use",
    "tail": "@MetaAndLocalTxConfig",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.MetaAndLocalTxConfigClass",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Set;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.ParametersAreNonnullByDefault;\nimport javax.annotation.meta.When;\n\nimport jakarta.annotation.Resource;\nimport org.jspecify.annotations.Nullable;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.AnnotationUtilsTests.ExtendsBaseClassWithGenericAnnotatedMethod;\nimport org.springframework.core.annotation.AnnotationUtilsTests.ImplementsInterfaceWithGenericAnnotatedMethod;\nimport org.springframework.core.annotation.AnnotationUtilsTests.WebController;\nimport org.springframework.core.annotation.AnnotationUtilsTests.WebMapping;\nimport org.springframework.core.testfixture.stereotype.Component;\nimport org.springframework.core.testfixture.stereotype.Indexed;\nimport org.springframework.util.MultiValueMap;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.Collectors.toSet;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.findAllMergedAnnotations;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.findMergedAnnotation;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getAllAnnotationAttributes;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getAllMergedAnnotations;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getMergedAnnotation;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getMergedAnnotationAttributes;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getMetaAnnotationTypes;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.hasAnnotation;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.hasMetaAnnotationTypes;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.isAnnotated;\nimport static org.springframework.core.annotation.AnnotationUtilsTests.asArray;\n\n/**\n * Tests for {@link AnnotatedElementUtils}.\n *\n * @author Sam Brannen\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 4.0.3\n * @see AnnotationUtilsTests\n * @see MultipleComposedAnnotationsOnSingleAnnotatedElementTests\n * @see ComposedRepeatableAnnotationsTests\n * @see NestedRepeatableAnnotationsTests\n */\nclass AnnotatedElementUtilsTests {\n\n\tprivate static final String TX_NAME = Transactional.class.getName();\n\n\n\t@Nested\n\tclass ConventionBasedAnnotationAttributeOverrideTests {\n\n\t\t@Test\n\t\tvoid getMergedAnnotationAttributesWithConventionBasedComposedAnnotation() {\n\t\t\tClass<?> element = ConventionBasedComposedContextConfigClass.class;\n\t\t\tString name = ContextConfig.class.getName();\n\t\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\n\t\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").containsExactly(\"explicitDeclaration\");\n\t\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").containsExactly(\"explicitDeclaration\");\n\n\t\t\t// Verify contracts between utility methods:\n\t\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t\t}\n\n\t\t/**\n\t\t * This test should never pass, simply because Spring does not support a hybrid\n\t\t * approach for annotation attribute overrides with transitive implicit aliases.\n\t\t * See SPR-13554 for details.\n\t\t * <p>Furthermore, if you choose to execute this test, it can fail for either\n\t\t * the first test class or the second one (with different exceptions), depending\n\t\t * on the order in which the JVM returns the attribute methods via reflection.\n\t\t */\n\t\t@Disabled(\"Permanently disabled but left in place for illustrative purposes\")\n\t\t@Test\n\t\tvoid getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation() {\n\t\t\tfor (Class<?> clazz : asList(HalfConventionBasedAndHalfAliasedComposedContextConfigClassV1.class,\n\t\t\t\t\tHalfConventionBasedAndHalfAliasedComposedContextConfigClassV2.class)) {\n\t\t\t\tgetMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation(clazz);\n\t\t\t}\n\t\t}\n\n\t\tprivate void getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation(Class<?> clazz) {\n\t\t\tString name = ContextConfig.class.getName();\n\t\t\tString simpleName = clazz.getSimpleName();\n\t\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(clazz, name);\n\n\t\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + simpleName).isNotNull();\n\t\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations for class [\" + simpleName + \"]\")\n\t\t\t\t.containsExactly(\"explicitDeclaration\");\n\t\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value for class [\" + simpleName + \"]\")\n\t\t\t\t.containsExactly(\"explicitDeclaration\");\n\n\t\t\t// Verify contracts between utility methods:\n\t\t\tassertThat(isAnnotated(clazz, name)).isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid getMergedAnnotationAttributesWithInvalidConventionBasedComposedAnnotation() {\n\t\t\tClass<?> element = InvalidConventionBasedComposedContextConfigClass.class;\n\t\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\t\tgetMergedAnnotationAttributes(element, ContextConfig.class))\n\t\t\t\t\t.withMessageContaining(\"Different @AliasFor mirror values for annotation\")\n\t\t\t\t\t.withMessageContaining(\"attribute 'locations' and its alias 'value'\")\n\t\t\t\t\t.withMessageContaining(\"values of [{requiredLocationsDeclaration}] and [{duplicateDeclaration}]\");\n\t\t}\n\n\t\t@Test\n\t\tvoid findMergedAnnotationAttributesWithSingleElementOverridingAnArrayViaConvention() {\n\t\t\tassertComponentScanAttributes(ConventionBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\n\t\t}\n\n\t\t@Test\n\t\tvoid findMergedAnnotationWithLocalAliasesThatConflictWithAttributesInMetaAnnotationByConvention() {\n\t\t\tClass<?> element = SpringAppConfigClass.class;\n\t\t\tContextConfig contextConfig = findMergedAnnotation(element, ContextConfig.class);\n\n\t\t\tassertThat(contextConfig).as(\"Should find @ContextConfig on \" + element).isNotNull();\n\t\t\tassertThat(contextConfig.locations()).as(\"locations for \" + element).isEmpty();\n\t\t\t// 'value' in @SpringAppConfig should not override 'value' in @ContextConfig\n\t\t\tassertThat(contextConfig.value()).as(\"value for \" + element).isEmpty();\n\t\t\tassertThat(contextConfig.classes()).as(\"classes for \" + element).containsExactly(Number.class);\n\t\t}\n\n\t\t@Test\n\t\tvoid findMergedAnnotationWithSingleElementOverridingAnArrayViaConvention() throws Exception {\n\t\t\tassertWebMapping(WebController.class.getMethod(\"postMappedWithPathAttribute\"));\n\t\t}\n\n\t}\n\n\n\t@Test\n\tvoid getMetaAnnotationTypesOnNonAnnotatedClass() {\n\t\tassertThat(getMetaAnnotationTypes(NonAnnotatedClass.class, TransactionalComponent.class)).isEmpty();\n\t\tassertThat(getMetaAnnotationTypes(NonAnnotatedClass.class, TransactionalComponent.class.getName())).isEmpty();\n\t}\n\n\t@Test\n\tvoid getMetaAnnotationTypesOnClassWithMetaDepth1() {\n\t\tSet<String> names = getMetaAnnotationTypes(TransactionalComponentClass.class, TransactionalComponent.class);\n\t\tassertThat(names).isEqualTo(names(Transactional.class, Component.class, Indexed.class));\n\n\t\tnames = getMetaAnnotationTypes(TransactionalComponentClass.class, TransactionalComponent.class.getName());\n\t\tassertThat(names).isEqualTo(names(Transactional.class, Component.class, Indexed.class));\n\t}\n\n\t@Test\n\tvoid getMetaAnnotationTypesOnClassWithMetaDepth2() {\n\t\tSet<String> names = getMetaAnnotationTypes(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class);\n\t\tassertThat(names).isEqualTo(names(TransactionalComponent.class, Transactional.class, Component.class, Indexed.class));\n\n\t\tnames = getMetaAnnotationTypes(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class.getName());\n\t\tassertThat(names).isEqualTo(names(TransactionalComponent.class, Transactional.class, Component.class, Indexed.class));\n\t}\n\n\tprivate Set<String> names(Class<?>... classes) {\n\t\treturn stream(classes).map(Class::getName).collect(toSet());\n\t}\n\n\t@Test\n\tvoid hasMetaAnnotationTypesOnNonAnnotatedClass() {\n\t\tassertThat(hasMetaAnnotationTypes(NonAnnotatedClass.class, TX_NAME)).isFalse();\n\t}\n\n\t@Test\n\tvoid hasMetaAnnotationTypesOnClassWithMetaDepth0() {\n\t\tassertThat(hasMetaAnnotationTypes(TransactionalComponentClass.class, TransactionalComponent.class.getName())).isFalse();\n\t}\n\n\t@Test\n\tvoid hasMetaAnnotationTypesOnClassWithMetaDepth1() {\n\t\tassertThat(hasMetaAnnotationTypes(TransactionalComponentClass.class, TX_NAME)).isTrue();\n\t\tassertThat(hasMetaAnnotationTypes(TransactionalComponentClass.class, Component.class.getName())).isTrue();\n\t}\n\n\t@Test\n\tvoid hasMetaAnnotationTypesOnClassWithMetaDepth2() {\n\t\tassertThat(hasMetaAnnotationTypes(ComposedTransactionalComponentClass.class, TX_NAME)).isTrue();\n\t\tassertThat(hasMetaAnnotationTypes(ComposedTransactionalComponentClass.class, Component.class.getName())).isTrue();\n\t\tassertThat(hasMetaAnnotationTypes(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class.getName())).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotatedOnNonAnnotatedClass() {\n\t\tassertThat(isAnnotated(NonAnnotatedClass.class, Transactional.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotatedOnClassWithMetaDepth() {\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, TransactionalComponent.class)).isTrue();\n\t\tassertThat(isAnnotated(SubTransactionalComponentClass.class, TransactionalComponent.class)).as(\"isAnnotated() does not search the class hierarchy.\").isFalse();\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, Transactional.class)).isTrue();\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, Component.class)).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, Transactional.class)).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, Component.class)).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class)).isTrue();\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid isAnnotatedForPlainTypes() {\n\t\tassertThat(isAnnotated(Order.class, Documented.class)).isTrue();\n\t\tassertThat(isAnnotated(org.springframework.lang.NonNullApi.class, Documented.class)).isTrue();\n\t\tassertThat(isAnnotated(org.springframework.lang.NonNullApi.class, Nonnull.class)).isTrue();\n\t\tassertThat(isAnnotated(ParametersAreNonnullByDefault.class, Nonnull.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isAnnotatedWithNameOnNonAnnotatedClass() {\n\t\tassertThat(isAnnotated(NonAnnotatedClass.class, TX_NAME)).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotatedWithNameOnClassWithMetaDepth() {\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, TransactionalComponent.class.getName())).isTrue();\n\t\tassertThat(isAnnotated(SubTransactionalComponentClass.class, TransactionalComponent.class.getName())).as(\"isAnnotated() does not search the class hierarchy.\").isFalse();\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, TX_NAME)).isTrue();\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, Component.class.getName())).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, TX_NAME)).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, Component.class.getName())).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class.getName())).isTrue();\n\t}\n\n\t@Test\n\tvoid hasAnnotationOnNonAnnotatedClass() {\n\t\tassertThat(hasAnnotation(NonAnnotatedClass.class, Transactional.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid hasAnnotationOnClassWithMetaDepth() {\n\t\tassertThat(hasAnnotation(TransactionalComponentClass.class, TransactionalComponent.class)).isTrue();\n\t\tassertThat(hasAnnotation(SubTransactionalComponentClass.class, TransactionalComponent.class)).isTrue();\n\t\tassertThat(hasAnnotation(TransactionalComponentClass.class, Transactional.class)).isTrue();\n\t\tassertThat(hasAnnotation(TransactionalComponentClass.class, Component.class)).isTrue();\n\t\tassertThat(hasAnnotation(ComposedTransactionalComponentClass.class, Transactional.class)).isTrue();\n\t\tassertThat(hasAnnotation(ComposedTransactionalComponentClass.class, Component.class)).isTrue();\n\t\tassertThat(hasAnnotation(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class)).isTrue();\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid hasAnnotationForPlainTypes() {\n\t\tassertThat(hasAnnotation(Order.class, Documented.class)).isTrue();\n\t\tassertThat(hasAnnotation(org.springframework.lang.NonNullApi.class, Documented.class)).isTrue();\n\t\tassertThat(hasAnnotation(org.springframework.lang.NonNullApi.class, Nonnull.class)).isTrue();\n\t\tassertThat(hasAnnotation(ParametersAreNonnullByDefault.class, Nonnull.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesOnNonAnnotatedClass() {\n\t\tassertThat(getAllAnnotationAttributes(NonAnnotatedClass.class, TX_NAME)).isNull();\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesOnClassWithLocalAnnotation() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxConfig.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on TxConfig\").isNotNull();\n\t\tassertThat(attributes.get(\"value\")).as(\"value for TxConfig\").isEqualTo(List.of(\"TxConfig\"));\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesOnClassWithLocalComposedAnnotationAndInheritedAnnotation() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(SubClassWithInheritedAnnotation.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on SubClassWithInheritedAnnotation\").isNotNull();\n\t\tassertThat(attributes.get(\"qualifier\")).isEqualTo(asList(\"composed2\", \"transactionManager\"));\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(SubSubClassWithInheritedAnnotation.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on SubSubClassWithInheritedAnnotation\").isNotNull();\n\t\tassertThat(attributes.get(\"qualifier\")).isEqualTo(List.of(\"transactionManager\"));\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes( SubSubClassWithInheritedComposedAnnotation.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on SubSubClassWithInheritedComposedAnnotation\").isNotNull();\n\t\tassertThat(attributes.get(\"qualifier\")).isEqualTo(List.of(\"composed1\"));\n\t}\n\n\t/**\n\t * If the \"value\" entry contains both \"DerivedTxConfig\" AND \"TxConfig\", then\n\t * the algorithm is accidentally picking up shadowed annotations of the same\n\t * type within the class hierarchy. Such undesirable behavior would cause the\n\t * logic in {@code org.springframework.context.annotation.ProfileCondition}\n\t * to fail.\n\t */\n\t@Test\n\tvoid getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\n\t\t// See org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on DerivedTxConfig\").isNotNull();\n\t\tassertThat(attributes.get(\"value\")).as(\"value for DerivedTxConfig\").isEqualTo(List.of(\"DerivedTxConfig\"));\n\t}\n\n\t/**\n\t * Note: this functionality is required by {@code org.springframework.context.annotation.ProfileCondition}.\n\t */\n\t@Test\n\tvoid getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {\n\t\t// See org.springframework.core.env.EnvironmentSystemIntegrationTests\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations\").isNotNull();\n\t\tassertThat(attributes.get(\"value\")).as(\"value for TxFromMultipleComposedAnnotations.\").isEqualTo(asList(\"TxInheritedComposed\", \"TxComposed\"));\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid getAllAnnotationAttributesOnLangType() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(\n\t\t\t\torg.springframework.lang.NonNullApi.class, Nonnull.class.getName());\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Nonnull on NonNullApi\").isNotNull();\n\t\tassertThat(attributes.get(\"when\")).as(\"value for NonNullApi\").isEqualTo(List.of(When.ALWAYS));\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesOnJavaxType() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(\n\t\t\t\tParametersAreNonnullByDefault.class, Nonnull.class.getName());\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Nonnull on NonNullApi\").isNotNull();\n\t\tassertThat(attributes.get(\"when\")).as(\"value for NonNullApi\").isEqualTo(List.of(When.ALWAYS));\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnClassWithLocalAnnotation() {\n\t\tClass<?> element = TxConfig.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Annotation attributes for @Transactional on TxConfig\").isNotNull();\n\t\tassertThat(attributes.getString(\"value\")).as(\"value for TxConfig\").isEqualTo(\"TxConfig\");\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\n\t\tClass<?> element = DerivedTxConfig.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Annotation attributes for @Transactional on DerivedTxConfig\").isNotNull();\n\t\tassertThat(attributes.getString(\"value\")).as(\"value for DerivedTxConfig\").isEqualTo(\"DerivedTxConfig\");\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(MetaCycleAnnotatedClass.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Should not find annotation attributes for @Transactional on MetaCycleAnnotatedClass\").isNull();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesFavorsLocalComposedAnnotationOverInheritedAnnotation() {\n\t\tClass<?> element = SubClassWithInheritedAnnotation.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"AnnotationAttributes for @Transactional on SubClassWithInheritedAnnotation\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t\tassertThat(attributes.getBoolean(\"readOnly\")).as(\"readOnly flag for SubClassWithInheritedAnnotation.\").isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tClass<?> element = SubSubClassWithInheritedAnnotation.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"AnnotationAttributes for @Transactional on SubSubClassWithInheritedAnnotation\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t\tassertThat(attributes.getBoolean(\"readOnly\")).as(\"readOnly flag for SubSubClassWithInheritedAnnotation.\").isFalse();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tClass<?> element = SubSubClassWithInheritedComposedAnnotation.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"AnnotationAttributes for @Transactional on SubSubClassWithInheritedComposedAnnotation.\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t\tassertThat(attributes.getBoolean(\"readOnly\")).as(\"readOnly flag for SubSubClassWithInheritedComposedAnnotation.\").isFalse();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesFromInterfaceImplementedBySuperclass() {\n\t\tClass<?> element = ConcreteClassWithInheritedAnnotation.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Should not find @Transactional on ConcreteClassWithInheritedAnnotation\").isNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isFalse();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnInheritedAnnotationInterface() {\n\t\tClass<?> element = InheritedAnnotationInterface.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Should find @Transactional on InheritedAnnotationInterface\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnNonInheritedAnnotationInterface() {\n\t\tClass<?> element = NonInheritedAnnotationInterface.class;\n\t\tString name = Order.class.getName();\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Should find @Order on NonInheritedAnnotationInterface\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesWithAliasedComposedAnnotation() {\n\t\tClass<?> element = AliasedComposedContextConfigClass.class;\n\t\tString name = ContextConfig.class.getName();\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\n\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(asArray(\"test.xml\"));\n\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(asArray(\"test.xml\"));\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesWithAliasedValueComposedAnnotation() {\n\t\tClass<?> element = AliasedValueComposedContextConfigClass.class;\n\t\tString name = ContextConfig.class.getName();\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\n\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(asArray(\"test.xml\"));\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(asArray(\"test.xml\"));\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesWithImplicitAliasesInMetaAnnotationOnComposedAnnotation() {\n\t\tClass<?> element = ComposedImplicitAliasesContextConfigClass.class;\n\t\tString name = ImplicitAliasesContextConfig.class.getName();\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tString[] expected = asArray(\"A.xml\", \"B.xml\");\n\n\t\tassertThat(attributes).as(\"Should find @ImplicitAliasesContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"groovyScripts\")).as(\"groovyScripts\").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"xmlFiles\")).as(\"xmlFiles\").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(expected);\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithAliasedValueComposedAnnotation() {\n\t\tassertGetMergedAnnotation(AliasedValueComposedContextConfigClass.class, \"test.xml\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithImplicitAliasesForSameAttributeInComposedAnnotation() {\n\t\tassertGetMergedAnnotation(ImplicitAliasesContextConfigClass1.class, \"foo.xml\");\n\t\tassertGetMergedAnnotation(ImplicitAliasesContextConfigClass2.class, \"bar.xml\");\n\t\tassertGetMergedAnnotation(ImplicitAliasesContextConfigClass3.class, \"baz.xml\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithTransitiveImplicitAliases() {\n\t\tassertGetMergedAnnotation(TransitiveImplicitAliasesContextConfigClass.class, \"test.groovy\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithTransitiveImplicitAliasesWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\tassertGetMergedAnnotation(SingleLocationTransitiveImplicitAliasesContextConfigClass.class, \"test.groovy\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithTransitiveImplicitAliasesWithSkippedLevel() {\n\t\tassertGetMergedAnnotation(TransitiveImplicitAliasesWithSkippedLevelContextConfigClass.class, \"test.xml\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithTransitiveImplicitAliasesWithSkippedLevelWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\tassertGetMergedAnnotation(SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigClass.class, \"test.xml\");\n\t}\n\n\tprivate void assertGetMergedAnnotation(Class<?> element, String... expected) {\n\t\tString name = ContextConfig.class.getName();\n\t\tContextConfig contextConfig = getMergedAnnotation(element, ContextConfig.class);\n\n\t\tassertThat(contextConfig).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(contextConfig.locations()).as(\"locations\").isEqualTo(expected);\n\t\tassertThat(contextConfig.value()).as(\"value\").isEqualTo(expected);\n\t\tObject[] expecteds = new Class<?>[0];\n\t\tassertThat(contextConfig.classes()).as(\"classes\").isEqualTo(expecteds);\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithImplicitAliasesInMetaAnnotationOnComposedAnnotation() {\n\t\tClass<?> element = ComposedImplicitAliasesContextConfigClass.class;\n\t\tString name = ImplicitAliasesContextConfig.class.getName();\n\t\tImplicitAliasesContextConfig config = getMergedAnnotation(element, ImplicitAliasesContextConfig.class);\n\t\tString[] expected = asArray(\"A.xml\", \"B.xml\");\n\n\t\tassertThat(config).as(\"Should find @ImplicitAliasesContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(config.groovyScripts()).as(\"groovyScripts\").isEqualTo(expected);\n\t\tassertThat(config.xmlFiles()).as(\"xmlFiles\").isEqualTo(expected);\n\t\tassertThat(config.locations()).as(\"locations\").isEqualTo(expected);\n\t\tassertThat(config.value()).as(\"value\").isEqualTo(expected);\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithImplicitAliasesWithDefaultsInMetaAnnotationOnComposedAnnotation() {\n\t\tClass<?> element = ImplicitAliasesWithDefaultsClass.class;\n\t\tString name = AliasesWithDefaults.class.getName();\n\t\tAliasesWithDefaults annotation = getMergedAnnotation(element, AliasesWithDefaults.class);\n\n\t\tassertThat(annotation).as(\"Should find @AliasesWithDefaults on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(annotation.a1()).as(\"a1\").isEqualTo(\"ImplicitAliasesWithDefaults\");\n\t\tassertThat(annotation.a2()).as(\"a2\").isEqualTo(\"ImplicitAliasesWithDefaults\");\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesWithShadowedAliasComposedAnnotation() {\n\t\tClass<?> element = ShadowedAliasComposedContextConfigClass.class;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, ContextConfig.class);\n\n\t\tString[] expected = asArray(\"test.xml\");\n\n\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(expected);\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(InheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on InheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnSubInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(SubInheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on SubInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnSubSubInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(SubSubInheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on SubSubInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnNonInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(NonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on NonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnSubNonInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(SubNonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on SubNonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnSubSubNonInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(SubSubNonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on SubSubNonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesInheritedFromInterfaceMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleFromInterface\");\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(method, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on ConcreteClassWithInheritedAnnotation.handleFromInterface() method\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesInheritedFromAbstractMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handle\");\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on ConcreteClassWithInheritedAnnotation.handle() method\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleParameterized\", String.class);\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()\").isNotNull();\n\t}\n\n\t/**\n\t * Bridge/bridged method setup code copied from\n\t * {@link org.springframework.core.BridgeMethodResolverTests#withGenericParameter()}.\n\t * @since 4.2\n\t */\n\t@Test\n\tvoid findMergedAnnotationAttributesFromBridgeMethod() {\n\t\tMethod[] methods = StringGenericParameter.class.getMethods();\n\t\tMethod bridgeMethod = null;\n\t\tMethod bridgedMethod = null;\n\n\t\tfor (Method method : methods) {\n\t\t\tif (\"getFor\".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {\n\t\t\t\tif (method.getReturnType().equals(Object.class)) {\n\t\t\t\t\tbridgeMethod = method;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbridgedMethod = method;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\n\t\tboolean condition = bridgedMethod != null && !bridgedMethod.isBridge();\n\t\tassertThat(condition).isTrue();\n\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on StringGenericParameter.getFor() bridge method\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnClassWithMetaAndLocalTxConfig() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(MetaAndLocalTxConfigClass.class, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on MetaAndLocalTxConfigClass\").isNotNull();\n\t\tassertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier for MetaAndLocalTxConfigClass.\").isEqualTo(\"localTxMgr\");\n\t}\n\n\t@Test\n\tvoid findAndSynthesizeAnnotationAttributesOnClassWithAttributeAliasesInTargetAnnotation() {\n\t\tString qualifier = \"aliasForQualifier\";\n\n\t\t// 1) Find and merge AnnotationAttributes from the annotation hierarchy\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(\n\t\t\t\tAliasedTransactionalComponentClass.class, AliasedTransactional.class);\n\t\tassertThat(attributes).as(\"@AliasedTransactional on AliasedTransactionalComponentClass.\").isNotNull();\n\n\t\t// 2) Synthesize the AnnotationAttributes back into the target annotation\n\t\tAliasedTransactional annotation = AnnotationUtils.synthesizeAnnotation(attributes,\n\t\t\t\tAliasedTransactional.class, AliasedTransactionalComponentClass.class);\n\t\tassertThat(annotation).isNotNull();\n\n\t\t// 3) Verify that the AnnotationAttributes and synthesized annotation are equivalent\n\t\tassertThat(attributes.getString(\"value\")).as(\"TX value via attributes.\").isEqualTo(qualifier);\n\t\tassertThat(annotation.value()).as(\"TX value via synthesized annotation.\").isEqualTo(qualifier);\n\t\tassertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier via attributes.\").isEqualTo(qualifier);\n\t\tassertThat(annotation.qualifier()).as(\"TX qualifier via synthesized annotation.\").isEqualTo(qualifier);\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnClassWithAttributeAliasInComposedAnnotationAndNestedAnnotationsInTargetAnnotation() {\n\t\tAnnotationAttributes attributes = assertComponentScanAttributes(TestComponentScanClass.class, \"com.example.app.test\");\n\n\t\tFilter[] excludeFilters = attributes.getAnnotationArray(\"excludeFilters\", Filter.class);\n\t\tassertThat(excludeFilters).isNotNull();\n\n\t\tList<String> patterns = stream(excludeFilters).map(Filter::pattern).collect(toList());\n\t\tassertThat(patterns).isEqualTo(asList(\"*Test\", \"*Tests\"));\n\t}\n\n\t/**\n\t * This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}\n\t * uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation\n\t * attributes since attributes may be arrays.\n\t */\n\t@Test\n\tvoid findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {\n\t\tassertComponentScanAttributes(ComponentScanWithBasePackagesAndValueAliasClass.class, \"com.example.app.test\");\n\t}\n\n\t/**\n\t * @since 5.2.1\n\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\n\t */\n\t@Test\n\tvoid findMergedAnnotationAttributesOnMethodWithComposedMetaTransactionalAnnotation() throws Exception {\n\t\tMethod method = getClass().getDeclaredMethod(\"composedTransactionalMethod\");\n\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(method, AliasedTransactional.class);\n\t\tassertThat(attributes).as(\"Should find @AliasedTransactional on \" + method).isNotNull();\n\t\tassertThat(attributes.getString(\"value\")).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t/**\n\t * @since 5.2.1\n\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\n\t */\n\t@Test\n\tvoid findMergedAnnotationOnMethodWithComposedMetaTransactionalAnnotation() throws Exception {\n\t\tMethod method = getClass().getDeclaredMethod(\"composedTransactionalMethod\");\n\n\t\tAliasedTransactional annotation = findMergedAnnotation(method, AliasedTransactional.class);\n\t\tassertThat(annotation).as(\"Should find @AliasedTransactional on \" + method).isNotNull();\n\t\tassertThat(annotation.value()).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(annotation.qualifier()).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t/**\n\t * @since 5.2.1\n\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\n\t */\n\t@Test\n\tvoid findMergedAnnotationAttributesOnClassWithComposedMetaTransactionalAnnotation() {\n\t\tClass<?> clazz = ComposedTransactionalClass.class;\n\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(clazz, AliasedTransactional.class);\n\t\tassertThat(attributes).as(\"Should find @AliasedTransactional on \" + clazz).isNotNull();\n\t\tassertThat(attributes.getString(\"value\")).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t/**\n\t * @since 5.2.1\n\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\n\t */\n\t@Test\n\tvoid findMergedAnnotationOnClassWithComposedMetaTransactionalAnnotation() {\n\t\tClass<?> clazz = ComposedTransactionalClass.class;\n\n\t\tAliasedTransactional annotation = findMergedAnnotation(clazz, AliasedTransactional.class);\n\t\tassertThat(annotation).as(\"Should find @AliasedTransactional on \" + clazz).isNotNull();\n\t\tassertThat(annotation.value()).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(annotation.qualifier()).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\tassertComponentScanAttributes(AliasForBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\n\t}\n\n\tprivate AnnotationAttributes assertComponentScanAttributes(Class<?> element, String... expected) {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(element, ComponentScan.class);\n\n\t\tassertThat(attributes).as(\"Should find @ComponentScan on \" + element).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value: \").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"basePackages\")).as(\"basePackages: \").isEqualTo(expected);\n\n\t\treturn attributes;\n\t}\n\n\tprivate AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element, Class<? extends Annotation> annotationType) {\n\t\treturn AnnotatedElementUtils.findMergedAnnotationAttributes(element, annotationType.getName(), false, false);\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationWithAttributeAliasesInTargetAnnotation() {\n\t\tClass<?> element = AliasedTransactionalComponentClass.class;\n\t\tAliasedTransactional annotation = findMergedAnnotation(element, AliasedTransactional.class);\n\t\tassertThat(annotation).as(\"@AliasedTransactional on \" + element).isNotNull();\n\t\tassertThat(annotation.value()).as(\"TX value via synthesized annotation.\").isEqualTo(\"aliasForQualifier\");\n\t\tassertThat(annotation.qualifier()).as(\"TX qualifier via synthesized annotation.\").isEqualTo(\"aliasForQualifier\");\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationForMultipleMetaAnnotationsWithClashingAttributeNames() {\n\t\tString[] xmlLocations = asArray(\"test.xml\");\n\t\tString[] propFiles = asArray(\"test.properties\");\n\n\t\tClass<?> element = AliasedComposedContextConfigAndTestPropSourceClass.class;\n\n\t\tContextConfig contextConfig = findMergedAnnotation(element, ContextConfig.class);\n\t\tassertThat(contextConfig).as(\"@ContextConfig on \" + element).isNotNull();\n\t\tassertThat(contextConfig.locations()).as(\"locations\").isEqualTo(xmlLocations);\n\t\tassertThat(contextConfig.value()).as(\"value\").isEqualTo(xmlLocations);\n\n\t\t// Synthesized annotation\n\t\tTestPropSource testPropSource = AnnotationUtils.findAnnotation(element, TestPropSource.class);\n\t\tassertThat(testPropSource.locations()).as(\"locations\").isEqualTo(propFiles);\n\t\tassertThat(testPropSource.value()).as(\"value\").isEqualTo(propFiles);\n\n\t\t// Merged annotation\n\t\ttestPropSource = findMergedAnnotation(element, TestPropSource.class);\n\t\tassertThat(testPropSource).as(\"@TestPropSource on \" + element).isNotNull();\n\t\tassertThat(testPropSource.locations()).as(\"locations\").isEqualTo(propFiles);\n\t\tassertThat(testPropSource.value()).as(\"value\").isEqualTo(propFiles);\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationWithSingleElementOverridingAnArrayViaAliasFor() throws Exception {\n\t\tassertWebMapping(WebController.class.getMethod(\"getMappedWithValueAttribute\"));\n\t\tassertWebMapping(WebController.class.getMethod(\"getMappedWithPathAttribute\"));\n\t}\n\n\tprivate void assertWebMapping(AnnotatedElement element) {\n\t\tWebMapping webMapping = findMergedAnnotation(element, WebMapping.class);\n\t\tassertThat(webMapping).isNotNull();\n\t\tassertThat(webMapping.value()).as(\"value attribute: \").isEqualTo(asArray(\"/test\"));\n\t\tassertThat(webMapping.path()).as(\"path attribute: \").isEqualTo(asArray(\"/test\"));\n\t}\n\n\t@Test\n\tvoid javaLangAnnotationTypeViaFindMergedAnnotation() throws Exception {\n\t\tConstructor<?> deprecatedCtor = Date.class.getConstructor(String.class);\n\t\tassertThat(findMergedAnnotation(deprecatedCtor, Deprecated.class)).isEqualTo(deprecatedCtor.getAnnotation(Deprecated.class));\n\t\tassertThat(findMergedAnnotation(Date.class, Deprecated.class)).isEqualTo(Date.class.getAnnotation(Deprecated.class));\n\t}\n\n\t@Test\n\tvoid javaxAnnotationTypeViaFindMergedAnnotation() {\n\t\tassertThat(findMergedAnnotation(ResourceHolder.class, Resource.class)).isEqualTo(ResourceHolder.class.getAnnotation(Resource.class));\n\t\tassertThat(findMergedAnnotation(SpringAppConfigClass.class, Resource.class)).isEqualTo(SpringAppConfigClass.class.getAnnotation(Resource.class));\n\t}\n\n\t@Test\n\tvoid javaxMetaAnnotationTypeViaFindMergedAnnotation() {\n\t\tassertThat(findMergedAnnotation(ParametersAreNonnullByDefault.class, Nonnull.class)).isEqualTo(ParametersAreNonnullByDefault.class.getAnnotation(Nonnull.class));\n\t\tassertThat(findMergedAnnotation(ResourceHolder.class, Nonnull.class)).isEqualTo(ParametersAreNonnullByDefault.class.getAnnotation(Nonnull.class));\n\t}\n\n\t@Test\n\tvoid nullableAnnotationTypeViaFindMergedAnnotation() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tassertThat(findMergedAnnotation(method, Resource.class)).isEqualTo(method.getAnnotation(Resource.class));\n\t}\n\n\t@Test\n\tvoid getAllMergedAnnotationsOnClassWithInterface() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tSet<Transactional> allMergedAnnotations = getAllMergedAnnotations(method, Transactional.class);\n\t\tassertThat(allMergedAnnotations).isEmpty();\n\t}\n\n\t@Test\n\tvoid findAllMergedAnnotationsOnClassWithInterface() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tSet<Transactional> allMergedAnnotations = findAllMergedAnnotations(method, Transactional.class);\n\t\tassertThat(allMergedAnnotations).hasSize(1);\n\t}\n\n\t@Test  // SPR-16060\n\tvoid findMethodAnnotationFromGenericInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tOrder order = findMergedAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test  // SPR-17146\n\tvoid findMethodAnnotationFromGenericSuperclass() throws Exception {\n\t\tMethod method = ExtendsBaseClassWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tOrder order = findMergedAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test // gh-22655\n\tvoid forAnnotationsCreatesCopyOfArrayOnEachCall() {\n\t\tAnnotatedElement element = AnnotatedElementUtils.forAnnotations(ForAnnotationsClass.class.getDeclaredAnnotations());\n\t\t// Trigger the NPE as originally reported in the bug\n\t\tAnnotationsScanner.getDeclaredAnnotations(element, false);\n\t\tAnnotationsScanner.getDeclaredAnnotations(element, false);\n\t\t// Also specifically test we get different instances\n\t\tassertThat(element.getDeclaredAnnotations()).isNotSameAs(element.getDeclaredAnnotations());\n\t}\n\n\t@Test // gh-22703\n\tvoid getMergedAnnotationOnThreeDeepMetaWithValue() {\n\t\tValueAttribute annotation = AnnotatedElementUtils.getMergedAnnotation(\n\t\t\t\tValueAttributeMetaMetaClass.class, ValueAttribute.class);\n\t\tassertThat(annotation.value()).containsExactly(\"FromValueAttributeMeta\");\n\t}\n\n\t/**\n\t * @since 5.3.25\n\t */\n\t@Test // gh-29685\n\tvoid getMergedRepeatableAnnotationsWithContainerWithMultipleAttributes() {\n\t\tSet<StandardRepeatableWithContainerWithMultipleAttributes> repeatableAnnotations =\n\t\t\t\tAnnotatedElementUtils.getMergedRepeatableAnnotations(\n\t\t\t\t\t\tStandardRepeatablesWithContainerWithMultipleAttributesTestCase.class,\n\t\t\t\t\t\tStandardRepeatableWithContainerWithMultipleAttributes.class);\n\t\tassertThat(repeatableAnnotations).map(StandardRepeatableWithContainerWithMultipleAttributes::value)\n\t\t\t\t.containsExactly(\"a\", \"b\");\n\t}\n\n\t/**\n\t * @since 5.3.25\n\t */\n\t@Test // gh-29685\n\tvoid findMergedRepeatableAnnotationsWithContainerWithMultipleAttributes() {\n\t\tSet<StandardRepeatableWithContainerWithMultipleAttributes> repeatableAnnotations =\n\t\t\t\tAnnotatedElementUtils.findMergedRepeatableAnnotations(\n\t\t\t\t\t\tStandardRepeatablesWithContainerWithMultipleAttributesTestCase.class,\n\t\t\t\t\t\tStandardRepeatableWithContainerWithMultipleAttributes.class);\n\t\tassertThat(repeatableAnnotations).map(StandardRepeatableWithContainerWithMultipleAttributes::value)\n\t\t\t\t.containsExactly(\"a\", \"b\");\n\t}\n\n\t// -------------------------------------------------------------------------\n\n\t@MetaCycle3\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.ANNOTATION_TYPE)\n\t@interface MetaCycle1 {\n\t}\n\n\t@MetaCycle1\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.ANNOTATION_TYPE)\n\t@interface MetaCycle2 {\n\t}\n\n\t@MetaCycle2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface MetaCycle3 {\n\t}\n\n\t@MetaCycle3\n\tstatic class MetaCycleAnnotatedClass {\n\t}\n\n\t// -------------------------------------------------------------------------\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Inherited\n\t@interface Transactional {\n\n\t\tString value() default \"\";\n\n\t\tString qualifier() default \"transactionManager\";\n\n\t\tboolean readOnly() default false;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Inherited\n\t@interface AliasedTransactional {\n\n\t\t@AliasFor(\"qualifier\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString qualifier() default \"\";\n\t}\n\n\t@AliasedTransactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@interface MyAliasedTransactional {\n\n\t\t@AliasFor(annotation = AliasedTransactional.class, attribute = \"value\")\n\t\tString value() default \"defaultTransactionManager\";\n\t}\n\n\t@MyAliasedTransactional(\"anotherTransactionManager\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@interface ComposedMyAliasedTransactional {\n\t}\n\n\t@Transactional(qualifier = \"composed1\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@Inherited\n\t@interface InheritedComposed {\n\t}\n\n\t@Transactional(qualifier = \"composed2\", readOnly = true)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface Composed {\n\t}\n\n\t@Transactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxComposedWithOverride {\n\n\t\tString qualifier() default \"txMgr\";\n\t}\n\n\t@Transactional(\"TxInheritedComposed\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxInheritedComposed {\n\t}\n\n\t@Transactional(\"TxComposed\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxComposed {\n\t}\n\n\t@Transactional\n\t@Component\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransactionalComponent {\n\t}\n\n\t@TransactionalComponent\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedTransactionalComponent {\n\t}\n\n\t@AliasedTransactional(value = \"aliasForQualifier\")\n\t@Component\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedTransactionalComponent {\n\t}\n\n\t@TxComposedWithOverride\n\t// Override default \"txMgr\" from @TxComposedWithOverride with \"localTxMgr\"\n\t@Transactional(qualifier = \"localTxMgr\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface MetaAndLocalTxConfig {\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.test.context.TestPropertySource}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestPropSource {\n\n\t\t@AliasFor(\"locations\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] locations() default {};\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.test.context.ContextConfiguration}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContextConfig {\n\n\t\t@AliasFor(\"locations\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] locations() default {};\n\n\t\tClass<?>[] classes() default {};\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionBasedComposedContextConfig {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfig.class)\n\t\tString[] locations() default {};\n\t}\n\n\t@ContextConfig(value = \"duplicateDeclaration\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface InvalidConventionBasedComposedContextConfig {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfig.class)\n\t\tString[] locations();\n\t}\n\n\t/**\n\t * This hybrid approach for annotation attribute overrides with transitive implicit\n\t * aliases is unsupported. See SPR-13554 for details.\n\t */\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface HalfConventionBasedAndHalfAliasedComposedContextConfig {\n\n\t\tString[] locations() default {};\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles() default {};\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles();\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedValueComposedContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"value\")\n\t\tString[] locations();\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] groovyScripts() default {};\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlFiles() default {};\n\n\t\t// intentionally omitted: attribute = \"locations\"\n\t\t@AliasFor(annotation = ContextConfig.class)\n\t\tString[] locations() default {};\n\n\t\t// intentionally omitted: attribute = \"locations\" (SPR-14069)\n\t\t@AliasFor(annotation = ContextConfig.class)\n\t\tString[] value() default {};\n\t}\n\n\t@ImplicitAliasesContextConfig(xmlFiles = {\"A.xml\", \"B.xml\"})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedImplicitAliasesContextConfig {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasesWithDefaults {\n\n\t\t@AliasFor(\"a2\")\n\t\tString a1() default \"AliasesWithDefaults\";\n\n\t\t@AliasFor(\"a1\")\n\t\tString a2() default \"AliasesWithDefaults\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasesWithDefaults\n\t@interface ImplicitAliasesWithDefaults {\n\n\t\t@AliasFor(annotation = AliasesWithDefaults.class, attribute = \"a1\")\n\t\tString b1() default \"ImplicitAliasesWithDefaults\";\n\n\t\t@AliasFor(annotation = AliasesWithDefaults.class, attribute = \"a2\")\n\t\tString b2() default \"ImplicitAliasesWithDefaults\";\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"xmlFiles\")\n\t\tString[] xml() default {};\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScripts\")\n\t\tString[] groovy() default {};\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SingleLocationTransitiveImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"xmlFiles\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScripts\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesWithSkippedLevelContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xml() default {};\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScripts\")\n\t\tString[] groovy() default {};\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScripts\")\n\t\tString groovy() default \"\";\n\t}\n\n\t/**\n\t * Although the configuration declares an explicit value for 'value' and\n\t * requires a value for the aliased 'locations', this does not result in\n\t * an error since 'locations' effectively <em>shadows</em> the 'value'\n\t * attribute (which cannot be set via the composed annotation anyway).\n\t *\n\t * If 'value' were not shadowed, such a declaration would not make sense.\n\t */\n\t@ContextConfig(value = \"duplicateDeclaration\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ShadowedAliasComposedContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles();\n\t}\n\n\t@ContextConfig(locations = \"shadowed.xml\")\n\t@TestPropSource(locations = \"test.properties\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfigAndTestPropSource {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles() default \"default.xml\";\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.boot.test.SpringApplicationConfiguration}.\n\t */\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SpringAppConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] locations() default {};\n\n\t\t// Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfig.class, attribute = \"classes\")\n\t\t@AliasFor(\"value\")\n\t\tClass<?>[] classes() default {};\n\n\t\t// Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfig.class, attribute = \"classes\")\n\t\t@AliasFor(\"classes\")\n\t\tClass<?>[] value() default {};\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.context.annotation.ComponentScan}\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScan {\n\n\t\t@AliasFor(\"basePackages\")\n\t\tString[] value() default {};\n\n\t\t// Intentionally no alias declaration for \"value\"\n\t\tString[] basePackages() default {};\n\n\t\tFilter[] excludeFilters() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({})\n\t@interface Filter {\n\n\t\tString pattern();\n\t}\n\n\t@ComponentScan(excludeFilters = {@Filter(pattern = \"*Test\"), @Filter(pattern = \"*Tests\")})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestComponentScan {\n\n\t\t@AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\n\t\tString[] packages();\n\t}\n\n\t@ComponentScan\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionBasedSinglePackageComponentScan {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ComponentScan.class)\n\t\tString basePackages();\n\t}\n\n\t@ComponentScan\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForBasedSinglePackageComponentScan {\n\n\t\t@AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\n\t\tString pkg();\n\t}\n\n\t// -------------------------------------------------------------------------\n\n\tstatic class NonAnnotatedClass {\n\t}\n\n\t@TransactionalComponent\n\tstatic class TransactionalComponentClass {\n\t}\n\n\tstatic class SubTransactionalComponentClass extends TransactionalComponentClass {\n\t}\n\n\t@ComposedTransactionalComponent\n\tstatic class ComposedTransactionalComponentClass {\n\t}\n\n\t@AliasedTransactionalComponent\n\tstatic class AliasedTransactionalComponentClass {\n\t}\n\n\t@ComposedMyAliasedTransactional\n\tvoid composedTransactionalMethod() {\n\t}\n\n\t@ComposedMyAliasedTransactional\n\tstatic class ComposedTransactionalClass {\n\t}\n\n\t@Transactional\n\tstatic class ClassWithInheritedAnnotation {\n\t}\n\n\t@Composed\n\tstatic class SubClassWithInheritedAnnotation extends ClassWithInheritedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedAnnotation extends SubClassWithInheritedAnnotation {\n\t}\n\n\t@InheritedComposed\n\tstatic class ClassWithInheritedComposedAnnotation {\n\t}\n\n\t@Composed\n\tstatic class SubClassWithInheritedComposedAnnotation extends ClassWithInheritedComposedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedComposedAnnotation extends SubClassWithInheritedComposedAnnotation {\n\t}\n\n\t@MetaAndLocalTxConfig\n\tstatic class MetaAndLocalTxConfigClass {\n\t}\n\n\t@Transactional(\"TxConfig\")\n\tstatic class TxConfig {\n\t}\n\n\t@Transactional(\"DerivedTxConfig\")\n\tstatic class DerivedTxConfig extends TxConfig {\n\t}\n\n\t@TxInheritedComposed\n\t@TxComposed\n\tstatic class TxFromMultipleComposedAnnotations {\n\t}\n\n\t@Transactional\n\tinterface InterfaceWithInheritedAnnotation {\n\n\t\t@Order\n\t\tvoid handleFromInterface();\n\t}\n\n\tabstract static class AbstractClassWithInheritedAnnotation<T> implements InterfaceWithInheritedAnnotation {\n\n\t\t@Transactional\n\t\tpublic abstract void handle();\n\n\t\t@Transactional\n\t\tpublic void handleParameterized(T t) {\n\t\t}\n\t}\n\n\tstatic class ConcreteClassWithInheritedAnnotation extends AbstractClassWithInheritedAnnotation<String> {\n\n\t\t@Override\n\t\tpublic void handle() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleParameterized(String s) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleFromInterface() {\n\t\t}\n\t}\n\n\tpublic interface GenericParameter<T> {\n\n\t\tT getFor(Class<T> cls);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class StringGenericParameter implements GenericParameter<String> {\n\n\t\t@Order\n\t\t@Override\n\t\tpublic String getFor(Class<String> cls) {\n\t\t\treturn \"foo\";\n\t\t}\n\n\t\tpublic String getFor(Integer integer) {\n\t\t\treturn \"foo\";\n\t\t}\n\t}\n\n\t@Transactional\n\tpublic interface InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubInheritedAnnotationInterface extends InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubInheritedAnnotationInterface extends SubInheritedAnnotationInterface {\n\t}\n\n\t@Order\n\tpublic interface NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubNonInheritedAnnotationInterface extends NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubNonInheritedAnnotationInterface extends SubNonInheritedAnnotationInterface {\n\t}\n\n\t@ConventionBasedComposedContextConfig(locations = \"explicitDeclaration\")\n\tstatic class ConventionBasedComposedContextConfigClass {\n\t}\n\n\t@InvalidConventionBasedComposedContextConfig(locations = \"requiredLocationsDeclaration\")\n\tstatic class InvalidConventionBasedComposedContextConfigClass {\n\t}\n\n\t@HalfConventionBasedAndHalfAliasedComposedContextConfig(xmlConfigFiles = \"explicitDeclaration\")\n\tstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigClassV1 {\n\t}\n\n\t@HalfConventionBasedAndHalfAliasedComposedContextConfig(locations = \"explicitDeclaration\")\n\tstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigClassV2 {\n\t}\n\n\t@AliasedComposedContextConfig(xmlConfigFiles = \"test.xml\")\n\tstatic class AliasedComposedContextConfigClass {\n\t}\n\n\t@AliasedValueComposedContextConfig(locations = \"test.xml\")\n\tstatic class AliasedValueComposedContextConfigClass {\n\t}\n\n\t@ImplicitAliasesContextConfig(\"foo.xml\")\n\tstatic class ImplicitAliasesContextConfigClass1 {\n\t}\n\n\t@ImplicitAliasesContextConfig(locations = \"bar.xml\")\n\tstatic class ImplicitAliasesContextConfigClass2 {\n\t}\n\n\t@ImplicitAliasesContextConfig(xmlFiles = \"baz.xml\")\n\tstatic class ImplicitAliasesContextConfigClass3 {\n\t}\n\n\t@ImplicitAliasesWithDefaults\n\tstatic class ImplicitAliasesWithDefaultsClass {\n\t}\n\n\t@TransitiveImplicitAliasesContextConfig(groovy = \"test.groovy\")\n\tstatic class TransitiveImplicitAliasesContextConfigClass {\n\t}\n\n\t@SingleLocationTransitiveImplicitAliasesContextConfig(groovy = \"test.groovy\")\n\tstatic class SingleLocationTransitiveImplicitAliasesContextConfigClass {\n\t}\n\n\t@TransitiveImplicitAliasesWithSkippedLevelContextConfig(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesWithSkippedLevelContextConfigClass {\n\t}\n\n\t@SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfig(xml = \"test.xml\")\n\tstatic class SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigClass {\n\t}\n\n\t@ComposedImplicitAliasesContextConfig\n\tstatic class ComposedImplicitAliasesContextConfigClass {\n\t}\n\n\t@ShadowedAliasComposedContextConfig(xmlConfigFiles = \"test.xml\")\n\tstatic class ShadowedAliasComposedContextConfigClass {\n\t}\n\n\t@AliasedComposedContextConfigAndTestPropSource(xmlConfigFiles = \"test.xml\")\n\tstatic class AliasedComposedContextConfigAndTestPropSourceClass {\n\t}\n\n\t@ComponentScan(value = \"com.example.app.test\", basePackages = \"com.example.app.test\")\n\tstatic class ComponentScanWithBasePackagesAndValueAliasClass {\n\t}\n\n\t@TestComponentScan(packages = \"com.example.app.test\")\n\tstatic class TestComponentScanClass {\n\t}\n\n\t@ConventionBasedSinglePackageComponentScan(basePackages = \"com.example.app.test\")\n\tstatic class ConventionBasedSinglePackageComponentScanClass {\n\t}\n\n\t@AliasForBasedSinglePackageComponentScan(pkg = \"com.example.app.test\")\n\tstatic class AliasForBasedSinglePackageComponentScanClass {\n\t}\n\n\t@SpringAppConfig(Number.class)\n\tstatic class SpringAppConfigClass {\n\t}\n\n\t@Resource(name = \"x\")\n\t@ParametersAreNonnullByDefault\n\tstatic class ResourceHolder {\n\t}\n\n\tinterface TransactionalService {\n\n\t\t@Transactional\n\t\t@Nullable Object doIt();\n\t}\n\n\tclass TransactionalServiceImpl implements TransactionalService {\n\n\t\t@Override\n\t\tpublic @Nullable Object doIt() {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Deprecated\n\t@ComponentScan\n\tclass ForAnnotationsClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ValueAttribute {\n\n\t\tString[] value();\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueAttribute(\"FromValueAttributeMeta\")\n\t@interface ValueAttributeMeta {\n\n\t\t@AliasFor(\"alias\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] alias() default {};\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueAttributeMeta(\"FromValueAttributeMetaMeta\")\n\t@interface ValueAttributeMetaMeta {\n\t}\n\n\t@ValueAttributeMetaMeta\n\tstatic class ValueAttributeMetaMetaClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface StandardContainerWithMultipleAttributes {\n\n\t\tStandardRepeatableWithContainerWithMultipleAttributes[] value();\n\n\t\tString name() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(StandardContainerWithMultipleAttributes.class)\n\t@interface StandardRepeatableWithContainerWithMultipleAttributes {\n\n\t\tString value() default \"\";\n\t}\n\n\t@StandardRepeatableWithContainerWithMultipleAttributes(\"a\")\n\t@StandardRepeatableWithContainerWithMultipleAttributes(\"b\")\n\tstatic class StandardRepeatablesWithContainerWithMultipleAttributesTestCase {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.TxConfig",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.TxConfig",
    "headType": "class",
    "relation": "use",
    "tail": "@Transactional",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.TxConfig",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Set;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.ParametersAreNonnullByDefault;\nimport javax.annotation.meta.When;\n\nimport jakarta.annotation.Resource;\nimport org.jspecify.annotations.Nullable;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.AnnotationUtilsTests.ExtendsBaseClassWithGenericAnnotatedMethod;\nimport org.springframework.core.annotation.AnnotationUtilsTests.ImplementsInterfaceWithGenericAnnotatedMethod;\nimport org.springframework.core.annotation.AnnotationUtilsTests.WebController;\nimport org.springframework.core.annotation.AnnotationUtilsTests.WebMapping;\nimport org.springframework.core.testfixture.stereotype.Component;\nimport org.springframework.core.testfixture.stereotype.Indexed;\nimport org.springframework.util.MultiValueMap;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.Collectors.toSet;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.findAllMergedAnnotations;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.findMergedAnnotation;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getAllAnnotationAttributes;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getAllMergedAnnotations;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getMergedAnnotation;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getMergedAnnotationAttributes;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getMetaAnnotationTypes;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.hasAnnotation;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.hasMetaAnnotationTypes;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.isAnnotated;\nimport static org.springframework.core.annotation.AnnotationUtilsTests.asArray;\n\n/**\n * Tests for {@link AnnotatedElementUtils}.\n *\n * @author Sam Brannen\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 4.0.3\n * @see AnnotationUtilsTests\n * @see MultipleComposedAnnotationsOnSingleAnnotatedElementTests\n * @see ComposedRepeatableAnnotationsTests\n * @see NestedRepeatableAnnotationsTests\n */\nclass AnnotatedElementUtilsTests {\n\n\tprivate static final String TX_NAME = Transactional.class.getName();\n\n\n\t@Nested\n\tclass ConventionBasedAnnotationAttributeOverrideTests {\n\n\t\t@Test\n\t\tvoid getMergedAnnotationAttributesWithConventionBasedComposedAnnotation() {\n\t\t\tClass<?> element = ConventionBasedComposedContextConfigClass.class;\n\t\t\tString name = ContextConfig.class.getName();\n\t\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\n\t\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").containsExactly(\"explicitDeclaration\");\n\t\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").containsExactly(\"explicitDeclaration\");\n\n\t\t\t// Verify contracts between utility methods:\n\t\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t\t}\n\n\t\t/**\n\t\t * This test should never pass, simply because Spring does not support a hybrid\n\t\t * approach for annotation attribute overrides with transitive implicit aliases.\n\t\t * See SPR-13554 for details.\n\t\t * <p>Furthermore, if you choose to execute this test, it can fail for either\n\t\t * the first test class or the second one (with different exceptions), depending\n\t\t * on the order in which the JVM returns the attribute methods via reflection.\n\t\t */\n\t\t@Disabled(\"Permanently disabled but left in place for illustrative purposes\")\n\t\t@Test\n\t\tvoid getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation() {\n\t\t\tfor (Class<?> clazz : asList(HalfConventionBasedAndHalfAliasedComposedContextConfigClassV1.class,\n\t\t\t\t\tHalfConventionBasedAndHalfAliasedComposedContextConfigClassV2.class)) {\n\t\t\t\tgetMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation(clazz);\n\t\t\t}\n\t\t}\n\n\t\tprivate void getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation(Class<?> clazz) {\n\t\t\tString name = ContextConfig.class.getName();\n\t\t\tString simpleName = clazz.getSimpleName();\n\t\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(clazz, name);\n\n\t\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + simpleName).isNotNull();\n\t\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations for class [\" + simpleName + \"]\")\n\t\t\t\t.containsExactly(\"explicitDeclaration\");\n\t\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value for class [\" + simpleName + \"]\")\n\t\t\t\t.containsExactly(\"explicitDeclaration\");\n\n\t\t\t// Verify contracts between utility methods:\n\t\t\tassertThat(isAnnotated(clazz, name)).isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid getMergedAnnotationAttributesWithInvalidConventionBasedComposedAnnotation() {\n\t\t\tClass<?> element = InvalidConventionBasedComposedContextConfigClass.class;\n\t\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\t\tgetMergedAnnotationAttributes(element, ContextConfig.class))\n\t\t\t\t\t.withMessageContaining(\"Different @AliasFor mirror values for annotation\")\n\t\t\t\t\t.withMessageContaining(\"attribute 'locations' and its alias 'value'\")\n\t\t\t\t\t.withMessageContaining(\"values of [{requiredLocationsDeclaration}] and [{duplicateDeclaration}]\");\n\t\t}\n\n\t\t@Test\n\t\tvoid findMergedAnnotationAttributesWithSingleElementOverridingAnArrayViaConvention() {\n\t\t\tassertComponentScanAttributes(ConventionBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\n\t\t}\n\n\t\t@Test\n\t\tvoid findMergedAnnotationWithLocalAliasesThatConflictWithAttributesInMetaAnnotationByConvention() {\n\t\t\tClass<?> element = SpringAppConfigClass.class;\n\t\t\tContextConfig contextConfig = findMergedAnnotation(element, ContextConfig.class);\n\n\t\t\tassertThat(contextConfig).as(\"Should find @ContextConfig on \" + element).isNotNull();\n\t\t\tassertThat(contextConfig.locations()).as(\"locations for \" + element).isEmpty();\n\t\t\t// 'value' in @SpringAppConfig should not override 'value' in @ContextConfig\n\t\t\tassertThat(contextConfig.value()).as(\"value for \" + element).isEmpty();\n\t\t\tassertThat(contextConfig.classes()).as(\"classes for \" + element).containsExactly(Number.class);\n\t\t}\n\n\t\t@Test\n\t\tvoid findMergedAnnotationWithSingleElementOverridingAnArrayViaConvention() throws Exception {\n\t\t\tassertWebMapping(WebController.class.getMethod(\"postMappedWithPathAttribute\"));\n\t\t}\n\n\t}\n\n\n\t@Test\n\tvoid getMetaAnnotationTypesOnNonAnnotatedClass() {\n\t\tassertThat(getMetaAnnotationTypes(NonAnnotatedClass.class, TransactionalComponent.class)).isEmpty();\n\t\tassertThat(getMetaAnnotationTypes(NonAnnotatedClass.class, TransactionalComponent.class.getName())).isEmpty();\n\t}\n\n\t@Test\n\tvoid getMetaAnnotationTypesOnClassWithMetaDepth1() {\n\t\tSet<String> names = getMetaAnnotationTypes(TransactionalComponentClass.class, TransactionalComponent.class);\n\t\tassertThat(names).isEqualTo(names(Transactional.class, Component.class, Indexed.class));\n\n\t\tnames = getMetaAnnotationTypes(TransactionalComponentClass.class, TransactionalComponent.class.getName());\n\t\tassertThat(names).isEqualTo(names(Transactional.class, Component.class, Indexed.class));\n\t}\n\n\t@Test\n\tvoid getMetaAnnotationTypesOnClassWithMetaDepth2() {\n\t\tSet<String> names = getMetaAnnotationTypes(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class);\n\t\tassertThat(names).isEqualTo(names(TransactionalComponent.class, Transactional.class, Component.class, Indexed.class));\n\n\t\tnames = getMetaAnnotationTypes(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class.getName());\n\t\tassertThat(names).isEqualTo(names(TransactionalComponent.class, Transactional.class, Component.class, Indexed.class));\n\t}\n\n\tprivate Set<String> names(Class<?>... classes) {\n\t\treturn stream(classes).map(Class::getName).collect(toSet());\n\t}\n\n\t@Test\n\tvoid hasMetaAnnotationTypesOnNonAnnotatedClass() {\n\t\tassertThat(hasMetaAnnotationTypes(NonAnnotatedClass.class, TX_NAME)).isFalse();\n\t}\n\n\t@Test\n\tvoid hasMetaAnnotationTypesOnClassWithMetaDepth0() {\n\t\tassertThat(hasMetaAnnotationTypes(TransactionalComponentClass.class, TransactionalComponent.class.getName())).isFalse();\n\t}\n\n\t@Test\n\tvoid hasMetaAnnotationTypesOnClassWithMetaDepth1() {\n\t\tassertThat(hasMetaAnnotationTypes(TransactionalComponentClass.class, TX_NAME)).isTrue();\n\t\tassertThat(hasMetaAnnotationTypes(TransactionalComponentClass.class, Component.class.getName())).isTrue();\n\t}\n\n\t@Test\n\tvoid hasMetaAnnotationTypesOnClassWithMetaDepth2() {\n\t\tassertThat(hasMetaAnnotationTypes(ComposedTransactionalComponentClass.class, TX_NAME)).isTrue();\n\t\tassertThat(hasMetaAnnotationTypes(ComposedTransactionalComponentClass.class, Component.class.getName())).isTrue();\n\t\tassertThat(hasMetaAnnotationTypes(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class.getName())).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotatedOnNonAnnotatedClass() {\n\t\tassertThat(isAnnotated(NonAnnotatedClass.class, Transactional.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotatedOnClassWithMetaDepth() {\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, TransactionalComponent.class)).isTrue();\n\t\tassertThat(isAnnotated(SubTransactionalComponentClass.class, TransactionalComponent.class)).as(\"isAnnotated() does not search the class hierarchy.\").isFalse();\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, Transactional.class)).isTrue();\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, Component.class)).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, Transactional.class)).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, Component.class)).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class)).isTrue();\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid isAnnotatedForPlainTypes() {\n\t\tassertThat(isAnnotated(Order.class, Documented.class)).isTrue();\n\t\tassertThat(isAnnotated(org.springframework.lang.NonNullApi.class, Documented.class)).isTrue();\n\t\tassertThat(isAnnotated(org.springframework.lang.NonNullApi.class, Nonnull.class)).isTrue();\n\t\tassertThat(isAnnotated(ParametersAreNonnullByDefault.class, Nonnull.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isAnnotatedWithNameOnNonAnnotatedClass() {\n\t\tassertThat(isAnnotated(NonAnnotatedClass.class, TX_NAME)).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotatedWithNameOnClassWithMetaDepth() {\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, TransactionalComponent.class.getName())).isTrue();\n\t\tassertThat(isAnnotated(SubTransactionalComponentClass.class, TransactionalComponent.class.getName())).as(\"isAnnotated() does not search the class hierarchy.\").isFalse();\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, TX_NAME)).isTrue();\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, Component.class.getName())).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, TX_NAME)).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, Component.class.getName())).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class.getName())).isTrue();\n\t}\n\n\t@Test\n\tvoid hasAnnotationOnNonAnnotatedClass() {\n\t\tassertThat(hasAnnotation(NonAnnotatedClass.class, Transactional.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid hasAnnotationOnClassWithMetaDepth() {\n\t\tassertThat(hasAnnotation(TransactionalComponentClass.class, TransactionalComponent.class)).isTrue();\n\t\tassertThat(hasAnnotation(SubTransactionalComponentClass.class, TransactionalComponent.class)).isTrue();\n\t\tassertThat(hasAnnotation(TransactionalComponentClass.class, Transactional.class)).isTrue();\n\t\tassertThat(hasAnnotation(TransactionalComponentClass.class, Component.class)).isTrue();\n\t\tassertThat(hasAnnotation(ComposedTransactionalComponentClass.class, Transactional.class)).isTrue();\n\t\tassertThat(hasAnnotation(ComposedTransactionalComponentClass.class, Component.class)).isTrue();\n\t\tassertThat(hasAnnotation(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class)).isTrue();\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid hasAnnotationForPlainTypes() {\n\t\tassertThat(hasAnnotation(Order.class, Documented.class)).isTrue();\n\t\tassertThat(hasAnnotation(org.springframework.lang.NonNullApi.class, Documented.class)).isTrue();\n\t\tassertThat(hasAnnotation(org.springframework.lang.NonNullApi.class, Nonnull.class)).isTrue();\n\t\tassertThat(hasAnnotation(ParametersAreNonnullByDefault.class, Nonnull.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesOnNonAnnotatedClass() {\n\t\tassertThat(getAllAnnotationAttributes(NonAnnotatedClass.class, TX_NAME)).isNull();\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesOnClassWithLocalAnnotation() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxConfig.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on TxConfig\").isNotNull();\n\t\tassertThat(attributes.get(\"value\")).as(\"value for TxConfig\").isEqualTo(List.of(\"TxConfig\"));\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesOnClassWithLocalComposedAnnotationAndInheritedAnnotation() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(SubClassWithInheritedAnnotation.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on SubClassWithInheritedAnnotation\").isNotNull();\n\t\tassertThat(attributes.get(\"qualifier\")).isEqualTo(asList(\"composed2\", \"transactionManager\"));\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(SubSubClassWithInheritedAnnotation.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on SubSubClassWithInheritedAnnotation\").isNotNull();\n\t\tassertThat(attributes.get(\"qualifier\")).isEqualTo(List.of(\"transactionManager\"));\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes( SubSubClassWithInheritedComposedAnnotation.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on SubSubClassWithInheritedComposedAnnotation\").isNotNull();\n\t\tassertThat(attributes.get(\"qualifier\")).isEqualTo(List.of(\"composed1\"));\n\t}\n\n\t/**\n\t * If the \"value\" entry contains both \"DerivedTxConfig\" AND \"TxConfig\", then\n\t * the algorithm is accidentally picking up shadowed annotations of the same\n\t * type within the class hierarchy. Such undesirable behavior would cause the\n\t * logic in {@code org.springframework.context.annotation.ProfileCondition}\n\t * to fail.\n\t */\n\t@Test\n\tvoid getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\n\t\t// See org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on DerivedTxConfig\").isNotNull();\n\t\tassertThat(attributes.get(\"value\")).as(\"value for DerivedTxConfig\").isEqualTo(List.of(\"DerivedTxConfig\"));\n\t}\n\n\t/**\n\t * Note: this functionality is required by {@code org.springframework.context.annotation.ProfileCondition}.\n\t */\n\t@Test\n\tvoid getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {\n\t\t// See org.springframework.core.env.EnvironmentSystemIntegrationTests\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations\").isNotNull();\n\t\tassertThat(attributes.get(\"value\")).as(\"value for TxFromMultipleComposedAnnotations.\").isEqualTo(asList(\"TxInheritedComposed\", \"TxComposed\"));\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid getAllAnnotationAttributesOnLangType() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(\n\t\t\t\torg.springframework.lang.NonNullApi.class, Nonnull.class.getName());\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Nonnull on NonNullApi\").isNotNull();\n\t\tassertThat(attributes.get(\"when\")).as(\"value for NonNullApi\").isEqualTo(List.of(When.ALWAYS));\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesOnJavaxType() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(\n\t\t\t\tParametersAreNonnullByDefault.class, Nonnull.class.getName());\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Nonnull on NonNullApi\").isNotNull();\n\t\tassertThat(attributes.get(\"when\")).as(\"value for NonNullApi\").isEqualTo(List.of(When.ALWAYS));\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnClassWithLocalAnnotation() {\n\t\tClass<?> element = TxConfig.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Annotation attributes for @Transactional on TxConfig\").isNotNull();\n\t\tassertThat(attributes.getString(\"value\")).as(\"value for TxConfig\").isEqualTo(\"TxConfig\");\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\n\t\tClass<?> element = DerivedTxConfig.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Annotation attributes for @Transactional on DerivedTxConfig\").isNotNull();\n\t\tassertThat(attributes.getString(\"value\")).as(\"value for DerivedTxConfig\").isEqualTo(\"DerivedTxConfig\");\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(MetaCycleAnnotatedClass.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Should not find annotation attributes for @Transactional on MetaCycleAnnotatedClass\").isNull();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesFavorsLocalComposedAnnotationOverInheritedAnnotation() {\n\t\tClass<?> element = SubClassWithInheritedAnnotation.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"AnnotationAttributes for @Transactional on SubClassWithInheritedAnnotation\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t\tassertThat(attributes.getBoolean(\"readOnly\")).as(\"readOnly flag for SubClassWithInheritedAnnotation.\").isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tClass<?> element = SubSubClassWithInheritedAnnotation.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"AnnotationAttributes for @Transactional on SubSubClassWithInheritedAnnotation\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t\tassertThat(attributes.getBoolean(\"readOnly\")).as(\"readOnly flag for SubSubClassWithInheritedAnnotation.\").isFalse();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tClass<?> element = SubSubClassWithInheritedComposedAnnotation.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"AnnotationAttributes for @Transactional on SubSubClassWithInheritedComposedAnnotation.\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t\tassertThat(attributes.getBoolean(\"readOnly\")).as(\"readOnly flag for SubSubClassWithInheritedComposedAnnotation.\").isFalse();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesFromInterfaceImplementedBySuperclass() {\n\t\tClass<?> element = ConcreteClassWithInheritedAnnotation.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Should not find @Transactional on ConcreteClassWithInheritedAnnotation\").isNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isFalse();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnInheritedAnnotationInterface() {\n\t\tClass<?> element = InheritedAnnotationInterface.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Should find @Transactional on InheritedAnnotationInterface\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnNonInheritedAnnotationInterface() {\n\t\tClass<?> element = NonInheritedAnnotationInterface.class;\n\t\tString name = Order.class.getName();\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Should find @Order on NonInheritedAnnotationInterface\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesWithAliasedComposedAnnotation() {\n\t\tClass<?> element = AliasedComposedContextConfigClass.class;\n\t\tString name = ContextConfig.class.getName();\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\n\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(asArray(\"test.xml\"));\n\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(asArray(\"test.xml\"));\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesWithAliasedValueComposedAnnotation() {\n\t\tClass<?> element = AliasedValueComposedContextConfigClass.class;\n\t\tString name = ContextConfig.class.getName();\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\n\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(asArray(\"test.xml\"));\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(asArray(\"test.xml\"));\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesWithImplicitAliasesInMetaAnnotationOnComposedAnnotation() {\n\t\tClass<?> element = ComposedImplicitAliasesContextConfigClass.class;\n\t\tString name = ImplicitAliasesContextConfig.class.getName();\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tString[] expected = asArray(\"A.xml\", \"B.xml\");\n\n\t\tassertThat(attributes).as(\"Should find @ImplicitAliasesContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"groovyScripts\")).as(\"groovyScripts\").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"xmlFiles\")).as(\"xmlFiles\").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(expected);\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithAliasedValueComposedAnnotation() {\n\t\tassertGetMergedAnnotation(AliasedValueComposedContextConfigClass.class, \"test.xml\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithImplicitAliasesForSameAttributeInComposedAnnotation() {\n\t\tassertGetMergedAnnotation(ImplicitAliasesContextConfigClass1.class, \"foo.xml\");\n\t\tassertGetMergedAnnotation(ImplicitAliasesContextConfigClass2.class, \"bar.xml\");\n\t\tassertGetMergedAnnotation(ImplicitAliasesContextConfigClass3.class, \"baz.xml\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithTransitiveImplicitAliases() {\n\t\tassertGetMergedAnnotation(TransitiveImplicitAliasesContextConfigClass.class, \"test.groovy\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithTransitiveImplicitAliasesWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\tassertGetMergedAnnotation(SingleLocationTransitiveImplicitAliasesContextConfigClass.class, \"test.groovy\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithTransitiveImplicitAliasesWithSkippedLevel() {\n\t\tassertGetMergedAnnotation(TransitiveImplicitAliasesWithSkippedLevelContextConfigClass.class, \"test.xml\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithTransitiveImplicitAliasesWithSkippedLevelWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\tassertGetMergedAnnotation(SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigClass.class, \"test.xml\");\n\t}\n\n\tprivate void assertGetMergedAnnotation(Class<?> element, String... expected) {\n\t\tString name = ContextConfig.class.getName();\n\t\tContextConfig contextConfig = getMergedAnnotation(element, ContextConfig.class);\n\n\t\tassertThat(contextConfig).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(contextConfig.locations()).as(\"locations\").isEqualTo(expected);\n\t\tassertThat(contextConfig.value()).as(\"value\").isEqualTo(expected);\n\t\tObject[] expecteds = new Class<?>[0];\n\t\tassertThat(contextConfig.classes()).as(\"classes\").isEqualTo(expecteds);\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithImplicitAliasesInMetaAnnotationOnComposedAnnotation() {\n\t\tClass<?> element = ComposedImplicitAliasesContextConfigClass.class;\n\t\tString name = ImplicitAliasesContextConfig.class.getName();\n\t\tImplicitAliasesContextConfig config = getMergedAnnotation(element, ImplicitAliasesContextConfig.class);\n\t\tString[] expected = asArray(\"A.xml\", \"B.xml\");\n\n\t\tassertThat(config).as(\"Should find @ImplicitAliasesContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(config.groovyScripts()).as(\"groovyScripts\").isEqualTo(expected);\n\t\tassertThat(config.xmlFiles()).as(\"xmlFiles\").isEqualTo(expected);\n\t\tassertThat(config.locations()).as(\"locations\").isEqualTo(expected);\n\t\tassertThat(config.value()).as(\"value\").isEqualTo(expected);\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithImplicitAliasesWithDefaultsInMetaAnnotationOnComposedAnnotation() {\n\t\tClass<?> element = ImplicitAliasesWithDefaultsClass.class;\n\t\tString name = AliasesWithDefaults.class.getName();\n\t\tAliasesWithDefaults annotation = getMergedAnnotation(element, AliasesWithDefaults.class);\n\n\t\tassertThat(annotation).as(\"Should find @AliasesWithDefaults on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(annotation.a1()).as(\"a1\").isEqualTo(\"ImplicitAliasesWithDefaults\");\n\t\tassertThat(annotation.a2()).as(\"a2\").isEqualTo(\"ImplicitAliasesWithDefaults\");\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesWithShadowedAliasComposedAnnotation() {\n\t\tClass<?> element = ShadowedAliasComposedContextConfigClass.class;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, ContextConfig.class);\n\n\t\tString[] expected = asArray(\"test.xml\");\n\n\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(expected);\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(InheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on InheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnSubInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(SubInheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on SubInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnSubSubInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(SubSubInheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on SubSubInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnNonInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(NonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on NonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnSubNonInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(SubNonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on SubNonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnSubSubNonInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(SubSubNonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on SubSubNonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesInheritedFromInterfaceMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleFromInterface\");\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(method, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on ConcreteClassWithInheritedAnnotation.handleFromInterface() method\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesInheritedFromAbstractMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handle\");\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on ConcreteClassWithInheritedAnnotation.handle() method\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleParameterized\", String.class);\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()\").isNotNull();\n\t}\n\n\t/**\n\t * Bridge/bridged method setup code copied from\n\t * {@link org.springframework.core.BridgeMethodResolverTests#withGenericParameter()}.\n\t * @since 4.2\n\t */\n\t@Test\n\tvoid findMergedAnnotationAttributesFromBridgeMethod() {\n\t\tMethod[] methods = StringGenericParameter.class.getMethods();\n\t\tMethod bridgeMethod = null;\n\t\tMethod bridgedMethod = null;\n\n\t\tfor (Method method : methods) {\n\t\t\tif (\"getFor\".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {\n\t\t\t\tif (method.getReturnType().equals(Object.class)) {\n\t\t\t\t\tbridgeMethod = method;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbridgedMethod = method;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\n\t\tboolean condition = bridgedMethod != null && !bridgedMethod.isBridge();\n\t\tassertThat(condition).isTrue();\n\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on StringGenericParameter.getFor() bridge method\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnClassWithMetaAndLocalTxConfig() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(MetaAndLocalTxConfigClass.class, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on MetaAndLocalTxConfigClass\").isNotNull();\n\t\tassertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier for MetaAndLocalTxConfigClass.\").isEqualTo(\"localTxMgr\");\n\t}\n\n\t@Test\n\tvoid findAndSynthesizeAnnotationAttributesOnClassWithAttributeAliasesInTargetAnnotation() {\n\t\tString qualifier = \"aliasForQualifier\";\n\n\t\t// 1) Find and merge AnnotationAttributes from the annotation hierarchy\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(\n\t\t\t\tAliasedTransactionalComponentClass.class, AliasedTransactional.class);\n\t\tassertThat(attributes).as(\"@AliasedTransactional on AliasedTransactionalComponentClass.\").isNotNull();\n\n\t\t// 2) Synthesize the AnnotationAttributes back into the target annotation\n\t\tAliasedTransactional annotation = AnnotationUtils.synthesizeAnnotation(attributes,\n\t\t\t\tAliasedTransactional.class, AliasedTransactionalComponentClass.class);\n\t\tassertThat(annotation).isNotNull();\n\n\t\t// 3) Verify that the AnnotationAttributes and synthesized annotation are equivalent\n\t\tassertThat(attributes.getString(\"value\")).as(\"TX value via attributes.\").isEqualTo(qualifier);\n\t\tassertThat(annotation.value()).as(\"TX value via synthesized annotation.\").isEqualTo(qualifier);\n\t\tassertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier via attributes.\").isEqualTo(qualifier);\n\t\tassertThat(annotation.qualifier()).as(\"TX qualifier via synthesized annotation.\").isEqualTo(qualifier);\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnClassWithAttributeAliasInComposedAnnotationAndNestedAnnotationsInTargetAnnotation() {\n\t\tAnnotationAttributes attributes = assertComponentScanAttributes(TestComponentScanClass.class, \"com.example.app.test\");\n\n\t\tFilter[] excludeFilters = attributes.getAnnotationArray(\"excludeFilters\", Filter.class);\n\t\tassertThat(excludeFilters).isNotNull();\n\n\t\tList<String> patterns = stream(excludeFilters).map(Filter::pattern).collect(toList());\n\t\tassertThat(patterns).isEqualTo(asList(\"*Test\", \"*Tests\"));\n\t}\n\n\t/**\n\t * This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}\n\t * uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation\n\t * attributes since attributes may be arrays.\n\t */\n\t@Test\n\tvoid findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {\n\t\tassertComponentScanAttributes(ComponentScanWithBasePackagesAndValueAliasClass.class, \"com.example.app.test\");\n\t}\n\n\t/**\n\t * @since 5.2.1\n\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\n\t */\n\t@Test\n\tvoid findMergedAnnotationAttributesOnMethodWithComposedMetaTransactionalAnnotation() throws Exception {\n\t\tMethod method = getClass().getDeclaredMethod(\"composedTransactionalMethod\");\n\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(method, AliasedTransactional.class);\n\t\tassertThat(attributes).as(\"Should find @AliasedTransactional on \" + method).isNotNull();\n\t\tassertThat(attributes.getString(\"value\")).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t/**\n\t * @since 5.2.1\n\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\n\t */\n\t@Test\n\tvoid findMergedAnnotationOnMethodWithComposedMetaTransactionalAnnotation() throws Exception {\n\t\tMethod method = getClass().getDeclaredMethod(\"composedTransactionalMethod\");\n\n\t\tAliasedTransactional annotation = findMergedAnnotation(method, AliasedTransactional.class);\n\t\tassertThat(annotation).as(\"Should find @AliasedTransactional on \" + method).isNotNull();\n\t\tassertThat(annotation.value()).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(annotation.qualifier()).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t/**\n\t * @since 5.2.1\n\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\n\t */\n\t@Test\n\tvoid findMergedAnnotationAttributesOnClassWithComposedMetaTransactionalAnnotation() {\n\t\tClass<?> clazz = ComposedTransactionalClass.class;\n\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(clazz, AliasedTransactional.class);\n\t\tassertThat(attributes).as(\"Should find @AliasedTransactional on \" + clazz).isNotNull();\n\t\tassertThat(attributes.getString(\"value\")).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t/**\n\t * @since 5.2.1\n\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\n\t */\n\t@Test\n\tvoid findMergedAnnotationOnClassWithComposedMetaTransactionalAnnotation() {\n\t\tClass<?> clazz = ComposedTransactionalClass.class;\n\n\t\tAliasedTransactional annotation = findMergedAnnotation(clazz, AliasedTransactional.class);\n\t\tassertThat(annotation).as(\"Should find @AliasedTransactional on \" + clazz).isNotNull();\n\t\tassertThat(annotation.value()).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(annotation.qualifier()).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\tassertComponentScanAttributes(AliasForBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\n\t}\n\n\tprivate AnnotationAttributes assertComponentScanAttributes(Class<?> element, String... expected) {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(element, ComponentScan.class);\n\n\t\tassertThat(attributes).as(\"Should find @ComponentScan on \" + element).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value: \").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"basePackages\")).as(\"basePackages: \").isEqualTo(expected);\n\n\t\treturn attributes;\n\t}\n\n\tprivate AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element, Class<? extends Annotation> annotationType) {\n\t\treturn AnnotatedElementUtils.findMergedAnnotationAttributes(element, annotationType.getName(), false, false);\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationWithAttributeAliasesInTargetAnnotation() {\n\t\tClass<?> element = AliasedTransactionalComponentClass.class;\n\t\tAliasedTransactional annotation = findMergedAnnotation(element, AliasedTransactional.class);\n\t\tassertThat(annotation).as(\"@AliasedTransactional on \" + element).isNotNull();\n\t\tassertThat(annotation.value()).as(\"TX value via synthesized annotation.\").isEqualTo(\"aliasForQualifier\");\n\t\tassertThat(annotation.qualifier()).as(\"TX qualifier via synthesized annotation.\").isEqualTo(\"aliasForQualifier\");\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationForMultipleMetaAnnotationsWithClashingAttributeNames() {\n\t\tString[] xmlLocations = asArray(\"test.xml\");\n\t\tString[] propFiles = asArray(\"test.properties\");\n\n\t\tClass<?> element = AliasedComposedContextConfigAndTestPropSourceClass.class;\n\n\t\tContextConfig contextConfig = findMergedAnnotation(element, ContextConfig.class);\n\t\tassertThat(contextConfig).as(\"@ContextConfig on \" + element).isNotNull();\n\t\tassertThat(contextConfig.locations()).as(\"locations\").isEqualTo(xmlLocations);\n\t\tassertThat(contextConfig.value()).as(\"value\").isEqualTo(xmlLocations);\n\n\t\t// Synthesized annotation\n\t\tTestPropSource testPropSource = AnnotationUtils.findAnnotation(element, TestPropSource.class);\n\t\tassertThat(testPropSource.locations()).as(\"locations\").isEqualTo(propFiles);\n\t\tassertThat(testPropSource.value()).as(\"value\").isEqualTo(propFiles);\n\n\t\t// Merged annotation\n\t\ttestPropSource = findMergedAnnotation(element, TestPropSource.class);\n\t\tassertThat(testPropSource).as(\"@TestPropSource on \" + element).isNotNull();\n\t\tassertThat(testPropSource.locations()).as(\"locations\").isEqualTo(propFiles);\n\t\tassertThat(testPropSource.value()).as(\"value\").isEqualTo(propFiles);\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationWithSingleElementOverridingAnArrayViaAliasFor() throws Exception {\n\t\tassertWebMapping(WebController.class.getMethod(\"getMappedWithValueAttribute\"));\n\t\tassertWebMapping(WebController.class.getMethod(\"getMappedWithPathAttribute\"));\n\t}\n\n\tprivate void assertWebMapping(AnnotatedElement element) {\n\t\tWebMapping webMapping = findMergedAnnotation(element, WebMapping.class);\n\t\tassertThat(webMapping).isNotNull();\n\t\tassertThat(webMapping.value()).as(\"value attribute: \").isEqualTo(asArray(\"/test\"));\n\t\tassertThat(webMapping.path()).as(\"path attribute: \").isEqualTo(asArray(\"/test\"));\n\t}\n\n\t@Test\n\tvoid javaLangAnnotationTypeViaFindMergedAnnotation() throws Exception {\n\t\tConstructor<?> deprecatedCtor = Date.class.getConstructor(String.class);\n\t\tassertThat(findMergedAnnotation(deprecatedCtor, Deprecated.class)).isEqualTo(deprecatedCtor.getAnnotation(Deprecated.class));\n\t\tassertThat(findMergedAnnotation(Date.class, Deprecated.class)).isEqualTo(Date.class.getAnnotation(Deprecated.class));\n\t}\n\n\t@Test\n\tvoid javaxAnnotationTypeViaFindMergedAnnotation() {\n\t\tassertThat(findMergedAnnotation(ResourceHolder.class, Resource.class)).isEqualTo(ResourceHolder.class.getAnnotation(Resource.class));\n\t\tassertThat(findMergedAnnotation(SpringAppConfigClass.class, Resource.class)).isEqualTo(SpringAppConfigClass.class.getAnnotation(Resource.class));\n\t}\n\n\t@Test\n\tvoid javaxMetaAnnotationTypeViaFindMergedAnnotation() {\n\t\tassertThat(findMergedAnnotation(ParametersAreNonnullByDefault.class, Nonnull.class)).isEqualTo(ParametersAreNonnullByDefault.class.getAnnotation(Nonnull.class));\n\t\tassertThat(findMergedAnnotation(ResourceHolder.class, Nonnull.class)).isEqualTo(ParametersAreNonnullByDefault.class.getAnnotation(Nonnull.class));\n\t}\n\n\t@Test\n\tvoid nullableAnnotationTypeViaFindMergedAnnotation() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tassertThat(findMergedAnnotation(method, Resource.class)).isEqualTo(method.getAnnotation(Resource.class));\n\t}\n\n\t@Test\n\tvoid getAllMergedAnnotationsOnClassWithInterface() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tSet<Transactional> allMergedAnnotations = getAllMergedAnnotations(method, Transactional.class);\n\t\tassertThat(allMergedAnnotations).isEmpty();\n\t}\n\n\t@Test\n\tvoid findAllMergedAnnotationsOnClassWithInterface() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tSet<Transactional> allMergedAnnotations = findAllMergedAnnotations(method, Transactional.class);\n\t\tassertThat(allMergedAnnotations).hasSize(1);\n\t}\n\n\t@Test  // SPR-16060\n\tvoid findMethodAnnotationFromGenericInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tOrder order = findMergedAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test  // SPR-17146\n\tvoid findMethodAnnotationFromGenericSuperclass() throws Exception {\n\t\tMethod method = ExtendsBaseClassWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tOrder order = findMergedAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test // gh-22655\n\tvoid forAnnotationsCreatesCopyOfArrayOnEachCall() {\n\t\tAnnotatedElement element = AnnotatedElementUtils.forAnnotations(ForAnnotationsClass.class.getDeclaredAnnotations());\n\t\t// Trigger the NPE as originally reported in the bug\n\t\tAnnotationsScanner.getDeclaredAnnotations(element, false);\n\t\tAnnotationsScanner.getDeclaredAnnotations(element, false);\n\t\t// Also specifically test we get different instances\n\t\tassertThat(element.getDeclaredAnnotations()).isNotSameAs(element.getDeclaredAnnotations());\n\t}\n\n\t@Test // gh-22703\n\tvoid getMergedAnnotationOnThreeDeepMetaWithValue() {\n\t\tValueAttribute annotation = AnnotatedElementUtils.getMergedAnnotation(\n\t\t\t\tValueAttributeMetaMetaClass.class, ValueAttribute.class);\n\t\tassertThat(annotation.value()).containsExactly(\"FromValueAttributeMeta\");\n\t}\n\n\t/**\n\t * @since 5.3.25\n\t */\n\t@Test // gh-29685\n\tvoid getMergedRepeatableAnnotationsWithContainerWithMultipleAttributes() {\n\t\tSet<StandardRepeatableWithContainerWithMultipleAttributes> repeatableAnnotations =\n\t\t\t\tAnnotatedElementUtils.getMergedRepeatableAnnotations(\n\t\t\t\t\t\tStandardRepeatablesWithContainerWithMultipleAttributesTestCase.class,\n\t\t\t\t\t\tStandardRepeatableWithContainerWithMultipleAttributes.class);\n\t\tassertThat(repeatableAnnotations).map(StandardRepeatableWithContainerWithMultipleAttributes::value)\n\t\t\t\t.containsExactly(\"a\", \"b\");\n\t}\n\n\t/**\n\t * @since 5.3.25\n\t */\n\t@Test // gh-29685\n\tvoid findMergedRepeatableAnnotationsWithContainerWithMultipleAttributes() {\n\t\tSet<StandardRepeatableWithContainerWithMultipleAttributes> repeatableAnnotations =\n\t\t\t\tAnnotatedElementUtils.findMergedRepeatableAnnotations(\n\t\t\t\t\t\tStandardRepeatablesWithContainerWithMultipleAttributesTestCase.class,\n\t\t\t\t\t\tStandardRepeatableWithContainerWithMultipleAttributes.class);\n\t\tassertThat(repeatableAnnotations).map(StandardRepeatableWithContainerWithMultipleAttributes::value)\n\t\t\t\t.containsExactly(\"a\", \"b\");\n\t}\n\n\t// -------------------------------------------------------------------------\n\n\t@MetaCycle3\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.ANNOTATION_TYPE)\n\t@interface MetaCycle1 {\n\t}\n\n\t@MetaCycle1\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.ANNOTATION_TYPE)\n\t@interface MetaCycle2 {\n\t}\n\n\t@MetaCycle2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface MetaCycle3 {\n\t}\n\n\t@MetaCycle3\n\tstatic class MetaCycleAnnotatedClass {\n\t}\n\n\t// -------------------------------------------------------------------------\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Inherited\n\t@interface Transactional {\n\n\t\tString value() default \"\";\n\n\t\tString qualifier() default \"transactionManager\";\n\n\t\tboolean readOnly() default false;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Inherited\n\t@interface AliasedTransactional {\n\n\t\t@AliasFor(\"qualifier\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString qualifier() default \"\";\n\t}\n\n\t@AliasedTransactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@interface MyAliasedTransactional {\n\n\t\t@AliasFor(annotation = AliasedTransactional.class, attribute = \"value\")\n\t\tString value() default \"defaultTransactionManager\";\n\t}\n\n\t@MyAliasedTransactional(\"anotherTransactionManager\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@interface ComposedMyAliasedTransactional {\n\t}\n\n\t@Transactional(qualifier = \"composed1\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@Inherited\n\t@interface InheritedComposed {\n\t}\n\n\t@Transactional(qualifier = \"composed2\", readOnly = true)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface Composed {\n\t}\n\n\t@Transactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxComposedWithOverride {\n\n\t\tString qualifier() default \"txMgr\";\n\t}\n\n\t@Transactional(\"TxInheritedComposed\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxInheritedComposed {\n\t}\n\n\t@Transactional(\"TxComposed\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxComposed {\n\t}\n\n\t@Transactional\n\t@Component\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransactionalComponent {\n\t}\n\n\t@TransactionalComponent\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedTransactionalComponent {\n\t}\n\n\t@AliasedTransactional(value = \"aliasForQualifier\")\n\t@Component\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedTransactionalComponent {\n\t}\n\n\t@TxComposedWithOverride\n\t// Override default \"txMgr\" from @TxComposedWithOverride with \"localTxMgr\"\n\t@Transactional(qualifier = \"localTxMgr\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface MetaAndLocalTxConfig {\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.test.context.TestPropertySource}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestPropSource {\n\n\t\t@AliasFor(\"locations\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] locations() default {};\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.test.context.ContextConfiguration}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContextConfig {\n\n\t\t@AliasFor(\"locations\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] locations() default {};\n\n\t\tClass<?>[] classes() default {};\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionBasedComposedContextConfig {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfig.class)\n\t\tString[] locations() default {};\n\t}\n\n\t@ContextConfig(value = \"duplicateDeclaration\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface InvalidConventionBasedComposedContextConfig {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfig.class)\n\t\tString[] locations();\n\t}\n\n\t/**\n\t * This hybrid approach for annotation attribute overrides with transitive implicit\n\t * aliases is unsupported. See SPR-13554 for details.\n\t */\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface HalfConventionBasedAndHalfAliasedComposedContextConfig {\n\n\t\tString[] locations() default {};\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles() default {};\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles();\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedValueComposedContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"value\")\n\t\tString[] locations();\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] groovyScripts() default {};\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlFiles() default {};\n\n\t\t// intentionally omitted: attribute = \"locations\"\n\t\t@AliasFor(annotation = ContextConfig.class)\n\t\tString[] locations() default {};\n\n\t\t// intentionally omitted: attribute = \"locations\" (SPR-14069)\n\t\t@AliasFor(annotation = ContextConfig.class)\n\t\tString[] value() default {};\n\t}\n\n\t@ImplicitAliasesContextConfig(xmlFiles = {\"A.xml\", \"B.xml\"})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedImplicitAliasesContextConfig {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasesWithDefaults {\n\n\t\t@AliasFor(\"a2\")\n\t\tString a1() default \"AliasesWithDefaults\";\n\n\t\t@AliasFor(\"a1\")\n\t\tString a2() default \"AliasesWithDefaults\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasesWithDefaults\n\t@interface ImplicitAliasesWithDefaults {\n\n\t\t@AliasFor(annotation = AliasesWithDefaults.class, attribute = \"a1\")\n\t\tString b1() default \"ImplicitAliasesWithDefaults\";\n\n\t\t@AliasFor(annotation = AliasesWithDefaults.class, attribute = \"a2\")\n\t\tString b2() default \"ImplicitAliasesWithDefaults\";\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"xmlFiles\")\n\t\tString[] xml() default {};\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScripts\")\n\t\tString[] groovy() default {};\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SingleLocationTransitiveImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"xmlFiles\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScripts\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesWithSkippedLevelContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xml() default {};\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScripts\")\n\t\tString[] groovy() default {};\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScripts\")\n\t\tString groovy() default \"\";\n\t}\n\n\t/**\n\t * Although the configuration declares an explicit value for 'value' and\n\t * requires a value for the aliased 'locations', this does not result in\n\t * an error since 'locations' effectively <em>shadows</em> the 'value'\n\t * attribute (which cannot be set via the composed annotation anyway).\n\t *\n\t * If 'value' were not shadowed, such a declaration would not make sense.\n\t */\n\t@ContextConfig(value = \"duplicateDeclaration\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ShadowedAliasComposedContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles();\n\t}\n\n\t@ContextConfig(locations = \"shadowed.xml\")\n\t@TestPropSource(locations = \"test.properties\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfigAndTestPropSource {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles() default \"default.xml\";\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.boot.test.SpringApplicationConfiguration}.\n\t */\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SpringAppConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] locations() default {};\n\n\t\t// Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfig.class, attribute = \"classes\")\n\t\t@AliasFor(\"value\")\n\t\tClass<?>[] classes() default {};\n\n\t\t// Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfig.class, attribute = \"classes\")\n\t\t@AliasFor(\"classes\")\n\t\tClass<?>[] value() default {};\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.context.annotation.ComponentScan}\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScan {\n\n\t\t@AliasFor(\"basePackages\")\n\t\tString[] value() default {};\n\n\t\t// Intentionally no alias declaration for \"value\"\n\t\tString[] basePackages() default {};\n\n\t\tFilter[] excludeFilters() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({})\n\t@interface Filter {\n\n\t\tString pattern();\n\t}\n\n\t@ComponentScan(excludeFilters = {@Filter(pattern = \"*Test\"), @Filter(pattern = \"*Tests\")})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestComponentScan {\n\n\t\t@AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\n\t\tString[] packages();\n\t}\n\n\t@ComponentScan\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionBasedSinglePackageComponentScan {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ComponentScan.class)\n\t\tString basePackages();\n\t}\n\n\t@ComponentScan\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForBasedSinglePackageComponentScan {\n\n\t\t@AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\n\t\tString pkg();\n\t}\n\n\t// -------------------------------------------------------------------------\n\n\tstatic class NonAnnotatedClass {\n\t}\n\n\t@TransactionalComponent\n\tstatic class TransactionalComponentClass {\n\t}\n\n\tstatic class SubTransactionalComponentClass extends TransactionalComponentClass {\n\t}\n\n\t@ComposedTransactionalComponent\n\tstatic class ComposedTransactionalComponentClass {\n\t}\n\n\t@AliasedTransactionalComponent\n\tstatic class AliasedTransactionalComponentClass {\n\t}\n\n\t@ComposedMyAliasedTransactional\n\tvoid composedTransactionalMethod() {\n\t}\n\n\t@ComposedMyAliasedTransactional\n\tstatic class ComposedTransactionalClass {\n\t}\n\n\t@Transactional\n\tstatic class ClassWithInheritedAnnotation {\n\t}\n\n\t@Composed\n\tstatic class SubClassWithInheritedAnnotation extends ClassWithInheritedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedAnnotation extends SubClassWithInheritedAnnotation {\n\t}\n\n\t@InheritedComposed\n\tstatic class ClassWithInheritedComposedAnnotation {\n\t}\n\n\t@Composed\n\tstatic class SubClassWithInheritedComposedAnnotation extends ClassWithInheritedComposedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedComposedAnnotation extends SubClassWithInheritedComposedAnnotation {\n\t}\n\n\t@MetaAndLocalTxConfig\n\tstatic class MetaAndLocalTxConfigClass {\n\t}\n\n\t@Transactional(\"TxConfig\")\n\tstatic class TxConfig {\n\t}\n\n\t@Transactional(\"DerivedTxConfig\")\n\tstatic class DerivedTxConfig extends TxConfig {\n\t}\n\n\t@TxInheritedComposed\n\t@TxComposed\n\tstatic class TxFromMultipleComposedAnnotations {\n\t}\n\n\t@Transactional\n\tinterface InterfaceWithInheritedAnnotation {\n\n\t\t@Order\n\t\tvoid handleFromInterface();\n\t}\n\n\tabstract static class AbstractClassWithInheritedAnnotation<T> implements InterfaceWithInheritedAnnotation {\n\n\t\t@Transactional\n\t\tpublic abstract void handle();\n\n\t\t@Transactional\n\t\tpublic void handleParameterized(T t) {\n\t\t}\n\t}\n\n\tstatic class ConcreteClassWithInheritedAnnotation extends AbstractClassWithInheritedAnnotation<String> {\n\n\t\t@Override\n\t\tpublic void handle() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleParameterized(String s) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleFromInterface() {\n\t\t}\n\t}\n\n\tpublic interface GenericParameter<T> {\n\n\t\tT getFor(Class<T> cls);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class StringGenericParameter implements GenericParameter<String> {\n\n\t\t@Order\n\t\t@Override\n\t\tpublic String getFor(Class<String> cls) {\n\t\t\treturn \"foo\";\n\t\t}\n\n\t\tpublic String getFor(Integer integer) {\n\t\t\treturn \"foo\";\n\t\t}\n\t}\n\n\t@Transactional\n\tpublic interface InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubInheritedAnnotationInterface extends InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubInheritedAnnotationInterface extends SubInheritedAnnotationInterface {\n\t}\n\n\t@Order\n\tpublic interface NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubNonInheritedAnnotationInterface extends NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubNonInheritedAnnotationInterface extends SubNonInheritedAnnotationInterface {\n\t}\n\n\t@ConventionBasedComposedContextConfig(locations = \"explicitDeclaration\")\n\tstatic class ConventionBasedComposedContextConfigClass {\n\t}\n\n\t@InvalidConventionBasedComposedContextConfig(locations = \"requiredLocationsDeclaration\")\n\tstatic class InvalidConventionBasedComposedContextConfigClass {\n\t}\n\n\t@HalfConventionBasedAndHalfAliasedComposedContextConfig(xmlConfigFiles = \"explicitDeclaration\")\n\tstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigClassV1 {\n\t}\n\n\t@HalfConventionBasedAndHalfAliasedComposedContextConfig(locations = \"explicitDeclaration\")\n\tstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigClassV2 {\n\t}\n\n\t@AliasedComposedContextConfig(xmlConfigFiles = \"test.xml\")\n\tstatic class AliasedComposedContextConfigClass {\n\t}\n\n\t@AliasedValueComposedContextConfig(locations = \"test.xml\")\n\tstatic class AliasedValueComposedContextConfigClass {\n\t}\n\n\t@ImplicitAliasesContextConfig(\"foo.xml\")\n\tstatic class ImplicitAliasesContextConfigClass1 {\n\t}\n\n\t@ImplicitAliasesContextConfig(locations = \"bar.xml\")\n\tstatic class ImplicitAliasesContextConfigClass2 {\n\t}\n\n\t@ImplicitAliasesContextConfig(xmlFiles = \"baz.xml\")\n\tstatic class ImplicitAliasesContextConfigClass3 {\n\t}\n\n\t@ImplicitAliasesWithDefaults\n\tstatic class ImplicitAliasesWithDefaultsClass {\n\t}\n\n\t@TransitiveImplicitAliasesContextConfig(groovy = \"test.groovy\")\n\tstatic class TransitiveImplicitAliasesContextConfigClass {\n\t}\n\n\t@SingleLocationTransitiveImplicitAliasesContextConfig(groovy = \"test.groovy\")\n\tstatic class SingleLocationTransitiveImplicitAliasesContextConfigClass {\n\t}\n\n\t@TransitiveImplicitAliasesWithSkippedLevelContextConfig(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesWithSkippedLevelContextConfigClass {\n\t}\n\n\t@SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfig(xml = \"test.xml\")\n\tstatic class SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigClass {\n\t}\n\n\t@ComposedImplicitAliasesContextConfig\n\tstatic class ComposedImplicitAliasesContextConfigClass {\n\t}\n\n\t@ShadowedAliasComposedContextConfig(xmlConfigFiles = \"test.xml\")\n\tstatic class ShadowedAliasComposedContextConfigClass {\n\t}\n\n\t@AliasedComposedContextConfigAndTestPropSource(xmlConfigFiles = \"test.xml\")\n\tstatic class AliasedComposedContextConfigAndTestPropSourceClass {\n\t}\n\n\t@ComponentScan(value = \"com.example.app.test\", basePackages = \"com.example.app.test\")\n\tstatic class ComponentScanWithBasePackagesAndValueAliasClass {\n\t}\n\n\t@TestComponentScan(packages = \"com.example.app.test\")\n\tstatic class TestComponentScanClass {\n\t}\n\n\t@ConventionBasedSinglePackageComponentScan(basePackages = \"com.example.app.test\")\n\tstatic class ConventionBasedSinglePackageComponentScanClass {\n\t}\n\n\t@AliasForBasedSinglePackageComponentScan(pkg = \"com.example.app.test\")\n\tstatic class AliasForBasedSinglePackageComponentScanClass {\n\t}\n\n\t@SpringAppConfig(Number.class)\n\tstatic class SpringAppConfigClass {\n\t}\n\n\t@Resource(name = \"x\")\n\t@ParametersAreNonnullByDefault\n\tstatic class ResourceHolder {\n\t}\n\n\tinterface TransactionalService {\n\n\t\t@Transactional\n\t\t@Nullable Object doIt();\n\t}\n\n\tclass TransactionalServiceImpl implements TransactionalService {\n\n\t\t@Override\n\t\tpublic @Nullable Object doIt() {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Deprecated\n\t@ComponentScan\n\tclass ForAnnotationsClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ValueAttribute {\n\n\t\tString[] value();\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueAttribute(\"FromValueAttributeMeta\")\n\t@interface ValueAttributeMeta {\n\n\t\t@AliasFor(\"alias\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] alias() default {};\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueAttributeMeta(\"FromValueAttributeMetaMeta\")\n\t@interface ValueAttributeMetaMeta {\n\t}\n\n\t@ValueAttributeMetaMeta\n\tstatic class ValueAttributeMetaMetaClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface StandardContainerWithMultipleAttributes {\n\n\t\tStandardRepeatableWithContainerWithMultipleAttributes[] value();\n\n\t\tString name() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(StandardContainerWithMultipleAttributes.class)\n\t@interface StandardRepeatableWithContainerWithMultipleAttributes {\n\n\t\tString value() default \"\";\n\t}\n\n\t@StandardRepeatableWithContainerWithMultipleAttributes(\"a\")\n\t@StandardRepeatableWithContainerWithMultipleAttributes(\"b\")\n\tstatic class StandardRepeatablesWithContainerWithMultipleAttributesTestCase {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.DerivedTxConfig",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.DerivedTxConfig",
    "headType": "class",
    "relation": "use",
    "tail": "@Transactional",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.DerivedTxConfig",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Set;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.ParametersAreNonnullByDefault;\nimport javax.annotation.meta.When;\n\nimport jakarta.annotation.Resource;\nimport org.jspecify.annotations.Nullable;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.annotation.AnnotationUtilsTests.ExtendsBaseClassWithGenericAnnotatedMethod;\nimport org.springframework.core.annotation.AnnotationUtilsTests.ImplementsInterfaceWithGenericAnnotatedMethod;\nimport org.springframework.core.annotation.AnnotationUtilsTests.WebController;\nimport org.springframework.core.annotation.AnnotationUtilsTests.WebMapping;\nimport org.springframework.core.testfixture.stereotype.Component;\nimport org.springframework.core.testfixture.stereotype.Indexed;\nimport org.springframework.util.MultiValueMap;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.Collectors.toSet;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.findAllMergedAnnotations;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.findMergedAnnotation;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getAllAnnotationAttributes;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getAllMergedAnnotations;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getMergedAnnotation;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getMergedAnnotationAttributes;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.getMetaAnnotationTypes;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.hasAnnotation;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.hasMetaAnnotationTypes;\nimport static org.springframework.core.annotation.AnnotatedElementUtils.isAnnotated;\nimport static org.springframework.core.annotation.AnnotationUtilsTests.asArray;\n\n/**\n * Tests for {@link AnnotatedElementUtils}.\n *\n * @author Sam Brannen\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 4.0.3\n * @see AnnotationUtilsTests\n * @see MultipleComposedAnnotationsOnSingleAnnotatedElementTests\n * @see ComposedRepeatableAnnotationsTests\n * @see NestedRepeatableAnnotationsTests\n */\nclass AnnotatedElementUtilsTests {\n\n\tprivate static final String TX_NAME = Transactional.class.getName();\n\n\n\t@Nested\n\tclass ConventionBasedAnnotationAttributeOverrideTests {\n\n\t\t@Test\n\t\tvoid getMergedAnnotationAttributesWithConventionBasedComposedAnnotation() {\n\t\t\tClass<?> element = ConventionBasedComposedContextConfigClass.class;\n\t\t\tString name = ContextConfig.class.getName();\n\t\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\n\t\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").containsExactly(\"explicitDeclaration\");\n\t\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").containsExactly(\"explicitDeclaration\");\n\n\t\t\t// Verify contracts between utility methods:\n\t\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t\t}\n\n\t\t/**\n\t\t * This test should never pass, simply because Spring does not support a hybrid\n\t\t * approach for annotation attribute overrides with transitive implicit aliases.\n\t\t * See SPR-13554 for details.\n\t\t * <p>Furthermore, if you choose to execute this test, it can fail for either\n\t\t * the first test class or the second one (with different exceptions), depending\n\t\t * on the order in which the JVM returns the attribute methods via reflection.\n\t\t */\n\t\t@Disabled(\"Permanently disabled but left in place for illustrative purposes\")\n\t\t@Test\n\t\tvoid getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation() {\n\t\t\tfor (Class<?> clazz : asList(HalfConventionBasedAndHalfAliasedComposedContextConfigClassV1.class,\n\t\t\t\t\tHalfConventionBasedAndHalfAliasedComposedContextConfigClassV2.class)) {\n\t\t\t\tgetMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation(clazz);\n\t\t\t}\n\t\t}\n\n\t\tprivate void getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation(Class<?> clazz) {\n\t\t\tString name = ContextConfig.class.getName();\n\t\t\tString simpleName = clazz.getSimpleName();\n\t\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(clazz, name);\n\n\t\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + simpleName).isNotNull();\n\t\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations for class [\" + simpleName + \"]\")\n\t\t\t\t.containsExactly(\"explicitDeclaration\");\n\t\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value for class [\" + simpleName + \"]\")\n\t\t\t\t.containsExactly(\"explicitDeclaration\");\n\n\t\t\t// Verify contracts between utility methods:\n\t\t\tassertThat(isAnnotated(clazz, name)).isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid getMergedAnnotationAttributesWithInvalidConventionBasedComposedAnnotation() {\n\t\t\tClass<?> element = InvalidConventionBasedComposedContextConfigClass.class;\n\t\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\t\tgetMergedAnnotationAttributes(element, ContextConfig.class))\n\t\t\t\t\t.withMessageContaining(\"Different @AliasFor mirror values for annotation\")\n\t\t\t\t\t.withMessageContaining(\"attribute 'locations' and its alias 'value'\")\n\t\t\t\t\t.withMessageContaining(\"values of [{requiredLocationsDeclaration}] and [{duplicateDeclaration}]\");\n\t\t}\n\n\t\t@Test\n\t\tvoid findMergedAnnotationAttributesWithSingleElementOverridingAnArrayViaConvention() {\n\t\t\tassertComponentScanAttributes(ConventionBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\n\t\t}\n\n\t\t@Test\n\t\tvoid findMergedAnnotationWithLocalAliasesThatConflictWithAttributesInMetaAnnotationByConvention() {\n\t\t\tClass<?> element = SpringAppConfigClass.class;\n\t\t\tContextConfig contextConfig = findMergedAnnotation(element, ContextConfig.class);\n\n\t\t\tassertThat(contextConfig).as(\"Should find @ContextConfig on \" + element).isNotNull();\n\t\t\tassertThat(contextConfig.locations()).as(\"locations for \" + element).isEmpty();\n\t\t\t// 'value' in @SpringAppConfig should not override 'value' in @ContextConfig\n\t\t\tassertThat(contextConfig.value()).as(\"value for \" + element).isEmpty();\n\t\t\tassertThat(contextConfig.classes()).as(\"classes for \" + element).containsExactly(Number.class);\n\t\t}\n\n\t\t@Test\n\t\tvoid findMergedAnnotationWithSingleElementOverridingAnArrayViaConvention() throws Exception {\n\t\t\tassertWebMapping(WebController.class.getMethod(\"postMappedWithPathAttribute\"));\n\t\t}\n\n\t}\n\n\n\t@Test\n\tvoid getMetaAnnotationTypesOnNonAnnotatedClass() {\n\t\tassertThat(getMetaAnnotationTypes(NonAnnotatedClass.class, TransactionalComponent.class)).isEmpty();\n\t\tassertThat(getMetaAnnotationTypes(NonAnnotatedClass.class, TransactionalComponent.class.getName())).isEmpty();\n\t}\n\n\t@Test\n\tvoid getMetaAnnotationTypesOnClassWithMetaDepth1() {\n\t\tSet<String> names = getMetaAnnotationTypes(TransactionalComponentClass.class, TransactionalComponent.class);\n\t\tassertThat(names).isEqualTo(names(Transactional.class, Component.class, Indexed.class));\n\n\t\tnames = getMetaAnnotationTypes(TransactionalComponentClass.class, TransactionalComponent.class.getName());\n\t\tassertThat(names).isEqualTo(names(Transactional.class, Component.class, Indexed.class));\n\t}\n\n\t@Test\n\tvoid getMetaAnnotationTypesOnClassWithMetaDepth2() {\n\t\tSet<String> names = getMetaAnnotationTypes(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class);\n\t\tassertThat(names).isEqualTo(names(TransactionalComponent.class, Transactional.class, Component.class, Indexed.class));\n\n\t\tnames = getMetaAnnotationTypes(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class.getName());\n\t\tassertThat(names).isEqualTo(names(TransactionalComponent.class, Transactional.class, Component.class, Indexed.class));\n\t}\n\n\tprivate Set<String> names(Class<?>... classes) {\n\t\treturn stream(classes).map(Class::getName).collect(toSet());\n\t}\n\n\t@Test\n\tvoid hasMetaAnnotationTypesOnNonAnnotatedClass() {\n\t\tassertThat(hasMetaAnnotationTypes(NonAnnotatedClass.class, TX_NAME)).isFalse();\n\t}\n\n\t@Test\n\tvoid hasMetaAnnotationTypesOnClassWithMetaDepth0() {\n\t\tassertThat(hasMetaAnnotationTypes(TransactionalComponentClass.class, TransactionalComponent.class.getName())).isFalse();\n\t}\n\n\t@Test\n\tvoid hasMetaAnnotationTypesOnClassWithMetaDepth1() {\n\t\tassertThat(hasMetaAnnotationTypes(TransactionalComponentClass.class, TX_NAME)).isTrue();\n\t\tassertThat(hasMetaAnnotationTypes(TransactionalComponentClass.class, Component.class.getName())).isTrue();\n\t}\n\n\t@Test\n\tvoid hasMetaAnnotationTypesOnClassWithMetaDepth2() {\n\t\tassertThat(hasMetaAnnotationTypes(ComposedTransactionalComponentClass.class, TX_NAME)).isTrue();\n\t\tassertThat(hasMetaAnnotationTypes(ComposedTransactionalComponentClass.class, Component.class.getName())).isTrue();\n\t\tassertThat(hasMetaAnnotationTypes(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class.getName())).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotatedOnNonAnnotatedClass() {\n\t\tassertThat(isAnnotated(NonAnnotatedClass.class, Transactional.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotatedOnClassWithMetaDepth() {\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, TransactionalComponent.class)).isTrue();\n\t\tassertThat(isAnnotated(SubTransactionalComponentClass.class, TransactionalComponent.class)).as(\"isAnnotated() does not search the class hierarchy.\").isFalse();\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, Transactional.class)).isTrue();\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, Component.class)).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, Transactional.class)).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, Component.class)).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class)).isTrue();\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid isAnnotatedForPlainTypes() {\n\t\tassertThat(isAnnotated(Order.class, Documented.class)).isTrue();\n\t\tassertThat(isAnnotated(org.springframework.lang.NonNullApi.class, Documented.class)).isTrue();\n\t\tassertThat(isAnnotated(org.springframework.lang.NonNullApi.class, Nonnull.class)).isTrue();\n\t\tassertThat(isAnnotated(ParametersAreNonnullByDefault.class, Nonnull.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isAnnotatedWithNameOnNonAnnotatedClass() {\n\t\tassertThat(isAnnotated(NonAnnotatedClass.class, TX_NAME)).isFalse();\n\t}\n\n\t@Test\n\tvoid isAnnotatedWithNameOnClassWithMetaDepth() {\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, TransactionalComponent.class.getName())).isTrue();\n\t\tassertThat(isAnnotated(SubTransactionalComponentClass.class, TransactionalComponent.class.getName())).as(\"isAnnotated() does not search the class hierarchy.\").isFalse();\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, TX_NAME)).isTrue();\n\t\tassertThat(isAnnotated(TransactionalComponentClass.class, Component.class.getName())).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, TX_NAME)).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, Component.class.getName())).isTrue();\n\t\tassertThat(isAnnotated(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class.getName())).isTrue();\n\t}\n\n\t@Test\n\tvoid hasAnnotationOnNonAnnotatedClass() {\n\t\tassertThat(hasAnnotation(NonAnnotatedClass.class, Transactional.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid hasAnnotationOnClassWithMetaDepth() {\n\t\tassertThat(hasAnnotation(TransactionalComponentClass.class, TransactionalComponent.class)).isTrue();\n\t\tassertThat(hasAnnotation(SubTransactionalComponentClass.class, TransactionalComponent.class)).isTrue();\n\t\tassertThat(hasAnnotation(TransactionalComponentClass.class, Transactional.class)).isTrue();\n\t\tassertThat(hasAnnotation(TransactionalComponentClass.class, Component.class)).isTrue();\n\t\tassertThat(hasAnnotation(ComposedTransactionalComponentClass.class, Transactional.class)).isTrue();\n\t\tassertThat(hasAnnotation(ComposedTransactionalComponentClass.class, Component.class)).isTrue();\n\t\tassertThat(hasAnnotation(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class)).isTrue();\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid hasAnnotationForPlainTypes() {\n\t\tassertThat(hasAnnotation(Order.class, Documented.class)).isTrue();\n\t\tassertThat(hasAnnotation(org.springframework.lang.NonNullApi.class, Documented.class)).isTrue();\n\t\tassertThat(hasAnnotation(org.springframework.lang.NonNullApi.class, Nonnull.class)).isTrue();\n\t\tassertThat(hasAnnotation(ParametersAreNonnullByDefault.class, Nonnull.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesOnNonAnnotatedClass() {\n\t\tassertThat(getAllAnnotationAttributes(NonAnnotatedClass.class, TX_NAME)).isNull();\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesOnClassWithLocalAnnotation() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxConfig.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on TxConfig\").isNotNull();\n\t\tassertThat(attributes.get(\"value\")).as(\"value for TxConfig\").isEqualTo(List.of(\"TxConfig\"));\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesOnClassWithLocalComposedAnnotationAndInheritedAnnotation() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(SubClassWithInheritedAnnotation.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on SubClassWithInheritedAnnotation\").isNotNull();\n\t\tassertThat(attributes.get(\"qualifier\")).isEqualTo(asList(\"composed2\", \"transactionManager\"));\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(SubSubClassWithInheritedAnnotation.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on SubSubClassWithInheritedAnnotation\").isNotNull();\n\t\tassertThat(attributes.get(\"qualifier\")).isEqualTo(List.of(\"transactionManager\"));\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes( SubSubClassWithInheritedComposedAnnotation.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on SubSubClassWithInheritedComposedAnnotation\").isNotNull();\n\t\tassertThat(attributes.get(\"qualifier\")).isEqualTo(List.of(\"composed1\"));\n\t}\n\n\t/**\n\t * If the \"value\" entry contains both \"DerivedTxConfig\" AND \"TxConfig\", then\n\t * the algorithm is accidentally picking up shadowed annotations of the same\n\t * type within the class hierarchy. Such undesirable behavior would cause the\n\t * logic in {@code org.springframework.context.annotation.ProfileCondition}\n\t * to fail.\n\t */\n\t@Test\n\tvoid getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\n\t\t// See org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on DerivedTxConfig\").isNotNull();\n\t\tassertThat(attributes.get(\"value\")).as(\"value for DerivedTxConfig\").isEqualTo(List.of(\"DerivedTxConfig\"));\n\t}\n\n\t/**\n\t * Note: this functionality is required by {@code org.springframework.context.annotation.ProfileCondition}.\n\t */\n\t@Test\n\tvoid getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {\n\t\t// See org.springframework.core.env.EnvironmentSystemIntegrationTests\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations\").isNotNull();\n\t\tassertThat(attributes.get(\"value\")).as(\"value for TxFromMultipleComposedAnnotations.\").isEqualTo(asList(\"TxInheritedComposed\", \"TxComposed\"));\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid getAllAnnotationAttributesOnLangType() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(\n\t\t\t\torg.springframework.lang.NonNullApi.class, Nonnull.class.getName());\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Nonnull on NonNullApi\").isNotNull();\n\t\tassertThat(attributes.get(\"when\")).as(\"value for NonNullApi\").isEqualTo(List.of(When.ALWAYS));\n\t}\n\n\t@Test\n\tvoid getAllAnnotationAttributesOnJavaxType() {\n\t\tMultiValueMap<String, Object> attributes = getAllAnnotationAttributes(\n\t\t\t\tParametersAreNonnullByDefault.class, Nonnull.class.getName());\n\t\tassertThat(attributes).as(\"Annotation attributes map for @Nonnull on NonNullApi\").isNotNull();\n\t\tassertThat(attributes.get(\"when\")).as(\"value for NonNullApi\").isEqualTo(List.of(When.ALWAYS));\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnClassWithLocalAnnotation() {\n\t\tClass<?> element = TxConfig.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Annotation attributes for @Transactional on TxConfig\").isNotNull();\n\t\tassertThat(attributes.getString(\"value\")).as(\"value for TxConfig\").isEqualTo(\"TxConfig\");\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\n\t\tClass<?> element = DerivedTxConfig.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Annotation attributes for @Transactional on DerivedTxConfig\").isNotNull();\n\t\tassertThat(attributes.getString(\"value\")).as(\"value for DerivedTxConfig\").isEqualTo(\"DerivedTxConfig\");\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(MetaCycleAnnotatedClass.class, TX_NAME);\n\t\tassertThat(attributes).as(\"Should not find annotation attributes for @Transactional on MetaCycleAnnotatedClass\").isNull();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesFavorsLocalComposedAnnotationOverInheritedAnnotation() {\n\t\tClass<?> element = SubClassWithInheritedAnnotation.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"AnnotationAttributes for @Transactional on SubClassWithInheritedAnnotation\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t\tassertThat(attributes.getBoolean(\"readOnly\")).as(\"readOnly flag for SubClassWithInheritedAnnotation.\").isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tClass<?> element = SubSubClassWithInheritedAnnotation.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"AnnotationAttributes for @Transactional on SubSubClassWithInheritedAnnotation\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t\tassertThat(attributes.getBoolean(\"readOnly\")).as(\"readOnly flag for SubSubClassWithInheritedAnnotation.\").isFalse();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tClass<?> element = SubSubClassWithInheritedComposedAnnotation.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"AnnotationAttributes for @Transactional on SubSubClassWithInheritedComposedAnnotation.\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t\tassertThat(attributes.getBoolean(\"readOnly\")).as(\"readOnly flag for SubSubClassWithInheritedComposedAnnotation.\").isFalse();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesFromInterfaceImplementedBySuperclass() {\n\t\tClass<?> element = ConcreteClassWithInheritedAnnotation.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Should not find @Transactional on ConcreteClassWithInheritedAnnotation\").isNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isFalse();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnInheritedAnnotationInterface() {\n\t\tClass<?> element = InheritedAnnotationInterface.class;\n\t\tString name = TX_NAME;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Should find @Transactional on InheritedAnnotationInterface\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesOnNonInheritedAnnotationInterface() {\n\t\tClass<?> element = NonInheritedAnnotationInterface.class;\n\t\tString name = Order.class.getName();\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tassertThat(attributes).as(\"Should find @Order on NonInheritedAnnotationInterface\").isNotNull();\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesWithAliasedComposedAnnotation() {\n\t\tClass<?> element = AliasedComposedContextConfigClass.class;\n\t\tString name = ContextConfig.class.getName();\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\n\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(asArray(\"test.xml\"));\n\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(asArray(\"test.xml\"));\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesWithAliasedValueComposedAnnotation() {\n\t\tClass<?> element = AliasedValueComposedContextConfigClass.class;\n\t\tString name = ContextConfig.class.getName();\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\n\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(asArray(\"test.xml\"));\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(asArray(\"test.xml\"));\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesWithImplicitAliasesInMetaAnnotationOnComposedAnnotation() {\n\t\tClass<?> element = ComposedImplicitAliasesContextConfigClass.class;\n\t\tString name = ImplicitAliasesContextConfig.class.getName();\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\n\t\tString[] expected = asArray(\"A.xml\", \"B.xml\");\n\n\t\tassertThat(attributes).as(\"Should find @ImplicitAliasesContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"groovyScripts\")).as(\"groovyScripts\").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"xmlFiles\")).as(\"xmlFiles\").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(expected);\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithAliasedValueComposedAnnotation() {\n\t\tassertGetMergedAnnotation(AliasedValueComposedContextConfigClass.class, \"test.xml\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithImplicitAliasesForSameAttributeInComposedAnnotation() {\n\t\tassertGetMergedAnnotation(ImplicitAliasesContextConfigClass1.class, \"foo.xml\");\n\t\tassertGetMergedAnnotation(ImplicitAliasesContextConfigClass2.class, \"bar.xml\");\n\t\tassertGetMergedAnnotation(ImplicitAliasesContextConfigClass3.class, \"baz.xml\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithTransitiveImplicitAliases() {\n\t\tassertGetMergedAnnotation(TransitiveImplicitAliasesContextConfigClass.class, \"test.groovy\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithTransitiveImplicitAliasesWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\tassertGetMergedAnnotation(SingleLocationTransitiveImplicitAliasesContextConfigClass.class, \"test.groovy\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithTransitiveImplicitAliasesWithSkippedLevel() {\n\t\tassertGetMergedAnnotation(TransitiveImplicitAliasesWithSkippedLevelContextConfigClass.class, \"test.xml\");\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithTransitiveImplicitAliasesWithSkippedLevelWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\tassertGetMergedAnnotation(SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigClass.class, \"test.xml\");\n\t}\n\n\tprivate void assertGetMergedAnnotation(Class<?> element, String... expected) {\n\t\tString name = ContextConfig.class.getName();\n\t\tContextConfig contextConfig = getMergedAnnotation(element, ContextConfig.class);\n\n\t\tassertThat(contextConfig).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(contextConfig.locations()).as(\"locations\").isEqualTo(expected);\n\t\tassertThat(contextConfig.value()).as(\"value\").isEqualTo(expected);\n\t\tObject[] expecteds = new Class<?>[0];\n\t\tassertThat(contextConfig.classes()).as(\"classes\").isEqualTo(expecteds);\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithImplicitAliasesInMetaAnnotationOnComposedAnnotation() {\n\t\tClass<?> element = ComposedImplicitAliasesContextConfigClass.class;\n\t\tString name = ImplicitAliasesContextConfig.class.getName();\n\t\tImplicitAliasesContextConfig config = getMergedAnnotation(element, ImplicitAliasesContextConfig.class);\n\t\tString[] expected = asArray(\"A.xml\", \"B.xml\");\n\n\t\tassertThat(config).as(\"Should find @ImplicitAliasesContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(config.groovyScripts()).as(\"groovyScripts\").isEqualTo(expected);\n\t\tassertThat(config.xmlFiles()).as(\"xmlFiles\").isEqualTo(expected);\n\t\tassertThat(config.locations()).as(\"locations\").isEqualTo(expected);\n\t\tassertThat(config.value()).as(\"value\").isEqualTo(expected);\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationWithImplicitAliasesWithDefaultsInMetaAnnotationOnComposedAnnotation() {\n\t\tClass<?> element = ImplicitAliasesWithDefaultsClass.class;\n\t\tString name = AliasesWithDefaults.class.getName();\n\t\tAliasesWithDefaults annotation = getMergedAnnotation(element, AliasesWithDefaults.class);\n\n\t\tassertThat(annotation).as(\"Should find @AliasesWithDefaults on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(annotation.a1()).as(\"a1\").isEqualTo(\"ImplicitAliasesWithDefaults\");\n\t\tassertThat(annotation.a2()).as(\"a2\").isEqualTo(\"ImplicitAliasesWithDefaults\");\n\n\t\t// Verify contracts between utility methods:\n\t\tassertThat(isAnnotated(element, name)).isTrue();\n\t}\n\n\t@Test\n\tvoid getMergedAnnotationAttributesWithShadowedAliasComposedAnnotation() {\n\t\tClass<?> element = ShadowedAliasComposedContextConfigClass.class;\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, ContextConfig.class);\n\n\t\tString[] expected = asArray(\"test.xml\");\n\n\t\tassertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(expected);\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(InheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on InheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnSubInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(SubInheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on SubInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnSubSubInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(SubSubInheritedAnnotationInterface.class, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on SubSubInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnNonInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(NonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on NonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnSubNonInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(SubNonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on SubNonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnSubSubNonInheritedAnnotationInterface() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(SubSubNonInheritedAnnotationInterface.class, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on SubSubNonInheritedAnnotationInterface\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesInheritedFromInterfaceMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleFromInterface\");\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(method, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on ConcreteClassWithInheritedAnnotation.handleFromInterface() method\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesInheritedFromAbstractMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handle\");\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on ConcreteClassWithInheritedAnnotation.handle() method\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleParameterized\", String.class);\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()\").isNotNull();\n\t}\n\n\t/**\n\t * Bridge/bridged method setup code copied from\n\t * {@link org.springframework.core.BridgeMethodResolverTests#withGenericParameter()}.\n\t * @since 4.2\n\t */\n\t@Test\n\tvoid findMergedAnnotationAttributesFromBridgeMethod() {\n\t\tMethod[] methods = StringGenericParameter.class.getMethods();\n\t\tMethod bridgeMethod = null;\n\t\tMethod bridgedMethod = null;\n\n\t\tfor (Method method : methods) {\n\t\t\tif (\"getFor\".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {\n\t\t\t\tif (method.getReturnType().equals(Object.class)) {\n\t\t\t\t\tbridgeMethod = method;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbridgedMethod = method;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\n\t\tboolean condition = bridgedMethod != null && !bridgedMethod.isBridge();\n\t\tassertThat(condition).isTrue();\n\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class);\n\t\tassertThat(attributes).as(\"Should find @Order on StringGenericParameter.getFor() bridge method\").isNotNull();\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnClassWithMetaAndLocalTxConfig() {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(MetaAndLocalTxConfigClass.class, Transactional.class);\n\t\tassertThat(attributes).as(\"Should find @Transactional on MetaAndLocalTxConfigClass\").isNotNull();\n\t\tassertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier for MetaAndLocalTxConfigClass.\").isEqualTo(\"localTxMgr\");\n\t}\n\n\t@Test\n\tvoid findAndSynthesizeAnnotationAttributesOnClassWithAttributeAliasesInTargetAnnotation() {\n\t\tString qualifier = \"aliasForQualifier\";\n\n\t\t// 1) Find and merge AnnotationAttributes from the annotation hierarchy\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(\n\t\t\t\tAliasedTransactionalComponentClass.class, AliasedTransactional.class);\n\t\tassertThat(attributes).as(\"@AliasedTransactional on AliasedTransactionalComponentClass.\").isNotNull();\n\n\t\t// 2) Synthesize the AnnotationAttributes back into the target annotation\n\t\tAliasedTransactional annotation = AnnotationUtils.synthesizeAnnotation(attributes,\n\t\t\t\tAliasedTransactional.class, AliasedTransactionalComponentClass.class);\n\t\tassertThat(annotation).isNotNull();\n\n\t\t// 3) Verify that the AnnotationAttributes and synthesized annotation are equivalent\n\t\tassertThat(attributes.getString(\"value\")).as(\"TX value via attributes.\").isEqualTo(qualifier);\n\t\tassertThat(annotation.value()).as(\"TX value via synthesized annotation.\").isEqualTo(qualifier);\n\t\tassertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier via attributes.\").isEqualTo(qualifier);\n\t\tassertThat(annotation.qualifier()).as(\"TX qualifier via synthesized annotation.\").isEqualTo(qualifier);\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesOnClassWithAttributeAliasInComposedAnnotationAndNestedAnnotationsInTargetAnnotation() {\n\t\tAnnotationAttributes attributes = assertComponentScanAttributes(TestComponentScanClass.class, \"com.example.app.test\");\n\n\t\tFilter[] excludeFilters = attributes.getAnnotationArray(\"excludeFilters\", Filter.class);\n\t\tassertThat(excludeFilters).isNotNull();\n\n\t\tList<String> patterns = stream(excludeFilters).map(Filter::pattern).collect(toList());\n\t\tassertThat(patterns).isEqualTo(asList(\"*Test\", \"*Tests\"));\n\t}\n\n\t/**\n\t * This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}\n\t * uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation\n\t * attributes since attributes may be arrays.\n\t */\n\t@Test\n\tvoid findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {\n\t\tassertComponentScanAttributes(ComponentScanWithBasePackagesAndValueAliasClass.class, \"com.example.app.test\");\n\t}\n\n\t/**\n\t * @since 5.2.1\n\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\n\t */\n\t@Test\n\tvoid findMergedAnnotationAttributesOnMethodWithComposedMetaTransactionalAnnotation() throws Exception {\n\t\tMethod method = getClass().getDeclaredMethod(\"composedTransactionalMethod\");\n\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(method, AliasedTransactional.class);\n\t\tassertThat(attributes).as(\"Should find @AliasedTransactional on \" + method).isNotNull();\n\t\tassertThat(attributes.getString(\"value\")).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t/**\n\t * @since 5.2.1\n\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\n\t */\n\t@Test\n\tvoid findMergedAnnotationOnMethodWithComposedMetaTransactionalAnnotation() throws Exception {\n\t\tMethod method = getClass().getDeclaredMethod(\"composedTransactionalMethod\");\n\n\t\tAliasedTransactional annotation = findMergedAnnotation(method, AliasedTransactional.class);\n\t\tassertThat(annotation).as(\"Should find @AliasedTransactional on \" + method).isNotNull();\n\t\tassertThat(annotation.value()).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(annotation.qualifier()).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t/**\n\t * @since 5.2.1\n\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\n\t */\n\t@Test\n\tvoid findMergedAnnotationAttributesOnClassWithComposedMetaTransactionalAnnotation() {\n\t\tClass<?> clazz = ComposedTransactionalClass.class;\n\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(clazz, AliasedTransactional.class);\n\t\tassertThat(attributes).as(\"Should find @AliasedTransactional on \" + clazz).isNotNull();\n\t\tassertThat(attributes.getString(\"value\")).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t/**\n\t * @since 5.2.1\n\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\n\t */\n\t@Test\n\tvoid findMergedAnnotationOnClassWithComposedMetaTransactionalAnnotation() {\n\t\tClass<?> clazz = ComposedTransactionalClass.class;\n\n\t\tAliasedTransactional annotation = findMergedAnnotation(clazz, AliasedTransactional.class);\n\t\tassertThat(annotation).as(\"Should find @AliasedTransactional on \" + clazz).isNotNull();\n\t\tassertThat(annotation.value()).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(annotation.qualifier()).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationAttributesWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\tassertComponentScanAttributes(AliasForBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\n\t}\n\n\tprivate AnnotationAttributes assertComponentScanAttributes(Class<?> element, String... expected) {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(element, ComponentScan.class);\n\n\t\tassertThat(attributes).as(\"Should find @ComponentScan on \" + element).isNotNull();\n\t\tassertThat(attributes.getStringArray(\"value\")).as(\"value: \").isEqualTo(expected);\n\t\tassertThat(attributes.getStringArray(\"basePackages\")).as(\"basePackages: \").isEqualTo(expected);\n\n\t\treturn attributes;\n\t}\n\n\tprivate AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element, Class<? extends Annotation> annotationType) {\n\t\treturn AnnotatedElementUtils.findMergedAnnotationAttributes(element, annotationType.getName(), false, false);\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationWithAttributeAliasesInTargetAnnotation() {\n\t\tClass<?> element = AliasedTransactionalComponentClass.class;\n\t\tAliasedTransactional annotation = findMergedAnnotation(element, AliasedTransactional.class);\n\t\tassertThat(annotation).as(\"@AliasedTransactional on \" + element).isNotNull();\n\t\tassertThat(annotation.value()).as(\"TX value via synthesized annotation.\").isEqualTo(\"aliasForQualifier\");\n\t\tassertThat(annotation.qualifier()).as(\"TX qualifier via synthesized annotation.\").isEqualTo(\"aliasForQualifier\");\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationForMultipleMetaAnnotationsWithClashingAttributeNames() {\n\t\tString[] xmlLocations = asArray(\"test.xml\");\n\t\tString[] propFiles = asArray(\"test.properties\");\n\n\t\tClass<?> element = AliasedComposedContextConfigAndTestPropSourceClass.class;\n\n\t\tContextConfig contextConfig = findMergedAnnotation(element, ContextConfig.class);\n\t\tassertThat(contextConfig).as(\"@ContextConfig on \" + element).isNotNull();\n\t\tassertThat(contextConfig.locations()).as(\"locations\").isEqualTo(xmlLocations);\n\t\tassertThat(contextConfig.value()).as(\"value\").isEqualTo(xmlLocations);\n\n\t\t// Synthesized annotation\n\t\tTestPropSource testPropSource = AnnotationUtils.findAnnotation(element, TestPropSource.class);\n\t\tassertThat(testPropSource.locations()).as(\"locations\").isEqualTo(propFiles);\n\t\tassertThat(testPropSource.value()).as(\"value\").isEqualTo(propFiles);\n\n\t\t// Merged annotation\n\t\ttestPropSource = findMergedAnnotation(element, TestPropSource.class);\n\t\tassertThat(testPropSource).as(\"@TestPropSource on \" + element).isNotNull();\n\t\tassertThat(testPropSource.locations()).as(\"locations\").isEqualTo(propFiles);\n\t\tassertThat(testPropSource.value()).as(\"value\").isEqualTo(propFiles);\n\t}\n\n\t@Test\n\tvoid findMergedAnnotationWithSingleElementOverridingAnArrayViaAliasFor() throws Exception {\n\t\tassertWebMapping(WebController.class.getMethod(\"getMappedWithValueAttribute\"));\n\t\tassertWebMapping(WebController.class.getMethod(\"getMappedWithPathAttribute\"));\n\t}\n\n\tprivate void assertWebMapping(AnnotatedElement element) {\n\t\tWebMapping webMapping = findMergedAnnotation(element, WebMapping.class);\n\t\tassertThat(webMapping).isNotNull();\n\t\tassertThat(webMapping.value()).as(\"value attribute: \").isEqualTo(asArray(\"/test\"));\n\t\tassertThat(webMapping.path()).as(\"path attribute: \").isEqualTo(asArray(\"/test\"));\n\t}\n\n\t@Test\n\tvoid javaLangAnnotationTypeViaFindMergedAnnotation() throws Exception {\n\t\tConstructor<?> deprecatedCtor = Date.class.getConstructor(String.class);\n\t\tassertThat(findMergedAnnotation(deprecatedCtor, Deprecated.class)).isEqualTo(deprecatedCtor.getAnnotation(Deprecated.class));\n\t\tassertThat(findMergedAnnotation(Date.class, Deprecated.class)).isEqualTo(Date.class.getAnnotation(Deprecated.class));\n\t}\n\n\t@Test\n\tvoid javaxAnnotationTypeViaFindMergedAnnotation() {\n\t\tassertThat(findMergedAnnotation(ResourceHolder.class, Resource.class)).isEqualTo(ResourceHolder.class.getAnnotation(Resource.class));\n\t\tassertThat(findMergedAnnotation(SpringAppConfigClass.class, Resource.class)).isEqualTo(SpringAppConfigClass.class.getAnnotation(Resource.class));\n\t}\n\n\t@Test\n\tvoid javaxMetaAnnotationTypeViaFindMergedAnnotation() {\n\t\tassertThat(findMergedAnnotation(ParametersAreNonnullByDefault.class, Nonnull.class)).isEqualTo(ParametersAreNonnullByDefault.class.getAnnotation(Nonnull.class));\n\t\tassertThat(findMergedAnnotation(ResourceHolder.class, Nonnull.class)).isEqualTo(ParametersAreNonnullByDefault.class.getAnnotation(Nonnull.class));\n\t}\n\n\t@Test\n\tvoid nullableAnnotationTypeViaFindMergedAnnotation() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tassertThat(findMergedAnnotation(method, Resource.class)).isEqualTo(method.getAnnotation(Resource.class));\n\t}\n\n\t@Test\n\tvoid getAllMergedAnnotationsOnClassWithInterface() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tSet<Transactional> allMergedAnnotations = getAllMergedAnnotations(method, Transactional.class);\n\t\tassertThat(allMergedAnnotations).isEmpty();\n\t}\n\n\t@Test\n\tvoid findAllMergedAnnotationsOnClassWithInterface() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tSet<Transactional> allMergedAnnotations = findAllMergedAnnotations(method, Transactional.class);\n\t\tassertThat(allMergedAnnotations).hasSize(1);\n\t}\n\n\t@Test  // SPR-16060\n\tvoid findMethodAnnotationFromGenericInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tOrder order = findMergedAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test  // SPR-17146\n\tvoid findMethodAnnotationFromGenericSuperclass() throws Exception {\n\t\tMethod method = ExtendsBaseClassWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tOrder order = findMergedAnnotation(method, Order.class);\n\t\tassertThat(order).isNotNull();\n\t}\n\n\t@Test // gh-22655\n\tvoid forAnnotationsCreatesCopyOfArrayOnEachCall() {\n\t\tAnnotatedElement element = AnnotatedElementUtils.forAnnotations(ForAnnotationsClass.class.getDeclaredAnnotations());\n\t\t// Trigger the NPE as originally reported in the bug\n\t\tAnnotationsScanner.getDeclaredAnnotations(element, false);\n\t\tAnnotationsScanner.getDeclaredAnnotations(element, false);\n\t\t// Also specifically test we get different instances\n\t\tassertThat(element.getDeclaredAnnotations()).isNotSameAs(element.getDeclaredAnnotations());\n\t}\n\n\t@Test // gh-22703\n\tvoid getMergedAnnotationOnThreeDeepMetaWithValue() {\n\t\tValueAttribute annotation = AnnotatedElementUtils.getMergedAnnotation(\n\t\t\t\tValueAttributeMetaMetaClass.class, ValueAttribute.class);\n\t\tassertThat(annotation.value()).containsExactly(\"FromValueAttributeMeta\");\n\t}\n\n\t/**\n\t * @since 5.3.25\n\t */\n\t@Test // gh-29685\n\tvoid getMergedRepeatableAnnotationsWithContainerWithMultipleAttributes() {\n\t\tSet<StandardRepeatableWithContainerWithMultipleAttributes> repeatableAnnotations =\n\t\t\t\tAnnotatedElementUtils.getMergedRepeatableAnnotations(\n\t\t\t\t\t\tStandardRepeatablesWithContainerWithMultipleAttributesTestCase.class,\n\t\t\t\t\t\tStandardRepeatableWithContainerWithMultipleAttributes.class);\n\t\tassertThat(repeatableAnnotations).map(StandardRepeatableWithContainerWithMultipleAttributes::value)\n\t\t\t\t.containsExactly(\"a\", \"b\");\n\t}\n\n\t/**\n\t * @since 5.3.25\n\t */\n\t@Test // gh-29685\n\tvoid findMergedRepeatableAnnotationsWithContainerWithMultipleAttributes() {\n\t\tSet<StandardRepeatableWithContainerWithMultipleAttributes> repeatableAnnotations =\n\t\t\t\tAnnotatedElementUtils.findMergedRepeatableAnnotations(\n\t\t\t\t\t\tStandardRepeatablesWithContainerWithMultipleAttributesTestCase.class,\n\t\t\t\t\t\tStandardRepeatableWithContainerWithMultipleAttributes.class);\n\t\tassertThat(repeatableAnnotations).map(StandardRepeatableWithContainerWithMultipleAttributes::value)\n\t\t\t\t.containsExactly(\"a\", \"b\");\n\t}\n\n\t// -------------------------------------------------------------------------\n\n\t@MetaCycle3\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.ANNOTATION_TYPE)\n\t@interface MetaCycle1 {\n\t}\n\n\t@MetaCycle1\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.ANNOTATION_TYPE)\n\t@interface MetaCycle2 {\n\t}\n\n\t@MetaCycle2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface MetaCycle3 {\n\t}\n\n\t@MetaCycle3\n\tstatic class MetaCycleAnnotatedClass {\n\t}\n\n\t// -------------------------------------------------------------------------\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Inherited\n\t@interface Transactional {\n\n\t\tString value() default \"\";\n\n\t\tString qualifier() default \"transactionManager\";\n\n\t\tboolean readOnly() default false;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Inherited\n\t@interface AliasedTransactional {\n\n\t\t@AliasFor(\"qualifier\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString qualifier() default \"\";\n\t}\n\n\t@AliasedTransactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@interface MyAliasedTransactional {\n\n\t\t@AliasFor(annotation = AliasedTransactional.class, attribute = \"value\")\n\t\tString value() default \"defaultTransactionManager\";\n\t}\n\n\t@MyAliasedTransactional(\"anotherTransactionManager\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@interface ComposedMyAliasedTransactional {\n\t}\n\n\t@Transactional(qualifier = \"composed1\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@Inherited\n\t@interface InheritedComposed {\n\t}\n\n\t@Transactional(qualifier = \"composed2\", readOnly = true)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface Composed {\n\t}\n\n\t@Transactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxComposedWithOverride {\n\n\t\tString qualifier() default \"txMgr\";\n\t}\n\n\t@Transactional(\"TxInheritedComposed\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxInheritedComposed {\n\t}\n\n\t@Transactional(\"TxComposed\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxComposed {\n\t}\n\n\t@Transactional\n\t@Component\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransactionalComponent {\n\t}\n\n\t@TransactionalComponent\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedTransactionalComponent {\n\t}\n\n\t@AliasedTransactional(value = \"aliasForQualifier\")\n\t@Component\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedTransactionalComponent {\n\t}\n\n\t@TxComposedWithOverride\n\t// Override default \"txMgr\" from @TxComposedWithOverride with \"localTxMgr\"\n\t@Transactional(qualifier = \"localTxMgr\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface MetaAndLocalTxConfig {\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.test.context.TestPropertySource}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestPropSource {\n\n\t\t@AliasFor(\"locations\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] locations() default {};\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.test.context.ContextConfiguration}.\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContextConfig {\n\n\t\t@AliasFor(\"locations\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] locations() default {};\n\n\t\tClass<?>[] classes() default {};\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionBasedComposedContextConfig {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfig.class)\n\t\tString[] locations() default {};\n\t}\n\n\t@ContextConfig(value = \"duplicateDeclaration\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface InvalidConventionBasedComposedContextConfig {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfig.class)\n\t\tString[] locations();\n\t}\n\n\t/**\n\t * This hybrid approach for annotation attribute overrides with transitive implicit\n\t * aliases is unsupported. See SPR-13554 for details.\n\t */\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface HalfConventionBasedAndHalfAliasedComposedContextConfig {\n\n\t\tString[] locations() default {};\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles() default {};\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles();\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedValueComposedContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"value\")\n\t\tString[] locations();\n\t}\n\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] groovyScripts() default {};\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlFiles() default {};\n\n\t\t// intentionally omitted: attribute = \"locations\"\n\t\t@AliasFor(annotation = ContextConfig.class)\n\t\tString[] locations() default {};\n\n\t\t// intentionally omitted: attribute = \"locations\" (SPR-14069)\n\t\t@AliasFor(annotation = ContextConfig.class)\n\t\tString[] value() default {};\n\t}\n\n\t@ImplicitAliasesContextConfig(xmlFiles = {\"A.xml\", \"B.xml\"})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedImplicitAliasesContextConfig {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasesWithDefaults {\n\n\t\t@AliasFor(\"a2\")\n\t\tString a1() default \"AliasesWithDefaults\";\n\n\t\t@AliasFor(\"a1\")\n\t\tString a2() default \"AliasesWithDefaults\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@AliasesWithDefaults\n\t@interface ImplicitAliasesWithDefaults {\n\n\t\t@AliasFor(annotation = AliasesWithDefaults.class, attribute = \"a1\")\n\t\tString b1() default \"ImplicitAliasesWithDefaults\";\n\n\t\t@AliasFor(annotation = AliasesWithDefaults.class, attribute = \"a2\")\n\t\tString b2() default \"ImplicitAliasesWithDefaults\";\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"xmlFiles\")\n\t\tString[] xml() default {};\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScripts\")\n\t\tString[] groovy() default {};\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SingleLocationTransitiveImplicitAliasesContextConfig {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"xmlFiles\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScripts\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesWithSkippedLevelContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xml() default {};\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScripts\")\n\t\tString[] groovy() default {};\n\t}\n\n\t@ImplicitAliasesContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScripts\")\n\t\tString groovy() default \"\";\n\t}\n\n\t/**\n\t * Although the configuration declares an explicit value for 'value' and\n\t * requires a value for the aliased 'locations', this does not result in\n\t * an error since 'locations' effectively <em>shadows</em> the 'value'\n\t * attribute (which cannot be set via the composed annotation anyway).\n\t *\n\t * If 'value' were not shadowed, such a declaration would not make sense.\n\t */\n\t@ContextConfig(value = \"duplicateDeclaration\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ShadowedAliasComposedContextConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles();\n\t}\n\n\t@ContextConfig(locations = \"shadowed.xml\")\n\t@TestPropSource(locations = \"test.properties\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfigAndTestPropSource {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles() default \"default.xml\";\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.boot.test.SpringApplicationConfiguration}.\n\t */\n\t@ContextConfig\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SpringAppConfig {\n\n\t\t@AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\n\t\tString[] locations() default {};\n\n\t\t// Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfig.class, attribute = \"classes\")\n\t\t@AliasFor(\"value\")\n\t\tClass<?>[] classes() default {};\n\n\t\t// Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfig.class, attribute = \"classes\")\n\t\t@AliasFor(\"classes\")\n\t\tClass<?>[] value() default {};\n\t}\n\n\t/**\n\t * Mock of {@code org.springframework.context.annotation.ComponentScan}\n\t */\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScan {\n\n\t\t@AliasFor(\"basePackages\")\n\t\tString[] value() default {};\n\n\t\t// Intentionally no alias declaration for \"value\"\n\t\tString[] basePackages() default {};\n\n\t\tFilter[] excludeFilters() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({})\n\t@interface Filter {\n\n\t\tString pattern();\n\t}\n\n\t@ComponentScan(excludeFilters = {@Filter(pattern = \"*Test\"), @Filter(pattern = \"*Tests\")})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestComponentScan {\n\n\t\t@AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\n\t\tString[] packages();\n\t}\n\n\t@ComponentScan\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionBasedSinglePackageComponentScan {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ComponentScan.class)\n\t\tString basePackages();\n\t}\n\n\t@ComponentScan\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForBasedSinglePackageComponentScan {\n\n\t\t@AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\n\t\tString pkg();\n\t}\n\n\t// -------------------------------------------------------------------------\n\n\tstatic class NonAnnotatedClass {\n\t}\n\n\t@TransactionalComponent\n\tstatic class TransactionalComponentClass {\n\t}\n\n\tstatic class SubTransactionalComponentClass extends TransactionalComponentClass {\n\t}\n\n\t@ComposedTransactionalComponent\n\tstatic class ComposedTransactionalComponentClass {\n\t}\n\n\t@AliasedTransactionalComponent\n\tstatic class AliasedTransactionalComponentClass {\n\t}\n\n\t@ComposedMyAliasedTransactional\n\tvoid composedTransactionalMethod() {\n\t}\n\n\t@ComposedMyAliasedTransactional\n\tstatic class ComposedTransactionalClass {\n\t}\n\n\t@Transactional\n\tstatic class ClassWithInheritedAnnotation {\n\t}\n\n\t@Composed\n\tstatic class SubClassWithInheritedAnnotation extends ClassWithInheritedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedAnnotation extends SubClassWithInheritedAnnotation {\n\t}\n\n\t@InheritedComposed\n\tstatic class ClassWithInheritedComposedAnnotation {\n\t}\n\n\t@Composed\n\tstatic class SubClassWithInheritedComposedAnnotation extends ClassWithInheritedComposedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedComposedAnnotation extends SubClassWithInheritedComposedAnnotation {\n\t}\n\n\t@MetaAndLocalTxConfig\n\tstatic class MetaAndLocalTxConfigClass {\n\t}\n\n\t@Transactional(\"TxConfig\")\n\tstatic class TxConfig {\n\t}\n\n\t@Transactional(\"DerivedTxConfig\")\n\tstatic class DerivedTxConfig extends TxConfig {\n\t}\n\n\t@TxInheritedComposed\n\t@TxComposed\n\tstatic class TxFromMultipleComposedAnnotations {\n\t}\n\n\t@Transactional\n\tinterface InterfaceWithInheritedAnnotation {\n\n\t\t@Order\n\t\tvoid handleFromInterface();\n\t}\n\n\tabstract static class AbstractClassWithInheritedAnnotation<T> implements InterfaceWithInheritedAnnotation {\n\n\t\t@Transactional\n\t\tpublic abstract void handle();\n\n\t\t@Transactional\n\t\tpublic void handleParameterized(T t) {\n\t\t}\n\t}\n\n\tstatic class ConcreteClassWithInheritedAnnotation extends AbstractClassWithInheritedAnnotation<String> {\n\n\t\t@Override\n\t\tpublic void handle() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleParameterized(String s) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleFromInterface() {\n\t\t}\n\t}\n\n\tpublic interface GenericParameter<T> {\n\n\t\tT getFor(Class<T> cls);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class StringGenericParameter implements GenericParameter<String> {\n\n\t\t@Order\n\t\t@Override\n\t\tpublic String getFor(Class<String> cls) {\n\t\t\treturn \"foo\";\n\t\t}\n\n\t\tpublic String getFor(Integer integer) {\n\t\t\treturn \"foo\";\n\t\t}\n\t}\n\n\t@Transactional\n\tpublic interface InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubInheritedAnnotationInterface extends InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubInheritedAnnotationInterface extends SubInheritedAnnotationInterface {\n\t}\n\n\t@Order\n\tpublic interface NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubNonInheritedAnnotationInterface extends NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubNonInheritedAnnotationInterface extends SubNonInheritedAnnotationInterface {\n\t}\n\n\t@ConventionBasedComposedContextConfig(locations = \"explicitDeclaration\")\n\tstatic class ConventionBasedComposedContextConfigClass {\n\t}\n\n\t@InvalidConventionBasedComposedContextConfig(locations = \"requiredLocationsDeclaration\")\n\tstatic class InvalidConventionBasedComposedContextConfigClass {\n\t}\n\n\t@HalfConventionBasedAndHalfAliasedComposedContextConfig(xmlConfigFiles = \"explicitDeclaration\")\n\tstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigClassV1 {\n\t}\n\n\t@HalfConventionBasedAndHalfAliasedComposedContextConfig(locations = \"explicitDeclaration\")\n\tstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigClassV2 {\n\t}\n\n\t@AliasedComposedContextConfig(xmlConfigFiles = \"test.xml\")\n\tstatic class AliasedComposedContextConfigClass {\n\t}\n\n\t@AliasedValueComposedContextConfig(locations = \"test.xml\")\n\tstatic class AliasedValueComposedContextConfigClass {\n\t}\n\n\t@ImplicitAliasesContextConfig(\"foo.xml\")\n\tstatic class ImplicitAliasesContextConfigClass1 {\n\t}\n\n\t@ImplicitAliasesContextConfig(locations = \"bar.xml\")\n\tstatic class ImplicitAliasesContextConfigClass2 {\n\t}\n\n\t@ImplicitAliasesContextConfig(xmlFiles = \"baz.xml\")\n\tstatic class ImplicitAliasesContextConfigClass3 {\n\t}\n\n\t@ImplicitAliasesWithDefaults\n\tstatic class ImplicitAliasesWithDefaultsClass {\n\t}\n\n\t@TransitiveImplicitAliasesContextConfig(groovy = \"test.groovy\")\n\tstatic class TransitiveImplicitAliasesContextConfigClass {\n\t}\n\n\t@SingleLocationTransitiveImplicitAliasesContextConfig(groovy = \"test.groovy\")\n\tstatic class SingleLocationTransitiveImplicitAliasesContextConfigClass {\n\t}\n\n\t@TransitiveImplicitAliasesWithSkippedLevelContextConfig(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesWithSkippedLevelContextConfigClass {\n\t}\n\n\t@SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfig(xml = \"test.xml\")\n\tstatic class SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigClass {\n\t}\n\n\t@ComposedImplicitAliasesContextConfig\n\tstatic class ComposedImplicitAliasesContextConfigClass {\n\t}\n\n\t@ShadowedAliasComposedContextConfig(xmlConfigFiles = \"test.xml\")\n\tstatic class ShadowedAliasComposedContextConfigClass {\n\t}\n\n\t@AliasedComposedContextConfigAndTestPropSource(xmlConfigFiles = \"test.xml\")\n\tstatic class AliasedComposedContextConfigAndTestPropSourceClass {\n\t}\n\n\t@ComponentScan(value = \"com.example.app.test\", basePackages = \"com.example.app.test\")\n\tstatic class ComponentScanWithBasePackagesAndValueAliasClass {\n\t}\n\n\t@TestComponentScan(packages = \"com.example.app.test\")\n\tstatic class TestComponentScanClass {\n\t}\n\n\t@ConventionBasedSinglePackageComponentScan(basePackages = \"com.example.app.test\")\n\tstatic class ConventionBasedSinglePackageComponentScanClass {\n\t}\n\n\t@AliasForBasedSinglePackageComponentScan(pkg = \"com.example.app.test\")\n\tstatic class AliasForBasedSinglePackageComponentScanClass {\n\t}\n\n\t@SpringAppConfig(Number.class)\n\tstatic class SpringAppConfigClass {\n\t}\n\n\t@Resource(name = \"x\")\n\t@ParametersAreNonnullByDefault\n\tstatic class ResourceHolder {\n\t}\n\n\tinterface TransactionalService {\n\n\t\t@Transactional\n\t\t@Nullable Object doIt();\n\t}\n\n\tclass TransactionalServiceImpl implements TransactionalService {\n\n\t\t@Override\n\t\tpublic @Nullable Object doIt() {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Deprecated\n\t@ComponentScan\n\tclass ForAnnotationsClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ValueAttribute {\n\n\t\tString[] value();\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueAttribute(\"FromValueAttributeMeta\")\n\t@interface ValueAttributeMeta {\n\n\t\t@AliasFor(\"alias\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] alias() default {};\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueAttributeMeta(\"FromValueAttributeMetaMeta\")\n\t@interface ValueAttributeMetaMeta {\n\t}\n\n\t@ValueAttributeMetaMeta\n\tstatic class ValueAttributeMetaMetaClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface StandardContainerWithMultipleAttributes {\n\n\t\tStandardRepeatableWithContainerWithMultipleAttributes[] value();\n\n\t\tString name() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Repeatable(StandardContainerWithMultipleAttributes.class)\n\t@interface StandardRepeatableWithContainerWithMultipleAttributes {\n\n\t\tString value() default \"\";\n\t}\n\n\t@StandardRepeatableWithContainerWithMultipleAttributes(\"a\")\n\t@StandardRepeatableWithContainerWithMultipleAttributes(\"b\")\n\tstatic class StandardRepeatablesWithContainerWithMultipleAttributesTestCase {\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation.DerivedTxConfig",
    "headType": "class",
    "relation": "extend",
    "tail": "TxConfig",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.TxFromMultipleComposedAnnotations",
    "tailType": "class"
  }
]