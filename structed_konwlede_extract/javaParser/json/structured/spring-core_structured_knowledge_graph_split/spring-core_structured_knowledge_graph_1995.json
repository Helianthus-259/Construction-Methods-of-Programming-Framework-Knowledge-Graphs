[
  {
    "head": "org.springframework.core.ListOfListSupplier",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.ListOfListSupplier#get()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.StringListOfListSupplier",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.StringListOfListSupplier",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.springframework.core.GenericTypeResolver.getTypeVariableMap;\nimport static org.springframework.core.GenericTypeResolver.resolveReturnTypeArgument;\nimport static org.springframework.core.GenericTypeResolver.resolveType;\nimport static org.springframework.core.GenericTypeResolver.resolveTypeArgument;\nimport static org.springframework.util.ReflectionUtils.findMethod;\n\n/**\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Sebastien Deleuze\n * @author Stephane Nicoll\n * @author Yanming Zhou\n */\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\nclass GenericTypeResolverTests {\n\n\t@Test\n\tvoid simpleInterfaceType() {\n\t\tassertThat(resolveTypeArgument(MySimpleInterfaceType.class, MyInterfaceType.class)).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid simpleCollectionInterfaceType() {\n\t\tassertThat(resolveTypeArgument(MyCollectionInterfaceType.class, MyInterfaceType.class)).isEqualTo(Collection.class);\n\t}\n\n\t@Test\n\tvoid simpleSuperclassType() {\n\t\tassertThat(resolveTypeArgument(MySimpleSuperclassType.class, MySuperclassType.class)).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid simpleCollectionSuperclassType() {\n\t\tassertThat(resolveTypeArgument(MyCollectionSuperclassType.class, MySuperclassType.class)).isEqualTo(Collection.class);\n\t}\n\n\t@Test\n\tvoid nullIfNotResolvable() {\n\t\tGenericClass<String> obj = new GenericClass<>();\n\t\tassertThat(resolveTypeArgument(obj.getClass(), GenericClass.class)).isNull();\n\t}\n\n\t@Test\n\tvoid methodReturnTypes() {\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"integer\"), MyInterfaceType.class)).isEqualTo(Integer.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"string\"), MyInterfaceType.class)).isEqualTo(String.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"character\"), MyAbstractType.class)).isEqualTo(Character.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"raw\"), MyInterfaceType.class)).isNull();\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"object\"), MyInterfaceType.class)).isNull();\n\t}\n\n\t@Test\n\tvoid testResolveType() {\n\t\tMethod intMessageMethod = method(MyTypeWithMethods.class, \"readIntegerInputMessage\", MyInterfaceType.class);\n\t\tMethodParameter intMessageMethodParam = new MethodParameter(intMessageMethod, 0);\n\t\tassertThat(resolveType(intMessageMethodParam.getGenericParameterType(), new HashMap<>())).isEqualTo(MyInterfaceType.class);\n\n\t\tMethod intArrMessageMethod = method(MyTypeWithMethods.class, \"readIntegerArrayInputMessage\",\n\t\t\t\tMyInterfaceType[].class);\n\t\tMethodParameter intArrMessageMethodParam = new MethodParameter(intArrMessageMethod, 0);\n\t\tassertThat(resolveType(intArrMessageMethodParam.getGenericParameterType(), new HashMap<>())).isEqualTo(MyInterfaceType[].class);\n\n\t\tMethod genericArrMessageMethod = method(MySimpleTypeWithMethods.class, \"readGenericArrayInputMessage\",\n\t\t\t\tObject[].class);\n\t\tMethodParameter genericArrMessageMethodParam = new MethodParameter(genericArrMessageMethod, 0);\n\t\tMap<TypeVariable, Type> varMap = getTypeVariableMap(MySimpleTypeWithMethods.class);\n\t\tassertThat(resolveType(genericArrMessageMethodParam.getGenericParameterType(), varMap)).isEqualTo(Integer[].class);\n\t}\n\n\t@Test\n\tvoid boundParameterizedType() {\n\t\tassertThat(resolveTypeArgument(TestImpl.class, TestIfc.class)).isEqualTo(B.class);\n\t}\n\n\t@Test\n\tvoid testGetTypeVariableMap() {\n\t\tMap<TypeVariable, Type> map;\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MySimpleInterfaceType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.String}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MyCollectionInterfaceType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=java.util.Collection<java.lang.String>}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MyCollectionSuperclassType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=java.util.Collection<java.lang.String>}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MySimpleTypeWithMethods.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.Integer}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TopLevelClass.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TypedTopLevelClass.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.Integer}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TypedTopLevelClass.TypedNested.class);\n\t\tassertThat(map).hasSize(2);\n\t\tType t = null;\n\t\tType x = null;\n\t\tfor (Map.Entry<TypeVariable, Type> entry : map.entrySet()) {\n\t\t\tif (entry.getKey().toString().equals(\"T\")) {\n\t\t\t\tt = entry.getValue();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = entry.getValue();\n\t\t\t}\n\t\t}\n\t\tassertThat(t).isEqualTo(Integer.class);\n\t\tassertThat(x).isEqualTo(Long.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeArgumentsOfAbstractType() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(MyConcreteType.class, MyAbstractType.class);\n\t\tassertThat(resolved).containsExactly(Character.class);\n\t}\n\n\t@Test  // SPR-11030\n\tvoid getGenericsCannotBeResolved() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(List.class, Iterable.class);\n\t\tassertThat(resolved).isNull();\n\t}\n\n\t@Test  // SPR-11052\n\tvoid getRawMapTypeCannotBeResolved() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(Map.class, Map.class);\n\t\tassertThat(resolved).isNull();\n\t}\n\n\t@Test  // SPR-11044\n\t@SuppressWarnings(\"deprecation\")\n\tvoid getGenericsOnArrayFromParamCannotBeResolved() throws Exception {\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(\n\t\t\t\tWithArrayBase.class.getDeclaredMethod(\"array\", Object[].class), 0);\n\t\tClass<?> resolved = GenericTypeResolver.resolveParameterType(methodParameter, WithArray.class);\n\t\tassertThat(resolved).isEqualTo(Object[].class);\n\t}\n\n\t@Test  // SPR-11044\n\tvoid getGenericsOnArrayFromReturnCannotBeResolved() throws Exception {\n\t\tClass<?> resolved = GenericTypeResolver.resolveReturnType(\n\t\t\t\tWithArrayBase.class.getDeclaredMethod(\"array\", Object[].class), WithArray.class);\n\t\tassertThat(resolved).isEqualTo(Object[].class);\n\t}\n\n\t@Test  // SPR-11763\n\tvoid resolveIncompleteTypeVariables() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(IdFixingRepository.class, Repository.class);\n\t\tassertThat(resolved).isNotNull();\n\t\tassertThat(resolved).hasSize(2);\n\t\tassertThat(resolved[0]).isEqualTo(Object.class);\n\t\tassertThat(resolved[1]).isEqualTo(Long.class);\n\t}\n\n\t@Test\n\tvoid resolvePartiallySpecializedTypeVariables() {\n\t\tType resolved = resolveType(BiGenericClass.class.getTypeParameters()[0], TypeFixedBiGenericClass.class);\n\t\tassertThat(resolved).isEqualTo(D.class);\n\t}\n\n\t@Test\n\tvoid resolveTransitiveTypeVariableWithDifferentName() {\n\t\tType resolved = resolveType(BiGenericClass.class.getTypeParameters()[1], TypeFixedBiGenericClass.class);\n\t\tassertThat(resolved).isEqualTo(E.class);\n\t}\n\n\t@Test\n\tvoid resolveMethodParameterWithNestedGenerics() {\n\t\tMethod method = method(WithMethodParameter.class, \"nestedGenerics\", List.class);\n\t\tMethodParameter methodParameter = new MethodParameter(method, 0);\n\t\tType resolvedType = resolveType(methodParameter.getGenericParameterType(), WithMethodParameter.class);\n\t\tParameterizedTypeReference<List<Map<String, Integer>>> reference = new ParameterizedTypeReference<>() {};\n\t\tassertThat(resolvedType).isEqualTo(reference.getType());\n\t}\n\n\t@Test\n\tvoid resolveNestedTypeVariable() throws Exception {\n\t\tType resolved = resolveType(ListOfListSupplier.class.getMethod(\"get\").getGenericReturnType(),\n\t\t\t\tStringListOfListSupplier.class);\n\t\tassertThat(ResolvableType.forType(resolved).getGeneric(0).getGeneric(0).resolve()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeWithElementBounds() {\n\t\tType type = method(WithElementBounds.class, \"get\").getGenericReturnType();\n\t\tType resolvedType = resolveType(type, WithElementBounds.class);\n\t\tParameterizedTypeReference<List<A>> reference = new ParameterizedTypeReference<>() {};\n\t\tassertThat(resolvedType).isEqualTo(reference.getType());\n\t}\n\n\t@Test\n\tvoid resolveTypeWithUnresolvableElement() {\n\t\tType type = method(WithUnresolvableElement.class, \"get\").getGenericReturnType();\n\t\tType resolvedType = resolveType(type, WithUnresolvableElement.class);\n\t\tassertThat(resolvedType.toString()).isEqualTo(\"java.util.List<E>\");\n\t}\n\n\tprivate static Method method(Class<?> target, String methodName, Class<?>... parameterTypes) {\n\t\tMethod method = findMethod(target, methodName, parameterTypes);\n\t\tassertThat(method).describedAs(target.getName() + \"#\" + methodName).isNotNull();\n\t\treturn method;\n\t}\n\n\n\tpublic interface MyInterfaceType<T> {\n\t}\n\n\tpublic class MySimpleInterfaceType implements MyInterfaceType<String> {\n\t}\n\n\tpublic class MyCollectionInterfaceType implements MyInterfaceType<Collection<String>> {\n\t}\n\n\tpublic abstract class MyAbstractType<T> implements MyInterfaceType<T> {\n\t}\n\n\tpublic class MyConcreteType extends MyAbstractType<Character> {\n\t}\n\n\tpublic abstract class MySuperclassType<T> {\n\t}\n\n\tpublic class MySimpleSuperclassType extends MySuperclassType<String> {\n\t}\n\n\tpublic class MyCollectionSuperclassType extends MySuperclassType<Collection<String>> {\n\t}\n\n\tpublic static class MyTypeWithMethods<T> {\n\n\t\tpublic MyInterfaceType<Integer> integer() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MySimpleInterfaceType string() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MyConcreteType character() { return null; }\n\n\t\tpublic Object object() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MyInterfaceType raw() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic String notParameterized() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic String notParameterizedWithArguments(Integer x, Boolean b) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Simulates a factory method that wraps the supplied object in a proxy of the\n\t\t * same type.\n\t\t */\n\t\tpublic static <T> T createProxy(T object) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createProxy(Object)} but adds an additional argument before\n\t\t * the argument of type {@code T}. Note that they may potentially be of the same\n\t\t * time when invoked!\n\t\t */\n\t\tpublic static <T> T createNamedProxy(String name, T object) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Simulates factory methods found in libraries such as Mockito and EasyMock.\n\t\t */\n\t\tpublic static <MOCK> MOCK createMock(Class<MOCK> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createMock(Class)} but adds an additional method argument\n\t\t * before the parameterized argument.\n\t\t */\n\t\tpublic static <T> T createNamedMock(String name, Class<T> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createNamedMock(String, Class)} but adds an additional\n\t\t * parameterized type.\n\t\t */\n\t\tpublic static <V extends Object, T> T createVMock(V name, Class<T> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Extract some value of the type supported by the interface (i.e., by a concrete,\n\t\t * non-generic implementation of the interface).\n\t\t */\n\t\tpublic static <T> T extractValueFrom(MyInterfaceType<T> myInterfaceType) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Extract some magic value from the supplied map.\n\t\t */\n\t\tpublic static <K, V> V extractMagicValue(Map<K, V> map) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void readIntegerInputMessage(MyInterfaceType<Integer> message) {\n\t\t}\n\n\t\tpublic void readIntegerArrayInputMessage(MyInterfaceType<Integer>[] message) {\n\t\t}\n\n\t\tpublic void readGenericArrayInputMessage(T[] message) {\n\t\t}\n\t}\n\n\tpublic static class MySimpleTypeWithMethods extends MyTypeWithMethods<Integer> {\n\t}\n\n\tstatic class GenericClass<T> {\n\t}\n\n\tclass A {}\n\n\tclass B<T> {}\n\n\tclass C extends A {}\n\n\tclass D extends B<Long> {}\n\n\tclass E extends C {}\n\n\tclass TestIfc<T> {}\n\n\tclass TestImpl<I extends A, T extends B<I>> extends TestIfc<T> {\n\t}\n\n\tabstract static class BiGenericClass<T extends B<?>, V extends A> {}\n\n\tabstract static class SpecializedBiGenericClass<U extends C> extends BiGenericClass<D, U> {}\n\n\tstatic class TypeFixedBiGenericClass extends SpecializedBiGenericClass<E> {}\n\n\tstatic class TopLevelClass<T> {\n\n\t\tclass Nested<X> {\n\t\t}\n\t}\n\n\tstatic class TypedTopLevelClass extends TopLevelClass<Integer> {\n\n\t\tclass TypedNested extends Nested<Long> {\n\t\t}\n\t}\n\n\tabstract static class WithArrayBase<T> {\n\n\t\tpublic abstract T[] array(T... args);\n\t}\n\n\tabstract static class WithArray<T> extends WithArrayBase<T> {\n\t}\n\n\tinterface Repository<T, ID extends Serializable> {\n\t}\n\n\tinterface IdFixingRepository<T> extends Repository<T, Long> {\n\t}\n\n\tstatic class WithMethodParameter {\n\n\t\tpublic void nestedGenerics(List<Map<String, Integer>> input) {\n\t\t}\n\t}\n\n\tinterface ListOfListSupplier<T> {\n\n\t\tList<List<T>> get();\n\t}\n\n\tinterface StringListOfListSupplier extends ListOfListSupplier<String> {\n\t}\n\n\tstatic class WithElementBounds {\n\n\t\t<T extends A> List<T> get() {\n\t\t\treturn List.of();\n\t\t}\n\t}\n\n\tstatic class WithUnresolvableElement<T> {\n\n\t\tList<T> get() {\n\t\t\treturn List.of();\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.StringListOfListSupplier",
    "headType": "class",
    "relation": "extend",
    "tail": "ListOfListSupplier",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.WithElementBounds",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.WithElementBounds",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.springframework.core.GenericTypeResolver.getTypeVariableMap;\nimport static org.springframework.core.GenericTypeResolver.resolveReturnTypeArgument;\nimport static org.springframework.core.GenericTypeResolver.resolveType;\nimport static org.springframework.core.GenericTypeResolver.resolveTypeArgument;\nimport static org.springframework.util.ReflectionUtils.findMethod;\n\n/**\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Sebastien Deleuze\n * @author Stephane Nicoll\n * @author Yanming Zhou\n */\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\nclass GenericTypeResolverTests {\n\n\t@Test\n\tvoid simpleInterfaceType() {\n\t\tassertThat(resolveTypeArgument(MySimpleInterfaceType.class, MyInterfaceType.class)).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid simpleCollectionInterfaceType() {\n\t\tassertThat(resolveTypeArgument(MyCollectionInterfaceType.class, MyInterfaceType.class)).isEqualTo(Collection.class);\n\t}\n\n\t@Test\n\tvoid simpleSuperclassType() {\n\t\tassertThat(resolveTypeArgument(MySimpleSuperclassType.class, MySuperclassType.class)).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid simpleCollectionSuperclassType() {\n\t\tassertThat(resolveTypeArgument(MyCollectionSuperclassType.class, MySuperclassType.class)).isEqualTo(Collection.class);\n\t}\n\n\t@Test\n\tvoid nullIfNotResolvable() {\n\t\tGenericClass<String> obj = new GenericClass<>();\n\t\tassertThat(resolveTypeArgument(obj.getClass(), GenericClass.class)).isNull();\n\t}\n\n\t@Test\n\tvoid methodReturnTypes() {\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"integer\"), MyInterfaceType.class)).isEqualTo(Integer.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"string\"), MyInterfaceType.class)).isEqualTo(String.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"character\"), MyAbstractType.class)).isEqualTo(Character.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"raw\"), MyInterfaceType.class)).isNull();\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"object\"), MyInterfaceType.class)).isNull();\n\t}\n\n\t@Test\n\tvoid testResolveType() {\n\t\tMethod intMessageMethod = method(MyTypeWithMethods.class, \"readIntegerInputMessage\", MyInterfaceType.class);\n\t\tMethodParameter intMessageMethodParam = new MethodParameter(intMessageMethod, 0);\n\t\tassertThat(resolveType(intMessageMethodParam.getGenericParameterType(), new HashMap<>())).isEqualTo(MyInterfaceType.class);\n\n\t\tMethod intArrMessageMethod = method(MyTypeWithMethods.class, \"readIntegerArrayInputMessage\",\n\t\t\t\tMyInterfaceType[].class);\n\t\tMethodParameter intArrMessageMethodParam = new MethodParameter(intArrMessageMethod, 0);\n\t\tassertThat(resolveType(intArrMessageMethodParam.getGenericParameterType(), new HashMap<>())).isEqualTo(MyInterfaceType[].class);\n\n\t\tMethod genericArrMessageMethod = method(MySimpleTypeWithMethods.class, \"readGenericArrayInputMessage\",\n\t\t\t\tObject[].class);\n\t\tMethodParameter genericArrMessageMethodParam = new MethodParameter(genericArrMessageMethod, 0);\n\t\tMap<TypeVariable, Type> varMap = getTypeVariableMap(MySimpleTypeWithMethods.class);\n\t\tassertThat(resolveType(genericArrMessageMethodParam.getGenericParameterType(), varMap)).isEqualTo(Integer[].class);\n\t}\n\n\t@Test\n\tvoid boundParameterizedType() {\n\t\tassertThat(resolveTypeArgument(TestImpl.class, TestIfc.class)).isEqualTo(B.class);\n\t}\n\n\t@Test\n\tvoid testGetTypeVariableMap() {\n\t\tMap<TypeVariable, Type> map;\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MySimpleInterfaceType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.String}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MyCollectionInterfaceType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=java.util.Collection<java.lang.String>}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MyCollectionSuperclassType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=java.util.Collection<java.lang.String>}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MySimpleTypeWithMethods.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.Integer}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TopLevelClass.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TypedTopLevelClass.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.Integer}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TypedTopLevelClass.TypedNested.class);\n\t\tassertThat(map).hasSize(2);\n\t\tType t = null;\n\t\tType x = null;\n\t\tfor (Map.Entry<TypeVariable, Type> entry : map.entrySet()) {\n\t\t\tif (entry.getKey().toString().equals(\"T\")) {\n\t\t\t\tt = entry.getValue();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = entry.getValue();\n\t\t\t}\n\t\t}\n\t\tassertThat(t).isEqualTo(Integer.class);\n\t\tassertThat(x).isEqualTo(Long.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeArgumentsOfAbstractType() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(MyConcreteType.class, MyAbstractType.class);\n\t\tassertThat(resolved).containsExactly(Character.class);\n\t}\n\n\t@Test  // SPR-11030\n\tvoid getGenericsCannotBeResolved() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(List.class, Iterable.class);\n\t\tassertThat(resolved).isNull();\n\t}\n\n\t@Test  // SPR-11052\n\tvoid getRawMapTypeCannotBeResolved() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(Map.class, Map.class);\n\t\tassertThat(resolved).isNull();\n\t}\n\n\t@Test  // SPR-11044\n\t@SuppressWarnings(\"deprecation\")\n\tvoid getGenericsOnArrayFromParamCannotBeResolved() throws Exception {\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(\n\t\t\t\tWithArrayBase.class.getDeclaredMethod(\"array\", Object[].class), 0);\n\t\tClass<?> resolved = GenericTypeResolver.resolveParameterType(methodParameter, WithArray.class);\n\t\tassertThat(resolved).isEqualTo(Object[].class);\n\t}\n\n\t@Test  // SPR-11044\n\tvoid getGenericsOnArrayFromReturnCannotBeResolved() throws Exception {\n\t\tClass<?> resolved = GenericTypeResolver.resolveReturnType(\n\t\t\t\tWithArrayBase.class.getDeclaredMethod(\"array\", Object[].class), WithArray.class);\n\t\tassertThat(resolved).isEqualTo(Object[].class);\n\t}\n\n\t@Test  // SPR-11763\n\tvoid resolveIncompleteTypeVariables() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(IdFixingRepository.class, Repository.class);\n\t\tassertThat(resolved).isNotNull();\n\t\tassertThat(resolved).hasSize(2);\n\t\tassertThat(resolved[0]).isEqualTo(Object.class);\n\t\tassertThat(resolved[1]).isEqualTo(Long.class);\n\t}\n\n\t@Test\n\tvoid resolvePartiallySpecializedTypeVariables() {\n\t\tType resolved = resolveType(BiGenericClass.class.getTypeParameters()[0], TypeFixedBiGenericClass.class);\n\t\tassertThat(resolved).isEqualTo(D.class);\n\t}\n\n\t@Test\n\tvoid resolveTransitiveTypeVariableWithDifferentName() {\n\t\tType resolved = resolveType(BiGenericClass.class.getTypeParameters()[1], TypeFixedBiGenericClass.class);\n\t\tassertThat(resolved).isEqualTo(E.class);\n\t}\n\n\t@Test\n\tvoid resolveMethodParameterWithNestedGenerics() {\n\t\tMethod method = method(WithMethodParameter.class, \"nestedGenerics\", List.class);\n\t\tMethodParameter methodParameter = new MethodParameter(method, 0);\n\t\tType resolvedType = resolveType(methodParameter.getGenericParameterType(), WithMethodParameter.class);\n\t\tParameterizedTypeReference<List<Map<String, Integer>>> reference = new ParameterizedTypeReference<>() {};\n\t\tassertThat(resolvedType).isEqualTo(reference.getType());\n\t}\n\n\t@Test\n\tvoid resolveNestedTypeVariable() throws Exception {\n\t\tType resolved = resolveType(ListOfListSupplier.class.getMethod(\"get\").getGenericReturnType(),\n\t\t\t\tStringListOfListSupplier.class);\n\t\tassertThat(ResolvableType.forType(resolved).getGeneric(0).getGeneric(0).resolve()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeWithElementBounds() {\n\t\tType type = method(WithElementBounds.class, \"get\").getGenericReturnType();\n\t\tType resolvedType = resolveType(type, WithElementBounds.class);\n\t\tParameterizedTypeReference<List<A>> reference = new ParameterizedTypeReference<>() {};\n\t\tassertThat(resolvedType).isEqualTo(reference.getType());\n\t}\n\n\t@Test\n\tvoid resolveTypeWithUnresolvableElement() {\n\t\tType type = method(WithUnresolvableElement.class, \"get\").getGenericReturnType();\n\t\tType resolvedType = resolveType(type, WithUnresolvableElement.class);\n\t\tassertThat(resolvedType.toString()).isEqualTo(\"java.util.List<E>\");\n\t}\n\n\tprivate static Method method(Class<?> target, String methodName, Class<?>... parameterTypes) {\n\t\tMethod method = findMethod(target, methodName, parameterTypes);\n\t\tassertThat(method).describedAs(target.getName() + \"#\" + methodName).isNotNull();\n\t\treturn method;\n\t}\n\n\n\tpublic interface MyInterfaceType<T> {\n\t}\n\n\tpublic class MySimpleInterfaceType implements MyInterfaceType<String> {\n\t}\n\n\tpublic class MyCollectionInterfaceType implements MyInterfaceType<Collection<String>> {\n\t}\n\n\tpublic abstract class MyAbstractType<T> implements MyInterfaceType<T> {\n\t}\n\n\tpublic class MyConcreteType extends MyAbstractType<Character> {\n\t}\n\n\tpublic abstract class MySuperclassType<T> {\n\t}\n\n\tpublic class MySimpleSuperclassType extends MySuperclassType<String> {\n\t}\n\n\tpublic class MyCollectionSuperclassType extends MySuperclassType<Collection<String>> {\n\t}\n\n\tpublic static class MyTypeWithMethods<T> {\n\n\t\tpublic MyInterfaceType<Integer> integer() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MySimpleInterfaceType string() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MyConcreteType character() { return null; }\n\n\t\tpublic Object object() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MyInterfaceType raw() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic String notParameterized() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic String notParameterizedWithArguments(Integer x, Boolean b) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Simulates a factory method that wraps the supplied object in a proxy of the\n\t\t * same type.\n\t\t */\n\t\tpublic static <T> T createProxy(T object) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createProxy(Object)} but adds an additional argument before\n\t\t * the argument of type {@code T}. Note that they may potentially be of the same\n\t\t * time when invoked!\n\t\t */\n\t\tpublic static <T> T createNamedProxy(String name, T object) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Simulates factory methods found in libraries such as Mockito and EasyMock.\n\t\t */\n\t\tpublic static <MOCK> MOCK createMock(Class<MOCK> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createMock(Class)} but adds an additional method argument\n\t\t * before the parameterized argument.\n\t\t */\n\t\tpublic static <T> T createNamedMock(String name, Class<T> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createNamedMock(String, Class)} but adds an additional\n\t\t * parameterized type.\n\t\t */\n\t\tpublic static <V extends Object, T> T createVMock(V name, Class<T> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Extract some value of the type supported by the interface (i.e., by a concrete,\n\t\t * non-generic implementation of the interface).\n\t\t */\n\t\tpublic static <T> T extractValueFrom(MyInterfaceType<T> myInterfaceType) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Extract some magic value from the supplied map.\n\t\t */\n\t\tpublic static <K, V> V extractMagicValue(Map<K, V> map) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void readIntegerInputMessage(MyInterfaceType<Integer> message) {\n\t\t}\n\n\t\tpublic void readIntegerArrayInputMessage(MyInterfaceType<Integer>[] message) {\n\t\t}\n\n\t\tpublic void readGenericArrayInputMessage(T[] message) {\n\t\t}\n\t}\n\n\tpublic static class MySimpleTypeWithMethods extends MyTypeWithMethods<Integer> {\n\t}\n\n\tstatic class GenericClass<T> {\n\t}\n\n\tclass A {}\n\n\tclass B<T> {}\n\n\tclass C extends A {}\n\n\tclass D extends B<Long> {}\n\n\tclass E extends C {}\n\n\tclass TestIfc<T> {}\n\n\tclass TestImpl<I extends A, T extends B<I>> extends TestIfc<T> {\n\t}\n\n\tabstract static class BiGenericClass<T extends B<?>, V extends A> {}\n\n\tabstract static class SpecializedBiGenericClass<U extends C> extends BiGenericClass<D, U> {}\n\n\tstatic class TypeFixedBiGenericClass extends SpecializedBiGenericClass<E> {}\n\n\tstatic class TopLevelClass<T> {\n\n\t\tclass Nested<X> {\n\t\t}\n\t}\n\n\tstatic class TypedTopLevelClass extends TopLevelClass<Integer> {\n\n\t\tclass TypedNested extends Nested<Long> {\n\t\t}\n\t}\n\n\tabstract static class WithArrayBase<T> {\n\n\t\tpublic abstract T[] array(T... args);\n\t}\n\n\tabstract static class WithArray<T> extends WithArrayBase<T> {\n\t}\n\n\tinterface Repository<T, ID extends Serializable> {\n\t}\n\n\tinterface IdFixingRepository<T> extends Repository<T, Long> {\n\t}\n\n\tstatic class WithMethodParameter {\n\n\t\tpublic void nestedGenerics(List<Map<String, Integer>> input) {\n\t\t}\n\t}\n\n\tinterface ListOfListSupplier<T> {\n\n\t\tList<List<T>> get();\n\t}\n\n\tinterface StringListOfListSupplier extends ListOfListSupplier<String> {\n\t}\n\n\tstatic class WithElementBounds {\n\n\t\t<T extends A> List<T> get() {\n\t\t\treturn List.of();\n\t\t}\n\t}\n\n\tstatic class WithUnresolvableElement<T> {\n\n\t\tList<T> get() {\n\t\t\treturn List.of();\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.WithElementBounds#get()",
    "headType": "method",
    "relation": "provide",
    "tail": "<T extends A> List<T> get() {\r\n    return List.of();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.WithElementBounds",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.WithElementBounds#get()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.WithUnresolvableElement",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.WithUnresolvableElement",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.springframework.core.GenericTypeResolver.getTypeVariableMap;\nimport static org.springframework.core.GenericTypeResolver.resolveReturnTypeArgument;\nimport static org.springframework.core.GenericTypeResolver.resolveType;\nimport static org.springframework.core.GenericTypeResolver.resolveTypeArgument;\nimport static org.springframework.util.ReflectionUtils.findMethod;\n\n/**\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Sebastien Deleuze\n * @author Stephane Nicoll\n * @author Yanming Zhou\n */\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\nclass GenericTypeResolverTests {\n\n\t@Test\n\tvoid simpleInterfaceType() {\n\t\tassertThat(resolveTypeArgument(MySimpleInterfaceType.class, MyInterfaceType.class)).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid simpleCollectionInterfaceType() {\n\t\tassertThat(resolveTypeArgument(MyCollectionInterfaceType.class, MyInterfaceType.class)).isEqualTo(Collection.class);\n\t}\n\n\t@Test\n\tvoid simpleSuperclassType() {\n\t\tassertThat(resolveTypeArgument(MySimpleSuperclassType.class, MySuperclassType.class)).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid simpleCollectionSuperclassType() {\n\t\tassertThat(resolveTypeArgument(MyCollectionSuperclassType.class, MySuperclassType.class)).isEqualTo(Collection.class);\n\t}\n\n\t@Test\n\tvoid nullIfNotResolvable() {\n\t\tGenericClass<String> obj = new GenericClass<>();\n\t\tassertThat(resolveTypeArgument(obj.getClass(), GenericClass.class)).isNull();\n\t}\n\n\t@Test\n\tvoid methodReturnTypes() {\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"integer\"), MyInterfaceType.class)).isEqualTo(Integer.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"string\"), MyInterfaceType.class)).isEqualTo(String.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"character\"), MyAbstractType.class)).isEqualTo(Character.class);\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"raw\"), MyInterfaceType.class)).isNull();\n\t\tassertThat(resolveReturnTypeArgument(method(MyTypeWithMethods.class, \"object\"), MyInterfaceType.class)).isNull();\n\t}\n\n\t@Test\n\tvoid testResolveType() {\n\t\tMethod intMessageMethod = method(MyTypeWithMethods.class, \"readIntegerInputMessage\", MyInterfaceType.class);\n\t\tMethodParameter intMessageMethodParam = new MethodParameter(intMessageMethod, 0);\n\t\tassertThat(resolveType(intMessageMethodParam.getGenericParameterType(), new HashMap<>())).isEqualTo(MyInterfaceType.class);\n\n\t\tMethod intArrMessageMethod = method(MyTypeWithMethods.class, \"readIntegerArrayInputMessage\",\n\t\t\t\tMyInterfaceType[].class);\n\t\tMethodParameter intArrMessageMethodParam = new MethodParameter(intArrMessageMethod, 0);\n\t\tassertThat(resolveType(intArrMessageMethodParam.getGenericParameterType(), new HashMap<>())).isEqualTo(MyInterfaceType[].class);\n\n\t\tMethod genericArrMessageMethod = method(MySimpleTypeWithMethods.class, \"readGenericArrayInputMessage\",\n\t\t\t\tObject[].class);\n\t\tMethodParameter genericArrMessageMethodParam = new MethodParameter(genericArrMessageMethod, 0);\n\t\tMap<TypeVariable, Type> varMap = getTypeVariableMap(MySimpleTypeWithMethods.class);\n\t\tassertThat(resolveType(genericArrMessageMethodParam.getGenericParameterType(), varMap)).isEqualTo(Integer[].class);\n\t}\n\n\t@Test\n\tvoid boundParameterizedType() {\n\t\tassertThat(resolveTypeArgument(TestImpl.class, TestIfc.class)).isEqualTo(B.class);\n\t}\n\n\t@Test\n\tvoid testGetTypeVariableMap() {\n\t\tMap<TypeVariable, Type> map;\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MySimpleInterfaceType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.String}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MyCollectionInterfaceType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=java.util.Collection<java.lang.String>}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MyCollectionSuperclassType.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=java.util.Collection<java.lang.String>}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(MySimpleTypeWithMethods.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.Integer}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TopLevelClass.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TypedTopLevelClass.class);\n\t\tassertThat(map.toString()).isEqualTo(\"{T=class java.lang.Integer}\");\n\n\t\tmap = GenericTypeResolver.getTypeVariableMap(TypedTopLevelClass.TypedNested.class);\n\t\tassertThat(map).hasSize(2);\n\t\tType t = null;\n\t\tType x = null;\n\t\tfor (Map.Entry<TypeVariable, Type> entry : map.entrySet()) {\n\t\t\tif (entry.getKey().toString().equals(\"T\")) {\n\t\t\t\tt = entry.getValue();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = entry.getValue();\n\t\t\t}\n\t\t}\n\t\tassertThat(t).isEqualTo(Integer.class);\n\t\tassertThat(x).isEqualTo(Long.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeArgumentsOfAbstractType() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(MyConcreteType.class, MyAbstractType.class);\n\t\tassertThat(resolved).containsExactly(Character.class);\n\t}\n\n\t@Test  // SPR-11030\n\tvoid getGenericsCannotBeResolved() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(List.class, Iterable.class);\n\t\tassertThat(resolved).isNull();\n\t}\n\n\t@Test  // SPR-11052\n\tvoid getRawMapTypeCannotBeResolved() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(Map.class, Map.class);\n\t\tassertThat(resolved).isNull();\n\t}\n\n\t@Test  // SPR-11044\n\t@SuppressWarnings(\"deprecation\")\n\tvoid getGenericsOnArrayFromParamCannotBeResolved() throws Exception {\n\t\tMethodParameter methodParameter = MethodParameter.forExecutable(\n\t\t\t\tWithArrayBase.class.getDeclaredMethod(\"array\", Object[].class), 0);\n\t\tClass<?> resolved = GenericTypeResolver.resolveParameterType(methodParameter, WithArray.class);\n\t\tassertThat(resolved).isEqualTo(Object[].class);\n\t}\n\n\t@Test  // SPR-11044\n\tvoid getGenericsOnArrayFromReturnCannotBeResolved() throws Exception {\n\t\tClass<?> resolved = GenericTypeResolver.resolveReturnType(\n\t\t\t\tWithArrayBase.class.getDeclaredMethod(\"array\", Object[].class), WithArray.class);\n\t\tassertThat(resolved).isEqualTo(Object[].class);\n\t}\n\n\t@Test  // SPR-11763\n\tvoid resolveIncompleteTypeVariables() {\n\t\tClass<?>[] resolved = GenericTypeResolver.resolveTypeArguments(IdFixingRepository.class, Repository.class);\n\t\tassertThat(resolved).isNotNull();\n\t\tassertThat(resolved).hasSize(2);\n\t\tassertThat(resolved[0]).isEqualTo(Object.class);\n\t\tassertThat(resolved[1]).isEqualTo(Long.class);\n\t}\n\n\t@Test\n\tvoid resolvePartiallySpecializedTypeVariables() {\n\t\tType resolved = resolveType(BiGenericClass.class.getTypeParameters()[0], TypeFixedBiGenericClass.class);\n\t\tassertThat(resolved).isEqualTo(D.class);\n\t}\n\n\t@Test\n\tvoid resolveTransitiveTypeVariableWithDifferentName() {\n\t\tType resolved = resolveType(BiGenericClass.class.getTypeParameters()[1], TypeFixedBiGenericClass.class);\n\t\tassertThat(resolved).isEqualTo(E.class);\n\t}\n\n\t@Test\n\tvoid resolveMethodParameterWithNestedGenerics() {\n\t\tMethod method = method(WithMethodParameter.class, \"nestedGenerics\", List.class);\n\t\tMethodParameter methodParameter = new MethodParameter(method, 0);\n\t\tType resolvedType = resolveType(methodParameter.getGenericParameterType(), WithMethodParameter.class);\n\t\tParameterizedTypeReference<List<Map<String, Integer>>> reference = new ParameterizedTypeReference<>() {};\n\t\tassertThat(resolvedType).isEqualTo(reference.getType());\n\t}\n\n\t@Test\n\tvoid resolveNestedTypeVariable() throws Exception {\n\t\tType resolved = resolveType(ListOfListSupplier.class.getMethod(\"get\").getGenericReturnType(),\n\t\t\t\tStringListOfListSupplier.class);\n\t\tassertThat(ResolvableType.forType(resolved).getGeneric(0).getGeneric(0).resolve()).isEqualTo(String.class);\n\t}\n\n\t@Test\n\tvoid resolveTypeWithElementBounds() {\n\t\tType type = method(WithElementBounds.class, \"get\").getGenericReturnType();\n\t\tType resolvedType = resolveType(type, WithElementBounds.class);\n\t\tParameterizedTypeReference<List<A>> reference = new ParameterizedTypeReference<>() {};\n\t\tassertThat(resolvedType).isEqualTo(reference.getType());\n\t}\n\n\t@Test\n\tvoid resolveTypeWithUnresolvableElement() {\n\t\tType type = method(WithUnresolvableElement.class, \"get\").getGenericReturnType();\n\t\tType resolvedType = resolveType(type, WithUnresolvableElement.class);\n\t\tassertThat(resolvedType.toString()).isEqualTo(\"java.util.List<E>\");\n\t}\n\n\tprivate static Method method(Class<?> target, String methodName, Class<?>... parameterTypes) {\n\t\tMethod method = findMethod(target, methodName, parameterTypes);\n\t\tassertThat(method).describedAs(target.getName() + \"#\" + methodName).isNotNull();\n\t\treturn method;\n\t}\n\n\n\tpublic interface MyInterfaceType<T> {\n\t}\n\n\tpublic class MySimpleInterfaceType implements MyInterfaceType<String> {\n\t}\n\n\tpublic class MyCollectionInterfaceType implements MyInterfaceType<Collection<String>> {\n\t}\n\n\tpublic abstract class MyAbstractType<T> implements MyInterfaceType<T> {\n\t}\n\n\tpublic class MyConcreteType extends MyAbstractType<Character> {\n\t}\n\n\tpublic abstract class MySuperclassType<T> {\n\t}\n\n\tpublic class MySimpleSuperclassType extends MySuperclassType<String> {\n\t}\n\n\tpublic class MyCollectionSuperclassType extends MySuperclassType<Collection<String>> {\n\t}\n\n\tpublic static class MyTypeWithMethods<T> {\n\n\t\tpublic MyInterfaceType<Integer> integer() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MySimpleInterfaceType string() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MyConcreteType character() { return null; }\n\n\t\tpublic Object object() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic MyInterfaceType raw() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic String notParameterized() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic String notParameterizedWithArguments(Integer x, Boolean b) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Simulates a factory method that wraps the supplied object in a proxy of the\n\t\t * same type.\n\t\t */\n\t\tpublic static <T> T createProxy(T object) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createProxy(Object)} but adds an additional argument before\n\t\t * the argument of type {@code T}. Note that they may potentially be of the same\n\t\t * time when invoked!\n\t\t */\n\t\tpublic static <T> T createNamedProxy(String name, T object) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Simulates factory methods found in libraries such as Mockito and EasyMock.\n\t\t */\n\t\tpublic static <MOCK> MOCK createMock(Class<MOCK> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createMock(Class)} but adds an additional method argument\n\t\t * before the parameterized argument.\n\t\t */\n\t\tpublic static <T> T createNamedMock(String name, Class<T> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Similar to {@link #createNamedMock(String, Class)} but adds an additional\n\t\t * parameterized type.\n\t\t */\n\t\tpublic static <V extends Object, T> T createVMock(V name, Class<T> toMock) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Extract some value of the type supported by the interface (i.e., by a concrete,\n\t\t * non-generic implementation of the interface).\n\t\t */\n\t\tpublic static <T> T extractValueFrom(MyInterfaceType<T> myInterfaceType) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Extract some magic value from the supplied map.\n\t\t */\n\t\tpublic static <K, V> V extractMagicValue(Map<K, V> map) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void readIntegerInputMessage(MyInterfaceType<Integer> message) {\n\t\t}\n\n\t\tpublic void readIntegerArrayInputMessage(MyInterfaceType<Integer>[] message) {\n\t\t}\n\n\t\tpublic void readGenericArrayInputMessage(T[] message) {\n\t\t}\n\t}\n\n\tpublic static class MySimpleTypeWithMethods extends MyTypeWithMethods<Integer> {\n\t}\n\n\tstatic class GenericClass<T> {\n\t}\n\n\tclass A {}\n\n\tclass B<T> {}\n\n\tclass C extends A {}\n\n\tclass D extends B<Long> {}\n\n\tclass E extends C {}\n\n\tclass TestIfc<T> {}\n\n\tclass TestImpl<I extends A, T extends B<I>> extends TestIfc<T> {\n\t}\n\n\tabstract static class BiGenericClass<T extends B<?>, V extends A> {}\n\n\tabstract static class SpecializedBiGenericClass<U extends C> extends BiGenericClass<D, U> {}\n\n\tstatic class TypeFixedBiGenericClass extends SpecializedBiGenericClass<E> {}\n\n\tstatic class TopLevelClass<T> {\n\n\t\tclass Nested<X> {\n\t\t}\n\t}\n\n\tstatic class TypedTopLevelClass extends TopLevelClass<Integer> {\n\n\t\tclass TypedNested extends Nested<Long> {\n\t\t}\n\t}\n\n\tabstract static class WithArrayBase<T> {\n\n\t\tpublic abstract T[] array(T... args);\n\t}\n\n\tabstract static class WithArray<T> extends WithArrayBase<T> {\n\t}\n\n\tinterface Repository<T, ID extends Serializable> {\n\t}\n\n\tinterface IdFixingRepository<T> extends Repository<T, Long> {\n\t}\n\n\tstatic class WithMethodParameter {\n\n\t\tpublic void nestedGenerics(List<Map<String, Integer>> input) {\n\t\t}\n\t}\n\n\tinterface ListOfListSupplier<T> {\n\n\t\tList<List<T>> get();\n\t}\n\n\tinterface StringListOfListSupplier extends ListOfListSupplier<String> {\n\t}\n\n\tstatic class WithElementBounds {\n\n\t\t<T extends A> List<T> get() {\n\t\t\treturn List.of();\n\t\t}\n\t}\n\n\tstatic class WithUnresolvableElement<T> {\n\n\t\tList<T> get() {\n\t\t\treturn List.of();\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.WithUnresolvableElement#get()",
    "headType": "method",
    "relation": "provide",
    "tail": "List<T> get() {\r\n    return List.of();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.WithUnresolvableElement",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.WithUnresolvableElement#get()",
    "tailType": "method"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.io.buffer",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core.io.buffer",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.io.buffer.DataBufferTests",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.io.buffer.DataBufferTests",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.io.buffer;\n\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\n\nimport org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatException;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.junit.jupiter.api.Assumptions.assumeFalse;\n\n/**\n * @author Arjen Poutsma\n * @author Sam Brannen\n */\nclass DataBufferTests extends AbstractDataBufferAllocatingTests {\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid byteCountsAndPositions(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(2);\n\n\t\tassertThat(buffer.readPosition()).isEqualTo(0);\n\t\tassertThat(buffer.writePosition()).isEqualTo(0);\n\t\tassertThat(buffer.readableByteCount()).isEqualTo(0);\n\t\tassertThat(buffer.writableByteCount()).isEqualTo(2);\n\t\tassertThat(buffer.capacity()).isEqualTo(2);\n\n\t\tbuffer.write((byte) 'a');\n\t\tassertThat(buffer.readPosition()).isEqualTo(0);\n\t\tassertThat(buffer.writePosition()).isEqualTo(1);\n\t\tassertThat(buffer.readableByteCount()).isEqualTo(1);\n\t\tassertThat(buffer.writableByteCount()).isEqualTo(1);\n\t\tassertThat(buffer.capacity()).isEqualTo(2);\n\n\t\tbuffer.write((byte) 'b');\n\t\tassertThat(buffer.readPosition()).isEqualTo(0);\n\t\tassertThat(buffer.writePosition()).isEqualTo(2);\n\t\tassertThat(buffer.readableByteCount()).isEqualTo(2);\n\t\tassertThat(buffer.writableByteCount()).isEqualTo(0);\n\t\tassertThat(buffer.capacity()).isEqualTo(2);\n\n\t\tbuffer.read();\n\t\tassertThat(buffer.readPosition()).isEqualTo(1);\n\t\tassertThat(buffer.writePosition()).isEqualTo(2);\n\t\tassertThat(buffer.readableByteCount()).isEqualTo(1);\n\t\tassertThat(buffer.writableByteCount()).isEqualTo(0);\n\t\tassertThat(buffer.capacity()).isEqualTo(2);\n\n\t\tbuffer.read();\n\t\tassertThat(buffer.readPosition()).isEqualTo(2);\n\t\tassertThat(buffer.writePosition()).isEqualTo(2);\n\t\tassertThat(buffer.readableByteCount()).isEqualTo(0);\n\t\tassertThat(buffer.writableByteCount()).isEqualTo(0);\n\t\tassertThat(buffer.capacity()).isEqualTo(2);\n\n\t\trelease(buffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid readPositionSmallerThanZero(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(1);\n\t\ttry {\n\t\t\tassertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> buffer.readPosition(-1));\n\t\t}\n\t\tfinally {\n\t\t\trelease(buffer);\n\t\t}\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid readPositionGreaterThanWritePosition(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(1);\n\t\ttry {\n\t\t\tassertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> buffer.readPosition(1));\n\t\t}\n\t\tfinally {\n\t\t\trelease(buffer);\n\t\t}\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid writePositionSmallerThanReadPosition(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(2);\n\t\ttry {\n\t\t\tbuffer.write((byte) 'a');\n\t\t\tbuffer.read();\n\t\t\tassertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> buffer.writePosition(0));\n\t\t}\n\t\tfinally {\n\t\t\trelease(buffer);\n\t\t}\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid writePositionGreaterThanCapacity(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(1);\n\t\ttry {\n\t\t\tassertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> buffer.writePosition(2));\n\t\t}\n\t\tfinally {\n\t\t\trelease(buffer);\n\t\t}\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid writeAndRead(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(5);\n\t\tbuffer.write(new byte[]{'a', 'b', 'c'});\n\n\t\tint ch = buffer.read();\n\t\tassertThat(ch).isEqualTo((byte) 'a');\n\n\t\tbuffer.write((byte) 'd');\n\t\tbuffer.write((byte) 'e');\n\n\t\tbyte[] result = new byte[4];\n\t\tbuffer.read(result);\n\n\t\tassertThat(result).isEqualTo(new byte[]{'b', 'c', 'd', 'e'});\n\n\t\trelease(buffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid writeNullString(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(1);\n\t\ttry {\n\t\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\t\tbuffer.write(null, StandardCharsets.UTF_8));\n\t\t}\n\t\tfinally {\n\t\t\trelease(buffer);\n\t\t}\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid writeNullCharset(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(1);\n\t\ttry {\n\t\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\t\tbuffer.write(\"test\", null));\n\t\t}\n\t\tfinally {\n\t\t\trelease(buffer);\n\t\t}\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid writeEmptyString(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(1);\n\t\tbuffer.write(\"\", StandardCharsets.UTF_8);\n\n\t\tassertThat(buffer.readableByteCount()).isEqualTo(0);\n\n\t\trelease(buffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid writeUtf8String(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(6);\n\t\tbuffer.write(\"Spring\", StandardCharsets.UTF_8);\n\n\t\tbyte[] result = new byte[6];\n\t\tbuffer.read(result);\n\n\t\tassertThat(result).isEqualTo(\"Spring\".getBytes(StandardCharsets.UTF_8));\n\t\trelease(buffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid writeUtf8StringOutGrowsCapacity(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(5);\n\t\tbuffer.write(\"Spring €\", StandardCharsets.UTF_8);\n\n\t\tbyte[] result = new byte[10];\n\t\tbuffer.read(result);\n\n\t\tassertThat(result).isEqualTo(\"Spring €\".getBytes(StandardCharsets.UTF_8));\n\t\trelease(buffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid writeIsoString(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(3);\n\t\tbuffer.write(\"\\u00A3\", StandardCharsets.ISO_8859_1);\n\n\t\tbyte[] result = new byte[1];\n\t\tbuffer.read(result);\n\n\t\tassertThat(result).isEqualTo(\"\\u00A3\".getBytes(StandardCharsets.ISO_8859_1));\n\t\trelease(buffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid writeMultipleUtf8String(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(1);\n\t\tbuffer.write(\"abc\", StandardCharsets.UTF_8);\n\t\tassertThat(buffer.readableByteCount()).isEqualTo(3);\n\n\t\tbuffer.write(\"def\", StandardCharsets.UTF_8);\n\t\tassertThat(buffer.readableByteCount()).isEqualTo(6);\n\n\t\tbuffer.write(\"ghi\", StandardCharsets.UTF_8);\n\t\tassertThat(buffer.readableByteCount()).isEqualTo(9);\n\n\t\tbyte[] result = new byte[9];\n\t\tbuffer.read(result);\n\n\t\tassertThat(result).isEqualTo(\"abcdefghi\".getBytes());\n\n\t\trelease(buffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid toStringNullCharset(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(1);\n\t\ttry {\n\t\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\t\tbuffer.toString(null));\n\t\t}\n\t\tfinally {\n\t\t\trelease(buffer);\n\t\t}\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid toStringUtf8(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tString spring = \"Spring\";\n\t\tbyte[] bytes = spring.getBytes(StandardCharsets.UTF_8);\n\t\tDataBuffer buffer = createDataBuffer(bytes.length);\n\t\tbuffer.write(bytes);\n\n\t\tString result = buffer.toString(StandardCharsets.UTF_8);\n\n\t\tassertThat(result).isEqualTo(spring);\n\t\trelease(buffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid toStringSection(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tString spring = \"Spring\";\n\t\tbyte[] bytes = spring.getBytes(StandardCharsets.UTF_8);\n\t\tDataBuffer buffer = createDataBuffer(bytes.length);\n\t\tbuffer.write(bytes);\n\n\t\tString result = buffer.toString(1, 3, StandardCharsets.UTF_8);\n\n\t\tassertThat(result).isEqualTo(\"pri\");\n\t\trelease(buffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid inputStream(DataBufferFactory bufferFactory) throws Exception {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(4);\n\t\tbuffer.write(new byte[]{'a', 'b', 'c', 'd', 'e'});\n\t\tbuffer.readPosition(1);\n\n\t\tInputStream inputStream = buffer.asInputStream();\n\n\t\tassertThat(inputStream.available()).isEqualTo(4);\n\n\t\tint result = inputStream.read();\n\t\tassertThat(result).isEqualTo((byte) 'b');\n\t\tassertThat(inputStream.available()).isEqualTo(3);\n\n\t\tassertThat(inputStream.markSupported()).isTrue();\n\t\tinputStream.mark(2);\n\n\t\tbyte[] bytes = new byte[2];\n\t\tint len = inputStream.read(bytes);\n\t\tassertThat(len).isEqualTo(2);\n\t\tassertThat(bytes).isEqualTo(new byte[]{'c', 'd'});\n\t\tassertThat(inputStream.available()).isEqualTo(1);\n\n\t\tArrays.fill(bytes, (byte) 0);\n\t\tlen = inputStream.read(bytes);\n\t\tassertThat(len).isEqualTo(1);\n\t\tassertThat(bytes).isEqualTo(new byte[]{'e', (byte) 0});\n\t\tassertThat(inputStream.available()).isEqualTo(0);\n\n\t\tassertThat(inputStream.read()).isEqualTo(-1);\n\t\tassertThat(inputStream.read(bytes)).isEqualTo(-1);\n\n\t\tinputStream.reset();\n\t\tbytes = new byte[3];\n\t\tlen = inputStream.read(bytes);\n\t\tassertThat(len).isEqualTo(3);\n\t\tassertThat(bytes).containsExactly('c', 'd', 'e');\n\n\t\trelease(buffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid inputStreamReleaseOnClose(DataBufferFactory bufferFactory) throws Exception {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(3);\n\t\tbyte[] bytes = {'a', 'b', 'c'};\n\t\tbuffer.write(bytes);\n\n\t\ttry (InputStream inputStream = buffer.asInputStream(true)) {\n\t\t\tbyte[] result = new byte[3];\n\t\t\tint len = inputStream.read(result);\n\t\t\tassertThat(len).isEqualTo(3);\n\t\t\tassertThat(result).isEqualTo(bytes);\n\t\t}\n\n\t\t// AbstractDataBufferAllocatingTests.leakDetector will verify the buffer's release\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid outputStream(DataBufferFactory bufferFactory) throws Exception {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(4);\n\t\tbuffer.write((byte) 'a');\n\n\t\tOutputStream outputStream = buffer.asOutputStream();\n\t\toutputStream.write('b');\n\t\toutputStream.write(new byte[]{'c', 'd'});\n\n\t\tbuffer.write((byte) 'e');\n\n\t\tbyte[] bytes = new byte[5];\n\t\tbuffer.read(bytes);\n\t\tassertThat(bytes).isEqualTo(new byte[]{'a', 'b', 'c', 'd', 'e'});\n\n\t\trelease(buffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid expand(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(1);\n\t\tbuffer.write((byte) 'a');\n\t\tassertThat(buffer.capacity()).isEqualTo(1);\n\t\tbuffer.write((byte) 'b');\n\n\t\tassertThat(buffer.capacity()).isGreaterThan(1);\n\n\t\trelease(buffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\t@SuppressWarnings(\"deprecation\")\n\tvoid increaseCapacity(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(1);\n\t\tassertThat(buffer.capacity()).isEqualTo(1);\n\n\t\tbuffer.capacity(2);\n\t\tassertThat(buffer.capacity()).isEqualTo(2);\n\n\t\trelease(buffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\t@SuppressWarnings(\"deprecation\")\n\tvoid decreaseCapacityLowReadPosition(DataBufferFactory bufferFactory) {\n\t\tassumeFalse(bufferFactory instanceof Netty5DataBufferFactory,\n\t\t\t\t\"Netty 5 does not support decreasing the capacity\");\n\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(2);\n\t\tbuffer.writePosition(2);\n\t\tbuffer.capacity(1);\n\t\tassertThat(buffer.capacity()).isEqualTo(1);\n\n\t\trelease(buffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\t@SuppressWarnings(\"deprecation\")\n\tvoid decreaseCapacityHighReadPosition(DataBufferFactory bufferFactory) {\n\t\tassumeFalse(bufferFactory instanceof Netty5DataBufferFactory,\n\t\t\t\t\"Netty 5 does not support decreasing the capacity\");\n\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(2);\n\t\tbuffer.writePosition(2);\n\t\tbuffer.readPosition(2);\n\t\tbuffer.capacity(1);\n\t\tassertThat(buffer.capacity()).isEqualTo(1);\n\n\t\trelease(buffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\t@SuppressWarnings(\"deprecation\")\n\tvoid capacityLessThanZero(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(1);\n\t\ttry {\n\t\t\tassertThatIllegalArgumentException().isThrownBy(() -> buffer.capacity(-1));\n\t\t}\n\t\tfinally {\n\t\t\trelease(buffer);\n\t\t}\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid writeByteBuffer(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer1 = createDataBuffer(1);\n\t\tbuffer1.write((byte) 'a');\n\t\tByteBuffer buffer2 = createByteBuffer(2);\n\t\tbuffer2.put((byte) 'b');\n\t\tbuffer2.flip();\n\t\tByteBuffer buffer3 = createByteBuffer(3);\n\t\tbuffer3.put((byte) 'c');\n\t\tbuffer3.flip();\n\n\t\tbuffer1.write(buffer2, buffer3);\n\t\tbuffer1.write((byte) 'd'); // make sure the write index is correctly set\n\n\t\tassertThat(buffer1.readableByteCount()).isEqualTo(4);\n\t\tbyte[] result = new byte[4];\n\t\tbuffer1.read(result);\n\n\t\tassertThat(result).isEqualTo(new byte[]{'a', 'b', 'c', 'd'});\n\n\t\trelease(buffer1);\n\t}\n\n\tprivate ByteBuffer createByteBuffer(int capacity) {\n\t\treturn ByteBuffer.allocate(capacity);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid writeDataBuffer(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer1 = createDataBuffer(1);\n\t\tbuffer1.write((byte) 'a');\n\t\tDataBuffer buffer2 = createDataBuffer(2);\n\t\tbuffer2.write((byte) 'b');\n\t\tDataBuffer buffer3 = createDataBuffer(3);\n\t\tbuffer3.write((byte) 'c');\n\n\t\tbuffer1.write(buffer2, buffer3);\n\t\tbuffer1.write((byte) 'd'); // make sure the write index is correctly set\n\n\t\tassertThat(buffer1.readableByteCount()).isEqualTo(4);\n\t\tbyte[] result = new byte[4];\n\t\tbuffer1.read(result);\n\n\t\tassertThat(result).isEqualTo(new byte[]{'a', 'b', 'c', 'd'});\n\n\t\trelease(buffer1, buffer2, buffer3);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\t@SuppressWarnings(\"deprecation\")\n\tvoid asByteBuffer(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(4);\n\t\tbuffer.write(new byte[]{'a', 'b', 'c'});\n\t\tbuffer.read(); // skip a\n\n\t\tByteBuffer result = buffer.asByteBuffer();\n\t\tassertThat(result.capacity()).isEqualTo(2);\n\n\t\tbuffer.write((byte) 'd');\n\t\tassertThat(result.remaining()).isEqualTo(2);\n\n\t\tbyte[] resultBytes = new byte[2];\n\t\tresult.get(resultBytes);\n\t\tassertThat(resultBytes).isEqualTo(new byte[]{'b', 'c'});\n\n\t\trelease(buffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid asByteBufferIndexLength(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(3);\n\t\tbuffer.write(new byte[]{'a', 'b'});\n\n\t\t@SuppressWarnings(\"deprecation\")\n\t\tByteBuffer result = buffer.asByteBuffer(1, 2);\n\t\tassertThat(result.capacity()).isEqualTo(2);\n\n\t\tassumeFalse(bufferFactory instanceof Netty5DataBufferFactory, () -> {\n\t\t\tDataBufferUtils.release(buffer);\n\t\t\treturn \"Netty 5 does share the internal buffer\";\n\t\t});\n\n\t\tbuffer.write((byte) 'c');\n\t\tassertThat(result.remaining()).isEqualTo(2);\n\n\t\tbyte[] resultBytes = new byte[2];\n\t\tresult.get(resultBytes);\n\t\tassertThat(resultBytes).isEqualTo(new byte[]{'b', 'c'});\n\n\t\trelease(buffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\t@SuppressWarnings(\"deprecation\")\n\tvoid byteBufferContainsDataBufferChanges(DataBufferFactory bufferFactory) {\n\t\tassumeFalse(bufferFactory instanceof Netty5DataBufferFactory,\n\t\t\t\t\"Netty 5 does not support sharing data between buffers\");\n\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer dataBuffer = createDataBuffer(1);\n\t\tByteBuffer byteBuffer = dataBuffer.asByteBuffer(0, 1);\n\n\t\tdataBuffer.write((byte) 'a');\n\n\t\tassertThat(byteBuffer.limit()).isEqualTo(1);\n\t\tbyte b = byteBuffer.get();\n\t\tassertThat(b).isEqualTo((byte) 'a');\n\n\t\trelease(dataBuffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\t@SuppressWarnings(\"deprecation\")\n\tvoid dataBufferContainsByteBufferChanges(DataBufferFactory bufferFactory) {\n\t\tassumeFalse(bufferFactory instanceof Netty5DataBufferFactory,\n\t\t\t\t\"Netty 5 does not support sharing data between buffers\");\n\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer dataBuffer = createDataBuffer(1);\n\t\tByteBuffer byteBuffer = dataBuffer.asByteBuffer(0, 1);\n\n\t\tbyteBuffer.put((byte) 'a');\n\t\tdataBuffer.writePosition(1);\n\n\t\tbyte b = dataBuffer.read();\n\t\tassertThat(b).isEqualTo((byte) 'a');\n\n\t\trelease(dataBuffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\t@SuppressWarnings(\"deprecation\")\n\tvoid emptyAsByteBuffer(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(1);\n\n\t\tByteBuffer result = buffer.asByteBuffer();\n\t\tassertThat(result.capacity()).isEqualTo(0);\n\n\t\trelease(buffer);\n\t}\n\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid toByteBuffer(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(4);\n\t\tbuffer.write(new byte[]{'a', 'b', 'c'});\n\t\tbuffer.read(); // skip a\n\n\t\t@SuppressWarnings(\"deprecation\")\n\t\tByteBuffer result = buffer.toByteBuffer();\n\t\tassertThat(result.capacity()).isEqualTo(2);\n\t\tassertThat(result.remaining()).isEqualTo(2);\n\n\t\tbyte[] resultBytes = new byte[2];\n\t\tresult.get(resultBytes);\n\t\tassertThat(resultBytes).isEqualTo(new byte[]{'b', 'c'});\n\n\t\trelease(buffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid toByteBufferIndexLength(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(3);\n\t\tbuffer.write(new byte[]{'a', 'b', 'c'});\n\n\t\t@SuppressWarnings(\"deprecation\")\n\t\tByteBuffer result = buffer.toByteBuffer(1, 2);\n\t\tassertThat(result.capacity()).isEqualTo(2);\n\t\tassertThat(result.remaining()).isEqualTo(2);\n\n\t\tbyte[] resultBytes = new byte[2];\n\t\tresult.get(resultBytes);\n\t\tassertThat(resultBytes).isEqualTo(new byte[]{'b', 'c'});\n\n\t\trelease(buffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid toByteBufferDestination(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(4);\n\t\tbuffer.write(new byte[]{'a', 'b', 'c'});\n\n\t\tByteBuffer byteBuffer = createByteBuffer(2);\n\t\tbuffer.toByteBuffer(1, byteBuffer, 0, 2);\n\t\tassertThat(byteBuffer.capacity()).isEqualTo(2);\n\t\tassertThat(byteBuffer.remaining()).isEqualTo(2);\n\n\t\tbyte[] resultBytes = new byte[2];\n\t\tbyteBuffer.get(resultBytes);\n\t\tassertThat(resultBytes).isEqualTo(new byte[]{'b', 'c'});\n\n\t\tassertThatExceptionOfType(IndexOutOfBoundsException.class)\n\t\t\t\t.isThrownBy(() -> buffer.toByteBuffer(0, byteBuffer, 0, 3));\n\n\t\trelease(buffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid readableByteBuffers(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer dataBuffer = this.bufferFactory.allocateBuffer(3);\n\t\tdataBuffer.write(\"abc\".getBytes(StandardCharsets.UTF_8));\n\t\tdataBuffer.readPosition(1);\n\t\tdataBuffer.writePosition(2);\n\n\n\t\tbyte[] result = new byte[1];\n\t\ttry (var iterator = dataBuffer.readableByteBuffers()) {\n\t\t\tassertThat(iterator).hasNext();\n\t\t\tint i = 0;\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tByteBuffer byteBuffer = iterator.next();\n\t\t\t\tassertThat(byteBuffer.position()).isEqualTo(0);\n\t\t\t\tassertThat(byteBuffer.limit()).isEqualTo(1);\n\t\t\t\tassertThat(byteBuffer.capacity()).isEqualTo(1);\n\t\t\t\tassertThat(byteBuffer.remaining()).isEqualTo(1);\n\n\t\t\t\tbyteBuffer.get(result, i, 1);\n\n\t\t\t\tassertThat(iterator).isExhausted();\n\t\t\t}\n\t\t}\n\n\t\tassertThat(result).containsExactly('b');\n\n\t\trelease(dataBuffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid readableByteBuffersJoined(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer dataBuffer = this.bufferFactory.join(Arrays.asList(stringBuffer(\"a\"),\n\t\t\t\tstringBuffer(\"b\"), stringBuffer(\"c\")));\n\n\t\tbyte[] result = new byte[3];\n\t\ttry (var iterator = dataBuffer.readableByteBuffers()) {\n\t\t\tassertThat(iterator).hasNext();\n\t\t\tint i = 0;\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tByteBuffer byteBuffer = iterator.next();\n\t\t\t\tint len = byteBuffer.remaining();\n\t\t\t\tbyteBuffer.get(result, i, len);\n\t\t\t\ti += len;\n\t\t\t\tassertThatException().isThrownBy(() -> byteBuffer.put((byte) 'd'));\n\t\t\t}\n\t\t}\n\n\t\tassertThat(result).containsExactly('a', 'b', 'c');\n\n\t\trelease(dataBuffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid writableByteBuffers(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer dataBuffer = this.bufferFactory.allocateBuffer(3);\n\t\tdataBuffer.write(\"ab\".getBytes(StandardCharsets.UTF_8));\n\t\tdataBuffer.readPosition(1);\n\n\t\ttry (DataBuffer.ByteBufferIterator iterator = dataBuffer.writableByteBuffers()) {\n\t\t\tassertThat(iterator).hasNext();\n\t\t\tByteBuffer byteBuffer = iterator.next();\n\t\t\tassertThat(byteBuffer.position()).isEqualTo(0);\n\t\t\tassertThat(byteBuffer.limit()).isEqualTo(1);\n\t\t\tassertThat(byteBuffer.capacity()).isEqualTo(1);\n\t\t\tassertThat(byteBuffer.remaining()).isEqualTo(1);\n\n\t\t\tbyteBuffer.put((byte) 'c');\n\t\t\tdataBuffer.writePosition(3);\n\n\t\t\tassertThat(iterator).isExhausted();\n\t\t}\n\t\tbyte[] result = new byte[2];\n\t\tdataBuffer.read(result);\n\t\tassertThat(result).containsExactly('b', 'c');\n\n\t\trelease(dataBuffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid indexOf(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(3);\n\t\tbuffer.write(new byte[]{'a', 'b', 'c'});\n\n\t\tint result = buffer.indexOf(b -> b == 'c', 0);\n\t\tassertThat(result).isEqualTo(2);\n\n\t\tresult = buffer.indexOf(b -> b == 'c', Integer.MIN_VALUE);\n\t\tassertThat(result).isEqualTo(2);\n\n\t\tresult = buffer.indexOf(b -> b == 'c', Integer.MAX_VALUE);\n\t\tassertThat(result).isEqualTo(-1);\n\n\t\tresult = buffer.indexOf(b -> b == 'z', 0);\n\t\tassertThat(result).isEqualTo(-1);\n\n\t\trelease(buffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid lastIndexOf(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(3);\n\t\tbuffer.write(new byte[]{'a', 'b', 'c'});\n\n\t\tint result = buffer.lastIndexOf(b -> b == 'b', 2);\n\t\tassertThat(result).isEqualTo(1);\n\n\t\tresult = buffer.lastIndexOf(b -> b == 'c', 2);\n\t\tassertThat(result).isEqualTo(2);\n\n\t\tresult = buffer.lastIndexOf(b -> b == 'b', Integer.MAX_VALUE);\n\t\tassertThat(result).isEqualTo(1);\n\n\t\tresult = buffer.lastIndexOf(b -> b == 'c', Integer.MAX_VALUE);\n\t\tassertThat(result).isEqualTo(2);\n\n\t\tresult = buffer.lastIndexOf(b -> b == 'b', Integer.MIN_VALUE);\n\t\tassertThat(result).isEqualTo(-1);\n\n\t\tresult = buffer.lastIndexOf(b -> b == 'c', Integer.MIN_VALUE);\n\t\tassertThat(result).isEqualTo(-1);\n\n\t\tresult = buffer.lastIndexOf(b -> b == 'z', 0);\n\t\tassertThat(result).isEqualTo(-1);\n\n\t\trelease(buffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\t@SuppressWarnings(\"deprecation\")\n\tvoid slice(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(3);\n\t\tbuffer.write(new byte[]{'a', 'b'});\n\n\t\tDataBuffer slice = buffer.slice(1, 2);\n\t\tassertThat(slice.readableByteCount()).isEqualTo(2);\n\t\tbuffer.write((byte) 'c');\n\n\t\tassertThat(buffer.readableByteCount()).isEqualTo(3);\n\t\tbyte[] result = new byte[3];\n\t\tbuffer.read(result);\n\n\t\tassertThat(result).isEqualTo(new byte[]{'a', 'b', 'c'});\n\n\t\tassertThat(slice.readableByteCount()).isEqualTo(2);\n\t\tresult = new byte[2];\n\t\tslice.read(result);\n\n\t\tif (!(bufferFactory instanceof Netty5DataBufferFactory)) {\n\t\t\tassertThat(result).isEqualTo(new byte[]{'b', 'c'});\n\t\t}\n\t\trelease(buffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\t@SuppressWarnings(\"deprecation\")\n\tvoid retainedSlice(DataBufferFactory bufferFactory) {\n\t\tassumeFalse(bufferFactory instanceof Netty5DataBufferFactory,\n\t\t\t\t\"Netty 5 does not support retainedSlice\");\n\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(3);\n\t\tbuffer.write(new byte[]{'a', 'b'});\n\n\t\tDataBuffer slice = buffer.retainedSlice(1, 2);\n\t\tassertThat(slice.readableByteCount()).isEqualTo(2);\n\t\tbuffer.write((byte) 'c');\n\n\t\tassertThat(buffer.readableByteCount()).isEqualTo(3);\n\t\tbyte[] result = new byte[3];\n\t\tbuffer.read(result);\n\n\t\tassertThat(result).isEqualTo(new byte[]{'a', 'b', 'c'});\n\n\t\tassertThat(slice.readableByteCount()).isEqualTo(2);\n\t\tresult = new byte[2];\n\t\tslice.read(result);\n\n\t\tassertThat(result).isEqualTo(new byte[]{'b', 'c'});\n\n\t\trelease(buffer, slice);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\t@SuppressWarnings(\"deprecation\")\n\tvoid spr16351(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(6);\n\t\tbyte[] bytes = {'a', 'b', 'c', 'd', 'e', 'f'};\n\t\tbuffer.write(bytes);\n\t\tDataBuffer slice = buffer.slice(3, 3);\n\t\tbuffer.writePosition(3);\n\t\tbuffer.write(slice);\n\n\t\tassertThat(buffer.readableByteCount()).isEqualTo(6);\n\t\tbyte[] result = new byte[6];\n\t\tbuffer.read(result);\n\n\t\tassertThat(result).isEqualTo(bytes);\n\n\t\tif (bufferFactory instanceof Netty5DataBufferFactory) {\n\t\t\trelease(slice);\n\t\t}\n\t\trelease(buffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid split(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = createDataBuffer(3);\n\t\tbuffer.write(new byte[]{'a', 'b'});\n\n\t\tassertThatException().isThrownBy(() -> buffer.split(-1));\n\t\tassertThatException().isThrownBy(() -> buffer.split(4));\n\n\t\tDataBuffer split = buffer.split(1);\n\n\t\tassertThat(split.readPosition()).isEqualTo(0);\n\t\tassertThat(split.writePosition()).isEqualTo(1);\n\t\tassertThat(split.capacity()).isEqualTo(1);\n\t\tassertThat(split.readableByteCount()).isEqualTo(1);\n\t\tbyte[] bytes = new byte[1];\n\t\tsplit.read(bytes);\n\t\tassertThat(bytes).containsExactly('a');\n\n\t\tassertThat(buffer.readPosition()).isEqualTo(0);\n\t\tassertThat(buffer.writePosition()).isEqualTo(1);\n\t\tassertThat(buffer.capacity()).isEqualTo(2);\n\n\t\tbuffer.write((byte) 'c');\n\t\tassertThat(buffer.readableByteCount()).isEqualTo(2);\n\t\tbytes = new byte[2];\n\t\tbuffer.read(bytes);\n\n\t\tassertThat(bytes).isEqualTo(new byte[]{'b', 'c'});\n\n\t\tDataBuffer buffer2 = createDataBuffer(1);\n\t\tbuffer2.write(new byte[]{'a'});\n\t\tDataBuffer split2 = buffer2.split(1);\n\n\t\tassertThat(split2.readPosition()).isEqualTo(0);\n\t\tassertThat(split2.writePosition()).isEqualTo(1);\n\t\tassertThat(split2.capacity()).isEqualTo(1);\n\t\tassertThat(split2.readableByteCount()).isEqualTo(1);\n\t\tbytes = new byte[1];\n\t\tsplit2.read(bytes);\n\t\tassertThat(bytes).containsExactly('a');\n\n\t\tassertThat(buffer2.readPosition()).isEqualTo(0);\n\t\tassertThat(buffer2.writePosition()).isEqualTo(0);\n\t\tassertThat(buffer2.capacity()).isEqualTo(0);\n\t\tassertThat(buffer.readableByteCount()).isEqualTo(0);\n\n\t\trelease(buffer, buffer2, split, split2);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid join(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer composite = this.bufferFactory.join(Arrays.asList(stringBuffer(\"a\"),\n\t\t\t\tstringBuffer(\"b\"), stringBuffer(\"c\")));\n\t\tassertThat(composite.readableByteCount()).isEqualTo(3);\n\t\tbyte[] bytes = new byte[3];\n\t\tcomposite.read(bytes);\n\n\t\tassertThat(bytes).isEqualTo(new byte[]{'a', 'b', 'c'});\n\n\t\trelease(composite);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest\n\tvoid getByte(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = stringBuffer(\"abc\");\n\n\t\tassertThat(buffer.getByte(0)).isEqualTo((byte) 'a');\n\t\tassertThat(buffer.getByte(1)).isEqualTo((byte) 'b');\n\t\tassertThat(buffer.getByte(2)).isEqualTo((byte) 'c');\n\t\tassertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> buffer.getByte(-1));\n\t\tassertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> buffer.getByte(3));\n\n\t\trelease(buffer);\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest // gh-31605\n\tvoid shouldHonorSourceBuffersReadPosition(DataBufferFactory bufferFactory) {\n\t\tDataBuffer dataBuffer = bufferFactory.wrap(\"ab\".getBytes(StandardCharsets.UTF_8));\n\t\tdataBuffer.readPosition(1);\n\n\t\tByteBuffer byteBuffer = ByteBuffer.allocate(dataBuffer.readableByteCount());\n\t\tdataBuffer.toByteBuffer(byteBuffer);\n\n\t\tassertThat(StandardCharsets.UTF_8.decode(byteBuffer).toString()).isEqualTo(\"b\");\n\t}\n\n\t@ParameterizedDataBufferAllocatingTest // gh-31873\n\tvoid repeatedWrites(DataBufferFactory bufferFactory) {\n\t\tsuper.bufferFactory = bufferFactory;\n\n\t\tDataBuffer buffer = bufferFactory.allocateBuffer(256);\n\t\tString name = \"Müller\";\n\t\tint repeatCount = 19;\n\t\tfor (int i = 0; i < repeatCount; i++) {\n\t\t\tbuffer.write(name, StandardCharsets.UTF_8);\n\t\t}\n\t\tString result = buffer.toString(StandardCharsets.UTF_8);\n\t\tString expected = name.repeat(repeatCount);\n\t\tassertThat(result).isEqualTo(expected);\n\n\t\trelease(buffer);\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.io.buffer.DataBufferTests#byteCountsAndPositions(DataBufferFactory)",
    "headType": "method",
    "relation": "provide",
    "tail": "@ParameterizedDataBufferAllocatingTest\r\nvoid byteCountsAndPositions(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(2);\r\n    assertThat(buffer.readPosition()).isEqualTo(0);\r\n    assertThat(buffer.writePosition()).isEqualTo(0);\r\n    assertThat(buffer.readableByteCount()).isEqualTo(0);\r\n    assertThat(buffer.writableByteCount()).isEqualTo(2);\r\n    assertThat(buffer.capacity()).isEqualTo(2);\r\n    buffer.write((byte) 'a');\r\n    assertThat(buffer.readPosition()).isEqualTo(0);\r\n    assertThat(buffer.writePosition()).isEqualTo(1);\r\n    assertThat(buffer.readableByteCount()).isEqualTo(1);\r\n    assertThat(buffer.writableByteCount()).isEqualTo(1);\r\n    assertThat(buffer.capacity()).isEqualTo(2);\r\n    buffer.write((byte) 'b');\r\n    assertThat(buffer.readPosition()).isEqualTo(0);\r\n    assertThat(buffer.writePosition()).isEqualTo(2);\r\n    assertThat(buffer.readableByteCount()).isEqualTo(2);\r\n    assertThat(buffer.writableByteCount()).isEqualTo(0);\r\n    assertThat(buffer.capacity()).isEqualTo(2);\r\n    buffer.read();\r\n    assertThat(buffer.readPosition()).isEqualTo(1);\r\n    assertThat(buffer.writePosition()).isEqualTo(2);\r\n    assertThat(buffer.readableByteCount()).isEqualTo(1);\r\n    assertThat(buffer.writableByteCount()).isEqualTo(0);\r\n    assertThat(buffer.capacity()).isEqualTo(2);\r\n    buffer.read();\r\n    assertThat(buffer.readPosition()).isEqualTo(2);\r\n    assertThat(buffer.writePosition()).isEqualTo(2);\r\n    assertThat(buffer.readableByteCount()).isEqualTo(0);\r\n    assertThat(buffer.writableByteCount()).isEqualTo(0);\r\n    assertThat(buffer.capacity()).isEqualTo(2);\r\n    release(buffer);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.io.buffer.DataBufferTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.io.buffer.DataBufferTests#byteCountsAndPositions(DataBufferFactory)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.io.buffer.DataBufferTests#byteCountsAndPositions(DataBufferFactory)",
    "headType": "method",
    "relation": "use",
    "tail": "@ParameterizedDataBufferAllocatingTest",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.io.buffer.DataBufferTests#readPositionSmallerThanZero(DataBufferFactory)",
    "headType": "method",
    "relation": "provide",
    "tail": "@ParameterizedDataBufferAllocatingTest\r\nvoid readPositionSmallerThanZero(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(1);\r\n    try {\r\n        assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> buffer.readPosition(-1));\r\n    } finally {\r\n        release(buffer);\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.io.buffer.DataBufferTests",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.io.buffer.DataBufferTests#readPositionSmallerThanZero(DataBufferFactory)",
    "tailType": "method"
  }
]