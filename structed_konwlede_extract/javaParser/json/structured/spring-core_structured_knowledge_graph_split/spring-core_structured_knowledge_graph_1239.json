[
  {
    "head": "org.springframework.util.AutoPopulatingList#hashCode()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic int hashCode() {\r\n    return this.backingList.hashCode();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.AutoPopulatingList",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.AutoPopulatingList#hashCode()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.AutoPopulatingList#hashCode()",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.ElementFactory",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.ElementFactory",
    "headType": "class",
    "relation": "use",
    "tail": "@FunctionalInterface",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.ElementFactory",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\n\nimport org.jspecify.annotations.Nullable;\n\n/**\n * Simple {@link List} wrapper class that allows for elements to be\n * automatically populated as they are requested. This is particularly\n * useful for data binding to {@link List Lists}, allowing for elements\n * to be created and added to the {@link List} in a \"just in time\" fashion.\n *\n * <p>Note: This class is not thread-safe. To create a thread-safe version,\n * use the {@link java.util.Collections#synchronizedList} utility methods.\n *\n * <p>Inspired by {@code LazyList} from Commons Collections.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @since 2.0\n * @param <E> the element type\n */\n@SuppressWarnings(\"serial\")\npublic class AutoPopulatingList<E> implements List<E>, Serializable {\n\n\t/**\n\t * The {@link List} that all operations are eventually delegated to.\n\t */\n\tprivate final List<E> backingList;\n\n\t/**\n\t * The {@link ElementFactory} to use to create new {@link List} elements\n\t * on demand.\n\t */\n\tprivate final ElementFactory<E> elementFactory;\n\n\n\t/**\n\t * Creates a new {@code AutoPopulatingList} that is backed by a standard\n\t * {@link ArrayList} and adds new instances of the supplied {@link Class element Class}\n\t * to the backing {@link List} on demand.\n\t */\n\tpublic AutoPopulatingList(Class<? extends E> elementClass) {\n\t\tthis(new ArrayList<>(), elementClass);\n\t}\n\n\t/**\n\t * Creates a new {@code AutoPopulatingList} that is backed by the supplied {@link List}\n\t * and adds new instances of the supplied {@link Class element Class} to the backing\n\t * {@link List} on demand.\n\t */\n\tpublic AutoPopulatingList(List<E> backingList, Class<? extends E> elementClass) {\n\t\tthis(backingList, new ReflectiveElementFactory<>(elementClass));\n\t}\n\n\t/**\n\t * Creates a new {@code AutoPopulatingList} that is backed by a standard\n\t * {@link ArrayList} and creates new elements on demand using the supplied {@link ElementFactory}.\n\t */\n\tpublic AutoPopulatingList(ElementFactory<E> elementFactory) {\n\t\tthis(new ArrayList<>(), elementFactory);\n\t}\n\n\t/**\n\t * Creates a new {@code AutoPopulatingList} that is backed by the supplied {@link List}\n\t * and creates new elements on demand using the supplied {@link ElementFactory}.\n\t */\n\tpublic AutoPopulatingList(List<E> backingList, ElementFactory<E> elementFactory) {\n\t\tAssert.notNull(backingList, \"Backing List must not be null\");\n\t\tAssert.notNull(elementFactory, \"Element factory must not be null\");\n\t\tthis.backingList = backingList;\n\t\tthis.elementFactory = elementFactory;\n\t}\n\n\n\t@Override\n\tpublic void add(int index, E element) {\n\t\tthis.backingList.add(index, element);\n\t}\n\n\t@Override\n\tpublic boolean add(E o) {\n\t\treturn this.backingList.add(o);\n\t}\n\n\t@Override\n\tpublic boolean addAll(Collection<? extends E> c) {\n\t\treturn this.backingList.addAll(c);\n\t}\n\n\t@Override\n\tpublic boolean addAll(int index, Collection<? extends E> c) {\n\t\treturn this.backingList.addAll(index, c);\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tthis.backingList.clear();\n\t}\n\n\t@Override\n\tpublic boolean contains(Object o) {\n\t\treturn this.backingList.contains(o);\n\t}\n\n\t@Override\n\tpublic boolean containsAll(Collection<?> c) {\n\t\treturn this.backingList.containsAll(c);\n\t}\n\n\t/**\n\t * Get the element at the supplied index, creating it if there is\n\t * no element at that index.\n\t */\n\t@Override\n\tpublic E get(int index) {\n\t\tint backingListSize = this.backingList.size();\n\t\tE element;\n\t\tif (index < backingListSize) {\n\t\t\telement = this.backingList.get(index);\n\t\t\tif (element == null) {\n\t\t\t\telement = this.elementFactory.createElement(index);\n\t\t\t\tthis.backingList.set(index, element);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int x = backingListSize; x < index; x++) {\n\t\t\t\tthis.backingList.add(null);\n\t\t\t}\n\t\t\telement = this.elementFactory.createElement(index);\n\t\t\tthis.backingList.add(element);\n\t\t}\n\t\treturn element;\n\t}\n\n\t@Override\n\tpublic int indexOf(Object o) {\n\t\treturn this.backingList.indexOf(o);\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn this.backingList.isEmpty();\n\t}\n\n\t@Override\n\tpublic Iterator<E> iterator() {\n\t\treturn this.backingList.iterator();\n\t}\n\n\t@Override\n\tpublic int lastIndexOf(Object o) {\n\t\treturn this.backingList.lastIndexOf(o);\n\t}\n\n\t@Override\n\tpublic ListIterator<E> listIterator() {\n\t\treturn this.backingList.listIterator();\n\t}\n\n\t@Override\n\tpublic ListIterator<E> listIterator(int index) {\n\t\treturn this.backingList.listIterator(index);\n\t}\n\n\t@Override\n\tpublic E remove(int index) {\n\t\treturn this.backingList.remove(index);\n\t}\n\n\t@Override\n\tpublic boolean remove(Object o) {\n\t\treturn this.backingList.remove(o);\n\t}\n\n\t@Override\n\tpublic boolean removeAll(Collection<?> c) {\n\t\treturn this.backingList.removeAll(c);\n\t}\n\n\t@Override\n\tpublic boolean retainAll(Collection<?> c) {\n\t\treturn this.backingList.retainAll(c);\n\t}\n\n\t@Override\n\tpublic E set(int index, E element) {\n\t\treturn this.backingList.set(index, element);\n\t}\n\n\t@Override\n\tpublic int size() {\n\t\treturn this.backingList.size();\n\t}\n\n\t@Override\n\tpublic List<E> subList(int fromIndex, int toIndex) {\n\t\treturn this.backingList.subList(fromIndex, toIndex);\n\t}\n\n\t@Override\n\tpublic Object[] toArray() {\n\t\treturn this.backingList.toArray();\n\t}\n\n\t@Override\n\tpublic <T> T[] toArray(T[] a) {\n\t\treturn this.backingList.toArray(a);\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn this.backingList.equals(other);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.backingList.hashCode();\n\t}\n\n\n\t/**\n\t * Factory interface for creating elements for an index-based access\n\t * data structure such as a {@link java.util.List}.\n\t *\n\t * @param <E> the element type\n\t */\n\t@FunctionalInterface\n\tpublic interface ElementFactory<E> {\n\n\t\t/**\n\t\t * Create the element for the supplied index.\n\t\t * @return the element object\n\t\t * @throws ElementInstantiationException if the instantiation process failed\n\t\t * (any exception thrown by a target constructor should be propagated as-is)\n\t\t */\n\t\tE createElement(int index) throws ElementInstantiationException;\n\t}\n\n\n\t/**\n\t * Exception to be thrown from ElementFactory.\n\t */\n\tpublic static class ElementInstantiationException extends RuntimeException {\n\n\t\tpublic ElementInstantiationException(String msg) {\n\t\t\tsuper(msg);\n\t\t}\n\n\t\tpublic ElementInstantiationException(String message, Throwable cause) {\n\t\t\tsuper(message, cause);\n\t\t}\n\t}\n\n\n\t/**\n\t * Reflective implementation of the ElementFactory interface, using\n\t * {@code Class.getDeclaredConstructor().newInstance()} on a given element class.\n\t */\n\tprivate static class ReflectiveElementFactory<E> implements ElementFactory<E>, Serializable {\n\n\t\tprivate final Class<? extends E> elementClass;\n\n\t\tpublic ReflectiveElementFactory(Class<? extends E> elementClass) {\n\t\t\tAssert.notNull(elementClass, \"Element class must not be null\");\n\t\t\tAssert.isTrue(!elementClass.isInterface(), \"Element class must not be an interface type\");\n\t\t\tAssert.isTrue(!Modifier.isAbstract(elementClass.getModifiers()), \"Element class cannot be an abstract class\");\n\t\t\tthis.elementClass = elementClass;\n\t\t}\n\n\t\t@Override\n\t\tpublic E createElement(int index) {\n\t\t\ttry {\n\t\t\t\treturn ReflectionUtils.accessibleConstructor(this.elementClass).newInstance();\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\tthrow new ElementInstantiationException(\n\t\t\t\t\t\t\"No default constructor on element class: \" + this.elementClass.getName(), ex);\n\t\t\t}\n\t\t\tcatch (InstantiationException ex) {\n\t\t\t\tthrow new ElementInstantiationException(\n\t\t\t\t\t\t\"Unable to instantiate element class: \" + this.elementClass.getName(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tthrow new ElementInstantiationException(\n\t\t\t\t\t\t\"Could not access element constructor: \" + this.elementClass.getName(), ex);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow new ElementInstantiationException(\n\t\t\t\t\t\t\"Failed to invoke element constructor: \" + this.elementClass.getName(), ex.getTargetException());\n\t\t\t}\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.ElementFactory#createElement(int)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Create the element for the supplied index.\r\n * @return the element object\r\n * @throws ElementInstantiationException if the instantiation process failed\r\n * (any exception thrown by a target constructor should be propagated as-is)\r\n */\r\nE createElement(int index) throws ElementInstantiationException;",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.ElementFactory",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.ElementFactory#createElement(int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.ElementInstantiationException",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.ElementInstantiationException",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\n\nimport org.jspecify.annotations.Nullable;\n\n/**\n * Simple {@link List} wrapper class that allows for elements to be\n * automatically populated as they are requested. This is particularly\n * useful for data binding to {@link List Lists}, allowing for elements\n * to be created and added to the {@link List} in a \"just in time\" fashion.\n *\n * <p>Note: This class is not thread-safe. To create a thread-safe version,\n * use the {@link java.util.Collections#synchronizedList} utility methods.\n *\n * <p>Inspired by {@code LazyList} from Commons Collections.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @since 2.0\n * @param <E> the element type\n */\n@SuppressWarnings(\"serial\")\npublic class AutoPopulatingList<E> implements List<E>, Serializable {\n\n\t/**\n\t * The {@link List} that all operations are eventually delegated to.\n\t */\n\tprivate final List<E> backingList;\n\n\t/**\n\t * The {@link ElementFactory} to use to create new {@link List} elements\n\t * on demand.\n\t */\n\tprivate final ElementFactory<E> elementFactory;\n\n\n\t/**\n\t * Creates a new {@code AutoPopulatingList} that is backed by a standard\n\t * {@link ArrayList} and adds new instances of the supplied {@link Class element Class}\n\t * to the backing {@link List} on demand.\n\t */\n\tpublic AutoPopulatingList(Class<? extends E> elementClass) {\n\t\tthis(new ArrayList<>(), elementClass);\n\t}\n\n\t/**\n\t * Creates a new {@code AutoPopulatingList} that is backed by the supplied {@link List}\n\t * and adds new instances of the supplied {@link Class element Class} to the backing\n\t * {@link List} on demand.\n\t */\n\tpublic AutoPopulatingList(List<E> backingList, Class<? extends E> elementClass) {\n\t\tthis(backingList, new ReflectiveElementFactory<>(elementClass));\n\t}\n\n\t/**\n\t * Creates a new {@code AutoPopulatingList} that is backed by a standard\n\t * {@link ArrayList} and creates new elements on demand using the supplied {@link ElementFactory}.\n\t */\n\tpublic AutoPopulatingList(ElementFactory<E> elementFactory) {\n\t\tthis(new ArrayList<>(), elementFactory);\n\t}\n\n\t/**\n\t * Creates a new {@code AutoPopulatingList} that is backed by the supplied {@link List}\n\t * and creates new elements on demand using the supplied {@link ElementFactory}.\n\t */\n\tpublic AutoPopulatingList(List<E> backingList, ElementFactory<E> elementFactory) {\n\t\tAssert.notNull(backingList, \"Backing List must not be null\");\n\t\tAssert.notNull(elementFactory, \"Element factory must not be null\");\n\t\tthis.backingList = backingList;\n\t\tthis.elementFactory = elementFactory;\n\t}\n\n\n\t@Override\n\tpublic void add(int index, E element) {\n\t\tthis.backingList.add(index, element);\n\t}\n\n\t@Override\n\tpublic boolean add(E o) {\n\t\treturn this.backingList.add(o);\n\t}\n\n\t@Override\n\tpublic boolean addAll(Collection<? extends E> c) {\n\t\treturn this.backingList.addAll(c);\n\t}\n\n\t@Override\n\tpublic boolean addAll(int index, Collection<? extends E> c) {\n\t\treturn this.backingList.addAll(index, c);\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tthis.backingList.clear();\n\t}\n\n\t@Override\n\tpublic boolean contains(Object o) {\n\t\treturn this.backingList.contains(o);\n\t}\n\n\t@Override\n\tpublic boolean containsAll(Collection<?> c) {\n\t\treturn this.backingList.containsAll(c);\n\t}\n\n\t/**\n\t * Get the element at the supplied index, creating it if there is\n\t * no element at that index.\n\t */\n\t@Override\n\tpublic E get(int index) {\n\t\tint backingListSize = this.backingList.size();\n\t\tE element;\n\t\tif (index < backingListSize) {\n\t\t\telement = this.backingList.get(index);\n\t\t\tif (element == null) {\n\t\t\t\telement = this.elementFactory.createElement(index);\n\t\t\t\tthis.backingList.set(index, element);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int x = backingListSize; x < index; x++) {\n\t\t\t\tthis.backingList.add(null);\n\t\t\t}\n\t\t\telement = this.elementFactory.createElement(index);\n\t\t\tthis.backingList.add(element);\n\t\t}\n\t\treturn element;\n\t}\n\n\t@Override\n\tpublic int indexOf(Object o) {\n\t\treturn this.backingList.indexOf(o);\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn this.backingList.isEmpty();\n\t}\n\n\t@Override\n\tpublic Iterator<E> iterator() {\n\t\treturn this.backingList.iterator();\n\t}\n\n\t@Override\n\tpublic int lastIndexOf(Object o) {\n\t\treturn this.backingList.lastIndexOf(o);\n\t}\n\n\t@Override\n\tpublic ListIterator<E> listIterator() {\n\t\treturn this.backingList.listIterator();\n\t}\n\n\t@Override\n\tpublic ListIterator<E> listIterator(int index) {\n\t\treturn this.backingList.listIterator(index);\n\t}\n\n\t@Override\n\tpublic E remove(int index) {\n\t\treturn this.backingList.remove(index);\n\t}\n\n\t@Override\n\tpublic boolean remove(Object o) {\n\t\treturn this.backingList.remove(o);\n\t}\n\n\t@Override\n\tpublic boolean removeAll(Collection<?> c) {\n\t\treturn this.backingList.removeAll(c);\n\t}\n\n\t@Override\n\tpublic boolean retainAll(Collection<?> c) {\n\t\treturn this.backingList.retainAll(c);\n\t}\n\n\t@Override\n\tpublic E set(int index, E element) {\n\t\treturn this.backingList.set(index, element);\n\t}\n\n\t@Override\n\tpublic int size() {\n\t\treturn this.backingList.size();\n\t}\n\n\t@Override\n\tpublic List<E> subList(int fromIndex, int toIndex) {\n\t\treturn this.backingList.subList(fromIndex, toIndex);\n\t}\n\n\t@Override\n\tpublic Object[] toArray() {\n\t\treturn this.backingList.toArray();\n\t}\n\n\t@Override\n\tpublic <T> T[] toArray(T[] a) {\n\t\treturn this.backingList.toArray(a);\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn this.backingList.equals(other);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.backingList.hashCode();\n\t}\n\n\n\t/**\n\t * Factory interface for creating elements for an index-based access\n\t * data structure such as a {@link java.util.List}.\n\t *\n\t * @param <E> the element type\n\t */\n\t@FunctionalInterface\n\tpublic interface ElementFactory<E> {\n\n\t\t/**\n\t\t * Create the element for the supplied index.\n\t\t * @return the element object\n\t\t * @throws ElementInstantiationException if the instantiation process failed\n\t\t * (any exception thrown by a target constructor should be propagated as-is)\n\t\t */\n\t\tE createElement(int index) throws ElementInstantiationException;\n\t}\n\n\n\t/**\n\t * Exception to be thrown from ElementFactory.\n\t */\n\tpublic static class ElementInstantiationException extends RuntimeException {\n\n\t\tpublic ElementInstantiationException(String msg) {\n\t\t\tsuper(msg);\n\t\t}\n\n\t\tpublic ElementInstantiationException(String message, Throwable cause) {\n\t\t\tsuper(message, cause);\n\t\t}\n\t}\n\n\n\t/**\n\t * Reflective implementation of the ElementFactory interface, using\n\t * {@code Class.getDeclaredConstructor().newInstance()} on a given element class.\n\t */\n\tprivate static class ReflectiveElementFactory<E> implements ElementFactory<E>, Serializable {\n\n\t\tprivate final Class<? extends E> elementClass;\n\n\t\tpublic ReflectiveElementFactory(Class<? extends E> elementClass) {\n\t\t\tAssert.notNull(elementClass, \"Element class must not be null\");\n\t\t\tAssert.isTrue(!elementClass.isInterface(), \"Element class must not be an interface type\");\n\t\t\tAssert.isTrue(!Modifier.isAbstract(elementClass.getModifiers()), \"Element class cannot be an abstract class\");\n\t\t\tthis.elementClass = elementClass;\n\t\t}\n\n\t\t@Override\n\t\tpublic E createElement(int index) {\n\t\t\ttry {\n\t\t\t\treturn ReflectionUtils.accessibleConstructor(this.elementClass).newInstance();\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\tthrow new ElementInstantiationException(\n\t\t\t\t\t\t\"No default constructor on element class: \" + this.elementClass.getName(), ex);\n\t\t\t}\n\t\t\tcatch (InstantiationException ex) {\n\t\t\t\tthrow new ElementInstantiationException(\n\t\t\t\t\t\t\"Unable to instantiate element class: \" + this.elementClass.getName(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tthrow new ElementInstantiationException(\n\t\t\t\t\t\t\"Could not access element constructor: \" + this.elementClass.getName(), ex);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow new ElementInstantiationException(\n\t\t\t\t\t\t\"Failed to invoke element constructor: \" + this.elementClass.getName(), ex.getTargetException());\n\t\t\t}\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.ElementInstantiationException",
    "headType": "class",
    "relation": "extend",
    "tail": "RuntimeException",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.ReflectiveElementFactory",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.ReflectiveElementFactory",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\n\nimport org.jspecify.annotations.Nullable;\n\n/**\n * Simple {@link List} wrapper class that allows for elements to be\n * automatically populated as they are requested. This is particularly\n * useful for data binding to {@link List Lists}, allowing for elements\n * to be created and added to the {@link List} in a \"just in time\" fashion.\n *\n * <p>Note: This class is not thread-safe. To create a thread-safe version,\n * use the {@link java.util.Collections#synchronizedList} utility methods.\n *\n * <p>Inspired by {@code LazyList} from Commons Collections.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @since 2.0\n * @param <E> the element type\n */\n@SuppressWarnings(\"serial\")\npublic class AutoPopulatingList<E> implements List<E>, Serializable {\n\n\t/**\n\t * The {@link List} that all operations are eventually delegated to.\n\t */\n\tprivate final List<E> backingList;\n\n\t/**\n\t * The {@link ElementFactory} to use to create new {@link List} elements\n\t * on demand.\n\t */\n\tprivate final ElementFactory<E> elementFactory;\n\n\n\t/**\n\t * Creates a new {@code AutoPopulatingList} that is backed by a standard\n\t * {@link ArrayList} and adds new instances of the supplied {@link Class element Class}\n\t * to the backing {@link List} on demand.\n\t */\n\tpublic AutoPopulatingList(Class<? extends E> elementClass) {\n\t\tthis(new ArrayList<>(), elementClass);\n\t}\n\n\t/**\n\t * Creates a new {@code AutoPopulatingList} that is backed by the supplied {@link List}\n\t * and adds new instances of the supplied {@link Class element Class} to the backing\n\t * {@link List} on demand.\n\t */\n\tpublic AutoPopulatingList(List<E> backingList, Class<? extends E> elementClass) {\n\t\tthis(backingList, new ReflectiveElementFactory<>(elementClass));\n\t}\n\n\t/**\n\t * Creates a new {@code AutoPopulatingList} that is backed by a standard\n\t * {@link ArrayList} and creates new elements on demand using the supplied {@link ElementFactory}.\n\t */\n\tpublic AutoPopulatingList(ElementFactory<E> elementFactory) {\n\t\tthis(new ArrayList<>(), elementFactory);\n\t}\n\n\t/**\n\t * Creates a new {@code AutoPopulatingList} that is backed by the supplied {@link List}\n\t * and creates new elements on demand using the supplied {@link ElementFactory}.\n\t */\n\tpublic AutoPopulatingList(List<E> backingList, ElementFactory<E> elementFactory) {\n\t\tAssert.notNull(backingList, \"Backing List must not be null\");\n\t\tAssert.notNull(elementFactory, \"Element factory must not be null\");\n\t\tthis.backingList = backingList;\n\t\tthis.elementFactory = elementFactory;\n\t}\n\n\n\t@Override\n\tpublic void add(int index, E element) {\n\t\tthis.backingList.add(index, element);\n\t}\n\n\t@Override\n\tpublic boolean add(E o) {\n\t\treturn this.backingList.add(o);\n\t}\n\n\t@Override\n\tpublic boolean addAll(Collection<? extends E> c) {\n\t\treturn this.backingList.addAll(c);\n\t}\n\n\t@Override\n\tpublic boolean addAll(int index, Collection<? extends E> c) {\n\t\treturn this.backingList.addAll(index, c);\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tthis.backingList.clear();\n\t}\n\n\t@Override\n\tpublic boolean contains(Object o) {\n\t\treturn this.backingList.contains(o);\n\t}\n\n\t@Override\n\tpublic boolean containsAll(Collection<?> c) {\n\t\treturn this.backingList.containsAll(c);\n\t}\n\n\t/**\n\t * Get the element at the supplied index, creating it if there is\n\t * no element at that index.\n\t */\n\t@Override\n\tpublic E get(int index) {\n\t\tint backingListSize = this.backingList.size();\n\t\tE element;\n\t\tif (index < backingListSize) {\n\t\t\telement = this.backingList.get(index);\n\t\t\tif (element == null) {\n\t\t\t\telement = this.elementFactory.createElement(index);\n\t\t\t\tthis.backingList.set(index, element);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int x = backingListSize; x < index; x++) {\n\t\t\t\tthis.backingList.add(null);\n\t\t\t}\n\t\t\telement = this.elementFactory.createElement(index);\n\t\t\tthis.backingList.add(element);\n\t\t}\n\t\treturn element;\n\t}\n\n\t@Override\n\tpublic int indexOf(Object o) {\n\t\treturn this.backingList.indexOf(o);\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn this.backingList.isEmpty();\n\t}\n\n\t@Override\n\tpublic Iterator<E> iterator() {\n\t\treturn this.backingList.iterator();\n\t}\n\n\t@Override\n\tpublic int lastIndexOf(Object o) {\n\t\treturn this.backingList.lastIndexOf(o);\n\t}\n\n\t@Override\n\tpublic ListIterator<E> listIterator() {\n\t\treturn this.backingList.listIterator();\n\t}\n\n\t@Override\n\tpublic ListIterator<E> listIterator(int index) {\n\t\treturn this.backingList.listIterator(index);\n\t}\n\n\t@Override\n\tpublic E remove(int index) {\n\t\treturn this.backingList.remove(index);\n\t}\n\n\t@Override\n\tpublic boolean remove(Object o) {\n\t\treturn this.backingList.remove(o);\n\t}\n\n\t@Override\n\tpublic boolean removeAll(Collection<?> c) {\n\t\treturn this.backingList.removeAll(c);\n\t}\n\n\t@Override\n\tpublic boolean retainAll(Collection<?> c) {\n\t\treturn this.backingList.retainAll(c);\n\t}\n\n\t@Override\n\tpublic E set(int index, E element) {\n\t\treturn this.backingList.set(index, element);\n\t}\n\n\t@Override\n\tpublic int size() {\n\t\treturn this.backingList.size();\n\t}\n\n\t@Override\n\tpublic List<E> subList(int fromIndex, int toIndex) {\n\t\treturn this.backingList.subList(fromIndex, toIndex);\n\t}\n\n\t@Override\n\tpublic Object[] toArray() {\n\t\treturn this.backingList.toArray();\n\t}\n\n\t@Override\n\tpublic <T> T[] toArray(T[] a) {\n\t\treturn this.backingList.toArray(a);\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn this.backingList.equals(other);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.backingList.hashCode();\n\t}\n\n\n\t/**\n\t * Factory interface for creating elements for an index-based access\n\t * data structure such as a {@link java.util.List}.\n\t *\n\t * @param <E> the element type\n\t */\n\t@FunctionalInterface\n\tpublic interface ElementFactory<E> {\n\n\t\t/**\n\t\t * Create the element for the supplied index.\n\t\t * @return the element object\n\t\t * @throws ElementInstantiationException if the instantiation process failed\n\t\t * (any exception thrown by a target constructor should be propagated as-is)\n\t\t */\n\t\tE createElement(int index) throws ElementInstantiationException;\n\t}\n\n\n\t/**\n\t * Exception to be thrown from ElementFactory.\n\t */\n\tpublic static class ElementInstantiationException extends RuntimeException {\n\n\t\tpublic ElementInstantiationException(String msg) {\n\t\t\tsuper(msg);\n\t\t}\n\n\t\tpublic ElementInstantiationException(String message, Throwable cause) {\n\t\t\tsuper(message, cause);\n\t\t}\n\t}\n\n\n\t/**\n\t * Reflective implementation of the ElementFactory interface, using\n\t * {@code Class.getDeclaredConstructor().newInstance()} on a given element class.\n\t */\n\tprivate static class ReflectiveElementFactory<E> implements ElementFactory<E>, Serializable {\n\n\t\tprivate final Class<? extends E> elementClass;\n\n\t\tpublic ReflectiveElementFactory(Class<? extends E> elementClass) {\n\t\t\tAssert.notNull(elementClass, \"Element class must not be null\");\n\t\t\tAssert.isTrue(!elementClass.isInterface(), \"Element class must not be an interface type\");\n\t\t\tAssert.isTrue(!Modifier.isAbstract(elementClass.getModifiers()), \"Element class cannot be an abstract class\");\n\t\t\tthis.elementClass = elementClass;\n\t\t}\n\n\t\t@Override\n\t\tpublic E createElement(int index) {\n\t\t\ttry {\n\t\t\t\treturn ReflectionUtils.accessibleConstructor(this.elementClass).newInstance();\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\tthrow new ElementInstantiationException(\n\t\t\t\t\t\t\"No default constructor on element class: \" + this.elementClass.getName(), ex);\n\t\t\t}\n\t\t\tcatch (InstantiationException ex) {\n\t\t\t\tthrow new ElementInstantiationException(\n\t\t\t\t\t\t\"Unable to instantiate element class: \" + this.elementClass.getName(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tthrow new ElementInstantiationException(\n\t\t\t\t\t\t\"Could not access element constructor: \" + this.elementClass.getName(), ex);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow new ElementInstantiationException(\n\t\t\t\t\t\t\"Failed to invoke element constructor: \" + this.elementClass.getName(), ex.getTargetException());\n\t\t\t}\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.ReflectiveElementFactory",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.ReflectiveElementFactory#elementClass",
    "tailType": "field"
  },
  {
    "head": "org.springframework.util.ReflectiveElementFactory#elementClass",
    "headType": "field",
    "relation": "haveType",
    "tail": "Class<? extends E>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.util.ReflectiveElementFactory#createElement(int)",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic E createElement(int index) {\r\n    try {\r\n        return ReflectionUtils.accessibleConstructor(this.elementClass).newInstance();\r\n    } catch (NoSuchMethodException ex) {\r\n        throw new ElementInstantiationException(\"No default constructor on element class: \" + this.elementClass.getName(), ex);\r\n    } catch (InstantiationException ex) {\r\n        throw new ElementInstantiationException(\"Unable to instantiate element class: \" + this.elementClass.getName(), ex);\r\n    } catch (IllegalAccessException ex) {\r\n        throw new ElementInstantiationException(\"Could not access element constructor: \" + this.elementClass.getName(), ex);\r\n    } catch (InvocationTargetException ex) {\r\n        throw new ElementInstantiationException(\"Failed to invoke element constructor: \" + this.elementClass.getName(), ex.getTargetException());\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.ReflectiveElementFactory",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.ReflectiveElementFactory#createElement(int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.ReflectiveElementFactory#createElement(int)",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.util.backoff",
    "tailType": "package"
  },
  {
    "head": "org.springframework.util.backoff",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.backoff.BackOff",
    "tailType": "class"
  }
]