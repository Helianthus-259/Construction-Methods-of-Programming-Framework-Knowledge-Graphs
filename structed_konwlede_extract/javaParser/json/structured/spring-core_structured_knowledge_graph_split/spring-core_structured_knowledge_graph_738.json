[
  {
    "head": "org.springframework.core.annotation.AnnotatedElementUtils#getRepeatableAnnotations(AnnotatedElement,Class<? extends Annotation>,Class<? extends Annotation>)",
    "headType": "method",
    "relation": "provide",
    "tail": "private static MergedAnnotations getRepeatableAnnotations(AnnotatedElement element, @Nullable Class<? extends Annotation> containerType, Class<? extends Annotation> annotationType) {\r\n    RepeatableContainers repeatableContainers;\r\n    if (containerType == null) {\r\n        // Invoke RepeatableContainers.of() in order to adhere to the contract of\r\n        // getMergedRepeatableAnnotations() which states that an IllegalArgumentException\r\n        // will be thrown if the container cannot be resolved.\r\n        //\r\n        // In any case, we use standardRepeatables() in order to support repeatable\r\n        // annotations on other types of repeatable annotations (i.e., nested repeatable\r\n        // annotation types).\r\n        //\r\n        // See https://github.com/spring-projects/spring-framework/issues/20279\r\n        RepeatableContainers.of(annotationType, null);\r\n        repeatableContainers = RepeatableContainers.standardRepeatables();\r\n    } else {\r\n        repeatableContainers = RepeatableContainers.of(annotationType, containerType);\r\n    }\r\n    return MergedAnnotations.from(element, SearchStrategy.INHERITED_ANNOTATIONS, repeatableContainers);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotatedElementUtils",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotatedElementUtils#getRepeatableAnnotations(AnnotatedElement,Class<? extends Annotation>,Class<? extends Annotation>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotatedElementUtils#findAnnotations(AnnotatedElement)",
    "headType": "method",
    "relation": "provide",
    "tail": "private static MergedAnnotations findAnnotations(AnnotatedElement element) {\r\n    return MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none());\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotatedElementUtils",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotatedElementUtils#findAnnotations(AnnotatedElement)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotatedElementUtils#findRepeatableAnnotations(AnnotatedElement,Class<? extends Annotation>,Class<? extends Annotation>)",
    "headType": "method",
    "relation": "provide",
    "tail": "private static MergedAnnotations findRepeatableAnnotations(AnnotatedElement element, @Nullable Class<? extends Annotation> containerType, Class<? extends Annotation> annotationType) {\r\n    RepeatableContainers repeatableContainers;\r\n    if (containerType == null) {\r\n        // Invoke RepeatableContainers.of() in order to adhere to the contract of\r\n        // findMergedRepeatableAnnotations() which states that an IllegalArgumentException\r\n        // will be thrown if the container cannot be resolved.\r\n        //\r\n        // In any case, we use standardRepeatables() in order to support repeatable\r\n        // annotations on other types of repeatable annotations (i.e., nested repeatable\r\n        // annotation types).\r\n        //\r\n        // See https://github.com/spring-projects/spring-framework/issues/20279\r\n        RepeatableContainers.of(annotationType, null);\r\n        repeatableContainers = RepeatableContainers.standardRepeatables();\r\n    } else {\r\n        repeatableContainers = RepeatableContainers.of(annotationType, containerType);\r\n    }\r\n    return MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY, repeatableContainers);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotatedElementUtils",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotatedElementUtils#findRepeatableAnnotations(AnnotatedElement,Class<? extends Annotation>,Class<? extends Annotation>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotatedElementUtils#nullIfEmpty(MultiValueMap<String,Object>)",
    "headType": "method",
    "relation": "provide",
    "tail": "@Nullable\r\nprivate static MultiValueMap<String, Object> nullIfEmpty(MultiValueMap<String, Object> map) {\r\n    return (map.isEmpty() ? null : map);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotatedElementUtils",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotatedElementUtils#nullIfEmpty(MultiValueMap<String,Object>)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotatedElementUtils#nullIfEmpty(MultiValueMap<String,Object>)",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AnnotatedElementUtils#highAggregateIndexesFirst()",
    "headType": "method",
    "relation": "provide",
    "tail": "private static <A extends Annotation> Comparator<MergedAnnotation<A>> highAggregateIndexesFirst() {\r\n    return Comparator.<MergedAnnotation<A>>comparingInt(MergedAnnotation::getAggregateIndex).reversed();\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotatedElementUtils",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotatedElementUtils#highAggregateIndexesFirst()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotatedElementUtils#getAnnotationAttributes(MergedAnnotation<?>,boolean,boolean)",
    "headType": "method",
    "relation": "provide",
    "tail": "@Nullable\r\nprivate static AnnotationAttributes getAnnotationAttributes(MergedAnnotation<?> annotation, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {\r\n    if (!annotation.isPresent()) {\r\n        return null;\r\n    }\r\n    return annotation.asAnnotationAttributes(Adapt.values(classValuesAsString, nestedAnnotationsAsMap));\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotatedElementUtils",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotatedElementUtils#getAnnotationAttributes(MergedAnnotation<?>,boolean,boolean)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.annotation.AnnotatedElementUtils#getAnnotationAttributes(MergedAnnotation<?>,boolean,boolean)",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.AnnotatedElementForAnnotations",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.AnnotatedElementForAnnotations",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AnnotatedElement;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.core.BridgeMethodResolver;\nimport org.springframework.core.annotation.MergedAnnotation.Adapt;\nimport org.springframework.core.annotation.MergedAnnotations.SearchStrategy;\nimport org.springframework.util.MultiValueMap;\n\n/**\n * General utility methods for finding annotations, meta-annotations, and\n * repeatable annotations on {@link AnnotatedElement AnnotatedElements}.\n *\n * <p>{@code AnnotatedElementUtils} defines the public API for Spring's\n * meta-annotation programming model with support for <em>annotation attribute\n * overrides</em>. If you do not need support for annotation attribute\n * overrides, consider using {@link AnnotationUtils} instead.\n *\n * <p>Note that the features of this class are not provided by the JDK's\n * introspection facilities themselves.\n *\n * <h3>Annotation Attribute Overrides</h3>\n * <p>Support for meta-annotations with <em>attribute overrides</em> in\n * <em>composed annotations</em> is provided by all variants of the\n * {@code getMergedAnnotationAttributes()}, {@code getMergedAnnotation()},\n * {@code getAllMergedAnnotations()}, {@code getMergedRepeatableAnnotations()},\n * {@code findMergedAnnotationAttributes()}, {@code findMergedAnnotation()},\n * {@code findAllMergedAnnotations()}, and {@code findMergedRepeatableAnnotations()}\n * methods.\n *\n * <h3>Find vs. Get Semantics</h3>\n * <p>The search algorithms used by methods in this class follow either\n * <em>find</em> or <em>get</em> semantics. Consult the javadocs for each\n * individual method for details on which search algorithm is used.\n *\n * <p><strong>Get semantics</strong> are limited to searching for annotations\n * that are either <em>present</em> on an {@code AnnotatedElement} (i.e. declared\n * locally or {@linkplain java.lang.annotation.Inherited inherited}) or declared\n * within the annotation hierarchy <em>above</em> the {@code AnnotatedElement}.\n *\n * <p><strong>Find semantics</strong> are much more exhaustive, providing\n * <em>get semantics</em> plus support for the following:\n *\n * <ul>\n * <li>Searching on interfaces, if the annotated element is a class\n * <li>Searching on superclasses, if the annotated element is a class\n * <li>Resolving bridged methods, if the annotated element is a method\n * <li>Searching on methods in interfaces, if the annotated element is a method\n * <li>Searching on methods in superclasses, if the annotated element is a method\n * </ul>\n *\n * <h3>Support for {@code @Inherited}</h3>\n * <p>Methods following <em>get semantics</em> will honor the contract of Java's\n * {@link java.lang.annotation.Inherited @Inherited} annotation except that locally\n * declared annotations (including custom composed annotations) will be favored over\n * inherited annotations. In contrast, methods following <em>find semantics</em>\n * will completely ignore the presence of {@code @Inherited} since the <em>find</em>\n * search algorithm manually traverses type and method hierarchies and thereby\n * implicitly supports annotation inheritance without a need for {@code @Inherited}.\n *\n * @author Phillip Webb\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 4.0\n * @see AliasFor\n * @see AnnotationAttributes\n * @see AnnotationUtils\n * @see BridgeMethodResolver\n */\npublic abstract class AnnotatedElementUtils {\n\n\t/**\n\t * Build an adapted {@link AnnotatedElement} for the given annotations,\n\t * typically for use with other methods on {@link AnnotatedElementUtils}.\n\t * @param annotations the annotations to expose through the {@code AnnotatedElement}\n\t * @since 4.3\n\t */\n\tpublic static AnnotatedElement forAnnotations(Annotation... annotations) {\n\t\treturn new AnnotatedElementForAnnotations(annotations);\n\t}\n\n\t/**\n\t * Get the fully qualified class names of all meta-annotation types\n\t * <em>present</em> on the annotation (of the specified {@code annotationType})\n\t * on the supplied {@link AnnotatedElement}.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type on which to find meta-annotations\n\t * @return the names of all meta-annotations present on the annotation,\n\t * or an empty set if not found\n\t * @since 4.2\n\t * @see #getMetaAnnotationTypes(AnnotatedElement, String)\n\t * @see #hasMetaAnnotationTypes\n\t */\n\tpublic static Set<String> getMetaAnnotationTypes(AnnotatedElement element,\n\t\t\tClass<? extends Annotation> annotationType) {\n\n\t\treturn getMetaAnnotationTypes(element, element.getAnnotation(annotationType));\n\t}\n\n\t/**\n\t * Get the fully qualified class names of all meta-annotation\n\t * types <em>present</em> on the annotation (of the specified\n\t * {@code annotationName}) on the supplied {@link AnnotatedElement}.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation\n\t * type on which to find meta-annotations\n\t * @return the names of all meta-annotations present on the annotation,\n\t * or an empty set if none found\n\t * @see #getMetaAnnotationTypes(AnnotatedElement, Class)\n\t * @see #hasMetaAnnotationTypes\n\t */\n\tpublic static Set<String> getMetaAnnotationTypes(AnnotatedElement element, String annotationName) {\n\t\tfor (Annotation annotation : element.getAnnotations()) {\n\t\t\tif (annotation.annotationType().getName().equals(annotationName)) {\n\t\t\t\treturn getMetaAnnotationTypes(element, annotation);\n\t\t\t}\n\t\t}\n\t\treturn Collections.emptySet();\n\t}\n\n\tprivate static Set<String> getMetaAnnotationTypes(AnnotatedElement element, @Nullable Annotation annotation) {\n\t\tif (annotation == null) {\n\t\t\treturn Collections.emptySet();\n\t\t}\n\t\treturn getAnnotations(annotation.annotationType()).stream()\n\t\t\t\t.map(mergedAnnotation -> mergedAnnotation.getType().getName())\n\t\t\t\t.collect(Collectors.toCollection(LinkedHashSet::new));\n\t}\n\n\t/**\n\t * Determine if the supplied {@link AnnotatedElement} is annotated with\n\t * a <em>composed annotation</em> that is meta-annotated with an\n\t * annotation of the specified {@code annotationType}.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the meta-annotation type to find\n\t * @return {@code true} if a matching meta-annotation is present\n\t * @since 4.2.3\n\t * @see #getMetaAnnotationTypes\n\t */\n\tpublic static boolean hasMetaAnnotationTypes(AnnotatedElement element, Class<? extends Annotation> annotationType) {\n\t\treturn getAnnotations(element).stream(annotationType).anyMatch(MergedAnnotation::isMetaPresent);\n\t}\n\n\t/**\n\t * Determine if the supplied {@link AnnotatedElement} is annotated with a\n\t * <em>composed annotation</em> that is meta-annotated with an annotation\n\t * of the specified {@code annotationName}.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the\n\t * meta-annotation type to find\n\t * @return {@code true} if a matching meta-annotation is present\n\t * @see #getMetaAnnotationTypes\n\t */\n\tpublic static boolean hasMetaAnnotationTypes(AnnotatedElement element, String annotationName) {\n\t\treturn getAnnotations(element).stream(annotationName).anyMatch(MergedAnnotation::isMetaPresent);\n\t}\n\n\t/**\n\t * Determine if an annotation of the specified {@code annotationType}\n\t * is <em>present</em> on the supplied {@link AnnotatedElement} or\n\t * within the annotation hierarchy <em>above</em> the specified element.\n\t * <p>If this method returns {@code true}, then {@link #getMergedAnnotationAttributes}\n\t * will return a non-null value.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return {@code true} if a matching annotation is present\n\t * @since 4.2.3\n\t * @see #hasAnnotation(AnnotatedElement, Class)\n\t */\n\tpublic static boolean isAnnotated(AnnotatedElement element, Class<? extends Annotation> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\n\t\t\treturn element.isAnnotationPresent(annotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn getAnnotations(element).isPresent(annotationType);\n\t}\n\n\t/**\n\t * Determine if an annotation of the specified {@code annotationName} is\n\t * <em>present</em> on the supplied {@link AnnotatedElement} or within the\n\t * annotation hierarchy <em>above</em> the specified element.\n\t * <p>If this method returns {@code true}, then {@link #getMergedAnnotationAttributes}\n\t * will return a non-null value.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @return {@code true} if a matching annotation is present\n\t */\n\tpublic static boolean isAnnotated(AnnotatedElement element, String annotationName) {\n\t\treturn getAnnotations(element).isPresent(annotationName);\n\t}\n\n\t/**\n\t * Get the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element} and\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>This method delegates to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #getMergedAnnotation(AnnotatedElement, Class)\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t */\n\tpublic static @Nullable AnnotationAttributes getMergedAnnotationAttributes(\n\t\t\tAnnotatedElement element, Class<? extends Annotation> annotationType) {\n\n\t\tMergedAnnotation<?> mergedAnnotation = getAnnotations(element)\n\t\t\t\t.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared());\n\t\treturn getAnnotationAttributes(mergedAnnotation, false, false);\n\t}\n\n\t/**\n\t * Get the first annotation of the specified {@code annotationName} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element} and\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>This method delegates to {@link #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)},\n\t * supplying {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getAllAnnotationAttributes(AnnotatedElement, String)\n\t */\n\tpublic static @Nullable AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element,\n\t\t\tString annotationName) {\n\n\t\treturn getMergedAnnotationAttributes(element, annotationName, false, false);\n\t}\n\n\t/**\n\t * Get the first annotation of the specified {@code annotationName} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element} and\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy.\n\t * <p>Attributes from lower levels in the annotation hierarchy override attributes\n\t * of the same name from higher levels, and {@link AliasFor @AliasFor} semantics are\n\t * fully supported, both within a single annotation and within the annotation hierarchy.\n\t * <p>In contrast to {@link #getAllAnnotationAttributes}, the search algorithm used by\n\t * this method will stop searching the annotation hierarchy once the first annotation\n\t * of the specified {@code annotationName} has been found. As a consequence,\n\t * additional annotations of the specified {@code annotationName} will be ignored.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @param classValuesAsString whether to convert Class references into Strings or to\n\t * preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested Annotation instances\n\t * into {@code AnnotationAttributes} maps or to preserve them as Annotation instances\n\t * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #getAllAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t */\n\tpublic static @Nullable AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element,\n\t\t\tString annotationName, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {\n\n\t\tMergedAnnotation<?> mergedAnnotation = getAnnotations(element)\n\t\t\t\t.get(annotationName, null, MergedAnnotationSelectors.firstDirectlyDeclared());\n\t\treturn getAnnotationAttributes(mergedAnnotation, classValuesAsString, nestedAnnotationsAsMap);\n\t}\n\n\t/**\n\t * Get the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element},\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy, and synthesize\n\t * the result back into an annotation of the specified {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t */\n\tpublic static <A extends Annotation> @Nullable A getMergedAnnotation(AnnotatedElement element, Class<A> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\n\t\t\treturn element.getDeclaredAnnotation(annotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn getAnnotations(element)\n\t\t\t\t.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared())\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}\n\n\t/**\n\t * Get <strong>all</strong> annotations of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @return the set of all merged, synthesized {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @since 4.3\n\t * @see #getMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getAllAnnotationAttributes(AnnotatedElement, String)\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t */\n\tpublic static <A extends Annotation> Set<A> getAllMergedAnnotations(\n\t\t\tAnnotatedElement element, Class<A> annotationType) {\n\n\t\treturn getAnnotations(element).stream(annotationType)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}\n\n\t/**\n\t * Get <strong>all</strong> annotations of the specified {@code annotationTypes}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the\n\t * annotation hierarchy and synthesize the results back into an annotation\n\t * of the corresponding {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationTypes the annotation types to find\n\t * @return the set of all merged, synthesized {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @since 5.1\n\t * @see #getAllMergedAnnotations(AnnotatedElement, Class)\n\t */\n\tpublic static Set<Annotation> getAllMergedAnnotations(AnnotatedElement element,\n\t\t\tSet<Class<? extends Annotation>> annotationTypes) {\n\n\t\treturn getAnnotations(element).stream()\n\t\t\t\t.filter(MergedAnnotationPredicates.typeIn(annotationTypes))\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}\n\n\t/**\n\t * Get all <em>repeatable annotations</em> of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>The container type that holds the repeatable annotations will be looked up\n\t * via {@link java.lang.annotation.Repeatable}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @return the set of all merged repeatable {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\n\t * is {@code null}, or if the container type cannot be resolved\n\t * @since 4.3\n\t * @see #getMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getAllMergedAnnotations(AnnotatedElement, Class)\n\t * @see #getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t */\n\tpublic static <A extends Annotation> Set<A> getMergedRepeatableAnnotations(\n\t\t\tAnnotatedElement element, Class<A> annotationType) {\n\n\t\treturn getMergedRepeatableAnnotations(element, annotationType, null);\n\t}\n\n\t/**\n\t * Get all <em>repeatable annotations</em> of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * <p><strong>WARNING</strong>: if the supplied {@code containerType} is not\n\t * {@code null}, the search will be restricted to supporting only repeatable\n\t * annotations whose container is the supplied {@code containerType}. This\n\t * prevents the search from finding repeatable annotations declared as\n\t * meta-annotations on other types of repeatable annotations. If you need to\n\t * support such a use case, favor {@link #getMergedRepeatableAnnotations(AnnotatedElement, Class)}\n\t * over this method or alternatively use the {@link MergedAnnotations} API\n\t * directly in conjunction with {@link RepeatableContainers} that are\n\t * {@linkplain RepeatableContainers#and(Class, Class) composed} to support\n\t * multiple repeatable annotation types.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @param containerType the type of the container that holds the annotations;\n\t * may be {@code null} if the container type should be looked up via\n\t * {@link java.lang.annotation.Repeatable}\n\t * @return the set of all merged repeatable {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\n\t * is {@code null}, or if the container type cannot be resolved\n\t * @throws AnnotationConfigurationException if the supplied {@code containerType}\n\t * is not a valid container annotation for the supplied {@code annotationType}\n\t * @since 4.3\n\t * @see #getMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getAllMergedAnnotations(AnnotatedElement, Class)\n\t */\n\tpublic static <A extends Annotation> Set<A> getMergedRepeatableAnnotations(\n\t\t\tAnnotatedElement element, Class<A> annotationType,\n\t\t\t@Nullable Class<? extends Annotation> containerType) {\n\n\t\treturn getRepeatableAnnotations(element, containerType, annotationType)\n\t\t\t\t.stream(annotationType)\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}\n\n\t/**\n\t * Get the annotation attributes of <strong>all</strong> annotations of the specified\n\t * {@code annotationName} in the annotation hierarchy above the supplied\n\t * {@link AnnotatedElement} and store the results in a {@link MultiValueMap}.\n\t * <p>Note: in contrast to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)},\n\t * this method does <em>not</em> support attribute overrides.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @return a {@link MultiValueMap} keyed by attribute name, containing the annotation\n\t * attributes from all annotations found, or {@code null} if not found\n\t * @see #getAllAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t */\n\tpublic static MultiValueMap<String, @Nullable Object> getAllAnnotationAttributes(\n\t\t\tAnnotatedElement element, String annotationName) {\n\n\t\treturn getAllAnnotationAttributes(element, annotationName, false, false);\n\t}\n\n\t/**\n\t * Get the annotation attributes of <strong>all</strong> annotations of\n\t * the specified {@code annotationName} in the annotation hierarchy above\n\t * the supplied {@link AnnotatedElement} and store the results in a\n\t * {@link MultiValueMap}.\n\t * <p>Note: in contrast to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)},\n\t * this method does <em>not</em> support attribute overrides.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @param classValuesAsString whether to convert Class references into Strings or to\n\t * preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into\n\t * {@code AnnotationAttributes} maps or to preserve them as Annotation instances\n\t * @return a {@link MultiValueMap} keyed by attribute name, containing the annotation\n\t * attributes from all annotations found, or {@code null} if not found\n\t */\n\tpublic static MultiValueMap<String, @Nullable Object> getAllAnnotationAttributes(AnnotatedElement element,\n\t\t\tString annotationName, final boolean classValuesAsString, final boolean nestedAnnotationsAsMap) {\n\n\t\tAdapt[] adaptations = Adapt.values(classValuesAsString, nestedAnnotationsAsMap);\n\t\treturn getAnnotations(element).stream(annotationName)\n\t\t\t\t.filter(MergedAnnotationPredicates.unique(MergedAnnotation::getMetaTypes))\n\t\t\t\t.map(MergedAnnotation::withNonMergedAttributes)\n\t\t\t\t.collect(MergedAnnotationCollectors.toMultiValueMap(AnnotatedElementUtils::nullIfEmpty, adaptations));\n\t}\n\n\t/**\n\t * Determine if an annotation of the specified {@code annotationType}\n\t * is <em>available</em> on the supplied {@link AnnotatedElement} or\n\t * within the annotation hierarchy <em>above</em> the specified element.\n\t * <p>If this method returns {@code true}, then {@link #findMergedAnnotationAttributes}\n\t * will return a non-null value.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return {@code true} if a matching annotation is present\n\t * @since 4.3\n\t * @see #isAnnotated(AnnotatedElement, Class)\n\t */\n\tpublic static boolean hasAnnotation(AnnotatedElement element, Class<? extends Annotation> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\n\t\t\treturn element.isAnnotationPresent(annotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn findAnnotations(element).isPresent(annotationType);\n\t}\n\n\t/**\n\t * Find the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element} and\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy.\n\t * <p>Attributes from lower levels in the annotation hierarchy override\n\t * attributes of the same name from higher levels, and\n\t * {@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>In contrast to {@link #getAllAnnotationAttributes}, the search algorithm\n\t * used by this method will stop searching the annotation hierarchy once the\n\t * first annotation of the specified {@code annotationType} has been found.\n\t * As a consequence, additional annotations of the specified\n\t * {@code annotationType} will be ignored.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @param classValuesAsString whether to convert Class references into\n\t * Strings or to preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into\n\t * {@code AnnotationAttributes} maps or to preserve them as Annotation instances\n\t * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t */\n\tpublic static @Nullable AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element,\n\t\t\tClass<? extends Annotation> annotationType, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {\n\n\t\tMergedAnnotation<?> mergedAnnotation = findAnnotations(element)\n\t\t\t\t.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared());\n\t\treturn getAnnotationAttributes(mergedAnnotation, classValuesAsString, nestedAnnotationsAsMap);\n\t}\n\n\t/**\n\t * Find the first annotation of the specified {@code annotationName} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element} and\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy.\n\t * <p>Attributes from lower levels in the annotation hierarchy override\n\t * attributes of the same name from higher levels, and\n\t * {@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>In contrast to {@link #getAllAnnotationAttributes}, the search\n\t * algorithm used by this method will stop searching the annotation\n\t * hierarchy once the first annotation of the specified\n\t * {@code annotationName} has been found. As a consequence, additional\n\t * annotations of the specified {@code annotationName} will be ignored.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @param classValuesAsString whether to convert Class references into Strings or to\n\t * preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into\n\t * {@code AnnotationAttributes} maps or to preserve them as Annotation instances\n\t * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t */\n\tpublic static @Nullable AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element,\n\t\t\tString annotationName, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {\n\n\t\tMergedAnnotation<?> mergedAnnotation = findAnnotations(element)\n\t\t\t\t.get(annotationName, null, MergedAnnotationSelectors.firstDirectlyDeclared());\n\t\treturn getAnnotationAttributes(mergedAnnotation, classValuesAsString, nestedAnnotationsAsMap);\n\t}\n\n\t/**\n\t * Find the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element},\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy, and synthesize\n\t * the result back into an annotation of the specified {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, Class)\n\t */\n\tpublic static <A extends Annotation> @Nullable A findMergedAnnotation(AnnotatedElement element, Class<A> annotationType) {\n\t\t// Shortcut: directly present on the element, with no merging needed?\n\t\tif (AnnotationFilter.PLAIN.matches(annotationType) ||\n\t\t\t\tAnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\n\t\t\treturn element.getDeclaredAnnotation(annotationType);\n\t\t}\n\t\t// Exhaustive retrieval of merged annotations...\n\t\treturn findAnnotations(element)\n\t\t\t\t.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared())\n\t\t\t\t.synthesize(MergedAnnotation::isPresent).orElse(null);\n\t}\n\n\t/**\n\t * Find <strong>all</strong> annotations of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @return the set of all merged, synthesized {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @since 4.3\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getAllMergedAnnotations(AnnotatedElement, Class)\n\t */\n\tpublic static <A extends Annotation> Set<A> findAllMergedAnnotations(AnnotatedElement element, Class<A> annotationType) {\n\t\treturn findAnnotations(element).stream(annotationType)\n\t\t\t\t.sorted(highAggregateIndexesFirst())\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}\n\n\t/**\n\t * Find <strong>all</strong> annotations of the specified {@code annotationTypes}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the\n\t * annotation hierarchy and synthesize the results back into an annotation\n\t * of the corresponding {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationTypes the annotation types to find\n\t * @return the set of all merged, synthesized {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @since 5.1\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t */\n\tpublic static Set<Annotation> findAllMergedAnnotations(AnnotatedElement element, Set<Class<? extends Annotation>> annotationTypes) {\n\t\treturn findAnnotations(element).stream()\n\t\t\t\t.filter(MergedAnnotationPredicates.typeIn(annotationTypes))\n\t\t\t\t.sorted(highAggregateIndexesFirst())\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}\n\n\t/**\n\t * Find all <em>repeatable annotations</em> of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>The container type that holds the repeatable annotations will be looked up\n\t * via {@link java.lang.annotation.Repeatable}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @return the set of all merged repeatable {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\n\t * is {@code null}, or if the container type cannot be resolved\n\t * @since 4.3\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t * @see #findMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t */\n\tpublic static <A extends Annotation> Set<A> findMergedRepeatableAnnotations(AnnotatedElement element,\n\t\t\tClass<A> annotationType) {\n\n\t\treturn findMergedRepeatableAnnotations(element, annotationType, null);\n\t}\n\n\t/**\n\t * Find all <em>repeatable annotations</em> of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * <p><strong>WARNING</strong>: if the supplied {@code containerType} is not\n\t * {@code null}, the search will be restricted to supporting only repeatable\n\t * annotations whose container is the supplied {@code containerType}. This\n\t * prevents the search from finding repeatable annotations declared as\n\t * meta-annotations on other types of repeatable annotations. If you need to\n\t * support such a use case, favor {@link #findMergedRepeatableAnnotations(AnnotatedElement, Class)}\n\t * over this method or alternatively use the {@link MergedAnnotations} API\n\t * directly in conjunction with {@link RepeatableContainers} that are\n\t * {@linkplain RepeatableContainers#and(Class, Class) composed} to support\n\t * multiple repeatable annotation types.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @param containerType the type of the container that holds the annotations;\n\t * may be {@code null} if the container type should be looked up via\n\t * {@link java.lang.annotation.Repeatable}\n\t * @return the set of all merged repeatable {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\n\t * is {@code null}, or if the container type cannot be resolved\n\t * @throws AnnotationConfigurationException if the supplied {@code containerType}\n\t * is not a valid container annotation for the supplied {@code annotationType}\n\t * @since 4.3\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t */\n\tpublic static <A extends Annotation> Set<A> findMergedRepeatableAnnotations(AnnotatedElement element,\n\t\t\tClass<A> annotationType, @Nullable Class<? extends Annotation> containerType) {\n\n\t\treturn findRepeatableAnnotations(element, containerType, annotationType)\n\t\t\t\t.stream(annotationType)\n\t\t\t\t.sorted(highAggregateIndexesFirst())\n\t\t\t\t.collect(MergedAnnotationCollectors.toAnnotationSet());\n\t}\n\n\tprivate static MergedAnnotations getAnnotations(AnnotatedElement element) {\n\t\treturn MergedAnnotations.from(element, SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none());\n\t}\n\n\tprivate static MergedAnnotations getRepeatableAnnotations(AnnotatedElement element,\n\t\t\t@Nullable Class<? extends Annotation> containerType, Class<? extends Annotation> annotationType) {\n\n\t\tRepeatableContainers repeatableContainers;\n\t\tif (containerType == null) {\n\t\t\t// Invoke RepeatableContainers.of() in order to adhere to the contract of\n\t\t\t// getMergedRepeatableAnnotations() which states that an IllegalArgumentException\n\t\t\t// will be thrown if the container cannot be resolved.\n\t\t\t//\n\t\t\t// In any case, we use standardRepeatables() in order to support repeatable\n\t\t\t// annotations on other types of repeatable annotations (i.e., nested repeatable\n\t\t\t// annotation types).\n\t\t\t//\n\t\t\t// See https://github.com/spring-projects/spring-framework/issues/20279\n\t\t\tRepeatableContainers.of(annotationType, null);\n\t\t\trepeatableContainers = RepeatableContainers.standardRepeatables();\n\t\t}\n\t\telse {\n\t\t\trepeatableContainers = RepeatableContainers.of(annotationType, containerType);\n\t\t}\n\t\treturn MergedAnnotations.from(element, SearchStrategy.INHERITED_ANNOTATIONS, repeatableContainers);\n\t}\n\n\tprivate static MergedAnnotations findAnnotations(AnnotatedElement element) {\n\t\treturn MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none());\n\t}\n\n\tprivate static MergedAnnotations findRepeatableAnnotations(AnnotatedElement element,\n\t\t\t@Nullable Class<? extends Annotation> containerType, Class<? extends Annotation> annotationType) {\n\n\t\tRepeatableContainers repeatableContainers;\n\t\tif (containerType == null) {\n\t\t\t// Invoke RepeatableContainers.of() in order to adhere to the contract of\n\t\t\t// findMergedRepeatableAnnotations() which states that an IllegalArgumentException\n\t\t\t// will be thrown if the container cannot be resolved.\n\t\t\t//\n\t\t\t// In any case, we use standardRepeatables() in order to support repeatable\n\t\t\t// annotations on other types of repeatable annotations (i.e., nested repeatable\n\t\t\t// annotation types).\n\t\t\t//\n\t\t\t// See https://github.com/spring-projects/spring-framework/issues/20279\n\t\t\tRepeatableContainers.of(annotationType, null);\n\t\t\trepeatableContainers = RepeatableContainers.standardRepeatables();\n\t\t}\n\t\telse {\n\t\t\trepeatableContainers = RepeatableContainers.of(annotationType, containerType);\n\t\t}\n\t\treturn MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY, repeatableContainers);\n\t}\n\n\tprivate static @Nullable MultiValueMap<String, Object> nullIfEmpty(MultiValueMap<String, Object> map) {\n\t\treturn (map.isEmpty() ? null : map);\n\t}\n\n\tprivate static <A extends Annotation> Comparator<MergedAnnotation<A>> highAggregateIndexesFirst() {\n\t\treturn Comparator.<MergedAnnotation<A>> comparingInt(MergedAnnotation::getAggregateIndex).reversed();\n\t}\n\n\tprivate static @Nullable AnnotationAttributes getAnnotationAttributes(MergedAnnotation<?> annotation,\n\t\t\tboolean classValuesAsString, boolean nestedAnnotationsAsMap) {\n\n\t\tif (!annotation.isPresent()) {\n\t\t\treturn null;\n\t\t}\n\t\treturn annotation.asAnnotationAttributes(Adapt.values(classValuesAsString, nestedAnnotationsAsMap));\n\t}\n\n\n\t/**\n\t * Adapted {@link AnnotatedElement} that holds specific annotations.\n\t */\n\tprivate static class AnnotatedElementForAnnotations implements AnnotatedElement {\n\n\t\tprivate final Annotation[] annotations;\n\n\t\tAnnotatedElementForAnnotations(Annotation... annotations) {\n\t\t\tthis.annotations = annotations;\n\t\t}\n\n\t\t@Override\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic <T extends Annotation> @Nullable T getAnnotation(Class<T> annotationClass) {\n\t\t\tfor (Annotation annotation : this.annotations) {\n\t\t\t\tif (annotation.annotationType() == annotationClass) {\n\t\t\t\t\treturn (T) annotation;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Annotation[] getAnnotations() {\n\t\t\treturn this.annotations.clone();\n\t\t}\n\n\t\t@Override\n\t\tpublic Annotation[] getDeclaredAnnotations() {\n\t\t\treturn this.annotations.clone();\n\t\t}\n\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotatedElementForAnnotations",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.core.annotation.AnnotatedElementForAnnotations#annotations",
    "tailType": "field"
  },
  {
    "head": "org.springframework.core.annotation.AnnotatedElementForAnnotations#annotations",
    "headType": "field",
    "relation": "haveType",
    "tail": "Annotation",
    "tailType": "type"
  },
  {
    "head": "org.springframework.core.annotation.AnnotatedElementForAnnotations#getAnnotation(Class<T>)",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\npublic <T extends Annotation> T getAnnotation(Class<T> annotationClass) {\r\n    for (Annotation annotation : this.annotations) {\r\n        if (annotation.annotationType() == annotationClass) {\r\n            return (T) annotation;\r\n        }\r\n    }\r\n    return null;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.annotation.AnnotatedElementForAnnotations",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.annotation.AnnotatedElementForAnnotations#getAnnotation(Class<T>)",
    "tailType": "method"
  }
]