[
  {
    "head": "org.springframework.core.annotation.HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass1",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.stream.Stream;\n\nimport jakarta.annotation.Resource;\nimport org.jspecify.annotations.Nullable;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.AnnotationsScannerTests.Hello2Impl;\nimport org.springframework.core.annotation.AnnotationsScannerTests.TestAnnotation1;\nimport org.springframework.core.annotation.MergedAnnotation.Adapt;\nimport org.springframework.core.annotation.MergedAnnotations.Search;\nimport org.springframework.core.annotation.MergedAnnotations.SearchStrategy;\nimport org.springframework.core.annotation.subpackage.NonPublicAnnotatedClass;\nimport org.springframework.core.testfixture.ide.IdeUtils;\nimport org.springframework.core.testfixture.stereotype.Component;\nimport org.springframework.core.testfixture.stereotype.Indexed;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.MultiValueMap;\nimport org.springframework.util.ReflectionUtils;\n\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.assertj.core.api.Assertions.assertThatIllegalStateException;\nimport static org.assertj.core.api.Assertions.entry;\n\n/**\n * Tests for {@link MergedAnnotations} and {@link MergedAnnotation}. These tests\n * cover common usage scenarios and were mainly ported from the original\n * {@code AnnotationUtils} and {@code AnnotatedElementUtils} tests.\n *\n * @author Phillip Webb\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Chris Beams\n * @author Oleg Zhurakousky\n * @author Rossen Stoyanchev\n * @see MergedAnnotationsRepeatableAnnotationTests\n * @see MergedAnnotationClassLoaderTests\n */\nclass MergedAnnotationsTests {\n\n\t/**\n\t * Subset (and duplication) of other tests in {@link MergedAnnotationsTests}\n\t * that verify behavior of the fluent {@link Search} API.\n\t * @since 6.0\n\t */\n\t@Nested\n\tclass FluentSearchApiTests {\n\n\t\t@Test\n\t\tvoid preconditions() {\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> MergedAnnotations.search(null))\n\t\t\t\t\t.withMessage(\"SearchStrategy must not be null\");\n\n\t\t\tSearch search = MergedAnnotations.search(SearchStrategy.SUPERCLASS);\n\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> search.withEnclosingClasses(null))\n\t\t\t\t\t.withMessage(\"Predicate must not be null\");\n\t\t\tassertThatIllegalStateException()\n\t\t\t\t\t.isThrownBy(() -> search.withEnclosingClasses(Search.always))\n\t\t\t\t\t.withMessage(\"A custom 'searchEnclosingClass' predicate can only be combined with SearchStrategy.TYPE_HIERARCHY\");\n\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> search.withAnnotationFilter(null))\n\t\t\t\t\t.withMessage(\"AnnotationFilter must not be null\");\n\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> search.withRepeatableContainers(null))\n\t\t\t\t\t.withMessage(\"RepeatableContainers must not be null\");\n\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> search.from(null))\n\t\t\t\t\t.withMessage(\"AnnotatedElement must not be null\");\n\t\t}\n\n\t\t@Test\n\t\tvoid searchFromClassWithDefaultAnnotationFilterAndDefaultRepeatableContainers() {\n\t\t\tStream<Class<?>> classes = MergedAnnotations.search(SearchStrategy.DIRECT)\n\t\t\t\t\t.from(TransactionalComponent.class)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Transactional.class, Component.class, Indexed.class);\n\t\t}\n\n\t\t@Test\n\t\tvoid searchFromClassWithCustomAnnotationFilter() {\n\t\t\tStream<Class<?>> classes = MergedAnnotations.search(SearchStrategy.DIRECT)\n\t\t\t\t\t.withAnnotationFilter(annotationName -> annotationName.endsWith(\"Indexed\"))\n\t\t\t\t\t.from(TransactionalComponent.class)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Transactional.class, Component.class);\n\t\t}\n\n\t\t@Test\n\t\tvoid searchFromClassWithCustomRepeatableContainers() {\n\t\t\tassertThat(MergedAnnotations.from(HierarchyClass.class).stream(TestConfiguration.class)).isEmpty();\n\t\t\tRepeatableContainers containers = RepeatableContainers.of(TestConfiguration.class, Hierarchy.class);\n\n\t\t\tMergedAnnotations annotations = MergedAnnotations.search(SearchStrategy.DIRECT)\n\t\t\t\t\t.withRepeatableContainers(containers)\n\t\t\t\t\t.from(HierarchyClass.class);\n\t\t\tassertThat(annotations.stream(TestConfiguration.class))\n\t\t\t\t\t.map(annotation -> annotation.getString(\"location\"))\n\t\t\t\t\t.containsExactly(\"A\", \"B\");\n\t\t\tassertThat(annotations.stream(TestConfiguration.class))\n\t\t\t\t\t.map(annotation -> annotation.getString(\"value\"))\n\t\t\t\t\t.containsExactly(\"A\", \"B\");\n\t\t}\n\n\t\t/**\n\t\t * @since 6.0\n\t\t */\n\t\t@Test\n\t\tvoid searchFromNonAnnotatedInnerClassWithAnnotatedEnclosingClassWithEnclosingClassPredicates() {\n\t\t\tClass<?> testCase = AnnotatedClass.NonAnnotatedInnerClass.class;\n\t\t\tSearch search = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY);\n\n\t\t\tassertThat(search.from(testCase).stream()).isEmpty();\n\t\t\tassertThat(search.withEnclosingClasses(Search.never).from(testCase).stream()).isEmpty();\n\t\t\tassertThat(search.withEnclosingClasses(ClassUtils::isStaticClass).from(testCase).stream()).isEmpty();\n\n\t\t\tStream<Class<?>> classes = search.withEnclosingClasses(ClassUtils::isInnerClass)\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class, Indexed.class);\n\n\t\t\tclasses = search.withEnclosingClasses(Search.always)\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class, Indexed.class);\n\n\t\t\tclasses = search.withEnclosingClasses(ClassUtils::isInnerClass)\n\t\t\t\t\t.withRepeatableContainers(RepeatableContainers.none())\n\t\t\t\t\t.withAnnotationFilter(annotationName -> annotationName.endsWith(\"Indexed\"))\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class);\n\t\t}\n\n\t\t/**\n\t\t * @since 6.0\n\t\t */\n\t\t@Test\n\t\tvoid searchFromNonAnnotatedStaticNestedClassWithAnnotatedEnclosingClassWithEnclosingClassPredicates() {\n\t\t\tClass<?> testCase = AnnotatedClass.NonAnnotatedStaticNestedClass.class;\n\t\t\tSearch search = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY);\n\n\t\t\tassertThat(search.from(testCase).stream()).isEmpty();\n\t\t\tassertThat(search.withEnclosingClasses(Search.never).from(testCase).stream()).isEmpty();\n\t\t\tassertThat(search.withEnclosingClasses(ClassUtils::isInnerClass).from(testCase).stream()).isEmpty();\n\n\t\t\tStream<Class<?>> classes = search.withEnclosingClasses(ClassUtils::isStaticClass)\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class, Indexed.class);\n\n\t\t\tclasses = search.withEnclosingClasses(Search.always)\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class, Indexed.class);\n\t\t}\n\t}\n\n\n\t@Nested\n\tclass ConventionBasedAnnotationAttributeOverrideTests {\n\n\t\t@Test\n\t\tvoid getWithInheritedAnnotationsAttributesWithConventionBasedComposedAnnotation() {\n\t\t\tMergedAnnotation<?> annotation =\n\t\t\t\t\tMergedAnnotations.from(ConventionBasedComposedContextConfigurationClass.class,\n\t\t\t\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\t\tassertThat(annotation.isPresent()).isTrue();\n\t\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"explicitDeclaration\");\n\t\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"explicitDeclaration\");\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithInheritedAnnotationsFromHalfConventionBasedAndHalfAliasedComposedAnnotation1() {\n\t\t\t// SPR-13554: convention mapping mixed with AliasFor annotations\n\t\t\t// xmlConfigFiles can be used because it has an AliasFor annotation\n\t\t\tMergedAnnotation<?> annotation =\n\t\t\t\t\tMergedAnnotations.from(HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass1.class,\n\t\t\t\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"explicitDeclaration\");\n\t\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"explicitDeclaration\");\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithInheritedAnnotationsFromHalfConventionBasedAndHalfAliasedComposedAnnotation2() {\n\t\t\t// SPR-13554: convention mapping mixed with AliasFor annotations\n\t\t\t// locations doesn't apply because it has no AliasFor annotation\n\t\t\tMergedAnnotation<?> annotation =\n\t\t\t\t\tMergedAnnotations.from(HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass2.class,\n\t\t\t\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\t\tassertThat(annotation.getStringArray(\"locations\")).isEmpty();\n\t\t\tassertThat(annotation.getStringArray(\"value\")).isEmpty();\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithInheritedAnnotationsFromInvalidConventionBasedComposedAnnotation() {\n\t\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(InvalidConventionBasedComposedContextConfigurationClass.class,\n\t\t\t\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class));\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithTypeHierarchyWithSingleElementOverridingAnArrayViaConvention() {\n\t\t\ttestGetWithTypeHierarchy(ConventionBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithTypeHierarchyWithLocalAliasesThatConflictWithAttributesInMetaAnnotationByConvention() {\n\t\t\tMergedAnnotation<?> annotation =\n\t\t\t\t\tMergedAnnotations.from(SpringApplicationConfigurationClass.class, SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t\t\t\t.get(ContextConfiguration.class);\n\t\t\tassertThat(annotation.getStringArray(\"locations\")).isEmpty();\n\t\t\tassertThat(annotation.getStringArray(\"value\")).isEmpty();\n\t\t\tassertThat(annotation.getClassArray(\"classes\")).containsExactly(Number.class);\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithTypeHierarchyOnMethodWithSingleElementOverridingAnArrayViaConvention() throws Exception {\n\t\t\ttestGetWithTypeHierarchyWebMapping(WebController.class.getMethod(\"postMappedWithPathAttribute\"));\n\t\t}\n\t}\n\n\n\t@Test\n\tvoid fromPreconditions() {\n\t\tSearchStrategy strategy = SearchStrategy.DIRECT;\n\t\tRepeatableContainers containers = RepeatableContainers.standardRepeatables();\n\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(getClass(), strategy, null, AnnotationFilter.PLAIN))\n\t\t\t\t.withMessage(\"RepeatableContainers must not be null\");\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(getClass(), strategy, containers, null))\n\t\t\t\t.withMessage(\"AnnotationFilter must not be null\");\n\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(getClass(), new Annotation[0], null, AnnotationFilter.PLAIN))\n\t\t\t\t.withMessage(\"RepeatableContainers must not be null\");\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(getClass(), new Annotation[0], containers, null))\n\t\t\t\t.withMessage(\"AnnotationFilter must not be null\");\n\t}\n\n\t@Test\n\tvoid streamWhenFromNonAnnotatedClass() {\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class).stream(TransactionalComponent.class)).isEmpty();\n\t}\n\n\t@Test\n\tvoid streamWhenFromClassWithMetaDepth1() {\n\t\tStream<Class<?>> classes = MergedAnnotations.from(TransactionalComponent.class)\n\t\t\t\t.stream().map(MergedAnnotation::getType);\n\t\tassertThat(classes).containsExactly(Transactional.class, Component.class, Indexed.class);\n\t}\n\n\t@Test\n\tvoid streamWhenFromClassWithMetaDepth2() {\n\t\tStream<Class<?>> classes = MergedAnnotations.from(ComposedTransactionalComponent.class)\n\t\t\t\t.stream().map(MergedAnnotation::getType);\n\t\tassertThat(classes).containsExactly(TransactionalComponent.class,\n\t\t\t\tTransactional.class, Component.class, Indexed.class);\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromNonAnnotatedClass() {\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class).isPresent(Transactional.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromAnnotationClassWithMetaDepth0() {\n\t\tassertThat(MergedAnnotations.from(TransactionalComponent.class).isPresent(TransactionalComponent.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromAnnotationClassWithMetaDepth1() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(TransactionalComponent.class);\n\t\tassertThat(annotations.isPresent(Transactional.class)).isTrue();\n\t\tassertThat(annotations.isPresent(Component.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromAnnotationClassWithMetaDepth2() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponent.class);\n\t\tassertThat(annotations.isPresent(Transactional.class)).isTrue();\n\t\tassertThat(annotations.isPresent(Component.class)).isTrue();\n\t\tassertThat(annotations.isPresent(ComposedTransactionalComponent.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromClassWithMetaDepth0() {\n\t\tassertThat(MergedAnnotations.from(TransactionalComponentClass.class).isPresent(TransactionalComponent.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromSubclassWithMetaDepth0() {\n\t\tassertThat(MergedAnnotations.from(SubTransactionalComponentClass.class).isPresent(TransactionalComponent.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromClassWithMetaDepth1() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(TransactionalComponentClass.class);\n\t\tassertThat(annotations.isPresent(Transactional.class)).isTrue();\n\t\tassertThat(annotations.isPresent(Component.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromClassWithMetaDepth2() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\n\t\tassertThat(annotations.isPresent(Transactional.class)).isTrue();\n\t\tassertThat(annotations.isPresent(Component.class)).isTrue();\n\t\tassertThat(annotations.isPresent(ComposedTransactionalComponent.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid getParent() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\n\t\tassertThat(annotations.get(TransactionalComponent.class).getMetaSource().getType())\n\t\t\t\t.isEqualTo(ComposedTransactionalComponent.class);\n\t}\n\n\t@Test\n\tvoid getRootWhenNotDirect() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\n\t\tMergedAnnotation<?> annotation = annotations.get(TransactionalComponent.class);\n\t\tassertThat(annotation.getDistance()).isGreaterThan(0);\n\t\tassertThat(annotation.getRoot().getType()).isEqualTo(ComposedTransactionalComponent.class);\n\t}\n\n\t@Test\n\tvoid getRootWhenDirect() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\n\t\tMergedAnnotation<?> annotation = annotations.get(ComposedTransactionalComponent.class);\n\t\tassertThat(annotation.getDistance()).isEqualTo(0);\n\t\tassertThat(annotation.getRoot()).isSameAs(annotation);\n\t}\n\n\t@Test\n\tvoid getMetaTypes() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(ComposedTransactionalComponentClass.class)\n\t\t\t\t.get(TransactionalComponent.class);\n\t\tassertThat(annotation.getMetaTypes()).containsExactly(\n\t\t\t\tComposedTransactionalComponent.class, TransactionalComponent.class);\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFromNonAnnotatedClass() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(NonAnnotatedClass.class)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).isEmpty();\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFromClassWithLocalAnnotation() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(TxConfig.class)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"value\", List.of(\"TxConfig\")));\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFromClassWithLocalComposedAnnotationAndInheritedAnnotation() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"qualifier\", List.of(\"composed2\", \"transactionManager\")));\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"qualifier\", List.of(\"transactionManager\")));\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedComposedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"qualifier\", List.of(\"composed1\")));\n\t}\n\n\t/**\n\t * If the \"value\" entry contains both \"DerivedTxConfig\" AND \"TxConfig\", then\n\t * the algorithm is accidentally picking up shadowed annotations of the same\n\t * type within the class hierarchy. Such undesirable behavior would cause\n\t * the logic in\n\t * {@code org.springframework.context.annotation.ProfileCondition} to fail.\n\t */\n\t@Test\n\tvoid collectMultiValueMapFromClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tDerivedTxConfig.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"value\", List.of(\"DerivedTxConfig\")));\n\t}\n\n\t/**\n\t * Note: this functionality is required by\n\t * {@code org.springframework.context.annotation.ProfileCondition}.\n\t */\n\t@Test\n\tvoid collectMultiValueMapFromClassWithMultipleComposedAnnotations() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tTxFromMultipleComposedAnnotations.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"value\", List.of(\"TxInheritedComposed\", \"TxComposed\")));\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromClassWithLocalAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tTxConfig.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"TxConfig\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tDerivedTxConfig.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"DerivedTxConfig\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaCycleAnnotatedClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isFalse();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFavorsLocalComposedAnnotationOverInheritedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getBoolean(\"readOnly\")).isTrue();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getBoolean(\"readOnly\")).isFalse();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedComposedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getBoolean(\"readOnly\")).isFalse();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromInterfaceImplementedBySuperclass() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tConcreteClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isFalse();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tInheritedAnnotationInterface.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationInterface.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t}\n\n\n\t@Test\n\tvoid withInheritedAnnotationsFromAliasedComposedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tAliasedComposedContextConfigurationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"test.xml\");\n\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid withInheritedAnnotationsFromAliasedValueComposedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tAliasedValueComposedContextConfigurationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"test.xml\");\n\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromImplicitAliasesInMetaAnnotationOnComposedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tComposedImplicitAliasesContextConfigurationClass.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.get(ImplicitAliasesContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"groovyScripts\")).containsExactly(\"A.xml\", \"B.xml\");\n\t\tassertThat(annotation.getStringArray(\"xmlFiles\")).containsExactly(\"A.xml\", \"B.xml\");\n\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"A.xml\", \"B.xml\");\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"A.xml\", \"B.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromAliasedValueComposedAnnotation() {\n\t\ttestGetWithInherited(AliasedValueComposedContextConfigurationClass.class, \"test.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromImplicitAliasesForSameAttributeInComposedAnnotation() {\n\t\ttestGetWithInherited(ImplicitAliasesContextConfigurationClass1.class, \"foo.xml\");\n\t\ttestGetWithInherited(ImplicitAliasesContextConfigurationClass2.class, \"bar.xml\");\n\t\ttestGetWithInherited(ImplicitAliasesContextConfigurationClass3.class, \"baz.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromTransitiveImplicitAliases() {\n\t\ttestGetWithInherited(TransitiveImplicitAliasesContextConfigurationClass.class, \"test.groovy\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\ttestGetWithInherited(\n\t\t\t\tSingleLocationTransitiveImplicitAliasesContextConfigurationClass.class, \"test.groovy\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSkippedLevel() {\n\t\ttestGetWithInherited(\n\t\t\t\tTransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass.class, \"test.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSkippedLevelWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\ttestGetWithInherited(\n\t\t\t\tSingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass.class, \"test.xml\");\n\t}\n\n\tprivate void testGetWithInherited(Class<?> element, String... expected) {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(element, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.get(ContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"locations\")).isEqualTo(expected);\n\t\tassertThat(annotation.getStringArray(\"value\")).isEqualTo(expected);\n\t\tassertThat(annotation.getClassArray(\"classes\")).isEmpty();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromShadowedAliasComposedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tShadowedAliasComposedContextConfigurationClass.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.get(ContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"test.xml\");\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromSubInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromSubSubInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromSubNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromSubSubNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyInheritedFromInterfaceMethod() throws Exception {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleFromInterface\");\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test  // gh-31803\n\tvoid streamWithTypeHierarchyInheritedFromSuperInterfaceMethod() throws Exception {\n\t\tMethod method = Hello2Impl.class.getMethod(\"method\");\n\t\tlong count = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.from(method).stream(TestAnnotation1.class).count();\n\t\tassertThat(count).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyInheritedFromAbstractMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handle\");\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyInheritedFromBridgedMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleParameterized\", String.class);\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromBridgeMethod() {\n\t\tList<Method> methods = new ArrayList<>();\n\t\tReflectionUtils.doWithLocalMethods(StringGenericParameter.class, method -> {\n\t\t\tif (\"getFor\".equals(method.getName())) {\n\t\t\t\tmethods.add(method);\n\t\t\t}\n\t\t});\n\t\tMethod bridgeMethod = methods.get(0).getReturnType().equals(Object.class) ?\n\t\t\t\tmethods.get(0) : methods.get(1);\n\t\tMethod bridgedMethod = methods.get(0).getReturnType().equals(Object.class) ?\n\t\t\t\tmethods.get(1) : methods.get(0);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(bridgeMethod,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromClassWithMetaAndLocalTxConfig() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaAndLocalTxConfigClass.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getString(\"qualifier\")).isEqualTo(\"localTxMgr\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromClassWithAttributeAliasesInTargetAnnotation() {\n\t\tMergedAnnotation<AliasedTransactional> mergedAnnotation = MergedAnnotations.from(\n\t\t\t\tAliasedTransactionalComponentClass.class, SearchStrategy.TYPE_HIERARCHY).get(AliasedTransactional.class);\n\t\tAliasedTransactional synthesizedAnnotation = mergedAnnotation.synthesize();\n\t\tString qualifier = \"aliasForQualifier\";\n\t\tassertThat(mergedAnnotation.getString(\"value\")).isEqualTo(qualifier);\n\t\tassertThat(mergedAnnotation.getString(\"qualifier\")).isEqualTo(qualifier);\n\t\tassertThat(synthesizedAnnotation.value()).isEqualTo(qualifier);\n\t\tassertThat(synthesizedAnnotation.qualifier()).isEqualTo(qualifier);\n\t}\n\n\t@Test // gh-23767\n\tvoid getWithTypeHierarchyFromClassWithComposedMetaTransactionalAnnotation() {\n\t\tMergedAnnotation<AliasedTransactional> mergedAnnotation = MergedAnnotations.from(\n\t\t\t\tComposedTransactionalClass.class, SearchStrategy.TYPE_HIERARCHY).get(AliasedTransactional.class);\n\t\tassertThat(mergedAnnotation.getString(\"value\")).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(mergedAnnotation.getString(\"qualifier\")).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t@Test // gh-23767\n\tvoid getWithTypeHierarchyFromClassWithMetaMetaAliasedTransactional() {\n\t\tMergedAnnotation<AliasedTransactional> mergedAnnotation = MergedAnnotations.from(\n\t\t\t\tMetaMetaAliasedTransactionalClass.class, SearchStrategy.TYPE_HIERARCHY).get(AliasedTransactional.class);\n\t\tassertThat(mergedAnnotation.getString(\"value\")).isEqualTo(\"meta\");\n\t\tassertThat(mergedAnnotation.getString(\"qualifier\")).isEqualTo(\"meta\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromClassWithAttributeAliasInComposedAnnotationAndNestedAnnotationsInTargetAnnotation() {\n\t\tMergedAnnotation<?> annotation = testGetWithTypeHierarchy(\n\t\t\t\tTestComponentScanClass.class, \"com.example.app.test\");\n\t\tMergedAnnotation<Filter>[] excludeFilters = annotation.getAnnotationArray(\n\t\t\t\t\"excludeFilters\", Filter.class);\n\t\tassertThat(Arrays.stream(excludeFilters).map(\n\t\t\t\tfilter -> filter.getString(\"pattern\"))).containsExactly(\"*Test\", \"*Tests\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromClassWithBothAttributesOfAnAliasPairDeclared() {\n\t\ttestGetWithTypeHierarchy(ComponentScanWithBasePackagesAndValueAliasClass.class, \"com.example.app.test\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\ttestGetWithTypeHierarchy(AliasForBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\n\t}\n\n\tprivate MergedAnnotation<?> testGetWithTypeHierarchy(Class<?> element, String... expected) {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(element,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(ComponentScan.class);\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(expected);\n\t\tassertThat(annotation.getStringArray(\"basePackages\")).containsExactly(expected);\n\t\treturn annotation;\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyWhenMultipleMetaAnnotationsHaveClashingAttributeNames() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tAliasedComposedContextConfigurationAndTestPropertySourceClass.class, SearchStrategy.TYPE_HIERARCHY);\n\t\tMergedAnnotation<?> contextConfig = annotations.get(ContextConfiguration.class);\n\t\tassertThat(contextConfig.getStringArray(\"locations\")).containsExactly(\"test.xml\");\n\t\tassertThat(contextConfig.getStringArray(\"value\")).containsExactly(\"test.xml\");\n\t\tMergedAnnotation<?> testPropSource = annotations.get(TestPropertySource.class);\n\t\tassertThat(testPropSource.getStringArray(\"locations\")).containsExactly(\"test.properties\");\n\t\tassertThat(testPropSource.getStringArray(\"value\")).containsExactly(\"test.properties\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyOnMethodWithSingleElementOverridingAnArrayViaAliasFor() throws Exception {\n\t\ttestGetWithTypeHierarchyWebMapping(WebController.class.getMethod(\"getMappedWithValueAttribute\"));\n\t\ttestGetWithTypeHierarchyWebMapping(WebController.class.getMethod(\"getMappedWithPathAttribute\"));\n\t}\n\n\tprivate void testGetWithTypeHierarchyWebMapping(AnnotatedElement element) {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.get(RequestMapping.class);\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"/test\");\n\t\tassertThat(annotation.getStringArray(\"path\")).containsExactly(\"/test\");\n\t}\n\n\t@Test\n\tvoid getDirectWithJavaxAnnotationType() {\n\t\tassertThat(MergedAnnotations.from(ResourceHolder.class).get(Resource.class)\n\t\t\t\t.getString(\"name\")).isEqualTo(\"x\");\n\t}\n\n\t@Test\n\tvoid streamInheritedFromClassWithInterface() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class)).isEmpty();\n\t}\n\n\t@Test\n\tvoid streamTypeHierarchyFromClassWithInterface() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.stream(Transactional.class)).hasSize(1);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithMethodAnnotationOnLeaf() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"annotatedOnLeaf\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNotNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class)\n\t\t\t\t.getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithAnnotationOnMethodInInterface() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"fromInterfaceImplementedByRoot\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class)\n\t\t\t\t.getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithMetaAnnotationOnLeaf() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"metaAnnotatedOnLeaf\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class)\n\t\t\t\t.getDistance()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithMetaMetaAnnotationOnLeaf() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"metaMetaAnnotatedOnLeaf\");\n\t\tassertThat(method.getAnnotation(Component.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Component.class).getDistance()).isEqualTo(2);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tComponent.class).getDistance()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getWithAnnotationOnRoot() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"annotatedOnRoot\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNotNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithMetaAnnotationOnRoot() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"metaAnnotatedOnRoot\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithOnRootButOverridden() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"overrideWithoutNewAnnotation\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithNotAnnotated() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"notAnnotated\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(-1);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithBridgeMethod() throws Exception {\n\t\tMethod method = TransactionalStringGeneric.class.getMethod(\"something\", Object.class);\n\t\tassertThat(method.isBridge()).isTrue();\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t\t// As of JDK 8, invoking getAnnotation() on a bridge method actually finds an\n\t\t// annotation on its 'bridged' method [1]; however, the Eclipse compiler does\n\t\t// not support this [2]. Thus, we effectively ignore the following\n\t\t// assertion if the test is currently executing within the Eclipse IDE.\n\t\t//\n\t\t// [1] https://bugs.openjdk.java.net/browse/JDK-6695379\n\t\t// [2] https://bugs.eclipse.org/bugs/show_bug.cgi?id=495396\n\t\t//\n\t\tif (!IdeUtils.runningInEclipse()) {\n\t\t\tassertThat(method.getAnnotation(Transactional.class)).isNotNull();\n\t\t}\n\t\tassertThat(MergedAnnotations.from(method).get(\n\t\t\t\tTransactional.class).getDistance()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tTransactional.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithBridgedMethod() throws Exception {\n\t\tMethod method = TransactionalStringGeneric.class.getMethod(\"something\", String.class);\n\t\tassertThat(method.isBridge()).isFalse();\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t\tassertThat(method.getAnnotation(Transactional.class)).isNotNull();\n\t\tassertThat(MergedAnnotations.from(method).get(\n\t\t\t\tTransactional.class).getDistance()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tTransactional.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test // SPR-16060\n\tvoid getFromMethodWithGenericInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test // SPR-17146\n\tvoid getFromMethodWithGenericSuperclass() throws Exception {\n\t\tMethod method = ExtendsBaseClassWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithInterfaceOnSuper() throws Exception {\n\t\tMethod method = SubOfImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWhenInterfaceWhenSuperDoesNotImplementMethod() throws Exception {\n\t\tMethod method = SubOfAbstractImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverAnnotationsOnInterfaces() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tClassWithLocalMetaAnnotationAndMetaAnnotatedInterface.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedAnnotation.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getBoolean(\"readOnly\")).isTrue();\n\t}\n\n\t@Test\n\tvoid getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedComposedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedMetaAnnotation.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid getDirectFromClassgetDirectFromClassMetaMetaAnnotatedClass() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaMetaAnnotatedClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithMetaMetaMetaAnnotatedClass() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaMetaMetaAnnotatedClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\t// TransactionalClass is NOT annotated or meta-annotated with @Component\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(TransactionalClass.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.isPresent()).isFalse();\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaCycleAnnotatedClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.isPresent()).isFalse();\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithSubInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithSubSubInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithSubNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithSubSubNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubNonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getSuperClassForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isNull();\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isNull();\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isEqualTo(\n\t\t\t\t\t\t\t\tInheritedAnnotationInterface.class);\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isNull();\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isEqualTo(\n\t\t\t\t\t\t\t\tInheritedAnnotationClass.class);\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isEqualTo(\n\t\t\t\t\t\t\t\tInheritedAnnotationClass.class);\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but we should still find it on classes.\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(Order.class).getSource()).isEqualTo(\n\t\t\t\t\t\tNonInheritedAnnotationInterface.class);\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(Order.class).getSource()).isNull();\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(Order.class).getSource()).isEqualTo(\n\t\t\t\t\t\tNonInheritedAnnotationClass.class);\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(Order.class).getSource()).isEqualTo(\n\t\t\t\t\t\tNonInheritedAnnotationClass.class);\n\t}\n\n\t@Test\n\tvoid getSuperClassSourceForTypesWithSingleCandidateType() {\n\t\t// no class-level annotation\n\t\tList<Class<? extends Annotation>> transactionalCandidateList = Collections.singletonList(Transactional.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonAnnotatedInterface.class,\n\t\t\t\ttransactionalCandidateList)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonAnnotatedClass.class,\n\t\t\t\ttransactionalCandidateList)).isNull();\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationInterface.class,\n\t\t\t\ttransactionalCandidateList)).isEqualTo(\n\t\t\t\t\t\tInheritedAnnotationInterface.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationInterface.class,\n\t\t\t\ttransactionalCandidateList)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationClass.class,\n\t\t\t\ttransactionalCandidateList)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationClass.class,\n\t\t\t\ttransactionalCandidateList)).isEqualTo(InheritedAnnotationClass.class);\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but should still find it on classes.\n\t\tList<Class<? extends Annotation>> orderCandidateList = Collections.singletonList(\n\t\t\t\tOrder.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationInterface.class,\n\t\t\t\torderCandidateList)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationInterface.class,\n\t\t\t\torderCandidateList)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationClass.class,\n\t\t\t\torderCandidateList)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationClass.class,\n\t\t\t\torderCandidateList)).isEqualTo(NonInheritedAnnotationClass.class);\n\t}\n\n\t@Test\n\tvoid getSuperClassSourceForTypesWithMultipleCandidateTypes() {\n\t\tList<Class<? extends Annotation>> candidates = List.of(Transactional.class, Order.class);\n\t\t// no class-level annotation\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonAnnotatedInterface.class,\n\t\t\t\tcandidates)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonAnnotatedClass.class,\n\t\t\t\tcandidates)).isNull();\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationInterface.class,\n\t\t\t\tcandidates)).isEqualTo(InheritedAnnotationInterface.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationInterface.class,\n\t\t\t\tcandidates)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationClass.class,\n\t\t\t\tcandidates)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationClass.class,\n\t\t\t\tcandidates)).isEqualTo(InheritedAnnotationClass.class);\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but findAnnotationDeclaringClassForTypes() should still find it on\n\t\t// classes.\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationInterface.class,\n\t\t\t\tcandidates)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationInterface.class,\n\t\t\t\tcandidates)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationClass.class,\n\t\t\t\tcandidates)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationClass.class,\n\t\t\t\tcandidates)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\t// class hierarchy mixed with @Transactional and @Order declarations\n\t\tassertThat(getSuperClassSourceWithTypeIn(TransactionalClass.class,\n\t\t\t\tcandidates)).isEqualTo(TransactionalClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(TransactionalAndOrderedClass.class,\n\t\t\t\tcandidates)).isEqualTo(TransactionalAndOrderedClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubTransactionalAndOrderedClass.class,\n\t\t\t\tcandidates)).isEqualTo(TransactionalAndOrderedClass.class);\n\t}\n\n\tprivate Object getSuperClassSourceWithTypeIn(Class<?> clazz, List<Class<? extends Annotation>> annotationTypes) {\n\t\treturn MergedAnnotations.from(clazz, SearchStrategy.SUPERCLASS).stream().filter(\n\t\t\t\tMergedAnnotationPredicates.typeIn(annotationTypes).and(\n\t\t\t\t\t\tMergedAnnotation::isDirectlyPresent)).map(\n\t\t\t\t\t\t\t\tMergedAnnotation::getSource).findFirst().orElse(null);\n\t}\n\n\t@Test\n\tvoid isDirectlyPresentForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedInterface.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedInterface.class).isDirectlyPresent(\n\t\t\t\tTransactional.class)).isFalse();\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class).isDirectlyPresent(\n\t\t\t\tTransactional.class)).isFalse();\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationInterface.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isTrue();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tInheritedAnnotationInterface.class).isDirectlyPresent(\n\t\t\t\t\t\tTransactional.class)).isTrue();\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tSubInheritedAnnotationInterface.class).isDirectlyPresent(\n\t\t\t\t\t\tTransactional.class)).isFalse();\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationClass.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isTrue();\n\t\tassertThat(\n\t\t\t\tMergedAnnotations.from(InheritedAnnotationClass.class).isDirectlyPresent(\n\t\t\t\t\t\tTransactional.class)).isTrue();\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tSubInheritedAnnotationClass.class).isDirectlyPresent(\n\t\t\t\t\t\tTransactional.class)).isFalse();\n\t\t// non-inherited class-level annotation; note: @Order is not inherited\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class).get(\n\t\t\t\tOrder.class).isDirectlyPresent()).isTrue();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationInterface.class).isDirectlyPresent(\n\t\t\t\t\t\tOrder.class)).isTrue();\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class).get(\n\t\t\t\tOrder.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tSubNonInheritedAnnotationInterface.class).isDirectlyPresent(\n\t\t\t\t\t\tOrder.class)).isFalse();\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class).get(\n\t\t\t\tOrder.class).isDirectlyPresent()).isTrue();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationClass.class).isDirectlyPresent(\n\t\t\t\t\t\tOrder.class)).isTrue();\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class).get(\n\t\t\t\tOrder.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tSubNonInheritedAnnotationClass.class).isDirectlyPresent(\n\t\t\t\t\t\tOrder.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid getAggregateIndexForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(-1);\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(0);\n\t\t// Since we're not traversing interface hierarchies the following,\n\t\t// though perhaps counterintuitive, must be false:\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(1);\n\t\t// non-inherited class-level annotation; note: @Order is not inherited\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tOrder.class).getAggregateIndex()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tOrder.class).getAggregateIndex()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tOrder.class).getAggregateIndex()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tOrder.class).getAggregateIndex()).isEqualTo(-1);\n\t}\n\n\t@Test\n\tvoid getDirectWithoutAttributeAliases() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(WebController.class).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"webController\");\n\t}\n\n\t@Test\n\tvoid getDirectWithNestedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(ComponentScanClass.class).get(ComponentScan.class);\n\t\tMergedAnnotation<Filter>[] filters = annotation.getAnnotationArray(\"excludeFilters\", Filter.class);\n\t\tassertThat(Arrays.stream(filters).map(\n\t\t\t\tfilter -> filter.getString(\"pattern\"))).containsExactly(\"*Foo\", \"*Bar\");\n\t}\n\n\t@Test\n\tvoid getDirectWithAttributeAliases1() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method).get(RequestMapping.class);\n\t\tassertThat(annotation.getString(\"name\")).isEqualTo(\"foo\");\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"/test\");\n\t\tassertThat(annotation.getStringArray(\"path\")).containsExactly(\"/test\");\n\t}\n\n\t@Test\n\tvoid getDirectWithAttributeAliases2() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method).get(RequestMapping.class);\n\t\tassertThat(annotation.getString(\"name\")).isEqualTo(\"bar\");\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"/test\");\n\t\tassertThat(annotation.getStringArray(\"path\")).containsExactly(\"/test\");\n\t}\n\n\t@Test\n\tvoid getDirectWithAttributeAliasesWithDifferentValues() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithDifferentPathAndValueAttributes\");\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tMergedAnnotations.from(method).get(RequestMapping.class))\n\t\t\t\t.withMessageContaining(\"attribute 'path' and its alias 'value'\")\n\t\t\t\t.withMessageContaining(\"values of [{/test}] and [{/enigma}]\");\n\t}\n\n\t@Test\n\tvoid getValueFromAnnotation() throws Exception {\n\t\tMethod method = TransactionalStringGeneric.class.getMethod(\"something\", Object.class);\n\t\tMergedAnnotation<?> annotation =\n\t\t\t\tMergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getInt(\"value\")).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getValueFromNonPublicAnnotation() {\n\t\tAnnotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\n\t\tassertThat(declaredAnnotations).hasSize(1);\n\t\tAnnotation annotation = declaredAnnotations[0];\n\t\tMergedAnnotation<Annotation> mergedAnnotation = MergedAnnotation.from(annotation);\n\t\tassertThat(mergedAnnotation.getType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\n\t\tassertThat(mergedAnnotation.synthesize().annotationType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\n\t\tassertThat(mergedAnnotation.getInt(\"value\")).isEqualTo(42);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromAnnotation() throws Exception {\n\t\tMethod method = TransactionalStringGeneric.class.getMethod(\"something\", Object.class);\n\t\tMergedAnnotation<Order> annotation =\n\t\t\t\tMergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getDefaultValue(\"value\")).contains(Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromNonPublicAnnotation() {\n\t\tAnnotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\n\t\tassertThat(declaredAnnotations).hasSize(1);\n\t\tAnnotation declaredAnnotation = declaredAnnotations[0];\n\t\tMergedAnnotation<?> annotation = MergedAnnotation.from(declaredAnnotation);\n\t\tassertThat(annotation.getType().getName()).isEqualTo(\n\t\t\t\t\"org.springframework.core.annotation.subpackage.NonPublicAnnotation\");\n\t\tassertThat(annotation.getDefaultValue(\"value\")).contains(-1);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromAnnotationType() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotation.of(Order.class);\n\t\tassertThat(annotation.getDefaultValue(\"value\")).contains(Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnMethod() throws Exception {\n\t\tMethod method = InterfaceWithRepeated.class.getMethod(\"foo\");\n\t\tStream<MergedAnnotation<MyRepeatable>> annotations = MergedAnnotations.from(\n\t\t\t\tmethod, SearchStrategy.TYPE_HIERARCHY).stream(MyRepeatable.class);\n\t\tStream<String> values = annotations.map(\n\t\t\t\tannotation -> annotation.getString(\"value\"));\n\t\tassertThat(values).containsExactly(\"A\", \"B\", \"C\", \"meta1\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid streamRepeatableDeclaredOnClassWithAttributeAliases() {\n\t\tassertThat(MergedAnnotations.from(HierarchyClass.class).stream(\n\t\t\t\tTestConfiguration.class)).isEmpty();\n\t\tRepeatableContainers containers = RepeatableContainers.of(TestConfiguration.class,\n\t\t\t\tHierarchy.class);\n\t\tMergedAnnotations annotations = MergedAnnotations.from(HierarchyClass.class,\n\t\t\t\tSearchStrategy.DIRECT, containers, AnnotationFilter.NONE);\n\t\tassertThat(annotations.stream(TestConfiguration.class).map(\n\t\t\t\tannotation -> annotation.getString(\"location\"))).containsExactly(\"A\", \"B\");\n\t\tassertThat(annotations.stream(TestConfiguration.class).map(\n\t\t\t\tannotation -> annotation.getString(\"value\"))).containsExactly(\"A\", \"B\");\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnClass() {\n\t\tClass<?> element = MyRepeatableClass.class;\n\t\tString[] expectedValuesJava = { \"A\", \"B\", \"C\" };\n\t\tString[] expectedValuesSpring = { \"A\", \"B\", \"C\", \"meta1\" };\n\t\ttestRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnSuperclass() {\n\t\tClass<?> element = SubMyRepeatableClass.class;\n\t\tString[] expectedValuesJava = { \"A\", \"B\", \"C\" };\n\t\tString[] expectedValuesSpring = { \"A\", \"B\", \"C\", \"meta1\" };\n\t\ttestRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnClassAndSuperclass() {\n\t\tClass<?> element = SubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\n\t\tString[] expectedValuesJava = { \"X\", \"Y\", \"Z\" };\n\t\tString[] expectedValuesSpring = { \"X\", \"Y\", \"Z\", \"meta2\" };\n\t\ttestRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnMultipleSuperclasses() {\n\t\tClass<?> element = SubSubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\n\t\tString[] expectedValuesJava = { \"X\", \"Y\", \"Z\" };\n\t\tString[] expectedValuesSpring = { \"X\", \"Y\", \"Z\", \"meta2\" };\n\t\ttestRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamDirectRepeatablesDeclaredOnClass() {\n\t\tClass<?> element = MyRepeatableClass.class;\n\t\tString[] expectedValuesJava = { \"A\", \"B\", \"C\" };\n\t\tString[] expectedValuesSpring = { \"A\", \"B\", \"C\", \"meta1\" };\n\t\ttestRepeatables(SearchStrategy.DIRECT, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamDirectRepeatablesDeclaredOnSuperclass() {\n\t\tClass<?> element = SubMyRepeatableClass.class;\n\t\tString[] expectedValuesJava = {};\n\t\tString[] expectedValuesSpring = {};\n\t\ttestRepeatables(SearchStrategy.DIRECT, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\tprivate void testRepeatables(SearchStrategy searchStrategy, Class<?> element,\n\t\t\tString[] expectedValuesJava, String[] expectedValuesSpring) {\n\n\t\ttestJavaRepeatables(searchStrategy, element, expectedValuesJava);\n\t\ttestExplicitRepeatables(searchStrategy, element, expectedValuesSpring);\n\t\ttestStandardRepeatables(searchStrategy, element, expectedValuesSpring);\n\t}\n\n\tprivate void testJavaRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expected) {\n\t\tMyRepeatable[] annotations = searchStrategy == SearchStrategy.DIRECT ?\n\t\t\t\telement.getDeclaredAnnotationsByType(MyRepeatable.class) :\n\t\t\t\telement.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(Arrays.stream(annotations).map(MyRepeatable::value)).containsExactly(\n\t\t\t\texpected);\n\t}\n\n\tprivate void testExplicitRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expected) {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(element, searchStrategy,\n\t\t\t\tRepeatableContainers.of(MyRepeatable.class, MyRepeatableContainer.class),\n\t\t\t\tAnnotationFilter.PLAIN);\n\t\tStream<String> values = annotations.stream(MyRepeatable.class)\n\t\t\t\t.filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex))\n\t\t\t\t.map(annotation -> annotation.getString(\"value\"));\n\t\tassertThat(values).containsExactly(expected);\n\t}\n\n\tprivate void testStandardRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expected) {\n\t\tStream<String> values = MergedAnnotations.from(element, searchStrategy).stream(MyRepeatable.class)\n\t\t\t\t.filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex))\n\t\t\t\t.map(annotation -> annotation.getString(\"value\"));\n\t\tassertThat(values).containsExactly(expected);\n\t}\n\n\t@Test\n\tvoid synthesizeWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tComponent synthesizedComponent = MergedAnnotation.from(component).synthesize();\n\t\tassertThat(synthesizedComponent).isNotNull();\n\t\tassertThat(synthesizedComponent).isEqualTo(component);\n\t\tassertThat(synthesizedComponent.value()).isEqualTo(\"webController\");\n\t}\n\n\t/**\n\t * @since 6.0\n\t */\n\t@Test\n\tvoid synthesizedAnnotationShouldReuseJdkProxyClass() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\n\t\tRequestMapping jdkRequestMapping = method.getAnnotation(RequestMapping.class);\n\t\tassertThat(jdkRequestMapping).isNotNull();\n\t\tassertThat(jdkRequestMapping.value()).containsExactly(\"/test\");\n\t\tassertThat(jdkRequestMapping.path()).containsExactly(\"\");\n\n\t\tRequestMapping synthesizedRequestMapping = MergedAnnotation.from(jdkRequestMapping).synthesize();\n\t\tassertSynthesized(synthesizedRequestMapping);\n\t\tassertThat(synthesizedRequestMapping.value()).containsExactly(\"/test\");\n\t\tassertThat(synthesizedRequestMapping.path()).containsExactly(\"/test\");\n\n\t\tassertThat(jdkRequestMapping.getClass()).isSameAs(synthesizedRequestMapping.getClass());\n\t}\n\n\t@Test\n\tvoid synthesizeAlreadySynthesized() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\t\tRequestMapping webMapping = method.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMapping).isNotNull();\n\n\t\tRequestMapping synthesizedWebMapping = MergedAnnotation.from(webMapping).synthesize();\n\t\tRequestMapping synthesizedAgainWebMapping = MergedAnnotation.from(synthesizedWebMapping).synthesize();\n\n\t\tassertSynthesized(synthesizedWebMapping);\n\t\tassertSynthesized(synthesizedAgainWebMapping);\n\t\tassertThat(synthesizedWebMapping).isEqualTo(synthesizedAgainWebMapping);\n\t\tassertThat(synthesizedWebMapping).isSameAs(synthesizedAgainWebMapping);\n\t\tassertThat(synthesizedWebMapping.name()).isEqualTo(\"foo\");\n\t\tassertThat(synthesizedWebMapping.path()).containsExactly(\"/test\");\n\t\tassertThat(synthesizedWebMapping.value()).containsExactly(\"/test\");\n\t}\n\n\t@Test\n\tvoid synthesizeShouldNotSynthesizeNonsynthesizableAnnotations() throws Exception {\n\t\tMethod method = getClass().getDeclaredMethod(\"getId\");\n\n\t\tId id = method.getAnnotation(Id.class);\n\t\tassertThat(id).isNotNull();\n\t\tId synthesizedId = MergedAnnotation.from(id).synthesize();\n\t\tassertThat(id).isEqualTo(synthesizedId);\n\t\t// It doesn't make sense to synthesize @Id since it declares zero attributes.\n\t\tassertNotSynthesized(synthesizedId);\n\t\tassertThat(id).isSameAs(synthesizedId);\n\n\t\tGeneratedValue generatedValue = method.getAnnotation(GeneratedValue.class);\n\t\tassertThat(generatedValue).isNotNull();\n\t\tGeneratedValue synthesizedGeneratedValue = MergedAnnotation.from(generatedValue).synthesize();\n\t\tassertThat(generatedValue).isEqualTo(synthesizedGeneratedValue);\n\t\t// It doesn't make sense to synthesize @GeneratedValue since it declares zero attributes with aliases.\n\t\tassertNotSynthesized(synthesizedGeneratedValue);\n\t\tassertThat(generatedValue).isSameAs(synthesizedGeneratedValue);\n\t}\n\n\t@Test  // gh-28716\n\tvoid synthesizeWhenUsingMergedAnnotationsFromApi() {\n\t\tField directlyAnnotatedField = ReflectionUtils.findField(DomainType.class, \"directlyAnnotated\");\n\t\tMergedAnnotations mergedAnnotations = MergedAnnotations.from(directlyAnnotatedField);\n\t\tRootAnnotation rootAnnotation = mergedAnnotations.get(RootAnnotation.class).synthesize();\n\t\tassertThat(rootAnnotation.flag()).isFalse();\n\t\tassertNotSynthesized(rootAnnotation);\n\n\t\tField metaAnnotatedField = ReflectionUtils.findField(DomainType.class, \"metaAnnotated\");\n\t\tmergedAnnotations = MergedAnnotations.from(metaAnnotatedField);\n\t\trootAnnotation = mergedAnnotations.get(RootAnnotation.class).synthesize();\n\t\tassertThat(rootAnnotation.flag()).isTrue();\n\t\tassertSynthesized(rootAnnotation);\n\n\t\tField metaMetaAnnotatedField = ReflectionUtils.findField(DomainType.class, \"metaMetaAnnotated\");\n\t\tmergedAnnotations = MergedAnnotations.from(metaMetaAnnotatedField);\n\t\trootAnnotation = mergedAnnotations.get(RootAnnotation.class).synthesize();\n\t\tassertThat(rootAnnotation.flag()).isTrue();\n\t\tassertSynthesized(rootAnnotation);\n\t}\n\n\t@Test  // gh-28704\n\tvoid synthesizeShouldNotSynthesizeNonsynthesizableAnnotationsWhenUsingMergedAnnotationsFromApi() {\n\t\tMergedAnnotations mergedAnnotations = MergedAnnotations.from(SecurityConfig.class);\n\n\t\tEnableWebSecurity enableWebSecurity = mergedAnnotations.get(EnableWebSecurity.class).synthesize();\n\t\tassertNotSynthesized(enableWebSecurity);\n\n\t\tEnableGlobalAuthentication enableGlobalAuthentication = mergedAnnotations.get(EnableGlobalAuthentication.class).synthesize();\n\t\tassertNotSynthesized(enableGlobalAuthentication);\n\t}\n\n\t/**\n\t * If an attempt is made to synthesize an annotation from an annotation instance\n\t * that has already been synthesized, the original synthesized annotation should\n\t * ideally be returned as-is without creating a new proxy instance with the same\n\t * values.\n\t */\n\t@Test\n\tvoid synthesizeShouldNotResynthesizeAlreadySynthesizedAnnotations() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\t\tRequestMapping webMapping = method.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMapping).isNotNull();\n\n\t\tMergedAnnotation<RequestMapping> mergedAnnotation1 = MergedAnnotation.from(webMapping);\n\t\tRequestMapping synthesizedWebMapping1 = mergedAnnotation1.synthesize();\n\t\tRequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMapping).synthesize();\n\n\t\tassertSynthesized(synthesizedWebMapping1);\n\t\tassertSynthesized(synthesizedWebMapping2);\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(synthesizedWebMapping2);\n\n\t\t// Synthesizing an annotation from a different MergedAnnotation results in a different synthesized annotation instance.\n\t\tassertThat(synthesizedWebMapping1).isNotSameAs(synthesizedWebMapping2);\n\t\t// Synthesizing an annotation from the same MergedAnnotation results in the same synthesized annotation instance.\n\t\tassertThat(synthesizedWebMapping1).isSameAs(mergedAnnotation1.synthesize());\n\n\t\tRequestMapping synthesizedAgainWebMapping = MergedAnnotation.from(synthesizedWebMapping1).synthesize();\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(synthesizedAgainWebMapping);\n\t\t// Synthesizing an already synthesized annotation results in the original synthesized annotation instance.\n\t\tassertThat(synthesizedWebMapping1).isSameAs(synthesizedAgainWebMapping);\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAliasForIsMissingAttributeDeclaration() {\n\t\tAliasForWithMissingAttributeDeclaration annotation =\n\t\t\t\tAliasForWithMissingAttributeDeclarationClass.class.getAnnotation(\n\t\t\t\t\t\tAliasForWithMissingAttributeDeclaration.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"@AliasFor declaration on attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(AliasForWithMissingAttributeDeclaration.class.getName())\n\t\t\t\t.withMessageContaining(\"points to itself\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAliasForHasDuplicateAttributeDeclaration() {\n\t\tAliasForWithDuplicateAttributeDeclaration annotation =\n\t\t\t\tAliasForWithDuplicateAttributeDeclarationClass.class.getAnnotation(\n\t\t\t\t\t\tAliasForWithDuplicateAttributeDeclaration.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"In @AliasFor declared on attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(AliasForWithDuplicateAttributeDeclaration.class.getName())\n\t\t\t\t.withMessageContaining(\"attribute 'attribute' and its alias 'value' are present with values of 'baz' and 'bar'\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForNonexistentAttribute() {\n\t\tAliasForNonexistentAttribute annotation = AliasForNonexistentAttributeClass.class.getAnnotation(\n\t\t\t\tAliasForNonexistentAttribute.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"@AliasFor declaration on attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(AliasForNonexistentAttribute.class.getName())\n\t\t\t\t.withMessageContaining(\"declares an alias for 'bar' which is not present\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasWithMirroredAliasForWrongAttribute() {\n\t\tAliasForWithMirroredAliasForWrongAttribute annotation =\n\t\t\t\tAliasForWithMirroredAliasForWrongAttributeClass.class.getAnnotation(\n\t\t\t\t\t\tAliasForWithMirroredAliasForWrongAttribute.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessage(\"@AliasFor declaration on attribute 'bar' in annotation [\" +\n\t\t\t\t\t\tAliasForWithMirroredAliasForWrongAttribute.class.getName() +\n\t\t\t\t\t\t\"] declares an alias for 'quux' which is not present.\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForAttributeOfDifferentType() {\n\t\tAliasForAttributeOfDifferentType annotation = AliasForAttributeOfDifferentTypeClass.class.getAnnotation(\n\t\t\t\tAliasForAttributeOfDifferentType.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases\")\n\t\t\t\t.withMessageContaining(AliasForAttributeOfDifferentType.class.getName())\n\t\t\t\t.withMessageContaining(\"attribute 'foo'\")\n\t\t\t\t.withMessageContaining(\"attribute 'bar'\")\n\t\t\t\t.withMessageContaining(\"same return type\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForWithMissingDefaultValues() {\n\t\tAliasForWithMissingDefaultValues annotation = AliasForWithMissingDefaultValuesClass.class.getAnnotation(\n\t\t\t\tAliasForWithMissingDefaultValues.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases\")\n\t\t\t\t.withMessageContaining(AliasForWithMissingDefaultValues.class.getName())\n\t\t\t\t.withMessageContaining(\"attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(\"attribute 'bar' in annotation\")\n\t\t\t\t.withMessageContaining(\"default values\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForAttributeWithDifferentDefaultValue() {\n\t\tAliasForAttributeWithDifferentDefaultValue annotation =\n\t\t\t\tAliasForAttributeWithDifferentDefaultValueClass.class.getAnnotation(\n\t\t\t\t\t\tAliasForAttributeWithDifferentDefaultValue.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases\")\n\t\t\t\t.withMessageContaining(AliasForAttributeWithDifferentDefaultValue.class.getName())\n\t\t\t\t.withMessageContaining(\"attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(\"attribute 'bar' in annotation\")\n\t\t\t\t.withMessageContaining(\"same default value\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForMetaAnnotationThatIsNotMetaPresent() {\n\t\tAliasedComposedTestConfigurationNotMetaPresent annotation =\n\t\t\t\tAliasedComposedTestConfigurationNotMetaPresentClass.class.getAnnotation(\n\t\t\t\t\t\tAliasedComposedTestConfigurationNotMetaPresent.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"@AliasFor declaration on attribute 'xmlConfigFile' in annotation\")\n\t\t\t\t.withMessageContaining(AliasedComposedTestConfigurationNotMetaPresent.class.getName())\n\t\t\t\t.withMessageContaining(\"declares an alias for attribute 'location' in annotation\")\n\t\t\t\t.withMessageContaining(TestConfiguration.class.getName())\n\t\t\t\t.withMessageContaining(\"not meta-present\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliases() {\n\t\ttestSynthesisWithImplicitAliases(ValueImplicitAliasesTestConfigurationClass.class, \"value\");\n\t\ttestSynthesisWithImplicitAliases(Location1ImplicitAliasesTestConfigurationClass.class, \"location1\");\n\t\ttestSynthesisWithImplicitAliases(XmlImplicitAliasesTestConfigurationClass.class, \"xmlFile\");\n\t\ttestSynthesisWithImplicitAliases(GroovyImplicitAliasesSimpleTestConfigurationClass.class, \"groovyScript\");\n\t}\n\n\tprivate void testSynthesisWithImplicitAliases(Class<?> clazz, String expected) {\n\t\tImplicitAliasesTestConfiguration config = clazz.getAnnotation(ImplicitAliasesTestConfiguration.class);\n\t\tassertThat(config).isNotNull();\n\t\tImplicitAliasesTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.value()).isEqualTo(expected);\n\t\tassertThat(synthesized.location1()).isEqualTo(expected);\n\t\tassertThat(synthesized.xmlFile()).isEqualTo(expected);\n\t\tassertThat(synthesized.groovyScript()).isEqualTo(expected);\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesWithImpliedAliasNamesOmitted() {\n\t\ttestSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(\n\t\t\t\tValueImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass.class,\n\t\t\t\t\"value\");\n\t\ttestSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(\n\t\t\t\tLocationsImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass.class,\n\t\t\t\t\"location\");\n\t\ttestSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(\n\t\t\t\tXmlFilesImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass.class,\n\t\t\t\t\"xmlFile\");\n\t}\n\n\tprivate void testSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(Class<?> clazz, String expected) {\n\t\tImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration config = clazz.getAnnotation(\n\t\t\t\tImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration.class);\n\t\tassertThat(config).isNotNull();\n\t\tImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration synthesized =\n\t\t\t\tMergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.value()).isEqualTo(expected);\n\t\tassertThat(synthesized.location()).isEqualTo(expected);\n\t\tassertThat(synthesized.xmlFile()).isEqualTo(expected);\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesForAliasPair() {\n\t\tImplicitAliasesForAliasPairTestConfiguration config =\n\t\t\t\tImplicitAliasesForAliasPairTestConfigurationClass.class.getAnnotation(\n\t\t\t\t\t\tImplicitAliasesForAliasPairTestConfiguration.class);\n\t\tImplicitAliasesForAliasPairTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.xmlFile()).isEqualTo(\"test.xml\");\n\t\tassertThat(synthesized.groovyScript()).isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithTransitiveImplicitAliases() {\n\t\tTransitiveImplicitAliasesTestConfiguration config =\n\t\t\t\tTransitiveImplicitAliasesTestConfigurationClass.class.getAnnotation(\n\t\t\t\t\t\tTransitiveImplicitAliasesTestConfiguration.class);\n\t\tTransitiveImplicitAliasesTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.xml()).isEqualTo(\"test.xml\");\n\t\tassertThat(synthesized.groovy()).isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithTransitiveImplicitAliasesForAliasPair() {\n\t\tTransitiveImplicitAliasesForAliasPairTestConfiguration config =\n\t\t\t\tTransitiveImplicitAliasesForAliasPairTestConfigurationClass.class.getAnnotation(\n\t\t\t\t\t\tTransitiveImplicitAliasesForAliasPairTestConfiguration.class);\n\t\tTransitiveImplicitAliasesForAliasPairTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.xml()).isEqualTo(\"test.xml\");\n\t\tassertThat(synthesized.groovy()).isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesWithMissingDefaultValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithMissingDefaultValuesTestConfigurationClass.class;\n\t\tClass<ImplicitAliasesWithMissingDefaultValuesTestConfiguration> annotationType =\n\t\t\t\tImplicitAliasesWithMissingDefaultValuesTestConfiguration.class;\n\t\tImplicitAliasesWithMissingDefaultValuesTestConfiguration config = clazz.getAnnotation(annotationType);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(clazz, config))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases:\")\n\t\t\t\t.withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t\t.withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t\t.withMessageContaining(\"default values\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesWithDifferentDefaultValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithDifferentDefaultValuesTestConfigurationClass.class;\n\t\tClass<ImplicitAliasesWithDifferentDefaultValuesTestConfiguration> annotationType =\n\t\t\t\tImplicitAliasesWithDifferentDefaultValuesTestConfiguration.class;\n\t\tImplicitAliasesWithDifferentDefaultValuesTestConfiguration config = clazz.getAnnotation(annotationType);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(clazz, config))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases:\")\n\t\t\t\t.withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t\t.withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t\t.withMessageContaining(\"same default value\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesWithDuplicateValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithDuplicateValuesTestConfigurationClass.class;\n\t\tClass<ImplicitAliasesWithDuplicateValuesTestConfiguration> annotationType =\n\t\t\t\tImplicitAliasesWithDuplicateValuesTestConfiguration.class;\n\t\tImplicitAliasesWithDuplicateValuesTestConfiguration config = clazz.getAnnotation(annotationType);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotation.from(clazz, config))\n\t\t\t\t.withMessageStartingWith(\"Different @AliasFor mirror values for annotation\")\n\t\t\t\t.withMessageContaining(annotationType.getName())\n\t\t\t\t.withMessageContaining(\"declared on class\")\n\t\t\t\t.withMessageContaining(clazz.getName())\n\t\t\t\t.withMessageContaining(\"are declared with values of\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tMap<String, Object> map = Collections.singletonMap(\"value\", \"webController\");\n\t\tMergedAnnotation<Component> annotation = MergedAnnotation.of(Component.class, map);\n\n\t\tComponent synthesizedComponent = annotation.synthesize();\n\t\tassertSynthesized(synthesizedComponent);\n\t\tassertThat(synthesizedComponent.value()).isEqualTo(\"webController\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeFromMapWithNestedMap() {\n\t\tComponentScanSingleFilter componentScan = ComponentScanSingleFilterClass.class.getAnnotation(\n\t\t\t\tComponentScanSingleFilter.class);\n\t\tassertThat(componentScan).isNotNull();\n\t\tassertThat(componentScan.value().pattern()).isEqualTo(\"*Foo\");\n\t\tMap<String, Object> map = MergedAnnotation.from(componentScan).asMap(\n\t\t\t\tannotation -> new LinkedHashMap<>(), Adapt.ANNOTATION_TO_MAP);\n\t\tMap<String, Object> filterMap = (Map<String, Object>) map.get(\"value\");\n\t\tassertThat(filterMap.get(\"pattern\")).isEqualTo(\"*Foo\");\n\t\tfilterMap.put(\"pattern\", \"newFoo\");\n\t\tfilterMap.put(\"enigma\", 42);\n\t\tMergedAnnotation<ComponentScanSingleFilter> annotation = MergedAnnotation.of(\n\t\t\t\tComponentScanSingleFilter.class, map);\n\t\tComponentScanSingleFilter synthesizedComponentScan = annotation.synthesize();\n\t\tassertSynthesized(synthesizedComponentScan);\n\t\tassertThat(synthesizedComponentScan.value().pattern()).isEqualTo(\"newFoo\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeFromMapWithNestedArrayOfMaps() {\n\t\tComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class);\n\t\tassertThat(componentScan).isNotNull();\n\t\tMap<String, Object> map = MergedAnnotation.from(componentScan).asMap(\n\t\t\t\tannotation -> new LinkedHashMap<>(), Adapt.ANNOTATION_TO_MAP);\n\t\tMap<String, Object>[] filters = (Map[]) map.get(\"excludeFilters\");\n\t\tList<String> patterns = Arrays.stream(filters).map(\n\t\t\t\tm -> (String) m.get(\"pattern\")).toList();\n\t\tassertThat(patterns).containsExactly(\"*Foo\", \"*Bar\");\n\t\tfilters[0].put(\"pattern\", \"newFoo\");\n\t\tfilters[0].put(\"enigma\", 42);\n\t\tfilters[1].put(\"pattern\", \"newBar\");\n\t\tfilters[1].put(\"enigma\", 42);\n\t\tMergedAnnotation<ComponentScan> annotation = MergedAnnotation.of(ComponentScan.class, map);\n\t\tComponentScan synthesizedComponentScan = annotation.synthesize();\n\t\tassertSynthesized(synthesizedComponentScan);\n\t\tassertThat(Arrays.stream(synthesizedComponentScan.excludeFilters()).map(Filter::pattern))\n\t\t\t\t.containsExactly(\"newFoo\", \"newBar\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromDefaultsWithoutAttributeAliases() {\n\t\tMergedAnnotation<AnnotationWithDefaults> annotation = MergedAnnotation.of(AnnotationWithDefaults.class);\n\t\tAnnotationWithDefaults synthesized = annotation.synthesize();\n\t\tassertThat(synthesized.text()).isEqualTo(\"enigma\");\n\t\tassertThat(synthesized.predicate()).isTrue();\n\t\tassertThat(synthesized.characters()).containsExactly('a', 'b', 'c');\n\t}\n\n\t@Test\n\tvoid synthesizeFromDefaultsWithAttributeAliases() {\n\t\tMergedAnnotation<TestConfiguration> annotation = MergedAnnotation.of(TestConfiguration.class);\n\t\tTestConfiguration synthesized = annotation.synthesize();\n\t\tassertThat(synthesized.value()).isEmpty();\n\t\tassertThat(synthesized.location()).isEmpty();\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasesWithDifferentValues() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tMergedAnnotation.from(TestConfigurationMismatch.class.getAnnotation(TestConfiguration.class)).synthesize());\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithMinimalAttributesWithAttributeAliases() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"location\", \"test.xml\");\n\t\tMergedAnnotation<TestConfiguration> annotation = MergedAnnotation.of(TestConfiguration.class, map);\n\t\tTestConfiguration synthesized = annotation.synthesize();\n\t\tassertThat(synthesized.value()).isEqualTo(\"test.xml\");\n\t\tassertThat(synthesized.location()).isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements() {\n\t\tsynthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements(\n\t\t\t\tCollections.singletonMap(\"value\", \"/foo\"));\n\t\tsynthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements(\n\t\t\t\tCollections.singletonMap(\"path\", \"/foo\"));\n\t}\n\n\tprivate void synthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements(Map<String, Object> map) {\n\t\tMergedAnnotation<GetMapping> annotation = MergedAnnotation.of(GetMapping.class, map);\n\t\tGetMapping synthesized = annotation.synthesize();\n\t\tassertThat(synthesized.value()).isEqualTo(\"/foo\");\n\t\tassertThat(synthesized.path()).isEqualTo(\"/foo\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithImplicitAttributeAliases() {\n\t\ttestSynthesisFromMapWithImplicitAliases(\"value\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"location1\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"location2\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"location3\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"xmlFile\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"groovyScript\");\n\t}\n\n\tprivate void testSynthesisFromMapWithImplicitAliases(String attributeNameAndValue) {\n\t\tMap<String, Object> map = Collections.singletonMap(attributeNameAndValue, attributeNameAndValue);\n\t\tMergedAnnotation<ImplicitAliasesTestConfiguration> annotation = MergedAnnotation.of(\n\t\t\t\tImplicitAliasesTestConfiguration.class, map);\n\t\tImplicitAliasesTestConfiguration synthesized = annotation.synthesize();\n\n\t\tassertThat(synthesized.value()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.location1()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.location2()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.location2()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.xmlFile()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.groovyScript()).isEqualTo(attributeNameAndValue);\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithMissingAttributeValue() {\n\t\ttestMissingTextAttribute(Collections.emptyMap());\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithNullAttributeValue() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"text\", null);\n\t\tassertThat(map).containsKey(\"text\");\n\t\ttestMissingTextAttribute(map);\n\t}\n\n\tprivate void testMissingTextAttribute(Map<String, Object> attributes) {\n\t\tassertThatExceptionOfType(NoSuchElementException.class).isThrownBy(() ->\n\t\t\t\tMergedAnnotation.of(AnnotationWithoutDefaults.class, attributes).synthesize().text())\n\t\t\t\t.withMessage(\"No value found for attribute named 'text' in merged annotation \" +\n\t\t\t\t\t\tAnnotationWithoutDefaults.class.getCanonicalName());\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithAttributeOfIncorrectType() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"value\", 42L);\n\t\tMergedAnnotation<Component> annotation = MergedAnnotation.of(Component.class, map);\n\t\tassertThatIllegalStateException().isThrownBy(() -> annotation.synthesize().value())\n\t\t\t\t.withMessage(\"Attribute 'value' in annotation \" +\n\t\t\t\t\t\t\"org.springframework.core.testfixture.stereotype.Component should be \" +\n\t\t\t\t\t\t\"compatible with java.lang.String but a java.lang.Long value was returned\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromAnnotationAttributesWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tMap<String, Object> attributes = MergedAnnotation.from(component).asMap();\n\n\t\tComponent synthesized = MergedAnnotation.of(Component.class, attributes).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized).isEqualTo(component);\n\t}\n\n\t@Test\n\tvoid toStringForSynthesizedAnnotations() throws Exception {\n\t\tMethod methodWithPath = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\tRequestMapping webMappingWithAliases = methodWithPath.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithAliases).isNotNull();\n\n\t\tMethod methodWithPathAndValue = WebController.class.getMethod(\"handleMappedWithSamePathAndValueAttributes\");\n\t\tRequestMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(RequestMapping.class);\n\t\tassertThat(methodWithPathAndValue).isNotNull();\n\n\t\tRequestMapping synthesizedWebMapping1 = MergedAnnotation.from(webMappingWithAliases).synthesize();\n\t\tRequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMappingWithPathAndValue).synthesize();\n\n\t\tassertThat(webMappingWithAliases.toString()).isNotEqualTo(synthesizedWebMapping1.toString());\n\n\t\t// The unsynthesized annotation for handleMappedWithSamePathAndValueAttributes()\n\t\t// should produce almost the same toString() results as synthesized annotations for\n\t\t// handleMappedWithPathAttribute() on Java 9 or higher; however, due to multiple changes\n\t\t// in the JDK's toString() implementation for annotations in JDK 9, 14, and 19,\n\t\t// we do not test the JDK implementation.\n\t\t// assertToStringForWebMappingWithPathAndValue(webMappingWithPathAndValue);\n\n\t\tassertToStringForWebMappingWithPathAndValue(synthesizedWebMapping1);\n\t\tassertToStringForWebMappingWithPathAndValue(synthesizedWebMapping2);\n\t}\n\n\tprivate void assertToStringForWebMappingWithPathAndValue(RequestMapping webMapping) {\n\t\tassertThat(webMapping.toString())\n\t\t\t\t.startsWith(\"@org.springframework.core.annotation.MergedAnnotationsTests.RequestMapping(\")\n\t\t\t\t.contains(\n\t\t\t\t\t// Strings\n\t\t\t\t\t\"value={\\\"/test\\\"}\", \"path={\\\"/test\\\"}\", \"name=\\\"bar\\\"\",\n\t\t\t\t\t// Characters\n\t\t\t\t\t\"ch='X'\", \"chars={'X'}\",\n\t\t\t\t\t// Enums\n\t\t\t\t\t\"method={GET, POST}\",\n\t\t\t\t\t// Classes\n\t\t\t\t\t\"clazz=org.springframework.core.annotation.MergedAnnotationsTests.RequestMethod.class\",\n\t\t\t\t\t\"classes={int[][].class, org.springframework.core.annotation.MergedAnnotationsTests.RequestMethod[].class}\",\n\t\t\t\t\t// Bytes\n\t\t\t\t\t\"byteValue=(byte) 0xFF\", \"bytes={(byte) 0xFF}\",\n\t\t\t\t\t// Shorts\n\t\t\t\t\t\"shortValue=9876\", \"shorts={9876}\",\n\t\t\t\t\t// Longs\n\t\t\t\t\t\"longValue=42L\", \"longs={42L}\",\n\t\t\t\t\t// Floats\n\t\t\t\t\t\"floatValue=3.14f\", \"floats={3.14f}\",\n\t\t\t\t\t// Doubles\n\t\t\t\t\t\"doubleValue=99.999d\", \"doubles={99.999d}\"\n\t\t\t\t)\n\t\t\t\t.endsWith(\")\");\n\t}\n\n\t@Test\n\tvoid equalsForSynthesizedAnnotations() throws Exception {\n\t\tMethod methodWithPath = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\tRequestMapping webMappingWithAliases = methodWithPath.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithAliases).isNotNull();\n\t\tMethod methodWithPathAndValue = WebController.class.getMethod(\"handleMappedWithSamePathAndValueAttributes\");\n\t\tRequestMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithPathAndValue).isNotNull();\n\t\tRequestMapping synthesizedWebMapping1 = MergedAnnotation.from(webMappingWithAliases).synthesize();\n\t\tRequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMappingWithPathAndValue).synthesize();\n\t\t// Equality amongst standard annotations\n\t\tassertThat(webMappingWithAliases).isEqualTo(webMappingWithAliases);\n\t\tassertThat(webMappingWithPathAndValue).isEqualTo(webMappingWithPathAndValue);\n\t\t// Inequality amongst standard annotations\n\t\tassertThat(webMappingWithAliases).isNotEqualTo(webMappingWithPathAndValue);\n\t\tassertThat(webMappingWithPathAndValue).isNotEqualTo(webMappingWithAliases);\n\t\t// Equality amongst synthesized annotations\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(synthesizedWebMapping1);\n\t\tassertThat(synthesizedWebMapping2).isEqualTo(synthesizedWebMapping2);\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(synthesizedWebMapping2);\n\t\tassertThat(synthesizedWebMapping2).isEqualTo(synthesizedWebMapping1);\n\t\t// Equality between standard and synthesized annotations\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(webMappingWithPathAndValue);\n\t\tassertThat(webMappingWithPathAndValue).isEqualTo(synthesizedWebMapping1);\n\t\t// Inequality between standard and synthesized annotations\n\t\tassertThat(synthesizedWebMapping1).isNotEqualTo(webMappingWithAliases);\n\t\tassertThat(webMappingWithAliases).isNotEqualTo(synthesizedWebMapping1);\n\t}\n\n\t@Test\n\tvoid hashCodeForSynthesizedAnnotations() throws Exception {\n\t\tMethod methodWithPath = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\tRequestMapping webMappingWithAliases = methodWithPath.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithAliases).isNotNull();\n\t\tMethod methodWithPathAndValue = WebController.class.getMethod(\"handleMappedWithSamePathAndValueAttributes\");\n\t\tRequestMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithPathAndValue).isNotNull();\n\t\tRequestMapping synthesizedWebMapping1 = MergedAnnotation.from(webMappingWithAliases).synthesize();\n\t\tassertThat(synthesizedWebMapping1).isNotNull();\n\t\tRequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMappingWithPathAndValue).synthesize();\n\t\tassertThat(synthesizedWebMapping2).isNotNull();\n\t\t// Equality amongst standard annotations\n\t\tassertThat(webMappingWithAliases.hashCode()).isEqualTo(webMappingWithAliases.hashCode());\n\t\tassertThat(webMappingWithPathAndValue.hashCode()).isEqualTo(webMappingWithPathAndValue.hashCode());\n\t\t// Inequality amongst standard annotations\n\t\tassertThat(webMappingWithAliases.hashCode()).isNotEqualTo(webMappingWithPathAndValue.hashCode());\n\t\tassertThat(webMappingWithPathAndValue.hashCode()).isNotEqualTo(webMappingWithAliases.hashCode());\n\t\t// Equality amongst synthesized annotations\n\t\tassertThat(synthesizedWebMapping1.hashCode()).isEqualTo(synthesizedWebMapping1.hashCode());\n\t\tassertThat(synthesizedWebMapping2.hashCode()).isEqualTo(synthesizedWebMapping2.hashCode());\n\t\tassertThat(synthesizedWebMapping1.hashCode()).isEqualTo(synthesizedWebMapping2.hashCode());\n\t\tassertThat(synthesizedWebMapping2.hashCode()).isEqualTo(synthesizedWebMapping1.hashCode());\n\t\t// Equality between standard and synthesized annotations\n\t\tassertThat(synthesizedWebMapping1.hashCode()).isEqualTo(webMappingWithPathAndValue.hashCode());\n\t\tassertThat(webMappingWithPathAndValue.hashCode()).isEqualTo(synthesizedWebMapping1.hashCode());\n\t\t// Inequality between standard and synthesized annotations\n\t\tassertThat(synthesizedWebMapping1.hashCode()).isNotEqualTo(webMappingWithAliases.hashCode());\n\t\tassertThat(webMappingWithAliases.hashCode()).isNotEqualTo(synthesizedWebMapping1.hashCode());\n\t}\n\n\t/**\n\t * Fully reflection-based test that verifies support for synthesizing\n\t * annotations across packages with non-public visibility of user types\n\t * (for example, a non-public annotation that uses {@code @AliasFor}).\n\t */\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeNonPublicWithAttributeAliasesFromDifferentPackage() throws Exception {\n\t\tClass<?> type = ClassUtils.forName(\n\t\t\t\t\"org.springframework.core.annotation.subpackage.NonPublicAliasedAnnotatedClass\",\n\t\t\t\tnull);\n\t\tClass<? extends Annotation> annotationType = (Class<? extends Annotation>) ClassUtils.forName(\n\t\t\t\t\"org.springframework.core.annotation.subpackage.NonPublicAliasedAnnotation\",\n\t\t\t\tnull);\n\t\tAnnotation annotation = type.getAnnotation(annotationType);\n\t\tassertThat(annotation).isNotNull();\n\t\tMergedAnnotation<Annotation> mergedAnnotation = MergedAnnotation.from(annotation);\n\t\tAnnotation synthesizedAnnotation = mergedAnnotation.synthesize();\n\t\tassertSynthesized(synthesizedAnnotation);\n\t\tassertThat(mergedAnnotation.getString(\"name\")).isEqualTo(\"test\");\n\t\tassertThat(mergedAnnotation.getString(\"path\")).isEqualTo(\"/test\");\n\t\tassertThat(mergedAnnotation.getString(\"value\")).isEqualTo(\"/test\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithArrayOfAnnotations() {\n\t\tHierarchy hierarchy = HierarchyClass.class.getAnnotation(Hierarchy.class);\n\t\tassertThat(hierarchy).isNotNull();\n\t\tHierarchy synthesizedHierarchy = MergedAnnotation.from(hierarchy).synthesize();\n\t\tassertSynthesized(synthesizedHierarchy);\n\t\tTestConfiguration[] configs = synthesizedHierarchy.value();\n\t\tassertThat(configs).isNotNull();\n\t\tassertThat(configs).allMatch(AnnotationUtils::isSynthesizedAnnotation);\n\t\tassertThat(configs).extracting(TestConfiguration::value).containsExactly(\"A\", \"B\");\n\t\tassertThat(configs).extracting(TestConfiguration::location).containsExactly(\"A\", \"B\");\n\n\t\tTestConfiguration contextConfig = TestConfigurationClass.class.getAnnotation(TestConfiguration.class);\n\t\tassertThat(contextConfig).isNotNull();\n\t\t// Alter array returned from synthesized annotation\n\t\tconfigs[0] = contextConfig;\n\t\tassertThat(configs).extracting(TestConfiguration::value).containsExactly(\"simple.xml\", \"B\");\n\t\t// Re-retrieve the array from the synthesized annotation\n\t\tconfigs = synthesizedHierarchy.value();\n\t\tassertThat(configs).extracting(TestConfiguration::value).containsExactly(\"A\", \"B\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithArrayOfChars() {\n\t\tCharsContainer charsContainer = GroupOfCharsClass.class.getAnnotation(CharsContainer.class);\n\t\tassertThat(charsContainer).isNotNull();\n\t\tCharsContainer synthesizedCharsContainer = MergedAnnotation.from(charsContainer).synthesize();\n\t\tassertSynthesized(synthesizedCharsContainer);\n\t\tchar[] chars = synthesizedCharsContainer.chars();\n\t\tassertThat(chars).containsExactly('x', 'y', 'z');\n\t\t// Alter array returned from synthesized annotation\n\t\tchars[0] = '?';\n\t\t// Re-retrieve the array from the synthesized annotation\n\t\tchars = synthesizedCharsContainer.chars();\n\t\tassertThat(chars).containsExactly('x', 'y', 'z');\n\t}\n\n\t@Test\n\tvoid getValueWhenHasDefaultOverride() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(DefaultOverrideClass.class)\n\t\t\t\t.get(DefaultOverrideRoot.class);\n\t\tassertThat(annotation.getString(\"text\")).isEqualTo(\"metameta\");\n\t}\n\n\t@Test // gh-22654\n\tvoid getValueWhenHasDefaultOverrideWithImplicitAlias() {\n\t\tMergedAnnotation<?> annotation1 = MergedAnnotations.from(DefaultOverrideImplicitAliasMetaClass1.class)\n\t\t\t\t.get(DefaultOverrideRoot.class);\n\t\tassertThat(annotation1.getString(\"text\")).isEqualTo(\"alias-meta-1\");\n\t\tMergedAnnotation<?> annotation2 = MergedAnnotations.from(DefaultOverrideImplicitAliasMetaClass2.class)\n\t\t\t\t.get(DefaultOverrideRoot.class);\n\t\tassertThat(annotation2.getString(\"text\")).isEqualTo(\"alias-meta-2\");\n\t}\n\n\t@Test // gh-22654\n\tvoid getValueWhenHasDefaultOverrideWithExplicitAlias() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(DefaultOverrideExplicitAliasRootMetaMetaClass.class)\n\t\t\t\t.get(DefaultOverrideExplicitAliasRoot.class);\n\t\tassertThat(annotation.getString(\"text\")).isEqualTo(\"meta\");\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta\");\n\t}\n\n\t@Test // gh-22703\n\tvoid getValueWhenThreeDeepMetaWithValue() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(ValueAttributeMetaMetaClass.class)\n\t\t\t\t.get(ValueAttribute.class);\n\t\tassertThat(annotation.getStringArray(MergedAnnotation.VALUE)).containsExactly(\"FromValueAttributeMeta\");\n\t}\n\n\t@Test\n\tvoid asAnnotationAttributesReturnsPopulatedAnnotationAttributes() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(SpringApplicationConfigurationClass.class)\n\t\t\t\t.get(SpringApplicationConfiguration.class);\n\t\tAnnotationAttributes attributes = annotation.asAnnotationAttributes(Adapt.CLASS_TO_STRING);\n\t\tassertThat(attributes).containsEntry(\"classes\", new String[] {Number.class.getName()});\n\t\tassertThat(attributes.annotationType()).isEqualTo(SpringApplicationConfiguration.class);\n\t}\n\n\n\t// @formatter:off\n\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Transactional {\n\n\t\tString value() default \"\";\n\n\t\tString qualifier() default \"transactionManager\";\n\n\t\tboolean readOnly() default false;\n\t}\n\n\t@Transactional\n\t@Component\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransactionalComponent {\n\t}\n\n\t@TransactionalComponent\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedTransactionalComponent {\n\t}\n\n\tstatic class NonAnnotatedClass {\n\t}\n\n\t@Component\n\tstatic class AnnotatedClass {\n\n\t\tclass NonAnnotatedInnerClass {\n\t\t}\n\n\t\tstatic class NonAnnotatedStaticNestedClass {\n\t\t}\n\t}\n\n\tinterface NonAnnotatedInterface {\n\t}\n\n\t@TransactionalComponent\n\tstatic class TransactionalComponentClass {\n\t}\n\n\tstatic class SubTransactionalComponentClass extends TransactionalComponentClass {\n\t}\n\n\t@ComposedTransactionalComponent\n\tstatic class ComposedTransactionalComponentClass {\n\t}\n\n\t@AliasedTransactionalComponent\n\tstatic class AliasedTransactionalComponentClass {\n\t}\n\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface AliasedTransactional {\n\n\t\t@AliasFor(attribute = \"qualifier\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tString qualifier() default \"\";\n\t}\n\n\t@Transactional(qualifier = \"composed1\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@Inherited\n\t@interface InheritedComposed {\n\t}\n\n\t@Transactional(qualifier = \"composed2\", readOnly = true)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface Composed {\n\t}\n\n\t@Transactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxComposedWithOverride {\n\n\t\tString qualifier() default \"txMgr\";\n\t}\n\n\t@Transactional(\"TxInheritedComposed\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxInheritedComposed {\n\t}\n\n\t@Transactional(\"TxComposed\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxComposed {\n\t}\n\n\t@AliasedTransactional(value = \"aliasForQualifier\")\n\t@Component\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedTransactionalComponent {\n\t}\n\n\t@AliasedTransactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MyAliasedTransactional {\n\n\t\t@AliasFor(annotation = AliasedTransactional.class, attribute = \"value\")\n\t\tString value() default \"defaultTransactionManager\";\n\t}\n\n\t@MyAliasedTransactional(\"anotherTransactionManager\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@interface ComposedMyAliasedTransactional {\n\t}\n\n\t@ComposedMyAliasedTransactional\n\tstatic class ComposedTransactionalClass {\n\t}\n\n\t@AliasedTransactional(\"meta\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaAliasedTransactional {\n\t}\n\n\t@MetaAliasedTransactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMetaAliasedTransactional {\n\t}\n\n\t@MetaMetaAliasedTransactional\n\tstatic class MetaMetaAliasedTransactionalClass {\n\t}\n\n\t@TxComposedWithOverride\n\t// Override default \"txMgr\" from @TxComposedWithOverride with \"localTxMgr\"\n\t@Transactional(qualifier = \"localTxMgr\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface MetaAndLocalTxConfig {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestPropertySource {\n\n\t\t@AliasFor(\"locations\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] locations() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContextConfiguration {\n\n\t\t@AliasFor(attribute = \"locations\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tString[] locations() default {};\n\n\t\tClass<?>[] classes() default {};\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionBasedComposedContextConfiguration {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] locations() default {};\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class)\n\t\tClass<?>[] classes() default {};\n\t}\n\n\t@ContextConfiguration(value = \"duplicateDeclaration\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface InvalidConventionBasedComposedContextConfiguration {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] locations();\n\t}\n\n\t/**\n\t * This hybrid approach for annotation attribute overrides with transitive implicit\n\t * aliases is unsupported. See SPR-13554 for details.\n\t */\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface HalfConventionBasedAndHalfAliasedComposedContextConfiguration {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] locations() default {};\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles() default {};\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles();\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedValueComposedContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"value\")\n\t\tString[] locations();\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] groovyScripts() default {};\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlFiles() default {};\n\n\t\t// intentionally omitted: attribute = \"locations\"\n\t\t@AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] locations() default {};\n\n\t\t// intentionally omitted: attribute = \"locations\" (SPR-14069)\n\t\t@AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] value() default {};\n\t}\n\n\t@ImplicitAliasesContextConfiguration(xmlFiles = { \"A.xml\", \"B.xml\" })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedImplicitAliasesContextConfiguration {\n\t}\n\n\t@ImplicitAliasesContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesContextConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"xmlFiles\")\n\t\tString[] xml() default {};\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\n\t\tString[] groovy() default {};\n\t}\n\n\t@ImplicitAliasesContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SingleLocationTransitiveImplicitAliasesContextConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"xmlFiles\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@ImplicitAliasesContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesWithSkippedLevelContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xml() default {};\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\n\t\tString[] groovy() default {};\n\t}\n\n\t@ImplicitAliasesContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\n\t\tString groovy() default \"\";\n\t}\n\n\t/**\n\t * Although the configuration declares an explicit value for 'value' and requires a\n\t * value for the aliased 'locations', this does not result in an error since\n\t * 'locations' effectively shadows the 'value' attribute (which cannot be set via the\n\t * composed annotation anyway). If 'value' were not shadowed, such a declaration would\n\t * not make sense.\n\t */\n\t@ContextConfiguration(value = \"duplicateDeclaration\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ShadowedAliasComposedContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles();\n\t}\n\n\t@ContextConfiguration(locations = \"shadowed.xml\")\n\t@TestPropertySource(locations = \"test.properties\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfigurationAndTestPropertySource {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles() default \"default.xml\";\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SpringApplicationConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] locations() default {};\n\n\t\t// Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class, attribute = \"classes\")\n\t\t@AliasFor(\"value\")\n\t\tClass<?>[] classes() default {};\n\n\t\t// Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class, attribute = \"classes\")\n\t\t@AliasFor(\"classes\")\n\t\tClass<?>[] value() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScan {\n\n\t\t@AliasFor(\"basePackages\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] basePackages() default {};\n\n\t\tFilter[] excludeFilters() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({})\n\t@interface Filter {\n\n\t\tString pattern();\n\t}\n\n\t@ComponentScan(excludeFilters = { @Filter(pattern = \"*Test\"),\n\t\t@Filter(pattern = \"*Tests\") })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestComponentScan {\n\n\t\t@AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\n\t\tString[] packages();\n\t}\n\n\t@ComponentScan\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionBasedSinglePackageComponentScan {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ComponentScan.class)\n\t\tString basePackages();\n\t}\n\n\t@ComponentScan\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForBasedSinglePackageComponentScan {\n\n\t\t@AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\n\t\tString pkg();\n\t}\n\n\t@Transactional\n\tstatic class ClassWithInheritedAnnotation {\n\t}\n\n\t@Composed\n\tstatic class SubClassWithInheritedAnnotation extends ClassWithInheritedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedAnnotation\n\t\t\textends SubClassWithInheritedAnnotation {\n\t}\n\n\t@InheritedComposed\n\tstatic class ClassWithInheritedComposedAnnotation {\n\t}\n\n\t@Composed\n\tstatic class SubClassWithInheritedComposedAnnotation\n\t\t\textends ClassWithInheritedComposedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedComposedAnnotation\n\t\t\textends SubClassWithInheritedComposedAnnotation {\n\t}\n\n\t@MetaAndLocalTxConfig\n\tstatic class MetaAndLocalTxConfigClass {\n\t}\n\n\t@Transactional(\"TxConfig\")\n\tstatic class TxConfig {\n\t}\n\n\t@Transactional(\"DerivedTxConfig\")\n\tstatic class DerivedTxConfig extends TxConfig {\n\t}\n\n\t@TxInheritedComposed\n\t@TxComposed\n\tstatic class TxFromMultipleComposedAnnotations {\n\t}\n\n\t@Transactional\n\tinterface InterfaceWithInheritedAnnotation {\n\n\t\t@Order\n\t\tvoid handleFromInterface();\n\t}\n\n\tabstract static class AbstractClassWithInheritedAnnotation<T>\n\t\t\timplements InterfaceWithInheritedAnnotation {\n\n\t\t@Transactional\n\t\tpublic abstract void handle();\n\n\t\t@Transactional\n\t\tpublic void handleParameterized(T t) {\n\t\t}\n\t}\n\n\tstatic class ConcreteClassWithInheritedAnnotation\n\t\t\textends AbstractClassWithInheritedAnnotation<String> {\n\n\t\t@Override\n\t\tpublic void handle() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleParameterized(String s) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleFromInterface() {\n\t\t}\n\t}\n\n\tpublic interface GenericParameter<T> {\n\n\t\tT getFor(Class<T> cls);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class StringGenericParameter implements GenericParameter<String> {\n\n\t\t@Order\n\t\t@Override\n\t\tpublic String getFor(Class<String> cls) {\n\t\t\treturn \"foo\";\n\t\t}\n\n\t\tpublic String getFor(Integer integer) {\n\t\t\treturn \"foo\";\n\t\t}\n\t}\n\n\t@Transactional\n\tpublic interface InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubInheritedAnnotationInterface\n\t\t\textends InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubInheritedAnnotationInterface\n\t\t\textends SubInheritedAnnotationInterface {\n\t}\n\n\t@Order\n\tpublic interface NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubNonInheritedAnnotationInterface\n\t\t\textends NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubNonInheritedAnnotationInterface\n\t\t\textends SubNonInheritedAnnotationInterface {\n\t}\n\n\t@ConventionBasedComposedContextConfiguration(locations = \"explicitDeclaration\")\n\tstatic class ConventionBasedComposedContextConfigurationClass {\n\t}\n\n\t@InvalidConventionBasedComposedContextConfiguration(locations = \"requiredLocationsDeclaration\")\n\tstatic class InvalidConventionBasedComposedContextConfigurationClass {\n\t}\n\n\t@HalfConventionBasedAndHalfAliasedComposedContextConfiguration(xmlConfigFiles = \"explicitDeclaration\")\n\tstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass1 {\n\t}\n\n\t@HalfConventionBasedAndHalfAliasedComposedContextConfiguration(locations = \"explicitDeclaration\")\n\tstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass2 {\n\t}\n\n\t@AliasedComposedContextConfiguration(xmlConfigFiles = \"test.xml\")\n\tstatic class AliasedComposedContextConfigurationClass {\n\t}\n\n\t@AliasedValueComposedContextConfiguration(locations = \"test.xml\")\n\tstatic class AliasedValueComposedContextConfigurationClass {\n\t}\n\n\t@ImplicitAliasesContextConfiguration(\"foo.xml\")\n\tstatic class ImplicitAliasesContextConfigurationClass1 {\n\t}\n\n\t@ImplicitAliasesContextConfiguration(locations = \"bar.xml\")\n\tstatic class ImplicitAliasesContextConfigurationClass2 {\n\t}\n\n\t@ImplicitAliasesContextConfiguration(xmlFiles = \"baz.xml\")\n\tstatic class ImplicitAliasesContextConfigurationClass3 {\n\t}\n\n\t@TransitiveImplicitAliasesContextConfiguration(groovy = \"test.groovy\")\n\tstatic class TransitiveImplicitAliasesContextConfigurationClass {\n\t}\n\n\t@SingleLocationTransitiveImplicitAliasesContextConfiguration(groovy = \"test.groovy\")\n\tstatic class SingleLocationTransitiveImplicitAliasesContextConfigurationClass {\n\t}\n\n\t@TransitiveImplicitAliasesWithSkippedLevelContextConfiguration(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass {\n\t}\n\n\t@SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfiguration(xml = \"test.xml\")\n\tstatic class SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass {\n\t}\n\n\t@ComposedImplicitAliasesContextConfiguration\n\tstatic class ComposedImplicitAliasesContextConfigurationClass {\n\t}\n\n\t@ShadowedAliasComposedContextConfiguration(xmlConfigFiles = \"test.xml\")\n\tstatic class ShadowedAliasComposedContextConfigurationClass {\n\t}\n\n\t@AliasedComposedContextConfigurationAndTestPropertySource(xmlConfigFiles = \"test.xml\")\n\tstatic class AliasedComposedContextConfigurationAndTestPropertySourceClass {\n\t}\n\n\t@ComponentScan(value = \"com.example.app.test\", basePackages = \"com.example.app.test\")\n\tstatic class ComponentScanWithBasePackagesAndValueAliasClass {\n\t}\n\n\t@TestComponentScan(packages = \"com.example.app.test\")\n\tstatic class TestComponentScanClass {\n\t}\n\n\t@ConventionBasedSinglePackageComponentScan(basePackages = \"com.example.app.test\")\n\tstatic class ConventionBasedSinglePackageComponentScanClass {\n\t}\n\n\t@AliasForBasedSinglePackageComponentScan(pkg = \"com.example.app.test\")\n\tstatic class AliasForBasedSinglePackageComponentScanClass {\n\t}\n\n\t@SpringApplicationConfiguration(Number.class)\n\tstatic class SpringApplicationConfigurationClass {\n\t}\n\n\t@Resource(name = \"x\")\n\tstatic class ResourceHolder {\n\t}\n\n\tinterface TransactionalService {\n\n\t\t@Transactional\n\t\tvoid doIt();\n\t}\n\n\tclass TransactionalServiceImpl implements TransactionalService {\n\n\t\t@Override\n\t\tpublic void doIt() {\n\t\t}\n\t}\n\n\t@Component(\"meta1\")\n\t@Order\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Meta1 {\n\t}\n\n\t@Component(\"meta2\")\n\t@Transactional(readOnly = true)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Meta2 {\n\t}\n\n\t@Meta2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMeta {\n\t}\n\n\t@MetaMeta\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMetaMeta {\n\t}\n\n\t@MetaCycle3\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle1 {\n\t}\n\n\t@MetaCycle1\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle2 {\n\t}\n\n\t@MetaCycle2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle3 {\n\t}\n\n\t@Meta1\n\tinterface InterfaceWithMetaAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface\n\t\t\timplements InterfaceWithMetaAnnotation {\n\t}\n\n\t@Meta1\n\tstatic class ClassWithInheritedMetaAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class SubClassWithInheritedMetaAnnotation\n\t\t\textends ClassWithInheritedMetaAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedMetaAnnotation\n\t\t\textends SubClassWithInheritedMetaAnnotation {\n\t}\n\n\t@MetaMeta\n\tstatic class MetaMetaAnnotatedClass {\n\t}\n\n\t@MetaMetaMeta\n\tstatic class MetaMetaMetaAnnotatedClass {\n\t}\n\n\t@MetaCycle3\n\tstatic class MetaCycleAnnotatedClass {\n\t}\n\n\tinterface AnnotatedInterface {\n\n\t\t@Order(0)\n\t\tvoid fromInterfaceImplementedByRoot();\n\t}\n\n\tinterface NullableAnnotatedInterface {\n\n\t\t@Nullable String fromInterfaceImplementedByRoot();\n\t}\n\n\tstatic class Root implements AnnotatedInterface {\n\n\t\t@Order(27)\n\t\tpublic void annotatedOnRoot() {\n\t\t}\n\n\t\t@Meta1\n\t\tpublic void metaAnnotatedOnRoot() {\n\t\t}\n\n\t\tpublic void overrideToAnnotate() {\n\t\t}\n\n\t\t@Order(27)\n\t\tpublic void overrideWithoutNewAnnotation() {\n\t\t}\n\n\t\tpublic void notAnnotated() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void fromInterfaceImplementedByRoot() {\n\t\t}\n\t}\n\n\tpublic static class Leaf extends Root {\n\n\t\t@Order(25)\n\t\tpublic void annotatedOnLeaf() {\n\t\t}\n\n\t\t@Meta1\n\t\tpublic void metaAnnotatedOnLeaf() {\n\t\t}\n\n\t\t@MetaMeta\n\t\tpublic void metaMetaAnnotatedOnLeaf() {\n\t\t}\n\n\t\t@Override\n\t\t@Order(1)\n\t\tpublic void overrideToAnnotate() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void overrideWithoutNewAnnotation() {\n\t\t}\n\t}\n\n\tpublic abstract static class SimpleGeneric<T> {\n\n\t\t@Order(1)\n\t\tpublic abstract void something(T arg);\n\n\t}\n\n\tpublic static class TransactionalStringGeneric extends SimpleGeneric<String> {\n\n\t\t@Override\n\t\t@Transactional\n\t\tpublic void something(final String arg) {\n\t\t}\n\t}\n\n\t@Transactional\n\tpublic static class InheritedAnnotationClass {\n\t}\n\n\tpublic static class SubInheritedAnnotationClass extends InheritedAnnotationClass {\n\t}\n\n\t@Order\n\tpublic static class NonInheritedAnnotationClass {\n\t}\n\n\tpublic static class SubNonInheritedAnnotationClass\n\t\t\textends NonInheritedAnnotationClass {\n\t}\n\n\t@Transactional\n\tpublic static class TransactionalClass {\n\t}\n\n\t@Order\n\tpublic static class TransactionalAndOrderedClass extends TransactionalClass {\n\t}\n\n\tpublic static class SubTransactionalAndOrderedClass\n\t\t\textends TransactionalAndOrderedClass {\n\t}\n\n\tpublic interface InterfaceWithAnnotatedMethod {\n\n\t\t@Order\n\t\tvoid foo();\n\t}\n\n\tpublic static class ImplementsInterfaceWithAnnotatedMethod\n\t\t\timplements InterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic static class SubOfImplementsInterfaceWithAnnotatedMethod\n\t\t\textends ImplementsInterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic abstract static class AbstractDoesNotImplementInterfaceWithAnnotatedMethod\n\t\t\timplements InterfaceWithAnnotatedMethod {\n\t}\n\n\tpublic static class SubOfAbstractImplementsInterfaceWithAnnotatedMethod\n\t\t\textends AbstractDoesNotImplementInterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic interface InterfaceWithGenericAnnotatedMethod<T> {\n\n\t\t@Order\n\t\tvoid foo(T t);\n\t}\n\n\tpublic static class ImplementsInterfaceWithGenericAnnotatedMethod\n\t\t\timplements InterfaceWithGenericAnnotatedMethod<String> {\n\n\t\t@Override\n\t\tpublic void foo(String t) {\n\t\t}\n\t}\n\n\tpublic abstract static class BaseClassWithGenericAnnotatedMethod<T> {\n\n\t\t@Order\n\t\tabstract void foo(T t);\n\t}\n\n\tpublic static class ExtendsBaseClassWithGenericAnnotatedMethod\n\t\t\textends BaseClassWithGenericAnnotatedMethod<String> {\n\n\t\t@Override\n\t\tpublic void foo(String t) {\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface MyRepeatableContainer {\n\n\t\tMyRepeatable[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@Repeatable(MyRepeatableContainer.class)\n\t@interface MyRepeatable {\n\n\t\tString value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta1\")\n\t@interface MyRepeatableMeta1 {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta2\")\n\t@interface MyRepeatableMeta2 {\n\t}\n\n\tinterface InterfaceWithRepeated {\n\n\t\t@MyRepeatable(\"A\")\n\t\t@MyRepeatableContainer({ @MyRepeatable(\"B\"), @MyRepeatable(\"C\") })\n\t\t@MyRepeatableMeta1\n\t\tvoid foo();\n\t}\n\n\t@MyRepeatable(\"A\")\n\t@MyRepeatableContainer({ @MyRepeatable(\"B\"), @MyRepeatable(\"C\") })\n\t@MyRepeatableMeta1\n\tstatic class MyRepeatableClass {\n\t}\n\n\tstatic class SubMyRepeatableClass extends MyRepeatableClass {\n\t}\n\n\t@MyRepeatable(\"X\")\n\t@MyRepeatableContainer({ @MyRepeatable(\"Y\"), @MyRepeatable(\"Z\") })\n\t@MyRepeatableMeta2\n\tstatic class SubMyRepeatableWithAdditionalLocalDeclarationsClass\n\t\t\textends MyRepeatableClass {\n\t}\n\n\tstatic class SubSubMyRepeatableWithAdditionalLocalDeclarationsClass\n\t\t\textends SubMyRepeatableWithAdditionalLocalDeclarationsClass {\n\t}\n\n\tenum RequestMethod {\n\t\tGET,\n\n\t\tPOST;\n\n\t\t/**\n\t\t * custom override to verify annotation toString() implementations.\n\t\t */\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"method: \" + name().toLowerCase();\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface RequestMapping {\n\n\t\tString name();\n\n\t\t@AliasFor(\"path\")\n\t\tString[] value() default \"\";\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tString[] path() default \"\";\n\n\t\tRequestMethod[] method() default {};\n\n\t\t// ---------------------------------------------------------------------\n\t\t// All remaining attributes declare default values that are used solely\n\t\t// for the purpose of testing the toString() implementations for annotations.\n\t\tClass<?> clazz() default RequestMethod.class;\n\t\tClass<?>[] classes() default {int[][].class, RequestMethod[].class};\n\n\t\tchar ch() default 'X';\n\t\tchar[] chars() default {'X'};\n\n\t\tbyte byteValue() default (byte) 0xFF;\n\t\tbyte[] bytes() default {(byte) 0xFF};\n\n\t\tshort shortValue() default 9876;\n\t\tshort[] shorts() default {9876};\n\n\t\tlong longValue() default 42L;\n\t\tlong[] longs() default {42L};\n\n\t\tfloat floatValue() default 3.14F;\n\t\tfloat[] floats() default {3.14F};\n\n\t\tdouble doubleValue() default 99.999D;\n\t\tdouble[] doubles() default {99.999D};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@RequestMapping(method = RequestMethod.GET, name = \"\")\n\t@interface GetMapping {\n\n\t\t@AliasFor(annotation = RequestMapping.class)\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = RequestMapping.class)\n\t\tString path() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@RequestMapping(method = RequestMethod.POST, name = \"\")\n\t@interface PostMapping {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = RequestMapping.class)\n\t\tString path() default \"\";\n\t}\n\n\t@Component(\"webController\")\n\tstatic class WebController {\n\n\t\t@RequestMapping(value = \"/test\", name = \"foo\")\n\t\tpublic void handleMappedWithValueAttribute() {\n\t\t}\n\n\t\t@RequestMapping(path = \"/test\", name = \"bar\", method = { RequestMethod.GET,\n\t\t\tRequestMethod.POST })\n\t\tpublic void handleMappedWithPathAttribute() {\n\t\t}\n\n\t\t@GetMapping(\"/test\")\n\t\tpublic void getMappedWithValueAttribute() {\n\t\t}\n\n\t\t@GetMapping(path = \"/test\")\n\t\tpublic void getMappedWithPathAttribute() {\n\t\t}\n\n\t\t@PostMapping(path = \"/test\")\n\t\tpublic void postMappedWithPathAttribute() {\n\t\t}\n\n\t\t@RequestMapping(value = \"/test\", path = \"/test\", name = \"bar\", method = {\n\t\t\tRequestMethod.GET, RequestMethod.POST })\n\t\tpublic void handleMappedWithSamePathAndValueAttributes() {\n\t\t}\n\n\t\t@RequestMapping(value = \"/enigma\", path = \"/test\", name = \"baz\")\n\t\tpublic void handleMappedWithDifferentPathAndValueAttributes() {\n\t\t}\n\t}\n\n\t/**\n\t * Mimics jakarta.persistence.Id\n\t */\n\t@Retention(RUNTIME)\n\t@interface Id {\n\t}\n\n\t/**\n\t * Mimics jakarta.persistence.GeneratedValue\n\t */\n\t@Retention(RUNTIME)\n\t@interface GeneratedValue {\n\t\tString strategy();\n\t}\n\n\t@Id\n\t@GeneratedValue(strategy = \"AUTO\")\n\tprivate Long getId() {\n\t\treturn 42L;\n\t}\n\n\t/**\n\t * Mimics org.springframework.security.config.annotation.authentication.configuration.EnableGlobalAuthentication\n\t */\n\t@Retention(RUNTIME)\n\t@interface EnableGlobalAuthentication {\n\t}\n\n\t/**\n\t * Mimics org.springframework.security.config.annotation.web.configuration.EnableWebSecurity\n\t */\n\t@Retention(RUNTIME)\n\t@EnableGlobalAuthentication\n\t@interface EnableWebSecurity {\n\t}\n\n\t@EnableWebSecurity\n\tstatic class SecurityConfig {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ ElementType.FIELD, ElementType.ANNOTATION_TYPE })\n\t@interface RootAnnotation {\n\t\tString value() default \"\";\n\t\tboolean flag() default false;\n\t}\n\n\t@RootAnnotation\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ ElementType.FIELD, ElementType.ANNOTATION_TYPE })\n\t@interface ComposedRootAnnotation {\n\n\t\t@AliasFor(annotation = RootAnnotation.class, attribute = \"flag\")\n\t\tboolean enabled() default true;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.FIELD)\n\t@ComposedRootAnnotation\n\t@interface DoublyComposedRootAnnotation {\n\t}\n\n\tclass DomainType {\n\n\t\t@RootAnnotation\n\t\tObject directlyAnnotated;\n\n\t\t@ComposedRootAnnotation\n\t\tObject metaAnnotated;\n\n\t\t@DoublyComposedRootAnnotation\n\t\tObject metaMetaAnnotated;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestConfiguration {\n\n\t\t@AliasFor(\"location\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString location() default \"\";\n\n\t\tClass<?> configClass() default Object.class;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Hierarchy {\n\n\t\tTestConfiguration[] value();\n\t}\n\n\t@Hierarchy({ @TestConfiguration(\"A\"), @TestConfiguration(location = \"B\") })\n\tstatic class HierarchyClass {\n\t}\n\n\t@TestConfiguration(\"simple.xml\")\n\tstatic class TestConfigurationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface CharsContainer {\n\n\t\t@AliasFor(attribute = \"chars\")\n\t\tchar[] value() default {};\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tchar[] chars() default {};\n\t}\n\n\t@CharsContainer(chars = { 'x', 'y', 'z' })\n\tstatic class GroupOfCharsClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMissingAttributeDeclaration {\n\n\t\t@AliasFor\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForWithMissingAttributeDeclaration\n\tstatic class AliasForWithMissingAttributeDeclarationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithDuplicateAttributeDeclaration {\n\n\t\t@AliasFor(value = \"bar\", attribute = \"baz\")\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForWithDuplicateAttributeDeclaration\n\tstatic class AliasForWithDuplicateAttributeDeclarationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForNonexistentAttribute {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForNonexistentAttribute\n\tstatic class AliasForNonexistentAttributeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithoutMirroredAliasFor {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"\";\n\n\t\tString bar() default \"\";\n\t}\n\n\t@AliasForWithoutMirroredAliasFor\n\tstatic class AliasForWithoutMirroredAliasForClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMirroredAliasForWrongAttribute {\n\n\t\t@AliasFor(attribute = \"bar\")\n\t\tString[] foo() default \"\";\n\n\t\t@AliasFor(attribute = \"quux\")\n\t\tString[] bar() default \"\";\n\t}\n\n\t@AliasForWithMirroredAliasForWrongAttribute\n\tstatic class AliasForWithMirroredAliasForWrongAttributeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForAttributeOfDifferentType {\n\n\t\t@AliasFor(\"bar\")\n\t\tString[] foo() default \"\";\n\n\t\t@AliasFor(\"foo\")\n\t\tboolean bar() default true;\n\t}\n\n\t@AliasForAttributeOfDifferentType\n\tstatic class AliasForAttributeOfDifferentTypeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMissingDefaultValues {\n\n\t\t@AliasFor(attribute = \"bar\")\n\t\tString foo();\n\n\t\t@AliasFor(attribute = \"foo\")\n\t\tString bar();\n\t}\n\n\t@AliasForWithMissingDefaultValues(foo = \"foo\", bar = \"bar\")\n\tstatic class AliasForWithMissingDefaultValuesClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForAttributeWithDifferentDefaultValue {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"X\";\n\n\t\t@AliasFor(\"foo\")\n\t\tString bar() default \"Z\";\n\t}\n\n\t@AliasForAttributeWithDifferentDefaultValue\n\tstatic class AliasForAttributeWithDifferentDefaultValueClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedTestConfigurationNotMetaPresent {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlConfigFile();\n\t}\n\n\t@AliasedComposedTestConfigurationNotMetaPresent(xmlConfigFile = \"test.xml\")\n\tstatic class AliasedComposedTestConfigurationNotMetaPresentClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlConfigFile();\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface ImplicitAliasesTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString groovyScript() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location1() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location2() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location3() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"configClass\")\n\t\tClass<?> configClass() default Object.class;\n\n\t\tString nonAliasedAttribute() default \"\";\n\t}\n\n\t@ImplicitAliasesTestConfiguration(groovyScript = \"groovyScript\")\n\tstatic class GroovyImplicitAliasesSimpleTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(xmlFile = \"xmlFile\")\n\tstatic class XmlImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(\"value\")\n\tstatic class ValueImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(location1 = \"location1\")\n\tstatic class Location1ImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(location2 = \"location2\")\n\tstatic class Location2ImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(location3 = \"location3\")\n\tstatic class Location3ImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class)\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class)\n\t\tString location() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration.class, attribute = \"location\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration(\"value\")\n\tstatic class ValueImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration(location = \"location\")\n\tstatic class LocationsImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration(xmlFile = \"xmlFile\")\n\tstatic class XmlFilesImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithMissingDefaultValuesTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location1();\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location2();\n\t}\n\n\t@ImplicitAliasesWithMissingDefaultValuesTestConfiguration(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithMissingDefaultValuesTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithDifferentDefaultValuesTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location1() default \"foo\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location2() default \"bar\";\n\t}\n\n\t@ImplicitAliasesWithDifferentDefaultValuesTestConfiguration(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithDifferentDefaultValuesTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithDuplicateValuesTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location1() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location2() default \"\";\n\t}\n\n\t@ImplicitAliasesWithDuplicateValuesTestConfiguration(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithDuplicateValuesTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesForAliasPairTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, value = \"value\")\n\t\tString groovyScript() default \"\";\n\t}\n\n\t@ImplicitAliasesForAliasPairTestConfiguration(xmlFile = \"test.xml\")\n\tstatic class ImplicitAliasesForAliasPairTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesTestConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesTestConfiguration.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesTestConfiguration.class, attribute = \"groovyScript\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@TransitiveImplicitAliasesTestConfiguration(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesForAliasPairTestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesForAliasPairTestConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesForAliasPairTestConfiguration.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesForAliasPairTestConfiguration.class, attribute = \"groovyScript\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@TransitiveImplicitAliasesForAliasPairTestConfiguration(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesForAliasPairTestConfigurationClass {\n\t}\n\n\t@ComponentScan(excludeFilters = { @Filter(pattern = \"*Foo\"),\n\t\t@Filter(pattern = \"*Bar\") })\n\tstatic class ComponentScanClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScanSingleFilter {\n\n\t\tFilter value();\n\t}\n\n\t@ComponentScanSingleFilter(@Filter(pattern = \"*Foo\"))\n\tstatic class ComponentScanSingleFilterClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnotationWithDefaults {\n\n\t\tString text() default \"enigma\";\n\n\t\tboolean predicate() default true;\n\n\t\tchar[] characters() default { 'a', 'b', 'c' };\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnotationWithoutDefaults {\n\n\t\tString text();\n\t}\n\n\t@TestConfiguration(value = \"foo\", location = \"bar\")\n\tinterface TestConfigurationMismatch {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface DefaultOverrideRoot {\n\n\t\tString text() default \"root\";\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideRoot\n\t@interface DefaultOverrideMeta {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideMeta\n\t@interface DefaultOverrideMetaMeta {\n\n\t\tString text() default \"metameta\";\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideMetaMeta\n\t@interface DefaultOverrideMetaMetaMeta {\n\n\t}\n\n\t@DefaultOverrideMetaMetaMeta\n\tstatic class DefaultOverrideClass {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideRoot\n\t@interface DefaultOverrideImplicitAlias {\n\n\t\t@AliasFor(annotation=DefaultOverrideRoot.class, attribute=\"text\")\n\t\tString text1() default \"alias\";\n\n\t\t@AliasFor(annotation=DefaultOverrideRoot.class, attribute=\"text\")\n\t\tString text2() default \"alias\";\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideImplicitAlias(text1=\"alias-meta-1\")\n\t@interface DefaultOverrideAliasImplicitMeta1 {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideImplicitAlias(text2=\"alias-meta-2\")\n\t@interface DefaultOverrideImplicitAliasMeta2 {\n\n\t}\n\n\t@DefaultOverrideAliasImplicitMeta1\n\tstatic class DefaultOverrideImplicitAliasMetaClass1 {\n\n\t}\n\n\t@DefaultOverrideImplicitAliasMeta2\n\tstatic class DefaultOverrideImplicitAliasMetaClass2 {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface DefaultOverrideExplicitAliasRoot {\n\n\t\t@AliasFor(\"value\")\n\t\tString text() default \"\";\n\n\t\t@AliasFor(\"text\")\n\t\tString value() default \"\";\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideExplicitAliasRoot(\"meta\")\n\t@interface DefaultOverrideExplicitAliasRootMeta {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideExplicitAliasRootMeta\n\t@interface DefaultOverrideExplicitAliasRootMetaMeta {\n\n\t}\n\n\t@DefaultOverrideExplicitAliasRootMetaMeta\n\tstatic class DefaultOverrideExplicitAliasRootMetaMetaClass {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ValueAttribute {\n\n\t\tString[] value();\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueAttribute(\"FromValueAttributeMeta\")\n\t@interface ValueAttributeMeta {\n\n\t\tString[] value() default {};\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueAttributeMeta(\"FromValueAttributeMetaMeta\")\n\t@interface ValueAttributeMetaMeta {\n\n\t}\n\n\t@ValueAttributeMetaMeta\n\tstatic class ValueAttributeMetaMetaClass {\n\n\t}\n\t// @formatter:on\n\n\tstatic void assertSynthesized(Annotation annotation) {\n\t\tassertThat(AnnotationUtils.isSynthesizedAnnotation(annotation)).as(\"synthesized annotation\").isTrue();\n\t}\n\n\tstatic void assertNotSynthesized(Annotation annotation) {\n\t\tassertThat(AnnotationUtils.isSynthesizedAnnotation(annotation)).as(\"synthesized annotation\").isFalse();\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass2",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass2",
    "headType": "class",
    "relation": "use",
    "tail": "@HalfConventionBasedAndHalfAliasedComposedContextConfiguration",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass2",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.stream.Stream;\n\nimport jakarta.annotation.Resource;\nimport org.jspecify.annotations.Nullable;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.AnnotationsScannerTests.Hello2Impl;\nimport org.springframework.core.annotation.AnnotationsScannerTests.TestAnnotation1;\nimport org.springframework.core.annotation.MergedAnnotation.Adapt;\nimport org.springframework.core.annotation.MergedAnnotations.Search;\nimport org.springframework.core.annotation.MergedAnnotations.SearchStrategy;\nimport org.springframework.core.annotation.subpackage.NonPublicAnnotatedClass;\nimport org.springframework.core.testfixture.ide.IdeUtils;\nimport org.springframework.core.testfixture.stereotype.Component;\nimport org.springframework.core.testfixture.stereotype.Indexed;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.MultiValueMap;\nimport org.springframework.util.ReflectionUtils;\n\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.assertj.core.api.Assertions.assertThatIllegalStateException;\nimport static org.assertj.core.api.Assertions.entry;\n\n/**\n * Tests for {@link MergedAnnotations} and {@link MergedAnnotation}. These tests\n * cover common usage scenarios and were mainly ported from the original\n * {@code AnnotationUtils} and {@code AnnotatedElementUtils} tests.\n *\n * @author Phillip Webb\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Chris Beams\n * @author Oleg Zhurakousky\n * @author Rossen Stoyanchev\n * @see MergedAnnotationsRepeatableAnnotationTests\n * @see MergedAnnotationClassLoaderTests\n */\nclass MergedAnnotationsTests {\n\n\t/**\n\t * Subset (and duplication) of other tests in {@link MergedAnnotationsTests}\n\t * that verify behavior of the fluent {@link Search} API.\n\t * @since 6.0\n\t */\n\t@Nested\n\tclass FluentSearchApiTests {\n\n\t\t@Test\n\t\tvoid preconditions() {\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> MergedAnnotations.search(null))\n\t\t\t\t\t.withMessage(\"SearchStrategy must not be null\");\n\n\t\t\tSearch search = MergedAnnotations.search(SearchStrategy.SUPERCLASS);\n\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> search.withEnclosingClasses(null))\n\t\t\t\t\t.withMessage(\"Predicate must not be null\");\n\t\t\tassertThatIllegalStateException()\n\t\t\t\t\t.isThrownBy(() -> search.withEnclosingClasses(Search.always))\n\t\t\t\t\t.withMessage(\"A custom 'searchEnclosingClass' predicate can only be combined with SearchStrategy.TYPE_HIERARCHY\");\n\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> search.withAnnotationFilter(null))\n\t\t\t\t\t.withMessage(\"AnnotationFilter must not be null\");\n\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> search.withRepeatableContainers(null))\n\t\t\t\t\t.withMessage(\"RepeatableContainers must not be null\");\n\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> search.from(null))\n\t\t\t\t\t.withMessage(\"AnnotatedElement must not be null\");\n\t\t}\n\n\t\t@Test\n\t\tvoid searchFromClassWithDefaultAnnotationFilterAndDefaultRepeatableContainers() {\n\t\t\tStream<Class<?>> classes = MergedAnnotations.search(SearchStrategy.DIRECT)\n\t\t\t\t\t.from(TransactionalComponent.class)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Transactional.class, Component.class, Indexed.class);\n\t\t}\n\n\t\t@Test\n\t\tvoid searchFromClassWithCustomAnnotationFilter() {\n\t\t\tStream<Class<?>> classes = MergedAnnotations.search(SearchStrategy.DIRECT)\n\t\t\t\t\t.withAnnotationFilter(annotationName -> annotationName.endsWith(\"Indexed\"))\n\t\t\t\t\t.from(TransactionalComponent.class)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Transactional.class, Component.class);\n\t\t}\n\n\t\t@Test\n\t\tvoid searchFromClassWithCustomRepeatableContainers() {\n\t\t\tassertThat(MergedAnnotations.from(HierarchyClass.class).stream(TestConfiguration.class)).isEmpty();\n\t\t\tRepeatableContainers containers = RepeatableContainers.of(TestConfiguration.class, Hierarchy.class);\n\n\t\t\tMergedAnnotations annotations = MergedAnnotations.search(SearchStrategy.DIRECT)\n\t\t\t\t\t.withRepeatableContainers(containers)\n\t\t\t\t\t.from(HierarchyClass.class);\n\t\t\tassertThat(annotations.stream(TestConfiguration.class))\n\t\t\t\t\t.map(annotation -> annotation.getString(\"location\"))\n\t\t\t\t\t.containsExactly(\"A\", \"B\");\n\t\t\tassertThat(annotations.stream(TestConfiguration.class))\n\t\t\t\t\t.map(annotation -> annotation.getString(\"value\"))\n\t\t\t\t\t.containsExactly(\"A\", \"B\");\n\t\t}\n\n\t\t/**\n\t\t * @since 6.0\n\t\t */\n\t\t@Test\n\t\tvoid searchFromNonAnnotatedInnerClassWithAnnotatedEnclosingClassWithEnclosingClassPredicates() {\n\t\t\tClass<?> testCase = AnnotatedClass.NonAnnotatedInnerClass.class;\n\t\t\tSearch search = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY);\n\n\t\t\tassertThat(search.from(testCase).stream()).isEmpty();\n\t\t\tassertThat(search.withEnclosingClasses(Search.never).from(testCase).stream()).isEmpty();\n\t\t\tassertThat(search.withEnclosingClasses(ClassUtils::isStaticClass).from(testCase).stream()).isEmpty();\n\n\t\t\tStream<Class<?>> classes = search.withEnclosingClasses(ClassUtils::isInnerClass)\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class, Indexed.class);\n\n\t\t\tclasses = search.withEnclosingClasses(Search.always)\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class, Indexed.class);\n\n\t\t\tclasses = search.withEnclosingClasses(ClassUtils::isInnerClass)\n\t\t\t\t\t.withRepeatableContainers(RepeatableContainers.none())\n\t\t\t\t\t.withAnnotationFilter(annotationName -> annotationName.endsWith(\"Indexed\"))\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class);\n\t\t}\n\n\t\t/**\n\t\t * @since 6.0\n\t\t */\n\t\t@Test\n\t\tvoid searchFromNonAnnotatedStaticNestedClassWithAnnotatedEnclosingClassWithEnclosingClassPredicates() {\n\t\t\tClass<?> testCase = AnnotatedClass.NonAnnotatedStaticNestedClass.class;\n\t\t\tSearch search = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY);\n\n\t\t\tassertThat(search.from(testCase).stream()).isEmpty();\n\t\t\tassertThat(search.withEnclosingClasses(Search.never).from(testCase).stream()).isEmpty();\n\t\t\tassertThat(search.withEnclosingClasses(ClassUtils::isInnerClass).from(testCase).stream()).isEmpty();\n\n\t\t\tStream<Class<?>> classes = search.withEnclosingClasses(ClassUtils::isStaticClass)\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class, Indexed.class);\n\n\t\t\tclasses = search.withEnclosingClasses(Search.always)\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class, Indexed.class);\n\t\t}\n\t}\n\n\n\t@Nested\n\tclass ConventionBasedAnnotationAttributeOverrideTests {\n\n\t\t@Test\n\t\tvoid getWithInheritedAnnotationsAttributesWithConventionBasedComposedAnnotation() {\n\t\t\tMergedAnnotation<?> annotation =\n\t\t\t\t\tMergedAnnotations.from(ConventionBasedComposedContextConfigurationClass.class,\n\t\t\t\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\t\tassertThat(annotation.isPresent()).isTrue();\n\t\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"explicitDeclaration\");\n\t\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"explicitDeclaration\");\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithInheritedAnnotationsFromHalfConventionBasedAndHalfAliasedComposedAnnotation1() {\n\t\t\t// SPR-13554: convention mapping mixed with AliasFor annotations\n\t\t\t// xmlConfigFiles can be used because it has an AliasFor annotation\n\t\t\tMergedAnnotation<?> annotation =\n\t\t\t\t\tMergedAnnotations.from(HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass1.class,\n\t\t\t\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"explicitDeclaration\");\n\t\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"explicitDeclaration\");\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithInheritedAnnotationsFromHalfConventionBasedAndHalfAliasedComposedAnnotation2() {\n\t\t\t// SPR-13554: convention mapping mixed with AliasFor annotations\n\t\t\t// locations doesn't apply because it has no AliasFor annotation\n\t\t\tMergedAnnotation<?> annotation =\n\t\t\t\t\tMergedAnnotations.from(HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass2.class,\n\t\t\t\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\t\tassertThat(annotation.getStringArray(\"locations\")).isEmpty();\n\t\t\tassertThat(annotation.getStringArray(\"value\")).isEmpty();\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithInheritedAnnotationsFromInvalidConventionBasedComposedAnnotation() {\n\t\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(InvalidConventionBasedComposedContextConfigurationClass.class,\n\t\t\t\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class));\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithTypeHierarchyWithSingleElementOverridingAnArrayViaConvention() {\n\t\t\ttestGetWithTypeHierarchy(ConventionBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithTypeHierarchyWithLocalAliasesThatConflictWithAttributesInMetaAnnotationByConvention() {\n\t\t\tMergedAnnotation<?> annotation =\n\t\t\t\t\tMergedAnnotations.from(SpringApplicationConfigurationClass.class, SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t\t\t\t.get(ContextConfiguration.class);\n\t\t\tassertThat(annotation.getStringArray(\"locations\")).isEmpty();\n\t\t\tassertThat(annotation.getStringArray(\"value\")).isEmpty();\n\t\t\tassertThat(annotation.getClassArray(\"classes\")).containsExactly(Number.class);\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithTypeHierarchyOnMethodWithSingleElementOverridingAnArrayViaConvention() throws Exception {\n\t\t\ttestGetWithTypeHierarchyWebMapping(WebController.class.getMethod(\"postMappedWithPathAttribute\"));\n\t\t}\n\t}\n\n\n\t@Test\n\tvoid fromPreconditions() {\n\t\tSearchStrategy strategy = SearchStrategy.DIRECT;\n\t\tRepeatableContainers containers = RepeatableContainers.standardRepeatables();\n\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(getClass(), strategy, null, AnnotationFilter.PLAIN))\n\t\t\t\t.withMessage(\"RepeatableContainers must not be null\");\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(getClass(), strategy, containers, null))\n\t\t\t\t.withMessage(\"AnnotationFilter must not be null\");\n\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(getClass(), new Annotation[0], null, AnnotationFilter.PLAIN))\n\t\t\t\t.withMessage(\"RepeatableContainers must not be null\");\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(getClass(), new Annotation[0], containers, null))\n\t\t\t\t.withMessage(\"AnnotationFilter must not be null\");\n\t}\n\n\t@Test\n\tvoid streamWhenFromNonAnnotatedClass() {\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class).stream(TransactionalComponent.class)).isEmpty();\n\t}\n\n\t@Test\n\tvoid streamWhenFromClassWithMetaDepth1() {\n\t\tStream<Class<?>> classes = MergedAnnotations.from(TransactionalComponent.class)\n\t\t\t\t.stream().map(MergedAnnotation::getType);\n\t\tassertThat(classes).containsExactly(Transactional.class, Component.class, Indexed.class);\n\t}\n\n\t@Test\n\tvoid streamWhenFromClassWithMetaDepth2() {\n\t\tStream<Class<?>> classes = MergedAnnotations.from(ComposedTransactionalComponent.class)\n\t\t\t\t.stream().map(MergedAnnotation::getType);\n\t\tassertThat(classes).containsExactly(TransactionalComponent.class,\n\t\t\t\tTransactional.class, Component.class, Indexed.class);\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromNonAnnotatedClass() {\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class).isPresent(Transactional.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromAnnotationClassWithMetaDepth0() {\n\t\tassertThat(MergedAnnotations.from(TransactionalComponent.class).isPresent(TransactionalComponent.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromAnnotationClassWithMetaDepth1() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(TransactionalComponent.class);\n\t\tassertThat(annotations.isPresent(Transactional.class)).isTrue();\n\t\tassertThat(annotations.isPresent(Component.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromAnnotationClassWithMetaDepth2() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponent.class);\n\t\tassertThat(annotations.isPresent(Transactional.class)).isTrue();\n\t\tassertThat(annotations.isPresent(Component.class)).isTrue();\n\t\tassertThat(annotations.isPresent(ComposedTransactionalComponent.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromClassWithMetaDepth0() {\n\t\tassertThat(MergedAnnotations.from(TransactionalComponentClass.class).isPresent(TransactionalComponent.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromSubclassWithMetaDepth0() {\n\t\tassertThat(MergedAnnotations.from(SubTransactionalComponentClass.class).isPresent(TransactionalComponent.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromClassWithMetaDepth1() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(TransactionalComponentClass.class);\n\t\tassertThat(annotations.isPresent(Transactional.class)).isTrue();\n\t\tassertThat(annotations.isPresent(Component.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromClassWithMetaDepth2() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\n\t\tassertThat(annotations.isPresent(Transactional.class)).isTrue();\n\t\tassertThat(annotations.isPresent(Component.class)).isTrue();\n\t\tassertThat(annotations.isPresent(ComposedTransactionalComponent.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid getParent() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\n\t\tassertThat(annotations.get(TransactionalComponent.class).getMetaSource().getType())\n\t\t\t\t.isEqualTo(ComposedTransactionalComponent.class);\n\t}\n\n\t@Test\n\tvoid getRootWhenNotDirect() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\n\t\tMergedAnnotation<?> annotation = annotations.get(TransactionalComponent.class);\n\t\tassertThat(annotation.getDistance()).isGreaterThan(0);\n\t\tassertThat(annotation.getRoot().getType()).isEqualTo(ComposedTransactionalComponent.class);\n\t}\n\n\t@Test\n\tvoid getRootWhenDirect() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\n\t\tMergedAnnotation<?> annotation = annotations.get(ComposedTransactionalComponent.class);\n\t\tassertThat(annotation.getDistance()).isEqualTo(0);\n\t\tassertThat(annotation.getRoot()).isSameAs(annotation);\n\t}\n\n\t@Test\n\tvoid getMetaTypes() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(ComposedTransactionalComponentClass.class)\n\t\t\t\t.get(TransactionalComponent.class);\n\t\tassertThat(annotation.getMetaTypes()).containsExactly(\n\t\t\t\tComposedTransactionalComponent.class, TransactionalComponent.class);\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFromNonAnnotatedClass() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(NonAnnotatedClass.class)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).isEmpty();\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFromClassWithLocalAnnotation() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(TxConfig.class)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"value\", List.of(\"TxConfig\")));\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFromClassWithLocalComposedAnnotationAndInheritedAnnotation() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"qualifier\", List.of(\"composed2\", \"transactionManager\")));\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"qualifier\", List.of(\"transactionManager\")));\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedComposedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"qualifier\", List.of(\"composed1\")));\n\t}\n\n\t/**\n\t * If the \"value\" entry contains both \"DerivedTxConfig\" AND \"TxConfig\", then\n\t * the algorithm is accidentally picking up shadowed annotations of the same\n\t * type within the class hierarchy. Such undesirable behavior would cause\n\t * the logic in\n\t * {@code org.springframework.context.annotation.ProfileCondition} to fail.\n\t */\n\t@Test\n\tvoid collectMultiValueMapFromClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tDerivedTxConfig.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"value\", List.of(\"DerivedTxConfig\")));\n\t}\n\n\t/**\n\t * Note: this functionality is required by\n\t * {@code org.springframework.context.annotation.ProfileCondition}.\n\t */\n\t@Test\n\tvoid collectMultiValueMapFromClassWithMultipleComposedAnnotations() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tTxFromMultipleComposedAnnotations.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"value\", List.of(\"TxInheritedComposed\", \"TxComposed\")));\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromClassWithLocalAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tTxConfig.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"TxConfig\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tDerivedTxConfig.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"DerivedTxConfig\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaCycleAnnotatedClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isFalse();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFavorsLocalComposedAnnotationOverInheritedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getBoolean(\"readOnly\")).isTrue();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getBoolean(\"readOnly\")).isFalse();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedComposedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getBoolean(\"readOnly\")).isFalse();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromInterfaceImplementedBySuperclass() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tConcreteClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isFalse();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tInheritedAnnotationInterface.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationInterface.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t}\n\n\n\t@Test\n\tvoid withInheritedAnnotationsFromAliasedComposedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tAliasedComposedContextConfigurationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"test.xml\");\n\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid withInheritedAnnotationsFromAliasedValueComposedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tAliasedValueComposedContextConfigurationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"test.xml\");\n\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromImplicitAliasesInMetaAnnotationOnComposedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tComposedImplicitAliasesContextConfigurationClass.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.get(ImplicitAliasesContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"groovyScripts\")).containsExactly(\"A.xml\", \"B.xml\");\n\t\tassertThat(annotation.getStringArray(\"xmlFiles\")).containsExactly(\"A.xml\", \"B.xml\");\n\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"A.xml\", \"B.xml\");\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"A.xml\", \"B.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromAliasedValueComposedAnnotation() {\n\t\ttestGetWithInherited(AliasedValueComposedContextConfigurationClass.class, \"test.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromImplicitAliasesForSameAttributeInComposedAnnotation() {\n\t\ttestGetWithInherited(ImplicitAliasesContextConfigurationClass1.class, \"foo.xml\");\n\t\ttestGetWithInherited(ImplicitAliasesContextConfigurationClass2.class, \"bar.xml\");\n\t\ttestGetWithInherited(ImplicitAliasesContextConfigurationClass3.class, \"baz.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromTransitiveImplicitAliases() {\n\t\ttestGetWithInherited(TransitiveImplicitAliasesContextConfigurationClass.class, \"test.groovy\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\ttestGetWithInherited(\n\t\t\t\tSingleLocationTransitiveImplicitAliasesContextConfigurationClass.class, \"test.groovy\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSkippedLevel() {\n\t\ttestGetWithInherited(\n\t\t\t\tTransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass.class, \"test.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSkippedLevelWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\ttestGetWithInherited(\n\t\t\t\tSingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass.class, \"test.xml\");\n\t}\n\n\tprivate void testGetWithInherited(Class<?> element, String... expected) {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(element, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.get(ContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"locations\")).isEqualTo(expected);\n\t\tassertThat(annotation.getStringArray(\"value\")).isEqualTo(expected);\n\t\tassertThat(annotation.getClassArray(\"classes\")).isEmpty();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromShadowedAliasComposedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tShadowedAliasComposedContextConfigurationClass.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.get(ContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"test.xml\");\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromSubInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromSubSubInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromSubNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromSubSubNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyInheritedFromInterfaceMethod() throws Exception {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleFromInterface\");\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test  // gh-31803\n\tvoid streamWithTypeHierarchyInheritedFromSuperInterfaceMethod() throws Exception {\n\t\tMethod method = Hello2Impl.class.getMethod(\"method\");\n\t\tlong count = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.from(method).stream(TestAnnotation1.class).count();\n\t\tassertThat(count).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyInheritedFromAbstractMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handle\");\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyInheritedFromBridgedMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleParameterized\", String.class);\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromBridgeMethod() {\n\t\tList<Method> methods = new ArrayList<>();\n\t\tReflectionUtils.doWithLocalMethods(StringGenericParameter.class, method -> {\n\t\t\tif (\"getFor\".equals(method.getName())) {\n\t\t\t\tmethods.add(method);\n\t\t\t}\n\t\t});\n\t\tMethod bridgeMethod = methods.get(0).getReturnType().equals(Object.class) ?\n\t\t\t\tmethods.get(0) : methods.get(1);\n\t\tMethod bridgedMethod = methods.get(0).getReturnType().equals(Object.class) ?\n\t\t\t\tmethods.get(1) : methods.get(0);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(bridgeMethod,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromClassWithMetaAndLocalTxConfig() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaAndLocalTxConfigClass.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getString(\"qualifier\")).isEqualTo(\"localTxMgr\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromClassWithAttributeAliasesInTargetAnnotation() {\n\t\tMergedAnnotation<AliasedTransactional> mergedAnnotation = MergedAnnotations.from(\n\t\t\t\tAliasedTransactionalComponentClass.class, SearchStrategy.TYPE_HIERARCHY).get(AliasedTransactional.class);\n\t\tAliasedTransactional synthesizedAnnotation = mergedAnnotation.synthesize();\n\t\tString qualifier = \"aliasForQualifier\";\n\t\tassertThat(mergedAnnotation.getString(\"value\")).isEqualTo(qualifier);\n\t\tassertThat(mergedAnnotation.getString(\"qualifier\")).isEqualTo(qualifier);\n\t\tassertThat(synthesizedAnnotation.value()).isEqualTo(qualifier);\n\t\tassertThat(synthesizedAnnotation.qualifier()).isEqualTo(qualifier);\n\t}\n\n\t@Test // gh-23767\n\tvoid getWithTypeHierarchyFromClassWithComposedMetaTransactionalAnnotation() {\n\t\tMergedAnnotation<AliasedTransactional> mergedAnnotation = MergedAnnotations.from(\n\t\t\t\tComposedTransactionalClass.class, SearchStrategy.TYPE_HIERARCHY).get(AliasedTransactional.class);\n\t\tassertThat(mergedAnnotation.getString(\"value\")).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(mergedAnnotation.getString(\"qualifier\")).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t@Test // gh-23767\n\tvoid getWithTypeHierarchyFromClassWithMetaMetaAliasedTransactional() {\n\t\tMergedAnnotation<AliasedTransactional> mergedAnnotation = MergedAnnotations.from(\n\t\t\t\tMetaMetaAliasedTransactionalClass.class, SearchStrategy.TYPE_HIERARCHY).get(AliasedTransactional.class);\n\t\tassertThat(mergedAnnotation.getString(\"value\")).isEqualTo(\"meta\");\n\t\tassertThat(mergedAnnotation.getString(\"qualifier\")).isEqualTo(\"meta\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromClassWithAttributeAliasInComposedAnnotationAndNestedAnnotationsInTargetAnnotation() {\n\t\tMergedAnnotation<?> annotation = testGetWithTypeHierarchy(\n\t\t\t\tTestComponentScanClass.class, \"com.example.app.test\");\n\t\tMergedAnnotation<Filter>[] excludeFilters = annotation.getAnnotationArray(\n\t\t\t\t\"excludeFilters\", Filter.class);\n\t\tassertThat(Arrays.stream(excludeFilters).map(\n\t\t\t\tfilter -> filter.getString(\"pattern\"))).containsExactly(\"*Test\", \"*Tests\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromClassWithBothAttributesOfAnAliasPairDeclared() {\n\t\ttestGetWithTypeHierarchy(ComponentScanWithBasePackagesAndValueAliasClass.class, \"com.example.app.test\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\ttestGetWithTypeHierarchy(AliasForBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\n\t}\n\n\tprivate MergedAnnotation<?> testGetWithTypeHierarchy(Class<?> element, String... expected) {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(element,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(ComponentScan.class);\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(expected);\n\t\tassertThat(annotation.getStringArray(\"basePackages\")).containsExactly(expected);\n\t\treturn annotation;\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyWhenMultipleMetaAnnotationsHaveClashingAttributeNames() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tAliasedComposedContextConfigurationAndTestPropertySourceClass.class, SearchStrategy.TYPE_HIERARCHY);\n\t\tMergedAnnotation<?> contextConfig = annotations.get(ContextConfiguration.class);\n\t\tassertThat(contextConfig.getStringArray(\"locations\")).containsExactly(\"test.xml\");\n\t\tassertThat(contextConfig.getStringArray(\"value\")).containsExactly(\"test.xml\");\n\t\tMergedAnnotation<?> testPropSource = annotations.get(TestPropertySource.class);\n\t\tassertThat(testPropSource.getStringArray(\"locations\")).containsExactly(\"test.properties\");\n\t\tassertThat(testPropSource.getStringArray(\"value\")).containsExactly(\"test.properties\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyOnMethodWithSingleElementOverridingAnArrayViaAliasFor() throws Exception {\n\t\ttestGetWithTypeHierarchyWebMapping(WebController.class.getMethod(\"getMappedWithValueAttribute\"));\n\t\ttestGetWithTypeHierarchyWebMapping(WebController.class.getMethod(\"getMappedWithPathAttribute\"));\n\t}\n\n\tprivate void testGetWithTypeHierarchyWebMapping(AnnotatedElement element) {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.get(RequestMapping.class);\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"/test\");\n\t\tassertThat(annotation.getStringArray(\"path\")).containsExactly(\"/test\");\n\t}\n\n\t@Test\n\tvoid getDirectWithJavaxAnnotationType() {\n\t\tassertThat(MergedAnnotations.from(ResourceHolder.class).get(Resource.class)\n\t\t\t\t.getString(\"name\")).isEqualTo(\"x\");\n\t}\n\n\t@Test\n\tvoid streamInheritedFromClassWithInterface() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class)).isEmpty();\n\t}\n\n\t@Test\n\tvoid streamTypeHierarchyFromClassWithInterface() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.stream(Transactional.class)).hasSize(1);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithMethodAnnotationOnLeaf() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"annotatedOnLeaf\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNotNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class)\n\t\t\t\t.getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithAnnotationOnMethodInInterface() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"fromInterfaceImplementedByRoot\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class)\n\t\t\t\t.getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithMetaAnnotationOnLeaf() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"metaAnnotatedOnLeaf\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class)\n\t\t\t\t.getDistance()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithMetaMetaAnnotationOnLeaf() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"metaMetaAnnotatedOnLeaf\");\n\t\tassertThat(method.getAnnotation(Component.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Component.class).getDistance()).isEqualTo(2);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tComponent.class).getDistance()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getWithAnnotationOnRoot() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"annotatedOnRoot\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNotNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithMetaAnnotationOnRoot() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"metaAnnotatedOnRoot\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithOnRootButOverridden() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"overrideWithoutNewAnnotation\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithNotAnnotated() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"notAnnotated\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(-1);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithBridgeMethod() throws Exception {\n\t\tMethod method = TransactionalStringGeneric.class.getMethod(\"something\", Object.class);\n\t\tassertThat(method.isBridge()).isTrue();\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t\t// As of JDK 8, invoking getAnnotation() on a bridge method actually finds an\n\t\t// annotation on its 'bridged' method [1]; however, the Eclipse compiler does\n\t\t// not support this [2]. Thus, we effectively ignore the following\n\t\t// assertion if the test is currently executing within the Eclipse IDE.\n\t\t//\n\t\t// [1] https://bugs.openjdk.java.net/browse/JDK-6695379\n\t\t// [2] https://bugs.eclipse.org/bugs/show_bug.cgi?id=495396\n\t\t//\n\t\tif (!IdeUtils.runningInEclipse()) {\n\t\t\tassertThat(method.getAnnotation(Transactional.class)).isNotNull();\n\t\t}\n\t\tassertThat(MergedAnnotations.from(method).get(\n\t\t\t\tTransactional.class).getDistance()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tTransactional.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithBridgedMethod() throws Exception {\n\t\tMethod method = TransactionalStringGeneric.class.getMethod(\"something\", String.class);\n\t\tassertThat(method.isBridge()).isFalse();\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t\tassertThat(method.getAnnotation(Transactional.class)).isNotNull();\n\t\tassertThat(MergedAnnotations.from(method).get(\n\t\t\t\tTransactional.class).getDistance()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tTransactional.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test // SPR-16060\n\tvoid getFromMethodWithGenericInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test // SPR-17146\n\tvoid getFromMethodWithGenericSuperclass() throws Exception {\n\t\tMethod method = ExtendsBaseClassWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithInterfaceOnSuper() throws Exception {\n\t\tMethod method = SubOfImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWhenInterfaceWhenSuperDoesNotImplementMethod() throws Exception {\n\t\tMethod method = SubOfAbstractImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverAnnotationsOnInterfaces() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tClassWithLocalMetaAnnotationAndMetaAnnotatedInterface.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedAnnotation.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getBoolean(\"readOnly\")).isTrue();\n\t}\n\n\t@Test\n\tvoid getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedComposedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedMetaAnnotation.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid getDirectFromClassgetDirectFromClassMetaMetaAnnotatedClass() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaMetaAnnotatedClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithMetaMetaMetaAnnotatedClass() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaMetaMetaAnnotatedClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\t// TransactionalClass is NOT annotated or meta-annotated with @Component\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(TransactionalClass.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.isPresent()).isFalse();\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaCycleAnnotatedClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.isPresent()).isFalse();\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithSubInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithSubSubInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithSubNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithSubSubNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubNonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getSuperClassForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isNull();\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isNull();\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isEqualTo(\n\t\t\t\t\t\t\t\tInheritedAnnotationInterface.class);\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isNull();\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isEqualTo(\n\t\t\t\t\t\t\t\tInheritedAnnotationClass.class);\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isEqualTo(\n\t\t\t\t\t\t\t\tInheritedAnnotationClass.class);\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but we should still find it on classes.\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(Order.class).getSource()).isEqualTo(\n\t\t\t\t\t\tNonInheritedAnnotationInterface.class);\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(Order.class).getSource()).isNull();\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(Order.class).getSource()).isEqualTo(\n\t\t\t\t\t\tNonInheritedAnnotationClass.class);\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(Order.class).getSource()).isEqualTo(\n\t\t\t\t\t\tNonInheritedAnnotationClass.class);\n\t}\n\n\t@Test\n\tvoid getSuperClassSourceForTypesWithSingleCandidateType() {\n\t\t// no class-level annotation\n\t\tList<Class<? extends Annotation>> transactionalCandidateList = Collections.singletonList(Transactional.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonAnnotatedInterface.class,\n\t\t\t\ttransactionalCandidateList)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonAnnotatedClass.class,\n\t\t\t\ttransactionalCandidateList)).isNull();\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationInterface.class,\n\t\t\t\ttransactionalCandidateList)).isEqualTo(\n\t\t\t\t\t\tInheritedAnnotationInterface.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationInterface.class,\n\t\t\t\ttransactionalCandidateList)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationClass.class,\n\t\t\t\ttransactionalCandidateList)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationClass.class,\n\t\t\t\ttransactionalCandidateList)).isEqualTo(InheritedAnnotationClass.class);\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but should still find it on classes.\n\t\tList<Class<? extends Annotation>> orderCandidateList = Collections.singletonList(\n\t\t\t\tOrder.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationInterface.class,\n\t\t\t\torderCandidateList)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationInterface.class,\n\t\t\t\torderCandidateList)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationClass.class,\n\t\t\t\torderCandidateList)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationClass.class,\n\t\t\t\torderCandidateList)).isEqualTo(NonInheritedAnnotationClass.class);\n\t}\n\n\t@Test\n\tvoid getSuperClassSourceForTypesWithMultipleCandidateTypes() {\n\t\tList<Class<? extends Annotation>> candidates = List.of(Transactional.class, Order.class);\n\t\t// no class-level annotation\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonAnnotatedInterface.class,\n\t\t\t\tcandidates)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonAnnotatedClass.class,\n\t\t\t\tcandidates)).isNull();\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationInterface.class,\n\t\t\t\tcandidates)).isEqualTo(InheritedAnnotationInterface.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationInterface.class,\n\t\t\t\tcandidates)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationClass.class,\n\t\t\t\tcandidates)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationClass.class,\n\t\t\t\tcandidates)).isEqualTo(InheritedAnnotationClass.class);\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but findAnnotationDeclaringClassForTypes() should still find it on\n\t\t// classes.\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationInterface.class,\n\t\t\t\tcandidates)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationInterface.class,\n\t\t\t\tcandidates)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationClass.class,\n\t\t\t\tcandidates)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationClass.class,\n\t\t\t\tcandidates)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\t// class hierarchy mixed with @Transactional and @Order declarations\n\t\tassertThat(getSuperClassSourceWithTypeIn(TransactionalClass.class,\n\t\t\t\tcandidates)).isEqualTo(TransactionalClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(TransactionalAndOrderedClass.class,\n\t\t\t\tcandidates)).isEqualTo(TransactionalAndOrderedClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubTransactionalAndOrderedClass.class,\n\t\t\t\tcandidates)).isEqualTo(TransactionalAndOrderedClass.class);\n\t}\n\n\tprivate Object getSuperClassSourceWithTypeIn(Class<?> clazz, List<Class<? extends Annotation>> annotationTypes) {\n\t\treturn MergedAnnotations.from(clazz, SearchStrategy.SUPERCLASS).stream().filter(\n\t\t\t\tMergedAnnotationPredicates.typeIn(annotationTypes).and(\n\t\t\t\t\t\tMergedAnnotation::isDirectlyPresent)).map(\n\t\t\t\t\t\t\t\tMergedAnnotation::getSource).findFirst().orElse(null);\n\t}\n\n\t@Test\n\tvoid isDirectlyPresentForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedInterface.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedInterface.class).isDirectlyPresent(\n\t\t\t\tTransactional.class)).isFalse();\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class).isDirectlyPresent(\n\t\t\t\tTransactional.class)).isFalse();\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationInterface.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isTrue();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tInheritedAnnotationInterface.class).isDirectlyPresent(\n\t\t\t\t\t\tTransactional.class)).isTrue();\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tSubInheritedAnnotationInterface.class).isDirectlyPresent(\n\t\t\t\t\t\tTransactional.class)).isFalse();\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationClass.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isTrue();\n\t\tassertThat(\n\t\t\t\tMergedAnnotations.from(InheritedAnnotationClass.class).isDirectlyPresent(\n\t\t\t\t\t\tTransactional.class)).isTrue();\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tSubInheritedAnnotationClass.class).isDirectlyPresent(\n\t\t\t\t\t\tTransactional.class)).isFalse();\n\t\t// non-inherited class-level annotation; note: @Order is not inherited\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class).get(\n\t\t\t\tOrder.class).isDirectlyPresent()).isTrue();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationInterface.class).isDirectlyPresent(\n\t\t\t\t\t\tOrder.class)).isTrue();\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class).get(\n\t\t\t\tOrder.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tSubNonInheritedAnnotationInterface.class).isDirectlyPresent(\n\t\t\t\t\t\tOrder.class)).isFalse();\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class).get(\n\t\t\t\tOrder.class).isDirectlyPresent()).isTrue();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationClass.class).isDirectlyPresent(\n\t\t\t\t\t\tOrder.class)).isTrue();\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class).get(\n\t\t\t\tOrder.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tSubNonInheritedAnnotationClass.class).isDirectlyPresent(\n\t\t\t\t\t\tOrder.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid getAggregateIndexForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(-1);\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(0);\n\t\t// Since we're not traversing interface hierarchies the following,\n\t\t// though perhaps counterintuitive, must be false:\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(1);\n\t\t// non-inherited class-level annotation; note: @Order is not inherited\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tOrder.class).getAggregateIndex()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tOrder.class).getAggregateIndex()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tOrder.class).getAggregateIndex()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tOrder.class).getAggregateIndex()).isEqualTo(-1);\n\t}\n\n\t@Test\n\tvoid getDirectWithoutAttributeAliases() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(WebController.class).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"webController\");\n\t}\n\n\t@Test\n\tvoid getDirectWithNestedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(ComponentScanClass.class).get(ComponentScan.class);\n\t\tMergedAnnotation<Filter>[] filters = annotation.getAnnotationArray(\"excludeFilters\", Filter.class);\n\t\tassertThat(Arrays.stream(filters).map(\n\t\t\t\tfilter -> filter.getString(\"pattern\"))).containsExactly(\"*Foo\", \"*Bar\");\n\t}\n\n\t@Test\n\tvoid getDirectWithAttributeAliases1() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method).get(RequestMapping.class);\n\t\tassertThat(annotation.getString(\"name\")).isEqualTo(\"foo\");\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"/test\");\n\t\tassertThat(annotation.getStringArray(\"path\")).containsExactly(\"/test\");\n\t}\n\n\t@Test\n\tvoid getDirectWithAttributeAliases2() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method).get(RequestMapping.class);\n\t\tassertThat(annotation.getString(\"name\")).isEqualTo(\"bar\");\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"/test\");\n\t\tassertThat(annotation.getStringArray(\"path\")).containsExactly(\"/test\");\n\t}\n\n\t@Test\n\tvoid getDirectWithAttributeAliasesWithDifferentValues() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithDifferentPathAndValueAttributes\");\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tMergedAnnotations.from(method).get(RequestMapping.class))\n\t\t\t\t.withMessageContaining(\"attribute 'path' and its alias 'value'\")\n\t\t\t\t.withMessageContaining(\"values of [{/test}] and [{/enigma}]\");\n\t}\n\n\t@Test\n\tvoid getValueFromAnnotation() throws Exception {\n\t\tMethod method = TransactionalStringGeneric.class.getMethod(\"something\", Object.class);\n\t\tMergedAnnotation<?> annotation =\n\t\t\t\tMergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getInt(\"value\")).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getValueFromNonPublicAnnotation() {\n\t\tAnnotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\n\t\tassertThat(declaredAnnotations).hasSize(1);\n\t\tAnnotation annotation = declaredAnnotations[0];\n\t\tMergedAnnotation<Annotation> mergedAnnotation = MergedAnnotation.from(annotation);\n\t\tassertThat(mergedAnnotation.getType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\n\t\tassertThat(mergedAnnotation.synthesize().annotationType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\n\t\tassertThat(mergedAnnotation.getInt(\"value\")).isEqualTo(42);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromAnnotation() throws Exception {\n\t\tMethod method = TransactionalStringGeneric.class.getMethod(\"something\", Object.class);\n\t\tMergedAnnotation<Order> annotation =\n\t\t\t\tMergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getDefaultValue(\"value\")).contains(Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromNonPublicAnnotation() {\n\t\tAnnotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\n\t\tassertThat(declaredAnnotations).hasSize(1);\n\t\tAnnotation declaredAnnotation = declaredAnnotations[0];\n\t\tMergedAnnotation<?> annotation = MergedAnnotation.from(declaredAnnotation);\n\t\tassertThat(annotation.getType().getName()).isEqualTo(\n\t\t\t\t\"org.springframework.core.annotation.subpackage.NonPublicAnnotation\");\n\t\tassertThat(annotation.getDefaultValue(\"value\")).contains(-1);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromAnnotationType() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotation.of(Order.class);\n\t\tassertThat(annotation.getDefaultValue(\"value\")).contains(Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnMethod() throws Exception {\n\t\tMethod method = InterfaceWithRepeated.class.getMethod(\"foo\");\n\t\tStream<MergedAnnotation<MyRepeatable>> annotations = MergedAnnotations.from(\n\t\t\t\tmethod, SearchStrategy.TYPE_HIERARCHY).stream(MyRepeatable.class);\n\t\tStream<String> values = annotations.map(\n\t\t\t\tannotation -> annotation.getString(\"value\"));\n\t\tassertThat(values).containsExactly(\"A\", \"B\", \"C\", \"meta1\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid streamRepeatableDeclaredOnClassWithAttributeAliases() {\n\t\tassertThat(MergedAnnotations.from(HierarchyClass.class).stream(\n\t\t\t\tTestConfiguration.class)).isEmpty();\n\t\tRepeatableContainers containers = RepeatableContainers.of(TestConfiguration.class,\n\t\t\t\tHierarchy.class);\n\t\tMergedAnnotations annotations = MergedAnnotations.from(HierarchyClass.class,\n\t\t\t\tSearchStrategy.DIRECT, containers, AnnotationFilter.NONE);\n\t\tassertThat(annotations.stream(TestConfiguration.class).map(\n\t\t\t\tannotation -> annotation.getString(\"location\"))).containsExactly(\"A\", \"B\");\n\t\tassertThat(annotations.stream(TestConfiguration.class).map(\n\t\t\t\tannotation -> annotation.getString(\"value\"))).containsExactly(\"A\", \"B\");\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnClass() {\n\t\tClass<?> element = MyRepeatableClass.class;\n\t\tString[] expectedValuesJava = { \"A\", \"B\", \"C\" };\n\t\tString[] expectedValuesSpring = { \"A\", \"B\", \"C\", \"meta1\" };\n\t\ttestRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnSuperclass() {\n\t\tClass<?> element = SubMyRepeatableClass.class;\n\t\tString[] expectedValuesJava = { \"A\", \"B\", \"C\" };\n\t\tString[] expectedValuesSpring = { \"A\", \"B\", \"C\", \"meta1\" };\n\t\ttestRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnClassAndSuperclass() {\n\t\tClass<?> element = SubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\n\t\tString[] expectedValuesJava = { \"X\", \"Y\", \"Z\" };\n\t\tString[] expectedValuesSpring = { \"X\", \"Y\", \"Z\", \"meta2\" };\n\t\ttestRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnMultipleSuperclasses() {\n\t\tClass<?> element = SubSubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\n\t\tString[] expectedValuesJava = { \"X\", \"Y\", \"Z\" };\n\t\tString[] expectedValuesSpring = { \"X\", \"Y\", \"Z\", \"meta2\" };\n\t\ttestRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamDirectRepeatablesDeclaredOnClass() {\n\t\tClass<?> element = MyRepeatableClass.class;\n\t\tString[] expectedValuesJava = { \"A\", \"B\", \"C\" };\n\t\tString[] expectedValuesSpring = { \"A\", \"B\", \"C\", \"meta1\" };\n\t\ttestRepeatables(SearchStrategy.DIRECT, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamDirectRepeatablesDeclaredOnSuperclass() {\n\t\tClass<?> element = SubMyRepeatableClass.class;\n\t\tString[] expectedValuesJava = {};\n\t\tString[] expectedValuesSpring = {};\n\t\ttestRepeatables(SearchStrategy.DIRECT, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\tprivate void testRepeatables(SearchStrategy searchStrategy, Class<?> element,\n\t\t\tString[] expectedValuesJava, String[] expectedValuesSpring) {\n\n\t\ttestJavaRepeatables(searchStrategy, element, expectedValuesJava);\n\t\ttestExplicitRepeatables(searchStrategy, element, expectedValuesSpring);\n\t\ttestStandardRepeatables(searchStrategy, element, expectedValuesSpring);\n\t}\n\n\tprivate void testJavaRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expected) {\n\t\tMyRepeatable[] annotations = searchStrategy == SearchStrategy.DIRECT ?\n\t\t\t\telement.getDeclaredAnnotationsByType(MyRepeatable.class) :\n\t\t\t\telement.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(Arrays.stream(annotations).map(MyRepeatable::value)).containsExactly(\n\t\t\t\texpected);\n\t}\n\n\tprivate void testExplicitRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expected) {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(element, searchStrategy,\n\t\t\t\tRepeatableContainers.of(MyRepeatable.class, MyRepeatableContainer.class),\n\t\t\t\tAnnotationFilter.PLAIN);\n\t\tStream<String> values = annotations.stream(MyRepeatable.class)\n\t\t\t\t.filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex))\n\t\t\t\t.map(annotation -> annotation.getString(\"value\"));\n\t\tassertThat(values).containsExactly(expected);\n\t}\n\n\tprivate void testStandardRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expected) {\n\t\tStream<String> values = MergedAnnotations.from(element, searchStrategy).stream(MyRepeatable.class)\n\t\t\t\t.filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex))\n\t\t\t\t.map(annotation -> annotation.getString(\"value\"));\n\t\tassertThat(values).containsExactly(expected);\n\t}\n\n\t@Test\n\tvoid synthesizeWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tComponent synthesizedComponent = MergedAnnotation.from(component).synthesize();\n\t\tassertThat(synthesizedComponent).isNotNull();\n\t\tassertThat(synthesizedComponent).isEqualTo(component);\n\t\tassertThat(synthesizedComponent.value()).isEqualTo(\"webController\");\n\t}\n\n\t/**\n\t * @since 6.0\n\t */\n\t@Test\n\tvoid synthesizedAnnotationShouldReuseJdkProxyClass() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\n\t\tRequestMapping jdkRequestMapping = method.getAnnotation(RequestMapping.class);\n\t\tassertThat(jdkRequestMapping).isNotNull();\n\t\tassertThat(jdkRequestMapping.value()).containsExactly(\"/test\");\n\t\tassertThat(jdkRequestMapping.path()).containsExactly(\"\");\n\n\t\tRequestMapping synthesizedRequestMapping = MergedAnnotation.from(jdkRequestMapping).synthesize();\n\t\tassertSynthesized(synthesizedRequestMapping);\n\t\tassertThat(synthesizedRequestMapping.value()).containsExactly(\"/test\");\n\t\tassertThat(synthesizedRequestMapping.path()).containsExactly(\"/test\");\n\n\t\tassertThat(jdkRequestMapping.getClass()).isSameAs(synthesizedRequestMapping.getClass());\n\t}\n\n\t@Test\n\tvoid synthesizeAlreadySynthesized() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\t\tRequestMapping webMapping = method.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMapping).isNotNull();\n\n\t\tRequestMapping synthesizedWebMapping = MergedAnnotation.from(webMapping).synthesize();\n\t\tRequestMapping synthesizedAgainWebMapping = MergedAnnotation.from(synthesizedWebMapping).synthesize();\n\n\t\tassertSynthesized(synthesizedWebMapping);\n\t\tassertSynthesized(synthesizedAgainWebMapping);\n\t\tassertThat(synthesizedWebMapping).isEqualTo(synthesizedAgainWebMapping);\n\t\tassertThat(synthesizedWebMapping).isSameAs(synthesizedAgainWebMapping);\n\t\tassertThat(synthesizedWebMapping.name()).isEqualTo(\"foo\");\n\t\tassertThat(synthesizedWebMapping.path()).containsExactly(\"/test\");\n\t\tassertThat(synthesizedWebMapping.value()).containsExactly(\"/test\");\n\t}\n\n\t@Test\n\tvoid synthesizeShouldNotSynthesizeNonsynthesizableAnnotations() throws Exception {\n\t\tMethod method = getClass().getDeclaredMethod(\"getId\");\n\n\t\tId id = method.getAnnotation(Id.class);\n\t\tassertThat(id).isNotNull();\n\t\tId synthesizedId = MergedAnnotation.from(id).synthesize();\n\t\tassertThat(id).isEqualTo(synthesizedId);\n\t\t// It doesn't make sense to synthesize @Id since it declares zero attributes.\n\t\tassertNotSynthesized(synthesizedId);\n\t\tassertThat(id).isSameAs(synthesizedId);\n\n\t\tGeneratedValue generatedValue = method.getAnnotation(GeneratedValue.class);\n\t\tassertThat(generatedValue).isNotNull();\n\t\tGeneratedValue synthesizedGeneratedValue = MergedAnnotation.from(generatedValue).synthesize();\n\t\tassertThat(generatedValue).isEqualTo(synthesizedGeneratedValue);\n\t\t// It doesn't make sense to synthesize @GeneratedValue since it declares zero attributes with aliases.\n\t\tassertNotSynthesized(synthesizedGeneratedValue);\n\t\tassertThat(generatedValue).isSameAs(synthesizedGeneratedValue);\n\t}\n\n\t@Test  // gh-28716\n\tvoid synthesizeWhenUsingMergedAnnotationsFromApi() {\n\t\tField directlyAnnotatedField = ReflectionUtils.findField(DomainType.class, \"directlyAnnotated\");\n\t\tMergedAnnotations mergedAnnotations = MergedAnnotations.from(directlyAnnotatedField);\n\t\tRootAnnotation rootAnnotation = mergedAnnotations.get(RootAnnotation.class).synthesize();\n\t\tassertThat(rootAnnotation.flag()).isFalse();\n\t\tassertNotSynthesized(rootAnnotation);\n\n\t\tField metaAnnotatedField = ReflectionUtils.findField(DomainType.class, \"metaAnnotated\");\n\t\tmergedAnnotations = MergedAnnotations.from(metaAnnotatedField);\n\t\trootAnnotation = mergedAnnotations.get(RootAnnotation.class).synthesize();\n\t\tassertThat(rootAnnotation.flag()).isTrue();\n\t\tassertSynthesized(rootAnnotation);\n\n\t\tField metaMetaAnnotatedField = ReflectionUtils.findField(DomainType.class, \"metaMetaAnnotated\");\n\t\tmergedAnnotations = MergedAnnotations.from(metaMetaAnnotatedField);\n\t\trootAnnotation = mergedAnnotations.get(RootAnnotation.class).synthesize();\n\t\tassertThat(rootAnnotation.flag()).isTrue();\n\t\tassertSynthesized(rootAnnotation);\n\t}\n\n\t@Test  // gh-28704\n\tvoid synthesizeShouldNotSynthesizeNonsynthesizableAnnotationsWhenUsingMergedAnnotationsFromApi() {\n\t\tMergedAnnotations mergedAnnotations = MergedAnnotations.from(SecurityConfig.class);\n\n\t\tEnableWebSecurity enableWebSecurity = mergedAnnotations.get(EnableWebSecurity.class).synthesize();\n\t\tassertNotSynthesized(enableWebSecurity);\n\n\t\tEnableGlobalAuthentication enableGlobalAuthentication = mergedAnnotations.get(EnableGlobalAuthentication.class).synthesize();\n\t\tassertNotSynthesized(enableGlobalAuthentication);\n\t}\n\n\t/**\n\t * If an attempt is made to synthesize an annotation from an annotation instance\n\t * that has already been synthesized, the original synthesized annotation should\n\t * ideally be returned as-is without creating a new proxy instance with the same\n\t * values.\n\t */\n\t@Test\n\tvoid synthesizeShouldNotResynthesizeAlreadySynthesizedAnnotations() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\t\tRequestMapping webMapping = method.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMapping).isNotNull();\n\n\t\tMergedAnnotation<RequestMapping> mergedAnnotation1 = MergedAnnotation.from(webMapping);\n\t\tRequestMapping synthesizedWebMapping1 = mergedAnnotation1.synthesize();\n\t\tRequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMapping).synthesize();\n\n\t\tassertSynthesized(synthesizedWebMapping1);\n\t\tassertSynthesized(synthesizedWebMapping2);\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(synthesizedWebMapping2);\n\n\t\t// Synthesizing an annotation from a different MergedAnnotation results in a different synthesized annotation instance.\n\t\tassertThat(synthesizedWebMapping1).isNotSameAs(synthesizedWebMapping2);\n\t\t// Synthesizing an annotation from the same MergedAnnotation results in the same synthesized annotation instance.\n\t\tassertThat(synthesizedWebMapping1).isSameAs(mergedAnnotation1.synthesize());\n\n\t\tRequestMapping synthesizedAgainWebMapping = MergedAnnotation.from(synthesizedWebMapping1).synthesize();\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(synthesizedAgainWebMapping);\n\t\t// Synthesizing an already synthesized annotation results in the original synthesized annotation instance.\n\t\tassertThat(synthesizedWebMapping1).isSameAs(synthesizedAgainWebMapping);\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAliasForIsMissingAttributeDeclaration() {\n\t\tAliasForWithMissingAttributeDeclaration annotation =\n\t\t\t\tAliasForWithMissingAttributeDeclarationClass.class.getAnnotation(\n\t\t\t\t\t\tAliasForWithMissingAttributeDeclaration.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"@AliasFor declaration on attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(AliasForWithMissingAttributeDeclaration.class.getName())\n\t\t\t\t.withMessageContaining(\"points to itself\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAliasForHasDuplicateAttributeDeclaration() {\n\t\tAliasForWithDuplicateAttributeDeclaration annotation =\n\t\t\t\tAliasForWithDuplicateAttributeDeclarationClass.class.getAnnotation(\n\t\t\t\t\t\tAliasForWithDuplicateAttributeDeclaration.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"In @AliasFor declared on attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(AliasForWithDuplicateAttributeDeclaration.class.getName())\n\t\t\t\t.withMessageContaining(\"attribute 'attribute' and its alias 'value' are present with values of 'baz' and 'bar'\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForNonexistentAttribute() {\n\t\tAliasForNonexistentAttribute annotation = AliasForNonexistentAttributeClass.class.getAnnotation(\n\t\t\t\tAliasForNonexistentAttribute.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"@AliasFor declaration on attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(AliasForNonexistentAttribute.class.getName())\n\t\t\t\t.withMessageContaining(\"declares an alias for 'bar' which is not present\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasWithMirroredAliasForWrongAttribute() {\n\t\tAliasForWithMirroredAliasForWrongAttribute annotation =\n\t\t\t\tAliasForWithMirroredAliasForWrongAttributeClass.class.getAnnotation(\n\t\t\t\t\t\tAliasForWithMirroredAliasForWrongAttribute.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessage(\"@AliasFor declaration on attribute 'bar' in annotation [\" +\n\t\t\t\t\t\tAliasForWithMirroredAliasForWrongAttribute.class.getName() +\n\t\t\t\t\t\t\"] declares an alias for 'quux' which is not present.\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForAttributeOfDifferentType() {\n\t\tAliasForAttributeOfDifferentType annotation = AliasForAttributeOfDifferentTypeClass.class.getAnnotation(\n\t\t\t\tAliasForAttributeOfDifferentType.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases\")\n\t\t\t\t.withMessageContaining(AliasForAttributeOfDifferentType.class.getName())\n\t\t\t\t.withMessageContaining(\"attribute 'foo'\")\n\t\t\t\t.withMessageContaining(\"attribute 'bar'\")\n\t\t\t\t.withMessageContaining(\"same return type\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForWithMissingDefaultValues() {\n\t\tAliasForWithMissingDefaultValues annotation = AliasForWithMissingDefaultValuesClass.class.getAnnotation(\n\t\t\t\tAliasForWithMissingDefaultValues.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases\")\n\t\t\t\t.withMessageContaining(AliasForWithMissingDefaultValues.class.getName())\n\t\t\t\t.withMessageContaining(\"attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(\"attribute 'bar' in annotation\")\n\t\t\t\t.withMessageContaining(\"default values\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForAttributeWithDifferentDefaultValue() {\n\t\tAliasForAttributeWithDifferentDefaultValue annotation =\n\t\t\t\tAliasForAttributeWithDifferentDefaultValueClass.class.getAnnotation(\n\t\t\t\t\t\tAliasForAttributeWithDifferentDefaultValue.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases\")\n\t\t\t\t.withMessageContaining(AliasForAttributeWithDifferentDefaultValue.class.getName())\n\t\t\t\t.withMessageContaining(\"attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(\"attribute 'bar' in annotation\")\n\t\t\t\t.withMessageContaining(\"same default value\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForMetaAnnotationThatIsNotMetaPresent() {\n\t\tAliasedComposedTestConfigurationNotMetaPresent annotation =\n\t\t\t\tAliasedComposedTestConfigurationNotMetaPresentClass.class.getAnnotation(\n\t\t\t\t\t\tAliasedComposedTestConfigurationNotMetaPresent.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"@AliasFor declaration on attribute 'xmlConfigFile' in annotation\")\n\t\t\t\t.withMessageContaining(AliasedComposedTestConfigurationNotMetaPresent.class.getName())\n\t\t\t\t.withMessageContaining(\"declares an alias for attribute 'location' in annotation\")\n\t\t\t\t.withMessageContaining(TestConfiguration.class.getName())\n\t\t\t\t.withMessageContaining(\"not meta-present\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliases() {\n\t\ttestSynthesisWithImplicitAliases(ValueImplicitAliasesTestConfigurationClass.class, \"value\");\n\t\ttestSynthesisWithImplicitAliases(Location1ImplicitAliasesTestConfigurationClass.class, \"location1\");\n\t\ttestSynthesisWithImplicitAliases(XmlImplicitAliasesTestConfigurationClass.class, \"xmlFile\");\n\t\ttestSynthesisWithImplicitAliases(GroovyImplicitAliasesSimpleTestConfigurationClass.class, \"groovyScript\");\n\t}\n\n\tprivate void testSynthesisWithImplicitAliases(Class<?> clazz, String expected) {\n\t\tImplicitAliasesTestConfiguration config = clazz.getAnnotation(ImplicitAliasesTestConfiguration.class);\n\t\tassertThat(config).isNotNull();\n\t\tImplicitAliasesTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.value()).isEqualTo(expected);\n\t\tassertThat(synthesized.location1()).isEqualTo(expected);\n\t\tassertThat(synthesized.xmlFile()).isEqualTo(expected);\n\t\tassertThat(synthesized.groovyScript()).isEqualTo(expected);\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesWithImpliedAliasNamesOmitted() {\n\t\ttestSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(\n\t\t\t\tValueImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass.class,\n\t\t\t\t\"value\");\n\t\ttestSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(\n\t\t\t\tLocationsImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass.class,\n\t\t\t\t\"location\");\n\t\ttestSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(\n\t\t\t\tXmlFilesImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass.class,\n\t\t\t\t\"xmlFile\");\n\t}\n\n\tprivate void testSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(Class<?> clazz, String expected) {\n\t\tImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration config = clazz.getAnnotation(\n\t\t\t\tImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration.class);\n\t\tassertThat(config).isNotNull();\n\t\tImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration synthesized =\n\t\t\t\tMergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.value()).isEqualTo(expected);\n\t\tassertThat(synthesized.location()).isEqualTo(expected);\n\t\tassertThat(synthesized.xmlFile()).isEqualTo(expected);\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesForAliasPair() {\n\t\tImplicitAliasesForAliasPairTestConfiguration config =\n\t\t\t\tImplicitAliasesForAliasPairTestConfigurationClass.class.getAnnotation(\n\t\t\t\t\t\tImplicitAliasesForAliasPairTestConfiguration.class);\n\t\tImplicitAliasesForAliasPairTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.xmlFile()).isEqualTo(\"test.xml\");\n\t\tassertThat(synthesized.groovyScript()).isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithTransitiveImplicitAliases() {\n\t\tTransitiveImplicitAliasesTestConfiguration config =\n\t\t\t\tTransitiveImplicitAliasesTestConfigurationClass.class.getAnnotation(\n\t\t\t\t\t\tTransitiveImplicitAliasesTestConfiguration.class);\n\t\tTransitiveImplicitAliasesTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.xml()).isEqualTo(\"test.xml\");\n\t\tassertThat(synthesized.groovy()).isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithTransitiveImplicitAliasesForAliasPair() {\n\t\tTransitiveImplicitAliasesForAliasPairTestConfiguration config =\n\t\t\t\tTransitiveImplicitAliasesForAliasPairTestConfigurationClass.class.getAnnotation(\n\t\t\t\t\t\tTransitiveImplicitAliasesForAliasPairTestConfiguration.class);\n\t\tTransitiveImplicitAliasesForAliasPairTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.xml()).isEqualTo(\"test.xml\");\n\t\tassertThat(synthesized.groovy()).isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesWithMissingDefaultValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithMissingDefaultValuesTestConfigurationClass.class;\n\t\tClass<ImplicitAliasesWithMissingDefaultValuesTestConfiguration> annotationType =\n\t\t\t\tImplicitAliasesWithMissingDefaultValuesTestConfiguration.class;\n\t\tImplicitAliasesWithMissingDefaultValuesTestConfiguration config = clazz.getAnnotation(annotationType);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(clazz, config))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases:\")\n\t\t\t\t.withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t\t.withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t\t.withMessageContaining(\"default values\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesWithDifferentDefaultValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithDifferentDefaultValuesTestConfigurationClass.class;\n\t\tClass<ImplicitAliasesWithDifferentDefaultValuesTestConfiguration> annotationType =\n\t\t\t\tImplicitAliasesWithDifferentDefaultValuesTestConfiguration.class;\n\t\tImplicitAliasesWithDifferentDefaultValuesTestConfiguration config = clazz.getAnnotation(annotationType);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(clazz, config))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases:\")\n\t\t\t\t.withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t\t.withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t\t.withMessageContaining(\"same default value\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesWithDuplicateValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithDuplicateValuesTestConfigurationClass.class;\n\t\tClass<ImplicitAliasesWithDuplicateValuesTestConfiguration> annotationType =\n\t\t\t\tImplicitAliasesWithDuplicateValuesTestConfiguration.class;\n\t\tImplicitAliasesWithDuplicateValuesTestConfiguration config = clazz.getAnnotation(annotationType);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotation.from(clazz, config))\n\t\t\t\t.withMessageStartingWith(\"Different @AliasFor mirror values for annotation\")\n\t\t\t\t.withMessageContaining(annotationType.getName())\n\t\t\t\t.withMessageContaining(\"declared on class\")\n\t\t\t\t.withMessageContaining(clazz.getName())\n\t\t\t\t.withMessageContaining(\"are declared with values of\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tMap<String, Object> map = Collections.singletonMap(\"value\", \"webController\");\n\t\tMergedAnnotation<Component> annotation = MergedAnnotation.of(Component.class, map);\n\n\t\tComponent synthesizedComponent = annotation.synthesize();\n\t\tassertSynthesized(synthesizedComponent);\n\t\tassertThat(synthesizedComponent.value()).isEqualTo(\"webController\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeFromMapWithNestedMap() {\n\t\tComponentScanSingleFilter componentScan = ComponentScanSingleFilterClass.class.getAnnotation(\n\t\t\t\tComponentScanSingleFilter.class);\n\t\tassertThat(componentScan).isNotNull();\n\t\tassertThat(componentScan.value().pattern()).isEqualTo(\"*Foo\");\n\t\tMap<String, Object> map = MergedAnnotation.from(componentScan).asMap(\n\t\t\t\tannotation -> new LinkedHashMap<>(), Adapt.ANNOTATION_TO_MAP);\n\t\tMap<String, Object> filterMap = (Map<String, Object>) map.get(\"value\");\n\t\tassertThat(filterMap.get(\"pattern\")).isEqualTo(\"*Foo\");\n\t\tfilterMap.put(\"pattern\", \"newFoo\");\n\t\tfilterMap.put(\"enigma\", 42);\n\t\tMergedAnnotation<ComponentScanSingleFilter> annotation = MergedAnnotation.of(\n\t\t\t\tComponentScanSingleFilter.class, map);\n\t\tComponentScanSingleFilter synthesizedComponentScan = annotation.synthesize();\n\t\tassertSynthesized(synthesizedComponentScan);\n\t\tassertThat(synthesizedComponentScan.value().pattern()).isEqualTo(\"newFoo\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeFromMapWithNestedArrayOfMaps() {\n\t\tComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class);\n\t\tassertThat(componentScan).isNotNull();\n\t\tMap<String, Object> map = MergedAnnotation.from(componentScan).asMap(\n\t\t\t\tannotation -> new LinkedHashMap<>(), Adapt.ANNOTATION_TO_MAP);\n\t\tMap<String, Object>[] filters = (Map[]) map.get(\"excludeFilters\");\n\t\tList<String> patterns = Arrays.stream(filters).map(\n\t\t\t\tm -> (String) m.get(\"pattern\")).toList();\n\t\tassertThat(patterns).containsExactly(\"*Foo\", \"*Bar\");\n\t\tfilters[0].put(\"pattern\", \"newFoo\");\n\t\tfilters[0].put(\"enigma\", 42);\n\t\tfilters[1].put(\"pattern\", \"newBar\");\n\t\tfilters[1].put(\"enigma\", 42);\n\t\tMergedAnnotation<ComponentScan> annotation = MergedAnnotation.of(ComponentScan.class, map);\n\t\tComponentScan synthesizedComponentScan = annotation.synthesize();\n\t\tassertSynthesized(synthesizedComponentScan);\n\t\tassertThat(Arrays.stream(synthesizedComponentScan.excludeFilters()).map(Filter::pattern))\n\t\t\t\t.containsExactly(\"newFoo\", \"newBar\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromDefaultsWithoutAttributeAliases() {\n\t\tMergedAnnotation<AnnotationWithDefaults> annotation = MergedAnnotation.of(AnnotationWithDefaults.class);\n\t\tAnnotationWithDefaults synthesized = annotation.synthesize();\n\t\tassertThat(synthesized.text()).isEqualTo(\"enigma\");\n\t\tassertThat(synthesized.predicate()).isTrue();\n\t\tassertThat(synthesized.characters()).containsExactly('a', 'b', 'c');\n\t}\n\n\t@Test\n\tvoid synthesizeFromDefaultsWithAttributeAliases() {\n\t\tMergedAnnotation<TestConfiguration> annotation = MergedAnnotation.of(TestConfiguration.class);\n\t\tTestConfiguration synthesized = annotation.synthesize();\n\t\tassertThat(synthesized.value()).isEmpty();\n\t\tassertThat(synthesized.location()).isEmpty();\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasesWithDifferentValues() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tMergedAnnotation.from(TestConfigurationMismatch.class.getAnnotation(TestConfiguration.class)).synthesize());\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithMinimalAttributesWithAttributeAliases() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"location\", \"test.xml\");\n\t\tMergedAnnotation<TestConfiguration> annotation = MergedAnnotation.of(TestConfiguration.class, map);\n\t\tTestConfiguration synthesized = annotation.synthesize();\n\t\tassertThat(synthesized.value()).isEqualTo(\"test.xml\");\n\t\tassertThat(synthesized.location()).isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements() {\n\t\tsynthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements(\n\t\t\t\tCollections.singletonMap(\"value\", \"/foo\"));\n\t\tsynthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements(\n\t\t\t\tCollections.singletonMap(\"path\", \"/foo\"));\n\t}\n\n\tprivate void synthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements(Map<String, Object> map) {\n\t\tMergedAnnotation<GetMapping> annotation = MergedAnnotation.of(GetMapping.class, map);\n\t\tGetMapping synthesized = annotation.synthesize();\n\t\tassertThat(synthesized.value()).isEqualTo(\"/foo\");\n\t\tassertThat(synthesized.path()).isEqualTo(\"/foo\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithImplicitAttributeAliases() {\n\t\ttestSynthesisFromMapWithImplicitAliases(\"value\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"location1\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"location2\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"location3\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"xmlFile\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"groovyScript\");\n\t}\n\n\tprivate void testSynthesisFromMapWithImplicitAliases(String attributeNameAndValue) {\n\t\tMap<String, Object> map = Collections.singletonMap(attributeNameAndValue, attributeNameAndValue);\n\t\tMergedAnnotation<ImplicitAliasesTestConfiguration> annotation = MergedAnnotation.of(\n\t\t\t\tImplicitAliasesTestConfiguration.class, map);\n\t\tImplicitAliasesTestConfiguration synthesized = annotation.synthesize();\n\n\t\tassertThat(synthesized.value()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.location1()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.location2()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.location2()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.xmlFile()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.groovyScript()).isEqualTo(attributeNameAndValue);\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithMissingAttributeValue() {\n\t\ttestMissingTextAttribute(Collections.emptyMap());\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithNullAttributeValue() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"text\", null);\n\t\tassertThat(map).containsKey(\"text\");\n\t\ttestMissingTextAttribute(map);\n\t}\n\n\tprivate void testMissingTextAttribute(Map<String, Object> attributes) {\n\t\tassertThatExceptionOfType(NoSuchElementException.class).isThrownBy(() ->\n\t\t\t\tMergedAnnotation.of(AnnotationWithoutDefaults.class, attributes).synthesize().text())\n\t\t\t\t.withMessage(\"No value found for attribute named 'text' in merged annotation \" +\n\t\t\t\t\t\tAnnotationWithoutDefaults.class.getCanonicalName());\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithAttributeOfIncorrectType() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"value\", 42L);\n\t\tMergedAnnotation<Component> annotation = MergedAnnotation.of(Component.class, map);\n\t\tassertThatIllegalStateException().isThrownBy(() -> annotation.synthesize().value())\n\t\t\t\t.withMessage(\"Attribute 'value' in annotation \" +\n\t\t\t\t\t\t\"org.springframework.core.testfixture.stereotype.Component should be \" +\n\t\t\t\t\t\t\"compatible with java.lang.String but a java.lang.Long value was returned\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromAnnotationAttributesWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tMap<String, Object> attributes = MergedAnnotation.from(component).asMap();\n\n\t\tComponent synthesized = MergedAnnotation.of(Component.class, attributes).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized).isEqualTo(component);\n\t}\n\n\t@Test\n\tvoid toStringForSynthesizedAnnotations() throws Exception {\n\t\tMethod methodWithPath = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\tRequestMapping webMappingWithAliases = methodWithPath.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithAliases).isNotNull();\n\n\t\tMethod methodWithPathAndValue = WebController.class.getMethod(\"handleMappedWithSamePathAndValueAttributes\");\n\t\tRequestMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(RequestMapping.class);\n\t\tassertThat(methodWithPathAndValue).isNotNull();\n\n\t\tRequestMapping synthesizedWebMapping1 = MergedAnnotation.from(webMappingWithAliases).synthesize();\n\t\tRequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMappingWithPathAndValue).synthesize();\n\n\t\tassertThat(webMappingWithAliases.toString()).isNotEqualTo(synthesizedWebMapping1.toString());\n\n\t\t// The unsynthesized annotation for handleMappedWithSamePathAndValueAttributes()\n\t\t// should produce almost the same toString() results as synthesized annotations for\n\t\t// handleMappedWithPathAttribute() on Java 9 or higher; however, due to multiple changes\n\t\t// in the JDK's toString() implementation for annotations in JDK 9, 14, and 19,\n\t\t// we do not test the JDK implementation.\n\t\t// assertToStringForWebMappingWithPathAndValue(webMappingWithPathAndValue);\n\n\t\tassertToStringForWebMappingWithPathAndValue(synthesizedWebMapping1);\n\t\tassertToStringForWebMappingWithPathAndValue(synthesizedWebMapping2);\n\t}\n\n\tprivate void assertToStringForWebMappingWithPathAndValue(RequestMapping webMapping) {\n\t\tassertThat(webMapping.toString())\n\t\t\t\t.startsWith(\"@org.springframework.core.annotation.MergedAnnotationsTests.RequestMapping(\")\n\t\t\t\t.contains(\n\t\t\t\t\t// Strings\n\t\t\t\t\t\"value={\\\"/test\\\"}\", \"path={\\\"/test\\\"}\", \"name=\\\"bar\\\"\",\n\t\t\t\t\t// Characters\n\t\t\t\t\t\"ch='X'\", \"chars={'X'}\",\n\t\t\t\t\t// Enums\n\t\t\t\t\t\"method={GET, POST}\",\n\t\t\t\t\t// Classes\n\t\t\t\t\t\"clazz=org.springframework.core.annotation.MergedAnnotationsTests.RequestMethod.class\",\n\t\t\t\t\t\"classes={int[][].class, org.springframework.core.annotation.MergedAnnotationsTests.RequestMethod[].class}\",\n\t\t\t\t\t// Bytes\n\t\t\t\t\t\"byteValue=(byte) 0xFF\", \"bytes={(byte) 0xFF}\",\n\t\t\t\t\t// Shorts\n\t\t\t\t\t\"shortValue=9876\", \"shorts={9876}\",\n\t\t\t\t\t// Longs\n\t\t\t\t\t\"longValue=42L\", \"longs={42L}\",\n\t\t\t\t\t// Floats\n\t\t\t\t\t\"floatValue=3.14f\", \"floats={3.14f}\",\n\t\t\t\t\t// Doubles\n\t\t\t\t\t\"doubleValue=99.999d\", \"doubles={99.999d}\"\n\t\t\t\t)\n\t\t\t\t.endsWith(\")\");\n\t}\n\n\t@Test\n\tvoid equalsForSynthesizedAnnotations() throws Exception {\n\t\tMethod methodWithPath = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\tRequestMapping webMappingWithAliases = methodWithPath.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithAliases).isNotNull();\n\t\tMethod methodWithPathAndValue = WebController.class.getMethod(\"handleMappedWithSamePathAndValueAttributes\");\n\t\tRequestMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithPathAndValue).isNotNull();\n\t\tRequestMapping synthesizedWebMapping1 = MergedAnnotation.from(webMappingWithAliases).synthesize();\n\t\tRequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMappingWithPathAndValue).synthesize();\n\t\t// Equality amongst standard annotations\n\t\tassertThat(webMappingWithAliases).isEqualTo(webMappingWithAliases);\n\t\tassertThat(webMappingWithPathAndValue).isEqualTo(webMappingWithPathAndValue);\n\t\t// Inequality amongst standard annotations\n\t\tassertThat(webMappingWithAliases).isNotEqualTo(webMappingWithPathAndValue);\n\t\tassertThat(webMappingWithPathAndValue).isNotEqualTo(webMappingWithAliases);\n\t\t// Equality amongst synthesized annotations\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(synthesizedWebMapping1);\n\t\tassertThat(synthesizedWebMapping2).isEqualTo(synthesizedWebMapping2);\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(synthesizedWebMapping2);\n\t\tassertThat(synthesizedWebMapping2).isEqualTo(synthesizedWebMapping1);\n\t\t// Equality between standard and synthesized annotations\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(webMappingWithPathAndValue);\n\t\tassertThat(webMappingWithPathAndValue).isEqualTo(synthesizedWebMapping1);\n\t\t// Inequality between standard and synthesized annotations\n\t\tassertThat(synthesizedWebMapping1).isNotEqualTo(webMappingWithAliases);\n\t\tassertThat(webMappingWithAliases).isNotEqualTo(synthesizedWebMapping1);\n\t}\n\n\t@Test\n\tvoid hashCodeForSynthesizedAnnotations() throws Exception {\n\t\tMethod methodWithPath = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\tRequestMapping webMappingWithAliases = methodWithPath.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithAliases).isNotNull();\n\t\tMethod methodWithPathAndValue = WebController.class.getMethod(\"handleMappedWithSamePathAndValueAttributes\");\n\t\tRequestMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithPathAndValue).isNotNull();\n\t\tRequestMapping synthesizedWebMapping1 = MergedAnnotation.from(webMappingWithAliases).synthesize();\n\t\tassertThat(synthesizedWebMapping1).isNotNull();\n\t\tRequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMappingWithPathAndValue).synthesize();\n\t\tassertThat(synthesizedWebMapping2).isNotNull();\n\t\t// Equality amongst standard annotations\n\t\tassertThat(webMappingWithAliases.hashCode()).isEqualTo(webMappingWithAliases.hashCode());\n\t\tassertThat(webMappingWithPathAndValue.hashCode()).isEqualTo(webMappingWithPathAndValue.hashCode());\n\t\t// Inequality amongst standard annotations\n\t\tassertThat(webMappingWithAliases.hashCode()).isNotEqualTo(webMappingWithPathAndValue.hashCode());\n\t\tassertThat(webMappingWithPathAndValue.hashCode()).isNotEqualTo(webMappingWithAliases.hashCode());\n\t\t// Equality amongst synthesized annotations\n\t\tassertThat(synthesizedWebMapping1.hashCode()).isEqualTo(synthesizedWebMapping1.hashCode());\n\t\tassertThat(synthesizedWebMapping2.hashCode()).isEqualTo(synthesizedWebMapping2.hashCode());\n\t\tassertThat(synthesizedWebMapping1.hashCode()).isEqualTo(synthesizedWebMapping2.hashCode());\n\t\tassertThat(synthesizedWebMapping2.hashCode()).isEqualTo(synthesizedWebMapping1.hashCode());\n\t\t// Equality between standard and synthesized annotations\n\t\tassertThat(synthesizedWebMapping1.hashCode()).isEqualTo(webMappingWithPathAndValue.hashCode());\n\t\tassertThat(webMappingWithPathAndValue.hashCode()).isEqualTo(synthesizedWebMapping1.hashCode());\n\t\t// Inequality between standard and synthesized annotations\n\t\tassertThat(synthesizedWebMapping1.hashCode()).isNotEqualTo(webMappingWithAliases.hashCode());\n\t\tassertThat(webMappingWithAliases.hashCode()).isNotEqualTo(synthesizedWebMapping1.hashCode());\n\t}\n\n\t/**\n\t * Fully reflection-based test that verifies support for synthesizing\n\t * annotations across packages with non-public visibility of user types\n\t * (for example, a non-public annotation that uses {@code @AliasFor}).\n\t */\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeNonPublicWithAttributeAliasesFromDifferentPackage() throws Exception {\n\t\tClass<?> type = ClassUtils.forName(\n\t\t\t\t\"org.springframework.core.annotation.subpackage.NonPublicAliasedAnnotatedClass\",\n\t\t\t\tnull);\n\t\tClass<? extends Annotation> annotationType = (Class<? extends Annotation>) ClassUtils.forName(\n\t\t\t\t\"org.springframework.core.annotation.subpackage.NonPublicAliasedAnnotation\",\n\t\t\t\tnull);\n\t\tAnnotation annotation = type.getAnnotation(annotationType);\n\t\tassertThat(annotation).isNotNull();\n\t\tMergedAnnotation<Annotation> mergedAnnotation = MergedAnnotation.from(annotation);\n\t\tAnnotation synthesizedAnnotation = mergedAnnotation.synthesize();\n\t\tassertSynthesized(synthesizedAnnotation);\n\t\tassertThat(mergedAnnotation.getString(\"name\")).isEqualTo(\"test\");\n\t\tassertThat(mergedAnnotation.getString(\"path\")).isEqualTo(\"/test\");\n\t\tassertThat(mergedAnnotation.getString(\"value\")).isEqualTo(\"/test\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithArrayOfAnnotations() {\n\t\tHierarchy hierarchy = HierarchyClass.class.getAnnotation(Hierarchy.class);\n\t\tassertThat(hierarchy).isNotNull();\n\t\tHierarchy synthesizedHierarchy = MergedAnnotation.from(hierarchy).synthesize();\n\t\tassertSynthesized(synthesizedHierarchy);\n\t\tTestConfiguration[] configs = synthesizedHierarchy.value();\n\t\tassertThat(configs).isNotNull();\n\t\tassertThat(configs).allMatch(AnnotationUtils::isSynthesizedAnnotation);\n\t\tassertThat(configs).extracting(TestConfiguration::value).containsExactly(\"A\", \"B\");\n\t\tassertThat(configs).extracting(TestConfiguration::location).containsExactly(\"A\", \"B\");\n\n\t\tTestConfiguration contextConfig = TestConfigurationClass.class.getAnnotation(TestConfiguration.class);\n\t\tassertThat(contextConfig).isNotNull();\n\t\t// Alter array returned from synthesized annotation\n\t\tconfigs[0] = contextConfig;\n\t\tassertThat(configs).extracting(TestConfiguration::value).containsExactly(\"simple.xml\", \"B\");\n\t\t// Re-retrieve the array from the synthesized annotation\n\t\tconfigs = synthesizedHierarchy.value();\n\t\tassertThat(configs).extracting(TestConfiguration::value).containsExactly(\"A\", \"B\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithArrayOfChars() {\n\t\tCharsContainer charsContainer = GroupOfCharsClass.class.getAnnotation(CharsContainer.class);\n\t\tassertThat(charsContainer).isNotNull();\n\t\tCharsContainer synthesizedCharsContainer = MergedAnnotation.from(charsContainer).synthesize();\n\t\tassertSynthesized(synthesizedCharsContainer);\n\t\tchar[] chars = synthesizedCharsContainer.chars();\n\t\tassertThat(chars).containsExactly('x', 'y', 'z');\n\t\t// Alter array returned from synthesized annotation\n\t\tchars[0] = '?';\n\t\t// Re-retrieve the array from the synthesized annotation\n\t\tchars = synthesizedCharsContainer.chars();\n\t\tassertThat(chars).containsExactly('x', 'y', 'z');\n\t}\n\n\t@Test\n\tvoid getValueWhenHasDefaultOverride() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(DefaultOverrideClass.class)\n\t\t\t\t.get(DefaultOverrideRoot.class);\n\t\tassertThat(annotation.getString(\"text\")).isEqualTo(\"metameta\");\n\t}\n\n\t@Test // gh-22654\n\tvoid getValueWhenHasDefaultOverrideWithImplicitAlias() {\n\t\tMergedAnnotation<?> annotation1 = MergedAnnotations.from(DefaultOverrideImplicitAliasMetaClass1.class)\n\t\t\t\t.get(DefaultOverrideRoot.class);\n\t\tassertThat(annotation1.getString(\"text\")).isEqualTo(\"alias-meta-1\");\n\t\tMergedAnnotation<?> annotation2 = MergedAnnotations.from(DefaultOverrideImplicitAliasMetaClass2.class)\n\t\t\t\t.get(DefaultOverrideRoot.class);\n\t\tassertThat(annotation2.getString(\"text\")).isEqualTo(\"alias-meta-2\");\n\t}\n\n\t@Test // gh-22654\n\tvoid getValueWhenHasDefaultOverrideWithExplicitAlias() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(DefaultOverrideExplicitAliasRootMetaMetaClass.class)\n\t\t\t\t.get(DefaultOverrideExplicitAliasRoot.class);\n\t\tassertThat(annotation.getString(\"text\")).isEqualTo(\"meta\");\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta\");\n\t}\n\n\t@Test // gh-22703\n\tvoid getValueWhenThreeDeepMetaWithValue() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(ValueAttributeMetaMetaClass.class)\n\t\t\t\t.get(ValueAttribute.class);\n\t\tassertThat(annotation.getStringArray(MergedAnnotation.VALUE)).containsExactly(\"FromValueAttributeMeta\");\n\t}\n\n\t@Test\n\tvoid asAnnotationAttributesReturnsPopulatedAnnotationAttributes() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(SpringApplicationConfigurationClass.class)\n\t\t\t\t.get(SpringApplicationConfiguration.class);\n\t\tAnnotationAttributes attributes = annotation.asAnnotationAttributes(Adapt.CLASS_TO_STRING);\n\t\tassertThat(attributes).containsEntry(\"classes\", new String[] {Number.class.getName()});\n\t\tassertThat(attributes.annotationType()).isEqualTo(SpringApplicationConfiguration.class);\n\t}\n\n\n\t// @formatter:off\n\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Transactional {\n\n\t\tString value() default \"\";\n\n\t\tString qualifier() default \"transactionManager\";\n\n\t\tboolean readOnly() default false;\n\t}\n\n\t@Transactional\n\t@Component\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransactionalComponent {\n\t}\n\n\t@TransactionalComponent\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedTransactionalComponent {\n\t}\n\n\tstatic class NonAnnotatedClass {\n\t}\n\n\t@Component\n\tstatic class AnnotatedClass {\n\n\t\tclass NonAnnotatedInnerClass {\n\t\t}\n\n\t\tstatic class NonAnnotatedStaticNestedClass {\n\t\t}\n\t}\n\n\tinterface NonAnnotatedInterface {\n\t}\n\n\t@TransactionalComponent\n\tstatic class TransactionalComponentClass {\n\t}\n\n\tstatic class SubTransactionalComponentClass extends TransactionalComponentClass {\n\t}\n\n\t@ComposedTransactionalComponent\n\tstatic class ComposedTransactionalComponentClass {\n\t}\n\n\t@AliasedTransactionalComponent\n\tstatic class AliasedTransactionalComponentClass {\n\t}\n\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface AliasedTransactional {\n\n\t\t@AliasFor(attribute = \"qualifier\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tString qualifier() default \"\";\n\t}\n\n\t@Transactional(qualifier = \"composed1\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@Inherited\n\t@interface InheritedComposed {\n\t}\n\n\t@Transactional(qualifier = \"composed2\", readOnly = true)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface Composed {\n\t}\n\n\t@Transactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxComposedWithOverride {\n\n\t\tString qualifier() default \"txMgr\";\n\t}\n\n\t@Transactional(\"TxInheritedComposed\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxInheritedComposed {\n\t}\n\n\t@Transactional(\"TxComposed\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxComposed {\n\t}\n\n\t@AliasedTransactional(value = \"aliasForQualifier\")\n\t@Component\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedTransactionalComponent {\n\t}\n\n\t@AliasedTransactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MyAliasedTransactional {\n\n\t\t@AliasFor(annotation = AliasedTransactional.class, attribute = \"value\")\n\t\tString value() default \"defaultTransactionManager\";\n\t}\n\n\t@MyAliasedTransactional(\"anotherTransactionManager\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@interface ComposedMyAliasedTransactional {\n\t}\n\n\t@ComposedMyAliasedTransactional\n\tstatic class ComposedTransactionalClass {\n\t}\n\n\t@AliasedTransactional(\"meta\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaAliasedTransactional {\n\t}\n\n\t@MetaAliasedTransactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMetaAliasedTransactional {\n\t}\n\n\t@MetaMetaAliasedTransactional\n\tstatic class MetaMetaAliasedTransactionalClass {\n\t}\n\n\t@TxComposedWithOverride\n\t// Override default \"txMgr\" from @TxComposedWithOverride with \"localTxMgr\"\n\t@Transactional(qualifier = \"localTxMgr\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface MetaAndLocalTxConfig {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestPropertySource {\n\n\t\t@AliasFor(\"locations\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] locations() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContextConfiguration {\n\n\t\t@AliasFor(attribute = \"locations\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tString[] locations() default {};\n\n\t\tClass<?>[] classes() default {};\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionBasedComposedContextConfiguration {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] locations() default {};\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class)\n\t\tClass<?>[] classes() default {};\n\t}\n\n\t@ContextConfiguration(value = \"duplicateDeclaration\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface InvalidConventionBasedComposedContextConfiguration {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] locations();\n\t}\n\n\t/**\n\t * This hybrid approach for annotation attribute overrides with transitive implicit\n\t * aliases is unsupported. See SPR-13554 for details.\n\t */\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface HalfConventionBasedAndHalfAliasedComposedContextConfiguration {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] locations() default {};\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles() default {};\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles();\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedValueComposedContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"value\")\n\t\tString[] locations();\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] groovyScripts() default {};\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlFiles() default {};\n\n\t\t// intentionally omitted: attribute = \"locations\"\n\t\t@AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] locations() default {};\n\n\t\t// intentionally omitted: attribute = \"locations\" (SPR-14069)\n\t\t@AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] value() default {};\n\t}\n\n\t@ImplicitAliasesContextConfiguration(xmlFiles = { \"A.xml\", \"B.xml\" })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedImplicitAliasesContextConfiguration {\n\t}\n\n\t@ImplicitAliasesContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesContextConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"xmlFiles\")\n\t\tString[] xml() default {};\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\n\t\tString[] groovy() default {};\n\t}\n\n\t@ImplicitAliasesContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SingleLocationTransitiveImplicitAliasesContextConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"xmlFiles\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@ImplicitAliasesContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesWithSkippedLevelContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xml() default {};\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\n\t\tString[] groovy() default {};\n\t}\n\n\t@ImplicitAliasesContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\n\t\tString groovy() default \"\";\n\t}\n\n\t/**\n\t * Although the configuration declares an explicit value for 'value' and requires a\n\t * value for the aliased 'locations', this does not result in an error since\n\t * 'locations' effectively shadows the 'value' attribute (which cannot be set via the\n\t * composed annotation anyway). If 'value' were not shadowed, such a declaration would\n\t * not make sense.\n\t */\n\t@ContextConfiguration(value = \"duplicateDeclaration\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ShadowedAliasComposedContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles();\n\t}\n\n\t@ContextConfiguration(locations = \"shadowed.xml\")\n\t@TestPropertySource(locations = \"test.properties\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfigurationAndTestPropertySource {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles() default \"default.xml\";\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SpringApplicationConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] locations() default {};\n\n\t\t// Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class, attribute = \"classes\")\n\t\t@AliasFor(\"value\")\n\t\tClass<?>[] classes() default {};\n\n\t\t// Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class, attribute = \"classes\")\n\t\t@AliasFor(\"classes\")\n\t\tClass<?>[] value() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScan {\n\n\t\t@AliasFor(\"basePackages\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] basePackages() default {};\n\n\t\tFilter[] excludeFilters() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({})\n\t@interface Filter {\n\n\t\tString pattern();\n\t}\n\n\t@ComponentScan(excludeFilters = { @Filter(pattern = \"*Test\"),\n\t\t@Filter(pattern = \"*Tests\") })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestComponentScan {\n\n\t\t@AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\n\t\tString[] packages();\n\t}\n\n\t@ComponentScan\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionBasedSinglePackageComponentScan {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ComponentScan.class)\n\t\tString basePackages();\n\t}\n\n\t@ComponentScan\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForBasedSinglePackageComponentScan {\n\n\t\t@AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\n\t\tString pkg();\n\t}\n\n\t@Transactional\n\tstatic class ClassWithInheritedAnnotation {\n\t}\n\n\t@Composed\n\tstatic class SubClassWithInheritedAnnotation extends ClassWithInheritedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedAnnotation\n\t\t\textends SubClassWithInheritedAnnotation {\n\t}\n\n\t@InheritedComposed\n\tstatic class ClassWithInheritedComposedAnnotation {\n\t}\n\n\t@Composed\n\tstatic class SubClassWithInheritedComposedAnnotation\n\t\t\textends ClassWithInheritedComposedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedComposedAnnotation\n\t\t\textends SubClassWithInheritedComposedAnnotation {\n\t}\n\n\t@MetaAndLocalTxConfig\n\tstatic class MetaAndLocalTxConfigClass {\n\t}\n\n\t@Transactional(\"TxConfig\")\n\tstatic class TxConfig {\n\t}\n\n\t@Transactional(\"DerivedTxConfig\")\n\tstatic class DerivedTxConfig extends TxConfig {\n\t}\n\n\t@TxInheritedComposed\n\t@TxComposed\n\tstatic class TxFromMultipleComposedAnnotations {\n\t}\n\n\t@Transactional\n\tinterface InterfaceWithInheritedAnnotation {\n\n\t\t@Order\n\t\tvoid handleFromInterface();\n\t}\n\n\tabstract static class AbstractClassWithInheritedAnnotation<T>\n\t\t\timplements InterfaceWithInheritedAnnotation {\n\n\t\t@Transactional\n\t\tpublic abstract void handle();\n\n\t\t@Transactional\n\t\tpublic void handleParameterized(T t) {\n\t\t}\n\t}\n\n\tstatic class ConcreteClassWithInheritedAnnotation\n\t\t\textends AbstractClassWithInheritedAnnotation<String> {\n\n\t\t@Override\n\t\tpublic void handle() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleParameterized(String s) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleFromInterface() {\n\t\t}\n\t}\n\n\tpublic interface GenericParameter<T> {\n\n\t\tT getFor(Class<T> cls);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class StringGenericParameter implements GenericParameter<String> {\n\n\t\t@Order\n\t\t@Override\n\t\tpublic String getFor(Class<String> cls) {\n\t\t\treturn \"foo\";\n\t\t}\n\n\t\tpublic String getFor(Integer integer) {\n\t\t\treturn \"foo\";\n\t\t}\n\t}\n\n\t@Transactional\n\tpublic interface InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubInheritedAnnotationInterface\n\t\t\textends InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubInheritedAnnotationInterface\n\t\t\textends SubInheritedAnnotationInterface {\n\t}\n\n\t@Order\n\tpublic interface NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubNonInheritedAnnotationInterface\n\t\t\textends NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubNonInheritedAnnotationInterface\n\t\t\textends SubNonInheritedAnnotationInterface {\n\t}\n\n\t@ConventionBasedComposedContextConfiguration(locations = \"explicitDeclaration\")\n\tstatic class ConventionBasedComposedContextConfigurationClass {\n\t}\n\n\t@InvalidConventionBasedComposedContextConfiguration(locations = \"requiredLocationsDeclaration\")\n\tstatic class InvalidConventionBasedComposedContextConfigurationClass {\n\t}\n\n\t@HalfConventionBasedAndHalfAliasedComposedContextConfiguration(xmlConfigFiles = \"explicitDeclaration\")\n\tstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass1 {\n\t}\n\n\t@HalfConventionBasedAndHalfAliasedComposedContextConfiguration(locations = \"explicitDeclaration\")\n\tstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass2 {\n\t}\n\n\t@AliasedComposedContextConfiguration(xmlConfigFiles = \"test.xml\")\n\tstatic class AliasedComposedContextConfigurationClass {\n\t}\n\n\t@AliasedValueComposedContextConfiguration(locations = \"test.xml\")\n\tstatic class AliasedValueComposedContextConfigurationClass {\n\t}\n\n\t@ImplicitAliasesContextConfiguration(\"foo.xml\")\n\tstatic class ImplicitAliasesContextConfigurationClass1 {\n\t}\n\n\t@ImplicitAliasesContextConfiguration(locations = \"bar.xml\")\n\tstatic class ImplicitAliasesContextConfigurationClass2 {\n\t}\n\n\t@ImplicitAliasesContextConfiguration(xmlFiles = \"baz.xml\")\n\tstatic class ImplicitAliasesContextConfigurationClass3 {\n\t}\n\n\t@TransitiveImplicitAliasesContextConfiguration(groovy = \"test.groovy\")\n\tstatic class TransitiveImplicitAliasesContextConfigurationClass {\n\t}\n\n\t@SingleLocationTransitiveImplicitAliasesContextConfiguration(groovy = \"test.groovy\")\n\tstatic class SingleLocationTransitiveImplicitAliasesContextConfigurationClass {\n\t}\n\n\t@TransitiveImplicitAliasesWithSkippedLevelContextConfiguration(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass {\n\t}\n\n\t@SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfiguration(xml = \"test.xml\")\n\tstatic class SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass {\n\t}\n\n\t@ComposedImplicitAliasesContextConfiguration\n\tstatic class ComposedImplicitAliasesContextConfigurationClass {\n\t}\n\n\t@ShadowedAliasComposedContextConfiguration(xmlConfigFiles = \"test.xml\")\n\tstatic class ShadowedAliasComposedContextConfigurationClass {\n\t}\n\n\t@AliasedComposedContextConfigurationAndTestPropertySource(xmlConfigFiles = \"test.xml\")\n\tstatic class AliasedComposedContextConfigurationAndTestPropertySourceClass {\n\t}\n\n\t@ComponentScan(value = \"com.example.app.test\", basePackages = \"com.example.app.test\")\n\tstatic class ComponentScanWithBasePackagesAndValueAliasClass {\n\t}\n\n\t@TestComponentScan(packages = \"com.example.app.test\")\n\tstatic class TestComponentScanClass {\n\t}\n\n\t@ConventionBasedSinglePackageComponentScan(basePackages = \"com.example.app.test\")\n\tstatic class ConventionBasedSinglePackageComponentScanClass {\n\t}\n\n\t@AliasForBasedSinglePackageComponentScan(pkg = \"com.example.app.test\")\n\tstatic class AliasForBasedSinglePackageComponentScanClass {\n\t}\n\n\t@SpringApplicationConfiguration(Number.class)\n\tstatic class SpringApplicationConfigurationClass {\n\t}\n\n\t@Resource(name = \"x\")\n\tstatic class ResourceHolder {\n\t}\n\n\tinterface TransactionalService {\n\n\t\t@Transactional\n\t\tvoid doIt();\n\t}\n\n\tclass TransactionalServiceImpl implements TransactionalService {\n\n\t\t@Override\n\t\tpublic void doIt() {\n\t\t}\n\t}\n\n\t@Component(\"meta1\")\n\t@Order\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Meta1 {\n\t}\n\n\t@Component(\"meta2\")\n\t@Transactional(readOnly = true)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Meta2 {\n\t}\n\n\t@Meta2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMeta {\n\t}\n\n\t@MetaMeta\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMetaMeta {\n\t}\n\n\t@MetaCycle3\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle1 {\n\t}\n\n\t@MetaCycle1\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle2 {\n\t}\n\n\t@MetaCycle2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle3 {\n\t}\n\n\t@Meta1\n\tinterface InterfaceWithMetaAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface\n\t\t\timplements InterfaceWithMetaAnnotation {\n\t}\n\n\t@Meta1\n\tstatic class ClassWithInheritedMetaAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class SubClassWithInheritedMetaAnnotation\n\t\t\textends ClassWithInheritedMetaAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedMetaAnnotation\n\t\t\textends SubClassWithInheritedMetaAnnotation {\n\t}\n\n\t@MetaMeta\n\tstatic class MetaMetaAnnotatedClass {\n\t}\n\n\t@MetaMetaMeta\n\tstatic class MetaMetaMetaAnnotatedClass {\n\t}\n\n\t@MetaCycle3\n\tstatic class MetaCycleAnnotatedClass {\n\t}\n\n\tinterface AnnotatedInterface {\n\n\t\t@Order(0)\n\t\tvoid fromInterfaceImplementedByRoot();\n\t}\n\n\tinterface NullableAnnotatedInterface {\n\n\t\t@Nullable String fromInterfaceImplementedByRoot();\n\t}\n\n\tstatic class Root implements AnnotatedInterface {\n\n\t\t@Order(27)\n\t\tpublic void annotatedOnRoot() {\n\t\t}\n\n\t\t@Meta1\n\t\tpublic void metaAnnotatedOnRoot() {\n\t\t}\n\n\t\tpublic void overrideToAnnotate() {\n\t\t}\n\n\t\t@Order(27)\n\t\tpublic void overrideWithoutNewAnnotation() {\n\t\t}\n\n\t\tpublic void notAnnotated() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void fromInterfaceImplementedByRoot() {\n\t\t}\n\t}\n\n\tpublic static class Leaf extends Root {\n\n\t\t@Order(25)\n\t\tpublic void annotatedOnLeaf() {\n\t\t}\n\n\t\t@Meta1\n\t\tpublic void metaAnnotatedOnLeaf() {\n\t\t}\n\n\t\t@MetaMeta\n\t\tpublic void metaMetaAnnotatedOnLeaf() {\n\t\t}\n\n\t\t@Override\n\t\t@Order(1)\n\t\tpublic void overrideToAnnotate() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void overrideWithoutNewAnnotation() {\n\t\t}\n\t}\n\n\tpublic abstract static class SimpleGeneric<T> {\n\n\t\t@Order(1)\n\t\tpublic abstract void something(T arg);\n\n\t}\n\n\tpublic static class TransactionalStringGeneric extends SimpleGeneric<String> {\n\n\t\t@Override\n\t\t@Transactional\n\t\tpublic void something(final String arg) {\n\t\t}\n\t}\n\n\t@Transactional\n\tpublic static class InheritedAnnotationClass {\n\t}\n\n\tpublic static class SubInheritedAnnotationClass extends InheritedAnnotationClass {\n\t}\n\n\t@Order\n\tpublic static class NonInheritedAnnotationClass {\n\t}\n\n\tpublic static class SubNonInheritedAnnotationClass\n\t\t\textends NonInheritedAnnotationClass {\n\t}\n\n\t@Transactional\n\tpublic static class TransactionalClass {\n\t}\n\n\t@Order\n\tpublic static class TransactionalAndOrderedClass extends TransactionalClass {\n\t}\n\n\tpublic static class SubTransactionalAndOrderedClass\n\t\t\textends TransactionalAndOrderedClass {\n\t}\n\n\tpublic interface InterfaceWithAnnotatedMethod {\n\n\t\t@Order\n\t\tvoid foo();\n\t}\n\n\tpublic static class ImplementsInterfaceWithAnnotatedMethod\n\t\t\timplements InterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic static class SubOfImplementsInterfaceWithAnnotatedMethod\n\t\t\textends ImplementsInterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic abstract static class AbstractDoesNotImplementInterfaceWithAnnotatedMethod\n\t\t\timplements InterfaceWithAnnotatedMethod {\n\t}\n\n\tpublic static class SubOfAbstractImplementsInterfaceWithAnnotatedMethod\n\t\t\textends AbstractDoesNotImplementInterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic interface InterfaceWithGenericAnnotatedMethod<T> {\n\n\t\t@Order\n\t\tvoid foo(T t);\n\t}\n\n\tpublic static class ImplementsInterfaceWithGenericAnnotatedMethod\n\t\t\timplements InterfaceWithGenericAnnotatedMethod<String> {\n\n\t\t@Override\n\t\tpublic void foo(String t) {\n\t\t}\n\t}\n\n\tpublic abstract static class BaseClassWithGenericAnnotatedMethod<T> {\n\n\t\t@Order\n\t\tabstract void foo(T t);\n\t}\n\n\tpublic static class ExtendsBaseClassWithGenericAnnotatedMethod\n\t\t\textends BaseClassWithGenericAnnotatedMethod<String> {\n\n\t\t@Override\n\t\tpublic void foo(String t) {\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface MyRepeatableContainer {\n\n\t\tMyRepeatable[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@Repeatable(MyRepeatableContainer.class)\n\t@interface MyRepeatable {\n\n\t\tString value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta1\")\n\t@interface MyRepeatableMeta1 {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta2\")\n\t@interface MyRepeatableMeta2 {\n\t}\n\n\tinterface InterfaceWithRepeated {\n\n\t\t@MyRepeatable(\"A\")\n\t\t@MyRepeatableContainer({ @MyRepeatable(\"B\"), @MyRepeatable(\"C\") })\n\t\t@MyRepeatableMeta1\n\t\tvoid foo();\n\t}\n\n\t@MyRepeatable(\"A\")\n\t@MyRepeatableContainer({ @MyRepeatable(\"B\"), @MyRepeatable(\"C\") })\n\t@MyRepeatableMeta1\n\tstatic class MyRepeatableClass {\n\t}\n\n\tstatic class SubMyRepeatableClass extends MyRepeatableClass {\n\t}\n\n\t@MyRepeatable(\"X\")\n\t@MyRepeatableContainer({ @MyRepeatable(\"Y\"), @MyRepeatable(\"Z\") })\n\t@MyRepeatableMeta2\n\tstatic class SubMyRepeatableWithAdditionalLocalDeclarationsClass\n\t\t\textends MyRepeatableClass {\n\t}\n\n\tstatic class SubSubMyRepeatableWithAdditionalLocalDeclarationsClass\n\t\t\textends SubMyRepeatableWithAdditionalLocalDeclarationsClass {\n\t}\n\n\tenum RequestMethod {\n\t\tGET,\n\n\t\tPOST;\n\n\t\t/**\n\t\t * custom override to verify annotation toString() implementations.\n\t\t */\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"method: \" + name().toLowerCase();\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface RequestMapping {\n\n\t\tString name();\n\n\t\t@AliasFor(\"path\")\n\t\tString[] value() default \"\";\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tString[] path() default \"\";\n\n\t\tRequestMethod[] method() default {};\n\n\t\t// ---------------------------------------------------------------------\n\t\t// All remaining attributes declare default values that are used solely\n\t\t// for the purpose of testing the toString() implementations for annotations.\n\t\tClass<?> clazz() default RequestMethod.class;\n\t\tClass<?>[] classes() default {int[][].class, RequestMethod[].class};\n\n\t\tchar ch() default 'X';\n\t\tchar[] chars() default {'X'};\n\n\t\tbyte byteValue() default (byte) 0xFF;\n\t\tbyte[] bytes() default {(byte) 0xFF};\n\n\t\tshort shortValue() default 9876;\n\t\tshort[] shorts() default {9876};\n\n\t\tlong longValue() default 42L;\n\t\tlong[] longs() default {42L};\n\n\t\tfloat floatValue() default 3.14F;\n\t\tfloat[] floats() default {3.14F};\n\n\t\tdouble doubleValue() default 99.999D;\n\t\tdouble[] doubles() default {99.999D};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@RequestMapping(method = RequestMethod.GET, name = \"\")\n\t@interface GetMapping {\n\n\t\t@AliasFor(annotation = RequestMapping.class)\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = RequestMapping.class)\n\t\tString path() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@RequestMapping(method = RequestMethod.POST, name = \"\")\n\t@interface PostMapping {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = RequestMapping.class)\n\t\tString path() default \"\";\n\t}\n\n\t@Component(\"webController\")\n\tstatic class WebController {\n\n\t\t@RequestMapping(value = \"/test\", name = \"foo\")\n\t\tpublic void handleMappedWithValueAttribute() {\n\t\t}\n\n\t\t@RequestMapping(path = \"/test\", name = \"bar\", method = { RequestMethod.GET,\n\t\t\tRequestMethod.POST })\n\t\tpublic void handleMappedWithPathAttribute() {\n\t\t}\n\n\t\t@GetMapping(\"/test\")\n\t\tpublic void getMappedWithValueAttribute() {\n\t\t}\n\n\t\t@GetMapping(path = \"/test\")\n\t\tpublic void getMappedWithPathAttribute() {\n\t\t}\n\n\t\t@PostMapping(path = \"/test\")\n\t\tpublic void postMappedWithPathAttribute() {\n\t\t}\n\n\t\t@RequestMapping(value = \"/test\", path = \"/test\", name = \"bar\", method = {\n\t\t\tRequestMethod.GET, RequestMethod.POST })\n\t\tpublic void handleMappedWithSamePathAndValueAttributes() {\n\t\t}\n\n\t\t@RequestMapping(value = \"/enigma\", path = \"/test\", name = \"baz\")\n\t\tpublic void handleMappedWithDifferentPathAndValueAttributes() {\n\t\t}\n\t}\n\n\t/**\n\t * Mimics jakarta.persistence.Id\n\t */\n\t@Retention(RUNTIME)\n\t@interface Id {\n\t}\n\n\t/**\n\t * Mimics jakarta.persistence.GeneratedValue\n\t */\n\t@Retention(RUNTIME)\n\t@interface GeneratedValue {\n\t\tString strategy();\n\t}\n\n\t@Id\n\t@GeneratedValue(strategy = \"AUTO\")\n\tprivate Long getId() {\n\t\treturn 42L;\n\t}\n\n\t/**\n\t * Mimics org.springframework.security.config.annotation.authentication.configuration.EnableGlobalAuthentication\n\t */\n\t@Retention(RUNTIME)\n\t@interface EnableGlobalAuthentication {\n\t}\n\n\t/**\n\t * Mimics org.springframework.security.config.annotation.web.configuration.EnableWebSecurity\n\t */\n\t@Retention(RUNTIME)\n\t@EnableGlobalAuthentication\n\t@interface EnableWebSecurity {\n\t}\n\n\t@EnableWebSecurity\n\tstatic class SecurityConfig {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ ElementType.FIELD, ElementType.ANNOTATION_TYPE })\n\t@interface RootAnnotation {\n\t\tString value() default \"\";\n\t\tboolean flag() default false;\n\t}\n\n\t@RootAnnotation\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ ElementType.FIELD, ElementType.ANNOTATION_TYPE })\n\t@interface ComposedRootAnnotation {\n\n\t\t@AliasFor(annotation = RootAnnotation.class, attribute = \"flag\")\n\t\tboolean enabled() default true;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.FIELD)\n\t@ComposedRootAnnotation\n\t@interface DoublyComposedRootAnnotation {\n\t}\n\n\tclass DomainType {\n\n\t\t@RootAnnotation\n\t\tObject directlyAnnotated;\n\n\t\t@ComposedRootAnnotation\n\t\tObject metaAnnotated;\n\n\t\t@DoublyComposedRootAnnotation\n\t\tObject metaMetaAnnotated;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestConfiguration {\n\n\t\t@AliasFor(\"location\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString location() default \"\";\n\n\t\tClass<?> configClass() default Object.class;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Hierarchy {\n\n\t\tTestConfiguration[] value();\n\t}\n\n\t@Hierarchy({ @TestConfiguration(\"A\"), @TestConfiguration(location = \"B\") })\n\tstatic class HierarchyClass {\n\t}\n\n\t@TestConfiguration(\"simple.xml\")\n\tstatic class TestConfigurationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface CharsContainer {\n\n\t\t@AliasFor(attribute = \"chars\")\n\t\tchar[] value() default {};\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tchar[] chars() default {};\n\t}\n\n\t@CharsContainer(chars = { 'x', 'y', 'z' })\n\tstatic class GroupOfCharsClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMissingAttributeDeclaration {\n\n\t\t@AliasFor\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForWithMissingAttributeDeclaration\n\tstatic class AliasForWithMissingAttributeDeclarationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithDuplicateAttributeDeclaration {\n\n\t\t@AliasFor(value = \"bar\", attribute = \"baz\")\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForWithDuplicateAttributeDeclaration\n\tstatic class AliasForWithDuplicateAttributeDeclarationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForNonexistentAttribute {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForNonexistentAttribute\n\tstatic class AliasForNonexistentAttributeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithoutMirroredAliasFor {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"\";\n\n\t\tString bar() default \"\";\n\t}\n\n\t@AliasForWithoutMirroredAliasFor\n\tstatic class AliasForWithoutMirroredAliasForClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMirroredAliasForWrongAttribute {\n\n\t\t@AliasFor(attribute = \"bar\")\n\t\tString[] foo() default \"\";\n\n\t\t@AliasFor(attribute = \"quux\")\n\t\tString[] bar() default \"\";\n\t}\n\n\t@AliasForWithMirroredAliasForWrongAttribute\n\tstatic class AliasForWithMirroredAliasForWrongAttributeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForAttributeOfDifferentType {\n\n\t\t@AliasFor(\"bar\")\n\t\tString[] foo() default \"\";\n\n\t\t@AliasFor(\"foo\")\n\t\tboolean bar() default true;\n\t}\n\n\t@AliasForAttributeOfDifferentType\n\tstatic class AliasForAttributeOfDifferentTypeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMissingDefaultValues {\n\n\t\t@AliasFor(attribute = \"bar\")\n\t\tString foo();\n\n\t\t@AliasFor(attribute = \"foo\")\n\t\tString bar();\n\t}\n\n\t@AliasForWithMissingDefaultValues(foo = \"foo\", bar = \"bar\")\n\tstatic class AliasForWithMissingDefaultValuesClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForAttributeWithDifferentDefaultValue {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"X\";\n\n\t\t@AliasFor(\"foo\")\n\t\tString bar() default \"Z\";\n\t}\n\n\t@AliasForAttributeWithDifferentDefaultValue\n\tstatic class AliasForAttributeWithDifferentDefaultValueClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedTestConfigurationNotMetaPresent {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlConfigFile();\n\t}\n\n\t@AliasedComposedTestConfigurationNotMetaPresent(xmlConfigFile = \"test.xml\")\n\tstatic class AliasedComposedTestConfigurationNotMetaPresentClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlConfigFile();\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface ImplicitAliasesTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString groovyScript() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location1() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location2() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location3() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"configClass\")\n\t\tClass<?> configClass() default Object.class;\n\n\t\tString nonAliasedAttribute() default \"\";\n\t}\n\n\t@ImplicitAliasesTestConfiguration(groovyScript = \"groovyScript\")\n\tstatic class GroovyImplicitAliasesSimpleTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(xmlFile = \"xmlFile\")\n\tstatic class XmlImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(\"value\")\n\tstatic class ValueImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(location1 = \"location1\")\n\tstatic class Location1ImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(location2 = \"location2\")\n\tstatic class Location2ImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(location3 = \"location3\")\n\tstatic class Location3ImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class)\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class)\n\t\tString location() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration.class, attribute = \"location\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration(\"value\")\n\tstatic class ValueImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration(location = \"location\")\n\tstatic class LocationsImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration(xmlFile = \"xmlFile\")\n\tstatic class XmlFilesImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithMissingDefaultValuesTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location1();\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location2();\n\t}\n\n\t@ImplicitAliasesWithMissingDefaultValuesTestConfiguration(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithMissingDefaultValuesTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithDifferentDefaultValuesTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location1() default \"foo\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location2() default \"bar\";\n\t}\n\n\t@ImplicitAliasesWithDifferentDefaultValuesTestConfiguration(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithDifferentDefaultValuesTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithDuplicateValuesTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location1() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location2() default \"\";\n\t}\n\n\t@ImplicitAliasesWithDuplicateValuesTestConfiguration(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithDuplicateValuesTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesForAliasPairTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, value = \"value\")\n\t\tString groovyScript() default \"\";\n\t}\n\n\t@ImplicitAliasesForAliasPairTestConfiguration(xmlFile = \"test.xml\")\n\tstatic class ImplicitAliasesForAliasPairTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesTestConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesTestConfiguration.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesTestConfiguration.class, attribute = \"groovyScript\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@TransitiveImplicitAliasesTestConfiguration(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesForAliasPairTestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesForAliasPairTestConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesForAliasPairTestConfiguration.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesForAliasPairTestConfiguration.class, attribute = \"groovyScript\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@TransitiveImplicitAliasesForAliasPairTestConfiguration(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesForAliasPairTestConfigurationClass {\n\t}\n\n\t@ComponentScan(excludeFilters = { @Filter(pattern = \"*Foo\"),\n\t\t@Filter(pattern = \"*Bar\") })\n\tstatic class ComponentScanClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScanSingleFilter {\n\n\t\tFilter value();\n\t}\n\n\t@ComponentScanSingleFilter(@Filter(pattern = \"*Foo\"))\n\tstatic class ComponentScanSingleFilterClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnotationWithDefaults {\n\n\t\tString text() default \"enigma\";\n\n\t\tboolean predicate() default true;\n\n\t\tchar[] characters() default { 'a', 'b', 'c' };\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnotationWithoutDefaults {\n\n\t\tString text();\n\t}\n\n\t@TestConfiguration(value = \"foo\", location = \"bar\")\n\tinterface TestConfigurationMismatch {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface DefaultOverrideRoot {\n\n\t\tString text() default \"root\";\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideRoot\n\t@interface DefaultOverrideMeta {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideMeta\n\t@interface DefaultOverrideMetaMeta {\n\n\t\tString text() default \"metameta\";\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideMetaMeta\n\t@interface DefaultOverrideMetaMetaMeta {\n\n\t}\n\n\t@DefaultOverrideMetaMetaMeta\n\tstatic class DefaultOverrideClass {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideRoot\n\t@interface DefaultOverrideImplicitAlias {\n\n\t\t@AliasFor(annotation=DefaultOverrideRoot.class, attribute=\"text\")\n\t\tString text1() default \"alias\";\n\n\t\t@AliasFor(annotation=DefaultOverrideRoot.class, attribute=\"text\")\n\t\tString text2() default \"alias\";\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideImplicitAlias(text1=\"alias-meta-1\")\n\t@interface DefaultOverrideAliasImplicitMeta1 {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideImplicitAlias(text2=\"alias-meta-2\")\n\t@interface DefaultOverrideImplicitAliasMeta2 {\n\n\t}\n\n\t@DefaultOverrideAliasImplicitMeta1\n\tstatic class DefaultOverrideImplicitAliasMetaClass1 {\n\n\t}\n\n\t@DefaultOverrideImplicitAliasMeta2\n\tstatic class DefaultOverrideImplicitAliasMetaClass2 {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface DefaultOverrideExplicitAliasRoot {\n\n\t\t@AliasFor(\"value\")\n\t\tString text() default \"\";\n\n\t\t@AliasFor(\"text\")\n\t\tString value() default \"\";\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideExplicitAliasRoot(\"meta\")\n\t@interface DefaultOverrideExplicitAliasRootMeta {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideExplicitAliasRootMeta\n\t@interface DefaultOverrideExplicitAliasRootMetaMeta {\n\n\t}\n\n\t@DefaultOverrideExplicitAliasRootMetaMeta\n\tstatic class DefaultOverrideExplicitAliasRootMetaMetaClass {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ValueAttribute {\n\n\t\tString[] value();\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueAttribute(\"FromValueAttributeMeta\")\n\t@interface ValueAttributeMeta {\n\n\t\tString[] value() default {};\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueAttributeMeta(\"FromValueAttributeMetaMeta\")\n\t@interface ValueAttributeMetaMeta {\n\n\t}\n\n\t@ValueAttributeMetaMeta\n\tstatic class ValueAttributeMetaMetaClass {\n\n\t}\n\t// @formatter:on\n\n\tstatic void assertSynthesized(Annotation annotation) {\n\t\tassertThat(AnnotationUtils.isSynthesizedAnnotation(annotation)).as(\"synthesized annotation\").isTrue();\n\t}\n\n\tstatic void assertNotSynthesized(Annotation annotation) {\n\t\tassertThat(AnnotationUtils.isSynthesizedAnnotation(annotation)).as(\"synthesized annotation\").isFalse();\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.AliasedComposedContextConfigurationClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.AliasedComposedContextConfigurationClass",
    "headType": "class",
    "relation": "use",
    "tail": "@AliasedComposedContextConfiguration",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AliasedComposedContextConfigurationClass",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.stream.Stream;\n\nimport jakarta.annotation.Resource;\nimport org.jspecify.annotations.Nullable;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.AnnotationsScannerTests.Hello2Impl;\nimport org.springframework.core.annotation.AnnotationsScannerTests.TestAnnotation1;\nimport org.springframework.core.annotation.MergedAnnotation.Adapt;\nimport org.springframework.core.annotation.MergedAnnotations.Search;\nimport org.springframework.core.annotation.MergedAnnotations.SearchStrategy;\nimport org.springframework.core.annotation.subpackage.NonPublicAnnotatedClass;\nimport org.springframework.core.testfixture.ide.IdeUtils;\nimport org.springframework.core.testfixture.stereotype.Component;\nimport org.springframework.core.testfixture.stereotype.Indexed;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.MultiValueMap;\nimport org.springframework.util.ReflectionUtils;\n\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.assertj.core.api.Assertions.assertThatIllegalStateException;\nimport static org.assertj.core.api.Assertions.entry;\n\n/**\n * Tests for {@link MergedAnnotations} and {@link MergedAnnotation}. These tests\n * cover common usage scenarios and were mainly ported from the original\n * {@code AnnotationUtils} and {@code AnnotatedElementUtils} tests.\n *\n * @author Phillip Webb\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Chris Beams\n * @author Oleg Zhurakousky\n * @author Rossen Stoyanchev\n * @see MergedAnnotationsRepeatableAnnotationTests\n * @see MergedAnnotationClassLoaderTests\n */\nclass MergedAnnotationsTests {\n\n\t/**\n\t * Subset (and duplication) of other tests in {@link MergedAnnotationsTests}\n\t * that verify behavior of the fluent {@link Search} API.\n\t * @since 6.0\n\t */\n\t@Nested\n\tclass FluentSearchApiTests {\n\n\t\t@Test\n\t\tvoid preconditions() {\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> MergedAnnotations.search(null))\n\t\t\t\t\t.withMessage(\"SearchStrategy must not be null\");\n\n\t\t\tSearch search = MergedAnnotations.search(SearchStrategy.SUPERCLASS);\n\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> search.withEnclosingClasses(null))\n\t\t\t\t\t.withMessage(\"Predicate must not be null\");\n\t\t\tassertThatIllegalStateException()\n\t\t\t\t\t.isThrownBy(() -> search.withEnclosingClasses(Search.always))\n\t\t\t\t\t.withMessage(\"A custom 'searchEnclosingClass' predicate can only be combined with SearchStrategy.TYPE_HIERARCHY\");\n\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> search.withAnnotationFilter(null))\n\t\t\t\t\t.withMessage(\"AnnotationFilter must not be null\");\n\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> search.withRepeatableContainers(null))\n\t\t\t\t\t.withMessage(\"RepeatableContainers must not be null\");\n\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> search.from(null))\n\t\t\t\t\t.withMessage(\"AnnotatedElement must not be null\");\n\t\t}\n\n\t\t@Test\n\t\tvoid searchFromClassWithDefaultAnnotationFilterAndDefaultRepeatableContainers() {\n\t\t\tStream<Class<?>> classes = MergedAnnotations.search(SearchStrategy.DIRECT)\n\t\t\t\t\t.from(TransactionalComponent.class)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Transactional.class, Component.class, Indexed.class);\n\t\t}\n\n\t\t@Test\n\t\tvoid searchFromClassWithCustomAnnotationFilter() {\n\t\t\tStream<Class<?>> classes = MergedAnnotations.search(SearchStrategy.DIRECT)\n\t\t\t\t\t.withAnnotationFilter(annotationName -> annotationName.endsWith(\"Indexed\"))\n\t\t\t\t\t.from(TransactionalComponent.class)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Transactional.class, Component.class);\n\t\t}\n\n\t\t@Test\n\t\tvoid searchFromClassWithCustomRepeatableContainers() {\n\t\t\tassertThat(MergedAnnotations.from(HierarchyClass.class).stream(TestConfiguration.class)).isEmpty();\n\t\t\tRepeatableContainers containers = RepeatableContainers.of(TestConfiguration.class, Hierarchy.class);\n\n\t\t\tMergedAnnotations annotations = MergedAnnotations.search(SearchStrategy.DIRECT)\n\t\t\t\t\t.withRepeatableContainers(containers)\n\t\t\t\t\t.from(HierarchyClass.class);\n\t\t\tassertThat(annotations.stream(TestConfiguration.class))\n\t\t\t\t\t.map(annotation -> annotation.getString(\"location\"))\n\t\t\t\t\t.containsExactly(\"A\", \"B\");\n\t\t\tassertThat(annotations.stream(TestConfiguration.class))\n\t\t\t\t\t.map(annotation -> annotation.getString(\"value\"))\n\t\t\t\t\t.containsExactly(\"A\", \"B\");\n\t\t}\n\n\t\t/**\n\t\t * @since 6.0\n\t\t */\n\t\t@Test\n\t\tvoid searchFromNonAnnotatedInnerClassWithAnnotatedEnclosingClassWithEnclosingClassPredicates() {\n\t\t\tClass<?> testCase = AnnotatedClass.NonAnnotatedInnerClass.class;\n\t\t\tSearch search = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY);\n\n\t\t\tassertThat(search.from(testCase).stream()).isEmpty();\n\t\t\tassertThat(search.withEnclosingClasses(Search.never).from(testCase).stream()).isEmpty();\n\t\t\tassertThat(search.withEnclosingClasses(ClassUtils::isStaticClass).from(testCase).stream()).isEmpty();\n\n\t\t\tStream<Class<?>> classes = search.withEnclosingClasses(ClassUtils::isInnerClass)\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class, Indexed.class);\n\n\t\t\tclasses = search.withEnclosingClasses(Search.always)\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class, Indexed.class);\n\n\t\t\tclasses = search.withEnclosingClasses(ClassUtils::isInnerClass)\n\t\t\t\t\t.withRepeatableContainers(RepeatableContainers.none())\n\t\t\t\t\t.withAnnotationFilter(annotationName -> annotationName.endsWith(\"Indexed\"))\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class);\n\t\t}\n\n\t\t/**\n\t\t * @since 6.0\n\t\t */\n\t\t@Test\n\t\tvoid searchFromNonAnnotatedStaticNestedClassWithAnnotatedEnclosingClassWithEnclosingClassPredicates() {\n\t\t\tClass<?> testCase = AnnotatedClass.NonAnnotatedStaticNestedClass.class;\n\t\t\tSearch search = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY);\n\n\t\t\tassertThat(search.from(testCase).stream()).isEmpty();\n\t\t\tassertThat(search.withEnclosingClasses(Search.never).from(testCase).stream()).isEmpty();\n\t\t\tassertThat(search.withEnclosingClasses(ClassUtils::isInnerClass).from(testCase).stream()).isEmpty();\n\n\t\t\tStream<Class<?>> classes = search.withEnclosingClasses(ClassUtils::isStaticClass)\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class, Indexed.class);\n\n\t\t\tclasses = search.withEnclosingClasses(Search.always)\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class, Indexed.class);\n\t\t}\n\t}\n\n\n\t@Nested\n\tclass ConventionBasedAnnotationAttributeOverrideTests {\n\n\t\t@Test\n\t\tvoid getWithInheritedAnnotationsAttributesWithConventionBasedComposedAnnotation() {\n\t\t\tMergedAnnotation<?> annotation =\n\t\t\t\t\tMergedAnnotations.from(ConventionBasedComposedContextConfigurationClass.class,\n\t\t\t\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\t\tassertThat(annotation.isPresent()).isTrue();\n\t\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"explicitDeclaration\");\n\t\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"explicitDeclaration\");\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithInheritedAnnotationsFromHalfConventionBasedAndHalfAliasedComposedAnnotation1() {\n\t\t\t// SPR-13554: convention mapping mixed with AliasFor annotations\n\t\t\t// xmlConfigFiles can be used because it has an AliasFor annotation\n\t\t\tMergedAnnotation<?> annotation =\n\t\t\t\t\tMergedAnnotations.from(HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass1.class,\n\t\t\t\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"explicitDeclaration\");\n\t\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"explicitDeclaration\");\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithInheritedAnnotationsFromHalfConventionBasedAndHalfAliasedComposedAnnotation2() {\n\t\t\t// SPR-13554: convention mapping mixed with AliasFor annotations\n\t\t\t// locations doesn't apply because it has no AliasFor annotation\n\t\t\tMergedAnnotation<?> annotation =\n\t\t\t\t\tMergedAnnotations.from(HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass2.class,\n\t\t\t\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\t\tassertThat(annotation.getStringArray(\"locations\")).isEmpty();\n\t\t\tassertThat(annotation.getStringArray(\"value\")).isEmpty();\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithInheritedAnnotationsFromInvalidConventionBasedComposedAnnotation() {\n\t\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(InvalidConventionBasedComposedContextConfigurationClass.class,\n\t\t\t\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class));\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithTypeHierarchyWithSingleElementOverridingAnArrayViaConvention() {\n\t\t\ttestGetWithTypeHierarchy(ConventionBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithTypeHierarchyWithLocalAliasesThatConflictWithAttributesInMetaAnnotationByConvention() {\n\t\t\tMergedAnnotation<?> annotation =\n\t\t\t\t\tMergedAnnotations.from(SpringApplicationConfigurationClass.class, SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t\t\t\t.get(ContextConfiguration.class);\n\t\t\tassertThat(annotation.getStringArray(\"locations\")).isEmpty();\n\t\t\tassertThat(annotation.getStringArray(\"value\")).isEmpty();\n\t\t\tassertThat(annotation.getClassArray(\"classes\")).containsExactly(Number.class);\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithTypeHierarchyOnMethodWithSingleElementOverridingAnArrayViaConvention() throws Exception {\n\t\t\ttestGetWithTypeHierarchyWebMapping(WebController.class.getMethod(\"postMappedWithPathAttribute\"));\n\t\t}\n\t}\n\n\n\t@Test\n\tvoid fromPreconditions() {\n\t\tSearchStrategy strategy = SearchStrategy.DIRECT;\n\t\tRepeatableContainers containers = RepeatableContainers.standardRepeatables();\n\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(getClass(), strategy, null, AnnotationFilter.PLAIN))\n\t\t\t\t.withMessage(\"RepeatableContainers must not be null\");\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(getClass(), strategy, containers, null))\n\t\t\t\t.withMessage(\"AnnotationFilter must not be null\");\n\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(getClass(), new Annotation[0], null, AnnotationFilter.PLAIN))\n\t\t\t\t.withMessage(\"RepeatableContainers must not be null\");\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(getClass(), new Annotation[0], containers, null))\n\t\t\t\t.withMessage(\"AnnotationFilter must not be null\");\n\t}\n\n\t@Test\n\tvoid streamWhenFromNonAnnotatedClass() {\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class).stream(TransactionalComponent.class)).isEmpty();\n\t}\n\n\t@Test\n\tvoid streamWhenFromClassWithMetaDepth1() {\n\t\tStream<Class<?>> classes = MergedAnnotations.from(TransactionalComponent.class)\n\t\t\t\t.stream().map(MergedAnnotation::getType);\n\t\tassertThat(classes).containsExactly(Transactional.class, Component.class, Indexed.class);\n\t}\n\n\t@Test\n\tvoid streamWhenFromClassWithMetaDepth2() {\n\t\tStream<Class<?>> classes = MergedAnnotations.from(ComposedTransactionalComponent.class)\n\t\t\t\t.stream().map(MergedAnnotation::getType);\n\t\tassertThat(classes).containsExactly(TransactionalComponent.class,\n\t\t\t\tTransactional.class, Component.class, Indexed.class);\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromNonAnnotatedClass() {\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class).isPresent(Transactional.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromAnnotationClassWithMetaDepth0() {\n\t\tassertThat(MergedAnnotations.from(TransactionalComponent.class).isPresent(TransactionalComponent.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromAnnotationClassWithMetaDepth1() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(TransactionalComponent.class);\n\t\tassertThat(annotations.isPresent(Transactional.class)).isTrue();\n\t\tassertThat(annotations.isPresent(Component.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromAnnotationClassWithMetaDepth2() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponent.class);\n\t\tassertThat(annotations.isPresent(Transactional.class)).isTrue();\n\t\tassertThat(annotations.isPresent(Component.class)).isTrue();\n\t\tassertThat(annotations.isPresent(ComposedTransactionalComponent.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromClassWithMetaDepth0() {\n\t\tassertThat(MergedAnnotations.from(TransactionalComponentClass.class).isPresent(TransactionalComponent.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromSubclassWithMetaDepth0() {\n\t\tassertThat(MergedAnnotations.from(SubTransactionalComponentClass.class).isPresent(TransactionalComponent.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromClassWithMetaDepth1() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(TransactionalComponentClass.class);\n\t\tassertThat(annotations.isPresent(Transactional.class)).isTrue();\n\t\tassertThat(annotations.isPresent(Component.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromClassWithMetaDepth2() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\n\t\tassertThat(annotations.isPresent(Transactional.class)).isTrue();\n\t\tassertThat(annotations.isPresent(Component.class)).isTrue();\n\t\tassertThat(annotations.isPresent(ComposedTransactionalComponent.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid getParent() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\n\t\tassertThat(annotations.get(TransactionalComponent.class).getMetaSource().getType())\n\t\t\t\t.isEqualTo(ComposedTransactionalComponent.class);\n\t}\n\n\t@Test\n\tvoid getRootWhenNotDirect() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\n\t\tMergedAnnotation<?> annotation = annotations.get(TransactionalComponent.class);\n\t\tassertThat(annotation.getDistance()).isGreaterThan(0);\n\t\tassertThat(annotation.getRoot().getType()).isEqualTo(ComposedTransactionalComponent.class);\n\t}\n\n\t@Test\n\tvoid getRootWhenDirect() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\n\t\tMergedAnnotation<?> annotation = annotations.get(ComposedTransactionalComponent.class);\n\t\tassertThat(annotation.getDistance()).isEqualTo(0);\n\t\tassertThat(annotation.getRoot()).isSameAs(annotation);\n\t}\n\n\t@Test\n\tvoid getMetaTypes() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(ComposedTransactionalComponentClass.class)\n\t\t\t\t.get(TransactionalComponent.class);\n\t\tassertThat(annotation.getMetaTypes()).containsExactly(\n\t\t\t\tComposedTransactionalComponent.class, TransactionalComponent.class);\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFromNonAnnotatedClass() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(NonAnnotatedClass.class)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).isEmpty();\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFromClassWithLocalAnnotation() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(TxConfig.class)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"value\", List.of(\"TxConfig\")));\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFromClassWithLocalComposedAnnotationAndInheritedAnnotation() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"qualifier\", List.of(\"composed2\", \"transactionManager\")));\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"qualifier\", List.of(\"transactionManager\")));\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedComposedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"qualifier\", List.of(\"composed1\")));\n\t}\n\n\t/**\n\t * If the \"value\" entry contains both \"DerivedTxConfig\" AND \"TxConfig\", then\n\t * the algorithm is accidentally picking up shadowed annotations of the same\n\t * type within the class hierarchy. Such undesirable behavior would cause\n\t * the logic in\n\t * {@code org.springframework.context.annotation.ProfileCondition} to fail.\n\t */\n\t@Test\n\tvoid collectMultiValueMapFromClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tDerivedTxConfig.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"value\", List.of(\"DerivedTxConfig\")));\n\t}\n\n\t/**\n\t * Note: this functionality is required by\n\t * {@code org.springframework.context.annotation.ProfileCondition}.\n\t */\n\t@Test\n\tvoid collectMultiValueMapFromClassWithMultipleComposedAnnotations() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tTxFromMultipleComposedAnnotations.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"value\", List.of(\"TxInheritedComposed\", \"TxComposed\")));\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromClassWithLocalAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tTxConfig.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"TxConfig\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tDerivedTxConfig.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"DerivedTxConfig\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaCycleAnnotatedClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isFalse();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFavorsLocalComposedAnnotationOverInheritedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getBoolean(\"readOnly\")).isTrue();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getBoolean(\"readOnly\")).isFalse();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedComposedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getBoolean(\"readOnly\")).isFalse();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromInterfaceImplementedBySuperclass() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tConcreteClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isFalse();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tInheritedAnnotationInterface.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationInterface.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t}\n\n\n\t@Test\n\tvoid withInheritedAnnotationsFromAliasedComposedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tAliasedComposedContextConfigurationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"test.xml\");\n\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid withInheritedAnnotationsFromAliasedValueComposedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tAliasedValueComposedContextConfigurationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"test.xml\");\n\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromImplicitAliasesInMetaAnnotationOnComposedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tComposedImplicitAliasesContextConfigurationClass.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.get(ImplicitAliasesContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"groovyScripts\")).containsExactly(\"A.xml\", \"B.xml\");\n\t\tassertThat(annotation.getStringArray(\"xmlFiles\")).containsExactly(\"A.xml\", \"B.xml\");\n\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"A.xml\", \"B.xml\");\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"A.xml\", \"B.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromAliasedValueComposedAnnotation() {\n\t\ttestGetWithInherited(AliasedValueComposedContextConfigurationClass.class, \"test.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromImplicitAliasesForSameAttributeInComposedAnnotation() {\n\t\ttestGetWithInherited(ImplicitAliasesContextConfigurationClass1.class, \"foo.xml\");\n\t\ttestGetWithInherited(ImplicitAliasesContextConfigurationClass2.class, \"bar.xml\");\n\t\ttestGetWithInherited(ImplicitAliasesContextConfigurationClass3.class, \"baz.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromTransitiveImplicitAliases() {\n\t\ttestGetWithInherited(TransitiveImplicitAliasesContextConfigurationClass.class, \"test.groovy\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\ttestGetWithInherited(\n\t\t\t\tSingleLocationTransitiveImplicitAliasesContextConfigurationClass.class, \"test.groovy\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSkippedLevel() {\n\t\ttestGetWithInherited(\n\t\t\t\tTransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass.class, \"test.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSkippedLevelWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\ttestGetWithInherited(\n\t\t\t\tSingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass.class, \"test.xml\");\n\t}\n\n\tprivate void testGetWithInherited(Class<?> element, String... expected) {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(element, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.get(ContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"locations\")).isEqualTo(expected);\n\t\tassertThat(annotation.getStringArray(\"value\")).isEqualTo(expected);\n\t\tassertThat(annotation.getClassArray(\"classes\")).isEmpty();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromShadowedAliasComposedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tShadowedAliasComposedContextConfigurationClass.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.get(ContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"test.xml\");\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromSubInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromSubSubInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromSubNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromSubSubNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyInheritedFromInterfaceMethod() throws Exception {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleFromInterface\");\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test  // gh-31803\n\tvoid streamWithTypeHierarchyInheritedFromSuperInterfaceMethod() throws Exception {\n\t\tMethod method = Hello2Impl.class.getMethod(\"method\");\n\t\tlong count = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.from(method).stream(TestAnnotation1.class).count();\n\t\tassertThat(count).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyInheritedFromAbstractMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handle\");\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyInheritedFromBridgedMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleParameterized\", String.class);\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromBridgeMethod() {\n\t\tList<Method> methods = new ArrayList<>();\n\t\tReflectionUtils.doWithLocalMethods(StringGenericParameter.class, method -> {\n\t\t\tif (\"getFor\".equals(method.getName())) {\n\t\t\t\tmethods.add(method);\n\t\t\t}\n\t\t});\n\t\tMethod bridgeMethod = methods.get(0).getReturnType().equals(Object.class) ?\n\t\t\t\tmethods.get(0) : methods.get(1);\n\t\tMethod bridgedMethod = methods.get(0).getReturnType().equals(Object.class) ?\n\t\t\t\tmethods.get(1) : methods.get(0);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(bridgeMethod,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromClassWithMetaAndLocalTxConfig() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaAndLocalTxConfigClass.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getString(\"qualifier\")).isEqualTo(\"localTxMgr\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromClassWithAttributeAliasesInTargetAnnotation() {\n\t\tMergedAnnotation<AliasedTransactional> mergedAnnotation = MergedAnnotations.from(\n\t\t\t\tAliasedTransactionalComponentClass.class, SearchStrategy.TYPE_HIERARCHY).get(AliasedTransactional.class);\n\t\tAliasedTransactional synthesizedAnnotation = mergedAnnotation.synthesize();\n\t\tString qualifier = \"aliasForQualifier\";\n\t\tassertThat(mergedAnnotation.getString(\"value\")).isEqualTo(qualifier);\n\t\tassertThat(mergedAnnotation.getString(\"qualifier\")).isEqualTo(qualifier);\n\t\tassertThat(synthesizedAnnotation.value()).isEqualTo(qualifier);\n\t\tassertThat(synthesizedAnnotation.qualifier()).isEqualTo(qualifier);\n\t}\n\n\t@Test // gh-23767\n\tvoid getWithTypeHierarchyFromClassWithComposedMetaTransactionalAnnotation() {\n\t\tMergedAnnotation<AliasedTransactional> mergedAnnotation = MergedAnnotations.from(\n\t\t\t\tComposedTransactionalClass.class, SearchStrategy.TYPE_HIERARCHY).get(AliasedTransactional.class);\n\t\tassertThat(mergedAnnotation.getString(\"value\")).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(mergedAnnotation.getString(\"qualifier\")).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t@Test // gh-23767\n\tvoid getWithTypeHierarchyFromClassWithMetaMetaAliasedTransactional() {\n\t\tMergedAnnotation<AliasedTransactional> mergedAnnotation = MergedAnnotations.from(\n\t\t\t\tMetaMetaAliasedTransactionalClass.class, SearchStrategy.TYPE_HIERARCHY).get(AliasedTransactional.class);\n\t\tassertThat(mergedAnnotation.getString(\"value\")).isEqualTo(\"meta\");\n\t\tassertThat(mergedAnnotation.getString(\"qualifier\")).isEqualTo(\"meta\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromClassWithAttributeAliasInComposedAnnotationAndNestedAnnotationsInTargetAnnotation() {\n\t\tMergedAnnotation<?> annotation = testGetWithTypeHierarchy(\n\t\t\t\tTestComponentScanClass.class, \"com.example.app.test\");\n\t\tMergedAnnotation<Filter>[] excludeFilters = annotation.getAnnotationArray(\n\t\t\t\t\"excludeFilters\", Filter.class);\n\t\tassertThat(Arrays.stream(excludeFilters).map(\n\t\t\t\tfilter -> filter.getString(\"pattern\"))).containsExactly(\"*Test\", \"*Tests\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromClassWithBothAttributesOfAnAliasPairDeclared() {\n\t\ttestGetWithTypeHierarchy(ComponentScanWithBasePackagesAndValueAliasClass.class, \"com.example.app.test\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\ttestGetWithTypeHierarchy(AliasForBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\n\t}\n\n\tprivate MergedAnnotation<?> testGetWithTypeHierarchy(Class<?> element, String... expected) {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(element,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(ComponentScan.class);\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(expected);\n\t\tassertThat(annotation.getStringArray(\"basePackages\")).containsExactly(expected);\n\t\treturn annotation;\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyWhenMultipleMetaAnnotationsHaveClashingAttributeNames() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tAliasedComposedContextConfigurationAndTestPropertySourceClass.class, SearchStrategy.TYPE_HIERARCHY);\n\t\tMergedAnnotation<?> contextConfig = annotations.get(ContextConfiguration.class);\n\t\tassertThat(contextConfig.getStringArray(\"locations\")).containsExactly(\"test.xml\");\n\t\tassertThat(contextConfig.getStringArray(\"value\")).containsExactly(\"test.xml\");\n\t\tMergedAnnotation<?> testPropSource = annotations.get(TestPropertySource.class);\n\t\tassertThat(testPropSource.getStringArray(\"locations\")).containsExactly(\"test.properties\");\n\t\tassertThat(testPropSource.getStringArray(\"value\")).containsExactly(\"test.properties\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyOnMethodWithSingleElementOverridingAnArrayViaAliasFor() throws Exception {\n\t\ttestGetWithTypeHierarchyWebMapping(WebController.class.getMethod(\"getMappedWithValueAttribute\"));\n\t\ttestGetWithTypeHierarchyWebMapping(WebController.class.getMethod(\"getMappedWithPathAttribute\"));\n\t}\n\n\tprivate void testGetWithTypeHierarchyWebMapping(AnnotatedElement element) {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.get(RequestMapping.class);\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"/test\");\n\t\tassertThat(annotation.getStringArray(\"path\")).containsExactly(\"/test\");\n\t}\n\n\t@Test\n\tvoid getDirectWithJavaxAnnotationType() {\n\t\tassertThat(MergedAnnotations.from(ResourceHolder.class).get(Resource.class)\n\t\t\t\t.getString(\"name\")).isEqualTo(\"x\");\n\t}\n\n\t@Test\n\tvoid streamInheritedFromClassWithInterface() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class)).isEmpty();\n\t}\n\n\t@Test\n\tvoid streamTypeHierarchyFromClassWithInterface() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.stream(Transactional.class)).hasSize(1);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithMethodAnnotationOnLeaf() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"annotatedOnLeaf\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNotNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class)\n\t\t\t\t.getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithAnnotationOnMethodInInterface() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"fromInterfaceImplementedByRoot\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class)\n\t\t\t\t.getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithMetaAnnotationOnLeaf() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"metaAnnotatedOnLeaf\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class)\n\t\t\t\t.getDistance()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithMetaMetaAnnotationOnLeaf() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"metaMetaAnnotatedOnLeaf\");\n\t\tassertThat(method.getAnnotation(Component.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Component.class).getDistance()).isEqualTo(2);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tComponent.class).getDistance()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getWithAnnotationOnRoot() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"annotatedOnRoot\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNotNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithMetaAnnotationOnRoot() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"metaAnnotatedOnRoot\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithOnRootButOverridden() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"overrideWithoutNewAnnotation\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithNotAnnotated() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"notAnnotated\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(-1);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithBridgeMethod() throws Exception {\n\t\tMethod method = TransactionalStringGeneric.class.getMethod(\"something\", Object.class);\n\t\tassertThat(method.isBridge()).isTrue();\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t\t// As of JDK 8, invoking getAnnotation() on a bridge method actually finds an\n\t\t// annotation on its 'bridged' method [1]; however, the Eclipse compiler does\n\t\t// not support this [2]. Thus, we effectively ignore the following\n\t\t// assertion if the test is currently executing within the Eclipse IDE.\n\t\t//\n\t\t// [1] https://bugs.openjdk.java.net/browse/JDK-6695379\n\t\t// [2] https://bugs.eclipse.org/bugs/show_bug.cgi?id=495396\n\t\t//\n\t\tif (!IdeUtils.runningInEclipse()) {\n\t\t\tassertThat(method.getAnnotation(Transactional.class)).isNotNull();\n\t\t}\n\t\tassertThat(MergedAnnotations.from(method).get(\n\t\t\t\tTransactional.class).getDistance()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tTransactional.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithBridgedMethod() throws Exception {\n\t\tMethod method = TransactionalStringGeneric.class.getMethod(\"something\", String.class);\n\t\tassertThat(method.isBridge()).isFalse();\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t\tassertThat(method.getAnnotation(Transactional.class)).isNotNull();\n\t\tassertThat(MergedAnnotations.from(method).get(\n\t\t\t\tTransactional.class).getDistance()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tTransactional.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test // SPR-16060\n\tvoid getFromMethodWithGenericInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test // SPR-17146\n\tvoid getFromMethodWithGenericSuperclass() throws Exception {\n\t\tMethod method = ExtendsBaseClassWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithInterfaceOnSuper() throws Exception {\n\t\tMethod method = SubOfImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWhenInterfaceWhenSuperDoesNotImplementMethod() throws Exception {\n\t\tMethod method = SubOfAbstractImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverAnnotationsOnInterfaces() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tClassWithLocalMetaAnnotationAndMetaAnnotatedInterface.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedAnnotation.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getBoolean(\"readOnly\")).isTrue();\n\t}\n\n\t@Test\n\tvoid getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedComposedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedMetaAnnotation.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid getDirectFromClassgetDirectFromClassMetaMetaAnnotatedClass() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaMetaAnnotatedClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithMetaMetaMetaAnnotatedClass() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaMetaMetaAnnotatedClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\t// TransactionalClass is NOT annotated or meta-annotated with @Component\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(TransactionalClass.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.isPresent()).isFalse();\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaCycleAnnotatedClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.isPresent()).isFalse();\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithSubInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithSubSubInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithSubNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithSubSubNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubNonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getSuperClassForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isNull();\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isNull();\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isEqualTo(\n\t\t\t\t\t\t\t\tInheritedAnnotationInterface.class);\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isNull();\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isEqualTo(\n\t\t\t\t\t\t\t\tInheritedAnnotationClass.class);\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isEqualTo(\n\t\t\t\t\t\t\t\tInheritedAnnotationClass.class);\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but we should still find it on classes.\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(Order.class).getSource()).isEqualTo(\n\t\t\t\t\t\tNonInheritedAnnotationInterface.class);\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(Order.class).getSource()).isNull();\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(Order.class).getSource()).isEqualTo(\n\t\t\t\t\t\tNonInheritedAnnotationClass.class);\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(Order.class).getSource()).isEqualTo(\n\t\t\t\t\t\tNonInheritedAnnotationClass.class);\n\t}\n\n\t@Test\n\tvoid getSuperClassSourceForTypesWithSingleCandidateType() {\n\t\t// no class-level annotation\n\t\tList<Class<? extends Annotation>> transactionalCandidateList = Collections.singletonList(Transactional.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonAnnotatedInterface.class,\n\t\t\t\ttransactionalCandidateList)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonAnnotatedClass.class,\n\t\t\t\ttransactionalCandidateList)).isNull();\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationInterface.class,\n\t\t\t\ttransactionalCandidateList)).isEqualTo(\n\t\t\t\t\t\tInheritedAnnotationInterface.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationInterface.class,\n\t\t\t\ttransactionalCandidateList)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationClass.class,\n\t\t\t\ttransactionalCandidateList)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationClass.class,\n\t\t\t\ttransactionalCandidateList)).isEqualTo(InheritedAnnotationClass.class);\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but should still find it on classes.\n\t\tList<Class<? extends Annotation>> orderCandidateList = Collections.singletonList(\n\t\t\t\tOrder.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationInterface.class,\n\t\t\t\torderCandidateList)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationInterface.class,\n\t\t\t\torderCandidateList)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationClass.class,\n\t\t\t\torderCandidateList)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationClass.class,\n\t\t\t\torderCandidateList)).isEqualTo(NonInheritedAnnotationClass.class);\n\t}\n\n\t@Test\n\tvoid getSuperClassSourceForTypesWithMultipleCandidateTypes() {\n\t\tList<Class<? extends Annotation>> candidates = List.of(Transactional.class, Order.class);\n\t\t// no class-level annotation\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonAnnotatedInterface.class,\n\t\t\t\tcandidates)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonAnnotatedClass.class,\n\t\t\t\tcandidates)).isNull();\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationInterface.class,\n\t\t\t\tcandidates)).isEqualTo(InheritedAnnotationInterface.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationInterface.class,\n\t\t\t\tcandidates)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationClass.class,\n\t\t\t\tcandidates)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationClass.class,\n\t\t\t\tcandidates)).isEqualTo(InheritedAnnotationClass.class);\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but findAnnotationDeclaringClassForTypes() should still find it on\n\t\t// classes.\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationInterface.class,\n\t\t\t\tcandidates)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationInterface.class,\n\t\t\t\tcandidates)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationClass.class,\n\t\t\t\tcandidates)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationClass.class,\n\t\t\t\tcandidates)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\t// class hierarchy mixed with @Transactional and @Order declarations\n\t\tassertThat(getSuperClassSourceWithTypeIn(TransactionalClass.class,\n\t\t\t\tcandidates)).isEqualTo(TransactionalClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(TransactionalAndOrderedClass.class,\n\t\t\t\tcandidates)).isEqualTo(TransactionalAndOrderedClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubTransactionalAndOrderedClass.class,\n\t\t\t\tcandidates)).isEqualTo(TransactionalAndOrderedClass.class);\n\t}\n\n\tprivate Object getSuperClassSourceWithTypeIn(Class<?> clazz, List<Class<? extends Annotation>> annotationTypes) {\n\t\treturn MergedAnnotations.from(clazz, SearchStrategy.SUPERCLASS).stream().filter(\n\t\t\t\tMergedAnnotationPredicates.typeIn(annotationTypes).and(\n\t\t\t\t\t\tMergedAnnotation::isDirectlyPresent)).map(\n\t\t\t\t\t\t\t\tMergedAnnotation::getSource).findFirst().orElse(null);\n\t}\n\n\t@Test\n\tvoid isDirectlyPresentForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedInterface.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedInterface.class).isDirectlyPresent(\n\t\t\t\tTransactional.class)).isFalse();\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class).isDirectlyPresent(\n\t\t\t\tTransactional.class)).isFalse();\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationInterface.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isTrue();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tInheritedAnnotationInterface.class).isDirectlyPresent(\n\t\t\t\t\t\tTransactional.class)).isTrue();\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tSubInheritedAnnotationInterface.class).isDirectlyPresent(\n\t\t\t\t\t\tTransactional.class)).isFalse();\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationClass.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isTrue();\n\t\tassertThat(\n\t\t\t\tMergedAnnotations.from(InheritedAnnotationClass.class).isDirectlyPresent(\n\t\t\t\t\t\tTransactional.class)).isTrue();\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tSubInheritedAnnotationClass.class).isDirectlyPresent(\n\t\t\t\t\t\tTransactional.class)).isFalse();\n\t\t// non-inherited class-level annotation; note: @Order is not inherited\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class).get(\n\t\t\t\tOrder.class).isDirectlyPresent()).isTrue();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationInterface.class).isDirectlyPresent(\n\t\t\t\t\t\tOrder.class)).isTrue();\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class).get(\n\t\t\t\tOrder.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tSubNonInheritedAnnotationInterface.class).isDirectlyPresent(\n\t\t\t\t\t\tOrder.class)).isFalse();\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class).get(\n\t\t\t\tOrder.class).isDirectlyPresent()).isTrue();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationClass.class).isDirectlyPresent(\n\t\t\t\t\t\tOrder.class)).isTrue();\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class).get(\n\t\t\t\tOrder.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tSubNonInheritedAnnotationClass.class).isDirectlyPresent(\n\t\t\t\t\t\tOrder.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid getAggregateIndexForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(-1);\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(0);\n\t\t// Since we're not traversing interface hierarchies the following,\n\t\t// though perhaps counterintuitive, must be false:\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(1);\n\t\t// non-inherited class-level annotation; note: @Order is not inherited\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tOrder.class).getAggregateIndex()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tOrder.class).getAggregateIndex()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tOrder.class).getAggregateIndex()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tOrder.class).getAggregateIndex()).isEqualTo(-1);\n\t}\n\n\t@Test\n\tvoid getDirectWithoutAttributeAliases() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(WebController.class).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"webController\");\n\t}\n\n\t@Test\n\tvoid getDirectWithNestedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(ComponentScanClass.class).get(ComponentScan.class);\n\t\tMergedAnnotation<Filter>[] filters = annotation.getAnnotationArray(\"excludeFilters\", Filter.class);\n\t\tassertThat(Arrays.stream(filters).map(\n\t\t\t\tfilter -> filter.getString(\"pattern\"))).containsExactly(\"*Foo\", \"*Bar\");\n\t}\n\n\t@Test\n\tvoid getDirectWithAttributeAliases1() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method).get(RequestMapping.class);\n\t\tassertThat(annotation.getString(\"name\")).isEqualTo(\"foo\");\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"/test\");\n\t\tassertThat(annotation.getStringArray(\"path\")).containsExactly(\"/test\");\n\t}\n\n\t@Test\n\tvoid getDirectWithAttributeAliases2() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method).get(RequestMapping.class);\n\t\tassertThat(annotation.getString(\"name\")).isEqualTo(\"bar\");\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"/test\");\n\t\tassertThat(annotation.getStringArray(\"path\")).containsExactly(\"/test\");\n\t}\n\n\t@Test\n\tvoid getDirectWithAttributeAliasesWithDifferentValues() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithDifferentPathAndValueAttributes\");\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tMergedAnnotations.from(method).get(RequestMapping.class))\n\t\t\t\t.withMessageContaining(\"attribute 'path' and its alias 'value'\")\n\t\t\t\t.withMessageContaining(\"values of [{/test}] and [{/enigma}]\");\n\t}\n\n\t@Test\n\tvoid getValueFromAnnotation() throws Exception {\n\t\tMethod method = TransactionalStringGeneric.class.getMethod(\"something\", Object.class);\n\t\tMergedAnnotation<?> annotation =\n\t\t\t\tMergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getInt(\"value\")).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getValueFromNonPublicAnnotation() {\n\t\tAnnotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\n\t\tassertThat(declaredAnnotations).hasSize(1);\n\t\tAnnotation annotation = declaredAnnotations[0];\n\t\tMergedAnnotation<Annotation> mergedAnnotation = MergedAnnotation.from(annotation);\n\t\tassertThat(mergedAnnotation.getType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\n\t\tassertThat(mergedAnnotation.synthesize().annotationType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\n\t\tassertThat(mergedAnnotation.getInt(\"value\")).isEqualTo(42);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromAnnotation() throws Exception {\n\t\tMethod method = TransactionalStringGeneric.class.getMethod(\"something\", Object.class);\n\t\tMergedAnnotation<Order> annotation =\n\t\t\t\tMergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getDefaultValue(\"value\")).contains(Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromNonPublicAnnotation() {\n\t\tAnnotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\n\t\tassertThat(declaredAnnotations).hasSize(1);\n\t\tAnnotation declaredAnnotation = declaredAnnotations[0];\n\t\tMergedAnnotation<?> annotation = MergedAnnotation.from(declaredAnnotation);\n\t\tassertThat(annotation.getType().getName()).isEqualTo(\n\t\t\t\t\"org.springframework.core.annotation.subpackage.NonPublicAnnotation\");\n\t\tassertThat(annotation.getDefaultValue(\"value\")).contains(-1);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromAnnotationType() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotation.of(Order.class);\n\t\tassertThat(annotation.getDefaultValue(\"value\")).contains(Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnMethod() throws Exception {\n\t\tMethod method = InterfaceWithRepeated.class.getMethod(\"foo\");\n\t\tStream<MergedAnnotation<MyRepeatable>> annotations = MergedAnnotations.from(\n\t\t\t\tmethod, SearchStrategy.TYPE_HIERARCHY).stream(MyRepeatable.class);\n\t\tStream<String> values = annotations.map(\n\t\t\t\tannotation -> annotation.getString(\"value\"));\n\t\tassertThat(values).containsExactly(\"A\", \"B\", \"C\", \"meta1\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid streamRepeatableDeclaredOnClassWithAttributeAliases() {\n\t\tassertThat(MergedAnnotations.from(HierarchyClass.class).stream(\n\t\t\t\tTestConfiguration.class)).isEmpty();\n\t\tRepeatableContainers containers = RepeatableContainers.of(TestConfiguration.class,\n\t\t\t\tHierarchy.class);\n\t\tMergedAnnotations annotations = MergedAnnotations.from(HierarchyClass.class,\n\t\t\t\tSearchStrategy.DIRECT, containers, AnnotationFilter.NONE);\n\t\tassertThat(annotations.stream(TestConfiguration.class).map(\n\t\t\t\tannotation -> annotation.getString(\"location\"))).containsExactly(\"A\", \"B\");\n\t\tassertThat(annotations.stream(TestConfiguration.class).map(\n\t\t\t\tannotation -> annotation.getString(\"value\"))).containsExactly(\"A\", \"B\");\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnClass() {\n\t\tClass<?> element = MyRepeatableClass.class;\n\t\tString[] expectedValuesJava = { \"A\", \"B\", \"C\" };\n\t\tString[] expectedValuesSpring = { \"A\", \"B\", \"C\", \"meta1\" };\n\t\ttestRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnSuperclass() {\n\t\tClass<?> element = SubMyRepeatableClass.class;\n\t\tString[] expectedValuesJava = { \"A\", \"B\", \"C\" };\n\t\tString[] expectedValuesSpring = { \"A\", \"B\", \"C\", \"meta1\" };\n\t\ttestRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnClassAndSuperclass() {\n\t\tClass<?> element = SubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\n\t\tString[] expectedValuesJava = { \"X\", \"Y\", \"Z\" };\n\t\tString[] expectedValuesSpring = { \"X\", \"Y\", \"Z\", \"meta2\" };\n\t\ttestRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnMultipleSuperclasses() {\n\t\tClass<?> element = SubSubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\n\t\tString[] expectedValuesJava = { \"X\", \"Y\", \"Z\" };\n\t\tString[] expectedValuesSpring = { \"X\", \"Y\", \"Z\", \"meta2\" };\n\t\ttestRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamDirectRepeatablesDeclaredOnClass() {\n\t\tClass<?> element = MyRepeatableClass.class;\n\t\tString[] expectedValuesJava = { \"A\", \"B\", \"C\" };\n\t\tString[] expectedValuesSpring = { \"A\", \"B\", \"C\", \"meta1\" };\n\t\ttestRepeatables(SearchStrategy.DIRECT, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamDirectRepeatablesDeclaredOnSuperclass() {\n\t\tClass<?> element = SubMyRepeatableClass.class;\n\t\tString[] expectedValuesJava = {};\n\t\tString[] expectedValuesSpring = {};\n\t\ttestRepeatables(SearchStrategy.DIRECT, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\tprivate void testRepeatables(SearchStrategy searchStrategy, Class<?> element,\n\t\t\tString[] expectedValuesJava, String[] expectedValuesSpring) {\n\n\t\ttestJavaRepeatables(searchStrategy, element, expectedValuesJava);\n\t\ttestExplicitRepeatables(searchStrategy, element, expectedValuesSpring);\n\t\ttestStandardRepeatables(searchStrategy, element, expectedValuesSpring);\n\t}\n\n\tprivate void testJavaRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expected) {\n\t\tMyRepeatable[] annotations = searchStrategy == SearchStrategy.DIRECT ?\n\t\t\t\telement.getDeclaredAnnotationsByType(MyRepeatable.class) :\n\t\t\t\telement.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(Arrays.stream(annotations).map(MyRepeatable::value)).containsExactly(\n\t\t\t\texpected);\n\t}\n\n\tprivate void testExplicitRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expected) {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(element, searchStrategy,\n\t\t\t\tRepeatableContainers.of(MyRepeatable.class, MyRepeatableContainer.class),\n\t\t\t\tAnnotationFilter.PLAIN);\n\t\tStream<String> values = annotations.stream(MyRepeatable.class)\n\t\t\t\t.filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex))\n\t\t\t\t.map(annotation -> annotation.getString(\"value\"));\n\t\tassertThat(values).containsExactly(expected);\n\t}\n\n\tprivate void testStandardRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expected) {\n\t\tStream<String> values = MergedAnnotations.from(element, searchStrategy).stream(MyRepeatable.class)\n\t\t\t\t.filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex))\n\t\t\t\t.map(annotation -> annotation.getString(\"value\"));\n\t\tassertThat(values).containsExactly(expected);\n\t}\n\n\t@Test\n\tvoid synthesizeWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tComponent synthesizedComponent = MergedAnnotation.from(component).synthesize();\n\t\tassertThat(synthesizedComponent).isNotNull();\n\t\tassertThat(synthesizedComponent).isEqualTo(component);\n\t\tassertThat(synthesizedComponent.value()).isEqualTo(\"webController\");\n\t}\n\n\t/**\n\t * @since 6.0\n\t */\n\t@Test\n\tvoid synthesizedAnnotationShouldReuseJdkProxyClass() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\n\t\tRequestMapping jdkRequestMapping = method.getAnnotation(RequestMapping.class);\n\t\tassertThat(jdkRequestMapping).isNotNull();\n\t\tassertThat(jdkRequestMapping.value()).containsExactly(\"/test\");\n\t\tassertThat(jdkRequestMapping.path()).containsExactly(\"\");\n\n\t\tRequestMapping synthesizedRequestMapping = MergedAnnotation.from(jdkRequestMapping).synthesize();\n\t\tassertSynthesized(synthesizedRequestMapping);\n\t\tassertThat(synthesizedRequestMapping.value()).containsExactly(\"/test\");\n\t\tassertThat(synthesizedRequestMapping.path()).containsExactly(\"/test\");\n\n\t\tassertThat(jdkRequestMapping.getClass()).isSameAs(synthesizedRequestMapping.getClass());\n\t}\n\n\t@Test\n\tvoid synthesizeAlreadySynthesized() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\t\tRequestMapping webMapping = method.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMapping).isNotNull();\n\n\t\tRequestMapping synthesizedWebMapping = MergedAnnotation.from(webMapping).synthesize();\n\t\tRequestMapping synthesizedAgainWebMapping = MergedAnnotation.from(synthesizedWebMapping).synthesize();\n\n\t\tassertSynthesized(synthesizedWebMapping);\n\t\tassertSynthesized(synthesizedAgainWebMapping);\n\t\tassertThat(synthesizedWebMapping).isEqualTo(synthesizedAgainWebMapping);\n\t\tassertThat(synthesizedWebMapping).isSameAs(synthesizedAgainWebMapping);\n\t\tassertThat(synthesizedWebMapping.name()).isEqualTo(\"foo\");\n\t\tassertThat(synthesizedWebMapping.path()).containsExactly(\"/test\");\n\t\tassertThat(synthesizedWebMapping.value()).containsExactly(\"/test\");\n\t}\n\n\t@Test\n\tvoid synthesizeShouldNotSynthesizeNonsynthesizableAnnotations() throws Exception {\n\t\tMethod method = getClass().getDeclaredMethod(\"getId\");\n\n\t\tId id = method.getAnnotation(Id.class);\n\t\tassertThat(id).isNotNull();\n\t\tId synthesizedId = MergedAnnotation.from(id).synthesize();\n\t\tassertThat(id).isEqualTo(synthesizedId);\n\t\t// It doesn't make sense to synthesize @Id since it declares zero attributes.\n\t\tassertNotSynthesized(synthesizedId);\n\t\tassertThat(id).isSameAs(synthesizedId);\n\n\t\tGeneratedValue generatedValue = method.getAnnotation(GeneratedValue.class);\n\t\tassertThat(generatedValue).isNotNull();\n\t\tGeneratedValue synthesizedGeneratedValue = MergedAnnotation.from(generatedValue).synthesize();\n\t\tassertThat(generatedValue).isEqualTo(synthesizedGeneratedValue);\n\t\t// It doesn't make sense to synthesize @GeneratedValue since it declares zero attributes with aliases.\n\t\tassertNotSynthesized(synthesizedGeneratedValue);\n\t\tassertThat(generatedValue).isSameAs(synthesizedGeneratedValue);\n\t}\n\n\t@Test  // gh-28716\n\tvoid synthesizeWhenUsingMergedAnnotationsFromApi() {\n\t\tField directlyAnnotatedField = ReflectionUtils.findField(DomainType.class, \"directlyAnnotated\");\n\t\tMergedAnnotations mergedAnnotations = MergedAnnotations.from(directlyAnnotatedField);\n\t\tRootAnnotation rootAnnotation = mergedAnnotations.get(RootAnnotation.class).synthesize();\n\t\tassertThat(rootAnnotation.flag()).isFalse();\n\t\tassertNotSynthesized(rootAnnotation);\n\n\t\tField metaAnnotatedField = ReflectionUtils.findField(DomainType.class, \"metaAnnotated\");\n\t\tmergedAnnotations = MergedAnnotations.from(metaAnnotatedField);\n\t\trootAnnotation = mergedAnnotations.get(RootAnnotation.class).synthesize();\n\t\tassertThat(rootAnnotation.flag()).isTrue();\n\t\tassertSynthesized(rootAnnotation);\n\n\t\tField metaMetaAnnotatedField = ReflectionUtils.findField(DomainType.class, \"metaMetaAnnotated\");\n\t\tmergedAnnotations = MergedAnnotations.from(metaMetaAnnotatedField);\n\t\trootAnnotation = mergedAnnotations.get(RootAnnotation.class).synthesize();\n\t\tassertThat(rootAnnotation.flag()).isTrue();\n\t\tassertSynthesized(rootAnnotation);\n\t}\n\n\t@Test  // gh-28704\n\tvoid synthesizeShouldNotSynthesizeNonsynthesizableAnnotationsWhenUsingMergedAnnotationsFromApi() {\n\t\tMergedAnnotations mergedAnnotations = MergedAnnotations.from(SecurityConfig.class);\n\n\t\tEnableWebSecurity enableWebSecurity = mergedAnnotations.get(EnableWebSecurity.class).synthesize();\n\t\tassertNotSynthesized(enableWebSecurity);\n\n\t\tEnableGlobalAuthentication enableGlobalAuthentication = mergedAnnotations.get(EnableGlobalAuthentication.class).synthesize();\n\t\tassertNotSynthesized(enableGlobalAuthentication);\n\t}\n\n\t/**\n\t * If an attempt is made to synthesize an annotation from an annotation instance\n\t * that has already been synthesized, the original synthesized annotation should\n\t * ideally be returned as-is without creating a new proxy instance with the same\n\t * values.\n\t */\n\t@Test\n\tvoid synthesizeShouldNotResynthesizeAlreadySynthesizedAnnotations() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\t\tRequestMapping webMapping = method.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMapping).isNotNull();\n\n\t\tMergedAnnotation<RequestMapping> mergedAnnotation1 = MergedAnnotation.from(webMapping);\n\t\tRequestMapping synthesizedWebMapping1 = mergedAnnotation1.synthesize();\n\t\tRequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMapping).synthesize();\n\n\t\tassertSynthesized(synthesizedWebMapping1);\n\t\tassertSynthesized(synthesizedWebMapping2);\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(synthesizedWebMapping2);\n\n\t\t// Synthesizing an annotation from a different MergedAnnotation results in a different synthesized annotation instance.\n\t\tassertThat(synthesizedWebMapping1).isNotSameAs(synthesizedWebMapping2);\n\t\t// Synthesizing an annotation from the same MergedAnnotation results in the same synthesized annotation instance.\n\t\tassertThat(synthesizedWebMapping1).isSameAs(mergedAnnotation1.synthesize());\n\n\t\tRequestMapping synthesizedAgainWebMapping = MergedAnnotation.from(synthesizedWebMapping1).synthesize();\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(synthesizedAgainWebMapping);\n\t\t// Synthesizing an already synthesized annotation results in the original synthesized annotation instance.\n\t\tassertThat(synthesizedWebMapping1).isSameAs(synthesizedAgainWebMapping);\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAliasForIsMissingAttributeDeclaration() {\n\t\tAliasForWithMissingAttributeDeclaration annotation =\n\t\t\t\tAliasForWithMissingAttributeDeclarationClass.class.getAnnotation(\n\t\t\t\t\t\tAliasForWithMissingAttributeDeclaration.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"@AliasFor declaration on attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(AliasForWithMissingAttributeDeclaration.class.getName())\n\t\t\t\t.withMessageContaining(\"points to itself\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAliasForHasDuplicateAttributeDeclaration() {\n\t\tAliasForWithDuplicateAttributeDeclaration annotation =\n\t\t\t\tAliasForWithDuplicateAttributeDeclarationClass.class.getAnnotation(\n\t\t\t\t\t\tAliasForWithDuplicateAttributeDeclaration.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"In @AliasFor declared on attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(AliasForWithDuplicateAttributeDeclaration.class.getName())\n\t\t\t\t.withMessageContaining(\"attribute 'attribute' and its alias 'value' are present with values of 'baz' and 'bar'\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForNonexistentAttribute() {\n\t\tAliasForNonexistentAttribute annotation = AliasForNonexistentAttributeClass.class.getAnnotation(\n\t\t\t\tAliasForNonexistentAttribute.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"@AliasFor declaration on attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(AliasForNonexistentAttribute.class.getName())\n\t\t\t\t.withMessageContaining(\"declares an alias for 'bar' which is not present\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasWithMirroredAliasForWrongAttribute() {\n\t\tAliasForWithMirroredAliasForWrongAttribute annotation =\n\t\t\t\tAliasForWithMirroredAliasForWrongAttributeClass.class.getAnnotation(\n\t\t\t\t\t\tAliasForWithMirroredAliasForWrongAttribute.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessage(\"@AliasFor declaration on attribute 'bar' in annotation [\" +\n\t\t\t\t\t\tAliasForWithMirroredAliasForWrongAttribute.class.getName() +\n\t\t\t\t\t\t\"] declares an alias for 'quux' which is not present.\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForAttributeOfDifferentType() {\n\t\tAliasForAttributeOfDifferentType annotation = AliasForAttributeOfDifferentTypeClass.class.getAnnotation(\n\t\t\t\tAliasForAttributeOfDifferentType.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases\")\n\t\t\t\t.withMessageContaining(AliasForAttributeOfDifferentType.class.getName())\n\t\t\t\t.withMessageContaining(\"attribute 'foo'\")\n\t\t\t\t.withMessageContaining(\"attribute 'bar'\")\n\t\t\t\t.withMessageContaining(\"same return type\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForWithMissingDefaultValues() {\n\t\tAliasForWithMissingDefaultValues annotation = AliasForWithMissingDefaultValuesClass.class.getAnnotation(\n\t\t\t\tAliasForWithMissingDefaultValues.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases\")\n\t\t\t\t.withMessageContaining(AliasForWithMissingDefaultValues.class.getName())\n\t\t\t\t.withMessageContaining(\"attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(\"attribute 'bar' in annotation\")\n\t\t\t\t.withMessageContaining(\"default values\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForAttributeWithDifferentDefaultValue() {\n\t\tAliasForAttributeWithDifferentDefaultValue annotation =\n\t\t\t\tAliasForAttributeWithDifferentDefaultValueClass.class.getAnnotation(\n\t\t\t\t\t\tAliasForAttributeWithDifferentDefaultValue.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases\")\n\t\t\t\t.withMessageContaining(AliasForAttributeWithDifferentDefaultValue.class.getName())\n\t\t\t\t.withMessageContaining(\"attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(\"attribute 'bar' in annotation\")\n\t\t\t\t.withMessageContaining(\"same default value\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForMetaAnnotationThatIsNotMetaPresent() {\n\t\tAliasedComposedTestConfigurationNotMetaPresent annotation =\n\t\t\t\tAliasedComposedTestConfigurationNotMetaPresentClass.class.getAnnotation(\n\t\t\t\t\t\tAliasedComposedTestConfigurationNotMetaPresent.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"@AliasFor declaration on attribute 'xmlConfigFile' in annotation\")\n\t\t\t\t.withMessageContaining(AliasedComposedTestConfigurationNotMetaPresent.class.getName())\n\t\t\t\t.withMessageContaining(\"declares an alias for attribute 'location' in annotation\")\n\t\t\t\t.withMessageContaining(TestConfiguration.class.getName())\n\t\t\t\t.withMessageContaining(\"not meta-present\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliases() {\n\t\ttestSynthesisWithImplicitAliases(ValueImplicitAliasesTestConfigurationClass.class, \"value\");\n\t\ttestSynthesisWithImplicitAliases(Location1ImplicitAliasesTestConfigurationClass.class, \"location1\");\n\t\ttestSynthesisWithImplicitAliases(XmlImplicitAliasesTestConfigurationClass.class, \"xmlFile\");\n\t\ttestSynthesisWithImplicitAliases(GroovyImplicitAliasesSimpleTestConfigurationClass.class, \"groovyScript\");\n\t}\n\n\tprivate void testSynthesisWithImplicitAliases(Class<?> clazz, String expected) {\n\t\tImplicitAliasesTestConfiguration config = clazz.getAnnotation(ImplicitAliasesTestConfiguration.class);\n\t\tassertThat(config).isNotNull();\n\t\tImplicitAliasesTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.value()).isEqualTo(expected);\n\t\tassertThat(synthesized.location1()).isEqualTo(expected);\n\t\tassertThat(synthesized.xmlFile()).isEqualTo(expected);\n\t\tassertThat(synthesized.groovyScript()).isEqualTo(expected);\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesWithImpliedAliasNamesOmitted() {\n\t\ttestSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(\n\t\t\t\tValueImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass.class,\n\t\t\t\t\"value\");\n\t\ttestSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(\n\t\t\t\tLocationsImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass.class,\n\t\t\t\t\"location\");\n\t\ttestSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(\n\t\t\t\tXmlFilesImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass.class,\n\t\t\t\t\"xmlFile\");\n\t}\n\n\tprivate void testSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(Class<?> clazz, String expected) {\n\t\tImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration config = clazz.getAnnotation(\n\t\t\t\tImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration.class);\n\t\tassertThat(config).isNotNull();\n\t\tImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration synthesized =\n\t\t\t\tMergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.value()).isEqualTo(expected);\n\t\tassertThat(synthesized.location()).isEqualTo(expected);\n\t\tassertThat(synthesized.xmlFile()).isEqualTo(expected);\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesForAliasPair() {\n\t\tImplicitAliasesForAliasPairTestConfiguration config =\n\t\t\t\tImplicitAliasesForAliasPairTestConfigurationClass.class.getAnnotation(\n\t\t\t\t\t\tImplicitAliasesForAliasPairTestConfiguration.class);\n\t\tImplicitAliasesForAliasPairTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.xmlFile()).isEqualTo(\"test.xml\");\n\t\tassertThat(synthesized.groovyScript()).isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithTransitiveImplicitAliases() {\n\t\tTransitiveImplicitAliasesTestConfiguration config =\n\t\t\t\tTransitiveImplicitAliasesTestConfigurationClass.class.getAnnotation(\n\t\t\t\t\t\tTransitiveImplicitAliasesTestConfiguration.class);\n\t\tTransitiveImplicitAliasesTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.xml()).isEqualTo(\"test.xml\");\n\t\tassertThat(synthesized.groovy()).isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithTransitiveImplicitAliasesForAliasPair() {\n\t\tTransitiveImplicitAliasesForAliasPairTestConfiguration config =\n\t\t\t\tTransitiveImplicitAliasesForAliasPairTestConfigurationClass.class.getAnnotation(\n\t\t\t\t\t\tTransitiveImplicitAliasesForAliasPairTestConfiguration.class);\n\t\tTransitiveImplicitAliasesForAliasPairTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.xml()).isEqualTo(\"test.xml\");\n\t\tassertThat(synthesized.groovy()).isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesWithMissingDefaultValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithMissingDefaultValuesTestConfigurationClass.class;\n\t\tClass<ImplicitAliasesWithMissingDefaultValuesTestConfiguration> annotationType =\n\t\t\t\tImplicitAliasesWithMissingDefaultValuesTestConfiguration.class;\n\t\tImplicitAliasesWithMissingDefaultValuesTestConfiguration config = clazz.getAnnotation(annotationType);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(clazz, config))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases:\")\n\t\t\t\t.withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t\t.withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t\t.withMessageContaining(\"default values\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesWithDifferentDefaultValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithDifferentDefaultValuesTestConfigurationClass.class;\n\t\tClass<ImplicitAliasesWithDifferentDefaultValuesTestConfiguration> annotationType =\n\t\t\t\tImplicitAliasesWithDifferentDefaultValuesTestConfiguration.class;\n\t\tImplicitAliasesWithDifferentDefaultValuesTestConfiguration config = clazz.getAnnotation(annotationType);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(clazz, config))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases:\")\n\t\t\t\t.withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t\t.withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t\t.withMessageContaining(\"same default value\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesWithDuplicateValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithDuplicateValuesTestConfigurationClass.class;\n\t\tClass<ImplicitAliasesWithDuplicateValuesTestConfiguration> annotationType =\n\t\t\t\tImplicitAliasesWithDuplicateValuesTestConfiguration.class;\n\t\tImplicitAliasesWithDuplicateValuesTestConfiguration config = clazz.getAnnotation(annotationType);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotation.from(clazz, config))\n\t\t\t\t.withMessageStartingWith(\"Different @AliasFor mirror values for annotation\")\n\t\t\t\t.withMessageContaining(annotationType.getName())\n\t\t\t\t.withMessageContaining(\"declared on class\")\n\t\t\t\t.withMessageContaining(clazz.getName())\n\t\t\t\t.withMessageContaining(\"are declared with values of\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tMap<String, Object> map = Collections.singletonMap(\"value\", \"webController\");\n\t\tMergedAnnotation<Component> annotation = MergedAnnotation.of(Component.class, map);\n\n\t\tComponent synthesizedComponent = annotation.synthesize();\n\t\tassertSynthesized(synthesizedComponent);\n\t\tassertThat(synthesizedComponent.value()).isEqualTo(\"webController\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeFromMapWithNestedMap() {\n\t\tComponentScanSingleFilter componentScan = ComponentScanSingleFilterClass.class.getAnnotation(\n\t\t\t\tComponentScanSingleFilter.class);\n\t\tassertThat(componentScan).isNotNull();\n\t\tassertThat(componentScan.value().pattern()).isEqualTo(\"*Foo\");\n\t\tMap<String, Object> map = MergedAnnotation.from(componentScan).asMap(\n\t\t\t\tannotation -> new LinkedHashMap<>(), Adapt.ANNOTATION_TO_MAP);\n\t\tMap<String, Object> filterMap = (Map<String, Object>) map.get(\"value\");\n\t\tassertThat(filterMap.get(\"pattern\")).isEqualTo(\"*Foo\");\n\t\tfilterMap.put(\"pattern\", \"newFoo\");\n\t\tfilterMap.put(\"enigma\", 42);\n\t\tMergedAnnotation<ComponentScanSingleFilter> annotation = MergedAnnotation.of(\n\t\t\t\tComponentScanSingleFilter.class, map);\n\t\tComponentScanSingleFilter synthesizedComponentScan = annotation.synthesize();\n\t\tassertSynthesized(synthesizedComponentScan);\n\t\tassertThat(synthesizedComponentScan.value().pattern()).isEqualTo(\"newFoo\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeFromMapWithNestedArrayOfMaps() {\n\t\tComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class);\n\t\tassertThat(componentScan).isNotNull();\n\t\tMap<String, Object> map = MergedAnnotation.from(componentScan).asMap(\n\t\t\t\tannotation -> new LinkedHashMap<>(), Adapt.ANNOTATION_TO_MAP);\n\t\tMap<String, Object>[] filters = (Map[]) map.get(\"excludeFilters\");\n\t\tList<String> patterns = Arrays.stream(filters).map(\n\t\t\t\tm -> (String) m.get(\"pattern\")).toList();\n\t\tassertThat(patterns).containsExactly(\"*Foo\", \"*Bar\");\n\t\tfilters[0].put(\"pattern\", \"newFoo\");\n\t\tfilters[0].put(\"enigma\", 42);\n\t\tfilters[1].put(\"pattern\", \"newBar\");\n\t\tfilters[1].put(\"enigma\", 42);\n\t\tMergedAnnotation<ComponentScan> annotation = MergedAnnotation.of(ComponentScan.class, map);\n\t\tComponentScan synthesizedComponentScan = annotation.synthesize();\n\t\tassertSynthesized(synthesizedComponentScan);\n\t\tassertThat(Arrays.stream(synthesizedComponentScan.excludeFilters()).map(Filter::pattern))\n\t\t\t\t.containsExactly(\"newFoo\", \"newBar\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromDefaultsWithoutAttributeAliases() {\n\t\tMergedAnnotation<AnnotationWithDefaults> annotation = MergedAnnotation.of(AnnotationWithDefaults.class);\n\t\tAnnotationWithDefaults synthesized = annotation.synthesize();\n\t\tassertThat(synthesized.text()).isEqualTo(\"enigma\");\n\t\tassertThat(synthesized.predicate()).isTrue();\n\t\tassertThat(synthesized.characters()).containsExactly('a', 'b', 'c');\n\t}\n\n\t@Test\n\tvoid synthesizeFromDefaultsWithAttributeAliases() {\n\t\tMergedAnnotation<TestConfiguration> annotation = MergedAnnotation.of(TestConfiguration.class);\n\t\tTestConfiguration synthesized = annotation.synthesize();\n\t\tassertThat(synthesized.value()).isEmpty();\n\t\tassertThat(synthesized.location()).isEmpty();\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasesWithDifferentValues() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tMergedAnnotation.from(TestConfigurationMismatch.class.getAnnotation(TestConfiguration.class)).synthesize());\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithMinimalAttributesWithAttributeAliases() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"location\", \"test.xml\");\n\t\tMergedAnnotation<TestConfiguration> annotation = MergedAnnotation.of(TestConfiguration.class, map);\n\t\tTestConfiguration synthesized = annotation.synthesize();\n\t\tassertThat(synthesized.value()).isEqualTo(\"test.xml\");\n\t\tassertThat(synthesized.location()).isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements() {\n\t\tsynthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements(\n\t\t\t\tCollections.singletonMap(\"value\", \"/foo\"));\n\t\tsynthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements(\n\t\t\t\tCollections.singletonMap(\"path\", \"/foo\"));\n\t}\n\n\tprivate void synthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements(Map<String, Object> map) {\n\t\tMergedAnnotation<GetMapping> annotation = MergedAnnotation.of(GetMapping.class, map);\n\t\tGetMapping synthesized = annotation.synthesize();\n\t\tassertThat(synthesized.value()).isEqualTo(\"/foo\");\n\t\tassertThat(synthesized.path()).isEqualTo(\"/foo\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithImplicitAttributeAliases() {\n\t\ttestSynthesisFromMapWithImplicitAliases(\"value\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"location1\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"location2\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"location3\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"xmlFile\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"groovyScript\");\n\t}\n\n\tprivate void testSynthesisFromMapWithImplicitAliases(String attributeNameAndValue) {\n\t\tMap<String, Object> map = Collections.singletonMap(attributeNameAndValue, attributeNameAndValue);\n\t\tMergedAnnotation<ImplicitAliasesTestConfiguration> annotation = MergedAnnotation.of(\n\t\t\t\tImplicitAliasesTestConfiguration.class, map);\n\t\tImplicitAliasesTestConfiguration synthesized = annotation.synthesize();\n\n\t\tassertThat(synthesized.value()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.location1()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.location2()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.location2()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.xmlFile()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.groovyScript()).isEqualTo(attributeNameAndValue);\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithMissingAttributeValue() {\n\t\ttestMissingTextAttribute(Collections.emptyMap());\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithNullAttributeValue() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"text\", null);\n\t\tassertThat(map).containsKey(\"text\");\n\t\ttestMissingTextAttribute(map);\n\t}\n\n\tprivate void testMissingTextAttribute(Map<String, Object> attributes) {\n\t\tassertThatExceptionOfType(NoSuchElementException.class).isThrownBy(() ->\n\t\t\t\tMergedAnnotation.of(AnnotationWithoutDefaults.class, attributes).synthesize().text())\n\t\t\t\t.withMessage(\"No value found for attribute named 'text' in merged annotation \" +\n\t\t\t\t\t\tAnnotationWithoutDefaults.class.getCanonicalName());\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithAttributeOfIncorrectType() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"value\", 42L);\n\t\tMergedAnnotation<Component> annotation = MergedAnnotation.of(Component.class, map);\n\t\tassertThatIllegalStateException().isThrownBy(() -> annotation.synthesize().value())\n\t\t\t\t.withMessage(\"Attribute 'value' in annotation \" +\n\t\t\t\t\t\t\"org.springframework.core.testfixture.stereotype.Component should be \" +\n\t\t\t\t\t\t\"compatible with java.lang.String but a java.lang.Long value was returned\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromAnnotationAttributesWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tMap<String, Object> attributes = MergedAnnotation.from(component).asMap();\n\n\t\tComponent synthesized = MergedAnnotation.of(Component.class, attributes).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized).isEqualTo(component);\n\t}\n\n\t@Test\n\tvoid toStringForSynthesizedAnnotations() throws Exception {\n\t\tMethod methodWithPath = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\tRequestMapping webMappingWithAliases = methodWithPath.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithAliases).isNotNull();\n\n\t\tMethod methodWithPathAndValue = WebController.class.getMethod(\"handleMappedWithSamePathAndValueAttributes\");\n\t\tRequestMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(RequestMapping.class);\n\t\tassertThat(methodWithPathAndValue).isNotNull();\n\n\t\tRequestMapping synthesizedWebMapping1 = MergedAnnotation.from(webMappingWithAliases).synthesize();\n\t\tRequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMappingWithPathAndValue).synthesize();\n\n\t\tassertThat(webMappingWithAliases.toString()).isNotEqualTo(synthesizedWebMapping1.toString());\n\n\t\t// The unsynthesized annotation for handleMappedWithSamePathAndValueAttributes()\n\t\t// should produce almost the same toString() results as synthesized annotations for\n\t\t// handleMappedWithPathAttribute() on Java 9 or higher; however, due to multiple changes\n\t\t// in the JDK's toString() implementation for annotations in JDK 9, 14, and 19,\n\t\t// we do not test the JDK implementation.\n\t\t// assertToStringForWebMappingWithPathAndValue(webMappingWithPathAndValue);\n\n\t\tassertToStringForWebMappingWithPathAndValue(synthesizedWebMapping1);\n\t\tassertToStringForWebMappingWithPathAndValue(synthesizedWebMapping2);\n\t}\n\n\tprivate void assertToStringForWebMappingWithPathAndValue(RequestMapping webMapping) {\n\t\tassertThat(webMapping.toString())\n\t\t\t\t.startsWith(\"@org.springframework.core.annotation.MergedAnnotationsTests.RequestMapping(\")\n\t\t\t\t.contains(\n\t\t\t\t\t// Strings\n\t\t\t\t\t\"value={\\\"/test\\\"}\", \"path={\\\"/test\\\"}\", \"name=\\\"bar\\\"\",\n\t\t\t\t\t// Characters\n\t\t\t\t\t\"ch='X'\", \"chars={'X'}\",\n\t\t\t\t\t// Enums\n\t\t\t\t\t\"method={GET, POST}\",\n\t\t\t\t\t// Classes\n\t\t\t\t\t\"clazz=org.springframework.core.annotation.MergedAnnotationsTests.RequestMethod.class\",\n\t\t\t\t\t\"classes={int[][].class, org.springframework.core.annotation.MergedAnnotationsTests.RequestMethod[].class}\",\n\t\t\t\t\t// Bytes\n\t\t\t\t\t\"byteValue=(byte) 0xFF\", \"bytes={(byte) 0xFF}\",\n\t\t\t\t\t// Shorts\n\t\t\t\t\t\"shortValue=9876\", \"shorts={9876}\",\n\t\t\t\t\t// Longs\n\t\t\t\t\t\"longValue=42L\", \"longs={42L}\",\n\t\t\t\t\t// Floats\n\t\t\t\t\t\"floatValue=3.14f\", \"floats={3.14f}\",\n\t\t\t\t\t// Doubles\n\t\t\t\t\t\"doubleValue=99.999d\", \"doubles={99.999d}\"\n\t\t\t\t)\n\t\t\t\t.endsWith(\")\");\n\t}\n\n\t@Test\n\tvoid equalsForSynthesizedAnnotations() throws Exception {\n\t\tMethod methodWithPath = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\tRequestMapping webMappingWithAliases = methodWithPath.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithAliases).isNotNull();\n\t\tMethod methodWithPathAndValue = WebController.class.getMethod(\"handleMappedWithSamePathAndValueAttributes\");\n\t\tRequestMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithPathAndValue).isNotNull();\n\t\tRequestMapping synthesizedWebMapping1 = MergedAnnotation.from(webMappingWithAliases).synthesize();\n\t\tRequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMappingWithPathAndValue).synthesize();\n\t\t// Equality amongst standard annotations\n\t\tassertThat(webMappingWithAliases).isEqualTo(webMappingWithAliases);\n\t\tassertThat(webMappingWithPathAndValue).isEqualTo(webMappingWithPathAndValue);\n\t\t// Inequality amongst standard annotations\n\t\tassertThat(webMappingWithAliases).isNotEqualTo(webMappingWithPathAndValue);\n\t\tassertThat(webMappingWithPathAndValue).isNotEqualTo(webMappingWithAliases);\n\t\t// Equality amongst synthesized annotations\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(synthesizedWebMapping1);\n\t\tassertThat(synthesizedWebMapping2).isEqualTo(synthesizedWebMapping2);\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(synthesizedWebMapping2);\n\t\tassertThat(synthesizedWebMapping2).isEqualTo(synthesizedWebMapping1);\n\t\t// Equality between standard and synthesized annotations\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(webMappingWithPathAndValue);\n\t\tassertThat(webMappingWithPathAndValue).isEqualTo(synthesizedWebMapping1);\n\t\t// Inequality between standard and synthesized annotations\n\t\tassertThat(synthesizedWebMapping1).isNotEqualTo(webMappingWithAliases);\n\t\tassertThat(webMappingWithAliases).isNotEqualTo(synthesizedWebMapping1);\n\t}\n\n\t@Test\n\tvoid hashCodeForSynthesizedAnnotations() throws Exception {\n\t\tMethod methodWithPath = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\tRequestMapping webMappingWithAliases = methodWithPath.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithAliases).isNotNull();\n\t\tMethod methodWithPathAndValue = WebController.class.getMethod(\"handleMappedWithSamePathAndValueAttributes\");\n\t\tRequestMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithPathAndValue).isNotNull();\n\t\tRequestMapping synthesizedWebMapping1 = MergedAnnotation.from(webMappingWithAliases).synthesize();\n\t\tassertThat(synthesizedWebMapping1).isNotNull();\n\t\tRequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMappingWithPathAndValue).synthesize();\n\t\tassertThat(synthesizedWebMapping2).isNotNull();\n\t\t// Equality amongst standard annotations\n\t\tassertThat(webMappingWithAliases.hashCode()).isEqualTo(webMappingWithAliases.hashCode());\n\t\tassertThat(webMappingWithPathAndValue.hashCode()).isEqualTo(webMappingWithPathAndValue.hashCode());\n\t\t// Inequality amongst standard annotations\n\t\tassertThat(webMappingWithAliases.hashCode()).isNotEqualTo(webMappingWithPathAndValue.hashCode());\n\t\tassertThat(webMappingWithPathAndValue.hashCode()).isNotEqualTo(webMappingWithAliases.hashCode());\n\t\t// Equality amongst synthesized annotations\n\t\tassertThat(synthesizedWebMapping1.hashCode()).isEqualTo(synthesizedWebMapping1.hashCode());\n\t\tassertThat(synthesizedWebMapping2.hashCode()).isEqualTo(synthesizedWebMapping2.hashCode());\n\t\tassertThat(synthesizedWebMapping1.hashCode()).isEqualTo(synthesizedWebMapping2.hashCode());\n\t\tassertThat(synthesizedWebMapping2.hashCode()).isEqualTo(synthesizedWebMapping1.hashCode());\n\t\t// Equality between standard and synthesized annotations\n\t\tassertThat(synthesizedWebMapping1.hashCode()).isEqualTo(webMappingWithPathAndValue.hashCode());\n\t\tassertThat(webMappingWithPathAndValue.hashCode()).isEqualTo(synthesizedWebMapping1.hashCode());\n\t\t// Inequality between standard and synthesized annotations\n\t\tassertThat(synthesizedWebMapping1.hashCode()).isNotEqualTo(webMappingWithAliases.hashCode());\n\t\tassertThat(webMappingWithAliases.hashCode()).isNotEqualTo(synthesizedWebMapping1.hashCode());\n\t}\n\n\t/**\n\t * Fully reflection-based test that verifies support for synthesizing\n\t * annotations across packages with non-public visibility of user types\n\t * (for example, a non-public annotation that uses {@code @AliasFor}).\n\t */\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeNonPublicWithAttributeAliasesFromDifferentPackage() throws Exception {\n\t\tClass<?> type = ClassUtils.forName(\n\t\t\t\t\"org.springframework.core.annotation.subpackage.NonPublicAliasedAnnotatedClass\",\n\t\t\t\tnull);\n\t\tClass<? extends Annotation> annotationType = (Class<? extends Annotation>) ClassUtils.forName(\n\t\t\t\t\"org.springframework.core.annotation.subpackage.NonPublicAliasedAnnotation\",\n\t\t\t\tnull);\n\t\tAnnotation annotation = type.getAnnotation(annotationType);\n\t\tassertThat(annotation).isNotNull();\n\t\tMergedAnnotation<Annotation> mergedAnnotation = MergedAnnotation.from(annotation);\n\t\tAnnotation synthesizedAnnotation = mergedAnnotation.synthesize();\n\t\tassertSynthesized(synthesizedAnnotation);\n\t\tassertThat(mergedAnnotation.getString(\"name\")).isEqualTo(\"test\");\n\t\tassertThat(mergedAnnotation.getString(\"path\")).isEqualTo(\"/test\");\n\t\tassertThat(mergedAnnotation.getString(\"value\")).isEqualTo(\"/test\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithArrayOfAnnotations() {\n\t\tHierarchy hierarchy = HierarchyClass.class.getAnnotation(Hierarchy.class);\n\t\tassertThat(hierarchy).isNotNull();\n\t\tHierarchy synthesizedHierarchy = MergedAnnotation.from(hierarchy).synthesize();\n\t\tassertSynthesized(synthesizedHierarchy);\n\t\tTestConfiguration[] configs = synthesizedHierarchy.value();\n\t\tassertThat(configs).isNotNull();\n\t\tassertThat(configs).allMatch(AnnotationUtils::isSynthesizedAnnotation);\n\t\tassertThat(configs).extracting(TestConfiguration::value).containsExactly(\"A\", \"B\");\n\t\tassertThat(configs).extracting(TestConfiguration::location).containsExactly(\"A\", \"B\");\n\n\t\tTestConfiguration contextConfig = TestConfigurationClass.class.getAnnotation(TestConfiguration.class);\n\t\tassertThat(contextConfig).isNotNull();\n\t\t// Alter array returned from synthesized annotation\n\t\tconfigs[0] = contextConfig;\n\t\tassertThat(configs).extracting(TestConfiguration::value).containsExactly(\"simple.xml\", \"B\");\n\t\t// Re-retrieve the array from the synthesized annotation\n\t\tconfigs = synthesizedHierarchy.value();\n\t\tassertThat(configs).extracting(TestConfiguration::value).containsExactly(\"A\", \"B\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithArrayOfChars() {\n\t\tCharsContainer charsContainer = GroupOfCharsClass.class.getAnnotation(CharsContainer.class);\n\t\tassertThat(charsContainer).isNotNull();\n\t\tCharsContainer synthesizedCharsContainer = MergedAnnotation.from(charsContainer).synthesize();\n\t\tassertSynthesized(synthesizedCharsContainer);\n\t\tchar[] chars = synthesizedCharsContainer.chars();\n\t\tassertThat(chars).containsExactly('x', 'y', 'z');\n\t\t// Alter array returned from synthesized annotation\n\t\tchars[0] = '?';\n\t\t// Re-retrieve the array from the synthesized annotation\n\t\tchars = synthesizedCharsContainer.chars();\n\t\tassertThat(chars).containsExactly('x', 'y', 'z');\n\t}\n\n\t@Test\n\tvoid getValueWhenHasDefaultOverride() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(DefaultOverrideClass.class)\n\t\t\t\t.get(DefaultOverrideRoot.class);\n\t\tassertThat(annotation.getString(\"text\")).isEqualTo(\"metameta\");\n\t}\n\n\t@Test // gh-22654\n\tvoid getValueWhenHasDefaultOverrideWithImplicitAlias() {\n\t\tMergedAnnotation<?> annotation1 = MergedAnnotations.from(DefaultOverrideImplicitAliasMetaClass1.class)\n\t\t\t\t.get(DefaultOverrideRoot.class);\n\t\tassertThat(annotation1.getString(\"text\")).isEqualTo(\"alias-meta-1\");\n\t\tMergedAnnotation<?> annotation2 = MergedAnnotations.from(DefaultOverrideImplicitAliasMetaClass2.class)\n\t\t\t\t.get(DefaultOverrideRoot.class);\n\t\tassertThat(annotation2.getString(\"text\")).isEqualTo(\"alias-meta-2\");\n\t}\n\n\t@Test // gh-22654\n\tvoid getValueWhenHasDefaultOverrideWithExplicitAlias() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(DefaultOverrideExplicitAliasRootMetaMetaClass.class)\n\t\t\t\t.get(DefaultOverrideExplicitAliasRoot.class);\n\t\tassertThat(annotation.getString(\"text\")).isEqualTo(\"meta\");\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta\");\n\t}\n\n\t@Test // gh-22703\n\tvoid getValueWhenThreeDeepMetaWithValue() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(ValueAttributeMetaMetaClass.class)\n\t\t\t\t.get(ValueAttribute.class);\n\t\tassertThat(annotation.getStringArray(MergedAnnotation.VALUE)).containsExactly(\"FromValueAttributeMeta\");\n\t}\n\n\t@Test\n\tvoid asAnnotationAttributesReturnsPopulatedAnnotationAttributes() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(SpringApplicationConfigurationClass.class)\n\t\t\t\t.get(SpringApplicationConfiguration.class);\n\t\tAnnotationAttributes attributes = annotation.asAnnotationAttributes(Adapt.CLASS_TO_STRING);\n\t\tassertThat(attributes).containsEntry(\"classes\", new String[] {Number.class.getName()});\n\t\tassertThat(attributes.annotationType()).isEqualTo(SpringApplicationConfiguration.class);\n\t}\n\n\n\t// @formatter:off\n\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Transactional {\n\n\t\tString value() default \"\";\n\n\t\tString qualifier() default \"transactionManager\";\n\n\t\tboolean readOnly() default false;\n\t}\n\n\t@Transactional\n\t@Component\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransactionalComponent {\n\t}\n\n\t@TransactionalComponent\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedTransactionalComponent {\n\t}\n\n\tstatic class NonAnnotatedClass {\n\t}\n\n\t@Component\n\tstatic class AnnotatedClass {\n\n\t\tclass NonAnnotatedInnerClass {\n\t\t}\n\n\t\tstatic class NonAnnotatedStaticNestedClass {\n\t\t}\n\t}\n\n\tinterface NonAnnotatedInterface {\n\t}\n\n\t@TransactionalComponent\n\tstatic class TransactionalComponentClass {\n\t}\n\n\tstatic class SubTransactionalComponentClass extends TransactionalComponentClass {\n\t}\n\n\t@ComposedTransactionalComponent\n\tstatic class ComposedTransactionalComponentClass {\n\t}\n\n\t@AliasedTransactionalComponent\n\tstatic class AliasedTransactionalComponentClass {\n\t}\n\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface AliasedTransactional {\n\n\t\t@AliasFor(attribute = \"qualifier\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tString qualifier() default \"\";\n\t}\n\n\t@Transactional(qualifier = \"composed1\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@Inherited\n\t@interface InheritedComposed {\n\t}\n\n\t@Transactional(qualifier = \"composed2\", readOnly = true)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface Composed {\n\t}\n\n\t@Transactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxComposedWithOverride {\n\n\t\tString qualifier() default \"txMgr\";\n\t}\n\n\t@Transactional(\"TxInheritedComposed\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxInheritedComposed {\n\t}\n\n\t@Transactional(\"TxComposed\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxComposed {\n\t}\n\n\t@AliasedTransactional(value = \"aliasForQualifier\")\n\t@Component\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedTransactionalComponent {\n\t}\n\n\t@AliasedTransactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MyAliasedTransactional {\n\n\t\t@AliasFor(annotation = AliasedTransactional.class, attribute = \"value\")\n\t\tString value() default \"defaultTransactionManager\";\n\t}\n\n\t@MyAliasedTransactional(\"anotherTransactionManager\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@interface ComposedMyAliasedTransactional {\n\t}\n\n\t@ComposedMyAliasedTransactional\n\tstatic class ComposedTransactionalClass {\n\t}\n\n\t@AliasedTransactional(\"meta\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaAliasedTransactional {\n\t}\n\n\t@MetaAliasedTransactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMetaAliasedTransactional {\n\t}\n\n\t@MetaMetaAliasedTransactional\n\tstatic class MetaMetaAliasedTransactionalClass {\n\t}\n\n\t@TxComposedWithOverride\n\t// Override default \"txMgr\" from @TxComposedWithOverride with \"localTxMgr\"\n\t@Transactional(qualifier = \"localTxMgr\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface MetaAndLocalTxConfig {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestPropertySource {\n\n\t\t@AliasFor(\"locations\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] locations() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContextConfiguration {\n\n\t\t@AliasFor(attribute = \"locations\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tString[] locations() default {};\n\n\t\tClass<?>[] classes() default {};\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionBasedComposedContextConfiguration {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] locations() default {};\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class)\n\t\tClass<?>[] classes() default {};\n\t}\n\n\t@ContextConfiguration(value = \"duplicateDeclaration\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface InvalidConventionBasedComposedContextConfiguration {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] locations();\n\t}\n\n\t/**\n\t * This hybrid approach for annotation attribute overrides with transitive implicit\n\t * aliases is unsupported. See SPR-13554 for details.\n\t */\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface HalfConventionBasedAndHalfAliasedComposedContextConfiguration {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] locations() default {};\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles() default {};\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles();\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedValueComposedContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"value\")\n\t\tString[] locations();\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] groovyScripts() default {};\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlFiles() default {};\n\n\t\t// intentionally omitted: attribute = \"locations\"\n\t\t@AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] locations() default {};\n\n\t\t// intentionally omitted: attribute = \"locations\" (SPR-14069)\n\t\t@AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] value() default {};\n\t}\n\n\t@ImplicitAliasesContextConfiguration(xmlFiles = { \"A.xml\", \"B.xml\" })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedImplicitAliasesContextConfiguration {\n\t}\n\n\t@ImplicitAliasesContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesContextConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"xmlFiles\")\n\t\tString[] xml() default {};\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\n\t\tString[] groovy() default {};\n\t}\n\n\t@ImplicitAliasesContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SingleLocationTransitiveImplicitAliasesContextConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"xmlFiles\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@ImplicitAliasesContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesWithSkippedLevelContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xml() default {};\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\n\t\tString[] groovy() default {};\n\t}\n\n\t@ImplicitAliasesContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\n\t\tString groovy() default \"\";\n\t}\n\n\t/**\n\t * Although the configuration declares an explicit value for 'value' and requires a\n\t * value for the aliased 'locations', this does not result in an error since\n\t * 'locations' effectively shadows the 'value' attribute (which cannot be set via the\n\t * composed annotation anyway). If 'value' were not shadowed, such a declaration would\n\t * not make sense.\n\t */\n\t@ContextConfiguration(value = \"duplicateDeclaration\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ShadowedAliasComposedContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles();\n\t}\n\n\t@ContextConfiguration(locations = \"shadowed.xml\")\n\t@TestPropertySource(locations = \"test.properties\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfigurationAndTestPropertySource {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles() default \"default.xml\";\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SpringApplicationConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] locations() default {};\n\n\t\t// Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class, attribute = \"classes\")\n\t\t@AliasFor(\"value\")\n\t\tClass<?>[] classes() default {};\n\n\t\t// Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class, attribute = \"classes\")\n\t\t@AliasFor(\"classes\")\n\t\tClass<?>[] value() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScan {\n\n\t\t@AliasFor(\"basePackages\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] basePackages() default {};\n\n\t\tFilter[] excludeFilters() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({})\n\t@interface Filter {\n\n\t\tString pattern();\n\t}\n\n\t@ComponentScan(excludeFilters = { @Filter(pattern = \"*Test\"),\n\t\t@Filter(pattern = \"*Tests\") })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestComponentScan {\n\n\t\t@AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\n\t\tString[] packages();\n\t}\n\n\t@ComponentScan\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionBasedSinglePackageComponentScan {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ComponentScan.class)\n\t\tString basePackages();\n\t}\n\n\t@ComponentScan\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForBasedSinglePackageComponentScan {\n\n\t\t@AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\n\t\tString pkg();\n\t}\n\n\t@Transactional\n\tstatic class ClassWithInheritedAnnotation {\n\t}\n\n\t@Composed\n\tstatic class SubClassWithInheritedAnnotation extends ClassWithInheritedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedAnnotation\n\t\t\textends SubClassWithInheritedAnnotation {\n\t}\n\n\t@InheritedComposed\n\tstatic class ClassWithInheritedComposedAnnotation {\n\t}\n\n\t@Composed\n\tstatic class SubClassWithInheritedComposedAnnotation\n\t\t\textends ClassWithInheritedComposedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedComposedAnnotation\n\t\t\textends SubClassWithInheritedComposedAnnotation {\n\t}\n\n\t@MetaAndLocalTxConfig\n\tstatic class MetaAndLocalTxConfigClass {\n\t}\n\n\t@Transactional(\"TxConfig\")\n\tstatic class TxConfig {\n\t}\n\n\t@Transactional(\"DerivedTxConfig\")\n\tstatic class DerivedTxConfig extends TxConfig {\n\t}\n\n\t@TxInheritedComposed\n\t@TxComposed\n\tstatic class TxFromMultipleComposedAnnotations {\n\t}\n\n\t@Transactional\n\tinterface InterfaceWithInheritedAnnotation {\n\n\t\t@Order\n\t\tvoid handleFromInterface();\n\t}\n\n\tabstract static class AbstractClassWithInheritedAnnotation<T>\n\t\t\timplements InterfaceWithInheritedAnnotation {\n\n\t\t@Transactional\n\t\tpublic abstract void handle();\n\n\t\t@Transactional\n\t\tpublic void handleParameterized(T t) {\n\t\t}\n\t}\n\n\tstatic class ConcreteClassWithInheritedAnnotation\n\t\t\textends AbstractClassWithInheritedAnnotation<String> {\n\n\t\t@Override\n\t\tpublic void handle() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleParameterized(String s) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleFromInterface() {\n\t\t}\n\t}\n\n\tpublic interface GenericParameter<T> {\n\n\t\tT getFor(Class<T> cls);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class StringGenericParameter implements GenericParameter<String> {\n\n\t\t@Order\n\t\t@Override\n\t\tpublic String getFor(Class<String> cls) {\n\t\t\treturn \"foo\";\n\t\t}\n\n\t\tpublic String getFor(Integer integer) {\n\t\t\treturn \"foo\";\n\t\t}\n\t}\n\n\t@Transactional\n\tpublic interface InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubInheritedAnnotationInterface\n\t\t\textends InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubInheritedAnnotationInterface\n\t\t\textends SubInheritedAnnotationInterface {\n\t}\n\n\t@Order\n\tpublic interface NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubNonInheritedAnnotationInterface\n\t\t\textends NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubNonInheritedAnnotationInterface\n\t\t\textends SubNonInheritedAnnotationInterface {\n\t}\n\n\t@ConventionBasedComposedContextConfiguration(locations = \"explicitDeclaration\")\n\tstatic class ConventionBasedComposedContextConfigurationClass {\n\t}\n\n\t@InvalidConventionBasedComposedContextConfiguration(locations = \"requiredLocationsDeclaration\")\n\tstatic class InvalidConventionBasedComposedContextConfigurationClass {\n\t}\n\n\t@HalfConventionBasedAndHalfAliasedComposedContextConfiguration(xmlConfigFiles = \"explicitDeclaration\")\n\tstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass1 {\n\t}\n\n\t@HalfConventionBasedAndHalfAliasedComposedContextConfiguration(locations = \"explicitDeclaration\")\n\tstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass2 {\n\t}\n\n\t@AliasedComposedContextConfiguration(xmlConfigFiles = \"test.xml\")\n\tstatic class AliasedComposedContextConfigurationClass {\n\t}\n\n\t@AliasedValueComposedContextConfiguration(locations = \"test.xml\")\n\tstatic class AliasedValueComposedContextConfigurationClass {\n\t}\n\n\t@ImplicitAliasesContextConfiguration(\"foo.xml\")\n\tstatic class ImplicitAliasesContextConfigurationClass1 {\n\t}\n\n\t@ImplicitAliasesContextConfiguration(locations = \"bar.xml\")\n\tstatic class ImplicitAliasesContextConfigurationClass2 {\n\t}\n\n\t@ImplicitAliasesContextConfiguration(xmlFiles = \"baz.xml\")\n\tstatic class ImplicitAliasesContextConfigurationClass3 {\n\t}\n\n\t@TransitiveImplicitAliasesContextConfiguration(groovy = \"test.groovy\")\n\tstatic class TransitiveImplicitAliasesContextConfigurationClass {\n\t}\n\n\t@SingleLocationTransitiveImplicitAliasesContextConfiguration(groovy = \"test.groovy\")\n\tstatic class SingleLocationTransitiveImplicitAliasesContextConfigurationClass {\n\t}\n\n\t@TransitiveImplicitAliasesWithSkippedLevelContextConfiguration(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass {\n\t}\n\n\t@SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfiguration(xml = \"test.xml\")\n\tstatic class SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass {\n\t}\n\n\t@ComposedImplicitAliasesContextConfiguration\n\tstatic class ComposedImplicitAliasesContextConfigurationClass {\n\t}\n\n\t@ShadowedAliasComposedContextConfiguration(xmlConfigFiles = \"test.xml\")\n\tstatic class ShadowedAliasComposedContextConfigurationClass {\n\t}\n\n\t@AliasedComposedContextConfigurationAndTestPropertySource(xmlConfigFiles = \"test.xml\")\n\tstatic class AliasedComposedContextConfigurationAndTestPropertySourceClass {\n\t}\n\n\t@ComponentScan(value = \"com.example.app.test\", basePackages = \"com.example.app.test\")\n\tstatic class ComponentScanWithBasePackagesAndValueAliasClass {\n\t}\n\n\t@TestComponentScan(packages = \"com.example.app.test\")\n\tstatic class TestComponentScanClass {\n\t}\n\n\t@ConventionBasedSinglePackageComponentScan(basePackages = \"com.example.app.test\")\n\tstatic class ConventionBasedSinglePackageComponentScanClass {\n\t}\n\n\t@AliasForBasedSinglePackageComponentScan(pkg = \"com.example.app.test\")\n\tstatic class AliasForBasedSinglePackageComponentScanClass {\n\t}\n\n\t@SpringApplicationConfiguration(Number.class)\n\tstatic class SpringApplicationConfigurationClass {\n\t}\n\n\t@Resource(name = \"x\")\n\tstatic class ResourceHolder {\n\t}\n\n\tinterface TransactionalService {\n\n\t\t@Transactional\n\t\tvoid doIt();\n\t}\n\n\tclass TransactionalServiceImpl implements TransactionalService {\n\n\t\t@Override\n\t\tpublic void doIt() {\n\t\t}\n\t}\n\n\t@Component(\"meta1\")\n\t@Order\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Meta1 {\n\t}\n\n\t@Component(\"meta2\")\n\t@Transactional(readOnly = true)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Meta2 {\n\t}\n\n\t@Meta2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMeta {\n\t}\n\n\t@MetaMeta\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMetaMeta {\n\t}\n\n\t@MetaCycle3\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle1 {\n\t}\n\n\t@MetaCycle1\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle2 {\n\t}\n\n\t@MetaCycle2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle3 {\n\t}\n\n\t@Meta1\n\tinterface InterfaceWithMetaAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface\n\t\t\timplements InterfaceWithMetaAnnotation {\n\t}\n\n\t@Meta1\n\tstatic class ClassWithInheritedMetaAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class SubClassWithInheritedMetaAnnotation\n\t\t\textends ClassWithInheritedMetaAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedMetaAnnotation\n\t\t\textends SubClassWithInheritedMetaAnnotation {\n\t}\n\n\t@MetaMeta\n\tstatic class MetaMetaAnnotatedClass {\n\t}\n\n\t@MetaMetaMeta\n\tstatic class MetaMetaMetaAnnotatedClass {\n\t}\n\n\t@MetaCycle3\n\tstatic class MetaCycleAnnotatedClass {\n\t}\n\n\tinterface AnnotatedInterface {\n\n\t\t@Order(0)\n\t\tvoid fromInterfaceImplementedByRoot();\n\t}\n\n\tinterface NullableAnnotatedInterface {\n\n\t\t@Nullable String fromInterfaceImplementedByRoot();\n\t}\n\n\tstatic class Root implements AnnotatedInterface {\n\n\t\t@Order(27)\n\t\tpublic void annotatedOnRoot() {\n\t\t}\n\n\t\t@Meta1\n\t\tpublic void metaAnnotatedOnRoot() {\n\t\t}\n\n\t\tpublic void overrideToAnnotate() {\n\t\t}\n\n\t\t@Order(27)\n\t\tpublic void overrideWithoutNewAnnotation() {\n\t\t}\n\n\t\tpublic void notAnnotated() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void fromInterfaceImplementedByRoot() {\n\t\t}\n\t}\n\n\tpublic static class Leaf extends Root {\n\n\t\t@Order(25)\n\t\tpublic void annotatedOnLeaf() {\n\t\t}\n\n\t\t@Meta1\n\t\tpublic void metaAnnotatedOnLeaf() {\n\t\t}\n\n\t\t@MetaMeta\n\t\tpublic void metaMetaAnnotatedOnLeaf() {\n\t\t}\n\n\t\t@Override\n\t\t@Order(1)\n\t\tpublic void overrideToAnnotate() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void overrideWithoutNewAnnotation() {\n\t\t}\n\t}\n\n\tpublic abstract static class SimpleGeneric<T> {\n\n\t\t@Order(1)\n\t\tpublic abstract void something(T arg);\n\n\t}\n\n\tpublic static class TransactionalStringGeneric extends SimpleGeneric<String> {\n\n\t\t@Override\n\t\t@Transactional\n\t\tpublic void something(final String arg) {\n\t\t}\n\t}\n\n\t@Transactional\n\tpublic static class InheritedAnnotationClass {\n\t}\n\n\tpublic static class SubInheritedAnnotationClass extends InheritedAnnotationClass {\n\t}\n\n\t@Order\n\tpublic static class NonInheritedAnnotationClass {\n\t}\n\n\tpublic static class SubNonInheritedAnnotationClass\n\t\t\textends NonInheritedAnnotationClass {\n\t}\n\n\t@Transactional\n\tpublic static class TransactionalClass {\n\t}\n\n\t@Order\n\tpublic static class TransactionalAndOrderedClass extends TransactionalClass {\n\t}\n\n\tpublic static class SubTransactionalAndOrderedClass\n\t\t\textends TransactionalAndOrderedClass {\n\t}\n\n\tpublic interface InterfaceWithAnnotatedMethod {\n\n\t\t@Order\n\t\tvoid foo();\n\t}\n\n\tpublic static class ImplementsInterfaceWithAnnotatedMethod\n\t\t\timplements InterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic static class SubOfImplementsInterfaceWithAnnotatedMethod\n\t\t\textends ImplementsInterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic abstract static class AbstractDoesNotImplementInterfaceWithAnnotatedMethod\n\t\t\timplements InterfaceWithAnnotatedMethod {\n\t}\n\n\tpublic static class SubOfAbstractImplementsInterfaceWithAnnotatedMethod\n\t\t\textends AbstractDoesNotImplementInterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic interface InterfaceWithGenericAnnotatedMethod<T> {\n\n\t\t@Order\n\t\tvoid foo(T t);\n\t}\n\n\tpublic static class ImplementsInterfaceWithGenericAnnotatedMethod\n\t\t\timplements InterfaceWithGenericAnnotatedMethod<String> {\n\n\t\t@Override\n\t\tpublic void foo(String t) {\n\t\t}\n\t}\n\n\tpublic abstract static class BaseClassWithGenericAnnotatedMethod<T> {\n\n\t\t@Order\n\t\tabstract void foo(T t);\n\t}\n\n\tpublic static class ExtendsBaseClassWithGenericAnnotatedMethod\n\t\t\textends BaseClassWithGenericAnnotatedMethod<String> {\n\n\t\t@Override\n\t\tpublic void foo(String t) {\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface MyRepeatableContainer {\n\n\t\tMyRepeatable[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@Repeatable(MyRepeatableContainer.class)\n\t@interface MyRepeatable {\n\n\t\tString value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta1\")\n\t@interface MyRepeatableMeta1 {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta2\")\n\t@interface MyRepeatableMeta2 {\n\t}\n\n\tinterface InterfaceWithRepeated {\n\n\t\t@MyRepeatable(\"A\")\n\t\t@MyRepeatableContainer({ @MyRepeatable(\"B\"), @MyRepeatable(\"C\") })\n\t\t@MyRepeatableMeta1\n\t\tvoid foo();\n\t}\n\n\t@MyRepeatable(\"A\")\n\t@MyRepeatableContainer({ @MyRepeatable(\"B\"), @MyRepeatable(\"C\") })\n\t@MyRepeatableMeta1\n\tstatic class MyRepeatableClass {\n\t}\n\n\tstatic class SubMyRepeatableClass extends MyRepeatableClass {\n\t}\n\n\t@MyRepeatable(\"X\")\n\t@MyRepeatableContainer({ @MyRepeatable(\"Y\"), @MyRepeatable(\"Z\") })\n\t@MyRepeatableMeta2\n\tstatic class SubMyRepeatableWithAdditionalLocalDeclarationsClass\n\t\t\textends MyRepeatableClass {\n\t}\n\n\tstatic class SubSubMyRepeatableWithAdditionalLocalDeclarationsClass\n\t\t\textends SubMyRepeatableWithAdditionalLocalDeclarationsClass {\n\t}\n\n\tenum RequestMethod {\n\t\tGET,\n\n\t\tPOST;\n\n\t\t/**\n\t\t * custom override to verify annotation toString() implementations.\n\t\t */\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"method: \" + name().toLowerCase();\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface RequestMapping {\n\n\t\tString name();\n\n\t\t@AliasFor(\"path\")\n\t\tString[] value() default \"\";\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tString[] path() default \"\";\n\n\t\tRequestMethod[] method() default {};\n\n\t\t// ---------------------------------------------------------------------\n\t\t// All remaining attributes declare default values that are used solely\n\t\t// for the purpose of testing the toString() implementations for annotations.\n\t\tClass<?> clazz() default RequestMethod.class;\n\t\tClass<?>[] classes() default {int[][].class, RequestMethod[].class};\n\n\t\tchar ch() default 'X';\n\t\tchar[] chars() default {'X'};\n\n\t\tbyte byteValue() default (byte) 0xFF;\n\t\tbyte[] bytes() default {(byte) 0xFF};\n\n\t\tshort shortValue() default 9876;\n\t\tshort[] shorts() default {9876};\n\n\t\tlong longValue() default 42L;\n\t\tlong[] longs() default {42L};\n\n\t\tfloat floatValue() default 3.14F;\n\t\tfloat[] floats() default {3.14F};\n\n\t\tdouble doubleValue() default 99.999D;\n\t\tdouble[] doubles() default {99.999D};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@RequestMapping(method = RequestMethod.GET, name = \"\")\n\t@interface GetMapping {\n\n\t\t@AliasFor(annotation = RequestMapping.class)\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = RequestMapping.class)\n\t\tString path() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@RequestMapping(method = RequestMethod.POST, name = \"\")\n\t@interface PostMapping {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = RequestMapping.class)\n\t\tString path() default \"\";\n\t}\n\n\t@Component(\"webController\")\n\tstatic class WebController {\n\n\t\t@RequestMapping(value = \"/test\", name = \"foo\")\n\t\tpublic void handleMappedWithValueAttribute() {\n\t\t}\n\n\t\t@RequestMapping(path = \"/test\", name = \"bar\", method = { RequestMethod.GET,\n\t\t\tRequestMethod.POST })\n\t\tpublic void handleMappedWithPathAttribute() {\n\t\t}\n\n\t\t@GetMapping(\"/test\")\n\t\tpublic void getMappedWithValueAttribute() {\n\t\t}\n\n\t\t@GetMapping(path = \"/test\")\n\t\tpublic void getMappedWithPathAttribute() {\n\t\t}\n\n\t\t@PostMapping(path = \"/test\")\n\t\tpublic void postMappedWithPathAttribute() {\n\t\t}\n\n\t\t@RequestMapping(value = \"/test\", path = \"/test\", name = \"bar\", method = {\n\t\t\tRequestMethod.GET, RequestMethod.POST })\n\t\tpublic void handleMappedWithSamePathAndValueAttributes() {\n\t\t}\n\n\t\t@RequestMapping(value = \"/enigma\", path = \"/test\", name = \"baz\")\n\t\tpublic void handleMappedWithDifferentPathAndValueAttributes() {\n\t\t}\n\t}\n\n\t/**\n\t * Mimics jakarta.persistence.Id\n\t */\n\t@Retention(RUNTIME)\n\t@interface Id {\n\t}\n\n\t/**\n\t * Mimics jakarta.persistence.GeneratedValue\n\t */\n\t@Retention(RUNTIME)\n\t@interface GeneratedValue {\n\t\tString strategy();\n\t}\n\n\t@Id\n\t@GeneratedValue(strategy = \"AUTO\")\n\tprivate Long getId() {\n\t\treturn 42L;\n\t}\n\n\t/**\n\t * Mimics org.springframework.security.config.annotation.authentication.configuration.EnableGlobalAuthentication\n\t */\n\t@Retention(RUNTIME)\n\t@interface EnableGlobalAuthentication {\n\t}\n\n\t/**\n\t * Mimics org.springframework.security.config.annotation.web.configuration.EnableWebSecurity\n\t */\n\t@Retention(RUNTIME)\n\t@EnableGlobalAuthentication\n\t@interface EnableWebSecurity {\n\t}\n\n\t@EnableWebSecurity\n\tstatic class SecurityConfig {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ ElementType.FIELD, ElementType.ANNOTATION_TYPE })\n\t@interface RootAnnotation {\n\t\tString value() default \"\";\n\t\tboolean flag() default false;\n\t}\n\n\t@RootAnnotation\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ ElementType.FIELD, ElementType.ANNOTATION_TYPE })\n\t@interface ComposedRootAnnotation {\n\n\t\t@AliasFor(annotation = RootAnnotation.class, attribute = \"flag\")\n\t\tboolean enabled() default true;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.FIELD)\n\t@ComposedRootAnnotation\n\t@interface DoublyComposedRootAnnotation {\n\t}\n\n\tclass DomainType {\n\n\t\t@RootAnnotation\n\t\tObject directlyAnnotated;\n\n\t\t@ComposedRootAnnotation\n\t\tObject metaAnnotated;\n\n\t\t@DoublyComposedRootAnnotation\n\t\tObject metaMetaAnnotated;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestConfiguration {\n\n\t\t@AliasFor(\"location\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString location() default \"\";\n\n\t\tClass<?> configClass() default Object.class;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Hierarchy {\n\n\t\tTestConfiguration[] value();\n\t}\n\n\t@Hierarchy({ @TestConfiguration(\"A\"), @TestConfiguration(location = \"B\") })\n\tstatic class HierarchyClass {\n\t}\n\n\t@TestConfiguration(\"simple.xml\")\n\tstatic class TestConfigurationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface CharsContainer {\n\n\t\t@AliasFor(attribute = \"chars\")\n\t\tchar[] value() default {};\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tchar[] chars() default {};\n\t}\n\n\t@CharsContainer(chars = { 'x', 'y', 'z' })\n\tstatic class GroupOfCharsClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMissingAttributeDeclaration {\n\n\t\t@AliasFor\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForWithMissingAttributeDeclaration\n\tstatic class AliasForWithMissingAttributeDeclarationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithDuplicateAttributeDeclaration {\n\n\t\t@AliasFor(value = \"bar\", attribute = \"baz\")\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForWithDuplicateAttributeDeclaration\n\tstatic class AliasForWithDuplicateAttributeDeclarationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForNonexistentAttribute {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForNonexistentAttribute\n\tstatic class AliasForNonexistentAttributeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithoutMirroredAliasFor {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"\";\n\n\t\tString bar() default \"\";\n\t}\n\n\t@AliasForWithoutMirroredAliasFor\n\tstatic class AliasForWithoutMirroredAliasForClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMirroredAliasForWrongAttribute {\n\n\t\t@AliasFor(attribute = \"bar\")\n\t\tString[] foo() default \"\";\n\n\t\t@AliasFor(attribute = \"quux\")\n\t\tString[] bar() default \"\";\n\t}\n\n\t@AliasForWithMirroredAliasForWrongAttribute\n\tstatic class AliasForWithMirroredAliasForWrongAttributeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForAttributeOfDifferentType {\n\n\t\t@AliasFor(\"bar\")\n\t\tString[] foo() default \"\";\n\n\t\t@AliasFor(\"foo\")\n\t\tboolean bar() default true;\n\t}\n\n\t@AliasForAttributeOfDifferentType\n\tstatic class AliasForAttributeOfDifferentTypeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMissingDefaultValues {\n\n\t\t@AliasFor(attribute = \"bar\")\n\t\tString foo();\n\n\t\t@AliasFor(attribute = \"foo\")\n\t\tString bar();\n\t}\n\n\t@AliasForWithMissingDefaultValues(foo = \"foo\", bar = \"bar\")\n\tstatic class AliasForWithMissingDefaultValuesClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForAttributeWithDifferentDefaultValue {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"X\";\n\n\t\t@AliasFor(\"foo\")\n\t\tString bar() default \"Z\";\n\t}\n\n\t@AliasForAttributeWithDifferentDefaultValue\n\tstatic class AliasForAttributeWithDifferentDefaultValueClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedTestConfigurationNotMetaPresent {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlConfigFile();\n\t}\n\n\t@AliasedComposedTestConfigurationNotMetaPresent(xmlConfigFile = \"test.xml\")\n\tstatic class AliasedComposedTestConfigurationNotMetaPresentClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlConfigFile();\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface ImplicitAliasesTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString groovyScript() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location1() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location2() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location3() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"configClass\")\n\t\tClass<?> configClass() default Object.class;\n\n\t\tString nonAliasedAttribute() default \"\";\n\t}\n\n\t@ImplicitAliasesTestConfiguration(groovyScript = \"groovyScript\")\n\tstatic class GroovyImplicitAliasesSimpleTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(xmlFile = \"xmlFile\")\n\tstatic class XmlImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(\"value\")\n\tstatic class ValueImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(location1 = \"location1\")\n\tstatic class Location1ImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(location2 = \"location2\")\n\tstatic class Location2ImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(location3 = \"location3\")\n\tstatic class Location3ImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class)\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class)\n\t\tString location() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration.class, attribute = \"location\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration(\"value\")\n\tstatic class ValueImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration(location = \"location\")\n\tstatic class LocationsImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration(xmlFile = \"xmlFile\")\n\tstatic class XmlFilesImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithMissingDefaultValuesTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location1();\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location2();\n\t}\n\n\t@ImplicitAliasesWithMissingDefaultValuesTestConfiguration(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithMissingDefaultValuesTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithDifferentDefaultValuesTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location1() default \"foo\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location2() default \"bar\";\n\t}\n\n\t@ImplicitAliasesWithDifferentDefaultValuesTestConfiguration(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithDifferentDefaultValuesTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithDuplicateValuesTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location1() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location2() default \"\";\n\t}\n\n\t@ImplicitAliasesWithDuplicateValuesTestConfiguration(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithDuplicateValuesTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesForAliasPairTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, value = \"value\")\n\t\tString groovyScript() default \"\";\n\t}\n\n\t@ImplicitAliasesForAliasPairTestConfiguration(xmlFile = \"test.xml\")\n\tstatic class ImplicitAliasesForAliasPairTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesTestConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesTestConfiguration.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesTestConfiguration.class, attribute = \"groovyScript\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@TransitiveImplicitAliasesTestConfiguration(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesForAliasPairTestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesForAliasPairTestConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesForAliasPairTestConfiguration.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesForAliasPairTestConfiguration.class, attribute = \"groovyScript\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@TransitiveImplicitAliasesForAliasPairTestConfiguration(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesForAliasPairTestConfigurationClass {\n\t}\n\n\t@ComponentScan(excludeFilters = { @Filter(pattern = \"*Foo\"),\n\t\t@Filter(pattern = \"*Bar\") })\n\tstatic class ComponentScanClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScanSingleFilter {\n\n\t\tFilter value();\n\t}\n\n\t@ComponentScanSingleFilter(@Filter(pattern = \"*Foo\"))\n\tstatic class ComponentScanSingleFilterClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnotationWithDefaults {\n\n\t\tString text() default \"enigma\";\n\n\t\tboolean predicate() default true;\n\n\t\tchar[] characters() default { 'a', 'b', 'c' };\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnotationWithoutDefaults {\n\n\t\tString text();\n\t}\n\n\t@TestConfiguration(value = \"foo\", location = \"bar\")\n\tinterface TestConfigurationMismatch {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface DefaultOverrideRoot {\n\n\t\tString text() default \"root\";\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideRoot\n\t@interface DefaultOverrideMeta {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideMeta\n\t@interface DefaultOverrideMetaMeta {\n\n\t\tString text() default \"metameta\";\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideMetaMeta\n\t@interface DefaultOverrideMetaMetaMeta {\n\n\t}\n\n\t@DefaultOverrideMetaMetaMeta\n\tstatic class DefaultOverrideClass {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideRoot\n\t@interface DefaultOverrideImplicitAlias {\n\n\t\t@AliasFor(annotation=DefaultOverrideRoot.class, attribute=\"text\")\n\t\tString text1() default \"alias\";\n\n\t\t@AliasFor(annotation=DefaultOverrideRoot.class, attribute=\"text\")\n\t\tString text2() default \"alias\";\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideImplicitAlias(text1=\"alias-meta-1\")\n\t@interface DefaultOverrideAliasImplicitMeta1 {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideImplicitAlias(text2=\"alias-meta-2\")\n\t@interface DefaultOverrideImplicitAliasMeta2 {\n\n\t}\n\n\t@DefaultOverrideAliasImplicitMeta1\n\tstatic class DefaultOverrideImplicitAliasMetaClass1 {\n\n\t}\n\n\t@DefaultOverrideImplicitAliasMeta2\n\tstatic class DefaultOverrideImplicitAliasMetaClass2 {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface DefaultOverrideExplicitAliasRoot {\n\n\t\t@AliasFor(\"value\")\n\t\tString text() default \"\";\n\n\t\t@AliasFor(\"text\")\n\t\tString value() default \"\";\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideExplicitAliasRoot(\"meta\")\n\t@interface DefaultOverrideExplicitAliasRootMeta {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideExplicitAliasRootMeta\n\t@interface DefaultOverrideExplicitAliasRootMetaMeta {\n\n\t}\n\n\t@DefaultOverrideExplicitAliasRootMetaMeta\n\tstatic class DefaultOverrideExplicitAliasRootMetaMetaClass {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ValueAttribute {\n\n\t\tString[] value();\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueAttribute(\"FromValueAttributeMeta\")\n\t@interface ValueAttributeMeta {\n\n\t\tString[] value() default {};\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueAttributeMeta(\"FromValueAttributeMetaMeta\")\n\t@interface ValueAttributeMetaMeta {\n\n\t}\n\n\t@ValueAttributeMetaMeta\n\tstatic class ValueAttributeMetaMetaClass {\n\n\t}\n\t// @formatter:on\n\n\tstatic void assertSynthesized(Annotation annotation) {\n\t\tassertThat(AnnotationUtils.isSynthesizedAnnotation(annotation)).as(\"synthesized annotation\").isTrue();\n\t}\n\n\tstatic void assertNotSynthesized(Annotation annotation) {\n\t\tassertThat(AnnotationUtils.isSynthesizedAnnotation(annotation)).as(\"synthesized annotation\").isFalse();\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.AliasedValueComposedContextConfigurationClass",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.AliasedValueComposedContextConfigurationClass",
    "headType": "class",
    "relation": "use",
    "tail": "@AliasedValueComposedContextConfiguration",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.AliasedValueComposedContextConfigurationClass",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.stream.Stream;\n\nimport jakarta.annotation.Resource;\nimport org.jspecify.annotations.Nullable;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.AnnotationsScannerTests.Hello2Impl;\nimport org.springframework.core.annotation.AnnotationsScannerTests.TestAnnotation1;\nimport org.springframework.core.annotation.MergedAnnotation.Adapt;\nimport org.springframework.core.annotation.MergedAnnotations.Search;\nimport org.springframework.core.annotation.MergedAnnotations.SearchStrategy;\nimport org.springframework.core.annotation.subpackage.NonPublicAnnotatedClass;\nimport org.springframework.core.testfixture.ide.IdeUtils;\nimport org.springframework.core.testfixture.stereotype.Component;\nimport org.springframework.core.testfixture.stereotype.Indexed;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.MultiValueMap;\nimport org.springframework.util.ReflectionUtils;\n\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.assertj.core.api.Assertions.assertThatIllegalStateException;\nimport static org.assertj.core.api.Assertions.entry;\n\n/**\n * Tests for {@link MergedAnnotations} and {@link MergedAnnotation}. These tests\n * cover common usage scenarios and were mainly ported from the original\n * {@code AnnotationUtils} and {@code AnnotatedElementUtils} tests.\n *\n * @author Phillip Webb\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Chris Beams\n * @author Oleg Zhurakousky\n * @author Rossen Stoyanchev\n * @see MergedAnnotationsRepeatableAnnotationTests\n * @see MergedAnnotationClassLoaderTests\n */\nclass MergedAnnotationsTests {\n\n\t/**\n\t * Subset (and duplication) of other tests in {@link MergedAnnotationsTests}\n\t * that verify behavior of the fluent {@link Search} API.\n\t * @since 6.0\n\t */\n\t@Nested\n\tclass FluentSearchApiTests {\n\n\t\t@Test\n\t\tvoid preconditions() {\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> MergedAnnotations.search(null))\n\t\t\t\t\t.withMessage(\"SearchStrategy must not be null\");\n\n\t\t\tSearch search = MergedAnnotations.search(SearchStrategy.SUPERCLASS);\n\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> search.withEnclosingClasses(null))\n\t\t\t\t\t.withMessage(\"Predicate must not be null\");\n\t\t\tassertThatIllegalStateException()\n\t\t\t\t\t.isThrownBy(() -> search.withEnclosingClasses(Search.always))\n\t\t\t\t\t.withMessage(\"A custom 'searchEnclosingClass' predicate can only be combined with SearchStrategy.TYPE_HIERARCHY\");\n\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> search.withAnnotationFilter(null))\n\t\t\t\t\t.withMessage(\"AnnotationFilter must not be null\");\n\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> search.withRepeatableContainers(null))\n\t\t\t\t\t.withMessage(\"RepeatableContainers must not be null\");\n\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> search.from(null))\n\t\t\t\t\t.withMessage(\"AnnotatedElement must not be null\");\n\t\t}\n\n\t\t@Test\n\t\tvoid searchFromClassWithDefaultAnnotationFilterAndDefaultRepeatableContainers() {\n\t\t\tStream<Class<?>> classes = MergedAnnotations.search(SearchStrategy.DIRECT)\n\t\t\t\t\t.from(TransactionalComponent.class)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Transactional.class, Component.class, Indexed.class);\n\t\t}\n\n\t\t@Test\n\t\tvoid searchFromClassWithCustomAnnotationFilter() {\n\t\t\tStream<Class<?>> classes = MergedAnnotations.search(SearchStrategy.DIRECT)\n\t\t\t\t\t.withAnnotationFilter(annotationName -> annotationName.endsWith(\"Indexed\"))\n\t\t\t\t\t.from(TransactionalComponent.class)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Transactional.class, Component.class);\n\t\t}\n\n\t\t@Test\n\t\tvoid searchFromClassWithCustomRepeatableContainers() {\n\t\t\tassertThat(MergedAnnotations.from(HierarchyClass.class).stream(TestConfiguration.class)).isEmpty();\n\t\t\tRepeatableContainers containers = RepeatableContainers.of(TestConfiguration.class, Hierarchy.class);\n\n\t\t\tMergedAnnotations annotations = MergedAnnotations.search(SearchStrategy.DIRECT)\n\t\t\t\t\t.withRepeatableContainers(containers)\n\t\t\t\t\t.from(HierarchyClass.class);\n\t\t\tassertThat(annotations.stream(TestConfiguration.class))\n\t\t\t\t\t.map(annotation -> annotation.getString(\"location\"))\n\t\t\t\t\t.containsExactly(\"A\", \"B\");\n\t\t\tassertThat(annotations.stream(TestConfiguration.class))\n\t\t\t\t\t.map(annotation -> annotation.getString(\"value\"))\n\t\t\t\t\t.containsExactly(\"A\", \"B\");\n\t\t}\n\n\t\t/**\n\t\t * @since 6.0\n\t\t */\n\t\t@Test\n\t\tvoid searchFromNonAnnotatedInnerClassWithAnnotatedEnclosingClassWithEnclosingClassPredicates() {\n\t\t\tClass<?> testCase = AnnotatedClass.NonAnnotatedInnerClass.class;\n\t\t\tSearch search = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY);\n\n\t\t\tassertThat(search.from(testCase).stream()).isEmpty();\n\t\t\tassertThat(search.withEnclosingClasses(Search.never).from(testCase).stream()).isEmpty();\n\t\t\tassertThat(search.withEnclosingClasses(ClassUtils::isStaticClass).from(testCase).stream()).isEmpty();\n\n\t\t\tStream<Class<?>> classes = search.withEnclosingClasses(ClassUtils::isInnerClass)\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class, Indexed.class);\n\n\t\t\tclasses = search.withEnclosingClasses(Search.always)\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class, Indexed.class);\n\n\t\t\tclasses = search.withEnclosingClasses(ClassUtils::isInnerClass)\n\t\t\t\t\t.withRepeatableContainers(RepeatableContainers.none())\n\t\t\t\t\t.withAnnotationFilter(annotationName -> annotationName.endsWith(\"Indexed\"))\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class);\n\t\t}\n\n\t\t/**\n\t\t * @since 6.0\n\t\t */\n\t\t@Test\n\t\tvoid searchFromNonAnnotatedStaticNestedClassWithAnnotatedEnclosingClassWithEnclosingClassPredicates() {\n\t\t\tClass<?> testCase = AnnotatedClass.NonAnnotatedStaticNestedClass.class;\n\t\t\tSearch search = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY);\n\n\t\t\tassertThat(search.from(testCase).stream()).isEmpty();\n\t\t\tassertThat(search.withEnclosingClasses(Search.never).from(testCase).stream()).isEmpty();\n\t\t\tassertThat(search.withEnclosingClasses(ClassUtils::isInnerClass).from(testCase).stream()).isEmpty();\n\n\t\t\tStream<Class<?>> classes = search.withEnclosingClasses(ClassUtils::isStaticClass)\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class, Indexed.class);\n\n\t\t\tclasses = search.withEnclosingClasses(Search.always)\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class, Indexed.class);\n\t\t}\n\t}\n\n\n\t@Nested\n\tclass ConventionBasedAnnotationAttributeOverrideTests {\n\n\t\t@Test\n\t\tvoid getWithInheritedAnnotationsAttributesWithConventionBasedComposedAnnotation() {\n\t\t\tMergedAnnotation<?> annotation =\n\t\t\t\t\tMergedAnnotations.from(ConventionBasedComposedContextConfigurationClass.class,\n\t\t\t\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\t\tassertThat(annotation.isPresent()).isTrue();\n\t\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"explicitDeclaration\");\n\t\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"explicitDeclaration\");\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithInheritedAnnotationsFromHalfConventionBasedAndHalfAliasedComposedAnnotation1() {\n\t\t\t// SPR-13554: convention mapping mixed with AliasFor annotations\n\t\t\t// xmlConfigFiles can be used because it has an AliasFor annotation\n\t\t\tMergedAnnotation<?> annotation =\n\t\t\t\t\tMergedAnnotations.from(HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass1.class,\n\t\t\t\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"explicitDeclaration\");\n\t\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"explicitDeclaration\");\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithInheritedAnnotationsFromHalfConventionBasedAndHalfAliasedComposedAnnotation2() {\n\t\t\t// SPR-13554: convention mapping mixed with AliasFor annotations\n\t\t\t// locations doesn't apply because it has no AliasFor annotation\n\t\t\tMergedAnnotation<?> annotation =\n\t\t\t\t\tMergedAnnotations.from(HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass2.class,\n\t\t\t\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\t\tassertThat(annotation.getStringArray(\"locations\")).isEmpty();\n\t\t\tassertThat(annotation.getStringArray(\"value\")).isEmpty();\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithInheritedAnnotationsFromInvalidConventionBasedComposedAnnotation() {\n\t\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(InvalidConventionBasedComposedContextConfigurationClass.class,\n\t\t\t\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class));\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithTypeHierarchyWithSingleElementOverridingAnArrayViaConvention() {\n\t\t\ttestGetWithTypeHierarchy(ConventionBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithTypeHierarchyWithLocalAliasesThatConflictWithAttributesInMetaAnnotationByConvention() {\n\t\t\tMergedAnnotation<?> annotation =\n\t\t\t\t\tMergedAnnotations.from(SpringApplicationConfigurationClass.class, SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t\t\t\t.get(ContextConfiguration.class);\n\t\t\tassertThat(annotation.getStringArray(\"locations\")).isEmpty();\n\t\t\tassertThat(annotation.getStringArray(\"value\")).isEmpty();\n\t\t\tassertThat(annotation.getClassArray(\"classes\")).containsExactly(Number.class);\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithTypeHierarchyOnMethodWithSingleElementOverridingAnArrayViaConvention() throws Exception {\n\t\t\ttestGetWithTypeHierarchyWebMapping(WebController.class.getMethod(\"postMappedWithPathAttribute\"));\n\t\t}\n\t}\n\n\n\t@Test\n\tvoid fromPreconditions() {\n\t\tSearchStrategy strategy = SearchStrategy.DIRECT;\n\t\tRepeatableContainers containers = RepeatableContainers.standardRepeatables();\n\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(getClass(), strategy, null, AnnotationFilter.PLAIN))\n\t\t\t\t.withMessage(\"RepeatableContainers must not be null\");\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(getClass(), strategy, containers, null))\n\t\t\t\t.withMessage(\"AnnotationFilter must not be null\");\n\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(getClass(), new Annotation[0], null, AnnotationFilter.PLAIN))\n\t\t\t\t.withMessage(\"RepeatableContainers must not be null\");\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(getClass(), new Annotation[0], containers, null))\n\t\t\t\t.withMessage(\"AnnotationFilter must not be null\");\n\t}\n\n\t@Test\n\tvoid streamWhenFromNonAnnotatedClass() {\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class).stream(TransactionalComponent.class)).isEmpty();\n\t}\n\n\t@Test\n\tvoid streamWhenFromClassWithMetaDepth1() {\n\t\tStream<Class<?>> classes = MergedAnnotations.from(TransactionalComponent.class)\n\t\t\t\t.stream().map(MergedAnnotation::getType);\n\t\tassertThat(classes).containsExactly(Transactional.class, Component.class, Indexed.class);\n\t}\n\n\t@Test\n\tvoid streamWhenFromClassWithMetaDepth2() {\n\t\tStream<Class<?>> classes = MergedAnnotations.from(ComposedTransactionalComponent.class)\n\t\t\t\t.stream().map(MergedAnnotation::getType);\n\t\tassertThat(classes).containsExactly(TransactionalComponent.class,\n\t\t\t\tTransactional.class, Component.class, Indexed.class);\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromNonAnnotatedClass() {\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class).isPresent(Transactional.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromAnnotationClassWithMetaDepth0() {\n\t\tassertThat(MergedAnnotations.from(TransactionalComponent.class).isPresent(TransactionalComponent.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromAnnotationClassWithMetaDepth1() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(TransactionalComponent.class);\n\t\tassertThat(annotations.isPresent(Transactional.class)).isTrue();\n\t\tassertThat(annotations.isPresent(Component.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromAnnotationClassWithMetaDepth2() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponent.class);\n\t\tassertThat(annotations.isPresent(Transactional.class)).isTrue();\n\t\tassertThat(annotations.isPresent(Component.class)).isTrue();\n\t\tassertThat(annotations.isPresent(ComposedTransactionalComponent.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromClassWithMetaDepth0() {\n\t\tassertThat(MergedAnnotations.from(TransactionalComponentClass.class).isPresent(TransactionalComponent.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromSubclassWithMetaDepth0() {\n\t\tassertThat(MergedAnnotations.from(SubTransactionalComponentClass.class).isPresent(TransactionalComponent.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromClassWithMetaDepth1() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(TransactionalComponentClass.class);\n\t\tassertThat(annotations.isPresent(Transactional.class)).isTrue();\n\t\tassertThat(annotations.isPresent(Component.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromClassWithMetaDepth2() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\n\t\tassertThat(annotations.isPresent(Transactional.class)).isTrue();\n\t\tassertThat(annotations.isPresent(Component.class)).isTrue();\n\t\tassertThat(annotations.isPresent(ComposedTransactionalComponent.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid getParent() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\n\t\tassertThat(annotations.get(TransactionalComponent.class).getMetaSource().getType())\n\t\t\t\t.isEqualTo(ComposedTransactionalComponent.class);\n\t}\n\n\t@Test\n\tvoid getRootWhenNotDirect() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\n\t\tMergedAnnotation<?> annotation = annotations.get(TransactionalComponent.class);\n\t\tassertThat(annotation.getDistance()).isGreaterThan(0);\n\t\tassertThat(annotation.getRoot().getType()).isEqualTo(ComposedTransactionalComponent.class);\n\t}\n\n\t@Test\n\tvoid getRootWhenDirect() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\n\t\tMergedAnnotation<?> annotation = annotations.get(ComposedTransactionalComponent.class);\n\t\tassertThat(annotation.getDistance()).isEqualTo(0);\n\t\tassertThat(annotation.getRoot()).isSameAs(annotation);\n\t}\n\n\t@Test\n\tvoid getMetaTypes() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(ComposedTransactionalComponentClass.class)\n\t\t\t\t.get(TransactionalComponent.class);\n\t\tassertThat(annotation.getMetaTypes()).containsExactly(\n\t\t\t\tComposedTransactionalComponent.class, TransactionalComponent.class);\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFromNonAnnotatedClass() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(NonAnnotatedClass.class)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).isEmpty();\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFromClassWithLocalAnnotation() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(TxConfig.class)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"value\", List.of(\"TxConfig\")));\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFromClassWithLocalComposedAnnotationAndInheritedAnnotation() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"qualifier\", List.of(\"composed2\", \"transactionManager\")));\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"qualifier\", List.of(\"transactionManager\")));\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedComposedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"qualifier\", List.of(\"composed1\")));\n\t}\n\n\t/**\n\t * If the \"value\" entry contains both \"DerivedTxConfig\" AND \"TxConfig\", then\n\t * the algorithm is accidentally picking up shadowed annotations of the same\n\t * type within the class hierarchy. Such undesirable behavior would cause\n\t * the logic in\n\t * {@code org.springframework.context.annotation.ProfileCondition} to fail.\n\t */\n\t@Test\n\tvoid collectMultiValueMapFromClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tDerivedTxConfig.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"value\", List.of(\"DerivedTxConfig\")));\n\t}\n\n\t/**\n\t * Note: this functionality is required by\n\t * {@code org.springframework.context.annotation.ProfileCondition}.\n\t */\n\t@Test\n\tvoid collectMultiValueMapFromClassWithMultipleComposedAnnotations() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tTxFromMultipleComposedAnnotations.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"value\", List.of(\"TxInheritedComposed\", \"TxComposed\")));\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromClassWithLocalAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tTxConfig.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"TxConfig\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tDerivedTxConfig.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"DerivedTxConfig\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaCycleAnnotatedClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isFalse();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFavorsLocalComposedAnnotationOverInheritedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getBoolean(\"readOnly\")).isTrue();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getBoolean(\"readOnly\")).isFalse();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedComposedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getBoolean(\"readOnly\")).isFalse();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromInterfaceImplementedBySuperclass() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tConcreteClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isFalse();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tInheritedAnnotationInterface.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationInterface.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t}\n\n\n\t@Test\n\tvoid withInheritedAnnotationsFromAliasedComposedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tAliasedComposedContextConfigurationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"test.xml\");\n\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid withInheritedAnnotationsFromAliasedValueComposedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tAliasedValueComposedContextConfigurationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"test.xml\");\n\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromImplicitAliasesInMetaAnnotationOnComposedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tComposedImplicitAliasesContextConfigurationClass.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.get(ImplicitAliasesContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"groovyScripts\")).containsExactly(\"A.xml\", \"B.xml\");\n\t\tassertThat(annotation.getStringArray(\"xmlFiles\")).containsExactly(\"A.xml\", \"B.xml\");\n\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"A.xml\", \"B.xml\");\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"A.xml\", \"B.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromAliasedValueComposedAnnotation() {\n\t\ttestGetWithInherited(AliasedValueComposedContextConfigurationClass.class, \"test.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromImplicitAliasesForSameAttributeInComposedAnnotation() {\n\t\ttestGetWithInherited(ImplicitAliasesContextConfigurationClass1.class, \"foo.xml\");\n\t\ttestGetWithInherited(ImplicitAliasesContextConfigurationClass2.class, \"bar.xml\");\n\t\ttestGetWithInherited(ImplicitAliasesContextConfigurationClass3.class, \"baz.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromTransitiveImplicitAliases() {\n\t\ttestGetWithInherited(TransitiveImplicitAliasesContextConfigurationClass.class, \"test.groovy\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\ttestGetWithInherited(\n\t\t\t\tSingleLocationTransitiveImplicitAliasesContextConfigurationClass.class, \"test.groovy\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSkippedLevel() {\n\t\ttestGetWithInherited(\n\t\t\t\tTransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass.class, \"test.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSkippedLevelWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\ttestGetWithInherited(\n\t\t\t\tSingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass.class, \"test.xml\");\n\t}\n\n\tprivate void testGetWithInherited(Class<?> element, String... expected) {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(element, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.get(ContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"locations\")).isEqualTo(expected);\n\t\tassertThat(annotation.getStringArray(\"value\")).isEqualTo(expected);\n\t\tassertThat(annotation.getClassArray(\"classes\")).isEmpty();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromShadowedAliasComposedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tShadowedAliasComposedContextConfigurationClass.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.get(ContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"test.xml\");\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromSubInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromSubSubInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromSubNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromSubSubNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyInheritedFromInterfaceMethod() throws Exception {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleFromInterface\");\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test  // gh-31803\n\tvoid streamWithTypeHierarchyInheritedFromSuperInterfaceMethod() throws Exception {\n\t\tMethod method = Hello2Impl.class.getMethod(\"method\");\n\t\tlong count = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.from(method).stream(TestAnnotation1.class).count();\n\t\tassertThat(count).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyInheritedFromAbstractMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handle\");\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyInheritedFromBridgedMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleParameterized\", String.class);\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromBridgeMethod() {\n\t\tList<Method> methods = new ArrayList<>();\n\t\tReflectionUtils.doWithLocalMethods(StringGenericParameter.class, method -> {\n\t\t\tif (\"getFor\".equals(method.getName())) {\n\t\t\t\tmethods.add(method);\n\t\t\t}\n\t\t});\n\t\tMethod bridgeMethod = methods.get(0).getReturnType().equals(Object.class) ?\n\t\t\t\tmethods.get(0) : methods.get(1);\n\t\tMethod bridgedMethod = methods.get(0).getReturnType().equals(Object.class) ?\n\t\t\t\tmethods.get(1) : methods.get(0);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(bridgeMethod,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromClassWithMetaAndLocalTxConfig() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaAndLocalTxConfigClass.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getString(\"qualifier\")).isEqualTo(\"localTxMgr\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromClassWithAttributeAliasesInTargetAnnotation() {\n\t\tMergedAnnotation<AliasedTransactional> mergedAnnotation = MergedAnnotations.from(\n\t\t\t\tAliasedTransactionalComponentClass.class, SearchStrategy.TYPE_HIERARCHY).get(AliasedTransactional.class);\n\t\tAliasedTransactional synthesizedAnnotation = mergedAnnotation.synthesize();\n\t\tString qualifier = \"aliasForQualifier\";\n\t\tassertThat(mergedAnnotation.getString(\"value\")).isEqualTo(qualifier);\n\t\tassertThat(mergedAnnotation.getString(\"qualifier\")).isEqualTo(qualifier);\n\t\tassertThat(synthesizedAnnotation.value()).isEqualTo(qualifier);\n\t\tassertThat(synthesizedAnnotation.qualifier()).isEqualTo(qualifier);\n\t}\n\n\t@Test // gh-23767\n\tvoid getWithTypeHierarchyFromClassWithComposedMetaTransactionalAnnotation() {\n\t\tMergedAnnotation<AliasedTransactional> mergedAnnotation = MergedAnnotations.from(\n\t\t\t\tComposedTransactionalClass.class, SearchStrategy.TYPE_HIERARCHY).get(AliasedTransactional.class);\n\t\tassertThat(mergedAnnotation.getString(\"value\")).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(mergedAnnotation.getString(\"qualifier\")).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t@Test // gh-23767\n\tvoid getWithTypeHierarchyFromClassWithMetaMetaAliasedTransactional() {\n\t\tMergedAnnotation<AliasedTransactional> mergedAnnotation = MergedAnnotations.from(\n\t\t\t\tMetaMetaAliasedTransactionalClass.class, SearchStrategy.TYPE_HIERARCHY).get(AliasedTransactional.class);\n\t\tassertThat(mergedAnnotation.getString(\"value\")).isEqualTo(\"meta\");\n\t\tassertThat(mergedAnnotation.getString(\"qualifier\")).isEqualTo(\"meta\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromClassWithAttributeAliasInComposedAnnotationAndNestedAnnotationsInTargetAnnotation() {\n\t\tMergedAnnotation<?> annotation = testGetWithTypeHierarchy(\n\t\t\t\tTestComponentScanClass.class, \"com.example.app.test\");\n\t\tMergedAnnotation<Filter>[] excludeFilters = annotation.getAnnotationArray(\n\t\t\t\t\"excludeFilters\", Filter.class);\n\t\tassertThat(Arrays.stream(excludeFilters).map(\n\t\t\t\tfilter -> filter.getString(\"pattern\"))).containsExactly(\"*Test\", \"*Tests\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromClassWithBothAttributesOfAnAliasPairDeclared() {\n\t\ttestGetWithTypeHierarchy(ComponentScanWithBasePackagesAndValueAliasClass.class, \"com.example.app.test\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\ttestGetWithTypeHierarchy(AliasForBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\n\t}\n\n\tprivate MergedAnnotation<?> testGetWithTypeHierarchy(Class<?> element, String... expected) {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(element,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(ComponentScan.class);\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(expected);\n\t\tassertThat(annotation.getStringArray(\"basePackages\")).containsExactly(expected);\n\t\treturn annotation;\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyWhenMultipleMetaAnnotationsHaveClashingAttributeNames() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tAliasedComposedContextConfigurationAndTestPropertySourceClass.class, SearchStrategy.TYPE_HIERARCHY);\n\t\tMergedAnnotation<?> contextConfig = annotations.get(ContextConfiguration.class);\n\t\tassertThat(contextConfig.getStringArray(\"locations\")).containsExactly(\"test.xml\");\n\t\tassertThat(contextConfig.getStringArray(\"value\")).containsExactly(\"test.xml\");\n\t\tMergedAnnotation<?> testPropSource = annotations.get(TestPropertySource.class);\n\t\tassertThat(testPropSource.getStringArray(\"locations\")).containsExactly(\"test.properties\");\n\t\tassertThat(testPropSource.getStringArray(\"value\")).containsExactly(\"test.properties\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyOnMethodWithSingleElementOverridingAnArrayViaAliasFor() throws Exception {\n\t\ttestGetWithTypeHierarchyWebMapping(WebController.class.getMethod(\"getMappedWithValueAttribute\"));\n\t\ttestGetWithTypeHierarchyWebMapping(WebController.class.getMethod(\"getMappedWithPathAttribute\"));\n\t}\n\n\tprivate void testGetWithTypeHierarchyWebMapping(AnnotatedElement element) {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.get(RequestMapping.class);\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"/test\");\n\t\tassertThat(annotation.getStringArray(\"path\")).containsExactly(\"/test\");\n\t}\n\n\t@Test\n\tvoid getDirectWithJavaxAnnotationType() {\n\t\tassertThat(MergedAnnotations.from(ResourceHolder.class).get(Resource.class)\n\t\t\t\t.getString(\"name\")).isEqualTo(\"x\");\n\t}\n\n\t@Test\n\tvoid streamInheritedFromClassWithInterface() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class)).isEmpty();\n\t}\n\n\t@Test\n\tvoid streamTypeHierarchyFromClassWithInterface() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.stream(Transactional.class)).hasSize(1);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithMethodAnnotationOnLeaf() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"annotatedOnLeaf\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNotNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class)\n\t\t\t\t.getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithAnnotationOnMethodInInterface() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"fromInterfaceImplementedByRoot\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class)\n\t\t\t\t.getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithMetaAnnotationOnLeaf() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"metaAnnotatedOnLeaf\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class)\n\t\t\t\t.getDistance()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithMetaMetaAnnotationOnLeaf() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"metaMetaAnnotatedOnLeaf\");\n\t\tassertThat(method.getAnnotation(Component.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Component.class).getDistance()).isEqualTo(2);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tComponent.class).getDistance()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getWithAnnotationOnRoot() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"annotatedOnRoot\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNotNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithMetaAnnotationOnRoot() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"metaAnnotatedOnRoot\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithOnRootButOverridden() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"overrideWithoutNewAnnotation\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithNotAnnotated() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"notAnnotated\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(-1);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithBridgeMethod() throws Exception {\n\t\tMethod method = TransactionalStringGeneric.class.getMethod(\"something\", Object.class);\n\t\tassertThat(method.isBridge()).isTrue();\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t\t// As of JDK 8, invoking getAnnotation() on a bridge method actually finds an\n\t\t// annotation on its 'bridged' method [1]; however, the Eclipse compiler does\n\t\t// not support this [2]. Thus, we effectively ignore the following\n\t\t// assertion if the test is currently executing within the Eclipse IDE.\n\t\t//\n\t\t// [1] https://bugs.openjdk.java.net/browse/JDK-6695379\n\t\t// [2] https://bugs.eclipse.org/bugs/show_bug.cgi?id=495396\n\t\t//\n\t\tif (!IdeUtils.runningInEclipse()) {\n\t\t\tassertThat(method.getAnnotation(Transactional.class)).isNotNull();\n\t\t}\n\t\tassertThat(MergedAnnotations.from(method).get(\n\t\t\t\tTransactional.class).getDistance()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tTransactional.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithBridgedMethod() throws Exception {\n\t\tMethod method = TransactionalStringGeneric.class.getMethod(\"something\", String.class);\n\t\tassertThat(method.isBridge()).isFalse();\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t\tassertThat(method.getAnnotation(Transactional.class)).isNotNull();\n\t\tassertThat(MergedAnnotations.from(method).get(\n\t\t\t\tTransactional.class).getDistance()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tTransactional.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test // SPR-16060\n\tvoid getFromMethodWithGenericInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test // SPR-17146\n\tvoid getFromMethodWithGenericSuperclass() throws Exception {\n\t\tMethod method = ExtendsBaseClassWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithInterfaceOnSuper() throws Exception {\n\t\tMethod method = SubOfImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWhenInterfaceWhenSuperDoesNotImplementMethod() throws Exception {\n\t\tMethod method = SubOfAbstractImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverAnnotationsOnInterfaces() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tClassWithLocalMetaAnnotationAndMetaAnnotatedInterface.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedAnnotation.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getBoolean(\"readOnly\")).isTrue();\n\t}\n\n\t@Test\n\tvoid getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedComposedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedMetaAnnotation.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid getDirectFromClassgetDirectFromClassMetaMetaAnnotatedClass() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaMetaAnnotatedClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithMetaMetaMetaAnnotatedClass() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaMetaMetaAnnotatedClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\t// TransactionalClass is NOT annotated or meta-annotated with @Component\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(TransactionalClass.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.isPresent()).isFalse();\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaCycleAnnotatedClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.isPresent()).isFalse();\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithSubInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithSubSubInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithSubNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithSubSubNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubNonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getSuperClassForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isNull();\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isNull();\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isEqualTo(\n\t\t\t\t\t\t\t\tInheritedAnnotationInterface.class);\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isNull();\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isEqualTo(\n\t\t\t\t\t\t\t\tInheritedAnnotationClass.class);\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isEqualTo(\n\t\t\t\t\t\t\t\tInheritedAnnotationClass.class);\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but we should still find it on classes.\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(Order.class).getSource()).isEqualTo(\n\t\t\t\t\t\tNonInheritedAnnotationInterface.class);\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(Order.class).getSource()).isNull();\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(Order.class).getSource()).isEqualTo(\n\t\t\t\t\t\tNonInheritedAnnotationClass.class);\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(Order.class).getSource()).isEqualTo(\n\t\t\t\t\t\tNonInheritedAnnotationClass.class);\n\t}\n\n\t@Test\n\tvoid getSuperClassSourceForTypesWithSingleCandidateType() {\n\t\t// no class-level annotation\n\t\tList<Class<? extends Annotation>> transactionalCandidateList = Collections.singletonList(Transactional.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonAnnotatedInterface.class,\n\t\t\t\ttransactionalCandidateList)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonAnnotatedClass.class,\n\t\t\t\ttransactionalCandidateList)).isNull();\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationInterface.class,\n\t\t\t\ttransactionalCandidateList)).isEqualTo(\n\t\t\t\t\t\tInheritedAnnotationInterface.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationInterface.class,\n\t\t\t\ttransactionalCandidateList)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationClass.class,\n\t\t\t\ttransactionalCandidateList)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationClass.class,\n\t\t\t\ttransactionalCandidateList)).isEqualTo(InheritedAnnotationClass.class);\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but should still find it on classes.\n\t\tList<Class<? extends Annotation>> orderCandidateList = Collections.singletonList(\n\t\t\t\tOrder.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationInterface.class,\n\t\t\t\torderCandidateList)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationInterface.class,\n\t\t\t\torderCandidateList)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationClass.class,\n\t\t\t\torderCandidateList)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationClass.class,\n\t\t\t\torderCandidateList)).isEqualTo(NonInheritedAnnotationClass.class);\n\t}\n\n\t@Test\n\tvoid getSuperClassSourceForTypesWithMultipleCandidateTypes() {\n\t\tList<Class<? extends Annotation>> candidates = List.of(Transactional.class, Order.class);\n\t\t// no class-level annotation\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonAnnotatedInterface.class,\n\t\t\t\tcandidates)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonAnnotatedClass.class,\n\t\t\t\tcandidates)).isNull();\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationInterface.class,\n\t\t\t\tcandidates)).isEqualTo(InheritedAnnotationInterface.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationInterface.class,\n\t\t\t\tcandidates)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationClass.class,\n\t\t\t\tcandidates)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationClass.class,\n\t\t\t\tcandidates)).isEqualTo(InheritedAnnotationClass.class);\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but findAnnotationDeclaringClassForTypes() should still find it on\n\t\t// classes.\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationInterface.class,\n\t\t\t\tcandidates)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationInterface.class,\n\t\t\t\tcandidates)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationClass.class,\n\t\t\t\tcandidates)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationClass.class,\n\t\t\t\tcandidates)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\t// class hierarchy mixed with @Transactional and @Order declarations\n\t\tassertThat(getSuperClassSourceWithTypeIn(TransactionalClass.class,\n\t\t\t\tcandidates)).isEqualTo(TransactionalClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(TransactionalAndOrderedClass.class,\n\t\t\t\tcandidates)).isEqualTo(TransactionalAndOrderedClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubTransactionalAndOrderedClass.class,\n\t\t\t\tcandidates)).isEqualTo(TransactionalAndOrderedClass.class);\n\t}\n\n\tprivate Object getSuperClassSourceWithTypeIn(Class<?> clazz, List<Class<? extends Annotation>> annotationTypes) {\n\t\treturn MergedAnnotations.from(clazz, SearchStrategy.SUPERCLASS).stream().filter(\n\t\t\t\tMergedAnnotationPredicates.typeIn(annotationTypes).and(\n\t\t\t\t\t\tMergedAnnotation::isDirectlyPresent)).map(\n\t\t\t\t\t\t\t\tMergedAnnotation::getSource).findFirst().orElse(null);\n\t}\n\n\t@Test\n\tvoid isDirectlyPresentForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedInterface.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedInterface.class).isDirectlyPresent(\n\t\t\t\tTransactional.class)).isFalse();\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class).isDirectlyPresent(\n\t\t\t\tTransactional.class)).isFalse();\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationInterface.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isTrue();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tInheritedAnnotationInterface.class).isDirectlyPresent(\n\t\t\t\t\t\tTransactional.class)).isTrue();\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tSubInheritedAnnotationInterface.class).isDirectlyPresent(\n\t\t\t\t\t\tTransactional.class)).isFalse();\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationClass.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isTrue();\n\t\tassertThat(\n\t\t\t\tMergedAnnotations.from(InheritedAnnotationClass.class).isDirectlyPresent(\n\t\t\t\t\t\tTransactional.class)).isTrue();\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tSubInheritedAnnotationClass.class).isDirectlyPresent(\n\t\t\t\t\t\tTransactional.class)).isFalse();\n\t\t// non-inherited class-level annotation; note: @Order is not inherited\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class).get(\n\t\t\t\tOrder.class).isDirectlyPresent()).isTrue();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationInterface.class).isDirectlyPresent(\n\t\t\t\t\t\tOrder.class)).isTrue();\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class).get(\n\t\t\t\tOrder.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tSubNonInheritedAnnotationInterface.class).isDirectlyPresent(\n\t\t\t\t\t\tOrder.class)).isFalse();\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class).get(\n\t\t\t\tOrder.class).isDirectlyPresent()).isTrue();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationClass.class).isDirectlyPresent(\n\t\t\t\t\t\tOrder.class)).isTrue();\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class).get(\n\t\t\t\tOrder.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tSubNonInheritedAnnotationClass.class).isDirectlyPresent(\n\t\t\t\t\t\tOrder.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid getAggregateIndexForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(-1);\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(0);\n\t\t// Since we're not traversing interface hierarchies the following,\n\t\t// though perhaps counterintuitive, must be false:\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(1);\n\t\t// non-inherited class-level annotation; note: @Order is not inherited\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tOrder.class).getAggregateIndex()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tOrder.class).getAggregateIndex()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tOrder.class).getAggregateIndex()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tOrder.class).getAggregateIndex()).isEqualTo(-1);\n\t}\n\n\t@Test\n\tvoid getDirectWithoutAttributeAliases() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(WebController.class).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"webController\");\n\t}\n\n\t@Test\n\tvoid getDirectWithNestedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(ComponentScanClass.class).get(ComponentScan.class);\n\t\tMergedAnnotation<Filter>[] filters = annotation.getAnnotationArray(\"excludeFilters\", Filter.class);\n\t\tassertThat(Arrays.stream(filters).map(\n\t\t\t\tfilter -> filter.getString(\"pattern\"))).containsExactly(\"*Foo\", \"*Bar\");\n\t}\n\n\t@Test\n\tvoid getDirectWithAttributeAliases1() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method).get(RequestMapping.class);\n\t\tassertThat(annotation.getString(\"name\")).isEqualTo(\"foo\");\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"/test\");\n\t\tassertThat(annotation.getStringArray(\"path\")).containsExactly(\"/test\");\n\t}\n\n\t@Test\n\tvoid getDirectWithAttributeAliases2() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method).get(RequestMapping.class);\n\t\tassertThat(annotation.getString(\"name\")).isEqualTo(\"bar\");\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"/test\");\n\t\tassertThat(annotation.getStringArray(\"path\")).containsExactly(\"/test\");\n\t}\n\n\t@Test\n\tvoid getDirectWithAttributeAliasesWithDifferentValues() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithDifferentPathAndValueAttributes\");\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tMergedAnnotations.from(method).get(RequestMapping.class))\n\t\t\t\t.withMessageContaining(\"attribute 'path' and its alias 'value'\")\n\t\t\t\t.withMessageContaining(\"values of [{/test}] and [{/enigma}]\");\n\t}\n\n\t@Test\n\tvoid getValueFromAnnotation() throws Exception {\n\t\tMethod method = TransactionalStringGeneric.class.getMethod(\"something\", Object.class);\n\t\tMergedAnnotation<?> annotation =\n\t\t\t\tMergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getInt(\"value\")).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getValueFromNonPublicAnnotation() {\n\t\tAnnotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\n\t\tassertThat(declaredAnnotations).hasSize(1);\n\t\tAnnotation annotation = declaredAnnotations[0];\n\t\tMergedAnnotation<Annotation> mergedAnnotation = MergedAnnotation.from(annotation);\n\t\tassertThat(mergedAnnotation.getType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\n\t\tassertThat(mergedAnnotation.synthesize().annotationType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\n\t\tassertThat(mergedAnnotation.getInt(\"value\")).isEqualTo(42);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromAnnotation() throws Exception {\n\t\tMethod method = TransactionalStringGeneric.class.getMethod(\"something\", Object.class);\n\t\tMergedAnnotation<Order> annotation =\n\t\t\t\tMergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getDefaultValue(\"value\")).contains(Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromNonPublicAnnotation() {\n\t\tAnnotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\n\t\tassertThat(declaredAnnotations).hasSize(1);\n\t\tAnnotation declaredAnnotation = declaredAnnotations[0];\n\t\tMergedAnnotation<?> annotation = MergedAnnotation.from(declaredAnnotation);\n\t\tassertThat(annotation.getType().getName()).isEqualTo(\n\t\t\t\t\"org.springframework.core.annotation.subpackage.NonPublicAnnotation\");\n\t\tassertThat(annotation.getDefaultValue(\"value\")).contains(-1);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromAnnotationType() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotation.of(Order.class);\n\t\tassertThat(annotation.getDefaultValue(\"value\")).contains(Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnMethod() throws Exception {\n\t\tMethod method = InterfaceWithRepeated.class.getMethod(\"foo\");\n\t\tStream<MergedAnnotation<MyRepeatable>> annotations = MergedAnnotations.from(\n\t\t\t\tmethod, SearchStrategy.TYPE_HIERARCHY).stream(MyRepeatable.class);\n\t\tStream<String> values = annotations.map(\n\t\t\t\tannotation -> annotation.getString(\"value\"));\n\t\tassertThat(values).containsExactly(\"A\", \"B\", \"C\", \"meta1\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid streamRepeatableDeclaredOnClassWithAttributeAliases() {\n\t\tassertThat(MergedAnnotations.from(HierarchyClass.class).stream(\n\t\t\t\tTestConfiguration.class)).isEmpty();\n\t\tRepeatableContainers containers = RepeatableContainers.of(TestConfiguration.class,\n\t\t\t\tHierarchy.class);\n\t\tMergedAnnotations annotations = MergedAnnotations.from(HierarchyClass.class,\n\t\t\t\tSearchStrategy.DIRECT, containers, AnnotationFilter.NONE);\n\t\tassertThat(annotations.stream(TestConfiguration.class).map(\n\t\t\t\tannotation -> annotation.getString(\"location\"))).containsExactly(\"A\", \"B\");\n\t\tassertThat(annotations.stream(TestConfiguration.class).map(\n\t\t\t\tannotation -> annotation.getString(\"value\"))).containsExactly(\"A\", \"B\");\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnClass() {\n\t\tClass<?> element = MyRepeatableClass.class;\n\t\tString[] expectedValuesJava = { \"A\", \"B\", \"C\" };\n\t\tString[] expectedValuesSpring = { \"A\", \"B\", \"C\", \"meta1\" };\n\t\ttestRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnSuperclass() {\n\t\tClass<?> element = SubMyRepeatableClass.class;\n\t\tString[] expectedValuesJava = { \"A\", \"B\", \"C\" };\n\t\tString[] expectedValuesSpring = { \"A\", \"B\", \"C\", \"meta1\" };\n\t\ttestRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnClassAndSuperclass() {\n\t\tClass<?> element = SubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\n\t\tString[] expectedValuesJava = { \"X\", \"Y\", \"Z\" };\n\t\tString[] expectedValuesSpring = { \"X\", \"Y\", \"Z\", \"meta2\" };\n\t\ttestRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnMultipleSuperclasses() {\n\t\tClass<?> element = SubSubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\n\t\tString[] expectedValuesJava = { \"X\", \"Y\", \"Z\" };\n\t\tString[] expectedValuesSpring = { \"X\", \"Y\", \"Z\", \"meta2\" };\n\t\ttestRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamDirectRepeatablesDeclaredOnClass() {\n\t\tClass<?> element = MyRepeatableClass.class;\n\t\tString[] expectedValuesJava = { \"A\", \"B\", \"C\" };\n\t\tString[] expectedValuesSpring = { \"A\", \"B\", \"C\", \"meta1\" };\n\t\ttestRepeatables(SearchStrategy.DIRECT, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamDirectRepeatablesDeclaredOnSuperclass() {\n\t\tClass<?> element = SubMyRepeatableClass.class;\n\t\tString[] expectedValuesJava = {};\n\t\tString[] expectedValuesSpring = {};\n\t\ttestRepeatables(SearchStrategy.DIRECT, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\tprivate void testRepeatables(SearchStrategy searchStrategy, Class<?> element,\n\t\t\tString[] expectedValuesJava, String[] expectedValuesSpring) {\n\n\t\ttestJavaRepeatables(searchStrategy, element, expectedValuesJava);\n\t\ttestExplicitRepeatables(searchStrategy, element, expectedValuesSpring);\n\t\ttestStandardRepeatables(searchStrategy, element, expectedValuesSpring);\n\t}\n\n\tprivate void testJavaRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expected) {\n\t\tMyRepeatable[] annotations = searchStrategy == SearchStrategy.DIRECT ?\n\t\t\t\telement.getDeclaredAnnotationsByType(MyRepeatable.class) :\n\t\t\t\telement.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(Arrays.stream(annotations).map(MyRepeatable::value)).containsExactly(\n\t\t\t\texpected);\n\t}\n\n\tprivate void testExplicitRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expected) {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(element, searchStrategy,\n\t\t\t\tRepeatableContainers.of(MyRepeatable.class, MyRepeatableContainer.class),\n\t\t\t\tAnnotationFilter.PLAIN);\n\t\tStream<String> values = annotations.stream(MyRepeatable.class)\n\t\t\t\t.filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex))\n\t\t\t\t.map(annotation -> annotation.getString(\"value\"));\n\t\tassertThat(values).containsExactly(expected);\n\t}\n\n\tprivate void testStandardRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expected) {\n\t\tStream<String> values = MergedAnnotations.from(element, searchStrategy).stream(MyRepeatable.class)\n\t\t\t\t.filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex))\n\t\t\t\t.map(annotation -> annotation.getString(\"value\"));\n\t\tassertThat(values).containsExactly(expected);\n\t}\n\n\t@Test\n\tvoid synthesizeWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tComponent synthesizedComponent = MergedAnnotation.from(component).synthesize();\n\t\tassertThat(synthesizedComponent).isNotNull();\n\t\tassertThat(synthesizedComponent).isEqualTo(component);\n\t\tassertThat(synthesizedComponent.value()).isEqualTo(\"webController\");\n\t}\n\n\t/**\n\t * @since 6.0\n\t */\n\t@Test\n\tvoid synthesizedAnnotationShouldReuseJdkProxyClass() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\n\t\tRequestMapping jdkRequestMapping = method.getAnnotation(RequestMapping.class);\n\t\tassertThat(jdkRequestMapping).isNotNull();\n\t\tassertThat(jdkRequestMapping.value()).containsExactly(\"/test\");\n\t\tassertThat(jdkRequestMapping.path()).containsExactly(\"\");\n\n\t\tRequestMapping synthesizedRequestMapping = MergedAnnotation.from(jdkRequestMapping).synthesize();\n\t\tassertSynthesized(synthesizedRequestMapping);\n\t\tassertThat(synthesizedRequestMapping.value()).containsExactly(\"/test\");\n\t\tassertThat(synthesizedRequestMapping.path()).containsExactly(\"/test\");\n\n\t\tassertThat(jdkRequestMapping.getClass()).isSameAs(synthesizedRequestMapping.getClass());\n\t}\n\n\t@Test\n\tvoid synthesizeAlreadySynthesized() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\t\tRequestMapping webMapping = method.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMapping).isNotNull();\n\n\t\tRequestMapping synthesizedWebMapping = MergedAnnotation.from(webMapping).synthesize();\n\t\tRequestMapping synthesizedAgainWebMapping = MergedAnnotation.from(synthesizedWebMapping).synthesize();\n\n\t\tassertSynthesized(synthesizedWebMapping);\n\t\tassertSynthesized(synthesizedAgainWebMapping);\n\t\tassertThat(synthesizedWebMapping).isEqualTo(synthesizedAgainWebMapping);\n\t\tassertThat(synthesizedWebMapping).isSameAs(synthesizedAgainWebMapping);\n\t\tassertThat(synthesizedWebMapping.name()).isEqualTo(\"foo\");\n\t\tassertThat(synthesizedWebMapping.path()).containsExactly(\"/test\");\n\t\tassertThat(synthesizedWebMapping.value()).containsExactly(\"/test\");\n\t}\n\n\t@Test\n\tvoid synthesizeShouldNotSynthesizeNonsynthesizableAnnotations() throws Exception {\n\t\tMethod method = getClass().getDeclaredMethod(\"getId\");\n\n\t\tId id = method.getAnnotation(Id.class);\n\t\tassertThat(id).isNotNull();\n\t\tId synthesizedId = MergedAnnotation.from(id).synthesize();\n\t\tassertThat(id).isEqualTo(synthesizedId);\n\t\t// It doesn't make sense to synthesize @Id since it declares zero attributes.\n\t\tassertNotSynthesized(synthesizedId);\n\t\tassertThat(id).isSameAs(synthesizedId);\n\n\t\tGeneratedValue generatedValue = method.getAnnotation(GeneratedValue.class);\n\t\tassertThat(generatedValue).isNotNull();\n\t\tGeneratedValue synthesizedGeneratedValue = MergedAnnotation.from(generatedValue).synthesize();\n\t\tassertThat(generatedValue).isEqualTo(synthesizedGeneratedValue);\n\t\t// It doesn't make sense to synthesize @GeneratedValue since it declares zero attributes with aliases.\n\t\tassertNotSynthesized(synthesizedGeneratedValue);\n\t\tassertThat(generatedValue).isSameAs(synthesizedGeneratedValue);\n\t}\n\n\t@Test  // gh-28716\n\tvoid synthesizeWhenUsingMergedAnnotationsFromApi() {\n\t\tField directlyAnnotatedField = ReflectionUtils.findField(DomainType.class, \"directlyAnnotated\");\n\t\tMergedAnnotations mergedAnnotations = MergedAnnotations.from(directlyAnnotatedField);\n\t\tRootAnnotation rootAnnotation = mergedAnnotations.get(RootAnnotation.class).synthesize();\n\t\tassertThat(rootAnnotation.flag()).isFalse();\n\t\tassertNotSynthesized(rootAnnotation);\n\n\t\tField metaAnnotatedField = ReflectionUtils.findField(DomainType.class, \"metaAnnotated\");\n\t\tmergedAnnotations = MergedAnnotations.from(metaAnnotatedField);\n\t\trootAnnotation = mergedAnnotations.get(RootAnnotation.class).synthesize();\n\t\tassertThat(rootAnnotation.flag()).isTrue();\n\t\tassertSynthesized(rootAnnotation);\n\n\t\tField metaMetaAnnotatedField = ReflectionUtils.findField(DomainType.class, \"metaMetaAnnotated\");\n\t\tmergedAnnotations = MergedAnnotations.from(metaMetaAnnotatedField);\n\t\trootAnnotation = mergedAnnotations.get(RootAnnotation.class).synthesize();\n\t\tassertThat(rootAnnotation.flag()).isTrue();\n\t\tassertSynthesized(rootAnnotation);\n\t}\n\n\t@Test  // gh-28704\n\tvoid synthesizeShouldNotSynthesizeNonsynthesizableAnnotationsWhenUsingMergedAnnotationsFromApi() {\n\t\tMergedAnnotations mergedAnnotations = MergedAnnotations.from(SecurityConfig.class);\n\n\t\tEnableWebSecurity enableWebSecurity = mergedAnnotations.get(EnableWebSecurity.class).synthesize();\n\t\tassertNotSynthesized(enableWebSecurity);\n\n\t\tEnableGlobalAuthentication enableGlobalAuthentication = mergedAnnotations.get(EnableGlobalAuthentication.class).synthesize();\n\t\tassertNotSynthesized(enableGlobalAuthentication);\n\t}\n\n\t/**\n\t * If an attempt is made to synthesize an annotation from an annotation instance\n\t * that has already been synthesized, the original synthesized annotation should\n\t * ideally be returned as-is without creating a new proxy instance with the same\n\t * values.\n\t */\n\t@Test\n\tvoid synthesizeShouldNotResynthesizeAlreadySynthesizedAnnotations() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\t\tRequestMapping webMapping = method.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMapping).isNotNull();\n\n\t\tMergedAnnotation<RequestMapping> mergedAnnotation1 = MergedAnnotation.from(webMapping);\n\t\tRequestMapping synthesizedWebMapping1 = mergedAnnotation1.synthesize();\n\t\tRequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMapping).synthesize();\n\n\t\tassertSynthesized(synthesizedWebMapping1);\n\t\tassertSynthesized(synthesizedWebMapping2);\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(synthesizedWebMapping2);\n\n\t\t// Synthesizing an annotation from a different MergedAnnotation results in a different synthesized annotation instance.\n\t\tassertThat(synthesizedWebMapping1).isNotSameAs(synthesizedWebMapping2);\n\t\t// Synthesizing an annotation from the same MergedAnnotation results in the same synthesized annotation instance.\n\t\tassertThat(synthesizedWebMapping1).isSameAs(mergedAnnotation1.synthesize());\n\n\t\tRequestMapping synthesizedAgainWebMapping = MergedAnnotation.from(synthesizedWebMapping1).synthesize();\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(synthesizedAgainWebMapping);\n\t\t// Synthesizing an already synthesized annotation results in the original synthesized annotation instance.\n\t\tassertThat(synthesizedWebMapping1).isSameAs(synthesizedAgainWebMapping);\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAliasForIsMissingAttributeDeclaration() {\n\t\tAliasForWithMissingAttributeDeclaration annotation =\n\t\t\t\tAliasForWithMissingAttributeDeclarationClass.class.getAnnotation(\n\t\t\t\t\t\tAliasForWithMissingAttributeDeclaration.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"@AliasFor declaration on attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(AliasForWithMissingAttributeDeclaration.class.getName())\n\t\t\t\t.withMessageContaining(\"points to itself\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAliasForHasDuplicateAttributeDeclaration() {\n\t\tAliasForWithDuplicateAttributeDeclaration annotation =\n\t\t\t\tAliasForWithDuplicateAttributeDeclarationClass.class.getAnnotation(\n\t\t\t\t\t\tAliasForWithDuplicateAttributeDeclaration.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"In @AliasFor declared on attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(AliasForWithDuplicateAttributeDeclaration.class.getName())\n\t\t\t\t.withMessageContaining(\"attribute 'attribute' and its alias 'value' are present with values of 'baz' and 'bar'\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForNonexistentAttribute() {\n\t\tAliasForNonexistentAttribute annotation = AliasForNonexistentAttributeClass.class.getAnnotation(\n\t\t\t\tAliasForNonexistentAttribute.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"@AliasFor declaration on attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(AliasForNonexistentAttribute.class.getName())\n\t\t\t\t.withMessageContaining(\"declares an alias for 'bar' which is not present\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasWithMirroredAliasForWrongAttribute() {\n\t\tAliasForWithMirroredAliasForWrongAttribute annotation =\n\t\t\t\tAliasForWithMirroredAliasForWrongAttributeClass.class.getAnnotation(\n\t\t\t\t\t\tAliasForWithMirroredAliasForWrongAttribute.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessage(\"@AliasFor declaration on attribute 'bar' in annotation [\" +\n\t\t\t\t\t\tAliasForWithMirroredAliasForWrongAttribute.class.getName() +\n\t\t\t\t\t\t\"] declares an alias for 'quux' which is not present.\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForAttributeOfDifferentType() {\n\t\tAliasForAttributeOfDifferentType annotation = AliasForAttributeOfDifferentTypeClass.class.getAnnotation(\n\t\t\t\tAliasForAttributeOfDifferentType.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases\")\n\t\t\t\t.withMessageContaining(AliasForAttributeOfDifferentType.class.getName())\n\t\t\t\t.withMessageContaining(\"attribute 'foo'\")\n\t\t\t\t.withMessageContaining(\"attribute 'bar'\")\n\t\t\t\t.withMessageContaining(\"same return type\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForWithMissingDefaultValues() {\n\t\tAliasForWithMissingDefaultValues annotation = AliasForWithMissingDefaultValuesClass.class.getAnnotation(\n\t\t\t\tAliasForWithMissingDefaultValues.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases\")\n\t\t\t\t.withMessageContaining(AliasForWithMissingDefaultValues.class.getName())\n\t\t\t\t.withMessageContaining(\"attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(\"attribute 'bar' in annotation\")\n\t\t\t\t.withMessageContaining(\"default values\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForAttributeWithDifferentDefaultValue() {\n\t\tAliasForAttributeWithDifferentDefaultValue annotation =\n\t\t\t\tAliasForAttributeWithDifferentDefaultValueClass.class.getAnnotation(\n\t\t\t\t\t\tAliasForAttributeWithDifferentDefaultValue.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases\")\n\t\t\t\t.withMessageContaining(AliasForAttributeWithDifferentDefaultValue.class.getName())\n\t\t\t\t.withMessageContaining(\"attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(\"attribute 'bar' in annotation\")\n\t\t\t\t.withMessageContaining(\"same default value\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForMetaAnnotationThatIsNotMetaPresent() {\n\t\tAliasedComposedTestConfigurationNotMetaPresent annotation =\n\t\t\t\tAliasedComposedTestConfigurationNotMetaPresentClass.class.getAnnotation(\n\t\t\t\t\t\tAliasedComposedTestConfigurationNotMetaPresent.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"@AliasFor declaration on attribute 'xmlConfigFile' in annotation\")\n\t\t\t\t.withMessageContaining(AliasedComposedTestConfigurationNotMetaPresent.class.getName())\n\t\t\t\t.withMessageContaining(\"declares an alias for attribute 'location' in annotation\")\n\t\t\t\t.withMessageContaining(TestConfiguration.class.getName())\n\t\t\t\t.withMessageContaining(\"not meta-present\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliases() {\n\t\ttestSynthesisWithImplicitAliases(ValueImplicitAliasesTestConfigurationClass.class, \"value\");\n\t\ttestSynthesisWithImplicitAliases(Location1ImplicitAliasesTestConfigurationClass.class, \"location1\");\n\t\ttestSynthesisWithImplicitAliases(XmlImplicitAliasesTestConfigurationClass.class, \"xmlFile\");\n\t\ttestSynthesisWithImplicitAliases(GroovyImplicitAliasesSimpleTestConfigurationClass.class, \"groovyScript\");\n\t}\n\n\tprivate void testSynthesisWithImplicitAliases(Class<?> clazz, String expected) {\n\t\tImplicitAliasesTestConfiguration config = clazz.getAnnotation(ImplicitAliasesTestConfiguration.class);\n\t\tassertThat(config).isNotNull();\n\t\tImplicitAliasesTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.value()).isEqualTo(expected);\n\t\tassertThat(synthesized.location1()).isEqualTo(expected);\n\t\tassertThat(synthesized.xmlFile()).isEqualTo(expected);\n\t\tassertThat(synthesized.groovyScript()).isEqualTo(expected);\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesWithImpliedAliasNamesOmitted() {\n\t\ttestSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(\n\t\t\t\tValueImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass.class,\n\t\t\t\t\"value\");\n\t\ttestSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(\n\t\t\t\tLocationsImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass.class,\n\t\t\t\t\"location\");\n\t\ttestSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(\n\t\t\t\tXmlFilesImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass.class,\n\t\t\t\t\"xmlFile\");\n\t}\n\n\tprivate void testSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(Class<?> clazz, String expected) {\n\t\tImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration config = clazz.getAnnotation(\n\t\t\t\tImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration.class);\n\t\tassertThat(config).isNotNull();\n\t\tImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration synthesized =\n\t\t\t\tMergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.value()).isEqualTo(expected);\n\t\tassertThat(synthesized.location()).isEqualTo(expected);\n\t\tassertThat(synthesized.xmlFile()).isEqualTo(expected);\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesForAliasPair() {\n\t\tImplicitAliasesForAliasPairTestConfiguration config =\n\t\t\t\tImplicitAliasesForAliasPairTestConfigurationClass.class.getAnnotation(\n\t\t\t\t\t\tImplicitAliasesForAliasPairTestConfiguration.class);\n\t\tImplicitAliasesForAliasPairTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.xmlFile()).isEqualTo(\"test.xml\");\n\t\tassertThat(synthesized.groovyScript()).isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithTransitiveImplicitAliases() {\n\t\tTransitiveImplicitAliasesTestConfiguration config =\n\t\t\t\tTransitiveImplicitAliasesTestConfigurationClass.class.getAnnotation(\n\t\t\t\t\t\tTransitiveImplicitAliasesTestConfiguration.class);\n\t\tTransitiveImplicitAliasesTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.xml()).isEqualTo(\"test.xml\");\n\t\tassertThat(synthesized.groovy()).isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithTransitiveImplicitAliasesForAliasPair() {\n\t\tTransitiveImplicitAliasesForAliasPairTestConfiguration config =\n\t\t\t\tTransitiveImplicitAliasesForAliasPairTestConfigurationClass.class.getAnnotation(\n\t\t\t\t\t\tTransitiveImplicitAliasesForAliasPairTestConfiguration.class);\n\t\tTransitiveImplicitAliasesForAliasPairTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.xml()).isEqualTo(\"test.xml\");\n\t\tassertThat(synthesized.groovy()).isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesWithMissingDefaultValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithMissingDefaultValuesTestConfigurationClass.class;\n\t\tClass<ImplicitAliasesWithMissingDefaultValuesTestConfiguration> annotationType =\n\t\t\t\tImplicitAliasesWithMissingDefaultValuesTestConfiguration.class;\n\t\tImplicitAliasesWithMissingDefaultValuesTestConfiguration config = clazz.getAnnotation(annotationType);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(clazz, config))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases:\")\n\t\t\t\t.withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t\t.withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t\t.withMessageContaining(\"default values\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesWithDifferentDefaultValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithDifferentDefaultValuesTestConfigurationClass.class;\n\t\tClass<ImplicitAliasesWithDifferentDefaultValuesTestConfiguration> annotationType =\n\t\t\t\tImplicitAliasesWithDifferentDefaultValuesTestConfiguration.class;\n\t\tImplicitAliasesWithDifferentDefaultValuesTestConfiguration config = clazz.getAnnotation(annotationType);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(clazz, config))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases:\")\n\t\t\t\t.withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t\t.withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t\t.withMessageContaining(\"same default value\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesWithDuplicateValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithDuplicateValuesTestConfigurationClass.class;\n\t\tClass<ImplicitAliasesWithDuplicateValuesTestConfiguration> annotationType =\n\t\t\t\tImplicitAliasesWithDuplicateValuesTestConfiguration.class;\n\t\tImplicitAliasesWithDuplicateValuesTestConfiguration config = clazz.getAnnotation(annotationType);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotation.from(clazz, config))\n\t\t\t\t.withMessageStartingWith(\"Different @AliasFor mirror values for annotation\")\n\t\t\t\t.withMessageContaining(annotationType.getName())\n\t\t\t\t.withMessageContaining(\"declared on class\")\n\t\t\t\t.withMessageContaining(clazz.getName())\n\t\t\t\t.withMessageContaining(\"are declared with values of\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tMap<String, Object> map = Collections.singletonMap(\"value\", \"webController\");\n\t\tMergedAnnotation<Component> annotation = MergedAnnotation.of(Component.class, map);\n\n\t\tComponent synthesizedComponent = annotation.synthesize();\n\t\tassertSynthesized(synthesizedComponent);\n\t\tassertThat(synthesizedComponent.value()).isEqualTo(\"webController\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeFromMapWithNestedMap() {\n\t\tComponentScanSingleFilter componentScan = ComponentScanSingleFilterClass.class.getAnnotation(\n\t\t\t\tComponentScanSingleFilter.class);\n\t\tassertThat(componentScan).isNotNull();\n\t\tassertThat(componentScan.value().pattern()).isEqualTo(\"*Foo\");\n\t\tMap<String, Object> map = MergedAnnotation.from(componentScan).asMap(\n\t\t\t\tannotation -> new LinkedHashMap<>(), Adapt.ANNOTATION_TO_MAP);\n\t\tMap<String, Object> filterMap = (Map<String, Object>) map.get(\"value\");\n\t\tassertThat(filterMap.get(\"pattern\")).isEqualTo(\"*Foo\");\n\t\tfilterMap.put(\"pattern\", \"newFoo\");\n\t\tfilterMap.put(\"enigma\", 42);\n\t\tMergedAnnotation<ComponentScanSingleFilter> annotation = MergedAnnotation.of(\n\t\t\t\tComponentScanSingleFilter.class, map);\n\t\tComponentScanSingleFilter synthesizedComponentScan = annotation.synthesize();\n\t\tassertSynthesized(synthesizedComponentScan);\n\t\tassertThat(synthesizedComponentScan.value().pattern()).isEqualTo(\"newFoo\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeFromMapWithNestedArrayOfMaps() {\n\t\tComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class);\n\t\tassertThat(componentScan).isNotNull();\n\t\tMap<String, Object> map = MergedAnnotation.from(componentScan).asMap(\n\t\t\t\tannotation -> new LinkedHashMap<>(), Adapt.ANNOTATION_TO_MAP);\n\t\tMap<String, Object>[] filters = (Map[]) map.get(\"excludeFilters\");\n\t\tList<String> patterns = Arrays.stream(filters).map(\n\t\t\t\tm -> (String) m.get(\"pattern\")).toList();\n\t\tassertThat(patterns).containsExactly(\"*Foo\", \"*Bar\");\n\t\tfilters[0].put(\"pattern\", \"newFoo\");\n\t\tfilters[0].put(\"enigma\", 42);\n\t\tfilters[1].put(\"pattern\", \"newBar\");\n\t\tfilters[1].put(\"enigma\", 42);\n\t\tMergedAnnotation<ComponentScan> annotation = MergedAnnotation.of(ComponentScan.class, map);\n\t\tComponentScan synthesizedComponentScan = annotation.synthesize();\n\t\tassertSynthesized(synthesizedComponentScan);\n\t\tassertThat(Arrays.stream(synthesizedComponentScan.excludeFilters()).map(Filter::pattern))\n\t\t\t\t.containsExactly(\"newFoo\", \"newBar\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromDefaultsWithoutAttributeAliases() {\n\t\tMergedAnnotation<AnnotationWithDefaults> annotation = MergedAnnotation.of(AnnotationWithDefaults.class);\n\t\tAnnotationWithDefaults synthesized = annotation.synthesize();\n\t\tassertThat(synthesized.text()).isEqualTo(\"enigma\");\n\t\tassertThat(synthesized.predicate()).isTrue();\n\t\tassertThat(synthesized.characters()).containsExactly('a', 'b', 'c');\n\t}\n\n\t@Test\n\tvoid synthesizeFromDefaultsWithAttributeAliases() {\n\t\tMergedAnnotation<TestConfiguration> annotation = MergedAnnotation.of(TestConfiguration.class);\n\t\tTestConfiguration synthesized = annotation.synthesize();\n\t\tassertThat(synthesized.value()).isEmpty();\n\t\tassertThat(synthesized.location()).isEmpty();\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasesWithDifferentValues() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tMergedAnnotation.from(TestConfigurationMismatch.class.getAnnotation(TestConfiguration.class)).synthesize());\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithMinimalAttributesWithAttributeAliases() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"location\", \"test.xml\");\n\t\tMergedAnnotation<TestConfiguration> annotation = MergedAnnotation.of(TestConfiguration.class, map);\n\t\tTestConfiguration synthesized = annotation.synthesize();\n\t\tassertThat(synthesized.value()).isEqualTo(\"test.xml\");\n\t\tassertThat(synthesized.location()).isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements() {\n\t\tsynthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements(\n\t\t\t\tCollections.singletonMap(\"value\", \"/foo\"));\n\t\tsynthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements(\n\t\t\t\tCollections.singletonMap(\"path\", \"/foo\"));\n\t}\n\n\tprivate void synthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements(Map<String, Object> map) {\n\t\tMergedAnnotation<GetMapping> annotation = MergedAnnotation.of(GetMapping.class, map);\n\t\tGetMapping synthesized = annotation.synthesize();\n\t\tassertThat(synthesized.value()).isEqualTo(\"/foo\");\n\t\tassertThat(synthesized.path()).isEqualTo(\"/foo\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithImplicitAttributeAliases() {\n\t\ttestSynthesisFromMapWithImplicitAliases(\"value\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"location1\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"location2\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"location3\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"xmlFile\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"groovyScript\");\n\t}\n\n\tprivate void testSynthesisFromMapWithImplicitAliases(String attributeNameAndValue) {\n\t\tMap<String, Object> map = Collections.singletonMap(attributeNameAndValue, attributeNameAndValue);\n\t\tMergedAnnotation<ImplicitAliasesTestConfiguration> annotation = MergedAnnotation.of(\n\t\t\t\tImplicitAliasesTestConfiguration.class, map);\n\t\tImplicitAliasesTestConfiguration synthesized = annotation.synthesize();\n\n\t\tassertThat(synthesized.value()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.location1()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.location2()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.location2()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.xmlFile()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.groovyScript()).isEqualTo(attributeNameAndValue);\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithMissingAttributeValue() {\n\t\ttestMissingTextAttribute(Collections.emptyMap());\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithNullAttributeValue() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"text\", null);\n\t\tassertThat(map).containsKey(\"text\");\n\t\ttestMissingTextAttribute(map);\n\t}\n\n\tprivate void testMissingTextAttribute(Map<String, Object> attributes) {\n\t\tassertThatExceptionOfType(NoSuchElementException.class).isThrownBy(() ->\n\t\t\t\tMergedAnnotation.of(AnnotationWithoutDefaults.class, attributes).synthesize().text())\n\t\t\t\t.withMessage(\"No value found for attribute named 'text' in merged annotation \" +\n\t\t\t\t\t\tAnnotationWithoutDefaults.class.getCanonicalName());\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithAttributeOfIncorrectType() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"value\", 42L);\n\t\tMergedAnnotation<Component> annotation = MergedAnnotation.of(Component.class, map);\n\t\tassertThatIllegalStateException().isThrownBy(() -> annotation.synthesize().value())\n\t\t\t\t.withMessage(\"Attribute 'value' in annotation \" +\n\t\t\t\t\t\t\"org.springframework.core.testfixture.stereotype.Component should be \" +\n\t\t\t\t\t\t\"compatible with java.lang.String but a java.lang.Long value was returned\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromAnnotationAttributesWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tMap<String, Object> attributes = MergedAnnotation.from(component).asMap();\n\n\t\tComponent synthesized = MergedAnnotation.of(Component.class, attributes).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized).isEqualTo(component);\n\t}\n\n\t@Test\n\tvoid toStringForSynthesizedAnnotations() throws Exception {\n\t\tMethod methodWithPath = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\tRequestMapping webMappingWithAliases = methodWithPath.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithAliases).isNotNull();\n\n\t\tMethod methodWithPathAndValue = WebController.class.getMethod(\"handleMappedWithSamePathAndValueAttributes\");\n\t\tRequestMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(RequestMapping.class);\n\t\tassertThat(methodWithPathAndValue).isNotNull();\n\n\t\tRequestMapping synthesizedWebMapping1 = MergedAnnotation.from(webMappingWithAliases).synthesize();\n\t\tRequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMappingWithPathAndValue).synthesize();\n\n\t\tassertThat(webMappingWithAliases.toString()).isNotEqualTo(synthesizedWebMapping1.toString());\n\n\t\t// The unsynthesized annotation for handleMappedWithSamePathAndValueAttributes()\n\t\t// should produce almost the same toString() results as synthesized annotations for\n\t\t// handleMappedWithPathAttribute() on Java 9 or higher; however, due to multiple changes\n\t\t// in the JDK's toString() implementation for annotations in JDK 9, 14, and 19,\n\t\t// we do not test the JDK implementation.\n\t\t// assertToStringForWebMappingWithPathAndValue(webMappingWithPathAndValue);\n\n\t\tassertToStringForWebMappingWithPathAndValue(synthesizedWebMapping1);\n\t\tassertToStringForWebMappingWithPathAndValue(synthesizedWebMapping2);\n\t}\n\n\tprivate void assertToStringForWebMappingWithPathAndValue(RequestMapping webMapping) {\n\t\tassertThat(webMapping.toString())\n\t\t\t\t.startsWith(\"@org.springframework.core.annotation.MergedAnnotationsTests.RequestMapping(\")\n\t\t\t\t.contains(\n\t\t\t\t\t// Strings\n\t\t\t\t\t\"value={\\\"/test\\\"}\", \"path={\\\"/test\\\"}\", \"name=\\\"bar\\\"\",\n\t\t\t\t\t// Characters\n\t\t\t\t\t\"ch='X'\", \"chars={'X'}\",\n\t\t\t\t\t// Enums\n\t\t\t\t\t\"method={GET, POST}\",\n\t\t\t\t\t// Classes\n\t\t\t\t\t\"clazz=org.springframework.core.annotation.MergedAnnotationsTests.RequestMethod.class\",\n\t\t\t\t\t\"classes={int[][].class, org.springframework.core.annotation.MergedAnnotationsTests.RequestMethod[].class}\",\n\t\t\t\t\t// Bytes\n\t\t\t\t\t\"byteValue=(byte) 0xFF\", \"bytes={(byte) 0xFF}\",\n\t\t\t\t\t// Shorts\n\t\t\t\t\t\"shortValue=9876\", \"shorts={9876}\",\n\t\t\t\t\t// Longs\n\t\t\t\t\t\"longValue=42L\", \"longs={42L}\",\n\t\t\t\t\t// Floats\n\t\t\t\t\t\"floatValue=3.14f\", \"floats={3.14f}\",\n\t\t\t\t\t// Doubles\n\t\t\t\t\t\"doubleValue=99.999d\", \"doubles={99.999d}\"\n\t\t\t\t)\n\t\t\t\t.endsWith(\")\");\n\t}\n\n\t@Test\n\tvoid equalsForSynthesizedAnnotations() throws Exception {\n\t\tMethod methodWithPath = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\tRequestMapping webMappingWithAliases = methodWithPath.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithAliases).isNotNull();\n\t\tMethod methodWithPathAndValue = WebController.class.getMethod(\"handleMappedWithSamePathAndValueAttributes\");\n\t\tRequestMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithPathAndValue).isNotNull();\n\t\tRequestMapping synthesizedWebMapping1 = MergedAnnotation.from(webMappingWithAliases).synthesize();\n\t\tRequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMappingWithPathAndValue).synthesize();\n\t\t// Equality amongst standard annotations\n\t\tassertThat(webMappingWithAliases).isEqualTo(webMappingWithAliases);\n\t\tassertThat(webMappingWithPathAndValue).isEqualTo(webMappingWithPathAndValue);\n\t\t// Inequality amongst standard annotations\n\t\tassertThat(webMappingWithAliases).isNotEqualTo(webMappingWithPathAndValue);\n\t\tassertThat(webMappingWithPathAndValue).isNotEqualTo(webMappingWithAliases);\n\t\t// Equality amongst synthesized annotations\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(synthesizedWebMapping1);\n\t\tassertThat(synthesizedWebMapping2).isEqualTo(synthesizedWebMapping2);\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(synthesizedWebMapping2);\n\t\tassertThat(synthesizedWebMapping2).isEqualTo(synthesizedWebMapping1);\n\t\t// Equality between standard and synthesized annotations\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(webMappingWithPathAndValue);\n\t\tassertThat(webMappingWithPathAndValue).isEqualTo(synthesizedWebMapping1);\n\t\t// Inequality between standard and synthesized annotations\n\t\tassertThat(synthesizedWebMapping1).isNotEqualTo(webMappingWithAliases);\n\t\tassertThat(webMappingWithAliases).isNotEqualTo(synthesizedWebMapping1);\n\t}\n\n\t@Test\n\tvoid hashCodeForSynthesizedAnnotations() throws Exception {\n\t\tMethod methodWithPath = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\tRequestMapping webMappingWithAliases = methodWithPath.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithAliases).isNotNull();\n\t\tMethod methodWithPathAndValue = WebController.class.getMethod(\"handleMappedWithSamePathAndValueAttributes\");\n\t\tRequestMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithPathAndValue).isNotNull();\n\t\tRequestMapping synthesizedWebMapping1 = MergedAnnotation.from(webMappingWithAliases).synthesize();\n\t\tassertThat(synthesizedWebMapping1).isNotNull();\n\t\tRequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMappingWithPathAndValue).synthesize();\n\t\tassertThat(synthesizedWebMapping2).isNotNull();\n\t\t// Equality amongst standard annotations\n\t\tassertThat(webMappingWithAliases.hashCode()).isEqualTo(webMappingWithAliases.hashCode());\n\t\tassertThat(webMappingWithPathAndValue.hashCode()).isEqualTo(webMappingWithPathAndValue.hashCode());\n\t\t// Inequality amongst standard annotations\n\t\tassertThat(webMappingWithAliases.hashCode()).isNotEqualTo(webMappingWithPathAndValue.hashCode());\n\t\tassertThat(webMappingWithPathAndValue.hashCode()).isNotEqualTo(webMappingWithAliases.hashCode());\n\t\t// Equality amongst synthesized annotations\n\t\tassertThat(synthesizedWebMapping1.hashCode()).isEqualTo(synthesizedWebMapping1.hashCode());\n\t\tassertThat(synthesizedWebMapping2.hashCode()).isEqualTo(synthesizedWebMapping2.hashCode());\n\t\tassertThat(synthesizedWebMapping1.hashCode()).isEqualTo(synthesizedWebMapping2.hashCode());\n\t\tassertThat(synthesizedWebMapping2.hashCode()).isEqualTo(synthesizedWebMapping1.hashCode());\n\t\t// Equality between standard and synthesized annotations\n\t\tassertThat(synthesizedWebMapping1.hashCode()).isEqualTo(webMappingWithPathAndValue.hashCode());\n\t\tassertThat(webMappingWithPathAndValue.hashCode()).isEqualTo(synthesizedWebMapping1.hashCode());\n\t\t// Inequality between standard and synthesized annotations\n\t\tassertThat(synthesizedWebMapping1.hashCode()).isNotEqualTo(webMappingWithAliases.hashCode());\n\t\tassertThat(webMappingWithAliases.hashCode()).isNotEqualTo(synthesizedWebMapping1.hashCode());\n\t}\n\n\t/**\n\t * Fully reflection-based test that verifies support for synthesizing\n\t * annotations across packages with non-public visibility of user types\n\t * (for example, a non-public annotation that uses {@code @AliasFor}).\n\t */\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeNonPublicWithAttributeAliasesFromDifferentPackage() throws Exception {\n\t\tClass<?> type = ClassUtils.forName(\n\t\t\t\t\"org.springframework.core.annotation.subpackage.NonPublicAliasedAnnotatedClass\",\n\t\t\t\tnull);\n\t\tClass<? extends Annotation> annotationType = (Class<? extends Annotation>) ClassUtils.forName(\n\t\t\t\t\"org.springframework.core.annotation.subpackage.NonPublicAliasedAnnotation\",\n\t\t\t\tnull);\n\t\tAnnotation annotation = type.getAnnotation(annotationType);\n\t\tassertThat(annotation).isNotNull();\n\t\tMergedAnnotation<Annotation> mergedAnnotation = MergedAnnotation.from(annotation);\n\t\tAnnotation synthesizedAnnotation = mergedAnnotation.synthesize();\n\t\tassertSynthesized(synthesizedAnnotation);\n\t\tassertThat(mergedAnnotation.getString(\"name\")).isEqualTo(\"test\");\n\t\tassertThat(mergedAnnotation.getString(\"path\")).isEqualTo(\"/test\");\n\t\tassertThat(mergedAnnotation.getString(\"value\")).isEqualTo(\"/test\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithArrayOfAnnotations() {\n\t\tHierarchy hierarchy = HierarchyClass.class.getAnnotation(Hierarchy.class);\n\t\tassertThat(hierarchy).isNotNull();\n\t\tHierarchy synthesizedHierarchy = MergedAnnotation.from(hierarchy).synthesize();\n\t\tassertSynthesized(synthesizedHierarchy);\n\t\tTestConfiguration[] configs = synthesizedHierarchy.value();\n\t\tassertThat(configs).isNotNull();\n\t\tassertThat(configs).allMatch(AnnotationUtils::isSynthesizedAnnotation);\n\t\tassertThat(configs).extracting(TestConfiguration::value).containsExactly(\"A\", \"B\");\n\t\tassertThat(configs).extracting(TestConfiguration::location).containsExactly(\"A\", \"B\");\n\n\t\tTestConfiguration contextConfig = TestConfigurationClass.class.getAnnotation(TestConfiguration.class);\n\t\tassertThat(contextConfig).isNotNull();\n\t\t// Alter array returned from synthesized annotation\n\t\tconfigs[0] = contextConfig;\n\t\tassertThat(configs).extracting(TestConfiguration::value).containsExactly(\"simple.xml\", \"B\");\n\t\t// Re-retrieve the array from the synthesized annotation\n\t\tconfigs = synthesizedHierarchy.value();\n\t\tassertThat(configs).extracting(TestConfiguration::value).containsExactly(\"A\", \"B\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithArrayOfChars() {\n\t\tCharsContainer charsContainer = GroupOfCharsClass.class.getAnnotation(CharsContainer.class);\n\t\tassertThat(charsContainer).isNotNull();\n\t\tCharsContainer synthesizedCharsContainer = MergedAnnotation.from(charsContainer).synthesize();\n\t\tassertSynthesized(synthesizedCharsContainer);\n\t\tchar[] chars = synthesizedCharsContainer.chars();\n\t\tassertThat(chars).containsExactly('x', 'y', 'z');\n\t\t// Alter array returned from synthesized annotation\n\t\tchars[0] = '?';\n\t\t// Re-retrieve the array from the synthesized annotation\n\t\tchars = synthesizedCharsContainer.chars();\n\t\tassertThat(chars).containsExactly('x', 'y', 'z');\n\t}\n\n\t@Test\n\tvoid getValueWhenHasDefaultOverride() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(DefaultOverrideClass.class)\n\t\t\t\t.get(DefaultOverrideRoot.class);\n\t\tassertThat(annotation.getString(\"text\")).isEqualTo(\"metameta\");\n\t}\n\n\t@Test // gh-22654\n\tvoid getValueWhenHasDefaultOverrideWithImplicitAlias() {\n\t\tMergedAnnotation<?> annotation1 = MergedAnnotations.from(DefaultOverrideImplicitAliasMetaClass1.class)\n\t\t\t\t.get(DefaultOverrideRoot.class);\n\t\tassertThat(annotation1.getString(\"text\")).isEqualTo(\"alias-meta-1\");\n\t\tMergedAnnotation<?> annotation2 = MergedAnnotations.from(DefaultOverrideImplicitAliasMetaClass2.class)\n\t\t\t\t.get(DefaultOverrideRoot.class);\n\t\tassertThat(annotation2.getString(\"text\")).isEqualTo(\"alias-meta-2\");\n\t}\n\n\t@Test // gh-22654\n\tvoid getValueWhenHasDefaultOverrideWithExplicitAlias() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(DefaultOverrideExplicitAliasRootMetaMetaClass.class)\n\t\t\t\t.get(DefaultOverrideExplicitAliasRoot.class);\n\t\tassertThat(annotation.getString(\"text\")).isEqualTo(\"meta\");\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta\");\n\t}\n\n\t@Test // gh-22703\n\tvoid getValueWhenThreeDeepMetaWithValue() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(ValueAttributeMetaMetaClass.class)\n\t\t\t\t.get(ValueAttribute.class);\n\t\tassertThat(annotation.getStringArray(MergedAnnotation.VALUE)).containsExactly(\"FromValueAttributeMeta\");\n\t}\n\n\t@Test\n\tvoid asAnnotationAttributesReturnsPopulatedAnnotationAttributes() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(SpringApplicationConfigurationClass.class)\n\t\t\t\t.get(SpringApplicationConfiguration.class);\n\t\tAnnotationAttributes attributes = annotation.asAnnotationAttributes(Adapt.CLASS_TO_STRING);\n\t\tassertThat(attributes).containsEntry(\"classes\", new String[] {Number.class.getName()});\n\t\tassertThat(attributes.annotationType()).isEqualTo(SpringApplicationConfiguration.class);\n\t}\n\n\n\t// @formatter:off\n\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Transactional {\n\n\t\tString value() default \"\";\n\n\t\tString qualifier() default \"transactionManager\";\n\n\t\tboolean readOnly() default false;\n\t}\n\n\t@Transactional\n\t@Component\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransactionalComponent {\n\t}\n\n\t@TransactionalComponent\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedTransactionalComponent {\n\t}\n\n\tstatic class NonAnnotatedClass {\n\t}\n\n\t@Component\n\tstatic class AnnotatedClass {\n\n\t\tclass NonAnnotatedInnerClass {\n\t\t}\n\n\t\tstatic class NonAnnotatedStaticNestedClass {\n\t\t}\n\t}\n\n\tinterface NonAnnotatedInterface {\n\t}\n\n\t@TransactionalComponent\n\tstatic class TransactionalComponentClass {\n\t}\n\n\tstatic class SubTransactionalComponentClass extends TransactionalComponentClass {\n\t}\n\n\t@ComposedTransactionalComponent\n\tstatic class ComposedTransactionalComponentClass {\n\t}\n\n\t@AliasedTransactionalComponent\n\tstatic class AliasedTransactionalComponentClass {\n\t}\n\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface AliasedTransactional {\n\n\t\t@AliasFor(attribute = \"qualifier\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tString qualifier() default \"\";\n\t}\n\n\t@Transactional(qualifier = \"composed1\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@Inherited\n\t@interface InheritedComposed {\n\t}\n\n\t@Transactional(qualifier = \"composed2\", readOnly = true)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface Composed {\n\t}\n\n\t@Transactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxComposedWithOverride {\n\n\t\tString qualifier() default \"txMgr\";\n\t}\n\n\t@Transactional(\"TxInheritedComposed\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxInheritedComposed {\n\t}\n\n\t@Transactional(\"TxComposed\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxComposed {\n\t}\n\n\t@AliasedTransactional(value = \"aliasForQualifier\")\n\t@Component\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedTransactionalComponent {\n\t}\n\n\t@AliasedTransactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MyAliasedTransactional {\n\n\t\t@AliasFor(annotation = AliasedTransactional.class, attribute = \"value\")\n\t\tString value() default \"defaultTransactionManager\";\n\t}\n\n\t@MyAliasedTransactional(\"anotherTransactionManager\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@interface ComposedMyAliasedTransactional {\n\t}\n\n\t@ComposedMyAliasedTransactional\n\tstatic class ComposedTransactionalClass {\n\t}\n\n\t@AliasedTransactional(\"meta\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaAliasedTransactional {\n\t}\n\n\t@MetaAliasedTransactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMetaAliasedTransactional {\n\t}\n\n\t@MetaMetaAliasedTransactional\n\tstatic class MetaMetaAliasedTransactionalClass {\n\t}\n\n\t@TxComposedWithOverride\n\t// Override default \"txMgr\" from @TxComposedWithOverride with \"localTxMgr\"\n\t@Transactional(qualifier = \"localTxMgr\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface MetaAndLocalTxConfig {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestPropertySource {\n\n\t\t@AliasFor(\"locations\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] locations() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContextConfiguration {\n\n\t\t@AliasFor(attribute = \"locations\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tString[] locations() default {};\n\n\t\tClass<?>[] classes() default {};\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionBasedComposedContextConfiguration {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] locations() default {};\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class)\n\t\tClass<?>[] classes() default {};\n\t}\n\n\t@ContextConfiguration(value = \"duplicateDeclaration\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface InvalidConventionBasedComposedContextConfiguration {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] locations();\n\t}\n\n\t/**\n\t * This hybrid approach for annotation attribute overrides with transitive implicit\n\t * aliases is unsupported. See SPR-13554 for details.\n\t */\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface HalfConventionBasedAndHalfAliasedComposedContextConfiguration {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] locations() default {};\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles() default {};\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles();\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedValueComposedContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"value\")\n\t\tString[] locations();\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] groovyScripts() default {};\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlFiles() default {};\n\n\t\t// intentionally omitted: attribute = \"locations\"\n\t\t@AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] locations() default {};\n\n\t\t// intentionally omitted: attribute = \"locations\" (SPR-14069)\n\t\t@AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] value() default {};\n\t}\n\n\t@ImplicitAliasesContextConfiguration(xmlFiles = { \"A.xml\", \"B.xml\" })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedImplicitAliasesContextConfiguration {\n\t}\n\n\t@ImplicitAliasesContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesContextConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"xmlFiles\")\n\t\tString[] xml() default {};\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\n\t\tString[] groovy() default {};\n\t}\n\n\t@ImplicitAliasesContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SingleLocationTransitiveImplicitAliasesContextConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"xmlFiles\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@ImplicitAliasesContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesWithSkippedLevelContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xml() default {};\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\n\t\tString[] groovy() default {};\n\t}\n\n\t@ImplicitAliasesContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\n\t\tString groovy() default \"\";\n\t}\n\n\t/**\n\t * Although the configuration declares an explicit value for 'value' and requires a\n\t * value for the aliased 'locations', this does not result in an error since\n\t * 'locations' effectively shadows the 'value' attribute (which cannot be set via the\n\t * composed annotation anyway). If 'value' were not shadowed, such a declaration would\n\t * not make sense.\n\t */\n\t@ContextConfiguration(value = \"duplicateDeclaration\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ShadowedAliasComposedContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles();\n\t}\n\n\t@ContextConfiguration(locations = \"shadowed.xml\")\n\t@TestPropertySource(locations = \"test.properties\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfigurationAndTestPropertySource {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles() default \"default.xml\";\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SpringApplicationConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] locations() default {};\n\n\t\t// Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class, attribute = \"classes\")\n\t\t@AliasFor(\"value\")\n\t\tClass<?>[] classes() default {};\n\n\t\t// Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class, attribute = \"classes\")\n\t\t@AliasFor(\"classes\")\n\t\tClass<?>[] value() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScan {\n\n\t\t@AliasFor(\"basePackages\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] basePackages() default {};\n\n\t\tFilter[] excludeFilters() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({})\n\t@interface Filter {\n\n\t\tString pattern();\n\t}\n\n\t@ComponentScan(excludeFilters = { @Filter(pattern = \"*Test\"),\n\t\t@Filter(pattern = \"*Tests\") })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestComponentScan {\n\n\t\t@AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\n\t\tString[] packages();\n\t}\n\n\t@ComponentScan\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionBasedSinglePackageComponentScan {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ComponentScan.class)\n\t\tString basePackages();\n\t}\n\n\t@ComponentScan\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForBasedSinglePackageComponentScan {\n\n\t\t@AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\n\t\tString pkg();\n\t}\n\n\t@Transactional\n\tstatic class ClassWithInheritedAnnotation {\n\t}\n\n\t@Composed\n\tstatic class SubClassWithInheritedAnnotation extends ClassWithInheritedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedAnnotation\n\t\t\textends SubClassWithInheritedAnnotation {\n\t}\n\n\t@InheritedComposed\n\tstatic class ClassWithInheritedComposedAnnotation {\n\t}\n\n\t@Composed\n\tstatic class SubClassWithInheritedComposedAnnotation\n\t\t\textends ClassWithInheritedComposedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedComposedAnnotation\n\t\t\textends SubClassWithInheritedComposedAnnotation {\n\t}\n\n\t@MetaAndLocalTxConfig\n\tstatic class MetaAndLocalTxConfigClass {\n\t}\n\n\t@Transactional(\"TxConfig\")\n\tstatic class TxConfig {\n\t}\n\n\t@Transactional(\"DerivedTxConfig\")\n\tstatic class DerivedTxConfig extends TxConfig {\n\t}\n\n\t@TxInheritedComposed\n\t@TxComposed\n\tstatic class TxFromMultipleComposedAnnotations {\n\t}\n\n\t@Transactional\n\tinterface InterfaceWithInheritedAnnotation {\n\n\t\t@Order\n\t\tvoid handleFromInterface();\n\t}\n\n\tabstract static class AbstractClassWithInheritedAnnotation<T>\n\t\t\timplements InterfaceWithInheritedAnnotation {\n\n\t\t@Transactional\n\t\tpublic abstract void handle();\n\n\t\t@Transactional\n\t\tpublic void handleParameterized(T t) {\n\t\t}\n\t}\n\n\tstatic class ConcreteClassWithInheritedAnnotation\n\t\t\textends AbstractClassWithInheritedAnnotation<String> {\n\n\t\t@Override\n\t\tpublic void handle() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleParameterized(String s) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleFromInterface() {\n\t\t}\n\t}\n\n\tpublic interface GenericParameter<T> {\n\n\t\tT getFor(Class<T> cls);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class StringGenericParameter implements GenericParameter<String> {\n\n\t\t@Order\n\t\t@Override\n\t\tpublic String getFor(Class<String> cls) {\n\t\t\treturn \"foo\";\n\t\t}\n\n\t\tpublic String getFor(Integer integer) {\n\t\t\treturn \"foo\";\n\t\t}\n\t}\n\n\t@Transactional\n\tpublic interface InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubInheritedAnnotationInterface\n\t\t\textends InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubInheritedAnnotationInterface\n\t\t\textends SubInheritedAnnotationInterface {\n\t}\n\n\t@Order\n\tpublic interface NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubNonInheritedAnnotationInterface\n\t\t\textends NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubNonInheritedAnnotationInterface\n\t\t\textends SubNonInheritedAnnotationInterface {\n\t}\n\n\t@ConventionBasedComposedContextConfiguration(locations = \"explicitDeclaration\")\n\tstatic class ConventionBasedComposedContextConfigurationClass {\n\t}\n\n\t@InvalidConventionBasedComposedContextConfiguration(locations = \"requiredLocationsDeclaration\")\n\tstatic class InvalidConventionBasedComposedContextConfigurationClass {\n\t}\n\n\t@HalfConventionBasedAndHalfAliasedComposedContextConfiguration(xmlConfigFiles = \"explicitDeclaration\")\n\tstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass1 {\n\t}\n\n\t@HalfConventionBasedAndHalfAliasedComposedContextConfiguration(locations = \"explicitDeclaration\")\n\tstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass2 {\n\t}\n\n\t@AliasedComposedContextConfiguration(xmlConfigFiles = \"test.xml\")\n\tstatic class AliasedComposedContextConfigurationClass {\n\t}\n\n\t@AliasedValueComposedContextConfiguration(locations = \"test.xml\")\n\tstatic class AliasedValueComposedContextConfigurationClass {\n\t}\n\n\t@ImplicitAliasesContextConfiguration(\"foo.xml\")\n\tstatic class ImplicitAliasesContextConfigurationClass1 {\n\t}\n\n\t@ImplicitAliasesContextConfiguration(locations = \"bar.xml\")\n\tstatic class ImplicitAliasesContextConfigurationClass2 {\n\t}\n\n\t@ImplicitAliasesContextConfiguration(xmlFiles = \"baz.xml\")\n\tstatic class ImplicitAliasesContextConfigurationClass3 {\n\t}\n\n\t@TransitiveImplicitAliasesContextConfiguration(groovy = \"test.groovy\")\n\tstatic class TransitiveImplicitAliasesContextConfigurationClass {\n\t}\n\n\t@SingleLocationTransitiveImplicitAliasesContextConfiguration(groovy = \"test.groovy\")\n\tstatic class SingleLocationTransitiveImplicitAliasesContextConfigurationClass {\n\t}\n\n\t@TransitiveImplicitAliasesWithSkippedLevelContextConfiguration(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass {\n\t}\n\n\t@SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfiguration(xml = \"test.xml\")\n\tstatic class SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass {\n\t}\n\n\t@ComposedImplicitAliasesContextConfiguration\n\tstatic class ComposedImplicitAliasesContextConfigurationClass {\n\t}\n\n\t@ShadowedAliasComposedContextConfiguration(xmlConfigFiles = \"test.xml\")\n\tstatic class ShadowedAliasComposedContextConfigurationClass {\n\t}\n\n\t@AliasedComposedContextConfigurationAndTestPropertySource(xmlConfigFiles = \"test.xml\")\n\tstatic class AliasedComposedContextConfigurationAndTestPropertySourceClass {\n\t}\n\n\t@ComponentScan(value = \"com.example.app.test\", basePackages = \"com.example.app.test\")\n\tstatic class ComponentScanWithBasePackagesAndValueAliasClass {\n\t}\n\n\t@TestComponentScan(packages = \"com.example.app.test\")\n\tstatic class TestComponentScanClass {\n\t}\n\n\t@ConventionBasedSinglePackageComponentScan(basePackages = \"com.example.app.test\")\n\tstatic class ConventionBasedSinglePackageComponentScanClass {\n\t}\n\n\t@AliasForBasedSinglePackageComponentScan(pkg = \"com.example.app.test\")\n\tstatic class AliasForBasedSinglePackageComponentScanClass {\n\t}\n\n\t@SpringApplicationConfiguration(Number.class)\n\tstatic class SpringApplicationConfigurationClass {\n\t}\n\n\t@Resource(name = \"x\")\n\tstatic class ResourceHolder {\n\t}\n\n\tinterface TransactionalService {\n\n\t\t@Transactional\n\t\tvoid doIt();\n\t}\n\n\tclass TransactionalServiceImpl implements TransactionalService {\n\n\t\t@Override\n\t\tpublic void doIt() {\n\t\t}\n\t}\n\n\t@Component(\"meta1\")\n\t@Order\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Meta1 {\n\t}\n\n\t@Component(\"meta2\")\n\t@Transactional(readOnly = true)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Meta2 {\n\t}\n\n\t@Meta2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMeta {\n\t}\n\n\t@MetaMeta\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMetaMeta {\n\t}\n\n\t@MetaCycle3\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle1 {\n\t}\n\n\t@MetaCycle1\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle2 {\n\t}\n\n\t@MetaCycle2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle3 {\n\t}\n\n\t@Meta1\n\tinterface InterfaceWithMetaAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface\n\t\t\timplements InterfaceWithMetaAnnotation {\n\t}\n\n\t@Meta1\n\tstatic class ClassWithInheritedMetaAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class SubClassWithInheritedMetaAnnotation\n\t\t\textends ClassWithInheritedMetaAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedMetaAnnotation\n\t\t\textends SubClassWithInheritedMetaAnnotation {\n\t}\n\n\t@MetaMeta\n\tstatic class MetaMetaAnnotatedClass {\n\t}\n\n\t@MetaMetaMeta\n\tstatic class MetaMetaMetaAnnotatedClass {\n\t}\n\n\t@MetaCycle3\n\tstatic class MetaCycleAnnotatedClass {\n\t}\n\n\tinterface AnnotatedInterface {\n\n\t\t@Order(0)\n\t\tvoid fromInterfaceImplementedByRoot();\n\t}\n\n\tinterface NullableAnnotatedInterface {\n\n\t\t@Nullable String fromInterfaceImplementedByRoot();\n\t}\n\n\tstatic class Root implements AnnotatedInterface {\n\n\t\t@Order(27)\n\t\tpublic void annotatedOnRoot() {\n\t\t}\n\n\t\t@Meta1\n\t\tpublic void metaAnnotatedOnRoot() {\n\t\t}\n\n\t\tpublic void overrideToAnnotate() {\n\t\t}\n\n\t\t@Order(27)\n\t\tpublic void overrideWithoutNewAnnotation() {\n\t\t}\n\n\t\tpublic void notAnnotated() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void fromInterfaceImplementedByRoot() {\n\t\t}\n\t}\n\n\tpublic static class Leaf extends Root {\n\n\t\t@Order(25)\n\t\tpublic void annotatedOnLeaf() {\n\t\t}\n\n\t\t@Meta1\n\t\tpublic void metaAnnotatedOnLeaf() {\n\t\t}\n\n\t\t@MetaMeta\n\t\tpublic void metaMetaAnnotatedOnLeaf() {\n\t\t}\n\n\t\t@Override\n\t\t@Order(1)\n\t\tpublic void overrideToAnnotate() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void overrideWithoutNewAnnotation() {\n\t\t}\n\t}\n\n\tpublic abstract static class SimpleGeneric<T> {\n\n\t\t@Order(1)\n\t\tpublic abstract void something(T arg);\n\n\t}\n\n\tpublic static class TransactionalStringGeneric extends SimpleGeneric<String> {\n\n\t\t@Override\n\t\t@Transactional\n\t\tpublic void something(final String arg) {\n\t\t}\n\t}\n\n\t@Transactional\n\tpublic static class InheritedAnnotationClass {\n\t}\n\n\tpublic static class SubInheritedAnnotationClass extends InheritedAnnotationClass {\n\t}\n\n\t@Order\n\tpublic static class NonInheritedAnnotationClass {\n\t}\n\n\tpublic static class SubNonInheritedAnnotationClass\n\t\t\textends NonInheritedAnnotationClass {\n\t}\n\n\t@Transactional\n\tpublic static class TransactionalClass {\n\t}\n\n\t@Order\n\tpublic static class TransactionalAndOrderedClass extends TransactionalClass {\n\t}\n\n\tpublic static class SubTransactionalAndOrderedClass\n\t\t\textends TransactionalAndOrderedClass {\n\t}\n\n\tpublic interface InterfaceWithAnnotatedMethod {\n\n\t\t@Order\n\t\tvoid foo();\n\t}\n\n\tpublic static class ImplementsInterfaceWithAnnotatedMethod\n\t\t\timplements InterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic static class SubOfImplementsInterfaceWithAnnotatedMethod\n\t\t\textends ImplementsInterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic abstract static class AbstractDoesNotImplementInterfaceWithAnnotatedMethod\n\t\t\timplements InterfaceWithAnnotatedMethod {\n\t}\n\n\tpublic static class SubOfAbstractImplementsInterfaceWithAnnotatedMethod\n\t\t\textends AbstractDoesNotImplementInterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic interface InterfaceWithGenericAnnotatedMethod<T> {\n\n\t\t@Order\n\t\tvoid foo(T t);\n\t}\n\n\tpublic static class ImplementsInterfaceWithGenericAnnotatedMethod\n\t\t\timplements InterfaceWithGenericAnnotatedMethod<String> {\n\n\t\t@Override\n\t\tpublic void foo(String t) {\n\t\t}\n\t}\n\n\tpublic abstract static class BaseClassWithGenericAnnotatedMethod<T> {\n\n\t\t@Order\n\t\tabstract void foo(T t);\n\t}\n\n\tpublic static class ExtendsBaseClassWithGenericAnnotatedMethod\n\t\t\textends BaseClassWithGenericAnnotatedMethod<String> {\n\n\t\t@Override\n\t\tpublic void foo(String t) {\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface MyRepeatableContainer {\n\n\t\tMyRepeatable[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@Repeatable(MyRepeatableContainer.class)\n\t@interface MyRepeatable {\n\n\t\tString value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta1\")\n\t@interface MyRepeatableMeta1 {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta2\")\n\t@interface MyRepeatableMeta2 {\n\t}\n\n\tinterface InterfaceWithRepeated {\n\n\t\t@MyRepeatable(\"A\")\n\t\t@MyRepeatableContainer({ @MyRepeatable(\"B\"), @MyRepeatable(\"C\") })\n\t\t@MyRepeatableMeta1\n\t\tvoid foo();\n\t}\n\n\t@MyRepeatable(\"A\")\n\t@MyRepeatableContainer({ @MyRepeatable(\"B\"), @MyRepeatable(\"C\") })\n\t@MyRepeatableMeta1\n\tstatic class MyRepeatableClass {\n\t}\n\n\tstatic class SubMyRepeatableClass extends MyRepeatableClass {\n\t}\n\n\t@MyRepeatable(\"X\")\n\t@MyRepeatableContainer({ @MyRepeatable(\"Y\"), @MyRepeatable(\"Z\") })\n\t@MyRepeatableMeta2\n\tstatic class SubMyRepeatableWithAdditionalLocalDeclarationsClass\n\t\t\textends MyRepeatableClass {\n\t}\n\n\tstatic class SubSubMyRepeatableWithAdditionalLocalDeclarationsClass\n\t\t\textends SubMyRepeatableWithAdditionalLocalDeclarationsClass {\n\t}\n\n\tenum RequestMethod {\n\t\tGET,\n\n\t\tPOST;\n\n\t\t/**\n\t\t * custom override to verify annotation toString() implementations.\n\t\t */\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"method: \" + name().toLowerCase();\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface RequestMapping {\n\n\t\tString name();\n\n\t\t@AliasFor(\"path\")\n\t\tString[] value() default \"\";\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tString[] path() default \"\";\n\n\t\tRequestMethod[] method() default {};\n\n\t\t// ---------------------------------------------------------------------\n\t\t// All remaining attributes declare default values that are used solely\n\t\t// for the purpose of testing the toString() implementations for annotations.\n\t\tClass<?> clazz() default RequestMethod.class;\n\t\tClass<?>[] classes() default {int[][].class, RequestMethod[].class};\n\n\t\tchar ch() default 'X';\n\t\tchar[] chars() default {'X'};\n\n\t\tbyte byteValue() default (byte) 0xFF;\n\t\tbyte[] bytes() default {(byte) 0xFF};\n\n\t\tshort shortValue() default 9876;\n\t\tshort[] shorts() default {9876};\n\n\t\tlong longValue() default 42L;\n\t\tlong[] longs() default {42L};\n\n\t\tfloat floatValue() default 3.14F;\n\t\tfloat[] floats() default {3.14F};\n\n\t\tdouble doubleValue() default 99.999D;\n\t\tdouble[] doubles() default {99.999D};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@RequestMapping(method = RequestMethod.GET, name = \"\")\n\t@interface GetMapping {\n\n\t\t@AliasFor(annotation = RequestMapping.class)\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = RequestMapping.class)\n\t\tString path() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@RequestMapping(method = RequestMethod.POST, name = \"\")\n\t@interface PostMapping {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = RequestMapping.class)\n\t\tString path() default \"\";\n\t}\n\n\t@Component(\"webController\")\n\tstatic class WebController {\n\n\t\t@RequestMapping(value = \"/test\", name = \"foo\")\n\t\tpublic void handleMappedWithValueAttribute() {\n\t\t}\n\n\t\t@RequestMapping(path = \"/test\", name = \"bar\", method = { RequestMethod.GET,\n\t\t\tRequestMethod.POST })\n\t\tpublic void handleMappedWithPathAttribute() {\n\t\t}\n\n\t\t@GetMapping(\"/test\")\n\t\tpublic void getMappedWithValueAttribute() {\n\t\t}\n\n\t\t@GetMapping(path = \"/test\")\n\t\tpublic void getMappedWithPathAttribute() {\n\t\t}\n\n\t\t@PostMapping(path = \"/test\")\n\t\tpublic void postMappedWithPathAttribute() {\n\t\t}\n\n\t\t@RequestMapping(value = \"/test\", path = \"/test\", name = \"bar\", method = {\n\t\t\tRequestMethod.GET, RequestMethod.POST })\n\t\tpublic void handleMappedWithSamePathAndValueAttributes() {\n\t\t}\n\n\t\t@RequestMapping(value = \"/enigma\", path = \"/test\", name = \"baz\")\n\t\tpublic void handleMappedWithDifferentPathAndValueAttributes() {\n\t\t}\n\t}\n\n\t/**\n\t * Mimics jakarta.persistence.Id\n\t */\n\t@Retention(RUNTIME)\n\t@interface Id {\n\t}\n\n\t/**\n\t * Mimics jakarta.persistence.GeneratedValue\n\t */\n\t@Retention(RUNTIME)\n\t@interface GeneratedValue {\n\t\tString strategy();\n\t}\n\n\t@Id\n\t@GeneratedValue(strategy = \"AUTO\")\n\tprivate Long getId() {\n\t\treturn 42L;\n\t}\n\n\t/**\n\t * Mimics org.springframework.security.config.annotation.authentication.configuration.EnableGlobalAuthentication\n\t */\n\t@Retention(RUNTIME)\n\t@interface EnableGlobalAuthentication {\n\t}\n\n\t/**\n\t * Mimics org.springframework.security.config.annotation.web.configuration.EnableWebSecurity\n\t */\n\t@Retention(RUNTIME)\n\t@EnableGlobalAuthentication\n\t@interface EnableWebSecurity {\n\t}\n\n\t@EnableWebSecurity\n\tstatic class SecurityConfig {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ ElementType.FIELD, ElementType.ANNOTATION_TYPE })\n\t@interface RootAnnotation {\n\t\tString value() default \"\";\n\t\tboolean flag() default false;\n\t}\n\n\t@RootAnnotation\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ ElementType.FIELD, ElementType.ANNOTATION_TYPE })\n\t@interface ComposedRootAnnotation {\n\n\t\t@AliasFor(annotation = RootAnnotation.class, attribute = \"flag\")\n\t\tboolean enabled() default true;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.FIELD)\n\t@ComposedRootAnnotation\n\t@interface DoublyComposedRootAnnotation {\n\t}\n\n\tclass DomainType {\n\n\t\t@RootAnnotation\n\t\tObject directlyAnnotated;\n\n\t\t@ComposedRootAnnotation\n\t\tObject metaAnnotated;\n\n\t\t@DoublyComposedRootAnnotation\n\t\tObject metaMetaAnnotated;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestConfiguration {\n\n\t\t@AliasFor(\"location\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString location() default \"\";\n\n\t\tClass<?> configClass() default Object.class;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Hierarchy {\n\n\t\tTestConfiguration[] value();\n\t}\n\n\t@Hierarchy({ @TestConfiguration(\"A\"), @TestConfiguration(location = \"B\") })\n\tstatic class HierarchyClass {\n\t}\n\n\t@TestConfiguration(\"simple.xml\")\n\tstatic class TestConfigurationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface CharsContainer {\n\n\t\t@AliasFor(attribute = \"chars\")\n\t\tchar[] value() default {};\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tchar[] chars() default {};\n\t}\n\n\t@CharsContainer(chars = { 'x', 'y', 'z' })\n\tstatic class GroupOfCharsClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMissingAttributeDeclaration {\n\n\t\t@AliasFor\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForWithMissingAttributeDeclaration\n\tstatic class AliasForWithMissingAttributeDeclarationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithDuplicateAttributeDeclaration {\n\n\t\t@AliasFor(value = \"bar\", attribute = \"baz\")\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForWithDuplicateAttributeDeclaration\n\tstatic class AliasForWithDuplicateAttributeDeclarationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForNonexistentAttribute {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForNonexistentAttribute\n\tstatic class AliasForNonexistentAttributeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithoutMirroredAliasFor {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"\";\n\n\t\tString bar() default \"\";\n\t}\n\n\t@AliasForWithoutMirroredAliasFor\n\tstatic class AliasForWithoutMirroredAliasForClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMirroredAliasForWrongAttribute {\n\n\t\t@AliasFor(attribute = \"bar\")\n\t\tString[] foo() default \"\";\n\n\t\t@AliasFor(attribute = \"quux\")\n\t\tString[] bar() default \"\";\n\t}\n\n\t@AliasForWithMirroredAliasForWrongAttribute\n\tstatic class AliasForWithMirroredAliasForWrongAttributeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForAttributeOfDifferentType {\n\n\t\t@AliasFor(\"bar\")\n\t\tString[] foo() default \"\";\n\n\t\t@AliasFor(\"foo\")\n\t\tboolean bar() default true;\n\t}\n\n\t@AliasForAttributeOfDifferentType\n\tstatic class AliasForAttributeOfDifferentTypeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMissingDefaultValues {\n\n\t\t@AliasFor(attribute = \"bar\")\n\t\tString foo();\n\n\t\t@AliasFor(attribute = \"foo\")\n\t\tString bar();\n\t}\n\n\t@AliasForWithMissingDefaultValues(foo = \"foo\", bar = \"bar\")\n\tstatic class AliasForWithMissingDefaultValuesClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForAttributeWithDifferentDefaultValue {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"X\";\n\n\t\t@AliasFor(\"foo\")\n\t\tString bar() default \"Z\";\n\t}\n\n\t@AliasForAttributeWithDifferentDefaultValue\n\tstatic class AliasForAttributeWithDifferentDefaultValueClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedTestConfigurationNotMetaPresent {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlConfigFile();\n\t}\n\n\t@AliasedComposedTestConfigurationNotMetaPresent(xmlConfigFile = \"test.xml\")\n\tstatic class AliasedComposedTestConfigurationNotMetaPresentClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlConfigFile();\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface ImplicitAliasesTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString groovyScript() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location1() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location2() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location3() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"configClass\")\n\t\tClass<?> configClass() default Object.class;\n\n\t\tString nonAliasedAttribute() default \"\";\n\t}\n\n\t@ImplicitAliasesTestConfiguration(groovyScript = \"groovyScript\")\n\tstatic class GroovyImplicitAliasesSimpleTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(xmlFile = \"xmlFile\")\n\tstatic class XmlImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(\"value\")\n\tstatic class ValueImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(location1 = \"location1\")\n\tstatic class Location1ImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(location2 = \"location2\")\n\tstatic class Location2ImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(location3 = \"location3\")\n\tstatic class Location3ImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class)\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class)\n\t\tString location() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration.class, attribute = \"location\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration(\"value\")\n\tstatic class ValueImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration(location = \"location\")\n\tstatic class LocationsImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration(xmlFile = \"xmlFile\")\n\tstatic class XmlFilesImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithMissingDefaultValuesTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location1();\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location2();\n\t}\n\n\t@ImplicitAliasesWithMissingDefaultValuesTestConfiguration(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithMissingDefaultValuesTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithDifferentDefaultValuesTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location1() default \"foo\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location2() default \"bar\";\n\t}\n\n\t@ImplicitAliasesWithDifferentDefaultValuesTestConfiguration(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithDifferentDefaultValuesTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithDuplicateValuesTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location1() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location2() default \"\";\n\t}\n\n\t@ImplicitAliasesWithDuplicateValuesTestConfiguration(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithDuplicateValuesTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesForAliasPairTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, value = \"value\")\n\t\tString groovyScript() default \"\";\n\t}\n\n\t@ImplicitAliasesForAliasPairTestConfiguration(xmlFile = \"test.xml\")\n\tstatic class ImplicitAliasesForAliasPairTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesTestConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesTestConfiguration.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesTestConfiguration.class, attribute = \"groovyScript\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@TransitiveImplicitAliasesTestConfiguration(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesForAliasPairTestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesForAliasPairTestConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesForAliasPairTestConfiguration.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesForAliasPairTestConfiguration.class, attribute = \"groovyScript\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@TransitiveImplicitAliasesForAliasPairTestConfiguration(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesForAliasPairTestConfigurationClass {\n\t}\n\n\t@ComponentScan(excludeFilters = { @Filter(pattern = \"*Foo\"),\n\t\t@Filter(pattern = \"*Bar\") })\n\tstatic class ComponentScanClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScanSingleFilter {\n\n\t\tFilter value();\n\t}\n\n\t@ComponentScanSingleFilter(@Filter(pattern = \"*Foo\"))\n\tstatic class ComponentScanSingleFilterClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnotationWithDefaults {\n\n\t\tString text() default \"enigma\";\n\n\t\tboolean predicate() default true;\n\n\t\tchar[] characters() default { 'a', 'b', 'c' };\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnotationWithoutDefaults {\n\n\t\tString text();\n\t}\n\n\t@TestConfiguration(value = \"foo\", location = \"bar\")\n\tinterface TestConfigurationMismatch {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface DefaultOverrideRoot {\n\n\t\tString text() default \"root\";\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideRoot\n\t@interface DefaultOverrideMeta {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideMeta\n\t@interface DefaultOverrideMetaMeta {\n\n\t\tString text() default \"metameta\";\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideMetaMeta\n\t@interface DefaultOverrideMetaMetaMeta {\n\n\t}\n\n\t@DefaultOverrideMetaMetaMeta\n\tstatic class DefaultOverrideClass {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideRoot\n\t@interface DefaultOverrideImplicitAlias {\n\n\t\t@AliasFor(annotation=DefaultOverrideRoot.class, attribute=\"text\")\n\t\tString text1() default \"alias\";\n\n\t\t@AliasFor(annotation=DefaultOverrideRoot.class, attribute=\"text\")\n\t\tString text2() default \"alias\";\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideImplicitAlias(text1=\"alias-meta-1\")\n\t@interface DefaultOverrideAliasImplicitMeta1 {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideImplicitAlias(text2=\"alias-meta-2\")\n\t@interface DefaultOverrideImplicitAliasMeta2 {\n\n\t}\n\n\t@DefaultOverrideAliasImplicitMeta1\n\tstatic class DefaultOverrideImplicitAliasMetaClass1 {\n\n\t}\n\n\t@DefaultOverrideImplicitAliasMeta2\n\tstatic class DefaultOverrideImplicitAliasMetaClass2 {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface DefaultOverrideExplicitAliasRoot {\n\n\t\t@AliasFor(\"value\")\n\t\tString text() default \"\";\n\n\t\t@AliasFor(\"text\")\n\t\tString value() default \"\";\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideExplicitAliasRoot(\"meta\")\n\t@interface DefaultOverrideExplicitAliasRootMeta {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideExplicitAliasRootMeta\n\t@interface DefaultOverrideExplicitAliasRootMetaMeta {\n\n\t}\n\n\t@DefaultOverrideExplicitAliasRootMetaMeta\n\tstatic class DefaultOverrideExplicitAliasRootMetaMetaClass {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ValueAttribute {\n\n\t\tString[] value();\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueAttribute(\"FromValueAttributeMeta\")\n\t@interface ValueAttributeMeta {\n\n\t\tString[] value() default {};\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueAttributeMeta(\"FromValueAttributeMetaMeta\")\n\t@interface ValueAttributeMetaMeta {\n\n\t}\n\n\t@ValueAttributeMetaMeta\n\tstatic class ValueAttributeMetaMetaClass {\n\n\t}\n\t// @formatter:on\n\n\tstatic void assertSynthesized(Annotation annotation) {\n\t\tassertThat(AnnotationUtils.isSynthesizedAnnotation(annotation)).as(\"synthesized annotation\").isTrue();\n\t}\n\n\tstatic void assertNotSynthesized(Annotation annotation) {\n\t\tassertThat(AnnotationUtils.isSynthesizedAnnotation(annotation)).as(\"synthesized annotation\").isFalse();\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.ImplicitAliasesContextConfigurationClass1",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.ImplicitAliasesContextConfigurationClass1",
    "headType": "class",
    "relation": "use",
    "tail": "@ImplicitAliasesContextConfiguration",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.ImplicitAliasesContextConfigurationClass1",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.stream.Stream;\n\nimport jakarta.annotation.Resource;\nimport org.jspecify.annotations.Nullable;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.AnnotationsScannerTests.Hello2Impl;\nimport org.springframework.core.annotation.AnnotationsScannerTests.TestAnnotation1;\nimport org.springframework.core.annotation.MergedAnnotation.Adapt;\nimport org.springframework.core.annotation.MergedAnnotations.Search;\nimport org.springframework.core.annotation.MergedAnnotations.SearchStrategy;\nimport org.springframework.core.annotation.subpackage.NonPublicAnnotatedClass;\nimport org.springframework.core.testfixture.ide.IdeUtils;\nimport org.springframework.core.testfixture.stereotype.Component;\nimport org.springframework.core.testfixture.stereotype.Indexed;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.MultiValueMap;\nimport org.springframework.util.ReflectionUtils;\n\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.assertj.core.api.Assertions.assertThatIllegalStateException;\nimport static org.assertj.core.api.Assertions.entry;\n\n/**\n * Tests for {@link MergedAnnotations} and {@link MergedAnnotation}. These tests\n * cover common usage scenarios and were mainly ported from the original\n * {@code AnnotationUtils} and {@code AnnotatedElementUtils} tests.\n *\n * @author Phillip Webb\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Chris Beams\n * @author Oleg Zhurakousky\n * @author Rossen Stoyanchev\n * @see MergedAnnotationsRepeatableAnnotationTests\n * @see MergedAnnotationClassLoaderTests\n */\nclass MergedAnnotationsTests {\n\n\t/**\n\t * Subset (and duplication) of other tests in {@link MergedAnnotationsTests}\n\t * that verify behavior of the fluent {@link Search} API.\n\t * @since 6.0\n\t */\n\t@Nested\n\tclass FluentSearchApiTests {\n\n\t\t@Test\n\t\tvoid preconditions() {\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> MergedAnnotations.search(null))\n\t\t\t\t\t.withMessage(\"SearchStrategy must not be null\");\n\n\t\t\tSearch search = MergedAnnotations.search(SearchStrategy.SUPERCLASS);\n\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> search.withEnclosingClasses(null))\n\t\t\t\t\t.withMessage(\"Predicate must not be null\");\n\t\t\tassertThatIllegalStateException()\n\t\t\t\t\t.isThrownBy(() -> search.withEnclosingClasses(Search.always))\n\t\t\t\t\t.withMessage(\"A custom 'searchEnclosingClass' predicate can only be combined with SearchStrategy.TYPE_HIERARCHY\");\n\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> search.withAnnotationFilter(null))\n\t\t\t\t\t.withMessage(\"AnnotationFilter must not be null\");\n\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> search.withRepeatableContainers(null))\n\t\t\t\t\t.withMessage(\"RepeatableContainers must not be null\");\n\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> search.from(null))\n\t\t\t\t\t.withMessage(\"AnnotatedElement must not be null\");\n\t\t}\n\n\t\t@Test\n\t\tvoid searchFromClassWithDefaultAnnotationFilterAndDefaultRepeatableContainers() {\n\t\t\tStream<Class<?>> classes = MergedAnnotations.search(SearchStrategy.DIRECT)\n\t\t\t\t\t.from(TransactionalComponent.class)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Transactional.class, Component.class, Indexed.class);\n\t\t}\n\n\t\t@Test\n\t\tvoid searchFromClassWithCustomAnnotationFilter() {\n\t\t\tStream<Class<?>> classes = MergedAnnotations.search(SearchStrategy.DIRECT)\n\t\t\t\t\t.withAnnotationFilter(annotationName -> annotationName.endsWith(\"Indexed\"))\n\t\t\t\t\t.from(TransactionalComponent.class)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Transactional.class, Component.class);\n\t\t}\n\n\t\t@Test\n\t\tvoid searchFromClassWithCustomRepeatableContainers() {\n\t\t\tassertThat(MergedAnnotations.from(HierarchyClass.class).stream(TestConfiguration.class)).isEmpty();\n\t\t\tRepeatableContainers containers = RepeatableContainers.of(TestConfiguration.class, Hierarchy.class);\n\n\t\t\tMergedAnnotations annotations = MergedAnnotations.search(SearchStrategy.DIRECT)\n\t\t\t\t\t.withRepeatableContainers(containers)\n\t\t\t\t\t.from(HierarchyClass.class);\n\t\t\tassertThat(annotations.stream(TestConfiguration.class))\n\t\t\t\t\t.map(annotation -> annotation.getString(\"location\"))\n\t\t\t\t\t.containsExactly(\"A\", \"B\");\n\t\t\tassertThat(annotations.stream(TestConfiguration.class))\n\t\t\t\t\t.map(annotation -> annotation.getString(\"value\"))\n\t\t\t\t\t.containsExactly(\"A\", \"B\");\n\t\t}\n\n\t\t/**\n\t\t * @since 6.0\n\t\t */\n\t\t@Test\n\t\tvoid searchFromNonAnnotatedInnerClassWithAnnotatedEnclosingClassWithEnclosingClassPredicates() {\n\t\t\tClass<?> testCase = AnnotatedClass.NonAnnotatedInnerClass.class;\n\t\t\tSearch search = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY);\n\n\t\t\tassertThat(search.from(testCase).stream()).isEmpty();\n\t\t\tassertThat(search.withEnclosingClasses(Search.never).from(testCase).stream()).isEmpty();\n\t\t\tassertThat(search.withEnclosingClasses(ClassUtils::isStaticClass).from(testCase).stream()).isEmpty();\n\n\t\t\tStream<Class<?>> classes = search.withEnclosingClasses(ClassUtils::isInnerClass)\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class, Indexed.class);\n\n\t\t\tclasses = search.withEnclosingClasses(Search.always)\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class, Indexed.class);\n\n\t\t\tclasses = search.withEnclosingClasses(ClassUtils::isInnerClass)\n\t\t\t\t\t.withRepeatableContainers(RepeatableContainers.none())\n\t\t\t\t\t.withAnnotationFilter(annotationName -> annotationName.endsWith(\"Indexed\"))\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class);\n\t\t}\n\n\t\t/**\n\t\t * @since 6.0\n\t\t */\n\t\t@Test\n\t\tvoid searchFromNonAnnotatedStaticNestedClassWithAnnotatedEnclosingClassWithEnclosingClassPredicates() {\n\t\t\tClass<?> testCase = AnnotatedClass.NonAnnotatedStaticNestedClass.class;\n\t\t\tSearch search = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY);\n\n\t\t\tassertThat(search.from(testCase).stream()).isEmpty();\n\t\t\tassertThat(search.withEnclosingClasses(Search.never).from(testCase).stream()).isEmpty();\n\t\t\tassertThat(search.withEnclosingClasses(ClassUtils::isInnerClass).from(testCase).stream()).isEmpty();\n\n\t\t\tStream<Class<?>> classes = search.withEnclosingClasses(ClassUtils::isStaticClass)\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class, Indexed.class);\n\n\t\t\tclasses = search.withEnclosingClasses(Search.always)\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class, Indexed.class);\n\t\t}\n\t}\n\n\n\t@Nested\n\tclass ConventionBasedAnnotationAttributeOverrideTests {\n\n\t\t@Test\n\t\tvoid getWithInheritedAnnotationsAttributesWithConventionBasedComposedAnnotation() {\n\t\t\tMergedAnnotation<?> annotation =\n\t\t\t\t\tMergedAnnotations.from(ConventionBasedComposedContextConfigurationClass.class,\n\t\t\t\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\t\tassertThat(annotation.isPresent()).isTrue();\n\t\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"explicitDeclaration\");\n\t\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"explicitDeclaration\");\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithInheritedAnnotationsFromHalfConventionBasedAndHalfAliasedComposedAnnotation1() {\n\t\t\t// SPR-13554: convention mapping mixed with AliasFor annotations\n\t\t\t// xmlConfigFiles can be used because it has an AliasFor annotation\n\t\t\tMergedAnnotation<?> annotation =\n\t\t\t\t\tMergedAnnotations.from(HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass1.class,\n\t\t\t\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"explicitDeclaration\");\n\t\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"explicitDeclaration\");\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithInheritedAnnotationsFromHalfConventionBasedAndHalfAliasedComposedAnnotation2() {\n\t\t\t// SPR-13554: convention mapping mixed with AliasFor annotations\n\t\t\t// locations doesn't apply because it has no AliasFor annotation\n\t\t\tMergedAnnotation<?> annotation =\n\t\t\t\t\tMergedAnnotations.from(HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass2.class,\n\t\t\t\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\t\tassertThat(annotation.getStringArray(\"locations\")).isEmpty();\n\t\t\tassertThat(annotation.getStringArray(\"value\")).isEmpty();\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithInheritedAnnotationsFromInvalidConventionBasedComposedAnnotation() {\n\t\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(InvalidConventionBasedComposedContextConfigurationClass.class,\n\t\t\t\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class));\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithTypeHierarchyWithSingleElementOverridingAnArrayViaConvention() {\n\t\t\ttestGetWithTypeHierarchy(ConventionBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithTypeHierarchyWithLocalAliasesThatConflictWithAttributesInMetaAnnotationByConvention() {\n\t\t\tMergedAnnotation<?> annotation =\n\t\t\t\t\tMergedAnnotations.from(SpringApplicationConfigurationClass.class, SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t\t\t\t.get(ContextConfiguration.class);\n\t\t\tassertThat(annotation.getStringArray(\"locations\")).isEmpty();\n\t\t\tassertThat(annotation.getStringArray(\"value\")).isEmpty();\n\t\t\tassertThat(annotation.getClassArray(\"classes\")).containsExactly(Number.class);\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithTypeHierarchyOnMethodWithSingleElementOverridingAnArrayViaConvention() throws Exception {\n\t\t\ttestGetWithTypeHierarchyWebMapping(WebController.class.getMethod(\"postMappedWithPathAttribute\"));\n\t\t}\n\t}\n\n\n\t@Test\n\tvoid fromPreconditions() {\n\t\tSearchStrategy strategy = SearchStrategy.DIRECT;\n\t\tRepeatableContainers containers = RepeatableContainers.standardRepeatables();\n\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(getClass(), strategy, null, AnnotationFilter.PLAIN))\n\t\t\t\t.withMessage(\"RepeatableContainers must not be null\");\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(getClass(), strategy, containers, null))\n\t\t\t\t.withMessage(\"AnnotationFilter must not be null\");\n\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(getClass(), new Annotation[0], null, AnnotationFilter.PLAIN))\n\t\t\t\t.withMessage(\"RepeatableContainers must not be null\");\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(getClass(), new Annotation[0], containers, null))\n\t\t\t\t.withMessage(\"AnnotationFilter must not be null\");\n\t}\n\n\t@Test\n\tvoid streamWhenFromNonAnnotatedClass() {\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class).stream(TransactionalComponent.class)).isEmpty();\n\t}\n\n\t@Test\n\tvoid streamWhenFromClassWithMetaDepth1() {\n\t\tStream<Class<?>> classes = MergedAnnotations.from(TransactionalComponent.class)\n\t\t\t\t.stream().map(MergedAnnotation::getType);\n\t\tassertThat(classes).containsExactly(Transactional.class, Component.class, Indexed.class);\n\t}\n\n\t@Test\n\tvoid streamWhenFromClassWithMetaDepth2() {\n\t\tStream<Class<?>> classes = MergedAnnotations.from(ComposedTransactionalComponent.class)\n\t\t\t\t.stream().map(MergedAnnotation::getType);\n\t\tassertThat(classes).containsExactly(TransactionalComponent.class,\n\t\t\t\tTransactional.class, Component.class, Indexed.class);\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromNonAnnotatedClass() {\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class).isPresent(Transactional.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromAnnotationClassWithMetaDepth0() {\n\t\tassertThat(MergedAnnotations.from(TransactionalComponent.class).isPresent(TransactionalComponent.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromAnnotationClassWithMetaDepth1() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(TransactionalComponent.class);\n\t\tassertThat(annotations.isPresent(Transactional.class)).isTrue();\n\t\tassertThat(annotations.isPresent(Component.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromAnnotationClassWithMetaDepth2() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponent.class);\n\t\tassertThat(annotations.isPresent(Transactional.class)).isTrue();\n\t\tassertThat(annotations.isPresent(Component.class)).isTrue();\n\t\tassertThat(annotations.isPresent(ComposedTransactionalComponent.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromClassWithMetaDepth0() {\n\t\tassertThat(MergedAnnotations.from(TransactionalComponentClass.class).isPresent(TransactionalComponent.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromSubclassWithMetaDepth0() {\n\t\tassertThat(MergedAnnotations.from(SubTransactionalComponentClass.class).isPresent(TransactionalComponent.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromClassWithMetaDepth1() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(TransactionalComponentClass.class);\n\t\tassertThat(annotations.isPresent(Transactional.class)).isTrue();\n\t\tassertThat(annotations.isPresent(Component.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromClassWithMetaDepth2() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\n\t\tassertThat(annotations.isPresent(Transactional.class)).isTrue();\n\t\tassertThat(annotations.isPresent(Component.class)).isTrue();\n\t\tassertThat(annotations.isPresent(ComposedTransactionalComponent.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid getParent() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\n\t\tassertThat(annotations.get(TransactionalComponent.class).getMetaSource().getType())\n\t\t\t\t.isEqualTo(ComposedTransactionalComponent.class);\n\t}\n\n\t@Test\n\tvoid getRootWhenNotDirect() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\n\t\tMergedAnnotation<?> annotation = annotations.get(TransactionalComponent.class);\n\t\tassertThat(annotation.getDistance()).isGreaterThan(0);\n\t\tassertThat(annotation.getRoot().getType()).isEqualTo(ComposedTransactionalComponent.class);\n\t}\n\n\t@Test\n\tvoid getRootWhenDirect() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\n\t\tMergedAnnotation<?> annotation = annotations.get(ComposedTransactionalComponent.class);\n\t\tassertThat(annotation.getDistance()).isEqualTo(0);\n\t\tassertThat(annotation.getRoot()).isSameAs(annotation);\n\t}\n\n\t@Test\n\tvoid getMetaTypes() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(ComposedTransactionalComponentClass.class)\n\t\t\t\t.get(TransactionalComponent.class);\n\t\tassertThat(annotation.getMetaTypes()).containsExactly(\n\t\t\t\tComposedTransactionalComponent.class, TransactionalComponent.class);\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFromNonAnnotatedClass() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(NonAnnotatedClass.class)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).isEmpty();\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFromClassWithLocalAnnotation() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(TxConfig.class)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"value\", List.of(\"TxConfig\")));\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFromClassWithLocalComposedAnnotationAndInheritedAnnotation() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"qualifier\", List.of(\"composed2\", \"transactionManager\")));\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"qualifier\", List.of(\"transactionManager\")));\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedComposedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"qualifier\", List.of(\"composed1\")));\n\t}\n\n\t/**\n\t * If the \"value\" entry contains both \"DerivedTxConfig\" AND \"TxConfig\", then\n\t * the algorithm is accidentally picking up shadowed annotations of the same\n\t * type within the class hierarchy. Such undesirable behavior would cause\n\t * the logic in\n\t * {@code org.springframework.context.annotation.ProfileCondition} to fail.\n\t */\n\t@Test\n\tvoid collectMultiValueMapFromClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tDerivedTxConfig.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"value\", List.of(\"DerivedTxConfig\")));\n\t}\n\n\t/**\n\t * Note: this functionality is required by\n\t * {@code org.springframework.context.annotation.ProfileCondition}.\n\t */\n\t@Test\n\tvoid collectMultiValueMapFromClassWithMultipleComposedAnnotations() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tTxFromMultipleComposedAnnotations.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"value\", List.of(\"TxInheritedComposed\", \"TxComposed\")));\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromClassWithLocalAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tTxConfig.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"TxConfig\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tDerivedTxConfig.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"DerivedTxConfig\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaCycleAnnotatedClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isFalse();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFavorsLocalComposedAnnotationOverInheritedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getBoolean(\"readOnly\")).isTrue();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getBoolean(\"readOnly\")).isFalse();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedComposedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getBoolean(\"readOnly\")).isFalse();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromInterfaceImplementedBySuperclass() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tConcreteClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isFalse();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tInheritedAnnotationInterface.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationInterface.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t}\n\n\n\t@Test\n\tvoid withInheritedAnnotationsFromAliasedComposedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tAliasedComposedContextConfigurationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"test.xml\");\n\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid withInheritedAnnotationsFromAliasedValueComposedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tAliasedValueComposedContextConfigurationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"test.xml\");\n\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromImplicitAliasesInMetaAnnotationOnComposedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tComposedImplicitAliasesContextConfigurationClass.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.get(ImplicitAliasesContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"groovyScripts\")).containsExactly(\"A.xml\", \"B.xml\");\n\t\tassertThat(annotation.getStringArray(\"xmlFiles\")).containsExactly(\"A.xml\", \"B.xml\");\n\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"A.xml\", \"B.xml\");\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"A.xml\", \"B.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromAliasedValueComposedAnnotation() {\n\t\ttestGetWithInherited(AliasedValueComposedContextConfigurationClass.class, \"test.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromImplicitAliasesForSameAttributeInComposedAnnotation() {\n\t\ttestGetWithInherited(ImplicitAliasesContextConfigurationClass1.class, \"foo.xml\");\n\t\ttestGetWithInherited(ImplicitAliasesContextConfigurationClass2.class, \"bar.xml\");\n\t\ttestGetWithInherited(ImplicitAliasesContextConfigurationClass3.class, \"baz.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromTransitiveImplicitAliases() {\n\t\ttestGetWithInherited(TransitiveImplicitAliasesContextConfigurationClass.class, \"test.groovy\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\ttestGetWithInherited(\n\t\t\t\tSingleLocationTransitiveImplicitAliasesContextConfigurationClass.class, \"test.groovy\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSkippedLevel() {\n\t\ttestGetWithInherited(\n\t\t\t\tTransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass.class, \"test.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSkippedLevelWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\ttestGetWithInherited(\n\t\t\t\tSingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass.class, \"test.xml\");\n\t}\n\n\tprivate void testGetWithInherited(Class<?> element, String... expected) {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(element, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.get(ContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"locations\")).isEqualTo(expected);\n\t\tassertThat(annotation.getStringArray(\"value\")).isEqualTo(expected);\n\t\tassertThat(annotation.getClassArray(\"classes\")).isEmpty();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromShadowedAliasComposedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tShadowedAliasComposedContextConfigurationClass.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.get(ContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"test.xml\");\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromSubInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromSubSubInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromSubNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromSubSubNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyInheritedFromInterfaceMethod() throws Exception {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleFromInterface\");\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test  // gh-31803\n\tvoid streamWithTypeHierarchyInheritedFromSuperInterfaceMethod() throws Exception {\n\t\tMethod method = Hello2Impl.class.getMethod(\"method\");\n\t\tlong count = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.from(method).stream(TestAnnotation1.class).count();\n\t\tassertThat(count).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyInheritedFromAbstractMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handle\");\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyInheritedFromBridgedMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleParameterized\", String.class);\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromBridgeMethod() {\n\t\tList<Method> methods = new ArrayList<>();\n\t\tReflectionUtils.doWithLocalMethods(StringGenericParameter.class, method -> {\n\t\t\tif (\"getFor\".equals(method.getName())) {\n\t\t\t\tmethods.add(method);\n\t\t\t}\n\t\t});\n\t\tMethod bridgeMethod = methods.get(0).getReturnType().equals(Object.class) ?\n\t\t\t\tmethods.get(0) : methods.get(1);\n\t\tMethod bridgedMethod = methods.get(0).getReturnType().equals(Object.class) ?\n\t\t\t\tmethods.get(1) : methods.get(0);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(bridgeMethod,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromClassWithMetaAndLocalTxConfig() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaAndLocalTxConfigClass.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getString(\"qualifier\")).isEqualTo(\"localTxMgr\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromClassWithAttributeAliasesInTargetAnnotation() {\n\t\tMergedAnnotation<AliasedTransactional> mergedAnnotation = MergedAnnotations.from(\n\t\t\t\tAliasedTransactionalComponentClass.class, SearchStrategy.TYPE_HIERARCHY).get(AliasedTransactional.class);\n\t\tAliasedTransactional synthesizedAnnotation = mergedAnnotation.synthesize();\n\t\tString qualifier = \"aliasForQualifier\";\n\t\tassertThat(mergedAnnotation.getString(\"value\")).isEqualTo(qualifier);\n\t\tassertThat(mergedAnnotation.getString(\"qualifier\")).isEqualTo(qualifier);\n\t\tassertThat(synthesizedAnnotation.value()).isEqualTo(qualifier);\n\t\tassertThat(synthesizedAnnotation.qualifier()).isEqualTo(qualifier);\n\t}\n\n\t@Test // gh-23767\n\tvoid getWithTypeHierarchyFromClassWithComposedMetaTransactionalAnnotation() {\n\t\tMergedAnnotation<AliasedTransactional> mergedAnnotation = MergedAnnotations.from(\n\t\t\t\tComposedTransactionalClass.class, SearchStrategy.TYPE_HIERARCHY).get(AliasedTransactional.class);\n\t\tassertThat(mergedAnnotation.getString(\"value\")).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(mergedAnnotation.getString(\"qualifier\")).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t@Test // gh-23767\n\tvoid getWithTypeHierarchyFromClassWithMetaMetaAliasedTransactional() {\n\t\tMergedAnnotation<AliasedTransactional> mergedAnnotation = MergedAnnotations.from(\n\t\t\t\tMetaMetaAliasedTransactionalClass.class, SearchStrategy.TYPE_HIERARCHY).get(AliasedTransactional.class);\n\t\tassertThat(mergedAnnotation.getString(\"value\")).isEqualTo(\"meta\");\n\t\tassertThat(mergedAnnotation.getString(\"qualifier\")).isEqualTo(\"meta\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromClassWithAttributeAliasInComposedAnnotationAndNestedAnnotationsInTargetAnnotation() {\n\t\tMergedAnnotation<?> annotation = testGetWithTypeHierarchy(\n\t\t\t\tTestComponentScanClass.class, \"com.example.app.test\");\n\t\tMergedAnnotation<Filter>[] excludeFilters = annotation.getAnnotationArray(\n\t\t\t\t\"excludeFilters\", Filter.class);\n\t\tassertThat(Arrays.stream(excludeFilters).map(\n\t\t\t\tfilter -> filter.getString(\"pattern\"))).containsExactly(\"*Test\", \"*Tests\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromClassWithBothAttributesOfAnAliasPairDeclared() {\n\t\ttestGetWithTypeHierarchy(ComponentScanWithBasePackagesAndValueAliasClass.class, \"com.example.app.test\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\ttestGetWithTypeHierarchy(AliasForBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\n\t}\n\n\tprivate MergedAnnotation<?> testGetWithTypeHierarchy(Class<?> element, String... expected) {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(element,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(ComponentScan.class);\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(expected);\n\t\tassertThat(annotation.getStringArray(\"basePackages\")).containsExactly(expected);\n\t\treturn annotation;\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyWhenMultipleMetaAnnotationsHaveClashingAttributeNames() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tAliasedComposedContextConfigurationAndTestPropertySourceClass.class, SearchStrategy.TYPE_HIERARCHY);\n\t\tMergedAnnotation<?> contextConfig = annotations.get(ContextConfiguration.class);\n\t\tassertThat(contextConfig.getStringArray(\"locations\")).containsExactly(\"test.xml\");\n\t\tassertThat(contextConfig.getStringArray(\"value\")).containsExactly(\"test.xml\");\n\t\tMergedAnnotation<?> testPropSource = annotations.get(TestPropertySource.class);\n\t\tassertThat(testPropSource.getStringArray(\"locations\")).containsExactly(\"test.properties\");\n\t\tassertThat(testPropSource.getStringArray(\"value\")).containsExactly(\"test.properties\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyOnMethodWithSingleElementOverridingAnArrayViaAliasFor() throws Exception {\n\t\ttestGetWithTypeHierarchyWebMapping(WebController.class.getMethod(\"getMappedWithValueAttribute\"));\n\t\ttestGetWithTypeHierarchyWebMapping(WebController.class.getMethod(\"getMappedWithPathAttribute\"));\n\t}\n\n\tprivate void testGetWithTypeHierarchyWebMapping(AnnotatedElement element) {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.get(RequestMapping.class);\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"/test\");\n\t\tassertThat(annotation.getStringArray(\"path\")).containsExactly(\"/test\");\n\t}\n\n\t@Test\n\tvoid getDirectWithJavaxAnnotationType() {\n\t\tassertThat(MergedAnnotations.from(ResourceHolder.class).get(Resource.class)\n\t\t\t\t.getString(\"name\")).isEqualTo(\"x\");\n\t}\n\n\t@Test\n\tvoid streamInheritedFromClassWithInterface() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class)).isEmpty();\n\t}\n\n\t@Test\n\tvoid streamTypeHierarchyFromClassWithInterface() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.stream(Transactional.class)).hasSize(1);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithMethodAnnotationOnLeaf() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"annotatedOnLeaf\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNotNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class)\n\t\t\t\t.getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithAnnotationOnMethodInInterface() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"fromInterfaceImplementedByRoot\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class)\n\t\t\t\t.getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithMetaAnnotationOnLeaf() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"metaAnnotatedOnLeaf\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class)\n\t\t\t\t.getDistance()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithMetaMetaAnnotationOnLeaf() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"metaMetaAnnotatedOnLeaf\");\n\t\tassertThat(method.getAnnotation(Component.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Component.class).getDistance()).isEqualTo(2);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tComponent.class).getDistance()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getWithAnnotationOnRoot() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"annotatedOnRoot\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNotNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithMetaAnnotationOnRoot() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"metaAnnotatedOnRoot\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithOnRootButOverridden() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"overrideWithoutNewAnnotation\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithNotAnnotated() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"notAnnotated\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(-1);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithBridgeMethod() throws Exception {\n\t\tMethod method = TransactionalStringGeneric.class.getMethod(\"something\", Object.class);\n\t\tassertThat(method.isBridge()).isTrue();\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t\t// As of JDK 8, invoking getAnnotation() on a bridge method actually finds an\n\t\t// annotation on its 'bridged' method [1]; however, the Eclipse compiler does\n\t\t// not support this [2]. Thus, we effectively ignore the following\n\t\t// assertion if the test is currently executing within the Eclipse IDE.\n\t\t//\n\t\t// [1] https://bugs.openjdk.java.net/browse/JDK-6695379\n\t\t// [2] https://bugs.eclipse.org/bugs/show_bug.cgi?id=495396\n\t\t//\n\t\tif (!IdeUtils.runningInEclipse()) {\n\t\t\tassertThat(method.getAnnotation(Transactional.class)).isNotNull();\n\t\t}\n\t\tassertThat(MergedAnnotations.from(method).get(\n\t\t\t\tTransactional.class).getDistance()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tTransactional.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithBridgedMethod() throws Exception {\n\t\tMethod method = TransactionalStringGeneric.class.getMethod(\"something\", String.class);\n\t\tassertThat(method.isBridge()).isFalse();\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t\tassertThat(method.getAnnotation(Transactional.class)).isNotNull();\n\t\tassertThat(MergedAnnotations.from(method).get(\n\t\t\t\tTransactional.class).getDistance()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tTransactional.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test // SPR-16060\n\tvoid getFromMethodWithGenericInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test // SPR-17146\n\tvoid getFromMethodWithGenericSuperclass() throws Exception {\n\t\tMethod method = ExtendsBaseClassWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithInterfaceOnSuper() throws Exception {\n\t\tMethod method = SubOfImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWhenInterfaceWhenSuperDoesNotImplementMethod() throws Exception {\n\t\tMethod method = SubOfAbstractImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverAnnotationsOnInterfaces() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tClassWithLocalMetaAnnotationAndMetaAnnotatedInterface.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedAnnotation.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getBoolean(\"readOnly\")).isTrue();\n\t}\n\n\t@Test\n\tvoid getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedComposedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedMetaAnnotation.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid getDirectFromClassgetDirectFromClassMetaMetaAnnotatedClass() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaMetaAnnotatedClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithMetaMetaMetaAnnotatedClass() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaMetaMetaAnnotatedClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\t// TransactionalClass is NOT annotated or meta-annotated with @Component\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(TransactionalClass.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.isPresent()).isFalse();\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaCycleAnnotatedClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.isPresent()).isFalse();\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithSubInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithSubSubInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithSubNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithSubSubNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubNonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getSuperClassForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isNull();\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isNull();\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isEqualTo(\n\t\t\t\t\t\t\t\tInheritedAnnotationInterface.class);\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isNull();\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isEqualTo(\n\t\t\t\t\t\t\t\tInheritedAnnotationClass.class);\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isEqualTo(\n\t\t\t\t\t\t\t\tInheritedAnnotationClass.class);\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but we should still find it on classes.\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(Order.class).getSource()).isEqualTo(\n\t\t\t\t\t\tNonInheritedAnnotationInterface.class);\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(Order.class).getSource()).isNull();\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(Order.class).getSource()).isEqualTo(\n\t\t\t\t\t\tNonInheritedAnnotationClass.class);\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(Order.class).getSource()).isEqualTo(\n\t\t\t\t\t\tNonInheritedAnnotationClass.class);\n\t}\n\n\t@Test\n\tvoid getSuperClassSourceForTypesWithSingleCandidateType() {\n\t\t// no class-level annotation\n\t\tList<Class<? extends Annotation>> transactionalCandidateList = Collections.singletonList(Transactional.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonAnnotatedInterface.class,\n\t\t\t\ttransactionalCandidateList)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonAnnotatedClass.class,\n\t\t\t\ttransactionalCandidateList)).isNull();\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationInterface.class,\n\t\t\t\ttransactionalCandidateList)).isEqualTo(\n\t\t\t\t\t\tInheritedAnnotationInterface.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationInterface.class,\n\t\t\t\ttransactionalCandidateList)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationClass.class,\n\t\t\t\ttransactionalCandidateList)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationClass.class,\n\t\t\t\ttransactionalCandidateList)).isEqualTo(InheritedAnnotationClass.class);\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but should still find it on classes.\n\t\tList<Class<? extends Annotation>> orderCandidateList = Collections.singletonList(\n\t\t\t\tOrder.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationInterface.class,\n\t\t\t\torderCandidateList)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationInterface.class,\n\t\t\t\torderCandidateList)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationClass.class,\n\t\t\t\torderCandidateList)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationClass.class,\n\t\t\t\torderCandidateList)).isEqualTo(NonInheritedAnnotationClass.class);\n\t}\n\n\t@Test\n\tvoid getSuperClassSourceForTypesWithMultipleCandidateTypes() {\n\t\tList<Class<? extends Annotation>> candidates = List.of(Transactional.class, Order.class);\n\t\t// no class-level annotation\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonAnnotatedInterface.class,\n\t\t\t\tcandidates)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonAnnotatedClass.class,\n\t\t\t\tcandidates)).isNull();\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationInterface.class,\n\t\t\t\tcandidates)).isEqualTo(InheritedAnnotationInterface.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationInterface.class,\n\t\t\t\tcandidates)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationClass.class,\n\t\t\t\tcandidates)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationClass.class,\n\t\t\t\tcandidates)).isEqualTo(InheritedAnnotationClass.class);\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but findAnnotationDeclaringClassForTypes() should still find it on\n\t\t// classes.\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationInterface.class,\n\t\t\t\tcandidates)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationInterface.class,\n\t\t\t\tcandidates)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationClass.class,\n\t\t\t\tcandidates)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationClass.class,\n\t\t\t\tcandidates)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\t// class hierarchy mixed with @Transactional and @Order declarations\n\t\tassertThat(getSuperClassSourceWithTypeIn(TransactionalClass.class,\n\t\t\t\tcandidates)).isEqualTo(TransactionalClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(TransactionalAndOrderedClass.class,\n\t\t\t\tcandidates)).isEqualTo(TransactionalAndOrderedClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubTransactionalAndOrderedClass.class,\n\t\t\t\tcandidates)).isEqualTo(TransactionalAndOrderedClass.class);\n\t}\n\n\tprivate Object getSuperClassSourceWithTypeIn(Class<?> clazz, List<Class<? extends Annotation>> annotationTypes) {\n\t\treturn MergedAnnotations.from(clazz, SearchStrategy.SUPERCLASS).stream().filter(\n\t\t\t\tMergedAnnotationPredicates.typeIn(annotationTypes).and(\n\t\t\t\t\t\tMergedAnnotation::isDirectlyPresent)).map(\n\t\t\t\t\t\t\t\tMergedAnnotation::getSource).findFirst().orElse(null);\n\t}\n\n\t@Test\n\tvoid isDirectlyPresentForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedInterface.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedInterface.class).isDirectlyPresent(\n\t\t\t\tTransactional.class)).isFalse();\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class).isDirectlyPresent(\n\t\t\t\tTransactional.class)).isFalse();\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationInterface.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isTrue();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tInheritedAnnotationInterface.class).isDirectlyPresent(\n\t\t\t\t\t\tTransactional.class)).isTrue();\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tSubInheritedAnnotationInterface.class).isDirectlyPresent(\n\t\t\t\t\t\tTransactional.class)).isFalse();\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationClass.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isTrue();\n\t\tassertThat(\n\t\t\t\tMergedAnnotations.from(InheritedAnnotationClass.class).isDirectlyPresent(\n\t\t\t\t\t\tTransactional.class)).isTrue();\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tSubInheritedAnnotationClass.class).isDirectlyPresent(\n\t\t\t\t\t\tTransactional.class)).isFalse();\n\t\t// non-inherited class-level annotation; note: @Order is not inherited\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class).get(\n\t\t\t\tOrder.class).isDirectlyPresent()).isTrue();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationInterface.class).isDirectlyPresent(\n\t\t\t\t\t\tOrder.class)).isTrue();\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class).get(\n\t\t\t\tOrder.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tSubNonInheritedAnnotationInterface.class).isDirectlyPresent(\n\t\t\t\t\t\tOrder.class)).isFalse();\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class).get(\n\t\t\t\tOrder.class).isDirectlyPresent()).isTrue();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationClass.class).isDirectlyPresent(\n\t\t\t\t\t\tOrder.class)).isTrue();\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class).get(\n\t\t\t\tOrder.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tSubNonInheritedAnnotationClass.class).isDirectlyPresent(\n\t\t\t\t\t\tOrder.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid getAggregateIndexForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(-1);\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(0);\n\t\t// Since we're not traversing interface hierarchies the following,\n\t\t// though perhaps counterintuitive, must be false:\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(1);\n\t\t// non-inherited class-level annotation; note: @Order is not inherited\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tOrder.class).getAggregateIndex()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tOrder.class).getAggregateIndex()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tOrder.class).getAggregateIndex()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tOrder.class).getAggregateIndex()).isEqualTo(-1);\n\t}\n\n\t@Test\n\tvoid getDirectWithoutAttributeAliases() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(WebController.class).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"webController\");\n\t}\n\n\t@Test\n\tvoid getDirectWithNestedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(ComponentScanClass.class).get(ComponentScan.class);\n\t\tMergedAnnotation<Filter>[] filters = annotation.getAnnotationArray(\"excludeFilters\", Filter.class);\n\t\tassertThat(Arrays.stream(filters).map(\n\t\t\t\tfilter -> filter.getString(\"pattern\"))).containsExactly(\"*Foo\", \"*Bar\");\n\t}\n\n\t@Test\n\tvoid getDirectWithAttributeAliases1() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method).get(RequestMapping.class);\n\t\tassertThat(annotation.getString(\"name\")).isEqualTo(\"foo\");\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"/test\");\n\t\tassertThat(annotation.getStringArray(\"path\")).containsExactly(\"/test\");\n\t}\n\n\t@Test\n\tvoid getDirectWithAttributeAliases2() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method).get(RequestMapping.class);\n\t\tassertThat(annotation.getString(\"name\")).isEqualTo(\"bar\");\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"/test\");\n\t\tassertThat(annotation.getStringArray(\"path\")).containsExactly(\"/test\");\n\t}\n\n\t@Test\n\tvoid getDirectWithAttributeAliasesWithDifferentValues() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithDifferentPathAndValueAttributes\");\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tMergedAnnotations.from(method).get(RequestMapping.class))\n\t\t\t\t.withMessageContaining(\"attribute 'path' and its alias 'value'\")\n\t\t\t\t.withMessageContaining(\"values of [{/test}] and [{/enigma}]\");\n\t}\n\n\t@Test\n\tvoid getValueFromAnnotation() throws Exception {\n\t\tMethod method = TransactionalStringGeneric.class.getMethod(\"something\", Object.class);\n\t\tMergedAnnotation<?> annotation =\n\t\t\t\tMergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getInt(\"value\")).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getValueFromNonPublicAnnotation() {\n\t\tAnnotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\n\t\tassertThat(declaredAnnotations).hasSize(1);\n\t\tAnnotation annotation = declaredAnnotations[0];\n\t\tMergedAnnotation<Annotation> mergedAnnotation = MergedAnnotation.from(annotation);\n\t\tassertThat(mergedAnnotation.getType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\n\t\tassertThat(mergedAnnotation.synthesize().annotationType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\n\t\tassertThat(mergedAnnotation.getInt(\"value\")).isEqualTo(42);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromAnnotation() throws Exception {\n\t\tMethod method = TransactionalStringGeneric.class.getMethod(\"something\", Object.class);\n\t\tMergedAnnotation<Order> annotation =\n\t\t\t\tMergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getDefaultValue(\"value\")).contains(Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromNonPublicAnnotation() {\n\t\tAnnotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\n\t\tassertThat(declaredAnnotations).hasSize(1);\n\t\tAnnotation declaredAnnotation = declaredAnnotations[0];\n\t\tMergedAnnotation<?> annotation = MergedAnnotation.from(declaredAnnotation);\n\t\tassertThat(annotation.getType().getName()).isEqualTo(\n\t\t\t\t\"org.springframework.core.annotation.subpackage.NonPublicAnnotation\");\n\t\tassertThat(annotation.getDefaultValue(\"value\")).contains(-1);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromAnnotationType() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotation.of(Order.class);\n\t\tassertThat(annotation.getDefaultValue(\"value\")).contains(Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnMethod() throws Exception {\n\t\tMethod method = InterfaceWithRepeated.class.getMethod(\"foo\");\n\t\tStream<MergedAnnotation<MyRepeatable>> annotations = MergedAnnotations.from(\n\t\t\t\tmethod, SearchStrategy.TYPE_HIERARCHY).stream(MyRepeatable.class);\n\t\tStream<String> values = annotations.map(\n\t\t\t\tannotation -> annotation.getString(\"value\"));\n\t\tassertThat(values).containsExactly(\"A\", \"B\", \"C\", \"meta1\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid streamRepeatableDeclaredOnClassWithAttributeAliases() {\n\t\tassertThat(MergedAnnotations.from(HierarchyClass.class).stream(\n\t\t\t\tTestConfiguration.class)).isEmpty();\n\t\tRepeatableContainers containers = RepeatableContainers.of(TestConfiguration.class,\n\t\t\t\tHierarchy.class);\n\t\tMergedAnnotations annotations = MergedAnnotations.from(HierarchyClass.class,\n\t\t\t\tSearchStrategy.DIRECT, containers, AnnotationFilter.NONE);\n\t\tassertThat(annotations.stream(TestConfiguration.class).map(\n\t\t\t\tannotation -> annotation.getString(\"location\"))).containsExactly(\"A\", \"B\");\n\t\tassertThat(annotations.stream(TestConfiguration.class).map(\n\t\t\t\tannotation -> annotation.getString(\"value\"))).containsExactly(\"A\", \"B\");\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnClass() {\n\t\tClass<?> element = MyRepeatableClass.class;\n\t\tString[] expectedValuesJava = { \"A\", \"B\", \"C\" };\n\t\tString[] expectedValuesSpring = { \"A\", \"B\", \"C\", \"meta1\" };\n\t\ttestRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnSuperclass() {\n\t\tClass<?> element = SubMyRepeatableClass.class;\n\t\tString[] expectedValuesJava = { \"A\", \"B\", \"C\" };\n\t\tString[] expectedValuesSpring = { \"A\", \"B\", \"C\", \"meta1\" };\n\t\ttestRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnClassAndSuperclass() {\n\t\tClass<?> element = SubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\n\t\tString[] expectedValuesJava = { \"X\", \"Y\", \"Z\" };\n\t\tString[] expectedValuesSpring = { \"X\", \"Y\", \"Z\", \"meta2\" };\n\t\ttestRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnMultipleSuperclasses() {\n\t\tClass<?> element = SubSubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\n\t\tString[] expectedValuesJava = { \"X\", \"Y\", \"Z\" };\n\t\tString[] expectedValuesSpring = { \"X\", \"Y\", \"Z\", \"meta2\" };\n\t\ttestRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamDirectRepeatablesDeclaredOnClass() {\n\t\tClass<?> element = MyRepeatableClass.class;\n\t\tString[] expectedValuesJava = { \"A\", \"B\", \"C\" };\n\t\tString[] expectedValuesSpring = { \"A\", \"B\", \"C\", \"meta1\" };\n\t\ttestRepeatables(SearchStrategy.DIRECT, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamDirectRepeatablesDeclaredOnSuperclass() {\n\t\tClass<?> element = SubMyRepeatableClass.class;\n\t\tString[] expectedValuesJava = {};\n\t\tString[] expectedValuesSpring = {};\n\t\ttestRepeatables(SearchStrategy.DIRECT, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\tprivate void testRepeatables(SearchStrategy searchStrategy, Class<?> element,\n\t\t\tString[] expectedValuesJava, String[] expectedValuesSpring) {\n\n\t\ttestJavaRepeatables(searchStrategy, element, expectedValuesJava);\n\t\ttestExplicitRepeatables(searchStrategy, element, expectedValuesSpring);\n\t\ttestStandardRepeatables(searchStrategy, element, expectedValuesSpring);\n\t}\n\n\tprivate void testJavaRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expected) {\n\t\tMyRepeatable[] annotations = searchStrategy == SearchStrategy.DIRECT ?\n\t\t\t\telement.getDeclaredAnnotationsByType(MyRepeatable.class) :\n\t\t\t\telement.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(Arrays.stream(annotations).map(MyRepeatable::value)).containsExactly(\n\t\t\t\texpected);\n\t}\n\n\tprivate void testExplicitRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expected) {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(element, searchStrategy,\n\t\t\t\tRepeatableContainers.of(MyRepeatable.class, MyRepeatableContainer.class),\n\t\t\t\tAnnotationFilter.PLAIN);\n\t\tStream<String> values = annotations.stream(MyRepeatable.class)\n\t\t\t\t.filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex))\n\t\t\t\t.map(annotation -> annotation.getString(\"value\"));\n\t\tassertThat(values).containsExactly(expected);\n\t}\n\n\tprivate void testStandardRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expected) {\n\t\tStream<String> values = MergedAnnotations.from(element, searchStrategy).stream(MyRepeatable.class)\n\t\t\t\t.filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex))\n\t\t\t\t.map(annotation -> annotation.getString(\"value\"));\n\t\tassertThat(values).containsExactly(expected);\n\t}\n\n\t@Test\n\tvoid synthesizeWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tComponent synthesizedComponent = MergedAnnotation.from(component).synthesize();\n\t\tassertThat(synthesizedComponent).isNotNull();\n\t\tassertThat(synthesizedComponent).isEqualTo(component);\n\t\tassertThat(synthesizedComponent.value()).isEqualTo(\"webController\");\n\t}\n\n\t/**\n\t * @since 6.0\n\t */\n\t@Test\n\tvoid synthesizedAnnotationShouldReuseJdkProxyClass() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\n\t\tRequestMapping jdkRequestMapping = method.getAnnotation(RequestMapping.class);\n\t\tassertThat(jdkRequestMapping).isNotNull();\n\t\tassertThat(jdkRequestMapping.value()).containsExactly(\"/test\");\n\t\tassertThat(jdkRequestMapping.path()).containsExactly(\"\");\n\n\t\tRequestMapping synthesizedRequestMapping = MergedAnnotation.from(jdkRequestMapping).synthesize();\n\t\tassertSynthesized(synthesizedRequestMapping);\n\t\tassertThat(synthesizedRequestMapping.value()).containsExactly(\"/test\");\n\t\tassertThat(synthesizedRequestMapping.path()).containsExactly(\"/test\");\n\n\t\tassertThat(jdkRequestMapping.getClass()).isSameAs(synthesizedRequestMapping.getClass());\n\t}\n\n\t@Test\n\tvoid synthesizeAlreadySynthesized() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\t\tRequestMapping webMapping = method.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMapping).isNotNull();\n\n\t\tRequestMapping synthesizedWebMapping = MergedAnnotation.from(webMapping).synthesize();\n\t\tRequestMapping synthesizedAgainWebMapping = MergedAnnotation.from(synthesizedWebMapping).synthesize();\n\n\t\tassertSynthesized(synthesizedWebMapping);\n\t\tassertSynthesized(synthesizedAgainWebMapping);\n\t\tassertThat(synthesizedWebMapping).isEqualTo(synthesizedAgainWebMapping);\n\t\tassertThat(synthesizedWebMapping).isSameAs(synthesizedAgainWebMapping);\n\t\tassertThat(synthesizedWebMapping.name()).isEqualTo(\"foo\");\n\t\tassertThat(synthesizedWebMapping.path()).containsExactly(\"/test\");\n\t\tassertThat(synthesizedWebMapping.value()).containsExactly(\"/test\");\n\t}\n\n\t@Test\n\tvoid synthesizeShouldNotSynthesizeNonsynthesizableAnnotations() throws Exception {\n\t\tMethod method = getClass().getDeclaredMethod(\"getId\");\n\n\t\tId id = method.getAnnotation(Id.class);\n\t\tassertThat(id).isNotNull();\n\t\tId synthesizedId = MergedAnnotation.from(id).synthesize();\n\t\tassertThat(id).isEqualTo(synthesizedId);\n\t\t// It doesn't make sense to synthesize @Id since it declares zero attributes.\n\t\tassertNotSynthesized(synthesizedId);\n\t\tassertThat(id).isSameAs(synthesizedId);\n\n\t\tGeneratedValue generatedValue = method.getAnnotation(GeneratedValue.class);\n\t\tassertThat(generatedValue).isNotNull();\n\t\tGeneratedValue synthesizedGeneratedValue = MergedAnnotation.from(generatedValue).synthesize();\n\t\tassertThat(generatedValue).isEqualTo(synthesizedGeneratedValue);\n\t\t// It doesn't make sense to synthesize @GeneratedValue since it declares zero attributes with aliases.\n\t\tassertNotSynthesized(synthesizedGeneratedValue);\n\t\tassertThat(generatedValue).isSameAs(synthesizedGeneratedValue);\n\t}\n\n\t@Test  // gh-28716\n\tvoid synthesizeWhenUsingMergedAnnotationsFromApi() {\n\t\tField directlyAnnotatedField = ReflectionUtils.findField(DomainType.class, \"directlyAnnotated\");\n\t\tMergedAnnotations mergedAnnotations = MergedAnnotations.from(directlyAnnotatedField);\n\t\tRootAnnotation rootAnnotation = mergedAnnotations.get(RootAnnotation.class).synthesize();\n\t\tassertThat(rootAnnotation.flag()).isFalse();\n\t\tassertNotSynthesized(rootAnnotation);\n\n\t\tField metaAnnotatedField = ReflectionUtils.findField(DomainType.class, \"metaAnnotated\");\n\t\tmergedAnnotations = MergedAnnotations.from(metaAnnotatedField);\n\t\trootAnnotation = mergedAnnotations.get(RootAnnotation.class).synthesize();\n\t\tassertThat(rootAnnotation.flag()).isTrue();\n\t\tassertSynthesized(rootAnnotation);\n\n\t\tField metaMetaAnnotatedField = ReflectionUtils.findField(DomainType.class, \"metaMetaAnnotated\");\n\t\tmergedAnnotations = MergedAnnotations.from(metaMetaAnnotatedField);\n\t\trootAnnotation = mergedAnnotations.get(RootAnnotation.class).synthesize();\n\t\tassertThat(rootAnnotation.flag()).isTrue();\n\t\tassertSynthesized(rootAnnotation);\n\t}\n\n\t@Test  // gh-28704\n\tvoid synthesizeShouldNotSynthesizeNonsynthesizableAnnotationsWhenUsingMergedAnnotationsFromApi() {\n\t\tMergedAnnotations mergedAnnotations = MergedAnnotations.from(SecurityConfig.class);\n\n\t\tEnableWebSecurity enableWebSecurity = mergedAnnotations.get(EnableWebSecurity.class).synthesize();\n\t\tassertNotSynthesized(enableWebSecurity);\n\n\t\tEnableGlobalAuthentication enableGlobalAuthentication = mergedAnnotations.get(EnableGlobalAuthentication.class).synthesize();\n\t\tassertNotSynthesized(enableGlobalAuthentication);\n\t}\n\n\t/**\n\t * If an attempt is made to synthesize an annotation from an annotation instance\n\t * that has already been synthesized, the original synthesized annotation should\n\t * ideally be returned as-is without creating a new proxy instance with the same\n\t * values.\n\t */\n\t@Test\n\tvoid synthesizeShouldNotResynthesizeAlreadySynthesizedAnnotations() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\t\tRequestMapping webMapping = method.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMapping).isNotNull();\n\n\t\tMergedAnnotation<RequestMapping> mergedAnnotation1 = MergedAnnotation.from(webMapping);\n\t\tRequestMapping synthesizedWebMapping1 = mergedAnnotation1.synthesize();\n\t\tRequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMapping).synthesize();\n\n\t\tassertSynthesized(synthesizedWebMapping1);\n\t\tassertSynthesized(synthesizedWebMapping2);\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(synthesizedWebMapping2);\n\n\t\t// Synthesizing an annotation from a different MergedAnnotation results in a different synthesized annotation instance.\n\t\tassertThat(synthesizedWebMapping1).isNotSameAs(synthesizedWebMapping2);\n\t\t// Synthesizing an annotation from the same MergedAnnotation results in the same synthesized annotation instance.\n\t\tassertThat(synthesizedWebMapping1).isSameAs(mergedAnnotation1.synthesize());\n\n\t\tRequestMapping synthesizedAgainWebMapping = MergedAnnotation.from(synthesizedWebMapping1).synthesize();\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(synthesizedAgainWebMapping);\n\t\t// Synthesizing an already synthesized annotation results in the original synthesized annotation instance.\n\t\tassertThat(synthesizedWebMapping1).isSameAs(synthesizedAgainWebMapping);\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAliasForIsMissingAttributeDeclaration() {\n\t\tAliasForWithMissingAttributeDeclaration annotation =\n\t\t\t\tAliasForWithMissingAttributeDeclarationClass.class.getAnnotation(\n\t\t\t\t\t\tAliasForWithMissingAttributeDeclaration.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"@AliasFor declaration on attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(AliasForWithMissingAttributeDeclaration.class.getName())\n\t\t\t\t.withMessageContaining(\"points to itself\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAliasForHasDuplicateAttributeDeclaration() {\n\t\tAliasForWithDuplicateAttributeDeclaration annotation =\n\t\t\t\tAliasForWithDuplicateAttributeDeclarationClass.class.getAnnotation(\n\t\t\t\t\t\tAliasForWithDuplicateAttributeDeclaration.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"In @AliasFor declared on attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(AliasForWithDuplicateAttributeDeclaration.class.getName())\n\t\t\t\t.withMessageContaining(\"attribute 'attribute' and its alias 'value' are present with values of 'baz' and 'bar'\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForNonexistentAttribute() {\n\t\tAliasForNonexistentAttribute annotation = AliasForNonexistentAttributeClass.class.getAnnotation(\n\t\t\t\tAliasForNonexistentAttribute.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"@AliasFor declaration on attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(AliasForNonexistentAttribute.class.getName())\n\t\t\t\t.withMessageContaining(\"declares an alias for 'bar' which is not present\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasWithMirroredAliasForWrongAttribute() {\n\t\tAliasForWithMirroredAliasForWrongAttribute annotation =\n\t\t\t\tAliasForWithMirroredAliasForWrongAttributeClass.class.getAnnotation(\n\t\t\t\t\t\tAliasForWithMirroredAliasForWrongAttribute.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessage(\"@AliasFor declaration on attribute 'bar' in annotation [\" +\n\t\t\t\t\t\tAliasForWithMirroredAliasForWrongAttribute.class.getName() +\n\t\t\t\t\t\t\"] declares an alias for 'quux' which is not present.\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForAttributeOfDifferentType() {\n\t\tAliasForAttributeOfDifferentType annotation = AliasForAttributeOfDifferentTypeClass.class.getAnnotation(\n\t\t\t\tAliasForAttributeOfDifferentType.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases\")\n\t\t\t\t.withMessageContaining(AliasForAttributeOfDifferentType.class.getName())\n\t\t\t\t.withMessageContaining(\"attribute 'foo'\")\n\t\t\t\t.withMessageContaining(\"attribute 'bar'\")\n\t\t\t\t.withMessageContaining(\"same return type\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForWithMissingDefaultValues() {\n\t\tAliasForWithMissingDefaultValues annotation = AliasForWithMissingDefaultValuesClass.class.getAnnotation(\n\t\t\t\tAliasForWithMissingDefaultValues.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases\")\n\t\t\t\t.withMessageContaining(AliasForWithMissingDefaultValues.class.getName())\n\t\t\t\t.withMessageContaining(\"attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(\"attribute 'bar' in annotation\")\n\t\t\t\t.withMessageContaining(\"default values\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForAttributeWithDifferentDefaultValue() {\n\t\tAliasForAttributeWithDifferentDefaultValue annotation =\n\t\t\t\tAliasForAttributeWithDifferentDefaultValueClass.class.getAnnotation(\n\t\t\t\t\t\tAliasForAttributeWithDifferentDefaultValue.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases\")\n\t\t\t\t.withMessageContaining(AliasForAttributeWithDifferentDefaultValue.class.getName())\n\t\t\t\t.withMessageContaining(\"attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(\"attribute 'bar' in annotation\")\n\t\t\t\t.withMessageContaining(\"same default value\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForMetaAnnotationThatIsNotMetaPresent() {\n\t\tAliasedComposedTestConfigurationNotMetaPresent annotation =\n\t\t\t\tAliasedComposedTestConfigurationNotMetaPresentClass.class.getAnnotation(\n\t\t\t\t\t\tAliasedComposedTestConfigurationNotMetaPresent.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"@AliasFor declaration on attribute 'xmlConfigFile' in annotation\")\n\t\t\t\t.withMessageContaining(AliasedComposedTestConfigurationNotMetaPresent.class.getName())\n\t\t\t\t.withMessageContaining(\"declares an alias for attribute 'location' in annotation\")\n\t\t\t\t.withMessageContaining(TestConfiguration.class.getName())\n\t\t\t\t.withMessageContaining(\"not meta-present\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliases() {\n\t\ttestSynthesisWithImplicitAliases(ValueImplicitAliasesTestConfigurationClass.class, \"value\");\n\t\ttestSynthesisWithImplicitAliases(Location1ImplicitAliasesTestConfigurationClass.class, \"location1\");\n\t\ttestSynthesisWithImplicitAliases(XmlImplicitAliasesTestConfigurationClass.class, \"xmlFile\");\n\t\ttestSynthesisWithImplicitAliases(GroovyImplicitAliasesSimpleTestConfigurationClass.class, \"groovyScript\");\n\t}\n\n\tprivate void testSynthesisWithImplicitAliases(Class<?> clazz, String expected) {\n\t\tImplicitAliasesTestConfiguration config = clazz.getAnnotation(ImplicitAliasesTestConfiguration.class);\n\t\tassertThat(config).isNotNull();\n\t\tImplicitAliasesTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.value()).isEqualTo(expected);\n\t\tassertThat(synthesized.location1()).isEqualTo(expected);\n\t\tassertThat(synthesized.xmlFile()).isEqualTo(expected);\n\t\tassertThat(synthesized.groovyScript()).isEqualTo(expected);\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesWithImpliedAliasNamesOmitted() {\n\t\ttestSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(\n\t\t\t\tValueImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass.class,\n\t\t\t\t\"value\");\n\t\ttestSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(\n\t\t\t\tLocationsImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass.class,\n\t\t\t\t\"location\");\n\t\ttestSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(\n\t\t\t\tXmlFilesImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass.class,\n\t\t\t\t\"xmlFile\");\n\t}\n\n\tprivate void testSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(Class<?> clazz, String expected) {\n\t\tImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration config = clazz.getAnnotation(\n\t\t\t\tImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration.class);\n\t\tassertThat(config).isNotNull();\n\t\tImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration synthesized =\n\t\t\t\tMergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.value()).isEqualTo(expected);\n\t\tassertThat(synthesized.location()).isEqualTo(expected);\n\t\tassertThat(synthesized.xmlFile()).isEqualTo(expected);\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesForAliasPair() {\n\t\tImplicitAliasesForAliasPairTestConfiguration config =\n\t\t\t\tImplicitAliasesForAliasPairTestConfigurationClass.class.getAnnotation(\n\t\t\t\t\t\tImplicitAliasesForAliasPairTestConfiguration.class);\n\t\tImplicitAliasesForAliasPairTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.xmlFile()).isEqualTo(\"test.xml\");\n\t\tassertThat(synthesized.groovyScript()).isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithTransitiveImplicitAliases() {\n\t\tTransitiveImplicitAliasesTestConfiguration config =\n\t\t\t\tTransitiveImplicitAliasesTestConfigurationClass.class.getAnnotation(\n\t\t\t\t\t\tTransitiveImplicitAliasesTestConfiguration.class);\n\t\tTransitiveImplicitAliasesTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.xml()).isEqualTo(\"test.xml\");\n\t\tassertThat(synthesized.groovy()).isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithTransitiveImplicitAliasesForAliasPair() {\n\t\tTransitiveImplicitAliasesForAliasPairTestConfiguration config =\n\t\t\t\tTransitiveImplicitAliasesForAliasPairTestConfigurationClass.class.getAnnotation(\n\t\t\t\t\t\tTransitiveImplicitAliasesForAliasPairTestConfiguration.class);\n\t\tTransitiveImplicitAliasesForAliasPairTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.xml()).isEqualTo(\"test.xml\");\n\t\tassertThat(synthesized.groovy()).isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesWithMissingDefaultValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithMissingDefaultValuesTestConfigurationClass.class;\n\t\tClass<ImplicitAliasesWithMissingDefaultValuesTestConfiguration> annotationType =\n\t\t\t\tImplicitAliasesWithMissingDefaultValuesTestConfiguration.class;\n\t\tImplicitAliasesWithMissingDefaultValuesTestConfiguration config = clazz.getAnnotation(annotationType);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(clazz, config))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases:\")\n\t\t\t\t.withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t\t.withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t\t.withMessageContaining(\"default values\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesWithDifferentDefaultValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithDifferentDefaultValuesTestConfigurationClass.class;\n\t\tClass<ImplicitAliasesWithDifferentDefaultValuesTestConfiguration> annotationType =\n\t\t\t\tImplicitAliasesWithDifferentDefaultValuesTestConfiguration.class;\n\t\tImplicitAliasesWithDifferentDefaultValuesTestConfiguration config = clazz.getAnnotation(annotationType);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(clazz, config))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases:\")\n\t\t\t\t.withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t\t.withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t\t.withMessageContaining(\"same default value\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesWithDuplicateValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithDuplicateValuesTestConfigurationClass.class;\n\t\tClass<ImplicitAliasesWithDuplicateValuesTestConfiguration> annotationType =\n\t\t\t\tImplicitAliasesWithDuplicateValuesTestConfiguration.class;\n\t\tImplicitAliasesWithDuplicateValuesTestConfiguration config = clazz.getAnnotation(annotationType);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotation.from(clazz, config))\n\t\t\t\t.withMessageStartingWith(\"Different @AliasFor mirror values for annotation\")\n\t\t\t\t.withMessageContaining(annotationType.getName())\n\t\t\t\t.withMessageContaining(\"declared on class\")\n\t\t\t\t.withMessageContaining(clazz.getName())\n\t\t\t\t.withMessageContaining(\"are declared with values of\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tMap<String, Object> map = Collections.singletonMap(\"value\", \"webController\");\n\t\tMergedAnnotation<Component> annotation = MergedAnnotation.of(Component.class, map);\n\n\t\tComponent synthesizedComponent = annotation.synthesize();\n\t\tassertSynthesized(synthesizedComponent);\n\t\tassertThat(synthesizedComponent.value()).isEqualTo(\"webController\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeFromMapWithNestedMap() {\n\t\tComponentScanSingleFilter componentScan = ComponentScanSingleFilterClass.class.getAnnotation(\n\t\t\t\tComponentScanSingleFilter.class);\n\t\tassertThat(componentScan).isNotNull();\n\t\tassertThat(componentScan.value().pattern()).isEqualTo(\"*Foo\");\n\t\tMap<String, Object> map = MergedAnnotation.from(componentScan).asMap(\n\t\t\t\tannotation -> new LinkedHashMap<>(), Adapt.ANNOTATION_TO_MAP);\n\t\tMap<String, Object> filterMap = (Map<String, Object>) map.get(\"value\");\n\t\tassertThat(filterMap.get(\"pattern\")).isEqualTo(\"*Foo\");\n\t\tfilterMap.put(\"pattern\", \"newFoo\");\n\t\tfilterMap.put(\"enigma\", 42);\n\t\tMergedAnnotation<ComponentScanSingleFilter> annotation = MergedAnnotation.of(\n\t\t\t\tComponentScanSingleFilter.class, map);\n\t\tComponentScanSingleFilter synthesizedComponentScan = annotation.synthesize();\n\t\tassertSynthesized(synthesizedComponentScan);\n\t\tassertThat(synthesizedComponentScan.value().pattern()).isEqualTo(\"newFoo\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeFromMapWithNestedArrayOfMaps() {\n\t\tComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class);\n\t\tassertThat(componentScan).isNotNull();\n\t\tMap<String, Object> map = MergedAnnotation.from(componentScan).asMap(\n\t\t\t\tannotation -> new LinkedHashMap<>(), Adapt.ANNOTATION_TO_MAP);\n\t\tMap<String, Object>[] filters = (Map[]) map.get(\"excludeFilters\");\n\t\tList<String> patterns = Arrays.stream(filters).map(\n\t\t\t\tm -> (String) m.get(\"pattern\")).toList();\n\t\tassertThat(patterns).containsExactly(\"*Foo\", \"*Bar\");\n\t\tfilters[0].put(\"pattern\", \"newFoo\");\n\t\tfilters[0].put(\"enigma\", 42);\n\t\tfilters[1].put(\"pattern\", \"newBar\");\n\t\tfilters[1].put(\"enigma\", 42);\n\t\tMergedAnnotation<ComponentScan> annotation = MergedAnnotation.of(ComponentScan.class, map);\n\t\tComponentScan synthesizedComponentScan = annotation.synthesize();\n\t\tassertSynthesized(synthesizedComponentScan);\n\t\tassertThat(Arrays.stream(synthesizedComponentScan.excludeFilters()).map(Filter::pattern))\n\t\t\t\t.containsExactly(\"newFoo\", \"newBar\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromDefaultsWithoutAttributeAliases() {\n\t\tMergedAnnotation<AnnotationWithDefaults> annotation = MergedAnnotation.of(AnnotationWithDefaults.class);\n\t\tAnnotationWithDefaults synthesized = annotation.synthesize();\n\t\tassertThat(synthesized.text()).isEqualTo(\"enigma\");\n\t\tassertThat(synthesized.predicate()).isTrue();\n\t\tassertThat(synthesized.characters()).containsExactly('a', 'b', 'c');\n\t}\n\n\t@Test\n\tvoid synthesizeFromDefaultsWithAttributeAliases() {\n\t\tMergedAnnotation<TestConfiguration> annotation = MergedAnnotation.of(TestConfiguration.class);\n\t\tTestConfiguration synthesized = annotation.synthesize();\n\t\tassertThat(synthesized.value()).isEmpty();\n\t\tassertThat(synthesized.location()).isEmpty();\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasesWithDifferentValues() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tMergedAnnotation.from(TestConfigurationMismatch.class.getAnnotation(TestConfiguration.class)).synthesize());\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithMinimalAttributesWithAttributeAliases() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"location\", \"test.xml\");\n\t\tMergedAnnotation<TestConfiguration> annotation = MergedAnnotation.of(TestConfiguration.class, map);\n\t\tTestConfiguration synthesized = annotation.synthesize();\n\t\tassertThat(synthesized.value()).isEqualTo(\"test.xml\");\n\t\tassertThat(synthesized.location()).isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements() {\n\t\tsynthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements(\n\t\t\t\tCollections.singletonMap(\"value\", \"/foo\"));\n\t\tsynthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements(\n\t\t\t\tCollections.singletonMap(\"path\", \"/foo\"));\n\t}\n\n\tprivate void synthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements(Map<String, Object> map) {\n\t\tMergedAnnotation<GetMapping> annotation = MergedAnnotation.of(GetMapping.class, map);\n\t\tGetMapping synthesized = annotation.synthesize();\n\t\tassertThat(synthesized.value()).isEqualTo(\"/foo\");\n\t\tassertThat(synthesized.path()).isEqualTo(\"/foo\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithImplicitAttributeAliases() {\n\t\ttestSynthesisFromMapWithImplicitAliases(\"value\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"location1\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"location2\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"location3\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"xmlFile\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"groovyScript\");\n\t}\n\n\tprivate void testSynthesisFromMapWithImplicitAliases(String attributeNameAndValue) {\n\t\tMap<String, Object> map = Collections.singletonMap(attributeNameAndValue, attributeNameAndValue);\n\t\tMergedAnnotation<ImplicitAliasesTestConfiguration> annotation = MergedAnnotation.of(\n\t\t\t\tImplicitAliasesTestConfiguration.class, map);\n\t\tImplicitAliasesTestConfiguration synthesized = annotation.synthesize();\n\n\t\tassertThat(synthesized.value()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.location1()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.location2()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.location2()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.xmlFile()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.groovyScript()).isEqualTo(attributeNameAndValue);\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithMissingAttributeValue() {\n\t\ttestMissingTextAttribute(Collections.emptyMap());\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithNullAttributeValue() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"text\", null);\n\t\tassertThat(map).containsKey(\"text\");\n\t\ttestMissingTextAttribute(map);\n\t}\n\n\tprivate void testMissingTextAttribute(Map<String, Object> attributes) {\n\t\tassertThatExceptionOfType(NoSuchElementException.class).isThrownBy(() ->\n\t\t\t\tMergedAnnotation.of(AnnotationWithoutDefaults.class, attributes).synthesize().text())\n\t\t\t\t.withMessage(\"No value found for attribute named 'text' in merged annotation \" +\n\t\t\t\t\t\tAnnotationWithoutDefaults.class.getCanonicalName());\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithAttributeOfIncorrectType() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"value\", 42L);\n\t\tMergedAnnotation<Component> annotation = MergedAnnotation.of(Component.class, map);\n\t\tassertThatIllegalStateException().isThrownBy(() -> annotation.synthesize().value())\n\t\t\t\t.withMessage(\"Attribute 'value' in annotation \" +\n\t\t\t\t\t\t\"org.springframework.core.testfixture.stereotype.Component should be \" +\n\t\t\t\t\t\t\"compatible with java.lang.String but a java.lang.Long value was returned\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromAnnotationAttributesWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tMap<String, Object> attributes = MergedAnnotation.from(component).asMap();\n\n\t\tComponent synthesized = MergedAnnotation.of(Component.class, attributes).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized).isEqualTo(component);\n\t}\n\n\t@Test\n\tvoid toStringForSynthesizedAnnotations() throws Exception {\n\t\tMethod methodWithPath = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\tRequestMapping webMappingWithAliases = methodWithPath.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithAliases).isNotNull();\n\n\t\tMethod methodWithPathAndValue = WebController.class.getMethod(\"handleMappedWithSamePathAndValueAttributes\");\n\t\tRequestMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(RequestMapping.class);\n\t\tassertThat(methodWithPathAndValue).isNotNull();\n\n\t\tRequestMapping synthesizedWebMapping1 = MergedAnnotation.from(webMappingWithAliases).synthesize();\n\t\tRequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMappingWithPathAndValue).synthesize();\n\n\t\tassertThat(webMappingWithAliases.toString()).isNotEqualTo(synthesizedWebMapping1.toString());\n\n\t\t// The unsynthesized annotation for handleMappedWithSamePathAndValueAttributes()\n\t\t// should produce almost the same toString() results as synthesized annotations for\n\t\t// handleMappedWithPathAttribute() on Java 9 or higher; however, due to multiple changes\n\t\t// in the JDK's toString() implementation for annotations in JDK 9, 14, and 19,\n\t\t// we do not test the JDK implementation.\n\t\t// assertToStringForWebMappingWithPathAndValue(webMappingWithPathAndValue);\n\n\t\tassertToStringForWebMappingWithPathAndValue(synthesizedWebMapping1);\n\t\tassertToStringForWebMappingWithPathAndValue(synthesizedWebMapping2);\n\t}\n\n\tprivate void assertToStringForWebMappingWithPathAndValue(RequestMapping webMapping) {\n\t\tassertThat(webMapping.toString())\n\t\t\t\t.startsWith(\"@org.springframework.core.annotation.MergedAnnotationsTests.RequestMapping(\")\n\t\t\t\t.contains(\n\t\t\t\t\t// Strings\n\t\t\t\t\t\"value={\\\"/test\\\"}\", \"path={\\\"/test\\\"}\", \"name=\\\"bar\\\"\",\n\t\t\t\t\t// Characters\n\t\t\t\t\t\"ch='X'\", \"chars={'X'}\",\n\t\t\t\t\t// Enums\n\t\t\t\t\t\"method={GET, POST}\",\n\t\t\t\t\t// Classes\n\t\t\t\t\t\"clazz=org.springframework.core.annotation.MergedAnnotationsTests.RequestMethod.class\",\n\t\t\t\t\t\"classes={int[][].class, org.springframework.core.annotation.MergedAnnotationsTests.RequestMethod[].class}\",\n\t\t\t\t\t// Bytes\n\t\t\t\t\t\"byteValue=(byte) 0xFF\", \"bytes={(byte) 0xFF}\",\n\t\t\t\t\t// Shorts\n\t\t\t\t\t\"shortValue=9876\", \"shorts={9876}\",\n\t\t\t\t\t// Longs\n\t\t\t\t\t\"longValue=42L\", \"longs={42L}\",\n\t\t\t\t\t// Floats\n\t\t\t\t\t\"floatValue=3.14f\", \"floats={3.14f}\",\n\t\t\t\t\t// Doubles\n\t\t\t\t\t\"doubleValue=99.999d\", \"doubles={99.999d}\"\n\t\t\t\t)\n\t\t\t\t.endsWith(\")\");\n\t}\n\n\t@Test\n\tvoid equalsForSynthesizedAnnotations() throws Exception {\n\t\tMethod methodWithPath = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\tRequestMapping webMappingWithAliases = methodWithPath.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithAliases).isNotNull();\n\t\tMethod methodWithPathAndValue = WebController.class.getMethod(\"handleMappedWithSamePathAndValueAttributes\");\n\t\tRequestMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithPathAndValue).isNotNull();\n\t\tRequestMapping synthesizedWebMapping1 = MergedAnnotation.from(webMappingWithAliases).synthesize();\n\t\tRequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMappingWithPathAndValue).synthesize();\n\t\t// Equality amongst standard annotations\n\t\tassertThat(webMappingWithAliases).isEqualTo(webMappingWithAliases);\n\t\tassertThat(webMappingWithPathAndValue).isEqualTo(webMappingWithPathAndValue);\n\t\t// Inequality amongst standard annotations\n\t\tassertThat(webMappingWithAliases).isNotEqualTo(webMappingWithPathAndValue);\n\t\tassertThat(webMappingWithPathAndValue).isNotEqualTo(webMappingWithAliases);\n\t\t// Equality amongst synthesized annotations\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(synthesizedWebMapping1);\n\t\tassertThat(synthesizedWebMapping2).isEqualTo(synthesizedWebMapping2);\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(synthesizedWebMapping2);\n\t\tassertThat(synthesizedWebMapping2).isEqualTo(synthesizedWebMapping1);\n\t\t// Equality between standard and synthesized annotations\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(webMappingWithPathAndValue);\n\t\tassertThat(webMappingWithPathAndValue).isEqualTo(synthesizedWebMapping1);\n\t\t// Inequality between standard and synthesized annotations\n\t\tassertThat(synthesizedWebMapping1).isNotEqualTo(webMappingWithAliases);\n\t\tassertThat(webMappingWithAliases).isNotEqualTo(synthesizedWebMapping1);\n\t}\n\n\t@Test\n\tvoid hashCodeForSynthesizedAnnotations() throws Exception {\n\t\tMethod methodWithPath = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\tRequestMapping webMappingWithAliases = methodWithPath.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithAliases).isNotNull();\n\t\tMethod methodWithPathAndValue = WebController.class.getMethod(\"handleMappedWithSamePathAndValueAttributes\");\n\t\tRequestMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithPathAndValue).isNotNull();\n\t\tRequestMapping synthesizedWebMapping1 = MergedAnnotation.from(webMappingWithAliases).synthesize();\n\t\tassertThat(synthesizedWebMapping1).isNotNull();\n\t\tRequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMappingWithPathAndValue).synthesize();\n\t\tassertThat(synthesizedWebMapping2).isNotNull();\n\t\t// Equality amongst standard annotations\n\t\tassertThat(webMappingWithAliases.hashCode()).isEqualTo(webMappingWithAliases.hashCode());\n\t\tassertThat(webMappingWithPathAndValue.hashCode()).isEqualTo(webMappingWithPathAndValue.hashCode());\n\t\t// Inequality amongst standard annotations\n\t\tassertThat(webMappingWithAliases.hashCode()).isNotEqualTo(webMappingWithPathAndValue.hashCode());\n\t\tassertThat(webMappingWithPathAndValue.hashCode()).isNotEqualTo(webMappingWithAliases.hashCode());\n\t\t// Equality amongst synthesized annotations\n\t\tassertThat(synthesizedWebMapping1.hashCode()).isEqualTo(synthesizedWebMapping1.hashCode());\n\t\tassertThat(synthesizedWebMapping2.hashCode()).isEqualTo(synthesizedWebMapping2.hashCode());\n\t\tassertThat(synthesizedWebMapping1.hashCode()).isEqualTo(synthesizedWebMapping2.hashCode());\n\t\tassertThat(synthesizedWebMapping2.hashCode()).isEqualTo(synthesizedWebMapping1.hashCode());\n\t\t// Equality between standard and synthesized annotations\n\t\tassertThat(synthesizedWebMapping1.hashCode()).isEqualTo(webMappingWithPathAndValue.hashCode());\n\t\tassertThat(webMappingWithPathAndValue.hashCode()).isEqualTo(synthesizedWebMapping1.hashCode());\n\t\t// Inequality between standard and synthesized annotations\n\t\tassertThat(synthesizedWebMapping1.hashCode()).isNotEqualTo(webMappingWithAliases.hashCode());\n\t\tassertThat(webMappingWithAliases.hashCode()).isNotEqualTo(synthesizedWebMapping1.hashCode());\n\t}\n\n\t/**\n\t * Fully reflection-based test that verifies support for synthesizing\n\t * annotations across packages with non-public visibility of user types\n\t * (for example, a non-public annotation that uses {@code @AliasFor}).\n\t */\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeNonPublicWithAttributeAliasesFromDifferentPackage() throws Exception {\n\t\tClass<?> type = ClassUtils.forName(\n\t\t\t\t\"org.springframework.core.annotation.subpackage.NonPublicAliasedAnnotatedClass\",\n\t\t\t\tnull);\n\t\tClass<? extends Annotation> annotationType = (Class<? extends Annotation>) ClassUtils.forName(\n\t\t\t\t\"org.springframework.core.annotation.subpackage.NonPublicAliasedAnnotation\",\n\t\t\t\tnull);\n\t\tAnnotation annotation = type.getAnnotation(annotationType);\n\t\tassertThat(annotation).isNotNull();\n\t\tMergedAnnotation<Annotation> mergedAnnotation = MergedAnnotation.from(annotation);\n\t\tAnnotation synthesizedAnnotation = mergedAnnotation.synthesize();\n\t\tassertSynthesized(synthesizedAnnotation);\n\t\tassertThat(mergedAnnotation.getString(\"name\")).isEqualTo(\"test\");\n\t\tassertThat(mergedAnnotation.getString(\"path\")).isEqualTo(\"/test\");\n\t\tassertThat(mergedAnnotation.getString(\"value\")).isEqualTo(\"/test\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithArrayOfAnnotations() {\n\t\tHierarchy hierarchy = HierarchyClass.class.getAnnotation(Hierarchy.class);\n\t\tassertThat(hierarchy).isNotNull();\n\t\tHierarchy synthesizedHierarchy = MergedAnnotation.from(hierarchy).synthesize();\n\t\tassertSynthesized(synthesizedHierarchy);\n\t\tTestConfiguration[] configs = synthesizedHierarchy.value();\n\t\tassertThat(configs).isNotNull();\n\t\tassertThat(configs).allMatch(AnnotationUtils::isSynthesizedAnnotation);\n\t\tassertThat(configs).extracting(TestConfiguration::value).containsExactly(\"A\", \"B\");\n\t\tassertThat(configs).extracting(TestConfiguration::location).containsExactly(\"A\", \"B\");\n\n\t\tTestConfiguration contextConfig = TestConfigurationClass.class.getAnnotation(TestConfiguration.class);\n\t\tassertThat(contextConfig).isNotNull();\n\t\t// Alter array returned from synthesized annotation\n\t\tconfigs[0] = contextConfig;\n\t\tassertThat(configs).extracting(TestConfiguration::value).containsExactly(\"simple.xml\", \"B\");\n\t\t// Re-retrieve the array from the synthesized annotation\n\t\tconfigs = synthesizedHierarchy.value();\n\t\tassertThat(configs).extracting(TestConfiguration::value).containsExactly(\"A\", \"B\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithArrayOfChars() {\n\t\tCharsContainer charsContainer = GroupOfCharsClass.class.getAnnotation(CharsContainer.class);\n\t\tassertThat(charsContainer).isNotNull();\n\t\tCharsContainer synthesizedCharsContainer = MergedAnnotation.from(charsContainer).synthesize();\n\t\tassertSynthesized(synthesizedCharsContainer);\n\t\tchar[] chars = synthesizedCharsContainer.chars();\n\t\tassertThat(chars).containsExactly('x', 'y', 'z');\n\t\t// Alter array returned from synthesized annotation\n\t\tchars[0] = '?';\n\t\t// Re-retrieve the array from the synthesized annotation\n\t\tchars = synthesizedCharsContainer.chars();\n\t\tassertThat(chars).containsExactly('x', 'y', 'z');\n\t}\n\n\t@Test\n\tvoid getValueWhenHasDefaultOverride() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(DefaultOverrideClass.class)\n\t\t\t\t.get(DefaultOverrideRoot.class);\n\t\tassertThat(annotation.getString(\"text\")).isEqualTo(\"metameta\");\n\t}\n\n\t@Test // gh-22654\n\tvoid getValueWhenHasDefaultOverrideWithImplicitAlias() {\n\t\tMergedAnnotation<?> annotation1 = MergedAnnotations.from(DefaultOverrideImplicitAliasMetaClass1.class)\n\t\t\t\t.get(DefaultOverrideRoot.class);\n\t\tassertThat(annotation1.getString(\"text\")).isEqualTo(\"alias-meta-1\");\n\t\tMergedAnnotation<?> annotation2 = MergedAnnotations.from(DefaultOverrideImplicitAliasMetaClass2.class)\n\t\t\t\t.get(DefaultOverrideRoot.class);\n\t\tassertThat(annotation2.getString(\"text\")).isEqualTo(\"alias-meta-2\");\n\t}\n\n\t@Test // gh-22654\n\tvoid getValueWhenHasDefaultOverrideWithExplicitAlias() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(DefaultOverrideExplicitAliasRootMetaMetaClass.class)\n\t\t\t\t.get(DefaultOverrideExplicitAliasRoot.class);\n\t\tassertThat(annotation.getString(\"text\")).isEqualTo(\"meta\");\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta\");\n\t}\n\n\t@Test // gh-22703\n\tvoid getValueWhenThreeDeepMetaWithValue() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(ValueAttributeMetaMetaClass.class)\n\t\t\t\t.get(ValueAttribute.class);\n\t\tassertThat(annotation.getStringArray(MergedAnnotation.VALUE)).containsExactly(\"FromValueAttributeMeta\");\n\t}\n\n\t@Test\n\tvoid asAnnotationAttributesReturnsPopulatedAnnotationAttributes() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(SpringApplicationConfigurationClass.class)\n\t\t\t\t.get(SpringApplicationConfiguration.class);\n\t\tAnnotationAttributes attributes = annotation.asAnnotationAttributes(Adapt.CLASS_TO_STRING);\n\t\tassertThat(attributes).containsEntry(\"classes\", new String[] {Number.class.getName()});\n\t\tassertThat(attributes.annotationType()).isEqualTo(SpringApplicationConfiguration.class);\n\t}\n\n\n\t// @formatter:off\n\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Transactional {\n\n\t\tString value() default \"\";\n\n\t\tString qualifier() default \"transactionManager\";\n\n\t\tboolean readOnly() default false;\n\t}\n\n\t@Transactional\n\t@Component\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransactionalComponent {\n\t}\n\n\t@TransactionalComponent\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedTransactionalComponent {\n\t}\n\n\tstatic class NonAnnotatedClass {\n\t}\n\n\t@Component\n\tstatic class AnnotatedClass {\n\n\t\tclass NonAnnotatedInnerClass {\n\t\t}\n\n\t\tstatic class NonAnnotatedStaticNestedClass {\n\t\t}\n\t}\n\n\tinterface NonAnnotatedInterface {\n\t}\n\n\t@TransactionalComponent\n\tstatic class TransactionalComponentClass {\n\t}\n\n\tstatic class SubTransactionalComponentClass extends TransactionalComponentClass {\n\t}\n\n\t@ComposedTransactionalComponent\n\tstatic class ComposedTransactionalComponentClass {\n\t}\n\n\t@AliasedTransactionalComponent\n\tstatic class AliasedTransactionalComponentClass {\n\t}\n\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface AliasedTransactional {\n\n\t\t@AliasFor(attribute = \"qualifier\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tString qualifier() default \"\";\n\t}\n\n\t@Transactional(qualifier = \"composed1\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@Inherited\n\t@interface InheritedComposed {\n\t}\n\n\t@Transactional(qualifier = \"composed2\", readOnly = true)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface Composed {\n\t}\n\n\t@Transactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxComposedWithOverride {\n\n\t\tString qualifier() default \"txMgr\";\n\t}\n\n\t@Transactional(\"TxInheritedComposed\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxInheritedComposed {\n\t}\n\n\t@Transactional(\"TxComposed\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxComposed {\n\t}\n\n\t@AliasedTransactional(value = \"aliasForQualifier\")\n\t@Component\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedTransactionalComponent {\n\t}\n\n\t@AliasedTransactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MyAliasedTransactional {\n\n\t\t@AliasFor(annotation = AliasedTransactional.class, attribute = \"value\")\n\t\tString value() default \"defaultTransactionManager\";\n\t}\n\n\t@MyAliasedTransactional(\"anotherTransactionManager\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@interface ComposedMyAliasedTransactional {\n\t}\n\n\t@ComposedMyAliasedTransactional\n\tstatic class ComposedTransactionalClass {\n\t}\n\n\t@AliasedTransactional(\"meta\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaAliasedTransactional {\n\t}\n\n\t@MetaAliasedTransactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMetaAliasedTransactional {\n\t}\n\n\t@MetaMetaAliasedTransactional\n\tstatic class MetaMetaAliasedTransactionalClass {\n\t}\n\n\t@TxComposedWithOverride\n\t// Override default \"txMgr\" from @TxComposedWithOverride with \"localTxMgr\"\n\t@Transactional(qualifier = \"localTxMgr\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface MetaAndLocalTxConfig {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestPropertySource {\n\n\t\t@AliasFor(\"locations\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] locations() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContextConfiguration {\n\n\t\t@AliasFor(attribute = \"locations\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tString[] locations() default {};\n\n\t\tClass<?>[] classes() default {};\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionBasedComposedContextConfiguration {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] locations() default {};\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class)\n\t\tClass<?>[] classes() default {};\n\t}\n\n\t@ContextConfiguration(value = \"duplicateDeclaration\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface InvalidConventionBasedComposedContextConfiguration {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] locations();\n\t}\n\n\t/**\n\t * This hybrid approach for annotation attribute overrides with transitive implicit\n\t * aliases is unsupported. See SPR-13554 for details.\n\t */\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface HalfConventionBasedAndHalfAliasedComposedContextConfiguration {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] locations() default {};\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles() default {};\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles();\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedValueComposedContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"value\")\n\t\tString[] locations();\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] groovyScripts() default {};\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlFiles() default {};\n\n\t\t// intentionally omitted: attribute = \"locations\"\n\t\t@AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] locations() default {};\n\n\t\t// intentionally omitted: attribute = \"locations\" (SPR-14069)\n\t\t@AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] value() default {};\n\t}\n\n\t@ImplicitAliasesContextConfiguration(xmlFiles = { \"A.xml\", \"B.xml\" })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedImplicitAliasesContextConfiguration {\n\t}\n\n\t@ImplicitAliasesContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesContextConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"xmlFiles\")\n\t\tString[] xml() default {};\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\n\t\tString[] groovy() default {};\n\t}\n\n\t@ImplicitAliasesContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SingleLocationTransitiveImplicitAliasesContextConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"xmlFiles\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@ImplicitAliasesContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesWithSkippedLevelContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xml() default {};\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\n\t\tString[] groovy() default {};\n\t}\n\n\t@ImplicitAliasesContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\n\t\tString groovy() default \"\";\n\t}\n\n\t/**\n\t * Although the configuration declares an explicit value for 'value' and requires a\n\t * value for the aliased 'locations', this does not result in an error since\n\t * 'locations' effectively shadows the 'value' attribute (which cannot be set via the\n\t * composed annotation anyway). If 'value' were not shadowed, such a declaration would\n\t * not make sense.\n\t */\n\t@ContextConfiguration(value = \"duplicateDeclaration\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ShadowedAliasComposedContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles();\n\t}\n\n\t@ContextConfiguration(locations = \"shadowed.xml\")\n\t@TestPropertySource(locations = \"test.properties\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfigurationAndTestPropertySource {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles() default \"default.xml\";\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SpringApplicationConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] locations() default {};\n\n\t\t// Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class, attribute = \"classes\")\n\t\t@AliasFor(\"value\")\n\t\tClass<?>[] classes() default {};\n\n\t\t// Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class, attribute = \"classes\")\n\t\t@AliasFor(\"classes\")\n\t\tClass<?>[] value() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScan {\n\n\t\t@AliasFor(\"basePackages\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] basePackages() default {};\n\n\t\tFilter[] excludeFilters() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({})\n\t@interface Filter {\n\n\t\tString pattern();\n\t}\n\n\t@ComponentScan(excludeFilters = { @Filter(pattern = \"*Test\"),\n\t\t@Filter(pattern = \"*Tests\") })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestComponentScan {\n\n\t\t@AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\n\t\tString[] packages();\n\t}\n\n\t@ComponentScan\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionBasedSinglePackageComponentScan {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ComponentScan.class)\n\t\tString basePackages();\n\t}\n\n\t@ComponentScan\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForBasedSinglePackageComponentScan {\n\n\t\t@AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\n\t\tString pkg();\n\t}\n\n\t@Transactional\n\tstatic class ClassWithInheritedAnnotation {\n\t}\n\n\t@Composed\n\tstatic class SubClassWithInheritedAnnotation extends ClassWithInheritedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedAnnotation\n\t\t\textends SubClassWithInheritedAnnotation {\n\t}\n\n\t@InheritedComposed\n\tstatic class ClassWithInheritedComposedAnnotation {\n\t}\n\n\t@Composed\n\tstatic class SubClassWithInheritedComposedAnnotation\n\t\t\textends ClassWithInheritedComposedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedComposedAnnotation\n\t\t\textends SubClassWithInheritedComposedAnnotation {\n\t}\n\n\t@MetaAndLocalTxConfig\n\tstatic class MetaAndLocalTxConfigClass {\n\t}\n\n\t@Transactional(\"TxConfig\")\n\tstatic class TxConfig {\n\t}\n\n\t@Transactional(\"DerivedTxConfig\")\n\tstatic class DerivedTxConfig extends TxConfig {\n\t}\n\n\t@TxInheritedComposed\n\t@TxComposed\n\tstatic class TxFromMultipleComposedAnnotations {\n\t}\n\n\t@Transactional\n\tinterface InterfaceWithInheritedAnnotation {\n\n\t\t@Order\n\t\tvoid handleFromInterface();\n\t}\n\n\tabstract static class AbstractClassWithInheritedAnnotation<T>\n\t\t\timplements InterfaceWithInheritedAnnotation {\n\n\t\t@Transactional\n\t\tpublic abstract void handle();\n\n\t\t@Transactional\n\t\tpublic void handleParameterized(T t) {\n\t\t}\n\t}\n\n\tstatic class ConcreteClassWithInheritedAnnotation\n\t\t\textends AbstractClassWithInheritedAnnotation<String> {\n\n\t\t@Override\n\t\tpublic void handle() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleParameterized(String s) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleFromInterface() {\n\t\t}\n\t}\n\n\tpublic interface GenericParameter<T> {\n\n\t\tT getFor(Class<T> cls);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class StringGenericParameter implements GenericParameter<String> {\n\n\t\t@Order\n\t\t@Override\n\t\tpublic String getFor(Class<String> cls) {\n\t\t\treturn \"foo\";\n\t\t}\n\n\t\tpublic String getFor(Integer integer) {\n\t\t\treturn \"foo\";\n\t\t}\n\t}\n\n\t@Transactional\n\tpublic interface InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubInheritedAnnotationInterface\n\t\t\textends InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubInheritedAnnotationInterface\n\t\t\textends SubInheritedAnnotationInterface {\n\t}\n\n\t@Order\n\tpublic interface NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubNonInheritedAnnotationInterface\n\t\t\textends NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubNonInheritedAnnotationInterface\n\t\t\textends SubNonInheritedAnnotationInterface {\n\t}\n\n\t@ConventionBasedComposedContextConfiguration(locations = \"explicitDeclaration\")\n\tstatic class ConventionBasedComposedContextConfigurationClass {\n\t}\n\n\t@InvalidConventionBasedComposedContextConfiguration(locations = \"requiredLocationsDeclaration\")\n\tstatic class InvalidConventionBasedComposedContextConfigurationClass {\n\t}\n\n\t@HalfConventionBasedAndHalfAliasedComposedContextConfiguration(xmlConfigFiles = \"explicitDeclaration\")\n\tstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass1 {\n\t}\n\n\t@HalfConventionBasedAndHalfAliasedComposedContextConfiguration(locations = \"explicitDeclaration\")\n\tstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass2 {\n\t}\n\n\t@AliasedComposedContextConfiguration(xmlConfigFiles = \"test.xml\")\n\tstatic class AliasedComposedContextConfigurationClass {\n\t}\n\n\t@AliasedValueComposedContextConfiguration(locations = \"test.xml\")\n\tstatic class AliasedValueComposedContextConfigurationClass {\n\t}\n\n\t@ImplicitAliasesContextConfiguration(\"foo.xml\")\n\tstatic class ImplicitAliasesContextConfigurationClass1 {\n\t}\n\n\t@ImplicitAliasesContextConfiguration(locations = \"bar.xml\")\n\tstatic class ImplicitAliasesContextConfigurationClass2 {\n\t}\n\n\t@ImplicitAliasesContextConfiguration(xmlFiles = \"baz.xml\")\n\tstatic class ImplicitAliasesContextConfigurationClass3 {\n\t}\n\n\t@TransitiveImplicitAliasesContextConfiguration(groovy = \"test.groovy\")\n\tstatic class TransitiveImplicitAliasesContextConfigurationClass {\n\t}\n\n\t@SingleLocationTransitiveImplicitAliasesContextConfiguration(groovy = \"test.groovy\")\n\tstatic class SingleLocationTransitiveImplicitAliasesContextConfigurationClass {\n\t}\n\n\t@TransitiveImplicitAliasesWithSkippedLevelContextConfiguration(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass {\n\t}\n\n\t@SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfiguration(xml = \"test.xml\")\n\tstatic class SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass {\n\t}\n\n\t@ComposedImplicitAliasesContextConfiguration\n\tstatic class ComposedImplicitAliasesContextConfigurationClass {\n\t}\n\n\t@ShadowedAliasComposedContextConfiguration(xmlConfigFiles = \"test.xml\")\n\tstatic class ShadowedAliasComposedContextConfigurationClass {\n\t}\n\n\t@AliasedComposedContextConfigurationAndTestPropertySource(xmlConfigFiles = \"test.xml\")\n\tstatic class AliasedComposedContextConfigurationAndTestPropertySourceClass {\n\t}\n\n\t@ComponentScan(value = \"com.example.app.test\", basePackages = \"com.example.app.test\")\n\tstatic class ComponentScanWithBasePackagesAndValueAliasClass {\n\t}\n\n\t@TestComponentScan(packages = \"com.example.app.test\")\n\tstatic class TestComponentScanClass {\n\t}\n\n\t@ConventionBasedSinglePackageComponentScan(basePackages = \"com.example.app.test\")\n\tstatic class ConventionBasedSinglePackageComponentScanClass {\n\t}\n\n\t@AliasForBasedSinglePackageComponentScan(pkg = \"com.example.app.test\")\n\tstatic class AliasForBasedSinglePackageComponentScanClass {\n\t}\n\n\t@SpringApplicationConfiguration(Number.class)\n\tstatic class SpringApplicationConfigurationClass {\n\t}\n\n\t@Resource(name = \"x\")\n\tstatic class ResourceHolder {\n\t}\n\n\tinterface TransactionalService {\n\n\t\t@Transactional\n\t\tvoid doIt();\n\t}\n\n\tclass TransactionalServiceImpl implements TransactionalService {\n\n\t\t@Override\n\t\tpublic void doIt() {\n\t\t}\n\t}\n\n\t@Component(\"meta1\")\n\t@Order\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Meta1 {\n\t}\n\n\t@Component(\"meta2\")\n\t@Transactional(readOnly = true)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Meta2 {\n\t}\n\n\t@Meta2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMeta {\n\t}\n\n\t@MetaMeta\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMetaMeta {\n\t}\n\n\t@MetaCycle3\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle1 {\n\t}\n\n\t@MetaCycle1\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle2 {\n\t}\n\n\t@MetaCycle2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle3 {\n\t}\n\n\t@Meta1\n\tinterface InterfaceWithMetaAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface\n\t\t\timplements InterfaceWithMetaAnnotation {\n\t}\n\n\t@Meta1\n\tstatic class ClassWithInheritedMetaAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class SubClassWithInheritedMetaAnnotation\n\t\t\textends ClassWithInheritedMetaAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedMetaAnnotation\n\t\t\textends SubClassWithInheritedMetaAnnotation {\n\t}\n\n\t@MetaMeta\n\tstatic class MetaMetaAnnotatedClass {\n\t}\n\n\t@MetaMetaMeta\n\tstatic class MetaMetaMetaAnnotatedClass {\n\t}\n\n\t@MetaCycle3\n\tstatic class MetaCycleAnnotatedClass {\n\t}\n\n\tinterface AnnotatedInterface {\n\n\t\t@Order(0)\n\t\tvoid fromInterfaceImplementedByRoot();\n\t}\n\n\tinterface NullableAnnotatedInterface {\n\n\t\t@Nullable String fromInterfaceImplementedByRoot();\n\t}\n\n\tstatic class Root implements AnnotatedInterface {\n\n\t\t@Order(27)\n\t\tpublic void annotatedOnRoot() {\n\t\t}\n\n\t\t@Meta1\n\t\tpublic void metaAnnotatedOnRoot() {\n\t\t}\n\n\t\tpublic void overrideToAnnotate() {\n\t\t}\n\n\t\t@Order(27)\n\t\tpublic void overrideWithoutNewAnnotation() {\n\t\t}\n\n\t\tpublic void notAnnotated() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void fromInterfaceImplementedByRoot() {\n\t\t}\n\t}\n\n\tpublic static class Leaf extends Root {\n\n\t\t@Order(25)\n\t\tpublic void annotatedOnLeaf() {\n\t\t}\n\n\t\t@Meta1\n\t\tpublic void metaAnnotatedOnLeaf() {\n\t\t}\n\n\t\t@MetaMeta\n\t\tpublic void metaMetaAnnotatedOnLeaf() {\n\t\t}\n\n\t\t@Override\n\t\t@Order(1)\n\t\tpublic void overrideToAnnotate() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void overrideWithoutNewAnnotation() {\n\t\t}\n\t}\n\n\tpublic abstract static class SimpleGeneric<T> {\n\n\t\t@Order(1)\n\t\tpublic abstract void something(T arg);\n\n\t}\n\n\tpublic static class TransactionalStringGeneric extends SimpleGeneric<String> {\n\n\t\t@Override\n\t\t@Transactional\n\t\tpublic void something(final String arg) {\n\t\t}\n\t}\n\n\t@Transactional\n\tpublic static class InheritedAnnotationClass {\n\t}\n\n\tpublic static class SubInheritedAnnotationClass extends InheritedAnnotationClass {\n\t}\n\n\t@Order\n\tpublic static class NonInheritedAnnotationClass {\n\t}\n\n\tpublic static class SubNonInheritedAnnotationClass\n\t\t\textends NonInheritedAnnotationClass {\n\t}\n\n\t@Transactional\n\tpublic static class TransactionalClass {\n\t}\n\n\t@Order\n\tpublic static class TransactionalAndOrderedClass extends TransactionalClass {\n\t}\n\n\tpublic static class SubTransactionalAndOrderedClass\n\t\t\textends TransactionalAndOrderedClass {\n\t}\n\n\tpublic interface InterfaceWithAnnotatedMethod {\n\n\t\t@Order\n\t\tvoid foo();\n\t}\n\n\tpublic static class ImplementsInterfaceWithAnnotatedMethod\n\t\t\timplements InterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic static class SubOfImplementsInterfaceWithAnnotatedMethod\n\t\t\textends ImplementsInterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic abstract static class AbstractDoesNotImplementInterfaceWithAnnotatedMethod\n\t\t\timplements InterfaceWithAnnotatedMethod {\n\t}\n\n\tpublic static class SubOfAbstractImplementsInterfaceWithAnnotatedMethod\n\t\t\textends AbstractDoesNotImplementInterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic interface InterfaceWithGenericAnnotatedMethod<T> {\n\n\t\t@Order\n\t\tvoid foo(T t);\n\t}\n\n\tpublic static class ImplementsInterfaceWithGenericAnnotatedMethod\n\t\t\timplements InterfaceWithGenericAnnotatedMethod<String> {\n\n\t\t@Override\n\t\tpublic void foo(String t) {\n\t\t}\n\t}\n\n\tpublic abstract static class BaseClassWithGenericAnnotatedMethod<T> {\n\n\t\t@Order\n\t\tabstract void foo(T t);\n\t}\n\n\tpublic static class ExtendsBaseClassWithGenericAnnotatedMethod\n\t\t\textends BaseClassWithGenericAnnotatedMethod<String> {\n\n\t\t@Override\n\t\tpublic void foo(String t) {\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface MyRepeatableContainer {\n\n\t\tMyRepeatable[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@Repeatable(MyRepeatableContainer.class)\n\t@interface MyRepeatable {\n\n\t\tString value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta1\")\n\t@interface MyRepeatableMeta1 {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta2\")\n\t@interface MyRepeatableMeta2 {\n\t}\n\n\tinterface InterfaceWithRepeated {\n\n\t\t@MyRepeatable(\"A\")\n\t\t@MyRepeatableContainer({ @MyRepeatable(\"B\"), @MyRepeatable(\"C\") })\n\t\t@MyRepeatableMeta1\n\t\tvoid foo();\n\t}\n\n\t@MyRepeatable(\"A\")\n\t@MyRepeatableContainer({ @MyRepeatable(\"B\"), @MyRepeatable(\"C\") })\n\t@MyRepeatableMeta1\n\tstatic class MyRepeatableClass {\n\t}\n\n\tstatic class SubMyRepeatableClass extends MyRepeatableClass {\n\t}\n\n\t@MyRepeatable(\"X\")\n\t@MyRepeatableContainer({ @MyRepeatable(\"Y\"), @MyRepeatable(\"Z\") })\n\t@MyRepeatableMeta2\n\tstatic class SubMyRepeatableWithAdditionalLocalDeclarationsClass\n\t\t\textends MyRepeatableClass {\n\t}\n\n\tstatic class SubSubMyRepeatableWithAdditionalLocalDeclarationsClass\n\t\t\textends SubMyRepeatableWithAdditionalLocalDeclarationsClass {\n\t}\n\n\tenum RequestMethod {\n\t\tGET,\n\n\t\tPOST;\n\n\t\t/**\n\t\t * custom override to verify annotation toString() implementations.\n\t\t */\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"method: \" + name().toLowerCase();\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface RequestMapping {\n\n\t\tString name();\n\n\t\t@AliasFor(\"path\")\n\t\tString[] value() default \"\";\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tString[] path() default \"\";\n\n\t\tRequestMethod[] method() default {};\n\n\t\t// ---------------------------------------------------------------------\n\t\t// All remaining attributes declare default values that are used solely\n\t\t// for the purpose of testing the toString() implementations for annotations.\n\t\tClass<?> clazz() default RequestMethod.class;\n\t\tClass<?>[] classes() default {int[][].class, RequestMethod[].class};\n\n\t\tchar ch() default 'X';\n\t\tchar[] chars() default {'X'};\n\n\t\tbyte byteValue() default (byte) 0xFF;\n\t\tbyte[] bytes() default {(byte) 0xFF};\n\n\t\tshort shortValue() default 9876;\n\t\tshort[] shorts() default {9876};\n\n\t\tlong longValue() default 42L;\n\t\tlong[] longs() default {42L};\n\n\t\tfloat floatValue() default 3.14F;\n\t\tfloat[] floats() default {3.14F};\n\n\t\tdouble doubleValue() default 99.999D;\n\t\tdouble[] doubles() default {99.999D};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@RequestMapping(method = RequestMethod.GET, name = \"\")\n\t@interface GetMapping {\n\n\t\t@AliasFor(annotation = RequestMapping.class)\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = RequestMapping.class)\n\t\tString path() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@RequestMapping(method = RequestMethod.POST, name = \"\")\n\t@interface PostMapping {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = RequestMapping.class)\n\t\tString path() default \"\";\n\t}\n\n\t@Component(\"webController\")\n\tstatic class WebController {\n\n\t\t@RequestMapping(value = \"/test\", name = \"foo\")\n\t\tpublic void handleMappedWithValueAttribute() {\n\t\t}\n\n\t\t@RequestMapping(path = \"/test\", name = \"bar\", method = { RequestMethod.GET,\n\t\t\tRequestMethod.POST })\n\t\tpublic void handleMappedWithPathAttribute() {\n\t\t}\n\n\t\t@GetMapping(\"/test\")\n\t\tpublic void getMappedWithValueAttribute() {\n\t\t}\n\n\t\t@GetMapping(path = \"/test\")\n\t\tpublic void getMappedWithPathAttribute() {\n\t\t}\n\n\t\t@PostMapping(path = \"/test\")\n\t\tpublic void postMappedWithPathAttribute() {\n\t\t}\n\n\t\t@RequestMapping(value = \"/test\", path = \"/test\", name = \"bar\", method = {\n\t\t\tRequestMethod.GET, RequestMethod.POST })\n\t\tpublic void handleMappedWithSamePathAndValueAttributes() {\n\t\t}\n\n\t\t@RequestMapping(value = \"/enigma\", path = \"/test\", name = \"baz\")\n\t\tpublic void handleMappedWithDifferentPathAndValueAttributes() {\n\t\t}\n\t}\n\n\t/**\n\t * Mimics jakarta.persistence.Id\n\t */\n\t@Retention(RUNTIME)\n\t@interface Id {\n\t}\n\n\t/**\n\t * Mimics jakarta.persistence.GeneratedValue\n\t */\n\t@Retention(RUNTIME)\n\t@interface GeneratedValue {\n\t\tString strategy();\n\t}\n\n\t@Id\n\t@GeneratedValue(strategy = \"AUTO\")\n\tprivate Long getId() {\n\t\treturn 42L;\n\t}\n\n\t/**\n\t * Mimics org.springframework.security.config.annotation.authentication.configuration.EnableGlobalAuthentication\n\t */\n\t@Retention(RUNTIME)\n\t@interface EnableGlobalAuthentication {\n\t}\n\n\t/**\n\t * Mimics org.springframework.security.config.annotation.web.configuration.EnableWebSecurity\n\t */\n\t@Retention(RUNTIME)\n\t@EnableGlobalAuthentication\n\t@interface EnableWebSecurity {\n\t}\n\n\t@EnableWebSecurity\n\tstatic class SecurityConfig {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ ElementType.FIELD, ElementType.ANNOTATION_TYPE })\n\t@interface RootAnnotation {\n\t\tString value() default \"\";\n\t\tboolean flag() default false;\n\t}\n\n\t@RootAnnotation\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ ElementType.FIELD, ElementType.ANNOTATION_TYPE })\n\t@interface ComposedRootAnnotation {\n\n\t\t@AliasFor(annotation = RootAnnotation.class, attribute = \"flag\")\n\t\tboolean enabled() default true;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.FIELD)\n\t@ComposedRootAnnotation\n\t@interface DoublyComposedRootAnnotation {\n\t}\n\n\tclass DomainType {\n\n\t\t@RootAnnotation\n\t\tObject directlyAnnotated;\n\n\t\t@ComposedRootAnnotation\n\t\tObject metaAnnotated;\n\n\t\t@DoublyComposedRootAnnotation\n\t\tObject metaMetaAnnotated;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestConfiguration {\n\n\t\t@AliasFor(\"location\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString location() default \"\";\n\n\t\tClass<?> configClass() default Object.class;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Hierarchy {\n\n\t\tTestConfiguration[] value();\n\t}\n\n\t@Hierarchy({ @TestConfiguration(\"A\"), @TestConfiguration(location = \"B\") })\n\tstatic class HierarchyClass {\n\t}\n\n\t@TestConfiguration(\"simple.xml\")\n\tstatic class TestConfigurationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface CharsContainer {\n\n\t\t@AliasFor(attribute = \"chars\")\n\t\tchar[] value() default {};\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tchar[] chars() default {};\n\t}\n\n\t@CharsContainer(chars = { 'x', 'y', 'z' })\n\tstatic class GroupOfCharsClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMissingAttributeDeclaration {\n\n\t\t@AliasFor\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForWithMissingAttributeDeclaration\n\tstatic class AliasForWithMissingAttributeDeclarationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithDuplicateAttributeDeclaration {\n\n\t\t@AliasFor(value = \"bar\", attribute = \"baz\")\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForWithDuplicateAttributeDeclaration\n\tstatic class AliasForWithDuplicateAttributeDeclarationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForNonexistentAttribute {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForNonexistentAttribute\n\tstatic class AliasForNonexistentAttributeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithoutMirroredAliasFor {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"\";\n\n\t\tString bar() default \"\";\n\t}\n\n\t@AliasForWithoutMirroredAliasFor\n\tstatic class AliasForWithoutMirroredAliasForClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMirroredAliasForWrongAttribute {\n\n\t\t@AliasFor(attribute = \"bar\")\n\t\tString[] foo() default \"\";\n\n\t\t@AliasFor(attribute = \"quux\")\n\t\tString[] bar() default \"\";\n\t}\n\n\t@AliasForWithMirroredAliasForWrongAttribute\n\tstatic class AliasForWithMirroredAliasForWrongAttributeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForAttributeOfDifferentType {\n\n\t\t@AliasFor(\"bar\")\n\t\tString[] foo() default \"\";\n\n\t\t@AliasFor(\"foo\")\n\t\tboolean bar() default true;\n\t}\n\n\t@AliasForAttributeOfDifferentType\n\tstatic class AliasForAttributeOfDifferentTypeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMissingDefaultValues {\n\n\t\t@AliasFor(attribute = \"bar\")\n\t\tString foo();\n\n\t\t@AliasFor(attribute = \"foo\")\n\t\tString bar();\n\t}\n\n\t@AliasForWithMissingDefaultValues(foo = \"foo\", bar = \"bar\")\n\tstatic class AliasForWithMissingDefaultValuesClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForAttributeWithDifferentDefaultValue {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"X\";\n\n\t\t@AliasFor(\"foo\")\n\t\tString bar() default \"Z\";\n\t}\n\n\t@AliasForAttributeWithDifferentDefaultValue\n\tstatic class AliasForAttributeWithDifferentDefaultValueClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedTestConfigurationNotMetaPresent {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlConfigFile();\n\t}\n\n\t@AliasedComposedTestConfigurationNotMetaPresent(xmlConfigFile = \"test.xml\")\n\tstatic class AliasedComposedTestConfigurationNotMetaPresentClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlConfigFile();\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface ImplicitAliasesTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString groovyScript() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location1() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location2() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location3() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"configClass\")\n\t\tClass<?> configClass() default Object.class;\n\n\t\tString nonAliasedAttribute() default \"\";\n\t}\n\n\t@ImplicitAliasesTestConfiguration(groovyScript = \"groovyScript\")\n\tstatic class GroovyImplicitAliasesSimpleTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(xmlFile = \"xmlFile\")\n\tstatic class XmlImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(\"value\")\n\tstatic class ValueImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(location1 = \"location1\")\n\tstatic class Location1ImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(location2 = \"location2\")\n\tstatic class Location2ImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(location3 = \"location3\")\n\tstatic class Location3ImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class)\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class)\n\t\tString location() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration.class, attribute = \"location\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration(\"value\")\n\tstatic class ValueImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration(location = \"location\")\n\tstatic class LocationsImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration(xmlFile = \"xmlFile\")\n\tstatic class XmlFilesImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithMissingDefaultValuesTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location1();\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location2();\n\t}\n\n\t@ImplicitAliasesWithMissingDefaultValuesTestConfiguration(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithMissingDefaultValuesTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithDifferentDefaultValuesTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location1() default \"foo\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location2() default \"bar\";\n\t}\n\n\t@ImplicitAliasesWithDifferentDefaultValuesTestConfiguration(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithDifferentDefaultValuesTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithDuplicateValuesTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location1() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location2() default \"\";\n\t}\n\n\t@ImplicitAliasesWithDuplicateValuesTestConfiguration(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithDuplicateValuesTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesForAliasPairTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, value = \"value\")\n\t\tString groovyScript() default \"\";\n\t}\n\n\t@ImplicitAliasesForAliasPairTestConfiguration(xmlFile = \"test.xml\")\n\tstatic class ImplicitAliasesForAliasPairTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesTestConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesTestConfiguration.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesTestConfiguration.class, attribute = \"groovyScript\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@TransitiveImplicitAliasesTestConfiguration(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesForAliasPairTestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesForAliasPairTestConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesForAliasPairTestConfiguration.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesForAliasPairTestConfiguration.class, attribute = \"groovyScript\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@TransitiveImplicitAliasesForAliasPairTestConfiguration(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesForAliasPairTestConfigurationClass {\n\t}\n\n\t@ComponentScan(excludeFilters = { @Filter(pattern = \"*Foo\"),\n\t\t@Filter(pattern = \"*Bar\") })\n\tstatic class ComponentScanClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScanSingleFilter {\n\n\t\tFilter value();\n\t}\n\n\t@ComponentScanSingleFilter(@Filter(pattern = \"*Foo\"))\n\tstatic class ComponentScanSingleFilterClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnotationWithDefaults {\n\n\t\tString text() default \"enigma\";\n\n\t\tboolean predicate() default true;\n\n\t\tchar[] characters() default { 'a', 'b', 'c' };\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnotationWithoutDefaults {\n\n\t\tString text();\n\t}\n\n\t@TestConfiguration(value = \"foo\", location = \"bar\")\n\tinterface TestConfigurationMismatch {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface DefaultOverrideRoot {\n\n\t\tString text() default \"root\";\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideRoot\n\t@interface DefaultOverrideMeta {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideMeta\n\t@interface DefaultOverrideMetaMeta {\n\n\t\tString text() default \"metameta\";\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideMetaMeta\n\t@interface DefaultOverrideMetaMetaMeta {\n\n\t}\n\n\t@DefaultOverrideMetaMetaMeta\n\tstatic class DefaultOverrideClass {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideRoot\n\t@interface DefaultOverrideImplicitAlias {\n\n\t\t@AliasFor(annotation=DefaultOverrideRoot.class, attribute=\"text\")\n\t\tString text1() default \"alias\";\n\n\t\t@AliasFor(annotation=DefaultOverrideRoot.class, attribute=\"text\")\n\t\tString text2() default \"alias\";\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideImplicitAlias(text1=\"alias-meta-1\")\n\t@interface DefaultOverrideAliasImplicitMeta1 {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideImplicitAlias(text2=\"alias-meta-2\")\n\t@interface DefaultOverrideImplicitAliasMeta2 {\n\n\t}\n\n\t@DefaultOverrideAliasImplicitMeta1\n\tstatic class DefaultOverrideImplicitAliasMetaClass1 {\n\n\t}\n\n\t@DefaultOverrideImplicitAliasMeta2\n\tstatic class DefaultOverrideImplicitAliasMetaClass2 {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface DefaultOverrideExplicitAliasRoot {\n\n\t\t@AliasFor(\"value\")\n\t\tString text() default \"\";\n\n\t\t@AliasFor(\"text\")\n\t\tString value() default \"\";\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideExplicitAliasRoot(\"meta\")\n\t@interface DefaultOverrideExplicitAliasRootMeta {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideExplicitAliasRootMeta\n\t@interface DefaultOverrideExplicitAliasRootMetaMeta {\n\n\t}\n\n\t@DefaultOverrideExplicitAliasRootMetaMeta\n\tstatic class DefaultOverrideExplicitAliasRootMetaMetaClass {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ValueAttribute {\n\n\t\tString[] value();\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueAttribute(\"FromValueAttributeMeta\")\n\t@interface ValueAttributeMeta {\n\n\t\tString[] value() default {};\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueAttributeMeta(\"FromValueAttributeMetaMeta\")\n\t@interface ValueAttributeMetaMeta {\n\n\t}\n\n\t@ValueAttributeMetaMeta\n\tstatic class ValueAttributeMetaMetaClass {\n\n\t}\n\t// @formatter:on\n\n\tstatic void assertSynthesized(Annotation annotation) {\n\t\tassertThat(AnnotationUtils.isSynthesizedAnnotation(annotation)).as(\"synthesized annotation\").isTrue();\n\t}\n\n\tstatic void assertNotSynthesized(Annotation annotation) {\n\t\tassertThat(AnnotationUtils.isSynthesizedAnnotation(annotation)).as(\"synthesized annotation\").isFalse();\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.ImplicitAliasesContextConfigurationClass2",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.ImplicitAliasesContextConfigurationClass2",
    "headType": "class",
    "relation": "use",
    "tail": "@ImplicitAliasesContextConfiguration",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.ImplicitAliasesContextConfigurationClass2",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.stream.Stream;\n\nimport jakarta.annotation.Resource;\nimport org.jspecify.annotations.Nullable;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.AnnotationsScannerTests.Hello2Impl;\nimport org.springframework.core.annotation.AnnotationsScannerTests.TestAnnotation1;\nimport org.springframework.core.annotation.MergedAnnotation.Adapt;\nimport org.springframework.core.annotation.MergedAnnotations.Search;\nimport org.springframework.core.annotation.MergedAnnotations.SearchStrategy;\nimport org.springframework.core.annotation.subpackage.NonPublicAnnotatedClass;\nimport org.springframework.core.testfixture.ide.IdeUtils;\nimport org.springframework.core.testfixture.stereotype.Component;\nimport org.springframework.core.testfixture.stereotype.Indexed;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.MultiValueMap;\nimport org.springframework.util.ReflectionUtils;\n\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.assertj.core.api.Assertions.assertThatIllegalStateException;\nimport static org.assertj.core.api.Assertions.entry;\n\n/**\n * Tests for {@link MergedAnnotations} and {@link MergedAnnotation}. These tests\n * cover common usage scenarios and were mainly ported from the original\n * {@code AnnotationUtils} and {@code AnnotatedElementUtils} tests.\n *\n * @author Phillip Webb\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Chris Beams\n * @author Oleg Zhurakousky\n * @author Rossen Stoyanchev\n * @see MergedAnnotationsRepeatableAnnotationTests\n * @see MergedAnnotationClassLoaderTests\n */\nclass MergedAnnotationsTests {\n\n\t/**\n\t * Subset (and duplication) of other tests in {@link MergedAnnotationsTests}\n\t * that verify behavior of the fluent {@link Search} API.\n\t * @since 6.0\n\t */\n\t@Nested\n\tclass FluentSearchApiTests {\n\n\t\t@Test\n\t\tvoid preconditions() {\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> MergedAnnotations.search(null))\n\t\t\t\t\t.withMessage(\"SearchStrategy must not be null\");\n\n\t\t\tSearch search = MergedAnnotations.search(SearchStrategy.SUPERCLASS);\n\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> search.withEnclosingClasses(null))\n\t\t\t\t\t.withMessage(\"Predicate must not be null\");\n\t\t\tassertThatIllegalStateException()\n\t\t\t\t\t.isThrownBy(() -> search.withEnclosingClasses(Search.always))\n\t\t\t\t\t.withMessage(\"A custom 'searchEnclosingClass' predicate can only be combined with SearchStrategy.TYPE_HIERARCHY\");\n\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> search.withAnnotationFilter(null))\n\t\t\t\t\t.withMessage(\"AnnotationFilter must not be null\");\n\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> search.withRepeatableContainers(null))\n\t\t\t\t\t.withMessage(\"RepeatableContainers must not be null\");\n\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> search.from(null))\n\t\t\t\t\t.withMessage(\"AnnotatedElement must not be null\");\n\t\t}\n\n\t\t@Test\n\t\tvoid searchFromClassWithDefaultAnnotationFilterAndDefaultRepeatableContainers() {\n\t\t\tStream<Class<?>> classes = MergedAnnotations.search(SearchStrategy.DIRECT)\n\t\t\t\t\t.from(TransactionalComponent.class)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Transactional.class, Component.class, Indexed.class);\n\t\t}\n\n\t\t@Test\n\t\tvoid searchFromClassWithCustomAnnotationFilter() {\n\t\t\tStream<Class<?>> classes = MergedAnnotations.search(SearchStrategy.DIRECT)\n\t\t\t\t\t.withAnnotationFilter(annotationName -> annotationName.endsWith(\"Indexed\"))\n\t\t\t\t\t.from(TransactionalComponent.class)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Transactional.class, Component.class);\n\t\t}\n\n\t\t@Test\n\t\tvoid searchFromClassWithCustomRepeatableContainers() {\n\t\t\tassertThat(MergedAnnotations.from(HierarchyClass.class).stream(TestConfiguration.class)).isEmpty();\n\t\t\tRepeatableContainers containers = RepeatableContainers.of(TestConfiguration.class, Hierarchy.class);\n\n\t\t\tMergedAnnotations annotations = MergedAnnotations.search(SearchStrategy.DIRECT)\n\t\t\t\t\t.withRepeatableContainers(containers)\n\t\t\t\t\t.from(HierarchyClass.class);\n\t\t\tassertThat(annotations.stream(TestConfiguration.class))\n\t\t\t\t\t.map(annotation -> annotation.getString(\"location\"))\n\t\t\t\t\t.containsExactly(\"A\", \"B\");\n\t\t\tassertThat(annotations.stream(TestConfiguration.class))\n\t\t\t\t\t.map(annotation -> annotation.getString(\"value\"))\n\t\t\t\t\t.containsExactly(\"A\", \"B\");\n\t\t}\n\n\t\t/**\n\t\t * @since 6.0\n\t\t */\n\t\t@Test\n\t\tvoid searchFromNonAnnotatedInnerClassWithAnnotatedEnclosingClassWithEnclosingClassPredicates() {\n\t\t\tClass<?> testCase = AnnotatedClass.NonAnnotatedInnerClass.class;\n\t\t\tSearch search = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY);\n\n\t\t\tassertThat(search.from(testCase).stream()).isEmpty();\n\t\t\tassertThat(search.withEnclosingClasses(Search.never).from(testCase).stream()).isEmpty();\n\t\t\tassertThat(search.withEnclosingClasses(ClassUtils::isStaticClass).from(testCase).stream()).isEmpty();\n\n\t\t\tStream<Class<?>> classes = search.withEnclosingClasses(ClassUtils::isInnerClass)\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class, Indexed.class);\n\n\t\t\tclasses = search.withEnclosingClasses(Search.always)\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class, Indexed.class);\n\n\t\t\tclasses = search.withEnclosingClasses(ClassUtils::isInnerClass)\n\t\t\t\t\t.withRepeatableContainers(RepeatableContainers.none())\n\t\t\t\t\t.withAnnotationFilter(annotationName -> annotationName.endsWith(\"Indexed\"))\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class);\n\t\t}\n\n\t\t/**\n\t\t * @since 6.0\n\t\t */\n\t\t@Test\n\t\tvoid searchFromNonAnnotatedStaticNestedClassWithAnnotatedEnclosingClassWithEnclosingClassPredicates() {\n\t\t\tClass<?> testCase = AnnotatedClass.NonAnnotatedStaticNestedClass.class;\n\t\t\tSearch search = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY);\n\n\t\t\tassertThat(search.from(testCase).stream()).isEmpty();\n\t\t\tassertThat(search.withEnclosingClasses(Search.never).from(testCase).stream()).isEmpty();\n\t\t\tassertThat(search.withEnclosingClasses(ClassUtils::isInnerClass).from(testCase).stream()).isEmpty();\n\n\t\t\tStream<Class<?>> classes = search.withEnclosingClasses(ClassUtils::isStaticClass)\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class, Indexed.class);\n\n\t\t\tclasses = search.withEnclosingClasses(Search.always)\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class, Indexed.class);\n\t\t}\n\t}\n\n\n\t@Nested\n\tclass ConventionBasedAnnotationAttributeOverrideTests {\n\n\t\t@Test\n\t\tvoid getWithInheritedAnnotationsAttributesWithConventionBasedComposedAnnotation() {\n\t\t\tMergedAnnotation<?> annotation =\n\t\t\t\t\tMergedAnnotations.from(ConventionBasedComposedContextConfigurationClass.class,\n\t\t\t\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\t\tassertThat(annotation.isPresent()).isTrue();\n\t\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"explicitDeclaration\");\n\t\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"explicitDeclaration\");\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithInheritedAnnotationsFromHalfConventionBasedAndHalfAliasedComposedAnnotation1() {\n\t\t\t// SPR-13554: convention mapping mixed with AliasFor annotations\n\t\t\t// xmlConfigFiles can be used because it has an AliasFor annotation\n\t\t\tMergedAnnotation<?> annotation =\n\t\t\t\t\tMergedAnnotations.from(HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass1.class,\n\t\t\t\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"explicitDeclaration\");\n\t\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"explicitDeclaration\");\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithInheritedAnnotationsFromHalfConventionBasedAndHalfAliasedComposedAnnotation2() {\n\t\t\t// SPR-13554: convention mapping mixed with AliasFor annotations\n\t\t\t// locations doesn't apply because it has no AliasFor annotation\n\t\t\tMergedAnnotation<?> annotation =\n\t\t\t\t\tMergedAnnotations.from(HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass2.class,\n\t\t\t\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\t\tassertThat(annotation.getStringArray(\"locations\")).isEmpty();\n\t\t\tassertThat(annotation.getStringArray(\"value\")).isEmpty();\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithInheritedAnnotationsFromInvalidConventionBasedComposedAnnotation() {\n\t\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(InvalidConventionBasedComposedContextConfigurationClass.class,\n\t\t\t\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class));\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithTypeHierarchyWithSingleElementOverridingAnArrayViaConvention() {\n\t\t\ttestGetWithTypeHierarchy(ConventionBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithTypeHierarchyWithLocalAliasesThatConflictWithAttributesInMetaAnnotationByConvention() {\n\t\t\tMergedAnnotation<?> annotation =\n\t\t\t\t\tMergedAnnotations.from(SpringApplicationConfigurationClass.class, SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t\t\t\t.get(ContextConfiguration.class);\n\t\t\tassertThat(annotation.getStringArray(\"locations\")).isEmpty();\n\t\t\tassertThat(annotation.getStringArray(\"value\")).isEmpty();\n\t\t\tassertThat(annotation.getClassArray(\"classes\")).containsExactly(Number.class);\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithTypeHierarchyOnMethodWithSingleElementOverridingAnArrayViaConvention() throws Exception {\n\t\t\ttestGetWithTypeHierarchyWebMapping(WebController.class.getMethod(\"postMappedWithPathAttribute\"));\n\t\t}\n\t}\n\n\n\t@Test\n\tvoid fromPreconditions() {\n\t\tSearchStrategy strategy = SearchStrategy.DIRECT;\n\t\tRepeatableContainers containers = RepeatableContainers.standardRepeatables();\n\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(getClass(), strategy, null, AnnotationFilter.PLAIN))\n\t\t\t\t.withMessage(\"RepeatableContainers must not be null\");\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(getClass(), strategy, containers, null))\n\t\t\t\t.withMessage(\"AnnotationFilter must not be null\");\n\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(getClass(), new Annotation[0], null, AnnotationFilter.PLAIN))\n\t\t\t\t.withMessage(\"RepeatableContainers must not be null\");\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(getClass(), new Annotation[0], containers, null))\n\t\t\t\t.withMessage(\"AnnotationFilter must not be null\");\n\t}\n\n\t@Test\n\tvoid streamWhenFromNonAnnotatedClass() {\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class).stream(TransactionalComponent.class)).isEmpty();\n\t}\n\n\t@Test\n\tvoid streamWhenFromClassWithMetaDepth1() {\n\t\tStream<Class<?>> classes = MergedAnnotations.from(TransactionalComponent.class)\n\t\t\t\t.stream().map(MergedAnnotation::getType);\n\t\tassertThat(classes).containsExactly(Transactional.class, Component.class, Indexed.class);\n\t}\n\n\t@Test\n\tvoid streamWhenFromClassWithMetaDepth2() {\n\t\tStream<Class<?>> classes = MergedAnnotations.from(ComposedTransactionalComponent.class)\n\t\t\t\t.stream().map(MergedAnnotation::getType);\n\t\tassertThat(classes).containsExactly(TransactionalComponent.class,\n\t\t\t\tTransactional.class, Component.class, Indexed.class);\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromNonAnnotatedClass() {\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class).isPresent(Transactional.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromAnnotationClassWithMetaDepth0() {\n\t\tassertThat(MergedAnnotations.from(TransactionalComponent.class).isPresent(TransactionalComponent.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromAnnotationClassWithMetaDepth1() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(TransactionalComponent.class);\n\t\tassertThat(annotations.isPresent(Transactional.class)).isTrue();\n\t\tassertThat(annotations.isPresent(Component.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromAnnotationClassWithMetaDepth2() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponent.class);\n\t\tassertThat(annotations.isPresent(Transactional.class)).isTrue();\n\t\tassertThat(annotations.isPresent(Component.class)).isTrue();\n\t\tassertThat(annotations.isPresent(ComposedTransactionalComponent.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromClassWithMetaDepth0() {\n\t\tassertThat(MergedAnnotations.from(TransactionalComponentClass.class).isPresent(TransactionalComponent.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromSubclassWithMetaDepth0() {\n\t\tassertThat(MergedAnnotations.from(SubTransactionalComponentClass.class).isPresent(TransactionalComponent.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromClassWithMetaDepth1() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(TransactionalComponentClass.class);\n\t\tassertThat(annotations.isPresent(Transactional.class)).isTrue();\n\t\tassertThat(annotations.isPresent(Component.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromClassWithMetaDepth2() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\n\t\tassertThat(annotations.isPresent(Transactional.class)).isTrue();\n\t\tassertThat(annotations.isPresent(Component.class)).isTrue();\n\t\tassertThat(annotations.isPresent(ComposedTransactionalComponent.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid getParent() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\n\t\tassertThat(annotations.get(TransactionalComponent.class).getMetaSource().getType())\n\t\t\t\t.isEqualTo(ComposedTransactionalComponent.class);\n\t}\n\n\t@Test\n\tvoid getRootWhenNotDirect() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\n\t\tMergedAnnotation<?> annotation = annotations.get(TransactionalComponent.class);\n\t\tassertThat(annotation.getDistance()).isGreaterThan(0);\n\t\tassertThat(annotation.getRoot().getType()).isEqualTo(ComposedTransactionalComponent.class);\n\t}\n\n\t@Test\n\tvoid getRootWhenDirect() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\n\t\tMergedAnnotation<?> annotation = annotations.get(ComposedTransactionalComponent.class);\n\t\tassertThat(annotation.getDistance()).isEqualTo(0);\n\t\tassertThat(annotation.getRoot()).isSameAs(annotation);\n\t}\n\n\t@Test\n\tvoid getMetaTypes() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(ComposedTransactionalComponentClass.class)\n\t\t\t\t.get(TransactionalComponent.class);\n\t\tassertThat(annotation.getMetaTypes()).containsExactly(\n\t\t\t\tComposedTransactionalComponent.class, TransactionalComponent.class);\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFromNonAnnotatedClass() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(NonAnnotatedClass.class)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).isEmpty();\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFromClassWithLocalAnnotation() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(TxConfig.class)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"value\", List.of(\"TxConfig\")));\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFromClassWithLocalComposedAnnotationAndInheritedAnnotation() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"qualifier\", List.of(\"composed2\", \"transactionManager\")));\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"qualifier\", List.of(\"transactionManager\")));\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedComposedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"qualifier\", List.of(\"composed1\")));\n\t}\n\n\t/**\n\t * If the \"value\" entry contains both \"DerivedTxConfig\" AND \"TxConfig\", then\n\t * the algorithm is accidentally picking up shadowed annotations of the same\n\t * type within the class hierarchy. Such undesirable behavior would cause\n\t * the logic in\n\t * {@code org.springframework.context.annotation.ProfileCondition} to fail.\n\t */\n\t@Test\n\tvoid collectMultiValueMapFromClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tDerivedTxConfig.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"value\", List.of(\"DerivedTxConfig\")));\n\t}\n\n\t/**\n\t * Note: this functionality is required by\n\t * {@code org.springframework.context.annotation.ProfileCondition}.\n\t */\n\t@Test\n\tvoid collectMultiValueMapFromClassWithMultipleComposedAnnotations() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tTxFromMultipleComposedAnnotations.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"value\", List.of(\"TxInheritedComposed\", \"TxComposed\")));\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromClassWithLocalAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tTxConfig.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"TxConfig\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tDerivedTxConfig.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"DerivedTxConfig\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaCycleAnnotatedClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isFalse();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFavorsLocalComposedAnnotationOverInheritedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getBoolean(\"readOnly\")).isTrue();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getBoolean(\"readOnly\")).isFalse();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedComposedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getBoolean(\"readOnly\")).isFalse();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromInterfaceImplementedBySuperclass() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tConcreteClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isFalse();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tInheritedAnnotationInterface.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationInterface.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t}\n\n\n\t@Test\n\tvoid withInheritedAnnotationsFromAliasedComposedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tAliasedComposedContextConfigurationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"test.xml\");\n\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid withInheritedAnnotationsFromAliasedValueComposedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tAliasedValueComposedContextConfigurationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"test.xml\");\n\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromImplicitAliasesInMetaAnnotationOnComposedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tComposedImplicitAliasesContextConfigurationClass.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.get(ImplicitAliasesContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"groovyScripts\")).containsExactly(\"A.xml\", \"B.xml\");\n\t\tassertThat(annotation.getStringArray(\"xmlFiles\")).containsExactly(\"A.xml\", \"B.xml\");\n\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"A.xml\", \"B.xml\");\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"A.xml\", \"B.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromAliasedValueComposedAnnotation() {\n\t\ttestGetWithInherited(AliasedValueComposedContextConfigurationClass.class, \"test.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromImplicitAliasesForSameAttributeInComposedAnnotation() {\n\t\ttestGetWithInherited(ImplicitAliasesContextConfigurationClass1.class, \"foo.xml\");\n\t\ttestGetWithInherited(ImplicitAliasesContextConfigurationClass2.class, \"bar.xml\");\n\t\ttestGetWithInherited(ImplicitAliasesContextConfigurationClass3.class, \"baz.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromTransitiveImplicitAliases() {\n\t\ttestGetWithInherited(TransitiveImplicitAliasesContextConfigurationClass.class, \"test.groovy\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\ttestGetWithInherited(\n\t\t\t\tSingleLocationTransitiveImplicitAliasesContextConfigurationClass.class, \"test.groovy\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSkippedLevel() {\n\t\ttestGetWithInherited(\n\t\t\t\tTransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass.class, \"test.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSkippedLevelWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\ttestGetWithInherited(\n\t\t\t\tSingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass.class, \"test.xml\");\n\t}\n\n\tprivate void testGetWithInherited(Class<?> element, String... expected) {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(element, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.get(ContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"locations\")).isEqualTo(expected);\n\t\tassertThat(annotation.getStringArray(\"value\")).isEqualTo(expected);\n\t\tassertThat(annotation.getClassArray(\"classes\")).isEmpty();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromShadowedAliasComposedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tShadowedAliasComposedContextConfigurationClass.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.get(ContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"test.xml\");\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromSubInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromSubSubInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromSubNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromSubSubNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyInheritedFromInterfaceMethod() throws Exception {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleFromInterface\");\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test  // gh-31803\n\tvoid streamWithTypeHierarchyInheritedFromSuperInterfaceMethod() throws Exception {\n\t\tMethod method = Hello2Impl.class.getMethod(\"method\");\n\t\tlong count = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.from(method).stream(TestAnnotation1.class).count();\n\t\tassertThat(count).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyInheritedFromAbstractMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handle\");\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyInheritedFromBridgedMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleParameterized\", String.class);\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromBridgeMethod() {\n\t\tList<Method> methods = new ArrayList<>();\n\t\tReflectionUtils.doWithLocalMethods(StringGenericParameter.class, method -> {\n\t\t\tif (\"getFor\".equals(method.getName())) {\n\t\t\t\tmethods.add(method);\n\t\t\t}\n\t\t});\n\t\tMethod bridgeMethod = methods.get(0).getReturnType().equals(Object.class) ?\n\t\t\t\tmethods.get(0) : methods.get(1);\n\t\tMethod bridgedMethod = methods.get(0).getReturnType().equals(Object.class) ?\n\t\t\t\tmethods.get(1) : methods.get(0);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(bridgeMethod,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromClassWithMetaAndLocalTxConfig() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaAndLocalTxConfigClass.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getString(\"qualifier\")).isEqualTo(\"localTxMgr\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromClassWithAttributeAliasesInTargetAnnotation() {\n\t\tMergedAnnotation<AliasedTransactional> mergedAnnotation = MergedAnnotations.from(\n\t\t\t\tAliasedTransactionalComponentClass.class, SearchStrategy.TYPE_HIERARCHY).get(AliasedTransactional.class);\n\t\tAliasedTransactional synthesizedAnnotation = mergedAnnotation.synthesize();\n\t\tString qualifier = \"aliasForQualifier\";\n\t\tassertThat(mergedAnnotation.getString(\"value\")).isEqualTo(qualifier);\n\t\tassertThat(mergedAnnotation.getString(\"qualifier\")).isEqualTo(qualifier);\n\t\tassertThat(synthesizedAnnotation.value()).isEqualTo(qualifier);\n\t\tassertThat(synthesizedAnnotation.qualifier()).isEqualTo(qualifier);\n\t}\n\n\t@Test // gh-23767\n\tvoid getWithTypeHierarchyFromClassWithComposedMetaTransactionalAnnotation() {\n\t\tMergedAnnotation<AliasedTransactional> mergedAnnotation = MergedAnnotations.from(\n\t\t\t\tComposedTransactionalClass.class, SearchStrategy.TYPE_HIERARCHY).get(AliasedTransactional.class);\n\t\tassertThat(mergedAnnotation.getString(\"value\")).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(mergedAnnotation.getString(\"qualifier\")).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t@Test // gh-23767\n\tvoid getWithTypeHierarchyFromClassWithMetaMetaAliasedTransactional() {\n\t\tMergedAnnotation<AliasedTransactional> mergedAnnotation = MergedAnnotations.from(\n\t\t\t\tMetaMetaAliasedTransactionalClass.class, SearchStrategy.TYPE_HIERARCHY).get(AliasedTransactional.class);\n\t\tassertThat(mergedAnnotation.getString(\"value\")).isEqualTo(\"meta\");\n\t\tassertThat(mergedAnnotation.getString(\"qualifier\")).isEqualTo(\"meta\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromClassWithAttributeAliasInComposedAnnotationAndNestedAnnotationsInTargetAnnotation() {\n\t\tMergedAnnotation<?> annotation = testGetWithTypeHierarchy(\n\t\t\t\tTestComponentScanClass.class, \"com.example.app.test\");\n\t\tMergedAnnotation<Filter>[] excludeFilters = annotation.getAnnotationArray(\n\t\t\t\t\"excludeFilters\", Filter.class);\n\t\tassertThat(Arrays.stream(excludeFilters).map(\n\t\t\t\tfilter -> filter.getString(\"pattern\"))).containsExactly(\"*Test\", \"*Tests\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromClassWithBothAttributesOfAnAliasPairDeclared() {\n\t\ttestGetWithTypeHierarchy(ComponentScanWithBasePackagesAndValueAliasClass.class, \"com.example.app.test\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\ttestGetWithTypeHierarchy(AliasForBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\n\t}\n\n\tprivate MergedAnnotation<?> testGetWithTypeHierarchy(Class<?> element, String... expected) {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(element,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(ComponentScan.class);\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(expected);\n\t\tassertThat(annotation.getStringArray(\"basePackages\")).containsExactly(expected);\n\t\treturn annotation;\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyWhenMultipleMetaAnnotationsHaveClashingAttributeNames() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tAliasedComposedContextConfigurationAndTestPropertySourceClass.class, SearchStrategy.TYPE_HIERARCHY);\n\t\tMergedAnnotation<?> contextConfig = annotations.get(ContextConfiguration.class);\n\t\tassertThat(contextConfig.getStringArray(\"locations\")).containsExactly(\"test.xml\");\n\t\tassertThat(contextConfig.getStringArray(\"value\")).containsExactly(\"test.xml\");\n\t\tMergedAnnotation<?> testPropSource = annotations.get(TestPropertySource.class);\n\t\tassertThat(testPropSource.getStringArray(\"locations\")).containsExactly(\"test.properties\");\n\t\tassertThat(testPropSource.getStringArray(\"value\")).containsExactly(\"test.properties\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyOnMethodWithSingleElementOverridingAnArrayViaAliasFor() throws Exception {\n\t\ttestGetWithTypeHierarchyWebMapping(WebController.class.getMethod(\"getMappedWithValueAttribute\"));\n\t\ttestGetWithTypeHierarchyWebMapping(WebController.class.getMethod(\"getMappedWithPathAttribute\"));\n\t}\n\n\tprivate void testGetWithTypeHierarchyWebMapping(AnnotatedElement element) {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.get(RequestMapping.class);\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"/test\");\n\t\tassertThat(annotation.getStringArray(\"path\")).containsExactly(\"/test\");\n\t}\n\n\t@Test\n\tvoid getDirectWithJavaxAnnotationType() {\n\t\tassertThat(MergedAnnotations.from(ResourceHolder.class).get(Resource.class)\n\t\t\t\t.getString(\"name\")).isEqualTo(\"x\");\n\t}\n\n\t@Test\n\tvoid streamInheritedFromClassWithInterface() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class)).isEmpty();\n\t}\n\n\t@Test\n\tvoid streamTypeHierarchyFromClassWithInterface() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.stream(Transactional.class)).hasSize(1);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithMethodAnnotationOnLeaf() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"annotatedOnLeaf\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNotNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class)\n\t\t\t\t.getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithAnnotationOnMethodInInterface() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"fromInterfaceImplementedByRoot\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class)\n\t\t\t\t.getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithMetaAnnotationOnLeaf() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"metaAnnotatedOnLeaf\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class)\n\t\t\t\t.getDistance()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithMetaMetaAnnotationOnLeaf() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"metaMetaAnnotatedOnLeaf\");\n\t\tassertThat(method.getAnnotation(Component.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Component.class).getDistance()).isEqualTo(2);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tComponent.class).getDistance()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getWithAnnotationOnRoot() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"annotatedOnRoot\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNotNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithMetaAnnotationOnRoot() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"metaAnnotatedOnRoot\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithOnRootButOverridden() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"overrideWithoutNewAnnotation\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithNotAnnotated() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"notAnnotated\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(-1);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithBridgeMethod() throws Exception {\n\t\tMethod method = TransactionalStringGeneric.class.getMethod(\"something\", Object.class);\n\t\tassertThat(method.isBridge()).isTrue();\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t\t// As of JDK 8, invoking getAnnotation() on a bridge method actually finds an\n\t\t// annotation on its 'bridged' method [1]; however, the Eclipse compiler does\n\t\t// not support this [2]. Thus, we effectively ignore the following\n\t\t// assertion if the test is currently executing within the Eclipse IDE.\n\t\t//\n\t\t// [1] https://bugs.openjdk.java.net/browse/JDK-6695379\n\t\t// [2] https://bugs.eclipse.org/bugs/show_bug.cgi?id=495396\n\t\t//\n\t\tif (!IdeUtils.runningInEclipse()) {\n\t\t\tassertThat(method.getAnnotation(Transactional.class)).isNotNull();\n\t\t}\n\t\tassertThat(MergedAnnotations.from(method).get(\n\t\t\t\tTransactional.class).getDistance()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tTransactional.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithBridgedMethod() throws Exception {\n\t\tMethod method = TransactionalStringGeneric.class.getMethod(\"something\", String.class);\n\t\tassertThat(method.isBridge()).isFalse();\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t\tassertThat(method.getAnnotation(Transactional.class)).isNotNull();\n\t\tassertThat(MergedAnnotations.from(method).get(\n\t\t\t\tTransactional.class).getDistance()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tTransactional.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test // SPR-16060\n\tvoid getFromMethodWithGenericInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test // SPR-17146\n\tvoid getFromMethodWithGenericSuperclass() throws Exception {\n\t\tMethod method = ExtendsBaseClassWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithInterfaceOnSuper() throws Exception {\n\t\tMethod method = SubOfImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWhenInterfaceWhenSuperDoesNotImplementMethod() throws Exception {\n\t\tMethod method = SubOfAbstractImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverAnnotationsOnInterfaces() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tClassWithLocalMetaAnnotationAndMetaAnnotatedInterface.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedAnnotation.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getBoolean(\"readOnly\")).isTrue();\n\t}\n\n\t@Test\n\tvoid getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedComposedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedMetaAnnotation.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid getDirectFromClassgetDirectFromClassMetaMetaAnnotatedClass() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaMetaAnnotatedClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithMetaMetaMetaAnnotatedClass() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaMetaMetaAnnotatedClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\t// TransactionalClass is NOT annotated or meta-annotated with @Component\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(TransactionalClass.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.isPresent()).isFalse();\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaCycleAnnotatedClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.isPresent()).isFalse();\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithSubInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithSubSubInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithSubNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithSubSubNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubNonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getSuperClassForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isNull();\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isNull();\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isEqualTo(\n\t\t\t\t\t\t\t\tInheritedAnnotationInterface.class);\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isNull();\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isEqualTo(\n\t\t\t\t\t\t\t\tInheritedAnnotationClass.class);\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isEqualTo(\n\t\t\t\t\t\t\t\tInheritedAnnotationClass.class);\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but we should still find it on classes.\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(Order.class).getSource()).isEqualTo(\n\t\t\t\t\t\tNonInheritedAnnotationInterface.class);\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(Order.class).getSource()).isNull();\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(Order.class).getSource()).isEqualTo(\n\t\t\t\t\t\tNonInheritedAnnotationClass.class);\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(Order.class).getSource()).isEqualTo(\n\t\t\t\t\t\tNonInheritedAnnotationClass.class);\n\t}\n\n\t@Test\n\tvoid getSuperClassSourceForTypesWithSingleCandidateType() {\n\t\t// no class-level annotation\n\t\tList<Class<? extends Annotation>> transactionalCandidateList = Collections.singletonList(Transactional.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonAnnotatedInterface.class,\n\t\t\t\ttransactionalCandidateList)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonAnnotatedClass.class,\n\t\t\t\ttransactionalCandidateList)).isNull();\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationInterface.class,\n\t\t\t\ttransactionalCandidateList)).isEqualTo(\n\t\t\t\t\t\tInheritedAnnotationInterface.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationInterface.class,\n\t\t\t\ttransactionalCandidateList)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationClass.class,\n\t\t\t\ttransactionalCandidateList)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationClass.class,\n\t\t\t\ttransactionalCandidateList)).isEqualTo(InheritedAnnotationClass.class);\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but should still find it on classes.\n\t\tList<Class<? extends Annotation>> orderCandidateList = Collections.singletonList(\n\t\t\t\tOrder.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationInterface.class,\n\t\t\t\torderCandidateList)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationInterface.class,\n\t\t\t\torderCandidateList)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationClass.class,\n\t\t\t\torderCandidateList)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationClass.class,\n\t\t\t\torderCandidateList)).isEqualTo(NonInheritedAnnotationClass.class);\n\t}\n\n\t@Test\n\tvoid getSuperClassSourceForTypesWithMultipleCandidateTypes() {\n\t\tList<Class<? extends Annotation>> candidates = List.of(Transactional.class, Order.class);\n\t\t// no class-level annotation\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonAnnotatedInterface.class,\n\t\t\t\tcandidates)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonAnnotatedClass.class,\n\t\t\t\tcandidates)).isNull();\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationInterface.class,\n\t\t\t\tcandidates)).isEqualTo(InheritedAnnotationInterface.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationInterface.class,\n\t\t\t\tcandidates)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationClass.class,\n\t\t\t\tcandidates)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationClass.class,\n\t\t\t\tcandidates)).isEqualTo(InheritedAnnotationClass.class);\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but findAnnotationDeclaringClassForTypes() should still find it on\n\t\t// classes.\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationInterface.class,\n\t\t\t\tcandidates)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationInterface.class,\n\t\t\t\tcandidates)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationClass.class,\n\t\t\t\tcandidates)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationClass.class,\n\t\t\t\tcandidates)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\t// class hierarchy mixed with @Transactional and @Order declarations\n\t\tassertThat(getSuperClassSourceWithTypeIn(TransactionalClass.class,\n\t\t\t\tcandidates)).isEqualTo(TransactionalClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(TransactionalAndOrderedClass.class,\n\t\t\t\tcandidates)).isEqualTo(TransactionalAndOrderedClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubTransactionalAndOrderedClass.class,\n\t\t\t\tcandidates)).isEqualTo(TransactionalAndOrderedClass.class);\n\t}\n\n\tprivate Object getSuperClassSourceWithTypeIn(Class<?> clazz, List<Class<? extends Annotation>> annotationTypes) {\n\t\treturn MergedAnnotations.from(clazz, SearchStrategy.SUPERCLASS).stream().filter(\n\t\t\t\tMergedAnnotationPredicates.typeIn(annotationTypes).and(\n\t\t\t\t\t\tMergedAnnotation::isDirectlyPresent)).map(\n\t\t\t\t\t\t\t\tMergedAnnotation::getSource).findFirst().orElse(null);\n\t}\n\n\t@Test\n\tvoid isDirectlyPresentForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedInterface.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedInterface.class).isDirectlyPresent(\n\t\t\t\tTransactional.class)).isFalse();\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class).isDirectlyPresent(\n\t\t\t\tTransactional.class)).isFalse();\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationInterface.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isTrue();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tInheritedAnnotationInterface.class).isDirectlyPresent(\n\t\t\t\t\t\tTransactional.class)).isTrue();\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tSubInheritedAnnotationInterface.class).isDirectlyPresent(\n\t\t\t\t\t\tTransactional.class)).isFalse();\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationClass.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isTrue();\n\t\tassertThat(\n\t\t\t\tMergedAnnotations.from(InheritedAnnotationClass.class).isDirectlyPresent(\n\t\t\t\t\t\tTransactional.class)).isTrue();\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tSubInheritedAnnotationClass.class).isDirectlyPresent(\n\t\t\t\t\t\tTransactional.class)).isFalse();\n\t\t// non-inherited class-level annotation; note: @Order is not inherited\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class).get(\n\t\t\t\tOrder.class).isDirectlyPresent()).isTrue();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationInterface.class).isDirectlyPresent(\n\t\t\t\t\t\tOrder.class)).isTrue();\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class).get(\n\t\t\t\tOrder.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tSubNonInheritedAnnotationInterface.class).isDirectlyPresent(\n\t\t\t\t\t\tOrder.class)).isFalse();\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class).get(\n\t\t\t\tOrder.class).isDirectlyPresent()).isTrue();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationClass.class).isDirectlyPresent(\n\t\t\t\t\t\tOrder.class)).isTrue();\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class).get(\n\t\t\t\tOrder.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tSubNonInheritedAnnotationClass.class).isDirectlyPresent(\n\t\t\t\t\t\tOrder.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid getAggregateIndexForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(-1);\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(0);\n\t\t// Since we're not traversing interface hierarchies the following,\n\t\t// though perhaps counterintuitive, must be false:\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(1);\n\t\t// non-inherited class-level annotation; note: @Order is not inherited\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tOrder.class).getAggregateIndex()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tOrder.class).getAggregateIndex()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tOrder.class).getAggregateIndex()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tOrder.class).getAggregateIndex()).isEqualTo(-1);\n\t}\n\n\t@Test\n\tvoid getDirectWithoutAttributeAliases() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(WebController.class).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"webController\");\n\t}\n\n\t@Test\n\tvoid getDirectWithNestedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(ComponentScanClass.class).get(ComponentScan.class);\n\t\tMergedAnnotation<Filter>[] filters = annotation.getAnnotationArray(\"excludeFilters\", Filter.class);\n\t\tassertThat(Arrays.stream(filters).map(\n\t\t\t\tfilter -> filter.getString(\"pattern\"))).containsExactly(\"*Foo\", \"*Bar\");\n\t}\n\n\t@Test\n\tvoid getDirectWithAttributeAliases1() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method).get(RequestMapping.class);\n\t\tassertThat(annotation.getString(\"name\")).isEqualTo(\"foo\");\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"/test\");\n\t\tassertThat(annotation.getStringArray(\"path\")).containsExactly(\"/test\");\n\t}\n\n\t@Test\n\tvoid getDirectWithAttributeAliases2() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method).get(RequestMapping.class);\n\t\tassertThat(annotation.getString(\"name\")).isEqualTo(\"bar\");\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"/test\");\n\t\tassertThat(annotation.getStringArray(\"path\")).containsExactly(\"/test\");\n\t}\n\n\t@Test\n\tvoid getDirectWithAttributeAliasesWithDifferentValues() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithDifferentPathAndValueAttributes\");\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tMergedAnnotations.from(method).get(RequestMapping.class))\n\t\t\t\t.withMessageContaining(\"attribute 'path' and its alias 'value'\")\n\t\t\t\t.withMessageContaining(\"values of [{/test}] and [{/enigma}]\");\n\t}\n\n\t@Test\n\tvoid getValueFromAnnotation() throws Exception {\n\t\tMethod method = TransactionalStringGeneric.class.getMethod(\"something\", Object.class);\n\t\tMergedAnnotation<?> annotation =\n\t\t\t\tMergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getInt(\"value\")).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getValueFromNonPublicAnnotation() {\n\t\tAnnotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\n\t\tassertThat(declaredAnnotations).hasSize(1);\n\t\tAnnotation annotation = declaredAnnotations[0];\n\t\tMergedAnnotation<Annotation> mergedAnnotation = MergedAnnotation.from(annotation);\n\t\tassertThat(mergedAnnotation.getType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\n\t\tassertThat(mergedAnnotation.synthesize().annotationType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\n\t\tassertThat(mergedAnnotation.getInt(\"value\")).isEqualTo(42);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromAnnotation() throws Exception {\n\t\tMethod method = TransactionalStringGeneric.class.getMethod(\"something\", Object.class);\n\t\tMergedAnnotation<Order> annotation =\n\t\t\t\tMergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getDefaultValue(\"value\")).contains(Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromNonPublicAnnotation() {\n\t\tAnnotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\n\t\tassertThat(declaredAnnotations).hasSize(1);\n\t\tAnnotation declaredAnnotation = declaredAnnotations[0];\n\t\tMergedAnnotation<?> annotation = MergedAnnotation.from(declaredAnnotation);\n\t\tassertThat(annotation.getType().getName()).isEqualTo(\n\t\t\t\t\"org.springframework.core.annotation.subpackage.NonPublicAnnotation\");\n\t\tassertThat(annotation.getDefaultValue(\"value\")).contains(-1);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromAnnotationType() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotation.of(Order.class);\n\t\tassertThat(annotation.getDefaultValue(\"value\")).contains(Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnMethod() throws Exception {\n\t\tMethod method = InterfaceWithRepeated.class.getMethod(\"foo\");\n\t\tStream<MergedAnnotation<MyRepeatable>> annotations = MergedAnnotations.from(\n\t\t\t\tmethod, SearchStrategy.TYPE_HIERARCHY).stream(MyRepeatable.class);\n\t\tStream<String> values = annotations.map(\n\t\t\t\tannotation -> annotation.getString(\"value\"));\n\t\tassertThat(values).containsExactly(\"A\", \"B\", \"C\", \"meta1\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid streamRepeatableDeclaredOnClassWithAttributeAliases() {\n\t\tassertThat(MergedAnnotations.from(HierarchyClass.class).stream(\n\t\t\t\tTestConfiguration.class)).isEmpty();\n\t\tRepeatableContainers containers = RepeatableContainers.of(TestConfiguration.class,\n\t\t\t\tHierarchy.class);\n\t\tMergedAnnotations annotations = MergedAnnotations.from(HierarchyClass.class,\n\t\t\t\tSearchStrategy.DIRECT, containers, AnnotationFilter.NONE);\n\t\tassertThat(annotations.stream(TestConfiguration.class).map(\n\t\t\t\tannotation -> annotation.getString(\"location\"))).containsExactly(\"A\", \"B\");\n\t\tassertThat(annotations.stream(TestConfiguration.class).map(\n\t\t\t\tannotation -> annotation.getString(\"value\"))).containsExactly(\"A\", \"B\");\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnClass() {\n\t\tClass<?> element = MyRepeatableClass.class;\n\t\tString[] expectedValuesJava = { \"A\", \"B\", \"C\" };\n\t\tString[] expectedValuesSpring = { \"A\", \"B\", \"C\", \"meta1\" };\n\t\ttestRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnSuperclass() {\n\t\tClass<?> element = SubMyRepeatableClass.class;\n\t\tString[] expectedValuesJava = { \"A\", \"B\", \"C\" };\n\t\tString[] expectedValuesSpring = { \"A\", \"B\", \"C\", \"meta1\" };\n\t\ttestRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnClassAndSuperclass() {\n\t\tClass<?> element = SubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\n\t\tString[] expectedValuesJava = { \"X\", \"Y\", \"Z\" };\n\t\tString[] expectedValuesSpring = { \"X\", \"Y\", \"Z\", \"meta2\" };\n\t\ttestRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnMultipleSuperclasses() {\n\t\tClass<?> element = SubSubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\n\t\tString[] expectedValuesJava = { \"X\", \"Y\", \"Z\" };\n\t\tString[] expectedValuesSpring = { \"X\", \"Y\", \"Z\", \"meta2\" };\n\t\ttestRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamDirectRepeatablesDeclaredOnClass() {\n\t\tClass<?> element = MyRepeatableClass.class;\n\t\tString[] expectedValuesJava = { \"A\", \"B\", \"C\" };\n\t\tString[] expectedValuesSpring = { \"A\", \"B\", \"C\", \"meta1\" };\n\t\ttestRepeatables(SearchStrategy.DIRECT, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamDirectRepeatablesDeclaredOnSuperclass() {\n\t\tClass<?> element = SubMyRepeatableClass.class;\n\t\tString[] expectedValuesJava = {};\n\t\tString[] expectedValuesSpring = {};\n\t\ttestRepeatables(SearchStrategy.DIRECT, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\tprivate void testRepeatables(SearchStrategy searchStrategy, Class<?> element,\n\t\t\tString[] expectedValuesJava, String[] expectedValuesSpring) {\n\n\t\ttestJavaRepeatables(searchStrategy, element, expectedValuesJava);\n\t\ttestExplicitRepeatables(searchStrategy, element, expectedValuesSpring);\n\t\ttestStandardRepeatables(searchStrategy, element, expectedValuesSpring);\n\t}\n\n\tprivate void testJavaRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expected) {\n\t\tMyRepeatable[] annotations = searchStrategy == SearchStrategy.DIRECT ?\n\t\t\t\telement.getDeclaredAnnotationsByType(MyRepeatable.class) :\n\t\t\t\telement.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(Arrays.stream(annotations).map(MyRepeatable::value)).containsExactly(\n\t\t\t\texpected);\n\t}\n\n\tprivate void testExplicitRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expected) {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(element, searchStrategy,\n\t\t\t\tRepeatableContainers.of(MyRepeatable.class, MyRepeatableContainer.class),\n\t\t\t\tAnnotationFilter.PLAIN);\n\t\tStream<String> values = annotations.stream(MyRepeatable.class)\n\t\t\t\t.filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex))\n\t\t\t\t.map(annotation -> annotation.getString(\"value\"));\n\t\tassertThat(values).containsExactly(expected);\n\t}\n\n\tprivate void testStandardRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expected) {\n\t\tStream<String> values = MergedAnnotations.from(element, searchStrategy).stream(MyRepeatable.class)\n\t\t\t\t.filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex))\n\t\t\t\t.map(annotation -> annotation.getString(\"value\"));\n\t\tassertThat(values).containsExactly(expected);\n\t}\n\n\t@Test\n\tvoid synthesizeWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tComponent synthesizedComponent = MergedAnnotation.from(component).synthesize();\n\t\tassertThat(synthesizedComponent).isNotNull();\n\t\tassertThat(synthesizedComponent).isEqualTo(component);\n\t\tassertThat(synthesizedComponent.value()).isEqualTo(\"webController\");\n\t}\n\n\t/**\n\t * @since 6.0\n\t */\n\t@Test\n\tvoid synthesizedAnnotationShouldReuseJdkProxyClass() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\n\t\tRequestMapping jdkRequestMapping = method.getAnnotation(RequestMapping.class);\n\t\tassertThat(jdkRequestMapping).isNotNull();\n\t\tassertThat(jdkRequestMapping.value()).containsExactly(\"/test\");\n\t\tassertThat(jdkRequestMapping.path()).containsExactly(\"\");\n\n\t\tRequestMapping synthesizedRequestMapping = MergedAnnotation.from(jdkRequestMapping).synthesize();\n\t\tassertSynthesized(synthesizedRequestMapping);\n\t\tassertThat(synthesizedRequestMapping.value()).containsExactly(\"/test\");\n\t\tassertThat(synthesizedRequestMapping.path()).containsExactly(\"/test\");\n\n\t\tassertThat(jdkRequestMapping.getClass()).isSameAs(synthesizedRequestMapping.getClass());\n\t}\n\n\t@Test\n\tvoid synthesizeAlreadySynthesized() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\t\tRequestMapping webMapping = method.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMapping).isNotNull();\n\n\t\tRequestMapping synthesizedWebMapping = MergedAnnotation.from(webMapping).synthesize();\n\t\tRequestMapping synthesizedAgainWebMapping = MergedAnnotation.from(synthesizedWebMapping).synthesize();\n\n\t\tassertSynthesized(synthesizedWebMapping);\n\t\tassertSynthesized(synthesizedAgainWebMapping);\n\t\tassertThat(synthesizedWebMapping).isEqualTo(synthesizedAgainWebMapping);\n\t\tassertThat(synthesizedWebMapping).isSameAs(synthesizedAgainWebMapping);\n\t\tassertThat(synthesizedWebMapping.name()).isEqualTo(\"foo\");\n\t\tassertThat(synthesizedWebMapping.path()).containsExactly(\"/test\");\n\t\tassertThat(synthesizedWebMapping.value()).containsExactly(\"/test\");\n\t}\n\n\t@Test\n\tvoid synthesizeShouldNotSynthesizeNonsynthesizableAnnotations() throws Exception {\n\t\tMethod method = getClass().getDeclaredMethod(\"getId\");\n\n\t\tId id = method.getAnnotation(Id.class);\n\t\tassertThat(id).isNotNull();\n\t\tId synthesizedId = MergedAnnotation.from(id).synthesize();\n\t\tassertThat(id).isEqualTo(synthesizedId);\n\t\t// It doesn't make sense to synthesize @Id since it declares zero attributes.\n\t\tassertNotSynthesized(synthesizedId);\n\t\tassertThat(id).isSameAs(synthesizedId);\n\n\t\tGeneratedValue generatedValue = method.getAnnotation(GeneratedValue.class);\n\t\tassertThat(generatedValue).isNotNull();\n\t\tGeneratedValue synthesizedGeneratedValue = MergedAnnotation.from(generatedValue).synthesize();\n\t\tassertThat(generatedValue).isEqualTo(synthesizedGeneratedValue);\n\t\t// It doesn't make sense to synthesize @GeneratedValue since it declares zero attributes with aliases.\n\t\tassertNotSynthesized(synthesizedGeneratedValue);\n\t\tassertThat(generatedValue).isSameAs(synthesizedGeneratedValue);\n\t}\n\n\t@Test  // gh-28716\n\tvoid synthesizeWhenUsingMergedAnnotationsFromApi() {\n\t\tField directlyAnnotatedField = ReflectionUtils.findField(DomainType.class, \"directlyAnnotated\");\n\t\tMergedAnnotations mergedAnnotations = MergedAnnotations.from(directlyAnnotatedField);\n\t\tRootAnnotation rootAnnotation = mergedAnnotations.get(RootAnnotation.class).synthesize();\n\t\tassertThat(rootAnnotation.flag()).isFalse();\n\t\tassertNotSynthesized(rootAnnotation);\n\n\t\tField metaAnnotatedField = ReflectionUtils.findField(DomainType.class, \"metaAnnotated\");\n\t\tmergedAnnotations = MergedAnnotations.from(metaAnnotatedField);\n\t\trootAnnotation = mergedAnnotations.get(RootAnnotation.class).synthesize();\n\t\tassertThat(rootAnnotation.flag()).isTrue();\n\t\tassertSynthesized(rootAnnotation);\n\n\t\tField metaMetaAnnotatedField = ReflectionUtils.findField(DomainType.class, \"metaMetaAnnotated\");\n\t\tmergedAnnotations = MergedAnnotations.from(metaMetaAnnotatedField);\n\t\trootAnnotation = mergedAnnotations.get(RootAnnotation.class).synthesize();\n\t\tassertThat(rootAnnotation.flag()).isTrue();\n\t\tassertSynthesized(rootAnnotation);\n\t}\n\n\t@Test  // gh-28704\n\tvoid synthesizeShouldNotSynthesizeNonsynthesizableAnnotationsWhenUsingMergedAnnotationsFromApi() {\n\t\tMergedAnnotations mergedAnnotations = MergedAnnotations.from(SecurityConfig.class);\n\n\t\tEnableWebSecurity enableWebSecurity = mergedAnnotations.get(EnableWebSecurity.class).synthesize();\n\t\tassertNotSynthesized(enableWebSecurity);\n\n\t\tEnableGlobalAuthentication enableGlobalAuthentication = mergedAnnotations.get(EnableGlobalAuthentication.class).synthesize();\n\t\tassertNotSynthesized(enableGlobalAuthentication);\n\t}\n\n\t/**\n\t * If an attempt is made to synthesize an annotation from an annotation instance\n\t * that has already been synthesized, the original synthesized annotation should\n\t * ideally be returned as-is without creating a new proxy instance with the same\n\t * values.\n\t */\n\t@Test\n\tvoid synthesizeShouldNotResynthesizeAlreadySynthesizedAnnotations() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\t\tRequestMapping webMapping = method.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMapping).isNotNull();\n\n\t\tMergedAnnotation<RequestMapping> mergedAnnotation1 = MergedAnnotation.from(webMapping);\n\t\tRequestMapping synthesizedWebMapping1 = mergedAnnotation1.synthesize();\n\t\tRequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMapping).synthesize();\n\n\t\tassertSynthesized(synthesizedWebMapping1);\n\t\tassertSynthesized(synthesizedWebMapping2);\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(synthesizedWebMapping2);\n\n\t\t// Synthesizing an annotation from a different MergedAnnotation results in a different synthesized annotation instance.\n\t\tassertThat(synthesizedWebMapping1).isNotSameAs(synthesizedWebMapping2);\n\t\t// Synthesizing an annotation from the same MergedAnnotation results in the same synthesized annotation instance.\n\t\tassertThat(synthesizedWebMapping1).isSameAs(mergedAnnotation1.synthesize());\n\n\t\tRequestMapping synthesizedAgainWebMapping = MergedAnnotation.from(synthesizedWebMapping1).synthesize();\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(synthesizedAgainWebMapping);\n\t\t// Synthesizing an already synthesized annotation results in the original synthesized annotation instance.\n\t\tassertThat(synthesizedWebMapping1).isSameAs(synthesizedAgainWebMapping);\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAliasForIsMissingAttributeDeclaration() {\n\t\tAliasForWithMissingAttributeDeclaration annotation =\n\t\t\t\tAliasForWithMissingAttributeDeclarationClass.class.getAnnotation(\n\t\t\t\t\t\tAliasForWithMissingAttributeDeclaration.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"@AliasFor declaration on attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(AliasForWithMissingAttributeDeclaration.class.getName())\n\t\t\t\t.withMessageContaining(\"points to itself\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAliasForHasDuplicateAttributeDeclaration() {\n\t\tAliasForWithDuplicateAttributeDeclaration annotation =\n\t\t\t\tAliasForWithDuplicateAttributeDeclarationClass.class.getAnnotation(\n\t\t\t\t\t\tAliasForWithDuplicateAttributeDeclaration.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"In @AliasFor declared on attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(AliasForWithDuplicateAttributeDeclaration.class.getName())\n\t\t\t\t.withMessageContaining(\"attribute 'attribute' and its alias 'value' are present with values of 'baz' and 'bar'\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForNonexistentAttribute() {\n\t\tAliasForNonexistentAttribute annotation = AliasForNonexistentAttributeClass.class.getAnnotation(\n\t\t\t\tAliasForNonexistentAttribute.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"@AliasFor declaration on attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(AliasForNonexistentAttribute.class.getName())\n\t\t\t\t.withMessageContaining(\"declares an alias for 'bar' which is not present\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasWithMirroredAliasForWrongAttribute() {\n\t\tAliasForWithMirroredAliasForWrongAttribute annotation =\n\t\t\t\tAliasForWithMirroredAliasForWrongAttributeClass.class.getAnnotation(\n\t\t\t\t\t\tAliasForWithMirroredAliasForWrongAttribute.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessage(\"@AliasFor declaration on attribute 'bar' in annotation [\" +\n\t\t\t\t\t\tAliasForWithMirroredAliasForWrongAttribute.class.getName() +\n\t\t\t\t\t\t\"] declares an alias for 'quux' which is not present.\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForAttributeOfDifferentType() {\n\t\tAliasForAttributeOfDifferentType annotation = AliasForAttributeOfDifferentTypeClass.class.getAnnotation(\n\t\t\t\tAliasForAttributeOfDifferentType.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases\")\n\t\t\t\t.withMessageContaining(AliasForAttributeOfDifferentType.class.getName())\n\t\t\t\t.withMessageContaining(\"attribute 'foo'\")\n\t\t\t\t.withMessageContaining(\"attribute 'bar'\")\n\t\t\t\t.withMessageContaining(\"same return type\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForWithMissingDefaultValues() {\n\t\tAliasForWithMissingDefaultValues annotation = AliasForWithMissingDefaultValuesClass.class.getAnnotation(\n\t\t\t\tAliasForWithMissingDefaultValues.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases\")\n\t\t\t\t.withMessageContaining(AliasForWithMissingDefaultValues.class.getName())\n\t\t\t\t.withMessageContaining(\"attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(\"attribute 'bar' in annotation\")\n\t\t\t\t.withMessageContaining(\"default values\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForAttributeWithDifferentDefaultValue() {\n\t\tAliasForAttributeWithDifferentDefaultValue annotation =\n\t\t\t\tAliasForAttributeWithDifferentDefaultValueClass.class.getAnnotation(\n\t\t\t\t\t\tAliasForAttributeWithDifferentDefaultValue.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases\")\n\t\t\t\t.withMessageContaining(AliasForAttributeWithDifferentDefaultValue.class.getName())\n\t\t\t\t.withMessageContaining(\"attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(\"attribute 'bar' in annotation\")\n\t\t\t\t.withMessageContaining(\"same default value\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForMetaAnnotationThatIsNotMetaPresent() {\n\t\tAliasedComposedTestConfigurationNotMetaPresent annotation =\n\t\t\t\tAliasedComposedTestConfigurationNotMetaPresentClass.class.getAnnotation(\n\t\t\t\t\t\tAliasedComposedTestConfigurationNotMetaPresent.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"@AliasFor declaration on attribute 'xmlConfigFile' in annotation\")\n\t\t\t\t.withMessageContaining(AliasedComposedTestConfigurationNotMetaPresent.class.getName())\n\t\t\t\t.withMessageContaining(\"declares an alias for attribute 'location' in annotation\")\n\t\t\t\t.withMessageContaining(TestConfiguration.class.getName())\n\t\t\t\t.withMessageContaining(\"not meta-present\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliases() {\n\t\ttestSynthesisWithImplicitAliases(ValueImplicitAliasesTestConfigurationClass.class, \"value\");\n\t\ttestSynthesisWithImplicitAliases(Location1ImplicitAliasesTestConfigurationClass.class, \"location1\");\n\t\ttestSynthesisWithImplicitAliases(XmlImplicitAliasesTestConfigurationClass.class, \"xmlFile\");\n\t\ttestSynthesisWithImplicitAliases(GroovyImplicitAliasesSimpleTestConfigurationClass.class, \"groovyScript\");\n\t}\n\n\tprivate void testSynthesisWithImplicitAliases(Class<?> clazz, String expected) {\n\t\tImplicitAliasesTestConfiguration config = clazz.getAnnotation(ImplicitAliasesTestConfiguration.class);\n\t\tassertThat(config).isNotNull();\n\t\tImplicitAliasesTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.value()).isEqualTo(expected);\n\t\tassertThat(synthesized.location1()).isEqualTo(expected);\n\t\tassertThat(synthesized.xmlFile()).isEqualTo(expected);\n\t\tassertThat(synthesized.groovyScript()).isEqualTo(expected);\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesWithImpliedAliasNamesOmitted() {\n\t\ttestSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(\n\t\t\t\tValueImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass.class,\n\t\t\t\t\"value\");\n\t\ttestSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(\n\t\t\t\tLocationsImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass.class,\n\t\t\t\t\"location\");\n\t\ttestSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(\n\t\t\t\tXmlFilesImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass.class,\n\t\t\t\t\"xmlFile\");\n\t}\n\n\tprivate void testSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(Class<?> clazz, String expected) {\n\t\tImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration config = clazz.getAnnotation(\n\t\t\t\tImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration.class);\n\t\tassertThat(config).isNotNull();\n\t\tImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration synthesized =\n\t\t\t\tMergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.value()).isEqualTo(expected);\n\t\tassertThat(synthesized.location()).isEqualTo(expected);\n\t\tassertThat(synthesized.xmlFile()).isEqualTo(expected);\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesForAliasPair() {\n\t\tImplicitAliasesForAliasPairTestConfiguration config =\n\t\t\t\tImplicitAliasesForAliasPairTestConfigurationClass.class.getAnnotation(\n\t\t\t\t\t\tImplicitAliasesForAliasPairTestConfiguration.class);\n\t\tImplicitAliasesForAliasPairTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.xmlFile()).isEqualTo(\"test.xml\");\n\t\tassertThat(synthesized.groovyScript()).isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithTransitiveImplicitAliases() {\n\t\tTransitiveImplicitAliasesTestConfiguration config =\n\t\t\t\tTransitiveImplicitAliasesTestConfigurationClass.class.getAnnotation(\n\t\t\t\t\t\tTransitiveImplicitAliasesTestConfiguration.class);\n\t\tTransitiveImplicitAliasesTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.xml()).isEqualTo(\"test.xml\");\n\t\tassertThat(synthesized.groovy()).isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithTransitiveImplicitAliasesForAliasPair() {\n\t\tTransitiveImplicitAliasesForAliasPairTestConfiguration config =\n\t\t\t\tTransitiveImplicitAliasesForAliasPairTestConfigurationClass.class.getAnnotation(\n\t\t\t\t\t\tTransitiveImplicitAliasesForAliasPairTestConfiguration.class);\n\t\tTransitiveImplicitAliasesForAliasPairTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.xml()).isEqualTo(\"test.xml\");\n\t\tassertThat(synthesized.groovy()).isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesWithMissingDefaultValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithMissingDefaultValuesTestConfigurationClass.class;\n\t\tClass<ImplicitAliasesWithMissingDefaultValuesTestConfiguration> annotationType =\n\t\t\t\tImplicitAliasesWithMissingDefaultValuesTestConfiguration.class;\n\t\tImplicitAliasesWithMissingDefaultValuesTestConfiguration config = clazz.getAnnotation(annotationType);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(clazz, config))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases:\")\n\t\t\t\t.withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t\t.withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t\t.withMessageContaining(\"default values\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesWithDifferentDefaultValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithDifferentDefaultValuesTestConfigurationClass.class;\n\t\tClass<ImplicitAliasesWithDifferentDefaultValuesTestConfiguration> annotationType =\n\t\t\t\tImplicitAliasesWithDifferentDefaultValuesTestConfiguration.class;\n\t\tImplicitAliasesWithDifferentDefaultValuesTestConfiguration config = clazz.getAnnotation(annotationType);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(clazz, config))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases:\")\n\t\t\t\t.withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t\t.withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t\t.withMessageContaining(\"same default value\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesWithDuplicateValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithDuplicateValuesTestConfigurationClass.class;\n\t\tClass<ImplicitAliasesWithDuplicateValuesTestConfiguration> annotationType =\n\t\t\t\tImplicitAliasesWithDuplicateValuesTestConfiguration.class;\n\t\tImplicitAliasesWithDuplicateValuesTestConfiguration config = clazz.getAnnotation(annotationType);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotation.from(clazz, config))\n\t\t\t\t.withMessageStartingWith(\"Different @AliasFor mirror values for annotation\")\n\t\t\t\t.withMessageContaining(annotationType.getName())\n\t\t\t\t.withMessageContaining(\"declared on class\")\n\t\t\t\t.withMessageContaining(clazz.getName())\n\t\t\t\t.withMessageContaining(\"are declared with values of\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tMap<String, Object> map = Collections.singletonMap(\"value\", \"webController\");\n\t\tMergedAnnotation<Component> annotation = MergedAnnotation.of(Component.class, map);\n\n\t\tComponent synthesizedComponent = annotation.synthesize();\n\t\tassertSynthesized(synthesizedComponent);\n\t\tassertThat(synthesizedComponent.value()).isEqualTo(\"webController\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeFromMapWithNestedMap() {\n\t\tComponentScanSingleFilter componentScan = ComponentScanSingleFilterClass.class.getAnnotation(\n\t\t\t\tComponentScanSingleFilter.class);\n\t\tassertThat(componentScan).isNotNull();\n\t\tassertThat(componentScan.value().pattern()).isEqualTo(\"*Foo\");\n\t\tMap<String, Object> map = MergedAnnotation.from(componentScan).asMap(\n\t\t\t\tannotation -> new LinkedHashMap<>(), Adapt.ANNOTATION_TO_MAP);\n\t\tMap<String, Object> filterMap = (Map<String, Object>) map.get(\"value\");\n\t\tassertThat(filterMap.get(\"pattern\")).isEqualTo(\"*Foo\");\n\t\tfilterMap.put(\"pattern\", \"newFoo\");\n\t\tfilterMap.put(\"enigma\", 42);\n\t\tMergedAnnotation<ComponentScanSingleFilter> annotation = MergedAnnotation.of(\n\t\t\t\tComponentScanSingleFilter.class, map);\n\t\tComponentScanSingleFilter synthesizedComponentScan = annotation.synthesize();\n\t\tassertSynthesized(synthesizedComponentScan);\n\t\tassertThat(synthesizedComponentScan.value().pattern()).isEqualTo(\"newFoo\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeFromMapWithNestedArrayOfMaps() {\n\t\tComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class);\n\t\tassertThat(componentScan).isNotNull();\n\t\tMap<String, Object> map = MergedAnnotation.from(componentScan).asMap(\n\t\t\t\tannotation -> new LinkedHashMap<>(), Adapt.ANNOTATION_TO_MAP);\n\t\tMap<String, Object>[] filters = (Map[]) map.get(\"excludeFilters\");\n\t\tList<String> patterns = Arrays.stream(filters).map(\n\t\t\t\tm -> (String) m.get(\"pattern\")).toList();\n\t\tassertThat(patterns).containsExactly(\"*Foo\", \"*Bar\");\n\t\tfilters[0].put(\"pattern\", \"newFoo\");\n\t\tfilters[0].put(\"enigma\", 42);\n\t\tfilters[1].put(\"pattern\", \"newBar\");\n\t\tfilters[1].put(\"enigma\", 42);\n\t\tMergedAnnotation<ComponentScan> annotation = MergedAnnotation.of(ComponentScan.class, map);\n\t\tComponentScan synthesizedComponentScan = annotation.synthesize();\n\t\tassertSynthesized(synthesizedComponentScan);\n\t\tassertThat(Arrays.stream(synthesizedComponentScan.excludeFilters()).map(Filter::pattern))\n\t\t\t\t.containsExactly(\"newFoo\", \"newBar\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromDefaultsWithoutAttributeAliases() {\n\t\tMergedAnnotation<AnnotationWithDefaults> annotation = MergedAnnotation.of(AnnotationWithDefaults.class);\n\t\tAnnotationWithDefaults synthesized = annotation.synthesize();\n\t\tassertThat(synthesized.text()).isEqualTo(\"enigma\");\n\t\tassertThat(synthesized.predicate()).isTrue();\n\t\tassertThat(synthesized.characters()).containsExactly('a', 'b', 'c');\n\t}\n\n\t@Test\n\tvoid synthesizeFromDefaultsWithAttributeAliases() {\n\t\tMergedAnnotation<TestConfiguration> annotation = MergedAnnotation.of(TestConfiguration.class);\n\t\tTestConfiguration synthesized = annotation.synthesize();\n\t\tassertThat(synthesized.value()).isEmpty();\n\t\tassertThat(synthesized.location()).isEmpty();\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasesWithDifferentValues() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tMergedAnnotation.from(TestConfigurationMismatch.class.getAnnotation(TestConfiguration.class)).synthesize());\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithMinimalAttributesWithAttributeAliases() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"location\", \"test.xml\");\n\t\tMergedAnnotation<TestConfiguration> annotation = MergedAnnotation.of(TestConfiguration.class, map);\n\t\tTestConfiguration synthesized = annotation.synthesize();\n\t\tassertThat(synthesized.value()).isEqualTo(\"test.xml\");\n\t\tassertThat(synthesized.location()).isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements() {\n\t\tsynthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements(\n\t\t\t\tCollections.singletonMap(\"value\", \"/foo\"));\n\t\tsynthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements(\n\t\t\t\tCollections.singletonMap(\"path\", \"/foo\"));\n\t}\n\n\tprivate void synthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements(Map<String, Object> map) {\n\t\tMergedAnnotation<GetMapping> annotation = MergedAnnotation.of(GetMapping.class, map);\n\t\tGetMapping synthesized = annotation.synthesize();\n\t\tassertThat(synthesized.value()).isEqualTo(\"/foo\");\n\t\tassertThat(synthesized.path()).isEqualTo(\"/foo\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithImplicitAttributeAliases() {\n\t\ttestSynthesisFromMapWithImplicitAliases(\"value\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"location1\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"location2\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"location3\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"xmlFile\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"groovyScript\");\n\t}\n\n\tprivate void testSynthesisFromMapWithImplicitAliases(String attributeNameAndValue) {\n\t\tMap<String, Object> map = Collections.singletonMap(attributeNameAndValue, attributeNameAndValue);\n\t\tMergedAnnotation<ImplicitAliasesTestConfiguration> annotation = MergedAnnotation.of(\n\t\t\t\tImplicitAliasesTestConfiguration.class, map);\n\t\tImplicitAliasesTestConfiguration synthesized = annotation.synthesize();\n\n\t\tassertThat(synthesized.value()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.location1()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.location2()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.location2()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.xmlFile()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.groovyScript()).isEqualTo(attributeNameAndValue);\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithMissingAttributeValue() {\n\t\ttestMissingTextAttribute(Collections.emptyMap());\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithNullAttributeValue() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"text\", null);\n\t\tassertThat(map).containsKey(\"text\");\n\t\ttestMissingTextAttribute(map);\n\t}\n\n\tprivate void testMissingTextAttribute(Map<String, Object> attributes) {\n\t\tassertThatExceptionOfType(NoSuchElementException.class).isThrownBy(() ->\n\t\t\t\tMergedAnnotation.of(AnnotationWithoutDefaults.class, attributes).synthesize().text())\n\t\t\t\t.withMessage(\"No value found for attribute named 'text' in merged annotation \" +\n\t\t\t\t\t\tAnnotationWithoutDefaults.class.getCanonicalName());\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithAttributeOfIncorrectType() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"value\", 42L);\n\t\tMergedAnnotation<Component> annotation = MergedAnnotation.of(Component.class, map);\n\t\tassertThatIllegalStateException().isThrownBy(() -> annotation.synthesize().value())\n\t\t\t\t.withMessage(\"Attribute 'value' in annotation \" +\n\t\t\t\t\t\t\"org.springframework.core.testfixture.stereotype.Component should be \" +\n\t\t\t\t\t\t\"compatible with java.lang.String but a java.lang.Long value was returned\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromAnnotationAttributesWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tMap<String, Object> attributes = MergedAnnotation.from(component).asMap();\n\n\t\tComponent synthesized = MergedAnnotation.of(Component.class, attributes).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized).isEqualTo(component);\n\t}\n\n\t@Test\n\tvoid toStringForSynthesizedAnnotations() throws Exception {\n\t\tMethod methodWithPath = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\tRequestMapping webMappingWithAliases = methodWithPath.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithAliases).isNotNull();\n\n\t\tMethod methodWithPathAndValue = WebController.class.getMethod(\"handleMappedWithSamePathAndValueAttributes\");\n\t\tRequestMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(RequestMapping.class);\n\t\tassertThat(methodWithPathAndValue).isNotNull();\n\n\t\tRequestMapping synthesizedWebMapping1 = MergedAnnotation.from(webMappingWithAliases).synthesize();\n\t\tRequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMappingWithPathAndValue).synthesize();\n\n\t\tassertThat(webMappingWithAliases.toString()).isNotEqualTo(synthesizedWebMapping1.toString());\n\n\t\t// The unsynthesized annotation for handleMappedWithSamePathAndValueAttributes()\n\t\t// should produce almost the same toString() results as synthesized annotations for\n\t\t// handleMappedWithPathAttribute() on Java 9 or higher; however, due to multiple changes\n\t\t// in the JDK's toString() implementation for annotations in JDK 9, 14, and 19,\n\t\t// we do not test the JDK implementation.\n\t\t// assertToStringForWebMappingWithPathAndValue(webMappingWithPathAndValue);\n\n\t\tassertToStringForWebMappingWithPathAndValue(synthesizedWebMapping1);\n\t\tassertToStringForWebMappingWithPathAndValue(synthesizedWebMapping2);\n\t}\n\n\tprivate void assertToStringForWebMappingWithPathAndValue(RequestMapping webMapping) {\n\t\tassertThat(webMapping.toString())\n\t\t\t\t.startsWith(\"@org.springframework.core.annotation.MergedAnnotationsTests.RequestMapping(\")\n\t\t\t\t.contains(\n\t\t\t\t\t// Strings\n\t\t\t\t\t\"value={\\\"/test\\\"}\", \"path={\\\"/test\\\"}\", \"name=\\\"bar\\\"\",\n\t\t\t\t\t// Characters\n\t\t\t\t\t\"ch='X'\", \"chars={'X'}\",\n\t\t\t\t\t// Enums\n\t\t\t\t\t\"method={GET, POST}\",\n\t\t\t\t\t// Classes\n\t\t\t\t\t\"clazz=org.springframework.core.annotation.MergedAnnotationsTests.RequestMethod.class\",\n\t\t\t\t\t\"classes={int[][].class, org.springframework.core.annotation.MergedAnnotationsTests.RequestMethod[].class}\",\n\t\t\t\t\t// Bytes\n\t\t\t\t\t\"byteValue=(byte) 0xFF\", \"bytes={(byte) 0xFF}\",\n\t\t\t\t\t// Shorts\n\t\t\t\t\t\"shortValue=9876\", \"shorts={9876}\",\n\t\t\t\t\t// Longs\n\t\t\t\t\t\"longValue=42L\", \"longs={42L}\",\n\t\t\t\t\t// Floats\n\t\t\t\t\t\"floatValue=3.14f\", \"floats={3.14f}\",\n\t\t\t\t\t// Doubles\n\t\t\t\t\t\"doubleValue=99.999d\", \"doubles={99.999d}\"\n\t\t\t\t)\n\t\t\t\t.endsWith(\")\");\n\t}\n\n\t@Test\n\tvoid equalsForSynthesizedAnnotations() throws Exception {\n\t\tMethod methodWithPath = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\tRequestMapping webMappingWithAliases = methodWithPath.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithAliases).isNotNull();\n\t\tMethod methodWithPathAndValue = WebController.class.getMethod(\"handleMappedWithSamePathAndValueAttributes\");\n\t\tRequestMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithPathAndValue).isNotNull();\n\t\tRequestMapping synthesizedWebMapping1 = MergedAnnotation.from(webMappingWithAliases).synthesize();\n\t\tRequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMappingWithPathAndValue).synthesize();\n\t\t// Equality amongst standard annotations\n\t\tassertThat(webMappingWithAliases).isEqualTo(webMappingWithAliases);\n\t\tassertThat(webMappingWithPathAndValue).isEqualTo(webMappingWithPathAndValue);\n\t\t// Inequality amongst standard annotations\n\t\tassertThat(webMappingWithAliases).isNotEqualTo(webMappingWithPathAndValue);\n\t\tassertThat(webMappingWithPathAndValue).isNotEqualTo(webMappingWithAliases);\n\t\t// Equality amongst synthesized annotations\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(synthesizedWebMapping1);\n\t\tassertThat(synthesizedWebMapping2).isEqualTo(synthesizedWebMapping2);\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(synthesizedWebMapping2);\n\t\tassertThat(synthesizedWebMapping2).isEqualTo(synthesizedWebMapping1);\n\t\t// Equality between standard and synthesized annotations\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(webMappingWithPathAndValue);\n\t\tassertThat(webMappingWithPathAndValue).isEqualTo(synthesizedWebMapping1);\n\t\t// Inequality between standard and synthesized annotations\n\t\tassertThat(synthesizedWebMapping1).isNotEqualTo(webMappingWithAliases);\n\t\tassertThat(webMappingWithAliases).isNotEqualTo(synthesizedWebMapping1);\n\t}\n\n\t@Test\n\tvoid hashCodeForSynthesizedAnnotations() throws Exception {\n\t\tMethod methodWithPath = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\tRequestMapping webMappingWithAliases = methodWithPath.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithAliases).isNotNull();\n\t\tMethod methodWithPathAndValue = WebController.class.getMethod(\"handleMappedWithSamePathAndValueAttributes\");\n\t\tRequestMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithPathAndValue).isNotNull();\n\t\tRequestMapping synthesizedWebMapping1 = MergedAnnotation.from(webMappingWithAliases).synthesize();\n\t\tassertThat(synthesizedWebMapping1).isNotNull();\n\t\tRequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMappingWithPathAndValue).synthesize();\n\t\tassertThat(synthesizedWebMapping2).isNotNull();\n\t\t// Equality amongst standard annotations\n\t\tassertThat(webMappingWithAliases.hashCode()).isEqualTo(webMappingWithAliases.hashCode());\n\t\tassertThat(webMappingWithPathAndValue.hashCode()).isEqualTo(webMappingWithPathAndValue.hashCode());\n\t\t// Inequality amongst standard annotations\n\t\tassertThat(webMappingWithAliases.hashCode()).isNotEqualTo(webMappingWithPathAndValue.hashCode());\n\t\tassertThat(webMappingWithPathAndValue.hashCode()).isNotEqualTo(webMappingWithAliases.hashCode());\n\t\t// Equality amongst synthesized annotations\n\t\tassertThat(synthesizedWebMapping1.hashCode()).isEqualTo(synthesizedWebMapping1.hashCode());\n\t\tassertThat(synthesizedWebMapping2.hashCode()).isEqualTo(synthesizedWebMapping2.hashCode());\n\t\tassertThat(synthesizedWebMapping1.hashCode()).isEqualTo(synthesizedWebMapping2.hashCode());\n\t\tassertThat(synthesizedWebMapping2.hashCode()).isEqualTo(synthesizedWebMapping1.hashCode());\n\t\t// Equality between standard and synthesized annotations\n\t\tassertThat(synthesizedWebMapping1.hashCode()).isEqualTo(webMappingWithPathAndValue.hashCode());\n\t\tassertThat(webMappingWithPathAndValue.hashCode()).isEqualTo(synthesizedWebMapping1.hashCode());\n\t\t// Inequality between standard and synthesized annotations\n\t\tassertThat(synthesizedWebMapping1.hashCode()).isNotEqualTo(webMappingWithAliases.hashCode());\n\t\tassertThat(webMappingWithAliases.hashCode()).isNotEqualTo(synthesizedWebMapping1.hashCode());\n\t}\n\n\t/**\n\t * Fully reflection-based test that verifies support for synthesizing\n\t * annotations across packages with non-public visibility of user types\n\t * (for example, a non-public annotation that uses {@code @AliasFor}).\n\t */\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeNonPublicWithAttributeAliasesFromDifferentPackage() throws Exception {\n\t\tClass<?> type = ClassUtils.forName(\n\t\t\t\t\"org.springframework.core.annotation.subpackage.NonPublicAliasedAnnotatedClass\",\n\t\t\t\tnull);\n\t\tClass<? extends Annotation> annotationType = (Class<? extends Annotation>) ClassUtils.forName(\n\t\t\t\t\"org.springframework.core.annotation.subpackage.NonPublicAliasedAnnotation\",\n\t\t\t\tnull);\n\t\tAnnotation annotation = type.getAnnotation(annotationType);\n\t\tassertThat(annotation).isNotNull();\n\t\tMergedAnnotation<Annotation> mergedAnnotation = MergedAnnotation.from(annotation);\n\t\tAnnotation synthesizedAnnotation = mergedAnnotation.synthesize();\n\t\tassertSynthesized(synthesizedAnnotation);\n\t\tassertThat(mergedAnnotation.getString(\"name\")).isEqualTo(\"test\");\n\t\tassertThat(mergedAnnotation.getString(\"path\")).isEqualTo(\"/test\");\n\t\tassertThat(mergedAnnotation.getString(\"value\")).isEqualTo(\"/test\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithArrayOfAnnotations() {\n\t\tHierarchy hierarchy = HierarchyClass.class.getAnnotation(Hierarchy.class);\n\t\tassertThat(hierarchy).isNotNull();\n\t\tHierarchy synthesizedHierarchy = MergedAnnotation.from(hierarchy).synthesize();\n\t\tassertSynthesized(synthesizedHierarchy);\n\t\tTestConfiguration[] configs = synthesizedHierarchy.value();\n\t\tassertThat(configs).isNotNull();\n\t\tassertThat(configs).allMatch(AnnotationUtils::isSynthesizedAnnotation);\n\t\tassertThat(configs).extracting(TestConfiguration::value).containsExactly(\"A\", \"B\");\n\t\tassertThat(configs).extracting(TestConfiguration::location).containsExactly(\"A\", \"B\");\n\n\t\tTestConfiguration contextConfig = TestConfigurationClass.class.getAnnotation(TestConfiguration.class);\n\t\tassertThat(contextConfig).isNotNull();\n\t\t// Alter array returned from synthesized annotation\n\t\tconfigs[0] = contextConfig;\n\t\tassertThat(configs).extracting(TestConfiguration::value).containsExactly(\"simple.xml\", \"B\");\n\t\t// Re-retrieve the array from the synthesized annotation\n\t\tconfigs = synthesizedHierarchy.value();\n\t\tassertThat(configs).extracting(TestConfiguration::value).containsExactly(\"A\", \"B\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithArrayOfChars() {\n\t\tCharsContainer charsContainer = GroupOfCharsClass.class.getAnnotation(CharsContainer.class);\n\t\tassertThat(charsContainer).isNotNull();\n\t\tCharsContainer synthesizedCharsContainer = MergedAnnotation.from(charsContainer).synthesize();\n\t\tassertSynthesized(synthesizedCharsContainer);\n\t\tchar[] chars = synthesizedCharsContainer.chars();\n\t\tassertThat(chars).containsExactly('x', 'y', 'z');\n\t\t// Alter array returned from synthesized annotation\n\t\tchars[0] = '?';\n\t\t// Re-retrieve the array from the synthesized annotation\n\t\tchars = synthesizedCharsContainer.chars();\n\t\tassertThat(chars).containsExactly('x', 'y', 'z');\n\t}\n\n\t@Test\n\tvoid getValueWhenHasDefaultOverride() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(DefaultOverrideClass.class)\n\t\t\t\t.get(DefaultOverrideRoot.class);\n\t\tassertThat(annotation.getString(\"text\")).isEqualTo(\"metameta\");\n\t}\n\n\t@Test // gh-22654\n\tvoid getValueWhenHasDefaultOverrideWithImplicitAlias() {\n\t\tMergedAnnotation<?> annotation1 = MergedAnnotations.from(DefaultOverrideImplicitAliasMetaClass1.class)\n\t\t\t\t.get(DefaultOverrideRoot.class);\n\t\tassertThat(annotation1.getString(\"text\")).isEqualTo(\"alias-meta-1\");\n\t\tMergedAnnotation<?> annotation2 = MergedAnnotations.from(DefaultOverrideImplicitAliasMetaClass2.class)\n\t\t\t\t.get(DefaultOverrideRoot.class);\n\t\tassertThat(annotation2.getString(\"text\")).isEqualTo(\"alias-meta-2\");\n\t}\n\n\t@Test // gh-22654\n\tvoid getValueWhenHasDefaultOverrideWithExplicitAlias() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(DefaultOverrideExplicitAliasRootMetaMetaClass.class)\n\t\t\t\t.get(DefaultOverrideExplicitAliasRoot.class);\n\t\tassertThat(annotation.getString(\"text\")).isEqualTo(\"meta\");\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta\");\n\t}\n\n\t@Test // gh-22703\n\tvoid getValueWhenThreeDeepMetaWithValue() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(ValueAttributeMetaMetaClass.class)\n\t\t\t\t.get(ValueAttribute.class);\n\t\tassertThat(annotation.getStringArray(MergedAnnotation.VALUE)).containsExactly(\"FromValueAttributeMeta\");\n\t}\n\n\t@Test\n\tvoid asAnnotationAttributesReturnsPopulatedAnnotationAttributes() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(SpringApplicationConfigurationClass.class)\n\t\t\t\t.get(SpringApplicationConfiguration.class);\n\t\tAnnotationAttributes attributes = annotation.asAnnotationAttributes(Adapt.CLASS_TO_STRING);\n\t\tassertThat(attributes).containsEntry(\"classes\", new String[] {Number.class.getName()});\n\t\tassertThat(attributes.annotationType()).isEqualTo(SpringApplicationConfiguration.class);\n\t}\n\n\n\t// @formatter:off\n\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Transactional {\n\n\t\tString value() default \"\";\n\n\t\tString qualifier() default \"transactionManager\";\n\n\t\tboolean readOnly() default false;\n\t}\n\n\t@Transactional\n\t@Component\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransactionalComponent {\n\t}\n\n\t@TransactionalComponent\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedTransactionalComponent {\n\t}\n\n\tstatic class NonAnnotatedClass {\n\t}\n\n\t@Component\n\tstatic class AnnotatedClass {\n\n\t\tclass NonAnnotatedInnerClass {\n\t\t}\n\n\t\tstatic class NonAnnotatedStaticNestedClass {\n\t\t}\n\t}\n\n\tinterface NonAnnotatedInterface {\n\t}\n\n\t@TransactionalComponent\n\tstatic class TransactionalComponentClass {\n\t}\n\n\tstatic class SubTransactionalComponentClass extends TransactionalComponentClass {\n\t}\n\n\t@ComposedTransactionalComponent\n\tstatic class ComposedTransactionalComponentClass {\n\t}\n\n\t@AliasedTransactionalComponent\n\tstatic class AliasedTransactionalComponentClass {\n\t}\n\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface AliasedTransactional {\n\n\t\t@AliasFor(attribute = \"qualifier\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tString qualifier() default \"\";\n\t}\n\n\t@Transactional(qualifier = \"composed1\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@Inherited\n\t@interface InheritedComposed {\n\t}\n\n\t@Transactional(qualifier = \"composed2\", readOnly = true)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface Composed {\n\t}\n\n\t@Transactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxComposedWithOverride {\n\n\t\tString qualifier() default \"txMgr\";\n\t}\n\n\t@Transactional(\"TxInheritedComposed\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxInheritedComposed {\n\t}\n\n\t@Transactional(\"TxComposed\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxComposed {\n\t}\n\n\t@AliasedTransactional(value = \"aliasForQualifier\")\n\t@Component\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedTransactionalComponent {\n\t}\n\n\t@AliasedTransactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MyAliasedTransactional {\n\n\t\t@AliasFor(annotation = AliasedTransactional.class, attribute = \"value\")\n\t\tString value() default \"defaultTransactionManager\";\n\t}\n\n\t@MyAliasedTransactional(\"anotherTransactionManager\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@interface ComposedMyAliasedTransactional {\n\t}\n\n\t@ComposedMyAliasedTransactional\n\tstatic class ComposedTransactionalClass {\n\t}\n\n\t@AliasedTransactional(\"meta\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaAliasedTransactional {\n\t}\n\n\t@MetaAliasedTransactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMetaAliasedTransactional {\n\t}\n\n\t@MetaMetaAliasedTransactional\n\tstatic class MetaMetaAliasedTransactionalClass {\n\t}\n\n\t@TxComposedWithOverride\n\t// Override default \"txMgr\" from @TxComposedWithOverride with \"localTxMgr\"\n\t@Transactional(qualifier = \"localTxMgr\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface MetaAndLocalTxConfig {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestPropertySource {\n\n\t\t@AliasFor(\"locations\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] locations() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContextConfiguration {\n\n\t\t@AliasFor(attribute = \"locations\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tString[] locations() default {};\n\n\t\tClass<?>[] classes() default {};\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionBasedComposedContextConfiguration {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] locations() default {};\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class)\n\t\tClass<?>[] classes() default {};\n\t}\n\n\t@ContextConfiguration(value = \"duplicateDeclaration\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface InvalidConventionBasedComposedContextConfiguration {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] locations();\n\t}\n\n\t/**\n\t * This hybrid approach for annotation attribute overrides with transitive implicit\n\t * aliases is unsupported. See SPR-13554 for details.\n\t */\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface HalfConventionBasedAndHalfAliasedComposedContextConfiguration {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] locations() default {};\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles() default {};\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles();\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedValueComposedContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"value\")\n\t\tString[] locations();\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] groovyScripts() default {};\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlFiles() default {};\n\n\t\t// intentionally omitted: attribute = \"locations\"\n\t\t@AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] locations() default {};\n\n\t\t// intentionally omitted: attribute = \"locations\" (SPR-14069)\n\t\t@AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] value() default {};\n\t}\n\n\t@ImplicitAliasesContextConfiguration(xmlFiles = { \"A.xml\", \"B.xml\" })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedImplicitAliasesContextConfiguration {\n\t}\n\n\t@ImplicitAliasesContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesContextConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"xmlFiles\")\n\t\tString[] xml() default {};\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\n\t\tString[] groovy() default {};\n\t}\n\n\t@ImplicitAliasesContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SingleLocationTransitiveImplicitAliasesContextConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"xmlFiles\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@ImplicitAliasesContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesWithSkippedLevelContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xml() default {};\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\n\t\tString[] groovy() default {};\n\t}\n\n\t@ImplicitAliasesContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\n\t\tString groovy() default \"\";\n\t}\n\n\t/**\n\t * Although the configuration declares an explicit value for 'value' and requires a\n\t * value for the aliased 'locations', this does not result in an error since\n\t * 'locations' effectively shadows the 'value' attribute (which cannot be set via the\n\t * composed annotation anyway). If 'value' were not shadowed, such a declaration would\n\t * not make sense.\n\t */\n\t@ContextConfiguration(value = \"duplicateDeclaration\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ShadowedAliasComposedContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles();\n\t}\n\n\t@ContextConfiguration(locations = \"shadowed.xml\")\n\t@TestPropertySource(locations = \"test.properties\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfigurationAndTestPropertySource {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles() default \"default.xml\";\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SpringApplicationConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] locations() default {};\n\n\t\t// Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class, attribute = \"classes\")\n\t\t@AliasFor(\"value\")\n\t\tClass<?>[] classes() default {};\n\n\t\t// Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class, attribute = \"classes\")\n\t\t@AliasFor(\"classes\")\n\t\tClass<?>[] value() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScan {\n\n\t\t@AliasFor(\"basePackages\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] basePackages() default {};\n\n\t\tFilter[] excludeFilters() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({})\n\t@interface Filter {\n\n\t\tString pattern();\n\t}\n\n\t@ComponentScan(excludeFilters = { @Filter(pattern = \"*Test\"),\n\t\t@Filter(pattern = \"*Tests\") })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestComponentScan {\n\n\t\t@AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\n\t\tString[] packages();\n\t}\n\n\t@ComponentScan\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionBasedSinglePackageComponentScan {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ComponentScan.class)\n\t\tString basePackages();\n\t}\n\n\t@ComponentScan\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForBasedSinglePackageComponentScan {\n\n\t\t@AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\n\t\tString pkg();\n\t}\n\n\t@Transactional\n\tstatic class ClassWithInheritedAnnotation {\n\t}\n\n\t@Composed\n\tstatic class SubClassWithInheritedAnnotation extends ClassWithInheritedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedAnnotation\n\t\t\textends SubClassWithInheritedAnnotation {\n\t}\n\n\t@InheritedComposed\n\tstatic class ClassWithInheritedComposedAnnotation {\n\t}\n\n\t@Composed\n\tstatic class SubClassWithInheritedComposedAnnotation\n\t\t\textends ClassWithInheritedComposedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedComposedAnnotation\n\t\t\textends SubClassWithInheritedComposedAnnotation {\n\t}\n\n\t@MetaAndLocalTxConfig\n\tstatic class MetaAndLocalTxConfigClass {\n\t}\n\n\t@Transactional(\"TxConfig\")\n\tstatic class TxConfig {\n\t}\n\n\t@Transactional(\"DerivedTxConfig\")\n\tstatic class DerivedTxConfig extends TxConfig {\n\t}\n\n\t@TxInheritedComposed\n\t@TxComposed\n\tstatic class TxFromMultipleComposedAnnotations {\n\t}\n\n\t@Transactional\n\tinterface InterfaceWithInheritedAnnotation {\n\n\t\t@Order\n\t\tvoid handleFromInterface();\n\t}\n\n\tabstract static class AbstractClassWithInheritedAnnotation<T>\n\t\t\timplements InterfaceWithInheritedAnnotation {\n\n\t\t@Transactional\n\t\tpublic abstract void handle();\n\n\t\t@Transactional\n\t\tpublic void handleParameterized(T t) {\n\t\t}\n\t}\n\n\tstatic class ConcreteClassWithInheritedAnnotation\n\t\t\textends AbstractClassWithInheritedAnnotation<String> {\n\n\t\t@Override\n\t\tpublic void handle() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleParameterized(String s) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleFromInterface() {\n\t\t}\n\t}\n\n\tpublic interface GenericParameter<T> {\n\n\t\tT getFor(Class<T> cls);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class StringGenericParameter implements GenericParameter<String> {\n\n\t\t@Order\n\t\t@Override\n\t\tpublic String getFor(Class<String> cls) {\n\t\t\treturn \"foo\";\n\t\t}\n\n\t\tpublic String getFor(Integer integer) {\n\t\t\treturn \"foo\";\n\t\t}\n\t}\n\n\t@Transactional\n\tpublic interface InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubInheritedAnnotationInterface\n\t\t\textends InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubInheritedAnnotationInterface\n\t\t\textends SubInheritedAnnotationInterface {\n\t}\n\n\t@Order\n\tpublic interface NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubNonInheritedAnnotationInterface\n\t\t\textends NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubNonInheritedAnnotationInterface\n\t\t\textends SubNonInheritedAnnotationInterface {\n\t}\n\n\t@ConventionBasedComposedContextConfiguration(locations = \"explicitDeclaration\")\n\tstatic class ConventionBasedComposedContextConfigurationClass {\n\t}\n\n\t@InvalidConventionBasedComposedContextConfiguration(locations = \"requiredLocationsDeclaration\")\n\tstatic class InvalidConventionBasedComposedContextConfigurationClass {\n\t}\n\n\t@HalfConventionBasedAndHalfAliasedComposedContextConfiguration(xmlConfigFiles = \"explicitDeclaration\")\n\tstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass1 {\n\t}\n\n\t@HalfConventionBasedAndHalfAliasedComposedContextConfiguration(locations = \"explicitDeclaration\")\n\tstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass2 {\n\t}\n\n\t@AliasedComposedContextConfiguration(xmlConfigFiles = \"test.xml\")\n\tstatic class AliasedComposedContextConfigurationClass {\n\t}\n\n\t@AliasedValueComposedContextConfiguration(locations = \"test.xml\")\n\tstatic class AliasedValueComposedContextConfigurationClass {\n\t}\n\n\t@ImplicitAliasesContextConfiguration(\"foo.xml\")\n\tstatic class ImplicitAliasesContextConfigurationClass1 {\n\t}\n\n\t@ImplicitAliasesContextConfiguration(locations = \"bar.xml\")\n\tstatic class ImplicitAliasesContextConfigurationClass2 {\n\t}\n\n\t@ImplicitAliasesContextConfiguration(xmlFiles = \"baz.xml\")\n\tstatic class ImplicitAliasesContextConfigurationClass3 {\n\t}\n\n\t@TransitiveImplicitAliasesContextConfiguration(groovy = \"test.groovy\")\n\tstatic class TransitiveImplicitAliasesContextConfigurationClass {\n\t}\n\n\t@SingleLocationTransitiveImplicitAliasesContextConfiguration(groovy = \"test.groovy\")\n\tstatic class SingleLocationTransitiveImplicitAliasesContextConfigurationClass {\n\t}\n\n\t@TransitiveImplicitAliasesWithSkippedLevelContextConfiguration(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass {\n\t}\n\n\t@SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfiguration(xml = \"test.xml\")\n\tstatic class SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass {\n\t}\n\n\t@ComposedImplicitAliasesContextConfiguration\n\tstatic class ComposedImplicitAliasesContextConfigurationClass {\n\t}\n\n\t@ShadowedAliasComposedContextConfiguration(xmlConfigFiles = \"test.xml\")\n\tstatic class ShadowedAliasComposedContextConfigurationClass {\n\t}\n\n\t@AliasedComposedContextConfigurationAndTestPropertySource(xmlConfigFiles = \"test.xml\")\n\tstatic class AliasedComposedContextConfigurationAndTestPropertySourceClass {\n\t}\n\n\t@ComponentScan(value = \"com.example.app.test\", basePackages = \"com.example.app.test\")\n\tstatic class ComponentScanWithBasePackagesAndValueAliasClass {\n\t}\n\n\t@TestComponentScan(packages = \"com.example.app.test\")\n\tstatic class TestComponentScanClass {\n\t}\n\n\t@ConventionBasedSinglePackageComponentScan(basePackages = \"com.example.app.test\")\n\tstatic class ConventionBasedSinglePackageComponentScanClass {\n\t}\n\n\t@AliasForBasedSinglePackageComponentScan(pkg = \"com.example.app.test\")\n\tstatic class AliasForBasedSinglePackageComponentScanClass {\n\t}\n\n\t@SpringApplicationConfiguration(Number.class)\n\tstatic class SpringApplicationConfigurationClass {\n\t}\n\n\t@Resource(name = \"x\")\n\tstatic class ResourceHolder {\n\t}\n\n\tinterface TransactionalService {\n\n\t\t@Transactional\n\t\tvoid doIt();\n\t}\n\n\tclass TransactionalServiceImpl implements TransactionalService {\n\n\t\t@Override\n\t\tpublic void doIt() {\n\t\t}\n\t}\n\n\t@Component(\"meta1\")\n\t@Order\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Meta1 {\n\t}\n\n\t@Component(\"meta2\")\n\t@Transactional(readOnly = true)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Meta2 {\n\t}\n\n\t@Meta2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMeta {\n\t}\n\n\t@MetaMeta\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMetaMeta {\n\t}\n\n\t@MetaCycle3\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle1 {\n\t}\n\n\t@MetaCycle1\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle2 {\n\t}\n\n\t@MetaCycle2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle3 {\n\t}\n\n\t@Meta1\n\tinterface InterfaceWithMetaAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface\n\t\t\timplements InterfaceWithMetaAnnotation {\n\t}\n\n\t@Meta1\n\tstatic class ClassWithInheritedMetaAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class SubClassWithInheritedMetaAnnotation\n\t\t\textends ClassWithInheritedMetaAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedMetaAnnotation\n\t\t\textends SubClassWithInheritedMetaAnnotation {\n\t}\n\n\t@MetaMeta\n\tstatic class MetaMetaAnnotatedClass {\n\t}\n\n\t@MetaMetaMeta\n\tstatic class MetaMetaMetaAnnotatedClass {\n\t}\n\n\t@MetaCycle3\n\tstatic class MetaCycleAnnotatedClass {\n\t}\n\n\tinterface AnnotatedInterface {\n\n\t\t@Order(0)\n\t\tvoid fromInterfaceImplementedByRoot();\n\t}\n\n\tinterface NullableAnnotatedInterface {\n\n\t\t@Nullable String fromInterfaceImplementedByRoot();\n\t}\n\n\tstatic class Root implements AnnotatedInterface {\n\n\t\t@Order(27)\n\t\tpublic void annotatedOnRoot() {\n\t\t}\n\n\t\t@Meta1\n\t\tpublic void metaAnnotatedOnRoot() {\n\t\t}\n\n\t\tpublic void overrideToAnnotate() {\n\t\t}\n\n\t\t@Order(27)\n\t\tpublic void overrideWithoutNewAnnotation() {\n\t\t}\n\n\t\tpublic void notAnnotated() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void fromInterfaceImplementedByRoot() {\n\t\t}\n\t}\n\n\tpublic static class Leaf extends Root {\n\n\t\t@Order(25)\n\t\tpublic void annotatedOnLeaf() {\n\t\t}\n\n\t\t@Meta1\n\t\tpublic void metaAnnotatedOnLeaf() {\n\t\t}\n\n\t\t@MetaMeta\n\t\tpublic void metaMetaAnnotatedOnLeaf() {\n\t\t}\n\n\t\t@Override\n\t\t@Order(1)\n\t\tpublic void overrideToAnnotate() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void overrideWithoutNewAnnotation() {\n\t\t}\n\t}\n\n\tpublic abstract static class SimpleGeneric<T> {\n\n\t\t@Order(1)\n\t\tpublic abstract void something(T arg);\n\n\t}\n\n\tpublic static class TransactionalStringGeneric extends SimpleGeneric<String> {\n\n\t\t@Override\n\t\t@Transactional\n\t\tpublic void something(final String arg) {\n\t\t}\n\t}\n\n\t@Transactional\n\tpublic static class InheritedAnnotationClass {\n\t}\n\n\tpublic static class SubInheritedAnnotationClass extends InheritedAnnotationClass {\n\t}\n\n\t@Order\n\tpublic static class NonInheritedAnnotationClass {\n\t}\n\n\tpublic static class SubNonInheritedAnnotationClass\n\t\t\textends NonInheritedAnnotationClass {\n\t}\n\n\t@Transactional\n\tpublic static class TransactionalClass {\n\t}\n\n\t@Order\n\tpublic static class TransactionalAndOrderedClass extends TransactionalClass {\n\t}\n\n\tpublic static class SubTransactionalAndOrderedClass\n\t\t\textends TransactionalAndOrderedClass {\n\t}\n\n\tpublic interface InterfaceWithAnnotatedMethod {\n\n\t\t@Order\n\t\tvoid foo();\n\t}\n\n\tpublic static class ImplementsInterfaceWithAnnotatedMethod\n\t\t\timplements InterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic static class SubOfImplementsInterfaceWithAnnotatedMethod\n\t\t\textends ImplementsInterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic abstract static class AbstractDoesNotImplementInterfaceWithAnnotatedMethod\n\t\t\timplements InterfaceWithAnnotatedMethod {\n\t}\n\n\tpublic static class SubOfAbstractImplementsInterfaceWithAnnotatedMethod\n\t\t\textends AbstractDoesNotImplementInterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic interface InterfaceWithGenericAnnotatedMethod<T> {\n\n\t\t@Order\n\t\tvoid foo(T t);\n\t}\n\n\tpublic static class ImplementsInterfaceWithGenericAnnotatedMethod\n\t\t\timplements InterfaceWithGenericAnnotatedMethod<String> {\n\n\t\t@Override\n\t\tpublic void foo(String t) {\n\t\t}\n\t}\n\n\tpublic abstract static class BaseClassWithGenericAnnotatedMethod<T> {\n\n\t\t@Order\n\t\tabstract void foo(T t);\n\t}\n\n\tpublic static class ExtendsBaseClassWithGenericAnnotatedMethod\n\t\t\textends BaseClassWithGenericAnnotatedMethod<String> {\n\n\t\t@Override\n\t\tpublic void foo(String t) {\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface MyRepeatableContainer {\n\n\t\tMyRepeatable[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@Repeatable(MyRepeatableContainer.class)\n\t@interface MyRepeatable {\n\n\t\tString value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta1\")\n\t@interface MyRepeatableMeta1 {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta2\")\n\t@interface MyRepeatableMeta2 {\n\t}\n\n\tinterface InterfaceWithRepeated {\n\n\t\t@MyRepeatable(\"A\")\n\t\t@MyRepeatableContainer({ @MyRepeatable(\"B\"), @MyRepeatable(\"C\") })\n\t\t@MyRepeatableMeta1\n\t\tvoid foo();\n\t}\n\n\t@MyRepeatable(\"A\")\n\t@MyRepeatableContainer({ @MyRepeatable(\"B\"), @MyRepeatable(\"C\") })\n\t@MyRepeatableMeta1\n\tstatic class MyRepeatableClass {\n\t}\n\n\tstatic class SubMyRepeatableClass extends MyRepeatableClass {\n\t}\n\n\t@MyRepeatable(\"X\")\n\t@MyRepeatableContainer({ @MyRepeatable(\"Y\"), @MyRepeatable(\"Z\") })\n\t@MyRepeatableMeta2\n\tstatic class SubMyRepeatableWithAdditionalLocalDeclarationsClass\n\t\t\textends MyRepeatableClass {\n\t}\n\n\tstatic class SubSubMyRepeatableWithAdditionalLocalDeclarationsClass\n\t\t\textends SubMyRepeatableWithAdditionalLocalDeclarationsClass {\n\t}\n\n\tenum RequestMethod {\n\t\tGET,\n\n\t\tPOST;\n\n\t\t/**\n\t\t * custom override to verify annotation toString() implementations.\n\t\t */\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"method: \" + name().toLowerCase();\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface RequestMapping {\n\n\t\tString name();\n\n\t\t@AliasFor(\"path\")\n\t\tString[] value() default \"\";\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tString[] path() default \"\";\n\n\t\tRequestMethod[] method() default {};\n\n\t\t// ---------------------------------------------------------------------\n\t\t// All remaining attributes declare default values that are used solely\n\t\t// for the purpose of testing the toString() implementations for annotations.\n\t\tClass<?> clazz() default RequestMethod.class;\n\t\tClass<?>[] classes() default {int[][].class, RequestMethod[].class};\n\n\t\tchar ch() default 'X';\n\t\tchar[] chars() default {'X'};\n\n\t\tbyte byteValue() default (byte) 0xFF;\n\t\tbyte[] bytes() default {(byte) 0xFF};\n\n\t\tshort shortValue() default 9876;\n\t\tshort[] shorts() default {9876};\n\n\t\tlong longValue() default 42L;\n\t\tlong[] longs() default {42L};\n\n\t\tfloat floatValue() default 3.14F;\n\t\tfloat[] floats() default {3.14F};\n\n\t\tdouble doubleValue() default 99.999D;\n\t\tdouble[] doubles() default {99.999D};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@RequestMapping(method = RequestMethod.GET, name = \"\")\n\t@interface GetMapping {\n\n\t\t@AliasFor(annotation = RequestMapping.class)\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = RequestMapping.class)\n\t\tString path() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@RequestMapping(method = RequestMethod.POST, name = \"\")\n\t@interface PostMapping {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = RequestMapping.class)\n\t\tString path() default \"\";\n\t}\n\n\t@Component(\"webController\")\n\tstatic class WebController {\n\n\t\t@RequestMapping(value = \"/test\", name = \"foo\")\n\t\tpublic void handleMappedWithValueAttribute() {\n\t\t}\n\n\t\t@RequestMapping(path = \"/test\", name = \"bar\", method = { RequestMethod.GET,\n\t\t\tRequestMethod.POST })\n\t\tpublic void handleMappedWithPathAttribute() {\n\t\t}\n\n\t\t@GetMapping(\"/test\")\n\t\tpublic void getMappedWithValueAttribute() {\n\t\t}\n\n\t\t@GetMapping(path = \"/test\")\n\t\tpublic void getMappedWithPathAttribute() {\n\t\t}\n\n\t\t@PostMapping(path = \"/test\")\n\t\tpublic void postMappedWithPathAttribute() {\n\t\t}\n\n\t\t@RequestMapping(value = \"/test\", path = \"/test\", name = \"bar\", method = {\n\t\t\tRequestMethod.GET, RequestMethod.POST })\n\t\tpublic void handleMappedWithSamePathAndValueAttributes() {\n\t\t}\n\n\t\t@RequestMapping(value = \"/enigma\", path = \"/test\", name = \"baz\")\n\t\tpublic void handleMappedWithDifferentPathAndValueAttributes() {\n\t\t}\n\t}\n\n\t/**\n\t * Mimics jakarta.persistence.Id\n\t */\n\t@Retention(RUNTIME)\n\t@interface Id {\n\t}\n\n\t/**\n\t * Mimics jakarta.persistence.GeneratedValue\n\t */\n\t@Retention(RUNTIME)\n\t@interface GeneratedValue {\n\t\tString strategy();\n\t}\n\n\t@Id\n\t@GeneratedValue(strategy = \"AUTO\")\n\tprivate Long getId() {\n\t\treturn 42L;\n\t}\n\n\t/**\n\t * Mimics org.springframework.security.config.annotation.authentication.configuration.EnableGlobalAuthentication\n\t */\n\t@Retention(RUNTIME)\n\t@interface EnableGlobalAuthentication {\n\t}\n\n\t/**\n\t * Mimics org.springframework.security.config.annotation.web.configuration.EnableWebSecurity\n\t */\n\t@Retention(RUNTIME)\n\t@EnableGlobalAuthentication\n\t@interface EnableWebSecurity {\n\t}\n\n\t@EnableWebSecurity\n\tstatic class SecurityConfig {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ ElementType.FIELD, ElementType.ANNOTATION_TYPE })\n\t@interface RootAnnotation {\n\t\tString value() default \"\";\n\t\tboolean flag() default false;\n\t}\n\n\t@RootAnnotation\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ ElementType.FIELD, ElementType.ANNOTATION_TYPE })\n\t@interface ComposedRootAnnotation {\n\n\t\t@AliasFor(annotation = RootAnnotation.class, attribute = \"flag\")\n\t\tboolean enabled() default true;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.FIELD)\n\t@ComposedRootAnnotation\n\t@interface DoublyComposedRootAnnotation {\n\t}\n\n\tclass DomainType {\n\n\t\t@RootAnnotation\n\t\tObject directlyAnnotated;\n\n\t\t@ComposedRootAnnotation\n\t\tObject metaAnnotated;\n\n\t\t@DoublyComposedRootAnnotation\n\t\tObject metaMetaAnnotated;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestConfiguration {\n\n\t\t@AliasFor(\"location\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString location() default \"\";\n\n\t\tClass<?> configClass() default Object.class;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Hierarchy {\n\n\t\tTestConfiguration[] value();\n\t}\n\n\t@Hierarchy({ @TestConfiguration(\"A\"), @TestConfiguration(location = \"B\") })\n\tstatic class HierarchyClass {\n\t}\n\n\t@TestConfiguration(\"simple.xml\")\n\tstatic class TestConfigurationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface CharsContainer {\n\n\t\t@AliasFor(attribute = \"chars\")\n\t\tchar[] value() default {};\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tchar[] chars() default {};\n\t}\n\n\t@CharsContainer(chars = { 'x', 'y', 'z' })\n\tstatic class GroupOfCharsClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMissingAttributeDeclaration {\n\n\t\t@AliasFor\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForWithMissingAttributeDeclaration\n\tstatic class AliasForWithMissingAttributeDeclarationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithDuplicateAttributeDeclaration {\n\n\t\t@AliasFor(value = \"bar\", attribute = \"baz\")\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForWithDuplicateAttributeDeclaration\n\tstatic class AliasForWithDuplicateAttributeDeclarationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForNonexistentAttribute {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForNonexistentAttribute\n\tstatic class AliasForNonexistentAttributeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithoutMirroredAliasFor {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"\";\n\n\t\tString bar() default \"\";\n\t}\n\n\t@AliasForWithoutMirroredAliasFor\n\tstatic class AliasForWithoutMirroredAliasForClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMirroredAliasForWrongAttribute {\n\n\t\t@AliasFor(attribute = \"bar\")\n\t\tString[] foo() default \"\";\n\n\t\t@AliasFor(attribute = \"quux\")\n\t\tString[] bar() default \"\";\n\t}\n\n\t@AliasForWithMirroredAliasForWrongAttribute\n\tstatic class AliasForWithMirroredAliasForWrongAttributeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForAttributeOfDifferentType {\n\n\t\t@AliasFor(\"bar\")\n\t\tString[] foo() default \"\";\n\n\t\t@AliasFor(\"foo\")\n\t\tboolean bar() default true;\n\t}\n\n\t@AliasForAttributeOfDifferentType\n\tstatic class AliasForAttributeOfDifferentTypeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMissingDefaultValues {\n\n\t\t@AliasFor(attribute = \"bar\")\n\t\tString foo();\n\n\t\t@AliasFor(attribute = \"foo\")\n\t\tString bar();\n\t}\n\n\t@AliasForWithMissingDefaultValues(foo = \"foo\", bar = \"bar\")\n\tstatic class AliasForWithMissingDefaultValuesClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForAttributeWithDifferentDefaultValue {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"X\";\n\n\t\t@AliasFor(\"foo\")\n\t\tString bar() default \"Z\";\n\t}\n\n\t@AliasForAttributeWithDifferentDefaultValue\n\tstatic class AliasForAttributeWithDifferentDefaultValueClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedTestConfigurationNotMetaPresent {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlConfigFile();\n\t}\n\n\t@AliasedComposedTestConfigurationNotMetaPresent(xmlConfigFile = \"test.xml\")\n\tstatic class AliasedComposedTestConfigurationNotMetaPresentClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlConfigFile();\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface ImplicitAliasesTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString groovyScript() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location1() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location2() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location3() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"configClass\")\n\t\tClass<?> configClass() default Object.class;\n\n\t\tString nonAliasedAttribute() default \"\";\n\t}\n\n\t@ImplicitAliasesTestConfiguration(groovyScript = \"groovyScript\")\n\tstatic class GroovyImplicitAliasesSimpleTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(xmlFile = \"xmlFile\")\n\tstatic class XmlImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(\"value\")\n\tstatic class ValueImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(location1 = \"location1\")\n\tstatic class Location1ImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(location2 = \"location2\")\n\tstatic class Location2ImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(location3 = \"location3\")\n\tstatic class Location3ImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class)\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class)\n\t\tString location() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration.class, attribute = \"location\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration(\"value\")\n\tstatic class ValueImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration(location = \"location\")\n\tstatic class LocationsImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration(xmlFile = \"xmlFile\")\n\tstatic class XmlFilesImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithMissingDefaultValuesTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location1();\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location2();\n\t}\n\n\t@ImplicitAliasesWithMissingDefaultValuesTestConfiguration(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithMissingDefaultValuesTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithDifferentDefaultValuesTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location1() default \"foo\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location2() default \"bar\";\n\t}\n\n\t@ImplicitAliasesWithDifferentDefaultValuesTestConfiguration(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithDifferentDefaultValuesTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithDuplicateValuesTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location1() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location2() default \"\";\n\t}\n\n\t@ImplicitAliasesWithDuplicateValuesTestConfiguration(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithDuplicateValuesTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesForAliasPairTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, value = \"value\")\n\t\tString groovyScript() default \"\";\n\t}\n\n\t@ImplicitAliasesForAliasPairTestConfiguration(xmlFile = \"test.xml\")\n\tstatic class ImplicitAliasesForAliasPairTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesTestConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesTestConfiguration.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesTestConfiguration.class, attribute = \"groovyScript\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@TransitiveImplicitAliasesTestConfiguration(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesForAliasPairTestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesForAliasPairTestConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesForAliasPairTestConfiguration.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesForAliasPairTestConfiguration.class, attribute = \"groovyScript\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@TransitiveImplicitAliasesForAliasPairTestConfiguration(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesForAliasPairTestConfigurationClass {\n\t}\n\n\t@ComponentScan(excludeFilters = { @Filter(pattern = \"*Foo\"),\n\t\t@Filter(pattern = \"*Bar\") })\n\tstatic class ComponentScanClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScanSingleFilter {\n\n\t\tFilter value();\n\t}\n\n\t@ComponentScanSingleFilter(@Filter(pattern = \"*Foo\"))\n\tstatic class ComponentScanSingleFilterClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnotationWithDefaults {\n\n\t\tString text() default \"enigma\";\n\n\t\tboolean predicate() default true;\n\n\t\tchar[] characters() default { 'a', 'b', 'c' };\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnotationWithoutDefaults {\n\n\t\tString text();\n\t}\n\n\t@TestConfiguration(value = \"foo\", location = \"bar\")\n\tinterface TestConfigurationMismatch {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface DefaultOverrideRoot {\n\n\t\tString text() default \"root\";\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideRoot\n\t@interface DefaultOverrideMeta {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideMeta\n\t@interface DefaultOverrideMetaMeta {\n\n\t\tString text() default \"metameta\";\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideMetaMeta\n\t@interface DefaultOverrideMetaMetaMeta {\n\n\t}\n\n\t@DefaultOverrideMetaMetaMeta\n\tstatic class DefaultOverrideClass {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideRoot\n\t@interface DefaultOverrideImplicitAlias {\n\n\t\t@AliasFor(annotation=DefaultOverrideRoot.class, attribute=\"text\")\n\t\tString text1() default \"alias\";\n\n\t\t@AliasFor(annotation=DefaultOverrideRoot.class, attribute=\"text\")\n\t\tString text2() default \"alias\";\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideImplicitAlias(text1=\"alias-meta-1\")\n\t@interface DefaultOverrideAliasImplicitMeta1 {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideImplicitAlias(text2=\"alias-meta-2\")\n\t@interface DefaultOverrideImplicitAliasMeta2 {\n\n\t}\n\n\t@DefaultOverrideAliasImplicitMeta1\n\tstatic class DefaultOverrideImplicitAliasMetaClass1 {\n\n\t}\n\n\t@DefaultOverrideImplicitAliasMeta2\n\tstatic class DefaultOverrideImplicitAliasMetaClass2 {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface DefaultOverrideExplicitAliasRoot {\n\n\t\t@AliasFor(\"value\")\n\t\tString text() default \"\";\n\n\t\t@AliasFor(\"text\")\n\t\tString value() default \"\";\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideExplicitAliasRoot(\"meta\")\n\t@interface DefaultOverrideExplicitAliasRootMeta {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideExplicitAliasRootMeta\n\t@interface DefaultOverrideExplicitAliasRootMetaMeta {\n\n\t}\n\n\t@DefaultOverrideExplicitAliasRootMetaMeta\n\tstatic class DefaultOverrideExplicitAliasRootMetaMetaClass {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ValueAttribute {\n\n\t\tString[] value();\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueAttribute(\"FromValueAttributeMeta\")\n\t@interface ValueAttributeMeta {\n\n\t\tString[] value() default {};\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueAttributeMeta(\"FromValueAttributeMetaMeta\")\n\t@interface ValueAttributeMetaMeta {\n\n\t}\n\n\t@ValueAttributeMetaMeta\n\tstatic class ValueAttributeMetaMetaClass {\n\n\t}\n\t// @formatter:on\n\n\tstatic void assertSynthesized(Annotation annotation) {\n\t\tassertThat(AnnotationUtils.isSynthesizedAnnotation(annotation)).as(\"synthesized annotation\").isTrue();\n\t}\n\n\tstatic void assertNotSynthesized(Annotation annotation) {\n\t\tassertThat(AnnotationUtils.isSynthesizedAnnotation(annotation)).as(\"synthesized annotation\").isFalse();\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.ImplicitAliasesContextConfigurationClass3",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.annotation.ImplicitAliasesContextConfigurationClass3",
    "headType": "class",
    "relation": "use",
    "tail": "@ImplicitAliasesContextConfiguration",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.annotation.ImplicitAliasesContextConfigurationClass3",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.stream.Stream;\n\nimport jakarta.annotation.Resource;\nimport org.jspecify.annotations.Nullable;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.AnnotationsScannerTests.Hello2Impl;\nimport org.springframework.core.annotation.AnnotationsScannerTests.TestAnnotation1;\nimport org.springframework.core.annotation.MergedAnnotation.Adapt;\nimport org.springframework.core.annotation.MergedAnnotations.Search;\nimport org.springframework.core.annotation.MergedAnnotations.SearchStrategy;\nimport org.springframework.core.annotation.subpackage.NonPublicAnnotatedClass;\nimport org.springframework.core.testfixture.ide.IdeUtils;\nimport org.springframework.core.testfixture.stereotype.Component;\nimport org.springframework.core.testfixture.stereotype.Indexed;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.MultiValueMap;\nimport org.springframework.util.ReflectionUtils;\n\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.assertj.core.api.Assertions.assertThatIllegalStateException;\nimport static org.assertj.core.api.Assertions.entry;\n\n/**\n * Tests for {@link MergedAnnotations} and {@link MergedAnnotation}. These tests\n * cover common usage scenarios and were mainly ported from the original\n * {@code AnnotationUtils} and {@code AnnotatedElementUtils} tests.\n *\n * @author Phillip Webb\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Chris Beams\n * @author Oleg Zhurakousky\n * @author Rossen Stoyanchev\n * @see MergedAnnotationsRepeatableAnnotationTests\n * @see MergedAnnotationClassLoaderTests\n */\nclass MergedAnnotationsTests {\n\n\t/**\n\t * Subset (and duplication) of other tests in {@link MergedAnnotationsTests}\n\t * that verify behavior of the fluent {@link Search} API.\n\t * @since 6.0\n\t */\n\t@Nested\n\tclass FluentSearchApiTests {\n\n\t\t@Test\n\t\tvoid preconditions() {\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> MergedAnnotations.search(null))\n\t\t\t\t\t.withMessage(\"SearchStrategy must not be null\");\n\n\t\t\tSearch search = MergedAnnotations.search(SearchStrategy.SUPERCLASS);\n\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> search.withEnclosingClasses(null))\n\t\t\t\t\t.withMessage(\"Predicate must not be null\");\n\t\t\tassertThatIllegalStateException()\n\t\t\t\t\t.isThrownBy(() -> search.withEnclosingClasses(Search.always))\n\t\t\t\t\t.withMessage(\"A custom 'searchEnclosingClass' predicate can only be combined with SearchStrategy.TYPE_HIERARCHY\");\n\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> search.withAnnotationFilter(null))\n\t\t\t\t\t.withMessage(\"AnnotationFilter must not be null\");\n\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> search.withRepeatableContainers(null))\n\t\t\t\t\t.withMessage(\"RepeatableContainers must not be null\");\n\n\t\t\tassertThatIllegalArgumentException()\n\t\t\t\t\t.isThrownBy(() -> search.from(null))\n\t\t\t\t\t.withMessage(\"AnnotatedElement must not be null\");\n\t\t}\n\n\t\t@Test\n\t\tvoid searchFromClassWithDefaultAnnotationFilterAndDefaultRepeatableContainers() {\n\t\t\tStream<Class<?>> classes = MergedAnnotations.search(SearchStrategy.DIRECT)\n\t\t\t\t\t.from(TransactionalComponent.class)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Transactional.class, Component.class, Indexed.class);\n\t\t}\n\n\t\t@Test\n\t\tvoid searchFromClassWithCustomAnnotationFilter() {\n\t\t\tStream<Class<?>> classes = MergedAnnotations.search(SearchStrategy.DIRECT)\n\t\t\t\t\t.withAnnotationFilter(annotationName -> annotationName.endsWith(\"Indexed\"))\n\t\t\t\t\t.from(TransactionalComponent.class)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Transactional.class, Component.class);\n\t\t}\n\n\t\t@Test\n\t\tvoid searchFromClassWithCustomRepeatableContainers() {\n\t\t\tassertThat(MergedAnnotations.from(HierarchyClass.class).stream(TestConfiguration.class)).isEmpty();\n\t\t\tRepeatableContainers containers = RepeatableContainers.of(TestConfiguration.class, Hierarchy.class);\n\n\t\t\tMergedAnnotations annotations = MergedAnnotations.search(SearchStrategy.DIRECT)\n\t\t\t\t\t.withRepeatableContainers(containers)\n\t\t\t\t\t.from(HierarchyClass.class);\n\t\t\tassertThat(annotations.stream(TestConfiguration.class))\n\t\t\t\t\t.map(annotation -> annotation.getString(\"location\"))\n\t\t\t\t\t.containsExactly(\"A\", \"B\");\n\t\t\tassertThat(annotations.stream(TestConfiguration.class))\n\t\t\t\t\t.map(annotation -> annotation.getString(\"value\"))\n\t\t\t\t\t.containsExactly(\"A\", \"B\");\n\t\t}\n\n\t\t/**\n\t\t * @since 6.0\n\t\t */\n\t\t@Test\n\t\tvoid searchFromNonAnnotatedInnerClassWithAnnotatedEnclosingClassWithEnclosingClassPredicates() {\n\t\t\tClass<?> testCase = AnnotatedClass.NonAnnotatedInnerClass.class;\n\t\t\tSearch search = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY);\n\n\t\t\tassertThat(search.from(testCase).stream()).isEmpty();\n\t\t\tassertThat(search.withEnclosingClasses(Search.never).from(testCase).stream()).isEmpty();\n\t\t\tassertThat(search.withEnclosingClasses(ClassUtils::isStaticClass).from(testCase).stream()).isEmpty();\n\n\t\t\tStream<Class<?>> classes = search.withEnclosingClasses(ClassUtils::isInnerClass)\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class, Indexed.class);\n\n\t\t\tclasses = search.withEnclosingClasses(Search.always)\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class, Indexed.class);\n\n\t\t\tclasses = search.withEnclosingClasses(ClassUtils::isInnerClass)\n\t\t\t\t\t.withRepeatableContainers(RepeatableContainers.none())\n\t\t\t\t\t.withAnnotationFilter(annotationName -> annotationName.endsWith(\"Indexed\"))\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class);\n\t\t}\n\n\t\t/**\n\t\t * @since 6.0\n\t\t */\n\t\t@Test\n\t\tvoid searchFromNonAnnotatedStaticNestedClassWithAnnotatedEnclosingClassWithEnclosingClassPredicates() {\n\t\t\tClass<?> testCase = AnnotatedClass.NonAnnotatedStaticNestedClass.class;\n\t\t\tSearch search = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY);\n\n\t\t\tassertThat(search.from(testCase).stream()).isEmpty();\n\t\t\tassertThat(search.withEnclosingClasses(Search.never).from(testCase).stream()).isEmpty();\n\t\t\tassertThat(search.withEnclosingClasses(ClassUtils::isInnerClass).from(testCase).stream()).isEmpty();\n\n\t\t\tStream<Class<?>> classes = search.withEnclosingClasses(ClassUtils::isStaticClass)\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class, Indexed.class);\n\n\t\t\tclasses = search.withEnclosingClasses(Search.always)\n\t\t\t\t\t.from(testCase)\n\t\t\t\t\t.stream()\n\t\t\t\t\t.map(MergedAnnotation::getType);\n\t\t\tassertThat(classes).containsExactly(Component.class, Indexed.class);\n\t\t}\n\t}\n\n\n\t@Nested\n\tclass ConventionBasedAnnotationAttributeOverrideTests {\n\n\t\t@Test\n\t\tvoid getWithInheritedAnnotationsAttributesWithConventionBasedComposedAnnotation() {\n\t\t\tMergedAnnotation<?> annotation =\n\t\t\t\t\tMergedAnnotations.from(ConventionBasedComposedContextConfigurationClass.class,\n\t\t\t\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\t\tassertThat(annotation.isPresent()).isTrue();\n\t\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"explicitDeclaration\");\n\t\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"explicitDeclaration\");\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithInheritedAnnotationsFromHalfConventionBasedAndHalfAliasedComposedAnnotation1() {\n\t\t\t// SPR-13554: convention mapping mixed with AliasFor annotations\n\t\t\t// xmlConfigFiles can be used because it has an AliasFor annotation\n\t\t\tMergedAnnotation<?> annotation =\n\t\t\t\t\tMergedAnnotations.from(HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass1.class,\n\t\t\t\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"explicitDeclaration\");\n\t\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"explicitDeclaration\");\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithInheritedAnnotationsFromHalfConventionBasedAndHalfAliasedComposedAnnotation2() {\n\t\t\t// SPR-13554: convention mapping mixed with AliasFor annotations\n\t\t\t// locations doesn't apply because it has no AliasFor annotation\n\t\t\tMergedAnnotation<?> annotation =\n\t\t\t\t\tMergedAnnotations.from(HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass2.class,\n\t\t\t\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\t\tassertThat(annotation.getStringArray(\"locations\")).isEmpty();\n\t\t\tassertThat(annotation.getStringArray(\"value\")).isEmpty();\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithInheritedAnnotationsFromInvalidConventionBasedComposedAnnotation() {\n\t\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(InvalidConventionBasedComposedContextConfigurationClass.class,\n\t\t\t\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class));\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithTypeHierarchyWithSingleElementOverridingAnArrayViaConvention() {\n\t\t\ttestGetWithTypeHierarchy(ConventionBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithTypeHierarchyWithLocalAliasesThatConflictWithAttributesInMetaAnnotationByConvention() {\n\t\t\tMergedAnnotation<?> annotation =\n\t\t\t\t\tMergedAnnotations.from(SpringApplicationConfigurationClass.class, SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t\t\t\t.get(ContextConfiguration.class);\n\t\t\tassertThat(annotation.getStringArray(\"locations\")).isEmpty();\n\t\t\tassertThat(annotation.getStringArray(\"value\")).isEmpty();\n\t\t\tassertThat(annotation.getClassArray(\"classes\")).containsExactly(Number.class);\n\t\t}\n\n\t\t@Test\n\t\tvoid getWithTypeHierarchyOnMethodWithSingleElementOverridingAnArrayViaConvention() throws Exception {\n\t\t\ttestGetWithTypeHierarchyWebMapping(WebController.class.getMethod(\"postMappedWithPathAttribute\"));\n\t\t}\n\t}\n\n\n\t@Test\n\tvoid fromPreconditions() {\n\t\tSearchStrategy strategy = SearchStrategy.DIRECT;\n\t\tRepeatableContainers containers = RepeatableContainers.standardRepeatables();\n\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(getClass(), strategy, null, AnnotationFilter.PLAIN))\n\t\t\t\t.withMessage(\"RepeatableContainers must not be null\");\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(getClass(), strategy, containers, null))\n\t\t\t\t.withMessage(\"AnnotationFilter must not be null\");\n\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(getClass(), new Annotation[0], null, AnnotationFilter.PLAIN))\n\t\t\t\t.withMessage(\"RepeatableContainers must not be null\");\n\t\tassertThatIllegalArgumentException()\n\t\t\t\t.isThrownBy(() -> MergedAnnotations.from(getClass(), new Annotation[0], containers, null))\n\t\t\t\t.withMessage(\"AnnotationFilter must not be null\");\n\t}\n\n\t@Test\n\tvoid streamWhenFromNonAnnotatedClass() {\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class).stream(TransactionalComponent.class)).isEmpty();\n\t}\n\n\t@Test\n\tvoid streamWhenFromClassWithMetaDepth1() {\n\t\tStream<Class<?>> classes = MergedAnnotations.from(TransactionalComponent.class)\n\t\t\t\t.stream().map(MergedAnnotation::getType);\n\t\tassertThat(classes).containsExactly(Transactional.class, Component.class, Indexed.class);\n\t}\n\n\t@Test\n\tvoid streamWhenFromClassWithMetaDepth2() {\n\t\tStream<Class<?>> classes = MergedAnnotations.from(ComposedTransactionalComponent.class)\n\t\t\t\t.stream().map(MergedAnnotation::getType);\n\t\tassertThat(classes).containsExactly(TransactionalComponent.class,\n\t\t\t\tTransactional.class, Component.class, Indexed.class);\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromNonAnnotatedClass() {\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class).isPresent(Transactional.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromAnnotationClassWithMetaDepth0() {\n\t\tassertThat(MergedAnnotations.from(TransactionalComponent.class).isPresent(TransactionalComponent.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromAnnotationClassWithMetaDepth1() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(TransactionalComponent.class);\n\t\tassertThat(annotations.isPresent(Transactional.class)).isTrue();\n\t\tassertThat(annotations.isPresent(Component.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromAnnotationClassWithMetaDepth2() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponent.class);\n\t\tassertThat(annotations.isPresent(Transactional.class)).isTrue();\n\t\tassertThat(annotations.isPresent(Component.class)).isTrue();\n\t\tassertThat(annotations.isPresent(ComposedTransactionalComponent.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromClassWithMetaDepth0() {\n\t\tassertThat(MergedAnnotations.from(TransactionalComponentClass.class).isPresent(TransactionalComponent.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromSubclassWithMetaDepth0() {\n\t\tassertThat(MergedAnnotations.from(SubTransactionalComponentClass.class).isPresent(TransactionalComponent.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromClassWithMetaDepth1() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(TransactionalComponentClass.class);\n\t\tassertThat(annotations.isPresent(Transactional.class)).isTrue();\n\t\tassertThat(annotations.isPresent(Component.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid isPresentWhenFromClassWithMetaDepth2() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\n\t\tassertThat(annotations.isPresent(Transactional.class)).isTrue();\n\t\tassertThat(annotations.isPresent(Component.class)).isTrue();\n\t\tassertThat(annotations.isPresent(ComposedTransactionalComponent.class)).isTrue();\n\t}\n\n\t@Test\n\tvoid getParent() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\n\t\tassertThat(annotations.get(TransactionalComponent.class).getMetaSource().getType())\n\t\t\t\t.isEqualTo(ComposedTransactionalComponent.class);\n\t}\n\n\t@Test\n\tvoid getRootWhenNotDirect() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\n\t\tMergedAnnotation<?> annotation = annotations.get(TransactionalComponent.class);\n\t\tassertThat(annotation.getDistance()).isGreaterThan(0);\n\t\tassertThat(annotation.getRoot().getType()).isEqualTo(ComposedTransactionalComponent.class);\n\t}\n\n\t@Test\n\tvoid getRootWhenDirect() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\n\t\tMergedAnnotation<?> annotation = annotations.get(ComposedTransactionalComponent.class);\n\t\tassertThat(annotation.getDistance()).isEqualTo(0);\n\t\tassertThat(annotation.getRoot()).isSameAs(annotation);\n\t}\n\n\t@Test\n\tvoid getMetaTypes() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(ComposedTransactionalComponentClass.class)\n\t\t\t\t.get(TransactionalComponent.class);\n\t\tassertThat(annotation.getMetaTypes()).containsExactly(\n\t\t\t\tComposedTransactionalComponent.class, TransactionalComponent.class);\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFromNonAnnotatedClass() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(NonAnnotatedClass.class)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).isEmpty();\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFromClassWithLocalAnnotation() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(TxConfig.class)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"value\", List.of(\"TxConfig\")));\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFromClassWithLocalComposedAnnotationAndInheritedAnnotation() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"qualifier\", List.of(\"composed2\", \"transactionManager\")));\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"qualifier\", List.of(\"transactionManager\")));\n\t}\n\n\t@Test\n\tvoid collectMultiValueMapFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedComposedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"qualifier\", List.of(\"composed1\")));\n\t}\n\n\t/**\n\t * If the \"value\" entry contains both \"DerivedTxConfig\" AND \"TxConfig\", then\n\t * the algorithm is accidentally picking up shadowed annotations of the same\n\t * type within the class hierarchy. Such undesirable behavior would cause\n\t * the logic in\n\t * {@code org.springframework.context.annotation.ProfileCondition} to fail.\n\t */\n\t@Test\n\tvoid collectMultiValueMapFromClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tDerivedTxConfig.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"value\", List.of(\"DerivedTxConfig\")));\n\t}\n\n\t/**\n\t * Note: this functionality is required by\n\t * {@code org.springframework.context.annotation.ProfileCondition}.\n\t */\n\t@Test\n\tvoid collectMultiValueMapFromClassWithMultipleComposedAnnotations() {\n\t\tMultiValueMap<String, Object> map = MergedAnnotations.from(\n\t\t\t\tTxFromMultipleComposedAnnotations.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\n\t\tassertThat(map).contains(entry(\"value\", List.of(\"TxInheritedComposed\", \"TxComposed\")));\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromClassWithLocalAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tTxConfig.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"TxConfig\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tDerivedTxConfig.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"DerivedTxConfig\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaCycleAnnotatedClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isFalse();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFavorsLocalComposedAnnotationOverInheritedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getBoolean(\"readOnly\")).isTrue();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getBoolean(\"readOnly\")).isFalse();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedComposedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.getBoolean(\"readOnly\")).isFalse();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromInterfaceImplementedBySuperclass() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tConcreteClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isFalse();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tInheritedAnnotationInterface.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationInterface.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t}\n\n\n\t@Test\n\tvoid withInheritedAnnotationsFromAliasedComposedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tAliasedComposedContextConfigurationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"test.xml\");\n\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid withInheritedAnnotationsFromAliasedValueComposedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tAliasedValueComposedContextConfigurationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"test.xml\");\n\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromImplicitAliasesInMetaAnnotationOnComposedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tComposedImplicitAliasesContextConfigurationClass.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.get(ImplicitAliasesContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"groovyScripts\")).containsExactly(\"A.xml\", \"B.xml\");\n\t\tassertThat(annotation.getStringArray(\"xmlFiles\")).containsExactly(\"A.xml\", \"B.xml\");\n\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"A.xml\", \"B.xml\");\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"A.xml\", \"B.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromAliasedValueComposedAnnotation() {\n\t\ttestGetWithInherited(AliasedValueComposedContextConfigurationClass.class, \"test.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromImplicitAliasesForSameAttributeInComposedAnnotation() {\n\t\ttestGetWithInherited(ImplicitAliasesContextConfigurationClass1.class, \"foo.xml\");\n\t\ttestGetWithInherited(ImplicitAliasesContextConfigurationClass2.class, \"bar.xml\");\n\t\ttestGetWithInherited(ImplicitAliasesContextConfigurationClass3.class, \"baz.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromTransitiveImplicitAliases() {\n\t\ttestGetWithInherited(TransitiveImplicitAliasesContextConfigurationClass.class, \"test.groovy\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\ttestGetWithInherited(\n\t\t\t\tSingleLocationTransitiveImplicitAliasesContextConfigurationClass.class, \"test.groovy\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSkippedLevel() {\n\t\ttestGetWithInherited(\n\t\t\t\tTransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass.class, \"test.xml\");\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSkippedLevelWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\ttestGetWithInherited(\n\t\t\t\tSingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass.class, \"test.xml\");\n\t}\n\n\tprivate void testGetWithInherited(Class<?> element, String... expected) {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(element, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.get(ContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"locations\")).isEqualTo(expected);\n\t\tassertThat(annotation.getStringArray(\"value\")).isEqualTo(expected);\n\t\tassertThat(annotation.getClassArray(\"classes\")).isEmpty();\n\t}\n\n\t@Test\n\tvoid getWithInheritedAnnotationsFromShadowedAliasComposedAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tShadowedAliasComposedContextConfigurationClass.class, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.get(ContextConfiguration.class);\n\t\tassertThat(annotation.getStringArray(\"locations\")).containsExactly(\"test.xml\");\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromSubInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromSubSubInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromSubNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromSubSubNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyInheritedFromInterfaceMethod() throws Exception {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleFromInterface\");\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test  // gh-31803\n\tvoid streamWithTypeHierarchyInheritedFromSuperInterfaceMethod() throws Exception {\n\t\tMethod method = Hello2Impl.class.getMethod(\"method\");\n\t\tlong count = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.from(method).stream(TestAnnotation1.class).count();\n\t\tassertThat(count).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyInheritedFromAbstractMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handle\");\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyInheritedFromBridgedMethod() throws NoSuchMethodException {\n\t\tMethod method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleParameterized\", String.class);\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromBridgeMethod() {\n\t\tList<Method> methods = new ArrayList<>();\n\t\tReflectionUtils.doWithLocalMethods(StringGenericParameter.class, method -> {\n\t\t\tif (\"getFor\".equals(method.getName())) {\n\t\t\t\tmethods.add(method);\n\t\t\t}\n\t\t});\n\t\tMethod bridgeMethod = methods.get(0).getReturnType().equals(Object.class) ?\n\t\t\t\tmethods.get(0) : methods.get(1);\n\t\tMethod bridgedMethod = methods.get(0).getReturnType().equals(Object.class) ?\n\t\t\t\tmethods.get(1) : methods.get(0);\n\t\tassertThat(bridgeMethod.isBridge()).isTrue();\n\t\tassertThat(bridgedMethod.isBridge()).isFalse();\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(bridgeMethod,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.isPresent()).isTrue();\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromClassWithMetaAndLocalTxConfig() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaAndLocalTxConfigClass.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getString(\"qualifier\")).isEqualTo(\"localTxMgr\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromClassWithAttributeAliasesInTargetAnnotation() {\n\t\tMergedAnnotation<AliasedTransactional> mergedAnnotation = MergedAnnotations.from(\n\t\t\t\tAliasedTransactionalComponentClass.class, SearchStrategy.TYPE_HIERARCHY).get(AliasedTransactional.class);\n\t\tAliasedTransactional synthesizedAnnotation = mergedAnnotation.synthesize();\n\t\tString qualifier = \"aliasForQualifier\";\n\t\tassertThat(mergedAnnotation.getString(\"value\")).isEqualTo(qualifier);\n\t\tassertThat(mergedAnnotation.getString(\"qualifier\")).isEqualTo(qualifier);\n\t\tassertThat(synthesizedAnnotation.value()).isEqualTo(qualifier);\n\t\tassertThat(synthesizedAnnotation.qualifier()).isEqualTo(qualifier);\n\t}\n\n\t@Test // gh-23767\n\tvoid getWithTypeHierarchyFromClassWithComposedMetaTransactionalAnnotation() {\n\t\tMergedAnnotation<AliasedTransactional> mergedAnnotation = MergedAnnotations.from(\n\t\t\t\tComposedTransactionalClass.class, SearchStrategy.TYPE_HIERARCHY).get(AliasedTransactional.class);\n\t\tassertThat(mergedAnnotation.getString(\"value\")).isEqualTo(\"anotherTransactionManager\");\n\t\tassertThat(mergedAnnotation.getString(\"qualifier\")).isEqualTo(\"anotherTransactionManager\");\n\t}\n\n\t@Test // gh-23767\n\tvoid getWithTypeHierarchyFromClassWithMetaMetaAliasedTransactional() {\n\t\tMergedAnnotation<AliasedTransactional> mergedAnnotation = MergedAnnotations.from(\n\t\t\t\tMetaMetaAliasedTransactionalClass.class, SearchStrategy.TYPE_HIERARCHY).get(AliasedTransactional.class);\n\t\tassertThat(mergedAnnotation.getString(\"value\")).isEqualTo(\"meta\");\n\t\tassertThat(mergedAnnotation.getString(\"qualifier\")).isEqualTo(\"meta\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromClassWithAttributeAliasInComposedAnnotationAndNestedAnnotationsInTargetAnnotation() {\n\t\tMergedAnnotation<?> annotation = testGetWithTypeHierarchy(\n\t\t\t\tTestComponentScanClass.class, \"com.example.app.test\");\n\t\tMergedAnnotation<Filter>[] excludeFilters = annotation.getAnnotationArray(\n\t\t\t\t\"excludeFilters\", Filter.class);\n\t\tassertThat(Arrays.stream(excludeFilters).map(\n\t\t\t\tfilter -> filter.getString(\"pattern\"))).containsExactly(\"*Test\", \"*Tests\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyFromClassWithBothAttributesOfAnAliasPairDeclared() {\n\t\ttestGetWithTypeHierarchy(ComponentScanWithBasePackagesAndValueAliasClass.class, \"com.example.app.test\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyWithSingleElementOverridingAnArrayViaAliasFor() {\n\t\ttestGetWithTypeHierarchy(AliasForBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\n\t}\n\n\tprivate MergedAnnotation<?> testGetWithTypeHierarchy(Class<?> element, String... expected) {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(element,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(ComponentScan.class);\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(expected);\n\t\tassertThat(annotation.getStringArray(\"basePackages\")).containsExactly(expected);\n\t\treturn annotation;\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyWhenMultipleMetaAnnotationsHaveClashingAttributeNames() {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(\n\t\t\t\tAliasedComposedContextConfigurationAndTestPropertySourceClass.class, SearchStrategy.TYPE_HIERARCHY);\n\t\tMergedAnnotation<?> contextConfig = annotations.get(ContextConfiguration.class);\n\t\tassertThat(contextConfig.getStringArray(\"locations\")).containsExactly(\"test.xml\");\n\t\tassertThat(contextConfig.getStringArray(\"value\")).containsExactly(\"test.xml\");\n\t\tMergedAnnotation<?> testPropSource = annotations.get(TestPropertySource.class);\n\t\tassertThat(testPropSource.getStringArray(\"locations\")).containsExactly(\"test.properties\");\n\t\tassertThat(testPropSource.getStringArray(\"value\")).containsExactly(\"test.properties\");\n\t}\n\n\t@Test\n\tvoid getWithTypeHierarchyOnMethodWithSingleElementOverridingAnArrayViaAliasFor() throws Exception {\n\t\ttestGetWithTypeHierarchyWebMapping(WebController.class.getMethod(\"getMappedWithValueAttribute\"));\n\t\ttestGetWithTypeHierarchyWebMapping(WebController.class.getMethod(\"getMappedWithPathAttribute\"));\n\t}\n\n\tprivate void testGetWithTypeHierarchyWebMapping(AnnotatedElement element) {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.get(RequestMapping.class);\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"/test\");\n\t\tassertThat(annotation.getStringArray(\"path\")).containsExactly(\"/test\");\n\t}\n\n\t@Test\n\tvoid getDirectWithJavaxAnnotationType() {\n\t\tassertThat(MergedAnnotations.from(ResourceHolder.class).get(Resource.class)\n\t\t\t\t.getString(\"name\")).isEqualTo(\"x\");\n\t}\n\n\t@Test\n\tvoid streamInheritedFromClassWithInterface() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.INHERITED_ANNOTATIONS)\n\t\t\t\t.stream(Transactional.class)).isEmpty();\n\t}\n\n\t@Test\n\tvoid streamTypeHierarchyFromClassWithInterface() throws Exception {\n\t\tMethod method = TransactionalServiceImpl.class.getMethod(\"doIt\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t.stream(Transactional.class)).hasSize(1);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithMethodAnnotationOnLeaf() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"annotatedOnLeaf\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNotNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class)\n\t\t\t\t.getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithAnnotationOnMethodInInterface() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"fromInterfaceImplementedByRoot\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class)\n\t\t\t\t.getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithMetaAnnotationOnLeaf() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"metaAnnotatedOnLeaf\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class)\n\t\t\t\t.getDistance()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithMetaMetaAnnotationOnLeaf() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"metaMetaAnnotatedOnLeaf\");\n\t\tassertThat(method.getAnnotation(Component.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Component.class).getDistance()).isEqualTo(2);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tComponent.class).getDistance()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getWithAnnotationOnRoot() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"annotatedOnRoot\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNotNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithMetaAnnotationOnRoot() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"metaAnnotatedOnRoot\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithOnRootButOverridden() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"overrideWithoutNewAnnotation\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithNotAnnotated() throws Exception {\n\t\tMethod method = Leaf.class.getMethod(\"notAnnotated\");\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(-1);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithBridgeMethod() throws Exception {\n\t\tMethod method = TransactionalStringGeneric.class.getMethod(\"something\", Object.class);\n\t\tassertThat(method.isBridge()).isTrue();\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t\t// As of JDK 8, invoking getAnnotation() on a bridge method actually finds an\n\t\t// annotation on its 'bridged' method [1]; however, the Eclipse compiler does\n\t\t// not support this [2]. Thus, we effectively ignore the following\n\t\t// assertion if the test is currently executing within the Eclipse IDE.\n\t\t//\n\t\t// [1] https://bugs.openjdk.java.net/browse/JDK-6695379\n\t\t// [2] https://bugs.eclipse.org/bugs/show_bug.cgi?id=495396\n\t\t//\n\t\tif (!IdeUtils.runningInEclipse()) {\n\t\t\tassertThat(method.getAnnotation(Transactional.class)).isNotNull();\n\t\t}\n\t\tassertThat(MergedAnnotations.from(method).get(\n\t\t\t\tTransactional.class).getDistance()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tTransactional.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithBridgedMethod() throws Exception {\n\t\tMethod method = TransactionalStringGeneric.class.getMethod(\"something\", String.class);\n\t\tassertThat(method.isBridge()).isFalse();\n\t\tassertThat(method.getAnnotation(Order.class)).isNull();\n\t\tassertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t\tassertThat(method.getAnnotation(Transactional.class)).isNotNull();\n\t\tassertThat(MergedAnnotations.from(method).get(\n\t\t\t\tTransactional.class).getDistance()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tTransactional.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test // SPR-16060\n\tvoid getFromMethodWithGenericInterface() throws Exception {\n\t\tMethod method = ImplementsInterfaceWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test // SPR-17146\n\tvoid getFromMethodWithGenericSuperclass() throws Exception {\n\t\tMethod method = ExtendsBaseClassWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWithInterfaceOnSuper() throws Exception {\n\t\tMethod method = SubOfImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getFromMethodWhenInterfaceWhenSuperDoesNotImplementMethod() throws Exception {\n\t\tMethod method = SubOfAbstractImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\n\t\tassertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(\n\t\t\t\tOrder.class).getDistance()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverAnnotationsOnInterfaces() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tClassWithLocalMetaAnnotationAndMetaAnnotatedInterface.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedAnnotation.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getBoolean(\"readOnly\")).isTrue();\n\t}\n\n\t@Test\n\tvoid getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedComposedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubClassWithInheritedMetaAnnotation.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid getDirectFromClassgetDirectFromClassMetaMetaAnnotatedClass() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaMetaAnnotatedClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithMetaMetaMetaAnnotatedClass() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaMetaMetaAnnotatedClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\t// TransactionalClass is NOT annotated or meta-annotated with @Component\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(TransactionalClass.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.isPresent()).isFalse();\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tMetaCycleAnnotatedClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\n\t\tassertThat(annotation.isPresent()).isFalse();\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithSubInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithSubSubInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(0);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithSubNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getDirectFromClassWithSubSubNonInheritedAnnotationInterface() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(\n\t\t\t\tSubSubNonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getAggregateIndex()).isEqualTo(2);\n\t}\n\n\t@Test\n\tvoid getSuperClassForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isNull();\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isNull();\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isEqualTo(\n\t\t\t\t\t\t\t\tInheritedAnnotationInterface.class);\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isNull();\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isEqualTo(\n\t\t\t\t\t\t\t\tInheritedAnnotationClass.class);\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(\n\t\t\t\t\t\tTransactional.class).getSource()).isEqualTo(\n\t\t\t\t\t\t\t\tInheritedAnnotationClass.class);\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but we should still find it on classes.\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(Order.class).getSource()).isEqualTo(\n\t\t\t\t\t\tNonInheritedAnnotationInterface.class);\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(Order.class).getSource()).isNull();\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(Order.class).getSource()).isEqualTo(\n\t\t\t\t\t\tNonInheritedAnnotationClass.class);\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.SUPERCLASS).get(Order.class).getSource()).isEqualTo(\n\t\t\t\t\t\tNonInheritedAnnotationClass.class);\n\t}\n\n\t@Test\n\tvoid getSuperClassSourceForTypesWithSingleCandidateType() {\n\t\t// no class-level annotation\n\t\tList<Class<? extends Annotation>> transactionalCandidateList = Collections.singletonList(Transactional.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonAnnotatedInterface.class,\n\t\t\t\ttransactionalCandidateList)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonAnnotatedClass.class,\n\t\t\t\ttransactionalCandidateList)).isNull();\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationInterface.class,\n\t\t\t\ttransactionalCandidateList)).isEqualTo(\n\t\t\t\t\t\tInheritedAnnotationInterface.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationInterface.class,\n\t\t\t\ttransactionalCandidateList)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationClass.class,\n\t\t\t\ttransactionalCandidateList)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationClass.class,\n\t\t\t\ttransactionalCandidateList)).isEqualTo(InheritedAnnotationClass.class);\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but should still find it on classes.\n\t\tList<Class<? extends Annotation>> orderCandidateList = Collections.singletonList(\n\t\t\t\tOrder.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationInterface.class,\n\t\t\t\torderCandidateList)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationInterface.class,\n\t\t\t\torderCandidateList)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationClass.class,\n\t\t\t\torderCandidateList)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationClass.class,\n\t\t\t\torderCandidateList)).isEqualTo(NonInheritedAnnotationClass.class);\n\t}\n\n\t@Test\n\tvoid getSuperClassSourceForTypesWithMultipleCandidateTypes() {\n\t\tList<Class<? extends Annotation>> candidates = List.of(Transactional.class, Order.class);\n\t\t// no class-level annotation\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonAnnotatedInterface.class,\n\t\t\t\tcandidates)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonAnnotatedClass.class,\n\t\t\t\tcandidates)).isNull();\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationInterface.class,\n\t\t\t\tcandidates)).isEqualTo(InheritedAnnotationInterface.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationInterface.class,\n\t\t\t\tcandidates)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationClass.class,\n\t\t\t\tcandidates)).isEqualTo(InheritedAnnotationClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationClass.class,\n\t\t\t\tcandidates)).isEqualTo(InheritedAnnotationClass.class);\n\t\t// non-inherited class-level annotation; note: @Order is not inherited,\n\t\t// but findAnnotationDeclaringClassForTypes() should still find it on\n\t\t// classes.\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationInterface.class,\n\t\t\t\tcandidates)).isEqualTo(NonInheritedAnnotationInterface.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationInterface.class,\n\t\t\t\tcandidates)).isNull();\n\t\tassertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationClass.class,\n\t\t\t\tcandidates)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationClass.class,\n\t\t\t\tcandidates)).isEqualTo(NonInheritedAnnotationClass.class);\n\t\t// class hierarchy mixed with @Transactional and @Order declarations\n\t\tassertThat(getSuperClassSourceWithTypeIn(TransactionalClass.class,\n\t\t\t\tcandidates)).isEqualTo(TransactionalClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(TransactionalAndOrderedClass.class,\n\t\t\t\tcandidates)).isEqualTo(TransactionalAndOrderedClass.class);\n\t\tassertThat(getSuperClassSourceWithTypeIn(SubTransactionalAndOrderedClass.class,\n\t\t\t\tcandidates)).isEqualTo(TransactionalAndOrderedClass.class);\n\t}\n\n\tprivate Object getSuperClassSourceWithTypeIn(Class<?> clazz, List<Class<? extends Annotation>> annotationTypes) {\n\t\treturn MergedAnnotations.from(clazz, SearchStrategy.SUPERCLASS).stream().filter(\n\t\t\t\tMergedAnnotationPredicates.typeIn(annotationTypes).and(\n\t\t\t\t\t\tMergedAnnotation::isDirectlyPresent)).map(\n\t\t\t\t\t\t\t\tMergedAnnotation::getSource).findFirst().orElse(null);\n\t}\n\n\t@Test\n\tvoid isDirectlyPresentForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedInterface.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedInterface.class).isDirectlyPresent(\n\t\t\t\tTransactional.class)).isFalse();\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class).isDirectlyPresent(\n\t\t\t\tTransactional.class)).isFalse();\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationInterface.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isTrue();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tInheritedAnnotationInterface.class).isDirectlyPresent(\n\t\t\t\t\t\tTransactional.class)).isTrue();\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tSubInheritedAnnotationInterface.class).isDirectlyPresent(\n\t\t\t\t\t\tTransactional.class)).isFalse();\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationClass.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isTrue();\n\t\tassertThat(\n\t\t\t\tMergedAnnotations.from(InheritedAnnotationClass.class).isDirectlyPresent(\n\t\t\t\t\t\tTransactional.class)).isTrue();\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class).get(\n\t\t\t\tTransactional.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tSubInheritedAnnotationClass.class).isDirectlyPresent(\n\t\t\t\t\t\tTransactional.class)).isFalse();\n\t\t// non-inherited class-level annotation; note: @Order is not inherited\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class).get(\n\t\t\t\tOrder.class).isDirectlyPresent()).isTrue();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationInterface.class).isDirectlyPresent(\n\t\t\t\t\t\tOrder.class)).isTrue();\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class).get(\n\t\t\t\tOrder.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tSubNonInheritedAnnotationInterface.class).isDirectlyPresent(\n\t\t\t\t\t\tOrder.class)).isFalse();\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class).get(\n\t\t\t\tOrder.class).isDirectlyPresent()).isTrue();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tNonInheritedAnnotationClass.class).isDirectlyPresent(\n\t\t\t\t\t\tOrder.class)).isTrue();\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class).get(\n\t\t\t\tOrder.class).isDirectlyPresent()).isFalse();\n\t\tassertThat(MergedAnnotations.from(\n\t\t\t\tSubNonInheritedAnnotationClass.class).isDirectlyPresent(\n\t\t\t\t\t\tOrder.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid getAggregateIndexForAllScenarios() {\n\t\t// no class-level annotation\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(NonAnnotatedClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(-1);\n\t\t// inherited class-level annotation; note: @Transactional is inherited\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(0);\n\t\t// Since we're not traversing interface hierarchies the following,\n\t\t// though perhaps counterintuitive, must be false:\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(InheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tTransactional.class).getAggregateIndex()).isEqualTo(1);\n\t\t// non-inherited class-level annotation; note: @Order is not inherited\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tOrder.class).getAggregateIndex()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tOrder.class).getAggregateIndex()).isEqualTo(-1);\n\t\tassertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tOrder.class).getAggregateIndex()).isEqualTo(0);\n\t\tassertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class,\n\t\t\t\tSearchStrategy.INHERITED_ANNOTATIONS).get(\n\t\t\t\t\t\tOrder.class).getAggregateIndex()).isEqualTo(-1);\n\t}\n\n\t@Test\n\tvoid getDirectWithoutAttributeAliases() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(WebController.class).get(Component.class);\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"webController\");\n\t}\n\n\t@Test\n\tvoid getDirectWithNestedAnnotations() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(ComponentScanClass.class).get(ComponentScan.class);\n\t\tMergedAnnotation<Filter>[] filters = annotation.getAnnotationArray(\"excludeFilters\", Filter.class);\n\t\tassertThat(Arrays.stream(filters).map(\n\t\t\t\tfilter -> filter.getString(\"pattern\"))).containsExactly(\"*Foo\", \"*Bar\");\n\t}\n\n\t@Test\n\tvoid getDirectWithAttributeAliases1() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method).get(RequestMapping.class);\n\t\tassertThat(annotation.getString(\"name\")).isEqualTo(\"foo\");\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"/test\");\n\t\tassertThat(annotation.getStringArray(\"path\")).containsExactly(\"/test\");\n\t}\n\n\t@Test\n\tvoid getDirectWithAttributeAliases2() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(method).get(RequestMapping.class);\n\t\tassertThat(annotation.getString(\"name\")).isEqualTo(\"bar\");\n\t\tassertThat(annotation.getStringArray(\"value\")).containsExactly(\"/test\");\n\t\tassertThat(annotation.getStringArray(\"path\")).containsExactly(\"/test\");\n\t}\n\n\t@Test\n\tvoid getDirectWithAttributeAliasesWithDifferentValues() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithDifferentPathAndValueAttributes\");\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tMergedAnnotations.from(method).get(RequestMapping.class))\n\t\t\t\t.withMessageContaining(\"attribute 'path' and its alias 'value'\")\n\t\t\t\t.withMessageContaining(\"values of [{/test}] and [{/enigma}]\");\n\t}\n\n\t@Test\n\tvoid getValueFromAnnotation() throws Exception {\n\t\tMethod method = TransactionalStringGeneric.class.getMethod(\"something\", Object.class);\n\t\tMergedAnnotation<?> annotation =\n\t\t\t\tMergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getInt(\"value\")).isEqualTo(1);\n\t}\n\n\t@Test\n\tvoid getValueFromNonPublicAnnotation() {\n\t\tAnnotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\n\t\tassertThat(declaredAnnotations).hasSize(1);\n\t\tAnnotation annotation = declaredAnnotations[0];\n\t\tMergedAnnotation<Annotation> mergedAnnotation = MergedAnnotation.from(annotation);\n\t\tassertThat(mergedAnnotation.getType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\n\t\tassertThat(mergedAnnotation.synthesize().annotationType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\n\t\tassertThat(mergedAnnotation.getInt(\"value\")).isEqualTo(42);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromAnnotation() throws Exception {\n\t\tMethod method = TransactionalStringGeneric.class.getMethod(\"something\", Object.class);\n\t\tMergedAnnotation<Order> annotation =\n\t\t\t\tMergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\n\t\tassertThat(annotation.getDefaultValue(\"value\")).contains(Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromNonPublicAnnotation() {\n\t\tAnnotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\n\t\tassertThat(declaredAnnotations).hasSize(1);\n\t\tAnnotation declaredAnnotation = declaredAnnotations[0];\n\t\tMergedAnnotation<?> annotation = MergedAnnotation.from(declaredAnnotation);\n\t\tassertThat(annotation.getType().getName()).isEqualTo(\n\t\t\t\t\"org.springframework.core.annotation.subpackage.NonPublicAnnotation\");\n\t\tassertThat(annotation.getDefaultValue(\"value\")).contains(-1);\n\t}\n\n\t@Test\n\tvoid getDefaultValueFromAnnotationType() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotation.of(Order.class);\n\t\tassertThat(annotation.getDefaultValue(\"value\")).contains(Ordered.LOWEST_PRECEDENCE);\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnMethod() throws Exception {\n\t\tMethod method = InterfaceWithRepeated.class.getMethod(\"foo\");\n\t\tStream<MergedAnnotation<MyRepeatable>> annotations = MergedAnnotations.from(\n\t\t\t\tmethod, SearchStrategy.TYPE_HIERARCHY).stream(MyRepeatable.class);\n\t\tStream<String> values = annotations.map(\n\t\t\t\tannotation -> annotation.getString(\"value\"));\n\t\tassertThat(values).containsExactly(\"A\", \"B\", \"C\", \"meta1\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"deprecation\")\n\tvoid streamRepeatableDeclaredOnClassWithAttributeAliases() {\n\t\tassertThat(MergedAnnotations.from(HierarchyClass.class).stream(\n\t\t\t\tTestConfiguration.class)).isEmpty();\n\t\tRepeatableContainers containers = RepeatableContainers.of(TestConfiguration.class,\n\t\t\t\tHierarchy.class);\n\t\tMergedAnnotations annotations = MergedAnnotations.from(HierarchyClass.class,\n\t\t\t\tSearchStrategy.DIRECT, containers, AnnotationFilter.NONE);\n\t\tassertThat(annotations.stream(TestConfiguration.class).map(\n\t\t\t\tannotation -> annotation.getString(\"location\"))).containsExactly(\"A\", \"B\");\n\t\tassertThat(annotations.stream(TestConfiguration.class).map(\n\t\t\t\tannotation -> annotation.getString(\"value\"))).containsExactly(\"A\", \"B\");\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnClass() {\n\t\tClass<?> element = MyRepeatableClass.class;\n\t\tString[] expectedValuesJava = { \"A\", \"B\", \"C\" };\n\t\tString[] expectedValuesSpring = { \"A\", \"B\", \"C\", \"meta1\" };\n\t\ttestRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnSuperclass() {\n\t\tClass<?> element = SubMyRepeatableClass.class;\n\t\tString[] expectedValuesJava = { \"A\", \"B\", \"C\" };\n\t\tString[] expectedValuesSpring = { \"A\", \"B\", \"C\", \"meta1\" };\n\t\ttestRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnClassAndSuperclass() {\n\t\tClass<?> element = SubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\n\t\tString[] expectedValuesJava = { \"X\", \"Y\", \"Z\" };\n\t\tString[] expectedValuesSpring = { \"X\", \"Y\", \"Z\", \"meta2\" };\n\t\ttestRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamRepeatableDeclaredOnMultipleSuperclasses() {\n\t\tClass<?> element = SubSubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\n\t\tString[] expectedValuesJava = { \"X\", \"Y\", \"Z\" };\n\t\tString[] expectedValuesSpring = { \"X\", \"Y\", \"Z\", \"meta2\" };\n\t\ttestRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamDirectRepeatablesDeclaredOnClass() {\n\t\tClass<?> element = MyRepeatableClass.class;\n\t\tString[] expectedValuesJava = { \"A\", \"B\", \"C\" };\n\t\tString[] expectedValuesSpring = { \"A\", \"B\", \"C\", \"meta1\" };\n\t\ttestRepeatables(SearchStrategy.DIRECT, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\t@Test\n\tvoid streamDirectRepeatablesDeclaredOnSuperclass() {\n\t\tClass<?> element = SubMyRepeatableClass.class;\n\t\tString[] expectedValuesJava = {};\n\t\tString[] expectedValuesSpring = {};\n\t\ttestRepeatables(SearchStrategy.DIRECT, element, expectedValuesJava, expectedValuesSpring);\n\t}\n\n\tprivate void testRepeatables(SearchStrategy searchStrategy, Class<?> element,\n\t\t\tString[] expectedValuesJava, String[] expectedValuesSpring) {\n\n\t\ttestJavaRepeatables(searchStrategy, element, expectedValuesJava);\n\t\ttestExplicitRepeatables(searchStrategy, element, expectedValuesSpring);\n\t\ttestStandardRepeatables(searchStrategy, element, expectedValuesSpring);\n\t}\n\n\tprivate void testJavaRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expected) {\n\t\tMyRepeatable[] annotations = searchStrategy == SearchStrategy.DIRECT ?\n\t\t\t\telement.getDeclaredAnnotationsByType(MyRepeatable.class) :\n\t\t\t\telement.getAnnotationsByType(MyRepeatable.class);\n\t\tassertThat(Arrays.stream(annotations).map(MyRepeatable::value)).containsExactly(\n\t\t\t\texpected);\n\t}\n\n\tprivate void testExplicitRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expected) {\n\t\tMergedAnnotations annotations = MergedAnnotations.from(element, searchStrategy,\n\t\t\t\tRepeatableContainers.of(MyRepeatable.class, MyRepeatableContainer.class),\n\t\t\t\tAnnotationFilter.PLAIN);\n\t\tStream<String> values = annotations.stream(MyRepeatable.class)\n\t\t\t\t.filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex))\n\t\t\t\t.map(annotation -> annotation.getString(\"value\"));\n\t\tassertThat(values).containsExactly(expected);\n\t}\n\n\tprivate void testStandardRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expected) {\n\t\tStream<String> values = MergedAnnotations.from(element, searchStrategy).stream(MyRepeatable.class)\n\t\t\t\t.filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex))\n\t\t\t\t.map(annotation -> annotation.getString(\"value\"));\n\t\tassertThat(values).containsExactly(expected);\n\t}\n\n\t@Test\n\tvoid synthesizeWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tComponent synthesizedComponent = MergedAnnotation.from(component).synthesize();\n\t\tassertThat(synthesizedComponent).isNotNull();\n\t\tassertThat(synthesizedComponent).isEqualTo(component);\n\t\tassertThat(synthesizedComponent.value()).isEqualTo(\"webController\");\n\t}\n\n\t/**\n\t * @since 6.0\n\t */\n\t@Test\n\tvoid synthesizedAnnotationShouldReuseJdkProxyClass() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\n\t\tRequestMapping jdkRequestMapping = method.getAnnotation(RequestMapping.class);\n\t\tassertThat(jdkRequestMapping).isNotNull();\n\t\tassertThat(jdkRequestMapping.value()).containsExactly(\"/test\");\n\t\tassertThat(jdkRequestMapping.path()).containsExactly(\"\");\n\n\t\tRequestMapping synthesizedRequestMapping = MergedAnnotation.from(jdkRequestMapping).synthesize();\n\t\tassertSynthesized(synthesizedRequestMapping);\n\t\tassertThat(synthesizedRequestMapping.value()).containsExactly(\"/test\");\n\t\tassertThat(synthesizedRequestMapping.path()).containsExactly(\"/test\");\n\n\t\tassertThat(jdkRequestMapping.getClass()).isSameAs(synthesizedRequestMapping.getClass());\n\t}\n\n\t@Test\n\tvoid synthesizeAlreadySynthesized() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\t\tRequestMapping webMapping = method.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMapping).isNotNull();\n\n\t\tRequestMapping synthesizedWebMapping = MergedAnnotation.from(webMapping).synthesize();\n\t\tRequestMapping synthesizedAgainWebMapping = MergedAnnotation.from(synthesizedWebMapping).synthesize();\n\n\t\tassertSynthesized(synthesizedWebMapping);\n\t\tassertSynthesized(synthesizedAgainWebMapping);\n\t\tassertThat(synthesizedWebMapping).isEqualTo(synthesizedAgainWebMapping);\n\t\tassertThat(synthesizedWebMapping).isSameAs(synthesizedAgainWebMapping);\n\t\tassertThat(synthesizedWebMapping.name()).isEqualTo(\"foo\");\n\t\tassertThat(synthesizedWebMapping.path()).containsExactly(\"/test\");\n\t\tassertThat(synthesizedWebMapping.value()).containsExactly(\"/test\");\n\t}\n\n\t@Test\n\tvoid synthesizeShouldNotSynthesizeNonsynthesizableAnnotations() throws Exception {\n\t\tMethod method = getClass().getDeclaredMethod(\"getId\");\n\n\t\tId id = method.getAnnotation(Id.class);\n\t\tassertThat(id).isNotNull();\n\t\tId synthesizedId = MergedAnnotation.from(id).synthesize();\n\t\tassertThat(id).isEqualTo(synthesizedId);\n\t\t// It doesn't make sense to synthesize @Id since it declares zero attributes.\n\t\tassertNotSynthesized(synthesizedId);\n\t\tassertThat(id).isSameAs(synthesizedId);\n\n\t\tGeneratedValue generatedValue = method.getAnnotation(GeneratedValue.class);\n\t\tassertThat(generatedValue).isNotNull();\n\t\tGeneratedValue synthesizedGeneratedValue = MergedAnnotation.from(generatedValue).synthesize();\n\t\tassertThat(generatedValue).isEqualTo(synthesizedGeneratedValue);\n\t\t// It doesn't make sense to synthesize @GeneratedValue since it declares zero attributes with aliases.\n\t\tassertNotSynthesized(synthesizedGeneratedValue);\n\t\tassertThat(generatedValue).isSameAs(synthesizedGeneratedValue);\n\t}\n\n\t@Test  // gh-28716\n\tvoid synthesizeWhenUsingMergedAnnotationsFromApi() {\n\t\tField directlyAnnotatedField = ReflectionUtils.findField(DomainType.class, \"directlyAnnotated\");\n\t\tMergedAnnotations mergedAnnotations = MergedAnnotations.from(directlyAnnotatedField);\n\t\tRootAnnotation rootAnnotation = mergedAnnotations.get(RootAnnotation.class).synthesize();\n\t\tassertThat(rootAnnotation.flag()).isFalse();\n\t\tassertNotSynthesized(rootAnnotation);\n\n\t\tField metaAnnotatedField = ReflectionUtils.findField(DomainType.class, \"metaAnnotated\");\n\t\tmergedAnnotations = MergedAnnotations.from(metaAnnotatedField);\n\t\trootAnnotation = mergedAnnotations.get(RootAnnotation.class).synthesize();\n\t\tassertThat(rootAnnotation.flag()).isTrue();\n\t\tassertSynthesized(rootAnnotation);\n\n\t\tField metaMetaAnnotatedField = ReflectionUtils.findField(DomainType.class, \"metaMetaAnnotated\");\n\t\tmergedAnnotations = MergedAnnotations.from(metaMetaAnnotatedField);\n\t\trootAnnotation = mergedAnnotations.get(RootAnnotation.class).synthesize();\n\t\tassertThat(rootAnnotation.flag()).isTrue();\n\t\tassertSynthesized(rootAnnotation);\n\t}\n\n\t@Test  // gh-28704\n\tvoid synthesizeShouldNotSynthesizeNonsynthesizableAnnotationsWhenUsingMergedAnnotationsFromApi() {\n\t\tMergedAnnotations mergedAnnotations = MergedAnnotations.from(SecurityConfig.class);\n\n\t\tEnableWebSecurity enableWebSecurity = mergedAnnotations.get(EnableWebSecurity.class).synthesize();\n\t\tassertNotSynthesized(enableWebSecurity);\n\n\t\tEnableGlobalAuthentication enableGlobalAuthentication = mergedAnnotations.get(EnableGlobalAuthentication.class).synthesize();\n\t\tassertNotSynthesized(enableGlobalAuthentication);\n\t}\n\n\t/**\n\t * If an attempt is made to synthesize an annotation from an annotation instance\n\t * that has already been synthesized, the original synthesized annotation should\n\t * ideally be returned as-is without creating a new proxy instance with the same\n\t * values.\n\t */\n\t@Test\n\tvoid synthesizeShouldNotResynthesizeAlreadySynthesizedAnnotations() throws Exception {\n\t\tMethod method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\n\t\tRequestMapping webMapping = method.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMapping).isNotNull();\n\n\t\tMergedAnnotation<RequestMapping> mergedAnnotation1 = MergedAnnotation.from(webMapping);\n\t\tRequestMapping synthesizedWebMapping1 = mergedAnnotation1.synthesize();\n\t\tRequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMapping).synthesize();\n\n\t\tassertSynthesized(synthesizedWebMapping1);\n\t\tassertSynthesized(synthesizedWebMapping2);\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(synthesizedWebMapping2);\n\n\t\t// Synthesizing an annotation from a different MergedAnnotation results in a different synthesized annotation instance.\n\t\tassertThat(synthesizedWebMapping1).isNotSameAs(synthesizedWebMapping2);\n\t\t// Synthesizing an annotation from the same MergedAnnotation results in the same synthesized annotation instance.\n\t\tassertThat(synthesizedWebMapping1).isSameAs(mergedAnnotation1.synthesize());\n\n\t\tRequestMapping synthesizedAgainWebMapping = MergedAnnotation.from(synthesizedWebMapping1).synthesize();\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(synthesizedAgainWebMapping);\n\t\t// Synthesizing an already synthesized annotation results in the original synthesized annotation instance.\n\t\tassertThat(synthesizedWebMapping1).isSameAs(synthesizedAgainWebMapping);\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAliasForIsMissingAttributeDeclaration() {\n\t\tAliasForWithMissingAttributeDeclaration annotation =\n\t\t\t\tAliasForWithMissingAttributeDeclarationClass.class.getAnnotation(\n\t\t\t\t\t\tAliasForWithMissingAttributeDeclaration.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"@AliasFor declaration on attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(AliasForWithMissingAttributeDeclaration.class.getName())\n\t\t\t\t.withMessageContaining(\"points to itself\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAliasForHasDuplicateAttributeDeclaration() {\n\t\tAliasForWithDuplicateAttributeDeclaration annotation =\n\t\t\t\tAliasForWithDuplicateAttributeDeclarationClass.class.getAnnotation(\n\t\t\t\t\t\tAliasForWithDuplicateAttributeDeclaration.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"In @AliasFor declared on attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(AliasForWithDuplicateAttributeDeclaration.class.getName())\n\t\t\t\t.withMessageContaining(\"attribute 'attribute' and its alias 'value' are present with values of 'baz' and 'bar'\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForNonexistentAttribute() {\n\t\tAliasForNonexistentAttribute annotation = AliasForNonexistentAttributeClass.class.getAnnotation(\n\t\t\t\tAliasForNonexistentAttribute.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"@AliasFor declaration on attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(AliasForNonexistentAttribute.class.getName())\n\t\t\t\t.withMessageContaining(\"declares an alias for 'bar' which is not present\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasWithMirroredAliasForWrongAttribute() {\n\t\tAliasForWithMirroredAliasForWrongAttribute annotation =\n\t\t\t\tAliasForWithMirroredAliasForWrongAttributeClass.class.getAnnotation(\n\t\t\t\t\t\tAliasForWithMirroredAliasForWrongAttribute.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessage(\"@AliasFor declaration on attribute 'bar' in annotation [\" +\n\t\t\t\t\t\tAliasForWithMirroredAliasForWrongAttribute.class.getName() +\n\t\t\t\t\t\t\"] declares an alias for 'quux' which is not present.\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForAttributeOfDifferentType() {\n\t\tAliasForAttributeOfDifferentType annotation = AliasForAttributeOfDifferentTypeClass.class.getAnnotation(\n\t\t\t\tAliasForAttributeOfDifferentType.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases\")\n\t\t\t\t.withMessageContaining(AliasForAttributeOfDifferentType.class.getName())\n\t\t\t\t.withMessageContaining(\"attribute 'foo'\")\n\t\t\t\t.withMessageContaining(\"attribute 'bar'\")\n\t\t\t\t.withMessageContaining(\"same return type\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForWithMissingDefaultValues() {\n\t\tAliasForWithMissingDefaultValues annotation = AliasForWithMissingDefaultValuesClass.class.getAnnotation(\n\t\t\t\tAliasForWithMissingDefaultValues.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases\")\n\t\t\t\t.withMessageContaining(AliasForWithMissingDefaultValues.class.getName())\n\t\t\t\t.withMessageContaining(\"attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(\"attribute 'bar' in annotation\")\n\t\t\t\t.withMessageContaining(\"default values\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForAttributeWithDifferentDefaultValue() {\n\t\tAliasForAttributeWithDifferentDefaultValue annotation =\n\t\t\t\tAliasForAttributeWithDifferentDefaultValueClass.class.getAnnotation(\n\t\t\t\t\t\tAliasForAttributeWithDifferentDefaultValue.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases\")\n\t\t\t\t.withMessageContaining(AliasForAttributeWithDifferentDefaultValue.class.getName())\n\t\t\t\t.withMessageContaining(\"attribute 'foo' in annotation\")\n\t\t\t\t.withMessageContaining(\"attribute 'bar' in annotation\")\n\t\t\t\t.withMessageContaining(\"same default value\");\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasForMetaAnnotationThatIsNotMetaPresent() {\n\t\tAliasedComposedTestConfigurationNotMetaPresent annotation =\n\t\t\t\tAliasedComposedTestConfigurationNotMetaPresentClass.class.getAnnotation(\n\t\t\t\t\t\tAliasedComposedTestConfigurationNotMetaPresent.class);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(annotation))\n\t\t\t\t.withMessageStartingWith(\"@AliasFor declaration on attribute 'xmlConfigFile' in annotation\")\n\t\t\t\t.withMessageContaining(AliasedComposedTestConfigurationNotMetaPresent.class.getName())\n\t\t\t\t.withMessageContaining(\"declares an alias for attribute 'location' in annotation\")\n\t\t\t\t.withMessageContaining(TestConfiguration.class.getName())\n\t\t\t\t.withMessageContaining(\"not meta-present\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliases() {\n\t\ttestSynthesisWithImplicitAliases(ValueImplicitAliasesTestConfigurationClass.class, \"value\");\n\t\ttestSynthesisWithImplicitAliases(Location1ImplicitAliasesTestConfigurationClass.class, \"location1\");\n\t\ttestSynthesisWithImplicitAliases(XmlImplicitAliasesTestConfigurationClass.class, \"xmlFile\");\n\t\ttestSynthesisWithImplicitAliases(GroovyImplicitAliasesSimpleTestConfigurationClass.class, \"groovyScript\");\n\t}\n\n\tprivate void testSynthesisWithImplicitAliases(Class<?> clazz, String expected) {\n\t\tImplicitAliasesTestConfiguration config = clazz.getAnnotation(ImplicitAliasesTestConfiguration.class);\n\t\tassertThat(config).isNotNull();\n\t\tImplicitAliasesTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.value()).isEqualTo(expected);\n\t\tassertThat(synthesized.location1()).isEqualTo(expected);\n\t\tassertThat(synthesized.xmlFile()).isEqualTo(expected);\n\t\tassertThat(synthesized.groovyScript()).isEqualTo(expected);\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesWithImpliedAliasNamesOmitted() {\n\t\ttestSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(\n\t\t\t\tValueImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass.class,\n\t\t\t\t\"value\");\n\t\ttestSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(\n\t\t\t\tLocationsImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass.class,\n\t\t\t\t\"location\");\n\t\ttestSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(\n\t\t\t\tXmlFilesImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass.class,\n\t\t\t\t\"xmlFile\");\n\t}\n\n\tprivate void testSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(Class<?> clazz, String expected) {\n\t\tImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration config = clazz.getAnnotation(\n\t\t\t\tImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration.class);\n\t\tassertThat(config).isNotNull();\n\t\tImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration synthesized =\n\t\t\t\tMergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.value()).isEqualTo(expected);\n\t\tassertThat(synthesized.location()).isEqualTo(expected);\n\t\tassertThat(synthesized.xmlFile()).isEqualTo(expected);\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesForAliasPair() {\n\t\tImplicitAliasesForAliasPairTestConfiguration config =\n\t\t\t\tImplicitAliasesForAliasPairTestConfigurationClass.class.getAnnotation(\n\t\t\t\t\t\tImplicitAliasesForAliasPairTestConfiguration.class);\n\t\tImplicitAliasesForAliasPairTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.xmlFile()).isEqualTo(\"test.xml\");\n\t\tassertThat(synthesized.groovyScript()).isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithTransitiveImplicitAliases() {\n\t\tTransitiveImplicitAliasesTestConfiguration config =\n\t\t\t\tTransitiveImplicitAliasesTestConfigurationClass.class.getAnnotation(\n\t\t\t\t\t\tTransitiveImplicitAliasesTestConfiguration.class);\n\t\tTransitiveImplicitAliasesTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.xml()).isEqualTo(\"test.xml\");\n\t\tassertThat(synthesized.groovy()).isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithTransitiveImplicitAliasesForAliasPair() {\n\t\tTransitiveImplicitAliasesForAliasPairTestConfiguration config =\n\t\t\t\tTransitiveImplicitAliasesForAliasPairTestConfigurationClass.class.getAnnotation(\n\t\t\t\t\t\tTransitiveImplicitAliasesForAliasPairTestConfiguration.class);\n\t\tTransitiveImplicitAliasesForAliasPairTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized.xml()).isEqualTo(\"test.xml\");\n\t\tassertThat(synthesized.groovy()).isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesWithMissingDefaultValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithMissingDefaultValuesTestConfigurationClass.class;\n\t\tClass<ImplicitAliasesWithMissingDefaultValuesTestConfiguration> annotationType =\n\t\t\t\tImplicitAliasesWithMissingDefaultValuesTestConfiguration.class;\n\t\tImplicitAliasesWithMissingDefaultValuesTestConfiguration config = clazz.getAnnotation(annotationType);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(clazz, config))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases:\")\n\t\t\t\t.withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t\t.withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t\t.withMessageContaining(\"default values\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesWithDifferentDefaultValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithDifferentDefaultValuesTestConfigurationClass.class;\n\t\tClass<ImplicitAliasesWithDifferentDefaultValuesTestConfiguration> annotationType =\n\t\t\t\tImplicitAliasesWithDifferentDefaultValuesTestConfiguration.class;\n\t\tImplicitAliasesWithDifferentDefaultValuesTestConfiguration config = clazz.getAnnotation(annotationType);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(\n\t\t\t\t() -> MergedAnnotation.from(clazz, config))\n\t\t\t\t.withMessageStartingWith(\"Misconfigured aliases:\")\n\t\t\t\t.withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t\t.withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\")\n\t\t\t\t.withMessageContaining(\"same default value\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithImplicitAliasesWithDuplicateValues() {\n\t\tClass<?> clazz = ImplicitAliasesWithDuplicateValuesTestConfigurationClass.class;\n\t\tClass<ImplicitAliasesWithDuplicateValuesTestConfiguration> annotationType =\n\t\t\t\tImplicitAliasesWithDuplicateValuesTestConfiguration.class;\n\t\tImplicitAliasesWithDuplicateValuesTestConfiguration config = clazz.getAnnotation(annotationType);\n\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class)\n\t\t\t\t.isThrownBy(() -> MergedAnnotation.from(clazz, config))\n\t\t\t\t.withMessageStartingWith(\"Different @AliasFor mirror values for annotation\")\n\t\t\t\t.withMessageContaining(annotationType.getName())\n\t\t\t\t.withMessageContaining(\"declared on class\")\n\t\t\t\t.withMessageContaining(clazz.getName())\n\t\t\t\t.withMessageContaining(\"are declared with values of\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tMap<String, Object> map = Collections.singletonMap(\"value\", \"webController\");\n\t\tMergedAnnotation<Component> annotation = MergedAnnotation.of(Component.class, map);\n\n\t\tComponent synthesizedComponent = annotation.synthesize();\n\t\tassertSynthesized(synthesizedComponent);\n\t\tassertThat(synthesizedComponent.value()).isEqualTo(\"webController\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeFromMapWithNestedMap() {\n\t\tComponentScanSingleFilter componentScan = ComponentScanSingleFilterClass.class.getAnnotation(\n\t\t\t\tComponentScanSingleFilter.class);\n\t\tassertThat(componentScan).isNotNull();\n\t\tassertThat(componentScan.value().pattern()).isEqualTo(\"*Foo\");\n\t\tMap<String, Object> map = MergedAnnotation.from(componentScan).asMap(\n\t\t\t\tannotation -> new LinkedHashMap<>(), Adapt.ANNOTATION_TO_MAP);\n\t\tMap<String, Object> filterMap = (Map<String, Object>) map.get(\"value\");\n\t\tassertThat(filterMap.get(\"pattern\")).isEqualTo(\"*Foo\");\n\t\tfilterMap.put(\"pattern\", \"newFoo\");\n\t\tfilterMap.put(\"enigma\", 42);\n\t\tMergedAnnotation<ComponentScanSingleFilter> annotation = MergedAnnotation.of(\n\t\t\t\tComponentScanSingleFilter.class, map);\n\t\tComponentScanSingleFilter synthesizedComponentScan = annotation.synthesize();\n\t\tassertSynthesized(synthesizedComponentScan);\n\t\tassertThat(synthesizedComponentScan.value().pattern()).isEqualTo(\"newFoo\");\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeFromMapWithNestedArrayOfMaps() {\n\t\tComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class);\n\t\tassertThat(componentScan).isNotNull();\n\t\tMap<String, Object> map = MergedAnnotation.from(componentScan).asMap(\n\t\t\t\tannotation -> new LinkedHashMap<>(), Adapt.ANNOTATION_TO_MAP);\n\t\tMap<String, Object>[] filters = (Map[]) map.get(\"excludeFilters\");\n\t\tList<String> patterns = Arrays.stream(filters).map(\n\t\t\t\tm -> (String) m.get(\"pattern\")).toList();\n\t\tassertThat(patterns).containsExactly(\"*Foo\", \"*Bar\");\n\t\tfilters[0].put(\"pattern\", \"newFoo\");\n\t\tfilters[0].put(\"enigma\", 42);\n\t\tfilters[1].put(\"pattern\", \"newBar\");\n\t\tfilters[1].put(\"enigma\", 42);\n\t\tMergedAnnotation<ComponentScan> annotation = MergedAnnotation.of(ComponentScan.class, map);\n\t\tComponentScan synthesizedComponentScan = annotation.synthesize();\n\t\tassertSynthesized(synthesizedComponentScan);\n\t\tassertThat(Arrays.stream(synthesizedComponentScan.excludeFilters()).map(Filter::pattern))\n\t\t\t\t.containsExactly(\"newFoo\", \"newBar\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromDefaultsWithoutAttributeAliases() {\n\t\tMergedAnnotation<AnnotationWithDefaults> annotation = MergedAnnotation.of(AnnotationWithDefaults.class);\n\t\tAnnotationWithDefaults synthesized = annotation.synthesize();\n\t\tassertThat(synthesized.text()).isEqualTo(\"enigma\");\n\t\tassertThat(synthesized.predicate()).isTrue();\n\t\tassertThat(synthesized.characters()).containsExactly('a', 'b', 'c');\n\t}\n\n\t@Test\n\tvoid synthesizeFromDefaultsWithAttributeAliases() {\n\t\tMergedAnnotation<TestConfiguration> annotation = MergedAnnotation.of(TestConfiguration.class);\n\t\tTestConfiguration synthesized = annotation.synthesize();\n\t\tassertThat(synthesized.value()).isEmpty();\n\t\tassertThat(synthesized.location()).isEmpty();\n\t}\n\n\t@Test\n\tvoid synthesizeWhenAttributeAliasesWithDifferentValues() {\n\t\tassertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() ->\n\t\t\t\tMergedAnnotation.from(TestConfigurationMismatch.class.getAnnotation(TestConfiguration.class)).synthesize());\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithMinimalAttributesWithAttributeAliases() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"location\", \"test.xml\");\n\t\tMergedAnnotation<TestConfiguration> annotation = MergedAnnotation.of(TestConfiguration.class, map);\n\t\tTestConfiguration synthesized = annotation.synthesize();\n\t\tassertThat(synthesized.value()).isEqualTo(\"test.xml\");\n\t\tassertThat(synthesized.location()).isEqualTo(\"test.xml\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements() {\n\t\tsynthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements(\n\t\t\t\tCollections.singletonMap(\"value\", \"/foo\"));\n\t\tsynthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements(\n\t\t\t\tCollections.singletonMap(\"path\", \"/foo\"));\n\t}\n\n\tprivate void synthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements(Map<String, Object> map) {\n\t\tMergedAnnotation<GetMapping> annotation = MergedAnnotation.of(GetMapping.class, map);\n\t\tGetMapping synthesized = annotation.synthesize();\n\t\tassertThat(synthesized.value()).isEqualTo(\"/foo\");\n\t\tassertThat(synthesized.path()).isEqualTo(\"/foo\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithImplicitAttributeAliases() {\n\t\ttestSynthesisFromMapWithImplicitAliases(\"value\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"location1\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"location2\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"location3\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"xmlFile\");\n\t\ttestSynthesisFromMapWithImplicitAliases(\"groovyScript\");\n\t}\n\n\tprivate void testSynthesisFromMapWithImplicitAliases(String attributeNameAndValue) {\n\t\tMap<String, Object> map = Collections.singletonMap(attributeNameAndValue, attributeNameAndValue);\n\t\tMergedAnnotation<ImplicitAliasesTestConfiguration> annotation = MergedAnnotation.of(\n\t\t\t\tImplicitAliasesTestConfiguration.class, map);\n\t\tImplicitAliasesTestConfiguration synthesized = annotation.synthesize();\n\n\t\tassertThat(synthesized.value()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.location1()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.location2()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.location2()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.xmlFile()).isEqualTo(attributeNameAndValue);\n\t\tassertThat(synthesized.groovyScript()).isEqualTo(attributeNameAndValue);\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithMissingAttributeValue() {\n\t\ttestMissingTextAttribute(Collections.emptyMap());\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithNullAttributeValue() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"text\", null);\n\t\tassertThat(map).containsKey(\"text\");\n\t\ttestMissingTextAttribute(map);\n\t}\n\n\tprivate void testMissingTextAttribute(Map<String, Object> attributes) {\n\t\tassertThatExceptionOfType(NoSuchElementException.class).isThrownBy(() ->\n\t\t\t\tMergedAnnotation.of(AnnotationWithoutDefaults.class, attributes).synthesize().text())\n\t\t\t\t.withMessage(\"No value found for attribute named 'text' in merged annotation \" +\n\t\t\t\t\t\tAnnotationWithoutDefaults.class.getCanonicalName());\n\t}\n\n\t@Test\n\tvoid synthesizeFromMapWithAttributeOfIncorrectType() {\n\t\tMap<String, Object> map = Collections.singletonMap(\"value\", 42L);\n\t\tMergedAnnotation<Component> annotation = MergedAnnotation.of(Component.class, map);\n\t\tassertThatIllegalStateException().isThrownBy(() -> annotation.synthesize().value())\n\t\t\t\t.withMessage(\"Attribute 'value' in annotation \" +\n\t\t\t\t\t\t\"org.springframework.core.testfixture.stereotype.Component should be \" +\n\t\t\t\t\t\t\"compatible with java.lang.String but a java.lang.Long value was returned\");\n\t}\n\n\t@Test\n\tvoid synthesizeFromAnnotationAttributesWithoutAttributeAliases() {\n\t\tComponent component = WebController.class.getAnnotation(Component.class);\n\t\tassertThat(component).isNotNull();\n\t\tMap<String, Object> attributes = MergedAnnotation.from(component).asMap();\n\n\t\tComponent synthesized = MergedAnnotation.of(Component.class, attributes).synthesize();\n\t\tassertSynthesized(synthesized);\n\t\tassertThat(synthesized).isEqualTo(component);\n\t}\n\n\t@Test\n\tvoid toStringForSynthesizedAnnotations() throws Exception {\n\t\tMethod methodWithPath = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\tRequestMapping webMappingWithAliases = methodWithPath.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithAliases).isNotNull();\n\n\t\tMethod methodWithPathAndValue = WebController.class.getMethod(\"handleMappedWithSamePathAndValueAttributes\");\n\t\tRequestMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(RequestMapping.class);\n\t\tassertThat(methodWithPathAndValue).isNotNull();\n\n\t\tRequestMapping synthesizedWebMapping1 = MergedAnnotation.from(webMappingWithAliases).synthesize();\n\t\tRequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMappingWithPathAndValue).synthesize();\n\n\t\tassertThat(webMappingWithAliases.toString()).isNotEqualTo(synthesizedWebMapping1.toString());\n\n\t\t// The unsynthesized annotation for handleMappedWithSamePathAndValueAttributes()\n\t\t// should produce almost the same toString() results as synthesized annotations for\n\t\t// handleMappedWithPathAttribute() on Java 9 or higher; however, due to multiple changes\n\t\t// in the JDK's toString() implementation for annotations in JDK 9, 14, and 19,\n\t\t// we do not test the JDK implementation.\n\t\t// assertToStringForWebMappingWithPathAndValue(webMappingWithPathAndValue);\n\n\t\tassertToStringForWebMappingWithPathAndValue(synthesizedWebMapping1);\n\t\tassertToStringForWebMappingWithPathAndValue(synthesizedWebMapping2);\n\t}\n\n\tprivate void assertToStringForWebMappingWithPathAndValue(RequestMapping webMapping) {\n\t\tassertThat(webMapping.toString())\n\t\t\t\t.startsWith(\"@org.springframework.core.annotation.MergedAnnotationsTests.RequestMapping(\")\n\t\t\t\t.contains(\n\t\t\t\t\t// Strings\n\t\t\t\t\t\"value={\\\"/test\\\"}\", \"path={\\\"/test\\\"}\", \"name=\\\"bar\\\"\",\n\t\t\t\t\t// Characters\n\t\t\t\t\t\"ch='X'\", \"chars={'X'}\",\n\t\t\t\t\t// Enums\n\t\t\t\t\t\"method={GET, POST}\",\n\t\t\t\t\t// Classes\n\t\t\t\t\t\"clazz=org.springframework.core.annotation.MergedAnnotationsTests.RequestMethod.class\",\n\t\t\t\t\t\"classes={int[][].class, org.springframework.core.annotation.MergedAnnotationsTests.RequestMethod[].class}\",\n\t\t\t\t\t// Bytes\n\t\t\t\t\t\"byteValue=(byte) 0xFF\", \"bytes={(byte) 0xFF}\",\n\t\t\t\t\t// Shorts\n\t\t\t\t\t\"shortValue=9876\", \"shorts={9876}\",\n\t\t\t\t\t// Longs\n\t\t\t\t\t\"longValue=42L\", \"longs={42L}\",\n\t\t\t\t\t// Floats\n\t\t\t\t\t\"floatValue=3.14f\", \"floats={3.14f}\",\n\t\t\t\t\t// Doubles\n\t\t\t\t\t\"doubleValue=99.999d\", \"doubles={99.999d}\"\n\t\t\t\t)\n\t\t\t\t.endsWith(\")\");\n\t}\n\n\t@Test\n\tvoid equalsForSynthesizedAnnotations() throws Exception {\n\t\tMethod methodWithPath = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\tRequestMapping webMappingWithAliases = methodWithPath.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithAliases).isNotNull();\n\t\tMethod methodWithPathAndValue = WebController.class.getMethod(\"handleMappedWithSamePathAndValueAttributes\");\n\t\tRequestMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithPathAndValue).isNotNull();\n\t\tRequestMapping synthesizedWebMapping1 = MergedAnnotation.from(webMappingWithAliases).synthesize();\n\t\tRequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMappingWithPathAndValue).synthesize();\n\t\t// Equality amongst standard annotations\n\t\tassertThat(webMappingWithAliases).isEqualTo(webMappingWithAliases);\n\t\tassertThat(webMappingWithPathAndValue).isEqualTo(webMappingWithPathAndValue);\n\t\t// Inequality amongst standard annotations\n\t\tassertThat(webMappingWithAliases).isNotEqualTo(webMappingWithPathAndValue);\n\t\tassertThat(webMappingWithPathAndValue).isNotEqualTo(webMappingWithAliases);\n\t\t// Equality amongst synthesized annotations\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(synthesizedWebMapping1);\n\t\tassertThat(synthesizedWebMapping2).isEqualTo(synthesizedWebMapping2);\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(synthesizedWebMapping2);\n\t\tassertThat(synthesizedWebMapping2).isEqualTo(synthesizedWebMapping1);\n\t\t// Equality between standard and synthesized annotations\n\t\tassertThat(synthesizedWebMapping1).isEqualTo(webMappingWithPathAndValue);\n\t\tassertThat(webMappingWithPathAndValue).isEqualTo(synthesizedWebMapping1);\n\t\t// Inequality between standard and synthesized annotations\n\t\tassertThat(synthesizedWebMapping1).isNotEqualTo(webMappingWithAliases);\n\t\tassertThat(webMappingWithAliases).isNotEqualTo(synthesizedWebMapping1);\n\t}\n\n\t@Test\n\tvoid hashCodeForSynthesizedAnnotations() throws Exception {\n\t\tMethod methodWithPath = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\n\t\tRequestMapping webMappingWithAliases = methodWithPath.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithAliases).isNotNull();\n\t\tMethod methodWithPathAndValue = WebController.class.getMethod(\"handleMappedWithSamePathAndValueAttributes\");\n\t\tRequestMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(RequestMapping.class);\n\t\tassertThat(webMappingWithPathAndValue).isNotNull();\n\t\tRequestMapping synthesizedWebMapping1 = MergedAnnotation.from(webMappingWithAliases).synthesize();\n\t\tassertThat(synthesizedWebMapping1).isNotNull();\n\t\tRequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMappingWithPathAndValue).synthesize();\n\t\tassertThat(synthesizedWebMapping2).isNotNull();\n\t\t// Equality amongst standard annotations\n\t\tassertThat(webMappingWithAliases.hashCode()).isEqualTo(webMappingWithAliases.hashCode());\n\t\tassertThat(webMappingWithPathAndValue.hashCode()).isEqualTo(webMappingWithPathAndValue.hashCode());\n\t\t// Inequality amongst standard annotations\n\t\tassertThat(webMappingWithAliases.hashCode()).isNotEqualTo(webMappingWithPathAndValue.hashCode());\n\t\tassertThat(webMappingWithPathAndValue.hashCode()).isNotEqualTo(webMappingWithAliases.hashCode());\n\t\t// Equality amongst synthesized annotations\n\t\tassertThat(synthesizedWebMapping1.hashCode()).isEqualTo(synthesizedWebMapping1.hashCode());\n\t\tassertThat(synthesizedWebMapping2.hashCode()).isEqualTo(synthesizedWebMapping2.hashCode());\n\t\tassertThat(synthesizedWebMapping1.hashCode()).isEqualTo(synthesizedWebMapping2.hashCode());\n\t\tassertThat(synthesizedWebMapping2.hashCode()).isEqualTo(synthesizedWebMapping1.hashCode());\n\t\t// Equality between standard and synthesized annotations\n\t\tassertThat(synthesizedWebMapping1.hashCode()).isEqualTo(webMappingWithPathAndValue.hashCode());\n\t\tassertThat(webMappingWithPathAndValue.hashCode()).isEqualTo(synthesizedWebMapping1.hashCode());\n\t\t// Inequality between standard and synthesized annotations\n\t\tassertThat(synthesizedWebMapping1.hashCode()).isNotEqualTo(webMappingWithAliases.hashCode());\n\t\tassertThat(webMappingWithAliases.hashCode()).isNotEqualTo(synthesizedWebMapping1.hashCode());\n\t}\n\n\t/**\n\t * Fully reflection-based test that verifies support for synthesizing\n\t * annotations across packages with non-public visibility of user types\n\t * (for example, a non-public annotation that uses {@code @AliasFor}).\n\t */\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tvoid synthesizeNonPublicWithAttributeAliasesFromDifferentPackage() throws Exception {\n\t\tClass<?> type = ClassUtils.forName(\n\t\t\t\t\"org.springframework.core.annotation.subpackage.NonPublicAliasedAnnotatedClass\",\n\t\t\t\tnull);\n\t\tClass<? extends Annotation> annotationType = (Class<? extends Annotation>) ClassUtils.forName(\n\t\t\t\t\"org.springframework.core.annotation.subpackage.NonPublicAliasedAnnotation\",\n\t\t\t\tnull);\n\t\tAnnotation annotation = type.getAnnotation(annotationType);\n\t\tassertThat(annotation).isNotNull();\n\t\tMergedAnnotation<Annotation> mergedAnnotation = MergedAnnotation.from(annotation);\n\t\tAnnotation synthesizedAnnotation = mergedAnnotation.synthesize();\n\t\tassertSynthesized(synthesizedAnnotation);\n\t\tassertThat(mergedAnnotation.getString(\"name\")).isEqualTo(\"test\");\n\t\tassertThat(mergedAnnotation.getString(\"path\")).isEqualTo(\"/test\");\n\t\tassertThat(mergedAnnotation.getString(\"value\")).isEqualTo(\"/test\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithArrayOfAnnotations() {\n\t\tHierarchy hierarchy = HierarchyClass.class.getAnnotation(Hierarchy.class);\n\t\tassertThat(hierarchy).isNotNull();\n\t\tHierarchy synthesizedHierarchy = MergedAnnotation.from(hierarchy).synthesize();\n\t\tassertSynthesized(synthesizedHierarchy);\n\t\tTestConfiguration[] configs = synthesizedHierarchy.value();\n\t\tassertThat(configs).isNotNull();\n\t\tassertThat(configs).allMatch(AnnotationUtils::isSynthesizedAnnotation);\n\t\tassertThat(configs).extracting(TestConfiguration::value).containsExactly(\"A\", \"B\");\n\t\tassertThat(configs).extracting(TestConfiguration::location).containsExactly(\"A\", \"B\");\n\n\t\tTestConfiguration contextConfig = TestConfigurationClass.class.getAnnotation(TestConfiguration.class);\n\t\tassertThat(contextConfig).isNotNull();\n\t\t// Alter array returned from synthesized annotation\n\t\tconfigs[0] = contextConfig;\n\t\tassertThat(configs).extracting(TestConfiguration::value).containsExactly(\"simple.xml\", \"B\");\n\t\t// Re-retrieve the array from the synthesized annotation\n\t\tconfigs = synthesizedHierarchy.value();\n\t\tassertThat(configs).extracting(TestConfiguration::value).containsExactly(\"A\", \"B\");\n\t}\n\n\t@Test\n\tvoid synthesizeWithArrayOfChars() {\n\t\tCharsContainer charsContainer = GroupOfCharsClass.class.getAnnotation(CharsContainer.class);\n\t\tassertThat(charsContainer).isNotNull();\n\t\tCharsContainer synthesizedCharsContainer = MergedAnnotation.from(charsContainer).synthesize();\n\t\tassertSynthesized(synthesizedCharsContainer);\n\t\tchar[] chars = synthesizedCharsContainer.chars();\n\t\tassertThat(chars).containsExactly('x', 'y', 'z');\n\t\t// Alter array returned from synthesized annotation\n\t\tchars[0] = '?';\n\t\t// Re-retrieve the array from the synthesized annotation\n\t\tchars = synthesizedCharsContainer.chars();\n\t\tassertThat(chars).containsExactly('x', 'y', 'z');\n\t}\n\n\t@Test\n\tvoid getValueWhenHasDefaultOverride() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(DefaultOverrideClass.class)\n\t\t\t\t.get(DefaultOverrideRoot.class);\n\t\tassertThat(annotation.getString(\"text\")).isEqualTo(\"metameta\");\n\t}\n\n\t@Test // gh-22654\n\tvoid getValueWhenHasDefaultOverrideWithImplicitAlias() {\n\t\tMergedAnnotation<?> annotation1 = MergedAnnotations.from(DefaultOverrideImplicitAliasMetaClass1.class)\n\t\t\t\t.get(DefaultOverrideRoot.class);\n\t\tassertThat(annotation1.getString(\"text\")).isEqualTo(\"alias-meta-1\");\n\t\tMergedAnnotation<?> annotation2 = MergedAnnotations.from(DefaultOverrideImplicitAliasMetaClass2.class)\n\t\t\t\t.get(DefaultOverrideRoot.class);\n\t\tassertThat(annotation2.getString(\"text\")).isEqualTo(\"alias-meta-2\");\n\t}\n\n\t@Test // gh-22654\n\tvoid getValueWhenHasDefaultOverrideWithExplicitAlias() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(DefaultOverrideExplicitAliasRootMetaMetaClass.class)\n\t\t\t\t.get(DefaultOverrideExplicitAliasRoot.class);\n\t\tassertThat(annotation.getString(\"text\")).isEqualTo(\"meta\");\n\t\tassertThat(annotation.getString(\"value\")).isEqualTo(\"meta\");\n\t}\n\n\t@Test // gh-22703\n\tvoid getValueWhenThreeDeepMetaWithValue() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(ValueAttributeMetaMetaClass.class)\n\t\t\t\t.get(ValueAttribute.class);\n\t\tassertThat(annotation.getStringArray(MergedAnnotation.VALUE)).containsExactly(\"FromValueAttributeMeta\");\n\t}\n\n\t@Test\n\tvoid asAnnotationAttributesReturnsPopulatedAnnotationAttributes() {\n\t\tMergedAnnotation<?> annotation = MergedAnnotations.from(SpringApplicationConfigurationClass.class)\n\t\t\t\t.get(SpringApplicationConfiguration.class);\n\t\tAnnotationAttributes attributes = annotation.asAnnotationAttributes(Adapt.CLASS_TO_STRING);\n\t\tassertThat(attributes).containsEntry(\"classes\", new String[] {Number.class.getName()});\n\t\tassertThat(attributes.annotationType()).isEqualTo(SpringApplicationConfiguration.class);\n\t}\n\n\n\t// @formatter:off\n\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Transactional {\n\n\t\tString value() default \"\";\n\n\t\tString qualifier() default \"transactionManager\";\n\n\t\tboolean readOnly() default false;\n\t}\n\n\t@Transactional\n\t@Component\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransactionalComponent {\n\t}\n\n\t@TransactionalComponent\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedTransactionalComponent {\n\t}\n\n\tstatic class NonAnnotatedClass {\n\t}\n\n\t@Component\n\tstatic class AnnotatedClass {\n\n\t\tclass NonAnnotatedInnerClass {\n\t\t}\n\n\t\tstatic class NonAnnotatedStaticNestedClass {\n\t\t}\n\t}\n\n\tinterface NonAnnotatedInterface {\n\t}\n\n\t@TransactionalComponent\n\tstatic class TransactionalComponentClass {\n\t}\n\n\tstatic class SubTransactionalComponentClass extends TransactionalComponentClass {\n\t}\n\n\t@ComposedTransactionalComponent\n\tstatic class ComposedTransactionalComponentClass {\n\t}\n\n\t@AliasedTransactionalComponent\n\tstatic class AliasedTransactionalComponentClass {\n\t}\n\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface AliasedTransactional {\n\n\t\t@AliasFor(attribute = \"qualifier\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tString qualifier() default \"\";\n\t}\n\n\t@Transactional(qualifier = \"composed1\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@Inherited\n\t@interface InheritedComposed {\n\t}\n\n\t@Transactional(qualifier = \"composed2\", readOnly = true)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface Composed {\n\t}\n\n\t@Transactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxComposedWithOverride {\n\n\t\tString qualifier() default \"txMgr\";\n\t}\n\n\t@Transactional(\"TxInheritedComposed\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxInheritedComposed {\n\t}\n\n\t@Transactional(\"TxComposed\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TxComposed {\n\t}\n\n\t@AliasedTransactional(value = \"aliasForQualifier\")\n\t@Component\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedTransactionalComponent {\n\t}\n\n\t@AliasedTransactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MyAliasedTransactional {\n\n\t\t@AliasFor(annotation = AliasedTransactional.class, attribute = \"value\")\n\t\tString value() default \"defaultTransactionManager\";\n\t}\n\n\t@MyAliasedTransactional(\"anotherTransactionManager\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@interface ComposedMyAliasedTransactional {\n\t}\n\n\t@ComposedMyAliasedTransactional\n\tstatic class ComposedTransactionalClass {\n\t}\n\n\t@AliasedTransactional(\"meta\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaAliasedTransactional {\n\t}\n\n\t@MetaAliasedTransactional\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMetaAliasedTransactional {\n\t}\n\n\t@MetaMetaAliasedTransactional\n\tstatic class MetaMetaAliasedTransactionalClass {\n\t}\n\n\t@TxComposedWithOverride\n\t// Override default \"txMgr\" from @TxComposedWithOverride with \"localTxMgr\"\n\t@Transactional(qualifier = \"localTxMgr\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.TYPE)\n\t@interface MetaAndLocalTxConfig {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestPropertySource {\n\n\t\t@AliasFor(\"locations\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] locations() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ContextConfiguration {\n\n\t\t@AliasFor(attribute = \"locations\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tString[] locations() default {};\n\n\t\tClass<?>[] classes() default {};\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionBasedComposedContextConfiguration {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] locations() default {};\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class)\n\t\tClass<?>[] classes() default {};\n\t}\n\n\t@ContextConfiguration(value = \"duplicateDeclaration\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface InvalidConventionBasedComposedContextConfiguration {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] locations();\n\t}\n\n\t/**\n\t * This hybrid approach for annotation attribute overrides with transitive implicit\n\t * aliases is unsupported. See SPR-13554 for details.\n\t */\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface HalfConventionBasedAndHalfAliasedComposedContextConfiguration {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] locations() default {};\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles() default {};\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles();\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedValueComposedContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"value\")\n\t\tString[] locations();\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] groovyScripts() default {};\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlFiles() default {};\n\n\t\t// intentionally omitted: attribute = \"locations\"\n\t\t@AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] locations() default {};\n\n\t\t// intentionally omitted: attribute = \"locations\" (SPR-14069)\n\t\t@AliasFor(annotation = ContextConfiguration.class)\n\t\tString[] value() default {};\n\t}\n\n\t@ImplicitAliasesContextConfiguration(xmlFiles = { \"A.xml\", \"B.xml\" })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComposedImplicitAliasesContextConfiguration {\n\t}\n\n\t@ImplicitAliasesContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesContextConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"xmlFiles\")\n\t\tString[] xml() default {};\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\n\t\tString[] groovy() default {};\n\t}\n\n\t@ImplicitAliasesContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SingleLocationTransitiveImplicitAliasesContextConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"xmlFiles\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@ImplicitAliasesContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesWithSkippedLevelContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xml() default {};\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\n\t\tString[] groovy() default {};\n\t}\n\n\t@ImplicitAliasesContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\n\t\tString groovy() default \"\";\n\t}\n\n\t/**\n\t * Although the configuration declares an explicit value for 'value' and requires a\n\t * value for the aliased 'locations', this does not result in an error since\n\t * 'locations' effectively shadows the 'value' attribute (which cannot be set via the\n\t * composed annotation anyway). If 'value' were not shadowed, such a declaration would\n\t * not make sense.\n\t */\n\t@ContextConfiguration(value = \"duplicateDeclaration\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ShadowedAliasComposedContextConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles();\n\t}\n\n\t@ContextConfiguration(locations = \"shadowed.xml\")\n\t@TestPropertySource(locations = \"test.properties\")\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedContextConfigurationAndTestPropertySource {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] xmlConfigFiles() default \"default.xml\";\n\t}\n\n\t@ContextConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface SpringApplicationConfiguration {\n\n\t\t@AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\n\t\tString[] locations() default {};\n\n\t\t// Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class, attribute = \"classes\")\n\t\t@AliasFor(\"value\")\n\t\tClass<?>[] classes() default {};\n\n\t\t// Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\n\t\t// @AliasFor(annotation = ContextConfiguration.class, attribute = \"classes\")\n\t\t@AliasFor(\"classes\")\n\t\tClass<?>[] value() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScan {\n\n\t\t@AliasFor(\"basePackages\")\n\t\tString[] value() default {};\n\n\t\t@AliasFor(\"value\")\n\t\tString[] basePackages() default {};\n\n\t\tFilter[] excludeFilters() default {};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({})\n\t@interface Filter {\n\n\t\tString pattern();\n\t}\n\n\t@ComponentScan(excludeFilters = { @Filter(pattern = \"*Test\"),\n\t\t@Filter(pattern = \"*Tests\") })\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestComponentScan {\n\n\t\t@AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\n\t\tString[] packages();\n\t}\n\n\t@ComponentScan\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ConventionBasedSinglePackageComponentScan {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = ComponentScan.class)\n\t\tString basePackages();\n\t}\n\n\t@ComponentScan\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForBasedSinglePackageComponentScan {\n\n\t\t@AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\n\t\tString pkg();\n\t}\n\n\t@Transactional\n\tstatic class ClassWithInheritedAnnotation {\n\t}\n\n\t@Composed\n\tstatic class SubClassWithInheritedAnnotation extends ClassWithInheritedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedAnnotation\n\t\t\textends SubClassWithInheritedAnnotation {\n\t}\n\n\t@InheritedComposed\n\tstatic class ClassWithInheritedComposedAnnotation {\n\t}\n\n\t@Composed\n\tstatic class SubClassWithInheritedComposedAnnotation\n\t\t\textends ClassWithInheritedComposedAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedComposedAnnotation\n\t\t\textends SubClassWithInheritedComposedAnnotation {\n\t}\n\n\t@MetaAndLocalTxConfig\n\tstatic class MetaAndLocalTxConfigClass {\n\t}\n\n\t@Transactional(\"TxConfig\")\n\tstatic class TxConfig {\n\t}\n\n\t@Transactional(\"DerivedTxConfig\")\n\tstatic class DerivedTxConfig extends TxConfig {\n\t}\n\n\t@TxInheritedComposed\n\t@TxComposed\n\tstatic class TxFromMultipleComposedAnnotations {\n\t}\n\n\t@Transactional\n\tinterface InterfaceWithInheritedAnnotation {\n\n\t\t@Order\n\t\tvoid handleFromInterface();\n\t}\n\n\tabstract static class AbstractClassWithInheritedAnnotation<T>\n\t\t\timplements InterfaceWithInheritedAnnotation {\n\n\t\t@Transactional\n\t\tpublic abstract void handle();\n\n\t\t@Transactional\n\t\tpublic void handleParameterized(T t) {\n\t\t}\n\t}\n\n\tstatic class ConcreteClassWithInheritedAnnotation\n\t\t\textends AbstractClassWithInheritedAnnotation<String> {\n\n\t\t@Override\n\t\tpublic void handle() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleParameterized(String s) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleFromInterface() {\n\t\t}\n\t}\n\n\tpublic interface GenericParameter<T> {\n\n\t\tT getFor(Class<T> cls);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class StringGenericParameter implements GenericParameter<String> {\n\n\t\t@Order\n\t\t@Override\n\t\tpublic String getFor(Class<String> cls) {\n\t\t\treturn \"foo\";\n\t\t}\n\n\t\tpublic String getFor(Integer integer) {\n\t\t\treturn \"foo\";\n\t\t}\n\t}\n\n\t@Transactional\n\tpublic interface InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubInheritedAnnotationInterface\n\t\t\textends InheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubInheritedAnnotationInterface\n\t\t\textends SubInheritedAnnotationInterface {\n\t}\n\n\t@Order\n\tpublic interface NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubNonInheritedAnnotationInterface\n\t\t\textends NonInheritedAnnotationInterface {\n\t}\n\n\tpublic interface SubSubNonInheritedAnnotationInterface\n\t\t\textends SubNonInheritedAnnotationInterface {\n\t}\n\n\t@ConventionBasedComposedContextConfiguration(locations = \"explicitDeclaration\")\n\tstatic class ConventionBasedComposedContextConfigurationClass {\n\t}\n\n\t@InvalidConventionBasedComposedContextConfiguration(locations = \"requiredLocationsDeclaration\")\n\tstatic class InvalidConventionBasedComposedContextConfigurationClass {\n\t}\n\n\t@HalfConventionBasedAndHalfAliasedComposedContextConfiguration(xmlConfigFiles = \"explicitDeclaration\")\n\tstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass1 {\n\t}\n\n\t@HalfConventionBasedAndHalfAliasedComposedContextConfiguration(locations = \"explicitDeclaration\")\n\tstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass2 {\n\t}\n\n\t@AliasedComposedContextConfiguration(xmlConfigFiles = \"test.xml\")\n\tstatic class AliasedComposedContextConfigurationClass {\n\t}\n\n\t@AliasedValueComposedContextConfiguration(locations = \"test.xml\")\n\tstatic class AliasedValueComposedContextConfigurationClass {\n\t}\n\n\t@ImplicitAliasesContextConfiguration(\"foo.xml\")\n\tstatic class ImplicitAliasesContextConfigurationClass1 {\n\t}\n\n\t@ImplicitAliasesContextConfiguration(locations = \"bar.xml\")\n\tstatic class ImplicitAliasesContextConfigurationClass2 {\n\t}\n\n\t@ImplicitAliasesContextConfiguration(xmlFiles = \"baz.xml\")\n\tstatic class ImplicitAliasesContextConfigurationClass3 {\n\t}\n\n\t@TransitiveImplicitAliasesContextConfiguration(groovy = \"test.groovy\")\n\tstatic class TransitiveImplicitAliasesContextConfigurationClass {\n\t}\n\n\t@SingleLocationTransitiveImplicitAliasesContextConfiguration(groovy = \"test.groovy\")\n\tstatic class SingleLocationTransitiveImplicitAliasesContextConfigurationClass {\n\t}\n\n\t@TransitiveImplicitAliasesWithSkippedLevelContextConfiguration(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass {\n\t}\n\n\t@SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfiguration(xml = \"test.xml\")\n\tstatic class SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass {\n\t}\n\n\t@ComposedImplicitAliasesContextConfiguration\n\tstatic class ComposedImplicitAliasesContextConfigurationClass {\n\t}\n\n\t@ShadowedAliasComposedContextConfiguration(xmlConfigFiles = \"test.xml\")\n\tstatic class ShadowedAliasComposedContextConfigurationClass {\n\t}\n\n\t@AliasedComposedContextConfigurationAndTestPropertySource(xmlConfigFiles = \"test.xml\")\n\tstatic class AliasedComposedContextConfigurationAndTestPropertySourceClass {\n\t}\n\n\t@ComponentScan(value = \"com.example.app.test\", basePackages = \"com.example.app.test\")\n\tstatic class ComponentScanWithBasePackagesAndValueAliasClass {\n\t}\n\n\t@TestComponentScan(packages = \"com.example.app.test\")\n\tstatic class TestComponentScanClass {\n\t}\n\n\t@ConventionBasedSinglePackageComponentScan(basePackages = \"com.example.app.test\")\n\tstatic class ConventionBasedSinglePackageComponentScanClass {\n\t}\n\n\t@AliasForBasedSinglePackageComponentScan(pkg = \"com.example.app.test\")\n\tstatic class AliasForBasedSinglePackageComponentScanClass {\n\t}\n\n\t@SpringApplicationConfiguration(Number.class)\n\tstatic class SpringApplicationConfigurationClass {\n\t}\n\n\t@Resource(name = \"x\")\n\tstatic class ResourceHolder {\n\t}\n\n\tinterface TransactionalService {\n\n\t\t@Transactional\n\t\tvoid doIt();\n\t}\n\n\tclass TransactionalServiceImpl implements TransactionalService {\n\n\t\t@Override\n\t\tpublic void doIt() {\n\t\t}\n\t}\n\n\t@Component(\"meta1\")\n\t@Order\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface Meta1 {\n\t}\n\n\t@Component(\"meta2\")\n\t@Transactional(readOnly = true)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Meta2 {\n\t}\n\n\t@Meta2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMeta {\n\t}\n\n\t@MetaMeta\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaMetaMeta {\n\t}\n\n\t@MetaCycle3\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle1 {\n\t}\n\n\t@MetaCycle1\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle2 {\n\t}\n\n\t@MetaCycle2\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface MetaCycle3 {\n\t}\n\n\t@Meta1\n\tinterface InterfaceWithMetaAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface\n\t\t\timplements InterfaceWithMetaAnnotation {\n\t}\n\n\t@Meta1\n\tstatic class ClassWithInheritedMetaAnnotation {\n\t}\n\n\t@Meta2\n\tstatic class SubClassWithInheritedMetaAnnotation\n\t\t\textends ClassWithInheritedMetaAnnotation {\n\t}\n\n\tstatic class SubSubClassWithInheritedMetaAnnotation\n\t\t\textends SubClassWithInheritedMetaAnnotation {\n\t}\n\n\t@MetaMeta\n\tstatic class MetaMetaAnnotatedClass {\n\t}\n\n\t@MetaMetaMeta\n\tstatic class MetaMetaMetaAnnotatedClass {\n\t}\n\n\t@MetaCycle3\n\tstatic class MetaCycleAnnotatedClass {\n\t}\n\n\tinterface AnnotatedInterface {\n\n\t\t@Order(0)\n\t\tvoid fromInterfaceImplementedByRoot();\n\t}\n\n\tinterface NullableAnnotatedInterface {\n\n\t\t@Nullable String fromInterfaceImplementedByRoot();\n\t}\n\n\tstatic class Root implements AnnotatedInterface {\n\n\t\t@Order(27)\n\t\tpublic void annotatedOnRoot() {\n\t\t}\n\n\t\t@Meta1\n\t\tpublic void metaAnnotatedOnRoot() {\n\t\t}\n\n\t\tpublic void overrideToAnnotate() {\n\t\t}\n\n\t\t@Order(27)\n\t\tpublic void overrideWithoutNewAnnotation() {\n\t\t}\n\n\t\tpublic void notAnnotated() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void fromInterfaceImplementedByRoot() {\n\t\t}\n\t}\n\n\tpublic static class Leaf extends Root {\n\n\t\t@Order(25)\n\t\tpublic void annotatedOnLeaf() {\n\t\t}\n\n\t\t@Meta1\n\t\tpublic void metaAnnotatedOnLeaf() {\n\t\t}\n\n\t\t@MetaMeta\n\t\tpublic void metaMetaAnnotatedOnLeaf() {\n\t\t}\n\n\t\t@Override\n\t\t@Order(1)\n\t\tpublic void overrideToAnnotate() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void overrideWithoutNewAnnotation() {\n\t\t}\n\t}\n\n\tpublic abstract static class SimpleGeneric<T> {\n\n\t\t@Order(1)\n\t\tpublic abstract void something(T arg);\n\n\t}\n\n\tpublic static class TransactionalStringGeneric extends SimpleGeneric<String> {\n\n\t\t@Override\n\t\t@Transactional\n\t\tpublic void something(final String arg) {\n\t\t}\n\t}\n\n\t@Transactional\n\tpublic static class InheritedAnnotationClass {\n\t}\n\n\tpublic static class SubInheritedAnnotationClass extends InheritedAnnotationClass {\n\t}\n\n\t@Order\n\tpublic static class NonInheritedAnnotationClass {\n\t}\n\n\tpublic static class SubNonInheritedAnnotationClass\n\t\t\textends NonInheritedAnnotationClass {\n\t}\n\n\t@Transactional\n\tpublic static class TransactionalClass {\n\t}\n\n\t@Order\n\tpublic static class TransactionalAndOrderedClass extends TransactionalClass {\n\t}\n\n\tpublic static class SubTransactionalAndOrderedClass\n\t\t\textends TransactionalAndOrderedClass {\n\t}\n\n\tpublic interface InterfaceWithAnnotatedMethod {\n\n\t\t@Order\n\t\tvoid foo();\n\t}\n\n\tpublic static class ImplementsInterfaceWithAnnotatedMethod\n\t\t\timplements InterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic static class SubOfImplementsInterfaceWithAnnotatedMethod\n\t\t\textends ImplementsInterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic abstract static class AbstractDoesNotImplementInterfaceWithAnnotatedMethod\n\t\t\timplements InterfaceWithAnnotatedMethod {\n\t}\n\n\tpublic static class SubOfAbstractImplementsInterfaceWithAnnotatedMethod\n\t\t\textends AbstractDoesNotImplementInterfaceWithAnnotatedMethod {\n\n\t\t@Override\n\t\tpublic void foo() {\n\t\t}\n\t}\n\n\tpublic interface InterfaceWithGenericAnnotatedMethod<T> {\n\n\t\t@Order\n\t\tvoid foo(T t);\n\t}\n\n\tpublic static class ImplementsInterfaceWithGenericAnnotatedMethod\n\t\t\timplements InterfaceWithGenericAnnotatedMethod<String> {\n\n\t\t@Override\n\t\tpublic void foo(String t) {\n\t\t}\n\t}\n\n\tpublic abstract static class BaseClassWithGenericAnnotatedMethod<T> {\n\n\t\t@Order\n\t\tabstract void foo(T t);\n\t}\n\n\tpublic static class ExtendsBaseClassWithGenericAnnotatedMethod\n\t\t\textends BaseClassWithGenericAnnotatedMethod<String> {\n\n\t\t@Override\n\t\tpublic void foo(String t) {\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@interface MyRepeatableContainer {\n\n\t\tMyRepeatable[] value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@Repeatable(MyRepeatableContainer.class)\n\t@interface MyRepeatable {\n\n\t\tString value();\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta1\")\n\t@interface MyRepeatableMeta1 {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Inherited\n\t@MyRepeatable(\"meta2\")\n\t@interface MyRepeatableMeta2 {\n\t}\n\n\tinterface InterfaceWithRepeated {\n\n\t\t@MyRepeatable(\"A\")\n\t\t@MyRepeatableContainer({ @MyRepeatable(\"B\"), @MyRepeatable(\"C\") })\n\t\t@MyRepeatableMeta1\n\t\tvoid foo();\n\t}\n\n\t@MyRepeatable(\"A\")\n\t@MyRepeatableContainer({ @MyRepeatable(\"B\"), @MyRepeatable(\"C\") })\n\t@MyRepeatableMeta1\n\tstatic class MyRepeatableClass {\n\t}\n\n\tstatic class SubMyRepeatableClass extends MyRepeatableClass {\n\t}\n\n\t@MyRepeatable(\"X\")\n\t@MyRepeatableContainer({ @MyRepeatable(\"Y\"), @MyRepeatable(\"Z\") })\n\t@MyRepeatableMeta2\n\tstatic class SubMyRepeatableWithAdditionalLocalDeclarationsClass\n\t\t\textends MyRepeatableClass {\n\t}\n\n\tstatic class SubSubMyRepeatableWithAdditionalLocalDeclarationsClass\n\t\t\textends SubMyRepeatableWithAdditionalLocalDeclarationsClass {\n\t}\n\n\tenum RequestMethod {\n\t\tGET,\n\n\t\tPOST;\n\n\t\t/**\n\t\t * custom override to verify annotation toString() implementations.\n\t\t */\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"method: \" + name().toLowerCase();\n\t\t}\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface RequestMapping {\n\n\t\tString name();\n\n\t\t@AliasFor(\"path\")\n\t\tString[] value() default \"\";\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tString[] path() default \"\";\n\n\t\tRequestMethod[] method() default {};\n\n\t\t// ---------------------------------------------------------------------\n\t\t// All remaining attributes declare default values that are used solely\n\t\t// for the purpose of testing the toString() implementations for annotations.\n\t\tClass<?> clazz() default RequestMethod.class;\n\t\tClass<?>[] classes() default {int[][].class, RequestMethod[].class};\n\n\t\tchar ch() default 'X';\n\t\tchar[] chars() default {'X'};\n\n\t\tbyte byteValue() default (byte) 0xFF;\n\t\tbyte[] bytes() default {(byte) 0xFF};\n\n\t\tshort shortValue() default 9876;\n\t\tshort[] shorts() default {9876};\n\n\t\tlong longValue() default 42L;\n\t\tlong[] longs() default {42L};\n\n\t\tfloat floatValue() default 3.14F;\n\t\tfloat[] floats() default {3.14F};\n\n\t\tdouble doubleValue() default 99.999D;\n\t\tdouble[] doubles() default {99.999D};\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@RequestMapping(method = RequestMethod.GET, name = \"\")\n\t@interface GetMapping {\n\n\t\t@AliasFor(annotation = RequestMapping.class)\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = RequestMapping.class)\n\t\tString path() default \"\";\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@RequestMapping(method = RequestMethod.POST, name = \"\")\n\t@interface PostMapping {\n\n\t\t// Do NOT use @AliasFor here until Spring 6.1\n\t\t// @AliasFor(annotation = RequestMapping.class)\n\t\tString path() default \"\";\n\t}\n\n\t@Component(\"webController\")\n\tstatic class WebController {\n\n\t\t@RequestMapping(value = \"/test\", name = \"foo\")\n\t\tpublic void handleMappedWithValueAttribute() {\n\t\t}\n\n\t\t@RequestMapping(path = \"/test\", name = \"bar\", method = { RequestMethod.GET,\n\t\t\tRequestMethod.POST })\n\t\tpublic void handleMappedWithPathAttribute() {\n\t\t}\n\n\t\t@GetMapping(\"/test\")\n\t\tpublic void getMappedWithValueAttribute() {\n\t\t}\n\n\t\t@GetMapping(path = \"/test\")\n\t\tpublic void getMappedWithPathAttribute() {\n\t\t}\n\n\t\t@PostMapping(path = \"/test\")\n\t\tpublic void postMappedWithPathAttribute() {\n\t\t}\n\n\t\t@RequestMapping(value = \"/test\", path = \"/test\", name = \"bar\", method = {\n\t\t\tRequestMethod.GET, RequestMethod.POST })\n\t\tpublic void handleMappedWithSamePathAndValueAttributes() {\n\t\t}\n\n\t\t@RequestMapping(value = \"/enigma\", path = \"/test\", name = \"baz\")\n\t\tpublic void handleMappedWithDifferentPathAndValueAttributes() {\n\t\t}\n\t}\n\n\t/**\n\t * Mimics jakarta.persistence.Id\n\t */\n\t@Retention(RUNTIME)\n\t@interface Id {\n\t}\n\n\t/**\n\t * Mimics jakarta.persistence.GeneratedValue\n\t */\n\t@Retention(RUNTIME)\n\t@interface GeneratedValue {\n\t\tString strategy();\n\t}\n\n\t@Id\n\t@GeneratedValue(strategy = \"AUTO\")\n\tprivate Long getId() {\n\t\treturn 42L;\n\t}\n\n\t/**\n\t * Mimics org.springframework.security.config.annotation.authentication.configuration.EnableGlobalAuthentication\n\t */\n\t@Retention(RUNTIME)\n\t@interface EnableGlobalAuthentication {\n\t}\n\n\t/**\n\t * Mimics org.springframework.security.config.annotation.web.configuration.EnableWebSecurity\n\t */\n\t@Retention(RUNTIME)\n\t@EnableGlobalAuthentication\n\t@interface EnableWebSecurity {\n\t}\n\n\t@EnableWebSecurity\n\tstatic class SecurityConfig {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ ElementType.FIELD, ElementType.ANNOTATION_TYPE })\n\t@interface RootAnnotation {\n\t\tString value() default \"\";\n\t\tboolean flag() default false;\n\t}\n\n\t@RootAnnotation\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ ElementType.FIELD, ElementType.ANNOTATION_TYPE })\n\t@interface ComposedRootAnnotation {\n\n\t\t@AliasFor(annotation = RootAnnotation.class, attribute = \"flag\")\n\t\tboolean enabled() default true;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.FIELD)\n\t@ComposedRootAnnotation\n\t@interface DoublyComposedRootAnnotation {\n\t}\n\n\tclass DomainType {\n\n\t\t@RootAnnotation\n\t\tObject directlyAnnotated;\n\n\t\t@ComposedRootAnnotation\n\t\tObject metaAnnotated;\n\n\t\t@DoublyComposedRootAnnotation\n\t\tObject metaMetaAnnotated;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TestConfiguration {\n\n\t\t@AliasFor(\"location\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(\"value\")\n\t\tString location() default \"\";\n\n\t\tClass<?> configClass() default Object.class;\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface Hierarchy {\n\n\t\tTestConfiguration[] value();\n\t}\n\n\t@Hierarchy({ @TestConfiguration(\"A\"), @TestConfiguration(location = \"B\") })\n\tstatic class HierarchyClass {\n\t}\n\n\t@TestConfiguration(\"simple.xml\")\n\tstatic class TestConfigurationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface CharsContainer {\n\n\t\t@AliasFor(attribute = \"chars\")\n\t\tchar[] value() default {};\n\n\t\t@AliasFor(attribute = \"value\")\n\t\tchar[] chars() default {};\n\t}\n\n\t@CharsContainer(chars = { 'x', 'y', 'z' })\n\tstatic class GroupOfCharsClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMissingAttributeDeclaration {\n\n\t\t@AliasFor\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForWithMissingAttributeDeclaration\n\tstatic class AliasForWithMissingAttributeDeclarationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithDuplicateAttributeDeclaration {\n\n\t\t@AliasFor(value = \"bar\", attribute = \"baz\")\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForWithDuplicateAttributeDeclaration\n\tstatic class AliasForWithDuplicateAttributeDeclarationClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForNonexistentAttribute {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"\";\n\t}\n\n\t@AliasForNonexistentAttribute\n\tstatic class AliasForNonexistentAttributeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithoutMirroredAliasFor {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"\";\n\n\t\tString bar() default \"\";\n\t}\n\n\t@AliasForWithoutMirroredAliasFor\n\tstatic class AliasForWithoutMirroredAliasForClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMirroredAliasForWrongAttribute {\n\n\t\t@AliasFor(attribute = \"bar\")\n\t\tString[] foo() default \"\";\n\n\t\t@AliasFor(attribute = \"quux\")\n\t\tString[] bar() default \"\";\n\t}\n\n\t@AliasForWithMirroredAliasForWrongAttribute\n\tstatic class AliasForWithMirroredAliasForWrongAttributeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForAttributeOfDifferentType {\n\n\t\t@AliasFor(\"bar\")\n\t\tString[] foo() default \"\";\n\n\t\t@AliasFor(\"foo\")\n\t\tboolean bar() default true;\n\t}\n\n\t@AliasForAttributeOfDifferentType\n\tstatic class AliasForAttributeOfDifferentTypeClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForWithMissingDefaultValues {\n\n\t\t@AliasFor(attribute = \"bar\")\n\t\tString foo();\n\n\t\t@AliasFor(attribute = \"foo\")\n\t\tString bar();\n\t}\n\n\t@AliasForWithMissingDefaultValues(foo = \"foo\", bar = \"bar\")\n\tstatic class AliasForWithMissingDefaultValuesClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasForAttributeWithDifferentDefaultValue {\n\n\t\t@AliasFor(\"bar\")\n\t\tString foo() default \"X\";\n\n\t\t@AliasFor(\"foo\")\n\t\tString bar() default \"Z\";\n\t}\n\n\t@AliasForAttributeWithDifferentDefaultValue\n\tstatic class AliasForAttributeWithDifferentDefaultValueClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedTestConfigurationNotMetaPresent {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlConfigFile();\n\t}\n\n\t@AliasedComposedTestConfigurationNotMetaPresent(xmlConfigFile = \"test.xml\")\n\tstatic class AliasedComposedTestConfigurationNotMetaPresentClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AliasedComposedTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlConfigFile();\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\tpublic @interface ImplicitAliasesTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString groovyScript() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location1() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location2() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location3() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"configClass\")\n\t\tClass<?> configClass() default Object.class;\n\n\t\tString nonAliasedAttribute() default \"\";\n\t}\n\n\t@ImplicitAliasesTestConfiguration(groovyScript = \"groovyScript\")\n\tstatic class GroovyImplicitAliasesSimpleTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(xmlFile = \"xmlFile\")\n\tstatic class XmlImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(\"value\")\n\tstatic class ValueImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(location1 = \"location1\")\n\tstatic class Location1ImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(location2 = \"location2\")\n\tstatic class Location2ImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration(location3 = \"location3\")\n\tstatic class Location3ImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class)\n\t\tString value() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class)\n\t\tString location() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration.class, attribute = \"location\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration(\"value\")\n\tstatic class ValueImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration(location = \"location\")\n\tstatic class LocationsImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration(xmlFile = \"xmlFile\")\n\tstatic class XmlFilesImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithMissingDefaultValuesTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location1();\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location2();\n\t}\n\n\t@ImplicitAliasesWithMissingDefaultValuesTestConfiguration(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithMissingDefaultValuesTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithDifferentDefaultValuesTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location1() default \"foo\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location2() default \"bar\";\n\t}\n\n\t@ImplicitAliasesWithDifferentDefaultValuesTestConfiguration(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithDifferentDefaultValuesTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesWithDuplicateValuesTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location1() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString location2() default \"\";\n\t}\n\n\t@ImplicitAliasesWithDuplicateValuesTestConfiguration(location1 = \"1\", location2 = \"2\")\n\tstatic class ImplicitAliasesWithDuplicateValuesTestConfigurationClass {\n\t}\n\n\t@TestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ImplicitAliasesForAliasPairTestConfiguration {\n\n\t\t@AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\n\t\tString xmlFile() default \"\";\n\n\t\t@AliasFor(annotation = TestConfiguration.class, value = \"value\")\n\t\tString groovyScript() default \"\";\n\t}\n\n\t@ImplicitAliasesForAliasPairTestConfiguration(xmlFile = \"test.xml\")\n\tstatic class ImplicitAliasesForAliasPairTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesTestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesTestConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesTestConfiguration.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesTestConfiguration.class, attribute = \"groovyScript\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@TransitiveImplicitAliasesTestConfiguration(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesTestConfigurationClass {\n\t}\n\n\t@ImplicitAliasesForAliasPairTestConfiguration\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface TransitiveImplicitAliasesForAliasPairTestConfiguration {\n\n\t\t@AliasFor(annotation = ImplicitAliasesForAliasPairTestConfiguration.class, attribute = \"xmlFile\")\n\t\tString xml() default \"\";\n\n\t\t@AliasFor(annotation = ImplicitAliasesForAliasPairTestConfiguration.class, attribute = \"groovyScript\")\n\t\tString groovy() default \"\";\n\t}\n\n\t@TransitiveImplicitAliasesForAliasPairTestConfiguration(xml = \"test.xml\")\n\tstatic class TransitiveImplicitAliasesForAliasPairTestConfigurationClass {\n\t}\n\n\t@ComponentScan(excludeFilters = { @Filter(pattern = \"*Foo\"),\n\t\t@Filter(pattern = \"*Bar\") })\n\tstatic class ComponentScanClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ComponentScanSingleFilter {\n\n\t\tFilter value();\n\t}\n\n\t@ComponentScanSingleFilter(@Filter(pattern = \"*Foo\"))\n\tstatic class ComponentScanSingleFilterClass {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnotationWithDefaults {\n\n\t\tString text() default \"enigma\";\n\n\t\tboolean predicate() default true;\n\n\t\tchar[] characters() default { 'a', 'b', 'c' };\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnotationWithoutDefaults {\n\n\t\tString text();\n\t}\n\n\t@TestConfiguration(value = \"foo\", location = \"bar\")\n\tinterface TestConfigurationMismatch {\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface DefaultOverrideRoot {\n\n\t\tString text() default \"root\";\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideRoot\n\t@interface DefaultOverrideMeta {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideMeta\n\t@interface DefaultOverrideMetaMeta {\n\n\t\tString text() default \"metameta\";\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideMetaMeta\n\t@interface DefaultOverrideMetaMetaMeta {\n\n\t}\n\n\t@DefaultOverrideMetaMetaMeta\n\tstatic class DefaultOverrideClass {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideRoot\n\t@interface DefaultOverrideImplicitAlias {\n\n\t\t@AliasFor(annotation=DefaultOverrideRoot.class, attribute=\"text\")\n\t\tString text1() default \"alias\";\n\n\t\t@AliasFor(annotation=DefaultOverrideRoot.class, attribute=\"text\")\n\t\tString text2() default \"alias\";\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideImplicitAlias(text1=\"alias-meta-1\")\n\t@interface DefaultOverrideAliasImplicitMeta1 {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideImplicitAlias(text2=\"alias-meta-2\")\n\t@interface DefaultOverrideImplicitAliasMeta2 {\n\n\t}\n\n\t@DefaultOverrideAliasImplicitMeta1\n\tstatic class DefaultOverrideImplicitAliasMetaClass1 {\n\n\t}\n\n\t@DefaultOverrideImplicitAliasMeta2\n\tstatic class DefaultOverrideImplicitAliasMetaClass2 {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface DefaultOverrideExplicitAliasRoot {\n\n\t\t@AliasFor(\"value\")\n\t\tString text() default \"\";\n\n\t\t@AliasFor(\"text\")\n\t\tString value() default \"\";\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideExplicitAliasRoot(\"meta\")\n\t@interface DefaultOverrideExplicitAliasRootMeta {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DefaultOverrideExplicitAliasRootMeta\n\t@interface DefaultOverrideExplicitAliasRootMetaMeta {\n\n\t}\n\n\t@DefaultOverrideExplicitAliasRootMetaMeta\n\tstatic class DefaultOverrideExplicitAliasRootMetaMetaClass {\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface ValueAttribute {\n\n\t\tString[] value();\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueAttribute(\"FromValueAttributeMeta\")\n\t@interface ValueAttributeMeta {\n\n\t\tString[] value() default {};\n\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueAttributeMeta(\"FromValueAttributeMetaMeta\")\n\t@interface ValueAttributeMetaMeta {\n\n\t}\n\n\t@ValueAttributeMetaMeta\n\tstatic class ValueAttributeMetaMetaClass {\n\n\t}\n\t// @formatter:on\n\n\tstatic void assertSynthesized(Annotation annotation) {\n\t\tassertThat(AnnotationUtils.isSynthesizedAnnotation(annotation)).as(\"synthesized annotation\").isTrue();\n\t}\n\n\tstatic void assertNotSynthesized(Annotation annotation) {\n\t\tassertThat(AnnotationUtils.isSynthesizedAnnotation(annotation)).as(\"synthesized annotation\").isFalse();\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.annotation",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.annotation.TransitiveImplicitAliasesContextConfigurationClass",
    "tailType": "class"
  }
]