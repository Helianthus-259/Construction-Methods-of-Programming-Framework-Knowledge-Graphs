[
  {
    "head": "org.springframework.aot.hint.ExecutableHint#compareTo(ExecutableHint)",
    "headType": "method",
    "relation": "provide",
    "tail": "@Override\r\npublic int compareTo(ExecutableHint other) {\r\n    return Comparator.comparing(ExecutableHint::getName, String::compareToIgnoreCase).thenComparing(ExecutableHint::getParameterTypes, Comparator.comparingInt(List::size)).thenComparing(ExecutableHint::getParameterTypes, (params1, params2) -> {\r\n        String left = params1.stream().map(TypeReference::getCanonicalName).collect(Collectors.joining(\",\"));\r\n        String right = params2.stream().map(TypeReference::getCanonicalName).collect(Collectors.joining(\",\"));\r\n        return left.compareTo(right);\r\n    }).compare(this, other);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.hint.ExecutableHint",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.hint.ExecutableHint#compareTo(ExecutableHint)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.aot.hint.ExecutableHint#compareTo(ExecutableHint)",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.aot.hint.ExecutableHint",
    "headType": "class",
    "relation": "extend",
    "tail": "MemberHint",
    "tailType": "class"
  },
  {
    "head": "org.springframework.aot.hint",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.aot.hint.Builder",
    "tailType": "class"
  },
  {
    "head": "org.springframework.aot.hint.Builder",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.aot.hint;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Executable;\nimport java.lang.reflect.Method;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.function.Consumer;\nimport java.util.stream.Collectors;\n\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.util.Assert;\n\n/**\n * A hint that describes the need for reflection on a {@link Method} or\n * {@link Constructor}.\n *\n * @author Stephane Nicoll\n * @since 6.0\n */\npublic final class ExecutableHint extends MemberHint implements Comparable<ExecutableHint> {\n\n\tprivate final List<TypeReference> parameterTypes;\n\n\tprivate final ExecutableMode mode;\n\n\n\tprivate ExecutableHint(Builder builder) {\n\t\tsuper(builder.name);\n\t\tthis.parameterTypes = List.copyOf(builder.parameterTypes);\n\t\tthis.mode = (builder.mode != null ? builder.mode : ExecutableMode.INVOKE);\n\t}\n\n\t/**\n\t * Initialize a builder with the parameter types of a constructor.\n\t * @param parameterTypes the parameter types of the constructor\n\t * @return a builder\n\t */\n\tstatic Builder ofConstructor(List<TypeReference> parameterTypes) {\n\t\treturn new Builder(\"<init>\", parameterTypes);\n\t}\n\n\t/**\n\t * Initialize a builder with the name and parameter types of a method.\n\t * @param name the name of the method\n\t * @param parameterTypes the parameter types of the method\n\t * @return a builder\n\t */\n\tstatic Builder ofMethod(String name, List<TypeReference> parameterTypes) {\n\t\treturn new Builder(name, parameterTypes);\n\t}\n\n\t/**\n\t * Return the parameter types of the executable.\n\t * @return the parameter types\n\t * @see Executable#getParameterTypes()\n\t */\n\tpublic List<TypeReference> getParameterTypes() {\n\t\treturn this.parameterTypes;\n\t}\n\n\t/**\n\t * Return the {@linkplain ExecutableMode mode} that applies to this hint.\n\t * @return the mode\n\t */\n\tpublic ExecutableMode getMode() {\n\t\treturn this.mode;\n\t}\n\n\t/**\n\t * Return a {@link Consumer} that applies the given {@link ExecutableMode}\n\t * to the accepted {@link Builder}.\n\t * @param mode the mode to apply\n\t * @return a consumer to apply the mode\n\t */\n\tpublic static Consumer<Builder> builtWith(ExecutableMode mode) {\n\t\treturn builder -> builder.withMode(mode);\n\t}\n\n\t@Override\n\tpublic int compareTo(ExecutableHint other) {\n\t\treturn Comparator.comparing(ExecutableHint::getName, String::compareToIgnoreCase)\n\t\t\t\t.thenComparing(ExecutableHint::getParameterTypes, Comparator.comparingInt(List::size))\n\t\t\t\t.thenComparing(ExecutableHint::getParameterTypes, (params1, params2) -> {\n\t\t\t\t\tString left = params1.stream().map(TypeReference::getCanonicalName).collect(Collectors.joining(\",\"));\n\t\t\t\t\tString right = params2.stream().map(TypeReference::getCanonicalName).collect(Collectors.joining(\",\"));\n\t\t\t\t\treturn left.compareTo(right);\n\t\t\t\t}).compare(this, other);\n\t}\n\n\t/**\n\t * Builder for {@link ExecutableHint}.\n\t */\n\tpublic static class Builder {\n\n\t\tprivate final String name;\n\n\t\tprivate final List<TypeReference> parameterTypes;\n\n\t\tprivate @Nullable ExecutableMode mode;\n\n\n\t\tBuilder(String name, List<TypeReference> parameterTypes) {\n\t\t\tthis.name = name;\n\t\t\tthis.parameterTypes = parameterTypes;\n\t\t}\n\n\t\t/**\n\t\t * Specify that the {@linkplain ExecutableMode mode} is required.\n\t\t * @param mode the required mode\n\t\t * @return {@code this}, to facilitate method chaining\n\t\t */\n\t\tpublic Builder withMode(ExecutableMode mode) {\n\t\t\tAssert.notNull(mode, \"'mode' must not be null\");\n\t\t\tif ((this.mode == null) || !this.mode.includes(mode)) {\n\t\t\t\tthis.mode = mode;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Create an {@link ExecutableHint} based on the state of this builder.\n\t\t * @return an executable hint\n\t\t */\n\t\tExecutableHint build() {\n\t\t\treturn new ExecutableHint(this);\n\t\t}\n\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.aot.hint.Builder",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.aot.hint.Builder#name",
    "tailType": "field"
  },
  {
    "head": "org.springframework.aot.hint.Builder#name",
    "headType": "field",
    "relation": "haveType",
    "tail": "String",
    "tailType": "type"
  },
  {
    "head": "org.springframework.aot.hint.Builder",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.aot.hint.Builder#parameterTypes",
    "tailType": "field"
  },
  {
    "head": "org.springframework.aot.hint.Builder#parameterTypes",
    "headType": "field",
    "relation": "haveType",
    "tail": "List<TypeReference>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.aot.hint.Builder",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.aot.hint.Builder#mode",
    "tailType": "field"
  },
  {
    "head": "org.springframework.aot.hint.Builder#mode",
    "headType": "field",
    "relation": "haveType",
    "tail": "ExecutableMode",
    "tailType": "type"
  },
  {
    "head": "org.springframework.aot.hint.Builder#withMode(ExecutableMode)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Specify that the {@linkplain ExecutableMode mode} is required.\r\n * @param mode the required mode\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic Builder withMode(ExecutableMode mode) {\r\n    Assert.notNull(mode, \"'mode' must not be null\");\r\n    if ((this.mode == null) || !this.mode.includes(mode)) {\r\n        this.mode = mode;\r\n    }\r\n    return this;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.hint.Builder",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.hint.Builder#withMode(ExecutableMode)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.aot.hint.Builder#build()",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Create an {@link ExecutableHint} based on the state of this builder.\r\n * @return an executable hint\r\n */\r\nExecutableHint build() {\r\n    return new ExecutableHint(this);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.aot.hint.Builder",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.aot.hint.Builder#build()",
    "tailType": "method"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.aot.hint",
    "tailType": "package"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.util",
    "tailType": "package"
  },
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.AssertTests",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.AssertTests",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.function.Supplier;\n\nimport org.junit.jupiter.api.Test;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Collections.emptyList;\nimport static java.util.Collections.emptyMap;\nimport static java.util.Collections.singletonList;\nimport static java.util.Collections.singletonMap;\nimport static org.assertj.core.api.Assertions.assertThatCode;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\nimport static org.assertj.core.api.Assertions.assertThatIllegalStateException;\n\n/**\n * Tests for {@link Assert}.\n *\n * @author Keith Donald\n * @author Erwin Vervaet\n * @author Rick Evans\n * @author Arjen Poutsma\n * @author Sam Brannen\n * @author Juergen Hoeller\n */\nclass AssertTests {\n\n\t@Test\n\tvoid stateWithMessage() {\n\t\tAssert.state(true, \"enigma\");\n\t}\n\n\t@Test\n\tvoid stateWithFalseExpressionAndMessage() {\n\t\tassertThatIllegalStateException().isThrownBy(() ->\n\t\tAssert.state(false, \"enigma\")).withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid stateWithMessageSupplier() {\n\t\tAssert.state(true, () -> \"enigma\");\n\t}\n\n\t@Test\n\tvoid stateWithFalseExpressionAndMessageSupplier() {\n\t\tassertThatIllegalStateException().isThrownBy(() ->\n\t\t\t\tAssert.state(false, () -> \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid stateWithFalseExpressionAndNullMessageSupplier() {\n\t\tassertThatIllegalStateException().isThrownBy(() ->\n\t\t\t\tAssert.state(false, (Supplier<String>) null))\n\t\t\t.withMessage(null);\n\t}\n\n\t@Test\n\tvoid isTrueWithMessage() {\n\t\tAssert.isTrue(true, \"enigma\");\n\t}\n\n\t@Test\n\tvoid isTrueWithFalse() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.isTrue(false, \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid isTrueWithMessageSupplier() {\n\t\tAssert.isTrue(true, () -> \"enigma\");\n\t}\n\n\t@Test\n\tvoid isTrueWithFalseAndMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.isTrue(false, () -> \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid isTrueWithFalseAndNullMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.isTrue(false, (Supplier<String>) null))\n\t\t\t.withMessage(null);\n\t}\n\n\t@Test\n\tvoid isNullWithMessage() {\n\t\tAssert.isNull(null, \"Bla\");\n\t}\n\n\t@Test\n\tvoid isNullWithMessageSupplier() {\n\t\tAssert.isNull(null, () -> \"enigma\");\n\t}\n\n\t@Test\n\tvoid isNullWithNonNullObjectAndMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.isNull(\"foo\", () -> \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid isNullWithNonNullObjectAndNullMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.isNull(\"foo\", (Supplier<String>) null))\n\t\t\t.withMessage(null);\n\t}\n\n\t@Test\n\tvoid notNullWithMessage() {\n\t\tAssert.notNull(\"foo\", \"enigma\");\n\t}\n\n\t@Test\n\tvoid notNullWithMessageSupplier() {\n\t\tAssert.notNull(\"foo\", () -> \"enigma\");\n\t}\n\n\t@Test\n\tvoid notNullWithNullAndMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.notNull(null, () -> \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid notNullWithNullAndNullMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.notNull(null, (Supplier<String>) null))\n\t\t\t.withMessage(null);\n\t}\n\n\t@Test\n\tvoid hasLength() {\n\t\tAssert.hasLength(\"I Heart ...\", \"enigma\");\n\t}\n\n\t@Test\n\tvoid hasLengthWithWhitespaceOnly() {\n\t\tAssert.hasLength(\"\\t  \", \"enigma\");\n\t}\n\n\t@Test\n\tvoid hasLengthWithEmptyString() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.hasLength(\"\", \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid hasLengthWithNull() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.hasLength(null, \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid hasLengthWithMessageSupplier() {\n\t\tAssert.hasLength(\"foo\", () -> \"enigma\");\n\t}\n\n\t@Test\n\tvoid hasLengthWithWhitespaceOnlyAndMessageSupplier() {\n\t\tAssert.hasLength(\"\\t\", () -> \"enigma\");\n\t}\n\n\t@Test\n\tvoid hasLengthWithEmptyStringAndMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.hasLength(\"\", () -> \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid hasLengthWithNullAndMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.hasLength(null, () -> \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid hasLengthWithNullAndNullMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.hasLength(null, (Supplier<String>) null))\n\t\t\t.withMessage(null);\n\t}\n\n\t@Test\n\tvoid hasText() {\n\t\tAssert.hasText(\"foo\", \"enigma\");\n\t}\n\n\t@Test\n\tvoid hasTextWithWhitespaceOnly() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.hasText(\"\\t \", \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid hasTextWithEmptyString() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.hasText(\"\", \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid hasTextWithNull() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.hasText(null, \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid hasTextWithMessageSupplier() {\n\t\tAssert.hasText(\"foo\", () -> \"enigma\");\n\t}\n\n\t@Test\n\tvoid hasTextWithWhitespaceOnlyAndMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.hasText(\"\\t \", () -> \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid hasTextWithEmptyStringAndMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\tAssert.hasText(\"\", () -> \"enigma\")).withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid hasTextWithNullAndMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.hasText(null, () -> \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid hasTextWithNullAndNullMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.hasText(null, (Supplier<String>) null))\n\t\t\t.withMessage(null);\n\t}\n\n\t@Test\n\tvoid doesNotContainWithNullSearchString() {\n\t\tAssert.doesNotContain(null, \"rod\", \"enigma\");\n\t}\n\n\t@Test\n\tvoid doesNotContainWithNullSubstring() {\n\t\tAssert.doesNotContain(\"A cool chick's name is Brod.\", null, \"enigma\");\n\t}\n\n\t@Test\n\tvoid doesNotContainWithEmptySubstring() {\n\t\tAssert.doesNotContain(\"A cool chick's name is Brod.\", \"\", \"enigma\");\n\t}\n\n\t@Test\n\tvoid doesNotContainWithNullSearchStringAndNullSubstring() {\n\t\tAssert.doesNotContain(null, null, \"enigma\");\n\t}\n\n\t@Test\n\tvoid doesNotContainWithMessageSupplier() {\n\t\tAssert.doesNotContain(\"foo\", \"bar\", () -> \"enigma\");\n\t}\n\n\t@Test\n\tvoid doesNotContainWithNullSearchStringAndMessageSupplier() {\n\t\tAssert.doesNotContain(null, \"bar\", () -> \"enigma\");\n\t}\n\n\t@Test\n\tvoid doesNotContainWithNullSubstringAndMessageSupplier() {\n\t\tAssert.doesNotContain(\"foo\", null, () -> \"enigma\");\n\t}\n\n\t@Test\n\tvoid doesNotContainWithNullSearchStringAndNullSubstringAndMessageSupplier() {\n\t\tAssert.doesNotContain(null, null, () -> \"enigma\");\n\t}\n\n\t@Test\n\tvoid doesNotContainWithSubstringPresentInSearchStringAndMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.doesNotContain(\"1234\", \"23\", () -> \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid doesNotContainWithNullMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.doesNotContain(\"1234\", \"23\", (Supplier<String>) null))\n\t\t\t.withMessage(null);\n\t}\n\n\t@Test\n\tvoid notEmptyArray() {\n\t\tAssert.notEmpty(new String[] {\"1234\"}, \"enigma\");\n\t}\n\n\t@Test\n\tvoid notEmptyArrayWithEmptyArray() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.notEmpty(new String[] {}, \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid notEmptyArrayWithNullArray() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.notEmpty((Object[]) null, \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid notEmptyArrayWithMessageSupplier() {\n\t\tAssert.notEmpty(new String[] {\"1234\"}, () -> \"enigma\");\n\t}\n\n\t@Test\n\tvoid notEmptyArrayWithEmptyArrayAndMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.notEmpty(new String[] {}, () -> \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid notEmptyArrayWithNullArrayAndMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.notEmpty((Object[]) null, () -> \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid notEmptyArrayWithEmptyArrayAndNullMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.notEmpty(new String[] {}, (Supplier<String>) null))\n\t\t\t.withMessage(null);\n\t}\n\n\t@Test\n\tvoid noNullElements() {\n\t\tAssert.noNullElements(new String[] { \"1234\" }, \"enigma\");\n\t}\n\n\t@Test\n\tvoid noNullElementsWithEmptyArray() {\n\t\tAssert.noNullElements(new String[] {}, \"enigma\");\n\t}\n\n\t@Test\n\tvoid noNullElementsWithMessageSupplier() {\n\t\tAssert.noNullElements(new String[] { \"1234\" }, () -> \"enigma\");\n\t}\n\n\t@Test\n\tvoid noNullElementsWithEmptyArrayAndMessageSupplier() {\n\t\tAssert.noNullElements(new String[] {}, () -> \"enigma\");\n\t}\n\n\t@Test\n\tvoid noNullElementsWithNullArrayAndMessageSupplier() {\n\t\tAssert.noNullElements((Object[]) null, () -> \"enigma\");\n\t}\n\n\t@Test\n\tvoid noNullElementsWithNullElementsAndMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.noNullElements(new String[] { \"foo\", null, \"bar\" }, () -> \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid noNullElementsWithNullElementsAndNullMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.noNullElements(new String[] { \"foo\", null, \"bar\" }, (Supplier<String>) null))\n\t\t\t.withMessage(null);\n\t}\n\n\t@Test\n\tvoid noNullElementsWithCollection() {\n\t\tassertThatCode(() ->\n\t\t\t\tAssert.noNullElements(asList(\"foo\", \"bar\"), \"enigma\"))\n\t\t\t.doesNotThrowAnyException();\n\t}\n\n\t@Test\n\tvoid noNullElementsWithEmptyCollection() {\n\t\tassertThatCode(() ->\n\t\t\t\tAssert.noNullElements(emptyList(), \"enigma\"))\n\t\t\t.doesNotThrowAnyException();\n\t}\n\n\t@Test\n\tvoid noNullElementsWithNullCollection() {\n\t\tassertThatCode(() ->\n\t\t\t\tAssert.noNullElements((Collection<Object>) null, \"enigma\"))\n\t\t\t.doesNotThrowAnyException();\n\t}\n\n\t@Test\n\tvoid noNullElementsWithCollectionAndNullElement() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.noNullElements(asList(\"foo\", null, \"bar\"), \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid noNullElementsWithCollectionAndMessageSupplier() {\n\t\tassertThatCode(() ->\n\t\t\t\tAssert.noNullElements(asList(\"foo\", \"bar\"), () -> \"enigma\"))\n\t\t\t.doesNotThrowAnyException();\n\t}\n\n\t@Test\n\tvoid noNullElementsWithEmptyCollectionAndMessageSupplier() {\n\t\tassertThatCode(() ->\n\t\t\t\tAssert.noNullElements(emptyList(), \"enigma\"))\n\t\t\t.doesNotThrowAnyException();\n\t}\n\n\t@Test\n\tvoid noNullElementsWithNullCollectionAndMessageSupplier() {\n\t\tassertThatCode(() ->\n\t\t\t\tAssert.noNullElements((Collection<Object>) null, () -> \"enigma\"))\n\t\t\t.doesNotThrowAnyException();\n\t}\n\n\t@Test\n\tvoid noNullElementsWithCollectionAndNullElementAndMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.noNullElements(asList(\"foo\", null, \"bar\"), () -> \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid noNullElementsWithCollectionAndNullElementAndNullMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.noNullElements(asList(\"foo\", null, \"bar\"), (Supplier<String>) null))\n\t\t\t.withMessage(null);\n\t}\n\n\t@Test\n\tvoid notEmptyCollection() {\n\t\tAssert.notEmpty(singletonList(\"foo\"), \"enigma\");\n\t}\n\n\t@Test\n\tvoid notEmptyCollectionWithEmptyCollection() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.notEmpty(emptyList(), \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid notEmptyCollectionWithNullCollection() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.notEmpty((Collection<?>) null, \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid notEmptyCollectionWithMessageSupplier() {\n\t\tAssert.notEmpty(singletonList(\"foo\"), () -> \"enigma\");\n\t}\n\n\t@Test\n\tvoid notEmptyCollectionWithEmptyCollectionAndMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.notEmpty(emptyList(), () -> \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid notEmptyCollectionWithNullCollectionAndMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.notEmpty((Collection<?>) null, () -> \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid notEmptyCollectionWithEmptyCollectionAndNullMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.notEmpty(emptyList(), (Supplier<String>) null))\n\t\t\t.withMessage(null);\n\t}\n\n\t@Test\n\tvoid notEmptyMap() {\n\t\tAssert.notEmpty(singletonMap(\"foo\", \"bar\"), \"enigma\");\n\t}\n\n\t@Test\n\tvoid notEmptyMapWithNullMap() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.notEmpty((Map<?, ?>) null, \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid notEmptyMapWithEmptyMap() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.notEmpty(emptyMap(), \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid notEmptyMapWithMessageSupplier() {\n\t\tAssert.notEmpty(singletonMap(\"foo\", \"bar\"), () -> \"enigma\");\n\t}\n\n\t@Test\n\tvoid notEmptyMapWithEmptyMapAndMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.notEmpty(emptyMap(), () -> \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid notEmptyMapWithNullMapAndMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.notEmpty((Map<?, ?>) null, () -> \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n\t@Test\n\tvoid notEmptyMapWithEmptyMapAndNullMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.notEmpty(emptyMap(), (Supplier<String>) null))\n\t\t\t.withMessage(null);\n\t}\n\n\t@Test\n\tvoid isInstanceOf() {\n\t\tAssert.isInstanceOf(String.class, \"foo\", \"enigma\");\n\t}\n\n\t@Test\n\tvoid isInstanceOfWithNullType() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.isInstanceOf(null, \"foo\", \"enigma\"))\n\t\t\t.withMessageContaining(\"Type to check against must not be null\");\n\t}\n\n\t@Test\n\tvoid isInstanceOfWithNullInstance() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.isInstanceOf(String.class, null, \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma: null\");\n\t}\n\n\t@Test\n\tvoid isInstanceOfWithTypeMismatchAndNullMessage() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.isInstanceOf(String.class, 42L, (String) null))\n\t\t\t.withMessageContaining(\"Object of class [java.lang.Long] must be an instance of class java.lang.String\");\n\t}\n\n\t@Test\n\tvoid isInstanceOfWithTypeMismatchAndCustomMessage() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.isInstanceOf(String.class, 42L, \"Custom message\"))\n\t\t\t.withMessageContaining(\"Custom message: java.lang.Long\");\n\t}\n\n\t@Test\n\tvoid isInstanceOfWithTypeMismatchAndCustomMessageWithSeparator() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.isInstanceOf(String.class, 42L, \"Custom message:\"))\n\t\t\t.withMessageContaining(\"Custom message: Object of class [java.lang.Long] must be an instance of class java.lang.String\");\n\t}\n\n\t@Test\n\tvoid isInstanceOfWithTypeMismatchAndCustomMessageWithSpace() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.isInstanceOf(String.class, 42L, \"Custom message for \"))\n\t\t\t.withMessageContaining(\"Custom message for java.lang.Long\");\n\t}\n\n\t@Test\n\tvoid isInstanceOfWithMessageSupplier() {\n\t\tAssert.isInstanceOf(String.class, \"foo\", () -> \"enigma\");\n\t}\n\n\t@Test\n\tvoid isInstanceOfWithNullTypeAndMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.isInstanceOf(null, \"foo\", () -> \"enigma\"))\n\t\t\t.withMessageContaining(\"Type to check against must not be null\");\n\t}\n\n\t@Test\n\tvoid isInstanceOfWithNullInstanceAndMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.isInstanceOf(String.class, null, () -> \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma: null\");\n\t}\n\n\t@Test\n\tvoid isInstanceOfWithTypeMismatchAndNullMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.isInstanceOf(String.class, 42L, (Supplier<String>) null))\n\t\t\t.withMessageContaining(\"Object of class [java.lang.Long] must be an instance of class java.lang.String\");\n\t}\n\n\t@Test\n\tvoid isInstanceOfWithTypeMismatchAndMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.isInstanceOf(String.class, 42L, () -> \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma: java.lang.Long\");\n\t}\n\n\t@Test\n\tvoid isAssignable() {\n\t\tAssert.isAssignable(Number.class, Integer.class, \"enigma\");\n\t}\n\n\t@Test\n\tvoid isAssignableWithNullSupertype() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.isAssignable(null, Integer.class, \"enigma\"))\n\t\t\t.withMessageContaining(\"Supertype to check against must not be null\");\n\t}\n\n\t@Test\n\tvoid isAssignableWithNullSubtype() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.isAssignable(Integer.class, null, \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma: null\");\n\t}\n\n\t@Test\n\tvoid isAssignableWithTypeMismatchAndNullMessage() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.isAssignable(String.class, Integer.class, (String) null))\n\t\t\t.withMessageContaining(\"class java.lang.Integer is not assignable to class java.lang.String\");\n\t}\n\n\t@Test\n\tvoid isAssignableWithTypeMismatchAndCustomMessage() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.isAssignable(String.class, Integer.class, \"Custom message\"))\n\t\t\t.withMessageContaining(\"Custom message: class java.lang.Integer\");\n\t}\n\n\t@Test\n\tvoid isAssignableWithTypeMismatchAndCustomMessageWithSeparator() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.isAssignable(String.class, Integer.class, \"Custom message:\"))\n\t\t\t.withMessageContaining(\"Custom message: class java.lang.Integer is not assignable to class java.lang.String\");\n\t}\n\n\t@Test\n\tvoid isAssignableWithTypeMismatchAndCustomMessageWithSpace() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.isAssignable(String.class, Integer.class, \"Custom message for \"))\n\t\t\t.withMessageContaining(\"Custom message for class java.lang.Integer\");\n\t}\n\n\t@Test\n\tvoid isAssignableWithMessageSupplier() {\n\t\tAssert.isAssignable(Number.class, Integer.class, () -> \"enigma\");\n\t}\n\n\t@Test\n\tvoid isAssignableWithNullSupertypeAndMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.isAssignable(null, Integer.class, () -> \"enigma\"))\n\t\t\t.withMessageContaining(\"Supertype to check against must not be null\");\n\t}\n\n\t@Test\n\tvoid isAssignableWithNullSubtypeAndMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.isAssignable(Integer.class, null, () -> \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma: null\");\n\t}\n\n\t@Test\n\tvoid isAssignableWithTypeMismatchAndNullMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.isAssignable(String.class, Integer.class, (Supplier<String>) null))\n\t\t\t.withMessageContaining(\"class java.lang.Integer is not assignable to class java.lang.String\");\n\t}\n\n\t@Test\n\tvoid isAssignableWithTypeMismatchAndMessageSupplier() {\n\t\tassertThatIllegalArgumentException().isThrownBy(() ->\n\t\t\t\tAssert.isAssignable(String.class, Integer.class, () -> \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma: class java.lang.Integer\");\n\t}\n\n\t@Test\n\tvoid state() {\n\t\tAssert.state(true, \"enigma\");\n\t}\n\n\t@Test\n\tvoid stateWithFalseExpression() {\n\t\tassertThatIllegalStateException().isThrownBy(() ->\n\t\t\t\tAssert.state(false, \"enigma\"))\n\t\t\t.withMessageContaining(\"enigma\");\n\t}\n\n}\n",
    "tailType": "class_code"
  }
]