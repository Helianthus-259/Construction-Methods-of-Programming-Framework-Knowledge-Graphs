[
  {
    "head": "org.springframework.util.unit.DataSize",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.unit.DataSize#hashCode()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.util.unit.DataSize#hashCode()",
    "headType": "method",
    "relation": "use",
    "tail": "@Override",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.util.unit",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.unit.DataSizeUtils",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.unit.DataSizeUtils",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util.unit;\n\nimport java.io.Serializable;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.jspecify.annotations.Nullable;\n\nimport org.springframework.util.Assert;\nimport org.springframework.util.StringUtils;\n\n/**\n * A data size, such as '12MB'. This class models data size in terms of\n * bytes and is immutable and thread-safe.\n *\n * <p>The terms and units used in this class are based on\n * <a href=\"https://en.wikipedia.org/wiki/Binary_prefix\">binary prefixes</a>\n * indicating multiplication by powers of 2. Consult the following table and\n * the Javadoc for {@link DataUnit} for details.\n *\n * <p>\n * <table border=\"1\">\n * <tr><th>Term</th><th>Data Size</th><th>Size in Bytes</th></tr>\n * <tr><td>byte</td><td>1B</td><td>1</td></tr>\n * <tr><td>kilobyte</td><td>1KB</td><td>1,024</td></tr>\n * <tr><td>megabyte</td><td>1MB</td><td>1,048,576</td></tr>\n * <tr><td>gigabyte</td><td>1GB</td><td>1,073,741,824</td></tr>\n * <tr><td>terabyte</td><td>1TB</td><td>1,099,511,627,776</td></tr>\n * </table>\n *\n * @author Stephane Nicoll\n * @author Sam Brannen\n * @since 5.1\n * @see DataUnit\n */\n@SuppressWarnings(\"serial\")\npublic final class DataSize implements Comparable<DataSize>, Serializable {\n\n\t/**\n\t * Bytes per Kilobyte.\n\t */\n\tprivate static final long BYTES_PER_KB = 1024;\n\n\t/**\n\t * Bytes per Megabyte.\n\t */\n\tprivate static final long BYTES_PER_MB = BYTES_PER_KB * 1024;\n\n\t/**\n\t * Bytes per Gigabyte.\n\t */\n\tprivate static final long BYTES_PER_GB = BYTES_PER_MB * 1024;\n\n\t/**\n\t * Bytes per Terabyte.\n\t */\n\tprivate static final long BYTES_PER_TB = BYTES_PER_GB * 1024;\n\n\n\tprivate final long bytes;\n\n\n\tprivate DataSize(long bytes) {\n\t\tthis.bytes = bytes;\n\t}\n\n\n\t/**\n\t * Obtain a {@link DataSize} representing the specified number of bytes.\n\t * @param bytes the number of bytes, positive or negative\n\t * @return a {@code DataSize}\n\t */\n\tpublic static DataSize ofBytes(long bytes) {\n\t\treturn new DataSize(bytes);\n\t}\n\n\t/**\n\t * Obtain a {@link DataSize} representing the specified number of kilobytes.\n\t * @param kilobytes the number of kilobytes, positive or negative\n\t * @return a {@code DataSize}\n\t */\n\tpublic static DataSize ofKilobytes(long kilobytes) {\n\t\treturn new DataSize(Math.multiplyExact(kilobytes, BYTES_PER_KB));\n\t}\n\n\t/**\n\t * Obtain a {@link DataSize} representing the specified number of megabytes.\n\t * @param megabytes the number of megabytes, positive or negative\n\t * @return a {@code DataSize}\n\t */\n\tpublic static DataSize ofMegabytes(long megabytes) {\n\t\treturn new DataSize(Math.multiplyExact(megabytes, BYTES_PER_MB));\n\t}\n\n\t/**\n\t * Obtain a {@link DataSize} representing the specified number of gigabytes.\n\t * @param gigabytes the number of gigabytes, positive or negative\n\t * @return a {@code DataSize}\n\t */\n\tpublic static DataSize ofGigabytes(long gigabytes) {\n\t\treturn new DataSize(Math.multiplyExact(gigabytes, BYTES_PER_GB));\n\t}\n\n\t/**\n\t * Obtain a {@link DataSize} representing the specified number of terabytes.\n\t * @param terabytes the number of terabytes, positive or negative\n\t * @return a {@code DataSize}\n\t */\n\tpublic static DataSize ofTerabytes(long terabytes) {\n\t\treturn new DataSize(Math.multiplyExact(terabytes, BYTES_PER_TB));\n\t}\n\n\t/**\n\t * Obtain a {@link DataSize} representing an amount in the specified {@link DataUnit}.\n\t * @param amount the amount of the size, measured in terms of the unit,\n\t * positive or negative\n\t * @return a corresponding {@code DataSize}\n\t */\n\tpublic static DataSize of(long amount, DataUnit unit) {\n\t\tAssert.notNull(unit, \"Unit must not be null\");\n\t\treturn new DataSize(Math.multiplyExact(amount, unit.size().toBytes()));\n\t}\n\n\t/**\n\t * Obtain a {@link DataSize} from a text string such as {@code 12MB} using\n\t * {@link DataUnit#BYTES} if no unit is specified.\n\t * <p>Examples:\n\t * <pre>\n\t * \"12KB\" -- parses as \"12 kilobytes\"\n\t * \"5MB\"  -- parses as \"5 megabytes\"\n\t * \"20\"   -- parses as \"20 bytes\"\n\t * </pre>\n\t * @param text the text to parse\n\t * @return the parsed {@code DataSize}\n\t * @see #parse(CharSequence, DataUnit)\n\t */\n\tpublic static DataSize parse(CharSequence text) {\n\t\treturn parse(text, null);\n\t}\n\n\t/**\n\t * Obtain a {@link DataSize} from a text string such as {@code 12MB} using\n\t * the specified default {@link DataUnit} if no unit is specified.\n\t * <p>The string starts with a number followed optionally by a unit matching\n\t * one of the supported {@linkplain DataUnit suffixes}.\n\t * <p>If neither a unit nor a default {@code DataUnit} is specified,\n\t * {@link DataUnit#BYTES} will be inferred.\n\t * <p>Examples:\n\t * <pre>\n\t * \"12KB\" -- parses as \"12 kilobytes\"\n\t * \"5MB\"  -- parses as \"5 megabytes\"\n\t * \"20\"   -- parses as \"20 kilobytes\" (where the {@code defaultUnit} is {@link DataUnit#KILOBYTES})\n\t * \"20\"   -- parses as \"20 bytes\" (if the {@code defaultUnit} is {@code null})\n\t * </pre>\n\t * @param text the text to parse\n\t * @param defaultUnit the default {@code DataUnit} to use\n\t * @return the parsed {@code DataSize}\n\t */\n\tpublic static DataSize parse(CharSequence text, @Nullable DataUnit defaultUnit) {\n\t\tAssert.notNull(text, \"Text must not be null\");\n\t\ttry {\n\t\t\tCharSequence trimmedText = StringUtils.trimAllWhitespace(text);\n\t\t\tMatcher matcher = DataSizeUtils.PATTERN.matcher(trimmedText);\n\t\t\tAssert.state(matcher.matches(), () -> \"'\" + text + \"' does not match data size pattern\");\n\t\t\tDataUnit unit = DataSizeUtils.determineDataUnit(matcher.group(2), defaultUnit);\n\t\t\tlong amount = Long.parseLong(trimmedText, matcher.start(1), matcher.end(1), 10);\n\t\t\treturn DataSize.of(amount, unit);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new IllegalArgumentException(\"'\" + text + \"' is not a valid data size\", ex);\n\t\t}\n\t}\n\n\t/**\n\t * Checks if this size is negative, excluding zero.\n\t * @return true if this size has a size less than zero bytes\n\t */\n\tpublic boolean isNegative() {\n\t\treturn this.bytes < 0;\n\t}\n\n\t/**\n\t * Return the number of bytes in this instance.\n\t * @return the number of bytes\n\t */\n\tpublic long toBytes() {\n\t\treturn this.bytes;\n\t}\n\n\t/**\n\t * Return the number of kilobytes in this instance.\n\t * @return the number of kilobytes\n\t */\n\tpublic long toKilobytes() {\n\t\treturn this.bytes / BYTES_PER_KB;\n\t}\n\n\t/**\n\t * Return the number of megabytes in this instance.\n\t * @return the number of megabytes\n\t */\n\tpublic long toMegabytes() {\n\t\treturn this.bytes / BYTES_PER_MB;\n\t}\n\n\t/**\n\t * Return the number of gigabytes in this instance.\n\t * @return the number of gigabytes\n\t */\n\tpublic long toGigabytes() {\n\t\treturn this.bytes / BYTES_PER_GB;\n\t}\n\n\t/**\n\t * Return the number of terabytes in this instance.\n\t * @return the number of terabytes\n\t */\n\tpublic long toTerabytes() {\n\t\treturn this.bytes / BYTES_PER_TB;\n\t}\n\n\t@Override\n\tpublic int compareTo(DataSize other) {\n\t\treturn Long.compare(this.bytes, other.bytes);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn String.format(\"%dB\", this.bytes);\n\t}\n\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\tif (this == other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (other == null || getClass() != other.getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\tDataSize that = (DataSize) other;\n\t\treturn (this.bytes == that.bytes);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn Long.hashCode(this.bytes);\n\t}\n\n\n\t/**\n\t * Static nested class to support lazy loading of the {@link #PATTERN}.\n\t * @since 5.3.21\n\t */\n\tprivate static class DataSizeUtils {\n\n\t\t/**\n\t\t * The pattern for parsing.\n\t\t */\n\t\tprivate static final Pattern PATTERN = Pattern.compile(\"^([+\\\\-]?\\\\d+)([a-zA-Z]{0,2})$\");\n\n\t\tprivate static DataUnit determineDataUnit(String suffix, @Nullable DataUnit defaultUnit) {\n\t\t\tDataUnit defaultUnitToUse = (defaultUnit != null ? defaultUnit : DataUnit.BYTES);\n\t\t\treturn (StringUtils.hasLength(suffix) ? DataUnit.fromSuffix(suffix) : defaultUnitToUse);\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.unit.DataSizeUtils",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.unit.DataSizeUtils#PATTERN",
    "tailType": "field"
  },
  {
    "head": "org.springframework.util.unit.DataSizeUtils#PATTERN",
    "headType": "field",
    "relation": "haveType",
    "tail": "Pattern",
    "tailType": "type"
  },
  {
    "head": "org.springframework.util.unit.DataSizeUtils#determineDataUnit(String,DataUnit)",
    "headType": "method",
    "relation": "provide",
    "tail": "private static DataUnit determineDataUnit(String suffix, @Nullable DataUnit defaultUnit) {\r\n    DataUnit defaultUnitToUse = (defaultUnit != null ? defaultUnit : DataUnit.BYTES);\r\n    return (StringUtils.hasLength(suffix) ? DataUnit.fromSuffix(suffix) : defaultUnitToUse);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.util.unit.DataSizeUtils",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.util.unit.DataSizeUtils#determineDataUnit(String,DataUnit)",
    "tailType": "method"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.util.unit",
    "tailType": "package"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.util.unit",
    "tailType": "package"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.util",
    "tailType": "package"
  },
  {
    "head": "org.springframework.util",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.util.UnmodifiableMultiValueMap",
    "tailType": "class"
  },
  {
    "head": "org.springframework.util.UnmodifiableMultiValueMap",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.util;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.Spliterator;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport org.jspecify.annotations.Nullable;\n\n/**\n * Unmodifiable wrapper for {@link MultiValueMap}.\n *\n * @author Arjen Poutsma\n * @since 6.0\n * @param <K> the key type\n * @param <V> the value element type\n */\nfinal class UnmodifiableMultiValueMap<K,V> implements MultiValueMap<K,V>, Serializable {\n\n\tprivate static final long serialVersionUID = -8697084563854098920L;\n\n\t@SuppressWarnings(\"serial\")\n\tprivate final MultiValueMap<K, V> delegate;\n\n\tprivate transient @Nullable Set<K> keySet;\n\n\tprivate transient @Nullable Set<Entry<K, List<V>>> entrySet;\n\n\tprivate transient @Nullable Collection<List<V>> values;\n\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic UnmodifiableMultiValueMap(MultiValueMap<? extends K, ? extends V> delegate) {\n\t\tAssert.notNull(delegate, \"Delegate must not be null\");\n\t\tthis.delegate = (MultiValueMap<K, V>) delegate;\n\t}\n\n\n\t// delegation\n\n\t@Override\n\tpublic int size() {\n\t\treturn this.delegate.size();\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn this.delegate.isEmpty();\n\t}\n\n\t@Override\n\tpublic boolean containsKey(Object key) {\n\t\treturn this.delegate.containsKey(key);\n\t}\n\n\t@Override\n\tpublic boolean containsValue(Object value) {\n\t\treturn this.delegate.containsValue(value);\n\t}\n\n\t@Override\n\tpublic @Nullable List<V> get(Object key) {\n\t\tList<V> result = this.delegate.get(key);\n\t\treturn (result != null ? Collections.unmodifiableList(result) : null);\n\t}\n\n\t@Override\n\tpublic @Nullable V getFirst(K key) {\n\t\treturn this.delegate.getFirst(key);\n\t}\n\n\t@Override\n\tpublic List<V> getOrDefault(Object key, List<V> defaultValue) {\n\t\tList<V> result = this.delegate.getOrDefault(key, defaultValue);\n\t\tif (result != defaultValue) {\n\t\t\tresult = Collections.unmodifiableList(result);\n\t\t}\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic void forEach(BiConsumer<? super K, ? super List<V>> action) {\n\t\tthis.delegate.forEach((k, vs) -> action.accept(k, Collections.unmodifiableList(vs)));\n\t}\n\n\t@Override\n\tpublic Map<K, V> toSingleValueMap() {\n\t\treturn this.delegate.toSingleValueMap();\n\t}\n\n\t@Override\n\tpublic Map<K, V> asSingleValueMap() {\n\t\treturn this.delegate.asSingleValueMap();\n\t}\n\n\t@Override\n\tpublic boolean equals(@Nullable Object other) {\n\t\treturn (this == other || this.delegate.equals(other));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn this.delegate.hashCode();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn this.delegate.toString();\n\t}\n\n\n\t// lazy init\n\n\t@Override\n\tpublic Set<K> keySet() {\n\t\tif (this.keySet == null) {\n\t\t\tthis.keySet = Collections.unmodifiableSet(this.delegate.keySet());\n\t\t}\n\t\treturn this.keySet;\n\t}\n\n\t@Override\n\tpublic Set<Entry<K, List<V>>> entrySet() {\n\t\tif (this.entrySet == null) {\n\t\t\tthis.entrySet = new UnmodifiableEntrySet<>(this.delegate.entrySet());\n\t\t}\n\t\treturn this.entrySet;\n\t}\n\n\t@Override\n\tpublic Collection<List<V>> values() {\n\t\tif (this.values == null) {\n\t\t\tthis.values = new UnmodifiableValueCollection<>(this.delegate.values());\n\t\t}\n\t\treturn this.values;\n\t}\n\n\t// unsupported\n\n\t@Override\n\tpublic @Nullable List<V> put(K key, List<V> value) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic List<V> putIfAbsent(K key, List<V> value) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic void putAll(Map<? extends K, ? extends List<V>> m) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic List<V> remove(Object key) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic void add(K key, @Nullable V value) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic void addAll(K key, List<? extends V> values) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic void addAll(MultiValueMap<K, V> values) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic void addIfAbsent(K key, @Nullable V value) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic void set(K key, @Nullable V value) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic void setAll(Map<K, V> values) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic void replaceAll(BiFunction<? super K, ? super List<V>, ? extends List<V>> function) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic boolean remove(Object key, Object value) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic boolean replace(K key, List<V> oldValue, List<V> newValue) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic List<V> replace(K key, List<V> value) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic List<V> computeIfAbsent(K key, Function<? super K, ? extends List<V>> mappingFunction) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic List<V> computeIfPresent(K key, BiFunction<? super K, ? super List<V>, ? extends List<V>> remappingFunction) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic List<V> compute(K key, BiFunction<? super K, ? super List<V>, ? extends List<V>> remappingFunction) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic List<V> merge(K key, List<V> value, BiFunction<? super List<V>, ? super List<V>, ? extends List<V>> remappingFunction) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\n\tprivate static class UnmodifiableEntrySet<K,V> implements Set<Map.Entry<K, List<V>>>, Serializable {\n\n\t\tprivate static final long serialVersionUID = 2407578793783925203L;\n\n\t\t@SuppressWarnings(\"serial\")\n\t\tprivate final Set<Entry<K, List<V>>> delegate;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic UnmodifiableEntrySet(Set<? extends Entry<? extends K, ? extends List<? extends V>>> delegate) {\n\t\t\tthis.delegate = (Set<Entry<K, List<V>>>) delegate;\n\t\t}\n\n\t\t// delegation\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn this.delegate.size();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty() {\n\t\t\treturn this.delegate.isEmpty();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object o) {\n\t\t\treturn this.delegate.contains(o);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> c) {\n\t\t\treturn this.delegate.containsAll(c);\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Entry<K, List<V>>> iterator() {\n\t\t\tIterator<? extends Entry<? extends K, ? extends List<? extends V>>> iterator = this.delegate.iterator();\n\t\t\treturn new Iterator<>() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean hasNext() {\n\t\t\t\t\treturn iterator.hasNext();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic Entry<K, List<V>> next() {\n\t\t\t\t\treturn new UnmodifiableEntry<>(iterator.next());\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray() {\n\t\t\tObject[] result = this.delegate.toArray();\n\t\t\tfilterArray(result);\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] a) {\n\t\t\tT[] result = this.delegate.toArray(a);\n\t\t\tfilterArray(result);\n\t\t\treturn result;\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tprivate void filterArray(Object[] result) {\n\t\t\tfor (int i = 0; i < result.length; i++) {\n\t\t\t\tif (result[i] instanceof Map.Entry<?,?> entry) {\n\t\t\t\t\tresult[i] = new UnmodifiableEntry<>((Entry<K, List<V>>) entry);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void forEach(Consumer<? super Entry<K, List<V>>> action) {\n\t\t\tthis.delegate.forEach(e -> action.accept(new UnmodifiableEntry<>(e)));\n\t\t}\n\n\t\t@Override\n\t\tpublic Stream<Entry<K, List<V>>> stream() {\n\t\t\treturn StreamSupport.stream(spliterator(), false);\n\t\t}\n\n\t\t@Override\n\t\tpublic Stream<Entry<K, List<V>>> parallelStream() {\n\t\t\treturn StreamSupport.stream(spliterator(), true);\n\t\t}\n\n\t\t@Override\n\t\tpublic Spliterator<Entry<K, List<V>>> spliterator() {\n\t\t\treturn new UnmodifiableEntrySpliterator<>(this.delegate.spliterator());\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || other instanceof Set<?> that && size() == that.size() && containsAll(that));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn this.delegate.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.delegate.toString();\n\t\t}\n\n\t\t// unsupported\n\n\t\t@Override\n\t\tpublic boolean add(Entry<K, List<V>> kListEntry) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeIf(Predicate<? super Entry<K, List<V>>> filter) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends Entry<K, List<V>>> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\n\t\tprivate static class UnmodifiableEntrySpliterator<K,V> implements Spliterator<Entry<K,List<V>>> {\n\n\t\t\tprivate final Spliterator<Entry<K, List<V>>> delegate;\n\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tpublic UnmodifiableEntrySpliterator(\n\t\t\t\t\tSpliterator<? extends Entry<? extends K, ? extends List<? extends V>>> delegate) {\n\n\t\t\t\tthis.delegate = (Spliterator<Entry<K, List<V>>>) delegate;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean tryAdvance(Consumer<? super Entry<K, List<V>>> action) {\n\t\t\t\treturn this.delegate.tryAdvance(entry -> action.accept(new UnmodifiableEntry<>(entry)));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void forEachRemaining(Consumer<? super Entry<K, List<V>>> action) {\n\t\t\t\tthis.delegate.forEachRemaining(entry -> action.accept(new UnmodifiableEntry<>(entry)));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic @Nullable Spliterator<Entry<K, List<V>>> trySplit() {\n\t\t\t\tSpliterator<? extends Entry<? extends K, ? extends List<? extends V>>> split = this.delegate.trySplit();\n\t\t\t\tif (split != null) {\n\t\t\t\t\treturn new UnmodifiableEntrySpliterator<>(split);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic long estimateSize() {\n\t\t\t\treturn this.delegate.estimateSize();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic long getExactSizeIfKnown() {\n\t\t\t\treturn this.delegate.getExactSizeIfKnown();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int characteristics() {\n\t\t\t\treturn this.delegate.characteristics();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasCharacteristics(int characteristics) {\n\t\t\t\treturn this.delegate.hasCharacteristics(characteristics);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Comparator<? super Entry<K, List<V>>> getComparator() {\n\t\t\t\treturn this.delegate.getComparator();\n\t\t\t}\n\t\t}\n\n\n\t\tprivate static class UnmodifiableEntry<K,V> implements Map.Entry<K,List<V>> {\n\n\t\t\tprivate final Entry<K, List<V>> delegate;\n\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tpublic UnmodifiableEntry(Entry<? extends K, ? extends List<? extends V>> delegate) {\n\t\t\t\tAssert.notNull(delegate, \"Delegate must not be null\");\n\t\t\t\tthis.delegate = (Entry<K, List<V>>) delegate;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic K getKey() {\n\t\t\t\treturn this.delegate.getKey();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic List<V> getValue() {\n\t\t\t\treturn Collections.unmodifiableList(this.delegate.getValue());\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic List<V> setValue(List<V> value) {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\t\treturn (this == other || (other instanceof Map.Entry<?, ?> that &&\n\t\t\t\t\t\tgetKey().equals(that.getKey()) && getValue().equals(that.getValue())));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int hashCode() {\n\t\t\t\treturn this.delegate.hashCode();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\treturn this.delegate.toString();\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate static class UnmodifiableValueCollection<V> implements Collection<List<V>>, Serializable {\n\n\t\tprivate static final long serialVersionUID = 5518377583904339588L;\n\n\t\t@SuppressWarnings(\"serial\")\n\t\tprivate final Collection<List<V>> delegate;\n\n\t\tpublic UnmodifiableValueCollection(Collection<List<V>> delegate) {\n\t\t\tthis.delegate = delegate;\n\t\t}\n\n\t\t // delegation\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn this.delegate.size();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty() {\n\t\t\treturn this.delegate.isEmpty();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object o) {\n\t\t\treturn this.delegate.contains(o);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> c) {\n\t\t\treturn this.delegate.containsAll(c);\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray() {\n\t\t\tObject[] result = this.delegate.toArray();\n\t\t\tfilterArray(result);\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] a) {\n\t\t\tT[] result = this.delegate.toArray(a);\n\t\t\tfilterArray(result);\n\t\t\treturn result;\n\t\t}\n\n\t\tprivate void filterArray(Object[] array) {\n\t\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\t\tif (array[i] instanceof List<?> list) {\n\t\t\t\t\tarray[i] = Collections.unmodifiableList(list);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<List<V>> iterator() {\n\t\t\tIterator<List<V>> iterator = this.delegate.iterator();\n\t\t\treturn new Iterator<>() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean hasNext() {\n\t\t\t\t\treturn iterator.hasNext();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic List<V> next() {\n\t\t\t\t\treturn Collections.unmodifiableList(iterator.next());\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t@Override\n\t\tpublic void forEach(Consumer<? super List<V>> action) {\n\t\t\tthis.delegate.forEach(list -> action.accept(Collections.unmodifiableList(list)));\n\t\t}\n\n\t\t@Override\n\t\tpublic Spliterator<List<V>> spliterator() {\n\t\t\treturn new UnmodifiableValueSpliterator<>(this.delegate.spliterator());\n\t\t}\n\n\t\t@Override\n\t\tpublic Stream<List<V>> stream() {\n\t\t\treturn StreamSupport.stream(spliterator(), false);\n\t\t}\n\n\t\t@Override\n\t\tpublic Stream<List<V>> parallelStream() {\n\t\t\treturn StreamSupport.stream(spliterator(), true);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(@Nullable Object other) {\n\t\t\treturn (this == other || this.delegate.equals(other));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn this.delegate.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.delegate.toString();\n\t\t}\n\n\t\t// unsupported\n\n\t\t@Override\n\t\tpublic boolean add(List<V> ts) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends List<V>> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeIf(Predicate<? super List<V>> filter) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\n\t\tprivate static class UnmodifiableValueSpliterator<T> implements Spliterator<List<T>> {\n\n\t\t\tprivate final Spliterator<List<T>> delegate;\n\n\t\t\tpublic UnmodifiableValueSpliterator(Spliterator<List<T>> delegate) {\n\t\t\t\tthis.delegate = delegate;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean tryAdvance(Consumer<? super List<T>> action) {\n\t\t\t\treturn this.delegate.tryAdvance(l -> action.accept(Collections.unmodifiableList(l)));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void forEachRemaining(Consumer<? super List<T>> action) {\n\t\t\t\tthis.delegate.forEachRemaining(l -> action.accept(Collections.unmodifiableList(l)));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic @Nullable Spliterator<List<T>> trySplit() {\n\t\t\t\tSpliterator<List<T>> split = this.delegate.trySplit();\n\t\t\t\tif (split != null) {\n\t\t\t\t\treturn new UnmodifiableValueSpliterator<>(split);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic long estimateSize() {\n\t\t\t\treturn this.delegate.estimateSize();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic long getExactSizeIfKnown() {\n\t\t\t\treturn this.delegate.getExactSizeIfKnown();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int characteristics() {\n\t\t\t\treturn this.delegate.characteristics();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasCharacteristics(int characteristics) {\n\t\t\t\treturn this.delegate.hasCharacteristics(characteristics);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Comparator<? super List<T>> getComparator() {\n\t\t\t\treturn this.delegate.getComparator();\n\t\t\t}\n\t\t}\n\t}\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.util.UnmodifiableMultiValueMap",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.UnmodifiableMultiValueMap#serialVersionUID",
    "tailType": "field"
  },
  {
    "head": "org.springframework.util.UnmodifiableMultiValueMap#serialVersionUID",
    "headType": "field",
    "relation": "haveType",
    "tail": "long",
    "tailType": "type"
  },
  {
    "head": "org.springframework.util.UnmodifiableMultiValueMap",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.UnmodifiableMultiValueMap#delegate",
    "tailType": "field"
  },
  {
    "head": "org.springframework.util.UnmodifiableMultiValueMap#delegate",
    "headType": "field",
    "relation": "haveType",
    "tail": "MultiValueMap<K, V>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.util.UnmodifiableMultiValueMap",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.UnmodifiableMultiValueMap#keySet",
    "tailType": "field"
  },
  {
    "head": "org.springframework.util.UnmodifiableMultiValueMap#keySet",
    "headType": "field",
    "relation": "haveType",
    "tail": "Set<K>",
    "tailType": "type"
  },
  {
    "head": "org.springframework.util.UnmodifiableMultiValueMap",
    "headType": "class",
    "relation": "haveField",
    "tail": "org.springframework.util.UnmodifiableMultiValueMap#entrySet",
    "tailType": "field"
  }
]