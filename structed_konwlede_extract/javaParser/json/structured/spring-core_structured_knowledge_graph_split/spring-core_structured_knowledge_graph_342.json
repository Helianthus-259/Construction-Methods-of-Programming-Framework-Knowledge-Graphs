[
  {
    "head": "org.springframework.asm.ClassReader#readMethod(ClassVisitor,Context,int)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Reads a JVMS method_info structure and makes the given visitor visit it.\r\n *\r\n * @param classVisitor the visitor that must visit the method.\r\n * @param context information about the class being parsed.\r\n * @param methodInfoOffset the start offset of the method_info structure.\r\n * @return the offset of the first byte following the method_info structure.\r\n */\r\nprivate int readMethod(final ClassVisitor classVisitor, final Context context, final int methodInfoOffset) {\r\n    char[] charBuffer = context.charBuffer;\r\n    // Read the access_flags, name_index and descriptor_index fields.\r\n    int currentOffset = methodInfoOffset;\r\n    context.currentMethodAccessFlags = readUnsignedShort(currentOffset);\r\n    context.currentMethodName = readUTF8(currentOffset + 2, charBuffer);\r\n    context.currentMethodDescriptor = readUTF8(currentOffset + 4, charBuffer);\r\n    currentOffset += 6;\r\n    // Read the method attributes (the variables are ordered as in Section 4.7 of the JVMS).\r\n    // Attribute offsets exclude the attribute_name_index and attribute_length fields.\r\n    // - The offset of the Code attribute, or 0.\r\n    int codeOffset = 0;\r\n    // - The offset of the Exceptions attribute, or 0.\r\n    int exceptionsOffset = 0;\r\n    // - The strings corresponding to the Exceptions attribute, or null.\r\n    String[] exceptions = null;\r\n    // - Whether the method has a Synthetic attribute.\r\n    boolean synthetic = false;\r\n    // - The constant pool index contained in the Signature attribute, or 0.\r\n    int signatureIndex = 0;\r\n    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.\r\n    int runtimeVisibleAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.\r\n    int runtimeInvisibleAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeVisibleParameterAnnotations attribute, or 0.\r\n    int runtimeVisibleParameterAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeInvisibleParameterAnnotations attribute, or 0.\r\n    int runtimeInvisibleParameterAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.\r\n    int runtimeVisibleTypeAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.\r\n    int runtimeInvisibleTypeAnnotationsOffset = 0;\r\n    // - The offset of the AnnotationDefault attribute, or 0.\r\n    int annotationDefaultOffset = 0;\r\n    // - The offset of the MethodParameters attribute, or 0.\r\n    int methodParametersOffset = 0;\r\n    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\r\n    //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\r\n    Attribute attributes = null;\r\n    int attributesCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (attributesCount-- > 0) {\r\n        // Read the attribute_info's attribute_name and attribute_length fields.\r\n        String attributeName = readUTF8(currentOffset, charBuffer);\r\n        int attributeLength = readInt(currentOffset + 2);\r\n        currentOffset += 6;\r\n        // The tests are sorted in decreasing frequency order (based on frequencies observed on\r\n        // typical classes).\r\n        if (Constants.CODE.equals(attributeName)) {\r\n            if ((context.parsingOptions & SKIP_CODE) == 0) {\r\n                codeOffset = currentOffset;\r\n            }\r\n        } else if (Constants.EXCEPTIONS.equals(attributeName)) {\r\n            exceptionsOffset = currentOffset;\r\n            exceptions = new String[readUnsignedShort(exceptionsOffset)];\r\n            int currentExceptionOffset = exceptionsOffset + 2;\r\n            for (int i = 0; i < exceptions.length; ++i) {\r\n                exceptions[i] = readClass(currentExceptionOffset, charBuffer);\r\n                currentExceptionOffset += 2;\r\n            }\r\n        } else if (Constants.SIGNATURE.equals(attributeName)) {\r\n            signatureIndex = readUnsignedShort(currentOffset);\r\n        } else if (Constants.DEPRECATED.equals(attributeName)) {\r\n            context.currentMethodAccessFlags |= Opcodes.ACC_DEPRECATED;\r\n        } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeVisibleAnnotationsOffset = currentOffset;\r\n        } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeVisibleTypeAnnotationsOffset = currentOffset;\r\n        } else if (Constants.ANNOTATION_DEFAULT.equals(attributeName)) {\r\n            annotationDefaultOffset = currentOffset;\r\n        } else if (Constants.SYNTHETIC.equals(attributeName)) {\r\n            synthetic = true;\r\n            context.currentMethodAccessFlags |= Opcodes.ACC_SYNTHETIC;\r\n        } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeInvisibleAnnotationsOffset = currentOffset;\r\n        } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeInvisibleTypeAnnotationsOffset = currentOffset;\r\n        } else if (Constants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeVisibleParameterAnnotationsOffset = currentOffset;\r\n        } else if (Constants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeInvisibleParameterAnnotationsOffset = currentOffset;\r\n        } else if (Constants.METHOD_PARAMETERS.equals(attributeName)) {\r\n            methodParametersOffset = currentOffset;\r\n        } else {\r\n            Attribute attribute = readAttribute(context.attributePrototypes, attributeName, currentOffset, attributeLength, charBuffer, -1, null);\r\n            attribute.nextAttribute = attributes;\r\n            attributes = attribute;\r\n        }\r\n        currentOffset += attributeLength;\r\n    }\r\n    // Visit the method declaration.\r\n    MethodVisitor methodVisitor = classVisitor.visitMethod(context.currentMethodAccessFlags, context.currentMethodName, context.currentMethodDescriptor, signatureIndex == 0 ? null : readUtf(signatureIndex, charBuffer), exceptions);\r\n    if (methodVisitor == null) {\r\n        return currentOffset;\r\n    }\r\n    // If the returned MethodVisitor is in fact a MethodWriter, it means there is no method\r\n    // adapter between the reader and the writer. In this case, it might be possible to copy\r\n    // the method attributes directly into the writer. If so, return early without visiting\r\n    // the content of these attributes.\r\n    if (methodVisitor instanceof MethodWriter) {\r\n        MethodWriter methodWriter = (MethodWriter) methodVisitor;\r\n        if (methodWriter.canCopyMethodAttributes(this, synthetic, (context.currentMethodAccessFlags & Opcodes.ACC_DEPRECATED) != 0, readUnsignedShort(methodInfoOffset + 4), signatureIndex, exceptionsOffset)) {\r\n            methodWriter.setMethodAttributesSource(methodInfoOffset, currentOffset - methodInfoOffset);\r\n            return currentOffset;\r\n        }\r\n    }\r\n    // Visit the MethodParameters attribute.\r\n    if (methodParametersOffset != 0 && (context.parsingOptions & SKIP_DEBUG) == 0) {\r\n        int parametersCount = readByte(methodParametersOffset);\r\n        int currentParameterOffset = methodParametersOffset + 1;\r\n        while (parametersCount-- > 0) {\r\n            // Read the name_index and access_flags fields and visit them.\r\n            methodVisitor.visitParameter(readUTF8(currentParameterOffset, charBuffer), readUnsignedShort(currentParameterOffset + 2));\r\n            currentParameterOffset += 4;\r\n        }\r\n    }\r\n    // Visit the AnnotationDefault attribute.\r\n    if (annotationDefaultOffset != 0) {\r\n        AnnotationVisitor annotationVisitor = methodVisitor.visitAnnotationDefault();\r\n        readElementValue(annotationVisitor, annotationDefaultOffset, null, charBuffer);\r\n        if (annotationVisitor != null) {\r\n            annotationVisitor.visitEnd();\r\n        }\r\n    }\r\n    // Visit the RuntimeVisibleAnnotations attribute.\r\n    if (runtimeVisibleAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(methodVisitor.visitAnnotation(annotationDescriptor, /* visible= */\r\n            true), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeInvisibleAnnotations attribute.\r\n    if (runtimeInvisibleAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(methodVisitor.visitAnnotation(annotationDescriptor, /* visible= */\r\n            false), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeVisibleTypeAnnotations attribute.\r\n    if (runtimeVisibleTypeAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the target_type, target_info and target_path fields.\r\n            currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(methodVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor, /* visible= */\r\n            true), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeInvisibleTypeAnnotations attribute.\r\n    if (runtimeInvisibleTypeAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the target_type, target_info and target_path fields.\r\n            currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(methodVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor, /* visible= */\r\n            false), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeVisibleParameterAnnotations attribute.\r\n    if (runtimeVisibleParameterAnnotationsOffset != 0) {\r\n        readParameterAnnotations(methodVisitor, context, runtimeVisibleParameterAnnotationsOffset, /* visible= */\r\n        true);\r\n    }\r\n    // Visit the RuntimeInvisibleParameterAnnotations attribute.\r\n    if (runtimeInvisibleParameterAnnotationsOffset != 0) {\r\n        readParameterAnnotations(methodVisitor, context, runtimeInvisibleParameterAnnotationsOffset, /* visible= */\r\n        false);\r\n    }\r\n    // Visit the non standard attributes.\r\n    while (attributes != null) {\r\n        // Copy and reset the nextAttribute field so that it can also be used in MethodWriter.\r\n        Attribute nextAttribute = attributes.nextAttribute;\r\n        attributes.nextAttribute = null;\r\n        methodVisitor.visitAttribute(attributes);\r\n        attributes = nextAttribute;\r\n    }\r\n    // Visit the Code attribute.\r\n    if (codeOffset != 0) {\r\n        methodVisitor.visitCode();\r\n        readCode(methodVisitor, context, codeOffset);\r\n    }\r\n    // Visit the end of the method.\r\n    methodVisitor.visitEnd();\r\n    return currentOffset;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ClassReader#readMethod(ClassVisitor,Context,int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ClassReader#readCode(MethodVisitor,Context,int)",
    "headType": "method",
    "relation": "provide",
    "tail": "// ----------------------------------------------------------------------------------------------\r\n// Methods to parse a Code attribute\r\n// ----------------------------------------------------------------------------------------------\r\n/**\r\n * Reads a JVMS 'Code' attribute and makes the given visitor visit it.\r\n *\r\n * @param methodVisitor the visitor that must visit the Code attribute.\r\n * @param context information about the class being parsed.\r\n * @param codeOffset the start offset in {@link #classFileBuffer} of the Code attribute, excluding\r\n *     its attribute_name_index and attribute_length fields.\r\n */\r\nprivate void readCode(final MethodVisitor methodVisitor, final Context context, final int codeOffset) {\r\n    int currentOffset = codeOffset;\r\n    // Read the max_stack, max_locals and code_length fields.\r\n    final byte[] classBuffer = classFileBuffer;\r\n    final char[] charBuffer = context.charBuffer;\r\n    final int maxStack = readUnsignedShort(currentOffset);\r\n    final int maxLocals = readUnsignedShort(currentOffset + 2);\r\n    final int codeLength = readInt(currentOffset + 4);\r\n    currentOffset += 8;\r\n    if (codeLength > classFileBuffer.length - currentOffset) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    // Read the bytecode 'code' array to create a label for each referenced instruction.\r\n    final int bytecodeStartOffset = currentOffset;\r\n    final int bytecodeEndOffset = currentOffset + codeLength;\r\n    final Label[] labels = context.currentMethodLabels = new Label[codeLength + 1];\r\n    while (currentOffset < bytecodeEndOffset) {\r\n        final int bytecodeOffset = currentOffset - bytecodeStartOffset;\r\n        final int opcode = classBuffer[currentOffset] & 0xFF;\r\n        switch(opcode) {\r\n            case Opcodes.NOP:\r\n            case Opcodes.ACONST_NULL:\r\n            case Opcodes.ICONST_M1:\r\n            case Opcodes.ICONST_0:\r\n            case Opcodes.ICONST_1:\r\n            case Opcodes.ICONST_2:\r\n            case Opcodes.ICONST_3:\r\n            case Opcodes.ICONST_4:\r\n            case Opcodes.ICONST_5:\r\n            case Opcodes.LCONST_0:\r\n            case Opcodes.LCONST_1:\r\n            case Opcodes.FCONST_0:\r\n            case Opcodes.FCONST_1:\r\n            case Opcodes.FCONST_2:\r\n            case Opcodes.DCONST_0:\r\n            case Opcodes.DCONST_1:\r\n            case Opcodes.IALOAD:\r\n            case Opcodes.LALOAD:\r\n            case Opcodes.FALOAD:\r\n            case Opcodes.DALOAD:\r\n            case Opcodes.AALOAD:\r\n            case Opcodes.BALOAD:\r\n            case Opcodes.CALOAD:\r\n            case Opcodes.SALOAD:\r\n            case Opcodes.IASTORE:\r\n            case Opcodes.LASTORE:\r\n            case Opcodes.FASTORE:\r\n            case Opcodes.DASTORE:\r\n            case Opcodes.AASTORE:\r\n            case Opcodes.BASTORE:\r\n            case Opcodes.CASTORE:\r\n            case Opcodes.SASTORE:\r\n            case Opcodes.POP:\r\n            case Opcodes.POP2:\r\n            case Opcodes.DUP:\r\n            case Opcodes.DUP_X1:\r\n            case Opcodes.DUP_X2:\r\n            case Opcodes.DUP2:\r\n            case Opcodes.DUP2_X1:\r\n            case Opcodes.DUP2_X2:\r\n            case Opcodes.SWAP:\r\n            case Opcodes.IADD:\r\n            case Opcodes.LADD:\r\n            case Opcodes.FADD:\r\n            case Opcodes.DADD:\r\n            case Opcodes.ISUB:\r\n            case Opcodes.LSUB:\r\n            case Opcodes.FSUB:\r\n            case Opcodes.DSUB:\r\n            case Opcodes.IMUL:\r\n            case Opcodes.LMUL:\r\n            case Opcodes.FMUL:\r\n            case Opcodes.DMUL:\r\n            case Opcodes.IDIV:\r\n            case Opcodes.LDIV:\r\n            case Opcodes.FDIV:\r\n            case Opcodes.DDIV:\r\n            case Opcodes.IREM:\r\n            case Opcodes.LREM:\r\n            case Opcodes.FREM:\r\n            case Opcodes.DREM:\r\n            case Opcodes.INEG:\r\n            case Opcodes.LNEG:\r\n            case Opcodes.FNEG:\r\n            case Opcodes.DNEG:\r\n            case Opcodes.ISHL:\r\n            case Opcodes.LSHL:\r\n            case Opcodes.ISHR:\r\n            case Opcodes.LSHR:\r\n            case Opcodes.IUSHR:\r\n            case Opcodes.LUSHR:\r\n            case Opcodes.IAND:\r\n            case Opcodes.LAND:\r\n            case Opcodes.IOR:\r\n            case Opcodes.LOR:\r\n            case Opcodes.IXOR:\r\n            case Opcodes.LXOR:\r\n            case Opcodes.I2L:\r\n            case Opcodes.I2F:\r\n            case Opcodes.I2D:\r\n            case Opcodes.L2I:\r\n            case Opcodes.L2F:\r\n            case Opcodes.L2D:\r\n            case Opcodes.F2I:\r\n            case Opcodes.F2L:\r\n            case Opcodes.F2D:\r\n            case Opcodes.D2I:\r\n            case Opcodes.D2L:\r\n            case Opcodes.D2F:\r\n            case Opcodes.I2B:\r\n            case Opcodes.I2C:\r\n            case Opcodes.I2S:\r\n            case Opcodes.LCMP:\r\n            case Opcodes.FCMPL:\r\n            case Opcodes.FCMPG:\r\n            case Opcodes.DCMPL:\r\n            case Opcodes.DCMPG:\r\n            case Opcodes.IRETURN:\r\n            case Opcodes.LRETURN:\r\n            case Opcodes.FRETURN:\r\n            case Opcodes.DRETURN:\r\n            case Opcodes.ARETURN:\r\n            case Opcodes.RETURN:\r\n            case Opcodes.ARRAYLENGTH:\r\n            case Opcodes.ATHROW:\r\n            case Opcodes.MONITORENTER:\r\n            case Opcodes.MONITOREXIT:\r\n            case Constants.ILOAD_0:\r\n            case Constants.ILOAD_1:\r\n            case Constants.ILOAD_2:\r\n            case Constants.ILOAD_3:\r\n            case Constants.LLOAD_0:\r\n            case Constants.LLOAD_1:\r\n            case Constants.LLOAD_2:\r\n            case Constants.LLOAD_3:\r\n            case Constants.FLOAD_0:\r\n            case Constants.FLOAD_1:\r\n            case Constants.FLOAD_2:\r\n            case Constants.FLOAD_3:\r\n            case Constants.DLOAD_0:\r\n            case Constants.DLOAD_1:\r\n            case Constants.DLOAD_2:\r\n            case Constants.DLOAD_3:\r\n            case Constants.ALOAD_0:\r\n            case Constants.ALOAD_1:\r\n            case Constants.ALOAD_2:\r\n            case Constants.ALOAD_3:\r\n            case Constants.ISTORE_0:\r\n            case Constants.ISTORE_1:\r\n            case Constants.ISTORE_2:\r\n            case Constants.ISTORE_3:\r\n            case Constants.LSTORE_0:\r\n            case Constants.LSTORE_1:\r\n            case Constants.LSTORE_2:\r\n            case Constants.LSTORE_3:\r\n            case Constants.FSTORE_0:\r\n            case Constants.FSTORE_1:\r\n            case Constants.FSTORE_2:\r\n            case Constants.FSTORE_3:\r\n            case Constants.DSTORE_0:\r\n            case Constants.DSTORE_1:\r\n            case Constants.DSTORE_2:\r\n            case Constants.DSTORE_3:\r\n            case Constants.ASTORE_0:\r\n            case Constants.ASTORE_1:\r\n            case Constants.ASTORE_2:\r\n            case Constants.ASTORE_3:\r\n                currentOffset += 1;\r\n                break;\r\n            case Opcodes.IFEQ:\r\n            case Opcodes.IFNE:\r\n            case Opcodes.IFLT:\r\n            case Opcodes.IFGE:\r\n            case Opcodes.IFGT:\r\n            case Opcodes.IFLE:\r\n            case Opcodes.IF_ICMPEQ:\r\n            case Opcodes.IF_ICMPNE:\r\n            case Opcodes.IF_ICMPLT:\r\n            case Opcodes.IF_ICMPGE:\r\n            case Opcodes.IF_ICMPGT:\r\n            case Opcodes.IF_ICMPLE:\r\n            case Opcodes.IF_ACMPEQ:\r\n            case Opcodes.IF_ACMPNE:\r\n            case Opcodes.GOTO:\r\n            case Opcodes.JSR:\r\n            case Opcodes.IFNULL:\r\n            case Opcodes.IFNONNULL:\r\n                createLabel(bytecodeOffset + readShort(currentOffset + 1), labels);\r\n                currentOffset += 3;\r\n                break;\r\n            case Constants.ASM_IFEQ:\r\n            case Constants.ASM_IFNE:\r\n            case Constants.ASM_IFLT:\r\n            case Constants.ASM_IFGE:\r\n            case Constants.ASM_IFGT:\r\n            case Constants.ASM_IFLE:\r\n            case Constants.ASM_IF_ICMPEQ:\r\n            case Constants.ASM_IF_ICMPNE:\r\n            case Constants.ASM_IF_ICMPLT:\r\n            case Constants.ASM_IF_ICMPGE:\r\n            case Constants.ASM_IF_ICMPGT:\r\n            case Constants.ASM_IF_ICMPLE:\r\n            case Constants.ASM_IF_ACMPEQ:\r\n            case Constants.ASM_IF_ACMPNE:\r\n            case Constants.ASM_GOTO:\r\n            case Constants.ASM_JSR:\r\n            case Constants.ASM_IFNULL:\r\n            case Constants.ASM_IFNONNULL:\r\n                createLabel(bytecodeOffset + readUnsignedShort(currentOffset + 1), labels);\r\n                currentOffset += 3;\r\n                break;\r\n            case Constants.GOTO_W:\r\n            case Constants.JSR_W:\r\n            case Constants.ASM_GOTO_W:\r\n                createLabel(bytecodeOffset + readInt(currentOffset + 1), labels);\r\n                currentOffset += 5;\r\n                break;\r\n            case Constants.WIDE:\r\n                switch(classBuffer[currentOffset + 1] & 0xFF) {\r\n                    case Opcodes.ILOAD:\r\n                    case Opcodes.FLOAD:\r\n                    case Opcodes.ALOAD:\r\n                    case Opcodes.LLOAD:\r\n                    case Opcodes.DLOAD:\r\n                    case Opcodes.ISTORE:\r\n                    case Opcodes.FSTORE:\r\n                    case Opcodes.ASTORE:\r\n                    case Opcodes.LSTORE:\r\n                    case Opcodes.DSTORE:\r\n                    case Opcodes.RET:\r\n                        currentOffset += 4;\r\n                        break;\r\n                    case Opcodes.IINC:\r\n                        currentOffset += 6;\r\n                        break;\r\n                    default:\r\n                        throw new IllegalArgumentException();\r\n                }\r\n                break;\r\n            case Opcodes.TABLESWITCH:\r\n                // Skip 0 to 3 padding bytes.\r\n                currentOffset += 4 - (bytecodeOffset & 3);\r\n                // Read the default label and the number of table entries.\r\n                createLabel(bytecodeOffset + readInt(currentOffset), labels);\r\n                int numTableEntries = readInt(currentOffset + 8) - readInt(currentOffset + 4) + 1;\r\n                currentOffset += 12;\r\n                // Read the table labels.\r\n                while (numTableEntries-- > 0) {\r\n                    createLabel(bytecodeOffset + readInt(currentOffset), labels);\r\n                    currentOffset += 4;\r\n                }\r\n                break;\r\n            case Opcodes.LOOKUPSWITCH:\r\n                // Skip 0 to 3 padding bytes.\r\n                currentOffset += 4 - (bytecodeOffset & 3);\r\n                // Read the default label and the number of switch cases.\r\n                createLabel(bytecodeOffset + readInt(currentOffset), labels);\r\n                int numSwitchCases = readInt(currentOffset + 4);\r\n                currentOffset += 8;\r\n                // Read the switch labels.\r\n                while (numSwitchCases-- > 0) {\r\n                    createLabel(bytecodeOffset + readInt(currentOffset + 4), labels);\r\n                    currentOffset += 8;\r\n                }\r\n                break;\r\n            case Opcodes.ILOAD:\r\n            case Opcodes.LLOAD:\r\n            case Opcodes.FLOAD:\r\n            case Opcodes.DLOAD:\r\n            case Opcodes.ALOAD:\r\n            case Opcodes.ISTORE:\r\n            case Opcodes.LSTORE:\r\n            case Opcodes.FSTORE:\r\n            case Opcodes.DSTORE:\r\n            case Opcodes.ASTORE:\r\n            case Opcodes.RET:\r\n            case Opcodes.BIPUSH:\r\n            case Opcodes.NEWARRAY:\r\n            case Opcodes.LDC:\r\n                currentOffset += 2;\r\n                break;\r\n            case Opcodes.SIPUSH:\r\n            case Constants.LDC_W:\r\n            case Constants.LDC2_W:\r\n            case Opcodes.GETSTATIC:\r\n            case Opcodes.PUTSTATIC:\r\n            case Opcodes.GETFIELD:\r\n            case Opcodes.PUTFIELD:\r\n            case Opcodes.INVOKEVIRTUAL:\r\n            case Opcodes.INVOKESPECIAL:\r\n            case Opcodes.INVOKESTATIC:\r\n            case Opcodes.NEW:\r\n            case Opcodes.ANEWARRAY:\r\n            case Opcodes.CHECKCAST:\r\n            case Opcodes.INSTANCEOF:\r\n            case Opcodes.IINC:\r\n                currentOffset += 3;\r\n                break;\r\n            case Opcodes.INVOKEINTERFACE:\r\n            case Opcodes.INVOKEDYNAMIC:\r\n                currentOffset += 5;\r\n                break;\r\n            case Opcodes.MULTIANEWARRAY:\r\n                currentOffset += 4;\r\n                break;\r\n            default:\r\n                throw new IllegalArgumentException();\r\n        }\r\n    }\r\n    // Read the 'exception_table_length' and 'exception_table' field to create a label for each\r\n    // referenced instruction, and to make methodVisitor visit the corresponding try catch blocks.\r\n    int exceptionTableLength = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (exceptionTableLength-- > 0) {\r\n        Label start = createLabel(readUnsignedShort(currentOffset), labels);\r\n        Label end = createLabel(readUnsignedShort(currentOffset + 2), labels);\r\n        Label handler = createLabel(readUnsignedShort(currentOffset + 4), labels);\r\n        String catchType = readUTF8(cpInfoOffsets[readUnsignedShort(currentOffset + 6)], charBuffer);\r\n        currentOffset += 8;\r\n        methodVisitor.visitTryCatchBlock(start, end, handler, catchType);\r\n    }\r\n    // Read the Code attributes to create a label for each referenced instruction (the variables\r\n    // are ordered as in Section 4.7 of the JVMS). Attribute offsets exclude the\r\n    // attribute_name_index and attribute_length fields.\r\n    // - The offset of the current 'stack_map_frame' in the StackMap[Table] attribute, or 0.\r\n    // Initially, this is the offset of the first 'stack_map_frame' entry. Then this offset is\r\n    // updated after each stack_map_frame is read.\r\n    int stackMapFrameOffset = 0;\r\n    // - The end offset of the StackMap[Table] attribute, or 0.\r\n    int stackMapTableEndOffset = 0;\r\n    // - Whether the stack map frames are compressed (i.e. in a StackMapTable) or not.\r\n    boolean compressedFrames = true;\r\n    // - The offset of the LocalVariableTable attribute, or 0.\r\n    int localVariableTableOffset = 0;\r\n    // - The offset of the LocalVariableTypeTable attribute, or 0.\r\n    int localVariableTypeTableOffset = 0;\r\n    // - The offset of each 'type_annotation' entry in the RuntimeVisibleTypeAnnotations\r\n    // attribute, or null.\r\n    int[] visibleTypeAnnotationOffsets = null;\r\n    // - The offset of each 'type_annotation' entry in the RuntimeInvisibleTypeAnnotations\r\n    // attribute, or null.\r\n    int[] invisibleTypeAnnotationOffsets = null;\r\n    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\r\n    //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\r\n    Attribute attributes = null;\r\n    int attributesCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (attributesCount-- > 0) {\r\n        // Read the attribute_info's attribute_name and attribute_length fields.\r\n        String attributeName = readUTF8(currentOffset, charBuffer);\r\n        int attributeLength = readInt(currentOffset + 2);\r\n        currentOffset += 6;\r\n        if (Constants.LOCAL_VARIABLE_TABLE.equals(attributeName)) {\r\n            if ((context.parsingOptions & SKIP_DEBUG) == 0) {\r\n                localVariableTableOffset = currentOffset;\r\n                // Parse the attribute to find the corresponding (debug only) labels.\r\n                int currentLocalVariableTableOffset = currentOffset;\r\n                int localVariableTableLength = readUnsignedShort(currentLocalVariableTableOffset);\r\n                currentLocalVariableTableOffset += 2;\r\n                while (localVariableTableLength-- > 0) {\r\n                    int startPc = readUnsignedShort(currentLocalVariableTableOffset);\r\n                    createDebugLabel(startPc, labels);\r\n                    int length = readUnsignedShort(currentLocalVariableTableOffset + 2);\r\n                    createDebugLabel(startPc + length, labels);\r\n                    // Skip the name_index, descriptor_index and index fields (2 bytes each).\r\n                    currentLocalVariableTableOffset += 10;\r\n                }\r\n            }\r\n        } else if (Constants.LOCAL_VARIABLE_TYPE_TABLE.equals(attributeName)) {\r\n            localVariableTypeTableOffset = currentOffset;\r\n            // Here we do not extract the labels corresponding to the attribute content. We assume they\r\n            // are the same or a subset of those of the LocalVariableTable attribute.\r\n        } else if (Constants.LINE_NUMBER_TABLE.equals(attributeName)) {\r\n            if ((context.parsingOptions & SKIP_DEBUG) == 0) {\r\n                // Parse the attribute to find the corresponding (debug only) labels.\r\n                int currentLineNumberTableOffset = currentOffset;\r\n                int lineNumberTableLength = readUnsignedShort(currentLineNumberTableOffset);\r\n                currentLineNumberTableOffset += 2;\r\n                while (lineNumberTableLength-- > 0) {\r\n                    int startPc = readUnsignedShort(currentLineNumberTableOffset);\r\n                    int lineNumber = readUnsignedShort(currentLineNumberTableOffset + 2);\r\n                    currentLineNumberTableOffset += 4;\r\n                    createDebugLabel(startPc, labels);\r\n                    labels[startPc].addLineNumber(lineNumber);\r\n                }\r\n            }\r\n        } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\r\n            visibleTypeAnnotationOffsets = readTypeAnnotations(methodVisitor, context, currentOffset, /* visible= */\r\n            true);\r\n            // Here we do not extract the labels corresponding to the attribute content. This would\r\n            // require a full parsing of the attribute, which would need to be repeated when parsing\r\n            // the bytecode instructions (see below). Instead, the content of the attribute is read one\r\n            // type annotation at a time (i.e. after a type annotation has been visited, the next type\r\n            // annotation is read), and the labels it contains are also extracted one annotation at a\r\n            // time. This assumes that type annotations are ordered by increasing bytecode offset.\r\n        } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\r\n            invisibleTypeAnnotationOffsets = readTypeAnnotations(methodVisitor, context, currentOffset, /* visible= */\r\n            false);\r\n            // Same comment as above for the RuntimeVisibleTypeAnnotations attribute.\r\n        } else if (Constants.STACK_MAP_TABLE.equals(attributeName)) {\r\n            if ((context.parsingOptions & SKIP_FRAMES) == 0) {\r\n                stackMapFrameOffset = currentOffset + 2;\r\n                stackMapTableEndOffset = currentOffset + attributeLength;\r\n            }\r\n            // Here we do not extract the labels corresponding to the attribute content. This would\r\n            // require a full parsing of the attribute, which would need to be repeated when parsing\r\n            // the bytecode instructions (see below). Instead, the content of the attribute is read one\r\n            // frame at a time (i.e. after a frame has been visited, the next frame is read), and the\r\n            // labels it contains are also extracted one frame at a time. Thanks to the ordering of\r\n            // frames, having only a \"one frame lookahead\" is not a problem, i.e. it is not possible to\r\n            // see an offset smaller than the offset of the current instruction and for which no Label\r\n            // exist. Except for UNINITIALIZED type offsets. We solve this by parsing the stack map\r\n            // table without a full decoding (see below).\r\n        } else if (\"StackMap\".equals(attributeName)) {\r\n            if ((context.parsingOptions & SKIP_FRAMES) == 0) {\r\n                stackMapFrameOffset = currentOffset + 2;\r\n                stackMapTableEndOffset = currentOffset + attributeLength;\r\n                compressedFrames = false;\r\n            }\r\n            // IMPORTANT! Here we assume that the frames are ordered, as in the StackMapTable attribute,\r\n            // although this is not guaranteed by the attribute format. This allows an incremental\r\n            // extraction of the labels corresponding to this attribute (see the comment above for the\r\n            // StackMapTable attribute).\r\n        } else {\r\n            Attribute attribute = readAttribute(context.attributePrototypes, attributeName, currentOffset, attributeLength, charBuffer, codeOffset, labels);\r\n            attribute.nextAttribute = attributes;\r\n            attributes = attribute;\r\n        }\r\n        currentOffset += attributeLength;\r\n    }\r\n    // Initialize the context fields related to stack map frames, and generate the first\r\n    // (implicit) stack map frame, if needed.\r\n    final boolean expandFrames = (context.parsingOptions & EXPAND_FRAMES) != 0;\r\n    if (stackMapFrameOffset != 0) {\r\n        // The bytecode offset of the first explicit frame is not offset_delta + 1 but only\r\n        // offset_delta. Setting the implicit frame offset to -1 allows us to use of the\r\n        // \"offset_delta + 1\" rule in all cases.\r\n        context.currentFrameOffset = -1;\r\n        context.currentFrameType = 0;\r\n        context.currentFrameLocalCount = 0;\r\n        context.currentFrameLocalCountDelta = 0;\r\n        context.currentFrameLocalTypes = new Object[maxLocals];\r\n        context.currentFrameStackCount = 0;\r\n        context.currentFrameStackTypes = new Object[maxStack];\r\n        if (expandFrames) {\r\n            computeImplicitFrame(context);\r\n        }\r\n        // Find the labels for UNINITIALIZED frame types. Instead of decoding each element of the\r\n        // stack map table, we look for 3 consecutive bytes that \"look like\" an UNINITIALIZED type\r\n        // (tag ITEM_Uninitialized, offset within bytecode bounds, NEW instruction at this offset).\r\n        // We may find false positives (i.e. not real UNINITIALIZED types), but this should be rare,\r\n        // and the only consequence will be the creation of an unneeded label. This is better than\r\n        // creating a label for each NEW instruction, and faster than fully decoding the whole stack\r\n        // map table.\r\n        for (int offset = stackMapFrameOffset; offset < stackMapTableEndOffset - 2; ++offset) {\r\n            if (classBuffer[offset] == Frame.ITEM_UNINITIALIZED) {\r\n                int potentialBytecodeOffset = readUnsignedShort(offset + 1);\r\n                if (potentialBytecodeOffset >= 0 && potentialBytecodeOffset < codeLength && (classBuffer[bytecodeStartOffset + potentialBytecodeOffset] & 0xFF) == Opcodes.NEW) {\r\n                    createLabel(potentialBytecodeOffset, labels);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (expandFrames && (context.parsingOptions & EXPAND_ASM_INSNS) != 0) {\r\n        // Expanding the ASM specific instructions can introduce F_INSERT frames, even if the method\r\n        // does not currently have any frame. These inserted frames must be computed by simulating the\r\n        // effect of the bytecode instructions, one by one, starting from the implicit first frame.\r\n        // For this, MethodWriter needs to know maxLocals before the first instruction is visited. To\r\n        // ensure this, we visit the implicit first frame here (passing only maxLocals - the rest is\r\n        // computed in MethodWriter).\r\n        methodVisitor.visitFrame(Opcodes.F_NEW, maxLocals, null, 0, null);\r\n    }\r\n    // Visit the bytecode instructions. First, introduce state variables for the incremental parsing\r\n    // of the type annotations.\r\n    // Index of the next runtime visible type annotation to read (in the\r\n    // visibleTypeAnnotationOffsets array).\r\n    int currentVisibleTypeAnnotationIndex = 0;\r\n    // The bytecode offset of the next runtime visible type annotation to read, or -1.\r\n    int currentVisibleTypeAnnotationBytecodeOffset = getTypeAnnotationBytecodeOffset(visibleTypeAnnotationOffsets, 0);\r\n    // Index of the next runtime invisible type annotation to read (in the\r\n    // invisibleTypeAnnotationOffsets array).\r\n    int currentInvisibleTypeAnnotationIndex = 0;\r\n    // The bytecode offset of the next runtime invisible type annotation to read, or -1.\r\n    int currentInvisibleTypeAnnotationBytecodeOffset = getTypeAnnotationBytecodeOffset(invisibleTypeAnnotationOffsets, 0);\r\n    // Whether a F_INSERT stack map frame must be inserted before the current instruction.\r\n    boolean insertFrame = false;\r\n    // The delta to subtract from a goto_w or jsr_w opcode to get the corresponding goto or jsr\r\n    // opcode, or 0 if goto_w and jsr_w must be left unchanged (i.e. when expanding ASM specific\r\n    // instructions).\r\n    final int wideJumpOpcodeDelta = (context.parsingOptions & EXPAND_ASM_INSNS) == 0 ? Constants.WIDE_JUMP_OPCODE_DELTA : 0;\r\n    currentOffset = bytecodeStartOffset;\r\n    while (currentOffset < bytecodeEndOffset) {\r\n        final int currentBytecodeOffset = currentOffset - bytecodeStartOffset;\r\n        readBytecodeInstructionOffset(currentBytecodeOffset);\r\n        // Visit the label and the line number(s) for this bytecode offset, if any.\r\n        Label currentLabel = labels[currentBytecodeOffset];\r\n        if (currentLabel != null) {\r\n            currentLabel.accept(methodVisitor, (context.parsingOptions & SKIP_DEBUG) == 0);\r\n        }\r\n        // Visit the stack map frame for this bytecode offset, if any.\r\n        while (stackMapFrameOffset != 0 && (context.currentFrameOffset == currentBytecodeOffset || context.currentFrameOffset == -1)) {\r\n            // If there is a stack map frame for this offset, make methodVisitor visit it, and read the\r\n            // next stack map frame if there is one.\r\n            if (context.currentFrameOffset != -1) {\r\n                if (!compressedFrames || expandFrames) {\r\n                    methodVisitor.visitFrame(Opcodes.F_NEW, context.currentFrameLocalCount, context.currentFrameLocalTypes, context.currentFrameStackCount, context.currentFrameStackTypes);\r\n                } else {\r\n                    methodVisitor.visitFrame(context.currentFrameType, context.currentFrameLocalCountDelta, context.currentFrameLocalTypes, context.currentFrameStackCount, context.currentFrameStackTypes);\r\n                }\r\n                // Since there is already a stack map frame for this bytecode offset, there is no need to\r\n                // insert a new one.\r\n                insertFrame = false;\r\n            }\r\n            if (stackMapFrameOffset < stackMapTableEndOffset) {\r\n                stackMapFrameOffset = readStackMapFrame(stackMapFrameOffset, compressedFrames, expandFrames, context);\r\n            } else {\r\n                stackMapFrameOffset = 0;\r\n            }\r\n        }\r\n        // Insert a stack map frame for this bytecode offset, if requested by setting insertFrame to\r\n        // true during the previous iteration. The actual frame content is computed in MethodWriter.\r\n        if (insertFrame) {\r\n            if ((context.parsingOptions & EXPAND_FRAMES) != 0) {\r\n                methodVisitor.visitFrame(Constants.F_INSERT, 0, null, 0, null);\r\n            }\r\n            insertFrame = false;\r\n        }\r\n        // Visit the instruction at this bytecode offset.\r\n        int opcode = classBuffer[currentOffset] & 0xFF;\r\n        switch(opcode) {\r\n            case Opcodes.NOP:\r\n            case Opcodes.ACONST_NULL:\r\n            case Opcodes.ICONST_M1:\r\n            case Opcodes.ICONST_0:\r\n            case Opcodes.ICONST_1:\r\n            case Opcodes.ICONST_2:\r\n            case Opcodes.ICONST_3:\r\n            case Opcodes.ICONST_4:\r\n            case Opcodes.ICONST_5:\r\n            case Opcodes.LCONST_0:\r\n            case Opcodes.LCONST_1:\r\n            case Opcodes.FCONST_0:\r\n            case Opcodes.FCONST_1:\r\n            case Opcodes.FCONST_2:\r\n            case Opcodes.DCONST_0:\r\n            case Opcodes.DCONST_1:\r\n            case Opcodes.IALOAD:\r\n            case Opcodes.LALOAD:\r\n            case Opcodes.FALOAD:\r\n            case Opcodes.DALOAD:\r\n            case Opcodes.AALOAD:\r\n            case Opcodes.BALOAD:\r\n            case Opcodes.CALOAD:\r\n            case Opcodes.SALOAD:\r\n            case Opcodes.IASTORE:\r\n            case Opcodes.LASTORE:\r\n            case Opcodes.FASTORE:\r\n            case Opcodes.DASTORE:\r\n            case Opcodes.AASTORE:\r\n            case Opcodes.BASTORE:\r\n            case Opcodes.CASTORE:\r\n            case Opcodes.SASTORE:\r\n            case Opcodes.POP:\r\n            case Opcodes.POP2:\r\n            case Opcodes.DUP:\r\n            case Opcodes.DUP_X1:\r\n            case Opcodes.DUP_X2:\r\n            case Opcodes.DUP2:\r\n            case Opcodes.DUP2_X1:\r\n            case Opcodes.DUP2_X2:\r\n            case Opcodes.SWAP:\r\n            case Opcodes.IADD:\r\n            case Opcodes.LADD:\r\n            case Opcodes.FADD:\r\n            case Opcodes.DADD:\r\n            case Opcodes.ISUB:\r\n            case Opcodes.LSUB:\r\n            case Opcodes.FSUB:\r\n            case Opcodes.DSUB:\r\n            case Opcodes.IMUL:\r\n            case Opcodes.LMUL:\r\n            case Opcodes.FMUL:\r\n            case Opcodes.DMUL:\r\n            case Opcodes.IDIV:\r\n            case Opcodes.LDIV:\r\n            case Opcodes.FDIV:\r\n            case Opcodes.DDIV:\r\n            case Opcodes.IREM:\r\n            case Opcodes.LREM:\r\n            case Opcodes.FREM:\r\n            case Opcodes.DREM:\r\n            case Opcodes.INEG:\r\n            case Opcodes.LNEG:\r\n            case Opcodes.FNEG:\r\n            case Opcodes.DNEG:\r\n            case Opcodes.ISHL:\r\n            case Opcodes.LSHL:\r\n            case Opcodes.ISHR:\r\n            case Opcodes.LSHR:\r\n            case Opcodes.IUSHR:\r\n            case Opcodes.LUSHR:\r\n            case Opcodes.IAND:\r\n            case Opcodes.LAND:\r\n            case Opcodes.IOR:\r\n            case Opcodes.LOR:\r\n            case Opcodes.IXOR:\r\n            case Opcodes.LXOR:\r\n            case Opcodes.I2L:\r\n            case Opcodes.I2F:\r\n            case Opcodes.I2D:\r\n            case Opcodes.L2I:\r\n            case Opcodes.L2F:\r\n            case Opcodes.L2D:\r\n            case Opcodes.F2I:\r\n            case Opcodes.F2L:\r\n            case Opcodes.F2D:\r\n            case Opcodes.D2I:\r\n            case Opcodes.D2L:\r\n            case Opcodes.D2F:\r\n            case Opcodes.I2B:\r\n            case Opcodes.I2C:\r\n            case Opcodes.I2S:\r\n            case Opcodes.LCMP:\r\n            case Opcodes.FCMPL:\r\n            case Opcodes.FCMPG:\r\n            case Opcodes.DCMPL:\r\n            case Opcodes.DCMPG:\r\n            case Opcodes.IRETURN:\r\n            case Opcodes.LRETURN:\r\n            case Opcodes.FRETURN:\r\n            case Opcodes.DRETURN:\r\n            case Opcodes.ARETURN:\r\n            case Opcodes.RETURN:\r\n            case Opcodes.ARRAYLENGTH:\r\n            case Opcodes.ATHROW:\r\n            case Opcodes.MONITORENTER:\r\n            case Opcodes.MONITOREXIT:\r\n                methodVisitor.visitInsn(opcode);\r\n                currentOffset += 1;\r\n                break;\r\n            case Constants.ILOAD_0:\r\n            case Constants.ILOAD_1:\r\n            case Constants.ILOAD_2:\r\n            case Constants.ILOAD_3:\r\n            case Constants.LLOAD_0:\r\n            case Constants.LLOAD_1:\r\n            case Constants.LLOAD_2:\r\n            case Constants.LLOAD_3:\r\n            case Constants.FLOAD_0:\r\n            case Constants.FLOAD_1:\r\n            case Constants.FLOAD_2:\r\n            case Constants.FLOAD_3:\r\n            case Constants.DLOAD_0:\r\n            case Constants.DLOAD_1:\r\n            case Constants.DLOAD_2:\r\n            case Constants.DLOAD_3:\r\n            case Constants.ALOAD_0:\r\n            case Constants.ALOAD_1:\r\n            case Constants.ALOAD_2:\r\n            case Constants.ALOAD_3:\r\n                opcode -= Constants.ILOAD_0;\r\n                methodVisitor.visitVarInsn(Opcodes.ILOAD + (opcode >> 2), opcode & 0x3);\r\n                currentOffset += 1;\r\n                break;\r\n            case Constants.ISTORE_0:\r\n            case Constants.ISTORE_1:\r\n            case Constants.ISTORE_2:\r\n            case Constants.ISTORE_3:\r\n            case Constants.LSTORE_0:\r\n            case Constants.LSTORE_1:\r\n            case Constants.LSTORE_2:\r\n            case Constants.LSTORE_3:\r\n            case Constants.FSTORE_0:\r\n            case Constants.FSTORE_1:\r\n            case Constants.FSTORE_2:\r\n            case Constants.FSTORE_3:\r\n            case Constants.DSTORE_0:\r\n            case Constants.DSTORE_1:\r\n            case Constants.DSTORE_2:\r\n            case Constants.DSTORE_3:\r\n            case Constants.ASTORE_0:\r\n            case Constants.ASTORE_1:\r\n            case Constants.ASTORE_2:\r\n            case Constants.ASTORE_3:\r\n                opcode -= Constants.ISTORE_0;\r\n                methodVisitor.visitVarInsn(Opcodes.ISTORE + (opcode >> 2), opcode & 0x3);\r\n                currentOffset += 1;\r\n                break;\r\n            case Opcodes.IFEQ:\r\n            case Opcodes.IFNE:\r\n            case Opcodes.IFLT:\r\n            case Opcodes.IFGE:\r\n            case Opcodes.IFGT:\r\n            case Opcodes.IFLE:\r\n            case Opcodes.IF_ICMPEQ:\r\n            case Opcodes.IF_ICMPNE:\r\n            case Opcodes.IF_ICMPLT:\r\n            case Opcodes.IF_ICMPGE:\r\n            case Opcodes.IF_ICMPGT:\r\n            case Opcodes.IF_ICMPLE:\r\n            case Opcodes.IF_ACMPEQ:\r\n            case Opcodes.IF_ACMPNE:\r\n            case Opcodes.GOTO:\r\n            case Opcodes.JSR:\r\n            case Opcodes.IFNULL:\r\n            case Opcodes.IFNONNULL:\r\n                methodVisitor.visitJumpInsn(opcode, labels[currentBytecodeOffset + readShort(currentOffset + 1)]);\r\n                currentOffset += 3;\r\n                break;\r\n            case Constants.GOTO_W:\r\n            case Constants.JSR_W:\r\n                methodVisitor.visitJumpInsn(opcode - wideJumpOpcodeDelta, labels[currentBytecodeOffset + readInt(currentOffset + 1)]);\r\n                currentOffset += 5;\r\n                break;\r\n            case Constants.ASM_IFEQ:\r\n            case Constants.ASM_IFNE:\r\n            case Constants.ASM_IFLT:\r\n            case Constants.ASM_IFGE:\r\n            case Constants.ASM_IFGT:\r\n            case Constants.ASM_IFLE:\r\n            case Constants.ASM_IF_ICMPEQ:\r\n            case Constants.ASM_IF_ICMPNE:\r\n            case Constants.ASM_IF_ICMPLT:\r\n            case Constants.ASM_IF_ICMPGE:\r\n            case Constants.ASM_IF_ICMPGT:\r\n            case Constants.ASM_IF_ICMPLE:\r\n            case Constants.ASM_IF_ACMPEQ:\r\n            case Constants.ASM_IF_ACMPNE:\r\n            case Constants.ASM_GOTO:\r\n            case Constants.ASM_JSR:\r\n            case Constants.ASM_IFNULL:\r\n            case Constants.ASM_IFNONNULL:\r\n                {\r\n                    // A forward jump with an offset > 32767. In this case we automatically replace ASM_GOTO\r\n                    // with GOTO_W, ASM_JSR with JSR_W and ASM_IFxxx <l> with IFNOTxxx <L> GOTO_W <l> L:...,\r\n                    // where IFNOTxxx is the \"opposite\" opcode of ASMS_IFxxx (e.g. IFNE for ASM_IFEQ) and\r\n                    // where <L> designates the instruction just after the GOTO_W.\r\n                    // First, change the ASM specific opcodes ASM_IFEQ ... ASM_JSR, ASM_IFNULL and\r\n                    // ASM_IFNONNULL to IFEQ ... JSR, IFNULL and IFNONNULL.\r\n                    opcode = opcode < Constants.ASM_IFNULL ? opcode - Constants.ASM_OPCODE_DELTA : opcode - Constants.ASM_IFNULL_OPCODE_DELTA;\r\n                    Label target = labels[currentBytecodeOffset + readUnsignedShort(currentOffset + 1)];\r\n                    if (opcode == Opcodes.GOTO || opcode == Opcodes.JSR) {\r\n                        // Replace GOTO with GOTO_W and JSR with JSR_W.\r\n                        methodVisitor.visitJumpInsn(opcode + Constants.WIDE_JUMP_OPCODE_DELTA, target);\r\n                    } else {\r\n                        // Compute the \"opposite\" of opcode. This can be done by flipping the least\r\n                        // significant bit for IFNULL and IFNONNULL, and similarly for IFEQ ... IF_ACMPEQ\r\n                        // (with a pre and post offset by 1).\r\n                        opcode = opcode < Opcodes.GOTO ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1;\r\n                        Label endif = createLabel(currentBytecodeOffset + 3, labels);\r\n                        methodVisitor.visitJumpInsn(opcode, endif);\r\n                        methodVisitor.visitJumpInsn(Constants.GOTO_W, target);\r\n                        // endif designates the instruction just after GOTO_W, and is visited as part of the\r\n                        // next instruction. Since it is a jump target, we need to insert a frame here.\r\n                        insertFrame = true;\r\n                    }\r\n                    currentOffset += 3;\r\n                    break;\r\n                }\r\n            case Constants.ASM_GOTO_W:\r\n                // Replace ASM_GOTO_W with GOTO_W.\r\n                methodVisitor.visitJumpInsn(Constants.GOTO_W, labels[currentBytecodeOffset + readInt(currentOffset + 1)]);\r\n                // The instruction just after is a jump target (because ASM_GOTO_W is used in patterns\r\n                // IFNOTxxx <L> ASM_GOTO_W <l> L:..., see MethodWriter), so we need to insert a frame\r\n                // here.\r\n                insertFrame = true;\r\n                currentOffset += 5;\r\n                break;\r\n            case Constants.WIDE:\r\n                opcode = classBuffer[currentOffset + 1] & 0xFF;\r\n                if (opcode == Opcodes.IINC) {\r\n                    methodVisitor.visitIincInsn(readUnsignedShort(currentOffset + 2), readShort(currentOffset + 4));\r\n                    currentOffset += 6;\r\n                } else {\r\n                    methodVisitor.visitVarInsn(opcode, readUnsignedShort(currentOffset + 2));\r\n                    currentOffset += 4;\r\n                }\r\n                break;\r\n            case Opcodes.TABLESWITCH:\r\n                {\r\n                    // Skip 0 to 3 padding bytes.\r\n                    currentOffset += 4 - (currentBytecodeOffset & 3);\r\n                    // Read the instruction.\r\n                    Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];\r\n                    int low = readInt(currentOffset + 4);\r\n                    int high = readInt(currentOffset + 8);\r\n                    currentOffset += 12;\r\n                    Label[] table = new Label[high - low + 1];\r\n                    for (int i = 0; i < table.length; ++i) {\r\n                        table[i] = labels[currentBytecodeOffset + readInt(currentOffset)];\r\n                        currentOffset += 4;\r\n                    }\r\n                    methodVisitor.visitTableSwitchInsn(low, high, defaultLabel, table);\r\n                    break;\r\n                }\r\n            case Opcodes.LOOKUPSWITCH:\r\n                {\r\n                    // Skip 0 to 3 padding bytes.\r\n                    currentOffset += 4 - (currentBytecodeOffset & 3);\r\n                    // Read the instruction.\r\n                    Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];\r\n                    int numPairs = readInt(currentOffset + 4);\r\n                    currentOffset += 8;\r\n                    int[] keys = new int[numPairs];\r\n                    Label[] values = new Label[numPairs];\r\n                    for (int i = 0; i < numPairs; ++i) {\r\n                        keys[i] = readInt(currentOffset);\r\n                        values[i] = labels[currentBytecodeOffset + readInt(currentOffset + 4)];\r\n                        currentOffset += 8;\r\n                    }\r\n                    methodVisitor.visitLookupSwitchInsn(defaultLabel, keys, values);\r\n                    break;\r\n                }\r\n            case Opcodes.ILOAD:\r\n            case Opcodes.LLOAD:\r\n            case Opcodes.FLOAD:\r\n            case Opcodes.DLOAD:\r\n            case Opcodes.ALOAD:\r\n            case Opcodes.ISTORE:\r\n            case Opcodes.LSTORE:\r\n            case Opcodes.FSTORE:\r\n            case Opcodes.DSTORE:\r\n            case Opcodes.ASTORE:\r\n            case Opcodes.RET:\r\n                methodVisitor.visitVarInsn(opcode, classBuffer[currentOffset + 1] & 0xFF);\r\n                currentOffset += 2;\r\n                break;\r\n            case Opcodes.BIPUSH:\r\n            case Opcodes.NEWARRAY:\r\n                methodVisitor.visitIntInsn(opcode, classBuffer[currentOffset + 1]);\r\n                currentOffset += 2;\r\n                break;\r\n            case Opcodes.SIPUSH:\r\n                methodVisitor.visitIntInsn(opcode, readShort(currentOffset + 1));\r\n                currentOffset += 3;\r\n                break;\r\n            case Opcodes.LDC:\r\n                methodVisitor.visitLdcInsn(readConst(classBuffer[currentOffset + 1] & 0xFF, charBuffer));\r\n                currentOffset += 2;\r\n                break;\r\n            case Constants.LDC_W:\r\n            case Constants.LDC2_W:\r\n                methodVisitor.visitLdcInsn(readConst(readUnsignedShort(currentOffset + 1), charBuffer));\r\n                currentOffset += 3;\r\n                break;\r\n            case Opcodes.GETSTATIC:\r\n            case Opcodes.PUTSTATIC:\r\n            case Opcodes.GETFIELD:\r\n            case Opcodes.PUTFIELD:\r\n            case Opcodes.INVOKEVIRTUAL:\r\n            case Opcodes.INVOKESPECIAL:\r\n            case Opcodes.INVOKESTATIC:\r\n            case Opcodes.INVOKEINTERFACE:\r\n                {\r\n                    int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];\r\n                    int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];\r\n                    String owner = readClass(cpInfoOffset, charBuffer);\r\n                    String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);\r\n                    String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);\r\n                    if (opcode < Opcodes.INVOKEVIRTUAL) {\r\n                        methodVisitor.visitFieldInsn(opcode, owner, name, descriptor);\r\n                    } else {\r\n                        boolean isInterface = classBuffer[cpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;\r\n                        methodVisitor.visitMethodInsn(opcode, owner, name, descriptor, isInterface);\r\n                    }\r\n                    if (opcode == Opcodes.INVOKEINTERFACE) {\r\n                        currentOffset += 5;\r\n                    } else {\r\n                        currentOffset += 3;\r\n                    }\r\n                    break;\r\n                }\r\n            case Opcodes.INVOKEDYNAMIC:\r\n                {\r\n                    int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];\r\n                    int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];\r\n                    String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);\r\n                    String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);\r\n                    int bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];\r\n                    Handle handle = (Handle) readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);\r\n                    Object[] bootstrapMethodArguments = new Object[readUnsignedShort(bootstrapMethodOffset + 2)];\r\n                    bootstrapMethodOffset += 4;\r\n                    for (int i = 0; i < bootstrapMethodArguments.length; i++) {\r\n                        bootstrapMethodArguments[i] = readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);\r\n                        bootstrapMethodOffset += 2;\r\n                    }\r\n                    methodVisitor.visitInvokeDynamicInsn(name, descriptor, handle, bootstrapMethodArguments);\r\n                    currentOffset += 5;\r\n                    break;\r\n                }\r\n            case Opcodes.NEW:\r\n            case Opcodes.ANEWARRAY:\r\n            case Opcodes.CHECKCAST:\r\n            case Opcodes.INSTANCEOF:\r\n                methodVisitor.visitTypeInsn(opcode, readClass(currentOffset + 1, charBuffer));\r\n                currentOffset += 3;\r\n                break;\r\n            case Opcodes.IINC:\r\n                methodVisitor.visitIincInsn(classBuffer[currentOffset + 1] & 0xFF, classBuffer[currentOffset + 2]);\r\n                currentOffset += 3;\r\n                break;\r\n            case Opcodes.MULTIANEWARRAY:\r\n                methodVisitor.visitMultiANewArrayInsn(readClass(currentOffset + 1, charBuffer), classBuffer[currentOffset + 3] & 0xFF);\r\n                currentOffset += 4;\r\n                break;\r\n            default:\r\n                throw new AssertionError();\r\n        }\r\n        // Visit the runtime visible instruction annotations, if any.\r\n        while (visibleTypeAnnotationOffsets != null && currentVisibleTypeAnnotationIndex < visibleTypeAnnotationOffsets.length && currentVisibleTypeAnnotationBytecodeOffset <= currentBytecodeOffset) {\r\n            if (currentVisibleTypeAnnotationBytecodeOffset == currentBytecodeOffset) {\r\n                // Parse the target_type, target_info and target_path fields.\r\n                int currentAnnotationOffset = readTypeAnnotationTarget(context, visibleTypeAnnotationOffsets[currentVisibleTypeAnnotationIndex]);\r\n                // Parse the type_index field.\r\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n                currentAnnotationOffset += 2;\r\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n                readElementValues(methodVisitor.visitInsnAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor, /* visible= */\r\n                true), currentAnnotationOffset, /* named= */\r\n                true, charBuffer);\r\n            }\r\n            currentVisibleTypeAnnotationBytecodeOffset = getTypeAnnotationBytecodeOffset(visibleTypeAnnotationOffsets, ++currentVisibleTypeAnnotationIndex);\r\n        }\r\n        // Visit the runtime invisible instruction annotations, if any.\r\n        while (invisibleTypeAnnotationOffsets != null && currentInvisibleTypeAnnotationIndex < invisibleTypeAnnotationOffsets.length && currentInvisibleTypeAnnotationBytecodeOffset <= currentBytecodeOffset) {\r\n            if (currentInvisibleTypeAnnotationBytecodeOffset == currentBytecodeOffset) {\r\n                // Parse the target_type, target_info and target_path fields.\r\n                int currentAnnotationOffset = readTypeAnnotationTarget(context, invisibleTypeAnnotationOffsets[currentInvisibleTypeAnnotationIndex]);\r\n                // Parse the type_index field.\r\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n                currentAnnotationOffset += 2;\r\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n                readElementValues(methodVisitor.visitInsnAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor, /* visible= */\r\n                false), currentAnnotationOffset, /* named= */\r\n                true, charBuffer);\r\n            }\r\n            currentInvisibleTypeAnnotationBytecodeOffset = getTypeAnnotationBytecodeOffset(invisibleTypeAnnotationOffsets, ++currentInvisibleTypeAnnotationIndex);\r\n        }\r\n    }\r\n    if (labels[codeLength] != null) {\r\n        methodVisitor.visitLabel(labels[codeLength]);\r\n    }\r\n    // Visit LocalVariableTable and LocalVariableTypeTable attributes.\r\n    if (localVariableTableOffset != 0 && (context.parsingOptions & SKIP_DEBUG) == 0) {\r\n        // The (start_pc, index, signature_index) fields of each entry of the LocalVariableTypeTable.\r\n        int[] typeTable = null;\r\n        if (localVariableTypeTableOffset != 0) {\r\n            typeTable = new int[readUnsignedShort(localVariableTypeTableOffset) * 3];\r\n            currentOffset = localVariableTypeTableOffset + 2;\r\n            int typeTableIndex = typeTable.length;\r\n            while (typeTableIndex > 0) {\r\n                // Store the offset of 'signature_index', and the value of 'index' and 'start_pc'.\r\n                typeTable[--typeTableIndex] = currentOffset + 6;\r\n                typeTable[--typeTableIndex] = readUnsignedShort(currentOffset + 8);\r\n                typeTable[--typeTableIndex] = readUnsignedShort(currentOffset);\r\n                currentOffset += 10;\r\n            }\r\n        }\r\n        int localVariableTableLength = readUnsignedShort(localVariableTableOffset);\r\n        currentOffset = localVariableTableOffset + 2;\r\n        while (localVariableTableLength-- > 0) {\r\n            int startPc = readUnsignedShort(currentOffset);\r\n            int length = readUnsignedShort(currentOffset + 2);\r\n            String name = readUTF8(currentOffset + 4, charBuffer);\r\n            String descriptor = readUTF8(currentOffset + 6, charBuffer);\r\n            int index = readUnsignedShort(currentOffset + 8);\r\n            currentOffset += 10;\r\n            String signature = null;\r\n            if (typeTable != null) {\r\n                for (int i = 0; i < typeTable.length; i += 3) {\r\n                    if (typeTable[i] == startPc && typeTable[i + 1] == index) {\r\n                        signature = readUTF8(typeTable[i + 2], charBuffer);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            methodVisitor.visitLocalVariable(name, descriptor, signature, labels[startPc], labels[startPc + length], index);\r\n        }\r\n    }\r\n    // Visit the local variable type annotations of the RuntimeVisibleTypeAnnotations attribute.\r\n    if (visibleTypeAnnotationOffsets != null) {\r\n        for (int typeAnnotationOffset : visibleTypeAnnotationOffsets) {\r\n            int targetType = readByte(typeAnnotationOffset);\r\n            if (targetType == TypeReference.LOCAL_VARIABLE || targetType == TypeReference.RESOURCE_VARIABLE) {\r\n                // Parse the target_type, target_info and target_path fields.\r\n                currentOffset = readTypeAnnotationTarget(context, typeAnnotationOffset);\r\n                // Parse the type_index field.\r\n                String annotationDescriptor = readUTF8(currentOffset, charBuffer);\r\n                currentOffset += 2;\r\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n                readElementValues(methodVisitor.visitLocalVariableAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, context.currentLocalVariableAnnotationRangeStarts, context.currentLocalVariableAnnotationRangeEnds, context.currentLocalVariableAnnotationRangeIndices, annotationDescriptor, /* visible= */\r\n                true), currentOffset, /* named= */\r\n                true, charBuffer);\r\n            }\r\n        }\r\n    }\r\n    // Visit the local variable type annotations of the RuntimeInvisibleTypeAnnotations attribute.\r\n    if (invisibleTypeAnnotationOffsets != null) {\r\n        for (int typeAnnotationOffset : invisibleTypeAnnotationOffsets) {\r\n            int targetType = readByte(typeAnnotationOffset);\r\n            if (targetType == TypeReference.LOCAL_VARIABLE || targetType == TypeReference.RESOURCE_VARIABLE) {\r\n                // Parse the target_type, target_info and target_path fields.\r\n                currentOffset = readTypeAnnotationTarget(context, typeAnnotationOffset);\r\n                // Parse the type_index field.\r\n                String annotationDescriptor = readUTF8(currentOffset, charBuffer);\r\n                currentOffset += 2;\r\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n                readElementValues(methodVisitor.visitLocalVariableAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, context.currentLocalVariableAnnotationRangeStarts, context.currentLocalVariableAnnotationRangeEnds, context.currentLocalVariableAnnotationRangeIndices, annotationDescriptor, /* visible= */\r\n                false), currentOffset, /* named= */\r\n                true, charBuffer);\r\n            }\r\n        }\r\n    }\r\n    // Visit the non standard attributes.\r\n    while (attributes != null) {\r\n        // Copy and reset the nextAttribute field so that it can also be used in MethodWriter.\r\n        Attribute nextAttribute = attributes.nextAttribute;\r\n        attributes.nextAttribute = null;\r\n        methodVisitor.visitAttribute(attributes);\r\n        attributes = nextAttribute;\r\n    }\r\n    // Visit the max stack and max locals values.\r\n    methodVisitor.visitMaxs(maxStack, maxLocals);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ClassReader#readCode(MethodVisitor,Context,int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ClassReader#readBytecodeInstructionOffset(int)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Handles the bytecode offset of the next instruction to be visited in {@link\r\n * #accept(ClassVisitor,int)}. This method is called just before the instruction and before its\r\n * associated label and stack map frame, if any. The default implementation of this method does\r\n * nothing. Subclasses can override this method to store the argument in a mutable field, for\r\n * instance, so that {@link MethodVisitor} instances can get the bytecode offset of each visited\r\n * instruction (if so, the usual concurrency issues related to mutable data should be addressed).\r\n *\r\n * @param bytecodeOffset the bytecode offset of the next instruction to be visited.\r\n */\r\nprotected void readBytecodeInstructionOffset(final int bytecodeOffset) {\r\n    // Do nothing by default.\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ClassReader#readBytecodeInstructionOffset(int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ClassReader#readLabel(int,Label[])",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Returns the label corresponding to the given bytecode offset. The default implementation of\r\n * this method creates a label for the given offset if it has not been already created.\r\n *\r\n * @param bytecodeOffset a bytecode offset in a method.\r\n * @param labels the already created labels, indexed by their offset. If a label already exists\r\n *     for bytecodeOffset this method must not create a new one. Otherwise it must store the new\r\n *     label in this array.\r\n * @return a non null Label, which must be equal to labels[bytecodeOffset].\r\n */\r\nprotected Label readLabel(final int bytecodeOffset, final Label[] labels) {\r\n    // SPRING PATCH: leniently handle offset mismatch\r\n    if (bytecodeOffset >= labels.length) {\r\n        return new Label();\r\n    }\r\n    // END OF PATCH\r\n    if (labels[bytecodeOffset] == null) {\r\n        labels[bytecodeOffset] = new Label();\r\n    }\r\n    return labels[bytecodeOffset];\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ClassReader#readLabel(int,Label[])",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ClassReader#createLabel(int,Label[])",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Creates a label without the {@link Label#FLAG_DEBUG_ONLY} flag set, for the given bytecode\r\n * offset. The label is created with a call to {@link #readLabel} and its {@link\r\n * Label#FLAG_DEBUG_ONLY} flag is cleared.\r\n *\r\n * @param bytecodeOffset a bytecode offset in a method.\r\n * @param labels the already created labels, indexed by their offset.\r\n * @return a Label without the {@link Label#FLAG_DEBUG_ONLY} flag set.\r\n */\r\nprivate Label createLabel(final int bytecodeOffset, final Label[] labels) {\r\n    Label label = readLabel(bytecodeOffset, labels);\r\n    label.flags &= ~Label.FLAG_DEBUG_ONLY;\r\n    return label;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ClassReader#createLabel(int,Label[])",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ClassReader#createDebugLabel(int,Label[])",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Creates a label with the {@link Label#FLAG_DEBUG_ONLY} flag set, if there is no already\r\n * existing label for the given bytecode offset (otherwise does nothing). The label is created\r\n * with a call to {@link #readLabel}.\r\n *\r\n * @param bytecodeOffset a bytecode offset in a method.\r\n * @param labels the already created labels, indexed by their offset.\r\n */\r\nprivate void createDebugLabel(final int bytecodeOffset, final Label[] labels) {\r\n    if (labels[bytecodeOffset] == null) {\r\n        readLabel(bytecodeOffset, labels).flags |= Label.FLAG_DEBUG_ONLY;\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ClassReader#createDebugLabel(int,Label[])",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ClassReader#readTypeAnnotations(MethodVisitor,Context,int,boolean)",
    "headType": "method",
    "relation": "provide",
    "tail": "// ----------------------------------------------------------------------------------------------\r\n// Methods to parse annotations, type annotations and parameter annotations\r\n// ----------------------------------------------------------------------------------------------\r\n/**\r\n * Parses a Runtime[In]VisibleTypeAnnotations attribute to find the offset of each type_annotation\r\n * entry it contains, to find the corresponding labels, and to visit the try catch block\r\n * annotations.\r\n *\r\n * @param methodVisitor the method visitor to be used to visit the try catch block annotations.\r\n * @param context information about the class being parsed.\r\n * @param runtimeTypeAnnotationsOffset the start offset of a Runtime[In]VisibleTypeAnnotations\r\n *     attribute, excluding the attribute_info's attribute_name_index and attribute_length fields.\r\n * @param visible true if the attribute to parse is a RuntimeVisibleTypeAnnotations attribute,\r\n *     false it is a RuntimeInvisibleTypeAnnotations attribute.\r\n * @return the start offset of each entry of the Runtime[In]VisibleTypeAnnotations_attribute's\r\n *     'annotations' array field.\r\n */\r\nprivate int[] readTypeAnnotations(final MethodVisitor methodVisitor, final Context context, final int runtimeTypeAnnotationsOffset, final boolean visible) {\r\n    char[] charBuffer = context.charBuffer;\r\n    int currentOffset = runtimeTypeAnnotationsOffset;\r\n    // Read the num_annotations field and create an array to store the type_annotation offsets.\r\n    int[] typeAnnotationsOffsets = new int[readUnsignedShort(currentOffset)];\r\n    currentOffset += 2;\r\n    // Parse the 'annotations' array field.\r\n    for (int i = 0; i < typeAnnotationsOffsets.length; ++i) {\r\n        typeAnnotationsOffsets[i] = currentOffset;\r\n        // Parse the type_annotation's target_type and the target_info fields. The size of the\r\n        // target_info field depends on the value of target_type.\r\n        int targetType = readInt(currentOffset);\r\n        switch(targetType >>> 24) {\r\n            case TypeReference.LOCAL_VARIABLE:\r\n            case TypeReference.RESOURCE_VARIABLE:\r\n                // A localvar_target has a variable size, which depends on the value of their table_length\r\n                // field. It also references bytecode offsets, for which we need labels.\r\n                int tableLength = readUnsignedShort(currentOffset + 1);\r\n                currentOffset += 3;\r\n                while (tableLength-- > 0) {\r\n                    int startPc = readUnsignedShort(currentOffset);\r\n                    int length = readUnsignedShort(currentOffset + 2);\r\n                    // Skip the index field (2 bytes).\r\n                    currentOffset += 6;\r\n                    createLabel(startPc, context.currentMethodLabels);\r\n                    createLabel(startPc + length, context.currentMethodLabels);\r\n                }\r\n                break;\r\n            case TypeReference.CAST:\r\n            case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:\r\n            case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:\r\n            case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:\r\n            case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:\r\n                currentOffset += 4;\r\n                break;\r\n            case TypeReference.CLASS_EXTENDS:\r\n            case TypeReference.CLASS_TYPE_PARAMETER_BOUND:\r\n            case TypeReference.METHOD_TYPE_PARAMETER_BOUND:\r\n            case TypeReference.THROWS:\r\n            case TypeReference.EXCEPTION_PARAMETER:\r\n            case TypeReference.INSTANCEOF:\r\n            case TypeReference.NEW:\r\n            case TypeReference.CONSTRUCTOR_REFERENCE:\r\n            case TypeReference.METHOD_REFERENCE:\r\n                currentOffset += 3;\r\n                break;\r\n            case TypeReference.CLASS_TYPE_PARAMETER:\r\n            case TypeReference.METHOD_TYPE_PARAMETER:\r\n            case TypeReference.METHOD_FORMAL_PARAMETER:\r\n            case TypeReference.FIELD:\r\n            case TypeReference.METHOD_RETURN:\r\n            case TypeReference.METHOD_RECEIVER:\r\n            default:\r\n                // TypeReference type which can't be used in Code attribute, or which is unknown.\r\n                throw new IllegalArgumentException();\r\n        }\r\n        // Parse the rest of the type_annotation structure, starting with the target_path structure\r\n        // (whose size depends on its path_length field).\r\n        int pathLength = readByte(currentOffset);\r\n        if ((targetType >>> 24) == TypeReference.EXCEPTION_PARAMETER) {\r\n            // Parse the target_path structure and create a corresponding TypePath.\r\n            TypePath path = pathLength == 0 ? null : new TypePath(classFileBuffer, currentOffset);\r\n            currentOffset += 1 + 2 * pathLength;\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentOffset, charBuffer);\r\n            currentOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentOffset = readElementValues(methodVisitor.visitTryCatchAnnotation(targetType & 0xFFFFFF00, path, annotationDescriptor, visible), currentOffset, /* named= */\r\n            true, charBuffer);\r\n        } else {\r\n            // We don't want to visit the other target_type annotations, so we just skip them (which\r\n            // requires some parsing because the element_value_pairs array has a variable size). First,\r\n            // skip the target_path structure:\r\n            currentOffset += 3 + 2 * pathLength;\r\n            // Then skip the num_element_value_pairs and element_value_pairs fields (by reading them\r\n            // with a null AnnotationVisitor).\r\n            currentOffset = readElementValues(/* annotationVisitor= */\r\n            null, currentOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    return typeAnnotationsOffsets;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ClassReader#readTypeAnnotations(MethodVisitor,Context,int,boolean)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ClassReader#getTypeAnnotationBytecodeOffset(int[],int)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Returns the bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or\r\n * -1 if there is no such type_annotation of if it does not have a bytecode offset.\r\n *\r\n * @param typeAnnotationOffsets the offset of each 'type_annotation' entry in a\r\n *     Runtime[In]VisibleTypeAnnotations attribute, or {@literal null}.\r\n * @param typeAnnotationIndex the index a 'type_annotation' entry in typeAnnotationOffsets.\r\n * @return bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or -1\r\n *     if there is no such type_annotation of if it does not have a bytecode offset.\r\n */\r\nprivate int getTypeAnnotationBytecodeOffset(final int[] typeAnnotationOffsets, final int typeAnnotationIndex) {\r\n    if (typeAnnotationOffsets == null || typeAnnotationIndex >= typeAnnotationOffsets.length || readByte(typeAnnotationOffsets[typeAnnotationIndex]) < TypeReference.INSTANCEOF) {\r\n        return -1;\r\n    }\r\n    return readUnsignedShort(typeAnnotationOffsets[typeAnnotationIndex] + 1);\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ClassReader#getTypeAnnotationBytecodeOffset(int[],int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ClassReader#readTypeAnnotationTarget(Context,int)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Parses the header of a JVMS type_annotation structure to extract its target_type, target_info\r\n * and target_path (the result is stored in the given context), and returns the start offset of\r\n * the rest of the type_annotation structure.\r\n *\r\n * @param context information about the class being parsed. This is where the extracted\r\n *     target_type and target_path must be stored.\r\n * @param typeAnnotationOffset the start offset of a type_annotation structure.\r\n * @return the start offset of the rest of the type_annotation structure.\r\n */\r\nprivate int readTypeAnnotationTarget(final Context context, final int typeAnnotationOffset) {\r\n    int currentOffset = typeAnnotationOffset;\r\n    // Parse and store the target_type structure.\r\n    int targetType = readInt(typeAnnotationOffset);\r\n    switch(targetType >>> 24) {\r\n        case TypeReference.CLASS_TYPE_PARAMETER:\r\n        case TypeReference.METHOD_TYPE_PARAMETER:\r\n        case TypeReference.METHOD_FORMAL_PARAMETER:\r\n            targetType &= 0xFFFF0000;\r\n            currentOffset += 2;\r\n            break;\r\n        case TypeReference.FIELD:\r\n        case TypeReference.METHOD_RETURN:\r\n        case TypeReference.METHOD_RECEIVER:\r\n            targetType &= 0xFF000000;\r\n            currentOffset += 1;\r\n            break;\r\n        case TypeReference.LOCAL_VARIABLE:\r\n        case TypeReference.RESOURCE_VARIABLE:\r\n            targetType &= 0xFF000000;\r\n            int tableLength = readUnsignedShort(currentOffset + 1);\r\n            currentOffset += 3;\r\n            context.currentLocalVariableAnnotationRangeStarts = new Label[tableLength];\r\n            context.currentLocalVariableAnnotationRangeEnds = new Label[tableLength];\r\n            context.currentLocalVariableAnnotationRangeIndices = new int[tableLength];\r\n            for (int i = 0; i < tableLength; ++i) {\r\n                int startPc = readUnsignedShort(currentOffset);\r\n                int length = readUnsignedShort(currentOffset + 2);\r\n                int index = readUnsignedShort(currentOffset + 4);\r\n                currentOffset += 6;\r\n                context.currentLocalVariableAnnotationRangeStarts[i] = createLabel(startPc, context.currentMethodLabels);\r\n                context.currentLocalVariableAnnotationRangeEnds[i] = createLabel(startPc + length, context.currentMethodLabels);\r\n                context.currentLocalVariableAnnotationRangeIndices[i] = index;\r\n            }\r\n            break;\r\n        case TypeReference.CAST:\r\n        case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:\r\n        case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:\r\n        case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:\r\n        case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:\r\n            targetType &= 0xFF0000FF;\r\n            currentOffset += 4;\r\n            break;\r\n        case TypeReference.CLASS_EXTENDS:\r\n        case TypeReference.CLASS_TYPE_PARAMETER_BOUND:\r\n        case TypeReference.METHOD_TYPE_PARAMETER_BOUND:\r\n        case TypeReference.THROWS:\r\n        case TypeReference.EXCEPTION_PARAMETER:\r\n            targetType &= 0xFFFFFF00;\r\n            currentOffset += 3;\r\n            break;\r\n        case TypeReference.INSTANCEOF:\r\n        case TypeReference.NEW:\r\n        case TypeReference.CONSTRUCTOR_REFERENCE:\r\n        case TypeReference.METHOD_REFERENCE:\r\n            targetType &= 0xFF000000;\r\n            currentOffset += 3;\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException();\r\n    }\r\n    context.currentTypeAnnotationTarget = targetType;\r\n    // Parse and store the target_path structure.\r\n    int pathLength = readByte(currentOffset);\r\n    context.currentTypeAnnotationTargetPath = pathLength == 0 ? null : new TypePath(classFileBuffer, currentOffset);\r\n    // Return the start offset of the rest of the type_annotation structure.\r\n    return currentOffset + 1 + 2 * pathLength;\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ClassReader#readTypeAnnotationTarget(Context,int)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.asm.ClassReader#readParameterAnnotations(MethodVisitor,Context,int,boolean)",
    "headType": "method",
    "relation": "provide",
    "tail": "/**\r\n * Reads a Runtime[In]VisibleParameterAnnotations attribute and makes the given visitor visit it.\r\n *\r\n * @param methodVisitor the visitor that must visit the parameter annotations.\r\n * @param context information about the class being parsed.\r\n * @param runtimeParameterAnnotationsOffset the start offset of a\r\n *     Runtime[In]VisibleParameterAnnotations attribute, excluding the attribute_info's\r\n *     attribute_name_index and attribute_length fields.\r\n * @param visible true if the attribute to parse is a RuntimeVisibleParameterAnnotations\r\n *     attribute, false it is a RuntimeInvisibleParameterAnnotations attribute.\r\n */\r\nprivate void readParameterAnnotations(final MethodVisitor methodVisitor, final Context context, final int runtimeParameterAnnotationsOffset, final boolean visible) {\r\n    int currentOffset = runtimeParameterAnnotationsOffset;\r\n    int numParameters = classFileBuffer[currentOffset++] & 0xFF;\r\n    methodVisitor.visitAnnotableParameterCount(numParameters, visible);\r\n    char[] charBuffer = context.charBuffer;\r\n    for (int i = 0; i < numParameters; ++i) {\r\n        int numAnnotations = readUnsignedShort(currentOffset);\r\n        currentOffset += 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentOffset, charBuffer);\r\n            currentOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentOffset = readElementValues(methodVisitor.visitParameterAnnotation(i, annotationDescriptor, visible), currentOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n}",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.asm.ClassReader",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.asm.ClassReader#readParameterAnnotations(MethodVisitor,Context,int,boolean)",
    "tailType": "method"
  }
]