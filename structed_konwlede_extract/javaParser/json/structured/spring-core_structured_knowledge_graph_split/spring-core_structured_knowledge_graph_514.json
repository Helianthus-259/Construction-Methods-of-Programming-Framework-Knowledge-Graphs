[
  {
    "head": "org.springframework.core.testfixture.net.TestSocketUtils",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.testfixture.net.TestSocketUtils#isPortAvailable(int)",
    "tailType": "method"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.testfixture.nullness",
    "tailType": "package"
  },
  {
    "head": "org.springframework.core.testfixture.nullness",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.core.testfixture.nullness.ClassMarkedJSpecifyProcessor",
    "tailType": "class"
  },
  {
    "head": "org.springframework.core.testfixture.nullness.ClassMarkedJSpecifyProcessor",
    "headType": "class",
    "relation": "use",
    "tail": "@NullMarked",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.testfixture.nullness.ClassMarkedJSpecifyProcessor",
    "headType": "class",
    "relation": "provide",
    "tail": "/*\n * Copyright 2002-2025 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.testfixture.nullness;\n\nimport org.jspecify.annotations.NonNull;\nimport org.jspecify.annotations.NullMarked;\nimport org.jspecify.annotations.NullUnmarked;\nimport org.jspecify.annotations.Nullable;\n\n@NullMarked\npublic interface ClassMarkedJSpecifyProcessor {\n\n\tString process(String unspecified, @Nullable String nullable, @NonNull String nonNull);\n\n\t@Nullable String nullableProcess();\n\n\t@NonNull String nonNullProcess();\n\n\t@NullUnmarked\n\tString unmarkedProcess(String unspecified, @Nullable String nullable, @NonNull String nonNull);\n\n}\n",
    "tailType": "class_code"
  },
  {
    "head": "org.springframework.core.testfixture.nullness.ClassMarkedJSpecifyProcessor#process(String,String,String)",
    "headType": "method",
    "relation": "provide",
    "tail": "String process(String unspecified, @Nullable String nullable, @NonNull String nonNull);",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.testfixture.nullness.ClassMarkedJSpecifyProcessor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.testfixture.nullness.ClassMarkedJSpecifyProcessor#process(String,String,String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.testfixture.nullness.ClassMarkedJSpecifyProcessor#nullableProcess()",
    "headType": "method",
    "relation": "provide",
    "tail": "@Nullable\r\nString nullableProcess();",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.testfixture.nullness.ClassMarkedJSpecifyProcessor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.testfixture.nullness.ClassMarkedJSpecifyProcessor#nullableProcess()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.testfixture.nullness.ClassMarkedJSpecifyProcessor#nullableProcess()",
    "headType": "method",
    "relation": "use",
    "tail": "@Nullable",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.testfixture.nullness.ClassMarkedJSpecifyProcessor#nonNullProcess()",
    "headType": "method",
    "relation": "provide",
    "tail": "@NonNull\r\nString nonNullProcess();",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.testfixture.nullness.ClassMarkedJSpecifyProcessor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.testfixture.nullness.ClassMarkedJSpecifyProcessor#nonNullProcess()",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.testfixture.nullness.ClassMarkedJSpecifyProcessor#nonNullProcess()",
    "headType": "method",
    "relation": "use",
    "tail": "@NonNull",
    "tailType": "annotation"
  },
  {
    "head": "org.springframework.core.testfixture.nullness.ClassMarkedJSpecifyProcessor#unmarkedProcess(String,String,String)",
    "headType": "method",
    "relation": "provide",
    "tail": "@NullUnmarked\r\nString unmarkedProcess(String unspecified, @Nullable String nullable, @NonNull String nonNull);",
    "tailType": "method_code"
  },
  {
    "head": "org.springframework.core.testfixture.nullness.ClassMarkedJSpecifyProcessor",
    "headType": "class",
    "relation": "haveMethod",
    "tail": "org.springframework.core.testfixture.nullness.ClassMarkedJSpecifyProcessor#unmarkedProcess(String,String,String)",
    "tailType": "method"
  },
  {
    "head": "org.springframework.core.testfixture.nullness.ClassMarkedJSpecifyProcessor#unmarkedProcess(String,String,String)",
    "headType": "method",
    "relation": "use",
    "tail": "@NullUnmarked",
    "tailType": "annotation"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.asm",
    "tailType": "package"
  },
  {
    "head": "org.springframework.asm",
    "headType": "package",
    "relation": "haveClass",
    "tail": "org.springframework.asm.Type",
    "tailType": "class"
  },
  {
    "head": "spring-core",
    "headType": "module",
    "relation": "has",
    "tail": "org.springframework.core.testfixture.nullness.custom",
    "tailType": "package"
  },
  {
    "head": "org.springframework.asm.Type",
    "headType": "class",
    "relation": "provide",
    "tail": "// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage org.springframework.asm;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\n\n/**\n * A Java field or method type. This class can be used to make it easier to manipulate type and\n * method descriptors.\n *\n * @author Eric Bruneton\n * @author Chris Nokleberg\n */\npublic final class Type {\n\n  /** The sort of the {@code void} type. See {@link #getSort}. */\n  public static final int VOID = 0;\n\n  /** The sort of the {@code boolean} type. See {@link #getSort}. */\n  public static final int BOOLEAN = 1;\n\n  /** The sort of the {@code char} type. See {@link #getSort}. */\n  public static final int CHAR = 2;\n\n  /** The sort of the {@code byte} type. See {@link #getSort}. */\n  public static final int BYTE = 3;\n\n  /** The sort of the {@code short} type. See {@link #getSort}. */\n  public static final int SHORT = 4;\n\n  /** The sort of the {@code int} type. See {@link #getSort}. */\n  public static final int INT = 5;\n\n  /** The sort of the {@code float} type. See {@link #getSort}. */\n  public static final int FLOAT = 6;\n\n  /** The sort of the {@code long} type. See {@link #getSort}. */\n  public static final int LONG = 7;\n\n  /** The sort of the {@code double} type. See {@link #getSort}. */\n  public static final int DOUBLE = 8;\n\n  /** The sort of array reference types. See {@link #getSort}. */\n  public static final int ARRAY = 9;\n\n  /** The sort of object reference types. See {@link #getSort}. */\n  public static final int OBJECT = 10;\n\n  /** The sort of method types. See {@link #getSort}. */\n  public static final int METHOD = 11;\n\n  /** The (private) sort of object reference types represented with an internal name. */\n  private static final int INTERNAL = 12;\n\n  /** The descriptors of the primitive types. */\n  private static final String PRIMITIVE_DESCRIPTORS = \"VZCBSIFJD\";\n\n  /** The {@code void} type. */\n  public static final Type VOID_TYPE = new Type(VOID, PRIMITIVE_DESCRIPTORS, VOID, VOID + 1);\n\n  /** The {@code boolean} type. */\n  public static final Type BOOLEAN_TYPE =\n      new Type(BOOLEAN, PRIMITIVE_DESCRIPTORS, BOOLEAN, BOOLEAN + 1);\n\n  /** The {@code char} type. */\n  public static final Type CHAR_TYPE = new Type(CHAR, PRIMITIVE_DESCRIPTORS, CHAR, CHAR + 1);\n\n  /** The {@code byte} type. */\n  public static final Type BYTE_TYPE = new Type(BYTE, PRIMITIVE_DESCRIPTORS, BYTE, BYTE + 1);\n\n  /** The {@code short} type. */\n  public static final Type SHORT_TYPE = new Type(SHORT, PRIMITIVE_DESCRIPTORS, SHORT, SHORT + 1);\n\n  /** The {@code int} type. */\n  public static final Type INT_TYPE = new Type(INT, PRIMITIVE_DESCRIPTORS, INT, INT + 1);\n\n  /** The {@code float} type. */\n  public static final Type FLOAT_TYPE = new Type(FLOAT, PRIMITIVE_DESCRIPTORS, FLOAT, FLOAT + 1);\n\n  /** The {@code long} type. */\n  public static final Type LONG_TYPE = new Type(LONG, PRIMITIVE_DESCRIPTORS, LONG, LONG + 1);\n\n  /** The {@code double} type. */\n  public static final Type DOUBLE_TYPE =\n      new Type(DOUBLE, PRIMITIVE_DESCRIPTORS, DOUBLE, DOUBLE + 1);\n\n  // -----------------------------------------------------------------------------------------------\n  // Fields\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * The sort of this type. Either {@link #VOID}, {@link #BOOLEAN}, {@link #CHAR}, {@link #BYTE},\n   * {@link #SHORT}, {@link #INT}, {@link #FLOAT}, {@link #LONG}, {@link #DOUBLE}, {@link #ARRAY},\n   * {@link #OBJECT}, {@link #METHOD} or {@link #INTERNAL}.\n   */\n  private final int sort;\n\n  /**\n   * A buffer containing the value of this field or method type. This value is an internal name for\n   * {@link #OBJECT} and {@link #INTERNAL} types, and a field or method descriptor in the other\n   * cases.\n   *\n   * <p>For {@link #OBJECT} types, this field also contains the descriptor: the characters in\n   * [{@link #valueBegin},{@link #valueEnd}) contain the internal name, and those in [{@link\n   * #valueBegin} - 1, {@link #valueEnd} + 1) contain the descriptor.\n   */\n  private final String valueBuffer;\n\n  /**\n   * The beginning index, inclusive, of the value of this Java field or method type in {@link\n   * #valueBuffer}. This value is an internal name for {@link #OBJECT} and {@link #INTERNAL} types,\n   * and a field or method descriptor in the other cases.\n   */\n  private final int valueBegin;\n\n  /**\n   * The end index, exclusive, of the value of this Java field or method type in {@link\n   * #valueBuffer}. This value is an internal name for {@link #OBJECT} and {@link #INTERNAL} types,\n   * and a field or method descriptor in the other cases.\n   */\n  private final int valueEnd;\n\n  /**\n   * Constructs a reference type.\n   *\n   * @param sort the sort of this type, see {@link #sort}.\n   * @param valueBuffer a buffer containing the value of this field or method type.\n   * @param valueBegin the beginning index, inclusive, of the value of this field or method type in\n   *     valueBuffer.\n   * @param valueEnd the end index, exclusive, of the value of this field or method type in\n   *     valueBuffer.\n   */\n  private Type(final int sort, final String valueBuffer, final int valueBegin, final int valueEnd) {\n    this.sort = sort;\n    this.valueBuffer = valueBuffer;\n    this.valueBegin = valueBegin;\n    this.valueEnd = valueEnd;\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Methods to get Type(s) from a descriptor, a reflected Method or Constructor, other types, etc.\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Returns the {@link Type} corresponding to the given type descriptor.\n   *\n   * @param typeDescriptor a field or method type descriptor.\n   * @return the {@link Type} corresponding to the given type descriptor.\n   */\n  public static Type getType(final String typeDescriptor) {\n    return getTypeInternal(typeDescriptor, 0, typeDescriptor.length());\n  }\n\n  /**\n   * Returns the {@link Type} corresponding to the given class.\n   *\n   * @param clazz a class.\n   * @return the {@link Type} corresponding to the given class.\n   */\n  public static Type getType(final Class<?> clazz) {\n    if (clazz.isPrimitive()) {\n      if (clazz == Integer.TYPE) {\n        return INT_TYPE;\n      } else if (clazz == Void.TYPE) {\n        return VOID_TYPE;\n      } else if (clazz == Boolean.TYPE) {\n        return BOOLEAN_TYPE;\n      } else if (clazz == Byte.TYPE) {\n        return BYTE_TYPE;\n      } else if (clazz == Character.TYPE) {\n        return CHAR_TYPE;\n      } else if (clazz == Short.TYPE) {\n        return SHORT_TYPE;\n      } else if (clazz == Double.TYPE) {\n        return DOUBLE_TYPE;\n      } else if (clazz == Float.TYPE) {\n        return FLOAT_TYPE;\n      } else if (clazz == Long.TYPE) {\n        return LONG_TYPE;\n      } else {\n        throw new AssertionError();\n      }\n    } else {\n      return getType(getDescriptor(clazz));\n    }\n  }\n\n  /**\n   * Returns the method {@link Type} corresponding to the given constructor.\n   *\n   * @param constructor a {@link Constructor} object.\n   * @return the method {@link Type} corresponding to the given constructor.\n   */\n  public static Type getType(final Constructor<?> constructor) {\n    return getType(getConstructorDescriptor(constructor));\n  }\n\n  /**\n   * Returns the method {@link Type} corresponding to the given method.\n   *\n   * @param method a {@link Method} object.\n   * @return the method {@link Type} corresponding to the given method.\n   */\n  public static Type getType(final Method method) {\n    return getType(getMethodDescriptor(method));\n  }\n\n  /**\n   * Returns the type of the elements of this array type. This method should only be used for an\n   * array type.\n   *\n   * @return Returns the type of the elements of this array type.\n   */\n  public Type getElementType() {\n    final int numDimensions = getDimensions();\n    return getTypeInternal(valueBuffer, valueBegin + numDimensions, valueEnd);\n  }\n\n  /**\n   * Returns the {@link Type} corresponding to the given internal name.\n   *\n   * @param internalName an internal name (see {@link Type#getInternalName()}).\n   * @return the {@link Type} corresponding to the given internal name.\n   */\n  public static Type getObjectType(final String internalName) {\n    return new Type(\n        internalName.charAt(0) == '[' ? ARRAY : INTERNAL, internalName, 0, internalName.length());\n  }\n\n  /**\n   * Returns the {@link Type} corresponding to the given method descriptor. Equivalent to <code>\n   * Type.getType(methodDescriptor)</code>.\n   *\n   * @param methodDescriptor a method descriptor.\n   * @return the {@link Type} corresponding to the given method descriptor.\n   */\n  public static Type getMethodType(final String methodDescriptor) {\n    return new Type(METHOD, methodDescriptor, 0, methodDescriptor.length());\n  }\n\n  /**\n   * Returns the method {@link Type} corresponding to the given argument and return types.\n   *\n   * @param returnType the return type of the method.\n   * @param argumentTypes the argument types of the method.\n   * @return the method {@link Type} corresponding to the given argument and return types.\n   */\n  public static Type getMethodType(final Type returnType, final Type... argumentTypes) {\n    return getType(getMethodDescriptor(returnType, argumentTypes));\n  }\n\n  /**\n   * Returns the argument types of methods of this type. This method should only be used for method\n   * types.\n   *\n   * @return the argument types of methods of this type.\n   */\n  public Type[] getArgumentTypes() {\n    return getArgumentTypes(getDescriptor());\n  }\n\n  /**\n   * Returns the {@link Type} values corresponding to the argument types of the given method\n   * descriptor.\n   *\n   * @param methodDescriptor a method descriptor.\n   * @return the {@link Type} values corresponding to the argument types of the given method\n   *     descriptor.\n   */\n  public static Type[] getArgumentTypes(final String methodDescriptor) {\n    // First step: compute the number of argument types in methodDescriptor.\n    int numArgumentTypes = getArgumentCount(methodDescriptor);\n\n    // Second step: create a Type instance for each argument type.\n    Type[] argumentTypes = new Type[numArgumentTypes];\n    // Skip the first character, which is always a '('.\n    int currentOffset = 1;\n    // Parse and create the argument types, one at each loop iteration.\n    int currentArgumentTypeIndex = 0;\n    while (methodDescriptor.charAt(currentOffset) != ')') {\n      final int currentArgumentTypeOffset = currentOffset;\n      while (methodDescriptor.charAt(currentOffset) == '[') {\n        currentOffset++;\n      }\n      if (methodDescriptor.charAt(currentOffset++) == 'L') {\n        // Skip the argument descriptor content.\n        int semiColumnOffset = methodDescriptor.indexOf(';', currentOffset);\n        currentOffset = Math.max(currentOffset, semiColumnOffset + 1);\n      }\n      argumentTypes[currentArgumentTypeIndex++] =\n          getTypeInternal(methodDescriptor, currentArgumentTypeOffset, currentOffset);\n    }\n    return argumentTypes;\n  }\n\n  /**\n   * Returns the {@link Type} values corresponding to the argument types of the given method.\n   *\n   * @param method a method.\n   * @return the {@link Type} values corresponding to the argument types of the given method.\n   */\n  public static Type[] getArgumentTypes(final Method method) {\n    Class<?>[] classes = method.getParameterTypes();\n    Type[] types = new Type[classes.length];\n    for (int i = classes.length - 1; i >= 0; --i) {\n      types[i] = getType(classes[i]);\n    }\n    return types;\n  }\n\n  /**\n   * Returns the return type of methods of this type. This method should only be used for method\n   * types.\n   *\n   * @return the return type of methods of this type.\n   */\n  public Type getReturnType() {\n    return getReturnType(getDescriptor());\n  }\n\n  /**\n   * Returns the {@link Type} corresponding to the return type of the given method descriptor.\n   *\n   * @param methodDescriptor a method descriptor.\n   * @return the {@link Type} corresponding to the return type of the given method descriptor.\n   */\n  public static Type getReturnType(final String methodDescriptor) {\n    return getTypeInternal(\n        methodDescriptor, getReturnTypeOffset(methodDescriptor), methodDescriptor.length());\n  }\n\n  /**\n   * Returns the {@link Type} corresponding to the return type of the given method.\n   *\n   * @param method a method.\n   * @return the {@link Type} corresponding to the return type of the given method.\n   */\n  public static Type getReturnType(final Method method) {\n    return getType(method.getReturnType());\n  }\n\n  /**\n   * Returns the start index of the return type of the given method descriptor.\n   *\n   * @param methodDescriptor a method descriptor.\n   * @return the start index of the return type of the given method descriptor.\n   */\n  static int getReturnTypeOffset(final String methodDescriptor) {\n    // Skip the first character, which is always a '('.\n    int currentOffset = 1;\n    // Skip the argument types, one at a each loop iteration.\n    while (methodDescriptor.charAt(currentOffset) != ')') {\n      while (methodDescriptor.charAt(currentOffset) == '[') {\n        currentOffset++;\n      }\n      if (methodDescriptor.charAt(currentOffset++) == 'L') {\n        // Skip the argument descriptor content.\n        int semiColumnOffset = methodDescriptor.indexOf(';', currentOffset);\n        currentOffset = Math.max(currentOffset, semiColumnOffset + 1);\n      }\n    }\n    return currentOffset + 1;\n  }\n\n  /**\n   * Returns the {@link Type} corresponding to the given field or method descriptor.\n   *\n   * @param descriptorBuffer a buffer containing the field or method descriptor.\n   * @param descriptorBegin the beginning index, inclusive, of the field or method descriptor in\n   *     descriptorBuffer.\n   * @param descriptorEnd the end index, exclusive, of the field or method descriptor in\n   *     descriptorBuffer.\n   * @return the {@link Type} corresponding to the given type descriptor.\n   */\n  private static Type getTypeInternal(\n      final String descriptorBuffer, final int descriptorBegin, final int descriptorEnd) {\n    switch (descriptorBuffer.charAt(descriptorBegin)) {\n      case 'V':\n        return VOID_TYPE;\n      case 'Z':\n        return BOOLEAN_TYPE;\n      case 'C':\n        return CHAR_TYPE;\n      case 'B':\n        return BYTE_TYPE;\n      case 'S':\n        return SHORT_TYPE;\n      case 'I':\n        return INT_TYPE;\n      case 'F':\n        return FLOAT_TYPE;\n      case 'J':\n        return LONG_TYPE;\n      case 'D':\n        return DOUBLE_TYPE;\n      case '[':\n        return new Type(ARRAY, descriptorBuffer, descriptorBegin, descriptorEnd);\n      case 'L':\n        return new Type(OBJECT, descriptorBuffer, descriptorBegin + 1, descriptorEnd - 1);\n      case '(':\n        return new Type(METHOD, descriptorBuffer, descriptorBegin, descriptorEnd);\n      default:\n        throw new IllegalArgumentException(\"Invalid descriptor: \" + descriptorBuffer);\n    }\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Methods to get class names, internal names or descriptors.\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Returns the binary name of the class corresponding to this type. This method must not be used\n   * on method types.\n   *\n   * @return the binary name of the class corresponding to this type.\n   */\n  public String getClassName() {\n    switch (sort) {\n      case VOID:\n        return \"void\";\n      case BOOLEAN:\n        return \"boolean\";\n      case CHAR:\n        return \"char\";\n      case BYTE:\n        return \"byte\";\n      case SHORT:\n        return \"short\";\n      case INT:\n        return \"int\";\n      case FLOAT:\n        return \"float\";\n      case LONG:\n        return \"long\";\n      case DOUBLE:\n        return \"double\";\n      case ARRAY:\n        StringBuilder stringBuilder = new StringBuilder(getElementType().getClassName());\n        for (int i = getDimensions(); i > 0; --i) {\n          stringBuilder.append(\"[]\");\n        }\n        return stringBuilder.toString();\n      case OBJECT:\n      case INTERNAL:\n        return valueBuffer.substring(valueBegin, valueEnd).replace('/', '.');\n      default:\n        throw new AssertionError();\n    }\n  }\n\n  /**\n   * Returns the internal name of the class corresponding to this object or array type. The internal\n   * name of a class is its fully qualified name (as returned by Class.getName(), where '.' are\n   * replaced by '/'). This method should only be used for an object or array type.\n   *\n   * @return the internal name of the class corresponding to this object type.\n   */\n  public String getInternalName() {\n    return valueBuffer.substring(valueBegin, valueEnd);\n  }\n\n  /**\n   * Returns the internal name of the given class. The internal name of a class is its fully\n   * qualified name, as returned by Class.getName(), where '.' are replaced by '/'.\n   *\n   * @param clazz an object or array class.\n   * @return the internal name of the given class.\n   */\n  public static String getInternalName(final Class<?> clazz) {\n    return clazz.getName().replace('.', '/');\n  }\n\n  /**\n   * Returns the descriptor corresponding to this type.\n   *\n   * @return the descriptor corresponding to this type.\n   */\n  public String getDescriptor() {\n    if (sort == OBJECT) {\n      return valueBuffer.substring(valueBegin - 1, valueEnd + 1);\n    } else if (sort == INTERNAL) {\n      return 'L' + valueBuffer.substring(valueBegin, valueEnd) + ';';\n    } else {\n      return valueBuffer.substring(valueBegin, valueEnd);\n    }\n  }\n\n  /**\n   * Returns the descriptor corresponding to the given class.\n   *\n   * @param clazz an object class, a primitive class or an array class.\n   * @return the descriptor corresponding to the given class.\n   */\n  public static String getDescriptor(final Class<?> clazz) {\n    StringBuilder stringBuilder = new StringBuilder();\n    appendDescriptor(clazz, stringBuilder);\n    return stringBuilder.toString();\n  }\n\n  /**\n   * Returns the descriptor corresponding to the given constructor.\n   *\n   * @param constructor a {@link Constructor} object.\n   * @return the descriptor of the given constructor.\n   */\n  public static String getConstructorDescriptor(final Constructor<?> constructor) {\n    StringBuilder stringBuilder = new StringBuilder();\n    stringBuilder.append('(');\n    Class<?>[] parameters = constructor.getParameterTypes();\n    for (Class<?> parameter : parameters) {\n      appendDescriptor(parameter, stringBuilder);\n    }\n    return stringBuilder.append(\")V\").toString();\n  }\n\n  /**\n   * Returns the descriptor corresponding to the given argument and return types.\n   *\n   * @param returnType the return type of the method.\n   * @param argumentTypes the argument types of the method.\n   * @return the descriptor corresponding to the given argument and return types.\n   */\n  public static String getMethodDescriptor(final Type returnType, final Type... argumentTypes) {\n    StringBuilder stringBuilder = new StringBuilder();\n    stringBuilder.append('(');\n    for (Type argumentType : argumentTypes) {\n      argumentType.appendDescriptor(stringBuilder);\n    }\n    stringBuilder.append(')');\n    returnType.appendDescriptor(stringBuilder);\n    return stringBuilder.toString();\n  }\n\n  /**\n   * Returns the descriptor corresponding to the given method.\n   *\n   * @param method a {@link Method} object.\n   * @return the descriptor of the given method.\n   */\n  public static String getMethodDescriptor(final Method method) {\n    StringBuilder stringBuilder = new StringBuilder();\n    stringBuilder.append('(');\n    Class<?>[] parameters = method.getParameterTypes();\n    for (Class<?> parameter : parameters) {\n      appendDescriptor(parameter, stringBuilder);\n    }\n    stringBuilder.append(')');\n    appendDescriptor(method.getReturnType(), stringBuilder);\n    return stringBuilder.toString();\n  }\n\n  /**\n   * Appends the descriptor corresponding to this type to the given string buffer.\n   *\n   * @param stringBuilder the string builder to which the descriptor must be appended.\n   */\n  private void appendDescriptor(final StringBuilder stringBuilder) {\n    if (sort == OBJECT) {\n      stringBuilder.append(valueBuffer, valueBegin - 1, valueEnd + 1);\n    } else if (sort == INTERNAL) {\n      stringBuilder.append('L').append(valueBuffer, valueBegin, valueEnd).append(';');\n    } else {\n      stringBuilder.append(valueBuffer, valueBegin, valueEnd);\n    }\n  }\n\n  /**\n   * Appends the descriptor of the given class to the given string builder.\n   *\n   * @param clazz the class whose descriptor must be computed.\n   * @param stringBuilder the string builder to which the descriptor must be appended.\n   */\n  private static void appendDescriptor(final Class<?> clazz, final StringBuilder stringBuilder) {\n    Class<?> currentClass = clazz;\n    while (currentClass.isArray()) {\n      stringBuilder.append('[');\n      currentClass = currentClass.componentType();\n    }\n    if (currentClass.isPrimitive()) {\n      char descriptor;\n      if (currentClass == Integer.TYPE) {\n        descriptor = 'I';\n      } else if (currentClass == Void.TYPE) {\n        descriptor = 'V';\n      } else if (currentClass == Boolean.TYPE) {\n        descriptor = 'Z';\n      } else if (currentClass == Byte.TYPE) {\n        descriptor = 'B';\n      } else if (currentClass == Character.TYPE) {\n        descriptor = 'C';\n      } else if (currentClass == Short.TYPE) {\n        descriptor = 'S';\n      } else if (currentClass == Double.TYPE) {\n        descriptor = 'D';\n      } else if (currentClass == Float.TYPE) {\n        descriptor = 'F';\n      } else if (currentClass == Long.TYPE) {\n        descriptor = 'J';\n      } else {\n        throw new AssertionError();\n      }\n      stringBuilder.append(descriptor);\n    } else {\n      stringBuilder.append('L').append(getInternalName(currentClass)).append(';');\n    }\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Methods to get the sort, dimension, size, and opcodes corresponding to a Type or descriptor.\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Returns the sort of this type.\n   *\n   * @return {@link #VOID}, {@link #BOOLEAN}, {@link #CHAR}, {@link #BYTE}, {@link #SHORT}, {@link\n   *     #INT}, {@link #FLOAT}, {@link #LONG}, {@link #DOUBLE}, {@link #ARRAY}, {@link #OBJECT} or\n   *     {@link #METHOD}.\n   */\n  public int getSort() {\n    return sort == INTERNAL ? OBJECT : sort;\n  }\n\n  /**\n   * Returns the number of dimensions of this array type. This method should only be used for an\n   * array type.\n   *\n   * @return the number of dimensions of this array type.\n   */\n  public int getDimensions() {\n    int numDimensions = 1;\n    while (valueBuffer.charAt(valueBegin + numDimensions) == '[') {\n      numDimensions++;\n    }\n    return numDimensions;\n  }\n\n  /**\n   * Returns the size of values of this type. This method must not be used for method types.\n   *\n   * @return the size of values of this type, i.e., 2 for {@code long} and {@code double}, 0 for\n   *     {@code void} and 1 otherwise.\n   */\n  public int getSize() {\n    switch (sort) {\n      case VOID:\n        return 0;\n      case BOOLEAN:\n      case CHAR:\n      case BYTE:\n      case SHORT:\n      case INT:\n      case FLOAT:\n      case ARRAY:\n      case OBJECT:\n      case INTERNAL:\n        return 1;\n      case LONG:\n      case DOUBLE:\n        return 2;\n      default:\n        throw new AssertionError();\n    }\n  }\n\n  /**\n   * Returns the number of arguments of this method type. This method should only be used for method\n   * types.\n   *\n   * @return the number of arguments of this method type. Each argument counts for 1, even long and\n   *     double ones. The implicit @literal{this} argument is not counted.\n   */\n  public int getArgumentCount() {\n    return getArgumentCount(getDescriptor());\n  }\n\n  /**\n   * Returns the number of arguments in the given method descriptor.\n   *\n   * @param methodDescriptor a method descriptor.\n   * @return the number of arguments in the given method descriptor. Each argument counts for 1,\n   *     even long and double ones. The implicit @literal{this} argument is not counted.\n   */\n  public static int getArgumentCount(final String methodDescriptor) {\n    int argumentCount = 0;\n    // Skip the first character, which is always a '('.\n    int currentOffset = 1;\n    // Parse the argument types, one at a each loop iteration.\n    while (methodDescriptor.charAt(currentOffset) != ')') {\n      while (methodDescriptor.charAt(currentOffset) == '[') {\n        currentOffset++;\n      }\n      if (methodDescriptor.charAt(currentOffset++) == 'L') {\n        // Skip the argument descriptor content.\n        int semiColumnOffset = methodDescriptor.indexOf(';', currentOffset);\n        currentOffset = Math.max(currentOffset, semiColumnOffset + 1);\n      }\n      ++argumentCount;\n    }\n    return argumentCount;\n  }\n\n  /**\n   * Returns the size of the arguments and of the return value of methods of this type. This method\n   * should only be used for method types.\n   *\n   * @return the size of the arguments of the method (plus one for the implicit this argument),\n   *     argumentsSize, and the size of its return value, returnSize, packed into a single int i =\n   *     {@code (argumentsSize &lt;&lt; 2) | returnSize} (argumentsSize is therefore equal to {@code\n   *     i &gt;&gt; 2}, and returnSize to {@code i &amp; 0x03}). Long and double values have size 2,\n   *     the others have size 1.\n   */\n  public int getArgumentsAndReturnSizes() {\n    return getArgumentsAndReturnSizes(getDescriptor());\n  }\n\n  /**\n   * Computes the size of the arguments and of the return value of a method.\n   *\n   * @param methodDescriptor a method descriptor.\n   * @return the size of the arguments of the method (plus one for the implicit this argument),\n   *     argumentsSize, and the size of its return value, returnSize, packed into a single int i =\n   *     {@code (argumentsSize &lt;&lt; 2) | returnSize} (argumentsSize is therefore equal to {@code\n   *     i &gt;&gt; 2}, and returnSize to {@code i &amp; 0x03}). Long and double values have size 2,\n   *     the others have size 1.\n   */\n  public static int getArgumentsAndReturnSizes(final String methodDescriptor) {\n    int argumentsSize = 1;\n    // Skip the first character, which is always a '('.\n    int currentOffset = 1;\n    int currentChar = methodDescriptor.charAt(currentOffset);\n    // Parse the argument types and compute their size, one at a each loop iteration.\n    while (currentChar != ')') {\n      if (currentChar == 'J' || currentChar == 'D') {\n        currentOffset++;\n        argumentsSize += 2;\n      } else {\n        while (methodDescriptor.charAt(currentOffset) == '[') {\n          currentOffset++;\n        }\n        if (methodDescriptor.charAt(currentOffset++) == 'L') {\n          // Skip the argument descriptor content.\n          int semiColumnOffset = methodDescriptor.indexOf(';', currentOffset);\n          currentOffset = Math.max(currentOffset, semiColumnOffset + 1);\n        }\n        argumentsSize += 1;\n      }\n      currentChar = methodDescriptor.charAt(currentOffset);\n    }\n    currentChar = methodDescriptor.charAt(currentOffset + 1);\n    if (currentChar == 'V') {\n      return argumentsSize << 2;\n    } else {\n      int returnSize = (currentChar == 'J' || currentChar == 'D') ? 2 : 1;\n      return argumentsSize << 2 | returnSize;\n    }\n  }\n\n  /**\n   * Returns a JVM instruction opcode adapted to this {@link Type}. This method must not be used for\n   * method types.\n   *\n   * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD, ISTORE, IALOAD,\n   *     IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL, ISHR, IUSHR, IAND, IOR, IXOR and\n   *     IRETURN.\n   * @return an opcode that is similar to the given opcode, but adapted to this {@link Type}. For\n   *     example, if this type is {@code float} and {@code opcode} is IRETURN, this method returns\n   *     FRETURN.\n   */\n  public int getOpcode(final int opcode) {\n    if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {\n      switch (sort) {\n        case BOOLEAN:\n        case BYTE:\n          return opcode + (Opcodes.BALOAD - Opcodes.IALOAD);\n        case CHAR:\n          return opcode + (Opcodes.CALOAD - Opcodes.IALOAD);\n        case SHORT:\n          return opcode + (Opcodes.SALOAD - Opcodes.IALOAD);\n        case INT:\n          return opcode;\n        case FLOAT:\n          return opcode + (Opcodes.FALOAD - Opcodes.IALOAD);\n        case LONG:\n          return opcode + (Opcodes.LALOAD - Opcodes.IALOAD);\n        case DOUBLE:\n          return opcode + (Opcodes.DALOAD - Opcodes.IALOAD);\n        case ARRAY:\n        case OBJECT:\n        case INTERNAL:\n          return opcode + (Opcodes.AALOAD - Opcodes.IALOAD);\n        case METHOD:\n        case VOID:\n          throw new UnsupportedOperationException();\n        default:\n          throw new AssertionError();\n      }\n    } else {\n      switch (sort) {\n        case VOID:\n          if (opcode != Opcodes.IRETURN) {\n            throw new UnsupportedOperationException();\n          }\n          return Opcodes.RETURN;\n        case BOOLEAN:\n        case BYTE:\n        case CHAR:\n        case SHORT:\n        case INT:\n          return opcode;\n        case FLOAT:\n          return opcode + (Opcodes.FRETURN - Opcodes.IRETURN);\n        case LONG:\n          return opcode + (Opcodes.LRETURN - Opcodes.IRETURN);\n        case DOUBLE:\n          return opcode + (Opcodes.DRETURN - Opcodes.IRETURN);\n        case ARRAY:\n        case OBJECT:\n        case INTERNAL:\n          if (opcode != Opcodes.ILOAD && opcode != Opcodes.ISTORE && opcode != Opcodes.IRETURN) {\n            throw new UnsupportedOperationException();\n          }\n          return opcode + (Opcodes.ARETURN - Opcodes.IRETURN);\n        case METHOD:\n          throw new UnsupportedOperationException();\n        default:\n          throw new AssertionError();\n      }\n    }\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // Equals, hashCode and toString.\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * Tests if the given object is equal to this type.\n   *\n   * @param object the object to be compared to this type.\n   * @return {@literal true} if the given object is equal to this type.\n   */\n  @Override\n  public boolean equals(final Object object) {\n    if (this == object) {\n      return true;\n    }\n    if (!(object instanceof Type)) {\n      return false;\n    }\n    Type other = (Type) object;\n    if ((sort == INTERNAL ? OBJECT : sort) != (other.sort == INTERNAL ? OBJECT : other.sort)) {\n      return false;\n    }\n    int begin = valueBegin;\n    int end = valueEnd;\n    int otherBegin = other.valueBegin;\n    int otherEnd = other.valueEnd;\n    // Compare the values.\n    if (end - begin != otherEnd - otherBegin) {\n      return false;\n    }\n    for (int i = begin, j = otherBegin; i < end; i++, j++) {\n      if (valueBuffer.charAt(i) != other.valueBuffer.charAt(j)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns a hash code value for this type.\n   *\n   * @return a hash code value for this type.\n   */\n  @Override\n  public int hashCode() {\n    int hashCode = 13 * (sort == INTERNAL ? OBJECT : sort);\n    if (sort >= ARRAY) {\n      for (int i = valueBegin, end = valueEnd; i < end; i++) {\n        hashCode = 17 * (hashCode + valueBuffer.charAt(i));\n      }\n    }\n    return hashCode;\n  }\n\n  /**\n   * Returns a string representation of this type.\n   *\n   * @return the descriptor of this type.\n   */\n  @Override\n  public String toString() {\n    return getDescriptor();\n  }\n}\n",
    "tailType": "class_code"
  }
]