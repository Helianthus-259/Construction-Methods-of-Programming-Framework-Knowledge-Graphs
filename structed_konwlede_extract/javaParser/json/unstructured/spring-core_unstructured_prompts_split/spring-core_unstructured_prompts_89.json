[
  {
    "entityId": "org.springframework.util.xml.StaxEventXMLReader#handleEndDocument()",
    "entityType": "method",
    "code": "private void handleEndDocument() throws SAXException {\r\n    if (getContentHandler() != null) {\r\n        getContentHandler().endDocument();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxEventXMLReader#handleNotationDeclaration(NotationDeclaration)",
    "entityType": "method",
    "code": "private void handleNotationDeclaration(NotationDeclaration declaration) throws SAXException {\r\n    if (getDTDHandler() != null) {\r\n        getDTDHandler().notationDecl(declaration.getName(), declaration.getPublicId(), declaration.getSystemId());\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxEventXMLReader#handleEntityDeclaration(EntityDeclaration)",
    "entityType": "method",
    "code": "private void handleEntityDeclaration(EntityDeclaration entityDeclaration) throws SAXException {\r\n    if (getDTDHandler() != null) {\r\n        getDTDHandler().unparsedEntityDecl(entityDeclaration.getName(), entityDeclaration.getPublicId(), entityDeclaration.getSystemId(), entityDeclaration.getNotationName());\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxEventXMLReader#handleProcessingInstruction(ProcessingInstruction)",
    "entityType": "method",
    "code": "private void handleProcessingInstruction(ProcessingInstruction pi) throws SAXException {\r\n    if (getContentHandler() != null) {\r\n        getContentHandler().processingInstruction(pi.getTarget(), pi.getData());\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxEventXMLReader#handleComment(Comment)",
    "entityType": "method",
    "code": "private void handleComment(Comment comment) throws SAXException {\r\n    if (getLexicalHandler() != null) {\r\n        char[] ch = comment.getText().toCharArray();\r\n        getLexicalHandler().comment(ch, 0, ch.length);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxEventXMLReader#handleDtd(DTD)",
    "entityType": "method",
    "code": "private void handleDtd(DTD dtd) throws SAXException {\r\n    if (getLexicalHandler() != null) {\r\n        Location location = dtd.getLocation();\r\n        getLexicalHandler().startDTD(null, location.getPublicId(), location.getSystemId());\r\n    }\r\n    if (getLexicalHandler() != null) {\r\n        getLexicalHandler().endDTD();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxEventXMLReader#handleEntityReference(EntityReference)",
    "entityType": "method",
    "code": "private void handleEntityReference(EntityReference reference) throws SAXException {\r\n    if (getLexicalHandler() != null) {\r\n        getLexicalHandler().startEntity(reference.getName());\r\n    }\r\n    if (getLexicalHandler() != null) {\r\n        getLexicalHandler().endEntity(reference.getName());\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxEventXMLReader#getAttributes(StartElement)",
    "entityType": "method",
    "code": "private Attributes getAttributes(StartElement event) {\r\n    AttributesImpl attributes = new AttributesImpl();\r\n    for (Iterator i = event.getAttributes(); i.hasNext(); ) {\r\n        Attribute attribute = (Attribute) i.next();\r\n        QName qName = attribute.getName();\r\n        String namespace = qName.getNamespaceURI();\r\n        if (namespace == null || !hasNamespacesFeature()) {\r\n            namespace = \"\";\r\n        }\r\n        String type = attribute.getDTDType();\r\n        if (type == null) {\r\n            type = \"CDATA\";\r\n        }\r\n        attributes.addAttribute(namespace, qName.getLocalPart(), toQualifiedName(qName), type, attribute.getValue());\r\n    }\r\n    if (hasNamespacePrefixesFeature()) {\r\n        for (Iterator i = event.getNamespaces(); i.hasNext(); ) {\r\n            Namespace namespace = (Namespace) i.next();\r\n            String prefix = namespace.getPrefix();\r\n            String namespaceUri = namespace.getNamespaceURI();\r\n            String qName;\r\n            if (StringUtils.hasLength(prefix)) {\r\n                qName = \"xmlns:\" + prefix;\r\n            } else {\r\n                qName = \"xmlns\";\r\n            }\r\n            attributes.addAttribute(\"\", \"\", qName, \"CDATA\", namespaceUri);\r\n        }\r\n    }\r\n    return attributes;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxResult",
    "entityType": "class",
    "code": "@Nullable\r\nprivate XMLEventWriter eventWriter;\n@Nullable\r\nprivate XMLStreamWriter streamWriter;\n/**\r\n * Construct a new instance of the {@code StaxResult} with the specified {@code XMLEventWriter}.\r\n * @param eventWriter the {@code XMLEventWriter} to write to\r\n */\r\npublic StaxResult(XMLEventWriter eventWriter) {\r\n    StaxEventHandler handler = new StaxEventHandler(eventWriter);\r\n    super.setHandler(handler);\r\n    super.setLexicalHandler(handler);\r\n    this.eventWriter = eventWriter;\r\n}\n/**\r\n * Construct a new instance of the {@code StaxResult} with the specified {@code XMLStreamWriter}.\r\n * @param streamWriter the {@code XMLStreamWriter} to write to\r\n */\r\npublic StaxResult(XMLStreamWriter streamWriter) {\r\n    StaxStreamHandler handler = new StaxStreamHandler(streamWriter);\r\n    super.setHandler(handler);\r\n    super.setLexicalHandler(handler);\r\n    this.streamWriter = streamWriter;\r\n}\n/**\r\n * Return the {@code XMLEventWriter} used by this {@code StaxResult}.\r\n * <p>If this {@code StaxResult} was created with an {@code XMLStreamWriter},\r\n * the result will be {@code null}.\r\n * @return the StAX event writer used by this result\r\n * @see #StaxResult(javax.xml.stream.XMLEventWriter)\r\n */\r\n@Nullable\r\npublic XMLEventWriter getXMLEventWriter() {\r\n    return this.eventWriter;\r\n}\n/**\r\n * Return the {@code XMLStreamWriter} used by this {@code StaxResult}.\r\n * <p>If this {@code StaxResult} was created with an {@code XMLEventConsumer},\r\n * the result will be {@code null}.\r\n * @return the StAX stream writer used by this result\r\n * @see #StaxResult(javax.xml.stream.XMLStreamWriter)\r\n */\r\n@Nullable\r\npublic XMLStreamWriter getXMLStreamWriter() {\r\n    return this.streamWriter;\r\n}\n/**\r\n * Throws an {@code UnsupportedOperationException}.\r\n * @throws UnsupportedOperationException always\r\n */\r\n@Override\r\npublic void setHandler(ContentHandler handler) {\r\n    throw new UnsupportedOperationException(\"setHandler is not supported\");\r\n}\n/**\r\n * Throws an {@code UnsupportedOperationException}.\r\n * @throws UnsupportedOperationException always\r\n */\r\n@Override\r\npublic void setLexicalHandler(LexicalHandler handler) {\r\n    throw new UnsupportedOperationException(\"setLexicalHandler is not supported\");\r\n}",
    "comment": "\n * Implementation of the {@code Result} tagging interface for StAX writers. Can be constructed with\n * an {@code XMLEventConsumer} or an {@code XMLStreamWriter}.\n *\n * <p>This class is necessary because there is no implementation of {@code Source} for StaxReaders\n * in JAXP 1.3. There is a {@code StAXResult} in JAXP 1.4 (JDK 1.6), but this class is kept around\n * for backwards compatibility reasons.\n *\n * <p>Even though {@code StaxResult} extends from {@code SAXResult}, calling the methods of\n * {@code SAXResult} is <strong>not supported</strong>. In general, the only supported operation\n * on this class is to use the {@code ContentHandler} obtained via {@link #getHandler()} to parse an\n * input source using an {@code XMLReader}. Calling {@link #setHandler(org.xml.sax.ContentHandler)}\n * or {@link #setLexicalHandler(org.xml.sax.ext.LexicalHandler)} will result in\n * {@code UnsupportedOperationException}s.\n *\n * @author Arjen Poutsma\n * @since 3.0\n * @see XMLEventWriter\n * @see XMLStreamWriter\n * @see javax.xml.transform.Transformer\n "
  },
  {
    "entityId": "org.springframework.util.xml.StaxResult#getXMLEventWriter()",
    "entityType": "method",
    "code": "/**\r\n * Return the {@code XMLEventWriter} used by this {@code StaxResult}.\r\n * <p>If this {@code StaxResult} was created with an {@code XMLStreamWriter},\r\n * the result will be {@code null}.\r\n * @return the StAX event writer used by this result\r\n * @see #StaxResult(javax.xml.stream.XMLEventWriter)\r\n */\r\n@Nullable\r\npublic XMLEventWriter getXMLEventWriter() {\r\n    return this.eventWriter;\r\n}",
    "comment": "\n\t * Return the {@code XMLEventWriter} used by this {@code StaxResult}.\n\t * <p>If this {@code StaxResult} was created with an {@code XMLStreamWriter},\n\t * the result will be {@code null}.\n\t * @return the StAX event writer used by this result\n\t * @see #StaxResult(javax.xml.stream.XMLEventWriter)\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxResult#getXMLStreamWriter()",
    "entityType": "method",
    "code": "/**\r\n * Return the {@code XMLStreamWriter} used by this {@code StaxResult}.\r\n * <p>If this {@code StaxResult} was created with an {@code XMLEventConsumer},\r\n * the result will be {@code null}.\r\n * @return the StAX stream writer used by this result\r\n * @see #StaxResult(javax.xml.stream.XMLStreamWriter)\r\n */\r\n@Nullable\r\npublic XMLStreamWriter getXMLStreamWriter() {\r\n    return this.streamWriter;\r\n}",
    "comment": "\n\t * Return the {@code XMLStreamWriter} used by this {@code StaxResult}.\n\t * <p>If this {@code StaxResult} was created with an {@code XMLEventConsumer},\n\t * the result will be {@code null}.\n\t * @return the StAX stream writer used by this result\n\t * @see #StaxResult(javax.xml.stream.XMLStreamWriter)\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxResult#setHandler(ContentHandler)",
    "entityType": "method",
    "code": "/**\r\n * Throws an {@code UnsupportedOperationException}.\r\n * @throws UnsupportedOperationException always\r\n */\r\n@Override\r\npublic void setHandler(ContentHandler handler) {\r\n    throw new UnsupportedOperationException(\"setHandler is not supported\");\r\n}",
    "comment": "\n\t * Throws an {@code UnsupportedOperationException}.\n\t * @throws UnsupportedOperationException always\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxResult#setLexicalHandler(LexicalHandler)",
    "entityType": "method",
    "code": "/**\r\n * Throws an {@code UnsupportedOperationException}.\r\n * @throws UnsupportedOperationException always\r\n */\r\n@Override\r\npublic void setLexicalHandler(LexicalHandler handler) {\r\n    throw new UnsupportedOperationException(\"setLexicalHandler is not supported\");\r\n}",
    "comment": "\n\t * Throws an {@code UnsupportedOperationException}.\n\t * @throws UnsupportedOperationException always\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxSource",
    "entityType": "class",
    "code": "@Nullable\r\nprivate XMLEventReader eventReader;\n@Nullable\r\nprivate XMLStreamReader streamReader;\n/**\r\n * Construct a new instance of the {@code StaxSource} with the specified {@code XMLEventReader}.\r\n * The supplied event reader must be in {@code XMLStreamConstants.START_DOCUMENT} or\r\n * {@code XMLStreamConstants.START_ELEMENT} state.\r\n * @param eventReader the {@code XMLEventReader} to read from\r\n * @throws IllegalStateException if the reader is not at the start of a document or element\r\n */\r\nStaxSource(XMLEventReader eventReader) {\r\n    super(new StaxEventXMLReader(eventReader), new InputSource());\r\n    this.eventReader = eventReader;\r\n}\n/**\r\n * Construct a new instance of the {@code StaxSource} with the specified {@code XMLStreamReader}.\r\n * The supplied stream reader must be in {@code XMLStreamConstants.START_DOCUMENT} or\r\n * {@code XMLStreamConstants.START_ELEMENT} state.\r\n * @param streamReader the {@code XMLStreamReader} to read from\r\n * @throws IllegalStateException if the reader is not at the start of a document or element\r\n */\r\nStaxSource(XMLStreamReader streamReader) {\r\n    super(new StaxStreamXMLReader(streamReader), new InputSource());\r\n    this.streamReader = streamReader;\r\n}\n/**\r\n * Return the {@code XMLEventReader} used by this {@code StaxSource}.\r\n * <p>If this {@code StaxSource} was created with an {@code XMLStreamReader},\r\n * the result will be {@code null}.\r\n * @return the StAX event reader used by this source\r\n * @see StaxSource#StaxSource(javax.xml.stream.XMLEventReader)\r\n */\r\n@Nullable\r\nXMLEventReader getXMLEventReader() {\r\n    return this.eventReader;\r\n}\n/**\r\n * Return the {@code XMLStreamReader} used by this {@code StaxSource}.\r\n * <p>If this {@code StaxSource} was created with an {@code XMLEventReader},\r\n * the result will be {@code null}.\r\n * @return the StAX event reader used by this source\r\n * @see StaxSource#StaxSource(javax.xml.stream.XMLEventReader)\r\n */\r\n@Nullable\r\nXMLStreamReader getXMLStreamReader() {\r\n    return this.streamReader;\r\n}\n/**\r\n * Throws an {@code UnsupportedOperationException}.\r\n * @throws UnsupportedOperationException always\r\n */\r\n@Override\r\npublic void setInputSource(InputSource inputSource) {\r\n    throw new UnsupportedOperationException(\"setInputSource is not supported\");\r\n}\n/**\r\n * Throws an {@code UnsupportedOperationException}.\r\n * @throws UnsupportedOperationException always\r\n */\r\n@Override\r\npublic void setXMLReader(XMLReader reader) {\r\n    throw new UnsupportedOperationException(\"setXMLReader is not supported\");\r\n}",
    "comment": "\n * Implementation of the {@code Source} tagging interface for StAX readers. Can be constructed with\n * an {@code XMLEventReader} or an {@code XMLStreamReader}.\n *\n * <p>This class is necessary because there is no implementation of {@code Source} for StAX Readers\n * in JAXP 1.3. There is a {@code StAXSource} in JAXP 1.4 (JDK 1.6), but this class is kept around\n * for backwards compatibility reasons.\n *\n * <p>Even though {@code StaxSource} extends from {@code SAXSource}, calling the methods of\n * {@code SAXSource} is <strong>not supported</strong>. In general, the only supported operation\n * on this class is to use the {@code XMLReader} obtained via {@link #getXMLReader()} to parse the\n * input source obtained via {@link #getInputSource()}. Calling {@link #setXMLReader(XMLReader)}\n * or {@link #setInputSource(InputSource)} will result in {@code UnsupportedOperationException #setInputSource(InputSource)} will result in {@code UnsupportedOperationExceptions}.\n *\n * @author Arjen Poutsma\n * @since 3.0\n * @see XMLEventReader\n * @see XMLStreamReader\n * @see javax.xml.transform.Transformer\n "
  },
  {
    "entityId": "org.springframework.util.xml.StaxSource#getXMLEventReader()",
    "entityType": "method",
    "code": "/**\r\n * Return the {@code XMLEventReader} used by this {@code StaxSource}.\r\n * <p>If this {@code StaxSource} was created with an {@code XMLStreamReader},\r\n * the result will be {@code null}.\r\n * @return the StAX event reader used by this source\r\n * @see StaxSource#StaxSource(javax.xml.stream.XMLEventReader)\r\n */\r\n@Nullable\r\nXMLEventReader getXMLEventReader() {\r\n    return this.eventReader;\r\n}",
    "comment": "\n\t * Return the {@code XMLEventReader} used by this {@code StaxSource}.\n\t * <p>If this {@code StaxSource} was created with an {@code XMLStreamReader},\n\t * the result will be {@code null}.\n\t * @return the StAX event reader used by this source\n\t * @see StaxSource#StaxSource(javax.xml.stream.XMLEventReader)\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxSource#getXMLStreamReader()",
    "entityType": "method",
    "code": "/**\r\n * Return the {@code XMLStreamReader} used by this {@code StaxSource}.\r\n * <p>If this {@code StaxSource} was created with an {@code XMLEventReader},\r\n * the result will be {@code null}.\r\n * @return the StAX event reader used by this source\r\n * @see StaxSource#StaxSource(javax.xml.stream.XMLEventReader)\r\n */\r\n@Nullable\r\nXMLStreamReader getXMLStreamReader() {\r\n    return this.streamReader;\r\n}",
    "comment": "\n\t * Return the {@code XMLStreamReader} used by this {@code StaxSource}.\n\t * <p>If this {@code StaxSource} was created with an {@code XMLEventReader},\n\t * the result will be {@code null}.\n\t * @return the StAX event reader used by this source\n\t * @see StaxSource#StaxSource(javax.xml.stream.XMLEventReader)\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxSource#setInputSource(InputSource)",
    "entityType": "method",
    "code": "/**\r\n * Throws an {@code UnsupportedOperationException}.\r\n * @throws UnsupportedOperationException always\r\n */\r\n@Override\r\npublic void setInputSource(InputSource inputSource) {\r\n    throw new UnsupportedOperationException(\"setInputSource is not supported\");\r\n}",
    "comment": "\n\t * Throws an {@code UnsupportedOperationException}.\n\t * @throws UnsupportedOperationException always\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxSource#setXMLReader(XMLReader)",
    "entityType": "method",
    "code": "/**\r\n * Throws an {@code UnsupportedOperationException}.\r\n * @throws UnsupportedOperationException always\r\n */\r\n@Override\r\npublic void setXMLReader(XMLReader reader) {\r\n    throw new UnsupportedOperationException(\"setXMLReader is not supported\");\r\n}",
    "comment": "\n\t * Throws an {@code UnsupportedOperationException}.\n\t * @throws UnsupportedOperationException always\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamHandler",
    "entityType": "class",
    "code": "private final XMLStreamWriter streamWriter;\npublic StaxStreamHandler(XMLStreamWriter streamWriter) {\r\n    this.streamWriter = streamWriter;\r\n}\n@Override\r\nprotected void startDocumentInternal() throws XMLStreamException {\r\n    this.streamWriter.writeStartDocument();\r\n}\n@Override\r\nprotected void endDocumentInternal() throws XMLStreamException {\r\n    this.streamWriter.writeEndDocument();\r\n}\n@Override\r\nprotected void startElementInternal(QName name, Attributes attributes, Map<String, String> namespaceMapping) throws XMLStreamException {\r\n    this.streamWriter.writeStartElement(name.getPrefix(), name.getLocalPart(), name.getNamespaceURI());\r\n    for (Map.Entry<String, String> entry : namespaceMapping.entrySet()) {\r\n        String prefix = entry.getKey();\r\n        String namespaceUri = entry.getValue();\r\n        this.streamWriter.writeNamespace(prefix, namespaceUri);\r\n        if (XMLConstants.DEFAULT_NS_PREFIX.equals(prefix)) {\r\n            this.streamWriter.setDefaultNamespace(namespaceUri);\r\n        } else {\r\n            this.streamWriter.setPrefix(prefix, namespaceUri);\r\n        }\r\n    }\r\n    for (int i = 0; i < attributes.getLength(); i++) {\r\n        QName attrName = toQName(attributes.getURI(i), attributes.getQName(i));\r\n        if (!isNamespaceDeclaration(attrName)) {\r\n            this.streamWriter.writeAttribute(attrName.getPrefix(), attrName.getNamespaceURI(), attrName.getLocalPart(), attributes.getValue(i));\r\n        }\r\n    }\r\n}\n@Override\r\nprotected void endElementInternal(QName name, Map<String, String> namespaceMapping) throws XMLStreamException {\r\n    this.streamWriter.writeEndElement();\r\n}\n@Override\r\nprotected void charactersInternal(String data) throws XMLStreamException {\r\n    this.streamWriter.writeCharacters(data);\r\n}\n@Override\r\nprotected void cDataInternal(String data) throws XMLStreamException {\r\n    this.streamWriter.writeCData(data);\r\n}\n@Override\r\nprotected void ignorableWhitespaceInternal(String data) throws XMLStreamException {\r\n    this.streamWriter.writeCharacters(data);\r\n}\n@Override\r\nprotected void processingInstructionInternal(String target, String data) throws XMLStreamException {\r\n    this.streamWriter.writeProcessingInstruction(target, data);\r\n}\n@Override\r\nprotected void dtdInternal(String dtd) throws XMLStreamException {\r\n    this.streamWriter.writeDTD(dtd);\r\n}\n@Override\r\nprotected void commentInternal(String comment) throws XMLStreamException {\r\n    this.streamWriter.writeComment(comment);\r\n}\n// Ignored\r\n@Override\r\npublic void setDocumentLocator(Locator locator) ;\n@Override\r\npublic void startEntity(String name) throws SAXException ;\n@Override\r\npublic void endEntity(String name) throws SAXException ;\n@Override\r\nprotected void skippedEntityInternal(String name) throws XMLStreamException ;",
    "comment": "\n * SAX {@link org.xml.sax.ContentHandler} and {@link LexicalHandler}\n * that writes to an {@link XMLStreamWriter}.\n *\n * @author Arjen Poutsma\n * @since 4.0.3\n "
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamHandler#startDocumentInternal()",
    "entityType": "method",
    "code": "@Override\r\nprotected void startDocumentInternal() throws XMLStreamException {\r\n    this.streamWriter.writeStartDocument();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamHandler#endDocumentInternal()",
    "entityType": "method",
    "code": "@Override\r\nprotected void endDocumentInternal() throws XMLStreamException {\r\n    this.streamWriter.writeEndDocument();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamHandler#startElementInternal(QName,Attributes,Map<String,String>)",
    "entityType": "method",
    "code": "@Override\r\nprotected void startElementInternal(QName name, Attributes attributes, Map<String, String> namespaceMapping) throws XMLStreamException {\r\n    this.streamWriter.writeStartElement(name.getPrefix(), name.getLocalPart(), name.getNamespaceURI());\r\n    for (Map.Entry<String, String> entry : namespaceMapping.entrySet()) {\r\n        String prefix = entry.getKey();\r\n        String namespaceUri = entry.getValue();\r\n        this.streamWriter.writeNamespace(prefix, namespaceUri);\r\n        if (XMLConstants.DEFAULT_NS_PREFIX.equals(prefix)) {\r\n            this.streamWriter.setDefaultNamespace(namespaceUri);\r\n        } else {\r\n            this.streamWriter.setPrefix(prefix, namespaceUri);\r\n        }\r\n    }\r\n    for (int i = 0; i < attributes.getLength(); i++) {\r\n        QName attrName = toQName(attributes.getURI(i), attributes.getQName(i));\r\n        if (!isNamespaceDeclaration(attrName)) {\r\n            this.streamWriter.writeAttribute(attrName.getPrefix(), attrName.getNamespaceURI(), attrName.getLocalPart(), attributes.getValue(i));\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamHandler#endElementInternal(QName,Map<String,String>)",
    "entityType": "method",
    "code": "@Override\r\nprotected void endElementInternal(QName name, Map<String, String> namespaceMapping) throws XMLStreamException {\r\n    this.streamWriter.writeEndElement();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamHandler#charactersInternal(String)",
    "entityType": "method",
    "code": "@Override\r\nprotected void charactersInternal(String data) throws XMLStreamException {\r\n    this.streamWriter.writeCharacters(data);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamHandler#cDataInternal(String)",
    "entityType": "method",
    "code": "@Override\r\nprotected void cDataInternal(String data) throws XMLStreamException {\r\n    this.streamWriter.writeCData(data);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamHandler#ignorableWhitespaceInternal(String)",
    "entityType": "method",
    "code": "@Override\r\nprotected void ignorableWhitespaceInternal(String data) throws XMLStreamException {\r\n    this.streamWriter.writeCharacters(data);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamHandler#processingInstructionInternal(String,String)",
    "entityType": "method",
    "code": "@Override\r\nprotected void processingInstructionInternal(String target, String data) throws XMLStreamException {\r\n    this.streamWriter.writeProcessingInstruction(target, data);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamHandler#dtdInternal(String)",
    "entityType": "method",
    "code": "@Override\r\nprotected void dtdInternal(String dtd) throws XMLStreamException {\r\n    this.streamWriter.writeDTD(dtd);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamHandler#commentInternal(String)",
    "entityType": "method",
    "code": "@Override\r\nprotected void commentInternal(String comment) throws XMLStreamException {\r\n    this.streamWriter.writeComment(comment);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamHandler#setDocumentLocator(Locator)",
    "entityType": "method",
    "code": "// Ignored\r\n@Override\r\npublic void setDocumentLocator(Locator locator) ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamHandler#startEntity(String)",
    "entityType": "method",
    "code": "@Override\r\npublic void startEntity(String name) throws SAXException ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamHandler#endEntity(String)",
    "entityType": "method",
    "code": "@Override\r\npublic void endEntity(String name) throws SAXException ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamHandler#skippedEntityInternal(String)",
    "entityType": "method",
    "code": "@Override\r\nprotected void skippedEntityInternal(String name) throws XMLStreamException ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamXMLReader",
    "entityType": "class",
    "code": "private static final String DEFAULT_XML_VERSION = \"1.0\";\nprivate final XMLStreamReader reader;\nprivate String xmlVersion = DEFAULT_XML_VERSION;\n@Nullable\r\nprivate String encoding;\n/**\r\n * Construct a new instance of the {@code StaxStreamXmlReader} that reads from the given\r\n * {@code XMLStreamReader}. The supplied stream reader must be in {@code XMLStreamConstants.START_DOCUMENT}\r\n * or {@code XMLStreamConstants.START_ELEMENT} state.\r\n * @param reader the {@code XMLEventReader} to read from\r\n * @throws IllegalStateException if the reader is not at the start of a document or element\r\n */\r\nStaxStreamXMLReader(XMLStreamReader reader) {\r\n    int event = reader.getEventType();\r\n    if (!(event == XMLStreamConstants.START_DOCUMENT || event == XMLStreamConstants.START_ELEMENT)) {\r\n        throw new IllegalStateException(\"XMLEventReader not at start of document or element\");\r\n    }\r\n    this.reader = reader;\r\n}\n@Override\r\nprotected void parseInternal() throws SAXException, XMLStreamException {\r\n    boolean documentStarted = false;\r\n    boolean documentEnded = false;\r\n    int elementDepth = 0;\r\n    int eventType = this.reader.getEventType();\r\n    while (true) {\r\n        if (eventType != XMLStreamConstants.START_DOCUMENT && eventType != XMLStreamConstants.END_DOCUMENT && !documentStarted) {\r\n            handleStartDocument();\r\n            documentStarted = true;\r\n        }\r\n        switch(eventType) {\r\n            case XMLStreamConstants.START_ELEMENT ->\r\n                {\r\n                    elementDepth++;\r\n                    handleStartElement();\r\n                }\r\n            case XMLStreamConstants.END_ELEMENT ->\r\n                {\r\n                    elementDepth--;\r\n                    if (elementDepth >= 0) {\r\n                        handleEndElement();\r\n                    }\r\n                }\r\n            case XMLStreamConstants.PROCESSING_INSTRUCTION ->\r\n                handleProcessingInstruction();\r\n            case XMLStreamConstants.CHARACTERS, XMLStreamConstants.SPACE, XMLStreamConstants.CDATA ->\r\n                handleCharacters();\r\n            case XMLStreamConstants.START_DOCUMENT ->\r\n                {\r\n                    handleStartDocument();\r\n                    documentStarted = true;\r\n                }\r\n            case XMLStreamConstants.END_DOCUMENT ->\r\n                {\r\n                    handleEndDocument();\r\n                    documentEnded = true;\r\n                }\r\n            case XMLStreamConstants.COMMENT ->\r\n                handleComment();\r\n            case XMLStreamConstants.DTD ->\r\n                handleDtd();\r\n            case XMLStreamConstants.ENTITY_REFERENCE ->\r\n                handleEntityReference();\r\n        }\r\n        if (this.reader.hasNext() && elementDepth >= 0) {\r\n            eventType = this.reader.next();\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    if (!documentEnded) {\r\n        handleEndDocument();\r\n    }\r\n}\nprivate void handleStartDocument() throws SAXException {\r\n    if (XMLStreamConstants.START_DOCUMENT == this.reader.getEventType()) {\r\n        String xmlVersion = this.reader.getVersion();\r\n        if (StringUtils.hasLength(xmlVersion)) {\r\n            this.xmlVersion = xmlVersion;\r\n        }\r\n        this.encoding = this.reader.getCharacterEncodingScheme();\r\n    }\r\n    ContentHandler contentHandler = getContentHandler();\r\n    if (contentHandler != null) {\r\n        final Location location = this.reader.getLocation();\r\n        contentHandler.setDocumentLocator(new Locator2() {\r\n\r\n            @Override\r\n            public int getColumnNumber() {\r\n                return (location != null ? location.getColumnNumber() : -1);\r\n            }\r\n\r\n            @Override\r\n            public int getLineNumber() {\r\n                return (location != null ? location.getLineNumber() : -1);\r\n            }\r\n\r\n            @Override\r\n            @Nullable\r\n            public String getPublicId() {\r\n                return (location != null ? location.getPublicId() : null);\r\n            }\r\n\r\n            @Override\r\n            @Nullable\r\n            public String getSystemId() {\r\n                return (location != null ? location.getSystemId() : null);\r\n            }\r\n\r\n            @Override\r\n            public String getXMLVersion() {\r\n                return xmlVersion;\r\n            }\r\n\r\n            @Override\r\n            @Nullable\r\n            public String getEncoding() {\r\n                return encoding;\r\n            }\r\n        });\r\n        contentHandler.startDocument();\r\n        if (this.reader.standaloneSet()) {\r\n            setStandalone(this.reader.isStandalone());\r\n        }\r\n    }\r\n}\nprivate void handleStartElement() throws SAXException {\r\n    if (getContentHandler() != null) {\r\n        QName qName = this.reader.getName();\r\n        if (hasNamespacesFeature()) {\r\n            for (int i = 0; i < this.reader.getNamespaceCount(); i++) {\r\n                startPrefixMapping(this.reader.getNamespacePrefix(i), this.reader.getNamespaceURI(i));\r\n            }\r\n            for (int i = 0; i < this.reader.getAttributeCount(); i++) {\r\n                String prefix = this.reader.getAttributePrefix(i);\r\n                String namespace = this.reader.getAttributeNamespace(i);\r\n                if (StringUtils.hasLength(namespace)) {\r\n                    startPrefixMapping(prefix, namespace);\r\n                }\r\n            }\r\n            getContentHandler().startElement(qName.getNamespaceURI(), qName.getLocalPart(), toQualifiedName(qName), getAttributes());\r\n        } else {\r\n            getContentHandler().startElement(\"\", \"\", toQualifiedName(qName), getAttributes());\r\n        }\r\n    }\r\n}\nprivate void handleEndElement() throws SAXException {\r\n    if (getContentHandler() != null) {\r\n        QName qName = this.reader.getName();\r\n        if (hasNamespacesFeature()) {\r\n            getContentHandler().endElement(qName.getNamespaceURI(), qName.getLocalPart(), toQualifiedName(qName));\r\n            for (int i = 0; i < this.reader.getNamespaceCount(); i++) {\r\n                String prefix = this.reader.getNamespacePrefix(i);\r\n                if (prefix == null) {\r\n                    prefix = \"\";\r\n                }\r\n                endPrefixMapping(prefix);\r\n            }\r\n        } else {\r\n            getContentHandler().endElement(\"\", \"\", toQualifiedName(qName));\r\n        }\r\n    }\r\n}\nprivate void handleCharacters() throws SAXException {\r\n    if (XMLStreamConstants.CDATA == this.reader.getEventType() && getLexicalHandler() != null) {\r\n        getLexicalHandler().startCDATA();\r\n    }\r\n    if (getContentHandler() != null) {\r\n        getContentHandler().characters(this.reader.getTextCharacters(), this.reader.getTextStart(), this.reader.getTextLength());\r\n    }\r\n    if (XMLStreamConstants.CDATA == this.reader.getEventType() && getLexicalHandler() != null) {\r\n        getLexicalHandler().endCDATA();\r\n    }\r\n}\nprivate void handleComment() throws SAXException {\r\n    if (getLexicalHandler() != null) {\r\n        getLexicalHandler().comment(this.reader.getTextCharacters(), this.reader.getTextStart(), this.reader.getTextLength());\r\n    }\r\n}\nprivate void handleDtd() throws SAXException {\r\n    if (getLexicalHandler() != null) {\r\n        Location location = this.reader.getLocation();\r\n        getLexicalHandler().startDTD(null, location.getPublicId(), location.getSystemId());\r\n    }\r\n    if (getLexicalHandler() != null) {\r\n        getLexicalHandler().endDTD();\r\n    }\r\n}\nprivate void handleEntityReference() throws SAXException {\r\n    if (getLexicalHandler() != null) {\r\n        getLexicalHandler().startEntity(this.reader.getLocalName());\r\n    }\r\n    if (getLexicalHandler() != null) {\r\n        getLexicalHandler().endEntity(this.reader.getLocalName());\r\n    }\r\n}\nprivate void handleEndDocument() throws SAXException {\r\n    if (getContentHandler() != null) {\r\n        getContentHandler().endDocument();\r\n    }\r\n}\nprivate void handleProcessingInstruction() throws SAXException {\r\n    if (getContentHandler() != null) {\r\n        getContentHandler().processingInstruction(this.reader.getPITarget(), this.reader.getPIData());\r\n    }\r\n}\nprivate Attributes getAttributes() {\r\n    AttributesImpl attributes = new AttributesImpl();\r\n    for (int i = 0; i < this.reader.getAttributeCount(); i++) {\r\n        String namespace = this.reader.getAttributeNamespace(i);\r\n        if (namespace == null || !hasNamespacesFeature()) {\r\n            namespace = \"\";\r\n        }\r\n        String type = this.reader.getAttributeType(i);\r\n        if (type == null) {\r\n            type = \"CDATA\";\r\n        }\r\n        attributes.addAttribute(namespace, this.reader.getAttributeLocalName(i), toQualifiedName(this.reader.getAttributeName(i)), type, this.reader.getAttributeValue(i));\r\n    }\r\n    if (hasNamespacePrefixesFeature()) {\r\n        for (int i = 0; i < this.reader.getNamespaceCount(); i++) {\r\n            String prefix = this.reader.getNamespacePrefix(i);\r\n            String namespaceUri = this.reader.getNamespaceURI(i);\r\n            String qName;\r\n            if (StringUtils.hasLength(prefix)) {\r\n                qName = \"xmlns:\" + prefix;\r\n            } else {\r\n                qName = \"xmlns\";\r\n            }\r\n            attributes.addAttribute(\"\", \"\", qName, \"CDATA\", namespaceUri);\r\n        }\r\n    }\r\n    return attributes;\r\n}",
    "comment": "\n * SAX {@code XMLReader} that reads from a StAX {@code XMLStreamReader}. Reads from an\n * {@code XMLStreamReader}, and calls the corresponding methods on the SAX callback interfaces.\n *\n * @author Arjen Poutsma\n * @since 3.0\n * @see XMLStreamReader\n * @see #setContentHandler(org.xml.sax.ContentHandler)\n * @see #setDTDHandler(org.xml.sax.DTDHandler)\n * @see #setEntityResolver(org.xml.sax.EntityResolver)\n * @see #setErrorHandler(org.xml.sax.ErrorHandler)\n "
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamXMLReader#parseInternal()",
    "entityType": "method",
    "code": "@Override\r\nprotected void parseInternal() throws SAXException, XMLStreamException {\r\n    boolean documentStarted = false;\r\n    boolean documentEnded = false;\r\n    int elementDepth = 0;\r\n    int eventType = this.reader.getEventType();\r\n    while (true) {\r\n        if (eventType != XMLStreamConstants.START_DOCUMENT && eventType != XMLStreamConstants.END_DOCUMENT && !documentStarted) {\r\n            handleStartDocument();\r\n            documentStarted = true;\r\n        }\r\n        switch(eventType) {\r\n            case XMLStreamConstants.START_ELEMENT ->\r\n                {\r\n                    elementDepth++;\r\n                    handleStartElement();\r\n                }\r\n            case XMLStreamConstants.END_ELEMENT ->\r\n                {\r\n                    elementDepth--;\r\n                    if (elementDepth >= 0) {\r\n                        handleEndElement();\r\n                    }\r\n                }\r\n            case XMLStreamConstants.PROCESSING_INSTRUCTION ->\r\n                handleProcessingInstruction();\r\n            case XMLStreamConstants.CHARACTERS, XMLStreamConstants.SPACE, XMLStreamConstants.CDATA ->\r\n                handleCharacters();\r\n            case XMLStreamConstants.START_DOCUMENT ->\r\n                {\r\n                    handleStartDocument();\r\n                    documentStarted = true;\r\n                }\r\n            case XMLStreamConstants.END_DOCUMENT ->\r\n                {\r\n                    handleEndDocument();\r\n                    documentEnded = true;\r\n                }\r\n            case XMLStreamConstants.COMMENT ->\r\n                handleComment();\r\n            case XMLStreamConstants.DTD ->\r\n                handleDtd();\r\n            case XMLStreamConstants.ENTITY_REFERENCE ->\r\n                handleEntityReference();\r\n        }\r\n        if (this.reader.hasNext() && elementDepth >= 0) {\r\n            eventType = this.reader.next();\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    if (!documentEnded) {\r\n        handleEndDocument();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamXMLReader#handleStartDocument()",
    "entityType": "method",
    "code": "private void handleStartDocument() throws SAXException {\r\n    if (XMLStreamConstants.START_DOCUMENT == this.reader.getEventType()) {\r\n        String xmlVersion = this.reader.getVersion();\r\n        if (StringUtils.hasLength(xmlVersion)) {\r\n            this.xmlVersion = xmlVersion;\r\n        }\r\n        this.encoding = this.reader.getCharacterEncodingScheme();\r\n    }\r\n    ContentHandler contentHandler = getContentHandler();\r\n    if (contentHandler != null) {\r\n        final Location location = this.reader.getLocation();\r\n        contentHandler.setDocumentLocator(new Locator2() {\r\n\r\n            @Override\r\n            public int getColumnNumber() {\r\n                return (location != null ? location.getColumnNumber() : -1);\r\n            }\r\n\r\n            @Override\r\n            public int getLineNumber() {\r\n                return (location != null ? location.getLineNumber() : -1);\r\n            }\r\n\r\n            @Override\r\n            @Nullable\r\n            public String getPublicId() {\r\n                return (location != null ? location.getPublicId() : null);\r\n            }\r\n\r\n            @Override\r\n            @Nullable\r\n            public String getSystemId() {\r\n                return (location != null ? location.getSystemId() : null);\r\n            }\r\n\r\n            @Override\r\n            public String getXMLVersion() {\r\n                return xmlVersion;\r\n            }\r\n\r\n            @Override\r\n            @Nullable\r\n            public String getEncoding() {\r\n                return encoding;\r\n            }\r\n        });\r\n        contentHandler.startDocument();\r\n        if (this.reader.standaloneSet()) {\r\n            setStandalone(this.reader.isStandalone());\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamXMLReader#handleStartElement()",
    "entityType": "method",
    "code": "private void handleStartElement() throws SAXException {\r\n    if (getContentHandler() != null) {\r\n        QName qName = this.reader.getName();\r\n        if (hasNamespacesFeature()) {\r\n            for (int i = 0; i < this.reader.getNamespaceCount(); i++) {\r\n                startPrefixMapping(this.reader.getNamespacePrefix(i), this.reader.getNamespaceURI(i));\r\n            }\r\n            for (int i = 0; i < this.reader.getAttributeCount(); i++) {\r\n                String prefix = this.reader.getAttributePrefix(i);\r\n                String namespace = this.reader.getAttributeNamespace(i);\r\n                if (StringUtils.hasLength(namespace)) {\r\n                    startPrefixMapping(prefix, namespace);\r\n                }\r\n            }\r\n            getContentHandler().startElement(qName.getNamespaceURI(), qName.getLocalPart(), toQualifiedName(qName), getAttributes());\r\n        } else {\r\n            getContentHandler().startElement(\"\", \"\", toQualifiedName(qName), getAttributes());\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamXMLReader#handleEndElement()",
    "entityType": "method",
    "code": "private void handleEndElement() throws SAXException {\r\n    if (getContentHandler() != null) {\r\n        QName qName = this.reader.getName();\r\n        if (hasNamespacesFeature()) {\r\n            getContentHandler().endElement(qName.getNamespaceURI(), qName.getLocalPart(), toQualifiedName(qName));\r\n            for (int i = 0; i < this.reader.getNamespaceCount(); i++) {\r\n                String prefix = this.reader.getNamespacePrefix(i);\r\n                if (prefix == null) {\r\n                    prefix = \"\";\r\n                }\r\n                endPrefixMapping(prefix);\r\n            }\r\n        } else {\r\n            getContentHandler().endElement(\"\", \"\", toQualifiedName(qName));\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamXMLReader#handleCharacters()",
    "entityType": "method",
    "code": "private void handleCharacters() throws SAXException {\r\n    if (XMLStreamConstants.CDATA == this.reader.getEventType() && getLexicalHandler() != null) {\r\n        getLexicalHandler().startCDATA();\r\n    }\r\n    if (getContentHandler() != null) {\r\n        getContentHandler().characters(this.reader.getTextCharacters(), this.reader.getTextStart(), this.reader.getTextLength());\r\n    }\r\n    if (XMLStreamConstants.CDATA == this.reader.getEventType() && getLexicalHandler() != null) {\r\n        getLexicalHandler().endCDATA();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamXMLReader#handleComment()",
    "entityType": "method",
    "code": "private void handleComment() throws SAXException {\r\n    if (getLexicalHandler() != null) {\r\n        getLexicalHandler().comment(this.reader.getTextCharacters(), this.reader.getTextStart(), this.reader.getTextLength());\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamXMLReader#handleDtd()",
    "entityType": "method",
    "code": "private void handleDtd() throws SAXException {\r\n    if (getLexicalHandler() != null) {\r\n        Location location = this.reader.getLocation();\r\n        getLexicalHandler().startDTD(null, location.getPublicId(), location.getSystemId());\r\n    }\r\n    if (getLexicalHandler() != null) {\r\n        getLexicalHandler().endDTD();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamXMLReader#handleEntityReference()",
    "entityType": "method",
    "code": "private void handleEntityReference() throws SAXException {\r\n    if (getLexicalHandler() != null) {\r\n        getLexicalHandler().startEntity(this.reader.getLocalName());\r\n    }\r\n    if (getLexicalHandler() != null) {\r\n        getLexicalHandler().endEntity(this.reader.getLocalName());\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamXMLReader#handleEndDocument()",
    "entityType": "method",
    "code": "private void handleEndDocument() throws SAXException {\r\n    if (getContentHandler() != null) {\r\n        getContentHandler().endDocument();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamXMLReader#handleProcessingInstruction()",
    "entityType": "method",
    "code": "private void handleProcessingInstruction() throws SAXException {\r\n    if (getContentHandler() != null) {\r\n        getContentHandler().processingInstruction(this.reader.getPITarget(), this.reader.getPIData());\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamXMLReader#getAttributes()",
    "entityType": "method",
    "code": "private Attributes getAttributes() {\r\n    AttributesImpl attributes = new AttributesImpl();\r\n    for (int i = 0; i < this.reader.getAttributeCount(); i++) {\r\n        String namespace = this.reader.getAttributeNamespace(i);\r\n        if (namespace == null || !hasNamespacesFeature()) {\r\n            namespace = \"\";\r\n        }\r\n        String type = this.reader.getAttributeType(i);\r\n        if (type == null) {\r\n            type = \"CDATA\";\r\n        }\r\n        attributes.addAttribute(namespace, this.reader.getAttributeLocalName(i), toQualifiedName(this.reader.getAttributeName(i)), type, this.reader.getAttributeValue(i));\r\n    }\r\n    if (hasNamespacePrefixesFeature()) {\r\n        for (int i = 0; i < this.reader.getNamespaceCount(); i++) {\r\n            String prefix = this.reader.getNamespacePrefix(i);\r\n            String namespaceUri = this.reader.getNamespaceURI(i);\r\n            String qName;\r\n            if (StringUtils.hasLength(prefix)) {\r\n                qName = \"xmlns:\" + prefix;\r\n            } else {\r\n                qName = \"xmlns\";\r\n            }\r\n            attributes.addAttribute(\"\", \"\", qName, \"CDATA\", namespaceUri);\r\n        }\r\n    }\r\n    return attributes;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtils",
    "entityType": "class",
    "code": "private static final XMLResolver NO_OP_XML_RESOLVER = (publicID, systemID, base, ns) -> InputStream.nullInputStream();\n/**\r\n * Create an {@link XMLInputFactory} with Spring's defensive setup,\r\n * i.e. no support for the resolution of DTDs and external entities.\r\n * @return a new defensively initialized input factory instance to use\r\n * @since 5.0\r\n */\r\npublic static XMLInputFactory createDefensiveInputFactory() {\r\n    return createDefensiveInputFactory(XMLInputFactory::newInstance);\r\n}\n/**\r\n * Variant of {@link #createDefensiveInputFactory()} with a custom instance.\r\n * @param instanceSupplier supplier for the input factory instance\r\n * @return a new defensively initialized input factory instance to use\r\n * @since 5.0.12\r\n */\r\npublic static <T extends XMLInputFactory> T createDefensiveInputFactory(Supplier<T> instanceSupplier) {\r\n    T inputFactory = instanceSupplier.get();\r\n    inputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);\r\n    inputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\r\n    inputFactory.setXMLResolver(NO_OP_XML_RESOLVER);\r\n    return inputFactory;\r\n}\n/**\r\n * Create a JAXP 1.4 {@link StAXSource} for the given {@link XMLStreamReader}.\r\n * @param streamReader the StAX stream reader\r\n * @return a source wrapping the {@code streamReader}\r\n */\r\npublic static Source createStaxSource(XMLStreamReader streamReader) {\r\n    return new StAXSource(streamReader);\r\n}\n/**\r\n * Create a JAXP 1.4 {@link StAXSource} for the given {@link XMLEventReader}.\r\n * @param eventReader the StAX event reader\r\n * @return a source wrapping the {@code eventReader}\r\n */\r\npublic static Source createStaxSource(XMLEventReader eventReader) throws XMLStreamException {\r\n    return new StAXSource(eventReader);\r\n}\n/**\r\n * Create a custom, non-JAXP 1.4 StAX {@link Source} for the given {@link XMLStreamReader}.\r\n * @param streamReader the StAX stream reader\r\n * @return a source wrapping the {@code streamReader}\r\n */\r\npublic static Source createCustomStaxSource(XMLStreamReader streamReader) {\r\n    return new StaxSource(streamReader);\r\n}\n/**\r\n * Create a custom, non-JAXP 1.4 StAX {@link Source} for the given {@link XMLEventReader}.\r\n * @param eventReader the StAX event reader\r\n * @return a source wrapping the {@code eventReader}\r\n */\r\npublic static Source createCustomStaxSource(XMLEventReader eventReader) {\r\n    return new StaxSource(eventReader);\r\n}\n/**\r\n * Indicate whether the given {@link Source} is a JAXP 1.4 StAX Source or\r\n * custom StAX Source.\r\n * @return {@code true} if {@code source} is a JAXP 1.4 {@link StAXSource} or\r\n * custom StAX Source; {@code false} otherwise\r\n */\r\npublic static boolean isStaxSource(Source source) {\r\n    return (source instanceof StAXSource || source instanceof StaxSource);\r\n}\n/**\r\n * Return the {@link XMLStreamReader} for the given StAX Source.\r\n * @param source a JAXP 1.4 {@link StAXSource}\r\n * @return the {@link XMLStreamReader}\r\n * @throws IllegalArgumentException if {@code source} isn't a JAXP 1.4 {@link StAXSource}\r\n * or custom StAX Source\r\n */\r\n@Nullable\r\npublic static XMLStreamReader getXMLStreamReader(Source source) {\r\n    if (source instanceof StAXSource stAXSource) {\r\n        return stAXSource.getXMLStreamReader();\r\n    } else if (source instanceof StaxSource staxSource) {\r\n        return staxSource.getXMLStreamReader();\r\n    } else {\r\n        throw new IllegalArgumentException(\"Source '\" + source + \"' is neither StaxSource nor StAXSource\");\r\n    }\r\n}\n/**\r\n * Return the {@link XMLEventReader} for the given StAX Source.\r\n * @param source a JAXP 1.4 {@link StAXSource}\r\n * @return the {@link XMLEventReader}\r\n * @throws IllegalArgumentException if {@code source} isn't a JAXP 1.4 {@link StAXSource}\r\n * or custom StAX Source\r\n */\r\n@Nullable\r\npublic static XMLEventReader getXMLEventReader(Source source) {\r\n    if (source instanceof StAXSource stAXSource) {\r\n        return stAXSource.getXMLEventReader();\r\n    } else if (source instanceof StaxSource staxSource) {\r\n        return staxSource.getXMLEventReader();\r\n    } else {\r\n        throw new IllegalArgumentException(\"Source '\" + source + \"' is neither StaxSource nor StAXSource\");\r\n    }\r\n}\n/**\r\n * Create a JAXP 1.4 {@link StAXResult} for the given {@link XMLStreamWriter}.\r\n * @param streamWriter the StAX stream writer\r\n * @return a result wrapping the {@code streamWriter}\r\n */\r\npublic static Result createStaxResult(XMLStreamWriter streamWriter) {\r\n    return new StAXResult(streamWriter);\r\n}\n/**\r\n * Create a JAXP 1.4 {@link StAXResult} for the given {@link XMLEventWriter}.\r\n * @param eventWriter the StAX event writer\r\n * @return a result wrapping {@code streamReader}\r\n */\r\npublic static Result createStaxResult(XMLEventWriter eventWriter) {\r\n    return new StAXResult(eventWriter);\r\n}\n/**\r\n * Create a custom, non-JAXP 1.4 StAX {@link Result} for the given {@link XMLStreamWriter}.\r\n * @param streamWriter the StAX stream writer\r\n * @return a source wrapping the {@code streamWriter}\r\n */\r\npublic static Result createCustomStaxResult(XMLStreamWriter streamWriter) {\r\n    return new StaxResult(streamWriter);\r\n}\n/**\r\n * Create a custom, non-JAXP 1.4 StAX {@link Result} for the given {@link XMLEventWriter}.\r\n * @param eventWriter the StAX event writer\r\n * @return a source wrapping the {@code eventWriter}\r\n */\r\npublic static Result createCustomStaxResult(XMLEventWriter eventWriter) {\r\n    return new StaxResult(eventWriter);\r\n}\n/**\r\n * Indicate whether the given {@link Result} is a JAXP 1.4 StAX Result or\r\n * custom StAX Result.\r\n * @return {@code true} if {@code result} is a JAXP 1.4 {@link StAXResult} or\r\n * custom StAX Result; {@code false} otherwise\r\n */\r\npublic static boolean isStaxResult(Result result) {\r\n    return (result instanceof StAXResult || result instanceof StaxResult);\r\n}\n/**\r\n * Return the {@link XMLStreamWriter} for the given StAX Result.\r\n * @param result a JAXP 1.4 {@link StAXResult}\r\n * @return the {@link XMLStreamReader}\r\n * @throws IllegalArgumentException if {@code source} isn't a JAXP 1.4 {@link StAXResult}\r\n * or custom StAX Result\r\n */\r\n@Nullable\r\npublic static XMLStreamWriter getXMLStreamWriter(Result result) {\r\n    if (result instanceof StAXResult stAXResult) {\r\n        return stAXResult.getXMLStreamWriter();\r\n    } else if (result instanceof StaxResult staxResult) {\r\n        return staxResult.getXMLStreamWriter();\r\n    } else {\r\n        throw new IllegalArgumentException(\"Result '\" + result + \"' is neither StaxResult nor StAXResult\");\r\n    }\r\n}\n/**\r\n * Return the {@link XMLEventWriter} for the given StAX Result.\r\n * @param result a JAXP 1.4 {@link StAXResult}\r\n * @return the {@link XMLStreamReader}\r\n * @throws IllegalArgumentException if {@code source} isn't a JAXP 1.4 {@link StAXResult}\r\n * or custom StAX Result\r\n */\r\n@Nullable\r\npublic static XMLEventWriter getXMLEventWriter(Result result) {\r\n    if (result instanceof StAXResult stAXResult) {\r\n        return stAXResult.getXMLEventWriter();\r\n    } else if (result instanceof StaxResult staxResult) {\r\n        return staxResult.getXMLEventWriter();\r\n    } else {\r\n        throw new IllegalArgumentException(\"Result '\" + result + \"' is neither StaxResult nor StAXResult\");\r\n    }\r\n}\n/**\r\n * Create a {@link XMLEventReader} from the given list of {@link XMLEvent}.\r\n * @param events the list of {@link XMLEvent XMLEvents}.\r\n * @return an {@code XMLEventReader} that reads from the given events\r\n * @since 5.0\r\n */\r\npublic static XMLEventReader createXMLEventReader(List<XMLEvent> events) {\r\n    return new ListBasedXMLEventReader(events);\r\n}\n/**\r\n * Create a SAX {@link ContentHandler} that writes to the given StAX {@link XMLStreamWriter}.\r\n * @param streamWriter the StAX stream writer\r\n * @return a content handler writing to the {@code streamWriter}\r\n */\r\npublic static ContentHandler createContentHandler(XMLStreamWriter streamWriter) {\r\n    return new StaxStreamHandler(streamWriter);\r\n}\n/**\r\n * Create a SAX {@link ContentHandler} that writes events to the given StAX {@link XMLEventWriter}.\r\n * @param eventWriter the StAX event writer\r\n * @return a content handler writing to the {@code eventWriter}\r\n */\r\npublic static ContentHandler createContentHandler(XMLEventWriter eventWriter) {\r\n    return new StaxEventHandler(eventWriter);\r\n}\n/**\r\n * Create a SAX {@link XMLReader} that reads from the given StAX {@link XMLStreamReader}.\r\n * @param streamReader the StAX stream reader\r\n * @return a XMLReader reading from the {@code streamWriter}\r\n */\r\npublic static XMLReader createXMLReader(XMLStreamReader streamReader) {\r\n    return new StaxStreamXMLReader(streamReader);\r\n}\n/**\r\n * Create a SAX {@link XMLReader} that reads from the given StAX {@link XMLEventReader}.\r\n * @param eventReader the StAX event reader\r\n * @return a XMLReader reading from the {@code eventWriter}\r\n */\r\npublic static XMLReader createXMLReader(XMLEventReader eventReader) {\r\n    return new StaxEventXMLReader(eventReader);\r\n}\n/**\r\n * Return a {@link XMLStreamReader} that reads from a {@link XMLEventReader}.\r\n * Useful because the StAX {@code XMLInputFactory} allows one to create an\r\n * event reader from a stream reader, but not vice-versa.\r\n * @return a stream reader that reads from an event reader\r\n */\r\npublic static XMLStreamReader createEventStreamReader(XMLEventReader eventReader) throws XMLStreamException {\r\n    return new XMLEventStreamReader(eventReader);\r\n}\n/**\r\n * Return a {@link XMLStreamWriter} that writes to a {@link XMLEventWriter}.\r\n * @return a stream writer that writes to an event writer\r\n * @since 3.2\r\n */\r\npublic static XMLStreamWriter createEventStreamWriter(XMLEventWriter eventWriter) {\r\n    return new XMLEventStreamWriter(eventWriter, XMLEventFactory.newFactory());\r\n}\n/**\r\n * Return a {@link XMLStreamWriter} that writes to a {@link XMLEventWriter}.\r\n * @return a stream writer that writes to an event writer\r\n * @since 3.0.5\r\n */\r\npublic static XMLStreamWriter createEventStreamWriter(XMLEventWriter eventWriter, XMLEventFactory eventFactory) {\r\n    return new XMLEventStreamWriter(eventWriter, eventFactory);\r\n}",
    "comment": "\n * Convenience methods for working with the StAX API. Partly historic due to JAXP 1.3\n * compatibility; as of Spring 4.0, relying on JAXP 1.4 as included in JDK 1.6 and higher.\n *\n * <p>In particular, methods for using StAX ({@code javax.xml.stream}) in combination with\n * the TrAX API ({@code javax.xml.transform}), and converting StAX readers/writers into SAX\n * readers/handlers and vice-versa.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @since 3.0\n "
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtils#createDefensiveInputFactory()",
    "entityType": "method",
    "code": "/**\r\n * Create an {@link XMLInputFactory} with Spring's defensive setup,\r\n * i.e. no support for the resolution of DTDs and external entities.\r\n * @return a new defensively initialized input factory instance to use\r\n * @since 5.0\r\n */\r\npublic static XMLInputFactory createDefensiveInputFactory() {\r\n    return createDefensiveInputFactory(XMLInputFactory::newInstance);\r\n}",
    "comment": "\n\t * Create an {@link XMLInputFactory} with Spring's defensive setup,\n\t * i.e. no support for the resolution of DTDs and external entities.\n\t * @return a new defensively initialized input factory instance to use\n\t * @since 5.0\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtils#createDefensiveInputFactory(Supplier<T>)",
    "entityType": "method",
    "code": "/**\r\n * Variant of {@link #createDefensiveInputFactory()} with a custom instance.\r\n * @param instanceSupplier supplier for the input factory instance\r\n * @return a new defensively initialized input factory instance to use\r\n * @since 5.0.12\r\n */\r\npublic static <T extends XMLInputFactory> T createDefensiveInputFactory(Supplier<T> instanceSupplier) {\r\n    T inputFactory = instanceSupplier.get();\r\n    inputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);\r\n    inputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\r\n    inputFactory.setXMLResolver(NO_OP_XML_RESOLVER);\r\n    return inputFactory;\r\n}",
    "comment": "\n\t * Variant of {@link #createDefensiveInputFactory()} with a custom instance.\n\t * @param instanceSupplier supplier for the input factory instance\n\t * @return a new defensively initialized input factory instance to use\n\t * @since 5.0.12\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtils#createStaxSource(XMLStreamReader)",
    "entityType": "method",
    "code": "/**\r\n * Create a JAXP 1.4 {@link StAXSource} for the given {@link XMLStreamReader}.\r\n * @param streamReader the StAX stream reader\r\n * @return a source wrapping the {@code streamReader}\r\n */\r\npublic static Source createStaxSource(XMLStreamReader streamReader) {\r\n    return new StAXSource(streamReader);\r\n}",
    "comment": "\n\t * Create a JAXP 1.4 {@link StAXSource} for the given {@link XMLStreamReader}.\n\t * @param streamReader the StAX stream reader\n\t * @return a source wrapping the {@code streamReader}\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtils#createStaxSource(XMLEventReader)",
    "entityType": "method",
    "code": "/**\r\n * Create a JAXP 1.4 {@link StAXSource} for the given {@link XMLEventReader}.\r\n * @param eventReader the StAX event reader\r\n * @return a source wrapping the {@code eventReader}\r\n */\r\npublic static Source createStaxSource(XMLEventReader eventReader) throws XMLStreamException {\r\n    return new StAXSource(eventReader);\r\n}",
    "comment": "\n\t * Create a JAXP 1.4 {@link StAXSource} for the given {@link XMLEventReader}.\n\t * @param eventReader the StAX event reader\n\t * @return a source wrapping the {@code eventReader}\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtils#createCustomStaxSource(XMLStreamReader)",
    "entityType": "method",
    "code": "/**\r\n * Create a custom, non-JAXP 1.4 StAX {@link Source} for the given {@link XMLStreamReader}.\r\n * @param streamReader the StAX stream reader\r\n * @return a source wrapping the {@code streamReader}\r\n */\r\npublic static Source createCustomStaxSource(XMLStreamReader streamReader) {\r\n    return new StaxSource(streamReader);\r\n}",
    "comment": "\n\t * Create a custom, non-JAXP 1.4 StAX {@link Source} for the given {@link XMLStreamReader}.\n\t * @param streamReader the StAX stream reader\n\t * @return a source wrapping the {@code streamReader}\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtils#createCustomStaxSource(XMLEventReader)",
    "entityType": "method",
    "code": "/**\r\n * Create a custom, non-JAXP 1.4 StAX {@link Source} for the given {@link XMLEventReader}.\r\n * @param eventReader the StAX event reader\r\n * @return a source wrapping the {@code eventReader}\r\n */\r\npublic static Source createCustomStaxSource(XMLEventReader eventReader) {\r\n    return new StaxSource(eventReader);\r\n}",
    "comment": "\n\t * Create a custom, non-JAXP 1.4 StAX {@link Source} for the given {@link XMLEventReader}.\n\t * @param eventReader the StAX event reader\n\t * @return a source wrapping the {@code eventReader}\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtils#isStaxSource(Source)",
    "entityType": "method",
    "code": "/**\r\n * Indicate whether the given {@link Source} is a JAXP 1.4 StAX Source or\r\n * custom StAX Source.\r\n * @return {@code true} if {@code source} is a JAXP 1.4 {@link StAXSource} or\r\n * custom StAX Source; {@code false} otherwise\r\n */\r\npublic static boolean isStaxSource(Source source) {\r\n    return (source instanceof StAXSource || source instanceof StaxSource);\r\n}",
    "comment": "\n\t * Indicate whether the given {@link Source} is a JAXP 1.4 StAX Source or\n\t * custom StAX Source.\n\t * @return {@code true} if {@code source} is a JAXP 1.4 {@link StAXSource} or\n\t * custom StAX Source; {@code false} otherwise\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtils#getXMLStreamReader(Source)",
    "entityType": "method",
    "code": "/**\r\n * Return the {@link XMLStreamReader} for the given StAX Source.\r\n * @param source a JAXP 1.4 {@link StAXSource}\r\n * @return the {@link XMLStreamReader}\r\n * @throws IllegalArgumentException if {@code source} isn't a JAXP 1.4 {@link StAXSource}\r\n * or custom StAX Source\r\n */\r\n@Nullable\r\npublic static XMLStreamReader getXMLStreamReader(Source source) {\r\n    if (source instanceof StAXSource stAXSource) {\r\n        return stAXSource.getXMLStreamReader();\r\n    } else if (source instanceof StaxSource staxSource) {\r\n        return staxSource.getXMLStreamReader();\r\n    } else {\r\n        throw new IllegalArgumentException(\"Source '\" + source + \"' is neither StaxSource nor StAXSource\");\r\n    }\r\n}",
    "comment": "\n\t * Return the {@link XMLStreamReader} for the given StAX Source.\n\t * @param source a JAXP 1.4 {@link StAXSource}\n\t * @return the {@link XMLStreamReader}\n\t * @throws IllegalArgumentException if {@code source} isn't a JAXP 1.4 {@link StAXSource}\n\t * or custom StAX Source\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtils#getXMLEventReader(Source)",
    "entityType": "method",
    "code": "/**\r\n * Return the {@link XMLEventReader} for the given StAX Source.\r\n * @param source a JAXP 1.4 {@link StAXSource}\r\n * @return the {@link XMLEventReader}\r\n * @throws IllegalArgumentException if {@code source} isn't a JAXP 1.4 {@link StAXSource}\r\n * or custom StAX Source\r\n */\r\n@Nullable\r\npublic static XMLEventReader getXMLEventReader(Source source) {\r\n    if (source instanceof StAXSource stAXSource) {\r\n        return stAXSource.getXMLEventReader();\r\n    } else if (source instanceof StaxSource staxSource) {\r\n        return staxSource.getXMLEventReader();\r\n    } else {\r\n        throw new IllegalArgumentException(\"Source '\" + source + \"' is neither StaxSource nor StAXSource\");\r\n    }\r\n}",
    "comment": "\n\t * Return the {@link XMLEventReader} for the given StAX Source.\n\t * @param source a JAXP 1.4 {@link StAXSource}\n\t * @return the {@link XMLEventReader}\n\t * @throws IllegalArgumentException if {@code source} isn't a JAXP 1.4 {@link StAXSource}\n\t * or custom StAX Source\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtils#createStaxResult(XMLStreamWriter)",
    "entityType": "method",
    "code": "/**\r\n * Create a JAXP 1.4 {@link StAXResult} for the given {@link XMLStreamWriter}.\r\n * @param streamWriter the StAX stream writer\r\n * @return a result wrapping the {@code streamWriter}\r\n */\r\npublic static Result createStaxResult(XMLStreamWriter streamWriter) {\r\n    return new StAXResult(streamWriter);\r\n}",
    "comment": "\n\t * Create a JAXP 1.4 {@link StAXResult} for the given {@link XMLStreamWriter}.\n\t * @param streamWriter the StAX stream writer\n\t * @return a result wrapping the {@code streamWriter}\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtils#createStaxResult(XMLEventWriter)",
    "entityType": "method",
    "code": "/**\r\n * Create a JAXP 1.4 {@link StAXResult} for the given {@link XMLEventWriter}.\r\n * @param eventWriter the StAX event writer\r\n * @return a result wrapping {@code streamReader}\r\n */\r\npublic static Result createStaxResult(XMLEventWriter eventWriter) {\r\n    return new StAXResult(eventWriter);\r\n}",
    "comment": "\n\t * Create a JAXP 1.4 {@link StAXResult} for the given {@link XMLEventWriter}.\n\t * @param eventWriter the StAX event writer\n\t * @return a result wrapping {@code streamReader}\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtils#createCustomStaxResult(XMLStreamWriter)",
    "entityType": "method",
    "code": "/**\r\n * Create a custom, non-JAXP 1.4 StAX {@link Result} for the given {@link XMLStreamWriter}.\r\n * @param streamWriter the StAX stream writer\r\n * @return a source wrapping the {@code streamWriter}\r\n */\r\npublic static Result createCustomStaxResult(XMLStreamWriter streamWriter) {\r\n    return new StaxResult(streamWriter);\r\n}",
    "comment": "\n\t * Create a custom, non-JAXP 1.4 StAX {@link Result} for the given {@link XMLStreamWriter}.\n\t * @param streamWriter the StAX stream writer\n\t * @return a source wrapping the {@code streamWriter}\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtils#createCustomStaxResult(XMLEventWriter)",
    "entityType": "method",
    "code": "/**\r\n * Create a custom, non-JAXP 1.4 StAX {@link Result} for the given {@link XMLEventWriter}.\r\n * @param eventWriter the StAX event writer\r\n * @return a source wrapping the {@code eventWriter}\r\n */\r\npublic static Result createCustomStaxResult(XMLEventWriter eventWriter) {\r\n    return new StaxResult(eventWriter);\r\n}",
    "comment": "\n\t * Create a custom, non-JAXP 1.4 StAX {@link Result} for the given {@link XMLEventWriter}.\n\t * @param eventWriter the StAX event writer\n\t * @return a source wrapping the {@code eventWriter}\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtils#isStaxResult(Result)",
    "entityType": "method",
    "code": "/**\r\n * Indicate whether the given {@link Result} is a JAXP 1.4 StAX Result or\r\n * custom StAX Result.\r\n * @return {@code true} if {@code result} is a JAXP 1.4 {@link StAXResult} or\r\n * custom StAX Result; {@code false} otherwise\r\n */\r\npublic static boolean isStaxResult(Result result) {\r\n    return (result instanceof StAXResult || result instanceof StaxResult);\r\n}",
    "comment": "\n\t * Indicate whether the given {@link Result} is a JAXP 1.4 StAX Result or\n\t * custom StAX Result.\n\t * @return {@code true} if {@code result} is a JAXP 1.4 {@link StAXResult} or\n\t * custom StAX Result; {@code false} otherwise\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtils#getXMLStreamWriter(Result)",
    "entityType": "method",
    "code": "/**\r\n * Return the {@link XMLStreamWriter} for the given StAX Result.\r\n * @param result a JAXP 1.4 {@link StAXResult}\r\n * @return the {@link XMLStreamReader}\r\n * @throws IllegalArgumentException if {@code source} isn't a JAXP 1.4 {@link StAXResult}\r\n * or custom StAX Result\r\n */\r\n@Nullable\r\npublic static XMLStreamWriter getXMLStreamWriter(Result result) {\r\n    if (result instanceof StAXResult stAXResult) {\r\n        return stAXResult.getXMLStreamWriter();\r\n    } else if (result instanceof StaxResult staxResult) {\r\n        return staxResult.getXMLStreamWriter();\r\n    } else {\r\n        throw new IllegalArgumentException(\"Result '\" + result + \"' is neither StaxResult nor StAXResult\");\r\n    }\r\n}",
    "comment": "\n\t * Return the {@link XMLStreamWriter} for the given StAX Result.\n\t * @param result a JAXP 1.4 {@link StAXResult}\n\t * @return the {@link XMLStreamReader}\n\t * @throws IllegalArgumentException if {@code source} isn't a JAXP 1.4 {@link StAXResult}\n\t * or custom StAX Result\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtils#getXMLEventWriter(Result)",
    "entityType": "method",
    "code": "/**\r\n * Return the {@link XMLEventWriter} for the given StAX Result.\r\n * @param result a JAXP 1.4 {@link StAXResult}\r\n * @return the {@link XMLStreamReader}\r\n * @throws IllegalArgumentException if {@code source} isn't a JAXP 1.4 {@link StAXResult}\r\n * or custom StAX Result\r\n */\r\n@Nullable\r\npublic static XMLEventWriter getXMLEventWriter(Result result) {\r\n    if (result instanceof StAXResult stAXResult) {\r\n        return stAXResult.getXMLEventWriter();\r\n    } else if (result instanceof StaxResult staxResult) {\r\n        return staxResult.getXMLEventWriter();\r\n    } else {\r\n        throw new IllegalArgumentException(\"Result '\" + result + \"' is neither StaxResult nor StAXResult\");\r\n    }\r\n}",
    "comment": "\n\t * Return the {@link XMLEventWriter} for the given StAX Result.\n\t * @param result a JAXP 1.4 {@link StAXResult}\n\t * @return the {@link XMLStreamReader}\n\t * @throws IllegalArgumentException if {@code source} isn't a JAXP 1.4 {@link StAXResult}\n\t * or custom StAX Result\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtils#createXMLEventReader(List<XMLEvent>)",
    "entityType": "method",
    "code": "/**\r\n * Create a {@link XMLEventReader} from the given list of {@link XMLEvent}.\r\n * @param events the list of {@link XMLEvent XMLEvents}.\r\n * @return an {@code XMLEventReader} that reads from the given events\r\n * @since 5.0\r\n */\r\npublic static XMLEventReader createXMLEventReader(List<XMLEvent> events) {\r\n    return new ListBasedXMLEventReader(events);\r\n}",
    "comment": "\n\t * Create a {@link XMLEventReader} from the given list of {@link XMLEvent}.\n\t * @param events the list of {@link XMLEvent XMLEvents}.\n\t * @return an {@code XMLEventReader} that reads from the given events\n\t * @since 5.0\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtils#createContentHandler(XMLStreamWriter)",
    "entityType": "method",
    "code": "/**\r\n * Create a SAX {@link ContentHandler} that writes to the given StAX {@link XMLStreamWriter}.\r\n * @param streamWriter the StAX stream writer\r\n * @return a content handler writing to the {@code streamWriter}\r\n */\r\npublic static ContentHandler createContentHandler(XMLStreamWriter streamWriter) {\r\n    return new StaxStreamHandler(streamWriter);\r\n}",
    "comment": "\n\t * Create a SAX {@link ContentHandler} that writes to the given StAX {@link XMLStreamWriter}.\n\t * @param streamWriter the StAX stream writer\n\t * @return a content handler writing to the {@code streamWriter}\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtils#createContentHandler(XMLEventWriter)",
    "entityType": "method",
    "code": "/**\r\n * Create a SAX {@link ContentHandler} that writes events to the given StAX {@link XMLEventWriter}.\r\n * @param eventWriter the StAX event writer\r\n * @return a content handler writing to the {@code eventWriter}\r\n */\r\npublic static ContentHandler createContentHandler(XMLEventWriter eventWriter) {\r\n    return new StaxEventHandler(eventWriter);\r\n}",
    "comment": "\n\t * Create a SAX {@link ContentHandler} that writes events to the given StAX {@link XMLEventWriter}.\n\t * @param eventWriter the StAX event writer\n\t * @return a content handler writing to the {@code eventWriter}\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtils#createXMLReader(XMLStreamReader)",
    "entityType": "method",
    "code": "/**\r\n * Create a SAX {@link XMLReader} that reads from the given StAX {@link XMLStreamReader}.\r\n * @param streamReader the StAX stream reader\r\n * @return a XMLReader reading from the {@code streamWriter}\r\n */\r\npublic static XMLReader createXMLReader(XMLStreamReader streamReader) {\r\n    return new StaxStreamXMLReader(streamReader);\r\n}",
    "comment": "\n\t * Create a SAX {@link XMLReader} that reads from the given StAX {@link XMLStreamReader}.\n\t * @param streamReader the StAX stream reader\n\t * @return a XMLReader reading from the {@code streamWriter}\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtils#createXMLReader(XMLEventReader)",
    "entityType": "method",
    "code": "/**\r\n * Create a SAX {@link XMLReader} that reads from the given StAX {@link XMLEventReader}.\r\n * @param eventReader the StAX event reader\r\n * @return a XMLReader reading from the {@code eventWriter}\r\n */\r\npublic static XMLReader createXMLReader(XMLEventReader eventReader) {\r\n    return new StaxEventXMLReader(eventReader);\r\n}",
    "comment": "\n\t * Create a SAX {@link XMLReader} that reads from the given StAX {@link XMLEventReader}.\n\t * @param eventReader the StAX event reader\n\t * @return a XMLReader reading from the {@code eventWriter}\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtils#createEventStreamReader(XMLEventReader)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@link XMLStreamReader} that reads from a {@link XMLEventReader}.\r\n * Useful because the StAX {@code XMLInputFactory} allows one to create an\r\n * event reader from a stream reader, but not vice-versa.\r\n * @return a stream reader that reads from an event reader\r\n */\r\npublic static XMLStreamReader createEventStreamReader(XMLEventReader eventReader) throws XMLStreamException {\r\n    return new XMLEventStreamReader(eventReader);\r\n}",
    "comment": "\n\t * Return a {@link XMLStreamReader} that reads from a {@link XMLEventReader}.\n\t * Useful because the StAX {@code XMLInputFactory} allows one to create an\n\t * event reader from a stream reader, but not vice-versa.\n\t * @return a stream reader that reads from an event reader\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtils#createEventStreamWriter(XMLEventWriter)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@link XMLStreamWriter} that writes to a {@link XMLEventWriter}.\r\n * @return a stream writer that writes to an event writer\r\n * @since 3.2\r\n */\r\npublic static XMLStreamWriter createEventStreamWriter(XMLEventWriter eventWriter) {\r\n    return new XMLEventStreamWriter(eventWriter, XMLEventFactory.newFactory());\r\n}",
    "comment": "\n\t * Return a {@link XMLStreamWriter} that writes to a {@link XMLEventWriter}.\n\t * @return a stream writer that writes to an event writer\n\t * @since 3.2\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtils#createEventStreamWriter(XMLEventWriter,XMLEventFactory)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@link XMLStreamWriter} that writes to a {@link XMLEventWriter}.\r\n * @return a stream writer that writes to an event writer\r\n * @since 3.0.5\r\n */\r\npublic static XMLStreamWriter createEventStreamWriter(XMLEventWriter eventWriter, XMLEventFactory eventFactory) {\r\n    return new XMLEventStreamWriter(eventWriter, eventFactory);\r\n}",
    "comment": "\n\t * Return a {@link XMLStreamWriter} that writes to a {@link XMLEventWriter}.\n\t * @return a stream writer that writes to an event writer\n\t * @since 3.0.5\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.TransformerUtils",
    "entityType": "class",
    "code": "/**\r\n * The indent amount of characters if {@link #enableIndenting indenting is enabled}.\r\n * <p>Defaults to \"2\".\r\n */\r\npublic static final int DEFAULT_INDENT_AMOUNT = 2;\n/**\r\n * Enable indenting for the supplied {@link javax.xml.transform.Transformer}.\r\n * <p>If the underlying XSLT engine is Xalan, then the special output key {@code indent-amount}\r\n * will be also be set to a value of {@link #DEFAULT_INDENT_AMOUNT} characters.\r\n * @param transformer the target transformer\r\n * @see javax.xml.transform.Transformer#setOutputProperty(String, String)\r\n * @see javax.xml.transform.OutputKeys#INDENT\r\n */\r\npublic static void enableIndenting(Transformer transformer) {\r\n    enableIndenting(transformer, DEFAULT_INDENT_AMOUNT);\r\n}\n/**\r\n * Enable indenting for the supplied {@link javax.xml.transform.Transformer}.\r\n * <p>If the underlying XSLT engine is Xalan, then the special output key {@code indent-amount}\r\n * will be also be set to a value of {@link #DEFAULT_INDENT_AMOUNT} characters.\r\n * @param transformer the target transformer\r\n * @param indentAmount the size of the indent (2 characters, 3 characters, etc.)\r\n * @see javax.xml.transform.Transformer#setOutputProperty(String, String)\r\n * @see javax.xml.transform.OutputKeys#INDENT\r\n */\r\npublic static void enableIndenting(Transformer transformer, int indentAmount) {\r\n    Assert.notNull(transformer, \"Transformer must not be null\");\r\n    if (indentAmount < 0) {\r\n        throw new IllegalArgumentException(\"Invalid indent amount (must not be less than zero): \" + indentAmount);\r\n    }\r\n    transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\r\n    try {\r\n        // Xalan-specific, but this is the most common XSLT engine in any case\r\n        transformer.setOutputProperty(\"{http://xml.apache.org/xalan}indent-amount\", String.valueOf(indentAmount));\r\n    } catch (IllegalArgumentException ignored) ;\r\n}\n/**\r\n * Disable indenting for the supplied {@link javax.xml.transform.Transformer}.\r\n * @param transformer the target transformer\r\n * @see javax.xml.transform.OutputKeys#INDENT\r\n */\r\npublic static void disableIndenting(Transformer transformer) {\r\n    Assert.notNull(transformer, \"Transformer must not be null\");\r\n    transformer.setOutputProperty(OutputKeys.INDENT, \"no\");\r\n}",
    "comment": "\n * Contains common behavior relating to {@link javax.xml.transform.Transformer Transformers}\n * and the {@code javax.xml.transform} package in general.\n *\n * @author Rick Evans\n * @author Juergen Hoeller\n * @since 2.5.5\n "
  },
  {
    "entityId": "org.springframework.util.xml.TransformerUtils#enableIndenting(Transformer)",
    "entityType": "method",
    "code": "/**\r\n * Enable indenting for the supplied {@link javax.xml.transform.Transformer}.\r\n * <p>If the underlying XSLT engine is Xalan, then the special output key {@code indent-amount}\r\n * will be also be set to a value of {@link #DEFAULT_INDENT_AMOUNT} characters.\r\n * @param transformer the target transformer\r\n * @see javax.xml.transform.Transformer#setOutputProperty(String, String)\r\n * @see javax.xml.transform.OutputKeys#INDENT\r\n */\r\npublic static void enableIndenting(Transformer transformer) {\r\n    enableIndenting(transformer, DEFAULT_INDENT_AMOUNT);\r\n}",
    "comment": "\n\t * Enable indenting for the supplied {@link javax.xml.transform.Transformer}.\n\t * <p>If the underlying XSLT engine is Xalan, then the special output key {@code indent-amount}\n\t * will be also be set to a value of {@link #DEFAULT_INDENT_AMOUNT} characters.\n\t * @param transformer the target transformer\n\t * @see javax.xml.transform.Transformer#setOutputProperty(String, String)\n\t * @see javax.xml.transform.OutputKeys#INDENT\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.TransformerUtils#enableIndenting(Transformer,int)",
    "entityType": "method",
    "code": "/**\r\n * Enable indenting for the supplied {@link javax.xml.transform.Transformer}.\r\n * <p>If the underlying XSLT engine is Xalan, then the special output key {@code indent-amount}\r\n * will be also be set to a value of {@link #DEFAULT_INDENT_AMOUNT} characters.\r\n * @param transformer the target transformer\r\n * @param indentAmount the size of the indent (2 characters, 3 characters, etc.)\r\n * @see javax.xml.transform.Transformer#setOutputProperty(String, String)\r\n * @see javax.xml.transform.OutputKeys#INDENT\r\n */\r\npublic static void enableIndenting(Transformer transformer, int indentAmount) {\r\n    Assert.notNull(transformer, \"Transformer must not be null\");\r\n    if (indentAmount < 0) {\r\n        throw new IllegalArgumentException(\"Invalid indent amount (must not be less than zero): \" + indentAmount);\r\n    }\r\n    transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\r\n    try {\r\n        // Xalan-specific, but this is the most common XSLT engine in any case\r\n        transformer.setOutputProperty(\"{http://xml.apache.org/xalan}indent-amount\", String.valueOf(indentAmount));\r\n    } catch (IllegalArgumentException ignored) ;\r\n}",
    "comment": "\n\t * Enable indenting for the supplied {@link javax.xml.transform.Transformer}.\n\t * <p>If the underlying XSLT engine is Xalan, then the special output key {@code indent-amount}\n\t * will be also be set to a value of {@link #DEFAULT_INDENT_AMOUNT} characters.\n\t * @param transformer the target transformer\n\t * @param indentAmount the size of the indent (2 characters, 3 characters, etc.)\n\t * @see javax.xml.transform.Transformer#setOutputProperty(String, String)\n\t * @see javax.xml.transform.OutputKeys#INDENT\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.TransformerUtils#disableIndenting(Transformer)",
    "entityType": "method",
    "code": "/**\r\n * Disable indenting for the supplied {@link javax.xml.transform.Transformer}.\r\n * @param transformer the target transformer\r\n * @see javax.xml.transform.OutputKeys#INDENT\r\n */\r\npublic static void disableIndenting(Transformer transformer) {\r\n    Assert.notNull(transformer, \"Transformer must not be null\");\r\n    transformer.setOutputProperty(OutputKeys.INDENT, \"no\");\r\n}",
    "comment": "\n\t * Disable indenting for the supplied {@link javax.xml.transform.Transformer}.\n\t * @param transformer the target transformer\n\t * @see javax.xml.transform.OutputKeys#INDENT\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReader",
    "entityType": "class",
    "code": "private XMLEvent event;\nprivate final XMLEventReader eventReader;\npublic XMLEventStreamReader(XMLEventReader eventReader) throws XMLStreamException {\r\n    this.eventReader = eventReader;\r\n    this.event = eventReader.nextEvent();\r\n}\n@Override\r\npublic QName getName() {\r\n    if (this.event.isStartElement()) {\r\n        return this.event.asStartElement().getName();\r\n    } else if (this.event.isEndElement()) {\r\n        return this.event.asEndElement().getName();\r\n    } else {\r\n        throw new IllegalStateException();\r\n    }\r\n}\n@Override\r\npublic Location getLocation() {\r\n    return this.event.getLocation();\r\n}\n@Override\r\npublic int getEventType() {\r\n    return this.event.getEventType();\r\n}\n@Override\r\n@Nullable\r\npublic String getVersion() {\r\n    if (this.event.isStartDocument()) {\r\n        return ((StartDocument) this.event).getVersion();\r\n    } else {\r\n        return null;\r\n    }\r\n}\n@Override\r\npublic Object getProperty(String name) throws IllegalArgumentException {\r\n    return this.eventReader.getProperty(name);\r\n}\n@Override\r\npublic boolean isStandalone() {\r\n    if (this.event.isStartDocument()) {\r\n        return ((StartDocument) this.event).isStandalone();\r\n    } else {\r\n        throw new IllegalStateException();\r\n    }\r\n}\n@Override\r\npublic boolean standaloneSet() {\r\n    if (this.event.isStartDocument()) {\r\n        return ((StartDocument) this.event).standaloneSet();\r\n    } else {\r\n        throw new IllegalStateException();\r\n    }\r\n}\n@Override\r\n@Nullable\r\npublic String getEncoding() {\r\n    return null;\r\n}\n@Override\r\n@Nullable\r\npublic String getCharacterEncodingScheme() {\r\n    return null;\r\n}\n@Override\r\npublic String getPITarget() {\r\n    if (this.event.isProcessingInstruction()) {\r\n        return ((ProcessingInstruction) this.event).getTarget();\r\n    } else {\r\n        throw new IllegalStateException();\r\n    }\r\n}\n@Override\r\npublic String getPIData() {\r\n    if (this.event.isProcessingInstruction()) {\r\n        return ((ProcessingInstruction) this.event).getData();\r\n    } else {\r\n        throw new IllegalStateException();\r\n    }\r\n}\n@Override\r\npublic int getTextStart() {\r\n    return 0;\r\n}\n@Override\r\npublic String getText() {\r\n    if (this.event.isCharacters()) {\r\n        return this.event.asCharacters().getData();\r\n    } else if (this.event.getEventType() == XMLStreamConstants.COMMENT) {\r\n        return ((Comment) this.event).getText();\r\n    } else {\r\n        throw new IllegalStateException();\r\n    }\r\n}\n@Override\r\n@SuppressWarnings(\"rawtypes\")\r\npublic int getAttributeCount() {\r\n    if (!this.event.isStartElement()) {\r\n        throw new IllegalStateException();\r\n    }\r\n    Iterator attributes = this.event.asStartElement().getAttributes();\r\n    return countIterator(attributes);\r\n}\n@Override\r\npublic boolean isAttributeSpecified(int index) {\r\n    return getAttribute(index).isSpecified();\r\n}\n@Override\r\npublic QName getAttributeName(int index) {\r\n    return getAttribute(index).getName();\r\n}\n@Override\r\npublic String getAttributeType(int index) {\r\n    return getAttribute(index).getDTDType();\r\n}\n@Override\r\npublic String getAttributeValue(int index) {\r\n    return getAttribute(index).getValue();\r\n}\n@SuppressWarnings(\"rawtypes\")\r\nprivate Attribute getAttribute(int index) {\r\n    if (!this.event.isStartElement()) {\r\n        throw new IllegalStateException();\r\n    }\r\n    int count = 0;\r\n    Iterator attributes = this.event.asStartElement().getAttributes();\r\n    while (attributes.hasNext()) {\r\n        Attribute attribute = (Attribute) attributes.next();\r\n        if (count == index) {\r\n            return attribute;\r\n        } else {\r\n            count++;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException();\r\n}\n@Override\r\npublic NamespaceContext getNamespaceContext() {\r\n    if (this.event.isStartElement()) {\r\n        return this.event.asStartElement().getNamespaceContext();\r\n    } else {\r\n        throw new IllegalStateException();\r\n    }\r\n}\n@Override\r\n@SuppressWarnings(\"rawtypes\")\r\npublic int getNamespaceCount() {\r\n    Iterator namespaces;\r\n    if (this.event.isStartElement()) {\r\n        namespaces = this.event.asStartElement().getNamespaces();\r\n    } else if (this.event.isEndElement()) {\r\n        namespaces = this.event.asEndElement().getNamespaces();\r\n    } else {\r\n        throw new IllegalStateException();\r\n    }\r\n    return countIterator(namespaces);\r\n}\n@Override\r\npublic String getNamespacePrefix(int index) {\r\n    return getNamespace(index).getPrefix();\r\n}\n@Override\r\npublic String getNamespaceURI(int index) {\r\n    return getNamespace(index).getNamespaceURI();\r\n}\n@SuppressWarnings(\"rawtypes\")\r\nprivate Namespace getNamespace(int index) {\r\n    Iterator namespaces;\r\n    if (this.event.isStartElement()) {\r\n        namespaces = this.event.asStartElement().getNamespaces();\r\n    } else if (this.event.isEndElement()) {\r\n        namespaces = this.event.asEndElement().getNamespaces();\r\n    } else {\r\n        throw new IllegalStateException();\r\n    }\r\n    int count = 0;\r\n    while (namespaces.hasNext()) {\r\n        Namespace namespace = (Namespace) namespaces.next();\r\n        if (count == index) {\r\n            return namespace;\r\n        } else {\r\n            count++;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException();\r\n}\n@Override\r\npublic int next() throws XMLStreamException {\r\n    this.event = this.eventReader.nextEvent();\r\n    return this.event.getEventType();\r\n}\n@Override\r\npublic void close() throws XMLStreamException {\r\n    this.eventReader.close();\r\n}\n@SuppressWarnings(\"rawtypes\")\r\nprivate static int countIterator(Iterator iterator) {\r\n    int count = 0;\r\n    while (iterator.hasNext()) {\r\n        iterator.next();\r\n        count++;\r\n    }\r\n    return count;\r\n}",
    "comment": "\n * Implementation of the {@link javax.xml.stream.XMLStreamReader} interface that wraps a\n * {@link XMLEventReader}. Useful because the StAX {@link javax.xml.stream.XMLInputFactory}\n * allows one to create an event reader from a stream reader, but not vice-versa.\n *\n * @author Arjen Poutsma\n * @since 3.0\n * @see StaxUtils#createEventStreamReader(javax.xml.stream.XMLEventReader)\n "
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReader#getName()",
    "entityType": "method",
    "code": "@Override\r\npublic QName getName() {\r\n    if (this.event.isStartElement()) {\r\n        return this.event.asStartElement().getName();\r\n    } else if (this.event.isEndElement()) {\r\n        return this.event.asEndElement().getName();\r\n    } else {\r\n        throw new IllegalStateException();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReader#getLocation()",
    "entityType": "method",
    "code": "@Override\r\npublic Location getLocation() {\r\n    return this.event.getLocation();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReader#getEventType()",
    "entityType": "method",
    "code": "@Override\r\npublic int getEventType() {\r\n    return this.event.getEventType();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReader#getVersion()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic String getVersion() {\r\n    if (this.event.isStartDocument()) {\r\n        return ((StartDocument) this.event).getVersion();\r\n    } else {\r\n        return null;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReader#getProperty(String)",
    "entityType": "method",
    "code": "@Override\r\npublic Object getProperty(String name) throws IllegalArgumentException {\r\n    return this.eventReader.getProperty(name);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReader#isStandalone()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isStandalone() {\r\n    if (this.event.isStartDocument()) {\r\n        return ((StartDocument) this.event).isStandalone();\r\n    } else {\r\n        throw new IllegalStateException();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReader#standaloneSet()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean standaloneSet() {\r\n    if (this.event.isStartDocument()) {\r\n        return ((StartDocument) this.event).standaloneSet();\r\n    } else {\r\n        throw new IllegalStateException();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReader#getEncoding()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic String getEncoding() {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReader#getCharacterEncodingScheme()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic String getCharacterEncodingScheme() {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReader#getPITarget()",
    "entityType": "method",
    "code": "@Override\r\npublic String getPITarget() {\r\n    if (this.event.isProcessingInstruction()) {\r\n        return ((ProcessingInstruction) this.event).getTarget();\r\n    } else {\r\n        throw new IllegalStateException();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReader#getPIData()",
    "entityType": "method",
    "code": "@Override\r\npublic String getPIData() {\r\n    if (this.event.isProcessingInstruction()) {\r\n        return ((ProcessingInstruction) this.event).getData();\r\n    } else {\r\n        throw new IllegalStateException();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReader#getTextStart()",
    "entityType": "method",
    "code": "@Override\r\npublic int getTextStart() {\r\n    return 0;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReader#getText()",
    "entityType": "method",
    "code": "@Override\r\npublic String getText() {\r\n    if (this.event.isCharacters()) {\r\n        return this.event.asCharacters().getData();\r\n    } else if (this.event.getEventType() == XMLStreamConstants.COMMENT) {\r\n        return ((Comment) this.event).getText();\r\n    } else {\r\n        throw new IllegalStateException();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReader#getAttributeCount()",
    "entityType": "method",
    "code": "@Override\r\n@SuppressWarnings(\"rawtypes\")\r\npublic int getAttributeCount() {\r\n    if (!this.event.isStartElement()) {\r\n        throw new IllegalStateException();\r\n    }\r\n    Iterator attributes = this.event.asStartElement().getAttributes();\r\n    return countIterator(attributes);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReader#isAttributeSpecified(int)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isAttributeSpecified(int index) {\r\n    return getAttribute(index).isSpecified();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReader#getAttributeName(int)",
    "entityType": "method",
    "code": "@Override\r\npublic QName getAttributeName(int index) {\r\n    return getAttribute(index).getName();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReader#getAttributeType(int)",
    "entityType": "method",
    "code": "@Override\r\npublic String getAttributeType(int index) {\r\n    return getAttribute(index).getDTDType();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReader#getAttributeValue(int)",
    "entityType": "method",
    "code": "@Override\r\npublic String getAttributeValue(int index) {\r\n    return getAttribute(index).getValue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReader#getAttribute(int)",
    "entityType": "method",
    "code": "@SuppressWarnings(\"rawtypes\")\r\nprivate Attribute getAttribute(int index) {\r\n    if (!this.event.isStartElement()) {\r\n        throw new IllegalStateException();\r\n    }\r\n    int count = 0;\r\n    Iterator attributes = this.event.asStartElement().getAttributes();\r\n    while (attributes.hasNext()) {\r\n        Attribute attribute = (Attribute) attributes.next();\r\n        if (count == index) {\r\n            return attribute;\r\n        } else {\r\n            count++;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReader#getNamespaceContext()",
    "entityType": "method",
    "code": "@Override\r\npublic NamespaceContext getNamespaceContext() {\r\n    if (this.event.isStartElement()) {\r\n        return this.event.asStartElement().getNamespaceContext();\r\n    } else {\r\n        throw new IllegalStateException();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReader#getNamespaceCount()",
    "entityType": "method",
    "code": "@Override\r\n@SuppressWarnings(\"rawtypes\")\r\npublic int getNamespaceCount() {\r\n    Iterator namespaces;\r\n    if (this.event.isStartElement()) {\r\n        namespaces = this.event.asStartElement().getNamespaces();\r\n    } else if (this.event.isEndElement()) {\r\n        namespaces = this.event.asEndElement().getNamespaces();\r\n    } else {\r\n        throw new IllegalStateException();\r\n    }\r\n    return countIterator(namespaces);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReader#getNamespacePrefix(int)",
    "entityType": "method",
    "code": "@Override\r\npublic String getNamespacePrefix(int index) {\r\n    return getNamespace(index).getPrefix();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReader#getNamespaceURI(int)",
    "entityType": "method",
    "code": "@Override\r\npublic String getNamespaceURI(int index) {\r\n    return getNamespace(index).getNamespaceURI();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReader#getNamespace(int)",
    "entityType": "method",
    "code": "@SuppressWarnings(\"rawtypes\")\r\nprivate Namespace getNamespace(int index) {\r\n    Iterator namespaces;\r\n    if (this.event.isStartElement()) {\r\n        namespaces = this.event.asStartElement().getNamespaces();\r\n    } else if (this.event.isEndElement()) {\r\n        namespaces = this.event.asEndElement().getNamespaces();\r\n    } else {\r\n        throw new IllegalStateException();\r\n    }\r\n    int count = 0;\r\n    while (namespaces.hasNext()) {\r\n        Namespace namespace = (Namespace) namespaces.next();\r\n        if (count == index) {\r\n            return namespace;\r\n        } else {\r\n            count++;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReader#next()",
    "entityType": "method",
    "code": "@Override\r\npublic int next() throws XMLStreamException {\r\n    this.event = this.eventReader.nextEvent();\r\n    return this.event.getEventType();\r\n}",
    "comment": ""
  }
]