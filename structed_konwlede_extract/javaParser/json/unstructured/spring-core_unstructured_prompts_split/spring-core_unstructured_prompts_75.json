[
  {
    "entityId": "org.springframework.util.Assert#isNull(Object,String)",
    "entityType": "method",
    "code": "/**\r\n * Assert that an object is {@code null}.\r\n * <pre class=\"code\">Assert.isNull(value, \"The value must be null\");</pre>\r\n * @param object the object to check\r\n * @param message the exception message to use if the assertion fails\r\n * @throws IllegalArgumentException if the object is not {@code null}\r\n */\r\n@Contract(\"!null, _ -> fail\")\r\npublic static void isNull(@Nullable Object object, String message) {\r\n    if (object != null) {\r\n        throw new IllegalArgumentException(message);\r\n    }\r\n}",
    "comment": "\n\t * Assert that an object is {@code null}.\n\t * <pre class=\"code\">Assert.isNull(value, \"The value must be null\");</pre>\n\t * @param object the object to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the object is not {@code null}\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#isNull(Object,Supplier<String>)",
    "entityType": "method",
    "code": "/**\r\n * Assert that an object is {@code null}.\r\n * <pre class=\"code\">\r\n * Assert.isNull(value, () -&gt; \"The value '\" + value + \"' must be null\");\r\n * </pre>\r\n * @param object the object to check\r\n * @param messageSupplier a supplier for the exception message to use if the\r\n * assertion fails\r\n * @throws IllegalArgumentException if the object is not {@code null}\r\n * @since 5.0\r\n */\r\n@Contract(\"!null, _ -> fail\")\r\npublic static void isNull(@Nullable Object object, Supplier<String> messageSupplier) {\r\n    if (object != null) {\r\n        throw new IllegalArgumentException(nullSafeGet(messageSupplier));\r\n    }\r\n}",
    "comment": "\n\t * Assert that an object is {@code null}.\n\t * <pre class=\"code\">\n\t * Assert.isNull(value, () -&gt; \"The value '\" + value + \"' must be null\");\n\t * </pre>\n\t * @param object the object to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the object is not {@code null}\n\t * @since 5.0\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#notNull(Object,String)",
    "entityType": "method",
    "code": "/**\r\n * Assert that an object is not {@code null}.\r\n * <pre class=\"code\">Assert.notNull(clazz, \"The class must not be null\");</pre>\r\n * @param object the object to check\r\n * @param message the exception message to use if the assertion fails\r\n * @throws IllegalArgumentException if the object is {@code null}\r\n */\r\n@Contract(\"null, _ -> fail\")\r\npublic static void notNull(@Nullable Object object, String message) {\r\n    if (object == null) {\r\n        throw new IllegalArgumentException(message);\r\n    }\r\n}",
    "comment": "\n\t * Assert that an object is not {@code null}.\n\t * <pre class=\"code\">Assert.notNull(clazz, \"The class must not be null\");</pre>\n\t * @param object the object to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the object is {@code null}\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#notNull(Object,Supplier<String>)",
    "entityType": "method",
    "code": "/**\r\n * Assert that an object is not {@code null}.\r\n * <pre class=\"code\">\r\n * Assert.notNull(entity.getId(),\r\n *     () -&gt; \"ID for entity \" + entity.getName() + \" must not be null\");\r\n * </pre>\r\n * @param object the object to check\r\n * @param messageSupplier a supplier for the exception message to use if the\r\n * assertion fails\r\n * @throws IllegalArgumentException if the object is {@code null}\r\n * @since 5.0\r\n */\r\n@Contract(\"null, _ -> fail\")\r\npublic static void notNull(@Nullable Object object, Supplier<String> messageSupplier) {\r\n    if (object == null) {\r\n        throw new IllegalArgumentException(nullSafeGet(messageSupplier));\r\n    }\r\n}",
    "comment": "\n\t * Assert that an object is not {@code null}.\n\t * <pre class=\"code\">\n\t * Assert.notNull(entity.getId(),\n\t *     () -&gt; \"ID for entity \" + entity.getName() + \" must not be null\");\n\t * </pre>\n\t * @param object the object to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the object is {@code null}\n\t * @since 5.0\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#hasLength(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Assert that the given String is not empty; that is,\r\n * it must not be {@code null} and not the empty String.\r\n * <pre class=\"code\">Assert.hasLength(name, \"Name must not be empty\");</pre>\r\n * @param text the String to check\r\n * @param message the exception message to use if the assertion fails\r\n * @throws IllegalArgumentException if the text is empty\r\n * @see StringUtils#hasLength\r\n */\r\n@Contract(\"null, _ -> fail\")\r\npublic static void hasLength(@Nullable String text, String message) {\r\n    if (!StringUtils.hasLength(text)) {\r\n        throw new IllegalArgumentException(message);\r\n    }\r\n}",
    "comment": "\n\t * Assert that the given String is not empty; that is,\n\t * it must not be {@code null} and not the empty String.\n\t * <pre class=\"code\">Assert.hasLength(name, \"Name must not be empty\");</pre>\n\t * @param text the String to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the text is empty\n\t * @see StringUtils#hasLength\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#hasLength(String,Supplier<String>)",
    "entityType": "method",
    "code": "/**\r\n * Assert that the given String is not empty; that is,\r\n * it must not be {@code null} and not the empty String.\r\n * <pre class=\"code\">\r\n * Assert.hasLength(account.getName(),\r\n *     () -&gt; \"Name for account '\" + account.getId() + \"' must not be empty\");\r\n * </pre>\r\n * @param text the String to check\r\n * @param messageSupplier a supplier for the exception message to use if the\r\n * assertion fails\r\n * @throws IllegalArgumentException if the text is empty\r\n * @since 5.0\r\n * @see StringUtils#hasLength\r\n */\r\n@Contract(\"null, _ -> fail\")\r\npublic static void hasLength(@Nullable String text, Supplier<String> messageSupplier) {\r\n    if (!StringUtils.hasLength(text)) {\r\n        throw new IllegalArgumentException(nullSafeGet(messageSupplier));\r\n    }\r\n}",
    "comment": "\n\t * Assert that the given String is not empty; that is,\n\t * it must not be {@code null} and not the empty String.\n\t * <pre class=\"code\">\n\t * Assert.hasLength(account.getName(),\n\t *     () -&gt; \"Name for account '\" + account.getId() + \"' must not be empty\");\n\t * </pre>\n\t * @param text the String to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the text is empty\n\t * @since 5.0\n\t * @see StringUtils#hasLength\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#hasText(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Assert that the given String contains valid text content; that is, it must not\r\n * be {@code null} and must contain at least one non-whitespace character.\r\n * <pre class=\"code\">Assert.hasText(name, \"'name' must not be empty\");</pre>\r\n * @param text the String to check\r\n * @param message the exception message to use if the assertion fails\r\n * @throws IllegalArgumentException if the text does not contain valid text content\r\n * @see StringUtils#hasText\r\n */\r\n@Contract(\"null, _ -> fail\")\r\npublic static void hasText(@Nullable String text, String message) {\r\n    if (!StringUtils.hasText(text)) {\r\n        throw new IllegalArgumentException(message);\r\n    }\r\n}",
    "comment": "\n\t * Assert that the given String contains valid text content; that is, it must not\n\t * be {@code null} and must contain at least one non-whitespace character.\n\t * <pre class=\"code\">Assert.hasText(name, \"'name' must not be empty\");</pre>\n\t * @param text the String to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the text does not contain valid text content\n\t * @see StringUtils#hasText\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#hasText(String,Supplier<String>)",
    "entityType": "method",
    "code": "/**\r\n * Assert that the given String contains valid text content; that is, it must not\r\n * be {@code null} and must contain at least one non-whitespace character.\r\n * <pre class=\"code\">\r\n * Assert.hasText(account.getName(),\r\n *     () -&gt; \"Name for account '\" + account.getId() + \"' must not be empty\");\r\n * </pre>\r\n * @param text the String to check\r\n * @param messageSupplier a supplier for the exception message to use if the\r\n * assertion fails\r\n * @throws IllegalArgumentException if the text does not contain valid text content\r\n * @since 5.0\r\n * @see StringUtils#hasText\r\n */\r\n@Contract(\"null, _ -> fail\")\r\npublic static void hasText(@Nullable String text, Supplier<String> messageSupplier) {\r\n    if (!StringUtils.hasText(text)) {\r\n        throw new IllegalArgumentException(nullSafeGet(messageSupplier));\r\n    }\r\n}",
    "comment": "\n\t * Assert that the given String contains valid text content; that is, it must not\n\t * be {@code null} and must contain at least one non-whitespace character.\n\t * <pre class=\"code\">\n\t * Assert.hasText(account.getName(),\n\t *     () -&gt; \"Name for account '\" + account.getId() + \"' must not be empty\");\n\t * </pre>\n\t * @param text the String to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the text does not contain valid text content\n\t * @since 5.0\n\t * @see StringUtils#hasText\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#doesNotContain(String,String,String)",
    "entityType": "method",
    "code": "/**\r\n * Assert that the given text does not contain the given substring.\r\n * <pre class=\"code\">Assert.doesNotContain(name, \"rod\", \"Name must not contain 'rod'\");</pre>\r\n * @param textToSearch the text to search\r\n * @param substring the substring to find within the text\r\n * @param message the exception message to use if the assertion fails\r\n * @throws IllegalArgumentException if the text contains the substring\r\n */\r\npublic static void doesNotContain(@Nullable String textToSearch, String substring, String message) {\r\n    if (StringUtils.hasLength(textToSearch) && StringUtils.hasLength(substring) && textToSearch.contains(substring)) {\r\n        throw new IllegalArgumentException(message);\r\n    }\r\n}",
    "comment": "\n\t * Assert that the given text does not contain the given substring.\n\t * <pre class=\"code\">Assert.doesNotContain(name, \"rod\", \"Name must not contain 'rod'\");</pre>\n\t * @param textToSearch the text to search\n\t * @param substring the substring to find within the text\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the text contains the substring\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#doesNotContain(String,String,Supplier<String>)",
    "entityType": "method",
    "code": "/**\r\n * Assert that the given text does not contain the given substring.\r\n * <pre class=\"code\">\r\n * Assert.doesNotContain(name, forbidden, () -&gt; \"Name must not contain '\" + forbidden + \"'\");\r\n * </pre>\r\n * @param textToSearch the text to search\r\n * @param substring the substring to find within the text\r\n * @param messageSupplier a supplier for the exception message to use if the\r\n * assertion fails\r\n * @throws IllegalArgumentException if the text contains the substring\r\n * @since 5.0\r\n */\r\npublic static void doesNotContain(@Nullable String textToSearch, String substring, Supplier<String> messageSupplier) {\r\n    if (StringUtils.hasLength(textToSearch) && StringUtils.hasLength(substring) && textToSearch.contains(substring)) {\r\n        throw new IllegalArgumentException(nullSafeGet(messageSupplier));\r\n    }\r\n}",
    "comment": "\n\t * Assert that the given text does not contain the given substring.\n\t * <pre class=\"code\">\n\t * Assert.doesNotContain(name, forbidden, () -&gt; \"Name must not contain '\" + forbidden + \"'\");\n\t * </pre>\n\t * @param textToSearch the text to search\n\t * @param substring the substring to find within the text\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the text contains the substring\n\t * @since 5.0\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#notEmpty(Object[],String)",
    "entityType": "method",
    "code": "/**\r\n * Assert that an array contains elements; that is, it must not be\r\n * {@code null} and must contain at least one element.\r\n * <pre class=\"code\">Assert.notEmpty(array, \"The array must contain elements\");</pre>\r\n * @param array the array to check\r\n * @param message the exception message to use if the assertion fails\r\n * @throws IllegalArgumentException if the object array is {@code null} or contains no elements\r\n */\r\n@Contract(\"null, _ -> fail\")\r\npublic static void notEmpty(@Nullable Object @Nullable [] array, String message) {\r\n    if (ObjectUtils.isEmpty(array)) {\r\n        throw new IllegalArgumentException(message);\r\n    }\r\n}",
    "comment": "\n\t * Assert that an array contains elements; that is, it must not be\n\t * {@code null} and must contain at least one element.\n\t * <pre class=\"code\">Assert.notEmpty(array, \"The array must contain elements\");</pre>\n\t * @param array the array to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the object array is {@code null} or contains no elements\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#notEmpty(Object[],Supplier<String>)",
    "entityType": "method",
    "code": "/**\r\n * Assert that an array contains elements; that is, it must not be\r\n * {@code null} and must contain at least one element.\r\n * <pre class=\"code\">\r\n * Assert.notEmpty(array, () -&gt; \"The \" + arrayType + \" array must contain elements\");\r\n * </pre>\r\n * @param array the array to check\r\n * @param messageSupplier a supplier for the exception message to use if the\r\n * assertion fails\r\n * @throws IllegalArgumentException if the object array is {@code null} or contains no elements\r\n * @since 5.0\r\n */\r\n@Contract(\"null, _ -> fail\")\r\npublic static void notEmpty(Object @Nullable [] array, Supplier<String> messageSupplier) {\r\n    if (ObjectUtils.isEmpty(array)) {\r\n        throw new IllegalArgumentException(nullSafeGet(messageSupplier));\r\n    }\r\n}",
    "comment": "\n\t * Assert that an array contains elements; that is, it must not be\n\t * {@code null} and must contain at least one element.\n\t * <pre class=\"code\">\n\t * Assert.notEmpty(array, () -&gt; \"The \" + arrayType + \" array must contain elements\");\n\t * </pre>\n\t * @param array the array to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the object array is {@code null} or contains no elements\n\t * @since 5.0\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#noNullElements(Object[],String)",
    "entityType": "method",
    "code": "/**\r\n * Assert that an array contains no {@code null} elements.\r\n * <p>Note: Does not complain if the array is empty!\r\n * <pre class=\"code\">Assert.noNullElements(array, \"The array must contain non-null elements\");</pre>\r\n * @param array the array to check\r\n * @param message the exception message to use if the assertion fails\r\n * @throws IllegalArgumentException if the object array contains a {@code null} element\r\n */\r\npublic static void noNullElements(Object @Nullable [] array, String message) {\r\n    if (array != null) {\r\n        for (Object element : array) {\r\n            if (element == null) {\r\n                throw new IllegalArgumentException(message);\r\n            }\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Assert that an array contains no {@code null} elements.\n\t * <p>Note: Does not complain if the array is empty!\n\t * <pre class=\"code\">Assert.noNullElements(array, \"The array must contain non-null elements\");</pre>\n\t * @param array the array to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the object array contains a {@code null} element\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#noNullElements(Object[],Supplier<String>)",
    "entityType": "method",
    "code": "/**\r\n * Assert that an array contains no {@code null} elements.\r\n * <p>Note: Does not complain if the array is empty!\r\n * <pre class=\"code\">\r\n * Assert.noNullElements(array, () -&gt; \"The \" + arrayType + \" array must contain non-null elements\");\r\n * </pre>\r\n * @param array the array to check\r\n * @param messageSupplier a supplier for the exception message to use if the\r\n * assertion fails\r\n * @throws IllegalArgumentException if the object array contains a {@code null} element\r\n * @since 5.0\r\n */\r\npublic static void noNullElements(Object @Nullable [] array, Supplier<String> messageSupplier) {\r\n    if (array != null) {\r\n        for (Object element : array) {\r\n            if (element == null) {\r\n                throw new IllegalArgumentException(nullSafeGet(messageSupplier));\r\n            }\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Assert that an array contains no {@code null} elements.\n\t * <p>Note: Does not complain if the array is empty!\n\t * <pre class=\"code\">\n\t * Assert.noNullElements(array, () -&gt; \"The \" + arrayType + \" array must contain non-null elements\");\n\t * </pre>\n\t * @param array the array to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the object array contains a {@code null} element\n\t * @since 5.0\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#notEmpty(Collection<?>,String)",
    "entityType": "method",
    "code": "/**\r\n * Assert that a collection contains elements; that is, it must not be\r\n * {@code null} and must contain at least one element.\r\n * <pre class=\"code\">Assert.notEmpty(collection, \"Collection must contain elements\");</pre>\r\n * @param collection the collection to check\r\n * @param message the exception message to use if the assertion fails\r\n * @throws IllegalArgumentException if the collection is {@code null} or\r\n * contains no elements\r\n */\r\n@Contract(\"null, _ -> fail\")\r\npublic static void notEmpty(@Nullable Collection<?> collection, String message) {\r\n    if (CollectionUtils.isEmpty(collection)) {\r\n        throw new IllegalArgumentException(message);\r\n    }\r\n}",
    "comment": "\n\t * Assert that a collection contains elements; that is, it must not be\n\t * {@code null} and must contain at least one element.\n\t * <pre class=\"code\">Assert.notEmpty(collection, \"Collection must contain elements\");</pre>\n\t * @param collection the collection to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the collection is {@code null} or\n\t * contains no elements\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#notEmpty(Collection<?>,Supplier<String>)",
    "entityType": "method",
    "code": "/**\r\n * Assert that a collection contains elements; that is, it must not be\r\n * {@code null} and must contain at least one element.\r\n * <pre class=\"code\">\r\n * Assert.notEmpty(collection, () -&gt; \"The \" + collectionType + \" collection must contain elements\");\r\n * </pre>\r\n * @param collection the collection to check\r\n * @param messageSupplier a supplier for the exception message to use if the\r\n * assertion fails\r\n * @throws IllegalArgumentException if the collection is {@code null} or\r\n * contains no elements\r\n * @since 5.0\r\n */\r\n@Contract(\"null, _ -> fail\")\r\npublic static void notEmpty(@Nullable Collection<?> collection, Supplier<String> messageSupplier) {\r\n    if (CollectionUtils.isEmpty(collection)) {\r\n        throw new IllegalArgumentException(nullSafeGet(messageSupplier));\r\n    }\r\n}",
    "comment": "\n\t * Assert that a collection contains elements; that is, it must not be\n\t * {@code null} and must contain at least one element.\n\t * <pre class=\"code\">\n\t * Assert.notEmpty(collection, () -&gt; \"The \" + collectionType + \" collection must contain elements\");\n\t * </pre>\n\t * @param collection the collection to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the collection is {@code null} or\n\t * contains no elements\n\t * @since 5.0\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#noNullElements(Collection<?>,String)",
    "entityType": "method",
    "code": "/**\r\n * Assert that a collection contains no {@code null} elements.\r\n * <p>Note: Does not complain if the collection is empty!\r\n * <pre class=\"code\">Assert.noNullElements(collection, \"Collection must contain non-null elements\");</pre>\r\n * @param collection the collection to check\r\n * @param message the exception message to use if the assertion fails\r\n * @throws IllegalArgumentException if the collection contains a {@code null} element\r\n * @since 5.2\r\n */\r\npublic static void noNullElements(@Nullable Collection<?> collection, String message) {\r\n    if (collection != null) {\r\n        for (Object element : collection) {\r\n            if (element == null) {\r\n                throw new IllegalArgumentException(message);\r\n            }\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Assert that a collection contains no {@code null} elements.\n\t * <p>Note: Does not complain if the collection is empty!\n\t * <pre class=\"code\">Assert.noNullElements(collection, \"Collection must contain non-null elements\");</pre>\n\t * @param collection the collection to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the collection contains a {@code null} element\n\t * @since 5.2\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#noNullElements(Collection<?>,Supplier<String>)",
    "entityType": "method",
    "code": "/**\r\n * Assert that a collection contains no {@code null} elements.\r\n * <p>Note: Does not complain if the collection is empty!\r\n * <pre class=\"code\">\r\n * Assert.noNullElements(collection, () -&gt; \"Collection \" + collectionName + \" must contain non-null elements\");\r\n * </pre>\r\n * @param collection the collection to check\r\n * @param messageSupplier a supplier for the exception message to use if the\r\n * assertion fails\r\n * @throws IllegalArgumentException if the collection contains a {@code null} element\r\n * @since 5.2\r\n */\r\npublic static void noNullElements(@Nullable Collection<?> collection, Supplier<String> messageSupplier) {\r\n    if (collection != null) {\r\n        for (Object element : collection) {\r\n            if (element == null) {\r\n                throw new IllegalArgumentException(nullSafeGet(messageSupplier));\r\n            }\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Assert that a collection contains no {@code null} elements.\n\t * <p>Note: Does not complain if the collection is empty!\n\t * <pre class=\"code\">\n\t * Assert.noNullElements(collection, () -&gt; \"Collection \" + collectionName + \" must contain non-null elements\");\n\t * </pre>\n\t * @param collection the collection to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the collection contains a {@code null} element\n\t * @since 5.2\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#notEmpty(Map<?,?>,String)",
    "entityType": "method",
    "code": "/**\r\n * Assert that a Map contains entries; that is, it must not be {@code null}\r\n * and must contain at least one entry.\r\n * <pre class=\"code\">Assert.notEmpty(map, \"Map must contain entries\");</pre>\r\n * @param map the map to check\r\n * @param message the exception message to use if the assertion fails\r\n * @throws IllegalArgumentException if the map is {@code null} or contains no entries\r\n */\r\n@Contract(\"null, _ -> fail\")\r\npublic static void notEmpty(@Nullable Map<?, ?> map, String message) {\r\n    if (CollectionUtils.isEmpty(map)) {\r\n        throw new IllegalArgumentException(message);\r\n    }\r\n}",
    "comment": "\n\t * Assert that a Map contains entries; that is, it must not be {@code null}\n\t * and must contain at least one entry.\n\t * <pre class=\"code\">Assert.notEmpty(map, \"Map must contain entries\");</pre>\n\t * @param map the map to check\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if the map is {@code null} or contains no entries\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#notEmpty(Map<?,?>,Supplier<String>)",
    "entityType": "method",
    "code": "/**\r\n * Assert that a Map contains entries; that is, it must not be {@code null}\r\n * and must contain at least one entry.\r\n * <pre class=\"code\">\r\n * Assert.notEmpty(map, () -&gt; \"The \" + mapType + \" map must contain entries\");\r\n * </pre>\r\n * @param map the map to check\r\n * @param messageSupplier a supplier for the exception message to use if the\r\n * assertion fails\r\n * @throws IllegalArgumentException if the map is {@code null} or contains no entries\r\n * @since 5.0\r\n */\r\n@Contract(\"null, _ -> fail\")\r\npublic static void notEmpty(@Nullable Map<?, ?> map, Supplier<String> messageSupplier) {\r\n    if (CollectionUtils.isEmpty(map)) {\r\n        throw new IllegalArgumentException(nullSafeGet(messageSupplier));\r\n    }\r\n}",
    "comment": "\n\t * Assert that a Map contains entries; that is, it must not be {@code null}\n\t * and must contain at least one entry.\n\t * <pre class=\"code\">\n\t * Assert.notEmpty(map, () -&gt; \"The \" + mapType + \" map must contain entries\");\n\t * </pre>\n\t * @param map the map to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if the map is {@code null} or contains no entries\n\t * @since 5.0\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#isInstanceOf(Class<?>,Object,String)",
    "entityType": "method",
    "code": "/**\r\n * Assert that the provided object is an instance of the provided class.\r\n * <pre class=\"code\">Assert.instanceOf(Foo.class, foo, \"Foo expected\");</pre>\r\n * @param type the type to check against\r\n * @param obj the object to check\r\n * @param message a message which will be prepended to provide further context.\r\n * If it is empty or ends in \":\" or \";\" or \",\" or \".\", a full exception message\r\n * will be appended. If it ends in a space, the name of the offending object's\r\n * type will be appended. In any other case, a \":\" with a space and the name\r\n * of the offending object's type will be appended.\r\n * @throws IllegalArgumentException if the object is not an instance of type\r\n */\r\n@Contract(\"_, null, _ -> fail\")\r\npublic static void isInstanceOf(Class<?> type, @Nullable Object obj, String message) {\r\n    notNull(type, \"Type to check against must not be null\");\r\n    if (!type.isInstance(obj)) {\r\n        instanceCheckFailed(type, obj, message);\r\n    }\r\n}",
    "comment": "\n\t * Assert that the provided object is an instance of the provided class.\n\t * <pre class=\"code\">Assert.instanceOf(Foo.class, foo, \"Foo expected\");</pre>\n\t * @param type the type to check against\n\t * @param obj the object to check\n\t * @param message a message which will be prepended to provide further context.\n\t * If it is empty or ends in \":\" or \";\" or \",\" or \".\", a full exception message\n\t * will be appended. If it ends in a space, the name of the offending object's\n\t * type will be appended. In any other case, a \":\" with a space and the name\n\t * of the offending object's type will be appended.\n\t * @throws IllegalArgumentException if the object is not an instance of type\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#isInstanceOf(Class<?>,Object,Supplier<String>)",
    "entityType": "method",
    "code": "/**\r\n * Assert that the provided object is an instance of the provided class.\r\n * <pre class=\"code\">\r\n * Assert.instanceOf(Foo.class, foo, () -&gt; \"Processing \" + Foo.class.getSimpleName() + \":\");\r\n * </pre>\r\n * @param type the type to check against\r\n * @param obj the object to check\r\n * @param messageSupplier a supplier for the exception message to use if the\r\n * assertion fails. See {@link #isInstanceOf(Class, Object, String)} for details.\r\n * @throws IllegalArgumentException if the object is not an instance of type\r\n * @since 5.0\r\n */\r\n@Contract(\"_, null, _ -> fail\")\r\npublic static void isInstanceOf(Class<?> type, @Nullable Object obj, Supplier<String> messageSupplier) {\r\n    notNull(type, \"Type to check against must not be null\");\r\n    if (!type.isInstance(obj)) {\r\n        instanceCheckFailed(type, obj, nullSafeGet(messageSupplier));\r\n    }\r\n}",
    "comment": "\n\t * Assert that the provided object is an instance of the provided class.\n\t * <pre class=\"code\">\n\t * Assert.instanceOf(Foo.class, foo, () -&gt; \"Processing \" + Foo.class.getSimpleName() + \":\");\n\t * </pre>\n\t * @param type the type to check against\n\t * @param obj the object to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails. See {@link #isInstanceOf(Class, Object, String)} for details.\n\t * @throws IllegalArgumentException if the object is not an instance of type\n\t * @since 5.0\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#isInstanceOf(Class<?>,Object)",
    "entityType": "method",
    "code": "/**\r\n * Assert that the provided object is an instance of the provided class.\r\n * <pre class=\"code\">Assert.instanceOf(Foo.class, foo);</pre>\r\n * @param type the type to check against\r\n * @param obj the object to check\r\n * @throws IllegalArgumentException if the object is not an instance of type\r\n */\r\n@Contract(\"_, null -> fail\")\r\npublic static void isInstanceOf(Class<?> type, @Nullable Object obj) {\r\n    isInstanceOf(type, obj, \"\");\r\n}",
    "comment": "\n\t * Assert that the provided object is an instance of the provided class.\n\t * <pre class=\"code\">Assert.instanceOf(Foo.class, foo);</pre>\n\t * @param type the type to check against\n\t * @param obj the object to check\n\t * @throws IllegalArgumentException if the object is not an instance of type\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#isAssignable(Class<?>,Class<?>,String)",
    "entityType": "method",
    "code": "/**\r\n * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}.\r\n * <pre class=\"code\">Assert.isAssignable(Number.class, myClass, \"Number expected\");</pre>\r\n * @param superType the supertype to check against\r\n * @param subType the subtype to check\r\n * @param message a message which will be prepended to provide further context.\r\n * If it is empty or ends in \":\" or \";\" or \",\" or \".\", a full exception message\r\n * will be appended. If it ends in a space, the name of the offending subtype\r\n * will be appended. In any other case, a \":\" with a space and the name of the\r\n * offending subtype will be appended.\r\n * @throws IllegalArgumentException if the classes are not assignable\r\n */\r\n@Contract(\"_, null, _ -> fail\")\r\npublic static void isAssignable(Class<?> superType, @Nullable Class<?> subType, String message) {\r\n    notNull(superType, \"Supertype to check against must not be null\");\r\n    if (subType == null || !superType.isAssignableFrom(subType)) {\r\n        assignableCheckFailed(superType, subType, message);\r\n    }\r\n}",
    "comment": "\n\t * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}.\n\t * <pre class=\"code\">Assert.isAssignable(Number.class, myClass, \"Number expected\");</pre>\n\t * @param superType the supertype to check against\n\t * @param subType the subtype to check\n\t * @param message a message which will be prepended to provide further context.\n\t * If it is empty or ends in \":\" or \";\" or \",\" or \".\", a full exception message\n\t * will be appended. If it ends in a space, the name of the offending subtype\n\t * will be appended. In any other case, a \":\" with a space and the name of the\n\t * offending subtype will be appended.\n\t * @throws IllegalArgumentException if the classes are not assignable\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#isAssignable(Class<?>,Class<?>,Supplier<String>)",
    "entityType": "method",
    "code": "/**\r\n * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}.\r\n * <pre class=\"code\">\r\n * Assert.isAssignable(Number.class, myClass, () -&gt; \"Processing \" + myAttributeName + \":\");\r\n * </pre>\r\n * @param superType the supertype to check against\r\n * @param subType the subtype to check\r\n * @param messageSupplier a supplier for the exception message to use if the\r\n * assertion fails. See {@link #isAssignable(Class, Class, String)} for details.\r\n * @throws IllegalArgumentException if the classes are not assignable\r\n * @since 5.0\r\n */\r\n@Contract(\"_, null, _ -> fail\")\r\npublic static void isAssignable(Class<?> superType, @Nullable Class<?> subType, Supplier<String> messageSupplier) {\r\n    notNull(superType, \"Supertype to check against must not be null\");\r\n    if (subType == null || !superType.isAssignableFrom(subType)) {\r\n        assignableCheckFailed(superType, subType, nullSafeGet(messageSupplier));\r\n    }\r\n}",
    "comment": "\n\t * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}.\n\t * <pre class=\"code\">\n\t * Assert.isAssignable(Number.class, myClass, () -&gt; \"Processing \" + myAttributeName + \":\");\n\t * </pre>\n\t * @param superType the supertype to check against\n\t * @param subType the subtype to check\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails. See {@link #isAssignable(Class, Class, String)} for details.\n\t * @throws IllegalArgumentException if the classes are not assignable\n\t * @since 5.0\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#isAssignable(Class<?>,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}.\r\n * <pre class=\"code\">Assert.isAssignable(Number.class, myClass);</pre>\r\n * @param superType the supertype to check\r\n * @param subType the subtype to check\r\n * @throws IllegalArgumentException if the classes are not assignable\r\n */\r\n@Contract(\"_, null -> fail\")\r\npublic static void isAssignable(Class<?> superType, @Nullable Class<?> subType) {\r\n    isAssignable(superType, subType, \"\");\r\n}",
    "comment": "\n\t * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}.\n\t * <pre class=\"code\">Assert.isAssignable(Number.class, myClass);</pre>\n\t * @param superType the supertype to check\n\t * @param subType the subtype to check\n\t * @throws IllegalArgumentException if the classes are not assignable\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#instanceCheckFailed(Class<?>,Object,String)",
    "entityType": "method",
    "code": "private static void instanceCheckFailed(Class<?> type, @Nullable Object obj, @Nullable String msg) {\r\n    String className = (obj != null ? obj.getClass().getName() : \"null\");\r\n    String result = \"\";\r\n    boolean defaultMessage = true;\r\n    if (StringUtils.hasLength(msg)) {\r\n        if (endsWithSeparator(msg)) {\r\n            result = msg + \" \";\r\n        } else {\r\n            result = messageWithTypeName(msg, className);\r\n            defaultMessage = false;\r\n        }\r\n    }\r\n    if (defaultMessage) {\r\n        result = result + (\"Object of class [\" + className + \"] must be an instance of \" + type);\r\n    }\r\n    throw new IllegalArgumentException(result);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Assert#assignableCheckFailed(Class<?>,Class<?>,String)",
    "entityType": "method",
    "code": "private static void assignableCheckFailed(Class<?> superType, @Nullable Class<?> subType, @Nullable String msg) {\r\n    String result = \"\";\r\n    boolean defaultMessage = true;\r\n    if (StringUtils.hasLength(msg)) {\r\n        if (endsWithSeparator(msg)) {\r\n            result = msg + \" \";\r\n        } else {\r\n            result = messageWithTypeName(msg, subType);\r\n            defaultMessage = false;\r\n        }\r\n    }\r\n    if (defaultMessage) {\r\n        result = result + (subType + \" is not assignable to \" + superType);\r\n    }\r\n    throw new IllegalArgumentException(result);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Assert#endsWithSeparator(String)",
    "entityType": "method",
    "code": "private static boolean endsWithSeparator(String msg) {\r\n    return (msg.endsWith(\":\") || msg.endsWith(\";\") || msg.endsWith(\",\") || msg.endsWith(\".\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Assert#messageWithTypeName(String,Object)",
    "entityType": "method",
    "code": "private static String messageWithTypeName(String msg, @Nullable Object typeName) {\r\n    return msg + (msg.endsWith(\" \") ? \"\" : \": \") + typeName;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Assert#nullSafeGet(Supplier<String>)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static String nullSafeGet(@Nullable Supplier<String> messageSupplier) {\r\n    return (messageSupplier != null ? messageSupplier.get() : null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingList",
    "entityType": "class",
    "code": "/**\r\n * The {@link List} that all operations are eventually delegated to.\r\n */\r\nprivate final List<E> backingList;\n/**\r\n * The {@link ElementFactory} to use to create new {@link List} elements\r\n * on demand.\r\n */\r\nprivate final ElementFactory<E> elementFactory;\n/**\r\n * Creates a new {@code AutoPopulatingList} that is backed by a standard\r\n * {@link ArrayList} and adds new instances of the supplied {@link Class element Class}\r\n * to the backing {@link List} on demand.\r\n */\r\npublic AutoPopulatingList(Class<? extends E> elementClass) {\r\n    this(new ArrayList<>(), elementClass);\r\n}\n/**\r\n * Creates a new {@code AutoPopulatingList} that is backed by the supplied {@link List}\r\n * and adds new instances of the supplied {@link Class element Class} to the backing\r\n * {@link List} on demand.\r\n */\r\npublic AutoPopulatingList(List<E> backingList, Class<? extends E> elementClass) {\r\n    this(backingList, new ReflectiveElementFactory<>(elementClass));\r\n}\n/**\r\n * Creates a new {@code AutoPopulatingList} that is backed by a standard\r\n * {@link ArrayList} and creates new elements on demand using the supplied {@link ElementFactory}.\r\n */\r\npublic AutoPopulatingList(ElementFactory<E> elementFactory) {\r\n    this(new ArrayList<>(), elementFactory);\r\n}\n/**\r\n * Creates a new {@code AutoPopulatingList} that is backed by the supplied {@link List}\r\n * and creates new elements on demand using the supplied {@link ElementFactory}.\r\n */\r\npublic AutoPopulatingList(List<E> backingList, ElementFactory<E> elementFactory) {\r\n    Assert.notNull(backingList, \"Backing List must not be null\");\r\n    Assert.notNull(elementFactory, \"Element factory must not be null\");\r\n    this.backingList = backingList;\r\n    this.elementFactory = elementFactory;\r\n}\n@Override\r\npublic void add(int index, E element) {\r\n    this.backingList.add(index, element);\r\n}\n@Override\r\npublic boolean add(E o) {\r\n    return this.backingList.add(o);\r\n}\n@Override\r\npublic boolean addAll(Collection<? extends E> c) {\r\n    return this.backingList.addAll(c);\r\n}\n@Override\r\npublic boolean addAll(int index, Collection<? extends E> c) {\r\n    return this.backingList.addAll(index, c);\r\n}\n@Override\r\npublic void clear() {\r\n    this.backingList.clear();\r\n}\n@Override\r\npublic boolean contains(Object o) {\r\n    return this.backingList.contains(o);\r\n}\n@Override\r\npublic boolean containsAll(Collection<?> c) {\r\n    return this.backingList.containsAll(c);\r\n}\n/**\r\n * Get the element at the supplied index, creating it if there is\r\n * no element at that index.\r\n */\r\n@Override\r\npublic E get(int index) {\r\n    int backingListSize = this.backingList.size();\r\n    E element;\r\n    if (index < backingListSize) {\r\n        element = this.backingList.get(index);\r\n        if (element == null) {\r\n            element = this.elementFactory.createElement(index);\r\n            this.backingList.set(index, element);\r\n        }\r\n    } else {\r\n        for (int x = backingListSize; x < index; x++) {\r\n            this.backingList.add(null);\r\n        }\r\n        element = this.elementFactory.createElement(index);\r\n        this.backingList.add(element);\r\n    }\r\n    return element;\r\n}\n@Override\r\npublic int indexOf(Object o) {\r\n    return this.backingList.indexOf(o);\r\n}\n@Override\r\npublic boolean isEmpty() {\r\n    return this.backingList.isEmpty();\r\n}\n@Override\r\npublic Iterator<E> iterator() {\r\n    return this.backingList.iterator();\r\n}\n@Override\r\npublic int lastIndexOf(Object o) {\r\n    return this.backingList.lastIndexOf(o);\r\n}\n@Override\r\npublic ListIterator<E> listIterator() {\r\n    return this.backingList.listIterator();\r\n}\n@Override\r\npublic ListIterator<E> listIterator(int index) {\r\n    return this.backingList.listIterator(index);\r\n}\n@Override\r\npublic E remove(int index) {\r\n    return this.backingList.remove(index);\r\n}\n@Override\r\npublic boolean remove(Object o) {\r\n    return this.backingList.remove(o);\r\n}\n@Override\r\npublic boolean removeAll(Collection<?> c) {\r\n    return this.backingList.removeAll(c);\r\n}\n@Override\r\npublic boolean retainAll(Collection<?> c) {\r\n    return this.backingList.retainAll(c);\r\n}\n@Override\r\npublic E set(int index, E element) {\r\n    return this.backingList.set(index, element);\r\n}\n@Override\r\npublic int size() {\r\n    return this.backingList.size();\r\n}\n@Override\r\npublic List<E> subList(int fromIndex, int toIndex) {\r\n    return this.backingList.subList(fromIndex, toIndex);\r\n}\n@Override\r\npublic Object[] toArray() {\r\n    return this.backingList.toArray();\r\n}\n@Override\r\npublic <T> T[] toArray(T[] a) {\r\n    return this.backingList.toArray(a);\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return this.backingList.equals(other);\r\n}\n@Override\r\npublic int hashCode() {\r\n    return this.backingList.hashCode();\r\n}\n/**\r\n * Factory interface for creating elements for an index-based access\r\n * data structure such as a {@link java.util.List}.\r\n *\r\n * @param <E> the element type\r\n */\r\n@FunctionalInterface\r\npublic interface ElementFactory<E> {\r\n\r\n    /**\r\n     * Create the element for the supplied index.\r\n     * @return the element object\r\n     * @throws ElementInstantiationException if the instantiation process failed\r\n     * (any exception thrown by a target constructor should be propagated as-is)\r\n     */\r\n    E createElement(int index) throws ElementInstantiationException;\r\n}\n/**\r\n * Exception to be thrown from ElementFactory.\r\n */\r\npublic static class ElementInstantiationException extends RuntimeException {\r\n\r\n    public ElementInstantiationException(String msg) {\r\n        super(msg);\r\n    }\r\n\r\n    public ElementInstantiationException(String message, Throwable cause) {\r\n        super(message, cause);\r\n    }\r\n}\n/**\r\n * Reflective implementation of the ElementFactory interface, using\r\n * {@code Class.getDeclaredConstructor().newInstance()} on a given element class.\r\n */\r\nprivate static class ReflectiveElementFactory<E> implements ElementFactory<E>, Serializable {\r\n\r\n    private final Class<? extends E> elementClass;\r\n\r\n    public ReflectiveElementFactory(Class<? extends E> elementClass) {\r\n        Assert.notNull(elementClass, \"Element class must not be null\");\r\n        Assert.isTrue(!elementClass.isInterface(), \"Element class must not be an interface type\");\r\n        Assert.isTrue(!Modifier.isAbstract(elementClass.getModifiers()), \"Element class cannot be an abstract class\");\r\n        this.elementClass = elementClass;\r\n    }\r\n\r\n    @Override\r\n    public E createElement(int index) {\r\n        try {\r\n            return ReflectionUtils.accessibleConstructor(this.elementClass).newInstance();\r\n        } catch (NoSuchMethodException ex) {\r\n            throw new ElementInstantiationException(\"No default constructor on element class: \" + this.elementClass.getName(), ex);\r\n        } catch (InstantiationException ex) {\r\n            throw new ElementInstantiationException(\"Unable to instantiate element class: \" + this.elementClass.getName(), ex);\r\n        } catch (IllegalAccessException ex) {\r\n            throw new ElementInstantiationException(\"Could not access element constructor: \" + this.elementClass.getName(), ex);\r\n        } catch (InvocationTargetException ex) {\r\n            throw new ElementInstantiationException(\"Failed to invoke element constructor: \" + this.elementClass.getName(), ex.getTargetException());\r\n        }\r\n    }\r\n}",
    "comment": "\n * Simple {@link List} wrapper class that allows for elements to be\n * automatically populated as they are requested. This is particularly\n * useful for data binding to {@link List Lists}, allowing for elements\n * to be created and added to the {@link List} in a \"just in time\" fashion.\n *\n * <p>Note: This class is not thread-safe. To create a thread-safe version,\n * use the {@link java.util.Collections#synchronizedList} utility methods.\n *\n * <p>Inspired by {@code LazyList} from Commons Collections.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @since 2.0\n * @param <E> the element type\n "
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingList#add(int,E)",
    "entityType": "method",
    "code": "@Override\r\npublic void add(int index, E element) {\r\n    this.backingList.add(index, element);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingList#add(E)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean add(E o) {\r\n    return this.backingList.add(o);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingList#addAll(Collection<? extends E>)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean addAll(Collection<? extends E> c) {\r\n    return this.backingList.addAll(c);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingList#addAll(int,Collection<? extends E>)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean addAll(int index, Collection<? extends E> c) {\r\n    return this.backingList.addAll(index, c);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingList#clear()",
    "entityType": "method",
    "code": "@Override\r\npublic void clear() {\r\n    this.backingList.clear();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingList#contains(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean contains(Object o) {\r\n    return this.backingList.contains(o);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingList#containsAll(Collection<?>)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean containsAll(Collection<?> c) {\r\n    return this.backingList.containsAll(c);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingList#get(int)",
    "entityType": "method",
    "code": "/**\r\n * Get the element at the supplied index, creating it if there is\r\n * no element at that index.\r\n */\r\n@Override\r\npublic E get(int index) {\r\n    int backingListSize = this.backingList.size();\r\n    E element;\r\n    if (index < backingListSize) {\r\n        element = this.backingList.get(index);\r\n        if (element == null) {\r\n            element = this.elementFactory.createElement(index);\r\n            this.backingList.set(index, element);\r\n        }\r\n    } else {\r\n        for (int x = backingListSize; x < index; x++) {\r\n            this.backingList.add(null);\r\n        }\r\n        element = this.elementFactory.createElement(index);\r\n        this.backingList.add(element);\r\n    }\r\n    return element;\r\n}",
    "comment": "\n\t * Get the element at the supplied index, creating it if there is\n\t * no element at that index.\n\t "
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingList#indexOf(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic int indexOf(Object o) {\r\n    return this.backingList.indexOf(o);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingList#isEmpty()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isEmpty() {\r\n    return this.backingList.isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingList#iterator()",
    "entityType": "method",
    "code": "@Override\r\npublic Iterator<E> iterator() {\r\n    return this.backingList.iterator();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingList#lastIndexOf(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic int lastIndexOf(Object o) {\r\n    return this.backingList.lastIndexOf(o);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingList#listIterator()",
    "entityType": "method",
    "code": "@Override\r\npublic ListIterator<E> listIterator() {\r\n    return this.backingList.listIterator();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingList#listIterator(int)",
    "entityType": "method",
    "code": "@Override\r\npublic ListIterator<E> listIterator(int index) {\r\n    return this.backingList.listIterator(index);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingList#remove(int)",
    "entityType": "method",
    "code": "@Override\r\npublic E remove(int index) {\r\n    return this.backingList.remove(index);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingList#remove(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean remove(Object o) {\r\n    return this.backingList.remove(o);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingList#removeAll(Collection<?>)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean removeAll(Collection<?> c) {\r\n    return this.backingList.removeAll(c);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingList#retainAll(Collection<?>)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean retainAll(Collection<?> c) {\r\n    return this.backingList.retainAll(c);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingList#set(int,E)",
    "entityType": "method",
    "code": "@Override\r\npublic E set(int index, E element) {\r\n    return this.backingList.set(index, element);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingList#size()",
    "entityType": "method",
    "code": "@Override\r\npublic int size() {\r\n    return this.backingList.size();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingList#subList(int,int)",
    "entityType": "method",
    "code": "@Override\r\npublic List<E> subList(int fromIndex, int toIndex) {\r\n    return this.backingList.subList(fromIndex, toIndex);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingList#toArray()",
    "entityType": "method",
    "code": "@Override\r\npublic Object[] toArray() {\r\n    return this.backingList.toArray();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingList#toArray(T[])",
    "entityType": "method",
    "code": "@Override\r\npublic <T> T[] toArray(T[] a) {\r\n    return this.backingList.toArray(a);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingList#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return this.backingList.equals(other);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingList#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return this.backingList.hashCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ElementFactory",
    "entityType": "class",
    "code": "/**\r\n * Create the element for the supplied index.\r\n * @return the element object\r\n * @throws ElementInstantiationException if the instantiation process failed\r\n * (any exception thrown by a target constructor should be propagated as-is)\r\n */\r\nE createElement(int index) throws ElementInstantiationException;",
    "comment": "\n\t * Factory interface for creating elements for an index-based access\n\t * data structure such as a {@link java.util.List}.\n\t *\n\t * @param <E> the element type\n\t "
  },
  {
    "entityId": "org.springframework.util.ElementFactory#createElement(int)",
    "entityType": "method",
    "code": "/**\r\n * Create the element for the supplied index.\r\n * @return the element object\r\n * @throws ElementInstantiationException if the instantiation process failed\r\n * (any exception thrown by a target constructor should be propagated as-is)\r\n */\r\nE createElement(int index) throws ElementInstantiationException;",
    "comment": "\n\t\t * Create the element for the supplied index.\n\t\t * @return the element object\n\t\t * @throws ElementInstantiationException if the instantiation process failed\n\t\t * (any exception thrown by a target constructor should be propagated as-is)\n\t\t "
  },
  {
    "entityId": "org.springframework.util.ElementInstantiationException",
    "entityType": "class",
    "code": "public ElementInstantiationException(String msg) {\r\n    super(msg);\r\n}\npublic ElementInstantiationException(String message, Throwable cause) {\r\n    super(message, cause);\r\n}",
    "comment": "\n\t * Exception to be thrown from ElementFactory.\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectiveElementFactory",
    "entityType": "class",
    "code": "private final Class<? extends E> elementClass;\npublic ReflectiveElementFactory(Class<? extends E> elementClass) {\r\n    Assert.notNull(elementClass, \"Element class must not be null\");\r\n    Assert.isTrue(!elementClass.isInterface(), \"Element class must not be an interface type\");\r\n    Assert.isTrue(!Modifier.isAbstract(elementClass.getModifiers()), \"Element class cannot be an abstract class\");\r\n    this.elementClass = elementClass;\r\n}\n@Override\r\npublic E createElement(int index) {\r\n    try {\r\n        return ReflectionUtils.accessibleConstructor(this.elementClass).newInstance();\r\n    } catch (NoSuchMethodException ex) {\r\n        throw new ElementInstantiationException(\"No default constructor on element class: \" + this.elementClass.getName(), ex);\r\n    } catch (InstantiationException ex) {\r\n        throw new ElementInstantiationException(\"Unable to instantiate element class: \" + this.elementClass.getName(), ex);\r\n    } catch (IllegalAccessException ex) {\r\n        throw new ElementInstantiationException(\"Could not access element constructor: \" + this.elementClass.getName(), ex);\r\n    } catch (InvocationTargetException ex) {\r\n        throw new ElementInstantiationException(\"Failed to invoke element constructor: \" + this.elementClass.getName(), ex.getTargetException());\r\n    }\r\n}",
    "comment": "\n\t * Reflective implementation of the ElementFactory interface, using\n\t * {@code Class.getDeclaredConstructor().newInstance()} on a given element class.\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectiveElementFactory#createElement(int)",
    "entityType": "method",
    "code": "@Override\r\npublic E createElement(int index) {\r\n    try {\r\n        return ReflectionUtils.accessibleConstructor(this.elementClass).newInstance();\r\n    } catch (NoSuchMethodException ex) {\r\n        throw new ElementInstantiationException(\"No default constructor on element class: \" + this.elementClass.getName(), ex);\r\n    } catch (InstantiationException ex) {\r\n        throw new ElementInstantiationException(\"Unable to instantiate element class: \" + this.elementClass.getName(), ex);\r\n    } catch (IllegalAccessException ex) {\r\n        throw new ElementInstantiationException(\"Could not access element constructor: \" + this.elementClass.getName(), ex);\r\n    } catch (InvocationTargetException ex) {\r\n        throw new ElementInstantiationException(\"Failed to invoke element constructor: \" + this.elementClass.getName(), ex.getTargetException());\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.backoff.BackOff",
    "entityType": "class",
    "code": "/**\r\n * Start a new back off execution.\r\n * @return a fresh {@link BackOffExecution} ready to be used\r\n */\r\nBackOffExecution start();",
    "comment": "\n * Provide a {@link BackOffExecution} that indicates the rate at which\n * an operation should be retried.\n *\n * <p>Users of this interface are expected to use it like this:\n *\n * <pre class=\"code\">\n * BackOffExecution exec = backOff.start();\n *\n * // In the operation recovery/retry loop:\n * long waitInterval = exec.nextBackOff();\n * if (waitInterval == BackOffExecution.STOP) {\n *     // do not retry operation\n * }\n * else {\n *     // sleep, for example, Thread.sleep(waitInterval)\n *     // retry operation\n * }</pre>\n *\n * Once the underlying operation has completed successfully,\n * the execution instance can be discarded.\n *\n * @author Stephane Nicoll\n * @since 4.1\n * @see BackOffExecution\n "
  },
  {
    "entityId": "org.springframework.util.backoff.BackOff#start()",
    "entityType": "method",
    "code": "/**\r\n * Start a new back off execution.\r\n * @return a fresh {@link BackOffExecution} ready to be used\r\n */\r\nBackOffExecution start();",
    "comment": "\n\t * Start a new back off execution.\n\t * @return a fresh {@link BackOffExecution} ready to be used\n\t "
  },
  {
    "entityId": "org.springframework.util.backoff.BackOffExecution",
    "entityType": "class",
    "code": "/**\r\n * Return value of {@link #nextBackOff()} that indicates that the operation\r\n * should not be retried.\r\n */\r\nlong STOP = -1;\n/**\r\n * Return the number of milliseconds to wait before retrying the operation\r\n * or {@link #STOP} ({@value #STOP}) to indicate that no further attempt\r\n * should be made for the operation.\r\n */\r\nlong nextBackOff();",
    "comment": "\n * Represent a particular back-off execution.\n *\n * <p>Implementations do not need to be thread safe.\n *\n * @author Stephane Nicoll\n * @since 4.1\n * @see BackOff\n "
  },
  {
    "entityId": "org.springframework.util.backoff.BackOffExecution#nextBackOff()",
    "entityType": "method",
    "code": "/**\r\n * Return the number of milliseconds to wait before retrying the operation\r\n * or {@link #STOP} ({@value #STOP}) to indicate that no further attempt\r\n * should be made for the operation.\r\n */\r\nlong nextBackOff();",
    "comment": "\n\t * Return the number of milliseconds to wait before retrying the operation\n\t * or {@link #STOP} ({@value #STOP}) to indicate that no further attempt\n\t * should be made for the operation.\n\t "
  },
  {
    "entityId": "org.springframework.util.backoff.ExponentialBackOff",
    "entityType": "class",
    "code": "/**\r\n * The default initial interval.\r\n */\r\npublic static final long DEFAULT_INITIAL_INTERVAL = 2000L;\n/**\r\n * The default multiplier (increases the interval by 50%).\r\n */\r\npublic static final double DEFAULT_MULTIPLIER = 1.5;\n/**\r\n * The default maximum back off time.\r\n */\r\npublic static final long DEFAULT_MAX_INTERVAL = 30000L;\n/**\r\n * The default maximum elapsed time.\r\n */\r\npublic static final long DEFAULT_MAX_ELAPSED_TIME = Long.MAX_VALUE;\n/**\r\n * The default maximum attempts.\r\n * @since 6.1\r\n */\r\npublic static final int DEFAULT_MAX_ATTEMPTS = Integer.MAX_VALUE;\nprivate long initialInterval = DEFAULT_INITIAL_INTERVAL;\nprivate double multiplier = DEFAULT_MULTIPLIER;\nprivate long maxInterval = DEFAULT_MAX_INTERVAL;\nprivate long maxElapsedTime = DEFAULT_MAX_ELAPSED_TIME;\nprivate int maxAttempts = DEFAULT_MAX_ATTEMPTS;\n/**\r\n * Create an instance with the default settings.\r\n * @see #DEFAULT_INITIAL_INTERVAL\r\n * @see #DEFAULT_MULTIPLIER\r\n * @see #DEFAULT_MAX_INTERVAL\r\n * @see #DEFAULT_MAX_ELAPSED_TIME\r\n * @see #DEFAULT_MAX_ATTEMPTS\r\n */\r\npublic ExponentialBackOff() {\r\n}\n/**\r\n * Create an instance with the supplied settings.\r\n * @param initialInterval the initial interval in milliseconds\r\n * @param multiplier the multiplier (should be greater than or equal to 1)\r\n */\r\npublic ExponentialBackOff(long initialInterval, double multiplier) {\r\n    checkMultiplier(multiplier);\r\n    this.initialInterval = initialInterval;\r\n    this.multiplier = multiplier;\r\n}\n/**\r\n * Set the initial interval in milliseconds.\r\n */\r\npublic void setInitialInterval(long initialInterval) {\r\n    this.initialInterval = initialInterval;\r\n}\n/**\r\n * Return the initial interval in milliseconds.\r\n */\r\npublic long getInitialInterval() {\r\n    return this.initialInterval;\r\n}\n/**\r\n * Set the value to multiply the current interval by for each retry attempt.\r\n */\r\npublic void setMultiplier(double multiplier) {\r\n    checkMultiplier(multiplier);\r\n    this.multiplier = multiplier;\r\n}\n/**\r\n * Return the value to multiply the current interval by for each retry attempt.\r\n */\r\npublic double getMultiplier() {\r\n    return this.multiplier;\r\n}\n/**\r\n * Set the maximum back off time in milliseconds.\r\n */\r\npublic void setMaxInterval(long maxInterval) {\r\n    this.maxInterval = maxInterval;\r\n}\n/**\r\n * Return the maximum back off time in milliseconds.\r\n */\r\npublic long getMaxInterval() {\r\n    return this.maxInterval;\r\n}\n/**\r\n * Set the maximum elapsed time in milliseconds after which a call to\r\n * {@link BackOffExecution#nextBackOff()} returns {@link BackOffExecution#STOP}.\r\n * @param maxElapsedTime the maximum elapsed time\r\n * @see #setMaxAttempts\r\n */\r\npublic void setMaxElapsedTime(long maxElapsedTime) {\r\n    this.maxElapsedTime = maxElapsedTime;\r\n}\n/**\r\n * Return the maximum elapsed time in milliseconds after which a call to\r\n * {@link BackOffExecution#nextBackOff()} returns {@link BackOffExecution#STOP}.\r\n * @return the maximum elapsed time\r\n * @see #getMaxAttempts()\r\n */\r\npublic long getMaxElapsedTime() {\r\n    return this.maxElapsedTime;\r\n}\n/**\r\n * The maximum number of attempts after which a call to\r\n * {@link BackOffExecution#nextBackOff()} returns {@link BackOffExecution#STOP}.\r\n * @param maxAttempts the maximum number of attempts\r\n * @since 6.1\r\n * @see #setMaxElapsedTime\r\n */\r\npublic void setMaxAttempts(int maxAttempts) {\r\n    this.maxAttempts = maxAttempts;\r\n}\n/**\r\n * Return the maximum number of attempts after which a call to\r\n * {@link BackOffExecution#nextBackOff()} returns {@link BackOffExecution#STOP}.\r\n * @return the maximum number of attempts\r\n * @since 6.1\r\n * @see #getMaxElapsedTime()\r\n */\r\npublic int getMaxAttempts() {\r\n    return this.maxAttempts;\r\n}\n@Override\r\npublic BackOffExecution start() {\r\n    return new ExponentialBackOffExecution();\r\n}\nprivate void checkMultiplier(double multiplier) {\r\n    Assert.isTrue(multiplier >= 1, () -> \"Invalid multiplier '\" + multiplier + \"'. Should be greater than \" + \"or equal to 1. A multiplier of 1 is equivalent to a fixed interval.\");\r\n}\n@Override\r\npublic String toString() {\r\n    return new StringJoiner(\", \", ExponentialBackOff.class.getSimpleName() + \"{\", \"}\").add(\"initialInterval=\" + this.initialInterval).add(\"multiplier=\" + this.multiplier).add(\"maxInterval=\" + this.maxInterval).add(\"maxElapsedTime=\" + this.maxElapsedTime).add(\"maxAttempts=\" + this.maxAttempts).toString();\r\n}\nprivate class ExponentialBackOffExecution implements BackOffExecution {\r\n\r\n    private long currentInterval = -1;\r\n\r\n    private long currentElapsedTime = 0;\r\n\r\n    private int attempts;\r\n\r\n    @Override\r\n    public long nextBackOff() {\r\n        if (this.currentElapsedTime >= getMaxElapsedTime() || this.attempts >= getMaxAttempts()) {\r\n            return STOP;\r\n        }\r\n        long nextInterval = computeNextInterval();\r\n        this.currentElapsedTime += nextInterval;\r\n        this.attempts++;\r\n        return nextInterval;\r\n    }\r\n\r\n    private long computeNextInterval() {\r\n        long maxInterval = getMaxInterval();\r\n        if (this.currentInterval >= maxInterval) {\r\n            return maxInterval;\r\n        } else if (this.currentInterval < 0) {\r\n            long initialInterval = getInitialInterval();\r\n            this.currentInterval = Math.min(initialInterval, maxInterval);\r\n        } else {\r\n            this.currentInterval = multiplyInterval(maxInterval);\r\n        }\r\n        return this.currentInterval;\r\n    }\r\n\r\n    private long multiplyInterval(long maxInterval) {\r\n        long i = this.currentInterval;\r\n        i *= getMultiplier();\r\n        return Math.min(i, maxInterval);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        String currentIntervalDescription = this.currentInterval < 0 ? \"n/a\" : this.currentInterval + \"ms\";\r\n        return new StringJoiner(\", \", ExponentialBackOffExecution.class.getSimpleName() + \"{\", \"}\").add(\"currentInterval=\" + currentIntervalDescription).add(\"multiplier=\" + getMultiplier()).add(\"attempts=\" + this.attempts).toString();\r\n    }\r\n}",
    "comment": "\n * Implementation of {@link BackOff} that increases the back off period for each\n * retry attempt. When the interval has reached the {@linkplain #setMaxInterval\n * max interval}, it is no longer increased. Stops retrying once the\n * {@linkplain #setMaxElapsedTime max elapsed time} has been reached.\n *\n * <p>Example: The default interval is {@value #DEFAULT_INITIAL_INTERVAL} ms;\n * the default multiplier is {@value #DEFAULT_MULTIPLIER}; and the default max\n * interval is {@value #DEFAULT_MAX_INTERVAL}. For 10 attempts the sequence will be\n * as follows:\n *\n * <pre>\n * request#     back off\n *\n *  1              2000\n *  2              3000\n *  3              4500\n *  4              6750\n *  5             10125\n *  6             15187\n *  7             22780\n *  8             30000\n *  9             30000\n * 10             30000\n * </pre>\n *\n * <p>Note that the default max elapsed time is {@link Long#MAX_VALUE}, and the\n * default maximum number of attempts is {@link Integer#MAX_VALUE}.\n * Use {@link #setMaxElapsedTime} to limit the length of time that an instance\n * should accumulate before returning {@link BackOffExecution#STOP}. Alternatively,\n * use {@link #setMaxAttempts} to limit the number of attempts. The execution\n * stops when either of those two limits is reached.\n *\n * @author Stephane Nicoll\n * @author Gary Russell\n * @since 4.1\n "
  },
  {
    "entityId": "org.springframework.util.backoff.ExponentialBackOff#setInitialInterval(long)",
    "entityType": "method",
    "code": "/**\r\n * Set the initial interval in milliseconds.\r\n */\r\npublic void setInitialInterval(long initialInterval) {\r\n    this.initialInterval = initialInterval;\r\n}",
    "comment": "\n\t * Set the initial interval in milliseconds.\n\t "
  },
  {
    "entityId": "org.springframework.util.backoff.ExponentialBackOff#getInitialInterval()",
    "entityType": "method",
    "code": "/**\r\n * Return the initial interval in milliseconds.\r\n */\r\npublic long getInitialInterval() {\r\n    return this.initialInterval;\r\n}",
    "comment": "\n\t * Return the initial interval in milliseconds.\n\t "
  },
  {
    "entityId": "org.springframework.util.backoff.ExponentialBackOff#setMultiplier(double)",
    "entityType": "method",
    "code": "/**\r\n * Set the value to multiply the current interval by for each retry attempt.\r\n */\r\npublic void setMultiplier(double multiplier) {\r\n    checkMultiplier(multiplier);\r\n    this.multiplier = multiplier;\r\n}",
    "comment": "\n\t * Set the value to multiply the current interval by for each retry attempt.\n\t "
  },
  {
    "entityId": "org.springframework.util.backoff.ExponentialBackOff#getMultiplier()",
    "entityType": "method",
    "code": "/**\r\n * Return the value to multiply the current interval by for each retry attempt.\r\n */\r\npublic double getMultiplier() {\r\n    return this.multiplier;\r\n}",
    "comment": "\n\t * Return the value to multiply the current interval by for each retry attempt.\n\t "
  },
  {
    "entityId": "org.springframework.util.backoff.ExponentialBackOff#setMaxInterval(long)",
    "entityType": "method",
    "code": "/**\r\n * Set the maximum back off time in milliseconds.\r\n */\r\npublic void setMaxInterval(long maxInterval) {\r\n    this.maxInterval = maxInterval;\r\n}",
    "comment": "\n\t * Set the maximum back off time in milliseconds.\n\t "
  },
  {
    "entityId": "org.springframework.util.backoff.ExponentialBackOff#getMaxInterval()",
    "entityType": "method",
    "code": "/**\r\n * Return the maximum back off time in milliseconds.\r\n */\r\npublic long getMaxInterval() {\r\n    return this.maxInterval;\r\n}",
    "comment": "\n\t * Return the maximum back off time in milliseconds.\n\t "
  },
  {
    "entityId": "org.springframework.util.backoff.ExponentialBackOff#setMaxElapsedTime(long)",
    "entityType": "method",
    "code": "/**\r\n * Set the maximum elapsed time in milliseconds after which a call to\r\n * {@link BackOffExecution#nextBackOff()} returns {@link BackOffExecution#STOP}.\r\n * @param maxElapsedTime the maximum elapsed time\r\n * @see #setMaxAttempts\r\n */\r\npublic void setMaxElapsedTime(long maxElapsedTime) {\r\n    this.maxElapsedTime = maxElapsedTime;\r\n}",
    "comment": "\n\t * Set the maximum elapsed time in milliseconds after which a call to\n\t * {@link BackOffExecution#nextBackOff()} returns {@link BackOffExecution#STOP}.\n\t * @param maxElapsedTime the maximum elapsed time\n\t * @see #setMaxAttempts\n\t "
  },
  {
    "entityId": "org.springframework.util.backoff.ExponentialBackOff#getMaxElapsedTime()",
    "entityType": "method",
    "code": "/**\r\n * Return the maximum elapsed time in milliseconds after which a call to\r\n * {@link BackOffExecution#nextBackOff()} returns {@link BackOffExecution#STOP}.\r\n * @return the maximum elapsed time\r\n * @see #getMaxAttempts()\r\n */\r\npublic long getMaxElapsedTime() {\r\n    return this.maxElapsedTime;\r\n}",
    "comment": "\n\t * Return the maximum elapsed time in milliseconds after which a call to\n\t * {@link BackOffExecution#nextBackOff()} returns {@link BackOffExecution#STOP}.\n\t * @return the maximum elapsed time\n\t * @see #getMaxAttempts()\n\t "
  },
  {
    "entityId": "org.springframework.util.backoff.ExponentialBackOff#setMaxAttempts(int)",
    "entityType": "method",
    "code": "/**\r\n * The maximum number of attempts after which a call to\r\n * {@link BackOffExecution#nextBackOff()} returns {@link BackOffExecution#STOP}.\r\n * @param maxAttempts the maximum number of attempts\r\n * @since 6.1\r\n * @see #setMaxElapsedTime\r\n */\r\npublic void setMaxAttempts(int maxAttempts) {\r\n    this.maxAttempts = maxAttempts;\r\n}",
    "comment": "\n\t * The maximum number of attempts after which a call to\n\t * {@link BackOffExecution#nextBackOff()} returns {@link BackOffExecution#STOP}.\n\t * @param maxAttempts the maximum number of attempts\n\t * @since 6.1\n\t * @see #setMaxElapsedTime\n\t "
  },
  {
    "entityId": "org.springframework.util.backoff.ExponentialBackOff#getMaxAttempts()",
    "entityType": "method",
    "code": "/**\r\n * Return the maximum number of attempts after which a call to\r\n * {@link BackOffExecution#nextBackOff()} returns {@link BackOffExecution#STOP}.\r\n * @return the maximum number of attempts\r\n * @since 6.1\r\n * @see #getMaxElapsedTime()\r\n */\r\npublic int getMaxAttempts() {\r\n    return this.maxAttempts;\r\n}",
    "comment": "\n\t * Return the maximum number of attempts after which a call to\n\t * {@link BackOffExecution#nextBackOff()} returns {@link BackOffExecution#STOP}.\n\t * @return the maximum number of attempts\n\t * @since 6.1\n\t * @see #getMaxElapsedTime()\n\t "
  },
  {
    "entityId": "org.springframework.util.backoff.ExponentialBackOff#start()",
    "entityType": "method",
    "code": "@Override\r\npublic BackOffExecution start() {\r\n    return new ExponentialBackOffExecution();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.backoff.ExponentialBackOff#checkMultiplier(double)",
    "entityType": "method",
    "code": "private void checkMultiplier(double multiplier) {\r\n    Assert.isTrue(multiplier >= 1, () -> \"Invalid multiplier '\" + multiplier + \"'. Should be greater than \" + \"or equal to 1. A multiplier of 1 is equivalent to a fixed interval.\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.backoff.ExponentialBackOff#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return new StringJoiner(\", \", ExponentialBackOff.class.getSimpleName() + \"{\", \"}\").add(\"initialInterval=\" + this.initialInterval).add(\"multiplier=\" + this.multiplier).add(\"maxInterval=\" + this.maxInterval).add(\"maxElapsedTime=\" + this.maxElapsedTime).add(\"maxAttempts=\" + this.maxAttempts).toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.backoff.ExponentialBackOffExecution",
    "entityType": "class",
    "code": "private long currentInterval = -1;\nprivate long currentElapsedTime = 0;\nprivate int attempts;\n@Override\r\npublic long nextBackOff() {\r\n    if (this.currentElapsedTime >= getMaxElapsedTime() || this.attempts >= getMaxAttempts()) {\r\n        return STOP;\r\n    }\r\n    long nextInterval = computeNextInterval();\r\n    this.currentElapsedTime += nextInterval;\r\n    this.attempts++;\r\n    return nextInterval;\r\n}\nprivate long computeNextInterval() {\r\n    long maxInterval = getMaxInterval();\r\n    if (this.currentInterval >= maxInterval) {\r\n        return maxInterval;\r\n    } else if (this.currentInterval < 0) {\r\n        long initialInterval = getInitialInterval();\r\n        this.currentInterval = Math.min(initialInterval, maxInterval);\r\n    } else {\r\n        this.currentInterval = multiplyInterval(maxInterval);\r\n    }\r\n    return this.currentInterval;\r\n}\nprivate long multiplyInterval(long maxInterval) {\r\n    long i = this.currentInterval;\r\n    i *= getMultiplier();\r\n    return Math.min(i, maxInterval);\r\n}\n@Override\r\npublic String toString() {\r\n    String currentIntervalDescription = this.currentInterval < 0 ? \"n/a\" : this.currentInterval + \"ms\";\r\n    return new StringJoiner(\", \", ExponentialBackOffExecution.class.getSimpleName() + \"{\", \"}\").add(\"currentInterval=\" + currentIntervalDescription).add(\"multiplier=\" + getMultiplier()).add(\"attempts=\" + this.attempts).toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.backoff.ExponentialBackOffExecution#nextBackOff()",
    "entityType": "method",
    "code": "@Override\r\npublic long nextBackOff() {\r\n    if (this.currentElapsedTime >= getMaxElapsedTime() || this.attempts >= getMaxAttempts()) {\r\n        return STOP;\r\n    }\r\n    long nextInterval = computeNextInterval();\r\n    this.currentElapsedTime += nextInterval;\r\n    this.attempts++;\r\n    return nextInterval;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.backoff.ExponentialBackOffExecution#computeNextInterval()",
    "entityType": "method",
    "code": "private long computeNextInterval() {\r\n    long maxInterval = getMaxInterval();\r\n    if (this.currentInterval >= maxInterval) {\r\n        return maxInterval;\r\n    } else if (this.currentInterval < 0) {\r\n        long initialInterval = getInitialInterval();\r\n        this.currentInterval = Math.min(initialInterval, maxInterval);\r\n    } else {\r\n        this.currentInterval = multiplyInterval(maxInterval);\r\n    }\r\n    return this.currentInterval;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.backoff.ExponentialBackOffExecution#multiplyInterval(long)",
    "entityType": "method",
    "code": "private long multiplyInterval(long maxInterval) {\r\n    long i = this.currentInterval;\r\n    i *= getMultiplier();\r\n    return Math.min(i, maxInterval);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.backoff.ExponentialBackOffExecution#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    String currentIntervalDescription = this.currentInterval < 0 ? \"n/a\" : this.currentInterval + \"ms\";\r\n    return new StringJoiner(\", \", ExponentialBackOffExecution.class.getSimpleName() + \"{\", \"}\").add(\"currentInterval=\" + currentIntervalDescription).add(\"multiplier=\" + getMultiplier()).add(\"attempts=\" + this.attempts).toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.backoff.FixedBackOff",
    "entityType": "class",
    "code": "/**\r\n * The default recovery interval: 5000 ms = 5 seconds.\r\n */\r\npublic static final long DEFAULT_INTERVAL = 5000;\n/**\r\n * Constant value indicating an unlimited number of attempts.\r\n */\r\npublic static final long UNLIMITED_ATTEMPTS = Long.MAX_VALUE;\nprivate long interval = DEFAULT_INTERVAL;\nprivate long maxAttempts = UNLIMITED_ATTEMPTS;\n/**\r\n * Create an instance with an interval of {@value #DEFAULT_INTERVAL}\r\n * ms and an unlimited number of attempts.\r\n */\r\npublic FixedBackOff() {\r\n}\n/**\r\n * Create an instance.\r\n * @param interval the interval between two attempts\r\n * @param maxAttempts the maximum number of attempts\r\n */\r\npublic FixedBackOff(long interval, long maxAttempts) {\r\n    this.interval = interval;\r\n    this.maxAttempts = maxAttempts;\r\n}\n/**\r\n * Set the interval between two attempts in milliseconds.\r\n */\r\npublic void setInterval(long interval) {\r\n    this.interval = interval;\r\n}\n/**\r\n * Return the interval between two attempts in milliseconds.\r\n */\r\npublic long getInterval() {\r\n    return this.interval;\r\n}\n/**\r\n * Set the maximum number of attempts in milliseconds.\r\n */\r\npublic void setMaxAttempts(long maxAttempts) {\r\n    this.maxAttempts = maxAttempts;\r\n}\n/**\r\n * Return the maximum number of attempts in milliseconds.\r\n */\r\npublic long getMaxAttempts() {\r\n    return this.maxAttempts;\r\n}\n@Override\r\npublic BackOffExecution start() {\r\n    return new FixedBackOffExecution();\r\n}\nprivate class FixedBackOffExecution implements BackOffExecution {\r\n\r\n    private long currentAttempts = 0;\r\n\r\n    @Override\r\n    public long nextBackOff() {\r\n        this.currentAttempts++;\r\n        if (this.currentAttempts <= getMaxAttempts()) {\r\n            return getInterval();\r\n        } else {\r\n            return STOP;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        String attemptValue = (FixedBackOff.this.maxAttempts == Long.MAX_VALUE ? \"unlimited\" : String.valueOf(FixedBackOff.this.maxAttempts));\r\n        return \"FixedBackOff{interval=\" + FixedBackOff.this.interval + \", currentAttempts=\" + this.currentAttempts + \", maxAttempts=\" + attemptValue + '}';\r\n    }\r\n}",
    "comment": "\n * A simple {@link BackOff} implementation that provides a fixed interval\n * between two attempts and a maximum number of retries.\n *\n * @author Stephane Nicoll\n * @since 4.1\n "
  },
  {
    "entityId": "org.springframework.util.backoff.FixedBackOff#setInterval(long)",
    "entityType": "method",
    "code": "/**\r\n * Set the interval between two attempts in milliseconds.\r\n */\r\npublic void setInterval(long interval) {\r\n    this.interval = interval;\r\n}",
    "comment": "\n\t * Set the interval between two attempts in milliseconds.\n\t "
  },
  {
    "entityId": "org.springframework.util.backoff.FixedBackOff#getInterval()",
    "entityType": "method",
    "code": "/**\r\n * Return the interval between two attempts in milliseconds.\r\n */\r\npublic long getInterval() {\r\n    return this.interval;\r\n}",
    "comment": "\n\t * Return the interval between two attempts in milliseconds.\n\t "
  },
  {
    "entityId": "org.springframework.util.backoff.FixedBackOff#setMaxAttempts(long)",
    "entityType": "method",
    "code": "/**\r\n * Set the maximum number of attempts in milliseconds.\r\n */\r\npublic void setMaxAttempts(long maxAttempts) {\r\n    this.maxAttempts = maxAttempts;\r\n}",
    "comment": "\n\t * Set the maximum number of attempts in milliseconds.\n\t "
  },
  {
    "entityId": "org.springframework.util.backoff.FixedBackOff#getMaxAttempts()",
    "entityType": "method",
    "code": "/**\r\n * Return the maximum number of attempts in milliseconds.\r\n */\r\npublic long getMaxAttempts() {\r\n    return this.maxAttempts;\r\n}",
    "comment": "\n\t * Return the maximum number of attempts in milliseconds.\n\t "
  },
  {
    "entityId": "org.springframework.util.backoff.FixedBackOff#start()",
    "entityType": "method",
    "code": "@Override\r\npublic BackOffExecution start() {\r\n    return new FixedBackOffExecution();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.backoff.FixedBackOffExecution",
    "entityType": "class",
    "code": "private long currentAttempts = 0;\n@Override\r\npublic long nextBackOff() {\r\n    this.currentAttempts++;\r\n    if (this.currentAttempts <= getMaxAttempts()) {\r\n        return getInterval();\r\n    } else {\r\n        return STOP;\r\n    }\r\n}\n@Override\r\npublic String toString() {\r\n    String attemptValue = (FixedBackOff.this.maxAttempts == Long.MAX_VALUE ? \"unlimited\" : String.valueOf(FixedBackOff.this.maxAttempts));\r\n    return \"FixedBackOff{interval=\" + FixedBackOff.this.interval + \", currentAttempts=\" + this.currentAttempts + \", maxAttempts=\" + attemptValue + '}';\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.backoff.FixedBackOffExecution#nextBackOff()",
    "entityType": "method",
    "code": "@Override\r\npublic long nextBackOff() {\r\n    this.currentAttempts++;\r\n    if (this.currentAttempts <= getMaxAttempts()) {\r\n        return getInterval();\r\n    } else {\r\n        return STOP;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.backoff.FixedBackOffExecution#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    String attemptValue = (FixedBackOff.this.maxAttempts == Long.MAX_VALUE ? \"unlimited\" : String.valueOf(FixedBackOff.this.maxAttempts));\r\n    return \"FixedBackOff{interval=\" + FixedBackOff.this.interval + \", currentAttempts=\" + this.currentAttempts + \", maxAttempts=\" + attemptValue + '}';\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtils",
    "entityType": "class",
    "code": "/**\r\n * Suffix for array class names: {@code \"[]\"}.\r\n */\r\npublic static final String ARRAY_SUFFIX = \"[]\";\n/**\r\n * A reusable empty class array constant.\r\n */\r\nprivate static final Class<?>[] EMPTY_CLASS_ARRAY = {};\n/**\r\n * The package separator character: {@code '.'}.\r\n */\r\nprivate static final char PACKAGE_SEPARATOR = '.';\n/**\r\n * The path separator character: {@code '/'}.\r\n */\r\nprivate static final char PATH_SEPARATOR = '/';\n/**\r\n * The nested class separator character: {@code '$'}.\r\n */\r\nprivate static final char NESTED_CLASS_SEPARATOR = '$';\n/**\r\n * The CGLIB class separator: {@code \"$$\"}.\r\n */\r\npublic static final String CGLIB_CLASS_SEPARATOR = \"$$\";\n/**\r\n * The \".class\" file suffix.\r\n */\r\npublic static final String CLASS_FILE_SUFFIX = \".class\";\n/**\r\n * Precomputed value for the combination of private, static and final modifiers.\r\n */\r\nprivate static final int NON_OVERRIDABLE_MODIFIER = Modifier.PRIVATE | Modifier.STATIC | Modifier.FINAL;\n/**\r\n * Precomputed value for the combination of public and protected modifiers.\r\n */\r\nprivate static final int OVERRIDABLE_MODIFIER = Modifier.PUBLIC | Modifier.PROTECTED;\n/**\r\n * Map with primitive wrapper type as key and corresponding primitive\r\n * type as value, for example: {@code Integer.class -> int.class}.\r\n */\r\nprivate static final Map<Class<?>, Class<?>> primitiveWrapperTypeMap = new IdentityHashMap<>(9);\n/**\r\n * Map with primitive type as key and corresponding wrapper\r\n * type as value, for example: {@code int.class -> Integer.class}.\r\n */\r\nprivate static final Map<Class<?>, Class<?>> primitiveTypeToWrapperMap = new IdentityHashMap<>(9);\n/**\r\n * Map with primitive type name as key and corresponding primitive\r\n * type as value, for example: {@code \"int\" -> int.class}.\r\n */\r\nprivate static final Map<String, Class<?>> primitiveTypeNameMap = new HashMap<>(32);\n/**\r\n * Map with common Java language class name as key and corresponding Class as value.\r\n * Primarily for efficient deserialization of remote invocations.\r\n */\r\nprivate static final Map<String, Class<?>> commonClassCache = new HashMap<>(64);\n/**\r\n * Common Java language interfaces which are supposed to be ignored\r\n * when searching for 'primary' user-level interfaces.\r\n */\r\nprivate static final Set<Class<?>> javaLanguageInterfaces;\n/**\r\n * Cache for equivalent methods on a interface implemented by the declaring class.\r\n * <p>A {@code null} value signals that no interface method was found for the key.\r\n */\r\nprivate static final Map<Method, Method> interfaceMethodCache = new ConcurrentReferenceHashMap<>(256);\n/**\r\n * Cache for equivalent methods on a public interface implemented by the declaring class.\r\n * <p>A {@code null} value signals that no public interface method was found for the key.\r\n * @since 6.2\r\n */\r\nprivate static final Map<Method, Method> publicInterfaceMethodCache = new ConcurrentReferenceHashMap<>(256);\n/**\r\n * Cache for equivalent public methods in a public declaring type within the type hierarchy\r\n * of the method's declaring class.\r\n * <p>A {@code null} value signals that no publicly accessible method was found for the key.\r\n * @since 6.2\r\n */\r\nprivate static final Map<Method, Method> publiclyAccessibleMethodCache = new ConcurrentReferenceHashMap<>(256);\nstatic {\r\n    primitiveWrapperTypeMap.put(Boolean.class, boolean.class);\r\n    primitiveWrapperTypeMap.put(Byte.class, byte.class);\r\n    primitiveWrapperTypeMap.put(Character.class, char.class);\r\n    primitiveWrapperTypeMap.put(Double.class, double.class);\r\n    primitiveWrapperTypeMap.put(Float.class, float.class);\r\n    primitiveWrapperTypeMap.put(Integer.class, int.class);\r\n    primitiveWrapperTypeMap.put(Long.class, long.class);\r\n    primitiveWrapperTypeMap.put(Short.class, short.class);\r\n    primitiveWrapperTypeMap.put(Void.class, void.class);\r\n    // Map entry iteration is less expensive to initialize than forEach with lambdas\r\n    for (Map.Entry<Class<?>, Class<?>> entry : primitiveWrapperTypeMap.entrySet()) {\r\n        primitiveTypeToWrapperMap.put(entry.getValue(), entry.getKey());\r\n        registerCommonClasses(entry.getKey());\r\n    }\r\n    Set<Class<?>> primitiveTypes = new HashSet<>(32);\r\n    primitiveTypes.addAll(primitiveWrapperTypeMap.values());\r\n    Collections.addAll(primitiveTypes, boolean[].class, byte[].class, char[].class, double[].class, float[].class, int[].class, long[].class, short[].class);\r\n    for (Class<?> primitiveType : primitiveTypes) {\r\n        primitiveTypeNameMap.put(primitiveType.getName(), primitiveType);\r\n    }\r\n    registerCommonClasses(Boolean[].class, Byte[].class, Character[].class, Double[].class, Float[].class, Integer[].class, Long[].class, Short[].class);\r\n    registerCommonClasses(Number.class, Number[].class, String.class, String[].class, Class.class, Class[].class, Object.class, Object[].class);\r\n    registerCommonClasses(Throwable.class, Exception.class, RuntimeException.class, Error.class, StackTraceElement.class, StackTraceElement[].class);\r\n    registerCommonClasses(Enum.class, Iterable.class, Iterator.class, Enumeration.class, Collection.class, List.class, Set.class, Map.class, Map.Entry.class, Optional.class);\r\n    Class<?>[] javaLanguageInterfaceArray = { Serializable.class, Externalizable.class, Closeable.class, AutoCloseable.class, Cloneable.class, Comparable.class };\r\n    registerCommonClasses(javaLanguageInterfaceArray);\r\n    javaLanguageInterfaces = Set.of(javaLanguageInterfaceArray);\r\n}\n/**\r\n * Register the given common classes with the ClassUtils cache.\r\n */\r\nprivate static void registerCommonClasses(Class<?>... commonClasses) {\r\n    for (Class<?> clazz : commonClasses) {\r\n        commonClassCache.put(clazz.getName(), clazz);\r\n    }\r\n}\n/**\r\n * Return the default ClassLoader to use: typically the thread context\r\n * ClassLoader, if available; the ClassLoader that loaded the ClassUtils\r\n * class will be used as fallback.\r\n * <p>Call this method if you intend to use the thread context ClassLoader\r\n * in a scenario where you clearly prefer a non-null ClassLoader reference:\r\n * for example, for class path resource loading (but not necessarily for\r\n * {@code Class.forName}, which accepts a {@code null} ClassLoader\r\n * reference as well).\r\n * @return the default ClassLoader (only {@code null} if even the system\r\n * ClassLoader isn't accessible)\r\n * @see Thread#getContextClassLoader()\r\n * @see ClassLoader#getSystemClassLoader()\r\n */\r\n@Nullable\r\npublic static ClassLoader getDefaultClassLoader() {\r\n    ClassLoader cl = null;\r\n    try {\r\n        cl = Thread.currentThread().getContextClassLoader();\r\n    } catch (Throwable ex) {\r\n        // Cannot access thread context ClassLoader - falling back...\r\n    }\r\n    if (cl == null) {\r\n        // No thread context class loader -> use class loader of this class.\r\n        cl = ClassUtils.class.getClassLoader();\r\n        if (cl == null) {\r\n            // getClassLoader() returning null indicates the bootstrap ClassLoader\r\n            try {\r\n                cl = ClassLoader.getSystemClassLoader();\r\n            } catch (Throwable ex) {\r\n                // Cannot access system ClassLoader - oh well, maybe the caller can live with null...\r\n            }\r\n        }\r\n    }\r\n    return cl;\r\n}\n/**\r\n * Override the thread context ClassLoader with the environment's bean ClassLoader\r\n * if necessary, i.e. if the bean ClassLoader is not equivalent to the thread\r\n * context ClassLoader already.\r\n * @param classLoaderToUse the actual ClassLoader to use for the thread context\r\n * @return the original thread context ClassLoader, or {@code null} if not overridden\r\n */\r\n@Nullable\r\npublic static ClassLoader overrideThreadContextClassLoader(@Nullable ClassLoader classLoaderToUse) {\r\n    Thread currentThread = Thread.currentThread();\r\n    ClassLoader threadContextClassLoader = currentThread.getContextClassLoader();\r\n    if (classLoaderToUse != null && !classLoaderToUse.equals(threadContextClassLoader)) {\r\n        currentThread.setContextClassLoader(classLoaderToUse);\r\n        return threadContextClassLoader;\r\n    } else {\r\n        return null;\r\n    }\r\n}\n/**\r\n * Replacement for {@code Class.forName()} that also returns Class instances\r\n * for primitives (for example, \"int\") and array class names (for example, \"String[]\").\r\n * Furthermore, it is also capable of resolving nested class names in Java source\r\n * style (for example, \"java.lang.Thread.State\" instead of \"java.lang.Thread$State\").\r\n * @param name the name of the Class\r\n * @param classLoader the class loader to use\r\n * (can be {@code null}, which indicates the default class loader)\r\n * @return a class instance for the supplied name\r\n * @throws ClassNotFoundException if the class was not found\r\n * @throws LinkageError if the class file could not be loaded\r\n * @see Class#forName(String, boolean, ClassLoader)\r\n */\r\npublic static Class<?> forName(String name, @Nullable ClassLoader classLoader) throws ClassNotFoundException, LinkageError {\r\n    Assert.notNull(name, \"Name must not be null\");\r\n    Class<?> clazz = resolvePrimitiveClassName(name);\r\n    if (clazz == null) {\r\n        clazz = commonClassCache.get(name);\r\n    }\r\n    if (clazz != null) {\r\n        return clazz;\r\n    }\r\n    // \"java.lang.String[]\" style arrays\r\n    if (name.endsWith(ARRAY_SUFFIX)) {\r\n        String elementClassName = name.substring(0, name.length() - ARRAY_SUFFIX.length());\r\n        Class<?> elementClass = forName(elementClassName, classLoader);\r\n        return elementClass.arrayType();\r\n    }\r\n    ClassLoader clToUse = classLoader;\r\n    if (clToUse == null) {\r\n        clToUse = getDefaultClassLoader();\r\n    }\r\n    try {\r\n        return Class.forName(name, false, clToUse);\r\n    } catch (ClassNotFoundException ex) {\r\n        int lastDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR);\r\n        int previousDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR, lastDotIndex - 1);\r\n        if (lastDotIndex != -1 && previousDotIndex != -1 && Character.isUpperCase(name.charAt(previousDotIndex + 1))) {\r\n            String nestedClassName = name.substring(0, lastDotIndex) + NESTED_CLASS_SEPARATOR + name.substring(lastDotIndex + 1);\r\n            try {\r\n                return Class.forName(nestedClassName, false, clToUse);\r\n            } catch (ClassNotFoundException ex2) {\r\n                // Swallow - let original exception get through\r\n            }\r\n        }\r\n        throw ex;\r\n    }\r\n}\n/**\r\n * Resolve the given class name into a Class instance. Supports\r\n * primitives (like \"int\") and array class names (like \"String[]\").\r\n * <p>This is effectively equivalent to the {@code forName}\r\n * method with the same arguments, with the only difference being\r\n * the exceptions thrown in case of class loading failure.\r\n * @param className the name of the Class\r\n * @param classLoader the class loader to use\r\n * (can be {@code null}, which indicates the default class loader)\r\n * @return a class instance for the supplied name\r\n * @throws IllegalArgumentException if the class name was not resolvable\r\n * (that is, the class could not be found or the class file could not be loaded)\r\n * @throws IllegalStateException if the corresponding class is resolvable but there\r\n * was a readability mismatch in the inheritance hierarchy of the class (typically a\r\n * missing dependency declaration in a Java Module System module definition for a\r\n * superclass or interface implemented by the class to be loaded here)\r\n * @see #forName(String, ClassLoader)\r\n */\r\npublic static Class<?> resolveClassName(String className, @Nullable ClassLoader classLoader) throws IllegalArgumentException {\r\n    try {\r\n        return forName(className, classLoader);\r\n    } catch (IllegalAccessError err) {\r\n        throw new IllegalStateException(\"Readability mismatch in inheritance hierarchy of class [\" + className + \"]: \" + err.getMessage(), err);\r\n    } catch (LinkageError err) {\r\n        throw new IllegalArgumentException(\"Unresolvable class definition for class [\" + className + \"]\", err);\r\n    } catch (ClassNotFoundException ex) {\r\n        throw new IllegalArgumentException(\"Could not find class [\" + className + \"]\", ex);\r\n    }\r\n}\n/**\r\n * Determine whether the {@link Class} identified by the supplied name is present\r\n * and can be loaded. Will return {@code false} if either the class or\r\n * one of its dependencies is not present or cannot be loaded.\r\n * @param className the name of the class to check\r\n * @param classLoader the class loader to use\r\n * (can be {@code null} which indicates the default class loader)\r\n * @return whether the specified class is present (including all of its\r\n * superclasses and interfaces)\r\n * @throws IllegalStateException if the corresponding class is resolvable but there\r\n * was a readability mismatch in the inheritance hierarchy of the class (typically a\r\n * missing dependency declaration in a Java Module System module definition for a\r\n * superclass or interface implemented by the class to be checked here)\r\n */\r\npublic static boolean isPresent(String className, @Nullable ClassLoader classLoader) {\r\n    try {\r\n        forName(className, classLoader);\r\n        return true;\r\n    } catch (IllegalAccessError err) {\r\n        throw new IllegalStateException(\"Readability mismatch in inheritance hierarchy of class [\" + className + \"]: \" + err.getMessage(), err);\r\n    } catch (Throwable ex) {\r\n        // Typically ClassNotFoundException or NoClassDefFoundError...\r\n        return false;\r\n    }\r\n}\n/**\r\n * Check whether the given class is visible in the given ClassLoader.\r\n * @param clazz the class to check (typically an interface)\r\n * @param classLoader the ClassLoader to check against\r\n * (can be {@code null} in which case this method will always return {@code true})\r\n */\r\npublic static boolean isVisible(Class<?> clazz, @Nullable ClassLoader classLoader) {\r\n    if (classLoader == null) {\r\n        return true;\r\n    }\r\n    try {\r\n        if (clazz.getClassLoader() == classLoader) {\r\n            return true;\r\n        }\r\n    } catch (SecurityException ex) {\r\n        // Fall through to loadable check below\r\n    }\r\n    // Visible if same Class can be loaded from given ClassLoader\r\n    return isLoadable(clazz, classLoader);\r\n}\n/**\r\n * Check whether the given class is cache-safe in the given context,\r\n * i.e. whether it is loaded by the given ClassLoader or a parent of it.\r\n * @param clazz the class to analyze\r\n * @param classLoader the ClassLoader to potentially cache metadata in\r\n * (can be {@code null} which indicates the system class loader)\r\n */\r\npublic static boolean isCacheSafe(Class<?> clazz, @Nullable ClassLoader classLoader) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    try {\r\n        ClassLoader target = clazz.getClassLoader();\r\n        // Common cases\r\n        if (target == classLoader || target == null) {\r\n            return true;\r\n        }\r\n        if (classLoader == null) {\r\n            return false;\r\n        }\r\n        // Check for match in ancestors -> positive\r\n        ClassLoader current = classLoader;\r\n        while (current != null) {\r\n            current = current.getParent();\r\n            if (current == target) {\r\n                return true;\r\n            }\r\n        }\r\n        // Check for match in children -> negative\r\n        while (target != null) {\r\n            target = target.getParent();\r\n            if (target == classLoader) {\r\n                return false;\r\n            }\r\n        }\r\n    } catch (SecurityException ex) {\r\n        // Fall through to loadable check below\r\n    }\r\n    // Fallback for ClassLoaders without parent/child relationship:\r\n    // safe if same Class can be loaded from given ClassLoader\r\n    return (classLoader != null && isLoadable(clazz, classLoader));\r\n}\n/**\r\n * Check whether the given class is loadable in the given ClassLoader.\r\n * @param clazz the class to check (typically an interface)\r\n * @param classLoader the ClassLoader to check against\r\n * @since 5.0.6\r\n */\r\nprivate static boolean isLoadable(Class<?> clazz, ClassLoader classLoader) {\r\n    try {\r\n        return (clazz == classLoader.loadClass(clazz.getName()));\r\n        // Else: different class with same name found\r\n    } catch (ClassNotFoundException ex) {\r\n        // No corresponding class found at all\r\n        return false;\r\n    }\r\n}\n/**\r\n * Resolve the given class name as primitive class, if appropriate,\r\n * according to the JVM's naming rules for primitive classes.\r\n * <p>Also supports the JVM's internal class names for primitive arrays.\r\n * Does <i>not</i> support the \"[]\" suffix notation for primitive arrays;\r\n * this is only supported by {@link #forName(String, ClassLoader)}.\r\n * @param name the name of the potentially primitive class\r\n * @return the primitive class, or {@code null} if the name does not denote\r\n * a primitive class or primitive array class\r\n */\r\n@Nullable\r\npublic static Class<?> resolvePrimitiveClassName(@Nullable String name) {\r\n    Class<?> result = null;\r\n    // Most class names will be quite long, considering that they\r\n    // SHOULD sit in a package, so a length check is worthwhile.\r\n    if (name != null && name.length() <= 7) {\r\n        // Could be a primitive - likely.\r\n        result = primitiveTypeNameMap.get(name);\r\n    }\r\n    return result;\r\n}\n/**\r\n * Check if the given class represents a primitive wrapper,\r\n * i.e. Boolean, Byte, Character, Short, Integer, Long, Float, Double, or\r\n * Void.\r\n * @param clazz the class to check\r\n * @return whether the given class is a primitive wrapper class\r\n */\r\npublic static boolean isPrimitiveWrapper(Class<?> clazz) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    return primitiveWrapperTypeMap.containsKey(clazz);\r\n}\n/**\r\n * Check if the given class represents a primitive (i.e. boolean, byte,\r\n * char, short, int, long, float, or double), {@code void}, or a wrapper for\r\n * those types (i.e. Boolean, Byte, Character, Short, Integer, Long, Float,\r\n * Double, or Void).\r\n * @param clazz the class to check\r\n * @return {@code true} if the given class represents a primitive, void, or\r\n * a wrapper class\r\n */\r\npublic static boolean isPrimitiveOrWrapper(Class<?> clazz) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    return (clazz.isPrimitive() || isPrimitiveWrapper(clazz));\r\n}\n/**\r\n * Check if the given class represents an array of primitives,\r\n * i.e. boolean, byte, char, short, int, long, float, or double.\r\n * @param clazz the class to check\r\n * @return whether the given class is a primitive array class\r\n */\r\npublic static boolean isPrimitiveArray(Class<?> clazz) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    return (clazz.isArray() && clazz.componentType().isPrimitive());\r\n}\n/**\r\n * Check if the given class represents an array of primitive wrappers,\r\n * i.e. Boolean, Byte, Character, Short, Integer, Long, Float, or Double.\r\n * @param clazz the class to check\r\n * @return whether the given class is a primitive wrapper array class\r\n */\r\npublic static boolean isPrimitiveWrapperArray(Class<?> clazz) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    return (clazz.isArray() && isPrimitiveWrapper(clazz.componentType()));\r\n}\n/**\r\n * Resolve the given class if it is a primitive class,\r\n * returning the corresponding primitive wrapper type instead.\r\n * @param clazz the class to check\r\n * @return the original class, or a primitive wrapper for the original primitive type\r\n */\r\n// Dataflow analysis limitation\r\n@SuppressWarnings(\"NullAway\")\r\npublic static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    return (clazz.isPrimitive() && clazz != void.class ? primitiveTypeToWrapperMap.get(clazz) : clazz);\r\n}\n/**\r\n * Determine if the given type represents either {@code Void} or {@code void}.\r\n * @param type the type to check\r\n * @return {@code true} if the type represents {@code Void} or {@code void}\r\n * @since 6.1.4\r\n * @see Void\r\n * @see Void#TYPE\r\n */\r\npublic static boolean isVoidType(@Nullable Class<?> type) {\r\n    return (type == void.class || type == Void.class);\r\n}\n/**\r\n * Delegate for {@link org.springframework.beans.BeanUtils#isSimpleValueType}.\r\n * Also used by {@link ObjectUtils#nullSafeConciseToString}.\r\n * <p>Check if the given type represents a common \"simple\" value type:\r\n * primitive or primitive wrapper, {@link Enum}, {@link String} or other\r\n * {@link CharSequence}, {@link Number}, {@link Date}, {@link Temporal},\r\n * {@link ZoneId}, {@link TimeZone}, {@link File}, {@link Path}, {@link URI},\r\n * {@link URL}, {@link InetAddress}, {@link Charset}, {@link Currency},\r\n * {@link Locale}, {@link UUID}, {@link Pattern}, or {@link Class}.\r\n * <p>{@code Void} and {@code void} are not considered simple value types.\r\n * @param type the type to check\r\n * @return whether the given type represents a \"simple\" value type,\r\n * suggesting value-based data binding and {@code toString} output\r\n * @since 6.1\r\n */\r\npublic static boolean isSimpleValueType(Class<?> type) {\r\n    return (!isVoidType(type) && (isPrimitiveOrWrapper(type) || Enum.class.isAssignableFrom(type) || CharSequence.class.isAssignableFrom(type) || Number.class.isAssignableFrom(type) || Date.class.isAssignableFrom(type) || Temporal.class.isAssignableFrom(type) || ZoneId.class.isAssignableFrom(type) || TimeZone.class.isAssignableFrom(type) || File.class.isAssignableFrom(type) || Path.class.isAssignableFrom(type) || Charset.class.isAssignableFrom(type) || Currency.class.isAssignableFrom(type) || InetAddress.class.isAssignableFrom(type) || URI.class == type || URL.class == type || UUID.class == type || Locale.class == type || Pattern.class == type || Class.class == type));\r\n}\n/**\r\n * Check if the right-hand side type may be assigned to the left-hand side\r\n * type, assuming setting by reflection. Considers primitive wrapper\r\n * classes as assignable to the corresponding primitive types.\r\n * @param lhsType the target type (left-hand side (LHS) type)\r\n * @param rhsType the value type (right-hand side (RHS) type) that should\r\n * be assigned to the target type\r\n * @return {@code true} if {@code rhsType} is assignable to {@code lhsType}\r\n * @see TypeUtils#isAssignable(java.lang.reflect.Type, java.lang.reflect.Type)\r\n */\r\npublic static boolean isAssignable(Class<?> lhsType, Class<?> rhsType) {\r\n    Assert.notNull(lhsType, \"Left-hand side type must not be null\");\r\n    Assert.notNull(rhsType, \"Right-hand side type must not be null\");\r\n    if (lhsType.isAssignableFrom(rhsType)) {\r\n        return true;\r\n    }\r\n    if (lhsType.isPrimitive()) {\r\n        Class<?> resolvedPrimitive = primitiveWrapperTypeMap.get(rhsType);\r\n        return (lhsType == resolvedPrimitive);\r\n    } else {\r\n        Class<?> resolvedWrapper = primitiveTypeToWrapperMap.get(rhsType);\r\n        return (resolvedWrapper != null && lhsType.isAssignableFrom(resolvedWrapper));\r\n    }\r\n}\n/**\r\n * Determine if the given type is assignable from the given value,\r\n * assuming setting by reflection. Considers primitive wrapper classes\r\n * as assignable to the corresponding primitive types.\r\n * @param type the target type\r\n * @param value the value that should be assigned to the type\r\n * @return if the type is assignable from the value\r\n */\r\npublic static boolean isAssignableValue(Class<?> type, @Nullable Object value) {\r\n    Assert.notNull(type, \"Type must not be null\");\r\n    return (value != null ? isAssignable(type, value.getClass()) : !type.isPrimitive());\r\n}\n/**\r\n * Convert a \"/\"-based resource path to a \".\"-based fully qualified class name.\r\n * @param resourcePath the resource path pointing to a class\r\n * @return the corresponding fully qualified class name\r\n */\r\npublic static String convertResourcePathToClassName(String resourcePath) {\r\n    Assert.notNull(resourcePath, \"Resource path must not be null\");\r\n    return resourcePath.replace(PATH_SEPARATOR, PACKAGE_SEPARATOR);\r\n}\n/**\r\n * Convert a \".\"-based fully qualified class name to a \"/\"-based resource path.\r\n * @param className the fully qualified class name\r\n * @return the corresponding resource path, pointing to the class\r\n */\r\npublic static String convertClassNameToResourcePath(String className) {\r\n    Assert.notNull(className, \"Class name must not be null\");\r\n    return className.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\r\n}\n/**\r\n * Return a path suitable for use with {@code ClassLoader.getResource}\r\n * (also suitable for use with {@code Class.getResource} by prepending a\r\n * slash ('/') to the return value). Built by taking the package of the specified\r\n * class file, converting all dots ('.') to slashes ('/'), adding a trailing slash\r\n * if necessary, and concatenating the specified resource name to this.\r\n * <br/>As such, this function may be used to build a path suitable for\r\n * loading a resource file that is in the same package as a class file,\r\n * although {@link org.springframework.core.io.ClassPathResource} is usually\r\n * even more convenient.\r\n * @param clazz the Class whose package will be used as the base\r\n * @param resourceName the resource name to append. A leading slash is optional.\r\n * @return the built-up resource path\r\n * @see ClassLoader#getResource\r\n * @see Class#getResource\r\n */\r\npublic static String addResourcePathToPackagePath(Class<?> clazz, String resourceName) {\r\n    Assert.notNull(resourceName, \"Resource name must not be null\");\r\n    if (!resourceName.startsWith(\"/\")) {\r\n        return classPackageAsResourcePath(clazz) + PATH_SEPARATOR + resourceName;\r\n    }\r\n    return classPackageAsResourcePath(clazz) + resourceName;\r\n}\n/**\r\n * Given an input class object, return a string which consists of the\r\n * class's package name as a pathname, i.e., all dots ('.') are replaced by\r\n * slashes ('/'). Neither a leading nor trailing slash is added. The result\r\n * could be concatenated with a slash and the name of a resource and fed\r\n * directly to {@code ClassLoader.getResource()}. For it to be fed to\r\n * {@code Class.getResource} instead, a leading slash would also have\r\n * to be prepended to the returned value.\r\n * @param clazz the input class. A {@code null} value or the default\r\n * (empty) package will result in an empty string (\"\") being returned.\r\n * @return a path which represents the package name\r\n * @see ClassLoader#getResource\r\n * @see Class#getResource\r\n */\r\npublic static String classPackageAsResourcePath(@Nullable Class<?> clazz) {\r\n    if (clazz == null) {\r\n        return \"\";\r\n    }\r\n    String className = clazz.getName();\r\n    int packageEndIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\r\n    if (packageEndIndex == -1) {\r\n        return \"\";\r\n    }\r\n    String packageName = className.substring(0, packageEndIndex);\r\n    return packageName.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\r\n}\n/**\r\n * Build a String that consists of the names of the classes/interfaces\r\n * in the given array.\r\n * <p>Basically like {@code AbstractCollection.toString()}, but stripping\r\n * the \"class \"/\"interface \" prefix before every class name.\r\n * @param classes an array of Class objects\r\n * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\r\n * @see java.util.AbstractCollection#toString()\r\n */\r\npublic static String classNamesToString(Class<?>... classes) {\r\n    return classNamesToString(Arrays.asList(classes));\r\n}\n/**\r\n * Build a String that consists of the names of the classes/interfaces\r\n * in the given collection.\r\n * <p>Basically like {@code AbstractCollection.toString()}, but stripping\r\n * the \"class \"/\"interface \" prefix before every class name.\r\n * @param classes a Collection of Class objects (can be {@code null})\r\n * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\r\n * @see java.util.AbstractCollection#toString()\r\n */\r\npublic static String classNamesToString(@Nullable Collection<Class<?>> classes) {\r\n    if (CollectionUtils.isEmpty(classes)) {\r\n        return \"[]\";\r\n    }\r\n    StringJoiner stringJoiner = new StringJoiner(\", \", \"[\", \"]\");\r\n    for (Class<?> clazz : classes) {\r\n        stringJoiner.add(clazz.getName());\r\n    }\r\n    return stringJoiner.toString();\r\n}\n/**\r\n * Copy the given {@code Collection} into a {@code Class} array.\r\n * <p>The {@code Collection} must contain {@code Class} elements only.\r\n * @param collection the {@code Collection} to copy\r\n * @return the {@code Class} array\r\n * @since 3.1\r\n * @see StringUtils#toStringArray\r\n */\r\npublic static Class<?>[] toClassArray(@Nullable Collection<Class<?>> collection) {\r\n    return (!CollectionUtils.isEmpty(collection) ? collection.toArray(EMPTY_CLASS_ARRAY) : EMPTY_CLASS_ARRAY);\r\n}\n/**\r\n * Return all interfaces that the given instance implements as an array,\r\n * including ones implemented by superclasses.\r\n * @param instance the instance to analyze for interfaces\r\n * @return all interfaces that the given instance implements as an array\r\n */\r\npublic static Class<?>[] getAllInterfaces(Object instance) {\r\n    Assert.notNull(instance, \"Instance must not be null\");\r\n    return getAllInterfacesForClass(instance.getClass());\r\n}\n/**\r\n * Return all interfaces that the given class implements as an array,\r\n * including ones implemented by superclasses.\r\n * <p>If the class itself is an interface, it gets returned as sole interface.\r\n * @param clazz the class to analyze for interfaces\r\n * @return all interfaces that the given object implements as an array\r\n */\r\npublic static Class<?>[] getAllInterfacesForClass(Class<?> clazz) {\r\n    return getAllInterfacesForClass(clazz, null);\r\n}\n/**\r\n * Return all interfaces that the given class implements as an array,\r\n * including ones implemented by superclasses.\r\n * <p>If the class itself is an interface, it gets returned as sole interface.\r\n * @param clazz the class to analyze for interfaces\r\n * @param classLoader the ClassLoader that the interfaces need to be visible in\r\n * (can be {@code null} when accepting all declared interfaces)\r\n * @return all interfaces that the given object implements as an array\r\n */\r\npublic static Class<?>[] getAllInterfacesForClass(Class<?> clazz, @Nullable ClassLoader classLoader) {\r\n    return toClassArray(getAllInterfacesForClassAsSet(clazz, classLoader));\r\n}\n/**\r\n * Return all interfaces that the given instance implements as a Set,\r\n * including ones implemented by superclasses.\r\n * @param instance the instance to analyze for interfaces\r\n * @return all interfaces that the given instance implements as a Set\r\n */\r\npublic static Set<Class<?>> getAllInterfacesAsSet(Object instance) {\r\n    Assert.notNull(instance, \"Instance must not be null\");\r\n    return getAllInterfacesForClassAsSet(instance.getClass());\r\n}\n/**\r\n * Return all interfaces that the given class implements as a Set,\r\n * including ones implemented by superclasses.\r\n * <p>If the class itself is an interface, it gets returned as sole interface.\r\n * @param clazz the class to analyze for interfaces\r\n * @return all interfaces that the given object implements as a Set\r\n */\r\npublic static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz) {\r\n    return getAllInterfacesForClassAsSet(clazz, null);\r\n}\n/**\r\n * Return all interfaces that the given class implements as a Set,\r\n * including ones implemented by superclasses.\r\n * <p>If the class itself is an interface, it gets returned as sole interface.\r\n * @param clazz the class to analyze for interfaces\r\n * @param classLoader the ClassLoader that the interfaces need to be visible in\r\n * (can be {@code null} when accepting all declared interfaces)\r\n * @return all interfaces that the given object implements as a Set\r\n */\r\npublic static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, @Nullable ClassLoader classLoader) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    if (clazz.isInterface() && isVisible(clazz, classLoader)) {\r\n        return Collections.singleton(clazz);\r\n    }\r\n    Set<Class<?>> interfaces = new LinkedHashSet<>();\r\n    Class<?> current = clazz;\r\n    while (current != null) {\r\n        Class<?>[] ifcs = current.getInterfaces();\r\n        for (Class<?> ifc : ifcs) {\r\n            if (isVisible(ifc, classLoader)) {\r\n                interfaces.add(ifc);\r\n            }\r\n        }\r\n        current = current.getSuperclass();\r\n    }\r\n    return interfaces;\r\n}\n/**\r\n * Create a composite interface Class for the given interfaces,\r\n * implementing the given interfaces in one single Class.\r\n * <p>This implementation builds a JDK proxy class for the given interfaces.\r\n * @param interfaces the interfaces to merge\r\n * @param classLoader the ClassLoader to create the composite Class in\r\n * @return the merged interface as Class\r\n * @throws IllegalArgumentException if the specified interfaces expose\r\n * conflicting method signatures (or a similar constraint is violated)\r\n * @see java.lang.reflect.Proxy#getProxyClass\r\n */\r\n@SuppressWarnings(\"deprecation\")\r\npublic static Class<?> createCompositeInterface(Class<?>[] interfaces, @Nullable ClassLoader classLoader) {\r\n    Assert.notEmpty(interfaces, \"Interface array must not be empty\");\r\n    return Proxy.getProxyClass(classLoader, interfaces);\r\n}\n/**\r\n * Determine the common ancestor of the given classes, if any.\r\n * @param clazz1 the class to introspect\r\n * @param clazz2 the other class to introspect\r\n * @return the common ancestor (i.e. common superclass, one interface\r\n * extending the other), or {@code null} if none found. If any of the\r\n * given classes is {@code null}, the other class will be returned.\r\n * @since 3.2.6\r\n */\r\n@Nullable\r\npublic static Class<?> determineCommonAncestor(@Nullable Class<?> clazz1, @Nullable Class<?> clazz2) {\r\n    if (clazz1 == null) {\r\n        return clazz2;\r\n    }\r\n    if (clazz2 == null) {\r\n        return clazz1;\r\n    }\r\n    if (clazz1.isAssignableFrom(clazz2)) {\r\n        return clazz1;\r\n    }\r\n    if (clazz2.isAssignableFrom(clazz1)) {\r\n        return clazz2;\r\n    }\r\n    Class<?> ancestor = clazz1;\r\n    do {\r\n        ancestor = ancestor.getSuperclass();\r\n        if (ancestor == null || Object.class == ancestor) {\r\n            return null;\r\n        }\r\n    } while (!ancestor.isAssignableFrom(clazz2));\r\n    return ancestor;\r\n}\n/**\r\n * Determine whether the given interface is a common Java language interface:\r\n * {@link Serializable}, {@link Externalizable}, {@link Closeable}, {@link AutoCloseable},\r\n * {@link Cloneable}, {@link Comparable} - all of which can be ignored when looking\r\n * for 'primary' user-level interfaces. Common characteristics: no service-level\r\n * operations, no bean property methods, no default methods.\r\n * @param ifc the interface to check\r\n * @since 5.0.3\r\n */\r\npublic static boolean isJavaLanguageInterface(Class<?> ifc) {\r\n    return javaLanguageInterfaces.contains(ifc);\r\n}\n/**\r\n * Determine if the supplied class is a static class.\r\n * @return {@code true} if the supplied class is a static class\r\n * @since 6.0\r\n * @see Modifier#isStatic(int)\r\n * @see #isInnerClass(Class)\r\n */\r\npublic static boolean isStaticClass(Class<?> clazz) {\r\n    return Modifier.isStatic(clazz.getModifiers());\r\n}\n/**\r\n * Determine if the supplied class is an <em>inner class</em>,\r\n * i.e. a non-static member of an enclosing class.\r\n * @return {@code true} if the supplied class is an inner class\r\n * @since 5.0.5\r\n * @see Class#isMemberClass()\r\n * @see #isStaticClass(Class)\r\n */\r\npublic static boolean isInnerClass(Class<?> clazz) {\r\n    return (clazz.isMemberClass() && !isStaticClass(clazz));\r\n}\n/**\r\n * Determine if the supplied {@link Class} is a JVM-generated implementation\r\n * class for a lambda expression or method reference.\r\n * <p>This method makes a best-effort attempt at determining this, based on\r\n * checks that work on modern, mainstream JVMs.\r\n * @param clazz the class to check\r\n * @return {@code true} if the class is a lambda implementation class\r\n * @since 5.3.19\r\n */\r\npublic static boolean isLambdaClass(Class<?> clazz) {\r\n    return (clazz.isSynthetic() && (clazz.getSuperclass() == Object.class) && (clazz.getInterfaces().length > 0) && clazz.getName().contains(\"$$Lambda\"));\r\n}\n/**\r\n * Check whether the given object is a CGLIB proxy.\r\n * @param object the object to check\r\n * @see org.springframework.aop.support.AopUtils#isCglibProxy(Object)\r\n * @deprecated as of 5.2, in favor of custom (possibly narrower) checks\r\n * such as for a Spring AOP proxy\r\n */\r\n@Deprecated\r\npublic static boolean isCglibProxy(Object object) {\r\n    return isCglibProxyClass(object.getClass());\r\n}\n/**\r\n * Check whether the specified class is a CGLIB-generated class.\r\n * @param clazz the class to check\r\n * @see #getUserClass(Class)\r\n * @deprecated as of 5.2, in favor of custom (possibly narrower) checks\r\n * or simply a check for containing {@link #CGLIB_CLASS_SEPARATOR}\r\n */\r\n@Deprecated\r\npublic static boolean isCglibProxyClass(@Nullable Class<?> clazz) {\r\n    return (clazz != null && isCglibProxyClassName(clazz.getName()));\r\n}\n/**\r\n * Check whether the specified class name is a CGLIB-generated class.\r\n * @param className the class name to check\r\n * @see #CGLIB_CLASS_SEPARATOR\r\n * @deprecated as of 5.2, in favor of custom (possibly narrower) checks\r\n * or simply a check for containing {@link #CGLIB_CLASS_SEPARATOR}\r\n */\r\n@Deprecated\r\npublic static boolean isCglibProxyClassName(@Nullable String className) {\r\n    return (className != null && className.contains(CGLIB_CLASS_SEPARATOR));\r\n}\n/**\r\n * Return the user-defined class for the given instance: usually simply\r\n * the class of the given instance, but the original class in case of a\r\n * CGLIB-generated subclass.\r\n * @param instance the instance to check\r\n * @return the user-defined class\r\n */\r\npublic static Class<?> getUserClass(Object instance) {\r\n    Assert.notNull(instance, \"Instance must not be null\");\r\n    return getUserClass(instance.getClass());\r\n}\n/**\r\n * Return the user-defined class for the given class: usually simply the given\r\n * class, but the original class in case of a CGLIB-generated subclass.\r\n * @param clazz the class to check\r\n * @return the user-defined class\r\n * @see #CGLIB_CLASS_SEPARATOR\r\n */\r\npublic static Class<?> getUserClass(Class<?> clazz) {\r\n    if (clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) {\r\n        Class<?> superclass = clazz.getSuperclass();\r\n        if (superclass != null && superclass != Object.class) {\r\n            return superclass;\r\n        }\r\n    }\r\n    return clazz;\r\n}\n/**\r\n * Return a descriptive name for the given object's type: usually simply\r\n * the class name, but component type class name + \"[]\" for arrays,\r\n * and an appended list of implemented interfaces for JDK proxies.\r\n * @param value the value to introspect\r\n * @return the qualified name of the class\r\n */\r\n@Nullable\r\npublic static String getDescriptiveType(@Nullable Object value) {\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    Class<?> clazz = value.getClass();\r\n    if (Proxy.isProxyClass(clazz)) {\r\n        String prefix = clazz.getTypeName() + \" implementing \";\r\n        StringJoiner result = new StringJoiner(\",\", prefix, \"\");\r\n        for (Class<?> ifc : clazz.getInterfaces()) {\r\n            result.add(ifc.getTypeName());\r\n        }\r\n        return result.toString();\r\n    } else {\r\n        return clazz.getTypeName();\r\n    }\r\n}\n/**\r\n * Check whether the given class matches the user-specified type name.\r\n * @param clazz the class to check\r\n * @param typeName the type name to match\r\n */\r\npublic static boolean matchesTypeName(Class<?> clazz, @Nullable String typeName) {\r\n    return (typeName != null && (typeName.equals(clazz.getTypeName()) || typeName.equals(clazz.getSimpleName())));\r\n}\n/**\r\n * Get the class name without the qualified package name.\r\n * @param className the className to get the short name for\r\n * @return the class name of the class without the package name\r\n * @throws IllegalArgumentException if the className is empty\r\n */\r\npublic static String getShortName(String className) {\r\n    Assert.hasLength(className, \"Class name must not be empty\");\r\n    int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\r\n    int nameEndIndex = className.indexOf(CGLIB_CLASS_SEPARATOR);\r\n    if (nameEndIndex == -1) {\r\n        nameEndIndex = className.length();\r\n    }\r\n    String shortName = className.substring(lastDotIndex + 1, nameEndIndex);\r\n    shortName = shortName.replace(NESTED_CLASS_SEPARATOR, PACKAGE_SEPARATOR);\r\n    return shortName;\r\n}\n/**\r\n * Get the class name without the qualified package name.\r\n * @param clazz the class to get the short name for\r\n * @return the class name of the class without the package name\r\n */\r\npublic static String getShortName(Class<?> clazz) {\r\n    return getShortName(getQualifiedName(clazz));\r\n}\n/**\r\n * Return the short string name of a Java class in uncapitalized JavaBeans\r\n * property format. Strips the outer class name in case of a nested class.\r\n * @param clazz the class\r\n * @return the short name rendered in a standard JavaBeans property format\r\n * @see StringUtils#uncapitalizeAsProperty(String)\r\n */\r\npublic static String getShortNameAsProperty(Class<?> clazz) {\r\n    String shortName = getShortName(clazz);\r\n    int dotIndex = shortName.lastIndexOf(PACKAGE_SEPARATOR);\r\n    shortName = (dotIndex != -1 ? shortName.substring(dotIndex + 1) : shortName);\r\n    return StringUtils.uncapitalizeAsProperty(shortName);\r\n}\n/**\r\n * Determine the name of the class file, relative to the containing\r\n * package: for example, \"String.class\".\r\n * @param clazz the class\r\n * @return the file name of the \".class\" file\r\n */\r\npublic static String getClassFileName(Class<?> clazz) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    String className = clazz.getName();\r\n    int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\r\n    return className.substring(lastDotIndex + 1) + CLASS_FILE_SUFFIX;\r\n}\n/**\r\n * Determine the name of the package of the given class,\r\n * for example, \"java.lang\" for the {@code java.lang.String} class.\r\n * @param clazz the class\r\n * @return the package name, or the empty String if the class\r\n * is defined in the default package\r\n */\r\npublic static String getPackageName(Class<?> clazz) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    return getPackageName(clazz.getName());\r\n}\n/**\r\n * Determine the name of the package of the given fully-qualified class name,\r\n * for example, \"java.lang\" for the {@code java.lang.String} class name.\r\n * @param fqClassName the fully-qualified class name\r\n * @return the package name, or the empty String if the class\r\n * is defined in the default package\r\n */\r\npublic static String getPackageName(String fqClassName) {\r\n    Assert.notNull(fqClassName, \"Class name must not be null\");\r\n    int lastDotIndex = fqClassName.lastIndexOf(PACKAGE_SEPARATOR);\r\n    return (lastDotIndex != -1 ? fqClassName.substring(0, lastDotIndex) : \"\");\r\n}\n/**\r\n * Return the qualified name of the given class: usually simply\r\n * the class name, but component type class name + \"[]\" for arrays.\r\n * @param clazz the class\r\n * @return the qualified name of the class\r\n */\r\npublic static String getQualifiedName(Class<?> clazz) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    return clazz.getTypeName();\r\n}\n/**\r\n * Return the qualified name of the given method, consisting of\r\n * fully qualified interface/class name + \".\" + method name.\r\n * @param method the method\r\n * @return the qualified name of the method\r\n */\r\npublic static String getQualifiedMethodName(Method method) {\r\n    return getQualifiedMethodName(method, null);\r\n}\n/**\r\n * Return the qualified name of the given method, consisting of\r\n * fully qualified interface/class name + \".\" + method name.\r\n * @param method the method\r\n * @param clazz the clazz that the method is being invoked on\r\n * (can be {@code null} to indicate the method's declaring class)\r\n * @return the qualified name of the method\r\n * @since 4.3.4\r\n */\r\npublic static String getQualifiedMethodName(Method method, @Nullable Class<?> clazz) {\r\n    Assert.notNull(method, \"Method must not be null\");\r\n    return (clazz != null ? clazz : method.getDeclaringClass()).getName() + '.' + method.getName();\r\n}\n/**\r\n * Determine whether the given class has a public constructor with the given signature.\r\n * <p>Essentially translates {@code NoSuchMethodException} to \"false\".\r\n * @param clazz the clazz to analyze\r\n * @param paramTypes the parameter types of the method\r\n * @return whether the class has a corresponding constructor\r\n * @see Class#getConstructor\r\n */\r\npublic static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes) {\r\n    return (getConstructorIfAvailable(clazz, paramTypes) != null);\r\n}\n/**\r\n * Determine whether the given class has a public constructor with the given signature,\r\n * and return it if available (else return {@code null}).\r\n * <p>Essentially translates {@code NoSuchMethodException} to {@code null}.\r\n * @param clazz the clazz to analyze\r\n * @param paramTypes the parameter types of the method\r\n * @return the constructor, or {@code null} if not found\r\n * @see Class#getConstructor\r\n */\r\n@Nullable\r\npublic static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    try {\r\n        return clazz.getConstructor(paramTypes);\r\n    } catch (NoSuchMethodException ex) {\r\n        return null;\r\n    }\r\n}\n/**\r\n * Determine whether the given class has a public method with the given signature.\r\n * @param clazz the clazz to analyze\r\n * @param method the method to look for\r\n * @return whether the class has a corresponding method\r\n * @since 5.2.3\r\n */\r\npublic static boolean hasMethod(Class<?> clazz, Method method) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    Assert.notNull(method, \"Method must not be null\");\r\n    if (clazz == method.getDeclaringClass()) {\r\n        return true;\r\n    }\r\n    String methodName = method.getName();\r\n    Class<?>[] paramTypes = method.getParameterTypes();\r\n    return getMethodOrNull(clazz, methodName, paramTypes) != null;\r\n}\n/**\r\n * Determine whether the given class has a public method with the given signature.\r\n * <p>Essentially translates {@code NoSuchMethodException} to \"false\".\r\n * @param clazz the clazz to analyze\r\n * @param methodName the name of the method\r\n * @param paramTypes the parameter types of the method\r\n * @return whether the class has a corresponding method\r\n * @see Class#getMethod\r\n */\r\npublic static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\r\n    return (getMethodIfAvailable(clazz, methodName, paramTypes) != null);\r\n}\n/**\r\n * Determine whether the given class has a public method with the given signature,\r\n * and return it if available (else throws an {@code IllegalStateException}).\r\n * <p>In case of any signature specified, only returns the method if there is a\r\n * unique candidate, i.e. a single public method with the specified name.\r\n * <p>Essentially translates {@code NoSuchMethodException} to {@code IllegalStateException}.\r\n * @param clazz the clazz to analyze\r\n * @param methodName the name of the method\r\n * @param paramTypes the parameter types of the method\r\n * (can be {@code null} to indicate any signature)\r\n * @return the method (never {@code null})\r\n * @throws IllegalStateException if the method has not been found\r\n * @see Class#getMethod\r\n */\r\npublic static Method getMethod(Class<?> clazz, String methodName, @Nullable Class<?>... paramTypes) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    Assert.notNull(methodName, \"Method name must not be null\");\r\n    if (paramTypes != null) {\r\n        try {\r\n            return clazz.getMethod(methodName, paramTypes);\r\n        } catch (NoSuchMethodException ex) {\r\n            throw new IllegalStateException(\"Expected method not found: \" + ex);\r\n        }\r\n    } else {\r\n        Set<Method> candidates = findMethodCandidatesByName(clazz, methodName);\r\n        if (candidates.size() == 1) {\r\n            return candidates.iterator().next();\r\n        } else if (candidates.isEmpty()) {\r\n            throw new IllegalStateException(\"Expected method not found: \" + clazz.getName() + '.' + methodName);\r\n        } else {\r\n            throw new IllegalStateException(\"No unique method found: \" + clazz.getName() + '.' + methodName);\r\n        }\r\n    }\r\n}\n/**\r\n * Determine whether the given class has a public method with the given signature,\r\n * and return it if available (else return {@code null}).\r\n * <p>In case of any signature specified, only returns the method if there is a\r\n * unique candidate, i.e. a single public method with the specified name.\r\n * <p>Essentially translates {@code NoSuchMethodException} to {@code null}.\r\n * @param clazz the clazz to analyze\r\n * @param methodName the name of the method\r\n * @param paramTypes the parameter types of the method\r\n * (can be {@code null} to indicate any signature)\r\n * @return the method, or {@code null} if not found\r\n * @see Class#getMethod\r\n */\r\n@Nullable\r\npublic static Method getMethodIfAvailable(Class<?> clazz, String methodName, @Nullable Class<?>@Nullable ... paramTypes) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    Assert.notNull(methodName, \"Method name must not be null\");\r\n    if (paramTypes != null) {\r\n        return getMethodOrNull(clazz, methodName, paramTypes);\r\n    } else {\r\n        Set<Method> candidates = findMethodCandidatesByName(clazz, methodName);\r\n        if (candidates.size() == 1) {\r\n            return candidates.iterator().next();\r\n        }\r\n        return null;\r\n    }\r\n}\n/**\r\n * Return the number of methods with a given name (with any argument types),\r\n * for the given class and/or its superclasses. Includes non-public methods.\r\n * @param clazz\tthe clazz to check\r\n * @param methodName the name of the method\r\n * @return the number of methods with the given name\r\n */\r\npublic static int getMethodCountForName(Class<?> clazz, String methodName) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    Assert.notNull(methodName, \"Method name must not be null\");\r\n    int count = 0;\r\n    Method[] declaredMethods = clazz.getDeclaredMethods();\r\n    for (Method method : declaredMethods) {\r\n        if (methodName.equals(method.getName())) {\r\n            count++;\r\n        }\r\n    }\r\n    Class<?>[] ifcs = clazz.getInterfaces();\r\n    for (Class<?> ifc : ifcs) {\r\n        count += getMethodCountForName(ifc, methodName);\r\n    }\r\n    if (clazz.getSuperclass() != null) {\r\n        count += getMethodCountForName(clazz.getSuperclass(), methodName);\r\n    }\r\n    return count;\r\n}\n/**\r\n * Does the given class or one of its superclasses at least have one or more\r\n * methods with the supplied name (with any argument types)?\r\n * Includes non-public methods.\r\n * @param clazz\tthe clazz to check\r\n * @param methodName the name of the method\r\n * @return whether there is at least one method with the given name\r\n */\r\npublic static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    Assert.notNull(methodName, \"Method name must not be null\");\r\n    Method[] declaredMethods = clazz.getDeclaredMethods();\r\n    for (Method method : declaredMethods) {\r\n        if (method.getName().equals(methodName)) {\r\n            return true;\r\n        }\r\n    }\r\n    Class<?>[] ifcs = clazz.getInterfaces();\r\n    for (Class<?> ifc : ifcs) {\r\n        if (hasAtLeastOneMethodWithName(ifc, methodName)) {\r\n            return true;\r\n        }\r\n    }\r\n    return (clazz.getSuperclass() != null && hasAtLeastOneMethodWithName(clazz.getSuperclass(), methodName));\r\n}\n/**\r\n * Given a method, which may come from an interface, and a target class used\r\n * in the current reflective invocation, find the corresponding target method\r\n * if there is one &mdash; for example, the method may be {@code IFoo.bar()},\r\n * and the target class may be {@code DefaultFoo}. In this case, the method may be\r\n * {@code DefaultFoo.bar()}. This enables attributes on that method to be found.\r\n * <p><b>NOTE:</b> In contrast to {@link org.springframework.aop.support.AopUtils#getMostSpecificMethod},\r\n * this method does <i>not</i> resolve bridge methods automatically.\r\n * Call {@link org.springframework.core.BridgeMethodResolver#findBridgedMethod}\r\n * if bridge method resolution is desirable &mdash; for example, to obtain\r\n * metadata from the original method definition.\r\n * <p><b>NOTE:</b> If Java security settings disallow reflective access &mdash;\r\n * for example, calls to {@code Class#getDeclaredMethods}, etc. &mdash; this\r\n * implementation will fall back to returning the originally provided method.\r\n * @param method the method to be invoked, which may come from an interface\r\n * @param targetClass the target class for the current invocation\r\n * (can be {@code null} or may not even implement the method)\r\n * @return the specific target method, or the original method if the\r\n * {@code targetClass} does not implement it\r\n * @see #getInterfaceMethodIfPossible(Method, Class)\r\n */\r\npublic static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass) {\r\n    if (targetClass != null && targetClass != method.getDeclaringClass() && (isOverridable(method, targetClass) || !method.getDeclaringClass().isAssignableFrom(targetClass))) {\r\n        try {\r\n            if (Modifier.isPublic(method.getModifiers())) {\r\n                try {\r\n                    return targetClass.getMethod(method.getName(), method.getParameterTypes());\r\n                } catch (NoSuchMethodException ex) {\r\n                    return method;\r\n                }\r\n            } else {\r\n                Method specificMethod = ReflectionUtils.findMethod(targetClass, method.getName(), method.getParameterTypes());\r\n                return (specificMethod != null ? specificMethod : method);\r\n            }\r\n        } catch (SecurityException ex) {\r\n            // Security settings are disallowing reflective access; fall back to 'method' below.\r\n        }\r\n    }\r\n    return method;\r\n}\n/**\r\n * Determine a corresponding interface method for the given method handle, if possible.\r\n * <p>This is particularly useful for arriving at a public exported type on the Java\r\n * Module System which allows the method to be invoked via reflection without an illegal\r\n * access warning.\r\n * @param method the method to be invoked, potentially from an implementation class\r\n * @return the corresponding interface method, or the original method if none found\r\n * @since 5.1\r\n * @see #getPubliclyAccessibleMethodIfPossible(Method, Class)\r\n * @deprecated in favor of {@link #getInterfaceMethodIfPossible(Method, Class)}\r\n */\r\n@Deprecated\r\npublic static Method getInterfaceMethodIfPossible(Method method) {\r\n    return getInterfaceMethodIfPossible(method, null);\r\n}\n/**\r\n * Determine a corresponding interface method for the given method handle, if possible.\r\n * <p>This is particularly useful for arriving at a public exported type on the Java\r\n * Module System which allows the method to be invoked via reflection without an illegal\r\n * access warning.\r\n * @param method the method to be invoked, potentially from an implementation class\r\n * @param targetClass the target class to invoke the method on, or {@code null} if unknown\r\n * @return the corresponding interface method, or the original method if none found\r\n * @since 5.3.16\r\n * @see #getPubliclyAccessibleMethodIfPossible(Method, Class)\r\n * @see #getMostSpecificMethod\r\n */\r\npublic static Method getInterfaceMethodIfPossible(Method method, @Nullable Class<?> targetClass) {\r\n    return getInterfaceMethodIfPossible(method, targetClass, false);\r\n}\nprivate static Method getInterfaceMethodIfPossible(Method method, @Nullable Class<?> targetClass, boolean requirePublicInterface) {\r\n    Class<?> declaringClass = method.getDeclaringClass();\r\n    if (!Modifier.isPublic(method.getModifiers()) || (declaringClass.isInterface() && (!requirePublicInterface || Modifier.isPublic(declaringClass.getModifiers())))) {\r\n        return method;\r\n    }\r\n    String methodName = method.getName();\r\n    Class<?>[] parameterTypes = method.getParameterTypes();\r\n    Map<Method, Method> methodCache = (requirePublicInterface ? publicInterfaceMethodCache : interfaceMethodCache);\r\n    // Try cached version of method in its declaring class\r\n    Method result = methodCache.computeIfAbsent(method, key -> findInterfaceMethodIfPossible(methodName, parameterTypes, declaringClass, Object.class, requirePublicInterface));\r\n    if (result == null && targetClass != null) {\r\n        // No interface method found yet -> try given target class (possibly a subclass of the\r\n        // declaring class, late-binding a base class method to a subclass-declared interface:\r\n        // see, for example, HashMap.HashIterator.hasNext)\r\n        result = findInterfaceMethodIfPossible(methodName, parameterTypes, targetClass, declaringClass, requirePublicInterface);\r\n    }\r\n    return (result != null ? result : method);\r\n}\n@Nullable\r\nprivate static Method findInterfaceMethodIfPossible(String methodName, Class<?>[] parameterTypes, Class<?> startClass, Class<?> endClass, boolean requirePublicInterface) {\r\n    Class<?> current = startClass;\r\n    while (current != null && current != endClass) {\r\n        for (Class<?> ifc : current.getInterfaces()) {\r\n            try {\r\n                if (!requirePublicInterface || Modifier.isPublic(ifc.getModifiers())) {\r\n                    return ifc.getMethod(methodName, parameterTypes);\r\n                }\r\n            } catch (NoSuchMethodException ex) {\r\n                // ignore\r\n            }\r\n        }\r\n        current = current.getSuperclass();\r\n    }\r\n    return null;\r\n}\n/**\r\n * Get the first publicly accessible method in the supplied method's type hierarchy that\r\n * has a method signature equivalent to the supplied method, if possible.\r\n * <p>If the supplied method is {@code public} and declared in a {@code public} type,\r\n * the supplied method will be returned.\r\n * <p>Otherwise, this method recursively searches the class hierarchy and implemented\r\n * interfaces for an equivalent method that is {@code public} and declared in a\r\n * {@code public} type.\r\n * <p>If a publicly accessible equivalent method cannot be found, the supplied method\r\n * will be returned, indicating that no such equivalent method exists. Consequently,\r\n * callers of this method must manually validate the accessibility of the returned method\r\n * if public access is a requirement.\r\n * <p>This is particularly useful for arriving at a public exported type on the Java\r\n * Module System which allows the method to be invoked via reflection without an illegal\r\n * access warning. This is also useful for invoking methods via a public API in bytecode\r\n * &mdash; for example, for use with the Spring Expression Language (SpEL) compiler.\r\n * For example, if a non-public class overrides {@code toString()}, this method will\r\n * traverse up the type hierarchy to find the first public type that declares the method\r\n * (if there is one). For {@code toString()}, it may traverse as far as {@link Object}.\r\n * @param method the method to be invoked, potentially from an implementation class\r\n * @param targetClass the target class to invoke the method on, or {@code null} if unknown\r\n * @return the corresponding publicly accessible method, or the original method if none found\r\n * @since 6.2\r\n * @see #getInterfaceMethodIfPossible(Method, Class)\r\n * @see #getMostSpecificMethod(Method, Class)\r\n */\r\npublic static Method getPubliclyAccessibleMethodIfPossible(Method method, @Nullable Class<?> targetClass) {\r\n    Class<?> declaringClass = method.getDeclaringClass();\r\n    // If the method is not public, we can abort the search immediately; or if the method's\r\n    // declaring class is public, the method is already publicly accessible.\r\n    if (!Modifier.isPublic(method.getModifiers()) || Modifier.isPublic(declaringClass.getModifiers())) {\r\n        return method;\r\n    }\r\n    Method interfaceMethod = getInterfaceMethodIfPossible(method, targetClass, true);\r\n    // If we found a method in a public interface, return the interface method.\r\n    if (!interfaceMethod.equals(method)) {\r\n        return interfaceMethod;\r\n    }\r\n    Method result = publiclyAccessibleMethodCache.computeIfAbsent(method, key -> findPubliclyAccessibleMethodIfPossible(key.getName(), key.getParameterTypes(), declaringClass));\r\n    return (result != null ? result : method);\r\n}\n@Nullable\r\nprivate static Method findPubliclyAccessibleMethodIfPossible(String methodName, Class<?>[] parameterTypes, Class<?> declaringClass) {\r\n    Class<?> current = declaringClass.getSuperclass();\r\n    while (current != null) {\r\n        if (Modifier.isPublic(current.getModifiers())) {\r\n            try {\r\n                return current.getDeclaredMethod(methodName, parameterTypes);\r\n            } catch (NoSuchMethodException ex) {\r\n                // ignore\r\n            }\r\n        }\r\n        current = current.getSuperclass();\r\n    }\r\n    return null;\r\n}\n/**\r\n * Determine whether the given method is declared by the user or at least pointing to\r\n * a user-declared method.\r\n * <p>Checks {@link Method#isSynthetic()} (for implementation methods) as well as the\r\n * {@code GroovyObject} interface (for interface methods; on an implementation class,\r\n * implementations of the {@code GroovyObject} methods will be marked as synthetic anyway).\r\n * Note that, despite being synthetic, bridge methods ({@link Method#isBridge()}) are considered\r\n * as user-level methods since they are eventually pointing to a user-declared generic method.\r\n * @param method the method to check\r\n * @return {@code true} if the method can be considered as user-declared; {@code false} otherwise\r\n */\r\npublic static boolean isUserLevelMethod(Method method) {\r\n    Assert.notNull(method, \"Method must not be null\");\r\n    return (method.isBridge() || (!method.isSynthetic() && !isGroovyObjectMethod(method)));\r\n}\nprivate static boolean isGroovyObjectMethod(Method method) {\r\n    return method.getDeclaringClass().getName().equals(\"groovy.lang.GroovyObject\");\r\n}\n/**\r\n * Determine whether the given method is overridable in the given target class.\r\n * @param method the method to check\r\n * @param targetClass the target class to check against\r\n */\r\nprivate static boolean isOverridable(Method method, @Nullable Class<?> targetClass) {\r\n    if ((method.getModifiers() & NON_OVERRIDABLE_MODIFIER) != 0) {\r\n        return false;\r\n    }\r\n    if ((method.getModifiers() & OVERRIDABLE_MODIFIER) != 0) {\r\n        return true;\r\n    }\r\n    return (targetClass == null || getPackageName(method.getDeclaringClass()).equals(getPackageName(targetClass)));\r\n}\n/**\r\n * Return a public static method of a class.\r\n * @param clazz the class which defines the method\r\n * @param methodName the static method name\r\n * @param args the parameter types to the method\r\n * @return the static method, or {@code null} if no static method was found\r\n * @throws IllegalArgumentException if the method name is blank or the clazz is null\r\n */\r\n@Nullable\r\npublic static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    Assert.notNull(methodName, \"Method name must not be null\");\r\n    try {\r\n        Method method = clazz.getMethod(methodName, args);\r\n        return (Modifier.isStatic(method.getModifiers()) ? method : null);\r\n    } catch (NoSuchMethodException ex) {\r\n        return null;\r\n    }\r\n}\n@Nullable\r\nprivate static Method getMethodOrNull(Class<?> clazz, String methodName, @Nullable Class<?> @Nullable [] paramTypes) {\r\n    try {\r\n        return clazz.getMethod(methodName, paramTypes);\r\n    } catch (NoSuchMethodException ex) {\r\n        return null;\r\n    }\r\n}\nprivate static Set<Method> findMethodCandidatesByName(Class<?> clazz, String methodName) {\r\n    Set<Method> candidates = new HashSet<>(1);\r\n    Method[] methods = clazz.getMethods();\r\n    for (Method method : methods) {\r\n        if (methodName.equals(method.getName())) {\r\n            candidates.add(method);\r\n        }\r\n    }\r\n    return candidates;\r\n}",
    "comment": "\n * Miscellaneous {@code java.lang.Class} utility methods.\n *\n * <p>Mainly for internal use within the framework.\n *\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @author Sam Brannen\n * @author Sebastien Deleuze\n * @author Sungbin Yang\n * @since 1.1\n * @see TypeUtils\n * @see ReflectionUtils\n "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#registerCommonClasses(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Register the given common classes with the ClassUtils cache.\r\n */\r\nprivate static void registerCommonClasses(Class<?>... commonClasses) {\r\n    for (Class<?> clazz : commonClasses) {\r\n        commonClassCache.put(clazz.getName(), clazz);\r\n    }\r\n}",
    "comment": "\n\t * Register the given common classes with the ClassUtils cache.\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getDefaultClassLoader()",
    "entityType": "method",
    "code": "/**\r\n * Return the default ClassLoader to use: typically the thread context\r\n * ClassLoader, if available; the ClassLoader that loaded the ClassUtils\r\n * class will be used as fallback.\r\n * <p>Call this method if you intend to use the thread context ClassLoader\r\n * in a scenario where you clearly prefer a non-null ClassLoader reference:\r\n * for example, for class path resource loading (but not necessarily for\r\n * {@code Class.forName}, which accepts a {@code null} ClassLoader\r\n * reference as well).\r\n * @return the default ClassLoader (only {@code null} if even the system\r\n * ClassLoader isn't accessible)\r\n * @see Thread#getContextClassLoader()\r\n * @see ClassLoader#getSystemClassLoader()\r\n */\r\n@Nullable\r\npublic static ClassLoader getDefaultClassLoader() {\r\n    ClassLoader cl = null;\r\n    try {\r\n        cl = Thread.currentThread().getContextClassLoader();\r\n    } catch (Throwable ex) {\r\n        // Cannot access thread context ClassLoader - falling back...\r\n    }\r\n    if (cl == null) {\r\n        // No thread context class loader -> use class loader of this class.\r\n        cl = ClassUtils.class.getClassLoader();\r\n        if (cl == null) {\r\n            // getClassLoader() returning null indicates the bootstrap ClassLoader\r\n            try {\r\n                cl = ClassLoader.getSystemClassLoader();\r\n            } catch (Throwable ex) {\r\n                // Cannot access system ClassLoader - oh well, maybe the caller can live with null...\r\n            }\r\n        }\r\n    }\r\n    return cl;\r\n}",
    "comment": "\n\t * Return the default ClassLoader to use: typically the thread context\n\t * ClassLoader, if available; the ClassLoader that loaded the ClassUtils\n\t * class will be used as fallback.\n\t * <p>Call this method if you intend to use the thread context ClassLoader\n\t * in a scenario where you clearly prefer a non-null ClassLoader reference:\n\t * for example, for class path resource loading (but not necessarily for\n\t * {@code Class.forName}, which accepts a {@code null} ClassLoader\n\t * reference as well).\n\t * @return the default ClassLoader (only {@code null} if even the system\n\t * ClassLoader isn't accessible)\n\t * @see Thread#getContextClassLoader()\n\t * @see ClassLoader#getSystemClassLoader()\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#overrideThreadContextClassLoader(ClassLoader)",
    "entityType": "method",
    "code": "/**\r\n * Override the thread context ClassLoader with the environment's bean ClassLoader\r\n * if necessary, i.e. if the bean ClassLoader is not equivalent to the thread\r\n * context ClassLoader already.\r\n * @param classLoaderToUse the actual ClassLoader to use for the thread context\r\n * @return the original thread context ClassLoader, or {@code null} if not overridden\r\n */\r\n@Nullable\r\npublic static ClassLoader overrideThreadContextClassLoader(@Nullable ClassLoader classLoaderToUse) {\r\n    Thread currentThread = Thread.currentThread();\r\n    ClassLoader threadContextClassLoader = currentThread.getContextClassLoader();\r\n    if (classLoaderToUse != null && !classLoaderToUse.equals(threadContextClassLoader)) {\r\n        currentThread.setContextClassLoader(classLoaderToUse);\r\n        return threadContextClassLoader;\r\n    } else {\r\n        return null;\r\n    }\r\n}",
    "comment": "\n\t * Override the thread context ClassLoader with the environment's bean ClassLoader\n\t * if necessary, i.e. if the bean ClassLoader is not equivalent to the thread\n\t * context ClassLoader already.\n\t * @param classLoaderToUse the actual ClassLoader to use for the thread context\n\t * @return the original thread context ClassLoader, or {@code null} if not overridden\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#forName(String,ClassLoader)",
    "entityType": "method",
    "code": "/**\r\n * Replacement for {@code Class.forName()} that also returns Class instances\r\n * for primitives (for example, \"int\") and array class names (for example, \"String[]\").\r\n * Furthermore, it is also capable of resolving nested class names in Java source\r\n * style (for example, \"java.lang.Thread.State\" instead of \"java.lang.Thread$State\").\r\n * @param name the name of the Class\r\n * @param classLoader the class loader to use\r\n * (can be {@code null}, which indicates the default class loader)\r\n * @return a class instance for the supplied name\r\n * @throws ClassNotFoundException if the class was not found\r\n * @throws LinkageError if the class file could not be loaded\r\n * @see Class#forName(String, boolean, ClassLoader)\r\n */\r\npublic static Class<?> forName(String name, @Nullable ClassLoader classLoader) throws ClassNotFoundException, LinkageError {\r\n    Assert.notNull(name, \"Name must not be null\");\r\n    Class<?> clazz = resolvePrimitiveClassName(name);\r\n    if (clazz == null) {\r\n        clazz = commonClassCache.get(name);\r\n    }\r\n    if (clazz != null) {\r\n        return clazz;\r\n    }\r\n    // \"java.lang.String[]\" style arrays\r\n    if (name.endsWith(ARRAY_SUFFIX)) {\r\n        String elementClassName = name.substring(0, name.length() - ARRAY_SUFFIX.length());\r\n        Class<?> elementClass = forName(elementClassName, classLoader);\r\n        return elementClass.arrayType();\r\n    }\r\n    ClassLoader clToUse = classLoader;\r\n    if (clToUse == null) {\r\n        clToUse = getDefaultClassLoader();\r\n    }\r\n    try {\r\n        return Class.forName(name, false, clToUse);\r\n    } catch (ClassNotFoundException ex) {\r\n        int lastDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR);\r\n        int previousDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR, lastDotIndex - 1);\r\n        if (lastDotIndex != -1 && previousDotIndex != -1 && Character.isUpperCase(name.charAt(previousDotIndex + 1))) {\r\n            String nestedClassName = name.substring(0, lastDotIndex) + NESTED_CLASS_SEPARATOR + name.substring(lastDotIndex + 1);\r\n            try {\r\n                return Class.forName(nestedClassName, false, clToUse);\r\n            } catch (ClassNotFoundException ex2) {\r\n                // Swallow - let original exception get through\r\n            }\r\n        }\r\n        throw ex;\r\n    }\r\n}",
    "comment": "\n\t * Replacement for {@code Class.forName()} that also returns Class instances\n\t * for primitives (for example, \"int\") and array class names (for example, \"String[]\").\n\t * Furthermore, it is also capable of resolving nested class names in Java source\n\t * style (for example, \"java.lang.Thread.State\" instead of \"java.lang.Thread$State\").\n\t * @param name the name of the Class\n\t * @param classLoader the class loader to use\n\t * (can be {@code null}, which indicates the default class loader)\n\t * @return a class instance for the supplied name\n\t * @throws ClassNotFoundException if the class was not found\n\t * @throws LinkageError if the class file could not be loaded\n\t * @see Class#forName(String, boolean, ClassLoader)\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#resolveClassName(String,ClassLoader)",
    "entityType": "method",
    "code": "/**\r\n * Resolve the given class name into a Class instance. Supports\r\n * primitives (like \"int\") and array class names (like \"String[]\").\r\n * <p>This is effectively equivalent to the {@code forName}\r\n * method with the same arguments, with the only difference being\r\n * the exceptions thrown in case of class loading failure.\r\n * @param className the name of the Class\r\n * @param classLoader the class loader to use\r\n * (can be {@code null}, which indicates the default class loader)\r\n * @return a class instance for the supplied name\r\n * @throws IllegalArgumentException if the class name was not resolvable\r\n * (that is, the class could not be found or the class file could not be loaded)\r\n * @throws IllegalStateException if the corresponding class is resolvable but there\r\n * was a readability mismatch in the inheritance hierarchy of the class (typically a\r\n * missing dependency declaration in a Java Module System module definition for a\r\n * superclass or interface implemented by the class to be loaded here)\r\n * @see #forName(String, ClassLoader)\r\n */\r\npublic static Class<?> resolveClassName(String className, @Nullable ClassLoader classLoader) throws IllegalArgumentException {\r\n    try {\r\n        return forName(className, classLoader);\r\n    } catch (IllegalAccessError err) {\r\n        throw new IllegalStateException(\"Readability mismatch in inheritance hierarchy of class [\" + className + \"]: \" + err.getMessage(), err);\r\n    } catch (LinkageError err) {\r\n        throw new IllegalArgumentException(\"Unresolvable class definition for class [\" + className + \"]\", err);\r\n    } catch (ClassNotFoundException ex) {\r\n        throw new IllegalArgumentException(\"Could not find class [\" + className + \"]\", ex);\r\n    }\r\n}",
    "comment": "\n\t * Resolve the given class name into a Class instance. Supports\n\t * primitives (like \"int\") and array class names (like \"String[]\").\n\t * <p>This is effectively equivalent to the {@code forName}\n\t * method with the same arguments, with the only difference being\n\t * the exceptions thrown in case of class loading failure.\n\t * @param className the name of the Class\n\t * @param classLoader the class loader to use\n\t * (can be {@code null}, which indicates the default class loader)\n\t * @return a class instance for the supplied name\n\t * @throws IllegalArgumentException if the class name was not resolvable\n\t * (that is, the class could not be found or the class file could not be loaded)\n\t * @throws IllegalStateException if the corresponding class is resolvable but there\n\t * was a readability mismatch in the inheritance hierarchy of the class (typically a\n\t * missing dependency declaration in a Java Module System module definition for a\n\t * superclass or interface implemented by the class to be loaded here)\n\t * @see #forName(String, ClassLoader)\n\t "
  }
]