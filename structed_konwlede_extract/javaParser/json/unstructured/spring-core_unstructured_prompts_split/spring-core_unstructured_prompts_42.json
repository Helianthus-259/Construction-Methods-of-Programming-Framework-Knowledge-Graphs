[
  {
    "entityId": "org.springframework.cglib.transform.impl.FieldProviderTransformer#getByIndex(String[],int[])",
    "entityType": "method",
    "code": "private void getByIndex(final String[] names, final int[] indexes) throws Exception {\r\n    final CodeEmitter e = super.begin_method(Constants.ACC_PUBLIC, PROVIDER_GET_BY_INDEX, null);\r\n    e.load_this();\r\n    e.load_arg(0);\r\n    e.process_switch(indexes, new ProcessSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(int key, Label end) throws Exception {\r\n            Type type = (Type) fields.get(names[key]);\r\n            e.getfield(names[key]);\r\n            e.box(type);\r\n            e.return_value();\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() throws Exception {\r\n            e.throw_exception(ILLEGAL_ARGUMENT_EXCEPTION, \"Unknown field index\");\r\n        }\r\n    });\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.FieldProviderTransformer#getField(String[])",
    "entityType": "method",
    "code": "// TODO: if this is used to enhance class files SWITCH_STYLE_TRIE should be used\r\n// to avoid JVM hashcode implementation incompatibilities\r\nprivate void getField(String[] names) throws Exception {\r\n    final CodeEmitter e = begin_method(Constants.ACC_PUBLIC, PROVIDER_GET, null);\r\n    e.load_this();\r\n    e.load_arg(0);\r\n    EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(Object key, Label end) {\r\n            Type type = (Type) fields.get(key);\r\n            e.getfield((String) key);\r\n            e.box(type);\r\n            e.return_value();\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            e.throw_exception(ILLEGAL_ARGUMENT_EXCEPTION, \"Unknown field name\");\r\n        }\r\n    });\r\n    e.end_method();\r\n}",
    "comment": " to avoid JVM hashcode implementation incompatibilities"
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.FieldProviderTransformer#setField(String[])",
    "entityType": "method",
    "code": "private void setField(String[] names) throws Exception {\r\n    final CodeEmitter e = begin_method(Constants.ACC_PUBLIC, PROVIDER_SET, null);\r\n    e.load_this();\r\n    e.load_arg(1);\r\n    e.load_arg(0);\r\n    EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(Object key, Label end) {\r\n            Type type = (Type) fields.get(key);\r\n            e.unbox(type);\r\n            e.putfield((String) key);\r\n            e.return_value();\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            e.throw_exception(ILLEGAL_ARGUMENT_EXCEPTION, \"Unknown field name\");\r\n        }\r\n    });\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldCallback",
    "entityType": "class",
    "code": "int writeInt(Object obj, String name, int oldValue, int newValue);\nchar writeChar(Object obj, String name, char oldValue, char newValue);\nbyte writeByte(Object obj, String name, byte oldValue, byte newValue);\nboolean writeBoolean(Object obj, String name, boolean oldValue, boolean newValue);\nshort writeShort(Object obj, String name, short oldValue, short newValue);\nfloat writeFloat(Object obj, String name, float oldValue, float newValue);\ndouble writeDouble(Object obj, String name, double oldValue, double newValue);\nlong writeLong(Object obj, String name, long oldValue, long newValue);\nObject writeObject(Object obj, String name, Object oldValue, Object newValue);\nint readInt(Object obj, String name, int oldValue);\nchar readChar(Object obj, String name, char oldValue);\nbyte readByte(Object obj, String name, byte oldValue);\nboolean readBoolean(Object obj, String name, boolean oldValue);\nshort readShort(Object obj, String name, short oldValue);\nfloat readFloat(Object obj, String name, float oldValue);\ndouble readDouble(Object obj, String name, double oldValue);\nlong readLong(Object obj, String name, long oldValue);\nObject readObject(Object obj, String name, Object oldValue);",
    "comment": "\n * @author Juozas Baliuka\n "
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldCallback#writeInt(Object,String,int,int)",
    "entityType": "method",
    "code": "int writeInt(Object obj, String name, int oldValue, int newValue);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldCallback#writeChar(Object,String,char,char)",
    "entityType": "method",
    "code": "char writeChar(Object obj, String name, char oldValue, char newValue);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldCallback#writeByte(Object,String,byte,byte)",
    "entityType": "method",
    "code": "byte writeByte(Object obj, String name, byte oldValue, byte newValue);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldCallback#writeBoolean(Object,String,boolean,boolean)",
    "entityType": "method",
    "code": "boolean writeBoolean(Object obj, String name, boolean oldValue, boolean newValue);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldCallback#writeShort(Object,String,short,short)",
    "entityType": "method",
    "code": "short writeShort(Object obj, String name, short oldValue, short newValue);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldCallback#writeFloat(Object,String,float,float)",
    "entityType": "method",
    "code": "float writeFloat(Object obj, String name, float oldValue, float newValue);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldCallback#writeDouble(Object,String,double,double)",
    "entityType": "method",
    "code": "double writeDouble(Object obj, String name, double oldValue, double newValue);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldCallback#writeLong(Object,String,long,long)",
    "entityType": "method",
    "code": "long writeLong(Object obj, String name, long oldValue, long newValue);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldCallback#writeObject(Object,String,Object,Object)",
    "entityType": "method",
    "code": "Object writeObject(Object obj, String name, Object oldValue, Object newValue);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldCallback#readInt(Object,String,int)",
    "entityType": "method",
    "code": "int readInt(Object obj, String name, int oldValue);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldCallback#readChar(Object,String,char)",
    "entityType": "method",
    "code": "char readChar(Object obj, String name, char oldValue);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldCallback#readByte(Object,String,byte)",
    "entityType": "method",
    "code": "byte readByte(Object obj, String name, byte oldValue);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldCallback#readBoolean(Object,String,boolean)",
    "entityType": "method",
    "code": "boolean readBoolean(Object obj, String name, boolean oldValue);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldCallback#readShort(Object,String,short)",
    "entityType": "method",
    "code": "short readShort(Object obj, String name, short oldValue);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldCallback#readFloat(Object,String,float)",
    "entityType": "method",
    "code": "float readFloat(Object obj, String name, float oldValue);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldCallback#readDouble(Object,String,double)",
    "entityType": "method",
    "code": "double readDouble(Object obj, String name, double oldValue);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldCallback#readLong(Object,String,long)",
    "entityType": "method",
    "code": "long readLong(Object obj, String name, long oldValue);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldCallback#readObject(Object,String,Object)",
    "entityType": "method",
    "code": "Object readObject(Object obj, String name, Object oldValue);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldEnabled",
    "entityType": "class",
    "code": "void setInterceptFieldCallback(InterceptFieldCallback callback);\nInterceptFieldCallback getInterceptFieldCallback();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldEnabled#setInterceptFieldCallback(InterceptFieldCallback)",
    "entityType": "method",
    "code": "void setInterceptFieldCallback(InterceptFieldCallback callback);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldEnabled#getInterceptFieldCallback()",
    "entityType": "method",
    "code": "InterceptFieldCallback getInterceptFieldCallback();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldFilter",
    "entityType": "class",
    "code": "boolean acceptRead(Type owner, String name);\nboolean acceptWrite(Type owner, String name);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldFilter#acceptRead(Type,String)",
    "entityType": "method",
    "code": "boolean acceptRead(Type owner, String name);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldFilter#acceptWrite(Type,String)",
    "entityType": "method",
    "code": "boolean acceptWrite(Type owner, String name);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldTransformer",
    "entityType": "class",
    "code": "private static final String CALLBACK_FIELD = \"$CGLIB_READ_WRITE_CALLBACK\";\nprivate static final Type CALLBACK = TypeUtils.parseType(\"org.springframework.cglib.transform.impl.InterceptFieldCallback\");\nprivate static final Type ENABLED = TypeUtils.parseType(\"org.springframework.cglib.transform.impl.InterceptFieldEnabled\");\nprivate static final Signature ENABLED_SET = new Signature(\"setInterceptFieldCallback\", Type.VOID_TYPE, new Type[] { CALLBACK });\nprivate static final Signature ENABLED_GET = new Signature(\"getInterceptFieldCallback\", CALLBACK, new Type[0]);\nprivate InterceptFieldFilter filter;\npublic InterceptFieldTransformer(InterceptFieldFilter filter) {\r\n    this.filter = filter;\r\n}\n@Override\r\npublic void begin_class(int version, int access, String className, Type superType, Type[] interfaces, String sourceFile) {\r\n    if (!TypeUtils.isInterface(access)) {\r\n        super.begin_class(version, access, className, superType, TypeUtils.add(interfaces, ENABLED), sourceFile);\r\n        super.declare_field(Constants.ACC_PRIVATE | Constants.ACC_TRANSIENT, CALLBACK_FIELD, CALLBACK, null);\r\n        CodeEmitter e;\r\n        e = super.begin_method(Constants.ACC_PUBLIC, ENABLED_GET, null);\r\n        e.load_this();\r\n        e.getfield(CALLBACK_FIELD);\r\n        e.return_value();\r\n        e.end_method();\r\n        e = super.begin_method(Constants.ACC_PUBLIC, ENABLED_SET, null);\r\n        e.load_this();\r\n        e.load_arg(0);\r\n        e.putfield(CALLBACK_FIELD);\r\n        e.return_value();\r\n        e.end_method();\r\n    } else {\r\n        super.begin_class(version, access, className, superType, interfaces, sourceFile);\r\n    }\r\n}\n@Override\r\npublic void declare_field(int access, String name, Type type, Object value) {\r\n    super.declare_field(access, name, type, value);\r\n    if (!TypeUtils.isStatic(access)) {\r\n        if (filter.acceptRead(getClassType(), name)) {\r\n            addReadMethod(name, type);\r\n        }\r\n        if (filter.acceptWrite(getClassType(), name)) {\r\n            addWriteMethod(name, type);\r\n        }\r\n    }\r\n}\nprivate void addReadMethod(String name, Type type) {\r\n    CodeEmitter e = super.begin_method(Constants.ACC_PUBLIC, readMethodSig(name, type.getDescriptor()), null);\r\n    e.load_this();\r\n    e.getfield(name);\r\n    e.load_this();\r\n    e.invoke_interface(ENABLED, ENABLED_GET);\r\n    Label intercept = e.make_label();\r\n    e.ifnonnull(intercept);\r\n    e.return_value();\r\n    e.mark(intercept);\r\n    Local result = e.make_local(type);\r\n    e.store_local(result);\r\n    e.load_this();\r\n    e.invoke_interface(ENABLED, ENABLED_GET);\r\n    e.load_this();\r\n    e.push(name);\r\n    e.load_local(result);\r\n    e.invoke_interface(CALLBACK, readCallbackSig(type));\r\n    if (!TypeUtils.isPrimitive(type)) {\r\n        e.checkcast(type);\r\n    }\r\n    e.return_value();\r\n    e.end_method();\r\n}\nprivate void addWriteMethod(String name, Type type) {\r\n    CodeEmitter e = super.begin_method(Constants.ACC_PUBLIC, writeMethodSig(name, type.getDescriptor()), null);\r\n    e.load_this();\r\n    e.dup();\r\n    e.invoke_interface(ENABLED, ENABLED_GET);\r\n    Label skip = e.make_label();\r\n    e.ifnull(skip);\r\n    e.load_this();\r\n    e.invoke_interface(ENABLED, ENABLED_GET);\r\n    e.load_this();\r\n    e.push(name);\r\n    e.load_this();\r\n    e.getfield(name);\r\n    e.load_arg(0);\r\n    e.invoke_interface(CALLBACK, writeCallbackSig(type));\r\n    if (!TypeUtils.isPrimitive(type)) {\r\n        e.checkcast(type);\r\n    }\r\n    Label go = e.make_label();\r\n    e.goTo(go);\r\n    e.mark(skip);\r\n    e.load_arg(0);\r\n    e.mark(go);\r\n    e.putfield(name);\r\n    e.return_value();\r\n    e.end_method();\r\n}\n@Override\r\npublic CodeEmitter begin_method(int access, Signature sig, Type[] exceptions) {\r\n    return new CodeEmitter(super.begin_method(access, sig, exceptions)) {\r\n\r\n        @Override\r\n        public void visitFieldInsn(int opcode, String owner, String name, String desc) {\r\n            Type towner = TypeUtils.fromInternalName(owner);\r\n            switch(opcode) {\r\n                case Constants.GETFIELD:\r\n                    if (filter.acceptRead(towner, name)) {\r\n                        helper(towner, readMethodSig(name, desc));\r\n                        return;\r\n                    }\r\n                    break;\r\n                case Constants.PUTFIELD:\r\n                    if (filter.acceptWrite(towner, name)) {\r\n                        helper(towner, writeMethodSig(name, desc));\r\n                        return;\r\n                    }\r\n                    break;\r\n            }\r\n            super.visitFieldInsn(opcode, owner, name, desc);\r\n        }\r\n\r\n        private void helper(Type owner, Signature sig) {\r\n            invoke_virtual(owner, sig);\r\n        }\r\n    };\r\n}\nprivate static Signature readMethodSig(String name, String desc) {\r\n    return new Signature(\"$cglib_read_\" + name, \"()\" + desc);\r\n}\nprivate static Signature writeMethodSig(String name, String desc) {\r\n    return new Signature(\"$cglib_write_\" + name, \"(\" + desc + \")V\");\r\n}\nprivate static Signature readCallbackSig(Type type) {\r\n    Type remap = remap(type);\r\n    return new Signature(\"read\" + callbackName(remap), remap, new Type[] { Constants.TYPE_OBJECT, Constants.TYPE_STRING, remap });\r\n}\nprivate static Signature writeCallbackSig(Type type) {\r\n    Type remap = remap(type);\r\n    return new Signature(\"write\" + callbackName(remap), remap, new Type[] { Constants.TYPE_OBJECT, Constants.TYPE_STRING, remap, remap });\r\n}\nprivate static Type remap(Type type) {\r\n    switch(type.getSort()) {\r\n        case Type.OBJECT:\r\n        case Type.ARRAY:\r\n            return Constants.TYPE_OBJECT;\r\n        default:\r\n            return type;\r\n    }\r\n}\nprivate static String callbackName(Type type) {\r\n    return (type == Constants.TYPE_OBJECT) ? \"Object\" : TypeUtils.upperFirst(TypeUtils.getClassName(type));\r\n}",
    "comment": "\n * @author Juozas Baliuka, Chris Nokleberg\n "
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldTransformer#begin_class(int,int,String,Type,Type[],String)",
    "entityType": "method",
    "code": "@Override\r\npublic void begin_class(int version, int access, String className, Type superType, Type[] interfaces, String sourceFile) {\r\n    if (!TypeUtils.isInterface(access)) {\r\n        super.begin_class(version, access, className, superType, TypeUtils.add(interfaces, ENABLED), sourceFile);\r\n        super.declare_field(Constants.ACC_PRIVATE | Constants.ACC_TRANSIENT, CALLBACK_FIELD, CALLBACK, null);\r\n        CodeEmitter e;\r\n        e = super.begin_method(Constants.ACC_PUBLIC, ENABLED_GET, null);\r\n        e.load_this();\r\n        e.getfield(CALLBACK_FIELD);\r\n        e.return_value();\r\n        e.end_method();\r\n        e = super.begin_method(Constants.ACC_PUBLIC, ENABLED_SET, null);\r\n        e.load_this();\r\n        e.load_arg(0);\r\n        e.putfield(CALLBACK_FIELD);\r\n        e.return_value();\r\n        e.end_method();\r\n    } else {\r\n        super.begin_class(version, access, className, superType, interfaces, sourceFile);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldTransformer#declare_field(int,String,Type,Object)",
    "entityType": "method",
    "code": "@Override\r\npublic void declare_field(int access, String name, Type type, Object value) {\r\n    super.declare_field(access, name, type, value);\r\n    if (!TypeUtils.isStatic(access)) {\r\n        if (filter.acceptRead(getClassType(), name)) {\r\n            addReadMethod(name, type);\r\n        }\r\n        if (filter.acceptWrite(getClassType(), name)) {\r\n            addWriteMethod(name, type);\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldTransformer#addReadMethod(String,Type)",
    "entityType": "method",
    "code": "private void addReadMethod(String name, Type type) {\r\n    CodeEmitter e = super.begin_method(Constants.ACC_PUBLIC, readMethodSig(name, type.getDescriptor()), null);\r\n    e.load_this();\r\n    e.getfield(name);\r\n    e.load_this();\r\n    e.invoke_interface(ENABLED, ENABLED_GET);\r\n    Label intercept = e.make_label();\r\n    e.ifnonnull(intercept);\r\n    e.return_value();\r\n    e.mark(intercept);\r\n    Local result = e.make_local(type);\r\n    e.store_local(result);\r\n    e.load_this();\r\n    e.invoke_interface(ENABLED, ENABLED_GET);\r\n    e.load_this();\r\n    e.push(name);\r\n    e.load_local(result);\r\n    e.invoke_interface(CALLBACK, readCallbackSig(type));\r\n    if (!TypeUtils.isPrimitive(type)) {\r\n        e.checkcast(type);\r\n    }\r\n    e.return_value();\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldTransformer#addWriteMethod(String,Type)",
    "entityType": "method",
    "code": "private void addWriteMethod(String name, Type type) {\r\n    CodeEmitter e = super.begin_method(Constants.ACC_PUBLIC, writeMethodSig(name, type.getDescriptor()), null);\r\n    e.load_this();\r\n    e.dup();\r\n    e.invoke_interface(ENABLED, ENABLED_GET);\r\n    Label skip = e.make_label();\r\n    e.ifnull(skip);\r\n    e.load_this();\r\n    e.invoke_interface(ENABLED, ENABLED_GET);\r\n    e.load_this();\r\n    e.push(name);\r\n    e.load_this();\r\n    e.getfield(name);\r\n    e.load_arg(0);\r\n    e.invoke_interface(CALLBACK, writeCallbackSig(type));\r\n    if (!TypeUtils.isPrimitive(type)) {\r\n        e.checkcast(type);\r\n    }\r\n    Label go = e.make_label();\r\n    e.goTo(go);\r\n    e.mark(skip);\r\n    e.load_arg(0);\r\n    e.mark(go);\r\n    e.putfield(name);\r\n    e.return_value();\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldTransformer#begin_method(int,Signature,Type[])",
    "entityType": "method",
    "code": "@Override\r\npublic CodeEmitter begin_method(int access, Signature sig, Type[] exceptions) {\r\n    return new CodeEmitter(super.begin_method(access, sig, exceptions)) {\r\n\r\n        @Override\r\n        public void visitFieldInsn(int opcode, String owner, String name, String desc) {\r\n            Type towner = TypeUtils.fromInternalName(owner);\r\n            switch(opcode) {\r\n                case Constants.GETFIELD:\r\n                    if (filter.acceptRead(towner, name)) {\r\n                        helper(towner, readMethodSig(name, desc));\r\n                        return;\r\n                    }\r\n                    break;\r\n                case Constants.PUTFIELD:\r\n                    if (filter.acceptWrite(towner, name)) {\r\n                        helper(towner, writeMethodSig(name, desc));\r\n                        return;\r\n                    }\r\n                    break;\r\n            }\r\n            super.visitFieldInsn(opcode, owner, name, desc);\r\n        }\r\n\r\n        private void helper(Type owner, Signature sig) {\r\n            invoke_virtual(owner, sig);\r\n        }\r\n    };\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldTransformer#readMethodSig(String,String)",
    "entityType": "method",
    "code": "private static Signature readMethodSig(String name, String desc) {\r\n    return new Signature(\"$cglib_read_\" + name, \"()\" + desc);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldTransformer#writeMethodSig(String,String)",
    "entityType": "method",
    "code": "private static Signature writeMethodSig(String name, String desc) {\r\n    return new Signature(\"$cglib_write_\" + name, \"(\" + desc + \")V\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldTransformer#readCallbackSig(Type)",
    "entityType": "method",
    "code": "private static Signature readCallbackSig(Type type) {\r\n    Type remap = remap(type);\r\n    return new Signature(\"read\" + callbackName(remap), remap, new Type[] { Constants.TYPE_OBJECT, Constants.TYPE_STRING, remap });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldTransformer#writeCallbackSig(Type)",
    "entityType": "method",
    "code": "private static Signature writeCallbackSig(Type type) {\r\n    Type remap = remap(type);\r\n    return new Signature(\"write\" + callbackName(remap), remap, new Type[] { Constants.TYPE_OBJECT, Constants.TYPE_STRING, remap, remap });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldTransformer#remap(Type)",
    "entityType": "method",
    "code": "private static Type remap(Type type) {\r\n    switch(type.getSort()) {\r\n        case Type.OBJECT:\r\n        case Type.ARRAY:\r\n            return Constants.TYPE_OBJECT;\r\n        default:\r\n            return type;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.InterceptFieldTransformer#callbackName(Type)",
    "entityType": "method",
    "code": "private static String callbackName(Type type) {\r\n    return (type == Constants.TYPE_OBJECT) ? \"Object\" : TypeUtils.upperFirst(TypeUtils.getClassName(type));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.UndeclaredThrowableStrategy",
    "entityType": "class",
    "code": "private Class wrapper;\n/**\r\n * Create a new instance of this strategy.\r\n * @param wrapper a class which extends either directly or\r\n * indirectly from <code>Throwable</code> and which has at least one\r\n * constructor that takes a single argument of type\r\n * <code>Throwable</code>, for example\r\n * <code>java.lang.reflect.UndeclaredThrowableException.class</code>\r\n */\r\npublic UndeclaredThrowableStrategy(Class wrapper) {\r\n    this.wrapper = wrapper;\r\n}\nprivate static final MethodFilter TRANSFORM_FILTER = (access, name, desc, signature, exceptions) -> !TypeUtils.isPrivate(access) && name.indexOf('$') < 0;\n@Override\r\nprotected ClassGenerator transform(ClassGenerator cg) throws Exception {\r\n    ClassTransformer tr = new UndeclaredThrowableTransformer(wrapper);\r\n    tr = new MethodFilterTransformer(TRANSFORM_FILTER, tr);\r\n    return new TransformingClassGenerator(cg, tr);\r\n}",
    "comment": "\n * A {@link GeneratorStrategy} suitable for use with {@link org.springframework.cglib.proxy.Enhancer} which\n * causes all undeclared exceptions thrown from within a proxied method to be wrapped\n * in an alternative exception of your choice.\n "
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.UndeclaredThrowableStrategy#transform(ClassGenerator)",
    "entityType": "method",
    "code": "@Override\r\nprotected ClassGenerator transform(ClassGenerator cg) throws Exception {\r\n    ClassTransformer tr = new UndeclaredThrowableTransformer(wrapper);\r\n    tr = new MethodFilterTransformer(TRANSFORM_FILTER, tr);\r\n    return new TransformingClassGenerator(cg, tr);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.UndeclaredThrowableTransformer",
    "entityType": "class",
    "code": "private final Type wrapper;\npublic UndeclaredThrowableTransformer(Class wrapper) {\r\n    this.wrapper = Type.getType(wrapper);\r\n    boolean found = false;\r\n    Constructor[] cstructs = wrapper.getConstructors();\r\n    for (Constructor cstruct : cstructs) {\r\n        Class[] types = cstruct.getParameterTypes();\r\n        if (types.length == 1 && types[0].equals(Throwable.class)) {\r\n            found = true;\r\n            break;\r\n        }\r\n    }\r\n    if (!found) {\r\n        throw new IllegalArgumentException(wrapper + \" does not have a single-arg constructor that takes a Throwable\");\r\n    }\r\n}\n@Override\r\npublic CodeEmitter begin_method(int access, final Signature sig, final Type[] exceptions) {\r\n    CodeEmitter e = super.begin_method(access, sig, exceptions);\r\n    if (TypeUtils.isAbstract(access) || sig.equals(Constants.SIG_STATIC)) {\r\n        return e;\r\n    }\r\n    return new CodeEmitter(e) {\r\n\r\n        private final boolean isConstructor = Constants.CONSTRUCTOR_NAME.equals(sig.getName());\r\n\r\n        private Block handler = begin_block();\r\n\r\n        private boolean callToSuperSeen;\r\n\r\n        @Override\r\n        public void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean isInterface) {\r\n            super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);\r\n            if (isConstructor && !callToSuperSeen && Constants.CONSTRUCTOR_NAME.equals(name)) {\r\n                // we start the entry in the exception table after the call to super\r\n                handler = begin_block();\r\n                callToSuperSeen = true;\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void visitMaxs(int maxStack, int maxLocals) {\r\n            handler.end();\r\n            EmitUtils.wrap_undeclared_throwable(this, handler, exceptions, wrapper);\r\n            super.visitMaxs(maxStack, maxLocals);\r\n        }\r\n    };\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.impl.UndeclaredThrowableTransformer#begin_method(int,Signature,Type[])",
    "entityType": "method",
    "code": "@Override\r\npublic CodeEmitter begin_method(int access, final Signature sig, final Type[] exceptions) {\r\n    CodeEmitter e = super.begin_method(access, sig, exceptions);\r\n    if (TypeUtils.isAbstract(access) || sig.equals(Constants.SIG_STATIC)) {\r\n        return e;\r\n    }\r\n    return new CodeEmitter(e) {\r\n\r\n        private final boolean isConstructor = Constants.CONSTRUCTOR_NAME.equals(sig.getName());\r\n\r\n        private Block handler = begin_block();\r\n\r\n        private boolean callToSuperSeen;\r\n\r\n        @Override\r\n        public void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean isInterface) {\r\n            super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);\r\n            if (isConstructor && !callToSuperSeen && Constants.CONSTRUCTOR_NAME.equals(name)) {\r\n                // we start the entry in the exception table after the call to super\r\n                handler = begin_block();\r\n                callToSuperSeen = true;\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void visitMaxs(int maxStack, int maxLocals) {\r\n            handler.end();\r\n            EmitUtils.wrap_undeclared_throwable(this, handler, exceptions, wrapper);\r\n            super.visitMaxs(maxStack, maxLocals);\r\n        }\r\n    };\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodFilter",
    "entityType": "class",
    "code": "// TODO: pass class name too?\r\nboolean accept(int access, String name, String desc, String signature, String[] exceptions);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodFilter#accept(int,String,String,String,String[])",
    "entityType": "method",
    "code": "// TODO: pass class name too?\r\nboolean accept(int access, String name, String desc, String signature, String[] exceptions);",
    "comment": " TODO: pass class name too?"
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodFilterTransformer",
    "entityType": "class",
    "code": "private MethodFilter filter;\nprivate ClassTransformer pass;\nprivate ClassVisitor direct;\npublic MethodFilterTransformer(MethodFilter filter, ClassTransformer pass) {\r\n    this.filter = filter;\r\n    this.pass = pass;\r\n    super.setTarget(pass);\r\n}\n@Override\r\npublic MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\r\n    return (filter.accept(access, name, desc, signature, exceptions) ? pass : direct).visitMethod(access, name, desc, signature, exceptions);\r\n}\n@Override\r\npublic void setTarget(ClassVisitor target) {\r\n    pass.setTarget(target);\r\n    direct = target;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodFilterTransformer#visitMethod(int,String,String,String,String[])",
    "entityType": "method",
    "code": "@Override\r\npublic MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\r\n    return (filter.accept(access, name, desc, signature, exceptions) ? pass : direct).visitMethod(access, name, desc, signature, exceptions);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodFilterTransformer#setTarget(ClassVisitor)",
    "entityType": "method",
    "code": "@Override\r\npublic void setTarget(ClassVisitor target) {\r\n    pass.setTarget(target);\r\n    direct = target;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee",
    "entityType": "class",
    "code": "private final MethodVisitor mv1;\nprivate final MethodVisitor mv2;\npublic MethodVisitorTee(MethodVisitor mv1, MethodVisitor mv2) {\r\n    super(Constants.ASM_API);\r\n    this.mv1 = mv1;\r\n    this.mv2 = mv2;\r\n}\n@Override\r\npublic void visitFrame(int type, int nLocal, Object[] local, int nStack, Object[] stack) {\r\n    mv1.visitFrame(type, nLocal, local, nStack, stack);\r\n    mv2.visitFrame(type, nLocal, local, nStack, stack);\r\n}\n@Override\r\npublic AnnotationVisitor visitAnnotationDefault() {\r\n    return AnnotationVisitorTee.getInstance(mv1.visitAnnotationDefault(), mv2.visitAnnotationDefault());\r\n}\n@Override\r\npublic AnnotationVisitor visitAnnotation(String desc, boolean visible) {\r\n    return AnnotationVisitorTee.getInstance(mv1.visitAnnotation(desc, visible), mv2.visitAnnotation(desc, visible));\r\n}\n@Override\r\npublic AnnotationVisitor visitParameterAnnotation(int parameter, String desc, boolean visible) {\r\n    return AnnotationVisitorTee.getInstance(mv1.visitParameterAnnotation(parameter, desc, visible), mv2.visitParameterAnnotation(parameter, desc, visible));\r\n}\n@Override\r\npublic void visitAttribute(Attribute attr) {\r\n    mv1.visitAttribute(attr);\r\n    mv2.visitAttribute(attr);\r\n}\n@Override\r\npublic void visitCode() {\r\n    mv1.visitCode();\r\n    mv2.visitCode();\r\n}\n@Override\r\npublic void visitInsn(int opcode) {\r\n    mv1.visitInsn(opcode);\r\n    mv2.visitInsn(opcode);\r\n}\n@Override\r\npublic void visitIntInsn(int opcode, int operand) {\r\n    mv1.visitIntInsn(opcode, operand);\r\n    mv2.visitIntInsn(opcode, operand);\r\n}\n@Override\r\npublic void visitVarInsn(int opcode, int var) {\r\n    mv1.visitVarInsn(opcode, var);\r\n    mv2.visitVarInsn(opcode, var);\r\n}\n@Override\r\npublic void visitTypeInsn(int opcode, String desc) {\r\n    mv1.visitTypeInsn(opcode, desc);\r\n    mv2.visitTypeInsn(opcode, desc);\r\n}\n@Override\r\npublic void visitFieldInsn(int opcode, String owner, String name, String desc) {\r\n    mv1.visitFieldInsn(opcode, owner, name, desc);\r\n    mv2.visitFieldInsn(opcode, owner, name, desc);\r\n}\n@Override\r\npublic void visitMethodInsn(int opcode, String owner, String name, String desc) {\r\n    mv1.visitMethodInsn(opcode, owner, name, desc);\r\n    mv2.visitMethodInsn(opcode, owner, name, desc);\r\n}\n@Override\r\npublic void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\r\n    mv1.visitMethodInsn(opcode, owner, name, desc, itf);\r\n    mv2.visitMethodInsn(opcode, owner, name, desc, itf);\r\n}\n@Override\r\npublic void visitJumpInsn(int opcode, Label label) {\r\n    mv1.visitJumpInsn(opcode, label);\r\n    mv2.visitJumpInsn(opcode, label);\r\n}\n@Override\r\npublic void visitLabel(Label label) {\r\n    mv1.visitLabel(label);\r\n    mv2.visitLabel(label);\r\n}\n@Override\r\npublic void visitLdcInsn(Object cst) {\r\n    mv1.visitLdcInsn(cst);\r\n    mv2.visitLdcInsn(cst);\r\n}\n@Override\r\npublic void visitIincInsn(int var, int increment) {\r\n    mv1.visitIincInsn(var, increment);\r\n    mv2.visitIincInsn(var, increment);\r\n}\n@Override\r\npublic void visitTableSwitchInsn(int min, int max, Label dflt, Label... labels) {\r\n    mv1.visitTableSwitchInsn(min, max, dflt, labels);\r\n    mv2.visitTableSwitchInsn(min, max, dflt, labels);\r\n}\n@Override\r\npublic void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {\r\n    mv1.visitLookupSwitchInsn(dflt, keys, labels);\r\n    mv2.visitLookupSwitchInsn(dflt, keys, labels);\r\n}\n@Override\r\npublic void visitMultiANewArrayInsn(String desc, int dims) {\r\n    mv1.visitMultiANewArrayInsn(desc, dims);\r\n    mv2.visitMultiANewArrayInsn(desc, dims);\r\n}\n@Override\r\npublic void visitTryCatchBlock(Label start, Label end, Label handler, String type) {\r\n    mv1.visitTryCatchBlock(start, end, handler, type);\r\n    mv2.visitTryCatchBlock(start, end, handler, type);\r\n}\n@Override\r\npublic void visitLocalVariable(String name, String desc, String signature, Label start, Label end, int index) {\r\n    mv1.visitLocalVariable(name, desc, signature, start, end, index);\r\n    mv2.visitLocalVariable(name, desc, signature, start, end, index);\r\n}\n@Override\r\npublic void visitLineNumber(int line, Label start) {\r\n    mv1.visitLineNumber(line, start);\r\n    mv2.visitLineNumber(line, start);\r\n}\n@Override\r\npublic void visitMaxs(int maxStack, int maxLocals) {\r\n    mv1.visitMaxs(maxStack, maxLocals);\r\n    mv2.visitMaxs(maxStack, maxLocals);\r\n}\n@Override\r\npublic void visitEnd() {\r\n    mv1.visitEnd();\r\n    mv2.visitEnd();\r\n}\n@Override\r\npublic void visitParameter(String name, int access) {\r\n    mv1.visitParameter(name, access);\r\n    mv2.visitParameter(name, access);\r\n}\n@Override\r\npublic AnnotationVisitor visitTypeAnnotation(int typeRef, TypePath typePath, String desc, boolean visible) {\r\n    return AnnotationVisitorTee.getInstance(mv1.visitTypeAnnotation(typeRef, typePath, desc, visible), mv2.visitTypeAnnotation(typeRef, typePath, desc, visible));\r\n}\n@Override\r\npublic void visitInvokeDynamicInsn(String name, String desc, Handle bsm, Object... bsmArgs) {\r\n    mv1.visitInvokeDynamicInsn(name, desc, bsm, bsmArgs);\r\n    mv2.visitInvokeDynamicInsn(name, desc, bsm, bsmArgs);\r\n}\n@Override\r\npublic AnnotationVisitor visitInsnAnnotation(int typeRef, TypePath typePath, String desc, boolean visible) {\r\n    return AnnotationVisitorTee.getInstance(mv1.visitInsnAnnotation(typeRef, typePath, desc, visible), mv2.visitInsnAnnotation(typeRef, typePath, desc, visible));\r\n}\n@Override\r\npublic AnnotationVisitor visitTryCatchAnnotation(int typeRef, TypePath typePath, String desc, boolean visible) {\r\n    return AnnotationVisitorTee.getInstance(mv1.visitTryCatchAnnotation(typeRef, typePath, desc, visible), mv2.visitTryCatchAnnotation(typeRef, typePath, desc, visible));\r\n}\n@Override\r\npublic AnnotationVisitor visitLocalVariableAnnotation(int typeRef, TypePath typePath, Label[] start, Label[] end, int[] index, String desc, boolean visible) {\r\n    return AnnotationVisitorTee.getInstance(mv1.visitLocalVariableAnnotation(typeRef, typePath, start, end, index, desc, visible), mv2.visitLocalVariableAnnotation(typeRef, typePath, start, end, index, desc, visible));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitFrame(int,int,Object[],int,Object[])",
    "entityType": "method",
    "code": "@Override\r\npublic void visitFrame(int type, int nLocal, Object[] local, int nStack, Object[] stack) {\r\n    mv1.visitFrame(type, nLocal, local, nStack, stack);\r\n    mv2.visitFrame(type, nLocal, local, nStack, stack);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitAnnotationDefault()",
    "entityType": "method",
    "code": "@Override\r\npublic AnnotationVisitor visitAnnotationDefault() {\r\n    return AnnotationVisitorTee.getInstance(mv1.visitAnnotationDefault(), mv2.visitAnnotationDefault());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitAnnotation(String,boolean)",
    "entityType": "method",
    "code": "@Override\r\npublic AnnotationVisitor visitAnnotation(String desc, boolean visible) {\r\n    return AnnotationVisitorTee.getInstance(mv1.visitAnnotation(desc, visible), mv2.visitAnnotation(desc, visible));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitParameterAnnotation(int,String,boolean)",
    "entityType": "method",
    "code": "@Override\r\npublic AnnotationVisitor visitParameterAnnotation(int parameter, String desc, boolean visible) {\r\n    return AnnotationVisitorTee.getInstance(mv1.visitParameterAnnotation(parameter, desc, visible), mv2.visitParameterAnnotation(parameter, desc, visible));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitAttribute(Attribute)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitAttribute(Attribute attr) {\r\n    mv1.visitAttribute(attr);\r\n    mv2.visitAttribute(attr);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitCode()",
    "entityType": "method",
    "code": "@Override\r\npublic void visitCode() {\r\n    mv1.visitCode();\r\n    mv2.visitCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitInsn(int)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitInsn(int opcode) {\r\n    mv1.visitInsn(opcode);\r\n    mv2.visitInsn(opcode);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitIntInsn(int,int)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitIntInsn(int opcode, int operand) {\r\n    mv1.visitIntInsn(opcode, operand);\r\n    mv2.visitIntInsn(opcode, operand);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitVarInsn(int,int)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitVarInsn(int opcode, int var) {\r\n    mv1.visitVarInsn(opcode, var);\r\n    mv2.visitVarInsn(opcode, var);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitTypeInsn(int,String)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitTypeInsn(int opcode, String desc) {\r\n    mv1.visitTypeInsn(opcode, desc);\r\n    mv2.visitTypeInsn(opcode, desc);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitFieldInsn(int,String,String,String)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitFieldInsn(int opcode, String owner, String name, String desc) {\r\n    mv1.visitFieldInsn(opcode, owner, name, desc);\r\n    mv2.visitFieldInsn(opcode, owner, name, desc);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitMethodInsn(int,String,String,String)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitMethodInsn(int opcode, String owner, String name, String desc) {\r\n    mv1.visitMethodInsn(opcode, owner, name, desc);\r\n    mv2.visitMethodInsn(opcode, owner, name, desc);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitMethodInsn(int,String,String,String,boolean)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\r\n    mv1.visitMethodInsn(opcode, owner, name, desc, itf);\r\n    mv2.visitMethodInsn(opcode, owner, name, desc, itf);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitJumpInsn(int,Label)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitJumpInsn(int opcode, Label label) {\r\n    mv1.visitJumpInsn(opcode, label);\r\n    mv2.visitJumpInsn(opcode, label);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitLabel(Label)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitLabel(Label label) {\r\n    mv1.visitLabel(label);\r\n    mv2.visitLabel(label);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitLdcInsn(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitLdcInsn(Object cst) {\r\n    mv1.visitLdcInsn(cst);\r\n    mv2.visitLdcInsn(cst);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitIincInsn(int,int)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitIincInsn(int var, int increment) {\r\n    mv1.visitIincInsn(var, increment);\r\n    mv2.visitIincInsn(var, increment);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitTableSwitchInsn(int,int,Label,Label)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitTableSwitchInsn(int min, int max, Label dflt, Label... labels) {\r\n    mv1.visitTableSwitchInsn(min, max, dflt, labels);\r\n    mv2.visitTableSwitchInsn(min, max, dflt, labels);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitLookupSwitchInsn(Label,int[],Label[])",
    "entityType": "method",
    "code": "@Override\r\npublic void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {\r\n    mv1.visitLookupSwitchInsn(dflt, keys, labels);\r\n    mv2.visitLookupSwitchInsn(dflt, keys, labels);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitMultiANewArrayInsn(String,int)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitMultiANewArrayInsn(String desc, int dims) {\r\n    mv1.visitMultiANewArrayInsn(desc, dims);\r\n    mv2.visitMultiANewArrayInsn(desc, dims);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitTryCatchBlock(Label,Label,Label,String)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitTryCatchBlock(Label start, Label end, Label handler, String type) {\r\n    mv1.visitTryCatchBlock(start, end, handler, type);\r\n    mv2.visitTryCatchBlock(start, end, handler, type);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitLocalVariable(String,String,String,Label,Label,int)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitLocalVariable(String name, String desc, String signature, Label start, Label end, int index) {\r\n    mv1.visitLocalVariable(name, desc, signature, start, end, index);\r\n    mv2.visitLocalVariable(name, desc, signature, start, end, index);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitLineNumber(int,Label)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitLineNumber(int line, Label start) {\r\n    mv1.visitLineNumber(line, start);\r\n    mv2.visitLineNumber(line, start);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitMaxs(int,int)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitMaxs(int maxStack, int maxLocals) {\r\n    mv1.visitMaxs(maxStack, maxLocals);\r\n    mv2.visitMaxs(maxStack, maxLocals);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitEnd()",
    "entityType": "method",
    "code": "@Override\r\npublic void visitEnd() {\r\n    mv1.visitEnd();\r\n    mv2.visitEnd();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitParameter(String,int)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitParameter(String name, int access) {\r\n    mv1.visitParameter(name, access);\r\n    mv2.visitParameter(name, access);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitTypeAnnotation(int,TypePath,String,boolean)",
    "entityType": "method",
    "code": "@Override\r\npublic AnnotationVisitor visitTypeAnnotation(int typeRef, TypePath typePath, String desc, boolean visible) {\r\n    return AnnotationVisitorTee.getInstance(mv1.visitTypeAnnotation(typeRef, typePath, desc, visible), mv2.visitTypeAnnotation(typeRef, typePath, desc, visible));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitInvokeDynamicInsn(String,String,Handle,Object)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitInvokeDynamicInsn(String name, String desc, Handle bsm, Object... bsmArgs) {\r\n    mv1.visitInvokeDynamicInsn(name, desc, bsm, bsmArgs);\r\n    mv2.visitInvokeDynamicInsn(name, desc, bsm, bsmArgs);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitInsnAnnotation(int,TypePath,String,boolean)",
    "entityType": "method",
    "code": "@Override\r\npublic AnnotationVisitor visitInsnAnnotation(int typeRef, TypePath typePath, String desc, boolean visible) {\r\n    return AnnotationVisitorTee.getInstance(mv1.visitInsnAnnotation(typeRef, typePath, desc, visible), mv2.visitInsnAnnotation(typeRef, typePath, desc, visible));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitTryCatchAnnotation(int,TypePath,String,boolean)",
    "entityType": "method",
    "code": "@Override\r\npublic AnnotationVisitor visitTryCatchAnnotation(int typeRef, TypePath typePath, String desc, boolean visible) {\r\n    return AnnotationVisitorTee.getInstance(mv1.visitTryCatchAnnotation(typeRef, typePath, desc, visible), mv2.visitTryCatchAnnotation(typeRef, typePath, desc, visible));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.MethodVisitorTee#visitLocalVariableAnnotation(int,TypePath,Label[],Label[],int[],String,boolean)",
    "entityType": "method",
    "code": "@Override\r\npublic AnnotationVisitor visitLocalVariableAnnotation(int typeRef, TypePath typePath, Label[] start, Label[] end, int[] index, String desc, boolean visible) {\r\n    return AnnotationVisitorTee.getInstance(mv1.visitLocalVariableAnnotation(typeRef, typePath, start, end, index, desc, visible), mv2.visitLocalVariableAnnotation(typeRef, typePath, start, end, index, desc, visible));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.TransformingClassGenerator",
    "entityType": "class",
    "code": "private final ClassGenerator gen;\nprivate final ClassTransformer t;\npublic TransformingClassGenerator(ClassGenerator gen, ClassTransformer t) {\r\n    this.gen = gen;\r\n    this.t = t;\r\n}\n@Override\r\npublic void generateClass(ClassVisitor v) throws Exception {\r\n    t.setTarget(v);\r\n    gen.generateClass(t);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.TransformingClassGenerator#generateClass(ClassVisitor)",
    "entityType": "method",
    "code": "@Override\r\npublic void generateClass(ClassVisitor v) throws Exception {\r\n    t.setTarget(v);\r\n    gen.generateClass(t);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.TransformingClassLoader",
    "entityType": "class",
    "code": "private final ClassTransformerFactory t;\npublic TransformingClassLoader(ClassLoader parent, ClassFilter filter, ClassTransformerFactory t) {\r\n    super(parent, parent, filter);\r\n    this.t = t;\r\n}\n@Override\r\nprotected ClassGenerator getGenerator(ClassReader r) {\r\n    ClassTransformer t2 = t.newInstance();\r\n    return new TransformingClassGenerator(super.getGenerator(r), t2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.TransformingClassLoader#getGenerator(ClassReader)",
    "entityType": "method",
    "code": "@Override\r\nprotected ClassGenerator getGenerator(ClassReader r) {\r\n    ClassTransformer t2 = t.newInstance();\r\n    return new TransformingClassGenerator(super.getGenerator(r), t2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.ParallelSorter",
    "entityType": "class",
    "code": "protected Object[] a;\nprivate Comparer comparer;\nprotected ParallelSorter() {\r\n}\nabstract public ParallelSorter newInstance(Object[] arrays);\n/**\r\n * Create a new ParallelSorter object for a set of arrays. You may\r\n * sort the arrays multiple times via the same ParallelSorter object.\r\n * @param arrays An array of arrays to sort. The arrays may be a mix\r\n * of primitive and non-primitive types, but should all be the same\r\n * length.\r\n */\r\npublic static ParallelSorter create(Object[] arrays) {\r\n    Generator gen = new Generator();\r\n    gen.setArrays(arrays);\r\n    return gen.create();\r\n}\nprivate int len() {\r\n    return ((Object[]) a[0]).length;\r\n}\n/**\r\n * Sort the arrays using the quicksort algorithm.\r\n * @param index array (column) to sort by\r\n */\r\npublic void quickSort(int index) {\r\n    quickSort(index, 0, len(), null);\r\n}\n/**\r\n * Sort the arrays using the quicksort algorithm.\r\n * @param index array (column) to sort by\r\n * @param lo starting array index (row), inclusive\r\n * @param hi ending array index (row), exclusive\r\n */\r\npublic void quickSort(int index, int lo, int hi) {\r\n    quickSort(index, lo, hi, null);\r\n}\n/**\r\n * Sort the arrays using the quicksort algorithm.\r\n * @param index array (column) to sort by\r\n * @param cmp Comparator to use if the specified column is non-primitive\r\n */\r\npublic void quickSort(int index, Comparator cmp) {\r\n    quickSort(index, 0, len(), cmp);\r\n}\n/**\r\n * Sort the arrays using the quicksort algorithm.\r\n * @param index array (column) to sort by\r\n * @param lo starting array index (row), inclusive\r\n * @param hi ending array index (row), exclusive\r\n * @param cmp Comparator to use if the specified column is non-primitive\r\n */\r\npublic void quickSort(int index, int lo, int hi, Comparator cmp) {\r\n    chooseComparer(index, cmp);\r\n    super.quickSort(lo, hi - 1);\r\n}\n/**\r\n * @param index array (column) to sort by\r\n */\r\npublic void mergeSort(int index) {\r\n    mergeSort(index, 0, len(), null);\r\n}\n/**\r\n * Sort the arrays using an in-place merge sort.\r\n * @param index array (column) to sort by\r\n * @param lo starting array index (row), inclusive\r\n * @param hi ending array index (row), exclusive\r\n */\r\npublic void mergeSort(int index, int lo, int hi) {\r\n    mergeSort(index, lo, hi, null);\r\n}\n/**\r\n * Sort the arrays using an in-place merge sort.\r\n * @param index array (column) to sort by\r\n * @param cmp Comparator to use if the specified column is non-primitive\r\n */\r\npublic void mergeSort(int index, Comparator cmp) {\r\n    mergeSort(index, 0, len(), cmp);\r\n}\n/**\r\n * Sort the arrays using an in-place merge sort.\r\n * @param index array (column) to sort by\r\n * @param lo starting array index (row), inclusive\r\n * @param hi ending array index (row), exclusive\r\n * @param cmp Comparator to use if the specified column is non-primitive\r\n */\r\npublic void mergeSort(int index, int lo, int hi, Comparator cmp) {\r\n    chooseComparer(index, cmp);\r\n    super.mergeSort(lo, hi - 1);\r\n}\nprivate void chooseComparer(int index, Comparator cmp) {\r\n    Object array = a[index];\r\n    Class type = array.getClass().componentType();\r\n    if (type.equals(Integer.TYPE)) {\r\n        comparer = new IntComparer((int[]) array);\r\n    } else if (type.equals(Long.TYPE)) {\r\n        comparer = new LongComparer((long[]) array);\r\n    } else if (type.equals(Double.TYPE)) {\r\n        comparer = new DoubleComparer((double[]) array);\r\n    } else if (type.equals(Float.TYPE)) {\r\n        comparer = new FloatComparer((float[]) array);\r\n    } else if (type.equals(Short.TYPE)) {\r\n        comparer = new ShortComparer((short[]) array);\r\n    } else if (type.equals(Byte.TYPE)) {\r\n        comparer = new ByteComparer((byte[]) array);\r\n    } else if (cmp != null) {\r\n        comparer = new ComparatorComparer((Object[]) array, cmp);\r\n    } else {\r\n        comparer = new ObjectComparer((Object[]) array);\r\n    }\r\n}\n@Override\r\nprotected int compare(int i, int j) {\r\n    return comparer.compare(i, j);\r\n}\ninterface Comparer {\r\n\r\n    int compare(int i, int j);\r\n}\nstatic class ComparatorComparer implements Comparer {\r\n\r\n    private final Object[] a;\r\n\r\n    private final Comparator cmp;\r\n\r\n    public ComparatorComparer(Object[] a, Comparator cmp) {\r\n        this.a = a;\r\n        this.cmp = cmp;\r\n    }\r\n\r\n    @Override\r\n    public int compare(int i, int j) {\r\n        return cmp.compare(a[i], a[j]);\r\n    }\r\n}\nstatic class ObjectComparer implements Comparer {\r\n\r\n    private final Object[] a;\r\n\r\n    public ObjectComparer(Object[] a) {\r\n        this.a = a;\r\n    }\r\n\r\n    @Override\r\n    public int compare(int i, int j) {\r\n        return ((Comparable) a[i]).compareTo(a[j]);\r\n    }\r\n}\nstatic class IntComparer implements Comparer {\r\n\r\n    private final int[] a;\r\n\r\n    public IntComparer(int[] a) {\r\n        this.a = a;\r\n    }\r\n\r\n    @Override\r\n    public int compare(int i, int j) {\r\n        return a[i] - a[j];\r\n    }\r\n}\nstatic class LongComparer implements Comparer {\r\n\r\n    private final long[] a;\r\n\r\n    public LongComparer(long[] a) {\r\n        this.a = a;\r\n    }\r\n\r\n    @Override\r\n    public int compare(int i, int j) {\r\n        long vi = a[i];\r\n        long vj = a[j];\r\n        return Long.compare(vi, vj);\r\n    }\r\n}\nstatic class FloatComparer implements Comparer {\r\n\r\n    private final float[] a;\r\n\r\n    public FloatComparer(float[] a) {\r\n        this.a = a;\r\n    }\r\n\r\n    @Override\r\n    public int compare(int i, int j) {\r\n        float vi = a[i];\r\n        float vj = a[j];\r\n        return Float.compare(vi, vj);\r\n    }\r\n}\nstatic class DoubleComparer implements Comparer {\r\n\r\n    private final double[] a;\r\n\r\n    public DoubleComparer(double[] a) {\r\n        this.a = a;\r\n    }\r\n\r\n    @Override\r\n    public int compare(int i, int j) {\r\n        double vi = a[i];\r\n        double vj = a[j];\r\n        return Double.compare(vi, vj);\r\n    }\r\n}\nstatic class ShortComparer implements Comparer {\r\n\r\n    private final short[] a;\r\n\r\n    public ShortComparer(short[] a) {\r\n        this.a = a;\r\n    }\r\n\r\n    @Override\r\n    public int compare(int i, int j) {\r\n        return a[i] - a[j];\r\n    }\r\n}\nstatic class ByteComparer implements Comparer {\r\n\r\n    private final byte[] a;\r\n\r\n    public ByteComparer(byte[] a) {\r\n        this.a = a;\r\n    }\r\n\r\n    @Override\r\n    public int compare(int i, int j) {\r\n        return a[i] - a[j];\r\n    }\r\n}\npublic static class Generator extends AbstractClassGenerator {\r\n\r\n    private static final Source SOURCE = new Source(ParallelSorter.class.getName());\r\n\r\n    private Object[] arrays;\r\n\r\n    public Generator() {\r\n        super(SOURCE);\r\n    }\r\n\r\n    @Override\r\n    protected ClassLoader getDefaultClassLoader() {\r\n        // TODO\r\n        return null;\r\n    }\r\n\r\n    public void setArrays(Object[] arrays) {\r\n        this.arrays = arrays;\r\n    }\r\n\r\n    public ParallelSorter create() {\r\n        return (ParallelSorter) super.create(ClassesKey.create(arrays));\r\n    }\r\n\r\n    @Override\r\n    public void generateClass(ClassVisitor v) throws Exception {\r\n        if (arrays.length == 0) {\r\n            throw new IllegalArgumentException(\"No arrays specified to sort\");\r\n        }\r\n        for (Object array : arrays) {\r\n            if (!array.getClass().isArray()) {\r\n                throw new IllegalArgumentException(array.getClass() + \" is not an array\");\r\n            }\r\n        }\r\n        new ParallelSorterEmitter(v, getClassName(), arrays);\r\n    }\r\n\r\n    @Override\r\n    protected Object firstInstance(Class type) {\r\n        return ((ParallelSorter) ReflectUtils.newInstance(type)).newInstance(arrays);\r\n    }\r\n\r\n    @Override\r\n    protected Object nextInstance(Object instance) {\r\n        return ((ParallelSorter) instance).newInstance(arrays);\r\n    }\r\n}",
    "comment": "\n * For the efficient sorting of multiple arrays in parallel.\n * <p>\n * Given two arrays of equal length and varying types, the standard\n * technique for sorting them in parallel is to create a new temporary\n * object for each row, store the objects in a temporary array, sort the\n * array using a custom comparator, and the extract the original values\n * back into their respective arrays. This is wasteful in both time and\n * memory.\n * <p>\n * This class generates bytecode customized to the particular set of\n * arrays you need to sort, in such a way that both arrays are sorted\n * in-place, simultaneously.\n * <p>\n * Two sorting algorithms are provided.\n * Quicksort is best when you only need to sort by a single column, as\n * it requires very few comparisons and swaps. Mergesort is best used\n * when sorting multiple columns, as it is a \"stable\" sort--that is, it\n * does not affect the relative order of equal objects from previous sorts.\n * <p>\n * The mergesort algorithm here is an \"in-place\" variant, which while\n * slower, does not require a temporary array.\n *\n * @author Chris Nokleberg\n "
  },
  {
    "entityId": "org.springframework.cglib.util.ParallelSorter#newInstance(Object[])",
    "entityType": "method",
    "code": "abstract public ParallelSorter newInstance(Object[] arrays);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.ParallelSorter#create(Object[])",
    "entityType": "method",
    "code": "/**\r\n * Create a new ParallelSorter object for a set of arrays. You may\r\n * sort the arrays multiple times via the same ParallelSorter object.\r\n * @param arrays An array of arrays to sort. The arrays may be a mix\r\n * of primitive and non-primitive types, but should all be the same\r\n * length.\r\n */\r\npublic static ParallelSorter create(Object[] arrays) {\r\n    Generator gen = new Generator();\r\n    gen.setArrays(arrays);\r\n    return gen.create();\r\n}",
    "comment": "\n     * Create a new ParallelSorter object for a set of arrays. You may\n     * sort the arrays multiple times via the same ParallelSorter object.\n     * @param arrays An array of arrays to sort. The arrays may be a mix\n     * of primitive and non-primitive types, but should all be the same\n     * length.\n     "
  },
  {
    "entityId": "org.springframework.cglib.util.ParallelSorter#len()",
    "entityType": "method",
    "code": "private int len() {\r\n    return ((Object[]) a[0]).length;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.ParallelSorter#quickSort(int)",
    "entityType": "method",
    "code": "/**\r\n * Sort the arrays using the quicksort algorithm.\r\n * @param index array (column) to sort by\r\n */\r\npublic void quickSort(int index) {\r\n    quickSort(index, 0, len(), null);\r\n}",
    "comment": "\n     * Sort the arrays using the quicksort algorithm.\n     * @param index array (column) to sort by\n     "
  },
  {
    "entityId": "org.springframework.cglib.util.ParallelSorter#quickSort(int,int,int)",
    "entityType": "method",
    "code": "/**\r\n * Sort the arrays using the quicksort algorithm.\r\n * @param index array (column) to sort by\r\n * @param lo starting array index (row), inclusive\r\n * @param hi ending array index (row), exclusive\r\n */\r\npublic void quickSort(int index, int lo, int hi) {\r\n    quickSort(index, lo, hi, null);\r\n}",
    "comment": "\n     * Sort the arrays using the quicksort algorithm.\n     * @param index array (column) to sort by\n     * @param lo starting array index (row), inclusive\n     * @param hi ending array index (row), exclusive\n     "
  },
  {
    "entityId": "org.springframework.cglib.util.ParallelSorter#quickSort(int,Comparator)",
    "entityType": "method",
    "code": "/**\r\n * Sort the arrays using the quicksort algorithm.\r\n * @param index array (column) to sort by\r\n * @param cmp Comparator to use if the specified column is non-primitive\r\n */\r\npublic void quickSort(int index, Comparator cmp) {\r\n    quickSort(index, 0, len(), cmp);\r\n}",
    "comment": "\n     * Sort the arrays using the quicksort algorithm.\n     * @param index array (column) to sort by\n     * @param cmp Comparator to use if the specified column is non-primitive\n     "
  },
  {
    "entityId": "org.springframework.cglib.util.ParallelSorter#quickSort(int,int,int,Comparator)",
    "entityType": "method",
    "code": "/**\r\n * Sort the arrays using the quicksort algorithm.\r\n * @param index array (column) to sort by\r\n * @param lo starting array index (row), inclusive\r\n * @param hi ending array index (row), exclusive\r\n * @param cmp Comparator to use if the specified column is non-primitive\r\n */\r\npublic void quickSort(int index, int lo, int hi, Comparator cmp) {\r\n    chooseComparer(index, cmp);\r\n    super.quickSort(lo, hi - 1);\r\n}",
    "comment": "\n     * Sort the arrays using the quicksort algorithm.\n     * @param index array (column) to sort by\n     * @param lo starting array index (row), inclusive\n     * @param hi ending array index (row), exclusive\n     * @param cmp Comparator to use if the specified column is non-primitive\n     "
  },
  {
    "entityId": "org.springframework.cglib.util.ParallelSorter#mergeSort(int)",
    "entityType": "method",
    "code": "/**\r\n * @param index array (column) to sort by\r\n */\r\npublic void mergeSort(int index) {\r\n    mergeSort(index, 0, len(), null);\r\n}",
    "comment": "\n     * @param index array (column) to sort by\n     "
  },
  {
    "entityId": "org.springframework.cglib.util.ParallelSorter#mergeSort(int,int,int)",
    "entityType": "method",
    "code": "/**\r\n * Sort the arrays using an in-place merge sort.\r\n * @param index array (column) to sort by\r\n * @param lo starting array index (row), inclusive\r\n * @param hi ending array index (row), exclusive\r\n */\r\npublic void mergeSort(int index, int lo, int hi) {\r\n    mergeSort(index, lo, hi, null);\r\n}",
    "comment": "\n     * Sort the arrays using an in-place merge sort.\n     * @param index array (column) to sort by\n     * @param lo starting array index (row), inclusive\n     * @param hi ending array index (row), exclusive\n     "
  },
  {
    "entityId": "org.springframework.cglib.util.ParallelSorter#mergeSort(int,Comparator)",
    "entityType": "method",
    "code": "/**\r\n * Sort the arrays using an in-place merge sort.\r\n * @param index array (column) to sort by\r\n * @param cmp Comparator to use if the specified column is non-primitive\r\n */\r\npublic void mergeSort(int index, Comparator cmp) {\r\n    mergeSort(index, 0, len(), cmp);\r\n}",
    "comment": "\n     * Sort the arrays using an in-place merge sort.\n     * @param index array (column) to sort by\n     * @param cmp Comparator to use if the specified column is non-primitive\n     "
  },
  {
    "entityId": "org.springframework.cglib.util.ParallelSorter#mergeSort(int,int,int,Comparator)",
    "entityType": "method",
    "code": "/**\r\n * Sort the arrays using an in-place merge sort.\r\n * @param index array (column) to sort by\r\n * @param lo starting array index (row), inclusive\r\n * @param hi ending array index (row), exclusive\r\n * @param cmp Comparator to use if the specified column is non-primitive\r\n */\r\npublic void mergeSort(int index, int lo, int hi, Comparator cmp) {\r\n    chooseComparer(index, cmp);\r\n    super.mergeSort(lo, hi - 1);\r\n}",
    "comment": "\n     * Sort the arrays using an in-place merge sort.\n     * @param index array (column) to sort by\n     * @param lo starting array index (row), inclusive\n     * @param hi ending array index (row), exclusive\n     * @param cmp Comparator to use if the specified column is non-primitive\n     "
  },
  {
    "entityId": "org.springframework.cglib.util.ParallelSorter#chooseComparer(int,Comparator)",
    "entityType": "method",
    "code": "private void chooseComparer(int index, Comparator cmp) {\r\n    Object array = a[index];\r\n    Class type = array.getClass().componentType();\r\n    if (type.equals(Integer.TYPE)) {\r\n        comparer = new IntComparer((int[]) array);\r\n    } else if (type.equals(Long.TYPE)) {\r\n        comparer = new LongComparer((long[]) array);\r\n    } else if (type.equals(Double.TYPE)) {\r\n        comparer = new DoubleComparer((double[]) array);\r\n    } else if (type.equals(Float.TYPE)) {\r\n        comparer = new FloatComparer((float[]) array);\r\n    } else if (type.equals(Short.TYPE)) {\r\n        comparer = new ShortComparer((short[]) array);\r\n    } else if (type.equals(Byte.TYPE)) {\r\n        comparer = new ByteComparer((byte[]) array);\r\n    } else if (cmp != null) {\r\n        comparer = new ComparatorComparer((Object[]) array, cmp);\r\n    } else {\r\n        comparer = new ObjectComparer((Object[]) array);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.ParallelSorter#compare(int,int)",
    "entityType": "method",
    "code": "@Override\r\nprotected int compare(int i, int j) {\r\n    return comparer.compare(i, j);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.Comparer",
    "entityType": "class",
    "code": "int compare(int i, int j);",
    "comment": ""
  }
]