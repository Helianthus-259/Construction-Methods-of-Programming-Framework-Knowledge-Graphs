[
  {
    "entityId": "org.springframework.cglib.core.CodeEmitter#unbox(Type)",
    "entityType": "method",
    "code": "/**\r\n * If the argument is a primitive class, replaces the object\r\n * on the top of the stack with the unwrapped (primitive)\r\n * equivalent. For example, Character -> char.\r\n * @param type the class indicating the desired type of the top stack value\r\n */\r\npublic void unbox(Type type) {\r\n    Type t = Constants.TYPE_NUMBER;\r\n    Signature sig = null;\r\n    switch(type.getSort()) {\r\n        case Type.VOID:\r\n            return;\r\n        case Type.CHAR:\r\n            t = Constants.TYPE_CHARACTER;\r\n            sig = CHAR_VALUE;\r\n            break;\r\n        case Type.BOOLEAN:\r\n            t = Constants.TYPE_BOOLEAN;\r\n            sig = BOOLEAN_VALUE;\r\n            break;\r\n        case Type.DOUBLE:\r\n            sig = DOUBLE_VALUE;\r\n            break;\r\n        case Type.FLOAT:\r\n            sig = FLOAT_VALUE;\r\n            break;\r\n        case Type.LONG:\r\n            sig = LONG_VALUE;\r\n            break;\r\n        case Type.INT:\r\n        case Type.SHORT:\r\n        case Type.BYTE:\r\n            sig = INT_VALUE;\r\n    }\r\n    if (sig == null) {\r\n        checkcast(type);\r\n    } else {\r\n        checkcast(t);\r\n        invoke_virtual(t, sig);\r\n    }\r\n}",
    "comment": "\n     * If the argument is a primitive class, replaces the object\n     * on the top of the stack with the unwrapped (primitive)\n     * equivalent. For example, Character -> char.\n     * @param type the class indicating the desired type of the top stack value\n     "
  },
  {
    "entityId": "org.springframework.cglib.core.CodeEmitter#create_arg_array()",
    "entityType": "method",
    "code": "/**\r\n * Allocates and fills an Object[] array with the arguments to the\r\n * current method. Primitive values are inserted as their boxed\r\n * (Object) equivalents.\r\n */\r\npublic void create_arg_array() {\r\n    /* generates:\r\n           Object[] args = new Object[]{ arg1, new Integer(arg2) };\r\n         */\r\n    push(state.argumentTypes.length);\r\n    newarray();\r\n    for (int i = 0; i < state.argumentTypes.length; i++) {\r\n        dup();\r\n        push(i);\r\n        load_arg(i);\r\n        box(state.argumentTypes[i]);\r\n        aastore();\r\n    }\r\n}",
    "comment": "\n     * Allocates and fills an Object[] array with the arguments to the\n     * current method. Primitive values are inserted as their boxed\n     * (Object) equivalents.\n     "
  },
  {
    "entityId": "org.springframework.cglib.core.CodeEmitter#zero_or_null(Type)",
    "entityType": "method",
    "code": "/**\r\n * Pushes a zero onto the stack if the argument is a primitive class, or a null otherwise.\r\n */\r\npublic void zero_or_null(Type type) {\r\n    if (TypeUtils.isPrimitive(type)) {\r\n        switch(type.getSort()) {\r\n            case Type.DOUBLE:\r\n                push(0d);\r\n                break;\r\n            case Type.LONG:\r\n                push(0L);\r\n                break;\r\n            case Type.FLOAT:\r\n                push(0f);\r\n                break;\r\n            case Type.VOID:\r\n                aconst_null();\r\n            default:\r\n                push(0);\r\n        }\r\n    } else {\r\n        aconst_null();\r\n    }\r\n}",
    "comment": "\n     * Pushes a zero onto the stack if the argument is a primitive class, or a null otherwise.\n     "
  },
  {
    "entityId": "org.springframework.cglib.core.CodeEmitter#unbox_or_zero(Type)",
    "entityType": "method",
    "code": "/**\r\n * Unboxes the object on the top of the stack. If the object is null, the\r\n * unboxed primitive value becomes zero.\r\n */\r\npublic void unbox_or_zero(Type type) {\r\n    if (TypeUtils.isPrimitive(type)) {\r\n        if (type != Type.VOID_TYPE) {\r\n            Label nonNull = make_label();\r\n            Label end = make_label();\r\n            dup();\r\n            ifnonnull(nonNull);\r\n            pop();\r\n            zero_or_null(type);\r\n            goTo(end);\r\n            mark(nonNull);\r\n            unbox(type);\r\n            mark(end);\r\n        }\r\n    } else {\r\n        checkcast(type);\r\n    }\r\n}",
    "comment": "\n     * Unboxes the object on the top of the stack. If the object is null, the\n     * unboxed primitive value becomes zero.\n     "
  },
  {
    "entityId": "org.springframework.cglib.core.CodeEmitter#visitMaxs(int,int)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitMaxs(int maxStack, int maxLocals) {\r\n    if (!TypeUtils.isAbstract(state.access)) {\r\n        mv.visitMaxs(0, 0);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.CodeEmitter#invoke(MethodInfo,Type)",
    "entityType": "method",
    "code": "public void invoke(MethodInfo method, Type virtualType) {\r\n    ClassInfo classInfo = method.getClassInfo();\r\n    Type type = classInfo.getType();\r\n    Signature sig = method.getSignature();\r\n    if (sig.getName().equals(Constants.CONSTRUCTOR_NAME)) {\r\n        invoke_constructor(type, sig);\r\n    } else if (TypeUtils.isStatic(method.getModifiers())) {\r\n        invoke_static(type, sig, TypeUtils.isInterface(classInfo.getModifiers()));\r\n    } else if (TypeUtils.isInterface(classInfo.getModifiers())) {\r\n        invoke_interface(type, sig);\r\n    } else {\r\n        invoke_virtual(virtualType, sig);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.CodeEmitter#invoke(MethodInfo)",
    "entityType": "method",
    "code": "public void invoke(MethodInfo method) {\r\n    invoke(method, method.getClassInfo().getType());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.State",
    "entityType": "class",
    "code": "ClassInfo classInfo;\nint access;\nSignature sig;\nType[] argumentTypes;\nint localOffset;\nType[] exceptionTypes;\nState(ClassInfo classInfo, int access, Signature sig, Type[] exceptionTypes) {\r\n    this.classInfo = classInfo;\r\n    this.access = access;\r\n    this.sig = sig;\r\n    this.exceptionTypes = exceptionTypes;\r\n    localOffset = TypeUtils.isStatic(access) ? 0 : 1;\r\n    argumentTypes = sig.getArgumentTypes();\r\n}\n@Override\r\npublic ClassInfo getClassInfo() {\r\n    return classInfo;\r\n}\n@Override\r\npublic int getModifiers() {\r\n    return access;\r\n}\n@Override\r\npublic Signature getSignature() {\r\n    return sig;\r\n}\n@Override\r\npublic Type[] getExceptionTypes() {\r\n    return exceptionTypes;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.State#getClassInfo()",
    "entityType": "method",
    "code": "@Override\r\npublic ClassInfo getClassInfo() {\r\n    return classInfo;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.State#getModifiers()",
    "entityType": "method",
    "code": "@Override\r\npublic int getModifiers() {\r\n    return access;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.State#getSignature()",
    "entityType": "method",
    "code": "@Override\r\npublic Signature getSignature() {\r\n    return sig;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.State#getExceptionTypes()",
    "entityType": "method",
    "code": "@Override\r\npublic Type[] getExceptionTypes() {\r\n    return exceptionTypes;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.CodeGenerationException",
    "entityType": "class",
    "code": "private Throwable cause;\npublic CodeGenerationException(Throwable cause) {\r\n    super(cause.getClass().getName() + \"-->\" + cause.getMessage());\r\n    this.cause = cause;\r\n}\n@Override\r\npublic Throwable getCause() {\r\n    return cause;\r\n}",
    "comment": "\n * @version $Id: CodeGenerationException.java,v 1.3 2004/06/24 21:15:21 herbyderby Exp $\n "
  },
  {
    "entityId": "org.springframework.cglib.core.CodeGenerationException#getCause()",
    "entityType": "method",
    "code": "@Override\r\npublic Throwable getCause() {\r\n    return cause;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.CollectionUtils",
    "entityType": "class",
    "code": "private CollectionUtils() {\r\n}\npublic static Map bucket(Collection c, Transformer t) {\r\n    Map buckets = new HashMap();\r\n    for (Object value : c) {\r\n        Object key = t.transform(value);\r\n        List bucket = (List) buckets.get(key);\r\n        if (bucket == null) {\r\n            buckets.put(key, bucket = new LinkedList());\r\n        }\r\n        bucket.add(value);\r\n    }\r\n    return buckets;\r\n}\npublic static void reverse(Map source, Map target) {\r\n    for (Object key : source.keySet()) {\r\n        target.put(source.get(key), key);\r\n    }\r\n}\npublic static Collection filter(Collection c, Predicate p) {\r\n    c.removeIf(o -> !p.evaluate(o));\r\n    return c;\r\n}\npublic static List transform(Collection c, Transformer t) {\r\n    List result = new ArrayList(c.size());\r\n    for (Iterator it = c.iterator(); it.hasNext(); ) {\r\n        result.add(t.transform(it.next()));\r\n    }\r\n    return result;\r\n}\npublic static Map getIndexMap(List list) {\r\n    Map indexes = new HashMap();\r\n    int index = 0;\r\n    for (Iterator it = list.iterator(); it.hasNext(); ) {\r\n        indexes.put(it.next(), index++);\r\n    }\r\n    return indexes;\r\n}",
    "comment": "\n * @author Chris Nokleberg\n * @version $Id: CollectionUtils.java,v 1.7 2004/06/24 21:15:21 herbyderby Exp $\n "
  },
  {
    "entityId": "org.springframework.cglib.core.CollectionUtils#bucket(Collection,Transformer)",
    "entityType": "method",
    "code": "public static Map bucket(Collection c, Transformer t) {\r\n    Map buckets = new HashMap();\r\n    for (Object value : c) {\r\n        Object key = t.transform(value);\r\n        List bucket = (List) buckets.get(key);\r\n        if (bucket == null) {\r\n            buckets.put(key, bucket = new LinkedList());\r\n        }\r\n        bucket.add(value);\r\n    }\r\n    return buckets;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.CollectionUtils#reverse(Map,Map)",
    "entityType": "method",
    "code": "public static void reverse(Map source, Map target) {\r\n    for (Object key : source.keySet()) {\r\n        target.put(source.get(key), key);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.CollectionUtils#filter(Collection,Predicate)",
    "entityType": "method",
    "code": "public static Collection filter(Collection c, Predicate p) {\r\n    c.removeIf(o -> !p.evaluate(o));\r\n    return c;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.CollectionUtils#transform(Collection,Transformer)",
    "entityType": "method",
    "code": "public static List transform(Collection c, Transformer t) {\r\n    List result = new ArrayList(c.size());\r\n    for (Iterator it = c.iterator(); it.hasNext(); ) {\r\n        result.add(t.transform(it.next()));\r\n    }\r\n    return result;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.CollectionUtils#getIndexMap(List)",
    "entityType": "method",
    "code": "public static Map getIndexMap(List list) {\r\n    Map indexes = new HashMap();\r\n    int index = 0;\r\n    for (Iterator it = list.iterator(); it.hasNext(); ) {\r\n        indexes.put(it.next(), index++);\r\n    }\r\n    return indexes;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.Constants",
    "entityType": "class",
    "code": "/* Indicates the ASM API version that is used throughout cglib */\r\npublic static final int ASM_API = AsmApi.value();\npublic static final Class[] EMPTY_CLASS_ARRAY = {};\npublic static final Type[] TYPES_EMPTY = {};\npublic static final Signature SIG_STATIC = TypeUtils.parseSignature(\"void <clinit>()\");\npublic static final Type TYPE_OBJECT_ARRAY = TypeUtils.parseType(\"Object[]\");\npublic static final Type TYPE_CLASS_ARRAY = TypeUtils.parseType(\"Class[]\");\npublic static final Type TYPE_STRING_ARRAY = TypeUtils.parseType(\"String[]\");\npublic static final Type TYPE_OBJECT = TypeUtils.parseType(\"Object\");\npublic static final Type TYPE_CLASS = TypeUtils.parseType(\"Class\");\npublic static final Type TYPE_CLASS_LOADER = TypeUtils.parseType(\"ClassLoader\");\npublic static final Type TYPE_CHARACTER = TypeUtils.parseType(\"Character\");\npublic static final Type TYPE_BOOLEAN = TypeUtils.parseType(\"Boolean\");\npublic static final Type TYPE_DOUBLE = TypeUtils.parseType(\"Double\");\npublic static final Type TYPE_FLOAT = TypeUtils.parseType(\"Float\");\npublic static final Type TYPE_LONG = TypeUtils.parseType(\"Long\");\npublic static final Type TYPE_INTEGER = TypeUtils.parseType(\"Integer\");\npublic static final Type TYPE_SHORT = TypeUtils.parseType(\"Short\");\npublic static final Type TYPE_BYTE = TypeUtils.parseType(\"Byte\");\npublic static final Type TYPE_NUMBER = TypeUtils.parseType(\"Number\");\npublic static final Type TYPE_STRING = TypeUtils.parseType(\"String\");\npublic static final Type TYPE_THROWABLE = TypeUtils.parseType(\"Throwable\");\npublic static final Type TYPE_BIG_INTEGER = TypeUtils.parseType(\"java.math.BigInteger\");\npublic static final Type TYPE_BIG_DECIMAL = TypeUtils.parseType(\"java.math.BigDecimal\");\npublic static final Type TYPE_STRING_BUFFER = TypeUtils.parseType(\"StringBuffer\");\npublic static final Type TYPE_RUNTIME_EXCEPTION = TypeUtils.parseType(\"RuntimeException\");\npublic static final Type TYPE_ERROR = TypeUtils.parseType(\"Error\");\npublic static final Type TYPE_SYSTEM = TypeUtils.parseType(\"System\");\npublic static final Type TYPE_SIGNATURE = TypeUtils.parseType(\"org.springframework.cglib.core.Signature\");\npublic static final Type TYPE_TYPE = Type.getType(Type.class);\npublic static final String CONSTRUCTOR_NAME = \"<init>\";\npublic static final String STATIC_NAME = \"<clinit>\";\npublic static final String SOURCE_FILE = \"<generated>\";\npublic static final String SUID_FIELD_NAME = \"serialVersionUID\";\npublic static final int PRIVATE_FINAL_STATIC = ACC_PRIVATE | ACC_FINAL | ACC_STATIC;\npublic static final int SWITCH_STYLE_TRIE = 0;\npublic static final int SWITCH_STYLE_HASH = 1;\npublic static final int SWITCH_STYLE_HASHONLY = 2;",
    "comment": "\n * @author Juozas Baliuka <a href=\"mailto:baliuka@mwm.lt\">baliuka@mwm.lt</a>\n * @version $Id: Constants.java,v 1.21 2006/03/05 02:43:19 herbyderby Exp $\n "
  },
  {
    "entityId": "org.springframework.cglib.core.Converter",
    "entityType": "class",
    "code": "Object convert(Object value, Class target, Object context);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.Converter#convert(Object,Class,Object)",
    "entityType": "method",
    "code": "Object convert(Object value, Class target, Object context);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.Customizer",
    "entityType": "class",
    "code": "void customize(CodeEmitter e, Type type);",
    "comment": "\n * Customizes key types for {@link KeyFactory} when building equals, hashCode, and toString.\n * For customization of field types, use {@link FieldTypeCustomizer}\n *\n * @see KeyFactory#CLASS_BY_NAME\n "
  },
  {
    "entityId": "org.springframework.cglib.core.Customizer#customize(CodeEmitter,Type)",
    "entityType": "method",
    "code": "void customize(CodeEmitter e, Type type);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.DebuggingClassWriter",
    "entityType": "class",
    "code": "public static final String DEBUG_LOCATION_PROPERTY = \"cglib.debugLocation\";\nprivate static String debugLocation;\nprivate static Constructor traceCtor;\nprivate String className;\nprivate String superName;\nstatic {\r\n    debugLocation = System.getProperty(DEBUG_LOCATION_PROPERTY);\r\n    if (debugLocation != null) {\r\n        System.err.println(\"CGLIB debugging enabled, writing to '\" + debugLocation + \"'\");\r\n        try {\r\n            Class clazz = Class.forName(\"org.springframework.asm.util.TraceClassVisitor\");\r\n            traceCtor = clazz.getConstructor(new Class[] { ClassVisitor.class, PrintWriter.class });\r\n        } catch (Throwable ignore) {\r\n        }\r\n    }\r\n}\npublic DebuggingClassWriter(int flags) {\r\n    super(Constants.ASM_API, new ClassWriter(flags));\r\n}\n@Override\r\npublic void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\r\n    className = name.replace('/', '.');\r\n    this.superName = superName.replace('/', '.');\r\n    super.visit(version, access, name, signature, superName, interfaces);\r\n}\npublic String getClassName() {\r\n    return className;\r\n}\npublic String getSuperName() {\r\n    return superName;\r\n}\npublic byte[] toByteArray() {\r\n    byte[] b = ((ClassWriter) DebuggingClassWriter.super.cv).toByteArray();\r\n    if (debugLocation != null) {\r\n        String dirs = className.replace('.', File.separatorChar);\r\n        try {\r\n            new File(debugLocation + File.separatorChar + dirs).getParentFile().mkdirs();\r\n            File file = new File(new File(debugLocation), dirs + \".class\");\r\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(file));\r\n            try {\r\n                out.write(b);\r\n            } finally {\r\n                out.close();\r\n            }\r\n            if (traceCtor != null) {\r\n                file = new File(new File(debugLocation), dirs + \".asm\");\r\n                out = new BufferedOutputStream(new FileOutputStream(file));\r\n                try {\r\n                    ClassReader cr = new ClassReader(b);\r\n                    PrintWriter pw = new PrintWriter(new OutputStreamWriter(out));\r\n                    ClassVisitor tcv = (ClassVisitor) traceCtor.newInstance(new Object[] { null, pw });\r\n                    cr.accept(tcv, 0);\r\n                    pw.flush();\r\n                } finally {\r\n                    out.close();\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n            throw new CodeGenerationException(e);\r\n        }\r\n    }\r\n    return b;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.DebuggingClassWriter#visit(int,int,String,String,String,String[])",
    "entityType": "method",
    "code": "@Override\r\npublic void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\r\n    className = name.replace('/', '.');\r\n    this.superName = superName.replace('/', '.');\r\n    super.visit(version, access, name, signature, superName, interfaces);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.DebuggingClassWriter#getClassName()",
    "entityType": "method",
    "code": "public String getClassName() {\r\n    return className;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.DebuggingClassWriter#getSuperName()",
    "entityType": "method",
    "code": "public String getSuperName() {\r\n    return superName;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.DebuggingClassWriter#toByteArray()",
    "entityType": "method",
    "code": "public byte[] toByteArray() {\r\n    byte[] b = ((ClassWriter) DebuggingClassWriter.super.cv).toByteArray();\r\n    if (debugLocation != null) {\r\n        String dirs = className.replace('.', File.separatorChar);\r\n        try {\r\n            new File(debugLocation + File.separatorChar + dirs).getParentFile().mkdirs();\r\n            File file = new File(new File(debugLocation), dirs + \".class\");\r\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(file));\r\n            try {\r\n                out.write(b);\r\n            } finally {\r\n                out.close();\r\n            }\r\n            if (traceCtor != null) {\r\n                file = new File(new File(debugLocation), dirs + \".asm\");\r\n                out = new BufferedOutputStream(new FileOutputStream(file));\r\n                try {\r\n                    ClassReader cr = new ClassReader(b);\r\n                    PrintWriter pw = new PrintWriter(new OutputStreamWriter(out));\r\n                    ClassVisitor tcv = (ClassVisitor) traceCtor.newInstance(new Object[] { null, pw });\r\n                    cr.accept(tcv, 0);\r\n                    pw.flush();\r\n                } finally {\r\n                    out.close();\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n            throw new CodeGenerationException(e);\r\n        }\r\n    }\r\n    return b;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.DefaultGeneratorStrategy",
    "entityType": "class",
    "code": "public static final DefaultGeneratorStrategy INSTANCE = new DefaultGeneratorStrategy();\n@Override\r\npublic byte[] generate(ClassGenerator cg) throws Exception {\r\n    DebuggingClassWriter cw = getClassVisitor();\r\n    transform(cg).generateClass(cw);\r\n    return transform(cw.toByteArray());\r\n}\nprotected DebuggingClassWriter getClassVisitor() throws Exception {\r\n    return new DebuggingClassWriter(ClassWriter.COMPUTE_FRAMES);\r\n}\nprotected final ClassWriter getClassWriter() {\r\n    // Cause compile / runtime errors for people who implemented the old\r\n    // interface without using @Override\r\n    throw new UnsupportedOperationException(\"You are calling \" + \"getClassWriter, which no longer exists in this cglib version.\");\r\n}\nprotected byte[] transform(byte[] b) throws Exception {\r\n    return b;\r\n}\nprotected ClassGenerator transform(ClassGenerator cg) throws Exception {\r\n    return cg;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.DefaultGeneratorStrategy#generate(ClassGenerator)",
    "entityType": "method",
    "code": "@Override\r\npublic byte[] generate(ClassGenerator cg) throws Exception {\r\n    DebuggingClassWriter cw = getClassVisitor();\r\n    transform(cg).generateClass(cw);\r\n    return transform(cw.toByteArray());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.DefaultGeneratorStrategy#getClassVisitor()",
    "entityType": "method",
    "code": "protected DebuggingClassWriter getClassVisitor() throws Exception {\r\n    return new DebuggingClassWriter(ClassWriter.COMPUTE_FRAMES);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.DefaultGeneratorStrategy#getClassWriter()",
    "entityType": "method",
    "code": "protected final ClassWriter getClassWriter() {\r\n    // Cause compile / runtime errors for people who implemented the old\r\n    // interface without using @Override\r\n    throw new UnsupportedOperationException(\"You are calling \" + \"getClassWriter, which no longer exists in this cglib version.\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.DefaultGeneratorStrategy#transform(byte[])",
    "entityType": "method",
    "code": "protected byte[] transform(byte[] b) throws Exception {\r\n    return b;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.DefaultGeneratorStrategy#transform(ClassGenerator)",
    "entityType": "method",
    "code": "protected ClassGenerator transform(ClassGenerator cg) throws Exception {\r\n    return cg;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.DefaultNamingPolicy",
    "entityType": "class",
    "code": "public static final DefaultNamingPolicy INSTANCE = new DefaultNamingPolicy();\n/**\r\n * This allows to test collisions of {@code key.hashCode()}.\r\n */\r\nprivate static final boolean STRESS_HASH_CODE = Boolean.getBoolean(\"org.springframework.cglib.test.stressHashCodes\");\n@Override\r\npublic String getClassName(String prefix, String source, Object key, Predicate names) {\r\n    if (prefix == null) {\r\n        prefix = \"org.springframework.cglib.empty.Object\";\r\n    } else if (prefix.startsWith(\"java\")) {\r\n        prefix = \"$\" + prefix;\r\n    }\r\n    String base = prefix + \"$$\" + source.substring(source.lastIndexOf('.') + 1) + getTag() + \"$$\" + Integer.toHexString(STRESS_HASH_CODE ? 0 : key.hashCode());\r\n    String attempt = base;\r\n    int index = 2;\r\n    while (names.evaluate(attempt)) {\r\n        attempt = base + \"_\" + index++;\r\n    }\r\n    return attempt;\r\n}\n/**\r\n * Returns a string which is incorporated into every generated class name.\r\n * By default returns \"ByCGLIB\"\r\n */\r\nprotected String getTag() {\r\n    return \"ByCGLIB\";\r\n}\n@Override\r\npublic int hashCode() {\r\n    return getTag().hashCode();\r\n}\n@Override\r\npublic boolean equals(Object o) {\r\n    return (o instanceof DefaultNamingPolicy defaultNamingPolicy) && defaultNamingPolicy.getTag().equals(getTag());\r\n}",
    "comment": "\n * The default policy used by {@link AbstractClassGenerator}.\n * Generates names such as\n * <p><code>org.springframework.cglib.Foo$$EnhancerByCGLIB$$38272841</code><p>\n * This is composed of a prefix based on the name of the superclass, a fixed\n * string incorporating the CGLIB class responsible for generation, and a\n * hashcode derived from the parameters used to create the object. If the same\n * name has been previously been used in the same <code>ClassLoader</code>, a\n * suffix is added to ensure uniqueness.\n "
  },
  {
    "entityId": "org.springframework.cglib.core.DefaultNamingPolicy#getClassName(String,String,Object,Predicate)",
    "entityType": "method",
    "code": "@Override\r\npublic String getClassName(String prefix, String source, Object key, Predicate names) {\r\n    if (prefix == null) {\r\n        prefix = \"org.springframework.cglib.empty.Object\";\r\n    } else if (prefix.startsWith(\"java\")) {\r\n        prefix = \"$\" + prefix;\r\n    }\r\n    String base = prefix + \"$$\" + source.substring(source.lastIndexOf('.') + 1) + getTag() + \"$$\" + Integer.toHexString(STRESS_HASH_CODE ? 0 : key.hashCode());\r\n    String attempt = base;\r\n    int index = 2;\r\n    while (names.evaluate(attempt)) {\r\n        attempt = base + \"_\" + index++;\r\n    }\r\n    return attempt;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.DefaultNamingPolicy#getTag()",
    "entityType": "method",
    "code": "/**\r\n * Returns a string which is incorporated into every generated class name.\r\n * By default returns \"ByCGLIB\"\r\n */\r\nprotected String getTag() {\r\n    return \"ByCGLIB\";\r\n}",
    "comment": "\n     * Returns a string which is incorporated into every generated class name.\n     * By default returns \"ByCGLIB\"\n     "
  },
  {
    "entityId": "org.springframework.cglib.core.DefaultNamingPolicy#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return getTag().hashCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.DefaultNamingPolicy#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(Object o) {\r\n    return (o instanceof DefaultNamingPolicy defaultNamingPolicy) && defaultNamingPolicy.getTag().equals(getTag());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.DuplicatesPredicate",
    "entityType": "class",
    "code": "private final Set unique;\nprivate final Set rejected;\n/**\r\n * Constructs a DuplicatesPredicate that will allow subclass bridge methods to be preferred over\r\n * superclass non-bridge methods.\r\n */\r\npublic DuplicatesPredicate() {\r\n    unique = new HashSet();\r\n    rejected = Collections.emptySet();\r\n}\n/**\r\n * Constructs a DuplicatesPredicate that prefers using superclass non-bridge methods despite a\r\n * subclass method with the same signature existing (if the subclass is a bridge method).\r\n */\r\npublic DuplicatesPredicate(List allMethods) {\r\n    rejected = new HashSet();\r\n    unique = new HashSet();\r\n    // Traverse through the methods and capture ones that are bridge\r\n    // methods when a subsequent method (from a non-interface superclass)\r\n    // has the same signature but isn't a bridge. Record these so that\r\n    // we avoid using them when filtering duplicates.\r\n    Map scanned = new HashMap();\r\n    Map suspects = new HashMap();\r\n    for (Object o : allMethods) {\r\n        Method method = (Method) o;\r\n        Object sig = MethodWrapper.create(method);\r\n        Method existing = (Method) scanned.get(sig);\r\n        if (existing == null) {\r\n            scanned.put(sig, method);\r\n        } else if (!suspects.containsKey(sig) && existing.isBridge() && !method.isBridge()) {\r\n            // TODO: this currently only will capture a single bridge. it will not work\r\n            // if there's Child.bridge1 Middle.bridge2 Parent.concrete.  (we'd offer the 2nd bridge).\r\n            // no idea if that's even possible tho...\r\n            suspects.put(sig, existing);\r\n        }\r\n    }\r\n    if (!suspects.isEmpty()) {\r\n        Set classes = new HashSet();\r\n        UnnecessaryBridgeFinder finder = new UnnecessaryBridgeFinder(rejected);\r\n        for (Object o : suspects.values()) {\r\n            Method m = (Method) o;\r\n            classes.add(m.getDeclaringClass());\r\n            finder.addSuspectMethod(m);\r\n        }\r\n        for (Object o : classes) {\r\n            Class c = (Class) o;\r\n            try {\r\n                ClassLoader cl = getClassLoader(c);\r\n                if (cl == null) {\r\n                    continue;\r\n                }\r\n                InputStream is = cl.getResourceAsStream(c.getName().replace('.', '/') + \".class\");\r\n                if (is == null) {\r\n                    continue;\r\n                }\r\n                try {\r\n                    new ClassReader(is).accept(finder, ClassReader.SKIP_FRAMES | ClassReader.SKIP_DEBUG);\r\n                } finally {\r\n                    is.close();\r\n                }\r\n            } catch (IOException ignored) {\r\n            }\r\n        }\r\n    }\r\n}\n@Override\r\npublic boolean evaluate(Object arg) {\r\n    return !rejected.contains(arg) && unique.add(MethodWrapper.create((Method) arg));\r\n}\nprivate static ClassLoader getClassLoader(Class c) {\r\n    ClassLoader cl = c.getClassLoader();\r\n    if (cl == null) {\r\n        cl = DuplicatesPredicate.class.getClassLoader();\r\n    }\r\n    if (cl == null) {\r\n        cl = Thread.currentThread().getContextClassLoader();\r\n    }\r\n    return cl;\r\n}\nprivate static class UnnecessaryBridgeFinder extends ClassVisitor {\r\n\r\n    private final Set rejected;\r\n\r\n    private Signature currentMethodSig = null;\r\n\r\n    private Map methods = new HashMap();\r\n\r\n    UnnecessaryBridgeFinder(Set rejected) {\r\n        super(Constants.ASM_API);\r\n        this.rejected = rejected;\r\n    }\r\n\r\n    void addSuspectMethod(Method m) {\r\n        methods.put(ReflectUtils.getSignature(m), m);\r\n    }\r\n\r\n    @Override\r\n    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\r\n    }\r\n\r\n    @Override\r\n    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\r\n        Signature sig = new Signature(name, desc);\r\n        final Method currentMethod = (Method) methods.remove(sig);\r\n        if (currentMethod != null) {\r\n            currentMethodSig = sig;\r\n            return new MethodVisitor(Constants.ASM_API) {\r\n\r\n                @Override\r\n                public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\r\n                    if (opcode == Opcodes.INVOKESPECIAL && currentMethodSig != null) {\r\n                        Signature target = new Signature(name, desc);\r\n                        if (target.equals(currentMethodSig)) {\r\n                            rejected.add(currentMethod);\r\n                        }\r\n                        currentMethodSig = null;\r\n                    }\r\n                }\r\n            };\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.DuplicatesPredicate#evaluate(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean evaluate(Object arg) {\r\n    return !rejected.contains(arg) && unique.add(MethodWrapper.create((Method) arg));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.DuplicatesPredicate#getClassLoader(Class)",
    "entityType": "method",
    "code": "private static ClassLoader getClassLoader(Class c) {\r\n    ClassLoader cl = c.getClassLoader();\r\n    if (cl == null) {\r\n        cl = DuplicatesPredicate.class.getClassLoader();\r\n    }\r\n    if (cl == null) {\r\n        cl = Thread.currentThread().getContextClassLoader();\r\n    }\r\n    return cl;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.UnnecessaryBridgeFinder",
    "entityType": "class",
    "code": "private final Set rejected;\nprivate Signature currentMethodSig = null;\nprivate Map methods = new HashMap();\nUnnecessaryBridgeFinder(Set rejected) {\r\n    super(Constants.ASM_API);\r\n    this.rejected = rejected;\r\n}\nvoid addSuspectMethod(Method m) {\r\n    methods.put(ReflectUtils.getSignature(m), m);\r\n}\n@Override\r\npublic void visit(int version, int access, String name, String signature, String superName, String[] interfaces) ;\n@Override\r\npublic MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\r\n    Signature sig = new Signature(name, desc);\r\n    final Method currentMethod = (Method) methods.remove(sig);\r\n    if (currentMethod != null) {\r\n        currentMethodSig = sig;\r\n        return new MethodVisitor(Constants.ASM_API) {\r\n\r\n            @Override\r\n            public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\r\n                if (opcode == Opcodes.INVOKESPECIAL && currentMethodSig != null) {\r\n                    Signature target = new Signature(name, desc);\r\n                    if (target.equals(currentMethodSig)) {\r\n                        rejected.add(currentMethod);\r\n                    }\r\n                    currentMethodSig = null;\r\n                }\r\n            }\r\n        };\r\n    } else {\r\n        return null;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.UnnecessaryBridgeFinder#addSuspectMethod(Method)",
    "entityType": "method",
    "code": "void addSuspectMethod(Method m) {\r\n    methods.put(ReflectUtils.getSignature(m), m);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.UnnecessaryBridgeFinder#visit(int,int,String,String,String,String[])",
    "entityType": "method",
    "code": "@Override\r\npublic void visit(int version, int access, String name, String signature, String superName, String[] interfaces) ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.UnnecessaryBridgeFinder#visitMethod(int,String,String,String,String[])",
    "entityType": "method",
    "code": "@Override\r\npublic MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\r\n    Signature sig = new Signature(name, desc);\r\n    final Method currentMethod = (Method) methods.remove(sig);\r\n    if (currentMethod != null) {\r\n        currentMethodSig = sig;\r\n        return new MethodVisitor(Constants.ASM_API) {\r\n\r\n            @Override\r\n            public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\r\n                if (opcode == Opcodes.INVOKESPECIAL && currentMethodSig != null) {\r\n                    Signature target = new Signature(name, desc);\r\n                    if (target.equals(currentMethodSig)) {\r\n                        rejected.add(currentMethod);\r\n                    }\r\n                    currentMethodSig = null;\r\n                }\r\n            }\r\n        };\r\n    } else {\r\n        return null;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils",
    "entityType": "class",
    "code": "private static final Signature CSTRUCT_NULL = TypeUtils.parseConstructor(\"\");\nprivate static final Signature CSTRUCT_THROWABLE = TypeUtils.parseConstructor(\"Throwable\");\nprivate static final Signature GET_NAME = TypeUtils.parseSignature(\"String getName()\");\nprivate static final Signature HASH_CODE = TypeUtils.parseSignature(\"int hashCode()\");\nprivate static final Signature EQUALS = TypeUtils.parseSignature(\"boolean equals(Object)\");\nprivate static final Signature STRING_LENGTH = TypeUtils.parseSignature(\"int length()\");\nprivate static final Signature STRING_CHAR_AT = TypeUtils.parseSignature(\"char charAt(int)\");\nprivate static final Signature FOR_NAME = TypeUtils.parseSignature(\"Class forName(String)\");\nprivate static final Signature DOUBLE_TO_LONG_BITS = TypeUtils.parseSignature(\"long doubleToLongBits(double)\");\nprivate static final Signature FLOAT_TO_INT_BITS = TypeUtils.parseSignature(\"int floatToIntBits(float)\");\nprivate static final Signature TO_STRING = TypeUtils.parseSignature(\"String toString()\");\nprivate static final Signature APPEND_STRING = TypeUtils.parseSignature(\"StringBuffer append(String)\");\nprivate static final Signature APPEND_INT = TypeUtils.parseSignature(\"StringBuffer append(int)\");\nprivate static final Signature APPEND_DOUBLE = TypeUtils.parseSignature(\"StringBuffer append(double)\");\nprivate static final Signature APPEND_FLOAT = TypeUtils.parseSignature(\"StringBuffer append(float)\");\nprivate static final Signature APPEND_CHAR = TypeUtils.parseSignature(\"StringBuffer append(char)\");\nprivate static final Signature APPEND_LONG = TypeUtils.parseSignature(\"StringBuffer append(long)\");\nprivate static final Signature APPEND_BOOLEAN = TypeUtils.parseSignature(\"StringBuffer append(boolean)\");\nprivate static final Signature LENGTH = TypeUtils.parseSignature(\"int length()\");\nprivate static final Signature SET_LENGTH = TypeUtils.parseSignature(\"void setLength(int)\");\nprivate static final Signature GET_DECLARED_METHOD = TypeUtils.parseSignature(\"java.lang.reflect.Method getDeclaredMethod(String, Class[])\");\npublic static final ArrayDelimiters DEFAULT_DELIMITERS = new ArrayDelimiters(\"{\", \", \", \"}\");\nprivate EmitUtils() {\r\n}\npublic static void factory_method(ClassEmitter ce, Signature sig) {\r\n    CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, sig, null);\r\n    e.new_instance_this();\r\n    e.dup();\r\n    e.load_args();\r\n    e.invoke_constructor_this(TypeUtils.parseConstructor(sig.getArgumentTypes()));\r\n    e.return_value();\r\n    e.end_method();\r\n}\npublic static void null_constructor(ClassEmitter ce) {\r\n    CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, CSTRUCT_NULL, null);\r\n    e.load_this();\r\n    e.super_invoke_constructor();\r\n    e.return_value();\r\n    e.end_method();\r\n}\n/**\r\n * Process an array on the stack. Assumes the top item on the stack\r\n * is an array of the specified type. For each element in the array,\r\n * puts the element on the stack and triggers the callback.\r\n * @param type the type of the array (type.isArray() must be true)\r\n * @param callback the callback triggered for each element\r\n */\r\npublic static void process_array(CodeEmitter e, Type type, ProcessArrayCallback callback) {\r\n    Type componentType = TypeUtils.getComponentType(type);\r\n    Local array = e.make_local();\r\n    Local loopvar = e.make_local(Type.INT_TYPE);\r\n    Label loopbody = e.make_label();\r\n    Label checkloop = e.make_label();\r\n    e.store_local(array);\r\n    e.push(0);\r\n    e.store_local(loopvar);\r\n    e.goTo(checkloop);\r\n    e.mark(loopbody);\r\n    e.load_local(array);\r\n    e.load_local(loopvar);\r\n    e.array_load(componentType);\r\n    callback.processElement(componentType);\r\n    e.iinc(loopvar, 1);\r\n    e.mark(checkloop);\r\n    e.load_local(loopvar);\r\n    e.load_local(array);\r\n    e.arraylength();\r\n    e.if_icmp(CodeEmitter.LT, loopbody);\r\n}\n/**\r\n * Process two arrays on the stack in parallel. Assumes the top two items on the stack\r\n * are arrays of the specified class. The arrays must be the same length. For each pair\r\n * of elements in the arrays, puts the pair on the stack and triggers the callback.\r\n * @param type the type of the arrays (type.isArray() must be true)\r\n * @param callback the callback triggered for each pair of elements\r\n */\r\npublic static void process_arrays(CodeEmitter e, Type type, ProcessArrayCallback callback) {\r\n    Type componentType = TypeUtils.getComponentType(type);\r\n    Local array1 = e.make_local();\r\n    Local array2 = e.make_local();\r\n    Local loopvar = e.make_local(Type.INT_TYPE);\r\n    Label loopbody = e.make_label();\r\n    Label checkloop = e.make_label();\r\n    e.store_local(array1);\r\n    e.store_local(array2);\r\n    e.push(0);\r\n    e.store_local(loopvar);\r\n    e.goTo(checkloop);\r\n    e.mark(loopbody);\r\n    e.load_local(array1);\r\n    e.load_local(loopvar);\r\n    e.array_load(componentType);\r\n    e.load_local(array2);\r\n    e.load_local(loopvar);\r\n    e.array_load(componentType);\r\n    callback.processElement(componentType);\r\n    e.iinc(loopvar, 1);\r\n    e.mark(checkloop);\r\n    e.load_local(loopvar);\r\n    e.load_local(array1);\r\n    e.arraylength();\r\n    e.if_icmp(CodeEmitter.LT, loopbody);\r\n}\npublic static void string_switch(CodeEmitter e, String[] strings, int switchStyle, ObjectSwitchCallback callback) {\r\n    try {\r\n        switch(switchStyle) {\r\n            case Constants.SWITCH_STYLE_TRIE:\r\n                string_switch_trie(e, strings, callback);\r\n                break;\r\n            case Constants.SWITCH_STYLE_HASH:\r\n                string_switch_hash(e, strings, callback, false);\r\n                break;\r\n            case Constants.SWITCH_STYLE_HASHONLY:\r\n                string_switch_hash(e, strings, callback, true);\r\n                break;\r\n            default:\r\n                throw new IllegalArgumentException(\"unknown switch style \" + switchStyle);\r\n        }\r\n    } catch (RuntimeException | Error ex) {\r\n        throw ex;\r\n    } catch (Exception ex) {\r\n        throw new CodeGenerationException(ex);\r\n    }\r\n}\nprivate static void string_switch_trie(final CodeEmitter e, String[] strings, final ObjectSwitchCallback callback) throws Exception {\r\n    final Label def = e.make_label();\r\n    final Label end = e.make_label();\r\n    final Map buckets = CollectionUtils.bucket(Arrays.asList(strings), value -> ((String) value).length());\r\n    e.dup();\r\n    e.invoke_virtual(Constants.TYPE_STRING, STRING_LENGTH);\r\n    e.process_switch(getSwitchKeys(buckets), new ProcessSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(int key, Label ignore_end) throws Exception {\r\n            List bucket = (List) buckets.get(key);\r\n            stringSwitchHelper(e, bucket, callback, def, end, 0);\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            e.goTo(def);\r\n        }\r\n    });\r\n    e.mark(def);\r\n    e.pop();\r\n    callback.processDefault();\r\n    e.mark(end);\r\n}\nprivate static void stringSwitchHelper(final CodeEmitter e, List strings, final ObjectSwitchCallback callback, final Label def, final Label end, final int index) throws Exception {\r\n    final int len = ((String) strings.get(0)).length();\r\n    final Map buckets = CollectionUtils.bucket(strings, value -> ((String) value).charAt(index));\r\n    e.dup();\r\n    e.push(index);\r\n    e.invoke_virtual(Constants.TYPE_STRING, STRING_CHAR_AT);\r\n    e.process_switch(getSwitchKeys(buckets), new ProcessSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(int key, Label ignore_end) throws Exception {\r\n            List bucket = (List) buckets.get(key);\r\n            if (index + 1 == len) {\r\n                e.pop();\r\n                callback.processCase(bucket.get(0), end);\r\n            } else {\r\n                stringSwitchHelper(e, bucket, callback, def, end, index + 1);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            e.goTo(def);\r\n        }\r\n    });\r\n}\nstatic int[] getSwitchKeys(Map buckets) {\r\n    int[] keys = new int[buckets.size()];\r\n    int index = 0;\r\n    for (Iterator it = buckets.keySet().iterator(); it.hasNext(); ) {\r\n        keys[index++] = ((Integer) it.next());\r\n    }\r\n    Arrays.sort(keys);\r\n    return keys;\r\n}\nprivate static void string_switch_hash(final CodeEmitter e, final String[] strings, final ObjectSwitchCallback callback, final boolean skipEquals) throws Exception {\r\n    final Map buckets = CollectionUtils.bucket(Arrays.asList(strings), value -> value.hashCode());\r\n    final Label def = e.make_label();\r\n    final Label end = e.make_label();\r\n    e.dup();\r\n    e.invoke_virtual(Constants.TYPE_OBJECT, HASH_CODE);\r\n    e.process_switch(getSwitchKeys(buckets), new ProcessSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(int key, Label ignore_end) throws Exception {\r\n            List bucket = (List) buckets.get(key);\r\n            Label next = null;\r\n            if (skipEquals && bucket.size() == 1) {\r\n                if (skipEquals) {\r\n                    e.pop();\r\n                }\r\n                callback.processCase(bucket.get(0), end);\r\n            } else {\r\n                for (Iterator it = bucket.iterator(); it.hasNext(); ) {\r\n                    String string = (String) it.next();\r\n                    if (next != null) {\r\n                        e.mark(next);\r\n                    }\r\n                    if (it.hasNext()) {\r\n                        e.dup();\r\n                    }\r\n                    e.push(string);\r\n                    e.invoke_virtual(Constants.TYPE_OBJECT, EQUALS);\r\n                    if (it.hasNext()) {\r\n                        e.if_jump(CodeEmitter.EQ, next = e.make_label());\r\n                        e.pop();\r\n                    } else {\r\n                        e.if_jump(CodeEmitter.EQ, def);\r\n                    }\r\n                    callback.processCase(string, end);\r\n                }\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            e.pop();\r\n        }\r\n    });\r\n    e.mark(def);\r\n    callback.processDefault();\r\n    e.mark(end);\r\n}\npublic static void load_class_this(CodeEmitter e) {\r\n    load_class_helper(e, e.getClassEmitter().getClassType());\r\n}\npublic static void load_class(CodeEmitter e, Type type) {\r\n    if (TypeUtils.isPrimitive(type)) {\r\n        if (type == Type.VOID_TYPE) {\r\n            throw new IllegalArgumentException(\"cannot load void type\");\r\n        }\r\n        e.getstatic(TypeUtils.getBoxedType(type), \"TYPE\", Constants.TYPE_CLASS);\r\n    } else {\r\n        load_class_helper(e, type);\r\n    }\r\n}\nprivate static void load_class_helper(CodeEmitter e, final Type type) {\r\n    if (e.isStaticHook()) {\r\n        // have to fall back on non-optimized load\r\n        e.push(TypeUtils.emulateClassGetName(type));\r\n        e.invoke_static(Constants.TYPE_CLASS, FOR_NAME);\r\n    } else {\r\n        ClassEmitter ce = e.getClassEmitter();\r\n        String typeName = TypeUtils.emulateClassGetName(type);\r\n        // TODO: can end up with duplicated field names when using chained transformers; incorporate static hook # somehow\r\n        String fieldName = \"CGLIB$load_class$\" + TypeUtils.escapeType(typeName);\r\n        if (!ce.isFieldDeclared(fieldName)) {\r\n            ce.declare_field(Constants.PRIVATE_FINAL_STATIC, fieldName, Constants.TYPE_CLASS, null);\r\n            CodeEmitter hook = ce.getStaticHook();\r\n            hook.push(typeName);\r\n            hook.invoke_static(Constants.TYPE_CLASS, FOR_NAME);\r\n            hook.putstatic(ce.getClassType(), fieldName, Constants.TYPE_CLASS);\r\n        }\r\n        e.getfield(fieldName);\r\n    }\r\n}\npublic static void push_array(CodeEmitter e, Object[] array) {\r\n    e.push(array.length);\r\n    e.newarray(Type.getType(remapComponentType(array.getClass().componentType())));\r\n    for (int i = 0; i < array.length; i++) {\r\n        e.dup();\r\n        e.push(i);\r\n        push_object(e, array[i]);\r\n        e.aastore();\r\n    }\r\n}\nprivate static Class remapComponentType(Class componentType) {\r\n    if (componentType.equals(Type.class)) {\r\n        return Class.class;\r\n    }\r\n    return componentType;\r\n}\npublic static void push_object(CodeEmitter e, Object obj) {\r\n    if (obj == null) {\r\n        e.aconst_null();\r\n    } else {\r\n        if (obj.getClass().isArray()) {\r\n            push_array(e, (Object[]) obj);\r\n        } else if (obj instanceof String text) {\r\n            e.push(text);\r\n        } else if (obj instanceof Type type) {\r\n            load_class(e, type);\r\n        } else if (obj instanceof Class<?> clazz) {\r\n            load_class(e, Type.getType(clazz));\r\n        } else if (obj instanceof BigInteger) {\r\n            e.new_instance(Constants.TYPE_BIG_INTEGER);\r\n            e.dup();\r\n            e.push(obj.toString());\r\n            e.invoke_constructor(Constants.TYPE_BIG_INTEGER);\r\n        } else if (obj instanceof BigDecimal) {\r\n            e.new_instance(Constants.TYPE_BIG_DECIMAL);\r\n            e.dup();\r\n            e.push(obj.toString());\r\n            e.invoke_constructor(Constants.TYPE_BIG_DECIMAL);\r\n        } else {\r\n            throw new IllegalArgumentException(\"unknown type: \" + obj.getClass());\r\n        }\r\n    }\r\n}\n/**\r\n * @deprecated use {@link #hash_code(CodeEmitter, Type, int, CustomizerRegistry)} instead\r\n */\r\n@Deprecated\r\npublic static void hash_code(CodeEmitter e, Type type, int multiplier, final Customizer customizer) {\r\n    hash_code(e, type, multiplier, CustomizerRegistry.singleton(customizer));\r\n}\npublic static void hash_code(CodeEmitter e, Type type, int multiplier, final CustomizerRegistry registry) {\r\n    if (TypeUtils.isArray(type)) {\r\n        hash_array(e, type, multiplier, registry);\r\n    } else {\r\n        e.swap(Type.INT_TYPE, type);\r\n        e.push(multiplier);\r\n        e.math(CodeEmitter.MUL, Type.INT_TYPE);\r\n        e.swap(type, Type.INT_TYPE);\r\n        if (TypeUtils.isPrimitive(type)) {\r\n            hash_primitive(e, type);\r\n        } else {\r\n            hash_object(e, type, registry);\r\n        }\r\n        e.math(CodeEmitter.ADD, Type.INT_TYPE);\r\n    }\r\n}\nprivate static void hash_array(final CodeEmitter e, Type type, final int multiplier, final CustomizerRegistry registry) {\r\n    Label skip = e.make_label();\r\n    Label end = e.make_label();\r\n    e.dup();\r\n    e.ifnull(skip);\r\n    EmitUtils.process_array(e, type, type1 -> hash_code(e, type1, multiplier, registry));\r\n    e.goTo(end);\r\n    e.mark(skip);\r\n    e.pop();\r\n    e.mark(end);\r\n}\nprivate static void hash_object(CodeEmitter e, Type type, CustomizerRegistry registry) {\r\n    // (f == null) ? 0 : f.hashCode();\r\n    Label skip = e.make_label();\r\n    Label end = e.make_label();\r\n    e.dup();\r\n    e.ifnull(skip);\r\n    boolean customHashCode = false;\r\n    for (HashCodeCustomizer customizer : registry.get(HashCodeCustomizer.class)) {\r\n        if (customizer.customize(e, type)) {\r\n            customHashCode = true;\r\n            break;\r\n        }\r\n    }\r\n    if (!customHashCode) {\r\n        for (Customizer customizer : registry.get(Customizer.class)) {\r\n            customizer.customize(e, type);\r\n        }\r\n        e.invoke_virtual(Constants.TYPE_OBJECT, HASH_CODE);\r\n    }\r\n    e.goTo(end);\r\n    e.mark(skip);\r\n    e.pop();\r\n    e.push(0);\r\n    e.mark(end);\r\n}\nprivate static void hash_primitive(CodeEmitter e, Type type) {\r\n    switch(type.getSort()) {\r\n        case Type.BOOLEAN:\r\n            // f ? 0 : 1\r\n            e.push(1);\r\n            e.math(CodeEmitter.XOR, Type.INT_TYPE);\r\n            break;\r\n        case Type.FLOAT:\r\n            // Float.floatToIntBits(f)\r\n            e.invoke_static(Constants.TYPE_FLOAT, FLOAT_TO_INT_BITS);\r\n            break;\r\n        case Type.DOUBLE:\r\n            // Double.doubleToLongBits(f), hash_code(Long.TYPE)\r\n            e.invoke_static(Constants.TYPE_DOUBLE, DOUBLE_TO_LONG_BITS);\r\n        // fall through\r\n        case Type.LONG:\r\n            hash_long(e);\r\n    }\r\n}\nprivate static void hash_long(CodeEmitter e) {\r\n    // (int)(f ^ (f >>> 32))\r\n    e.dup2();\r\n    e.push(32);\r\n    e.math(CodeEmitter.USHR, Type.LONG_TYPE);\r\n    e.math(CodeEmitter.XOR, Type.LONG_TYPE);\r\n    e.cast_numeric(Type.LONG_TYPE, Type.INT_TYPE);\r\n}\n//     public static void not_equals(CodeEmitter e, Type type, Label notEquals) {\r\n//         not_equals(e, type, notEquals, null);\r\n//     }\r\n/**\r\n * @deprecated use {@link #not_equals(CodeEmitter, Type, Label, CustomizerRegistry)} instead\r\n */\r\n@Deprecated\r\npublic static void not_equals(CodeEmitter e, Type type, final Label notEquals, final Customizer customizer) {\r\n    not_equals(e, type, notEquals, CustomizerRegistry.singleton(customizer));\r\n}\n/**\r\n * Branches to the specified label if the top two items on the stack\r\n * are not equal. The items must both be of the specified\r\n * class. Equality is determined by comparing primitive values\r\n * directly and by invoking the <code>equals</code> method for\r\n * Objects. Arrays are recursively processed in the same manner.\r\n */\r\npublic static void not_equals(final CodeEmitter e, Type type, final Label notEquals, final CustomizerRegistry registry) {\r\n    (new ProcessArrayCallback() {\r\n\r\n        @Override\r\n        public void processElement(Type type) {\r\n            not_equals_helper(e, type, notEquals, registry, this);\r\n        }\r\n    }).processElement(type);\r\n}\nprivate static void not_equals_helper(CodeEmitter e, Type type, Label notEquals, CustomizerRegistry registry, ProcessArrayCallback callback) {\r\n    if (TypeUtils.isPrimitive(type)) {\r\n        e.if_cmp(type, CodeEmitter.NE, notEquals);\r\n    } else {\r\n        Label end = e.make_label();\r\n        nullcmp(e, notEquals, end);\r\n        if (TypeUtils.isArray(type)) {\r\n            Label checkContents = e.make_label();\r\n            e.dup2();\r\n            e.arraylength();\r\n            e.swap();\r\n            e.arraylength();\r\n            e.if_icmp(CodeEmitter.EQ, checkContents);\r\n            e.pop2();\r\n            e.goTo(notEquals);\r\n            e.mark(checkContents);\r\n            EmitUtils.process_arrays(e, type, callback);\r\n        } else {\r\n            List<Customizer> customizers = registry.get(Customizer.class);\r\n            if (!customizers.isEmpty()) {\r\n                for (Customizer customizer : customizers) {\r\n                    customizer.customize(e, type);\r\n                }\r\n                e.swap();\r\n                for (Customizer customizer : customizers) {\r\n                    customizer.customize(e, type);\r\n                }\r\n            }\r\n            e.invoke_virtual(Constants.TYPE_OBJECT, EQUALS);\r\n            e.if_jump(CodeEmitter.EQ, notEquals);\r\n        }\r\n        e.mark(end);\r\n    }\r\n}\n/**\r\n * If both objects on the top of the stack are non-null, does nothing.\r\n * If one is null, or both are null, both are popped off and execution\r\n * branches to the respective label.\r\n * @param oneNull label to branch to if only one of the objects is null\r\n * @param bothNull label to branch to if both of the objects are null\r\n */\r\nprivate static void nullcmp(CodeEmitter e, Label oneNull, Label bothNull) {\r\n    e.dup2();\r\n    Label nonNull = e.make_label();\r\n    Label oneNullHelper = e.make_label();\r\n    Label end = e.make_label();\r\n    e.ifnonnull(nonNull);\r\n    e.ifnonnull(oneNullHelper);\r\n    e.pop2();\r\n    e.goTo(bothNull);\r\n    e.mark(nonNull);\r\n    e.ifnull(oneNullHelper);\r\n    e.goTo(end);\r\n    e.mark(oneNullHelper);\r\n    e.pop2();\r\n    e.goTo(oneNull);\r\n    e.mark(end);\r\n}\n/*\r\n    public static void to_string(CodeEmitter e,\r\n                                 Type type,\r\n                                 ArrayDelimiters delims,\r\n                                 CustomizerRegistry registry) {\r\n        e.new_instance(Constants.TYPE_STRING_BUFFER);\r\n        e.dup();\r\n        e.invoke_constructor(Constants.TYPE_STRING_BUFFER);\r\n        e.swap();\r\n        append_string(e, type, delims, registry);\r\n        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, TO_STRING);\r\n    }\r\n    */\r\n/**\r\n * @deprecated use {@link #append_string(CodeEmitter, Type, ArrayDelimiters, CustomizerRegistry)} instead\r\n */\r\n@Deprecated\r\npublic static void append_string(final CodeEmitter e, Type type, final ArrayDelimiters delims, final Customizer customizer) {\r\n    append_string(e, type, delims, CustomizerRegistry.singleton(customizer));\r\n}\npublic static void append_string(final CodeEmitter e, Type type, final ArrayDelimiters delims, final CustomizerRegistry registry) {\r\n    final ArrayDelimiters d = (delims != null) ? delims : DEFAULT_DELIMITERS;\r\n    ProcessArrayCallback callback = new ProcessArrayCallback() {\r\n\r\n        @Override\r\n        public void processElement(Type type) {\r\n            append_string_helper(e, type, d, registry, this);\r\n            e.push(d.inside);\r\n            e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\r\n        }\r\n    };\r\n    append_string_helper(e, type, d, registry, callback);\r\n}\nprivate static void append_string_helper(CodeEmitter e, Type type, ArrayDelimiters delims, CustomizerRegistry registry, ProcessArrayCallback callback) {\r\n    Label skip = e.make_label();\r\n    Label end = e.make_label();\r\n    if (TypeUtils.isPrimitive(type)) {\r\n        switch(type.getSort()) {\r\n            case Type.INT:\r\n            case Type.SHORT:\r\n            case Type.BYTE:\r\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_INT);\r\n                break;\r\n            case Type.DOUBLE:\r\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_DOUBLE);\r\n                break;\r\n            case Type.FLOAT:\r\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_FLOAT);\r\n                break;\r\n            case Type.LONG:\r\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_LONG);\r\n                break;\r\n            case Type.BOOLEAN:\r\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_BOOLEAN);\r\n                break;\r\n            case Type.CHAR:\r\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_CHAR);\r\n                break;\r\n        }\r\n    } else if (TypeUtils.isArray(type)) {\r\n        e.dup();\r\n        e.ifnull(skip);\r\n        e.swap();\r\n        if (delims != null && delims.before != null && !delims.before.isEmpty()) {\r\n            e.push(delims.before);\r\n            e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\r\n            e.swap();\r\n        }\r\n        EmitUtils.process_array(e, type, callback);\r\n        shrinkStringBuffer(e, 2);\r\n        if (delims != null && delims.after != null && !delims.after.isEmpty()) {\r\n            e.push(delims.after);\r\n            e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\r\n        }\r\n    } else {\r\n        e.dup();\r\n        e.ifnull(skip);\r\n        for (Customizer customizer : registry.get(Customizer.class)) {\r\n            customizer.customize(e, type);\r\n        }\r\n        e.invoke_virtual(Constants.TYPE_OBJECT, TO_STRING);\r\n        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\r\n    }\r\n    e.goTo(end);\r\n    e.mark(skip);\r\n    e.pop();\r\n    e.push(\"null\");\r\n    e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\r\n    e.mark(end);\r\n}\nprivate static void shrinkStringBuffer(CodeEmitter e, int amt) {\r\n    e.dup();\r\n    e.dup();\r\n    e.invoke_virtual(Constants.TYPE_STRING_BUFFER, LENGTH);\r\n    e.push(amt);\r\n    e.math(CodeEmitter.SUB, Type.INT_TYPE);\r\n    e.invoke_virtual(Constants.TYPE_STRING_BUFFER, SET_LENGTH);\r\n}\npublic static class ArrayDelimiters {\r\n\r\n    private String before;\r\n\r\n    private String inside;\r\n\r\n    private String after;\r\n\r\n    public ArrayDelimiters(String before, String inside, String after) {\r\n        this.before = before;\r\n        this.inside = inside;\r\n        this.after = after;\r\n    }\r\n}\npublic static void load_method(CodeEmitter e, MethodInfo method) {\r\n    load_class(e, method.getClassInfo().getType());\r\n    e.push(method.getSignature().getName());\r\n    push_object(e, method.getSignature().getArgumentTypes());\r\n    e.invoke_virtual(Constants.TYPE_CLASS, GET_DECLARED_METHOD);\r\n}\nprivate interface ParameterTyper {\r\n\r\n    Type[] getParameterTypes(MethodInfo member);\r\n}\npublic static void method_switch(CodeEmitter e, List methods, ObjectSwitchCallback callback) {\r\n    member_switch_helper(e, methods, callback, true);\r\n}\npublic static void constructor_switch(CodeEmitter e, List constructors, ObjectSwitchCallback callback) {\r\n    member_switch_helper(e, constructors, callback, false);\r\n}\nprivate static void member_switch_helper(final CodeEmitter e, List members, final ObjectSwitchCallback callback, boolean useName) {\r\n    try {\r\n        final Map cache = new HashMap();\r\n        final ParameterTyper cached = member -> {\r\n            Type[] types = (Type[]) cache.get(member);\r\n            if (types == null) {\r\n                cache.put(member, types = member.getSignature().getArgumentTypes());\r\n            }\r\n            return types;\r\n        };\r\n        final Label def = e.make_label();\r\n        final Label end = e.make_label();\r\n        if (useName) {\r\n            e.swap();\r\n            final Map buckets = CollectionUtils.bucket(members, value -> ((MethodInfo) value).getSignature().getName());\r\n            String[] names = (String[]) buckets.keySet().toArray(new String[buckets.size()]);\r\n            EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\r\n\r\n                @Override\r\n                public void processCase(Object key, Label dontUseEnd) throws Exception {\r\n                    member_helper_size(e, (List) buckets.get(key), callback, cached, def, end);\r\n                }\r\n\r\n                @Override\r\n                public void processDefault() throws Exception {\r\n                    e.goTo(def);\r\n                }\r\n            });\r\n        } else {\r\n            member_helper_size(e, members, callback, cached, def, end);\r\n        }\r\n        e.mark(def);\r\n        e.pop();\r\n        callback.processDefault();\r\n        e.mark(end);\r\n    } catch (RuntimeException | Error ex) {\r\n        throw ex;\r\n    } catch (Exception ex) {\r\n        throw new CodeGenerationException(ex);\r\n    }\r\n}\nprivate static void member_helper_size(final CodeEmitter e, List members, final ObjectSwitchCallback callback, final ParameterTyper typer, final Label def, final Label end) throws Exception {\r\n    final Map buckets = CollectionUtils.bucket(members, value -> typer.getParameterTypes((MethodInfo) value).length);\r\n    e.dup();\r\n    e.arraylength();\r\n    e.process_switch(EmitUtils.getSwitchKeys(buckets), new ProcessSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(int key, Label dontUseEnd) throws Exception {\r\n            List bucket = (List) buckets.get(key);\r\n            member_helper_type(e, bucket, callback, typer, def, end, new BitSet());\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() throws Exception {\r\n            e.goTo(def);\r\n        }\r\n    });\r\n}\nprivate static void member_helper_type(final CodeEmitter e, List members, final ObjectSwitchCallback callback, final ParameterTyper typer, final Label def, final Label end, final BitSet checked) throws Exception {\r\n    if (members.size() == 1) {\r\n        MethodInfo member = (MethodInfo) members.get(0);\r\n        Type[] types = typer.getParameterTypes(member);\r\n        // need to check classes that have not already been checked via switches\r\n        for (int i = 0; i < types.length; i++) {\r\n            if (checked == null || !checked.get(i)) {\r\n                e.dup();\r\n                e.aaload(i);\r\n                e.invoke_virtual(Constants.TYPE_CLASS, GET_NAME);\r\n                e.push(TypeUtils.emulateClassGetName(types[i]));\r\n                e.invoke_virtual(Constants.TYPE_OBJECT, EQUALS);\r\n                e.if_jump(CodeEmitter.EQ, def);\r\n            }\r\n        }\r\n        e.pop();\r\n        callback.processCase(member, end);\r\n    } else {\r\n        // choose the index that has the best chance of uniquely identifying member\r\n        Type[] example = typer.getParameterTypes((MethodInfo) members.get(0));\r\n        Map buckets = null;\r\n        int index = -1;\r\n        for (int i = 0; i < example.length; i++) {\r\n            final int j = i;\r\n            Map test = CollectionUtils.bucket(members, value -> TypeUtils.emulateClassGetName(typer.getParameterTypes((MethodInfo) value)[j]));\r\n            if (buckets == null || test.size() > buckets.size()) {\r\n                buckets = test;\r\n                index = i;\r\n            }\r\n        }\r\n        if (buckets == null || buckets.size() == 1) {\r\n            // TODO: switch by returnType\r\n            // must have two methods with same name, types, and different return types\r\n            e.goTo(def);\r\n        } else {\r\n            checked.set(index);\r\n            e.dup();\r\n            e.aaload(index);\r\n            e.invoke_virtual(Constants.TYPE_CLASS, GET_NAME);\r\n            final Map fbuckets = buckets;\r\n            String[] names = (String[]) buckets.keySet().toArray(new String[buckets.size()]);\r\n            EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\r\n\r\n                @Override\r\n                public void processCase(Object key, Label dontUseEnd) throws Exception {\r\n                    member_helper_type(e, (List) fbuckets.get(key), callback, typer, def, end, checked);\r\n                }\r\n\r\n                @Override\r\n                public void processDefault() throws Exception {\r\n                    e.goTo(def);\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\npublic static void wrap_throwable(Block block, Type wrapper) {\r\n    CodeEmitter e = block.getCodeEmitter();\r\n    e.catch_exception(block, Constants.TYPE_THROWABLE);\r\n    e.new_instance(wrapper);\r\n    e.dup_x1();\r\n    e.swap();\r\n    e.invoke_constructor(wrapper, CSTRUCT_THROWABLE);\r\n    e.athrow();\r\n}\npublic static void add_properties(ClassEmitter ce, String[] names, Type[] types) {\r\n    for (int i = 0; i < names.length; i++) {\r\n        String fieldName = \"$cglib_prop_\" + names[i];\r\n        ce.declare_field(Constants.ACC_PRIVATE, fieldName, types[i], null);\r\n        EmitUtils.add_property(ce, names[i], types[i], fieldName);\r\n    }\r\n}\npublic static void add_property(ClassEmitter ce, String name, Type type, String fieldName) {\r\n    String property = TypeUtils.upperFirst(name);\r\n    CodeEmitter e;\r\n    e = ce.begin_method(Constants.ACC_PUBLIC, new Signature(\"get\" + property, type, Constants.TYPES_EMPTY), null);\r\n    e.load_this();\r\n    e.getfield(fieldName);\r\n    e.return_value();\r\n    e.end_method();\r\n    e = ce.begin_method(Constants.ACC_PUBLIC, new Signature(\"set\" + property, Type.VOID_TYPE, new Type[] { type }), null);\r\n    e.load_this();\r\n    e.load_arg(0);\r\n    e.putfield(fieldName);\r\n    e.return_value();\r\n    e.end_method();\r\n}\n/* generates:\r\n       } catch (RuntimeException e) {\r\n         throw e;\r\n       } catch (Error e) {\r\n         throw e;\r\n       } catch (<DeclaredException> e) {\r\n         throw e;\r\n       } catch (Throwable e) {\r\n         throw new <Wrapper>(e);\r\n       }\r\n    */\r\npublic static void wrap_undeclared_throwable(CodeEmitter e, Block handler, Type[] exceptions, Type wrapper) {\r\n    Set set = (exceptions == null) ? Collections.EMPTY_SET : new HashSet(Arrays.asList(exceptions));\r\n    if (set.contains(Constants.TYPE_THROWABLE)) {\r\n        return;\r\n    }\r\n    boolean needThrow = exceptions != null;\r\n    if (!set.contains(Constants.TYPE_RUNTIME_EXCEPTION)) {\r\n        e.catch_exception(handler, Constants.TYPE_RUNTIME_EXCEPTION);\r\n        needThrow = true;\r\n    }\r\n    if (!set.contains(Constants.TYPE_ERROR)) {\r\n        e.catch_exception(handler, Constants.TYPE_ERROR);\r\n        needThrow = true;\r\n    }\r\n    if (exceptions != null) {\r\n        for (Type exception : exceptions) {\r\n            e.catch_exception(handler, exception);\r\n        }\r\n    }\r\n    if (needThrow) {\r\n        e.athrow();\r\n    }\r\n    // e -> eo -> oeo -> ooe -> o\r\n    e.catch_exception(handler, Constants.TYPE_THROWABLE);\r\n    e.new_instance(wrapper);\r\n    e.dup_x1();\r\n    e.swap();\r\n    e.invoke_constructor(wrapper, CSTRUCT_THROWABLE);\r\n    e.athrow();\r\n}\npublic static CodeEmitter begin_method(ClassEmitter e, MethodInfo method) {\r\n    return begin_method(e, method, method.getModifiers());\r\n}\npublic static CodeEmitter begin_method(ClassEmitter e, MethodInfo method, int access) {\r\n    return e.begin_method(access, method.getSignature(), method.getExceptionTypes());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#factory_method(ClassEmitter,Signature)",
    "entityType": "method",
    "code": "public static void factory_method(ClassEmitter ce, Signature sig) {\r\n    CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, sig, null);\r\n    e.new_instance_this();\r\n    e.dup();\r\n    e.load_args();\r\n    e.invoke_constructor_this(TypeUtils.parseConstructor(sig.getArgumentTypes()));\r\n    e.return_value();\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#null_constructor(ClassEmitter)",
    "entityType": "method",
    "code": "public static void null_constructor(ClassEmitter ce) {\r\n    CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, CSTRUCT_NULL, null);\r\n    e.load_this();\r\n    e.super_invoke_constructor();\r\n    e.return_value();\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#process_array(CodeEmitter,Type,ProcessArrayCallback)",
    "entityType": "method",
    "code": "/**\r\n * Process an array on the stack. Assumes the top item on the stack\r\n * is an array of the specified type. For each element in the array,\r\n * puts the element on the stack and triggers the callback.\r\n * @param type the type of the array (type.isArray() must be true)\r\n * @param callback the callback triggered for each element\r\n */\r\npublic static void process_array(CodeEmitter e, Type type, ProcessArrayCallback callback) {\r\n    Type componentType = TypeUtils.getComponentType(type);\r\n    Local array = e.make_local();\r\n    Local loopvar = e.make_local(Type.INT_TYPE);\r\n    Label loopbody = e.make_label();\r\n    Label checkloop = e.make_label();\r\n    e.store_local(array);\r\n    e.push(0);\r\n    e.store_local(loopvar);\r\n    e.goTo(checkloop);\r\n    e.mark(loopbody);\r\n    e.load_local(array);\r\n    e.load_local(loopvar);\r\n    e.array_load(componentType);\r\n    callback.processElement(componentType);\r\n    e.iinc(loopvar, 1);\r\n    e.mark(checkloop);\r\n    e.load_local(loopvar);\r\n    e.load_local(array);\r\n    e.arraylength();\r\n    e.if_icmp(CodeEmitter.LT, loopbody);\r\n}",
    "comment": "\n     * Process an array on the stack. Assumes the top item on the stack\n     * is an array of the specified type. For each element in the array,\n     * puts the element on the stack and triggers the callback.\n     * @param type the type of the array (type.isArray() must be true)\n     * @param callback the callback triggered for each element\n     "
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#process_arrays(CodeEmitter,Type,ProcessArrayCallback)",
    "entityType": "method",
    "code": "/**\r\n * Process two arrays on the stack in parallel. Assumes the top two items on the stack\r\n * are arrays of the specified class. The arrays must be the same length. For each pair\r\n * of elements in the arrays, puts the pair on the stack and triggers the callback.\r\n * @param type the type of the arrays (type.isArray() must be true)\r\n * @param callback the callback triggered for each pair of elements\r\n */\r\npublic static void process_arrays(CodeEmitter e, Type type, ProcessArrayCallback callback) {\r\n    Type componentType = TypeUtils.getComponentType(type);\r\n    Local array1 = e.make_local();\r\n    Local array2 = e.make_local();\r\n    Local loopvar = e.make_local(Type.INT_TYPE);\r\n    Label loopbody = e.make_label();\r\n    Label checkloop = e.make_label();\r\n    e.store_local(array1);\r\n    e.store_local(array2);\r\n    e.push(0);\r\n    e.store_local(loopvar);\r\n    e.goTo(checkloop);\r\n    e.mark(loopbody);\r\n    e.load_local(array1);\r\n    e.load_local(loopvar);\r\n    e.array_load(componentType);\r\n    e.load_local(array2);\r\n    e.load_local(loopvar);\r\n    e.array_load(componentType);\r\n    callback.processElement(componentType);\r\n    e.iinc(loopvar, 1);\r\n    e.mark(checkloop);\r\n    e.load_local(loopvar);\r\n    e.load_local(array1);\r\n    e.arraylength();\r\n    e.if_icmp(CodeEmitter.LT, loopbody);\r\n}",
    "comment": "\n     * Process two arrays on the stack in parallel. Assumes the top two items on the stack\n     * are arrays of the specified class. The arrays must be the same length. For each pair\n     * of elements in the arrays, puts the pair on the stack and triggers the callback.\n     * @param type the type of the arrays (type.isArray() must be true)\n     * @param callback the callback triggered for each pair of elements\n     "
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#string_switch(CodeEmitter,String[],int,ObjectSwitchCallback)",
    "entityType": "method",
    "code": "public static void string_switch(CodeEmitter e, String[] strings, int switchStyle, ObjectSwitchCallback callback) {\r\n    try {\r\n        switch(switchStyle) {\r\n            case Constants.SWITCH_STYLE_TRIE:\r\n                string_switch_trie(e, strings, callback);\r\n                break;\r\n            case Constants.SWITCH_STYLE_HASH:\r\n                string_switch_hash(e, strings, callback, false);\r\n                break;\r\n            case Constants.SWITCH_STYLE_HASHONLY:\r\n                string_switch_hash(e, strings, callback, true);\r\n                break;\r\n            default:\r\n                throw new IllegalArgumentException(\"unknown switch style \" + switchStyle);\r\n        }\r\n    } catch (RuntimeException | Error ex) {\r\n        throw ex;\r\n    } catch (Exception ex) {\r\n        throw new CodeGenerationException(ex);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#string_switch_trie(CodeEmitter,String[],ObjectSwitchCallback)",
    "entityType": "method",
    "code": "private static void string_switch_trie(final CodeEmitter e, String[] strings, final ObjectSwitchCallback callback) throws Exception {\r\n    final Label def = e.make_label();\r\n    final Label end = e.make_label();\r\n    final Map buckets = CollectionUtils.bucket(Arrays.asList(strings), value -> ((String) value).length());\r\n    e.dup();\r\n    e.invoke_virtual(Constants.TYPE_STRING, STRING_LENGTH);\r\n    e.process_switch(getSwitchKeys(buckets), new ProcessSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(int key, Label ignore_end) throws Exception {\r\n            List bucket = (List) buckets.get(key);\r\n            stringSwitchHelper(e, bucket, callback, def, end, 0);\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            e.goTo(def);\r\n        }\r\n    });\r\n    e.mark(def);\r\n    e.pop();\r\n    callback.processDefault();\r\n    e.mark(end);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#stringSwitchHelper(CodeEmitter,List,ObjectSwitchCallback,Label,Label,int)",
    "entityType": "method",
    "code": "private static void stringSwitchHelper(final CodeEmitter e, List strings, final ObjectSwitchCallback callback, final Label def, final Label end, final int index) throws Exception {\r\n    final int len = ((String) strings.get(0)).length();\r\n    final Map buckets = CollectionUtils.bucket(strings, value -> ((String) value).charAt(index));\r\n    e.dup();\r\n    e.push(index);\r\n    e.invoke_virtual(Constants.TYPE_STRING, STRING_CHAR_AT);\r\n    e.process_switch(getSwitchKeys(buckets), new ProcessSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(int key, Label ignore_end) throws Exception {\r\n            List bucket = (List) buckets.get(key);\r\n            if (index + 1 == len) {\r\n                e.pop();\r\n                callback.processCase(bucket.get(0), end);\r\n            } else {\r\n                stringSwitchHelper(e, bucket, callback, def, end, index + 1);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            e.goTo(def);\r\n        }\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#getSwitchKeys(Map)",
    "entityType": "method",
    "code": "static int[] getSwitchKeys(Map buckets) {\r\n    int[] keys = new int[buckets.size()];\r\n    int index = 0;\r\n    for (Iterator it = buckets.keySet().iterator(); it.hasNext(); ) {\r\n        keys[index++] = ((Integer) it.next());\r\n    }\r\n    Arrays.sort(keys);\r\n    return keys;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#string_switch_hash(CodeEmitter,String[],ObjectSwitchCallback,boolean)",
    "entityType": "method",
    "code": "private static void string_switch_hash(final CodeEmitter e, final String[] strings, final ObjectSwitchCallback callback, final boolean skipEquals) throws Exception {\r\n    final Map buckets = CollectionUtils.bucket(Arrays.asList(strings), value -> value.hashCode());\r\n    final Label def = e.make_label();\r\n    final Label end = e.make_label();\r\n    e.dup();\r\n    e.invoke_virtual(Constants.TYPE_OBJECT, HASH_CODE);\r\n    e.process_switch(getSwitchKeys(buckets), new ProcessSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(int key, Label ignore_end) throws Exception {\r\n            List bucket = (List) buckets.get(key);\r\n            Label next = null;\r\n            if (skipEquals && bucket.size() == 1) {\r\n                if (skipEquals) {\r\n                    e.pop();\r\n                }\r\n                callback.processCase(bucket.get(0), end);\r\n            } else {\r\n                for (Iterator it = bucket.iterator(); it.hasNext(); ) {\r\n                    String string = (String) it.next();\r\n                    if (next != null) {\r\n                        e.mark(next);\r\n                    }\r\n                    if (it.hasNext()) {\r\n                        e.dup();\r\n                    }\r\n                    e.push(string);\r\n                    e.invoke_virtual(Constants.TYPE_OBJECT, EQUALS);\r\n                    if (it.hasNext()) {\r\n                        e.if_jump(CodeEmitter.EQ, next = e.make_label());\r\n                        e.pop();\r\n                    } else {\r\n                        e.if_jump(CodeEmitter.EQ, def);\r\n                    }\r\n                    callback.processCase(string, end);\r\n                }\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            e.pop();\r\n        }\r\n    });\r\n    e.mark(def);\r\n    callback.processDefault();\r\n    e.mark(end);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#load_class_this(CodeEmitter)",
    "entityType": "method",
    "code": "public static void load_class_this(CodeEmitter e) {\r\n    load_class_helper(e, e.getClassEmitter().getClassType());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#load_class(CodeEmitter,Type)",
    "entityType": "method",
    "code": "public static void load_class(CodeEmitter e, Type type) {\r\n    if (TypeUtils.isPrimitive(type)) {\r\n        if (type == Type.VOID_TYPE) {\r\n            throw new IllegalArgumentException(\"cannot load void type\");\r\n        }\r\n        e.getstatic(TypeUtils.getBoxedType(type), \"TYPE\", Constants.TYPE_CLASS);\r\n    } else {\r\n        load_class_helper(e, type);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#load_class_helper(CodeEmitter,Type)",
    "entityType": "method",
    "code": "private static void load_class_helper(CodeEmitter e, final Type type) {\r\n    if (e.isStaticHook()) {\r\n        // have to fall back on non-optimized load\r\n        e.push(TypeUtils.emulateClassGetName(type));\r\n        e.invoke_static(Constants.TYPE_CLASS, FOR_NAME);\r\n    } else {\r\n        ClassEmitter ce = e.getClassEmitter();\r\n        String typeName = TypeUtils.emulateClassGetName(type);\r\n        // TODO: can end up with duplicated field names when using chained transformers; incorporate static hook # somehow\r\n        String fieldName = \"CGLIB$load_class$\" + TypeUtils.escapeType(typeName);\r\n        if (!ce.isFieldDeclared(fieldName)) {\r\n            ce.declare_field(Constants.PRIVATE_FINAL_STATIC, fieldName, Constants.TYPE_CLASS, null);\r\n            CodeEmitter hook = ce.getStaticHook();\r\n            hook.push(typeName);\r\n            hook.invoke_static(Constants.TYPE_CLASS, FOR_NAME);\r\n            hook.putstatic(ce.getClassType(), fieldName, Constants.TYPE_CLASS);\r\n        }\r\n        e.getfield(fieldName);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#push_array(CodeEmitter,Object[])",
    "entityType": "method",
    "code": "public static void push_array(CodeEmitter e, Object[] array) {\r\n    e.push(array.length);\r\n    e.newarray(Type.getType(remapComponentType(array.getClass().componentType())));\r\n    for (int i = 0; i < array.length; i++) {\r\n        e.dup();\r\n        e.push(i);\r\n        push_object(e, array[i]);\r\n        e.aastore();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#remapComponentType(Class)",
    "entityType": "method",
    "code": "private static Class remapComponentType(Class componentType) {\r\n    if (componentType.equals(Type.class)) {\r\n        return Class.class;\r\n    }\r\n    return componentType;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#push_object(CodeEmitter,Object)",
    "entityType": "method",
    "code": "public static void push_object(CodeEmitter e, Object obj) {\r\n    if (obj == null) {\r\n        e.aconst_null();\r\n    } else {\r\n        if (obj.getClass().isArray()) {\r\n            push_array(e, (Object[]) obj);\r\n        } else if (obj instanceof String text) {\r\n            e.push(text);\r\n        } else if (obj instanceof Type type) {\r\n            load_class(e, type);\r\n        } else if (obj instanceof Class<?> clazz) {\r\n            load_class(e, Type.getType(clazz));\r\n        } else if (obj instanceof BigInteger) {\r\n            e.new_instance(Constants.TYPE_BIG_INTEGER);\r\n            e.dup();\r\n            e.push(obj.toString());\r\n            e.invoke_constructor(Constants.TYPE_BIG_INTEGER);\r\n        } else if (obj instanceof BigDecimal) {\r\n            e.new_instance(Constants.TYPE_BIG_DECIMAL);\r\n            e.dup();\r\n            e.push(obj.toString());\r\n            e.invoke_constructor(Constants.TYPE_BIG_DECIMAL);\r\n        } else {\r\n            throw new IllegalArgumentException(\"unknown type: \" + obj.getClass());\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#hash_code(CodeEmitter,Type,int,Customizer)",
    "entityType": "method",
    "code": "/**\r\n * @deprecated use {@link #hash_code(CodeEmitter, Type, int, CustomizerRegistry)} instead\r\n */\r\n@Deprecated\r\npublic static void hash_code(CodeEmitter e, Type type, int multiplier, final Customizer customizer) {\r\n    hash_code(e, type, multiplier, CustomizerRegistry.singleton(customizer));\r\n}",
    "comment": "\n     * @deprecated use {@link #hash_code(CodeEmitter, Type, int, CustomizerRegistry)} instead\n     "
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#hash_code(CodeEmitter,Type,int,CustomizerRegistry)",
    "entityType": "method",
    "code": "public static void hash_code(CodeEmitter e, Type type, int multiplier, final CustomizerRegistry registry) {\r\n    if (TypeUtils.isArray(type)) {\r\n        hash_array(e, type, multiplier, registry);\r\n    } else {\r\n        e.swap(Type.INT_TYPE, type);\r\n        e.push(multiplier);\r\n        e.math(CodeEmitter.MUL, Type.INT_TYPE);\r\n        e.swap(type, Type.INT_TYPE);\r\n        if (TypeUtils.isPrimitive(type)) {\r\n            hash_primitive(e, type);\r\n        } else {\r\n            hash_object(e, type, registry);\r\n        }\r\n        e.math(CodeEmitter.ADD, Type.INT_TYPE);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#hash_array(CodeEmitter,Type,int,CustomizerRegistry)",
    "entityType": "method",
    "code": "private static void hash_array(final CodeEmitter e, Type type, final int multiplier, final CustomizerRegistry registry) {\r\n    Label skip = e.make_label();\r\n    Label end = e.make_label();\r\n    e.dup();\r\n    e.ifnull(skip);\r\n    EmitUtils.process_array(e, type, type1 -> hash_code(e, type1, multiplier, registry));\r\n    e.goTo(end);\r\n    e.mark(skip);\r\n    e.pop();\r\n    e.mark(end);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#hash_object(CodeEmitter,Type,CustomizerRegistry)",
    "entityType": "method",
    "code": "private static void hash_object(CodeEmitter e, Type type, CustomizerRegistry registry) {\r\n    // (f == null) ? 0 : f.hashCode();\r\n    Label skip = e.make_label();\r\n    Label end = e.make_label();\r\n    e.dup();\r\n    e.ifnull(skip);\r\n    boolean customHashCode = false;\r\n    for (HashCodeCustomizer customizer : registry.get(HashCodeCustomizer.class)) {\r\n        if (customizer.customize(e, type)) {\r\n            customHashCode = true;\r\n            break;\r\n        }\r\n    }\r\n    if (!customHashCode) {\r\n        for (Customizer customizer : registry.get(Customizer.class)) {\r\n            customizer.customize(e, type);\r\n        }\r\n        e.invoke_virtual(Constants.TYPE_OBJECT, HASH_CODE);\r\n    }\r\n    e.goTo(end);\r\n    e.mark(skip);\r\n    e.pop();\r\n    e.push(0);\r\n    e.mark(end);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#hash_primitive(CodeEmitter,Type)",
    "entityType": "method",
    "code": "private static void hash_primitive(CodeEmitter e, Type type) {\r\n    switch(type.getSort()) {\r\n        case Type.BOOLEAN:\r\n            // f ? 0 : 1\r\n            e.push(1);\r\n            e.math(CodeEmitter.XOR, Type.INT_TYPE);\r\n            break;\r\n        case Type.FLOAT:\r\n            // Float.floatToIntBits(f)\r\n            e.invoke_static(Constants.TYPE_FLOAT, FLOAT_TO_INT_BITS);\r\n            break;\r\n        case Type.DOUBLE:\r\n            // Double.doubleToLongBits(f), hash_code(Long.TYPE)\r\n            e.invoke_static(Constants.TYPE_DOUBLE, DOUBLE_TO_LONG_BITS);\r\n        // fall through\r\n        case Type.LONG:\r\n            hash_long(e);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#hash_long(CodeEmitter)",
    "entityType": "method",
    "code": "private static void hash_long(CodeEmitter e) {\r\n    // (int)(f ^ (f >>> 32))\r\n    e.dup2();\r\n    e.push(32);\r\n    e.math(CodeEmitter.USHR, Type.LONG_TYPE);\r\n    e.math(CodeEmitter.XOR, Type.LONG_TYPE);\r\n    e.cast_numeric(Type.LONG_TYPE, Type.INT_TYPE);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#not_equals(CodeEmitter,Type,Label,Customizer)",
    "entityType": "method",
    "code": "//     public static void not_equals(CodeEmitter e, Type type, Label notEquals) {\r\n//         not_equals(e, type, notEquals, null);\r\n//     }\r\n/**\r\n * @deprecated use {@link #not_equals(CodeEmitter, Type, Label, CustomizerRegistry)} instead\r\n */\r\n@Deprecated\r\npublic static void not_equals(CodeEmitter e, Type type, final Label notEquals, final Customizer customizer) {\r\n    not_equals(e, type, notEquals, CustomizerRegistry.singleton(customizer));\r\n}",
    "comment": "\n     * @deprecated use {@link #not_equals(CodeEmitter, Type, Label, CustomizerRegistry)} instead\n     "
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#not_equals(CodeEmitter,Type,Label,CustomizerRegistry)",
    "entityType": "method",
    "code": "/**\r\n * Branches to the specified label if the top two items on the stack\r\n * are not equal. The items must both be of the specified\r\n * class. Equality is determined by comparing primitive values\r\n * directly and by invoking the <code>equals</code> method for\r\n * Objects. Arrays are recursively processed in the same manner.\r\n */\r\npublic static void not_equals(final CodeEmitter e, Type type, final Label notEquals, final CustomizerRegistry registry) {\r\n    (new ProcessArrayCallback() {\r\n\r\n        @Override\r\n        public void processElement(Type type) {\r\n            not_equals_helper(e, type, notEquals, registry, this);\r\n        }\r\n    }).processElement(type);\r\n}",
    "comment": "\n     * Branches to the specified label if the top two items on the stack\n     * are not equal. The items must both be of the specified\n     * class. Equality is determined by comparing primitive values\n     * directly and by invoking the <code>equals</code> method for\n     * Objects. Arrays are recursively processed in the same manner.\n     "
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#not_equals_helper(CodeEmitter,Type,Label,CustomizerRegistry,ProcessArrayCallback)",
    "entityType": "method",
    "code": "private static void not_equals_helper(CodeEmitter e, Type type, Label notEquals, CustomizerRegistry registry, ProcessArrayCallback callback) {\r\n    if (TypeUtils.isPrimitive(type)) {\r\n        e.if_cmp(type, CodeEmitter.NE, notEquals);\r\n    } else {\r\n        Label end = e.make_label();\r\n        nullcmp(e, notEquals, end);\r\n        if (TypeUtils.isArray(type)) {\r\n            Label checkContents = e.make_label();\r\n            e.dup2();\r\n            e.arraylength();\r\n            e.swap();\r\n            e.arraylength();\r\n            e.if_icmp(CodeEmitter.EQ, checkContents);\r\n            e.pop2();\r\n            e.goTo(notEquals);\r\n            e.mark(checkContents);\r\n            EmitUtils.process_arrays(e, type, callback);\r\n        } else {\r\n            List<Customizer> customizers = registry.get(Customizer.class);\r\n            if (!customizers.isEmpty()) {\r\n                for (Customizer customizer : customizers) {\r\n                    customizer.customize(e, type);\r\n                }\r\n                e.swap();\r\n                for (Customizer customizer : customizers) {\r\n                    customizer.customize(e, type);\r\n                }\r\n            }\r\n            e.invoke_virtual(Constants.TYPE_OBJECT, EQUALS);\r\n            e.if_jump(CodeEmitter.EQ, notEquals);\r\n        }\r\n        e.mark(end);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#nullcmp(CodeEmitter,Label,Label)",
    "entityType": "method",
    "code": "/**\r\n * If both objects on the top of the stack are non-null, does nothing.\r\n * If one is null, or both are null, both are popped off and execution\r\n * branches to the respective label.\r\n * @param oneNull label to branch to if only one of the objects is null\r\n * @param bothNull label to branch to if both of the objects are null\r\n */\r\nprivate static void nullcmp(CodeEmitter e, Label oneNull, Label bothNull) {\r\n    e.dup2();\r\n    Label nonNull = e.make_label();\r\n    Label oneNullHelper = e.make_label();\r\n    Label end = e.make_label();\r\n    e.ifnonnull(nonNull);\r\n    e.ifnonnull(oneNullHelper);\r\n    e.pop2();\r\n    e.goTo(bothNull);\r\n    e.mark(nonNull);\r\n    e.ifnull(oneNullHelper);\r\n    e.goTo(end);\r\n    e.mark(oneNullHelper);\r\n    e.pop2();\r\n    e.goTo(oneNull);\r\n    e.mark(end);\r\n}",
    "comment": "\n     * If both objects on the top of the stack are non-null, does nothing.\n     * If one is null, or both are null, both are popped off and execution\n     * branches to the respective label.\n     * @param oneNull label to branch to if only one of the objects is null\n     * @param bothNull label to branch to if both of the objects are null\n     "
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#append_string(CodeEmitter,Type,ArrayDelimiters,Customizer)",
    "entityType": "method",
    "code": "/*\r\n    public static void to_string(CodeEmitter e,\r\n                                 Type type,\r\n                                 ArrayDelimiters delims,\r\n                                 CustomizerRegistry registry) {\r\n        e.new_instance(Constants.TYPE_STRING_BUFFER);\r\n        e.dup();\r\n        e.invoke_constructor(Constants.TYPE_STRING_BUFFER);\r\n        e.swap();\r\n        append_string(e, type, delims, registry);\r\n        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, TO_STRING);\r\n    }\r\n    */\r\n/**\r\n * @deprecated use {@link #append_string(CodeEmitter, Type, ArrayDelimiters, CustomizerRegistry)} instead\r\n */\r\n@Deprecated\r\npublic static void append_string(final CodeEmitter e, Type type, final ArrayDelimiters delims, final Customizer customizer) {\r\n    append_string(e, type, delims, CustomizerRegistry.singleton(customizer));\r\n}",
    "comment": "\n      * @deprecated use {@link #append_string(CodeEmitter, Type, ArrayDelimiters, CustomizerRegistry)} instead\n      "
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#append_string(CodeEmitter,Type,ArrayDelimiters,CustomizerRegistry)",
    "entityType": "method",
    "code": "public static void append_string(final CodeEmitter e, Type type, final ArrayDelimiters delims, final CustomizerRegistry registry) {\r\n    final ArrayDelimiters d = (delims != null) ? delims : DEFAULT_DELIMITERS;\r\n    ProcessArrayCallback callback = new ProcessArrayCallback() {\r\n\r\n        @Override\r\n        public void processElement(Type type) {\r\n            append_string_helper(e, type, d, registry, this);\r\n            e.push(d.inside);\r\n            e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\r\n        }\r\n    };\r\n    append_string_helper(e, type, d, registry, callback);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#append_string_helper(CodeEmitter,Type,ArrayDelimiters,CustomizerRegistry,ProcessArrayCallback)",
    "entityType": "method",
    "code": "private static void append_string_helper(CodeEmitter e, Type type, ArrayDelimiters delims, CustomizerRegistry registry, ProcessArrayCallback callback) {\r\n    Label skip = e.make_label();\r\n    Label end = e.make_label();\r\n    if (TypeUtils.isPrimitive(type)) {\r\n        switch(type.getSort()) {\r\n            case Type.INT:\r\n            case Type.SHORT:\r\n            case Type.BYTE:\r\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_INT);\r\n                break;\r\n            case Type.DOUBLE:\r\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_DOUBLE);\r\n                break;\r\n            case Type.FLOAT:\r\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_FLOAT);\r\n                break;\r\n            case Type.LONG:\r\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_LONG);\r\n                break;\r\n            case Type.BOOLEAN:\r\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_BOOLEAN);\r\n                break;\r\n            case Type.CHAR:\r\n                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_CHAR);\r\n                break;\r\n        }\r\n    } else if (TypeUtils.isArray(type)) {\r\n        e.dup();\r\n        e.ifnull(skip);\r\n        e.swap();\r\n        if (delims != null && delims.before != null && !delims.before.isEmpty()) {\r\n            e.push(delims.before);\r\n            e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\r\n            e.swap();\r\n        }\r\n        EmitUtils.process_array(e, type, callback);\r\n        shrinkStringBuffer(e, 2);\r\n        if (delims != null && delims.after != null && !delims.after.isEmpty()) {\r\n            e.push(delims.after);\r\n            e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\r\n        }\r\n    } else {\r\n        e.dup();\r\n        e.ifnull(skip);\r\n        for (Customizer customizer : registry.get(Customizer.class)) {\r\n            customizer.customize(e, type);\r\n        }\r\n        e.invoke_virtual(Constants.TYPE_OBJECT, TO_STRING);\r\n        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\r\n    }\r\n    e.goTo(end);\r\n    e.mark(skip);\r\n    e.pop();\r\n    e.push(\"null\");\r\n    e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\r\n    e.mark(end);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#shrinkStringBuffer(CodeEmitter,int)",
    "entityType": "method",
    "code": "private static void shrinkStringBuffer(CodeEmitter e, int amt) {\r\n    e.dup();\r\n    e.dup();\r\n    e.invoke_virtual(Constants.TYPE_STRING_BUFFER, LENGTH);\r\n    e.push(amt);\r\n    e.math(CodeEmitter.SUB, Type.INT_TYPE);\r\n    e.invoke_virtual(Constants.TYPE_STRING_BUFFER, SET_LENGTH);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#load_method(CodeEmitter,MethodInfo)",
    "entityType": "method",
    "code": "public static void load_method(CodeEmitter e, MethodInfo method) {\r\n    load_class(e, method.getClassInfo().getType());\r\n    e.push(method.getSignature().getName());\r\n    push_object(e, method.getSignature().getArgumentTypes());\r\n    e.invoke_virtual(Constants.TYPE_CLASS, GET_DECLARED_METHOD);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#method_switch(CodeEmitter,List,ObjectSwitchCallback)",
    "entityType": "method",
    "code": "public static void method_switch(CodeEmitter e, List methods, ObjectSwitchCallback callback) {\r\n    member_switch_helper(e, methods, callback, true);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#constructor_switch(CodeEmitter,List,ObjectSwitchCallback)",
    "entityType": "method",
    "code": "public static void constructor_switch(CodeEmitter e, List constructors, ObjectSwitchCallback callback) {\r\n    member_switch_helper(e, constructors, callback, false);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#member_switch_helper(CodeEmitter,List,ObjectSwitchCallback,boolean)",
    "entityType": "method",
    "code": "private static void member_switch_helper(final CodeEmitter e, List members, final ObjectSwitchCallback callback, boolean useName) {\r\n    try {\r\n        final Map cache = new HashMap();\r\n        final ParameterTyper cached = member -> {\r\n            Type[] types = (Type[]) cache.get(member);\r\n            if (types == null) {\r\n                cache.put(member, types = member.getSignature().getArgumentTypes());\r\n            }\r\n            return types;\r\n        };\r\n        final Label def = e.make_label();\r\n        final Label end = e.make_label();\r\n        if (useName) {\r\n            e.swap();\r\n            final Map buckets = CollectionUtils.bucket(members, value -> ((MethodInfo) value).getSignature().getName());\r\n            String[] names = (String[]) buckets.keySet().toArray(new String[buckets.size()]);\r\n            EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\r\n\r\n                @Override\r\n                public void processCase(Object key, Label dontUseEnd) throws Exception {\r\n                    member_helper_size(e, (List) buckets.get(key), callback, cached, def, end);\r\n                }\r\n\r\n                @Override\r\n                public void processDefault() throws Exception {\r\n                    e.goTo(def);\r\n                }\r\n            });\r\n        } else {\r\n            member_helper_size(e, members, callback, cached, def, end);\r\n        }\r\n        e.mark(def);\r\n        e.pop();\r\n        callback.processDefault();\r\n        e.mark(end);\r\n    } catch (RuntimeException | Error ex) {\r\n        throw ex;\r\n    } catch (Exception ex) {\r\n        throw new CodeGenerationException(ex);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#member_helper_size(CodeEmitter,List,ObjectSwitchCallback,ParameterTyper,Label,Label)",
    "entityType": "method",
    "code": "private static void member_helper_size(final CodeEmitter e, List members, final ObjectSwitchCallback callback, final ParameterTyper typer, final Label def, final Label end) throws Exception {\r\n    final Map buckets = CollectionUtils.bucket(members, value -> typer.getParameterTypes((MethodInfo) value).length);\r\n    e.dup();\r\n    e.arraylength();\r\n    e.process_switch(EmitUtils.getSwitchKeys(buckets), new ProcessSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(int key, Label dontUseEnd) throws Exception {\r\n            List bucket = (List) buckets.get(key);\r\n            member_helper_type(e, bucket, callback, typer, def, end, new BitSet());\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() throws Exception {\r\n            e.goTo(def);\r\n        }\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#member_helper_type(CodeEmitter,List,ObjectSwitchCallback,ParameterTyper,Label,Label,BitSet)",
    "entityType": "method",
    "code": "private static void member_helper_type(final CodeEmitter e, List members, final ObjectSwitchCallback callback, final ParameterTyper typer, final Label def, final Label end, final BitSet checked) throws Exception {\r\n    if (members.size() == 1) {\r\n        MethodInfo member = (MethodInfo) members.get(0);\r\n        Type[] types = typer.getParameterTypes(member);\r\n        // need to check classes that have not already been checked via switches\r\n        for (int i = 0; i < types.length; i++) {\r\n            if (checked == null || !checked.get(i)) {\r\n                e.dup();\r\n                e.aaload(i);\r\n                e.invoke_virtual(Constants.TYPE_CLASS, GET_NAME);\r\n                e.push(TypeUtils.emulateClassGetName(types[i]));\r\n                e.invoke_virtual(Constants.TYPE_OBJECT, EQUALS);\r\n                e.if_jump(CodeEmitter.EQ, def);\r\n            }\r\n        }\r\n        e.pop();\r\n        callback.processCase(member, end);\r\n    } else {\r\n        // choose the index that has the best chance of uniquely identifying member\r\n        Type[] example = typer.getParameterTypes((MethodInfo) members.get(0));\r\n        Map buckets = null;\r\n        int index = -1;\r\n        for (int i = 0; i < example.length; i++) {\r\n            final int j = i;\r\n            Map test = CollectionUtils.bucket(members, value -> TypeUtils.emulateClassGetName(typer.getParameterTypes((MethodInfo) value)[j]));\r\n            if (buckets == null || test.size() > buckets.size()) {\r\n                buckets = test;\r\n                index = i;\r\n            }\r\n        }\r\n        if (buckets == null || buckets.size() == 1) {\r\n            // TODO: switch by returnType\r\n            // must have two methods with same name, types, and different return types\r\n            e.goTo(def);\r\n        } else {\r\n            checked.set(index);\r\n            e.dup();\r\n            e.aaload(index);\r\n            e.invoke_virtual(Constants.TYPE_CLASS, GET_NAME);\r\n            final Map fbuckets = buckets;\r\n            String[] names = (String[]) buckets.keySet().toArray(new String[buckets.size()]);\r\n            EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\r\n\r\n                @Override\r\n                public void processCase(Object key, Label dontUseEnd) throws Exception {\r\n                    member_helper_type(e, (List) fbuckets.get(key), callback, typer, def, end, checked);\r\n                }\r\n\r\n                @Override\r\n                public void processDefault() throws Exception {\r\n                    e.goTo(def);\r\n                }\r\n            });\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#wrap_throwable(Block,Type)",
    "entityType": "method",
    "code": "public static void wrap_throwable(Block block, Type wrapper) {\r\n    CodeEmitter e = block.getCodeEmitter();\r\n    e.catch_exception(block, Constants.TYPE_THROWABLE);\r\n    e.new_instance(wrapper);\r\n    e.dup_x1();\r\n    e.swap();\r\n    e.invoke_constructor(wrapper, CSTRUCT_THROWABLE);\r\n    e.athrow();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#add_properties(ClassEmitter,String[],Type[])",
    "entityType": "method",
    "code": "public static void add_properties(ClassEmitter ce, String[] names, Type[] types) {\r\n    for (int i = 0; i < names.length; i++) {\r\n        String fieldName = \"$cglib_prop_\" + names[i];\r\n        ce.declare_field(Constants.ACC_PRIVATE, fieldName, types[i], null);\r\n        EmitUtils.add_property(ce, names[i], types[i], fieldName);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#add_property(ClassEmitter,String,Type,String)",
    "entityType": "method",
    "code": "public static void add_property(ClassEmitter ce, String name, Type type, String fieldName) {\r\n    String property = TypeUtils.upperFirst(name);\r\n    CodeEmitter e;\r\n    e = ce.begin_method(Constants.ACC_PUBLIC, new Signature(\"get\" + property, type, Constants.TYPES_EMPTY), null);\r\n    e.load_this();\r\n    e.getfield(fieldName);\r\n    e.return_value();\r\n    e.end_method();\r\n    e = ce.begin_method(Constants.ACC_PUBLIC, new Signature(\"set\" + property, Type.VOID_TYPE, new Type[] { type }), null);\r\n    e.load_this();\r\n    e.load_arg(0);\r\n    e.putfield(fieldName);\r\n    e.return_value();\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#wrap_undeclared_throwable(CodeEmitter,Block,Type[],Type)",
    "entityType": "method",
    "code": "/* generates:\r\n       } catch (RuntimeException e) {\r\n         throw e;\r\n       } catch (Error e) {\r\n         throw e;\r\n       } catch (<DeclaredException> e) {\r\n         throw e;\r\n       } catch (Throwable e) {\r\n         throw new <Wrapper>(e);\r\n       }\r\n    */\r\npublic static void wrap_undeclared_throwable(CodeEmitter e, Block handler, Type[] exceptions, Type wrapper) {\r\n    Set set = (exceptions == null) ? Collections.EMPTY_SET : new HashSet(Arrays.asList(exceptions));\r\n    if (set.contains(Constants.TYPE_THROWABLE)) {\r\n        return;\r\n    }\r\n    boolean needThrow = exceptions != null;\r\n    if (!set.contains(Constants.TYPE_RUNTIME_EXCEPTION)) {\r\n        e.catch_exception(handler, Constants.TYPE_RUNTIME_EXCEPTION);\r\n        needThrow = true;\r\n    }\r\n    if (!set.contains(Constants.TYPE_ERROR)) {\r\n        e.catch_exception(handler, Constants.TYPE_ERROR);\r\n        needThrow = true;\r\n    }\r\n    if (exceptions != null) {\r\n        for (Type exception : exceptions) {\r\n            e.catch_exception(handler, exception);\r\n        }\r\n    }\r\n    if (needThrow) {\r\n        e.athrow();\r\n    }\r\n    // e -> eo -> oeo -> ooe -> o\r\n    e.catch_exception(handler, Constants.TYPE_THROWABLE);\r\n    e.new_instance(wrapper);\r\n    e.dup_x1();\r\n    e.swap();\r\n    e.invoke_constructor(wrapper, CSTRUCT_THROWABLE);\r\n    e.athrow();\r\n}",
    "comment": " generates:\n       } catch (RuntimeException e) {\n         throw e;\n       } catch (Error e) {\n         throw e;\n       } catch (<DeclaredException> e) {\n         throw e;\n       } catch (Throwable e) {\n         throw new <Wrapper>(e);\n       }\n    "
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#begin_method(ClassEmitter,MethodInfo)",
    "entityType": "method",
    "code": "public static CodeEmitter begin_method(ClassEmitter e, MethodInfo method) {\r\n    return begin_method(e, method, method.getModifiers());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.EmitUtils#begin_method(ClassEmitter,MethodInfo,int)",
    "entityType": "method",
    "code": "public static CodeEmitter begin_method(ClassEmitter e, MethodInfo method, int access) {\r\n    return e.begin_method(access, method.getSignature(), method.getExceptionTypes());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.ArrayDelimiters",
    "entityType": "class",
    "code": "private String before;\nprivate String inside;\nprivate String after;\npublic ArrayDelimiters(String before, String inside, String after) {\r\n    this.before = before;\r\n    this.inside = inside;\r\n    this.after = after;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.ParameterTyper",
    "entityType": "class",
    "code": "Type[] getParameterTypes(MethodInfo member);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.ParameterTyper#getParameterTypes(MethodInfo)",
    "entityType": "method",
    "code": "Type[] getParameterTypes(MethodInfo member);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.FieldTypeCustomizer",
    "entityType": "class",
    "code": "/**\r\n * Customizes {@code this.FIELD_0 = ?} assignment in key constructor\r\n * @param e code emitter\r\n * @param index parameter index\r\n * @param type parameter type\r\n */\r\nvoid customize(CodeEmitter e, int index, Type type);\n/**\r\n * Computes type of field for storing given parameter\r\n * @param index parameter index\r\n * @param type parameter type\r\n */\r\nType getOutType(int index, Type type);",
    "comment": "\n * Customizes key types for {@link KeyFactory} right in constructor.\n "
  },
  {
    "entityId": "org.springframework.cglib.core.FieldTypeCustomizer#customize(CodeEmitter,int,Type)",
    "entityType": "method",
    "code": "/**\r\n * Customizes {@code this.FIELD_0 = ?} assignment in key constructor\r\n * @param e code emitter\r\n * @param index parameter index\r\n * @param type parameter type\r\n */\r\nvoid customize(CodeEmitter e, int index, Type type);",
    "comment": "\n     * Customizes {@code this.FIELD_0 = ?} assignment in key constructor\n     * @param e code emitter\n     * @param index parameter index\n     * @param type parameter type\n     "
  },
  {
    "entityId": "org.springframework.cglib.core.FieldTypeCustomizer#getOutType(int,Type)",
    "entityType": "method",
    "code": "/**\r\n * Computes type of field for storing given parameter\r\n * @param index parameter index\r\n * @param type parameter type\r\n */\r\nType getOutType(int index, Type type);",
    "comment": "\n     * Computes type of field for storing given parameter\n     * @param index parameter index\n     * @param type parameter type\n     "
  },
  {
    "entityId": "org.springframework.cglib.core.GeneratorStrategy",
    "entityType": "class",
    "code": "/**\r\n * Generate the class.\r\n * @param cg a class generator on which you can call {@link ClassGenerator#generateClass}\r\n * @return a byte array containing the bits of a valid Class\r\n */\r\nbyte[] generate(ClassGenerator cg) throws Exception;\n/**\r\n * The <code>GeneratorStrategy</code> in use does not currently, but may\r\n * in the future, affect the caching of classes generated by {@link\r\n * AbstractClassGenerator}, so this is a reminder that you should\r\n * correctly implement <code>equals</code> and <code>hashCode</code>\r\n * to avoid generating too many classes.\r\n */\r\n@Override\r\nboolean equals(Object o);",
    "comment": "\n * The <code>GeneratorStrategy</code> is responsible for taking a\n * {@link ClassGenerator} and producing a byte array containing the\n * data for the generated <code>Class</code>.  By providing your\n * own strategy you may examine or modify the generated class before\n * it is loaded. Typically this will be accomplished by subclassing\n * {@link DefaultGeneratorStrategy} and overriding the appropriate\n * protected method.\n * @see AbstractClassGenerator#setStrategy\n "
  },
  {
    "entityId": "org.springframework.cglib.core.GeneratorStrategy#generate(ClassGenerator)",
    "entityType": "method",
    "code": "/**\r\n * Generate the class.\r\n * @param cg a class generator on which you can call {@link ClassGenerator#generateClass}\r\n * @return a byte array containing the bits of a valid Class\r\n */\r\nbyte[] generate(ClassGenerator cg) throws Exception;",
    "comment": "\n     * Generate the class.\n     * @param cg a class generator on which you can call {@link ClassGenerator#generateClass}\n     * @return a byte array containing the bits of a valid Class\n     "
  },
  {
    "entityId": "org.springframework.cglib.core.GeneratorStrategy#equals(Object)",
    "entityType": "method",
    "code": "/**\r\n * The <code>GeneratorStrategy</code> in use does not currently, but may\r\n * in the future, affect the caching of classes generated by {@link\r\n * AbstractClassGenerator}, so this is a reminder that you should\r\n * correctly implement <code>equals</code> and <code>hashCode</code>\r\n * to avoid generating too many classes.\r\n */\r\n@Override\r\nboolean equals(Object o);",
    "comment": "\n     * The <code>GeneratorStrategy</code> in use does not currently, but may\n     * in the future, affect the caching of classes generated by {@link\n     * AbstractClassGenerator}, so this is a reminder that you should\n     * correctly implement <code>equals</code> and <code>hashCode</code>\n     * to avoid generating too many classes.\n     "
  },
  {
    "entityId": "org.springframework.cglib.core.HashCodeCustomizer",
    "entityType": "class",
    "code": "/**\r\n * Customizes calculation of hashcode\r\n * @param e code emitter\r\n * @param type parameter type\r\n */\r\nboolean customize(CodeEmitter e, Type type);",
    "comment": ""
  }
]