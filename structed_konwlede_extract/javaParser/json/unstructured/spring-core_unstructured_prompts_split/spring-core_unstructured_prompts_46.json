[
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#findAnnotation(AnnotatedElement,Class<A>)",
    "entityType": "method",
    "code": "/**\r\n * Find a single {@link Annotation} of {@code annotationType} on the\r\n * supplied {@link AnnotatedElement}.\r\n * <p>Meta-annotations will be searched if the annotation is not\r\n * <em>directly present</em> on the supplied element.\r\n * <p><strong>Warning</strong>: this method operates generically on\r\n * annotated elements. In other words, this method does not execute\r\n * specialized search algorithms for classes or methods. If you require\r\n * the more specific semantics of {@link #findAnnotation(Class, Class)}\r\n * or {@link #findAnnotation(Method, Class)}, invoke one of those methods\r\n * instead.\r\n * @param annotatedElement the {@code AnnotatedElement} on which to find the annotation\r\n * @param annotationType the annotation type to look for, both locally and as a meta-annotation\r\n * @return the first matching annotation, or {@code null} if not found\r\n * @since 4.2\r\n */\r\n@Nullable\r\npublic static <A extends Annotation> A findAnnotation(AnnotatedElement annotatedElement, @Nullable Class<A> annotationType) {\r\n    if (annotationType == null) {\r\n        return null;\r\n    }\r\n    // Shortcut: directly present on the element, with no merging needed?\r\n    if (AnnotationFilter.PLAIN.matches(annotationType) || AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) {\r\n        return annotatedElement.getDeclaredAnnotation(annotationType);\r\n    }\r\n    // Exhaustive retrieval of merged annotations...\r\n    return MergedAnnotations.from(annotatedElement, SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none()).get(annotationType).withNonMergedAttributes().synthesize(MergedAnnotation::isPresent).orElse(null);\r\n}",
    "comment": "\n\t * Find a single {@link Annotation} of {@code annotationType} on the\n\t * supplied {@link AnnotatedElement}.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>directly present</em> on the supplied element.\n\t * <p><strong>Warning</strong>: this method operates generically on\n\t * annotated elements. In other words, this method does not execute\n\t * specialized search algorithms for classes or methods. If you require\n\t * the more specific semantics of {@link #findAnnotation(Class, Class)}\n\t * or {@link #findAnnotation(Method, Class)}, invoke one of those methods\n\t * instead.\n\t * @param annotatedElement the {@code AnnotatedElement} on which to find the annotation\n\t * @param annotationType the annotation type to look for, both locally and as a meta-annotation\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @since 4.2\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#findAnnotation(Method,Class<A>)",
    "entityType": "method",
    "code": "/**\r\n * Find a single {@link Annotation} of {@code annotationType} on the supplied\r\n * {@link Method}, traversing its super methods (i.e. from superclasses and\r\n * interfaces) if the annotation is not <em>directly present</em> on the given\r\n * method itself.\r\n * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.\r\n * <p>Meta-annotations will be searched if the annotation is not\r\n * <em>directly present</em> on the method.\r\n * <p>Annotations on methods are not inherited by default, so we need to handle\r\n * this explicitly.\r\n * @param method the method to look for annotations on\r\n * @param annotationType the annotation type to look for\r\n * @return the first matching annotation, or {@code null} if not found\r\n * @see #getAnnotation(Method, Class)\r\n */\r\n@Nullable\r\npublic static <A extends Annotation> A findAnnotation(Method method, @Nullable Class<A> annotationType) {\r\n    if (annotationType == null) {\r\n        return null;\r\n    }\r\n    // Shortcut: directly present on the element, with no merging needed?\r\n    if (AnnotationFilter.PLAIN.matches(annotationType) || AnnotationsScanner.hasPlainJavaAnnotationsOnly(method)) {\r\n        return method.getDeclaredAnnotation(annotationType);\r\n    }\r\n    // Exhaustive retrieval of merged annotations...\r\n    return MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none()).get(annotationType).withNonMergedAttributes().synthesize(MergedAnnotation::isPresent).orElse(null);\r\n}",
    "comment": "\n\t * Find a single {@link Annotation} of {@code annotationType} on the supplied\n\t * {@link Method}, traversing its super methods (i.e. from superclasses and\n\t * interfaces) if the annotation is not <em>directly present</em> on the given\n\t * method itself.\n\t * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>directly present</em> on the method.\n\t * <p>Annotations on methods are not inherited by default, so we need to handle\n\t * this explicitly.\n\t * @param method the method to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @see #getAnnotation(Method, Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#findAnnotation(Class<?>,Class<A>)",
    "entityType": "method",
    "code": "/**\r\n * Find a single {@link Annotation} of {@code annotationType} on the\r\n * supplied {@link Class}, traversing its interfaces, annotations, and\r\n * superclasses if the annotation is not <em>directly present</em> on\r\n * the given class itself.\r\n * <p>This method explicitly handles class-level annotations which are not\r\n * declared as {@link java.lang.annotation.Inherited inherited} <em>as well\r\n * as meta-annotations and annotations on interfaces</em>.\r\n * <p>The algorithm operates as follows:\r\n * <ol>\r\n * <li>Search for the annotation on the given class and return it if found.\r\n * <li>Recursively search through all annotations that the given class declares.\r\n * <li>Recursively search through all interfaces that the given class declares.\r\n * <li>Recursively search through the superclass hierarchy of the given class.\r\n * </ol>\r\n * <p>Note: in this context, the term <em>recursively</em> means that the search\r\n * process continues by returning to step #1 with the current interface,\r\n * annotation, or superclass as the class to look for annotations on.\r\n * @param clazz the class to look for annotations on\r\n * @param annotationType the type of annotation to look for\r\n * @return the first matching annotation, or {@code null} if not found\r\n */\r\n@Nullable\r\npublic static <A extends Annotation> A findAnnotation(Class<?> clazz, @Nullable Class<A> annotationType) {\r\n    if (annotationType == null) {\r\n        return null;\r\n    }\r\n    // Shortcut: directly present on the element, with no merging needed?\r\n    if (AnnotationFilter.PLAIN.matches(annotationType) || AnnotationsScanner.hasPlainJavaAnnotationsOnly(clazz)) {\r\n        A annotation = clazz.getDeclaredAnnotation(annotationType);\r\n        if (annotation != null) {\r\n            return annotation;\r\n        }\r\n        // For backwards compatibility, perform a superclass search with plain annotations\r\n        // even if not marked as @Inherited: for example, a findAnnotation search for @Deprecated\r\n        Class<?> superclass = clazz.getSuperclass();\r\n        if (superclass == null || superclass == Object.class) {\r\n            return null;\r\n        }\r\n        return findAnnotation(superclass, annotationType);\r\n    }\r\n    // Exhaustive retrieval of merged annotations...\r\n    return MergedAnnotations.from(clazz, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none()).get(annotationType).withNonMergedAttributes().synthesize(MergedAnnotation::isPresent).orElse(null);\r\n}",
    "comment": "\n\t * Find a single {@link Annotation} of {@code annotationType} on the\n\t * supplied {@link Class}, traversing its interfaces, annotations, and\n\t * superclasses if the annotation is not <em>directly present</em> on\n\t * the given class itself.\n\t * <p>This method explicitly handles class-level annotations which are not\n\t * declared as {@link java.lang.annotation.Inherited inherited} <em>as well\n\t * as meta-annotations and annotations on interfaces</em>.\n\t * <p>The algorithm operates as follows:\n\t * <ol>\n\t * <li>Search for the annotation on the given class and return it if found.\n\t * <li>Recursively search through all annotations that the given class declares.\n\t * <li>Recursively search through all interfaces that the given class declares.\n\t * <li>Recursively search through the superclass hierarchy of the given class.\n\t * </ol>\n\t * <p>Note: in this context, the term <em>recursively</em> means that the search\n\t * process continues by returning to step #1 with the current interface,\n\t * annotation, or superclass as the class to look for annotations on.\n\t * @param clazz the class to look for annotations on\n\t * @param annotationType the type of annotation to look for\n\t * @return the first matching annotation, or {@code null} if not found\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#findAnnotationDeclaringClass(Class<? extends Annotation>,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Find the first {@link Class} in the inheritance hierarchy of the\r\n * specified {@code clazz} (including the specified {@code clazz} itself)\r\n * on which an annotation of the specified {@code annotationType} is\r\n * <em>directly present</em>.\r\n * <p>If the supplied {@code clazz} is an interface, only the interface\r\n * itself will be checked; the inheritance hierarchy for interfaces will\r\n * not be traversed.\r\n * <p>Meta-annotations will <em>not</em> be searched.\r\n * <p>The standard {@link Class} API does not provide a mechanism for\r\n * determining which class in an inheritance hierarchy actually declares\r\n * an {@link Annotation}, so we need to handle this explicitly.\r\n * @param annotationType the annotation type to look for\r\n * @param clazz the class to check for the annotation on (may be {@code null})\r\n * @return the first {@link Class} in the inheritance hierarchy that\r\n * declares an annotation of the specified {@code annotationType},\r\n * or {@code null} if not found\r\n * @see Class#isAnnotationPresent(Class)\r\n * @see Class#getDeclaredAnnotations()\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\n@Nullable\r\npublic static Class<?> findAnnotationDeclaringClass(Class<? extends Annotation> annotationType, @Nullable Class<?> clazz) {\r\n    if (clazz == null) {\r\n        return null;\r\n    }\r\n    return (Class<?>) MergedAnnotations.from(clazz, SearchStrategy.SUPERCLASS).get(annotationType, MergedAnnotation::isDirectlyPresent).getSource();\r\n}",
    "comment": "\n\t * Find the first {@link Class} in the inheritance hierarchy of the\n\t * specified {@code clazz} (including the specified {@code clazz} itself)\n\t * on which an annotation of the specified {@code annotationType} is\n\t * <em>directly present</em>.\n\t * <p>If the supplied {@code clazz} is an interface, only the interface\n\t * itself will be checked; the inheritance hierarchy for interfaces will\n\t * not be traversed.\n\t * <p>Meta-annotations will <em>not</em> be searched.\n\t * <p>The standard {@link Class} API does not provide a mechanism for\n\t * determining which class in an inheritance hierarchy actually declares\n\t * an {@link Annotation}, so we need to handle this explicitly.\n\t * @param annotationType the annotation type to look for\n\t * @param clazz the class to check for the annotation on (may be {@code null})\n\t * @return the first {@link Class} in the inheritance hierarchy that\n\t * declares an annotation of the specified {@code annotationType},\n\t * or {@code null} if not found\n\t * @see Class#isAnnotationPresent(Class)\n\t * @see Class#getDeclaredAnnotations()\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#findAnnotationDeclaringClassForTypes(List<Class<? extends Annotation>>,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Find the first {@link Class} in the inheritance hierarchy of the\r\n * specified {@code clazz} (including the specified {@code clazz} itself)\r\n * on which at least one of the specified {@code annotationTypes} is\r\n * <em>directly present</em>.\r\n * <p>If the supplied {@code clazz} is an interface, only the interface\r\n * itself will be checked; the inheritance hierarchy for interfaces will\r\n * not be traversed.\r\n * <p>Meta-annotations will <em>not</em> be searched.\r\n * <p>The standard {@link Class} API does not provide a mechanism for\r\n * determining which class in an inheritance hierarchy actually declares\r\n * one of several candidate {@linkplain Annotation annotations}, so we\r\n * need to handle this explicitly.\r\n * @param annotationTypes the annotation types to look for\r\n * @param clazz the class to check for the annotation on (may be {@code null})\r\n * @return the first {@link Class} in the inheritance hierarchy that\r\n * declares an annotation of at least one of the specified\r\n * {@code annotationTypes}, or {@code null} if not found\r\n * @since 3.2.2\r\n * @see Class#isAnnotationPresent(Class)\r\n * @see Class#getDeclaredAnnotations()\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\n@Nullable\r\npublic static Class<?> findAnnotationDeclaringClassForTypes(List<Class<? extends Annotation>> annotationTypes, @Nullable Class<?> clazz) {\r\n    if (clazz == null) {\r\n        return null;\r\n    }\r\n    MergedAnnotation<?> merged = MergedAnnotations.from(clazz, SearchStrategy.SUPERCLASS).stream().filter(MergedAnnotationPredicates.typeIn(annotationTypes).and(MergedAnnotation::isDirectlyPresent)).findFirst().orElse(null);\r\n    return (merged != null && merged.getSource() instanceof Class<?> sourceClass ? sourceClass : null);\r\n}",
    "comment": "\n\t * Find the first {@link Class} in the inheritance hierarchy of the\n\t * specified {@code clazz} (including the specified {@code clazz} itself)\n\t * on which at least one of the specified {@code annotationTypes} is\n\t * <em>directly present</em>.\n\t * <p>If the supplied {@code clazz} is an interface, only the interface\n\t * itself will be checked; the inheritance hierarchy for interfaces will\n\t * not be traversed.\n\t * <p>Meta-annotations will <em>not</em> be searched.\n\t * <p>The standard {@link Class} API does not provide a mechanism for\n\t * determining which class in an inheritance hierarchy actually declares\n\t * one of several candidate {@linkplain Annotation annotations}, so we\n\t * need to handle this explicitly.\n\t * @param annotationTypes the annotation types to look for\n\t * @param clazz the class to check for the annotation on (may be {@code null})\n\t * @return the first {@link Class} in the inheritance hierarchy that\n\t * declares an annotation of at least one of the specified\n\t * {@code annotationTypes}, or {@code null} if not found\n\t * @since 3.2.2\n\t * @see Class#isAnnotationPresent(Class)\n\t * @see Class#getDeclaredAnnotations()\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#isAnnotationDeclaredLocally(Class<? extends Annotation>,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether an annotation of the specified {@code annotationType}\r\n * is declared locally (i.e. <em>directly present</em>) on the supplied\r\n * {@code clazz}.\r\n * <p>The supplied {@link Class} may represent any type.\r\n * <p>Meta-annotations will <em>not</em> be searched.\r\n * <p>Note: This method does <strong>not</strong> determine if the annotation\r\n * is {@linkplain java.lang.annotation.Inherited inherited}.\r\n * @param annotationType the annotation type to look for\r\n * @param clazz the class to check for the annotation on\r\n * @return {@code true} if an annotation of the specified {@code annotationType}\r\n * is <em>directly present</em>\r\n * @see java.lang.Class#getDeclaredAnnotations()\r\n * @see java.lang.Class#getDeclaredAnnotation(Class)\r\n */\r\npublic static boolean isAnnotationDeclaredLocally(Class<? extends Annotation> annotationType, Class<?> clazz) {\r\n    return MergedAnnotations.from(clazz).get(annotationType).isDirectlyPresent();\r\n}",
    "comment": "\n\t * Determine whether an annotation of the specified {@code annotationType}\n\t * is declared locally (i.e. <em>directly present</em>) on the supplied\n\t * {@code clazz}.\n\t * <p>The supplied {@link Class} may represent any type.\n\t * <p>Meta-annotations will <em>not</em> be searched.\n\t * <p>Note: This method does <strong>not</strong> determine if the annotation\n\t * is {@linkplain java.lang.annotation.Inherited inherited}.\n\t * @param annotationType the annotation type to look for\n\t * @param clazz the class to check for the annotation on\n\t * @return {@code true} if an annotation of the specified {@code annotationType}\n\t * is <em>directly present</em>\n\t * @see java.lang.Class#getDeclaredAnnotations()\n\t * @see java.lang.Class#getDeclaredAnnotation(Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#isAnnotationInherited(Class<? extends Annotation>,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether an annotation of the specified {@code annotationType}\r\n * is <em>present</em> on the supplied {@code clazz} and is\r\n * {@linkplain java.lang.annotation.Inherited inherited}\r\n * (i.e. not <em>directly present</em>).\r\n * <p>Meta-annotations will <em>not</em> be searched.\r\n * <p>If the supplied {@code clazz} is an interface, only the interface\r\n * itself will be checked. In accordance with standard meta-annotation\r\n * semantics in Java, the inheritance hierarchy for interfaces will not\r\n * be traversed. See the {@linkplain java.lang.annotation.Inherited javadoc}\r\n * for the {@code @Inherited} meta-annotation for further details regarding\r\n * annotation inheritance.\r\n * @param annotationType the annotation type to look for\r\n * @param clazz the class to check for the annotation on\r\n * @return {@code true} if an annotation of the specified {@code annotationType}\r\n * is <em>present</em> and <em>inherited</em>\r\n * @see Class#isAnnotationPresent(Class)\r\n * @see #isAnnotationDeclaredLocally(Class, Class)\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\npublic static boolean isAnnotationInherited(Class<? extends Annotation> annotationType, Class<?> clazz) {\r\n    return MergedAnnotations.from(clazz, SearchStrategy.INHERITED_ANNOTATIONS).stream(annotationType).filter(MergedAnnotation::isDirectlyPresent).findFirst().orElseGet(MergedAnnotation::missing).getAggregateIndex() > 0;\r\n}",
    "comment": "\n\t * Determine whether an annotation of the specified {@code annotationType}\n\t * is <em>present</em> on the supplied {@code clazz} and is\n\t * {@linkplain java.lang.annotation.Inherited inherited}\n\t * (i.e. not <em>directly present</em>).\n\t * <p>Meta-annotations will <em>not</em> be searched.\n\t * <p>If the supplied {@code clazz} is an interface, only the interface\n\t * itself will be checked. In accordance with standard meta-annotation\n\t * semantics in Java, the inheritance hierarchy for interfaces will not\n\t * be traversed. See the {@linkplain java.lang.annotation.Inherited javadoc}\n\t * for the {@code @Inherited} meta-annotation for further details regarding\n\t * annotation inheritance.\n\t * @param annotationType the annotation type to look for\n\t * @param clazz the class to check for the annotation on\n\t * @return {@code true} if an annotation of the specified {@code annotationType}\n\t * is <em>present</em> and <em>inherited</em>\n\t * @see Class#isAnnotationPresent(Class)\n\t * @see #isAnnotationDeclaredLocally(Class, Class)\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#isAnnotationMetaPresent(Class<? extends Annotation>,Class<? extends Annotation>)",
    "entityType": "method",
    "code": "/**\r\n * Determine if an annotation of type {@code metaAnnotationType} is\r\n * <em>meta-present</em> on the supplied {@code annotationType}.\r\n * @param annotationType the annotation type to search on\r\n * @param metaAnnotationType the type of meta-annotation to search for\r\n * @return {@code true} if such an annotation is meta-present\r\n * @since 4.2.1\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\npublic static boolean isAnnotationMetaPresent(Class<? extends Annotation> annotationType, @Nullable Class<? extends Annotation> metaAnnotationType) {\r\n    if (metaAnnotationType == null) {\r\n        return false;\r\n    }\r\n    // Shortcut: directly present on the element, with no merging needed?\r\n    if (AnnotationFilter.PLAIN.matches(metaAnnotationType) || AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotationType)) {\r\n        return annotationType.isAnnotationPresent(metaAnnotationType);\r\n    }\r\n    // Exhaustive retrieval of merged annotations...\r\n    return MergedAnnotations.from(annotationType, SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none()).isPresent(metaAnnotationType);\r\n}",
    "comment": "\n\t * Determine if an annotation of type {@code metaAnnotationType} is\n\t * <em>meta-present</em> on the supplied {@code annotationType}.\n\t * @param annotationType the annotation type to search on\n\t * @param metaAnnotationType the type of meta-annotation to search for\n\t * @return {@code true} if such an annotation is meta-present\n\t * @since 4.2.1\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#isInJavaLangAnnotationPackage(Annotation)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the supplied {@link Annotation} is defined in the core JDK\r\n * {@code java.lang.annotation} package.\r\n * @param annotation the annotation to check\r\n * @return {@code true} if the annotation is in the {@code java.lang.annotation} package\r\n */\r\npublic static boolean isInJavaLangAnnotationPackage(@Nullable Annotation annotation) {\r\n    return (annotation != null && JAVA_LANG_ANNOTATION_FILTER.matches(annotation));\r\n}",
    "comment": "\n\t * Determine if the supplied {@link Annotation} is defined in the core JDK\n\t * {@code java.lang.annotation} package.\n\t * @param annotation the annotation to check\n\t * @return {@code true} if the annotation is in the {@code java.lang.annotation} package\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#isInJavaLangAnnotationPackage(String)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the {@link Annotation} with the supplied name is defined\r\n * in the core JDK {@code java.lang.annotation} package.\r\n * @param annotationType the name of the annotation type to check\r\n * @return {@code true} if the annotation is in the {@code java.lang.annotation} package\r\n * @since 4.2\r\n */\r\npublic static boolean isInJavaLangAnnotationPackage(@Nullable String annotationType) {\r\n    return (annotationType != null && JAVA_LANG_ANNOTATION_FILTER.matches(annotationType));\r\n}",
    "comment": "\n\t * Determine if the {@link Annotation} with the supplied name is defined\n\t * in the core JDK {@code java.lang.annotation} package.\n\t * @param annotationType the name of the annotation type to check\n\t * @return {@code true} if the annotation is in the {@code java.lang.annotation} package\n\t * @since 4.2\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#validateAnnotation(Annotation)",
    "entityType": "method",
    "code": "/**\r\n * Check the declared attributes of the given annotation, in particular covering\r\n * Google App Engine's late arrival of {@code TypeNotPresentExceptionProxy} for\r\n * {@code Class} values (instead of early {@code Class.getAnnotations() failure}).\r\n * <p>This method not failing indicates that {@link #getAnnotationAttributes(Annotation)}\r\n * won't fail either (when attempted later on).\r\n * @param annotation the annotation to validate\r\n * @throws IllegalStateException if a declared {@code Class} attribute could not be read\r\n * @since 4.3.15\r\n * @see Class#getAnnotations()\r\n * @see #getAnnotationAttributes(Annotation)\r\n */\r\npublic static void validateAnnotation(Annotation annotation) {\r\n    AttributeMethods.forAnnotationType(annotation.annotationType()).validate(annotation);\r\n}",
    "comment": "\n\t * Check the declared attributes of the given annotation, in particular covering\n\t * Google App Engine's late arrival of {@code TypeNotPresentExceptionProxy} for\n\t * {@code Class} values (instead of early {@code Class.getAnnotations() failure}).\n\t * <p>This method not failing indicates that {@link #getAnnotationAttributes(Annotation)}\n\t * won't fail either (when attempted later on).\n\t * @param annotation the annotation to validate\n\t * @throws IllegalStateException if a declared {@code Class} attribute could not be read\n\t * @since 4.3.15\n\t * @see Class#getAnnotations()\n\t * @see #getAnnotationAttributes(Annotation)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#getAnnotationAttributes(Annotation)",
    "entityType": "method",
    "code": "/**\r\n * Retrieve the given annotation's attributes as a {@link Map}, preserving all\r\n * attribute types.\r\n * <p>Equivalent to calling {@link #getAnnotationAttributes(Annotation, boolean, boolean)}\r\n * with the {@code classValuesAsString} and {@code nestedAnnotationsAsMap} parameters\r\n * set to {@code false}.\r\n * <p>Note: This method actually returns an {@link AnnotationAttributes} instance.\r\n * However, the {@code Map} signature has been preserved for binary compatibility.\r\n * @param annotation the annotation to retrieve the attributes for\r\n * @return the Map of annotation attributes, with attribute names as keys and\r\n * corresponding attribute values as values (never {@code null})\r\n * @see #getAnnotationAttributes(AnnotatedElement, Annotation)\r\n * @see #getAnnotationAttributes(Annotation, boolean, boolean)\r\n * @see #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)\r\n */\r\npublic static Map<String, @Nullable Object> getAnnotationAttributes(Annotation annotation) {\r\n    return getAnnotationAttributes(null, annotation);\r\n}",
    "comment": "\n\t * Retrieve the given annotation's attributes as a {@link Map}, preserving all\n\t * attribute types.\n\t * <p>Equivalent to calling {@link #getAnnotationAttributes(Annotation, boolean, boolean)}\n\t * with the {@code classValuesAsString} and {@code nestedAnnotationsAsMap} parameters\n\t * set to {@code false}.\n\t * <p>Note: This method actually returns an {@link AnnotationAttributes} instance.\n\t * However, the {@code Map} signature has been preserved for binary compatibility.\n\t * @param annotation the annotation to retrieve the attributes for\n\t * @return the Map of annotation attributes, with attribute names as keys and\n\t * corresponding attribute values as values (never {@code null})\n\t * @see #getAnnotationAttributes(AnnotatedElement, Annotation)\n\t * @see #getAnnotationAttributes(Annotation, boolean, boolean)\n\t * @see #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#getAnnotationAttributes(Annotation,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Retrieve the given annotation's attributes as a {@link Map}.\r\n * <p>Equivalent to calling {@link #getAnnotationAttributes(Annotation, boolean, boolean)}\r\n * with the {@code nestedAnnotationsAsMap} parameter set to {@code false}.\r\n * <p>Note: This method actually returns an {@link AnnotationAttributes} instance.\r\n * However, the {@code Map} signature has been preserved for binary compatibility.\r\n * @param annotation the annotation to retrieve the attributes for\r\n * @param classValuesAsString whether to convert Class references into Strings (for\r\n * compatibility with {@link org.springframework.core.type.AnnotationMetadata})\r\n * or to preserve them as Class references\r\n * @return the Map of annotation attributes, with attribute names as keys and\r\n * corresponding attribute values as values (never {@code null})\r\n * @see #getAnnotationAttributes(Annotation, boolean, boolean)\r\n */\r\npublic static Map<String, @Nullable Object> getAnnotationAttributes(Annotation annotation, boolean classValuesAsString) {\r\n    return getAnnotationAttributes(annotation, classValuesAsString, false);\r\n}",
    "comment": "\n\t * Retrieve the given annotation's attributes as a {@link Map}.\n\t * <p>Equivalent to calling {@link #getAnnotationAttributes(Annotation, boolean, boolean)}\n\t * with the {@code nestedAnnotationsAsMap} parameter set to {@code false}.\n\t * <p>Note: This method actually returns an {@link AnnotationAttributes} instance.\n\t * However, the {@code Map} signature has been preserved for binary compatibility.\n\t * @param annotation the annotation to retrieve the attributes for\n\t * @param classValuesAsString whether to convert Class references into Strings (for\n\t * compatibility with {@link org.springframework.core.type.AnnotationMetadata})\n\t * or to preserve them as Class references\n\t * @return the Map of annotation attributes, with attribute names as keys and\n\t * corresponding attribute values as values (never {@code null})\n\t * @see #getAnnotationAttributes(Annotation, boolean, boolean)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#getAnnotationAttributes(Annotation,boolean,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.\r\n * <p>This method provides fully recursive annotation reading capabilities on par with\r\n * the reflection-based {@link org.springframework.core.type.StandardAnnotationMetadata}.\r\n * @param annotation the annotation to retrieve the attributes for\r\n * @param classValuesAsString whether to convert Class references into Strings (for\r\n * compatibility with {@link org.springframework.core.type.AnnotationMetadata})\r\n * or to preserve them as Class references\r\n * @param nestedAnnotationsAsMap whether to convert nested annotations into\r\n * {@link AnnotationAttributes} maps (for compatibility with\r\n * {@link org.springframework.core.type.AnnotationMetadata}) or to preserve them as\r\n * {@code Annotation} instances\r\n * @return the annotation attributes (a specialized Map) with attribute names as keys\r\n * and corresponding attribute values as values (never {@code null})\r\n * @since 3.1.1\r\n */\r\npublic static AnnotationAttributes getAnnotationAttributes(Annotation annotation, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {\r\n    return getAnnotationAttributes(null, annotation, classValuesAsString, nestedAnnotationsAsMap);\r\n}",
    "comment": "\n\t * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.\n\t * <p>This method provides fully recursive annotation reading capabilities on par with\n\t * the reflection-based {@link org.springframework.core.type.StandardAnnotationMetadata}.\n\t * @param annotation the annotation to retrieve the attributes for\n\t * @param classValuesAsString whether to convert Class references into Strings (for\n\t * compatibility with {@link org.springframework.core.type.AnnotationMetadata})\n\t * or to preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested annotations into\n\t * {@link AnnotationAttributes} maps (for compatibility with\n\t * {@link org.springframework.core.type.AnnotationMetadata}) or to preserve them as\n\t * {@code Annotation} instances\n\t * @return the annotation attributes (a specialized Map) with attribute names as keys\n\t * and corresponding attribute values as values (never {@code null})\n\t * @since 3.1.1\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#getAnnotationAttributes(AnnotatedElement,Annotation)",
    "entityType": "method",
    "code": "/**\r\n * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.\r\n * <p>Equivalent to calling {@link #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)}\r\n * with the {@code classValuesAsString} and {@code nestedAnnotationsAsMap} parameters\r\n * set to {@code false}.\r\n * @param annotatedElement the element that is annotated with the supplied annotation;\r\n * may be {@code null} if unknown\r\n * @param annotation the annotation to retrieve the attributes for\r\n * @return the annotation attributes (a specialized Map) with attribute names as keys\r\n * and corresponding attribute values as values (never {@code null})\r\n * @since 4.2\r\n * @see #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)\r\n */\r\npublic static AnnotationAttributes getAnnotationAttributes(@Nullable AnnotatedElement annotatedElement, Annotation annotation) {\r\n    return getAnnotationAttributes(annotatedElement, annotation, false, false);\r\n}",
    "comment": "\n\t * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.\n\t * <p>Equivalent to calling {@link #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)}\n\t * with the {@code classValuesAsString} and {@code nestedAnnotationsAsMap} parameters\n\t * set to {@code false}.\n\t * @param annotatedElement the element that is annotated with the supplied annotation;\n\t * may be {@code null} if unknown\n\t * @param annotation the annotation to retrieve the attributes for\n\t * @return the annotation attributes (a specialized Map) with attribute names as keys\n\t * and corresponding attribute values as values (never {@code null})\n\t * @since 4.2\n\t * @see #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#getAnnotationAttributes(AnnotatedElement,Annotation,boolean,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.\r\n * <p>This method provides fully recursive annotation reading capabilities on par with\r\n * the reflection-based {@link org.springframework.core.type.StandardAnnotationMetadata}.\r\n * @param annotatedElement the element that is annotated with the supplied annotation;\r\n * may be {@code null} if unknown\r\n * @param annotation the annotation to retrieve the attributes for\r\n * @param classValuesAsString whether to convert Class references into Strings (for\r\n * compatibility with {@link org.springframework.core.type.AnnotationMetadata})\r\n * or to preserve them as Class references\r\n * @param nestedAnnotationsAsMap whether to convert nested annotations into\r\n * {@link AnnotationAttributes} maps (for compatibility with\r\n * {@link org.springframework.core.type.AnnotationMetadata}) or to preserve them as\r\n * {@code Annotation} instances\r\n * @return the annotation attributes (a specialized Map) with attribute names as keys\r\n * and corresponding attribute values as values (never {@code null})\r\n * @since 4.2\r\n */\r\npublic static AnnotationAttributes getAnnotationAttributes(@Nullable AnnotatedElement annotatedElement, Annotation annotation, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {\r\n    Adapt[] adaptations = Adapt.values(classValuesAsString, nestedAnnotationsAsMap);\r\n    return MergedAnnotation.from(annotatedElement, annotation).withNonMergedAttributes().asMap(mergedAnnotation -> new AnnotationAttributes(mergedAnnotation.getType(), true), adaptations);\r\n}",
    "comment": "\n\t * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.\n\t * <p>This method provides fully recursive annotation reading capabilities on par with\n\t * the reflection-based {@link org.springframework.core.type.StandardAnnotationMetadata}.\n\t * @param annotatedElement the element that is annotated with the supplied annotation;\n\t * may be {@code null} if unknown\n\t * @param annotation the annotation to retrieve the attributes for\n\t * @param classValuesAsString whether to convert Class references into Strings (for\n\t * compatibility with {@link org.springframework.core.type.AnnotationMetadata})\n\t * or to preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested annotations into\n\t * {@link AnnotationAttributes} maps (for compatibility with\n\t * {@link org.springframework.core.type.AnnotationMetadata}) or to preserve them as\n\t * {@code Annotation} instances\n\t * @return the annotation attributes (a specialized Map) with attribute names as keys\n\t * and corresponding attribute values as values (never {@code null})\n\t * @since 4.2\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#registerDefaultValues(AnnotationAttributes)",
    "entityType": "method",
    "code": "/**\r\n * Register the annotation-declared default values for the given attributes,\r\n * if available.\r\n * @param attributes the annotation attributes to process\r\n * @since 4.3.2\r\n */\r\npublic static void registerDefaultValues(AnnotationAttributes attributes) {\r\n    Class<? extends Annotation> annotationType = attributes.annotationType();\r\n    if (annotationType != null && Modifier.isPublic(annotationType.getModifiers()) && !AnnotationFilter.PLAIN.matches(annotationType)) {\r\n        Map<String, DefaultValueHolder> defaultValues = getDefaultValues(annotationType);\r\n        defaultValues.forEach(attributes::putIfAbsent);\r\n    }\r\n}",
    "comment": "\n\t * Register the annotation-declared default values for the given attributes,\n\t * if available.\n\t * @param attributes the annotation attributes to process\n\t * @since 4.3.2\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#getDefaultValues(Class<? extends Annotation>)",
    "entityType": "method",
    "code": "private static Map<String, DefaultValueHolder> getDefaultValues(Class<? extends Annotation> annotationType) {\r\n    return defaultValuesCache.computeIfAbsent(annotationType, AnnotationUtils::computeDefaultValues);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#computeDefaultValues(Class<? extends Annotation>)",
    "entityType": "method",
    "code": "private static Map<String, DefaultValueHolder> computeDefaultValues(Class<? extends Annotation> annotationType) {\r\n    AttributeMethods methods = AttributeMethods.forAnnotationType(annotationType);\r\n    if (!methods.hasDefaultValueMethod()) {\r\n        return Collections.emptyMap();\r\n    }\r\n    Map<String, DefaultValueHolder> result = CollectionUtils.newLinkedHashMap(methods.size());\r\n    if (!methods.hasNestedAnnotation()) {\r\n        // Use simpler method if there are no nested annotations\r\n        for (int i = 0; i < methods.size(); i++) {\r\n            Method method = methods.get(i);\r\n            Object defaultValue = method.getDefaultValue();\r\n            if (defaultValue != null) {\r\n                result.put(method.getName(), new DefaultValueHolder(defaultValue));\r\n            }\r\n        }\r\n    } else {\r\n        // If we have nested annotations, we need them as nested maps\r\n        AnnotationAttributes attributes = MergedAnnotation.of(annotationType).asMap(annotation -> new AnnotationAttributes(annotation.getType(), true), Adapt.ANNOTATION_TO_MAP);\r\n        for (Map.Entry<String, Object> element : attributes.entrySet()) {\r\n            result.put(element.getKey(), new DefaultValueHolder(element.getValue()));\r\n        }\r\n    }\r\n    return result;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#postProcessAnnotationAttributes(Object,AnnotationAttributes,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Post-process the supplied {@link AnnotationAttributes}, preserving nested\r\n * annotations as {@code Annotation} instances.\r\n * <p>Specifically, this method enforces <em>attribute alias</em> semantics\r\n * for annotation attributes that are annotated with {@link AliasFor @AliasFor}\r\n * and replaces default value placeholders with their original default values.\r\n * @param annotatedElement the element that is annotated with an annotation or\r\n * annotation hierarchy from which the supplied attributes were created;\r\n * may be {@code null} if unknown\r\n * @param attributes the annotation attributes to post-process\r\n * @param classValuesAsString whether to convert Class references into Strings (for\r\n * compatibility with {@link org.springframework.core.type.AnnotationMetadata})\r\n * or to preserve them as Class references\r\n * @since 4.3.2\r\n * @see #getDefaultValue(Class, String)\r\n */\r\npublic static void postProcessAnnotationAttributes(@Nullable Object annotatedElement, @Nullable AnnotationAttributes attributes, boolean classValuesAsString) {\r\n    if (attributes == null) {\r\n        return;\r\n    }\r\n    if (!attributes.validated) {\r\n        Class<? extends Annotation> annotationType = attributes.annotationType();\r\n        if (annotationType == null) {\r\n            return;\r\n        }\r\n        AnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(annotationType).get(0);\r\n        for (int i = 0; i < mapping.getMirrorSets().size(); i++) {\r\n            MirrorSet mirrorSet = mapping.getMirrorSets().get(i);\r\n            int resolved = mirrorSet.resolve(attributes.displayName, attributes, AnnotationUtils::getAttributeValueForMirrorResolution);\r\n            if (resolved != -1) {\r\n                Method attribute = mapping.getAttributes().get(resolved);\r\n                Object value = attributes.get(attribute.getName());\r\n                for (int j = 0; j < mirrorSet.size(); j++) {\r\n                    Method mirror = mirrorSet.get(j);\r\n                    if (mirror != attribute) {\r\n                        attributes.put(mirror.getName(), adaptValue(annotatedElement, value, classValuesAsString));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (Map.Entry<String, Object> attributeEntry : attributes.entrySet()) {\r\n        String attributeName = attributeEntry.getKey();\r\n        Object value = attributeEntry.getValue();\r\n        if (value instanceof DefaultValueHolder defaultValueHolder) {\r\n            value = defaultValueHolder.defaultValue;\r\n            attributes.put(attributeName, adaptValue(annotatedElement, value, classValuesAsString));\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Post-process the supplied {@link AnnotationAttributes}, preserving nested\n\t * annotations as {@code Annotation} instances.\n\t * <p>Specifically, this method enforces <em>attribute alias</em> semantics\n\t * for annotation attributes that are annotated with {@link AliasFor @AliasFor}\n\t * and replaces default value placeholders with their original default values.\n\t * @param annotatedElement the element that is annotated with an annotation or\n\t * annotation hierarchy from which the supplied attributes were created;\n\t * may be {@code null} if unknown\n\t * @param attributes the annotation attributes to post-process\n\t * @param classValuesAsString whether to convert Class references into Strings (for\n\t * compatibility with {@link org.springframework.core.type.AnnotationMetadata})\n\t * or to preserve them as Class references\n\t * @since 4.3.2\n\t * @see #getDefaultValue(Class, String)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#getAttributeValueForMirrorResolution(Method,Object)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static Object getAttributeValueForMirrorResolution(Method attribute, @Nullable Object attributes) {\r\n    if (!(attributes instanceof AnnotationAttributes annotationAttributes)) {\r\n        return null;\r\n    }\r\n    Object result = annotationAttributes.get(attribute.getName());\r\n    return (result instanceof DefaultValueHolder defaultValueHolder ? defaultValueHolder.defaultValue : result);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#adaptValue(Object,Object,boolean)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static Object adaptValue(@Nullable Object annotatedElement, @Nullable Object value, boolean classValuesAsString) {\r\n    if (classValuesAsString) {\r\n        if (value instanceof Class<?> clazz) {\r\n            return clazz.getName();\r\n        }\r\n        if (value instanceof Class<?>[] classes) {\r\n            String[] names = new String[classes.length];\r\n            for (int i = 0; i < classes.length; i++) {\r\n                names[i] = classes[i].getName();\r\n            }\r\n            return names;\r\n        }\r\n    }\r\n    if (value instanceof Annotation annotation) {\r\n        return MergedAnnotation.from(annotatedElement, annotation).synthesize();\r\n    }\r\n    if (value instanceof Annotation[] annotations) {\r\n        Annotation[] synthesized = (Annotation[]) Array.newInstance(annotations.getClass().componentType(), annotations.length);\r\n        for (int i = 0; i < annotations.length; i++) {\r\n            synthesized[i] = MergedAnnotation.from(annotatedElement, annotations[i]).synthesize();\r\n        }\r\n        return synthesized;\r\n    }\r\n    return value;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#getValue(Annotation)",
    "entityType": "method",
    "code": "/**\r\n * Retrieve the <em>value</em> of the {@code value} attribute of a\r\n * single-element Annotation, given an annotation instance.\r\n * @param annotation the annotation instance from which to retrieve the value\r\n * @return the attribute value, or {@code null} if not found unless the attribute\r\n * value cannot be retrieved due to an {@link AnnotationConfigurationException},\r\n * in which case such an exception will be rethrown\r\n * @see #getValue(Annotation, String)\r\n */\r\n@Nullable\r\npublic static Object getValue(Annotation annotation) {\r\n    return getValue(annotation, VALUE);\r\n}",
    "comment": "\n\t * Retrieve the <em>value</em> of the {@code value} attribute of a\n\t * single-element Annotation, given an annotation instance.\n\t * @param annotation the annotation instance from which to retrieve the value\n\t * @return the attribute value, or {@code null} if not found unless the attribute\n\t * value cannot be retrieved due to an {@link AnnotationConfigurationException},\n\t * in which case such an exception will be rethrown\n\t * @see #getValue(Annotation, String)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#getValue(Annotation,String)",
    "entityType": "method",
    "code": "/**\r\n * Retrieve the <em>value</em> of a named attribute, given an annotation instance.\r\n * @param annotation the annotation instance from which to retrieve the value\r\n * @param attributeName the name of the attribute value to retrieve\r\n * @return the attribute value, or {@code null} if not found unless the attribute\r\n * value cannot be retrieved due to an {@link AnnotationConfigurationException},\r\n * in which case such an exception will be rethrown\r\n * @see #getValue(Annotation)\r\n */\r\n@Nullable\r\npublic static Object getValue(@Nullable Annotation annotation, @Nullable String attributeName) {\r\n    if (annotation == null || !StringUtils.hasText(attributeName)) {\r\n        return null;\r\n    }\r\n    try {\r\n        for (Method method : annotation.annotationType().getDeclaredMethods()) {\r\n            if (method.getName().equals(attributeName) && method.getParameterCount() == 0) {\r\n                return invokeAnnotationMethod(method, annotation);\r\n            }\r\n        }\r\n    } catch (Throwable ex) {\r\n        handleValueRetrievalFailure(annotation, ex);\r\n    }\r\n    return null;\r\n}",
    "comment": "\n\t * Retrieve the <em>value</em> of a named attribute, given an annotation instance.\n\t * @param annotation the annotation instance from which to retrieve the value\n\t * @param attributeName the name of the attribute value to retrieve\n\t * @return the attribute value, or {@code null} if not found unless the attribute\n\t * value cannot be retrieved due to an {@link AnnotationConfigurationException},\n\t * in which case such an exception will be rethrown\n\t * @see #getValue(Annotation)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#invokeAnnotationMethod(Method,Object)",
    "entityType": "method",
    "code": "/**\r\n * Invoke the supplied annotation attribute {@link Method} on the supplied\r\n * {@link Annotation}.\r\n * <p>An attempt will first be made to invoke the method via the annotation's\r\n * {@link InvocationHandler} (if the annotation instance is a JDK dynamic proxy).\r\n * If that fails, an attempt will be made to invoke the method via reflection.\r\n * @param method the method to invoke\r\n * @param annotation the annotation on which to invoke the method\r\n * @return the value returned from the method invocation\r\n * @since 5.3.24\r\n */\r\n@Nullable\r\nstatic Object invokeAnnotationMethod(Method method, @Nullable Object annotation) {\r\n    if (annotation == null) {\r\n        return null;\r\n    }\r\n    if (Proxy.isProxyClass(annotation.getClass())) {\r\n        try {\r\n            InvocationHandler handler = Proxy.getInvocationHandler(annotation);\r\n            return handler.invoke(annotation, method, null);\r\n        } catch (Throwable ex) {\r\n            // Ignore and fall back to reflection below\r\n        }\r\n    }\r\n    return ReflectionUtils.invokeMethod(method, annotation);\r\n}",
    "comment": "\n\t * Invoke the supplied annotation attribute {@link Method} on the supplied\n\t * {@link Annotation}.\n\t * <p>An attempt will first be made to invoke the method via the annotation's\n\t * {@link InvocationHandler} (if the annotation instance is a JDK dynamic proxy).\n\t * If that fails, an attempt will be made to invoke the method via reflection.\n\t * @param method the method to invoke\n\t * @param annotation the annotation on which to invoke the method\n\t * @return the value returned from the method invocation\n\t * @since 5.3.24\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#rethrowAnnotationConfigurationException(Throwable)",
    "entityType": "method",
    "code": "/**\r\n * If the supplied throwable is an {@link AnnotationConfigurationException},\r\n * it will be cast to an {@code AnnotationConfigurationException} and thrown,\r\n * allowing it to propagate to the caller.\r\n * <p>Otherwise, this method does nothing.\r\n * @param ex the throwable to inspect\r\n */\r\nstatic void rethrowAnnotationConfigurationException(Throwable ex) {\r\n    if (ex instanceof AnnotationConfigurationException exception) {\r\n        throw exception;\r\n    }\r\n}",
    "comment": "\n\t * If the supplied throwable is an {@link AnnotationConfigurationException},\n\t * it will be cast to an {@code AnnotationConfigurationException} and thrown,\n\t * allowing it to propagate to the caller.\n\t * <p>Otherwise, this method does nothing.\n\t * @param ex the throwable to inspect\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#handleIntrospectionFailure(AnnotatedElement,Throwable)",
    "entityType": "method",
    "code": "/**\r\n * Handle the supplied annotation introspection exception.\r\n * <p>If the supplied exception is an {@link AnnotationConfigurationException},\r\n * it will simply be thrown, allowing it to propagate to the caller, and\r\n * nothing will be logged.\r\n * <p>Otherwise, this method logs an introspection failure (in particular for\r\n * a {@link TypeNotPresentException}) before moving on, assuming nested\r\n * {@code Class} values were not resolvable within annotation attributes and\r\n * thereby effectively pretending there were no annotations on the specified\r\n * element.\r\n * @param element the element that we tried to introspect annotations on\r\n * @param ex the exception that we encountered\r\n * @see #rethrowAnnotationConfigurationException\r\n * @see IntrospectionFailureLogger\r\n */\r\nstatic void handleIntrospectionFailure(AnnotatedElement element, Throwable ex) {\r\n    rethrowAnnotationConfigurationException(ex);\r\n    IntrospectionFailureLogger logger = IntrospectionFailureLogger.INFO;\r\n    boolean meta = false;\r\n    if (element instanceof Class<?> clazz && Annotation.class.isAssignableFrom(clazz)) {\r\n        // Meta-annotation introspection failure\r\n        logger = IntrospectionFailureLogger.DEBUG;\r\n        meta = true;\r\n    }\r\n    if (logger.isEnabled()) {\r\n        logger.log(\"Failed to \" + (meta ? \"meta-introspect annotation \" : \"introspect annotations on \") + element + \": \" + ex);\r\n    }\r\n}",
    "comment": "\n\t * Handle the supplied annotation introspection exception.\n\t * <p>If the supplied exception is an {@link AnnotationConfigurationException},\n\t * it will simply be thrown, allowing it to propagate to the caller, and\n\t * nothing will be logged.\n\t * <p>Otherwise, this method logs an introspection failure (in particular for\n\t * a {@link TypeNotPresentException}) before moving on, assuming nested\n\t * {@code Class} values were not resolvable within annotation attributes and\n\t * thereby effectively pretending there were no annotations on the specified\n\t * element.\n\t * @param element the element that we tried to introspect annotations on\n\t * @param ex the exception that we encountered\n\t * @see #rethrowAnnotationConfigurationException\n\t * @see IntrospectionFailureLogger\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#handleValueRetrievalFailure(Annotation,Throwable)",
    "entityType": "method",
    "code": "/**\r\n * Handle the supplied value retrieval exception.\r\n * @param annotation the annotation instance from which to retrieve the value\r\n * @param ex the exception that we encountered\r\n * @see #handleIntrospectionFailure\r\n */\r\nprivate static void handleValueRetrievalFailure(Annotation annotation, Throwable ex) {\r\n    rethrowAnnotationConfigurationException(ex);\r\n    IntrospectionFailureLogger logger = IntrospectionFailureLogger.INFO;\r\n    if (logger.isEnabled()) {\r\n        logger.log(\"Failed to retrieve value from \" + annotation + \": \" + ex);\r\n    }\r\n}",
    "comment": "\n\t * Handle the supplied value retrieval exception.\n\t * @param annotation the annotation instance from which to retrieve the value\n\t * @param ex the exception that we encountered\n\t * @see #handleIntrospectionFailure\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#getDefaultValue(Annotation)",
    "entityType": "method",
    "code": "/**\r\n * Retrieve the <em>default value</em> of the {@code value} attribute\r\n * of a single-element Annotation, given an annotation instance.\r\n * @param annotation the annotation instance from which to retrieve the default value\r\n * @return the default value, or {@code null} if not found\r\n * @see #getDefaultValue(Annotation, String)\r\n */\r\n@Nullable\r\npublic static Object getDefaultValue(Annotation annotation) {\r\n    return getDefaultValue(annotation, VALUE);\r\n}",
    "comment": "\n\t * Retrieve the <em>default value</em> of the {@code value} attribute\n\t * of a single-element Annotation, given an annotation instance.\n\t * @param annotation the annotation instance from which to retrieve the default value\n\t * @return the default value, or {@code null} if not found\n\t * @see #getDefaultValue(Annotation, String)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#getDefaultValue(Annotation,String)",
    "entityType": "method",
    "code": "/**\r\n * Retrieve the <em>default value</em> of a named attribute, given an annotation instance.\r\n * @param annotation the annotation instance from which to retrieve the default value\r\n * @param attributeName the name of the attribute value to retrieve\r\n * @return the default value of the named attribute, or {@code null} if not found\r\n * @see #getDefaultValue(Class, String)\r\n */\r\n@Nullable\r\npublic static Object getDefaultValue(@Nullable Annotation annotation, @Nullable String attributeName) {\r\n    return (annotation != null ? getDefaultValue(annotation.annotationType(), attributeName) : null);\r\n}",
    "comment": "\n\t * Retrieve the <em>default value</em> of a named attribute, given an annotation instance.\n\t * @param annotation the annotation instance from which to retrieve the default value\n\t * @param attributeName the name of the attribute value to retrieve\n\t * @return the default value of the named attribute, or {@code null} if not found\n\t * @see #getDefaultValue(Class, String)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#getDefaultValue(Class<? extends Annotation>)",
    "entityType": "method",
    "code": "/**\r\n * Retrieve the <em>default value</em> of the {@code value} attribute\r\n * of a single-element Annotation, given the {@link Class annotation type}.\r\n * @param annotationType the <em>annotation type</em> for which the default value should be retrieved\r\n * @return the default value, or {@code null} if not found\r\n * @see #getDefaultValue(Class, String)\r\n */\r\n@Nullable\r\npublic static Object getDefaultValue(Class<? extends Annotation> annotationType) {\r\n    return getDefaultValue(annotationType, VALUE);\r\n}",
    "comment": "\n\t * Retrieve the <em>default value</em> of the {@code value} attribute\n\t * of a single-element Annotation, given the {@link Class annotation type}.\n\t * @param annotationType the <em>annotation type</em> for which the default value should be retrieved\n\t * @return the default value, or {@code null} if not found\n\t * @see #getDefaultValue(Class, String)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#getDefaultValue(Class<? extends Annotation>,String)",
    "entityType": "method",
    "code": "/**\r\n * Retrieve the <em>default value</em> of a named attribute, given the\r\n * {@link Class annotation type}.\r\n * @param annotationType the <em>annotation type</em> for which the default value should be retrieved\r\n * @param attributeName the name of the attribute value to retrieve.\r\n * @return the default value of the named attribute, or {@code null} if not found\r\n * @see #getDefaultValue(Annotation, String)\r\n */\r\n@Nullable\r\npublic static Object getDefaultValue(@Nullable Class<? extends Annotation> annotationType, @Nullable String attributeName) {\r\n    if (annotationType == null || !StringUtils.hasText(attributeName)) {\r\n        return null;\r\n    }\r\n    return MergedAnnotation.of(annotationType).getDefaultValue(attributeName).orElse(null);\r\n}",
    "comment": "\n\t * Retrieve the <em>default value</em> of a named attribute, given the\n\t * {@link Class annotation type}.\n\t * @param annotationType the <em>annotation type</em> for which the default value should be retrieved\n\t * @param attributeName the name of the attribute value to retrieve.\n\t * @return the default value of the named attribute, or {@code null} if not found\n\t * @see #getDefaultValue(Annotation, String)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#synthesizeAnnotation(A,AnnotatedElement)",
    "entityType": "method",
    "code": "/**\r\n * <em>Synthesize</em> an annotation from the supplied {@code annotation}\r\n * by wrapping it in a dynamic proxy that transparently enforces\r\n * <em>attribute alias</em> semantics for annotation attributes that are\r\n * annotated with {@link AliasFor @AliasFor}.\r\n * @param annotation the annotation to synthesize\r\n * @param annotatedElement the element that is annotated with the supplied\r\n * annotation; may be {@code null} if unknown\r\n * @return the synthesized annotation if the supplied annotation is\r\n * <em>synthesizable</em>; {@code null} if the supplied annotation is\r\n * {@code null}; otherwise the supplied annotation unmodified\r\n * @throws AnnotationConfigurationException if invalid configuration of\r\n * {@code @AliasFor} is detected\r\n * @since 4.2\r\n * @see #synthesizeAnnotation(Map, Class, AnnotatedElement)\r\n * @see #synthesizeAnnotation(Class)\r\n */\r\npublic static <A extends Annotation> A synthesizeAnnotation(A annotation, @Nullable AnnotatedElement annotatedElement) {\r\n    if (isSynthesizedAnnotation(annotation) || AnnotationFilter.PLAIN.matches(annotation)) {\r\n        return annotation;\r\n    }\r\n    return MergedAnnotation.from(annotatedElement, annotation).synthesize();\r\n}",
    "comment": "\n\t * <em>Synthesize</em> an annotation from the supplied {@code annotation}\n\t * by wrapping it in a dynamic proxy that transparently enforces\n\t * <em>attribute alias</em> semantics for annotation attributes that are\n\t * annotated with {@link AliasFor @AliasFor}.\n\t * @param annotation the annotation to synthesize\n\t * @param annotatedElement the element that is annotated with the supplied\n\t * annotation; may be {@code null} if unknown\n\t * @return the synthesized annotation if the supplied annotation is\n\t * <em>synthesizable</em>; {@code null} if the supplied annotation is\n\t * {@code null}; otherwise the supplied annotation unmodified\n\t * @throws AnnotationConfigurationException if invalid configuration of\n\t * {@code @AliasFor} is detected\n\t * @since 4.2\n\t * @see #synthesizeAnnotation(Map, Class, AnnotatedElement)\n\t * @see #synthesizeAnnotation(Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#synthesizeAnnotation(Class<A>)",
    "entityType": "method",
    "code": "/**\r\n * <em>Synthesize</em> an annotation from its default attributes values.\r\n * <p>This method simply delegates to\r\n * {@link #synthesizeAnnotation(Map, Class, AnnotatedElement)},\r\n * supplying an empty map for the source attribute values and {@code null}\r\n * for the {@link AnnotatedElement}.\r\n * @param annotationType the type of annotation to synthesize\r\n * @return the synthesized annotation\r\n * @throws IllegalArgumentException if a required attribute is missing\r\n * @throws AnnotationConfigurationException if invalid configuration of\r\n * {@code @AliasFor} is detected\r\n * @since 4.2\r\n * @see #synthesizeAnnotation(Map, Class, AnnotatedElement)\r\n * @see #synthesizeAnnotation(Annotation, AnnotatedElement)\r\n */\r\npublic static <A extends Annotation> A synthesizeAnnotation(Class<A> annotationType) {\r\n    return synthesizeAnnotation(Collections.emptyMap(), annotationType, null);\r\n}",
    "comment": "\n\t * <em>Synthesize</em> an annotation from its default attributes values.\n\t * <p>This method simply delegates to\n\t * {@link #synthesizeAnnotation(Map, Class, AnnotatedElement)},\n\t * supplying an empty map for the source attribute values and {@code null}\n\t * for the {@link AnnotatedElement}.\n\t * @param annotationType the type of annotation to synthesize\n\t * @return the synthesized annotation\n\t * @throws IllegalArgumentException if a required attribute is missing\n\t * @throws AnnotationConfigurationException if invalid configuration of\n\t * {@code @AliasFor} is detected\n\t * @since 4.2\n\t * @see #synthesizeAnnotation(Map, Class, AnnotatedElement)\n\t * @see #synthesizeAnnotation(Annotation, AnnotatedElement)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#synthesizeAnnotation(Map<String,Object>,Class<A>,AnnotatedElement)",
    "entityType": "method",
    "code": "/**\r\n * <em>Synthesize</em> an annotation from the supplied map of annotation\r\n * attributes by wrapping the map in a dynamic proxy that implements an\r\n * annotation of the specified {@code annotationType} and transparently\r\n * enforces <em>attribute alias</em> semantics for annotation attributes\r\n * that are annotated with {@link AliasFor @AliasFor}.\r\n * <p>The supplied map must contain a key-value pair for every attribute\r\n * defined in the supplied {@code annotationType} that is not aliased or\r\n * does not have a default value. Nested maps and nested arrays of maps\r\n * will be recursively synthesized into nested annotations or nested\r\n * arrays of annotations, respectively.\r\n * <p>Note that {@link AnnotationAttributes} is a specialized type of\r\n * {@link Map} that is an ideal candidate for this method's\r\n * {@code attributes} argument.\r\n * @param attributes the map of annotation attributes to synthesize\r\n * @param annotationType the type of annotation to synthesize\r\n * @param annotatedElement the element that is annotated with the annotation\r\n * corresponding to the supplied attributes; may be {@code null} if unknown\r\n * @return the synthesized annotation\r\n * @throws IllegalArgumentException if a required attribute is missing or if an\r\n * attribute is not of the correct type\r\n * @throws AnnotationConfigurationException if invalid configuration of\r\n * {@code @AliasFor} is detected\r\n * @since 4.2\r\n * @see #synthesizeAnnotation(Annotation, AnnotatedElement)\r\n * @see #synthesizeAnnotation(Class)\r\n * @see #getAnnotationAttributes(AnnotatedElement, Annotation)\r\n * @see #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)\r\n */\r\npublic static <A extends Annotation> A synthesizeAnnotation(Map<String, Object> attributes, Class<A> annotationType, @Nullable AnnotatedElement annotatedElement) {\r\n    try {\r\n        return MergedAnnotation.of(annotatedElement, annotationType, attributes).synthesize();\r\n    } catch (NoSuchElementException | IllegalStateException ex) {\r\n        throw new IllegalArgumentException(ex);\r\n    }\r\n}",
    "comment": "\n\t * <em>Synthesize</em> an annotation from the supplied map of annotation\n\t * attributes by wrapping the map in a dynamic proxy that implements an\n\t * annotation of the specified {@code annotationType} and transparently\n\t * enforces <em>attribute alias</em> semantics for annotation attributes\n\t * that are annotated with {@link AliasFor @AliasFor}.\n\t * <p>The supplied map must contain a key-value pair for every attribute\n\t * defined in the supplied {@code annotationType} that is not aliased or\n\t * does not have a default value. Nested maps and nested arrays of maps\n\t * will be recursively synthesized into nested annotations or nested\n\t * arrays of annotations, respectively.\n\t * <p>Note that {@link AnnotationAttributes} is a specialized type of\n\t * {@link Map} that is an ideal candidate for this method's\n\t * {@code attributes} argument.\n\t * @param attributes the map of annotation attributes to synthesize\n\t * @param annotationType the type of annotation to synthesize\n\t * @param annotatedElement the element that is annotated with the annotation\n\t * corresponding to the supplied attributes; may be {@code null} if unknown\n\t * @return the synthesized annotation\n\t * @throws IllegalArgumentException if a required attribute is missing or if an\n\t * attribute is not of the correct type\n\t * @throws AnnotationConfigurationException if invalid configuration of\n\t * {@code @AliasFor} is detected\n\t * @since 4.2\n\t * @see #synthesizeAnnotation(Annotation, AnnotatedElement)\n\t * @see #synthesizeAnnotation(Class)\n\t * @see #getAnnotationAttributes(AnnotatedElement, Annotation)\n\t * @see #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#synthesizeAnnotationArray(Annotation[],AnnotatedElement)",
    "entityType": "method",
    "code": "/**\r\n * <em>Synthesize</em> an array of annotations from the supplied array\r\n * of {@code annotations} by creating a new array of the same size and\r\n * type and populating it with {@linkplain #synthesizeAnnotation(Annotation,\r\n * AnnotatedElement) synthesized} versions of the annotations from the input\r\n * array.\r\n * @param annotations the array of annotations to synthesize\r\n * @param annotatedElement the element that is annotated with the supplied\r\n * array of annotations; may be {@code null} if unknown\r\n * @return a new array of synthesized annotations, or {@code null} if\r\n * the supplied array is {@code null}\r\n * @throws AnnotationConfigurationException if invalid configuration of\r\n * {@code @AliasFor} is detected\r\n * @since 4.2\r\n * @see #synthesizeAnnotation(Annotation, AnnotatedElement)\r\n * @see #synthesizeAnnotation(Map, Class, AnnotatedElement)\r\n */\r\nstatic Annotation[] synthesizeAnnotationArray(Annotation[] annotations, AnnotatedElement annotatedElement) {\r\n    if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) {\r\n        return annotations;\r\n    }\r\n    Annotation[] synthesized = (Annotation[]) Array.newInstance(annotations.getClass().componentType(), annotations.length);\r\n    for (int i = 0; i < annotations.length; i++) {\r\n        synthesized[i] = synthesizeAnnotation(annotations[i], annotatedElement);\r\n    }\r\n    return synthesized;\r\n}",
    "comment": "\n\t * <em>Synthesize</em> an array of annotations from the supplied array\n\t * of {@code annotations} by creating a new array of the same size and\n\t * type and populating it with {@linkplain #synthesizeAnnotation(Annotation,\n\t * AnnotatedElement) synthesized} versions of the annotations from the input\n\t * array.\n\t * @param annotations the array of annotations to synthesize\n\t * @param annotatedElement the element that is annotated with the supplied\n\t * array of annotations; may be {@code null} if unknown\n\t * @return a new array of synthesized annotations, or {@code null} if\n\t * the supplied array is {@code null}\n\t * @throws AnnotationConfigurationException if invalid configuration of\n\t * {@code @AliasFor} is detected\n\t * @since 4.2\n\t * @see #synthesizeAnnotation(Annotation, AnnotatedElement)\n\t * @see #synthesizeAnnotation(Map, Class, AnnotatedElement)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#isSynthesizedAnnotation(Annotation)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the supplied {@link Annotation} has been <em>synthesized</em>\r\n * by Spring (i.e. wrapped in a dynamic proxy) with additional functionality\r\n * such as attribute alias handling.\r\n * @param annotation the annotation to check\r\n * @return {@code true} if the supplied annotation is a synthesized annotation\r\n * @since 5.3.23\r\n */\r\npublic static boolean isSynthesizedAnnotation(@Nullable Annotation annotation) {\r\n    try {\r\n        return (annotation != null && Proxy.isProxyClass(annotation.getClass()) && Proxy.getInvocationHandler(annotation) instanceof SynthesizedMergedAnnotationInvocationHandler);\r\n    } catch (SecurityException ex) {\r\n        // Security settings disallow reflective access to the InvocationHandler:\r\n        // assume the annotation has not been synthesized by Spring.\r\n        return false;\r\n    }\r\n}",
    "comment": "\n\t * Determine if the supplied {@link Annotation} has been <em>synthesized</em>\n\t * by Spring (i.e. wrapped in a dynamic proxy) with additional functionality\n\t * such as attribute alias handling.\n\t * @param annotation the annotation to check\n\t * @return {@code true} if the supplied annotation is a synthesized annotation\n\t * @since 5.3.23\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#clearCache()",
    "entityType": "method",
    "code": "/**\r\n * Clear the internal annotation metadata cache.\r\n * @since 4.3.15\r\n */\r\npublic static void clearCache() {\r\n    AnnotationTypeMappings.clearCache();\r\n    AnnotationsScanner.clearCache();\r\n    AttributeMethods.cache.clear();\r\n    RepeatableContainers.cache.clear();\r\n    OrderUtils.orderCache.clear();\r\n}",
    "comment": "\n\t * Clear the internal annotation metadata cache.\n\t * @since 4.3.15\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.DefaultValueHolder",
    "entityType": "class",
    "code": "final Object defaultValue;\npublic DefaultValueHolder(Object defaultValue) {\r\n    this.defaultValue = defaultValue;\r\n}\n@Override\r\npublic String toString() {\r\n    return \"*\" + this.defaultValue;\r\n}",
    "comment": "\n\t * Internal holder used to wrap default values.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.DefaultValueHolder#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return \"*\" + this.defaultValue;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethods",
    "entityType": "class",
    "code": "static final AttributeMethods NONE = new AttributeMethods(null, new Method[0]);\nstatic final Map<Class<? extends Annotation>, AttributeMethods> cache = new ConcurrentReferenceHashMap<>();\nprivate static final Comparator<Method> methodComparator = (m1, m2) -> {\r\n    if (m1 != null && m2 != null) {\r\n        return m1.getName().compareTo(m2.getName());\r\n    }\r\n    return (m1 != null ? -1 : 1);\r\n};\n@Nullable\r\nprivate final Class<? extends Annotation> annotationType;\nprivate final Method[] attributeMethods;\nprivate final boolean[] canThrowTypeNotPresentException;\nprivate final boolean hasDefaultValueMethod;\nprivate final boolean hasNestedAnnotation;\nprivate AttributeMethods(@Nullable Class<? extends Annotation> annotationType, Method[] attributeMethods) {\r\n    this.annotationType = annotationType;\r\n    this.attributeMethods = attributeMethods;\r\n    this.canThrowTypeNotPresentException = new boolean[attributeMethods.length];\r\n    boolean foundDefaultValueMethod = false;\r\n    boolean foundNestedAnnotation = false;\r\n    for (int i = 0; i < attributeMethods.length; i++) {\r\n        Method method = this.attributeMethods[i];\r\n        Class<?> type = method.getReturnType();\r\n        if (!foundDefaultValueMethod && (method.getDefaultValue() != null)) {\r\n            foundDefaultValueMethod = true;\r\n        }\r\n        if (!foundNestedAnnotation && (type.isAnnotation() || (type.isArray() && type.componentType().isAnnotation()))) {\r\n            foundNestedAnnotation = true;\r\n        }\r\n        ReflectionUtils.makeAccessible(method);\r\n        this.canThrowTypeNotPresentException[i] = (type == Class.class || type == Class[].class || type.isEnum());\r\n    }\r\n    this.hasDefaultValueMethod = foundDefaultValueMethod;\r\n    this.hasNestedAnnotation = foundNestedAnnotation;\r\n}\n/**\r\n * Determine if values from the given annotation can be safely accessed without\r\n * causing any {@link TypeNotPresentException TypeNotPresentExceptions}.\r\n * <p>This method is designed to cover Google App Engine's late arrival of such\r\n * exceptions for {@code Class} values (instead of the more typical early\r\n * {@code Class.getAnnotations() failure} on a regular JVM).\r\n * @param annotation the annotation to check\r\n * @return {@code true} if all values are present\r\n * @see #validate(Annotation)\r\n */\r\nboolean canLoad(Annotation annotation) {\r\n    assertAnnotation(annotation);\r\n    for (int i = 0; i < size(); i++) {\r\n        if (canThrowTypeNotPresentException(i)) {\r\n            try {\r\n                AnnotationUtils.invokeAnnotationMethod(get(i), annotation);\r\n            } catch (IllegalStateException ex) {\r\n                // Plain invocation failure to expose -> leave up to attribute retrieval\r\n                // (if any) where such invocation failure will be logged eventually.\r\n            } catch (Throwable ex) {\r\n                // TypeNotPresentException etc. -> annotation type not actually loadable.\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\n/**\r\n * Check if values from the given annotation can be safely accessed without causing\r\n * any {@link TypeNotPresentException TypeNotPresentExceptions}.\r\n * <p>This method is designed to cover Google App Engine's late arrival of such\r\n * exceptions for {@code Class} values (instead of the more typical early\r\n * {@code Class.getAnnotations() failure} on a regular JVM).\r\n * @param annotation the annotation to validate\r\n * @throws IllegalStateException if a declared {@code Class} attribute could not be read\r\n * @see #canLoad(Annotation)\r\n */\r\nvoid validate(Annotation annotation) {\r\n    assertAnnotation(annotation);\r\n    for (int i = 0; i < size(); i++) {\r\n        if (canThrowTypeNotPresentException(i)) {\r\n            try {\r\n                AnnotationUtils.invokeAnnotationMethod(get(i), annotation);\r\n            } catch (IllegalStateException ex) {\r\n                throw ex;\r\n            } catch (Throwable ex) {\r\n                throw new IllegalStateException(\"Could not obtain annotation attribute value for \" + get(i).getName() + \" declared on @\" + getName(annotation.annotationType()), ex);\r\n            }\r\n        }\r\n    }\r\n}\nprivate void assertAnnotation(Annotation annotation) {\r\n    Assert.notNull(annotation, \"Annotation must not be null\");\r\n    if (this.annotationType != null) {\r\n        Assert.isInstanceOf(this.annotationType, annotation);\r\n    }\r\n}\n/**\r\n * Get the attribute with the specified name or {@code null} if no\r\n * matching attribute exists.\r\n * @param name the attribute name to find\r\n * @return the attribute method or {@code null}\r\n */\r\n@Nullable\r\nMethod get(String name) {\r\n    int index = indexOf(name);\r\n    return (index != -1 ? this.attributeMethods[index] : null);\r\n}\n/**\r\n * Get the attribute at the specified index.\r\n * @param index the index of the attribute to return\r\n * @return the attribute method\r\n * @throws IndexOutOfBoundsException if the index is out of range\r\n * ({@code index < 0 || index >= size()})\r\n */\r\nMethod get(int index) {\r\n    return this.attributeMethods[index];\r\n}\n/**\r\n * Determine if the attribute at the specified index could throw a\r\n * {@link TypeNotPresentException} when accessed.\r\n * @param index the index of the attribute to check\r\n * @return {@code true} if the attribute can throw a\r\n * {@link TypeNotPresentException}\r\n */\r\nboolean canThrowTypeNotPresentException(int index) {\r\n    return this.canThrowTypeNotPresentException[index];\r\n}\n/**\r\n * Get the index of the attribute with the specified name, or {@code -1}\r\n * if there is no attribute with the name.\r\n * @param name the name to find\r\n * @return the index of the attribute, or {@code -1}\r\n */\r\nint indexOf(String name) {\r\n    for (int i = 0; i < this.attributeMethods.length; i++) {\r\n        if (this.attributeMethods[i].getName().equals(name)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\n/**\r\n * Get the index of the specified attribute, or {@code -1} if the\r\n * attribute is not in this collection.\r\n * @param attribute the attribute to find\r\n * @return the index of the attribute, or {@code -1}\r\n */\r\nint indexOf(Method attribute) {\r\n    for (int i = 0; i < this.attributeMethods.length; i++) {\r\n        if (this.attributeMethods[i].equals(attribute)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\n/**\r\n * Get the number of attributes in this collection.\r\n * @return the number of attributes\r\n */\r\nint size() {\r\n    return this.attributeMethods.length;\r\n}\n/**\r\n * Determine if at least one of the attribute methods has a default value.\r\n * @return {@code true} if there is at least one attribute method with a default value\r\n */\r\nboolean hasDefaultValueMethod() {\r\n    return this.hasDefaultValueMethod;\r\n}\n/**\r\n * Determine if at least one of the attribute methods is a nested annotation.\r\n * @return {@code true} if there is at least one attribute method with a nested\r\n * annotation type\r\n */\r\nboolean hasNestedAnnotation() {\r\n    return this.hasNestedAnnotation;\r\n}\n/**\r\n * Get the attribute methods for the given annotation type.\r\n * @param annotationType the annotation type\r\n * @return the attribute methods for the annotation type\r\n */\r\nstatic AttributeMethods forAnnotationType(@Nullable Class<? extends Annotation> annotationType) {\r\n    if (annotationType == null) {\r\n        return NONE;\r\n    }\r\n    return cache.computeIfAbsent(annotationType, AttributeMethods::compute);\r\n}\n// Dataflow analysis limitation\r\n@SuppressWarnings(\"NullAway\")\r\nprivate static AttributeMethods compute(Class<? extends Annotation> annotationType) {\r\n    Method[] methods = annotationType.getDeclaredMethods();\r\n    int size = methods.length;\r\n    for (int i = 0; i < methods.length; i++) {\r\n        if (!isAttributeMethod(methods[i])) {\r\n            //noinspection DataFlowIssue\r\n            methods[i] = null;\r\n            size--;\r\n        }\r\n    }\r\n    if (size == 0) {\r\n        return NONE;\r\n    }\r\n    Arrays.sort(methods, methodComparator);\r\n    Method[] attributeMethods = Arrays.copyOf(methods, size);\r\n    return new AttributeMethods(annotationType, attributeMethods);\r\n}\nprivate static boolean isAttributeMethod(Method method) {\r\n    return (method.getParameterCount() == 0 && method.getReturnType() != void.class);\r\n}\n/**\r\n * Create a description for the given attribute method suitable to use in\r\n * exception messages and logs.\r\n * @param attribute the attribute to describe\r\n * @return a description of the attribute\r\n */\r\nstatic String describe(@Nullable Method attribute) {\r\n    if (attribute == null) {\r\n        return \"(none)\";\r\n    }\r\n    return describe(attribute.getDeclaringClass(), attribute.getName());\r\n}\n/**\r\n * Create a description for the given attribute method suitable to use in\r\n * exception messages and logs.\r\n * @param annotationType the annotation type\r\n * @param attributeName the attribute name\r\n * @return a description of the attribute\r\n */\r\nstatic String describe(@Nullable Class<?> annotationType, @Nullable String attributeName) {\r\n    if (attributeName == null) {\r\n        return \"(none)\";\r\n    }\r\n    String in = (annotationType != null ? \" in annotation [\" + annotationType.getName() + \"]\" : \"\");\r\n    return \"attribute '\" + attributeName + \"'\" + in;\r\n}\nprivate static String getName(Class<?> clazz) {\r\n    String canonicalName = clazz.getCanonicalName();\r\n    return (canonicalName != null ? canonicalName : clazz.getName());\r\n}",
    "comment": "\n * Provides a quick way to access the attribute methods of an {@link Annotation}\n * with consistent ordering as well as a few useful utility methods.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n * @since 5.2\n "
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethods#canLoad(Annotation)",
    "entityType": "method",
    "code": "/**\r\n * Determine if values from the given annotation can be safely accessed without\r\n * causing any {@link TypeNotPresentException TypeNotPresentExceptions}.\r\n * <p>This method is designed to cover Google App Engine's late arrival of such\r\n * exceptions for {@code Class} values (instead of the more typical early\r\n * {@code Class.getAnnotations() failure} on a regular JVM).\r\n * @param annotation the annotation to check\r\n * @return {@code true} if all values are present\r\n * @see #validate(Annotation)\r\n */\r\nboolean canLoad(Annotation annotation) {\r\n    assertAnnotation(annotation);\r\n    for (int i = 0; i < size(); i++) {\r\n        if (canThrowTypeNotPresentException(i)) {\r\n            try {\r\n                AnnotationUtils.invokeAnnotationMethod(get(i), annotation);\r\n            } catch (IllegalStateException ex) {\r\n                // Plain invocation failure to expose -> leave up to attribute retrieval\r\n                // (if any) where such invocation failure will be logged eventually.\r\n            } catch (Throwable ex) {\r\n                // TypeNotPresentException etc. -> annotation type not actually loadable.\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}",
    "comment": "\n\t * Determine if values from the given annotation can be safely accessed without\n\t * causing any {@link TypeNotPresentException TypeNotPresentExceptions}.\n\t * <p>This method is designed to cover Google App Engine's late arrival of such\n\t * exceptions for {@code Class} values (instead of the more typical early\n\t * {@code Class.getAnnotations() failure} on a regular JVM).\n\t * @param annotation the annotation to check\n\t * @return {@code true} if all values are present\n\t * @see #validate(Annotation)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethods#validate(Annotation)",
    "entityType": "method",
    "code": "/**\r\n * Check if values from the given annotation can be safely accessed without causing\r\n * any {@link TypeNotPresentException TypeNotPresentExceptions}.\r\n * <p>This method is designed to cover Google App Engine's late arrival of such\r\n * exceptions for {@code Class} values (instead of the more typical early\r\n * {@code Class.getAnnotations() failure} on a regular JVM).\r\n * @param annotation the annotation to validate\r\n * @throws IllegalStateException if a declared {@code Class} attribute could not be read\r\n * @see #canLoad(Annotation)\r\n */\r\nvoid validate(Annotation annotation) {\r\n    assertAnnotation(annotation);\r\n    for (int i = 0; i < size(); i++) {\r\n        if (canThrowTypeNotPresentException(i)) {\r\n            try {\r\n                AnnotationUtils.invokeAnnotationMethod(get(i), annotation);\r\n            } catch (IllegalStateException ex) {\r\n                throw ex;\r\n            } catch (Throwable ex) {\r\n                throw new IllegalStateException(\"Could not obtain annotation attribute value for \" + get(i).getName() + \" declared on @\" + getName(annotation.annotationType()), ex);\r\n            }\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Check if values from the given annotation can be safely accessed without causing\n\t * any {@link TypeNotPresentException TypeNotPresentExceptions}.\n\t * <p>This method is designed to cover Google App Engine's late arrival of such\n\t * exceptions for {@code Class} values (instead of the more typical early\n\t * {@code Class.getAnnotations() failure} on a regular JVM).\n\t * @param annotation the annotation to validate\n\t * @throws IllegalStateException if a declared {@code Class} attribute could not be read\n\t * @see #canLoad(Annotation)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethods#assertAnnotation(Annotation)",
    "entityType": "method",
    "code": "private void assertAnnotation(Annotation annotation) {\r\n    Assert.notNull(annotation, \"Annotation must not be null\");\r\n    if (this.annotationType != null) {\r\n        Assert.isInstanceOf(this.annotationType, annotation);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethods#get(String)",
    "entityType": "method",
    "code": "/**\r\n * Get the attribute with the specified name or {@code null} if no\r\n * matching attribute exists.\r\n * @param name the attribute name to find\r\n * @return the attribute method or {@code null}\r\n */\r\n@Nullable\r\nMethod get(String name) {\r\n    int index = indexOf(name);\r\n    return (index != -1 ? this.attributeMethods[index] : null);\r\n}",
    "comment": "\n\t * Get the attribute with the specified name or {@code null} if no\n\t * matching attribute exists.\n\t * @param name the attribute name to find\n\t * @return the attribute method or {@code null}\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethods#get(int)",
    "entityType": "method",
    "code": "/**\r\n * Get the attribute at the specified index.\r\n * @param index the index of the attribute to return\r\n * @return the attribute method\r\n * @throws IndexOutOfBoundsException if the index is out of range\r\n * ({@code index < 0 || index >= size()})\r\n */\r\nMethod get(int index) {\r\n    return this.attributeMethods[index];\r\n}",
    "comment": "\n\t * Get the attribute at the specified index.\n\t * @param index the index of the attribute to return\n\t * @return the attribute method\n\t * @throws IndexOutOfBoundsException if the index is out of range\n\t * ({@code index < 0 || index >= size()})\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethods#canThrowTypeNotPresentException(int)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the attribute at the specified index could throw a\r\n * {@link TypeNotPresentException} when accessed.\r\n * @param index the index of the attribute to check\r\n * @return {@code true} if the attribute can throw a\r\n * {@link TypeNotPresentException}\r\n */\r\nboolean canThrowTypeNotPresentException(int index) {\r\n    return this.canThrowTypeNotPresentException[index];\r\n}",
    "comment": "\n\t * Determine if the attribute at the specified index could throw a\n\t * {@link TypeNotPresentException} when accessed.\n\t * @param index the index of the attribute to check\n\t * @return {@code true} if the attribute can throw a\n\t * {@link TypeNotPresentException}\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethods#indexOf(String)",
    "entityType": "method",
    "code": "/**\r\n * Get the index of the attribute with the specified name, or {@code -1}\r\n * if there is no attribute with the name.\r\n * @param name the name to find\r\n * @return the index of the attribute, or {@code -1}\r\n */\r\nint indexOf(String name) {\r\n    for (int i = 0; i < this.attributeMethods.length; i++) {\r\n        if (this.attributeMethods[i].getName().equals(name)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}",
    "comment": "\n\t * Get the index of the attribute with the specified name, or {@code -1}\n\t * if there is no attribute with the name.\n\t * @param name the name to find\n\t * @return the index of the attribute, or {@code -1}\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethods#indexOf(Method)",
    "entityType": "method",
    "code": "/**\r\n * Get the index of the specified attribute, or {@code -1} if the\r\n * attribute is not in this collection.\r\n * @param attribute the attribute to find\r\n * @return the index of the attribute, or {@code -1}\r\n */\r\nint indexOf(Method attribute) {\r\n    for (int i = 0; i < this.attributeMethods.length; i++) {\r\n        if (this.attributeMethods[i].equals(attribute)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}",
    "comment": "\n\t * Get the index of the specified attribute, or {@code -1} if the\n\t * attribute is not in this collection.\n\t * @param attribute the attribute to find\n\t * @return the index of the attribute, or {@code -1}\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethods#size()",
    "entityType": "method",
    "code": "/**\r\n * Get the number of attributes in this collection.\r\n * @return the number of attributes\r\n */\r\nint size() {\r\n    return this.attributeMethods.length;\r\n}",
    "comment": "\n\t * Get the number of attributes in this collection.\n\t * @return the number of attributes\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethods#hasDefaultValueMethod()",
    "entityType": "method",
    "code": "/**\r\n * Determine if at least one of the attribute methods has a default value.\r\n * @return {@code true} if there is at least one attribute method with a default value\r\n */\r\nboolean hasDefaultValueMethod() {\r\n    return this.hasDefaultValueMethod;\r\n}",
    "comment": "\n\t * Determine if at least one of the attribute methods has a default value.\n\t * @return {@code true} if there is at least one attribute method with a default value\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethods#hasNestedAnnotation()",
    "entityType": "method",
    "code": "/**\r\n * Determine if at least one of the attribute methods is a nested annotation.\r\n * @return {@code true} if there is at least one attribute method with a nested\r\n * annotation type\r\n */\r\nboolean hasNestedAnnotation() {\r\n    return this.hasNestedAnnotation;\r\n}",
    "comment": "\n\t * Determine if at least one of the attribute methods is a nested annotation.\n\t * @return {@code true} if there is at least one attribute method with a nested\n\t * annotation type\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethods#forAnnotationType(Class<? extends Annotation>)",
    "entityType": "method",
    "code": "/**\r\n * Get the attribute methods for the given annotation type.\r\n * @param annotationType the annotation type\r\n * @return the attribute methods for the annotation type\r\n */\r\nstatic AttributeMethods forAnnotationType(@Nullable Class<? extends Annotation> annotationType) {\r\n    if (annotationType == null) {\r\n        return NONE;\r\n    }\r\n    return cache.computeIfAbsent(annotationType, AttributeMethods::compute);\r\n}",
    "comment": "\n\t * Get the attribute methods for the given annotation type.\n\t * @param annotationType the annotation type\n\t * @return the attribute methods for the annotation type\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethods#compute(Class<? extends Annotation>)",
    "entityType": "method",
    "code": "// Dataflow analysis limitation\r\n@SuppressWarnings(\"NullAway\")\r\nprivate static AttributeMethods compute(Class<? extends Annotation> annotationType) {\r\n    Method[] methods = annotationType.getDeclaredMethods();\r\n    int size = methods.length;\r\n    for (int i = 0; i < methods.length; i++) {\r\n        if (!isAttributeMethod(methods[i])) {\r\n            //noinspection DataFlowIssue\r\n            methods[i] = null;\r\n            size--;\r\n        }\r\n    }\r\n    if (size == 0) {\r\n        return NONE;\r\n    }\r\n    Arrays.sort(methods, methodComparator);\r\n    Method[] attributeMethods = Arrays.copyOf(methods, size);\r\n    return new AttributeMethods(annotationType, attributeMethods);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethods#isAttributeMethod(Method)",
    "entityType": "method",
    "code": "private static boolean isAttributeMethod(Method method) {\r\n    return (method.getParameterCount() == 0 && method.getReturnType() != void.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethods#describe(Method)",
    "entityType": "method",
    "code": "/**\r\n * Create a description for the given attribute method suitable to use in\r\n * exception messages and logs.\r\n * @param attribute the attribute to describe\r\n * @return a description of the attribute\r\n */\r\nstatic String describe(@Nullable Method attribute) {\r\n    if (attribute == null) {\r\n        return \"(none)\";\r\n    }\r\n    return describe(attribute.getDeclaringClass(), attribute.getName());\r\n}",
    "comment": "\n\t * Create a description for the given attribute method suitable to use in\n\t * exception messages and logs.\n\t * @param attribute the attribute to describe\n\t * @return a description of the attribute\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethods#describe(Class<?>,String)",
    "entityType": "method",
    "code": "/**\r\n * Create a description for the given attribute method suitable to use in\r\n * exception messages and logs.\r\n * @param annotationType the annotation type\r\n * @param attributeName the attribute name\r\n * @return a description of the attribute\r\n */\r\nstatic String describe(@Nullable Class<?> annotationType, @Nullable String attributeName) {\r\n    if (attributeName == null) {\r\n        return \"(none)\";\r\n    }\r\n    String in = (annotationType != null ? \" in annotation [\" + annotationType.getName() + \"]\" : \"\");\r\n    return \"attribute '\" + attributeName + \"'\" + in;\r\n}",
    "comment": "\n\t * Create a description for the given attribute method suitable to use in\n\t * exception messages and logs.\n\t * @param annotationType the annotation type\n\t * @param attributeName the attribute name\n\t * @return a description of the attribute\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethods#getName(Class<?>)",
    "entityType": "method",
    "code": "private static String getName(Class<?> clazz) {\r\n    String canonicalName = clazz.getCanonicalName();\r\n    return (canonicalName != null ? canonicalName : clazz.getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation",
    "entityType": "class",
    "code": "/**\r\n * The attribute name for annotations with a single element.\r\n */\r\nString VALUE = \"value\";\n/**\r\n * Get the {@code Class} reference for the actual annotation type.\r\n * @return the annotation type\r\n */\r\nClass<A> getType();\n/**\r\n * Determine if the annotation is present on the source. Considers\r\n * {@linkplain #isDirectlyPresent() directly present} and\r\n * {@linkplain #isMetaPresent() meta-present} annotations within the context\r\n * of the {@link SearchStrategy} used.\r\n * @return {@code true} if the annotation is present\r\n */\r\nboolean isPresent();\n/**\r\n * Determine if the annotation is directly present on the source.\r\n * <p>A directly present annotation is one that the user has explicitly\r\n * declared and not one that is {@linkplain #isMetaPresent() meta-present}\r\n * or {@link Inherited @Inherited}.\r\n * @return {@code true} if the annotation is directly present\r\n */\r\nboolean isDirectlyPresent();\n/**\r\n * Determine if the annotation is meta-present on the source.\r\n * <p>A meta-present annotation is an annotation that the user hasn't\r\n * explicitly declared, but has been used as a meta-annotation somewhere in\r\n * the annotation hierarchy.\r\n * @return {@code true} if the annotation is meta-present\r\n */\r\nboolean isMetaPresent();\n/**\r\n * Get the distance of this annotation related to its use as a\r\n * meta-annotation.\r\n * <p>A directly declared annotation has a distance of {@code 0}, a\r\n * meta-annotation has a distance of {@code 1}, a meta-annotation on a\r\n * meta-annotation has a distance of {@code 2}, etc. A {@linkplain #missing()\r\n * missing} annotation will always return a distance of {@code -1}.\r\n * @return the annotation distance or {@code -1} if the annotation is missing\r\n */\r\nint getDistance();\n/**\r\n * Get the index of the aggregate collection containing this annotation.\r\n * <p>Can be used to reorder a stream of annotations, for example, to give a\r\n * higher priority to annotations declared on a superclass or interface. A\r\n * {@linkplain #missing() missing} annotation will always return an aggregate\r\n * index of {@code -1}.\r\n * @return the aggregate index (starting at {@code 0}) or {@code -1} if the\r\n * annotation is missing\r\n */\r\nint getAggregateIndex();\n/**\r\n * Get the source that ultimately declared the root annotation, or\r\n * {@code null} if the source is not known.\r\n * <p>If this merged annotation was created\r\n * {@link MergedAnnotations#from(AnnotatedElement) from} an\r\n * {@link AnnotatedElement} then this source will be an element of the same\r\n * type. If the annotation was loaded without using reflection, the source\r\n * can be of any type, but should have a sensible {@code toString()}.\r\n * Meta-annotations will always return the same source as the\r\n * {@link #getRoot() root}.\r\n * @return the source, or {@code null}\r\n */\r\n@Nullable\r\nObject getSource();\n/**\r\n * Get the source of the meta-annotation, or {@code null} if the\r\n * annotation is not {@linkplain #isMetaPresent() meta-present}.\r\n * <p>The meta-source is the annotation that was meta-annotated with this\r\n * annotation.\r\n * @return the meta-annotation source or {@code null}\r\n * @see #getRoot()\r\n */\r\n@Nullable\r\nMergedAnnotation<?> getMetaSource();\n/**\r\n * Get the root annotation, i.e. the {@link #getDistance() distance} {@code 0}\r\n * annotation as directly declared on the source.\r\n * @return the root annotation\r\n * @see #getMetaSource()\r\n */\r\nMergedAnnotation<?> getRoot();\n/**\r\n * Get the complete list of annotation types within the annotation hierarchy\r\n * from this annotation to the {@link #getRoot() root}.\r\n * <p>Provides a useful way to uniquely identify a merged annotation instance.\r\n * @return the meta types for the annotation\r\n * @see MergedAnnotationPredicates#unique(Function)\r\n * @see #getRoot()\r\n * @see #getMetaSource()\r\n */\r\nList<Class<? extends Annotation>> getMetaTypes();\n/**\r\n * Determine if the specified attribute name has a non-default value when\r\n * compared to the annotation declaration.\r\n * @param attributeName the attribute name\r\n * @return {@code true} if the attribute value is different from the default\r\n * value\r\n */\r\nboolean hasNonDefaultValue(String attributeName);\n/**\r\n * Determine if the specified attribute name has a default value when compared\r\n * to the annotation declaration.\r\n * @param attributeName the attribute name\r\n * @return {@code true} if the attribute value is the same as the default\r\n * value\r\n */\r\nboolean hasDefaultValue(String attributeName) throws NoSuchElementException;\n/**\r\n * Get a required byte attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a byte\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nbyte getByte(String attributeName) throws NoSuchElementException;\n/**\r\n * Get a required byte array attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a byte array\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nbyte[] getByteArray(String attributeName) throws NoSuchElementException;\n/**\r\n * Get a required boolean attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a boolean\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nboolean getBoolean(String attributeName) throws NoSuchElementException;\n/**\r\n * Get a required boolean array attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a boolean array\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nboolean[] getBooleanArray(String attributeName) throws NoSuchElementException;\n/**\r\n * Get a required char attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a char\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nchar getChar(String attributeName) throws NoSuchElementException;\n/**\r\n * Get a required char array attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a char array\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nchar[] getCharArray(String attributeName) throws NoSuchElementException;\n/**\r\n * Get a required short attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a short\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nshort getShort(String attributeName) throws NoSuchElementException;\n/**\r\n * Get a required short array attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a short array\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nshort[] getShortArray(String attributeName) throws NoSuchElementException;\n/**\r\n * Get a required int attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as an int\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nint getInt(String attributeName) throws NoSuchElementException;\n/**\r\n * Get a required int array attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as an int array\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nint[] getIntArray(String attributeName) throws NoSuchElementException;\n/**\r\n * Get a required long attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a long\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nlong getLong(String attributeName) throws NoSuchElementException;\n/**\r\n * Get a required long array attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a long array\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nlong[] getLongArray(String attributeName) throws NoSuchElementException;\n/**\r\n * Get a required double attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a double\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\ndouble getDouble(String attributeName) throws NoSuchElementException;\n/**\r\n * Get a required double array attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a double array\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\ndouble[] getDoubleArray(String attributeName) throws NoSuchElementException;\n/**\r\n * Get a required float attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a float\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nfloat getFloat(String attributeName) throws NoSuchElementException;\n/**\r\n * Get a required float array attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a float array\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nfloat[] getFloatArray(String attributeName) throws NoSuchElementException;\n/**\r\n * Get a required string attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a string\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nString getString(String attributeName) throws NoSuchElementException;\n/**\r\n * Get a required string array attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a string array\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nString[] getStringArray(String attributeName) throws NoSuchElementException;\n/**\r\n * Get a required class attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a class\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nClass<?> getClass(String attributeName) throws NoSuchElementException;\n/**\r\n * Get a required class array attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a class array\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nClass<?>[] getClassArray(String attributeName) throws NoSuchElementException;\n/**\r\n * Get a required enum attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @param type the enum type\r\n * @return the value as an enum\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\n<E extends Enum<E>> E getEnum(String attributeName, Class<E> type) throws NoSuchElementException;\n/**\r\n * Get a required enum array attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @param type the enum type\r\n * @return the value as an enum array\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\n<E extends Enum<E>> E[] getEnumArray(String attributeName, Class<E> type) throws NoSuchElementException;\n/**\r\n * Get a required annotation attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @param type the annotation type\r\n * @return the value as a {@link MergedAnnotation}\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\n<T extends Annotation> MergedAnnotation<T> getAnnotation(String attributeName, Class<T> type) throws NoSuchElementException;\n/**\r\n * Get a required annotation array attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @param type the annotation type\r\n * @return the value as a {@link MergedAnnotation} array\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\n<T extends Annotation> MergedAnnotation<T>[] getAnnotationArray(String attributeName, Class<T> type) throws NoSuchElementException;\n/**\r\n * Get an optional attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return an optional value or {@link Optional#empty()} if there is no\r\n * matching attribute\r\n */\r\nOptional<Object> getValue(String attributeName);\n/**\r\n * Get an optional attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @param type the attribute type. Must be compatible with the underlying\r\n * attribute type or {@code Object.class}.\r\n * @return an optional value or {@link Optional#empty()} if there is no\r\n * matching attribute\r\n */\r\n<T> Optional<T> getValue(String attributeName, Class<T> type);\n/**\r\n * Get the default attribute value from the annotation as specified in\r\n * the annotation declaration.\r\n * @param attributeName the attribute name\r\n * @return an optional of the default value or {@link Optional#empty()} if\r\n * there is no matching attribute or no defined default\r\n */\r\nOptional<Object> getDefaultValue(String attributeName);\n/**\r\n * Get the default attribute value from the annotation as specified in\r\n * the annotation declaration.\r\n * @param attributeName the attribute name\r\n * @param type the attribute type. Must be compatible with the underlying\r\n * attribute type or {@code Object.class}.\r\n * @return an optional of the default value or {@link Optional#empty()} if\r\n * there is no matching attribute or no defined default\r\n */\r\n<T> Optional<T> getDefaultValue(String attributeName, Class<T> type);\n/**\r\n * Create a new view of the annotation with all attributes that have default\r\n * values removed.\r\n * @return a filtered view of the annotation without any attributes that\r\n * have a default value\r\n * @see #filterAttributes(Predicate)\r\n */\r\nMergedAnnotation<A> filterDefaultValues();\n/**\r\n * Create a new view of the annotation with only attributes that match the\r\n * given predicate.\r\n * @param predicate a predicate used to filter attribute names\r\n * @return a filtered view of the annotation\r\n * @see #filterDefaultValues()\r\n * @see MergedAnnotationPredicates\r\n */\r\nMergedAnnotation<A> filterAttributes(Predicate<String> predicate);\n/**\r\n * Create a new view of the annotation that exposes non-merged attribute values.\r\n * <p>Methods from this view will return attribute values with only alias mirroring\r\n * rules applied. Aliases to {@link #getMetaSource() meta-source} attributes will\r\n * not be applied.\r\n * @return a non-merged view of the annotation\r\n */\r\nMergedAnnotation<A> withNonMergedAttributes();\n/**\r\n * Create a new mutable {@link AnnotationAttributes} instance from this\r\n * merged annotation.\r\n * <p>The {@link Adapt adaptations} may be used to change the way that values\r\n * are added.\r\n * @param adaptations the adaptations that should be applied to the annotation values\r\n * @return an immutable map containing the attributes and values\r\n */\r\nAnnotationAttributes asAnnotationAttributes(Adapt... adaptations);\n/**\r\n * Get an immutable {@link Map} that contains all the annotation attributes.\r\n * <p>The {@link Adapt adaptations} may be used to change the way that values are added.\r\n * @param adaptations the adaptations that should be applied to the annotation values\r\n * @return an immutable map containing the attributes and values\r\n */\r\nMap<String, Object> asMap(Adapt... adaptations);\n/**\r\n * Create a new {@link Map} instance of the given type that contains all the annotation\r\n * attributes.\r\n * <p>The {@link Adapt adaptations} may be used to change the way that values are added.\r\n * @param factory a map factory\r\n * @param adaptations the adaptations that should be applied to the annotation values\r\n * @return a map containing the attributes and values\r\n */\r\n<T extends Map<String, Object>> T asMap(Function<MergedAnnotation<?>, T> factory, Adapt... adaptations);\n/**\r\n * Create a type-safe synthesized version of this merged annotation that can\r\n * be used directly in code.\r\n * <p>The result is synthesized using a JDK {@link java.lang.reflect.Proxy Proxy}\r\n * and as a result may incur a computational cost when first invoked.\r\n * <p>If this merged annotation was created {@linkplain #of(AnnotatedElement, Class, Map)\r\n * from} a map of annotation attributes or default attribute values, those\r\n * attributes will always be synthesized into an annotation instance.\r\n * <p>If this merged annotation was created {@linkplain #from(Annotation) from}\r\n * an annotation instance, that annotation will be returned unmodified if it is\r\n * not <em>synthesizable</em>. An annotation is considered synthesizable if\r\n * it has not already been synthesized and one of the following is true.\r\n * <ul>\r\n * <li>The annotation declares attributes annotated with {@link AliasFor @AliasFor}.</li>\r\n * <li>The annotation is a composed annotation that relies on convention-based\r\n * annotation attribute overrides in meta-annotations.</li>\r\n * <li>The annotation declares attributes that are annotations or arrays of\r\n * annotations that are themselves synthesizable.</li>\r\n * </ul>\r\n * @return a synthesized version of the annotation or the original annotation\r\n * unmodified\r\n * @throws NoSuchElementException on a missing annotation\r\n */\r\nA synthesize() throws NoSuchElementException;\n/**\r\n * Optionally create a type-safe synthesized version of this annotation based\r\n * on a condition predicate.\r\n * <p>The result is synthesized using a JDK {@link java.lang.reflect.Proxy Proxy}\r\n * and as a result may incur a computational cost when first invoked.\r\n * <p>Consult the documentation for {@link #synthesize()} for an explanation\r\n * of what is considered synthesizable.\r\n * @param condition the test to determine if the annotation can be synthesized\r\n * @return an optional containing the synthesized version of the annotation or\r\n * an empty optional if the condition doesn't match\r\n * @throws NoSuchElementException on a missing annotation\r\n * @see MergedAnnotationPredicates\r\n */\r\nOptional<A> synthesize(Predicate<? super MergedAnnotation<A>> condition) throws NoSuchElementException;\n/**\r\n * Create a {@link MergedAnnotation} that represents a missing annotation\r\n * (i.e. one that is not present).\r\n * @return an instance representing a missing annotation\r\n */\r\nstatic <A extends Annotation> MergedAnnotation<A> missing() {\r\n    return MissingMergedAnnotation.getInstance();\r\n}\n/**\r\n * Create a new {@link MergedAnnotation} instance from the specified\r\n * annotation.\r\n * @param annotation the annotation to include\r\n * @return a {@link MergedAnnotation} instance containing the annotation\r\n */\r\nstatic <A extends Annotation> MergedAnnotation<A> from(A annotation) {\r\n    return from(null, annotation);\r\n}\n/**\r\n * Create a new {@link MergedAnnotation} instance from the specified\r\n * annotation.\r\n * @param source the source for the annotation. This source is used only for\r\n * information and logging. It does not need to <em>actually</em> contain\r\n * the specified annotations, and it will not be searched.\r\n * @param annotation the annotation to include\r\n * @return a {@link MergedAnnotation} instance for the annotation\r\n */\r\nstatic <A extends Annotation> MergedAnnotation<A> from(@Nullable Object source, A annotation) {\r\n    return TypeMappedAnnotation.from(source, annotation);\r\n}\n/**\r\n * Create a new {@link MergedAnnotation} instance of the specified\r\n * annotation type. The resulting annotation will not have any attribute\r\n * values but may still be used to query default values.\r\n * @param annotationType the annotation type\r\n * @return a {@link MergedAnnotation} instance for the annotation\r\n */\r\nstatic <A extends Annotation> MergedAnnotation<A> of(Class<A> annotationType) {\r\n    return of(null, annotationType, null);\r\n}\n/**\r\n * Create a new {@link MergedAnnotation} instance of the specified\r\n * annotation type with attribute values supplied by a map.\r\n * @param annotationType the annotation type\r\n * @param attributes the annotation attributes or {@code null} if just default\r\n * values should be used\r\n * @return a {@link MergedAnnotation} instance for the annotation and attributes\r\n * @see #of(AnnotatedElement, Class, Map)\r\n */\r\nstatic <A extends Annotation> MergedAnnotation<A> of(Class<A> annotationType, @Nullable Map<String, ?> attributes) {\r\n    return of(null, annotationType, attributes);\r\n}\n/**\r\n * Create a new {@link MergedAnnotation} instance of the specified\r\n * annotation type with attribute values supplied by a map.\r\n * @param source the source for the annotation. This source is used only for\r\n * information and logging. It does not need to <em>actually</em> contain\r\n * the specified annotations and it will not be searched.\r\n * @param annotationType the annotation type\r\n * @param attributes the annotation attributes or {@code null} if just default\r\n * values should be used\r\n * @return a {@link MergedAnnotation} instance for the annotation and attributes\r\n */\r\nstatic <A extends Annotation> MergedAnnotation<A> of(@Nullable AnnotatedElement source, Class<A> annotationType, @Nullable Map<String, ?> attributes) {\r\n    return of(null, source, annotationType, attributes);\r\n}\n/**\r\n * Create a new {@link MergedAnnotation} instance of the specified\r\n * annotation type with attribute values supplied by a map.\r\n * @param classLoader the class loader used to resolve class attributes\r\n * @param source the source for the annotation. This source is used only for\r\n * information and logging. It does not need to <em>actually</em> contain\r\n * the specified annotations and it will not be searched.\r\n * @param annotationType the annotation type\r\n * @param attributes the annotation attributes or {@code null} if just default\r\n * values should be used\r\n * @return a {@link MergedAnnotation} instance for the annotation and attributes\r\n */\r\nstatic <A extends Annotation> MergedAnnotation<A> of(@Nullable ClassLoader classLoader, @Nullable Object source, Class<A> annotationType, @Nullable Map<String, ?> attributes) {\r\n    return TypeMappedAnnotation.of(classLoader, source, annotationType, attributes);\r\n}\n/**\r\n * Adaptations that can be applied to attribute values when creating\r\n * {@linkplain MergedAnnotation#asMap(Adapt...) Maps} or\r\n * {@link MergedAnnotation#asAnnotationAttributes(Adapt...) AnnotationAttributes}.\r\n */\r\nenum Adapt {\r\n\r\n    /**\r\n     * Adapt class or class array attributes to strings.\r\n     */\r\n    CLASS_TO_STRING,\r\n    /**\r\n     * Adapt nested annotation or annotation arrays to maps rather\r\n     * than synthesizing the values.\r\n     */\r\n    ANNOTATION_TO_MAP;\r\n\r\n    protected final boolean isIn(Adapt... adaptations) {\r\n        for (Adapt candidate : adaptations) {\r\n            if (candidate == this) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Factory method to create an {@link Adapt} array from a set of boolean flags.\r\n     * @param classToString if {@link Adapt#CLASS_TO_STRING} is included\r\n     * @param annotationsToMap if {@link Adapt#ANNOTATION_TO_MAP} is included\r\n     * @return a new {@link Adapt} array\r\n     */\r\n    public static Adapt[] values(boolean classToString, boolean annotationsToMap) {\r\n        EnumSet<Adapt> result = EnumSet.noneOf(Adapt.class);\r\n        addIfTrue(result, Adapt.CLASS_TO_STRING, classToString);\r\n        addIfTrue(result, Adapt.ANNOTATION_TO_MAP, annotationsToMap);\r\n        return result.toArray(new Adapt[0]);\r\n    }\r\n\r\n    private static <T> void addIfTrue(Set<T> result, T value, boolean test) {\r\n        if (test) {\r\n            result.add(value);\r\n        }\r\n    }\r\n}",
    "comment": "\n * A single merged annotation returned from a {@link MergedAnnotations}\n * collection. Presents a view onto an annotation where attribute values may\n * have been \"merged\" from different source values.\n *\n * <p>Attribute values may be accessed using the various {@code get} methods.\n * For example, to access an {@code int} attribute the {@link #getInt(String)}\n * method would be used.\n *\n * <p>Note that attribute values are <b>not</b> converted when accessed.\n * For example, it is not possible to call {@link #getString(String)} if the\n * underlying attribute is an {@code int}. The only exception to this rule is\n * {@code Class} and {@code Class[]} values which may be accessed as\n * {@code String} and {@code String[]} respectively to prevent potential early\n * class initialization.\n *\n * <p>If necessary, a {@code MergedAnnotation} can be {@linkplain #synthesize()\n * synthesized} back into an actual {@link java.lang.annotation.Annotation}.\n *\n * @author Phillip Webb\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 5.2\n * @param <A> the annotation type\n * @see MergedAnnotations\n * @see MergedAnnotationPredicates\n "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getType()",
    "entityType": "method",
    "code": "/**\r\n * Get the {@code Class} reference for the actual annotation type.\r\n * @return the annotation type\r\n */\r\nClass<A> getType();",
    "comment": "\n\t * Get the {@code Class} reference for the actual annotation type.\n\t * @return the annotation type\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#isPresent()",
    "entityType": "method",
    "code": "/**\r\n * Determine if the annotation is present on the source. Considers\r\n * {@linkplain #isDirectlyPresent() directly present} and\r\n * {@linkplain #isMetaPresent() meta-present} annotations within the context\r\n * of the {@link SearchStrategy} used.\r\n * @return {@code true} if the annotation is present\r\n */\r\nboolean isPresent();",
    "comment": "\n\t * Determine if the annotation is present on the source. Considers\n\t * {@linkplain #isDirectlyPresent() directly present} and\n\t * {@linkplain #isMetaPresent() meta-present} annotations within the context\n\t * of the {@link SearchStrategy} used.\n\t * @return {@code true} if the annotation is present\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#isDirectlyPresent()",
    "entityType": "method",
    "code": "/**\r\n * Determine if the annotation is directly present on the source.\r\n * <p>A directly present annotation is one that the user has explicitly\r\n * declared and not one that is {@linkplain #isMetaPresent() meta-present}\r\n * or {@link Inherited @Inherited}.\r\n * @return {@code true} if the annotation is directly present\r\n */\r\nboolean isDirectlyPresent();",
    "comment": "\n\t * Determine if the annotation is directly present on the source.\n\t * <p>A directly present annotation is one that the user has explicitly\n\t * declared and not one that is {@linkplain #isMetaPresent() meta-present}\n\t * or {@link Inherited @Inherited}.\n\t * @return {@code true} if the annotation is directly present\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#isMetaPresent()",
    "entityType": "method",
    "code": "/**\r\n * Determine if the annotation is meta-present on the source.\r\n * <p>A meta-present annotation is an annotation that the user hasn't\r\n * explicitly declared, but has been used as a meta-annotation somewhere in\r\n * the annotation hierarchy.\r\n * @return {@code true} if the annotation is meta-present\r\n */\r\nboolean isMetaPresent();",
    "comment": "\n\t * Determine if the annotation is meta-present on the source.\n\t * <p>A meta-present annotation is an annotation that the user hasn't\n\t * explicitly declared, but has been used as a meta-annotation somewhere in\n\t * the annotation hierarchy.\n\t * @return {@code true} if the annotation is meta-present\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getDistance()",
    "entityType": "method",
    "code": "/**\r\n * Get the distance of this annotation related to its use as a\r\n * meta-annotation.\r\n * <p>A directly declared annotation has a distance of {@code 0}, a\r\n * meta-annotation has a distance of {@code 1}, a meta-annotation on a\r\n * meta-annotation has a distance of {@code 2}, etc. A {@linkplain #missing()\r\n * missing} annotation will always return a distance of {@code -1}.\r\n * @return the annotation distance or {@code -1} if the annotation is missing\r\n */\r\nint getDistance();",
    "comment": "\n\t * Get the distance of this annotation related to its use as a\n\t * meta-annotation.\n\t * <p>A directly declared annotation has a distance of {@code 0}, a\n\t * meta-annotation has a distance of {@code 1}, a meta-annotation on a\n\t * meta-annotation has a distance of {@code 2}, etc. A {@linkplain #missing()\n\t * missing} annotation will always return a distance of {@code -1}.\n\t * @return the annotation distance or {@code -1} if the annotation is missing\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getAggregateIndex()",
    "entityType": "method",
    "code": "/**\r\n * Get the index of the aggregate collection containing this annotation.\r\n * <p>Can be used to reorder a stream of annotations, for example, to give a\r\n * higher priority to annotations declared on a superclass or interface. A\r\n * {@linkplain #missing() missing} annotation will always return an aggregate\r\n * index of {@code -1}.\r\n * @return the aggregate index (starting at {@code 0}) or {@code -1} if the\r\n * annotation is missing\r\n */\r\nint getAggregateIndex();",
    "comment": "\n\t * Get the index of the aggregate collection containing this annotation.\n\t * <p>Can be used to reorder a stream of annotations, for example, to give a\n\t * higher priority to annotations declared on a superclass or interface. A\n\t * {@linkplain #missing() missing} annotation will always return an aggregate\n\t * index of {@code -1}.\n\t * @return the aggregate index (starting at {@code 0}) or {@code -1} if the\n\t * annotation is missing\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getSource()",
    "entityType": "method",
    "code": "/**\r\n * Get the source that ultimately declared the root annotation, or\r\n * {@code null} if the source is not known.\r\n * <p>If this merged annotation was created\r\n * {@link MergedAnnotations#from(AnnotatedElement) from} an\r\n * {@link AnnotatedElement} then this source will be an element of the same\r\n * type. If the annotation was loaded without using reflection, the source\r\n * can be of any type, but should have a sensible {@code toString()}.\r\n * Meta-annotations will always return the same source as the\r\n * {@link #getRoot() root}.\r\n * @return the source, or {@code null}\r\n */\r\n@Nullable\r\nObject getSource();",
    "comment": "\n\t * Get the source that ultimately declared the root annotation, or\n\t * {@code null} if the source is not known.\n\t * <p>If this merged annotation was created\n\t * {@link MergedAnnotations#from(AnnotatedElement) from} an\n\t * {@link AnnotatedElement} then this source will be an element of the same\n\t * type. If the annotation was loaded without using reflection, the source\n\t * can be of any type, but should have a sensible {@code toString()}.\n\t * Meta-annotations will always return the same source as the\n\t * {@link #getRoot() root}.\n\t * @return the source, or {@code null}\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getMetaSource()",
    "entityType": "method",
    "code": "/**\r\n * Get the source of the meta-annotation, or {@code null} if the\r\n * annotation is not {@linkplain #isMetaPresent() meta-present}.\r\n * <p>The meta-source is the annotation that was meta-annotated with this\r\n * annotation.\r\n * @return the meta-annotation source or {@code null}\r\n * @see #getRoot()\r\n */\r\n@Nullable\r\nMergedAnnotation<?> getMetaSource();",
    "comment": "\n\t * Get the source of the meta-annotation, or {@code null} if the\n\t * annotation is not {@linkplain #isMetaPresent() meta-present}.\n\t * <p>The meta-source is the annotation that was meta-annotated with this\n\t * annotation.\n\t * @return the meta-annotation source or {@code null}\n\t * @see #getRoot()\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getRoot()",
    "entityType": "method",
    "code": "/**\r\n * Get the root annotation, i.e. the {@link #getDistance() distance} {@code 0}\r\n * annotation as directly declared on the source.\r\n * @return the root annotation\r\n * @see #getMetaSource()\r\n */\r\nMergedAnnotation<?> getRoot();",
    "comment": "\n\t * Get the root annotation, i.e. the {@link #getDistance() distance} {@code 0}\n\t * annotation as directly declared on the source.\n\t * @return the root annotation\n\t * @see #getMetaSource()\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getMetaTypes()",
    "entityType": "method",
    "code": "/**\r\n * Get the complete list of annotation types within the annotation hierarchy\r\n * from this annotation to the {@link #getRoot() root}.\r\n * <p>Provides a useful way to uniquely identify a merged annotation instance.\r\n * @return the meta types for the annotation\r\n * @see MergedAnnotationPredicates#unique(Function)\r\n * @see #getRoot()\r\n * @see #getMetaSource()\r\n */\r\nList<Class<? extends Annotation>> getMetaTypes();",
    "comment": "\n\t * Get the complete list of annotation types within the annotation hierarchy\n\t * from this annotation to the {@link #getRoot() root}.\n\t * <p>Provides a useful way to uniquely identify a merged annotation instance.\n\t * @return the meta types for the annotation\n\t * @see MergedAnnotationPredicates#unique(Function)\n\t * @see #getRoot()\n\t * @see #getMetaSource()\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#hasNonDefaultValue(String)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the specified attribute name has a non-default value when\r\n * compared to the annotation declaration.\r\n * @param attributeName the attribute name\r\n * @return {@code true} if the attribute value is different from the default\r\n * value\r\n */\r\nboolean hasNonDefaultValue(String attributeName);",
    "comment": "\n\t * Determine if the specified attribute name has a non-default value when\n\t * compared to the annotation declaration.\n\t * @param attributeName the attribute name\n\t * @return {@code true} if the attribute value is different from the default\n\t * value\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#hasDefaultValue(String)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the specified attribute name has a default value when compared\r\n * to the annotation declaration.\r\n * @param attributeName the attribute name\r\n * @return {@code true} if the attribute value is the same as the default\r\n * value\r\n */\r\nboolean hasDefaultValue(String attributeName) throws NoSuchElementException;",
    "comment": "\n\t * Determine if the specified attribute name has a default value when compared\n\t * to the annotation declaration.\n\t * @param attributeName the attribute name\n\t * @return {@code true} if the attribute value is the same as the default\n\t * value\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getByte(String)",
    "entityType": "method",
    "code": "/**\r\n * Get a required byte attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a byte\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nbyte getByte(String attributeName) throws NoSuchElementException;",
    "comment": "\n\t * Get a required byte attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a byte\n\t * @throws NoSuchElementException if there is no matching attribute\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getByteArray(String)",
    "entityType": "method",
    "code": "/**\r\n * Get a required byte array attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a byte array\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nbyte[] getByteArray(String attributeName) throws NoSuchElementException;",
    "comment": "\n\t * Get a required byte array attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a byte array\n\t * @throws NoSuchElementException if there is no matching attribute\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getBoolean(String)",
    "entityType": "method",
    "code": "/**\r\n * Get a required boolean attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a boolean\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nboolean getBoolean(String attributeName) throws NoSuchElementException;",
    "comment": "\n\t * Get a required boolean attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a boolean\n\t * @throws NoSuchElementException if there is no matching attribute\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getBooleanArray(String)",
    "entityType": "method",
    "code": "/**\r\n * Get a required boolean array attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a boolean array\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nboolean[] getBooleanArray(String attributeName) throws NoSuchElementException;",
    "comment": "\n\t * Get a required boolean array attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a boolean array\n\t * @throws NoSuchElementException if there is no matching attribute\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getChar(String)",
    "entityType": "method",
    "code": "/**\r\n * Get a required char attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a char\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nchar getChar(String attributeName) throws NoSuchElementException;",
    "comment": "\n\t * Get a required char attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a char\n\t * @throws NoSuchElementException if there is no matching attribute\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getCharArray(String)",
    "entityType": "method",
    "code": "/**\r\n * Get a required char array attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a char array\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nchar[] getCharArray(String attributeName) throws NoSuchElementException;",
    "comment": "\n\t * Get a required char array attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a char array\n\t * @throws NoSuchElementException if there is no matching attribute\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getShort(String)",
    "entityType": "method",
    "code": "/**\r\n * Get a required short attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a short\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nshort getShort(String attributeName) throws NoSuchElementException;",
    "comment": "\n\t * Get a required short attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a short\n\t * @throws NoSuchElementException if there is no matching attribute\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getShortArray(String)",
    "entityType": "method",
    "code": "/**\r\n * Get a required short array attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a short array\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nshort[] getShortArray(String attributeName) throws NoSuchElementException;",
    "comment": "\n\t * Get a required short array attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a short array\n\t * @throws NoSuchElementException if there is no matching attribute\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getInt(String)",
    "entityType": "method",
    "code": "/**\r\n * Get a required int attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as an int\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nint getInt(String attributeName) throws NoSuchElementException;",
    "comment": "\n\t * Get a required int attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as an int\n\t * @throws NoSuchElementException if there is no matching attribute\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getIntArray(String)",
    "entityType": "method",
    "code": "/**\r\n * Get a required int array attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as an int array\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nint[] getIntArray(String attributeName) throws NoSuchElementException;",
    "comment": "\n\t * Get a required int array attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as an int array\n\t * @throws NoSuchElementException if there is no matching attribute\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getLong(String)",
    "entityType": "method",
    "code": "/**\r\n * Get a required long attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a long\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nlong getLong(String attributeName) throws NoSuchElementException;",
    "comment": "\n\t * Get a required long attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a long\n\t * @throws NoSuchElementException if there is no matching attribute\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getLongArray(String)",
    "entityType": "method",
    "code": "/**\r\n * Get a required long array attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a long array\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nlong[] getLongArray(String attributeName) throws NoSuchElementException;",
    "comment": "\n\t * Get a required long array attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a long array\n\t * @throws NoSuchElementException if there is no matching attribute\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getDouble(String)",
    "entityType": "method",
    "code": "/**\r\n * Get a required double attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a double\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\ndouble getDouble(String attributeName) throws NoSuchElementException;",
    "comment": "\n\t * Get a required double attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a double\n\t * @throws NoSuchElementException if there is no matching attribute\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getDoubleArray(String)",
    "entityType": "method",
    "code": "/**\r\n * Get a required double array attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a double array\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\ndouble[] getDoubleArray(String attributeName) throws NoSuchElementException;",
    "comment": "\n\t * Get a required double array attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a double array\n\t * @throws NoSuchElementException if there is no matching attribute\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getFloat(String)",
    "entityType": "method",
    "code": "/**\r\n * Get a required float attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a float\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nfloat getFloat(String attributeName) throws NoSuchElementException;",
    "comment": "\n\t * Get a required float attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a float\n\t * @throws NoSuchElementException if there is no matching attribute\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getFloatArray(String)",
    "entityType": "method",
    "code": "/**\r\n * Get a required float array attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a float array\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nfloat[] getFloatArray(String attributeName) throws NoSuchElementException;",
    "comment": "\n\t * Get a required float array attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a float array\n\t * @throws NoSuchElementException if there is no matching attribute\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getString(String)",
    "entityType": "method",
    "code": "/**\r\n * Get a required string attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a string\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nString getString(String attributeName) throws NoSuchElementException;",
    "comment": "\n\t * Get a required string attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a string\n\t * @throws NoSuchElementException if there is no matching attribute\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getStringArray(String)",
    "entityType": "method",
    "code": "/**\r\n * Get a required string array attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a string array\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nString[] getStringArray(String attributeName) throws NoSuchElementException;",
    "comment": "\n\t * Get a required string array attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a string array\n\t * @throws NoSuchElementException if there is no matching attribute\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getClass(String)",
    "entityType": "method",
    "code": "/**\r\n * Get a required class attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a class\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nClass<?> getClass(String attributeName) throws NoSuchElementException;",
    "comment": "\n\t * Get a required class attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a class\n\t * @throws NoSuchElementException if there is no matching attribute\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getClassArray(String)",
    "entityType": "method",
    "code": "/**\r\n * Get a required class array attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return the value as a class array\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\nClass<?>[] getClassArray(String attributeName) throws NoSuchElementException;",
    "comment": "\n\t * Get a required class array attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return the value as a class array\n\t * @throws NoSuchElementException if there is no matching attribute\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getEnum(String,Class<E>)",
    "entityType": "method",
    "code": "/**\r\n * Get a required enum attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @param type the enum type\r\n * @return the value as an enum\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\n<E extends Enum<E>> E getEnum(String attributeName, Class<E> type) throws NoSuchElementException;",
    "comment": "\n\t * Get a required enum attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @param type the enum type\n\t * @return the value as an enum\n\t * @throws NoSuchElementException if there is no matching attribute\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getEnumArray(String,Class<E>)",
    "entityType": "method",
    "code": "/**\r\n * Get a required enum array attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @param type the enum type\r\n * @return the value as an enum array\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\n<E extends Enum<E>> E[] getEnumArray(String attributeName, Class<E> type) throws NoSuchElementException;",
    "comment": "\n\t * Get a required enum array attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @param type the enum type\n\t * @return the value as an enum array\n\t * @throws NoSuchElementException if there is no matching attribute\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getAnnotation(String,Class<T>)",
    "entityType": "method",
    "code": "/**\r\n * Get a required annotation attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @param type the annotation type\r\n * @return the value as a {@link MergedAnnotation}\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\n<T extends Annotation> MergedAnnotation<T> getAnnotation(String attributeName, Class<T> type) throws NoSuchElementException;",
    "comment": "\n\t * Get a required annotation attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @param type the annotation type\n\t * @return the value as a {@link MergedAnnotation}\n\t * @throws NoSuchElementException if there is no matching attribute\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getAnnotationArray(String,Class<T>)",
    "entityType": "method",
    "code": "/**\r\n * Get a required annotation array attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @param type the annotation type\r\n * @return the value as a {@link MergedAnnotation} array\r\n * @throws NoSuchElementException if there is no matching attribute\r\n */\r\n<T extends Annotation> MergedAnnotation<T>[] getAnnotationArray(String attributeName, Class<T> type) throws NoSuchElementException;",
    "comment": "\n\t * Get a required annotation array attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @param type the annotation type\n\t * @return the value as a {@link MergedAnnotation} array\n\t * @throws NoSuchElementException if there is no matching attribute\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getValue(String)",
    "entityType": "method",
    "code": "/**\r\n * Get an optional attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @return an optional value or {@link Optional#empty()} if there is no\r\n * matching attribute\r\n */\r\nOptional<Object> getValue(String attributeName);",
    "comment": "\n\t * Get an optional attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @return an optional value or {@link Optional#empty()} if there is no\n\t * matching attribute\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getValue(String,Class<T>)",
    "entityType": "method",
    "code": "/**\r\n * Get an optional attribute value from the annotation.\r\n * @param attributeName the attribute name\r\n * @param type the attribute type. Must be compatible with the underlying\r\n * attribute type or {@code Object.class}.\r\n * @return an optional value or {@link Optional#empty()} if there is no\r\n * matching attribute\r\n */\r\n<T> Optional<T> getValue(String attributeName, Class<T> type);",
    "comment": "\n\t * Get an optional attribute value from the annotation.\n\t * @param attributeName the attribute name\n\t * @param type the attribute type. Must be compatible with the underlying\n\t * attribute type or {@code Object.class}.\n\t * @return an optional value or {@link Optional#empty()} if there is no\n\t * matching attribute\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getDefaultValue(String)",
    "entityType": "method",
    "code": "/**\r\n * Get the default attribute value from the annotation as specified in\r\n * the annotation declaration.\r\n * @param attributeName the attribute name\r\n * @return an optional of the default value or {@link Optional#empty()} if\r\n * there is no matching attribute or no defined default\r\n */\r\nOptional<Object> getDefaultValue(String attributeName);",
    "comment": "\n\t * Get the default attribute value from the annotation as specified in\n\t * the annotation declaration.\n\t * @param attributeName the attribute name\n\t * @return an optional of the default value or {@link Optional#empty()} if\n\t * there is no matching attribute or no defined default\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#getDefaultValue(String,Class<T>)",
    "entityType": "method",
    "code": "/**\r\n * Get the default attribute value from the annotation as specified in\r\n * the annotation declaration.\r\n * @param attributeName the attribute name\r\n * @param type the attribute type. Must be compatible with the underlying\r\n * attribute type or {@code Object.class}.\r\n * @return an optional of the default value or {@link Optional#empty()} if\r\n * there is no matching attribute or no defined default\r\n */\r\n<T> Optional<T> getDefaultValue(String attributeName, Class<T> type);",
    "comment": "\n\t * Get the default attribute value from the annotation as specified in\n\t * the annotation declaration.\n\t * @param attributeName the attribute name\n\t * @param type the attribute type. Must be compatible with the underlying\n\t * attribute type or {@code Object.class}.\n\t * @return an optional of the default value or {@link Optional#empty()} if\n\t * there is no matching attribute or no defined default\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#filterDefaultValues()",
    "entityType": "method",
    "code": "/**\r\n * Create a new view of the annotation with all attributes that have default\r\n * values removed.\r\n * @return a filtered view of the annotation without any attributes that\r\n * have a default value\r\n * @see #filterAttributes(Predicate)\r\n */\r\nMergedAnnotation<A> filterDefaultValues();",
    "comment": "\n\t * Create a new view of the annotation with all attributes that have default\n\t * values removed.\n\t * @return a filtered view of the annotation without any attributes that\n\t * have a default value\n\t * @see #filterAttributes(Predicate)\n\t "
  }
]