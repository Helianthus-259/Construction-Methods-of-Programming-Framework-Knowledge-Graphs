[
  {
    "entityId": "org.springframework.core.MegaMessageProducer",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.Other",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.MegaMessageProducerImpl",
    "entityType": "class",
    "code": "public void receive(NewMegaMessageEvent event) {\r\n    throw new UnsupportedOperationException();\r\n}\npublic void receive(ModifiedMegaMessageEvent event) {\r\n    throw new UnsupportedOperationException();\r\n}\n@Override\r\npublic void receive(MegaMessageEvent event) {\r\n    throw new UnsupportedOperationException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.MegaMessageProducerImpl#receive(NewMegaMessageEvent)",
    "entityType": "method",
    "code": "public void receive(NewMegaMessageEvent event) {\r\n    throw new UnsupportedOperationException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.MegaMessageProducerImpl#receive(ModifiedMegaMessageEvent)",
    "entityType": "method",
    "code": "public void receive(ModifiedMegaMessageEvent event) {\r\n    throw new UnsupportedOperationException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.MegaMessageProducerImpl#receive(MegaMessageEvent)",
    "entityType": "method",
    "code": "@Override\r\npublic void receive(MegaMessageEvent event) {\r\n    throw new UnsupportedOperationException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.DomainObjectSuper",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.DomainObjectExtendsSuper",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.IGenericInterface",
    "entityType": "class",
    "code": "<T> void doSomething(final D domainObject, final T value);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.IGenericInterface#doSomething(D,T)",
    "entityType": "method",
    "code": "<T> void doSomething(final D domainObject, final T value);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.AbstractImplementsInterface",
    "entityType": "class",
    "code": "@Override\r\npublic <T> void doSomething(D domainObject, T value) ;\npublic void anotherBaseMethod() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.AbstractImplementsInterface#doSomething(D,T)",
    "entityType": "method",
    "code": "@Override\r\npublic <T> void doSomething(D domainObject, T value) ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.AbstractImplementsInterface#anotherBaseMethod()",
    "entityType": "method",
    "code": "public void anotherBaseMethod() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ExtendsAbstractImplementsInterface",
    "entityType": "class",
    "code": "@Override\r\npublic <T> void doSomething(DomainObjectExtendsSuper domainObject, T value) {\r\n    super.doSomething(domainObject, value);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ExtendsAbstractImplementsInterface#doSomething(DomainObjectExtendsSuper,T)",
    "entityType": "method",
    "code": "@Override\r\npublic <T> void doSomething(DomainObjectExtendsSuper domainObject, T value) {\r\n    super.doSomething(domainObject, value);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ParameterType",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.AbstractDomainObject",
    "entityType": "class",
    "code": "public R method1(P p) {\r\n    return null;\r\n}\npublic void method2(P p, R r) ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.AbstractDomainObject#method1(P)",
    "entityType": "method",
    "code": "public R method1(P p) {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.AbstractDomainObject#method2(P,R)",
    "entityType": "method",
    "code": "public void method2(P p, R r) ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.DomainObject",
    "entityType": "class",
    "code": "@Override\r\npublic byte[] method1(ParameterType p) {\r\n    return super.method1(p);\r\n}\n@Override\r\npublic void method2(ParameterType p, byte[] r) {\r\n    super.method2(p, r);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.DomainObject#method1(ParameterType)",
    "entityType": "method",
    "code": "@Override\r\npublic byte[] method1(ParameterType p) {\r\n    return super.method1(p);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.DomainObject#method2(ParameterType,byte[])",
    "entityType": "method",
    "code": "@Override\r\npublic void method2(ParameterType p, byte[] r) {\r\n    super.method2(p, r);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.SearchProvider",
    "entityType": "class",
    "code": "Collection<RETURN_TYPE> findBy(CONDITIONS_TYPE conditions);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.SearchProvider#findBy(CONDITIONS_TYPE)",
    "entityType": "method",
    "code": "Collection<RETURN_TYPE> findBy(CONDITIONS_TYPE conditions);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.SearchConditions",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.IExternalMessageProvider",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ExternalMessage",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ExternalMessageSearchConditions",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ExternalMessageProvider",
    "entityType": "class",
    "code": "@Override\r\npublic Collection<S> findBy(T conditions) {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ExternalMessageProvider#findBy(T)",
    "entityType": "method",
    "code": "@Override\r\npublic Collection<S> findBy(T conditions) {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.EmailMessage",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.EmailSearchConditions",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.EmailMessageProvider",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.TestEmailProvider",
    "entityType": "class",
    "code": "@Override\r\npublic Collection<EmailMessage> findBy(EmailSearchConditions conditions) {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.TestEmailProvider#findBy(EmailSearchConditions)",
    "entityType": "method",
    "code": "@Override\r\npublic Collection<EmailMessage> findBy(EmailSearchConditions conditions) {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BaseEntity",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.FooEntity",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BaseClass",
    "entityType": "class",
    "code": "public <S extends T> S test(S T) {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BaseClass#test(S)",
    "entityType": "method",
    "code": "public <S extends T> S test(S T) {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.EntityClass",
    "entityType": "class",
    "code": "@Override\r\npublic <S extends T> S test(S T) {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.EntityClass#test(S)",
    "entityType": "method",
    "code": "@Override\r\npublic <S extends T> S test(S T) {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.FooClass",
    "entityType": "class",
    "code": "@Override\r\npublic <S extends FooEntity> S test(S T) {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.FooClass#test(S)",
    "entityType": "method",
    "code": "@Override\r\npublic <S extends FooEntity> S test(S T) {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BaseInterface",
    "entityType": "class",
    "code": "<S extends T> S test(S T);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BaseInterface#test(S)",
    "entityType": "method",
    "code": "<S extends T> S test(S T);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.EntityInterface",
    "entityType": "class",
    "code": "@Override\r\n<S extends T> S test(S T);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.EntityInterface#test(S)",
    "entityType": "method",
    "code": "@Override\r\n<S extends T> S test(S T);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.FooInterface",
    "entityType": "class",
    "code": "@Override\r\n<S extends FooEntity> S test(S T);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.FooInterface#test(S)",
    "entityType": "method",
    "code": "@Override\r\n<S extends FooEntity> S test(S T);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.ByteArrayDecoderTests",
    "entityType": "class",
    "code": "private final byte[] fooBytes = \"foo\".getBytes(StandardCharsets.UTF_8);\nprivate final byte[] barBytes = \"bar\".getBytes(StandardCharsets.UTF_8);\nByteArrayDecoderTests() {\r\n    super(new ByteArrayDecoder());\r\n}\n@Override\r\n@Test\r\nprotected void canDecode() {\r\n    assertThat(this.decoder.canDecode(ResolvableType.forClass(byte[].class), MimeTypeUtils.TEXT_PLAIN)).isTrue();\r\n    assertThat(this.decoder.canDecode(ResolvableType.forClass(Integer.class), MimeTypeUtils.TEXT_PLAIN)).isFalse();\r\n    assertThat(this.decoder.canDecode(ResolvableType.forClass(byte[].class), MimeTypeUtils.APPLICATION_JSON)).isTrue();\r\n}\n@Override\r\n@Test\r\nprotected void decode() {\r\n    Flux<DataBuffer> input = Flux.concat(dataBuffer(this.fooBytes), dataBuffer(this.barBytes));\r\n    testDecodeAll(input, byte[].class, step -> step.consumeNextWith(expectBytes(this.fooBytes)).consumeNextWith(expectBytes(this.barBytes)).verifyComplete());\r\n}\n@Override\r\n@Test\r\nprotected void decodeToMono() {\r\n    Flux<DataBuffer> input = Flux.concat(dataBuffer(this.fooBytes), dataBuffer(this.barBytes));\r\n    byte[] expected = new byte[this.fooBytes.length + this.barBytes.length];\r\n    System.arraycopy(this.fooBytes, 0, expected, 0, this.fooBytes.length);\r\n    System.arraycopy(this.barBytes, 0, expected, this.fooBytes.length, this.barBytes.length);\r\n    testDecodeToMonoAll(input, byte[].class, step -> step.consumeNextWith(expectBytes(expected)).verifyComplete());\r\n}\nprivate Consumer<byte[]> expectBytes(byte[] expected) {\r\n    return bytes -> assertThat(bytes).isEqualTo(expected);\r\n}",
    "comment": "\n * @author Arjen Poutsma\n "
  },
  {
    "entityId": "org.springframework.core.codec.ByteArrayDecoderTests#canDecode()",
    "entityType": "method",
    "code": "@Override\r\n@Test\r\nprotected void canDecode() {\r\n    assertThat(this.decoder.canDecode(ResolvableType.forClass(byte[].class), MimeTypeUtils.TEXT_PLAIN)).isTrue();\r\n    assertThat(this.decoder.canDecode(ResolvableType.forClass(Integer.class), MimeTypeUtils.TEXT_PLAIN)).isFalse();\r\n    assertThat(this.decoder.canDecode(ResolvableType.forClass(byte[].class), MimeTypeUtils.APPLICATION_JSON)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.ByteArrayDecoderTests#decode()",
    "entityType": "method",
    "code": "@Override\r\n@Test\r\nprotected void decode() {\r\n    Flux<DataBuffer> input = Flux.concat(dataBuffer(this.fooBytes), dataBuffer(this.barBytes));\r\n    testDecodeAll(input, byte[].class, step -> step.consumeNextWith(expectBytes(this.fooBytes)).consumeNextWith(expectBytes(this.barBytes)).verifyComplete());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.ByteArrayDecoderTests#decodeToMono()",
    "entityType": "method",
    "code": "@Override\r\n@Test\r\nprotected void decodeToMono() {\r\n    Flux<DataBuffer> input = Flux.concat(dataBuffer(this.fooBytes), dataBuffer(this.barBytes));\r\n    byte[] expected = new byte[this.fooBytes.length + this.barBytes.length];\r\n    System.arraycopy(this.fooBytes, 0, expected, 0, this.fooBytes.length);\r\n    System.arraycopy(this.barBytes, 0, expected, this.fooBytes.length, this.barBytes.length);\r\n    testDecodeToMonoAll(input, byte[].class, step -> step.consumeNextWith(expectBytes(expected)).verifyComplete());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.ByteArrayDecoderTests#expectBytes(byte[])",
    "entityType": "method",
    "code": "private Consumer<byte[]> expectBytes(byte[] expected) {\r\n    return bytes -> assertThat(bytes).isEqualTo(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.ByteArrayEncoderTests",
    "entityType": "class",
    "code": "private final byte[] fooBytes = \"foo\".getBytes(StandardCharsets.UTF_8);\nprivate final byte[] barBytes = \"bar\".getBytes(StandardCharsets.UTF_8);\nByteArrayEncoderTests() {\r\n    super(new ByteArrayEncoder());\r\n}\n@Override\r\n@Test\r\nprotected void canEncode() {\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(byte[].class), MimeTypeUtils.TEXT_PLAIN)).isTrue();\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(Integer.class), MimeTypeUtils.TEXT_PLAIN)).isFalse();\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(byte[].class), MimeTypeUtils.APPLICATION_JSON)).isTrue();\r\n    // SPR-15464\r\n    assertThat(this.encoder.canEncode(ResolvableType.NONE, null)).isFalse();\r\n}\n@Override\r\n@Test\r\nprotected void encode() {\r\n    Flux<byte[]> input = Flux.just(this.fooBytes, this.barBytes);\r\n    testEncodeAll(input, byte[].class, step -> step.consumeNextWith(expectBytes(this.fooBytes)).consumeNextWith(expectBytes(this.barBytes)).verifyComplete());\r\n}",
    "comment": "\n * @author Arjen Poutsma\n "
  },
  {
    "entityId": "org.springframework.core.codec.ByteArrayEncoderTests#canEncode()",
    "entityType": "method",
    "code": "@Override\r\n@Test\r\nprotected void canEncode() {\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(byte[].class), MimeTypeUtils.TEXT_PLAIN)).isTrue();\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(Integer.class), MimeTypeUtils.TEXT_PLAIN)).isFalse();\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(byte[].class), MimeTypeUtils.APPLICATION_JSON)).isTrue();\r\n    // SPR-15464\r\n    assertThat(this.encoder.canEncode(ResolvableType.NONE, null)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.ByteArrayEncoderTests#encode()",
    "entityType": "method",
    "code": "@Override\r\n@Test\r\nprotected void encode() {\r\n    Flux<byte[]> input = Flux.just(this.fooBytes, this.barBytes);\r\n    testEncodeAll(input, byte[].class, step -> step.consumeNextWith(expectBytes(this.fooBytes)).consumeNextWith(expectBytes(this.barBytes)).verifyComplete());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.ByteBufferDecoderTests",
    "entityType": "class",
    "code": "private final byte[] fooBytes = \"foo\".getBytes(StandardCharsets.UTF_8);\nprivate final byte[] barBytes = \"bar\".getBytes(StandardCharsets.UTF_8);\nByteBufferDecoderTests() {\r\n    super(new ByteBufferDecoder());\r\n}\n@Override\r\n@Test\r\nprotected void canDecode() {\r\n    assertThat(this.decoder.canDecode(ResolvableType.forClass(ByteBuffer.class), MimeTypeUtils.TEXT_PLAIN)).isTrue();\r\n    assertThat(this.decoder.canDecode(ResolvableType.forClass(Integer.class), MimeTypeUtils.TEXT_PLAIN)).isFalse();\r\n    assertThat(this.decoder.canDecode(ResolvableType.forClass(ByteBuffer.class), MimeTypeUtils.APPLICATION_JSON)).isTrue();\r\n}\n@Override\r\n@Test\r\nprotected void decode() {\r\n    Flux<DataBuffer> input = Flux.concat(dataBuffer(this.fooBytes), dataBuffer(this.barBytes));\r\n    testDecodeAll(input, ByteBuffer.class, step -> step.consumeNextWith(expectByteBuffer(ByteBuffer.wrap(this.fooBytes))).consumeNextWith(expectByteBuffer(ByteBuffer.wrap(this.barBytes))).verifyComplete());\r\n}\n@Override\r\n@Test\r\nprotected void decodeToMono() {\r\n    Flux<DataBuffer> input = Flux.concat(dataBuffer(this.fooBytes), dataBuffer(this.barBytes));\r\n    ByteBuffer expected = ByteBuffer.allocate(this.fooBytes.length + this.barBytes.length);\r\n    expected.put(this.fooBytes).put(this.barBytes).flip();\r\n    testDecodeToMonoAll(input, ByteBuffer.class, step -> step.consumeNextWith(expectByteBuffer(expected)).verifyComplete());\r\n}\nprivate Consumer<ByteBuffer> expectByteBuffer(ByteBuffer expected) {\r\n    return actual -> assertThat(actual).isEqualTo(expected);\r\n}",
    "comment": "\n * @author Sebastien Deleuze\n "
  },
  {
    "entityId": "org.springframework.core.codec.ByteBufferDecoderTests#canDecode()",
    "entityType": "method",
    "code": "@Override\r\n@Test\r\nprotected void canDecode() {\r\n    assertThat(this.decoder.canDecode(ResolvableType.forClass(ByteBuffer.class), MimeTypeUtils.TEXT_PLAIN)).isTrue();\r\n    assertThat(this.decoder.canDecode(ResolvableType.forClass(Integer.class), MimeTypeUtils.TEXT_PLAIN)).isFalse();\r\n    assertThat(this.decoder.canDecode(ResolvableType.forClass(ByteBuffer.class), MimeTypeUtils.APPLICATION_JSON)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.ByteBufferDecoderTests#decode()",
    "entityType": "method",
    "code": "@Override\r\n@Test\r\nprotected void decode() {\r\n    Flux<DataBuffer> input = Flux.concat(dataBuffer(this.fooBytes), dataBuffer(this.barBytes));\r\n    testDecodeAll(input, ByteBuffer.class, step -> step.consumeNextWith(expectByteBuffer(ByteBuffer.wrap(this.fooBytes))).consumeNextWith(expectByteBuffer(ByteBuffer.wrap(this.barBytes))).verifyComplete());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.ByteBufferDecoderTests#decodeToMono()",
    "entityType": "method",
    "code": "@Override\r\n@Test\r\nprotected void decodeToMono() {\r\n    Flux<DataBuffer> input = Flux.concat(dataBuffer(this.fooBytes), dataBuffer(this.barBytes));\r\n    ByteBuffer expected = ByteBuffer.allocate(this.fooBytes.length + this.barBytes.length);\r\n    expected.put(this.fooBytes).put(this.barBytes).flip();\r\n    testDecodeToMonoAll(input, ByteBuffer.class, step -> step.consumeNextWith(expectByteBuffer(expected)).verifyComplete());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.ByteBufferDecoderTests#expectByteBuffer(ByteBuffer)",
    "entityType": "method",
    "code": "private Consumer<ByteBuffer> expectByteBuffer(ByteBuffer expected) {\r\n    return actual -> assertThat(actual).isEqualTo(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.ByteBufferEncoderTests",
    "entityType": "class",
    "code": "private final byte[] fooBytes = \"foo\".getBytes(StandardCharsets.UTF_8);\nprivate final byte[] barBytes = \"bar\".getBytes(StandardCharsets.UTF_8);\nByteBufferEncoderTests() {\r\n    super(new ByteBufferEncoder());\r\n}\n@Override\r\n@Test\r\nprotected void canEncode() {\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(ByteBuffer.class), MimeTypeUtils.TEXT_PLAIN)).isTrue();\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(Integer.class), MimeTypeUtils.TEXT_PLAIN)).isFalse();\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(ByteBuffer.class), MimeTypeUtils.APPLICATION_JSON)).isTrue();\r\n    // SPR-15464\r\n    assertThat(this.encoder.canEncode(ResolvableType.NONE, null)).isFalse();\r\n}\n@Override\r\n@Test\r\nprotected void encode() {\r\n    Flux<ByteBuffer> input = Flux.just(this.fooBytes, this.barBytes).map(ByteBuffer::wrap);\r\n    testEncodeAll(input, ByteBuffer.class, step -> step.consumeNextWith(expectBytes(this.fooBytes)).consumeNextWith(expectBytes(this.barBytes)).verifyComplete());\r\n}",
    "comment": "\n * @author Sebastien Deleuze\n "
  },
  {
    "entityId": "org.springframework.core.codec.ByteBufferEncoderTests#canEncode()",
    "entityType": "method",
    "code": "@Override\r\n@Test\r\nprotected void canEncode() {\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(ByteBuffer.class), MimeTypeUtils.TEXT_PLAIN)).isTrue();\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(Integer.class), MimeTypeUtils.TEXT_PLAIN)).isFalse();\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(ByteBuffer.class), MimeTypeUtils.APPLICATION_JSON)).isTrue();\r\n    // SPR-15464\r\n    assertThat(this.encoder.canEncode(ResolvableType.NONE, null)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.ByteBufferEncoderTests#encode()",
    "entityType": "method",
    "code": "@Override\r\n@Test\r\nprotected void encode() {\r\n    Flux<ByteBuffer> input = Flux.just(this.fooBytes, this.barBytes).map(ByteBuffer::wrap);\r\n    testEncodeAll(input, ByteBuffer.class, step -> step.consumeNextWith(expectBytes(this.fooBytes)).consumeNextWith(expectBytes(this.barBytes)).verifyComplete());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.CharBufferDecoderTests",
    "entityType": "class",
    "code": "private static final ResolvableType TYPE = ResolvableType.forClass(CharBuffer.class);\nCharBufferDecoderTests() {\r\n    super(CharBufferDecoder.allMimeTypes());\r\n}\n@Override\r\n@Test\r\nprotected void canDecode() {\r\n    assertThat(this.decoder.canDecode(TYPE, MimeTypeUtils.TEXT_PLAIN)).isTrue();\r\n    assertThat(this.decoder.canDecode(TYPE, MimeTypeUtils.TEXT_HTML)).isTrue();\r\n    assertThat(this.decoder.canDecode(TYPE, MimeTypeUtils.APPLICATION_JSON)).isTrue();\r\n    assertThat(this.decoder.canDecode(TYPE, MimeTypeUtils.parseMimeType(\"text/plain;charset=utf-8\"))).isTrue();\r\n    assertThat(this.decoder.canDecode(ResolvableType.forClass(Integer.class), MimeTypeUtils.TEXT_PLAIN)).isFalse();\r\n    assertThat(this.decoder.canDecode(ResolvableType.forClass(Object.class), MimeTypeUtils.APPLICATION_JSON)).isFalse();\r\n}\n@Override\r\n@Test\r\nprotected void decode() {\r\n    CharBuffer u = charBuffer(\"ü\");\r\n    CharBuffer e = charBuffer(\"é\");\r\n    CharBuffer o = charBuffer(\"ø\");\r\n    String s = String.format(\"%s\\n%s\\n%s\", u, e, o);\r\n    Flux<DataBuffer> input = toDataBuffers(s, 1, UTF_8);\r\n    testDecodeAll(input, TYPE, step -> step.expectNext(u, e, o).verifyComplete(), null, null);\r\n}\n@Test\r\nvoid decodeMultibyteCharacterUtf16() {\r\n    CharBuffer u = charBuffer(\"ü\");\r\n    CharBuffer e = charBuffer(\"é\");\r\n    CharBuffer o = charBuffer(\"ø\");\r\n    String s = String.format(\"%s\\n%s\\n%s\", u, e, o);\r\n    Flux<DataBuffer> source = toDataBuffers(s, 2, UTF_16BE);\r\n    MimeType mimeType = MimeTypeUtils.parseMimeType(\"text/plain;charset=utf-16be\");\r\n    testDecode(source, TYPE, step -> step.expectNext(u, e, o).verifyComplete(), mimeType, null);\r\n}\nprivate Flux<DataBuffer> toDataBuffers(String s, int length, Charset charset) {\r\n    byte[] bytes = s.getBytes(charset);\r\n    List<byte[]> chunks = new ArrayList<>();\r\n    for (int i = 0; i < bytes.length; i += length) {\r\n        chunks.add(Arrays.copyOfRange(bytes, i, i + length));\r\n    }\r\n    return Flux.fromIterable(chunks).map(chunk -> {\r\n        DataBuffer dataBuffer = this.bufferFactory.allocateBuffer(length);\r\n        dataBuffer.write(chunk, 0, chunk.length);\r\n        return dataBuffer;\r\n    });\r\n}\n@Test\r\nvoid decodeNewLine() {\r\n    Flux<DataBuffer> input = Flux.just(stringBuffer(\"\\r\\nabc\\n\"), stringBuffer(\"def\"), stringBuffer(\"ghi\\r\\n\\n\"), stringBuffer(\"jkl\"), stringBuffer(\"mno\\npqr\\n\"), stringBuffer(\"stu\"), stringBuffer(\"vw\"), stringBuffer(\"xyz\"));\r\n    testDecode(input, CharBuffer.class, step -> step.expectNext(charBuffer(\"\")).as(\"1st\").expectNext(charBuffer(\"abc\")).expectNext(charBuffer(\"defghi\")).expectNext(charBuffer(\"\")).as(\"2nd\").expectNext(charBuffer(\"jklmno\")).expectNext(charBuffer(\"pqr\")).expectNext(charBuffer(\"stuvwxyz\")).expectComplete().verify());\r\n}\n@Test\r\nvoid decodeNewlinesAcrossBuffers() {\r\n    Flux<DataBuffer> input = Flux.just(stringBuffer(\"\\r\"), stringBuffer(\"\\n\"), stringBuffer(\"xyz\"));\r\n    testDecode(input, CharBuffer.class, step -> step.expectNext(charBuffer(\"\")).expectNext(charBuffer(\"xyz\")).expectComplete().verify());\r\n}\n@Test\r\nvoid maxInMemoryLimit() {\r\n    Flux<DataBuffer> input = Flux.just(stringBuffer(\"abc\\n\"), stringBuffer(\"defg\\n\"), stringBuffer(\"hi\"), stringBuffer(\"jkl\"), stringBuffer(\"mnop\"));\r\n    this.decoder.setMaxInMemorySize(5);\r\n    testDecode(input, CharBuffer.class, step -> step.expectNext(charBuffer(\"abc\")).expectNext(charBuffer(\"defg\")).verifyError(DataBufferLimitException.class));\r\n}\n@Test\r\nvoid maxInMemoryLimitDoesNotApplyToParsedItemsThatDontRequireBuffering() {\r\n    Flux<DataBuffer> input = Flux.just(stringBuffer(\"TOO MUCH DATA\\nanother line\\n\\nand another\\n\"));\r\n    this.decoder.setMaxInMemorySize(5);\r\n    testDecode(input, CharBuffer.class, step -> step.expectNext(charBuffer(\"TOO MUCH DATA\")).expectNext(charBuffer(\"another line\")).expectNext(charBuffer(\"\")).expectNext(charBuffer(\"and another\")).expectComplete().verify());\r\n}\n@Test\r\n// gh-24339\r\nvoid maxInMemoryLimitReleaseUnprocessedLinesWhenUnlimited() {\r\n    Flux<DataBuffer> input = Flux.just(stringBuffer(\"Line 1\\nLine 2\\nLine 3\\n\"));\r\n    this.decoder.setMaxInMemorySize(-1);\r\n    testDecodeCancel(input, ResolvableType.forClass(String.class), null, Collections.emptyMap());\r\n}\n@Test\r\nvoid decodeNewLineIncludeDelimiters() {\r\n    this.decoder = CharBufferDecoder.allMimeTypes(CharBufferDecoder.DEFAULT_DELIMITERS, false);\r\n    Flux<DataBuffer> input = Flux.just(stringBuffer(\"\\r\\nabc\\n\"), stringBuffer(\"def\"), stringBuffer(\"ghi\\r\\n\\n\"), stringBuffer(\"jkl\"), stringBuffer(\"mno\\npqr\\n\"), stringBuffer(\"stu\"), stringBuffer(\"vw\"), stringBuffer(\"xyz\"));\r\n    testDecode(input, CharBuffer.class, step -> step.expectNext(charBuffer(\"\\r\\n\")).expectNext(charBuffer(\"abc\\n\")).expectNext(charBuffer(\"defghi\\r\\n\")).expectNext(charBuffer(\"\\n\")).expectNext(charBuffer(\"jklmno\\n\")).expectNext(charBuffer(\"pqr\\n\")).expectNext(charBuffer(\"stuvwxyz\")).expectComplete().verify());\r\n}\n@Test\r\nvoid decodeEmptyFlux() {\r\n    Flux<DataBuffer> input = Flux.empty();\r\n    testDecode(input, String.class, step -> step.expectComplete().verify());\r\n}\n@Test\r\nvoid decodeEmptyDataBuffer() {\r\n    Flux<DataBuffer> input = Flux.just(stringBuffer(\"\"));\r\n    Flux<CharBuffer> output = this.decoder.decode(input, TYPE, null, Collections.emptyMap());\r\n    StepVerifier.create(output).expectNext(charBuffer(\"\")).expectComplete().verify();\r\n}\n@Override\r\n@Test\r\nprotected void decodeToMono() {\r\n    Flux<DataBuffer> input = Flux.just(stringBuffer(\"foo\"), stringBuffer(\"bar\"), stringBuffer(\"baz\"));\r\n    testDecodeToMonoAll(input, CharBuffer.class, step -> step.expectNext(charBuffer(\"foobarbaz\")).expectComplete().verify());\r\n}\n@Test\r\nvoid decodeToMonoWithEmptyFlux() {\r\n    Flux<DataBuffer> input = Flux.empty();\r\n    testDecodeToMono(input, String.class, step -> step.expectComplete().verify());\r\n}\nprivate DataBuffer stringBuffer(String value) {\r\n    byte[] bytes = value.getBytes(StandardCharsets.UTF_8);\r\n    DataBuffer buffer = this.bufferFactory.allocateBuffer(bytes.length);\r\n    buffer.write(bytes);\r\n    return buffer;\r\n}\nprivate CharBuffer charBuffer(String value) {\r\n    return CharBuffer.allocate(value.length()).put(value).flip();\r\n}",
    "comment": "\n * Tests for {@link CharBufferDecoder}.\n *\n * @author Markus Heiden\n * @author Arjen Poutsma\n "
  },
  {
    "entityId": "org.springframework.core.codec.CharBufferDecoderTests#canDecode()",
    "entityType": "method",
    "code": "@Override\r\n@Test\r\nprotected void canDecode() {\r\n    assertThat(this.decoder.canDecode(TYPE, MimeTypeUtils.TEXT_PLAIN)).isTrue();\r\n    assertThat(this.decoder.canDecode(TYPE, MimeTypeUtils.TEXT_HTML)).isTrue();\r\n    assertThat(this.decoder.canDecode(TYPE, MimeTypeUtils.APPLICATION_JSON)).isTrue();\r\n    assertThat(this.decoder.canDecode(TYPE, MimeTypeUtils.parseMimeType(\"text/plain;charset=utf-8\"))).isTrue();\r\n    assertThat(this.decoder.canDecode(ResolvableType.forClass(Integer.class), MimeTypeUtils.TEXT_PLAIN)).isFalse();\r\n    assertThat(this.decoder.canDecode(ResolvableType.forClass(Object.class), MimeTypeUtils.APPLICATION_JSON)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.CharBufferDecoderTests#decode()",
    "entityType": "method",
    "code": "@Override\r\n@Test\r\nprotected void decode() {\r\n    CharBuffer u = charBuffer(\"ü\");\r\n    CharBuffer e = charBuffer(\"é\");\r\n    CharBuffer o = charBuffer(\"ø\");\r\n    String s = String.format(\"%s\\n%s\\n%s\", u, e, o);\r\n    Flux<DataBuffer> input = toDataBuffers(s, 1, UTF_8);\r\n    testDecodeAll(input, TYPE, step -> step.expectNext(u, e, o).verifyComplete(), null, null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.CharBufferDecoderTests#decodeMultibyteCharacterUtf16()",
    "entityType": "method",
    "code": "@Test\r\nvoid decodeMultibyteCharacterUtf16() {\r\n    CharBuffer u = charBuffer(\"ü\");\r\n    CharBuffer e = charBuffer(\"é\");\r\n    CharBuffer o = charBuffer(\"ø\");\r\n    String s = String.format(\"%s\\n%s\\n%s\", u, e, o);\r\n    Flux<DataBuffer> source = toDataBuffers(s, 2, UTF_16BE);\r\n    MimeType mimeType = MimeTypeUtils.parseMimeType(\"text/plain;charset=utf-16be\");\r\n    testDecode(source, TYPE, step -> step.expectNext(u, e, o).verifyComplete(), mimeType, null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.CharBufferDecoderTests#toDataBuffers(String,int,Charset)",
    "entityType": "method",
    "code": "private Flux<DataBuffer> toDataBuffers(String s, int length, Charset charset) {\r\n    byte[] bytes = s.getBytes(charset);\r\n    List<byte[]> chunks = new ArrayList<>();\r\n    for (int i = 0; i < bytes.length; i += length) {\r\n        chunks.add(Arrays.copyOfRange(bytes, i, i + length));\r\n    }\r\n    return Flux.fromIterable(chunks).map(chunk -> {\r\n        DataBuffer dataBuffer = this.bufferFactory.allocateBuffer(length);\r\n        dataBuffer.write(chunk, 0, chunk.length);\r\n        return dataBuffer;\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.CharBufferDecoderTests#decodeNewLine()",
    "entityType": "method",
    "code": "@Test\r\nvoid decodeNewLine() {\r\n    Flux<DataBuffer> input = Flux.just(stringBuffer(\"\\r\\nabc\\n\"), stringBuffer(\"def\"), stringBuffer(\"ghi\\r\\n\\n\"), stringBuffer(\"jkl\"), stringBuffer(\"mno\\npqr\\n\"), stringBuffer(\"stu\"), stringBuffer(\"vw\"), stringBuffer(\"xyz\"));\r\n    testDecode(input, CharBuffer.class, step -> step.expectNext(charBuffer(\"\")).as(\"1st\").expectNext(charBuffer(\"abc\")).expectNext(charBuffer(\"defghi\")).expectNext(charBuffer(\"\")).as(\"2nd\").expectNext(charBuffer(\"jklmno\")).expectNext(charBuffer(\"pqr\")).expectNext(charBuffer(\"stuvwxyz\")).expectComplete().verify());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.CharBufferDecoderTests#decodeNewlinesAcrossBuffers()",
    "entityType": "method",
    "code": "@Test\r\nvoid decodeNewlinesAcrossBuffers() {\r\n    Flux<DataBuffer> input = Flux.just(stringBuffer(\"\\r\"), stringBuffer(\"\\n\"), stringBuffer(\"xyz\"));\r\n    testDecode(input, CharBuffer.class, step -> step.expectNext(charBuffer(\"\")).expectNext(charBuffer(\"xyz\")).expectComplete().verify());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.CharBufferDecoderTests#maxInMemoryLimit()",
    "entityType": "method",
    "code": "@Test\r\nvoid maxInMemoryLimit() {\r\n    Flux<DataBuffer> input = Flux.just(stringBuffer(\"abc\\n\"), stringBuffer(\"defg\\n\"), stringBuffer(\"hi\"), stringBuffer(\"jkl\"), stringBuffer(\"mnop\"));\r\n    this.decoder.setMaxInMemorySize(5);\r\n    testDecode(input, CharBuffer.class, step -> step.expectNext(charBuffer(\"abc\")).expectNext(charBuffer(\"defg\")).verifyError(DataBufferLimitException.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.CharBufferDecoderTests#maxInMemoryLimitDoesNotApplyToParsedItemsThatDontRequireBuffering()",
    "entityType": "method",
    "code": "@Test\r\nvoid maxInMemoryLimitDoesNotApplyToParsedItemsThatDontRequireBuffering() {\r\n    Flux<DataBuffer> input = Flux.just(stringBuffer(\"TOO MUCH DATA\\nanother line\\n\\nand another\\n\"));\r\n    this.decoder.setMaxInMemorySize(5);\r\n    testDecode(input, CharBuffer.class, step -> step.expectNext(charBuffer(\"TOO MUCH DATA\")).expectNext(charBuffer(\"another line\")).expectNext(charBuffer(\"\")).expectNext(charBuffer(\"and another\")).expectComplete().verify());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.CharBufferDecoderTests#maxInMemoryLimitReleaseUnprocessedLinesWhenUnlimited()",
    "entityType": "method",
    "code": "@Test\r\n// gh-24339\r\nvoid maxInMemoryLimitReleaseUnprocessedLinesWhenUnlimited() {\r\n    Flux<DataBuffer> input = Flux.just(stringBuffer(\"Line 1\\nLine 2\\nLine 3\\n\"));\r\n    this.decoder.setMaxInMemorySize(-1);\r\n    testDecodeCancel(input, ResolvableType.forClass(String.class), null, Collections.emptyMap());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.CharBufferDecoderTests#decodeNewLineIncludeDelimiters()",
    "entityType": "method",
    "code": "@Test\r\nvoid decodeNewLineIncludeDelimiters() {\r\n    this.decoder = CharBufferDecoder.allMimeTypes(CharBufferDecoder.DEFAULT_DELIMITERS, false);\r\n    Flux<DataBuffer> input = Flux.just(stringBuffer(\"\\r\\nabc\\n\"), stringBuffer(\"def\"), stringBuffer(\"ghi\\r\\n\\n\"), stringBuffer(\"jkl\"), stringBuffer(\"mno\\npqr\\n\"), stringBuffer(\"stu\"), stringBuffer(\"vw\"), stringBuffer(\"xyz\"));\r\n    testDecode(input, CharBuffer.class, step -> step.expectNext(charBuffer(\"\\r\\n\")).expectNext(charBuffer(\"abc\\n\")).expectNext(charBuffer(\"defghi\\r\\n\")).expectNext(charBuffer(\"\\n\")).expectNext(charBuffer(\"jklmno\\n\")).expectNext(charBuffer(\"pqr\\n\")).expectNext(charBuffer(\"stuvwxyz\")).expectComplete().verify());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.CharBufferDecoderTests#decodeEmptyFlux()",
    "entityType": "method",
    "code": "@Test\r\nvoid decodeEmptyFlux() {\r\n    Flux<DataBuffer> input = Flux.empty();\r\n    testDecode(input, String.class, step -> step.expectComplete().verify());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.CharBufferDecoderTests#decodeEmptyDataBuffer()",
    "entityType": "method",
    "code": "@Test\r\nvoid decodeEmptyDataBuffer() {\r\n    Flux<DataBuffer> input = Flux.just(stringBuffer(\"\"));\r\n    Flux<CharBuffer> output = this.decoder.decode(input, TYPE, null, Collections.emptyMap());\r\n    StepVerifier.create(output).expectNext(charBuffer(\"\")).expectComplete().verify();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.CharBufferDecoderTests#decodeToMono()",
    "entityType": "method",
    "code": "@Override\r\n@Test\r\nprotected void decodeToMono() {\r\n    Flux<DataBuffer> input = Flux.just(stringBuffer(\"foo\"), stringBuffer(\"bar\"), stringBuffer(\"baz\"));\r\n    testDecodeToMonoAll(input, CharBuffer.class, step -> step.expectNext(charBuffer(\"foobarbaz\")).expectComplete().verify());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.CharBufferDecoderTests#decodeToMonoWithEmptyFlux()",
    "entityType": "method",
    "code": "@Test\r\nvoid decodeToMonoWithEmptyFlux() {\r\n    Flux<DataBuffer> input = Flux.empty();\r\n    testDecodeToMono(input, String.class, step -> step.expectComplete().verify());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.CharBufferDecoderTests#stringBuffer(String)",
    "entityType": "method",
    "code": "private DataBuffer stringBuffer(String value) {\r\n    byte[] bytes = value.getBytes(StandardCharsets.UTF_8);\r\n    DataBuffer buffer = this.bufferFactory.allocateBuffer(bytes.length);\r\n    buffer.write(bytes);\r\n    return buffer;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.CharBufferDecoderTests#charBuffer(String)",
    "entityType": "method",
    "code": "private CharBuffer charBuffer(String value) {\r\n    return CharBuffer.allocate(value.length()).put(value).flip();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.CharSequenceEncoderTests",
    "entityType": "class",
    "code": "private final String foo = \"foo\";\nprivate final String bar = \"bar\";\nCharSequenceEncoderTests() {\r\n    super(CharSequenceEncoder.textPlainOnly());\r\n}\n@Override\r\n@Test\r\nprotected void canEncode() {\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(String.class), MimeTypeUtils.TEXT_PLAIN)).isTrue();\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(StringBuilder.class), MimeTypeUtils.TEXT_PLAIN)).isTrue();\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(StringBuffer.class), MimeTypeUtils.TEXT_PLAIN)).isTrue();\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(Integer.class), MimeTypeUtils.TEXT_PLAIN)).isFalse();\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(String.class), MimeTypeUtils.APPLICATION_JSON)).isFalse();\r\n    // SPR-15464\r\n    assertThat(this.encoder.canEncode(ResolvableType.NONE, null)).isFalse();\r\n}\n@Override\r\n@Test\r\nprotected void encode() {\r\n    Flux<CharSequence> input = Flux.just(this.foo, this.bar);\r\n    testEncodeAll(input, CharSequence.class, step -> step.consumeNextWith(expectString(this.foo)).consumeNextWith(expectString(this.bar)).verifyComplete());\r\n}\n@Test\r\nvoid calculateCapacity() {\r\n    String sequence = \"Hello World!\";\r\n    Stream.of(UTF_8, UTF_16, ISO_8859_1, US_ASCII, Charset.forName(\"BIG5\")).forEach(charset -> {\r\n        int capacity = this.encoder.calculateCapacity(sequence, charset);\r\n        int length = sequence.length();\r\n        assertThat(capacity).as(String.format(\"%s has capacity %d; length %d\", charset, capacity, length)).isGreaterThanOrEqualTo(length);\r\n    });\r\n}",
    "comment": "\n * @author Sebastien Deleuze\n "
  },
  {
    "entityId": "org.springframework.core.codec.CharSequenceEncoderTests#canEncode()",
    "entityType": "method",
    "code": "@Override\r\n@Test\r\nprotected void canEncode() {\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(String.class), MimeTypeUtils.TEXT_PLAIN)).isTrue();\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(StringBuilder.class), MimeTypeUtils.TEXT_PLAIN)).isTrue();\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(StringBuffer.class), MimeTypeUtils.TEXT_PLAIN)).isTrue();\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(Integer.class), MimeTypeUtils.TEXT_PLAIN)).isFalse();\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(String.class), MimeTypeUtils.APPLICATION_JSON)).isFalse();\r\n    // SPR-15464\r\n    assertThat(this.encoder.canEncode(ResolvableType.NONE, null)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.CharSequenceEncoderTests#encode()",
    "entityType": "method",
    "code": "@Override\r\n@Test\r\nprotected void encode() {\r\n    Flux<CharSequence> input = Flux.just(this.foo, this.bar);\r\n    testEncodeAll(input, CharSequence.class, step -> step.consumeNextWith(expectString(this.foo)).consumeNextWith(expectString(this.bar)).verifyComplete());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.CharSequenceEncoderTests#calculateCapacity()",
    "entityType": "method",
    "code": "@Test\r\nvoid calculateCapacity() {\r\n    String sequence = \"Hello World!\";\r\n    Stream.of(UTF_8, UTF_16, ISO_8859_1, US_ASCII, Charset.forName(\"BIG5\")).forEach(charset -> {\r\n        int capacity = this.encoder.calculateCapacity(sequence, charset);\r\n        int length = sequence.length();\r\n        assertThat(capacity).as(String.format(\"%s has capacity %d; length %d\", charset, capacity, length)).isGreaterThanOrEqualTo(length);\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.DataBufferDecoderTests",
    "entityType": "class",
    "code": "private final byte[] fooBytes = \"foo\".getBytes(StandardCharsets.UTF_8);\nprivate final byte[] barBytes = \"bar\".getBytes(StandardCharsets.UTF_8);\nDataBufferDecoderTests() {\r\n    super(new DataBufferDecoder());\r\n}\n@Override\r\n@Test\r\nprotected void canDecode() {\r\n    assertThat(this.decoder.canDecode(ResolvableType.forClass(DataBuffer.class), MimeTypeUtils.TEXT_PLAIN)).isTrue();\r\n    assertThat(this.decoder.canDecode(ResolvableType.forClass(Integer.class), MimeTypeUtils.TEXT_PLAIN)).isFalse();\r\n    assertThat(this.decoder.canDecode(ResolvableType.forClass(DataBuffer.class), MimeTypeUtils.APPLICATION_JSON)).isTrue();\r\n}\n@Override\r\n@Test\r\nprotected void decode() {\r\n    Flux<DataBuffer> input = Flux.just(this.bufferFactory.wrap(this.fooBytes), this.bufferFactory.wrap(this.barBytes));\r\n    testDecodeAll(input, DataBuffer.class, step -> step.consumeNextWith(expectDataBuffer(this.fooBytes)).consumeNextWith(expectDataBuffer(this.barBytes)).verifyComplete());\r\n}\n@Override\r\n@Test\r\nprotected void decodeToMono() {\r\n    Flux<DataBuffer> input = Flux.concat(dataBuffer(this.fooBytes), dataBuffer(this.barBytes));\r\n    byte[] expected = new byte[this.fooBytes.length + this.barBytes.length];\r\n    System.arraycopy(this.fooBytes, 0, expected, 0, this.fooBytes.length);\r\n    System.arraycopy(this.barBytes, 0, expected, this.fooBytes.length, this.barBytes.length);\r\n    testDecodeToMonoAll(input, DataBuffer.class, step -> step.consumeNextWith(expectDataBuffer(expected)).verifyComplete());\r\n}\nprivate Consumer<DataBuffer> expectDataBuffer(byte[] expected) {\r\n    return actual -> {\r\n        byte[] actualBytes = new byte[actual.readableByteCount()];\r\n        actual.read(actualBytes);\r\n        assertThat(actualBytes).isEqualTo(expected);\r\n        DataBufferUtils.release(actual);\r\n    };\r\n}",
    "comment": "\n * @author Sebastien Deleuze\n "
  },
  {
    "entityId": "org.springframework.core.codec.DataBufferDecoderTests#canDecode()",
    "entityType": "method",
    "code": "@Override\r\n@Test\r\nprotected void canDecode() {\r\n    assertThat(this.decoder.canDecode(ResolvableType.forClass(DataBuffer.class), MimeTypeUtils.TEXT_PLAIN)).isTrue();\r\n    assertThat(this.decoder.canDecode(ResolvableType.forClass(Integer.class), MimeTypeUtils.TEXT_PLAIN)).isFalse();\r\n    assertThat(this.decoder.canDecode(ResolvableType.forClass(DataBuffer.class), MimeTypeUtils.APPLICATION_JSON)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.DataBufferDecoderTests#decode()",
    "entityType": "method",
    "code": "@Override\r\n@Test\r\nprotected void decode() {\r\n    Flux<DataBuffer> input = Flux.just(this.bufferFactory.wrap(this.fooBytes), this.bufferFactory.wrap(this.barBytes));\r\n    testDecodeAll(input, DataBuffer.class, step -> step.consumeNextWith(expectDataBuffer(this.fooBytes)).consumeNextWith(expectDataBuffer(this.barBytes)).verifyComplete());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.DataBufferDecoderTests#decodeToMono()",
    "entityType": "method",
    "code": "@Override\r\n@Test\r\nprotected void decodeToMono() {\r\n    Flux<DataBuffer> input = Flux.concat(dataBuffer(this.fooBytes), dataBuffer(this.barBytes));\r\n    byte[] expected = new byte[this.fooBytes.length + this.barBytes.length];\r\n    System.arraycopy(this.fooBytes, 0, expected, 0, this.fooBytes.length);\r\n    System.arraycopy(this.barBytes, 0, expected, this.fooBytes.length, this.barBytes.length);\r\n    testDecodeToMonoAll(input, DataBuffer.class, step -> step.consumeNextWith(expectDataBuffer(expected)).verifyComplete());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.DataBufferDecoderTests#expectDataBuffer(byte[])",
    "entityType": "method",
    "code": "private Consumer<DataBuffer> expectDataBuffer(byte[] expected) {\r\n    return actual -> {\r\n        byte[] actualBytes = new byte[actual.readableByteCount()];\r\n        actual.read(actualBytes);\r\n        assertThat(actualBytes).isEqualTo(expected);\r\n        DataBufferUtils.release(actual);\r\n    };\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.DataBufferEncoderTests",
    "entityType": "class",
    "code": "private final byte[] fooBytes = \"foo\".getBytes(StandardCharsets.UTF_8);\nprivate final byte[] barBytes = \"bar\".getBytes(StandardCharsets.UTF_8);\nDataBufferEncoderTests() {\r\n    super(new DataBufferEncoder());\r\n}\n@Override\r\n@Test\r\nprotected void canEncode() {\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(DataBuffer.class), MimeTypeUtils.TEXT_PLAIN)).isTrue();\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(Integer.class), MimeTypeUtils.TEXT_PLAIN)).isFalse();\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(DataBuffer.class), MimeTypeUtils.APPLICATION_JSON)).isTrue();\r\n    // SPR-15464\r\n    assertThat(this.encoder.canEncode(ResolvableType.NONE, null)).isFalse();\r\n}\n@Override\r\n@Test\r\nprotected void encode() {\r\n    Flux<DataBuffer> input = Flux.just(this.fooBytes, this.barBytes).flatMap(bytes -> Mono.defer(() -> {\r\n        DataBuffer dataBuffer = this.bufferFactory.allocateBuffer(bytes.length);\r\n        dataBuffer.write(bytes);\r\n        return Mono.just(dataBuffer);\r\n    }));\r\n    testEncodeAll(input, DataBuffer.class, step -> step.consumeNextWith(expectBytes(this.fooBytes)).consumeNextWith(expectBytes(this.barBytes)).verifyComplete());\r\n}",
    "comment": "\n * @author Sebastien Deleuze\n "
  },
  {
    "entityId": "org.springframework.core.codec.DataBufferEncoderTests#canEncode()",
    "entityType": "method",
    "code": "@Override\r\n@Test\r\nprotected void canEncode() {\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(DataBuffer.class), MimeTypeUtils.TEXT_PLAIN)).isTrue();\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(Integer.class), MimeTypeUtils.TEXT_PLAIN)).isFalse();\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(DataBuffer.class), MimeTypeUtils.APPLICATION_JSON)).isTrue();\r\n    // SPR-15464\r\n    assertThat(this.encoder.canEncode(ResolvableType.NONE, null)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.DataBufferEncoderTests#encode()",
    "entityType": "method",
    "code": "@Override\r\n@Test\r\nprotected void encode() {\r\n    Flux<DataBuffer> input = Flux.just(this.fooBytes, this.barBytes).flatMap(bytes -> Mono.defer(() -> {\r\n        DataBuffer dataBuffer = this.bufferFactory.allocateBuffer(bytes.length);\r\n        dataBuffer.write(bytes);\r\n        return Mono.just(dataBuffer);\r\n    }));\r\n    testEncodeAll(input, DataBuffer.class, step -> step.consumeNextWith(expectBytes(this.fooBytes)).consumeNextWith(expectBytes(this.barBytes)).verifyComplete());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.Netty5BufferDecoderTests",
    "entityType": "class",
    "code": "private final byte[] fooBytes = \"foo\".getBytes(StandardCharsets.UTF_8);\nprivate final byte[] barBytes = \"bar\".getBytes(StandardCharsets.UTF_8);\nNetty5BufferDecoderTests() {\r\n    super(new Netty5BufferDecoder());\r\n}\n@Override\r\n@Test\r\nprotected void canDecode() {\r\n    assertThat(this.decoder.canDecode(ResolvableType.forClass(Buffer.class), MimeTypeUtils.TEXT_PLAIN)).isTrue();\r\n    assertThat(this.decoder.canDecode(ResolvableType.forClass(Integer.class), MimeTypeUtils.TEXT_PLAIN)).isFalse();\r\n    assertThat(this.decoder.canDecode(ResolvableType.forClass(Buffer.class), MimeTypeUtils.APPLICATION_JSON)).isTrue();\r\n}\n@Override\r\n@Test\r\nprotected void decode() {\r\n    Flux<DataBuffer> input = Flux.concat(dataBuffer(this.fooBytes), dataBuffer(this.barBytes));\r\n    testDecodeAll(input, Buffer.class, step -> step.consumeNextWith(expectByteBuffer(DefaultBufferAllocators.preferredAllocator().copyOf(this.fooBytes))).consumeNextWith(expectByteBuffer(DefaultBufferAllocators.preferredAllocator().copyOf(this.barBytes))).verifyComplete());\r\n}\n@Override\r\n@Test\r\nprotected void decodeToMono() {\r\n    Flux<DataBuffer> input = Flux.concat(dataBuffer(this.fooBytes), dataBuffer(this.barBytes));\r\n    Buffer expected = DefaultBufferAllocators.preferredAllocator().allocate(this.fooBytes.length + this.barBytes.length).writeBytes(this.fooBytes).writeBytes(this.barBytes).readerOffset(0);\r\n    testDecodeToMonoAll(input, Buffer.class, step -> step.consumeNextWith(expectByteBuffer(expected)).verifyComplete());\r\n}\nprivate Consumer<Buffer> expectByteBuffer(Buffer expected) {\r\n    return actual -> {\r\n        try (actual;\r\n            expected) {\r\n            assertThat(actual).isEqualTo(expected);\r\n        }\r\n    };\r\n}",
    "comment": "\n * @author Arjen Poutsma\n "
  },
  {
    "entityId": "org.springframework.core.codec.Netty5BufferDecoderTests#canDecode()",
    "entityType": "method",
    "code": "@Override\r\n@Test\r\nprotected void canDecode() {\r\n    assertThat(this.decoder.canDecode(ResolvableType.forClass(Buffer.class), MimeTypeUtils.TEXT_PLAIN)).isTrue();\r\n    assertThat(this.decoder.canDecode(ResolvableType.forClass(Integer.class), MimeTypeUtils.TEXT_PLAIN)).isFalse();\r\n    assertThat(this.decoder.canDecode(ResolvableType.forClass(Buffer.class), MimeTypeUtils.APPLICATION_JSON)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.Netty5BufferDecoderTests#decode()",
    "entityType": "method",
    "code": "@Override\r\n@Test\r\nprotected void decode() {\r\n    Flux<DataBuffer> input = Flux.concat(dataBuffer(this.fooBytes), dataBuffer(this.barBytes));\r\n    testDecodeAll(input, Buffer.class, step -> step.consumeNextWith(expectByteBuffer(DefaultBufferAllocators.preferredAllocator().copyOf(this.fooBytes))).consumeNextWith(expectByteBuffer(DefaultBufferAllocators.preferredAllocator().copyOf(this.barBytes))).verifyComplete());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.Netty5BufferDecoderTests#decodeToMono()",
    "entityType": "method",
    "code": "@Override\r\n@Test\r\nprotected void decodeToMono() {\r\n    Flux<DataBuffer> input = Flux.concat(dataBuffer(this.fooBytes), dataBuffer(this.barBytes));\r\n    Buffer expected = DefaultBufferAllocators.preferredAllocator().allocate(this.fooBytes.length + this.barBytes.length).writeBytes(this.fooBytes).writeBytes(this.barBytes).readerOffset(0);\r\n    testDecodeToMonoAll(input, Buffer.class, step -> step.consumeNextWith(expectByteBuffer(expected)).verifyComplete());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.Netty5BufferDecoderTests#expectByteBuffer(Buffer)",
    "entityType": "method",
    "code": "private Consumer<Buffer> expectByteBuffer(Buffer expected) {\r\n    return actual -> {\r\n        try (actual;\r\n            expected) {\r\n            assertThat(actual).isEqualTo(expected);\r\n        }\r\n    };\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.Netty5BufferEncoderTests",
    "entityType": "class",
    "code": "private final byte[] fooBytes = \"foo\".getBytes(StandardCharsets.UTF_8);\nprivate final byte[] barBytes = \"bar\".getBytes(StandardCharsets.UTF_8);\nNetty5BufferEncoderTests() {\r\n    super(new Netty5BufferEncoder());\r\n}\n@Test\r\n@Override\r\npublic void canEncode() {\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(Buffer.class), MimeTypeUtils.TEXT_PLAIN)).isTrue();\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(Integer.class), MimeTypeUtils.TEXT_PLAIN)).isFalse();\r\n    assertThat(this.encoder.canEncode(ResolvableType.forClass(Buffer.class), MimeTypeUtils.APPLICATION_JSON)).isTrue();\r\n    // gh-20024\r\n    assertThat(this.encoder.canEncode(ResolvableType.NONE, null)).isFalse();\r\n}\n@Test\r\n@Override\r\n@SuppressWarnings(\"resource\")\r\npublic void encode() {\r\n    Flux<Buffer> input = Flux.just(this.fooBytes, this.barBytes).map(DefaultBufferAllocators.preferredAllocator()::copyOf);\r\n    testEncodeAll(input, Buffer.class, step -> step.consumeNextWith(expectBytes(this.fooBytes)).consumeNextWith(expectBytes(this.barBytes)).verifyComplete());\r\n}",
    "comment": "\n * @author Arjen Poutsma\n "
  }
]