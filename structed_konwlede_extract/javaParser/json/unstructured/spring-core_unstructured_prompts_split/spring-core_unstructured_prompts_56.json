[
  {
    "entityId": "org.springframework.core.env.CommandLinePropertySource#setNonOptionArgsPropertyName(String)",
    "entityType": "method",
    "code": "/**\r\n * Specify the name of the special \"non-option arguments\" property.\r\n * The default is {@value #DEFAULT_NON_OPTION_ARGS_PROPERTY_NAME}.\r\n */\r\npublic void setNonOptionArgsPropertyName(String nonOptionArgsPropertyName) {\r\n    this.nonOptionArgsPropertyName = nonOptionArgsPropertyName;\r\n}",
    "comment": "\n\t * Specify the name of the special \"non-option arguments\" property.\n\t * The default is {@value #DEFAULT_NON_OPTION_ARGS_PROPERTY_NAME}.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.CommandLinePropertySource#containsProperty(String)",
    "entityType": "method",
    "code": "/**\r\n * This implementation first checks to see if the name specified is the special\r\n * {@linkplain #setNonOptionArgsPropertyName(String) \"non-option arguments\" property},\r\n * and if so delegates to the abstract {@link #getNonOptionArgs()} method\r\n * checking to see whether it returns an empty collection. Otherwise, delegates to and\r\n * returns the value of the abstract {@link #containsOption(String)} method.\r\n */\r\n@Override\r\npublic final boolean containsProperty(String name) {\r\n    if (this.nonOptionArgsPropertyName.equals(name)) {\r\n        return !getNonOptionArgs().isEmpty();\r\n    }\r\n    return this.containsOption(name);\r\n}",
    "comment": "\n\t * This implementation first checks to see if the name specified is the special\n\t * {@linkplain #setNonOptionArgsPropertyName(String) \"non-option arguments\" property},\n\t * and if so delegates to the abstract {@link #getNonOptionArgs()} method\n\t * checking to see whether it returns an empty collection. Otherwise, delegates to and\n\t * returns the value of the abstract {@link #containsOption(String)} method.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.CommandLinePropertySource#getProperty(String)",
    "entityType": "method",
    "code": "/**\r\n * This implementation first checks to see if the name specified is the special\r\n * {@linkplain #setNonOptionArgsPropertyName(String) \"non-option arguments\" property},\r\n * and if so delegates to the abstract {@link #getNonOptionArgs()} method. If so\r\n * and the collection of non-option arguments is empty, this method returns\r\n * {@code null}. If not empty, it returns a comma-separated String of all non-option\r\n * arguments. Otherwise, this method delegates to and returns a comma-separated String\r\n * of the results of the abstract {@link #getOptionValues(String)} method or\r\n * {@code null} if there are no such option values.\r\n */\r\n@Override\r\n@Nullable\r\npublic final String getProperty(String name) {\r\n    if (this.nonOptionArgsPropertyName.equals(name)) {\r\n        Collection<String> nonOptionArguments = getNonOptionArgs();\r\n        if (nonOptionArguments.isEmpty()) {\r\n            return null;\r\n        } else {\r\n            return StringUtils.collectionToCommaDelimitedString(nonOptionArguments);\r\n        }\r\n    }\r\n    Collection<String> optionValues = getOptionValues(name);\r\n    if (optionValues == null) {\r\n        return null;\r\n    } else {\r\n        return StringUtils.collectionToCommaDelimitedString(optionValues);\r\n    }\r\n}",
    "comment": "\n\t * This implementation first checks to see if the name specified is the special\n\t * {@linkplain #setNonOptionArgsPropertyName(String) \"non-option arguments\" property},\n\t * and if so delegates to the abstract {@link #getNonOptionArgs()} method. If so\n\t * and the collection of non-option arguments is empty, this method returns\n\t * {@code null}. If not empty, it returns a comma-separated String of all non-option\n\t * arguments. Otherwise, this method delegates to and returns a comma-separated String\n\t * of the results of the abstract {@link #getOptionValues(String)} method or\n\t * {@code null} if there are no such option values.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.CommandLinePropertySource#containsOption(String)",
    "entityType": "method",
    "code": "/**\r\n * Return whether the set of option arguments parsed from the command line contains\r\n * an option with the given name.\r\n */\r\nprotected abstract boolean containsOption(String name);",
    "comment": "\n\t * Return whether the set of option arguments parsed from the command line contains\n\t * an option with the given name.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.CommandLinePropertySource#getOptionValues(String)",
    "entityType": "method",
    "code": "/**\r\n * Return the collection of values associated with the command line option having the\r\n * given name.\r\n * <ul>\r\n * <li>if the option is present and has no argument (for example: \"--foo\"), return an empty\r\n * collection ({@code []})</li>\r\n * <li>if the option is present and has a single value (for example, \"--foo=bar\"), return a\r\n * collection having one element ({@code [\"bar\"]})</li>\r\n * <li>if the option is present and the underlying command line parsing library\r\n * supports multiple arguments (for example, \"--foo=bar --foo=baz\"), return a collection\r\n * having elements for each value ({@code [\"bar\", \"baz\"]})</li>\r\n * <li>if the option is not present, return {@code null}</li>\r\n * </ul>\r\n */\r\n@Nullable\r\nprotected abstract List<String> getOptionValues(String name);",
    "comment": "\n\t * Return the collection of values associated with the command line option having the\n\t * given name.\n\t * <ul>\n\t * <li>if the option is present and has no argument (for example: \"--foo\"), return an empty\n\t * collection ({@code []})</li>\n\t * <li>if the option is present and has a single value (for example, \"--foo=bar\"), return a\n\t * collection having one element ({@code [\"bar\"]})</li>\n\t * <li>if the option is present and the underlying command line parsing library\n\t * supports multiple arguments (for example, \"--foo=bar --foo=baz\"), return a collection\n\t * having elements for each value ({@code [\"bar\", \"baz\"]})</li>\n\t * <li>if the option is not present, return {@code null}</li>\n\t * </ul>\n\t "
  },
  {
    "entityId": "org.springframework.core.env.CommandLinePropertySource#getNonOptionArgs()",
    "entityType": "method",
    "code": "/**\r\n * Return the collection of non-option arguments parsed from the command line.\r\n * Never {@code null}.\r\n */\r\nprotected abstract List<String> getNonOptionArgs();",
    "comment": "\n\t * Return the collection of non-option arguments parsed from the command line.\n\t * Never {@code null}.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.CompositePropertySource",
    "entityType": "class",
    "code": "private final Set<PropertySource<?>> propertySources = new LinkedHashSet<>();\n/**\r\n * Create a new {@code CompositePropertySource}.\r\n * @param name the name of the property source\r\n */\r\npublic CompositePropertySource(String name) {\r\n    super(name);\r\n}\n@Override\r\n@Nullable\r\npublic Object getProperty(String name) {\r\n    for (PropertySource<?> propertySource : this.propertySources) {\r\n        Object candidate = propertySource.getProperty(name);\r\n        if (candidate != null) {\r\n            return candidate;\r\n        }\r\n    }\r\n    return null;\r\n}\n@Override\r\npublic boolean containsProperty(String name) {\r\n    for (PropertySource<?> propertySource : this.propertySources) {\r\n        if (propertySource.containsProperty(name)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n@Override\r\npublic String[] getPropertyNames() {\r\n    List<String[]> namesList = new ArrayList<>(this.propertySources.size());\r\n    int total = 0;\r\n    for (PropertySource<?> propertySource : this.propertySources) {\r\n        if (!(propertySource instanceof EnumerablePropertySource<?> enumerablePropertySource)) {\r\n            throw new IllegalStateException(\"Failed to enumerate property names due to non-enumerable property source: \" + propertySource);\r\n        }\r\n        String[] names = enumerablePropertySource.getPropertyNames();\r\n        namesList.add(names);\r\n        total += names.length;\r\n    }\r\n    Set<String> allNames = CollectionUtils.newLinkedHashSet(total);\r\n    namesList.forEach(names -> Collections.addAll(allNames, names));\r\n    return StringUtils.toStringArray(allNames);\r\n}\n/**\r\n * Add the given {@link PropertySource} to the end of the chain.\r\n * @param propertySource the PropertySource to add\r\n */\r\npublic void addPropertySource(PropertySource<?> propertySource) {\r\n    this.propertySources.add(propertySource);\r\n}\n/**\r\n * Add the given {@link PropertySource} to the start of the chain.\r\n * @param propertySource the PropertySource to add\r\n * @since 4.1\r\n */\r\npublic void addFirstPropertySource(PropertySource<?> propertySource) {\r\n    List<PropertySource<?>> existing = new ArrayList<>(this.propertySources);\r\n    this.propertySources.clear();\r\n    this.propertySources.add(propertySource);\r\n    this.propertySources.addAll(existing);\r\n}\n/**\r\n * Return all property sources that this composite source holds.\r\n * @since 4.1.1\r\n */\r\npublic Collection<PropertySource<?>> getPropertySources() {\r\n    return this.propertySources;\r\n}\n@Override\r\npublic String toString() {\r\n    return getClass().getSimpleName() + \" {name='\" + this.name + \"', propertySources=\" + this.propertySources + \"}\";\r\n}",
    "comment": "\n * Composite {@link PropertySource} implementation that iterates over a set of\n * {@link PropertySource} instances. Necessary in cases where multiple property sources\n * share the same name, for example, when multiple values are supplied to {@code @PropertySource}.\n *\n * <p>As of Spring 4.1.2, this class extends {@link EnumerablePropertySource} instead\n * of plain {@link PropertySource}, exposing {@link #getPropertyNames()} based on the\n * accumulated property names from all contained sources (as far as possible).\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @author Phillip Webb\n * @since 3.1.1\n "
  },
  {
    "entityId": "org.springframework.core.env.CompositePropertySource#getProperty(String)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Object getProperty(String name) {\r\n    for (PropertySource<?> propertySource : this.propertySources) {\r\n        Object candidate = propertySource.getProperty(name);\r\n        if (candidate != null) {\r\n            return candidate;\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.CompositePropertySource#containsProperty(String)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean containsProperty(String name) {\r\n    for (PropertySource<?> propertySource : this.propertySources) {\r\n        if (propertySource.containsProperty(name)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.CompositePropertySource#getPropertyNames()",
    "entityType": "method",
    "code": "@Override\r\npublic String[] getPropertyNames() {\r\n    List<String[]> namesList = new ArrayList<>(this.propertySources.size());\r\n    int total = 0;\r\n    for (PropertySource<?> propertySource : this.propertySources) {\r\n        if (!(propertySource instanceof EnumerablePropertySource<?> enumerablePropertySource)) {\r\n            throw new IllegalStateException(\"Failed to enumerate property names due to non-enumerable property source: \" + propertySource);\r\n        }\r\n        String[] names = enumerablePropertySource.getPropertyNames();\r\n        namesList.add(names);\r\n        total += names.length;\r\n    }\r\n    Set<String> allNames = CollectionUtils.newLinkedHashSet(total);\r\n    namesList.forEach(names -> Collections.addAll(allNames, names));\r\n    return StringUtils.toStringArray(allNames);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.CompositePropertySource#addPropertySource(PropertySource<?>)",
    "entityType": "method",
    "code": "/**\r\n * Add the given {@link PropertySource} to the end of the chain.\r\n * @param propertySource the PropertySource to add\r\n */\r\npublic void addPropertySource(PropertySource<?> propertySource) {\r\n    this.propertySources.add(propertySource);\r\n}",
    "comment": "\n\t * Add the given {@link PropertySource} to the end of the chain.\n\t * @param propertySource the PropertySource to add\n\t "
  },
  {
    "entityId": "org.springframework.core.env.CompositePropertySource#addFirstPropertySource(PropertySource<?>)",
    "entityType": "method",
    "code": "/**\r\n * Add the given {@link PropertySource} to the start of the chain.\r\n * @param propertySource the PropertySource to add\r\n * @since 4.1\r\n */\r\npublic void addFirstPropertySource(PropertySource<?> propertySource) {\r\n    List<PropertySource<?>> existing = new ArrayList<>(this.propertySources);\r\n    this.propertySources.clear();\r\n    this.propertySources.add(propertySource);\r\n    this.propertySources.addAll(existing);\r\n}",
    "comment": "\n\t * Add the given {@link PropertySource} to the start of the chain.\n\t * @param propertySource the PropertySource to add\n\t * @since 4.1\n\t "
  },
  {
    "entityId": "org.springframework.core.env.CompositePropertySource#getPropertySources()",
    "entityType": "method",
    "code": "/**\r\n * Return all property sources that this composite source holds.\r\n * @since 4.1.1\r\n */\r\npublic Collection<PropertySource<?>> getPropertySources() {\r\n    return this.propertySources;\r\n}",
    "comment": "\n\t * Return all property sources that this composite source holds.\n\t * @since 4.1.1\n\t "
  },
  {
    "entityId": "org.springframework.core.env.CompositePropertySource#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return getClass().getSimpleName() + \" {name='\" + this.name + \"', propertySources=\" + this.propertySources + \"}\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ConfigurableEnvironment",
    "entityType": "class",
    "code": "/**\r\n * Specify the set of profiles active for this {@code Environment}. Profiles are\r\n * evaluated during container bootstrap to determine whether bean definitions\r\n * should be registered with the container.\r\n * <p>Any existing active profiles will be replaced with the given arguments; call\r\n * with zero arguments to clear the current set of active profiles. Use\r\n * {@link #addActiveProfile} to add a profile while preserving the existing set.\r\n * @throws IllegalArgumentException if any profile is null, empty or whitespace-only\r\n * @see #addActiveProfile\r\n * @see #setDefaultProfiles\r\n * @see org.springframework.context.annotation.Profile\r\n * @see AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME\r\n */\r\nvoid setActiveProfiles(String... profiles);\n/**\r\n * Add a profile to the current set of active profiles.\r\n * @throws IllegalArgumentException if the profile is null, empty or whitespace-only\r\n * @see #setActiveProfiles\r\n */\r\nvoid addActiveProfile(String profile);\n/**\r\n * Specify the set of profiles to be made active by default if no other profiles\r\n * are explicitly made active through {@link #setActiveProfiles}.\r\n * @throws IllegalArgumentException if any profile is null, empty or whitespace-only\r\n * @see AbstractEnvironment#DEFAULT_PROFILES_PROPERTY_NAME\r\n */\r\nvoid setDefaultProfiles(String... profiles);\n/**\r\n * Return the {@link PropertySources} for this {@code Environment} in mutable form,\r\n * allowing for manipulation of the set of {@link PropertySource} objects that should\r\n * be searched when resolving properties against this {@code Environment} object.\r\n * The various {@link MutablePropertySources} methods such as\r\n * {@link MutablePropertySources#addFirst addFirst},\r\n * {@link MutablePropertySources#addLast addLast},\r\n * {@link MutablePropertySources#addBefore addBefore} and\r\n * {@link MutablePropertySources#addAfter addAfter} allow for fine-grained control\r\n * over property source ordering. This is useful, for example, in ensuring that\r\n * certain user-defined property sources have search precedence over default property\r\n * sources such as the set of system properties or the set of system environment\r\n * variables.\r\n * @see AbstractEnvironment#customizePropertySources\r\n */\r\nMutablePropertySources getPropertySources();\n/**\r\n * Return the value of {@link System#getProperties()}.\r\n * <p>Note that most {@code Environment} implementations will include this system\r\n * properties map as a default {@link PropertySource} to be searched. Therefore, it is\r\n * recommended that this method not be used directly unless bypassing other property\r\n * sources is expressly intended.\r\n */\r\nMap<String, Object> getSystemProperties();\n/**\r\n * Return the value of {@link System#getenv()}.\r\n * <p>Note that most {@link Environment} implementations will include this system\r\n * environment map as a default {@link PropertySource} to be searched. Therefore, it\r\n * is recommended that this method not be used directly unless bypassing other\r\n * property sources is expressly intended.\r\n */\r\nMap<String, Object> getSystemEnvironment();\n/**\r\n * Append the given parent environment's active profiles, default profiles and\r\n * property sources to this (child) environment's respective collections of each.\r\n * <p>For any identically-named {@code PropertySource} instance existing in both\r\n * parent and child, the child instance is to be preserved and the parent instance\r\n * discarded. This has the effect of allowing overriding of property sources by the\r\n * child as well as avoiding redundant searches through common property source types,\r\n * for example, system environment and system properties.\r\n * <p>Active and default profile names are also filtered for duplicates, to avoid\r\n * confusion and redundant storage.\r\n * <p>The parent environment remains unmodified in any case. Note that any changes to\r\n * the parent environment occurring after the call to {@code merge} will not be\r\n * reflected in the child. Therefore, care should be taken to configure parent\r\n * property sources and profile information prior to calling {@code merge}.\r\n * @param parent the environment to merge with\r\n * @since 3.1.2\r\n * @see org.springframework.context.support.AbstractApplicationContext#setParent\r\n */\r\nvoid merge(ConfigurableEnvironment parent);",
    "comment": "\n * Configuration interface to be implemented by most if not all {@link Environment} types.\n * Provides facilities for setting active and default profiles and manipulating underlying\n * property sources. Allows clients to set and validate required properties, customize the\n * conversion service and more through the {@link ConfigurablePropertyResolver}\n * superinterface.\n *\n * <h2>Manipulating property sources</h2>\n * <p>Property sources may be removed, reordered, or replaced; and additional\n * property sources may be added using the {@link MutablePropertySources}\n * instance returned from {@link #getPropertySources()}. The following examples\n * are against the {@link StandardEnvironment} implementation of\n * {@code ConfigurableEnvironment}, but are generally applicable to any implementation,\n * though particular default property sources may differ.\n *\n * <h4>Example: adding a new property source with highest search priority</h4>\n * <pre class=\"code\">\n * ConfigurableEnvironment environment = new StandardEnvironment();\n * MutablePropertySources propertySources = environment.getPropertySources();\n * Map&lt;String, Object&gt; myMap = new HashMap&lt;&gt;();\n * myMap.put(\"xyz\", \"myValue\");\n * propertySources.addFirst(new MapPropertySource(\"MY_MAP\", myMap));\n * </pre>\n *\n * <h4>Example: removing the default system properties property source</h4>\n * <pre class=\"code\">\n * MutablePropertySources propertySources = environment.getPropertySources();\n * propertySources.remove(StandardEnvironment.SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME)\n * </pre>\n *\n * <h4>Example: mocking the system environment for testing purposes</h4>\n * <pre class=\"code\">\n * MutablePropertySources propertySources = environment.getPropertySources();\n * MockPropertySource mockEnvVars = new MockPropertySource().withProperty(\"xyz\", \"myValue\");\n * propertySources.replace(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, mockEnvVars);\n * </pre>\n *\n * When an {@link Environment} is being used by an {@code ApplicationContext}, it is\n * important that any such {@code PropertySource} manipulations be performed\n * <em>before</em> the context's {@link\n * org.springframework.context.support.AbstractApplicationContext#refresh() refresh()}\n * method is called. This ensures that all property sources are available during the\n * container bootstrap process, including use by {@linkplain\n * org.springframework.context.support.PropertySourcesPlaceholderConfigurer property\n * placeholder configurers}.\n *\n * @author Chris Beams\n * @since 3.1\n * @see StandardEnvironment\n * @see org.springframework.context.ConfigurableApplicationContext#getEnvironment\n "
  },
  {
    "entityId": "org.springframework.core.env.ConfigurableEnvironment#setActiveProfiles(String)",
    "entityType": "method",
    "code": "/**\r\n * Specify the set of profiles active for this {@code Environment}. Profiles are\r\n * evaluated during container bootstrap to determine whether bean definitions\r\n * should be registered with the container.\r\n * <p>Any existing active profiles will be replaced with the given arguments; call\r\n * with zero arguments to clear the current set of active profiles. Use\r\n * {@link #addActiveProfile} to add a profile while preserving the existing set.\r\n * @throws IllegalArgumentException if any profile is null, empty or whitespace-only\r\n * @see #addActiveProfile\r\n * @see #setDefaultProfiles\r\n * @see org.springframework.context.annotation.Profile\r\n * @see AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME\r\n */\r\nvoid setActiveProfiles(String... profiles);",
    "comment": "\n\t * Specify the set of profiles active for this {@code Environment}. Profiles are\n\t * evaluated during container bootstrap to determine whether bean definitions\n\t * should be registered with the container.\n\t * <p>Any existing active profiles will be replaced with the given arguments; call\n\t * with zero arguments to clear the current set of active profiles. Use\n\t * {@link #addActiveProfile} to add a profile while preserving the existing set.\n\t * @throws IllegalArgumentException if any profile is null, empty or whitespace-only\n\t * @see #addActiveProfile\n\t * @see #setDefaultProfiles\n\t * @see org.springframework.context.annotation.Profile\n\t * @see AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME\n\t "
  },
  {
    "entityId": "org.springframework.core.env.ConfigurableEnvironment#addActiveProfile(String)",
    "entityType": "method",
    "code": "/**\r\n * Add a profile to the current set of active profiles.\r\n * @throws IllegalArgumentException if the profile is null, empty or whitespace-only\r\n * @see #setActiveProfiles\r\n */\r\nvoid addActiveProfile(String profile);",
    "comment": "\n\t * Add a profile to the current set of active profiles.\n\t * @throws IllegalArgumentException if the profile is null, empty or whitespace-only\n\t * @see #setActiveProfiles\n\t "
  },
  {
    "entityId": "org.springframework.core.env.ConfigurableEnvironment#setDefaultProfiles(String)",
    "entityType": "method",
    "code": "/**\r\n * Specify the set of profiles to be made active by default if no other profiles\r\n * are explicitly made active through {@link #setActiveProfiles}.\r\n * @throws IllegalArgumentException if any profile is null, empty or whitespace-only\r\n * @see AbstractEnvironment#DEFAULT_PROFILES_PROPERTY_NAME\r\n */\r\nvoid setDefaultProfiles(String... profiles);",
    "comment": "\n\t * Specify the set of profiles to be made active by default if no other profiles\n\t * are explicitly made active through {@link #setActiveProfiles}.\n\t * @throws IllegalArgumentException if any profile is null, empty or whitespace-only\n\t * @see AbstractEnvironment#DEFAULT_PROFILES_PROPERTY_NAME\n\t "
  },
  {
    "entityId": "org.springframework.core.env.ConfigurableEnvironment#getPropertySources()",
    "entityType": "method",
    "code": "/**\r\n * Return the {@link PropertySources} for this {@code Environment} in mutable form,\r\n * allowing for manipulation of the set of {@link PropertySource} objects that should\r\n * be searched when resolving properties against this {@code Environment} object.\r\n * The various {@link MutablePropertySources} methods such as\r\n * {@link MutablePropertySources#addFirst addFirst},\r\n * {@link MutablePropertySources#addLast addLast},\r\n * {@link MutablePropertySources#addBefore addBefore} and\r\n * {@link MutablePropertySources#addAfter addAfter} allow for fine-grained control\r\n * over property source ordering. This is useful, for example, in ensuring that\r\n * certain user-defined property sources have search precedence over default property\r\n * sources such as the set of system properties or the set of system environment\r\n * variables.\r\n * @see AbstractEnvironment#customizePropertySources\r\n */\r\nMutablePropertySources getPropertySources();",
    "comment": "\n\t * Return the {@link PropertySources} for this {@code Environment} in mutable form,\n\t * allowing for manipulation of the set of {@link PropertySource} objects that should\n\t * be searched when resolving properties against this {@code Environment} object.\n\t * The various {@link MutablePropertySources} methods such as\n\t * {@link MutablePropertySources#addFirst addFirst},\n\t * {@link MutablePropertySources#addLast addLast},\n\t * {@link MutablePropertySources#addBefore addBefore} and\n\t * {@link MutablePropertySources#addAfter addAfter} allow for fine-grained control\n\t * over property source ordering. This is useful, for example, in ensuring that\n\t * certain user-defined property sources have search precedence over default property\n\t * sources such as the set of system properties or the set of system environment\n\t * variables.\n\t * @see AbstractEnvironment#customizePropertySources\n\t "
  },
  {
    "entityId": "org.springframework.core.env.ConfigurableEnvironment#getSystemProperties()",
    "entityType": "method",
    "code": "/**\r\n * Return the value of {@link System#getProperties()}.\r\n * <p>Note that most {@code Environment} implementations will include this system\r\n * properties map as a default {@link PropertySource} to be searched. Therefore, it is\r\n * recommended that this method not be used directly unless bypassing other property\r\n * sources is expressly intended.\r\n */\r\nMap<String, Object> getSystemProperties();",
    "comment": "\n\t * Return the value of {@link System#getProperties()}.\n\t * <p>Note that most {@code Environment} implementations will include this system\n\t * properties map as a default {@link PropertySource} to be searched. Therefore, it is\n\t * recommended that this method not be used directly unless bypassing other property\n\t * sources is expressly intended.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.ConfigurableEnvironment#getSystemEnvironment()",
    "entityType": "method",
    "code": "/**\r\n * Return the value of {@link System#getenv()}.\r\n * <p>Note that most {@link Environment} implementations will include this system\r\n * environment map as a default {@link PropertySource} to be searched. Therefore, it\r\n * is recommended that this method not be used directly unless bypassing other\r\n * property sources is expressly intended.\r\n */\r\nMap<String, Object> getSystemEnvironment();",
    "comment": "\n\t * Return the value of {@link System#getenv()}.\n\t * <p>Note that most {@link Environment} implementations will include this system\n\t * environment map as a default {@link PropertySource} to be searched. Therefore, it\n\t * is recommended that this method not be used directly unless bypassing other\n\t * property sources is expressly intended.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.ConfigurableEnvironment#merge(ConfigurableEnvironment)",
    "entityType": "method",
    "code": "/**\r\n * Append the given parent environment's active profiles, default profiles and\r\n * property sources to this (child) environment's respective collections of each.\r\n * <p>For any identically-named {@code PropertySource} instance existing in both\r\n * parent and child, the child instance is to be preserved and the parent instance\r\n * discarded. This has the effect of allowing overriding of property sources by the\r\n * child as well as avoiding redundant searches through common property source types,\r\n * for example, system environment and system properties.\r\n * <p>Active and default profile names are also filtered for duplicates, to avoid\r\n * confusion and redundant storage.\r\n * <p>The parent environment remains unmodified in any case. Note that any changes to\r\n * the parent environment occurring after the call to {@code merge} will not be\r\n * reflected in the child. Therefore, care should be taken to configure parent\r\n * property sources and profile information prior to calling {@code merge}.\r\n * @param parent the environment to merge with\r\n * @since 3.1.2\r\n * @see org.springframework.context.support.AbstractApplicationContext#setParent\r\n */\r\nvoid merge(ConfigurableEnvironment parent);",
    "comment": "\n\t * Append the given parent environment's active profiles, default profiles and\n\t * property sources to this (child) environment's respective collections of each.\n\t * <p>For any identically-named {@code PropertySource} instance existing in both\n\t * parent and child, the child instance is to be preserved and the parent instance\n\t * discarded. This has the effect of allowing overriding of property sources by the\n\t * child as well as avoiding redundant searches through common property source types,\n\t * for example, system environment and system properties.\n\t * <p>Active and default profile names are also filtered for duplicates, to avoid\n\t * confusion and redundant storage.\n\t * <p>The parent environment remains unmodified in any case. Note that any changes to\n\t * the parent environment occurring after the call to {@code merge} will not be\n\t * reflected in the child. Therefore, care should be taken to configure parent\n\t * property sources and profile information prior to calling {@code merge}.\n\t * @param parent the environment to merge with\n\t * @since 3.1.2\n\t * @see org.springframework.context.support.AbstractApplicationContext#setParent\n\t "
  },
  {
    "entityId": "org.springframework.core.env.ConfigurablePropertyResolver",
    "entityType": "class",
    "code": "/**\r\n * Return the {@link ConfigurableConversionService} used when performing type\r\n * conversions on properties.\r\n * <p>The configurable nature of the returned conversion service allows for\r\n * the convenient addition and removal of individual {@code Converter} instances:\r\n * <pre class=\"code\">\r\n * ConfigurableConversionService cs = env.getConversionService();\r\n * cs.addConverter(new FooConverter());\r\n * </pre>\r\n * @see PropertyResolver#getProperty(String, Class)\r\n * @see org.springframework.core.convert.converter.ConverterRegistry#addConverter\r\n */\r\nConfigurableConversionService getConversionService();\n/**\r\n * Set the {@link ConfigurableConversionService} to be used when performing type\r\n * conversions on properties.\r\n * <p><strong>Note:</strong> as an alternative to fully replacing the\r\n * {@code ConversionService}, consider adding or removing individual\r\n * {@code Converter} instances by drilling into {@link #getConversionService()}\r\n * and calling methods such as {@code #addConverter}.\r\n * @see PropertyResolver#getProperty(String, Class)\r\n * @see #getConversionService()\r\n * @see org.springframework.core.convert.converter.ConverterRegistry#addConverter\r\n */\r\nvoid setConversionService(ConfigurableConversionService conversionService);\n/**\r\n * Set the prefix that placeholders replaced by this resolver must begin with.\r\n */\r\nvoid setPlaceholderPrefix(String placeholderPrefix);\n/**\r\n * Set the suffix that placeholders replaced by this resolver must end with.\r\n */\r\nvoid setPlaceholderSuffix(String placeholderSuffix);\n/**\r\n * Specify the separating character between the placeholders replaced by this\r\n * resolver and their associated default value, or {@code null} if no such\r\n * special character should be processed as a value separator.\r\n */\r\nvoid setValueSeparator(@Nullable String valueSeparator);\n/**\r\n * Specify the escape character to use to ignore placeholder prefix or\r\n * value separator, or {@code null} if no escaping should take place.\r\n * @since 6.2\r\n */\r\nvoid setEscapeCharacter(@Nullable Character escapeCharacter);\n/**\r\n * Set whether to throw an exception when encountering an unresolvable placeholder\r\n * nested within the value of a given property. A {@code false} value indicates strict\r\n * resolution, i.e. that an exception will be thrown. A {@code true} value indicates\r\n * that unresolvable nested placeholders should be passed through in their unresolved\r\n * ${...} form.\r\n * <p>Implementations of {@link #getProperty(String)} and its variants must inspect\r\n * the value set here to determine correct behavior when property values contain\r\n * unresolvable placeholders.\r\n * @since 3.2\r\n */\r\nvoid setIgnoreUnresolvableNestedPlaceholders(boolean ignoreUnresolvableNestedPlaceholders);\n/**\r\n * Specify which properties must be present, to be verified by\r\n * {@link #validateRequiredProperties()}.\r\n */\r\nvoid setRequiredProperties(String... requiredProperties);\n/**\r\n * Validate that each of the properties specified by\r\n * {@link #setRequiredProperties} is present and resolves to a\r\n * non-{@code null} value.\r\n * @throws MissingRequiredPropertiesException if any of the required\r\n * properties are not resolvable.\r\n */\r\nvoid validateRequiredProperties() throws MissingRequiredPropertiesException;",
    "comment": "\n * Configuration interface to be implemented by most if not all {@link PropertyResolver}\n * types. Provides facilities for accessing and customizing the\n * {@link org.springframework.core.convert.ConversionService ConversionService}\n * used when converting property values from one type to another.\n *\n * @author Chris Beams\n * @author Stephane Nicoll\n * @since 3.1\n "
  },
  {
    "entityId": "org.springframework.core.env.ConfigurablePropertyResolver#getConversionService()",
    "entityType": "method",
    "code": "/**\r\n * Return the {@link ConfigurableConversionService} used when performing type\r\n * conversions on properties.\r\n * <p>The configurable nature of the returned conversion service allows for\r\n * the convenient addition and removal of individual {@code Converter} instances:\r\n * <pre class=\"code\">\r\n * ConfigurableConversionService cs = env.getConversionService();\r\n * cs.addConverter(new FooConverter());\r\n * </pre>\r\n * @see PropertyResolver#getProperty(String, Class)\r\n * @see org.springframework.core.convert.converter.ConverterRegistry#addConverter\r\n */\r\nConfigurableConversionService getConversionService();",
    "comment": "\n\t * Return the {@link ConfigurableConversionService} used when performing type\n\t * conversions on properties.\n\t * <p>The configurable nature of the returned conversion service allows for\n\t * the convenient addition and removal of individual {@code Converter} instances:\n\t * <pre class=\"code\">\n\t * ConfigurableConversionService cs = env.getConversionService();\n\t * cs.addConverter(new FooConverter());\n\t * </pre>\n\t * @see PropertyResolver#getProperty(String, Class)\n\t * @see org.springframework.core.convert.converter.ConverterRegistry#addConverter\n\t "
  },
  {
    "entityId": "org.springframework.core.env.ConfigurablePropertyResolver#setConversionService(ConfigurableConversionService)",
    "entityType": "method",
    "code": "/**\r\n * Set the {@link ConfigurableConversionService} to be used when performing type\r\n * conversions on properties.\r\n * <p><strong>Note:</strong> as an alternative to fully replacing the\r\n * {@code ConversionService}, consider adding or removing individual\r\n * {@code Converter} instances by drilling into {@link #getConversionService()}\r\n * and calling methods such as {@code #addConverter}.\r\n * @see PropertyResolver#getProperty(String, Class)\r\n * @see #getConversionService()\r\n * @see org.springframework.core.convert.converter.ConverterRegistry#addConverter\r\n */\r\nvoid setConversionService(ConfigurableConversionService conversionService);",
    "comment": "\n\t * Set the {@link ConfigurableConversionService} to be used when performing type\n\t * conversions on properties.\n\t * <p><strong>Note:</strong> as an alternative to fully replacing the\n\t * {@code ConversionService}, consider adding or removing individual\n\t * {@code Converter} instances by drilling into {@link #getConversionService()}\n\t * and calling methods such as {@code #addConverter}.\n\t * @see PropertyResolver#getProperty(String, Class)\n\t * @see #getConversionService()\n\t * @see org.springframework.core.convert.converter.ConverterRegistry#addConverter\n\t "
  },
  {
    "entityId": "org.springframework.core.env.ConfigurablePropertyResolver#setPlaceholderPrefix(String)",
    "entityType": "method",
    "code": "/**\r\n * Set the prefix that placeholders replaced by this resolver must begin with.\r\n */\r\nvoid setPlaceholderPrefix(String placeholderPrefix);",
    "comment": "\n\t * Set the prefix that placeholders replaced by this resolver must begin with.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.ConfigurablePropertyResolver#setPlaceholderSuffix(String)",
    "entityType": "method",
    "code": "/**\r\n * Set the suffix that placeholders replaced by this resolver must end with.\r\n */\r\nvoid setPlaceholderSuffix(String placeholderSuffix);",
    "comment": "\n\t * Set the suffix that placeholders replaced by this resolver must end with.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.ConfigurablePropertyResolver#setValueSeparator(String)",
    "entityType": "method",
    "code": "/**\r\n * Specify the separating character between the placeholders replaced by this\r\n * resolver and their associated default value, or {@code null} if no such\r\n * special character should be processed as a value separator.\r\n */\r\nvoid setValueSeparator(@Nullable String valueSeparator);",
    "comment": "\n\t * Specify the separating character between the placeholders replaced by this\n\t * resolver and their associated default value, or {@code null} if no such\n\t * special character should be processed as a value separator.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.ConfigurablePropertyResolver#setEscapeCharacter(Character)",
    "entityType": "method",
    "code": "/**\r\n * Specify the escape character to use to ignore placeholder prefix or\r\n * value separator, or {@code null} if no escaping should take place.\r\n * @since 6.2\r\n */\r\nvoid setEscapeCharacter(@Nullable Character escapeCharacter);",
    "comment": "\n\t * Specify the escape character to use to ignore placeholder prefix or\n\t * value separator, or {@code null} if no escaping should take place.\n\t * @since 6.2\n\t "
  },
  {
    "entityId": "org.springframework.core.env.ConfigurablePropertyResolver#setIgnoreUnresolvableNestedPlaceholders(boolean)",
    "entityType": "method",
    "code": "/**\r\n * Set whether to throw an exception when encountering an unresolvable placeholder\r\n * nested within the value of a given property. A {@code false} value indicates strict\r\n * resolution, i.e. that an exception will be thrown. A {@code true} value indicates\r\n * that unresolvable nested placeholders should be passed through in their unresolved\r\n * ${...} form.\r\n * <p>Implementations of {@link #getProperty(String)} and its variants must inspect\r\n * the value set here to determine correct behavior when property values contain\r\n * unresolvable placeholders.\r\n * @since 3.2\r\n */\r\nvoid setIgnoreUnresolvableNestedPlaceholders(boolean ignoreUnresolvableNestedPlaceholders);",
    "comment": "\n\t * Set whether to throw an exception when encountering an unresolvable placeholder\n\t * nested within the value of a given property. A {@code false} value indicates strict\n\t * resolution, i.e. that an exception will be thrown. A {@code true} value indicates\n\t * that unresolvable nested placeholders should be passed through in their unresolved\n\t * ${...} form.\n\t * <p>Implementations of {@link #getProperty(String)} and its variants must inspect\n\t * the value set here to determine correct behavior when property values contain\n\t * unresolvable placeholders.\n\t * @since 3.2\n\t "
  },
  {
    "entityId": "org.springframework.core.env.ConfigurablePropertyResolver#setRequiredProperties(String)",
    "entityType": "method",
    "code": "/**\r\n * Specify which properties must be present, to be verified by\r\n * {@link #validateRequiredProperties()}.\r\n */\r\nvoid setRequiredProperties(String... requiredProperties);",
    "comment": "\n\t * Specify which properties must be present, to be verified by\n\t * {@link #validateRequiredProperties()}.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.ConfigurablePropertyResolver#validateRequiredProperties()",
    "entityType": "method",
    "code": "/**\r\n * Validate that each of the properties specified by\r\n * {@link #setRequiredProperties} is present and resolves to a\r\n * non-{@code null} value.\r\n * @throws MissingRequiredPropertiesException if any of the required\r\n * properties are not resolvable.\r\n */\r\nvoid validateRequiredProperties() throws MissingRequiredPropertiesException;",
    "comment": "\n\t * Validate that each of the properties specified by\n\t * {@link #setRequiredProperties} is present and resolves to a\n\t * non-{@code null} value.\n\t * @throws MissingRequiredPropertiesException if any of the required\n\t * properties are not resolvable.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.EnumerablePropertySource",
    "entityType": "class",
    "code": "/**\r\n * Create a new {@code EnumerablePropertySource} with the given name and source object.\r\n * @param name the associated name\r\n * @param source the source object\r\n */\r\npublic EnumerablePropertySource(String name, T source) {\r\n    super(name, source);\r\n}\n/**\r\n * Create a new {@code EnumerablePropertySource} with the given name and with a new\r\n * {@code Object} instance as the underlying source.\r\n * @param name the associated name\r\n */\r\nprotected EnumerablePropertySource(String name) {\r\n    super(name);\r\n}\n/**\r\n * Return whether this {@code PropertySource} contains a property with the given name.\r\n * <p>This implementation checks for the presence of the given name within the\r\n * {@link #getPropertyNames()} array.\r\n * @param name the name of the property to find\r\n */\r\n@Override\r\npublic boolean containsProperty(String name) {\r\n    return ObjectUtils.containsElement(getPropertyNames(), name);\r\n}\n/**\r\n * Return the names of all properties contained by the\r\n * {@linkplain #getSource() source} object (never {@code null}).\r\n */\r\npublic abstract String[] getPropertyNames();",
    "comment": "\n * A {@link PropertySource} implementation capable of interrogating its\n * underlying source object to enumerate all possible property name/value\n * pairs. Exposes the {@link #getPropertyNames()} method to allow callers\n * to introspect available properties without having to access the underlying\n * source object. This also facilitates a more efficient implementation of\n * {@link #containsProperty(String)}, in that it can call {@link #getPropertyNames()}\n * and iterate through the returned array rather than attempting a call to\n * {@link #getProperty(String)} which may be more expensive. Implementations may\n * consider caching the result of {@link #getPropertyNames()} to fully exploit this\n * performance opportunity.\n *\n * <p>Most framework-provided {@code PropertySource} implementations are enumerable;\n * a counter-example would be {@code JndiPropertySource} where, due to the\n * nature of JNDI it is not possible to determine all possible property names at\n * any given time; rather it is only possible to try to access a property\n * (via {@link #getProperty(String)}) in order to evaluate whether it is present\n * or not.\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @since 3.1\n * @param <T> the source type\n "
  },
  {
    "entityId": "org.springframework.core.env.EnumerablePropertySource#containsProperty(String)",
    "entityType": "method",
    "code": "/**\r\n * Return whether this {@code PropertySource} contains a property with the given name.\r\n * <p>This implementation checks for the presence of the given name within the\r\n * {@link #getPropertyNames()} array.\r\n * @param name the name of the property to find\r\n */\r\n@Override\r\npublic boolean containsProperty(String name) {\r\n    return ObjectUtils.containsElement(getPropertyNames(), name);\r\n}",
    "comment": "\n\t * Return whether this {@code PropertySource} contains a property with the given name.\n\t * <p>This implementation checks for the presence of the given name within the\n\t * {@link #getPropertyNames()} array.\n\t * @param name the name of the property to find\n\t "
  },
  {
    "entityId": "org.springframework.core.env.EnumerablePropertySource#getPropertyNames()",
    "entityType": "method",
    "code": "/**\r\n * Return the names of all properties contained by the\r\n * {@linkplain #getSource() source} object (never {@code null}).\r\n */\r\npublic abstract String[] getPropertyNames();",
    "comment": "\n\t * Return the names of all properties contained by the\n\t * {@linkplain #getSource() source} object (never {@code null}).\n\t "
  },
  {
    "entityId": "org.springframework.core.env.Environment",
    "entityType": "class",
    "code": "/**\r\n * Return the set of profiles explicitly made active for this environment. Profiles\r\n * are used for creating logical groupings of bean definitions to be registered\r\n * conditionally, for example based on deployment environment. Profiles can be\r\n * activated by setting {@linkplain AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME\r\n * \"spring.profiles.active\"} as a system property or by calling\r\n * {@link ConfigurableEnvironment#setActiveProfiles(String...)}.\r\n * <p>If no profiles have explicitly been specified as active, then any\r\n * {@linkplain #getDefaultProfiles() default profiles} will automatically be activated.\r\n * @see #getDefaultProfiles\r\n * @see ConfigurableEnvironment#setActiveProfiles\r\n * @see AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME\r\n */\r\nString[] getActiveProfiles();\n/**\r\n * Return the set of profiles to be active by default when no active profiles have\r\n * been set explicitly.\r\n * @see #getActiveProfiles\r\n * @see ConfigurableEnvironment#setDefaultProfiles\r\n * @see AbstractEnvironment#DEFAULT_PROFILES_PROPERTY_NAME\r\n */\r\nString[] getDefaultProfiles();\n/**\r\n * Determine whether one of the given profile expressions matches the\r\n * {@linkplain #getActiveProfiles() active profiles} &mdash; or in the case\r\n * of no explicit active profiles, whether one of the given profile expressions\r\n * matches the {@linkplain #getDefaultProfiles() default profiles}.\r\n * <p>Profile expressions allow for complex, boolean profile logic to be\r\n * expressed &mdash; for example {@code \"p1 & p2\"}, {@code \"(p1 & p2) | p3\"},\r\n * etc. See {@link Profiles#of(String...)} for details on the supported\r\n * expression syntax.\r\n * <p>This method is a convenient shortcut for\r\n * {@code env.acceptsProfiles(Profiles.of(profileExpressions))}.\r\n * @since 5.3.28\r\n * @see Profiles#of(String...)\r\n * @see #acceptsProfiles(Profiles)\r\n */\r\ndefault boolean matchesProfiles(String... profileExpressions) {\r\n    return acceptsProfiles(Profiles.of(profileExpressions));\r\n}\n/**\r\n * Determine whether one or more of the given profiles is active &mdash; or\r\n * in the case of no explicit {@linkplain #getActiveProfiles() active profiles},\r\n * whether one or more of the given profiles is included in the set of\r\n * {@linkplain #getDefaultProfiles() default profiles}.\r\n * <p>If a profile begins with '!' the logic is inverted, meaning this method\r\n * will return {@code true} if the given profile is <em>not</em> active. For\r\n * example, {@code env.acceptsProfiles(\"p1\", \"!p2\")} will return {@code true}\r\n * if profile 'p1' is active or 'p2' is not active.\r\n * @throws IllegalArgumentException if called with a {@code null} array, an\r\n * empty array, zero arguments or if any profile is {@code null}, empty, or\r\n * whitespace only\r\n * @see #getActiveProfiles\r\n * @see #getDefaultProfiles\r\n * @see #matchesProfiles(String...)\r\n * @see #acceptsProfiles(Profiles)\r\n * @deprecated as of 5.1 in favor of {@link #acceptsProfiles(Profiles)} or\r\n * {@link #matchesProfiles(String...)}\r\n */\r\n@Deprecated\r\nboolean acceptsProfiles(String... profiles);\n/**\r\n * Determine whether the given {@link Profiles} predicate matches the\r\n * {@linkplain #getActiveProfiles() active profiles} &mdash; or in the case\r\n * of no explicit active profiles, whether the given {@code Profiles} predicate\r\n * matches the {@linkplain #getDefaultProfiles() default profiles}.\r\n * <p>If you wish provide profile expressions directly as strings, use\r\n * {@link #matchesProfiles(String...)} instead.\r\n * @since 5.1\r\n * @see #matchesProfiles(String...)\r\n * @see Profiles#of(String...)\r\n */\r\nboolean acceptsProfiles(Profiles profiles);",
    "comment": "\n * Interface representing the environment in which the current application is running.\n * Models two key aspects of the application environment: <em>profiles</em> and\n * <em>properties</em>. Methods related to property access are exposed via the\n * {@link PropertyResolver} superinterface.\n *\n * <p>A <em>profile</em> is a named, logical group of bean definitions to be registered\n * with the container only if the given profile is <em>active</em>. Beans may be assigned\n * to a profile whether defined in XML or via annotations; see the spring-beans 3.1 schema\n * or the {@link org.springframework.context.annotation.Profile @Profile} annotation for\n * syntax details. The role of the {@code Environment} object with relation to profiles is\n * in determining which profiles (if any) are currently {@linkplain #getActiveProfiles\n * active}, and which profiles (if any) should be {@linkplain #getDefaultProfiles active\n * by default}.\n *\n * <p><em>Properties</em> play an important role in almost all applications, and may\n * originate from a variety of sources: properties files, JVM system properties, system\n * environment variables, JNDI, servlet context parameters, ad-hoc Properties objects,\n * Maps, and so on. The role of the {@code Environment} object with relation to properties\n * is to provide the user with a convenient service interface for configuring property\n * sources and resolving properties from them.\n *\n * <p>Beans managed within an {@code ApplicationContext} may register to be {@link\n * org.springframework.context.EnvironmentAware EnvironmentAware} or {@code @Inject} the\n * {@code Environment} in order to query profile state or resolve properties directly.\n *\n * <p>In most cases, however, application-level beans should not need to interact with the\n * {@code Environment} directly but instead may request to have {@code ${...}} property\n * values replaced by a property placeholder configurer such as\n * {@link org.springframework.context.support.PropertySourcesPlaceholderConfigurer\n * PropertySourcesPlaceholderConfigurer}, which itself is {@code EnvironmentAware} and\n * registered by default when using {@code <context:property-placeholder/>}.\n *\n * <p>Configuration of the {@code Environment} object must be done through the\n * {@code ConfigurableEnvironment} interface, returned from all\n * {@code AbstractApplicationContext} subclass {@code getEnvironment()} methods. See\n * {@link ConfigurableEnvironment} Javadoc for usage examples demonstrating manipulation\n * of property sources prior to application context {@code refresh()}.\n *\n * @author Chris Beams\n * @author Phillip Webb\n * @author Sam Brannen\n * @since 3.1\n * @see PropertyResolver\n * @see EnvironmentCapable\n * @see ConfigurableEnvironment\n * @see AbstractEnvironment\n * @see StandardEnvironment\n * @see org.springframework.context.EnvironmentAware\n * @see org.springframework.context.ConfigurableApplicationContext#getEnvironment\n * @see org.springframework.context.ConfigurableApplicationContext#setEnvironment\n * @see org.springframework.context.support.AbstractApplicationContext#createEnvironment\n "
  },
  {
    "entityId": "org.springframework.core.env.Environment#getActiveProfiles()",
    "entityType": "method",
    "code": "/**\r\n * Return the set of profiles explicitly made active for this environment. Profiles\r\n * are used for creating logical groupings of bean definitions to be registered\r\n * conditionally, for example based on deployment environment. Profiles can be\r\n * activated by setting {@linkplain AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME\r\n * \"spring.profiles.active\"} as a system property or by calling\r\n * {@link ConfigurableEnvironment#setActiveProfiles(String...)}.\r\n * <p>If no profiles have explicitly been specified as active, then any\r\n * {@linkplain #getDefaultProfiles() default profiles} will automatically be activated.\r\n * @see #getDefaultProfiles\r\n * @see ConfigurableEnvironment#setActiveProfiles\r\n * @see AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME\r\n */\r\nString[] getActiveProfiles();",
    "comment": "\n\t * Return the set of profiles explicitly made active for this environment. Profiles\n\t * are used for creating logical groupings of bean definitions to be registered\n\t * conditionally, for example based on deployment environment. Profiles can be\n\t * activated by setting {@linkplain AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME\n\t * \"spring.profiles.active\"} as a system property or by calling\n\t * {@link ConfigurableEnvironment#setActiveProfiles(String...)}.\n\t * <p>If no profiles have explicitly been specified as active, then any\n\t * {@linkplain #getDefaultProfiles() default profiles} will automatically be activated.\n\t * @see #getDefaultProfiles\n\t * @see ConfigurableEnvironment#setActiveProfiles\n\t * @see AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME\n\t "
  },
  {
    "entityId": "org.springframework.core.env.Environment#getDefaultProfiles()",
    "entityType": "method",
    "code": "/**\r\n * Return the set of profiles to be active by default when no active profiles have\r\n * been set explicitly.\r\n * @see #getActiveProfiles\r\n * @see ConfigurableEnvironment#setDefaultProfiles\r\n * @see AbstractEnvironment#DEFAULT_PROFILES_PROPERTY_NAME\r\n */\r\nString[] getDefaultProfiles();",
    "comment": "\n\t * Return the set of profiles to be active by default when no active profiles have\n\t * been set explicitly.\n\t * @see #getActiveProfiles\n\t * @see ConfigurableEnvironment#setDefaultProfiles\n\t * @see AbstractEnvironment#DEFAULT_PROFILES_PROPERTY_NAME\n\t "
  },
  {
    "entityId": "org.springframework.core.env.Environment#matchesProfiles(String)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether one of the given profile expressions matches the\r\n * {@linkplain #getActiveProfiles() active profiles} &mdash; or in the case\r\n * of no explicit active profiles, whether one of the given profile expressions\r\n * matches the {@linkplain #getDefaultProfiles() default profiles}.\r\n * <p>Profile expressions allow for complex, boolean profile logic to be\r\n * expressed &mdash; for example {@code \"p1 & p2\"}, {@code \"(p1 & p2) | p3\"},\r\n * etc. See {@link Profiles#of(String...)} for details on the supported\r\n * expression syntax.\r\n * <p>This method is a convenient shortcut for\r\n * {@code env.acceptsProfiles(Profiles.of(profileExpressions))}.\r\n * @since 5.3.28\r\n * @see Profiles#of(String...)\r\n * @see #acceptsProfiles(Profiles)\r\n */\r\ndefault boolean matchesProfiles(String... profileExpressions) {\r\n    return acceptsProfiles(Profiles.of(profileExpressions));\r\n}",
    "comment": "\n\t * Determine whether one of the given profile expressions matches the\n\t * {@linkplain #getActiveProfiles() active profiles} &mdash; or in the case\n\t * of no explicit active profiles, whether one of the given profile expressions\n\t * matches the {@linkplain #getDefaultProfiles() default profiles}.\n\t * <p>Profile expressions allow for complex, boolean profile logic to be\n\t * expressed &mdash; for example {@code \"p1 & p2\"}, {@code \"(p1 & p2) | p3\"},\n\t * etc. See {@link Profiles#of(String...)} for details on the supported\n\t * expression syntax.\n\t * <p>This method is a convenient shortcut for\n\t * {@code env.acceptsProfiles(Profiles.of(profileExpressions))}.\n\t * @since 5.3.28\n\t * @see Profiles#of(String...)\n\t * @see #acceptsProfiles(Profiles)\n\t "
  },
  {
    "entityId": "org.springframework.core.env.Environment#acceptsProfiles(String)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether one or more of the given profiles is active &mdash; or\r\n * in the case of no explicit {@linkplain #getActiveProfiles() active profiles},\r\n * whether one or more of the given profiles is included in the set of\r\n * {@linkplain #getDefaultProfiles() default profiles}.\r\n * <p>If a profile begins with '!' the logic is inverted, meaning this method\r\n * will return {@code true} if the given profile is <em>not</em> active. For\r\n * example, {@code env.acceptsProfiles(\"p1\", \"!p2\")} will return {@code true}\r\n * if profile 'p1' is active or 'p2' is not active.\r\n * @throws IllegalArgumentException if called with a {@code null} array, an\r\n * empty array, zero arguments or if any profile is {@code null}, empty, or\r\n * whitespace only\r\n * @see #getActiveProfiles\r\n * @see #getDefaultProfiles\r\n * @see #matchesProfiles(String...)\r\n * @see #acceptsProfiles(Profiles)\r\n * @deprecated as of 5.1 in favor of {@link #acceptsProfiles(Profiles)} or\r\n * {@link #matchesProfiles(String...)}\r\n */\r\n@Deprecated\r\nboolean acceptsProfiles(String... profiles);",
    "comment": "\n\t * Determine whether one or more of the given profiles is active &mdash; or\n\t * in the case of no explicit {@linkplain #getActiveProfiles() active profiles},\n\t * whether one or more of the given profiles is included in the set of\n\t * {@linkplain #getDefaultProfiles() default profiles}.\n\t * <p>If a profile begins with '!' the logic is inverted, meaning this method\n\t * will return {@code true} if the given profile is <em>not</em> active. For\n\t * example, {@code env.acceptsProfiles(\"p1\", \"!p2\")} will return {@code true}\n\t * if profile 'p1' is active or 'p2' is not active.\n\t * @throws IllegalArgumentException if called with a {@code null} array, an\n\t * empty array, zero arguments or if any profile is {@code null}, empty, or\n\t * whitespace only\n\t * @see #getActiveProfiles\n\t * @see #getDefaultProfiles\n\t * @see #matchesProfiles(String...)\n\t * @see #acceptsProfiles(Profiles)\n\t * @deprecated as of 5.1 in favor of {@link #acceptsProfiles(Profiles)} or\n\t * {@link #matchesProfiles(String...)}\n\t "
  },
  {
    "entityId": "org.springframework.core.env.Environment#acceptsProfiles(Profiles)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given {@link Profiles} predicate matches the\r\n * {@linkplain #getActiveProfiles() active profiles} &mdash; or in the case\r\n * of no explicit active profiles, whether the given {@code Profiles} predicate\r\n * matches the {@linkplain #getDefaultProfiles() default profiles}.\r\n * <p>If you wish provide profile expressions directly as strings, use\r\n * {@link #matchesProfiles(String...)} instead.\r\n * @since 5.1\r\n * @see #matchesProfiles(String...)\r\n * @see Profiles#of(String...)\r\n */\r\nboolean acceptsProfiles(Profiles profiles);",
    "comment": "\n\t * Determine whether the given {@link Profiles} predicate matches the\n\t * {@linkplain #getActiveProfiles() active profiles} &mdash; or in the case\n\t * of no explicit active profiles, whether the given {@code Profiles} predicate\n\t * matches the {@linkplain #getDefaultProfiles() default profiles}.\n\t * <p>If you wish provide profile expressions directly as strings, use\n\t * {@link #matchesProfiles(String...)} instead.\n\t * @since 5.1\n\t * @see #matchesProfiles(String...)\n\t * @see Profiles#of(String...)\n\t "
  },
  {
    "entityId": "org.springframework.core.env.EnvironmentCapable",
    "entityType": "class",
    "code": "/**\r\n * Return the {@link Environment} associated with this component.\r\n */\r\nEnvironment getEnvironment();",
    "comment": "\n * Interface indicating a component that contains and exposes an {@link Environment} reference.\n *\n * <p>All Spring application contexts are EnvironmentCapable, and the interface is used primarily\n * for performing {@code instanceof} checks in framework methods that accept BeanFactory\n * instances that may or may not actually be ApplicationContext instances in order to interact\n * with the environment if indeed it is available.\n *\n * <p>As mentioned, {@link org.springframework.context.ApplicationContext ApplicationContext}\n * extends EnvironmentCapable, and thus exposes a {@link #getEnvironment()} method; however,\n * {@link org.springframework.context.ConfigurableApplicationContext ConfigurableApplicationContext}\n * redefines {@link org.springframework.context.ConfigurableApplicationContext#getEnvironment\n * getEnvironment()} and narrows the signature to return a {@link ConfigurableEnvironment}.\n * The effect is that an Environment object is 'read-only' until it is being accessed from\n * a ConfigurableApplicationContext, at which point it too may be configured.\n *\n * @author Chris Beams\n * @since 3.1\n * @see Environment\n * @see ConfigurableEnvironment\n * @see org.springframework.context.ConfigurableApplicationContext#getEnvironment()\n "
  },
  {
    "entityId": "org.springframework.core.env.EnvironmentCapable#getEnvironment()",
    "entityType": "method",
    "code": "/**\r\n * Return the {@link Environment} associated with this component.\r\n */\r\nEnvironment getEnvironment();",
    "comment": "\n\t * Return the {@link Environment} associated with this component.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.JOptCommandLinePropertySource",
    "entityType": "class",
    "code": "/**\r\n * Create a new {@code JOptCommandLinePropertySource} having the default name\r\n * and backed by the given {@code OptionSet}.\r\n * @see CommandLinePropertySource#COMMAND_LINE_PROPERTY_SOURCE_NAME\r\n * @see CommandLinePropertySource#CommandLinePropertySource(Object)\r\n */\r\npublic JOptCommandLinePropertySource(OptionSet options) {\r\n    super(options);\r\n}\n/**\r\n * Create a new {@code JOptCommandLinePropertySource} having the given name\r\n * and backed by the given {@code OptionSet}.\r\n */\r\npublic JOptCommandLinePropertySource(String name, OptionSet options) {\r\n    super(name, options);\r\n}\n@Override\r\nprotected boolean containsOption(String name) {\r\n    return this.source.has(name);\r\n}\n@Override\r\npublic String[] getPropertyNames() {\r\n    List<String> names = new ArrayList<>();\r\n    for (OptionSpec<?> spec : this.source.specs()) {\r\n        // Last option is expected to be the most descriptive.\r\n        String lastOption = CollectionUtils.lastElement(spec.options());\r\n        if (lastOption != null) {\r\n            names.add(lastOption);\r\n        }\r\n    }\r\n    return StringUtils.toStringArray(names);\r\n}\n@Override\r\n@Nullable\r\npublic List<String> getOptionValues(String name) {\r\n    List<?> argValues = this.source.valuesOf(name);\r\n    List<String> stringArgValues = new ArrayList<>();\r\n    for (Object argValue : argValues) {\r\n        stringArgValues.add(argValue.toString());\r\n    }\r\n    if (stringArgValues.isEmpty()) {\r\n        return (this.source.has(name) ? Collections.emptyList() : null);\r\n    }\r\n    return Collections.unmodifiableList(stringArgValues);\r\n}\n@Override\r\nprotected List<String> getNonOptionArgs() {\r\n    List<?> argValues = this.source.nonOptionArguments();\r\n    List<String> stringArgValues = new ArrayList<>();\r\n    for (Object argValue : argValues) {\r\n        stringArgValues.add(argValue.toString());\r\n    }\r\n    return (stringArgValues.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(stringArgValues));\r\n}",
    "comment": "\n * {@link CommandLinePropertySource} implementation backed by a JOpt {@link OptionSet}.\n *\n * <h2>Typical usage</h2>\n *\n * Configure and execute an {@code OptionParser} against the {@code String[]} of arguments\n * supplied to the {@code main} method, and create a {@link JOptCommandLinePropertySource}\n * using the resulting {@code OptionSet} object:\n *\n * <pre class=\"code\">\n * public static void main(String[] args) {\n *     OptionParser parser = new OptionParser();\n *     parser.accepts(\"option1\");\n *     parser.accepts(\"option2\").withRequiredArg();\n *     OptionSet options = parser.parse(args);\n *     PropertySource&lt;?&gt; ps = new JOptCommandLinePropertySource(options);\n *     // ...\n * }</pre>\n *\n * <p>If an option has several representations, the most descriptive is expected\n * to be set last, and is used as the property name of the associated\n * {@link EnumerablePropertySource#getPropertyNames()}.\n *\n * <p>See {@link CommandLinePropertySource} for complete general usage examples.\n *\n * <p>Requires JOpt Simple version 4.3 or higher. Tested against JOpt up until 5.0.\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @author Dave Syer\n * @since 3.1\n * @see CommandLinePropertySource\n * @see joptsimple.OptionParser\n * @see joptsimple.OptionSet\n * @deprecated since 6.1 with no plans for a replacement\n "
  },
  {
    "entityId": "org.springframework.core.env.JOptCommandLinePropertySource#containsOption(String)",
    "entityType": "method",
    "code": "@Override\r\nprotected boolean containsOption(String name) {\r\n    return this.source.has(name);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.JOptCommandLinePropertySource#getPropertyNames()",
    "entityType": "method",
    "code": "@Override\r\npublic String[] getPropertyNames() {\r\n    List<String> names = new ArrayList<>();\r\n    for (OptionSpec<?> spec : this.source.specs()) {\r\n        // Last option is expected to be the most descriptive.\r\n        String lastOption = CollectionUtils.lastElement(spec.options());\r\n        if (lastOption != null) {\r\n            names.add(lastOption);\r\n        }\r\n    }\r\n    return StringUtils.toStringArray(names);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.JOptCommandLinePropertySource#getOptionValues(String)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic List<String> getOptionValues(String name) {\r\n    List<?> argValues = this.source.valuesOf(name);\r\n    List<String> stringArgValues = new ArrayList<>();\r\n    for (Object argValue : argValues) {\r\n        stringArgValues.add(argValue.toString());\r\n    }\r\n    if (stringArgValues.isEmpty()) {\r\n        return (this.source.has(name) ? Collections.emptyList() : null);\r\n    }\r\n    return Collections.unmodifiableList(stringArgValues);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.JOptCommandLinePropertySource#getNonOptionArgs()",
    "entityType": "method",
    "code": "@Override\r\nprotected List<String> getNonOptionArgs() {\r\n    List<?> argValues = this.source.nonOptionArguments();\r\n    List<String> stringArgValues = new ArrayList<>();\r\n    for (Object argValue : argValues) {\r\n        stringArgValues.add(argValue.toString());\r\n    }\r\n    return (stringArgValues.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(stringArgValues));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.MapPropertySource",
    "entityType": "class",
    "code": "/**\r\n * Create a new {@code MapPropertySource} with the given name and {@code Map}.\r\n * @param name the associated name\r\n * @param source the Map source (without {@code null} values in order to get\r\n * consistent {@link #getProperty} and {@link #containsProperty} behavior)\r\n */\r\npublic MapPropertySource(String name, Map<String, Object> source) {\r\n    super(name, source);\r\n}\n@Override\r\n@Nullable\r\npublic Object getProperty(String name) {\r\n    return this.source.get(name);\r\n}\n@Override\r\npublic boolean containsProperty(String name) {\r\n    return this.source.containsKey(name);\r\n}\n@Override\r\npublic String[] getPropertyNames() {\r\n    return StringUtils.toStringArray(this.source.keySet());\r\n}",
    "comment": "\n * {@link PropertySource} that reads keys and values from a {@code Map} object.\n * The underlying map should not contain any {@code null} values in order to\n * comply with {@link #getProperty} and {@link #containsProperty} semantics.\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @since 3.1\n * @see PropertiesPropertySource\n "
  },
  {
    "entityId": "org.springframework.core.env.MapPropertySource#getProperty(String)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Object getProperty(String name) {\r\n    return this.source.get(name);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.MapPropertySource#containsProperty(String)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean containsProperty(String name) {\r\n    return this.source.containsKey(name);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.MapPropertySource#getPropertyNames()",
    "entityType": "method",
    "code": "@Override\r\npublic String[] getPropertyNames() {\r\n    return StringUtils.toStringArray(this.source.keySet());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.MissingRequiredPropertiesException",
    "entityType": "class",
    "code": "private final Set<String> missingRequiredProperties = new LinkedHashSet<>();\nvoid addMissingRequiredProperty(String key) {\r\n    this.missingRequiredProperties.add(key);\r\n}\n@Override\r\npublic String getMessage() {\r\n    return \"The following properties were declared as required but could not be resolved: \" + getMissingRequiredProperties();\r\n}\n/**\r\n * Return the set of properties marked as required but not present\r\n * upon validation.\r\n * @see ConfigurablePropertyResolver#setRequiredProperties(String...)\r\n * @see ConfigurablePropertyResolver#validateRequiredProperties()\r\n */\r\npublic Set<String> getMissingRequiredProperties() {\r\n    return this.missingRequiredProperties;\r\n}",
    "comment": "\n * Exception thrown when required properties are not found.\n *\n * @author Chris Beams\n * @since 3.1\n * @see ConfigurablePropertyResolver#setRequiredProperties(String...)\n * @see ConfigurablePropertyResolver#validateRequiredProperties()\n * @see org.springframework.context.support.AbstractApplicationContext#prepareRefresh()\n "
  },
  {
    "entityId": "org.springframework.core.env.MissingRequiredPropertiesException#addMissingRequiredProperty(String)",
    "entityType": "method",
    "code": "void addMissingRequiredProperty(String key) {\r\n    this.missingRequiredProperties.add(key);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.MissingRequiredPropertiesException#getMessage()",
    "entityType": "method",
    "code": "@Override\r\npublic String getMessage() {\r\n    return \"The following properties were declared as required but could not be resolved: \" + getMissingRequiredProperties();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.MissingRequiredPropertiesException#getMissingRequiredProperties()",
    "entityType": "method",
    "code": "/**\r\n * Return the set of properties marked as required but not present\r\n * upon validation.\r\n * @see ConfigurablePropertyResolver#setRequiredProperties(String...)\r\n * @see ConfigurablePropertyResolver#validateRequiredProperties()\r\n */\r\npublic Set<String> getMissingRequiredProperties() {\r\n    return this.missingRequiredProperties;\r\n}",
    "comment": "\n\t * Return the set of properties marked as required but not present\n\t * upon validation.\n\t * @see ConfigurablePropertyResolver#setRequiredProperties(String...)\n\t * @see ConfigurablePropertyResolver#validateRequiredProperties()\n\t "
  },
  {
    "entityId": "org.springframework.core.env.MutablePropertySources",
    "entityType": "class",
    "code": "private final List<PropertySource<?>> propertySourceList = new CopyOnWriteArrayList<>();\n/**\r\n * Create a new {@link MutablePropertySources} object.\r\n */\r\npublic MutablePropertySources() {\r\n}\n/**\r\n * Create a new {@code MutablePropertySources} from the given propertySources\r\n * object, preserving the original order of contained {@code PropertySource} objects.\r\n */\r\npublic MutablePropertySources(PropertySources propertySources) {\r\n    this();\r\n    for (PropertySource<?> propertySource : propertySources) {\r\n        addLast(propertySource);\r\n    }\r\n}\n@Override\r\npublic Iterator<PropertySource<?>> iterator() {\r\n    return this.propertySourceList.iterator();\r\n}\n@Override\r\npublic Spliterator<PropertySource<?>> spliterator() {\r\n    return this.propertySourceList.spliterator();\r\n}\n@Override\r\npublic Stream<PropertySource<?>> stream() {\r\n    return this.propertySourceList.stream();\r\n}\n@Override\r\npublic boolean contains(String name) {\r\n    for (PropertySource<?> propertySource : this.propertySourceList) {\r\n        if (propertySource.getName().equals(name)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n@Override\r\n@Nullable\r\npublic PropertySource<?> get(String name) {\r\n    for (PropertySource<?> propertySource : this.propertySourceList) {\r\n        if (propertySource.getName().equals(name)) {\r\n            return propertySource;\r\n        }\r\n    }\r\n    return null;\r\n}\n/**\r\n * Add the given property source object with the highest precedence.\r\n */\r\npublic void addFirst(PropertySource<?> propertySource) {\r\n    synchronized (this.propertySourceList) {\r\n        removeIfPresent(propertySource);\r\n        this.propertySourceList.add(0, propertySource);\r\n    }\r\n}\n/**\r\n * Add the given property source object with the lowest precedence.\r\n */\r\npublic void addLast(PropertySource<?> propertySource) {\r\n    synchronized (this.propertySourceList) {\r\n        removeIfPresent(propertySource);\r\n        this.propertySourceList.add(propertySource);\r\n    }\r\n}\n/**\r\n * Add the given property source object with precedence immediately higher\r\n * than the named relative property source.\r\n */\r\npublic void addBefore(String relativePropertySourceName, PropertySource<?> propertySource) {\r\n    assertLegalRelativeAddition(relativePropertySourceName, propertySource);\r\n    synchronized (this.propertySourceList) {\r\n        removeIfPresent(propertySource);\r\n        int index = assertPresentAndGetIndex(relativePropertySourceName);\r\n        addAtIndex(index, propertySource);\r\n    }\r\n}\n/**\r\n * Add the given property source object with precedence immediately lower\r\n * than the named relative property source.\r\n */\r\npublic void addAfter(String relativePropertySourceName, PropertySource<?> propertySource) {\r\n    assertLegalRelativeAddition(relativePropertySourceName, propertySource);\r\n    synchronized (this.propertySourceList) {\r\n        removeIfPresent(propertySource);\r\n        int index = assertPresentAndGetIndex(relativePropertySourceName);\r\n        addAtIndex(index + 1, propertySource);\r\n    }\r\n}\n/**\r\n * Return the precedence of the given property source, {@code -1} if not found.\r\n */\r\npublic int precedenceOf(PropertySource<?> propertySource) {\r\n    return this.propertySourceList.indexOf(propertySource);\r\n}\n/**\r\n * Remove and return the property source with the given name, {@code null} if not found.\r\n * @param name the name of the property source to find and remove\r\n */\r\n@Nullable\r\npublic PropertySource<?> remove(String name) {\r\n    synchronized (this.propertySourceList) {\r\n        int index = this.propertySourceList.indexOf(PropertySource.named(name));\r\n        return (index != -1 ? this.propertySourceList.remove(index) : null);\r\n    }\r\n}\n/**\r\n * Replace the property source with the given name with the given property source object.\r\n * @param name the name of the property source to find and replace\r\n * @param propertySource the replacement property source\r\n * @throws IllegalArgumentException if no property source with the given name is present\r\n * @see #contains\r\n */\r\npublic void replace(String name, PropertySource<?> propertySource) {\r\n    synchronized (this.propertySourceList) {\r\n        int index = assertPresentAndGetIndex(name);\r\n        this.propertySourceList.set(index, propertySource);\r\n    }\r\n}\n/**\r\n * Return the number of {@link PropertySource} objects contained.\r\n */\r\npublic int size() {\r\n    return this.propertySourceList.size();\r\n}\n@Override\r\npublic String toString() {\r\n    return this.propertySourceList.toString();\r\n}\n/**\r\n * Ensure that the given property source is not being added relative to itself.\r\n */\r\nprotected void assertLegalRelativeAddition(String relativePropertySourceName, PropertySource<?> propertySource) {\r\n    String newPropertySourceName = propertySource.getName();\r\n    if (relativePropertySourceName.equals(newPropertySourceName)) {\r\n        throw new IllegalArgumentException(\"PropertySource named '\" + newPropertySourceName + \"' cannot be added relative to itself\");\r\n    }\r\n}\n/**\r\n * Remove the given property source if it is present.\r\n */\r\nprotected void removeIfPresent(PropertySource<?> propertySource) {\r\n    this.propertySourceList.remove(propertySource);\r\n}\n/**\r\n * Add the given property source at a particular index in the list.\r\n */\r\nprivate void addAtIndex(int index, PropertySource<?> propertySource) {\r\n    removeIfPresent(propertySource);\r\n    this.propertySourceList.add(index, propertySource);\r\n}\n/**\r\n * Assert that the named property source is present and return its index.\r\n * @param name {@linkplain PropertySource#getName() name of the property source} to find\r\n * @throws IllegalArgumentException if the named property source is not present\r\n */\r\nprivate int assertPresentAndGetIndex(String name) {\r\n    int index = this.propertySourceList.indexOf(PropertySource.named(name));\r\n    if (index == -1) {\r\n        throw new IllegalArgumentException(\"PropertySource named '\" + name + \"' does not exist\");\r\n    }\r\n    return index;\r\n}",
    "comment": "\n * The default implementation of the {@link PropertySources} interface.\n * Allows manipulation of contained property sources and provides a constructor\n * for copying an existing {@code PropertySources} instance.\n *\n * <p>Where <em>precedence</em> is mentioned in methods such as {@link #addFirst}\n * and {@link #addLast}, this is with regard to the order in which property sources\n * will be searched when resolving a given property with a {@link PropertyResolver}.\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @since 3.1\n * @see PropertySourcesPropertyResolver\n "
  },
  {
    "entityId": "org.springframework.core.env.MutablePropertySources#iterator()",
    "entityType": "method",
    "code": "@Override\r\npublic Iterator<PropertySource<?>> iterator() {\r\n    return this.propertySourceList.iterator();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.MutablePropertySources#spliterator()",
    "entityType": "method",
    "code": "@Override\r\npublic Spliterator<PropertySource<?>> spliterator() {\r\n    return this.propertySourceList.spliterator();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.MutablePropertySources#stream()",
    "entityType": "method",
    "code": "@Override\r\npublic Stream<PropertySource<?>> stream() {\r\n    return this.propertySourceList.stream();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.MutablePropertySources#contains(String)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean contains(String name) {\r\n    for (PropertySource<?> propertySource : this.propertySourceList) {\r\n        if (propertySource.getName().equals(name)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.MutablePropertySources#get(String)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic PropertySource<?> get(String name) {\r\n    for (PropertySource<?> propertySource : this.propertySourceList) {\r\n        if (propertySource.getName().equals(name)) {\r\n            return propertySource;\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.MutablePropertySources#addFirst(PropertySource<?>)",
    "entityType": "method",
    "code": "/**\r\n * Add the given property source object with the highest precedence.\r\n */\r\npublic void addFirst(PropertySource<?> propertySource) {\r\n    synchronized (this.propertySourceList) {\r\n        removeIfPresent(propertySource);\r\n        this.propertySourceList.add(0, propertySource);\r\n    }\r\n}",
    "comment": "\n\t * Add the given property source object with the highest precedence.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.MutablePropertySources#addLast(PropertySource<?>)",
    "entityType": "method",
    "code": "/**\r\n * Add the given property source object with the lowest precedence.\r\n */\r\npublic void addLast(PropertySource<?> propertySource) {\r\n    synchronized (this.propertySourceList) {\r\n        removeIfPresent(propertySource);\r\n        this.propertySourceList.add(propertySource);\r\n    }\r\n}",
    "comment": "\n\t * Add the given property source object with the lowest precedence.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.MutablePropertySources#addBefore(String,PropertySource<?>)",
    "entityType": "method",
    "code": "/**\r\n * Add the given property source object with precedence immediately higher\r\n * than the named relative property source.\r\n */\r\npublic void addBefore(String relativePropertySourceName, PropertySource<?> propertySource) {\r\n    assertLegalRelativeAddition(relativePropertySourceName, propertySource);\r\n    synchronized (this.propertySourceList) {\r\n        removeIfPresent(propertySource);\r\n        int index = assertPresentAndGetIndex(relativePropertySourceName);\r\n        addAtIndex(index, propertySource);\r\n    }\r\n}",
    "comment": "\n\t * Add the given property source object with precedence immediately higher\n\t * than the named relative property source.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.MutablePropertySources#addAfter(String,PropertySource<?>)",
    "entityType": "method",
    "code": "/**\r\n * Add the given property source object with precedence immediately lower\r\n * than the named relative property source.\r\n */\r\npublic void addAfter(String relativePropertySourceName, PropertySource<?> propertySource) {\r\n    assertLegalRelativeAddition(relativePropertySourceName, propertySource);\r\n    synchronized (this.propertySourceList) {\r\n        removeIfPresent(propertySource);\r\n        int index = assertPresentAndGetIndex(relativePropertySourceName);\r\n        addAtIndex(index + 1, propertySource);\r\n    }\r\n}",
    "comment": "\n\t * Add the given property source object with precedence immediately lower\n\t * than the named relative property source.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.MutablePropertySources#precedenceOf(PropertySource<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return the precedence of the given property source, {@code -1} if not found.\r\n */\r\npublic int precedenceOf(PropertySource<?> propertySource) {\r\n    return this.propertySourceList.indexOf(propertySource);\r\n}",
    "comment": "\n\t * Return the precedence of the given property source, {@code -1} if not found.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.MutablePropertySources#remove(String)",
    "entityType": "method",
    "code": "/**\r\n * Remove and return the property source with the given name, {@code null} if not found.\r\n * @param name the name of the property source to find and remove\r\n */\r\n@Nullable\r\npublic PropertySource<?> remove(String name) {\r\n    synchronized (this.propertySourceList) {\r\n        int index = this.propertySourceList.indexOf(PropertySource.named(name));\r\n        return (index != -1 ? this.propertySourceList.remove(index) : null);\r\n    }\r\n}",
    "comment": "\n\t * Remove and return the property source with the given name, {@code null} if not found.\n\t * @param name the name of the property source to find and remove\n\t "
  },
  {
    "entityId": "org.springframework.core.env.MutablePropertySources#replace(String,PropertySource<?>)",
    "entityType": "method",
    "code": "/**\r\n * Replace the property source with the given name with the given property source object.\r\n * @param name the name of the property source to find and replace\r\n * @param propertySource the replacement property source\r\n * @throws IllegalArgumentException if no property source with the given name is present\r\n * @see #contains\r\n */\r\npublic void replace(String name, PropertySource<?> propertySource) {\r\n    synchronized (this.propertySourceList) {\r\n        int index = assertPresentAndGetIndex(name);\r\n        this.propertySourceList.set(index, propertySource);\r\n    }\r\n}",
    "comment": "\n\t * Replace the property source with the given name with the given property source object.\n\t * @param name the name of the property source to find and replace\n\t * @param propertySource the replacement property source\n\t * @throws IllegalArgumentException if no property source with the given name is present\n\t * @see #contains\n\t "
  },
  {
    "entityId": "org.springframework.core.env.MutablePropertySources#size()",
    "entityType": "method",
    "code": "/**\r\n * Return the number of {@link PropertySource} objects contained.\r\n */\r\npublic int size() {\r\n    return this.propertySourceList.size();\r\n}",
    "comment": "\n\t * Return the number of {@link PropertySource} objects contained.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.MutablePropertySources#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return this.propertySourceList.toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.MutablePropertySources#assertLegalRelativeAddition(String,PropertySource<?>)",
    "entityType": "method",
    "code": "/**\r\n * Ensure that the given property source is not being added relative to itself.\r\n */\r\nprotected void assertLegalRelativeAddition(String relativePropertySourceName, PropertySource<?> propertySource) {\r\n    String newPropertySourceName = propertySource.getName();\r\n    if (relativePropertySourceName.equals(newPropertySourceName)) {\r\n        throw new IllegalArgumentException(\"PropertySource named '\" + newPropertySourceName + \"' cannot be added relative to itself\");\r\n    }\r\n}",
    "comment": "\n\t * Ensure that the given property source is not being added relative to itself.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.MutablePropertySources#removeIfPresent(PropertySource<?>)",
    "entityType": "method",
    "code": "/**\r\n * Remove the given property source if it is present.\r\n */\r\nprotected void removeIfPresent(PropertySource<?> propertySource) {\r\n    this.propertySourceList.remove(propertySource);\r\n}",
    "comment": "\n\t * Remove the given property source if it is present.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.MutablePropertySources#addAtIndex(int,PropertySource<?>)",
    "entityType": "method",
    "code": "/**\r\n * Add the given property source at a particular index in the list.\r\n */\r\nprivate void addAtIndex(int index, PropertySource<?> propertySource) {\r\n    removeIfPresent(propertySource);\r\n    this.propertySourceList.add(index, propertySource);\r\n}",
    "comment": "\n\t * Add the given property source at a particular index in the list.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.MutablePropertySources#assertPresentAndGetIndex(String)",
    "entityType": "method",
    "code": "/**\r\n * Assert that the named property source is present and return its index.\r\n * @param name {@linkplain PropertySource#getName() name of the property source} to find\r\n * @throws IllegalArgumentException if the named property source is not present\r\n */\r\nprivate int assertPresentAndGetIndex(String name) {\r\n    int index = this.propertySourceList.indexOf(PropertySource.named(name));\r\n    if (index == -1) {\r\n        throw new IllegalArgumentException(\"PropertySource named '\" + name + \"' does not exist\");\r\n    }\r\n    return index;\r\n}",
    "comment": "\n\t * Assert that the named property source is present and return its index.\n\t * @param name {@linkplain PropertySource#getName() name of the property source} to find\n\t * @throws IllegalArgumentException if the named property source is not present\n\t "
  },
  {
    "entityId": "org.springframework.core.env.Profiles",
    "entityType": "class",
    "code": "/**\r\n * Test if this {@code Profiles} instance <em>matches</em> against the given\r\n * predicate.\r\n * @param isProfileActive a predicate that tests whether a given profile is\r\n * currently active\r\n */\r\nboolean matches(Predicate<String> isProfileActive);\n/**\r\n * Create a new {@link Profiles} instance that checks for matches against\r\n * the given <em>profile expressions</em>.\r\n * <p>The returned instance will {@linkplain Profiles#matches(Predicate) match}\r\n * if any one of the given profile expressions matches.\r\n * <p>A profile expression may contain a simple profile name (for example\r\n * {@code \"production\"}) or a compound expression. A compound expression allows\r\n * for more complicated profile logic to be expressed, for example\r\n * {@code \"production & cloud\"}.\r\n * <p>The following operators are supported in profile expressions.\r\n * <ul>\r\n * <li>{@code !} - A logical <em>NOT</em> of the profile name or compound expression</li>\r\n * <li>{@code &} - A logical <em>AND</em> of the profile names or compound expressions</li>\r\n * <li>{@code |} - A logical <em>OR</em> of the profile names or compound expressions</li>\r\n * </ul>\r\n * <p>Please note that the {@code &} and {@code |} operators may not be mixed\r\n * without using parentheses. For example, {@code \"a & b | c\"} is not a valid\r\n * expression: it must be expressed as {@code \"(a & b) | c\"} or\r\n * {@code \"a & (b | c)\"}.\r\n * <p>Two {@code Profiles} instances returned by this method are considered\r\n * equivalent to each other (in terms of {@code equals()} and {@code hashCode()}\r\n * semantics) if they are created with identical <em>profile expressions</em>.\r\n * @param profileExpressions the <em>profile expressions</em> to include\r\n * @return a new {@link Profiles} instance\r\n */\r\nstatic Profiles of(String... profileExpressions) {\r\n    return ProfilesParser.parse(profileExpressions);\r\n}",
    "comment": "\n * Profile predicate that may be {@linkplain Environment#acceptsProfiles(Profiles)\n * accepted} by an {@link Environment}.\n *\n * <p>May be implemented directly or, more usually, created using the\n * {@link #of(String...) of(...)} factory method.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n * @since 5.1\n * @see Environment#acceptsProfiles(Profiles)\n * @see Environment#matchesProfiles(String...)\n "
  },
  {
    "entityId": "org.springframework.core.env.Profiles#matches(Predicate<String>)",
    "entityType": "method",
    "code": "/**\r\n * Test if this {@code Profiles} instance <em>matches</em> against the given\r\n * predicate.\r\n * @param isProfileActive a predicate that tests whether a given profile is\r\n * currently active\r\n */\r\nboolean matches(Predicate<String> isProfileActive);",
    "comment": "\n\t * Test if this {@code Profiles} instance <em>matches</em> against the given\n\t * predicate.\n\t * @param isProfileActive a predicate that tests whether a given profile is\n\t * currently active\n\t "
  },
  {
    "entityId": "org.springframework.core.env.Profiles#of(String)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link Profiles} instance that checks for matches against\r\n * the given <em>profile expressions</em>.\r\n * <p>The returned instance will {@linkplain Profiles#matches(Predicate) match}\r\n * if any one of the given profile expressions matches.\r\n * <p>A profile expression may contain a simple profile name (for example\r\n * {@code \"production\"}) or a compound expression. A compound expression allows\r\n * for more complicated profile logic to be expressed, for example\r\n * {@code \"production & cloud\"}.\r\n * <p>The following operators are supported in profile expressions.\r\n * <ul>\r\n * <li>{@code !} - A logical <em>NOT</em> of the profile name or compound expression</li>\r\n * <li>{@code &} - A logical <em>AND</em> of the profile names or compound expressions</li>\r\n * <li>{@code |} - A logical <em>OR</em> of the profile names or compound expressions</li>\r\n * </ul>\r\n * <p>Please note that the {@code &} and {@code |} operators may not be mixed\r\n * without using parentheses. For example, {@code \"a & b | c\"} is not a valid\r\n * expression: it must be expressed as {@code \"(a & b) | c\"} or\r\n * {@code \"a & (b | c)\"}.\r\n * <p>Two {@code Profiles} instances returned by this method are considered\r\n * equivalent to each other (in terms of {@code equals()} and {@code hashCode()}\r\n * semantics) if they are created with identical <em>profile expressions</em>.\r\n * @param profileExpressions the <em>profile expressions</em> to include\r\n * @return a new {@link Profiles} instance\r\n */\r\nstatic Profiles of(String... profileExpressions) {\r\n    return ProfilesParser.parse(profileExpressions);\r\n}",
    "comment": "\n\t * Create a new {@link Profiles} instance that checks for matches against\n\t * the given <em>profile expressions</em>.\n\t * <p>The returned instance will {@linkplain Profiles#matches(Predicate) match}\n\t * if any one of the given profile expressions matches.\n\t * <p>A profile expression may contain a simple profile name (for example\n\t * {@code \"production\"}) or a compound expression. A compound expression allows\n\t * for more complicated profile logic to be expressed, for example\n\t * {@code \"production & cloud\"}.\n\t * <p>The following operators are supported in profile expressions.\n\t * <ul>\n\t * <li>{@code !} - A logical <em>NOT</em> of the profile name or compound expression</li>\n\t * <li>{@code &} - A logical <em>AND</em> of the profile names or compound expressions</li>\n\t * <li>{@code |} - A logical <em>OR</em> of the profile names or compound expressions</li>\n\t * </ul>\n\t * <p>Please note that the {@code &} and {@code |} operators may not be mixed\n\t * without using parentheses. For example, {@code \"a & b | c\"} is not a valid\n\t * expression: it must be expressed as {@code \"(a & b) | c\"} or\n\t * {@code \"a & (b | c)\"}.\n\t * <p>Two {@code Profiles} instances returned by this method are considered\n\t * equivalent to each other (in terms of {@code equals()} and {@code hashCode()}\n\t * semantics) if they are created with identical <em>profile expressions</em>.\n\t * @param profileExpressions the <em>profile expressions</em> to include\n\t * @return a new {@link Profiles} instance\n\t "
  },
  {
    "entityId": "org.springframework.core.env.ProfilesParser",
    "entityType": "class",
    "code": "private ProfilesParser() {\r\n}\nstatic Profiles parse(String... expressions) {\r\n    Assert.notEmpty(expressions, \"Must specify at least one profile expression\");\r\n    Profiles[] parsed = new Profiles[expressions.length];\r\n    for (int i = 0; i < expressions.length; i++) {\r\n        parsed[i] = parseExpression(expressions[i]);\r\n    }\r\n    return new ParsedProfiles(expressions, parsed);\r\n}\nprivate static Profiles parseExpression(String expression) {\r\n    Assert.hasText(expression, () -> \"Invalid profile expression [\" + expression + \"]: must contain text\");\r\n    StringTokenizer tokens = new StringTokenizer(expression, \"()&|!\", true);\r\n    return parseTokens(expression, tokens);\r\n}\nprivate static Profiles parseTokens(String expression, StringTokenizer tokens) {\r\n    return parseTokens(expression, tokens, Context.NONE);\r\n}\nprivate static Profiles parseTokens(String expression, StringTokenizer tokens, Context context) {\r\n    List<Profiles> elements = new ArrayList<>();\r\n    Operator operator = null;\r\n    while (tokens.hasMoreTokens()) {\r\n        String token = tokens.nextToken().trim();\r\n        if (token.isEmpty()) {\r\n            continue;\r\n        }\r\n        switch(token) {\r\n            case \"(\" ->\r\n                {\r\n                    Profiles contents = parseTokens(expression, tokens, Context.PARENTHESIS);\r\n                    if (context == Context.NEGATE) {\r\n                        return contents;\r\n                    }\r\n                    elements.add(contents);\r\n                }\r\n            case \"&\" ->\r\n                {\r\n                    assertWellFormed(expression, operator == null || operator == Operator.AND);\r\n                    operator = Operator.AND;\r\n                }\r\n            case \"|\" ->\r\n                {\r\n                    assertWellFormed(expression, operator == null || operator == Operator.OR);\r\n                    operator = Operator.OR;\r\n                }\r\n            case \"!\" ->\r\n                elements.add(not(parseTokens(expression, tokens, Context.NEGATE)));\r\n            case \")\" ->\r\n                {\r\n                    Profiles merged = merge(expression, elements, operator);\r\n                    if (context == Context.PARENTHESIS) {\r\n                        return merged;\r\n                    }\r\n                    elements.clear();\r\n                    elements.add(merged);\r\n                    operator = null;\r\n                }\r\n            default ->\r\n                {\r\n                    Profiles value = equals(token);\r\n                    if (context == Context.NEGATE) {\r\n                        return value;\r\n                    }\r\n                    elements.add(value);\r\n                }\r\n        }\r\n    }\r\n    return merge(expression, elements, operator);\r\n}\nprivate static Profiles merge(String expression, List<Profiles> elements, @Nullable Operator operator) {\r\n    assertWellFormed(expression, !elements.isEmpty());\r\n    if (elements.size() == 1) {\r\n        return elements.get(0);\r\n    }\r\n    Profiles[] profiles = elements.toArray(new Profiles[0]);\r\n    return (operator == Operator.AND ? and(profiles) : or(profiles));\r\n}\nprivate static void assertWellFormed(String expression, boolean wellFormed) {\r\n    Assert.isTrue(wellFormed, () -> \"Malformed profile expression [\" + expression + \"]\");\r\n}\nprivate static Profiles or(Profiles... profiles) {\r\n    return activeProfile -> Arrays.stream(profiles).anyMatch(isMatch(activeProfile));\r\n}\nprivate static Profiles and(Profiles... profiles) {\r\n    return activeProfile -> Arrays.stream(profiles).allMatch(isMatch(activeProfile));\r\n}\nprivate static Profiles not(Profiles profiles) {\r\n    return activeProfile -> !profiles.matches(activeProfile);\r\n}\nprivate static Profiles equals(String profile) {\r\n    return activeProfile -> activeProfile.test(profile);\r\n}\nprivate static Predicate<Profiles> isMatch(Predicate<String> activeProfiles) {\r\n    return profiles -> profiles.matches(activeProfiles);\r\n}\nprivate enum Operator {\r\n\r\n    AND, OR\r\n}\nprivate enum Context {\r\n\r\n    NONE, NEGATE, PARENTHESIS\r\n}\nprivate static class ParsedProfiles implements Profiles {\r\n\r\n    private final Set<String> expressions = new LinkedHashSet<>();\r\n\r\n    private final Profiles[] parsed;\r\n\r\n    ParsedProfiles(String[] expressions, Profiles[] parsed) {\r\n        Collections.addAll(this.expressions, expressions);\r\n        this.parsed = parsed;\r\n    }\r\n\r\n    @Override\r\n    public boolean matches(Predicate<String> activeProfiles) {\r\n        for (Profiles candidate : this.parsed) {\r\n            if (candidate.matches(activeProfiles)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(@Nullable Object other) {\r\n        return (this == other || (other instanceof ParsedProfiles that && this.expressions.equals(that.expressions)));\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        return this.expressions.hashCode();\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        if (this.expressions.size() == 1) {\r\n            return this.expressions.iterator().next();\r\n        }\r\n        return this.expressions.stream().map(this::wrap).collect(Collectors.joining(\" | \"));\r\n    }\r\n\r\n    private String wrap(String str) {\r\n        return \"(\" + str + \")\";\r\n    }\r\n}",
    "comment": "\n * Internal parser used by {@link Profiles#of}.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n * @since 5.1\n "
  },
  {
    "entityId": "org.springframework.core.env.ProfilesParser#parse(String)",
    "entityType": "method",
    "code": "static Profiles parse(String... expressions) {\r\n    Assert.notEmpty(expressions, \"Must specify at least one profile expression\");\r\n    Profiles[] parsed = new Profiles[expressions.length];\r\n    for (int i = 0; i < expressions.length; i++) {\r\n        parsed[i] = parseExpression(expressions[i]);\r\n    }\r\n    return new ParsedProfiles(expressions, parsed);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesParser#parseExpression(String)",
    "entityType": "method",
    "code": "private static Profiles parseExpression(String expression) {\r\n    Assert.hasText(expression, () -> \"Invalid profile expression [\" + expression + \"]: must contain text\");\r\n    StringTokenizer tokens = new StringTokenizer(expression, \"()&|!\", true);\r\n    return parseTokens(expression, tokens);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesParser#parseTokens(String,StringTokenizer)",
    "entityType": "method",
    "code": "private static Profiles parseTokens(String expression, StringTokenizer tokens) {\r\n    return parseTokens(expression, tokens, Context.NONE);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesParser#parseTokens(String,StringTokenizer,Context)",
    "entityType": "method",
    "code": "private static Profiles parseTokens(String expression, StringTokenizer tokens, Context context) {\r\n    List<Profiles> elements = new ArrayList<>();\r\n    Operator operator = null;\r\n    while (tokens.hasMoreTokens()) {\r\n        String token = tokens.nextToken().trim();\r\n        if (token.isEmpty()) {\r\n            continue;\r\n        }\r\n        switch(token) {\r\n            case \"(\" ->\r\n                {\r\n                    Profiles contents = parseTokens(expression, tokens, Context.PARENTHESIS);\r\n                    if (context == Context.NEGATE) {\r\n                        return contents;\r\n                    }\r\n                    elements.add(contents);\r\n                }\r\n            case \"&\" ->\r\n                {\r\n                    assertWellFormed(expression, operator == null || operator == Operator.AND);\r\n                    operator = Operator.AND;\r\n                }\r\n            case \"|\" ->\r\n                {\r\n                    assertWellFormed(expression, operator == null || operator == Operator.OR);\r\n                    operator = Operator.OR;\r\n                }\r\n            case \"!\" ->\r\n                elements.add(not(parseTokens(expression, tokens, Context.NEGATE)));\r\n            case \")\" ->\r\n                {\r\n                    Profiles merged = merge(expression, elements, operator);\r\n                    if (context == Context.PARENTHESIS) {\r\n                        return merged;\r\n                    }\r\n                    elements.clear();\r\n                    elements.add(merged);\r\n                    operator = null;\r\n                }\r\n            default ->\r\n                {\r\n                    Profiles value = equals(token);\r\n                    if (context == Context.NEGATE) {\r\n                        return value;\r\n                    }\r\n                    elements.add(value);\r\n                }\r\n        }\r\n    }\r\n    return merge(expression, elements, operator);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesParser#merge(String,List<Profiles>,Operator)",
    "entityType": "method",
    "code": "private static Profiles merge(String expression, List<Profiles> elements, @Nullable Operator operator) {\r\n    assertWellFormed(expression, !elements.isEmpty());\r\n    if (elements.size() == 1) {\r\n        return elements.get(0);\r\n    }\r\n    Profiles[] profiles = elements.toArray(new Profiles[0]);\r\n    return (operator == Operator.AND ? and(profiles) : or(profiles));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesParser#assertWellFormed(String,boolean)",
    "entityType": "method",
    "code": "private static void assertWellFormed(String expression, boolean wellFormed) {\r\n    Assert.isTrue(wellFormed, () -> \"Malformed profile expression [\" + expression + \"]\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesParser#or(Profiles)",
    "entityType": "method",
    "code": "private static Profiles or(Profiles... profiles) {\r\n    return activeProfile -> Arrays.stream(profiles).anyMatch(isMatch(activeProfile));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesParser#and(Profiles)",
    "entityType": "method",
    "code": "private static Profiles and(Profiles... profiles) {\r\n    return activeProfile -> Arrays.stream(profiles).allMatch(isMatch(activeProfile));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesParser#not(Profiles)",
    "entityType": "method",
    "code": "private static Profiles not(Profiles profiles) {\r\n    return activeProfile -> !profiles.matches(activeProfile);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesParser#equals(String)",
    "entityType": "method",
    "code": "private static Profiles equals(String profile) {\r\n    return activeProfile -> activeProfile.test(profile);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesParser#isMatch(Predicate<String>)",
    "entityType": "method",
    "code": "private static Predicate<Profiles> isMatch(Predicate<String> activeProfiles) {\r\n    return profiles -> profiles.matches(activeProfiles);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ParsedProfiles",
    "entityType": "class",
    "code": "private final Set<String> expressions = new LinkedHashSet<>();\nprivate final Profiles[] parsed;\nParsedProfiles(String[] expressions, Profiles[] parsed) {\r\n    Collections.addAll(this.expressions, expressions);\r\n    this.parsed = parsed;\r\n}\n@Override\r\npublic boolean matches(Predicate<String> activeProfiles) {\r\n    for (Profiles candidate : this.parsed) {\r\n        if (candidate.matches(activeProfiles)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof ParsedProfiles that && this.expressions.equals(that.expressions)));\r\n}\n@Override\r\npublic int hashCode() {\r\n    return this.expressions.hashCode();\r\n}\n@Override\r\npublic String toString() {\r\n    if (this.expressions.size() == 1) {\r\n        return this.expressions.iterator().next();\r\n    }\r\n    return this.expressions.stream().map(this::wrap).collect(Collectors.joining(\" | \"));\r\n}\nprivate String wrap(String str) {\r\n    return \"(\" + str + \")\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ParsedProfiles#matches(Predicate<String>)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean matches(Predicate<String> activeProfiles) {\r\n    for (Profiles candidate : this.parsed) {\r\n        if (candidate.matches(activeProfiles)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ParsedProfiles#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof ParsedProfiles that && this.expressions.equals(that.expressions)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ParsedProfiles#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return this.expressions.hashCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ParsedProfiles#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    if (this.expressions.size() == 1) {\r\n        return this.expressions.iterator().next();\r\n    }\r\n    return this.expressions.stream().map(this::wrap).collect(Collectors.joining(\" | \"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ParsedProfiles#wrap(String)",
    "entityType": "method",
    "code": "private String wrap(String str) {\r\n    return \"(\" + str + \")\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertiesPropertySource",
    "entityType": "class",
    "code": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\r\npublic PropertiesPropertySource(String name, Properties source) {\r\n    super(name, (Map) source);\r\n}\nprotected PropertiesPropertySource(String name, Map<String, Object> source) {\r\n    super(name, source);\r\n}\n@Override\r\npublic String[] getPropertyNames() {\r\n    synchronized (this.source) {\r\n        return ((Map<?, ?>) this.source).keySet().stream().filter(k -> k instanceof String).toArray(String[]::new);\r\n    }\r\n}",
    "comment": "\n * {@link PropertySource} implementation that extracts properties from a\n * {@link java.util.Properties} object.\n *\n * <p>Note that because a {@code Properties} object is technically an\n * {@code <Object, Object>} {@link java.util.Hashtable Hashtable}, one may contain\n * non-{@code String} keys or values. This implementation, however is restricted to\n * accessing only {@code String}-based keys and values, in the same fashion as\n * {@link Properties#getProperty} and {@link Properties#setProperty}.\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @since 3.1\n "
  },
  {
    "entityId": "org.springframework.core.env.PropertiesPropertySource#getPropertyNames()",
    "entityType": "method",
    "code": "@Override\r\npublic String[] getPropertyNames() {\r\n    synchronized (this.source) {\r\n        return ((Map<?, ?>) this.source).keySet().stream().filter(k -> k instanceof String).toArray(String[]::new);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertyResolver",
    "entityType": "class",
    "code": "/**\r\n * Return whether the given property key is available for resolution,\r\n * i.e. if the value for the given key is not {@code null}.\r\n */\r\nboolean containsProperty(String key);\n/**\r\n * Return the property value associated with the given key,\r\n * or {@code null} if the key cannot be resolved.\r\n * @param key the property name to resolve\r\n * @see #getProperty(String, String)\r\n * @see #getProperty(String, Class)\r\n * @see #getRequiredProperty(String)\r\n */\r\n@Nullable\r\nString getProperty(String key);\n/**\r\n * Return the property value associated with the given key, or\r\n * {@code defaultValue} if the key cannot be resolved.\r\n * @param key the property name to resolve\r\n * @param defaultValue the default value to return if no value is found\r\n * @see #getRequiredProperty(String)\r\n * @see #getProperty(String, Class)\r\n */\r\nString getProperty(String key, String defaultValue);\n/**\r\n * Return the property value associated with the given key,\r\n * or {@code null} if the key cannot be resolved.\r\n * @param key the property name to resolve\r\n * @param targetType the expected type of the property value\r\n * @see #getRequiredProperty(String, Class)\r\n */\r\n@Nullable\r\n<T> T getProperty(String key, Class<T> targetType);\n/**\r\n * Return the property value associated with the given key,\r\n * or {@code defaultValue} if the key cannot be resolved.\r\n * @param key the property name to resolve\r\n * @param targetType the expected type of the property value\r\n * @param defaultValue the default value to return if no value is found\r\n * @see #getRequiredProperty(String, Class)\r\n */\r\n<T> T getProperty(String key, Class<T> targetType, T defaultValue);\n/**\r\n * Return the property value associated with the given key (never {@code null}).\r\n * @throws IllegalStateException if the key cannot be resolved\r\n * @see #getRequiredProperty(String, Class)\r\n */\r\nString getRequiredProperty(String key) throws IllegalStateException;\n/**\r\n * Return the property value associated with the given key, converted to the given\r\n * targetType (never {@code null}).\r\n * @throws IllegalStateException if the given key cannot be resolved\r\n */\r\n<T> T getRequiredProperty(String key, Class<T> targetType) throws IllegalStateException;\n/**\r\n * Resolve ${...} placeholders in the given text, replacing them with corresponding\r\n * property values as resolved by {@link #getProperty}. Unresolvable placeholders with\r\n * no default value are ignored and passed through unchanged.\r\n * @param text the String to resolve\r\n * @return the resolved String (never {@code null})\r\n * @throws IllegalArgumentException if given text is {@code null}\r\n * @see #resolveRequiredPlaceholders\r\n */\r\nString resolvePlaceholders(String text);\n/**\r\n * Resolve ${...} placeholders in the given text, replacing them with corresponding\r\n * property values as resolved by {@link #getProperty}. Unresolvable placeholders with\r\n * no default value will cause an IllegalArgumentException to be thrown.\r\n * @return the resolved String (never {@code null})\r\n * @throws IllegalArgumentException if given text is {@code null}\r\n * or if any placeholders are unresolvable\r\n */\r\nString resolveRequiredPlaceholders(String text) throws IllegalArgumentException;",
    "comment": "\n * Interface for resolving properties against any underlying source.\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @since 3.1\n * @see Environment\n * @see PropertySourcesPropertyResolver\n "
  },
  {
    "entityId": "org.springframework.core.env.PropertyResolver#containsProperty(String)",
    "entityType": "method",
    "code": "/**\r\n * Return whether the given property key is available for resolution,\r\n * i.e. if the value for the given key is not {@code null}.\r\n */\r\nboolean containsProperty(String key);",
    "comment": "\n\t * Return whether the given property key is available for resolution,\n\t * i.e. if the value for the given key is not {@code null}.\n\t "
  }
]