[
  {
    "entityId": "org.springframework.core.env.PropertyResolver#getProperty(String)",
    "entityType": "method",
    "code": "/**\r\n * Return the property value associated with the given key,\r\n * or {@code null} if the key cannot be resolved.\r\n * @param key the property name to resolve\r\n * @see #getProperty(String, String)\r\n * @see #getProperty(String, Class)\r\n * @see #getRequiredProperty(String)\r\n */\r\n@Nullable\r\nString getProperty(String key);",
    "comment": "\n\t * Return the property value associated with the given key,\n\t * or {@code null} if the key cannot be resolved.\n\t * @param key the property name to resolve\n\t * @see #getProperty(String, String)\n\t * @see #getProperty(String, Class)\n\t * @see #getRequiredProperty(String)\n\t "
  },
  {
    "entityId": "org.springframework.core.env.PropertyResolver#getProperty(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Return the property value associated with the given key, or\r\n * {@code defaultValue} if the key cannot be resolved.\r\n * @param key the property name to resolve\r\n * @param defaultValue the default value to return if no value is found\r\n * @see #getRequiredProperty(String)\r\n * @see #getProperty(String, Class)\r\n */\r\nString getProperty(String key, String defaultValue);",
    "comment": "\n\t * Return the property value associated with the given key, or\n\t * {@code defaultValue} if the key cannot be resolved.\n\t * @param key the property name to resolve\n\t * @param defaultValue the default value to return if no value is found\n\t * @see #getRequiredProperty(String)\n\t * @see #getProperty(String, Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.env.PropertyResolver#getProperty(String,Class<T>)",
    "entityType": "method",
    "code": "/**\r\n * Return the property value associated with the given key,\r\n * or {@code null} if the key cannot be resolved.\r\n * @param key the property name to resolve\r\n * @param targetType the expected type of the property value\r\n * @see #getRequiredProperty(String, Class)\r\n */\r\n@Nullable\r\n<T> T getProperty(String key, Class<T> targetType);",
    "comment": "\n\t * Return the property value associated with the given key,\n\t * or {@code null} if the key cannot be resolved.\n\t * @param key the property name to resolve\n\t * @param targetType the expected type of the property value\n\t * @see #getRequiredProperty(String, Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.env.PropertyResolver#getProperty(String,Class<T>,T)",
    "entityType": "method",
    "code": "/**\r\n * Return the property value associated with the given key,\r\n * or {@code defaultValue} if the key cannot be resolved.\r\n * @param key the property name to resolve\r\n * @param targetType the expected type of the property value\r\n * @param defaultValue the default value to return if no value is found\r\n * @see #getRequiredProperty(String, Class)\r\n */\r\n<T> T getProperty(String key, Class<T> targetType, T defaultValue);",
    "comment": "\n\t * Return the property value associated with the given key,\n\t * or {@code defaultValue} if the key cannot be resolved.\n\t * @param key the property name to resolve\n\t * @param targetType the expected type of the property value\n\t * @param defaultValue the default value to return if no value is found\n\t * @see #getRequiredProperty(String, Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.env.PropertyResolver#getRequiredProperty(String)",
    "entityType": "method",
    "code": "/**\r\n * Return the property value associated with the given key (never {@code null}).\r\n * @throws IllegalStateException if the key cannot be resolved\r\n * @see #getRequiredProperty(String, Class)\r\n */\r\nString getRequiredProperty(String key) throws IllegalStateException;",
    "comment": "\n\t * Return the property value associated with the given key (never {@code null}).\n\t * @throws IllegalStateException if the key cannot be resolved\n\t * @see #getRequiredProperty(String, Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.env.PropertyResolver#getRequiredProperty(String,Class<T>)",
    "entityType": "method",
    "code": "/**\r\n * Return the property value associated with the given key, converted to the given\r\n * targetType (never {@code null}).\r\n * @throws IllegalStateException if the given key cannot be resolved\r\n */\r\n<T> T getRequiredProperty(String key, Class<T> targetType) throws IllegalStateException;",
    "comment": "\n\t * Return the property value associated with the given key, converted to the given\n\t * targetType (never {@code null}).\n\t * @throws IllegalStateException if the given key cannot be resolved\n\t "
  },
  {
    "entityId": "org.springframework.core.env.PropertyResolver#resolvePlaceholders(String)",
    "entityType": "method",
    "code": "/**\r\n * Resolve ${...} placeholders in the given text, replacing them with corresponding\r\n * property values as resolved by {@link #getProperty}. Unresolvable placeholders with\r\n * no default value are ignored and passed through unchanged.\r\n * @param text the String to resolve\r\n * @return the resolved String (never {@code null})\r\n * @throws IllegalArgumentException if given text is {@code null}\r\n * @see #resolveRequiredPlaceholders\r\n */\r\nString resolvePlaceholders(String text);",
    "comment": "\n\t * Resolve ${...} placeholders in the given text, replacing them with corresponding\n\t * property values as resolved by {@link #getProperty}. Unresolvable placeholders with\n\t * no default value are ignored and passed through unchanged.\n\t * @param text the String to resolve\n\t * @return the resolved String (never {@code null})\n\t * @throws IllegalArgumentException if given text is {@code null}\n\t * @see #resolveRequiredPlaceholders\n\t "
  },
  {
    "entityId": "org.springframework.core.env.PropertyResolver#resolveRequiredPlaceholders(String)",
    "entityType": "method",
    "code": "/**\r\n * Resolve ${...} placeholders in the given text, replacing them with corresponding\r\n * property values as resolved by {@link #getProperty}. Unresolvable placeholders with\r\n * no default value will cause an IllegalArgumentException to be thrown.\r\n * @return the resolved String (never {@code null})\r\n * @throws IllegalArgumentException if given text is {@code null}\r\n * or if any placeholders are unresolvable\r\n */\r\nString resolveRequiredPlaceholders(String text) throws IllegalArgumentException;",
    "comment": "\n\t * Resolve ${...} placeholders in the given text, replacing them with corresponding\n\t * property values as resolved by {@link #getProperty}. Unresolvable placeholders with\n\t * no default value will cause an IllegalArgumentException to be thrown.\n\t * @return the resolved String (never {@code null})\n\t * @throws IllegalArgumentException if given text is {@code null}\n\t * or if any placeholders are unresolvable\n\t "
  },
  {
    "entityId": "org.springframework.core.env.PropertySource",
    "entityType": "class",
    "code": "protected final Log logger = LogFactory.getLog(getClass());\nprotected final String name;\nprotected final T source;\n/**\r\n * Create a new {@code PropertySource} with the given name and source object.\r\n * @param name the associated name\r\n * @param source the source object\r\n */\r\npublic PropertySource(String name, T source) {\r\n    Assert.hasText(name, \"Property source name must contain at least one character\");\r\n    Assert.notNull(source, \"Property source must not be null\");\r\n    this.name = name;\r\n    this.source = source;\r\n}\n/**\r\n * Create a new {@code PropertySource} with the given name and with a new\r\n * {@code Object} instance as the underlying source.\r\n * <p>Often useful in testing scenarios when creating anonymous implementations\r\n * that never query an actual source but rather return hard-coded values.\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic PropertySource(String name) {\r\n    this(name, (T) new Object());\r\n}\n/**\r\n * Return the name of this {@code PropertySource}.\r\n * <p>See the {@linkplain PropertySource class-level Javadoc} for details\r\n * on property source identity and names.\r\n */\r\npublic String getName() {\r\n    return this.name;\r\n}\n/**\r\n * Return the underlying source object for this {@code PropertySource}.\r\n */\r\npublic T getSource() {\r\n    return this.source;\r\n}\n/**\r\n * Return whether this {@code PropertySource} contains the given name.\r\n * <p>This implementation simply checks for a {@code null} return value\r\n * from {@link #getProperty(String)}. Subclasses may wish to implement\r\n * a more efficient algorithm if possible.\r\n * @param name the property name to find\r\n */\r\npublic boolean containsProperty(String name) {\r\n    return (getProperty(name) != null);\r\n}\n/**\r\n * Return the value associated with the given name,\r\n * or {@code null} if not found.\r\n * @param name the property to find\r\n * @see PropertyResolver#getRequiredProperty(String)\r\n */\r\n@Nullable\r\npublic abstract Object getProperty(String name);\n/**\r\n * This {@code PropertySource} object is equal to the given object if:\r\n * <ul>\r\n * <li>they are the same instance\r\n * <li>the {@code name} properties for both objects are equal\r\n * </ul>\r\n * <p>No properties other than {@code name} are evaluated.\r\n */\r\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof PropertySource<?> that && ObjectUtils.nullSafeEquals(getName(), that.getName())));\r\n}\n/**\r\n * Return a hash code derived from the {@code name} property\r\n * of this {@code PropertySource} object.\r\n */\r\n@Override\r\npublic int hashCode() {\r\n    return Objects.hashCode(getName());\r\n}\n/**\r\n * Produce concise output (type and name) if the current log level does not include\r\n * debug. If debug is enabled, produce verbose output including the hash code of the\r\n * PropertySource instance and every name/value property pair.\r\n * <p>This variable verbosity is useful as a property source such as system properties\r\n * or environment variables may contain an arbitrary number of property pairs,\r\n * potentially leading to difficulties to read exception and log messages.\r\n * @see Log#isDebugEnabled()\r\n */\r\n@Override\r\npublic String toString() {\r\n    if (logger.isDebugEnabled()) {\r\n        return getClass().getSimpleName() + \"@\" + System.identityHashCode(this) + \" {name='\" + getName() + \"', properties=\" + getSource() + \"}\";\r\n    } else {\r\n        return getClass().getSimpleName() + \" {name='\" + getName() + \"'}\";\r\n    }\r\n}\n/**\r\n * Return a {@code PropertySource} implementation intended for collection\r\n * comparison purposes only.\r\n * <p>Primarily for internal use, but given a collection of {@code PropertySource}\r\n * objects, may be used as follows:\r\n * <pre class=\"code\">\r\n * List&lt;PropertySource&lt;?&gt;&gt; sources = new ArrayList&lt;&gt;();\r\n * sources.add(new MapPropertySource(\"sourceA\", mapA));\r\n * sources.add(new MapPropertySource(\"sourceB\", mapB));\r\n * assert sources.contains(PropertySource.named(\"sourceA\"));\r\n * assert sources.contains(PropertySource.named(\"sourceB\"));\r\n * assert !sources.contains(PropertySource.named(\"sourceC\"));</pre>\r\n * <p>The returned {@code PropertySource} will throw {@code UnsupportedOperationException}\r\n * if any methods other than {@code equals(Object)}, {@code hashCode()}, and {@code toString()}\r\n * are called.\r\n * @param name the name of the comparison {@code PropertySource} to be created\r\n * and returned\r\n */\r\npublic static PropertySource<?> named(String name) {\r\n    return new ComparisonPropertySource(name);\r\n}\n/**\r\n * {@code PropertySource} to be used as a placeholder in cases where an actual\r\n * property source cannot be eagerly initialized at application context\r\n * creation time.  For example, a {@code ServletContext}-based property source\r\n * must wait until the {@code ServletContext} object is available to its enclosing\r\n * {@code ApplicationContext}.  In such cases, a stub should be used to hold the\r\n * intended default position/order of the property source, then be replaced\r\n * during context refresh.\r\n * @see org.springframework.context.support.AbstractApplicationContext#initPropertySources()\r\n * @see org.springframework.web.context.support.StandardServletEnvironment\r\n * @see org.springframework.web.context.support.ServletContextPropertySource\r\n */\r\npublic static class StubPropertySource extends PropertySource<Object> {\r\n\r\n    public StubPropertySource(String name) {\r\n        super(name);\r\n    }\r\n\r\n    /**\r\n     * Always returns {@code null}.\r\n     */\r\n    @Override\r\n    @Nullable\r\n    public String getProperty(String name) {\r\n        return null;\r\n    }\r\n}\n/**\r\n * A {@code PropertySource} implementation intended for collection comparison\r\n * purposes.\r\n *\r\n * @see PropertySource#named(String)\r\n */\r\nstatic class ComparisonPropertySource extends StubPropertySource {\r\n\r\n    private static final String USAGE_ERROR = \"ComparisonPropertySource instances are for use with collection comparison only\";\r\n\r\n    public ComparisonPropertySource(String name) {\r\n        super(name);\r\n    }\r\n\r\n    @Override\r\n    public Object getSource() {\r\n        throw new UnsupportedOperationException(USAGE_ERROR);\r\n    }\r\n\r\n    @Override\r\n    public boolean containsProperty(String name) {\r\n        throw new UnsupportedOperationException(USAGE_ERROR);\r\n    }\r\n\r\n    @Override\r\n    @Nullable\r\n    public String getProperty(String name) {\r\n        throw new UnsupportedOperationException(USAGE_ERROR);\r\n    }\r\n}",
    "comment": "\n * Abstract base class representing a source of name/value property pairs. The underlying\n * {@linkplain #getSource() source object} may be of any type {@code T} that encapsulates\n * properties. Examples include {@link java.util.Properties} objects, {@link java.util.Map}\n * objects, {@code ServletContext} and {@code ServletConfig} objects (for access to init\n * parameters). Explore the {@code PropertySource} type hierarchy to see provided\n * implementations.\n *\n * <p>{@code PropertySource} objects are not typically used in isolation, but rather\n * through a {@link PropertySources} object, which aggregates property sources and in\n * conjunction with a {@link PropertyResolver} implementation that can perform\n * precedence-based searches across the set of {@code PropertySources}.\n *\n * <p>{@code PropertySource} identity is determined not based on the content of\n * encapsulated properties, but rather based on the {@link #getName() name} of the\n * {@code PropertySource} alone. This is useful for manipulating {@code PropertySource}\n * objects when in collection contexts. See operations in {@link MutablePropertySources}\n * as well as the {@link #named(String)} and {@link #toString()} methods for details.\n *\n * <p>Note that when working with @{@link\n * org.springframework.context.annotation.Configuration Configuration} classes that\n * the @{@link org.springframework.context.annotation.PropertySource PropertySource}\n * annotation provides a convenient and declarative way of adding property sources to the\n * enclosing {@code Environment}.\n *\n * @author Chris Beams\n * @since 3.1\n * @param <T> the source type\n * @see PropertySources\n * @see PropertyResolver\n * @see PropertySourcesPropertyResolver\n * @see MutablePropertySources\n * @see org.springframework.context.annotation.PropertySource\n "
  },
  {
    "entityId": "org.springframework.core.env.PropertySource#getName()",
    "entityType": "method",
    "code": "/**\r\n * Return the name of this {@code PropertySource}.\r\n * <p>See the {@linkplain PropertySource class-level Javadoc} for details\r\n * on property source identity and names.\r\n */\r\npublic String getName() {\r\n    return this.name;\r\n}",
    "comment": "\n\t * Return the name of this {@code PropertySource}.\n\t * <p>See the {@linkplain PropertySource class-level Javadoc} for details\n\t * on property source identity and names.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.PropertySource#getSource()",
    "entityType": "method",
    "code": "/**\r\n * Return the underlying source object for this {@code PropertySource}.\r\n */\r\npublic T getSource() {\r\n    return this.source;\r\n}",
    "comment": "\n\t * Return the underlying source object for this {@code PropertySource}.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.PropertySource#containsProperty(String)",
    "entityType": "method",
    "code": "/**\r\n * Return whether this {@code PropertySource} contains the given name.\r\n * <p>This implementation simply checks for a {@code null} return value\r\n * from {@link #getProperty(String)}. Subclasses may wish to implement\r\n * a more efficient algorithm if possible.\r\n * @param name the property name to find\r\n */\r\npublic boolean containsProperty(String name) {\r\n    return (getProperty(name) != null);\r\n}",
    "comment": "\n\t * Return whether this {@code PropertySource} contains the given name.\n\t * <p>This implementation simply checks for a {@code null} return value\n\t * from {@link #getProperty(String)}. Subclasses may wish to implement\n\t * a more efficient algorithm if possible.\n\t * @param name the property name to find\n\t "
  },
  {
    "entityId": "org.springframework.core.env.PropertySource#getProperty(String)",
    "entityType": "method",
    "code": "/**\r\n * Return the value associated with the given name,\r\n * or {@code null} if not found.\r\n * @param name the property to find\r\n * @see PropertyResolver#getRequiredProperty(String)\r\n */\r\n@Nullable\r\npublic abstract Object getProperty(String name);",
    "comment": "\n\t * Return the value associated with the given name,\n\t * or {@code null} if not found.\n\t * @param name the property to find\n\t * @see PropertyResolver#getRequiredProperty(String)\n\t "
  },
  {
    "entityId": "org.springframework.core.env.PropertySource#equals(Object)",
    "entityType": "method",
    "code": "/**\r\n * This {@code PropertySource} object is equal to the given object if:\r\n * <ul>\r\n * <li>they are the same instance\r\n * <li>the {@code name} properties for both objects are equal\r\n * </ul>\r\n * <p>No properties other than {@code name} are evaluated.\r\n */\r\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof PropertySource<?> that && ObjectUtils.nullSafeEquals(getName(), that.getName())));\r\n}",
    "comment": "\n\t * This {@code PropertySource} object is equal to the given object if:\n\t * <ul>\n\t * <li>they are the same instance\n\t * <li>the {@code name} properties for both objects are equal\n\t * </ul>\n\t * <p>No properties other than {@code name} are evaluated.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.PropertySource#hashCode()",
    "entityType": "method",
    "code": "/**\r\n * Return a hash code derived from the {@code name} property\r\n * of this {@code PropertySource} object.\r\n */\r\n@Override\r\npublic int hashCode() {\r\n    return Objects.hashCode(getName());\r\n}",
    "comment": "\n\t * Return a hash code derived from the {@code name} property\n\t * of this {@code PropertySource} object.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.PropertySource#toString()",
    "entityType": "method",
    "code": "/**\r\n * Produce concise output (type and name) if the current log level does not include\r\n * debug. If debug is enabled, produce verbose output including the hash code of the\r\n * PropertySource instance and every name/value property pair.\r\n * <p>This variable verbosity is useful as a property source such as system properties\r\n * or environment variables may contain an arbitrary number of property pairs,\r\n * potentially leading to difficulties to read exception and log messages.\r\n * @see Log#isDebugEnabled()\r\n */\r\n@Override\r\npublic String toString() {\r\n    if (logger.isDebugEnabled()) {\r\n        return getClass().getSimpleName() + \"@\" + System.identityHashCode(this) + \" {name='\" + getName() + \"', properties=\" + getSource() + \"}\";\r\n    } else {\r\n        return getClass().getSimpleName() + \" {name='\" + getName() + \"'}\";\r\n    }\r\n}",
    "comment": "\n\t * Produce concise output (type and name) if the current log level does not include\n\t * debug. If debug is enabled, produce verbose output including the hash code of the\n\t * PropertySource instance and every name/value property pair.\n\t * <p>This variable verbosity is useful as a property source such as system properties\n\t * or environment variables may contain an arbitrary number of property pairs,\n\t * potentially leading to difficulties to read exception and log messages.\n\t * @see Log#isDebugEnabled()\n\t "
  },
  {
    "entityId": "org.springframework.core.env.PropertySource#named(String)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code PropertySource} implementation intended for collection\r\n * comparison purposes only.\r\n * <p>Primarily for internal use, but given a collection of {@code PropertySource}\r\n * objects, may be used as follows:\r\n * <pre class=\"code\">\r\n * List&lt;PropertySource&lt;?&gt;&gt; sources = new ArrayList&lt;&gt;();\r\n * sources.add(new MapPropertySource(\"sourceA\", mapA));\r\n * sources.add(new MapPropertySource(\"sourceB\", mapB));\r\n * assert sources.contains(PropertySource.named(\"sourceA\"));\r\n * assert sources.contains(PropertySource.named(\"sourceB\"));\r\n * assert !sources.contains(PropertySource.named(\"sourceC\"));</pre>\r\n * <p>The returned {@code PropertySource} will throw {@code UnsupportedOperationException}\r\n * if any methods other than {@code equals(Object)}, {@code hashCode()}, and {@code toString()}\r\n * are called.\r\n * @param name the name of the comparison {@code PropertySource} to be created\r\n * and returned\r\n */\r\npublic static PropertySource<?> named(String name) {\r\n    return new ComparisonPropertySource(name);\r\n}",
    "comment": "\n\t * Return a {@code PropertySource} implementation intended for collection\n\t * comparison purposes only.\n\t * <p>Primarily for internal use, but given a collection of {@code PropertySource}\n\t * objects, may be used as follows:\n\t * <pre class=\"code\">\n\t * List&lt;PropertySource&lt;?&gt;&gt; sources = new ArrayList&lt;&gt;();\n\t * sources.add(new MapPropertySource(\"sourceA\", mapA));\n\t * sources.add(new MapPropertySource(\"sourceB\", mapB));\n\t * assert sources.contains(PropertySource.named(\"sourceA\"));\n\t * assert sources.contains(PropertySource.named(\"sourceB\"));\n\t * assert !sources.contains(PropertySource.named(\"sourceC\"));</pre>\n\t * <p>The returned {@code PropertySource} will throw {@code UnsupportedOperationException}\n\t * if any methods other than {@code equals(Object)}, {@code hashCode()}, and {@code toString()}\n\t * are called.\n\t * @param name the name of the comparison {@code PropertySource} to be created\n\t * and returned\n\t "
  },
  {
    "entityId": "org.springframework.core.env.StubPropertySource",
    "entityType": "class",
    "code": "public StubPropertySource(String name) {\r\n    super(name);\r\n}\n/**\r\n * Always returns {@code null}.\r\n */\r\n@Override\r\n@Nullable\r\npublic String getProperty(String name) {\r\n    return null;\r\n}",
    "comment": "\n\t * {@code PropertySource} to be used as a placeholder in cases where an actual\n\t * property source cannot be eagerly initialized at application context\n\t * creation time.  For example, a {@code ServletContext}-based property source\n\t * must wait until the {@code ServletContext} object is available to its enclosing\n\t * {@code ApplicationContext}.  In such cases, a stub should be used to hold the\n\t * intended default position/order of the property source, then be replaced\n\t * during context refresh.\n\t * @see org.springframework.context.support.AbstractApplicationContext#initPropertySources()\n\t * @see org.springframework.web.context.support.StandardServletEnvironment\n\t * @see org.springframework.web.context.support.ServletContextPropertySource\n\t "
  },
  {
    "entityId": "org.springframework.core.env.StubPropertySource#getProperty(String)",
    "entityType": "method",
    "code": "/**\r\n * Always returns {@code null}.\r\n */\r\n@Override\r\n@Nullable\r\npublic String getProperty(String name) {\r\n    return null;\r\n}",
    "comment": "\n\t\t * Always returns {@code null}.\n\t\t "
  },
  {
    "entityId": "org.springframework.core.env.ComparisonPropertySource",
    "entityType": "class",
    "code": "private static final String USAGE_ERROR = \"ComparisonPropertySource instances are for use with collection comparison only\";\npublic ComparisonPropertySource(String name) {\r\n    super(name);\r\n}\n@Override\r\npublic Object getSource() {\r\n    throw new UnsupportedOperationException(USAGE_ERROR);\r\n}\n@Override\r\npublic boolean containsProperty(String name) {\r\n    throw new UnsupportedOperationException(USAGE_ERROR);\r\n}\n@Override\r\n@Nullable\r\npublic String getProperty(String name) {\r\n    throw new UnsupportedOperationException(USAGE_ERROR);\r\n}",
    "comment": "\n\t * A {@code PropertySource} implementation intended for collection comparison\n\t * purposes.\n\t *\n\t * @see PropertySource#named(String)\n\t "
  },
  {
    "entityId": "org.springframework.core.env.ComparisonPropertySource#getSource()",
    "entityType": "method",
    "code": "@Override\r\npublic Object getSource() {\r\n    throw new UnsupportedOperationException(USAGE_ERROR);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ComparisonPropertySource#containsProperty(String)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean containsProperty(String name) {\r\n    throw new UnsupportedOperationException(USAGE_ERROR);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ComparisonPropertySource#getProperty(String)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic String getProperty(String name) {\r\n    throw new UnsupportedOperationException(USAGE_ERROR);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySources",
    "entityType": "class",
    "code": "/**\r\n * Return a sequential {@link Stream} containing the property sources.\r\n * @since 5.1\r\n */\r\ndefault Stream<PropertySource<?>> stream() {\r\n    return StreamSupport.stream(spliterator(), false);\r\n}\n/**\r\n * Return whether a property source with the given name is contained.\r\n * @param name the {@linkplain PropertySource#getName() name of the property source} to find\r\n */\r\nboolean contains(String name);\n/**\r\n * Return the property source with the given name, {@code null} if not found.\r\n * @param name the {@linkplain PropertySource#getName() name of the property source} to find\r\n */\r\n@Nullable\r\nPropertySource<?> get(String name);",
    "comment": "\n * Holder containing one or more {@link PropertySource} objects.\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @since 3.1\n * @see PropertySource\n "
  },
  {
    "entityId": "org.springframework.core.env.PropertySources#stream()",
    "entityType": "method",
    "code": "/**\r\n * Return a sequential {@link Stream} containing the property sources.\r\n * @since 5.1\r\n */\r\ndefault Stream<PropertySource<?>> stream() {\r\n    return StreamSupport.stream(spliterator(), false);\r\n}",
    "comment": "\n\t * Return a sequential {@link Stream} containing the property sources.\n\t * @since 5.1\n\t "
  },
  {
    "entityId": "org.springframework.core.env.PropertySources#contains(String)",
    "entityType": "method",
    "code": "/**\r\n * Return whether a property source with the given name is contained.\r\n * @param name the {@linkplain PropertySource#getName() name of the property source} to find\r\n */\r\nboolean contains(String name);",
    "comment": "\n\t * Return whether a property source with the given name is contained.\n\t * @param name the {@linkplain PropertySource#getName() name of the property source} to find\n\t "
  },
  {
    "entityId": "org.springframework.core.env.PropertySources#get(String)",
    "entityType": "method",
    "code": "/**\r\n * Return the property source with the given name, {@code null} if not found.\r\n * @param name the {@linkplain PropertySource#getName() name of the property source} to find\r\n */\r\n@Nullable\r\nPropertySource<?> get(String name);",
    "comment": "\n\t * Return the property source with the given name, {@code null} if not found.\n\t * @param name the {@linkplain PropertySource#getName() name of the property source} to find\n\t "
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolver",
    "entityType": "class",
    "code": "@Nullable\r\nprivate final PropertySources propertySources;\n/**\r\n * Create a new resolver against the given property sources.\r\n * @param propertySources the set of {@link PropertySource} objects to use\r\n */\r\npublic PropertySourcesPropertyResolver(@Nullable PropertySources propertySources) {\r\n    this.propertySources = propertySources;\r\n}\n@Override\r\npublic boolean containsProperty(String key) {\r\n    if (this.propertySources != null) {\r\n        for (PropertySource<?> propertySource : this.propertySources) {\r\n            if (propertySource.containsProperty(key)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\n@Override\r\n@Nullable\r\npublic String getProperty(String key) {\r\n    return getProperty(key, String.class, true);\r\n}\n@Override\r\n@Nullable\r\npublic <T> T getProperty(String key, Class<T> targetValueType) {\r\n    return getProperty(key, targetValueType, true);\r\n}\n@Override\r\n@Nullable\r\nprotected String getPropertyAsRawString(String key) {\r\n    return getProperty(key, String.class, false);\r\n}\n@Nullable\r\nprotected <T> T getProperty(String key, Class<T> targetValueType, boolean resolveNestedPlaceholders) {\r\n    if (this.propertySources != null) {\r\n        for (PropertySource<?> propertySource : this.propertySources) {\r\n            if (logger.isTraceEnabled()) {\r\n                logger.trace(\"Searching for key '\" + key + \"' in PropertySource '\" + propertySource.getName() + \"'\");\r\n            }\r\n            Object value = propertySource.getProperty(key);\r\n            if (value != null) {\r\n                if (resolveNestedPlaceholders) {\r\n                    if (value instanceof String string) {\r\n                        value = resolveNestedPlaceholders(string);\r\n                    } else if ((value instanceof CharSequence cs) && (String.class.equals(targetValueType) || CharSequence.class.equals(targetValueType))) {\r\n                        value = resolveNestedPlaceholders(cs.toString());\r\n                    }\r\n                }\r\n                logKeyFound(key, propertySource, value);\r\n                return convertValueIfNecessary(value, targetValueType);\r\n            }\r\n        }\r\n    }\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(\"Could not find key '\" + key + \"' in any property source\");\r\n    }\r\n    return null;\r\n}\n/**\r\n * Log the given key as found in the given {@link PropertySource}, resulting in\r\n * the given value.\r\n * <p>The default implementation writes a debug log message with key and source.\r\n * As of 4.3.3, this does not log the value anymore in order to avoid accidental\r\n * logging of sensitive settings. Subclasses may override this method to change\r\n * the log level and/or log message, including the property's value if desired.\r\n * @param key the key found\r\n * @param propertySource the {@code PropertySource} that the key has been found in\r\n * @param value the corresponding value\r\n * @since 4.3.1\r\n */\r\nprotected void logKeyFound(String key, PropertySource<?> propertySource, Object value) {\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(\"Found key '\" + key + \"' in PropertySource '\" + propertySource.getName() + \"' with value of type \" + value.getClass().getSimpleName());\r\n    }\r\n}",
    "comment": "\n * {@link PropertyResolver} implementation that resolves property values against\n * an underlying set of {@link PropertySources}.\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @since 3.1\n * @see PropertySource\n * @see PropertySources\n * @see AbstractEnvironment\n "
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolver#containsProperty(String)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean containsProperty(String key) {\r\n    if (this.propertySources != null) {\r\n        for (PropertySource<?> propertySource : this.propertySources) {\r\n            if (propertySource.containsProperty(key)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolver#getProperty(String)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic String getProperty(String key) {\r\n    return getProperty(key, String.class, true);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolver#getProperty(String,Class<T>)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic <T> T getProperty(String key, Class<T> targetValueType) {\r\n    return getProperty(key, targetValueType, true);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolver#getPropertyAsRawString(String)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\nprotected String getPropertyAsRawString(String key) {\r\n    return getProperty(key, String.class, false);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolver#getProperty(String,Class<T>,boolean)",
    "entityType": "method",
    "code": "@Nullable\r\nprotected <T> T getProperty(String key, Class<T> targetValueType, boolean resolveNestedPlaceholders) {\r\n    if (this.propertySources != null) {\r\n        for (PropertySource<?> propertySource : this.propertySources) {\r\n            if (logger.isTraceEnabled()) {\r\n                logger.trace(\"Searching for key '\" + key + \"' in PropertySource '\" + propertySource.getName() + \"'\");\r\n            }\r\n            Object value = propertySource.getProperty(key);\r\n            if (value != null) {\r\n                if (resolveNestedPlaceholders) {\r\n                    if (value instanceof String string) {\r\n                        value = resolveNestedPlaceholders(string);\r\n                    } else if ((value instanceof CharSequence cs) && (String.class.equals(targetValueType) || CharSequence.class.equals(targetValueType))) {\r\n                        value = resolveNestedPlaceholders(cs.toString());\r\n                    }\r\n                }\r\n                logKeyFound(key, propertySource, value);\r\n                return convertValueIfNecessary(value, targetValueType);\r\n            }\r\n        }\r\n    }\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(\"Could not find key '\" + key + \"' in any property source\");\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolver#logKeyFound(String,PropertySource<?>,Object)",
    "entityType": "method",
    "code": "/**\r\n * Log the given key as found in the given {@link PropertySource}, resulting in\r\n * the given value.\r\n * <p>The default implementation writes a debug log message with key and source.\r\n * As of 4.3.3, this does not log the value anymore in order to avoid accidental\r\n * logging of sensitive settings. Subclasses may override this method to change\r\n * the log level and/or log message, including the property's value if desired.\r\n * @param key the key found\r\n * @param propertySource the {@code PropertySource} that the key has been found in\r\n * @param value the corresponding value\r\n * @since 4.3.1\r\n */\r\nprotected void logKeyFound(String key, PropertySource<?> propertySource, Object value) {\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(\"Found key '\" + key + \"' in PropertySource '\" + propertySource.getName() + \"' with value of type \" + value.getClass().getSimpleName());\r\n    }\r\n}",
    "comment": "\n\t * Log the given key as found in the given {@link PropertySource}, resulting in\n\t * the given value.\n\t * <p>The default implementation writes a debug log message with key and source.\n\t * As of 4.3.3, this does not log the value anymore in order to avoid accidental\n\t * logging of sensitive settings. Subclasses may override this method to change\n\t * the log level and/or log message, including the property's value if desired.\n\t * @param key the key found\n\t * @param propertySource the {@code PropertySource} that the key has been found in\n\t * @param value the corresponding value\n\t * @since 4.3.1\n\t "
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLineArgsParser",
    "entityType": "class",
    "code": "/**\r\n * Parse the given {@code String} array based on the rules described {@linkplain\r\n * SimpleCommandLineArgsParser above}, returning a fully-populated\r\n * {@link CommandLineArgs} object.\r\n * @param args command line arguments, typically from a {@code main()} method\r\n */\r\npublic CommandLineArgs parse(String... args) {\r\n    CommandLineArgs commandLineArgs = new CommandLineArgs();\r\n    boolean endOfOptions = false;\r\n    for (String arg : args) {\r\n        if (!endOfOptions && arg.startsWith(\"--\")) {\r\n            String optionText = arg.substring(2);\r\n            int indexOfEqualsSign = optionText.indexOf('=');\r\n            if (indexOfEqualsSign > -1) {\r\n                String optionName = optionText.substring(0, indexOfEqualsSign);\r\n                String optionValue = optionText.substring(indexOfEqualsSign + 1);\r\n                if (optionName.isEmpty()) {\r\n                    throw new IllegalArgumentException(\"Invalid argument syntax: \" + arg);\r\n                }\r\n                commandLineArgs.addOptionArg(optionName, optionValue);\r\n            } else if (!optionText.isEmpty()) {\r\n                commandLineArgs.addOptionArg(optionText, null);\r\n            } else {\r\n                // '--' End of options delimiter, all remaining args are non-option arguments\r\n                endOfOptions = true;\r\n            }\r\n        } else {\r\n            commandLineArgs.addNonOptionArg(arg);\r\n        }\r\n    }\r\n    return commandLineArgs;\r\n}",
    "comment": "\n * Parses a {@code String[]} of command line arguments in order to populate a\n * {@link CommandLineArgs} object.\n *\n * <h3>Working with option arguments</h3>\n * <p>Option arguments must adhere to the exact syntax:\n *\n * <pre class=\"code\">--optName[=optValue]</pre>\n *\n * <p>That is, options must be prefixed with \"{@code --}\" and may or may not\n * specify a value. If a value is specified, the name and value must be separated\n * <em>without spaces</em> by an equals sign (\"=\"). The value may optionally be\n * an empty string. If an option is present multiple times with different values\n * &mdash; for example, {@code --foo=bar --foo=baz} &mdash; all supplied values\n * will be stored for the option.\n *\n * <h4>Valid examples of option arguments</h4>\n * <pre class=\"code\">\n * --foo\n * --foo=\n * --foo=\"\"\n * --foo=bar\n * --foo=\"bar then baz\"\n * --foo=bar,baz,biz\n * --foo=bar --foo=baz --foo=biz</pre>\n *\n * <h4>Invalid examples of option arguments</h4>\n * <pre class=\"code\">\n * -foo\n * --foo bar\n * --foo = bar</pre>\n *\n * <h3>End of option arguments</h3>\n * <p>This parser supports the POSIX \"end of options\" delimiter, meaning that any\n * {@code \"--\"} (empty option name) in the command line signals that all remaining\n * arguments are non-option arguments. For example, {@code \"--opt1=ignored\"},\n * {@code \"--opt2\"}, and {@code \"filename\"} in the following command line are\n * considered non-option arguments.\n * <pre class=\"code\">\n * --foo=bar -- --opt1=ignored -opt2 filename</pre>\n *\n * <h3>Working with non-option arguments</h3>\n * <p>Any arguments following the \"end of options\" delimiter ({@code --}) or\n * specified without the \"{@code --}\" option prefix will be considered as\n * \"non-option arguments\" and made available through the\n * {@link CommandLineArgs#getNonOptionArgs()} method.\n *\n * @author Chris Beams\n * @author Sam Brannen\n * @author Brian Clozel\n * @since 3.1\n * @see SimpleCommandLinePropertySource\n "
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLineArgsParser#parse(String)",
    "entityType": "method",
    "code": "/**\r\n * Parse the given {@code String} array based on the rules described {@linkplain\r\n * SimpleCommandLineArgsParser above}, returning a fully-populated\r\n * {@link CommandLineArgs} object.\r\n * @param args command line arguments, typically from a {@code main()} method\r\n */\r\npublic CommandLineArgs parse(String... args) {\r\n    CommandLineArgs commandLineArgs = new CommandLineArgs();\r\n    boolean endOfOptions = false;\r\n    for (String arg : args) {\r\n        if (!endOfOptions && arg.startsWith(\"--\")) {\r\n            String optionText = arg.substring(2);\r\n            int indexOfEqualsSign = optionText.indexOf('=');\r\n            if (indexOfEqualsSign > -1) {\r\n                String optionName = optionText.substring(0, indexOfEqualsSign);\r\n                String optionValue = optionText.substring(indexOfEqualsSign + 1);\r\n                if (optionName.isEmpty()) {\r\n                    throw new IllegalArgumentException(\"Invalid argument syntax: \" + arg);\r\n                }\r\n                commandLineArgs.addOptionArg(optionName, optionValue);\r\n            } else if (!optionText.isEmpty()) {\r\n                commandLineArgs.addOptionArg(optionText, null);\r\n            } else {\r\n                // '--' End of options delimiter, all remaining args are non-option arguments\r\n                endOfOptions = true;\r\n            }\r\n        } else {\r\n            commandLineArgs.addNonOptionArg(arg);\r\n        }\r\n    }\r\n    return commandLineArgs;\r\n}",
    "comment": "\n\t * Parse the given {@code String} array based on the rules described {@linkplain\n\t * SimpleCommandLineArgsParser above}, returning a fully-populated\n\t * {@link CommandLineArgs} object.\n\t * @param args command line arguments, typically from a {@code main()} method\n\t "
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLinePropertySource",
    "entityType": "class",
    "code": "/**\r\n * Create a new {@code SimpleCommandLinePropertySource} having the default name\r\n * and backed by the given {@code String[]} of command line arguments.\r\n * @see CommandLinePropertySource#COMMAND_LINE_PROPERTY_SOURCE_NAME\r\n * @see CommandLinePropertySource#CommandLinePropertySource(Object)\r\n */\r\npublic SimpleCommandLinePropertySource(String... args) {\r\n    super(new SimpleCommandLineArgsParser().parse(args));\r\n}\n/**\r\n * Create a new {@code SimpleCommandLinePropertySource} having the given name\r\n * and backed by the given {@code String[]} of command line arguments.\r\n */\r\npublic SimpleCommandLinePropertySource(String name, String[] args) {\r\n    super(name, new SimpleCommandLineArgsParser().parse(args));\r\n}\n/**\r\n * Get the property names for the option arguments.\r\n */\r\n@Override\r\npublic String[] getPropertyNames() {\r\n    return StringUtils.toStringArray(this.source.getOptionNames());\r\n}\n@Override\r\nprotected boolean containsOption(String name) {\r\n    return this.source.containsOption(name);\r\n}\n@Override\r\n@Nullable\r\nprotected List<String> getOptionValues(String name) {\r\n    return this.source.getOptionValues(name);\r\n}\n@Override\r\nprotected List<String> getNonOptionArgs() {\r\n    return this.source.getNonOptionArgs();\r\n}",
    "comment": "\n * {@link CommandLinePropertySource} implementation backed by an instance of\n * {@link CommandLineArgs}.\n *\n * <h3>Purpose</h3>\n * <p>This {@code CommandLinePropertySource} implementation aims to provide the simplest\n * possible approach to parsing command line arguments. As with all {@code\n * CommandLinePropertySource} implementations, command line arguments are broken into two\n * distinct groups: <em>option arguments</em> and <em>non-option arguments</em>, as\n * described below <em>(some sections copied from Javadoc for\n * {@link SimpleCommandLineArgsParser})</em>:\n *\n * <h3>Working with option arguments</h3>\n * <p>Option arguments must adhere to the exact syntax:\n *\n * <pre class=\"code\">--optName[=optValue]</pre>\n *\n * <p>That is, options must be prefixed with \"{@code --}\" and may or may not\n * specify a value. If a value is specified, the name and value must be separated\n * <em>without spaces</em> by an equals sign (\"=\"). The value may optionally be\n * an empty string. If an option is present multiple times with different values\n * &mdash; for example, {@code --foo=bar --foo=baz} &mdash; all supplied values\n * will be stored for the option.\n *\n * <h4>Valid examples of option arguments</h4>\n * <pre class=\"code\">\n * --foo\n * --foo=\n * --foo=\"\"\n * --foo=bar\n * --foo=\"bar then baz\"\n * --foo=bar,baz,biz\n * --foo=bar --foo=baz --foo=biz</pre>\n *\n * <h4>Invalid examples of option arguments</h4>\n * <pre class=\"code\">\n * -foo\n * --foo bar\n * --foo = bar</pre>\n *\n * <h3>End of option arguments</h3>\n * <p>The underlying parser supports the POSIX \"end of options\" delimiter, meaning\n * that any {@code \"--\"} (empty option name) in the command line signals that all\n * remaining arguments are non-option arguments. For example, {@code \"--opt1=ignored\"},\n * {@code \"--opt2\"}, and {@code \"filename\"} in the following command line are\n * considered non-option arguments.\n * <pre class=\"code\">\n * --foo=bar -- --opt1=ignored -opt2 filename</pre>\n *\n * <h3>Working with non-option arguments</h3>\n * <p>Any arguments following the \"end of options\" delimiter ({@code --}) or\n * specified without the \"{@code --}\" option prefix will be considered as\n * \"non-option arguments\" and made available through the\n * {@link CommandLineArgs#getNonOptionArgs()} method.\n *\n * <h3>Typical usage</h3>\n * <pre class=\"code\">\n * public static void main(String[] args) {\n *     PropertySource&lt;?&gt; ps = new SimpleCommandLinePropertySource(args);\n *     // ...\n * }</pre>\n *\n * See {@link CommandLinePropertySource} for complete general usage examples.\n *\n * <h3>Beyond the basics</h3>\n *\n * <p>When more fully-featured command line parsing is necessary, consider\n * implementing your own {@code CommandLinePropertySource} against the command line\n * parsing library of your choice.\n *\n * @author Chris Beams\n * @since 3.1\n * @see CommandLinePropertySource\n "
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLinePropertySource#getPropertyNames()",
    "entityType": "method",
    "code": "/**\r\n * Get the property names for the option arguments.\r\n */\r\n@Override\r\npublic String[] getPropertyNames() {\r\n    return StringUtils.toStringArray(this.source.getOptionNames());\r\n}",
    "comment": "\n\t * Get the property names for the option arguments.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLinePropertySource#containsOption(String)",
    "entityType": "method",
    "code": "@Override\r\nprotected boolean containsOption(String name) {\r\n    return this.source.containsOption(name);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLinePropertySource#getOptionValues(String)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\nprotected List<String> getOptionValues(String name) {\r\n    return this.source.getOptionValues(name);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLinePropertySource#getNonOptionArgs()",
    "entityType": "method",
    "code": "@Override\r\nprotected List<String> getNonOptionArgs() {\r\n    return this.source.getNonOptionArgs();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.StandardEnvironment",
    "entityType": "class",
    "code": "/**\r\n * System environment property source name: {@value}.\r\n */\r\npublic static final String SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME = \"systemEnvironment\";\n/**\r\n * JVM system properties property source name: {@value}.\r\n */\r\npublic static final String SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME = \"systemProperties\";\n/**\r\n * Create a new {@code StandardEnvironment} instance with a default\r\n * {@link MutablePropertySources} instance.\r\n */\r\npublic StandardEnvironment() {\r\n}\n/**\r\n * Create a new {@code StandardEnvironment} instance with a specific\r\n * {@link MutablePropertySources} instance.\r\n * @param propertySources property sources to use\r\n * @since 5.3.4\r\n */\r\nprotected StandardEnvironment(MutablePropertySources propertySources) {\r\n    super(propertySources);\r\n}\n/**\r\n * Customize the set of property sources with those appropriate for any standard\r\n * Java environment:\r\n * <ul>\r\n * <li>{@value #SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME}\r\n * <li>{@value #SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME}\r\n * </ul>\r\n * <p>Properties present in {@value #SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME} will\r\n * take precedence over those in {@value #SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME}.\r\n * @see AbstractEnvironment#customizePropertySources(MutablePropertySources)\r\n * @see #getSystemProperties()\r\n * @see #getSystemEnvironment()\r\n */\r\n@Override\r\nprotected void customizePropertySources(MutablePropertySources propertySources) {\r\n    propertySources.addLast(new PropertiesPropertySource(SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, getSystemProperties()));\r\n    propertySources.addLast(new SystemEnvironmentPropertySource(SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, getSystemEnvironment()));\r\n}",
    "comment": "\n * {@link Environment} implementation suitable for use in 'standard' (i.e. non-web)\n * applications.\n *\n * <p>In addition to the usual functions of a {@link ConfigurableEnvironment} such as\n * property resolution and profile-related operations, this implementation configures two\n * default property sources, to be searched in the following order:\n * <ul>\n * <li>{@linkplain AbstractEnvironment#getSystemProperties() system properties}\n * <li>{@linkplain AbstractEnvironment#getSystemEnvironment() system environment variables}\n * </ul>\n *\n * That is, if the key \"xyz\" is present both in the JVM system properties as well as in\n * the set of environment variables for the current process, the value of key \"xyz\" from\n * system properties will return from a call to {@code environment.getProperty(\"xyz\")}.\n * This ordering is chosen by default because system properties are per-JVM, while\n * environment variables may be the same across many JVMs on a given system.  Giving\n * system properties precedence allows for overriding of environment variables on a\n * per-JVM basis.\n *\n * <p>These default property sources may be removed, reordered, or replaced; and\n * additional property sources may be added using the {@link MutablePropertySources}\n * instance available from {@link #getPropertySources()}. See\n * {@link ConfigurableEnvironment} Javadoc for usage examples.\n *\n * <p>See {@link SystemEnvironmentPropertySource} javadoc for details on special handling\n * of property names in shell environments (for example, Bash) that disallow period characters in\n * variable names.\n *\n * @author Chris Beams\n * @author Phillip Webb\n * @since 3.1\n * @see ConfigurableEnvironment\n * @see SystemEnvironmentPropertySource\n * @see org.springframework.web.context.support.StandardServletEnvironment\n "
  },
  {
    "entityId": "org.springframework.core.env.StandardEnvironment#customizePropertySources(MutablePropertySources)",
    "entityType": "method",
    "code": "/**\r\n * Customize the set of property sources with those appropriate for any standard\r\n * Java environment:\r\n * <ul>\r\n * <li>{@value #SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME}\r\n * <li>{@value #SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME}\r\n * </ul>\r\n * <p>Properties present in {@value #SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME} will\r\n * take precedence over those in {@value #SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME}.\r\n * @see AbstractEnvironment#customizePropertySources(MutablePropertySources)\r\n * @see #getSystemProperties()\r\n * @see #getSystemEnvironment()\r\n */\r\n@Override\r\nprotected void customizePropertySources(MutablePropertySources propertySources) {\r\n    propertySources.addLast(new PropertiesPropertySource(SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, getSystemProperties()));\r\n    propertySources.addLast(new SystemEnvironmentPropertySource(SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, getSystemEnvironment()));\r\n}",
    "comment": "\n\t * Customize the set of property sources with those appropriate for any standard\n\t * Java environment:\n\t * <ul>\n\t * <li>{@value #SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME}\n\t * <li>{@value #SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME}\n\t * </ul>\n\t * <p>Properties present in {@value #SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME} will\n\t * take precedence over those in {@value #SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME}.\n\t * @see AbstractEnvironment#customizePropertySources(MutablePropertySources)\n\t * @see #getSystemProperties()\n\t * @see #getSystemEnvironment()\n\t "
  },
  {
    "entityId": "org.springframework.core.env.SystemEnvironmentPropertySource",
    "entityType": "class",
    "code": "/**\r\n * Create a new {@code SystemEnvironmentPropertySource} with the given name and\r\n * delegating to the given {@code MapPropertySource}.\r\n */\r\npublic SystemEnvironmentPropertySource(String name, Map<String, Object> source) {\r\n    super(name, source);\r\n}\n/**\r\n * Return {@code true} if a property with the given name or any underscore/uppercase variant\r\n * thereof exists in this property source.\r\n */\r\n@Override\r\npublic boolean containsProperty(String name) {\r\n    return (getProperty(name) != null);\r\n}\n/**\r\n * This implementation returns {@code true} if a property with the given name or\r\n * any underscore/uppercase variant thereof exists in this property source.\r\n */\r\n@Override\r\n@Nullable\r\npublic Object getProperty(String name) {\r\n    String actualName = resolvePropertyName(name);\r\n    if (logger.isDebugEnabled() && !name.equals(actualName)) {\r\n        logger.debug(\"PropertySource '\" + getName() + \"' does not contain property '\" + name + \"', but found equivalent '\" + actualName + \"'\");\r\n    }\r\n    return super.getProperty(actualName);\r\n}\n/**\r\n * Check to see if this property source contains a property with the given name, or\r\n * any underscore / uppercase variation thereof. Return the resolved name if one is\r\n * found or otherwise the original name. Never returns {@code null}.\r\n */\r\nprotected final String resolvePropertyName(String name) {\r\n    Assert.notNull(name, \"Property name must not be null\");\r\n    String resolvedName = checkPropertyName(name);\r\n    if (resolvedName != null) {\r\n        return resolvedName;\r\n    }\r\n    String uppercasedName = name.toUpperCase(Locale.ROOT);\r\n    if (!name.equals(uppercasedName)) {\r\n        resolvedName = checkPropertyName(uppercasedName);\r\n        if (resolvedName != null) {\r\n            return resolvedName;\r\n        }\r\n    }\r\n    return name;\r\n}\n@Nullable\r\nprivate String checkPropertyName(String name) {\r\n    // Check name as-is\r\n    if (this.source.containsKey(name)) {\r\n        return name;\r\n    }\r\n    // Check name with just dots replaced\r\n    String noDotName = name.replace('.', '_');\r\n    if (!name.equals(noDotName) && this.source.containsKey(noDotName)) {\r\n        return noDotName;\r\n    }\r\n    // Check name with just hyphens replaced\r\n    String noHyphenName = name.replace('-', '_');\r\n    if (!name.equals(noHyphenName) && this.source.containsKey(noHyphenName)) {\r\n        return noHyphenName;\r\n    }\r\n    // Check name with dots and hyphens replaced\r\n    String noDotNoHyphenName = noDotName.replace('-', '_');\r\n    if (!noDotName.equals(noDotNoHyphenName) && this.source.containsKey(noDotNoHyphenName)) {\r\n        return noDotNoHyphenName;\r\n    }\r\n    // Give up\r\n    return null;\r\n}",
    "comment": "\n * Specialization of {@link MapPropertySource} designed for use with\n * {@linkplain AbstractEnvironment#getSystemEnvironment() system environment variables}.\n * Compensates for constraints in Bash and other shells that do not allow for variables\n * containing the period character and/or hyphen character; also allows for uppercase\n * variations on property names for more idiomatic shell use.\n *\n * <p>For example, a call to {@code getProperty(\"foo.bar\")} will attempt to find a value\n * for the original property or any 'equivalent' property, returning the first found:\n * <ul>\n * <li>{@code foo.bar} - the original name</li>\n * <li>{@code foo_bar} - with underscores for periods (if any)</li>\n * <li>{@code FOO.BAR} - original, with upper case</li>\n * <li>{@code FOO_BAR} - with underscores and upper case</li>\n * </ul>\n * Any hyphen variant of the above would work as well, or even mix dot/hyphen variants.\n *\n * <p>The same applies for calls to {@link #containsProperty(String)}, which returns\n * {@code true} if any of the above properties are present, otherwise {@code false}.\n *\n * <p>This feature is particularly useful when specifying active or default profiles as\n * environment variables. The following is not allowable under Bash:\n *\n * <pre class=\"code\">spring.profiles.active=p1 java -classpath ... MyApp</pre>\n *\n * However, the following syntax is permitted and is also more conventional:\n *\n * <pre class=\"code\">SPRING_PROFILES_ACTIVE=p1 java -classpath ... MyApp</pre>\n *\n * <p>Enable debug- or trace-level logging for this class (or package) for messages\n * explaining when these 'property name resolutions' occur.\n *\n * <p>This property source is included by default in {@link StandardEnvironment}\n * and all its subclasses.\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @since 3.1\n * @see StandardEnvironment\n * @see AbstractEnvironment#getSystemEnvironment()\n * @see AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME\n "
  },
  {
    "entityId": "org.springframework.core.env.SystemEnvironmentPropertySource#containsProperty(String)",
    "entityType": "method",
    "code": "/**\r\n * Return {@code true} if a property with the given name or any underscore/uppercase variant\r\n * thereof exists in this property source.\r\n */\r\n@Override\r\npublic boolean containsProperty(String name) {\r\n    return (getProperty(name) != null);\r\n}",
    "comment": "\n\t * Return {@code true} if a property with the given name or any underscore/uppercase variant\n\t * thereof exists in this property source.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.SystemEnvironmentPropertySource#getProperty(String)",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns {@code true} if a property with the given name or\r\n * any underscore/uppercase variant thereof exists in this property source.\r\n */\r\n@Override\r\n@Nullable\r\npublic Object getProperty(String name) {\r\n    String actualName = resolvePropertyName(name);\r\n    if (logger.isDebugEnabled() && !name.equals(actualName)) {\r\n        logger.debug(\"PropertySource '\" + getName() + \"' does not contain property '\" + name + \"', but found equivalent '\" + actualName + \"'\");\r\n    }\r\n    return super.getProperty(actualName);\r\n}",
    "comment": "\n\t * This implementation returns {@code true} if a property with the given name or\n\t * any underscore/uppercase variant thereof exists in this property source.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.SystemEnvironmentPropertySource#resolvePropertyName(String)",
    "entityType": "method",
    "code": "/**\r\n * Check to see if this property source contains a property with the given name, or\r\n * any underscore / uppercase variation thereof. Return the resolved name if one is\r\n * found or otherwise the original name. Never returns {@code null}.\r\n */\r\nprotected final String resolvePropertyName(String name) {\r\n    Assert.notNull(name, \"Property name must not be null\");\r\n    String resolvedName = checkPropertyName(name);\r\n    if (resolvedName != null) {\r\n        return resolvedName;\r\n    }\r\n    String uppercasedName = name.toUpperCase(Locale.ROOT);\r\n    if (!name.equals(uppercasedName)) {\r\n        resolvedName = checkPropertyName(uppercasedName);\r\n        if (resolvedName != null) {\r\n            return resolvedName;\r\n        }\r\n    }\r\n    return name;\r\n}",
    "comment": "\n\t * Check to see if this property source contains a property with the given name, or\n\t * any underscore / uppercase variation thereof. Return the resolved name if one is\n\t * found or otherwise the original name. Never returns {@code null}.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.SystemEnvironmentPropertySource#checkPropertyName(String)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate String checkPropertyName(String name) {\r\n    // Check name as-is\r\n    if (this.source.containsKey(name)) {\r\n        return name;\r\n    }\r\n    // Check name with just dots replaced\r\n    String noDotName = name.replace('.', '_');\r\n    if (!name.equals(noDotName) && this.source.containsKey(noDotName)) {\r\n        return noDotName;\r\n    }\r\n    // Check name with just hyphens replaced\r\n    String noHyphenName = name.replace('-', '_');\r\n    if (!name.equals(noHyphenName) && this.source.containsKey(noHyphenName)) {\r\n        return noHyphenName;\r\n    }\r\n    // Check name with dots and hyphens replaced\r\n    String noDotNoHyphenName = noDotName.replace('-', '_');\r\n    if (!noDotName.equals(noDotNoHyphenName) && this.source.containsKey(noDotNoHyphenName)) {\r\n        return noDotNoHyphenName;\r\n    }\r\n    // Give up\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ExceptionDepthComparator",
    "entityType": "class",
    "code": "private final Class<? extends Throwable> targetException;\n/**\r\n * Create a new ExceptionDepthComparator for the given exception.\r\n * @param exception the target exception to compare to when sorting by depth\r\n */\r\npublic ExceptionDepthComparator(Throwable exception) {\r\n    Assert.notNull(exception, \"Target exception must not be null\");\r\n    this.targetException = exception.getClass();\r\n}\n/**\r\n * Create a new ExceptionDepthComparator for the given exception type.\r\n * @param exceptionType the target exception type to compare to when sorting by depth\r\n */\r\npublic ExceptionDepthComparator(Class<? extends Throwable> exceptionType) {\r\n    Assert.notNull(exceptionType, \"Target exception type must not be null\");\r\n    this.targetException = exceptionType;\r\n}\n@Override\r\npublic int compare(Class<? extends Throwable> o1, Class<? extends Throwable> o2) {\r\n    int depth1 = getDepth(o1, this.targetException, 0);\r\n    int depth2 = getDepth(o2, this.targetException, 0);\r\n    return (depth1 - depth2);\r\n}\nprivate int getDepth(Class<?> declaredException, Class<?> exceptionToMatch, int depth) {\r\n    if (exceptionToMatch.equals(declaredException)) {\r\n        // Found it!\r\n        return depth;\r\n    }\r\n    // If we've gone as far as we can go and haven't found it...\r\n    if (exceptionToMatch == Throwable.class) {\r\n        return Integer.MAX_VALUE;\r\n    }\r\n    return getDepth(declaredException, exceptionToMatch.getSuperclass(), depth + 1);\r\n}\n/**\r\n * Obtain the closest match from the given exception types for the given target exception.\r\n * @param exceptionTypes the collection of exception types\r\n * @param targetException the target exception to find a match for\r\n * @return the closest matching exception type from the given collection\r\n */\r\npublic static Class<? extends Throwable> findClosestMatch(Collection<Class<? extends Throwable>> exceptionTypes, Throwable targetException) {\r\n    Assert.notEmpty(exceptionTypes, \"Exception types must not be empty\");\r\n    if (exceptionTypes.size() == 1) {\r\n        return exceptionTypes.iterator().next();\r\n    }\r\n    List<Class<? extends Throwable>> handledExceptions = new ArrayList<>(exceptionTypes);\r\n    handledExceptions.sort(new ExceptionDepthComparator(targetException));\r\n    return handledExceptions.get(0);\r\n}",
    "comment": "\n * Comparator capable of sorting exceptions based on their depth from the thrown exception type.\n *\n * @author Juergen Hoeller\n * @author Arjen Poutsma\n * @since 3.0.3\n "
  },
  {
    "entityId": "org.springframework.core.ExceptionDepthComparator#compare(Class<? extends Throwable>,Class<? extends Throwable>)",
    "entityType": "method",
    "code": "@Override\r\npublic int compare(Class<? extends Throwable> o1, Class<? extends Throwable> o2) {\r\n    int depth1 = getDepth(o1, this.targetException, 0);\r\n    int depth2 = getDepth(o2, this.targetException, 0);\r\n    return (depth1 - depth2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ExceptionDepthComparator#getDepth(Class<?>,Class<?>,int)",
    "entityType": "method",
    "code": "private int getDepth(Class<?> declaredException, Class<?> exceptionToMatch, int depth) {\r\n    if (exceptionToMatch.equals(declaredException)) {\r\n        // Found it!\r\n        return depth;\r\n    }\r\n    // If we've gone as far as we can go and haven't found it...\r\n    if (exceptionToMatch == Throwable.class) {\r\n        return Integer.MAX_VALUE;\r\n    }\r\n    return getDepth(declaredException, exceptionToMatch.getSuperclass(), depth + 1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ExceptionDepthComparator#findClosestMatch(Collection<Class<? extends Throwable>>,Throwable)",
    "entityType": "method",
    "code": "/**\r\n * Obtain the closest match from the given exception types for the given target exception.\r\n * @param exceptionTypes the collection of exception types\r\n * @param targetException the target exception to find a match for\r\n * @return the closest matching exception type from the given collection\r\n */\r\npublic static Class<? extends Throwable> findClosestMatch(Collection<Class<? extends Throwable>> exceptionTypes, Throwable targetException) {\r\n    Assert.notEmpty(exceptionTypes, \"Exception types must not be empty\");\r\n    if (exceptionTypes.size() == 1) {\r\n        return exceptionTypes.iterator().next();\r\n    }\r\n    List<Class<? extends Throwable>> handledExceptions = new ArrayList<>(exceptionTypes);\r\n    handledExceptions.sort(new ExceptionDepthComparator(targetException));\r\n    return handledExceptions.get(0);\r\n}",
    "comment": "\n\t * Obtain the closest match from the given exception types for the given target exception.\n\t * @param exceptionTypes the collection of exception types\n\t * @param targetException the target exception to find a match for\n\t * @return the closest matching exception type from the given collection\n\t "
  },
  {
    "entityId": "org.springframework.core.GenericTypeResolver",
    "entityType": "class",
    "code": "/**\r\n * Cache from Class to TypeVariable Map.\r\n */\r\n@SuppressWarnings(\"rawtypes\")\r\nprivate static final Map<Class<?>, Map<TypeVariable, Type>> typeVariableCache = new ConcurrentReferenceHashMap<>();\nprivate GenericTypeResolver() {\r\n}\n/**\r\n * Determine the target type for the given generic parameter type.\r\n * @param methodParameter the method parameter specification\r\n * @param implementationClass the class to resolve type variables against\r\n * @return the corresponding generic parameter or return type\r\n * @deprecated since 5.2 in favor of {@code methodParameter.withContainingClass(implementationClass).getParameterType()}\r\n */\r\n@Deprecated\r\npublic static Class<?> resolveParameterType(MethodParameter methodParameter, Class<?> implementationClass) {\r\n    Assert.notNull(methodParameter, \"MethodParameter must not be null\");\r\n    Assert.notNull(implementationClass, \"Class must not be null\");\r\n    methodParameter.setContainingClass(implementationClass);\r\n    return methodParameter.getParameterType();\r\n}\n/**\r\n * Determine the target type for the generic return type of the given method,\r\n * where formal type variables are declared on the given class.\r\n * @param method the method to introspect\r\n * @param clazz the class to resolve type variables against\r\n * @return the corresponding generic parameter or return type\r\n */\r\npublic static Class<?> resolveReturnType(Method method, Class<?> clazz) {\r\n    Assert.notNull(method, \"Method must not be null\");\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    return ResolvableType.forMethodReturnType(method, clazz).resolve(method.getReturnType());\r\n}\n/**\r\n * Resolve the single type argument of the given generic type against the given\r\n * target method which is assumed to return the given type or an implementation\r\n * of it.\r\n * @param method the target method to check the return type of\r\n * @param genericType the generic interface or superclass to resolve the type argument from\r\n * @return the resolved parameter type of the method return type, or {@code null}\r\n * if not resolvable or if the single argument is of type {@link WildcardType}.\r\n */\r\n@Nullable\r\npublic static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericType) {\r\n    Assert.notNull(method, \"Method must not be null\");\r\n    ResolvableType resolvableType = ResolvableType.forMethodReturnType(method).as(genericType);\r\n    if (!resolvableType.hasGenerics() || resolvableType.getType() instanceof WildcardType) {\r\n        return null;\r\n    }\r\n    return getSingleGeneric(resolvableType);\r\n}\n/**\r\n * Resolve the single type argument of the given generic type against\r\n * the given target class which is assumed to implement the given type\r\n * and possibly declare a concrete type for its type variable.\r\n * @param clazz the target class to check against\r\n * @param genericType the generic interface or superclass to resolve the type argument from\r\n * @return the resolved type of the argument, or {@code null} if not resolvable\r\n */\r\n@Nullable\r\npublic static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericType) {\r\n    ResolvableType resolvableType = ResolvableType.forClass(clazz).as(genericType);\r\n    if (!resolvableType.hasGenerics()) {\r\n        return null;\r\n    }\r\n    return getSingleGeneric(resolvableType);\r\n}\n@Nullable\r\nprivate static Class<?> getSingleGeneric(ResolvableType resolvableType) {\r\n    Assert.isTrue(resolvableType.getGenerics().length == 1, () -> \"Expected 1 type argument on generic interface [\" + resolvableType + \"] but found \" + resolvableType.getGenerics().length);\r\n    return resolvableType.getGeneric().resolve();\r\n}\n/**\r\n * Resolve the type arguments of the given generic type against the given\r\n * target class which is assumed to implement or extend from the given type\r\n * and possibly declare concrete types for its type variables.\r\n * @param clazz the target class to check against\r\n * @param genericType the generic interface or superclass to resolve the type argument from\r\n * @return the resolved type of each argument, with the array size matching the\r\n * number of actual type arguments, or {@code null} if not resolvable\r\n */\r\npublic static Class<?> @Nullable [] resolveTypeArguments(Class<?> clazz, Class<?> genericType) {\r\n    ResolvableType type = ResolvableType.forClass(clazz).as(genericType);\r\n    if (!type.hasGenerics() || !type.hasResolvableGenerics()) {\r\n        return null;\r\n    }\r\n    return type.resolveGenerics(Object.class);\r\n}\n/**\r\n * Resolve the given generic type against the given context class,\r\n * substituting type variables as far as possible.\r\n * <p>As of 6.2, this method resolves type variables recursively.\r\n * @param genericType the (potentially) generic type\r\n * @param contextClass a context class for the target type, for example a class\r\n * in which the target type appears in a method signature (can be {@code null})\r\n * @return the resolved type (possibly the given generic type as-is)\r\n * @since 5.0\r\n */\r\npublic static Type resolveType(Type genericType, @Nullable Class<?> contextClass) {\r\n    if (contextClass != null) {\r\n        if (genericType instanceof TypeVariable<?> typeVariable) {\r\n            ResolvableType resolvedTypeVariable = resolveVariable(typeVariable, ResolvableType.forClass(contextClass));\r\n            if (resolvedTypeVariable != ResolvableType.NONE) {\r\n                Class<?> resolved = resolvedTypeVariable.resolve();\r\n                if (resolved != null) {\r\n                    return resolved;\r\n                }\r\n            }\r\n        } else if (genericType instanceof ParameterizedType parameterizedType) {\r\n            ResolvableType resolvedType = ResolvableType.forType(genericType);\r\n            if (resolvedType.hasUnresolvableGenerics()) {\r\n                ResolvableType[] generics = new ResolvableType[parameterizedType.getActualTypeArguments().length];\r\n                Type[] typeArguments = parameterizedType.getActualTypeArguments();\r\n                ResolvableType contextType = ResolvableType.forClass(contextClass);\r\n                for (int i = 0; i < typeArguments.length; i++) {\r\n                    Type typeArgument = typeArguments[i];\r\n                    if (typeArgument instanceof TypeVariable<?> typeVariable) {\r\n                        ResolvableType resolvedTypeArgument = resolveVariable(typeVariable, contextType);\r\n                        if (resolvedTypeArgument != ResolvableType.NONE) {\r\n                            generics[i] = resolvedTypeArgument;\r\n                        } else {\r\n                            generics[i] = ResolvableType.forType(typeArgument);\r\n                        }\r\n                    } else if (typeArgument instanceof ParameterizedType) {\r\n                        generics[i] = ResolvableType.forType(resolveType(typeArgument, contextClass));\r\n                    } else {\r\n                        generics[i] = ResolvableType.forType(typeArgument);\r\n                    }\r\n                }\r\n                Class<?> rawClass = resolvedType.getRawClass();\r\n                if (rawClass != null) {\r\n                    return ResolvableType.forClassWithGenerics(rawClass, generics).getType();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return genericType;\r\n}\nprivate static ResolvableType resolveVariable(TypeVariable<?> typeVariable, ResolvableType contextType) {\r\n    ResolvableType resolvedType;\r\n    if (contextType.hasGenerics()) {\r\n        ResolvableType.VariableResolver variableResolver = contextType.asVariableResolver();\r\n        if (variableResolver == null) {\r\n            return ResolvableType.NONE;\r\n        }\r\n        resolvedType = variableResolver.resolveVariable(typeVariable);\r\n        if (resolvedType != null) {\r\n            return resolvedType;\r\n        }\r\n    }\r\n    ResolvableType superType = contextType.getSuperType();\r\n    if (superType != ResolvableType.NONE) {\r\n        resolvedType = resolveVariable(typeVariable, superType);\r\n        if (resolvedType != ResolvableType.NONE) {\r\n            return resolvedType;\r\n        }\r\n    }\r\n    for (ResolvableType ifc : contextType.getInterfaces()) {\r\n        resolvedType = resolveVariable(typeVariable, ifc);\r\n        if (resolvedType != ResolvableType.NONE) {\r\n            return resolvedType;\r\n        }\r\n    }\r\n    return ResolvableType.forVariableBounds(typeVariable);\r\n}\n/**\r\n * Resolve the specified generic type against the given TypeVariable map.\r\n * <p>Used by Spring Data.\r\n * @param genericType the generic type to resolve\r\n * @param map the TypeVariable Map to resolved against\r\n * @return the type if it resolves to a Class, or {@code Object.class} otherwise\r\n */\r\n@SuppressWarnings(\"rawtypes\")\r\npublic static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map) {\r\n    return ResolvableType.forType(genericType, new TypeVariableMapVariableResolver(map)).toClass();\r\n}\n/**\r\n * Build a mapping of {@link TypeVariable#getName TypeVariable names} to\r\n * {@link Class concrete classes} for the specified {@link Class}.\r\n * Searches all supertypes, enclosing types and interfaces.\r\n * @see #resolveType(Type, Map)\r\n */\r\n@SuppressWarnings(\"rawtypes\")\r\npublic static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {\r\n    Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz);\r\n    if (typeVariableMap == null) {\r\n        typeVariableMap = new HashMap<>();\r\n        buildTypeVariableMap(ResolvableType.forClass(clazz), typeVariableMap);\r\n        typeVariableCache.put(clazz, Collections.unmodifiableMap(typeVariableMap));\r\n    }\r\n    return typeVariableMap;\r\n}\n@SuppressWarnings(\"rawtypes\")\r\nprivate static void buildTypeVariableMap(ResolvableType type, Map<TypeVariable, Type> typeVariableMap) {\r\n    if (type != ResolvableType.NONE) {\r\n        Class<?> resolved = type.resolve();\r\n        if (resolved != null && type.getType() instanceof ParameterizedType) {\r\n            TypeVariable<?>[] variables = resolved.getTypeParameters();\r\n            for (int i = 0; i < variables.length; i++) {\r\n                ResolvableType generic = type.getGeneric(i);\r\n                while (generic.getType() instanceof TypeVariable<?>) {\r\n                    generic = generic.resolveType();\r\n                }\r\n                if (generic != ResolvableType.NONE) {\r\n                    typeVariableMap.put(variables[i], generic.getType());\r\n                }\r\n            }\r\n        }\r\n        buildTypeVariableMap(type.getSuperType(), typeVariableMap);\r\n        for (ResolvableType interfaceType : type.getInterfaces()) {\r\n            buildTypeVariableMap(interfaceType, typeVariableMap);\r\n        }\r\n        if (resolved != null && resolved.isMemberClass()) {\r\n            buildTypeVariableMap(ResolvableType.forClass(resolved.getEnclosingClass()), typeVariableMap);\r\n        }\r\n    }\r\n}\n@SuppressWarnings({ \"serial\", \"rawtypes\" })\r\nprivate static class TypeVariableMapVariableResolver implements ResolvableType.VariableResolver {\r\n\r\n    private final Map<TypeVariable, Type> typeVariableMap;\r\n\r\n    public TypeVariableMapVariableResolver(Map<TypeVariable, Type> typeVariableMap) {\r\n        this.typeVariableMap = typeVariableMap;\r\n    }\r\n\r\n    @Override\r\n    @Nullable\r\n    public ResolvableType resolveVariable(TypeVariable<?> variable) {\r\n        Type type = this.typeVariableMap.get(variable);\r\n        return (type != null ? ResolvableType.forType(type) : null);\r\n    }\r\n\r\n    @Override\r\n    public Object getSource() {\r\n        return this.typeVariableMap;\r\n    }\r\n}",
    "comment": "\n * Helper class for resolving generic types against type variables.\n *\n * <p>Mainly intended for usage within the framework, resolving method\n * parameter types even when they are declared generically.\n *\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Sam Brannen\n * @author Phillip Webb\n * @author Yanming Zhou\n * @since 2.5.2\n "
  },
  {
    "entityId": "org.springframework.core.GenericTypeResolver#resolveParameterType(MethodParameter,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Determine the target type for the given generic parameter type.\r\n * @param methodParameter the method parameter specification\r\n * @param implementationClass the class to resolve type variables against\r\n * @return the corresponding generic parameter or return type\r\n * @deprecated since 5.2 in favor of {@code methodParameter.withContainingClass(implementationClass).getParameterType()}\r\n */\r\n@Deprecated\r\npublic static Class<?> resolveParameterType(MethodParameter methodParameter, Class<?> implementationClass) {\r\n    Assert.notNull(methodParameter, \"MethodParameter must not be null\");\r\n    Assert.notNull(implementationClass, \"Class must not be null\");\r\n    methodParameter.setContainingClass(implementationClass);\r\n    return methodParameter.getParameterType();\r\n}",
    "comment": "\n\t * Determine the target type for the given generic parameter type.\n\t * @param methodParameter the method parameter specification\n\t * @param implementationClass the class to resolve type variables against\n\t * @return the corresponding generic parameter or return type\n\t * @deprecated since 5.2 in favor of {@code methodParameter.withContainingClass(implementationClass).getParameterType()}\n\t "
  },
  {
    "entityId": "org.springframework.core.GenericTypeResolver#resolveReturnType(Method,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Determine the target type for the generic return type of the given method,\r\n * where formal type variables are declared on the given class.\r\n * @param method the method to introspect\r\n * @param clazz the class to resolve type variables against\r\n * @return the corresponding generic parameter or return type\r\n */\r\npublic static Class<?> resolveReturnType(Method method, Class<?> clazz) {\r\n    Assert.notNull(method, \"Method must not be null\");\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    return ResolvableType.forMethodReturnType(method, clazz).resolve(method.getReturnType());\r\n}",
    "comment": "\n\t * Determine the target type for the generic return type of the given method,\n\t * where formal type variables are declared on the given class.\n\t * @param method the method to introspect\n\t * @param clazz the class to resolve type variables against\n\t * @return the corresponding generic parameter or return type\n\t "
  },
  {
    "entityId": "org.springframework.core.GenericTypeResolver#resolveReturnTypeArgument(Method,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Resolve the single type argument of the given generic type against the given\r\n * target method which is assumed to return the given type or an implementation\r\n * of it.\r\n * @param method the target method to check the return type of\r\n * @param genericType the generic interface or superclass to resolve the type argument from\r\n * @return the resolved parameter type of the method return type, or {@code null}\r\n * if not resolvable or if the single argument is of type {@link WildcardType}.\r\n */\r\n@Nullable\r\npublic static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericType) {\r\n    Assert.notNull(method, \"Method must not be null\");\r\n    ResolvableType resolvableType = ResolvableType.forMethodReturnType(method).as(genericType);\r\n    if (!resolvableType.hasGenerics() || resolvableType.getType() instanceof WildcardType) {\r\n        return null;\r\n    }\r\n    return getSingleGeneric(resolvableType);\r\n}",
    "comment": "\n\t * Resolve the single type argument of the given generic type against the given\n\t * target method which is assumed to return the given type or an implementation\n\t * of it.\n\t * @param method the target method to check the return type of\n\t * @param genericType the generic interface or superclass to resolve the type argument from\n\t * @return the resolved parameter type of the method return type, or {@code null}\n\t * if not resolvable or if the single argument is of type {@link WildcardType}.\n\t "
  },
  {
    "entityId": "org.springframework.core.GenericTypeResolver#resolveTypeArgument(Class<?>,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Resolve the single type argument of the given generic type against\r\n * the given target class which is assumed to implement the given type\r\n * and possibly declare a concrete type for its type variable.\r\n * @param clazz the target class to check against\r\n * @param genericType the generic interface or superclass to resolve the type argument from\r\n * @return the resolved type of the argument, or {@code null} if not resolvable\r\n */\r\n@Nullable\r\npublic static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericType) {\r\n    ResolvableType resolvableType = ResolvableType.forClass(clazz).as(genericType);\r\n    if (!resolvableType.hasGenerics()) {\r\n        return null;\r\n    }\r\n    return getSingleGeneric(resolvableType);\r\n}",
    "comment": "\n\t * Resolve the single type argument of the given generic type against\n\t * the given target class which is assumed to implement the given type\n\t * and possibly declare a concrete type for its type variable.\n\t * @param clazz the target class to check against\n\t * @param genericType the generic interface or superclass to resolve the type argument from\n\t * @return the resolved type of the argument, or {@code null} if not resolvable\n\t "
  },
  {
    "entityId": "org.springframework.core.GenericTypeResolver#getSingleGeneric(ResolvableType)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static Class<?> getSingleGeneric(ResolvableType resolvableType) {\r\n    Assert.isTrue(resolvableType.getGenerics().length == 1, () -> \"Expected 1 type argument on generic interface [\" + resolvableType + \"] but found \" + resolvableType.getGenerics().length);\r\n    return resolvableType.getGeneric().resolve();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.GenericTypeResolver#resolveTypeArguments(Class<?>,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Resolve the type arguments of the given generic type against the given\r\n * target class which is assumed to implement or extend from the given type\r\n * and possibly declare concrete types for its type variables.\r\n * @param clazz the target class to check against\r\n * @param genericType the generic interface or superclass to resolve the type argument from\r\n * @return the resolved type of each argument, with the array size matching the\r\n * number of actual type arguments, or {@code null} if not resolvable\r\n */\r\npublic static Class<?> @Nullable [] resolveTypeArguments(Class<?> clazz, Class<?> genericType) {\r\n    ResolvableType type = ResolvableType.forClass(clazz).as(genericType);\r\n    if (!type.hasGenerics() || !type.hasResolvableGenerics()) {\r\n        return null;\r\n    }\r\n    return type.resolveGenerics(Object.class);\r\n}",
    "comment": "\n\t * Resolve the type arguments of the given generic type against the given\n\t * target class which is assumed to implement or extend from the given type\n\t * and possibly declare concrete types for its type variables.\n\t * @param clazz the target class to check against\n\t * @param genericType the generic interface or superclass to resolve the type argument from\n\t * @return the resolved type of each argument, with the array size matching the\n\t * number of actual type arguments, or {@code null} if not resolvable\n\t "
  },
  {
    "entityId": "org.springframework.core.GenericTypeResolver#resolveType(Type,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Resolve the given generic type against the given context class,\r\n * substituting type variables as far as possible.\r\n * <p>As of 6.2, this method resolves type variables recursively.\r\n * @param genericType the (potentially) generic type\r\n * @param contextClass a context class for the target type, for example a class\r\n * in which the target type appears in a method signature (can be {@code null})\r\n * @return the resolved type (possibly the given generic type as-is)\r\n * @since 5.0\r\n */\r\npublic static Type resolveType(Type genericType, @Nullable Class<?> contextClass) {\r\n    if (contextClass != null) {\r\n        if (genericType instanceof TypeVariable<?> typeVariable) {\r\n            ResolvableType resolvedTypeVariable = resolveVariable(typeVariable, ResolvableType.forClass(contextClass));\r\n            if (resolvedTypeVariable != ResolvableType.NONE) {\r\n                Class<?> resolved = resolvedTypeVariable.resolve();\r\n                if (resolved != null) {\r\n                    return resolved;\r\n                }\r\n            }\r\n        } else if (genericType instanceof ParameterizedType parameterizedType) {\r\n            ResolvableType resolvedType = ResolvableType.forType(genericType);\r\n            if (resolvedType.hasUnresolvableGenerics()) {\r\n                ResolvableType[] generics = new ResolvableType[parameterizedType.getActualTypeArguments().length];\r\n                Type[] typeArguments = parameterizedType.getActualTypeArguments();\r\n                ResolvableType contextType = ResolvableType.forClass(contextClass);\r\n                for (int i = 0; i < typeArguments.length; i++) {\r\n                    Type typeArgument = typeArguments[i];\r\n                    if (typeArgument instanceof TypeVariable<?> typeVariable) {\r\n                        ResolvableType resolvedTypeArgument = resolveVariable(typeVariable, contextType);\r\n                        if (resolvedTypeArgument != ResolvableType.NONE) {\r\n                            generics[i] = resolvedTypeArgument;\r\n                        } else {\r\n                            generics[i] = ResolvableType.forType(typeArgument);\r\n                        }\r\n                    } else if (typeArgument instanceof ParameterizedType) {\r\n                        generics[i] = ResolvableType.forType(resolveType(typeArgument, contextClass));\r\n                    } else {\r\n                        generics[i] = ResolvableType.forType(typeArgument);\r\n                    }\r\n                }\r\n                Class<?> rawClass = resolvedType.getRawClass();\r\n                if (rawClass != null) {\r\n                    return ResolvableType.forClassWithGenerics(rawClass, generics).getType();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return genericType;\r\n}",
    "comment": "\n\t * Resolve the given generic type against the given context class,\n\t * substituting type variables as far as possible.\n\t * <p>As of 6.2, this method resolves type variables recursively.\n\t * @param genericType the (potentially) generic type\n\t * @param contextClass a context class for the target type, for example a class\n\t * in which the target type appears in a method signature (can be {@code null})\n\t * @return the resolved type (possibly the given generic type as-is)\n\t * @since 5.0\n\t "
  },
  {
    "entityId": "org.springframework.core.GenericTypeResolver#resolveVariable(TypeVariable<?>,ResolvableType)",
    "entityType": "method",
    "code": "private static ResolvableType resolveVariable(TypeVariable<?> typeVariable, ResolvableType contextType) {\r\n    ResolvableType resolvedType;\r\n    if (contextType.hasGenerics()) {\r\n        ResolvableType.VariableResolver variableResolver = contextType.asVariableResolver();\r\n        if (variableResolver == null) {\r\n            return ResolvableType.NONE;\r\n        }\r\n        resolvedType = variableResolver.resolveVariable(typeVariable);\r\n        if (resolvedType != null) {\r\n            return resolvedType;\r\n        }\r\n    }\r\n    ResolvableType superType = contextType.getSuperType();\r\n    if (superType != ResolvableType.NONE) {\r\n        resolvedType = resolveVariable(typeVariable, superType);\r\n        if (resolvedType != ResolvableType.NONE) {\r\n            return resolvedType;\r\n        }\r\n    }\r\n    for (ResolvableType ifc : contextType.getInterfaces()) {\r\n        resolvedType = resolveVariable(typeVariable, ifc);\r\n        if (resolvedType != ResolvableType.NONE) {\r\n            return resolvedType;\r\n        }\r\n    }\r\n    return ResolvableType.forVariableBounds(typeVariable);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.GenericTypeResolver#resolveType(Type,Map<TypeVariable,Type>)",
    "entityType": "method",
    "code": "/**\r\n * Resolve the specified generic type against the given TypeVariable map.\r\n * <p>Used by Spring Data.\r\n * @param genericType the generic type to resolve\r\n * @param map the TypeVariable Map to resolved against\r\n * @return the type if it resolves to a Class, or {@code Object.class} otherwise\r\n */\r\n@SuppressWarnings(\"rawtypes\")\r\npublic static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map) {\r\n    return ResolvableType.forType(genericType, new TypeVariableMapVariableResolver(map)).toClass();\r\n}",
    "comment": "\n\t * Resolve the specified generic type against the given TypeVariable map.\n\t * <p>Used by Spring Data.\n\t * @param genericType the generic type to resolve\n\t * @param map the TypeVariable Map to resolved against\n\t * @return the type if it resolves to a Class, or {@code Object.class} otherwise\n\t "
  },
  {
    "entityId": "org.springframework.core.GenericTypeResolver#getTypeVariableMap(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Build a mapping of {@link TypeVariable#getName TypeVariable names} to\r\n * {@link Class concrete classes} for the specified {@link Class}.\r\n * Searches all supertypes, enclosing types and interfaces.\r\n * @see #resolveType(Type, Map)\r\n */\r\n@SuppressWarnings(\"rawtypes\")\r\npublic static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {\r\n    Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz);\r\n    if (typeVariableMap == null) {\r\n        typeVariableMap = new HashMap<>();\r\n        buildTypeVariableMap(ResolvableType.forClass(clazz), typeVariableMap);\r\n        typeVariableCache.put(clazz, Collections.unmodifiableMap(typeVariableMap));\r\n    }\r\n    return typeVariableMap;\r\n}",
    "comment": "\n\t * Build a mapping of {@link TypeVariable#getName TypeVariable names} to\n\t * {@link Class concrete classes} for the specified {@link Class}.\n\t * Searches all supertypes, enclosing types and interfaces.\n\t * @see #resolveType(Type, Map)\n\t "
  },
  {
    "entityId": "org.springframework.core.GenericTypeResolver#buildTypeVariableMap(ResolvableType,Map<TypeVariable,Type>)",
    "entityType": "method",
    "code": "@SuppressWarnings(\"rawtypes\")\r\nprivate static void buildTypeVariableMap(ResolvableType type, Map<TypeVariable, Type> typeVariableMap) {\r\n    if (type != ResolvableType.NONE) {\r\n        Class<?> resolved = type.resolve();\r\n        if (resolved != null && type.getType() instanceof ParameterizedType) {\r\n            TypeVariable<?>[] variables = resolved.getTypeParameters();\r\n            for (int i = 0; i < variables.length; i++) {\r\n                ResolvableType generic = type.getGeneric(i);\r\n                while (generic.getType() instanceof TypeVariable<?>) {\r\n                    generic = generic.resolveType();\r\n                }\r\n                if (generic != ResolvableType.NONE) {\r\n                    typeVariableMap.put(variables[i], generic.getType());\r\n                }\r\n            }\r\n        }\r\n        buildTypeVariableMap(type.getSuperType(), typeVariableMap);\r\n        for (ResolvableType interfaceType : type.getInterfaces()) {\r\n            buildTypeVariableMap(interfaceType, typeVariableMap);\r\n        }\r\n        if (resolved != null && resolved.isMemberClass()) {\r\n            buildTypeVariableMap(ResolvableType.forClass(resolved.getEnclosingClass()), typeVariableMap);\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.TypeVariableMapVariableResolver",
    "entityType": "class",
    "code": "private final Map<TypeVariable, Type> typeVariableMap;\npublic TypeVariableMapVariableResolver(Map<TypeVariable, Type> typeVariableMap) {\r\n    this.typeVariableMap = typeVariableMap;\r\n}\n@Override\r\n@Nullable\r\npublic ResolvableType resolveVariable(TypeVariable<?> variable) {\r\n    Type type = this.typeVariableMap.get(variable);\r\n    return (type != null ? ResolvableType.forType(type) : null);\r\n}\n@Override\r\npublic Object getSource() {\r\n    return this.typeVariableMap;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.TypeVariableMapVariableResolver#resolveVariable(TypeVariable<?>)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic ResolvableType resolveVariable(TypeVariable<?> variable) {\r\n    Type type = this.typeVariableMap.get(variable);\r\n    return (type != null ? ResolvableType.forType(type) : null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.TypeVariableMapVariableResolver#getSource()",
    "entityType": "method",
    "code": "@Override\r\npublic Object getSource() {\r\n    return this.typeVariableMap;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.InfrastructureProxy",
    "entityType": "class",
    "code": "/**\r\n * Return the underlying resource (never {@code null}).\r\n */\r\nObject getWrappedObject();",
    "comment": "\n * Interface to be implemented by transparent resource proxies that need to be\n * considered as equal to the underlying resource, for example for consistent\n * lookup key comparisons. Note that this interface does imply such special\n * semantics and does not constitute a general-purpose mixin!\n *\n * <p>Such wrappers will automatically be unwrapped for key comparisons in\n * {@link org.springframework.transaction.support.TransactionSynchronizationManager}.\n *\n * <p>Only fully transparent proxies, for example, for redirection or service lookups,\n * are supposed to implement this interface. Proxies that decorate the target\n * object with new behavior, such as AOP proxies, do <i>not</i> qualify here!\n *\n * @author Juergen Hoeller\n * @since 2.5.4\n * @see org.springframework.transaction.support.TransactionSynchronizationManager\n "
  },
  {
    "entityId": "org.springframework.core.InfrastructureProxy#getWrappedObject()",
    "entityType": "method",
    "code": "/**\r\n * Return the underlying resource (never {@code null}).\r\n */\r\nObject getWrappedObject();",
    "comment": "\n\t * Return the underlying resource (never {@code null}).\n\t "
  },
  {
    "entityId": "org.springframework.core.io.AbstractFileResolvingResource",
    "entityType": "class",
    "code": "@Override\r\npublic boolean exists() {\r\n    try {\r\n        URL url = getURL();\r\n        if (ResourceUtils.isFileURL(url)) {\r\n            // Proceed with file system resolution\r\n            return getFile().exists();\r\n        } else {\r\n            // Try a URL connection content-length header\r\n            URLConnection con = url.openConnection();\r\n            customizeConnection(con);\r\n            HttpURLConnection httpCon = (con instanceof HttpURLConnection huc ? huc : null);\r\n            if (httpCon != null) {\r\n                httpCon.setRequestMethod(\"HEAD\");\r\n                int code = httpCon.getResponseCode();\r\n                if (code == HttpURLConnection.HTTP_OK) {\r\n                    return true;\r\n                } else if (code == HttpURLConnection.HTTP_NOT_FOUND) {\r\n                    return false;\r\n                } else if (code == HttpURLConnection.HTTP_BAD_METHOD) {\r\n                    con = url.openConnection();\r\n                    customizeConnection(con);\r\n                    if (con instanceof HttpURLConnection newHttpCon) {\r\n                        code = newHttpCon.getResponseCode();\r\n                        if (code == HttpURLConnection.HTTP_OK) {\r\n                            return true;\r\n                        } else if (code == HttpURLConnection.HTTP_NOT_FOUND) {\r\n                            return false;\r\n                        }\r\n                        httpCon = newHttpCon;\r\n                    }\r\n                }\r\n            }\r\n            if (con.getContentLengthLong() > 0) {\r\n                return true;\r\n            }\r\n            if (httpCon != null) {\r\n                // No HTTP OK status, and no content-length header: give up\r\n                httpCon.disconnect();\r\n                return false;\r\n            } else {\r\n                // Fall back to stream existence: can we open the stream?\r\n                getInputStream().close();\r\n                return true;\r\n            }\r\n        }\r\n    } catch (IOException ex) {\r\n        return false;\r\n    }\r\n}\n@Override\r\npublic boolean isReadable() {\r\n    try {\r\n        return checkReadable(getURL());\r\n    } catch (IOException ex) {\r\n        return false;\r\n    }\r\n}\nboolean checkReadable(URL url) {\r\n    try {\r\n        if (ResourceUtils.isFileURL(url)) {\r\n            // Proceed with file system resolution\r\n            File file = getFile();\r\n            return (file.canRead() && !file.isDirectory());\r\n        } else {\r\n            // Try InputStream resolution for jar resources\r\n            URLConnection con = url.openConnection();\r\n            customizeConnection(con);\r\n            if (con instanceof HttpURLConnection httpCon) {\r\n                httpCon.setRequestMethod(\"HEAD\");\r\n                int code = httpCon.getResponseCode();\r\n                if (code == HttpURLConnection.HTTP_BAD_METHOD) {\r\n                    con = url.openConnection();\r\n                    customizeConnection(con);\r\n                    if (!(con instanceof HttpURLConnection newHttpCon)) {\r\n                        return false;\r\n                    }\r\n                    code = newHttpCon.getResponseCode();\r\n                    httpCon = newHttpCon;\r\n                }\r\n                if (code != HttpURLConnection.HTTP_OK) {\r\n                    httpCon.disconnect();\r\n                    return false;\r\n                }\r\n            } else if (con instanceof JarURLConnection jarCon) {\r\n                JarEntry jarEntry = jarCon.getJarEntry();\r\n                if (jarEntry == null) {\r\n                    return false;\r\n                } else {\r\n                    return !jarEntry.isDirectory();\r\n                }\r\n            }\r\n            long contentLength = con.getContentLengthLong();\r\n            if (contentLength > 0) {\r\n                return true;\r\n            } else if (contentLength == 0) {\r\n                // Empty file or directory -> not considered readable...\r\n                return false;\r\n            } else {\r\n                // Fall back to stream existence: can we open the stream?\r\n                getInputStream().close();\r\n                return true;\r\n            }\r\n        }\r\n    } catch (IOException ex) {\r\n        return false;\r\n    }\r\n}\n@Override\r\npublic boolean isFile() {\r\n    try {\r\n        URL url = getURL();\r\n        if (url.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {\r\n            return VfsResourceDelegate.getResource(url).isFile();\r\n        }\r\n        return ResourceUtils.URL_PROTOCOL_FILE.equals(url.getProtocol());\r\n    } catch (IOException ex) {\r\n        return false;\r\n    }\r\n}\n/**\r\n * This implementation returns a File reference for the underlying class path\r\n * resource, provided that it refers to a file in the file system.\r\n * @see org.springframework.util.ResourceUtils#getFile(java.net.URL, String)\r\n */\r\n@Override\r\npublic File getFile() throws IOException {\r\n    URL url = getURL();\r\n    if (url.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {\r\n        return VfsResourceDelegate.getResource(url).getFile();\r\n    }\r\n    return ResourceUtils.getFile(url, getDescription());\r\n}\n/**\r\n * This implementation determines the underlying File\r\n * (or jar file, in case of a resource in a jar/zip).\r\n */\r\n@Override\r\nprotected File getFileForLastModifiedCheck() throws IOException {\r\n    URL url = getURL();\r\n    if (ResourceUtils.isJarURL(url)) {\r\n        URL actualUrl = ResourceUtils.extractArchiveURL(url);\r\n        if (actualUrl.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {\r\n            return VfsResourceDelegate.getResource(actualUrl).getFile();\r\n        }\r\n        return ResourceUtils.getFile(actualUrl, \"Jar URL\");\r\n    } else {\r\n        return getFile();\r\n    }\r\n}\n/**\r\n * Determine whether the given {@link URI} represents a file in a file system.\r\n * @since 5.0\r\n * @see #getFile(URI)\r\n */\r\nprotected boolean isFile(URI uri) {\r\n    try {\r\n        if (uri.getScheme().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {\r\n            return VfsResourceDelegate.getResource(uri).isFile();\r\n        }\r\n        return ResourceUtils.URL_PROTOCOL_FILE.equals(uri.getScheme());\r\n    } catch (IOException ex) {\r\n        return false;\r\n    }\r\n}\n/**\r\n * This implementation returns a File reference for the given URI-identified\r\n * resource, provided that it refers to a file in the file system.\r\n * @see org.springframework.util.ResourceUtils#getFile(java.net.URI, String)\r\n */\r\nprotected File getFile(URI uri) throws IOException {\r\n    if (uri.getScheme().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {\r\n        return VfsResourceDelegate.getResource(uri).getFile();\r\n    }\r\n    return ResourceUtils.getFile(uri, getDescription());\r\n}\n/**\r\n * This implementation returns a FileChannel for the given URI-identified\r\n * resource, provided that it refers to a file in the file system.\r\n * @since 5.0\r\n * @see #getFile()\r\n */\r\n@Override\r\npublic ReadableByteChannel readableChannel() throws IOException {\r\n    try {\r\n        // Try file system channel\r\n        return FileChannel.open(getFile().toPath(), StandardOpenOption.READ);\r\n    } catch (FileNotFoundException | NoSuchFileException ex) {\r\n        // Fall back to InputStream adaptation in superclass\r\n        return super.readableChannel();\r\n    }\r\n}\n@Override\r\npublic long contentLength() throws IOException {\r\n    URL url = getURL();\r\n    if (ResourceUtils.isFileURL(url)) {\r\n        // Proceed with file system resolution\r\n        File file = getFile();\r\n        long length = file.length();\r\n        if (length == 0L && !file.exists()) {\r\n            throw new FileNotFoundException(getDescription() + \" cannot be resolved in the file system for checking its content length\");\r\n        }\r\n        return length;\r\n    } else {\r\n        // Try a URL connection content-length header\r\n        URLConnection con = url.openConnection();\r\n        customizeConnection(con);\r\n        if (con instanceof HttpURLConnection httpCon) {\r\n            httpCon.setRequestMethod(\"HEAD\");\r\n        }\r\n        long length = con.getContentLengthLong();\r\n        if (length <= 0 && con instanceof HttpURLConnection httpCon && httpCon.getResponseCode() == HttpURLConnection.HTTP_BAD_METHOD) {\r\n            con = url.openConnection();\r\n            customizeConnection(con);\r\n            length = con.getContentLengthLong();\r\n        }\r\n        return length;\r\n    }\r\n}\n@Override\r\npublic long lastModified() throws IOException {\r\n    URL url = getURL();\r\n    boolean fileCheck = false;\r\n    if (ResourceUtils.isFileURL(url) || ResourceUtils.isJarURL(url)) {\r\n        // Proceed with file system resolution\r\n        fileCheck = true;\r\n        try {\r\n            File fileToCheck = getFileForLastModifiedCheck();\r\n            long lastModified = fileToCheck.lastModified();\r\n            if (lastModified > 0L || fileToCheck.exists()) {\r\n                return lastModified;\r\n            }\r\n        } catch (FileNotFoundException ex) {\r\n            // Defensively fall back to URL connection check instead\r\n        }\r\n    }\r\n    // Try a URL connection last-modified header\r\n    URLConnection con = url.openConnection();\r\n    customizeConnection(con);\r\n    if (con instanceof HttpURLConnection httpCon) {\r\n        httpCon.setRequestMethod(\"HEAD\");\r\n    }\r\n    long lastModified = con.getLastModified();\r\n    if (lastModified == 0) {\r\n        if (con instanceof HttpURLConnection httpCon && httpCon.getResponseCode() == HttpURLConnection.HTTP_BAD_METHOD) {\r\n            con = url.openConnection();\r\n            customizeConnection(con);\r\n            lastModified = con.getLastModified();\r\n        }\r\n        if (fileCheck && con.getContentLengthLong() <= 0) {\r\n            throw new FileNotFoundException(getDescription() + \" cannot be resolved in the file system for checking its last-modified timestamp\");\r\n        }\r\n    }\r\n    return lastModified;\r\n}\n/**\r\n * Customize the given {@link URLConnection} before fetching the resource.\r\n * <p>Calls {@link ResourceUtils#useCachesIfNecessary(URLConnection)} and\r\n * delegates to {@link #customizeConnection(HttpURLConnection)} if possible.\r\n * Can be overridden in subclasses.\r\n * @param con the URLConnection to customize\r\n * @throws IOException if thrown from URLConnection methods\r\n */\r\nprotected void customizeConnection(URLConnection con) throws IOException {\r\n    ResourceUtils.useCachesIfNecessary(con);\r\n    if (con instanceof HttpURLConnection httpConn) {\r\n        customizeConnection(httpConn);\r\n    }\r\n}\n/**\r\n * Customize the given {@link HttpURLConnection} before fetching the resource.\r\n * <p>Can be overridden in subclasses for configuring request headers and timeouts.\r\n * @param con the HttpURLConnection to customize\r\n * @throws IOException if thrown from HttpURLConnection methods\r\n */\r\nprotected void customizeConnection(HttpURLConnection con) throws IOException ;\n/**\r\n * Inner delegate class, avoiding a hard JBoss VFS API dependency at runtime.\r\n */\r\nprivate static class VfsResourceDelegate {\r\n\r\n    public static Resource getResource(URL url) throws IOException {\r\n        return new VfsResource(VfsUtils.getRoot(url));\r\n    }\r\n\r\n    public static Resource getResource(URI uri) throws IOException {\r\n        return new VfsResource(VfsUtils.getRoot(uri));\r\n    }\r\n}",
    "comment": "\n * Abstract base class for resources which resolve URLs into File references,\n * such as {@link UrlResource} or {@link ClassPathResource}.\n *\n * <p>Detects the \"file\" protocol as well as the JBoss \"vfs\" protocol in URLs,\n * resolving file system references accordingly.\n *\n * @author Juergen Hoeller\n * @since 3.0\n "
  },
  {
    "entityId": "org.springframework.core.io.AbstractFileResolvingResource#exists()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean exists() {\r\n    try {\r\n        URL url = getURL();\r\n        if (ResourceUtils.isFileURL(url)) {\r\n            // Proceed with file system resolution\r\n            return getFile().exists();\r\n        } else {\r\n            // Try a URL connection content-length header\r\n            URLConnection con = url.openConnection();\r\n            customizeConnection(con);\r\n            HttpURLConnection httpCon = (con instanceof HttpURLConnection huc ? huc : null);\r\n            if (httpCon != null) {\r\n                httpCon.setRequestMethod(\"HEAD\");\r\n                int code = httpCon.getResponseCode();\r\n                if (code == HttpURLConnection.HTTP_OK) {\r\n                    return true;\r\n                } else if (code == HttpURLConnection.HTTP_NOT_FOUND) {\r\n                    return false;\r\n                } else if (code == HttpURLConnection.HTTP_BAD_METHOD) {\r\n                    con = url.openConnection();\r\n                    customizeConnection(con);\r\n                    if (con instanceof HttpURLConnection newHttpCon) {\r\n                        code = newHttpCon.getResponseCode();\r\n                        if (code == HttpURLConnection.HTTP_OK) {\r\n                            return true;\r\n                        } else if (code == HttpURLConnection.HTTP_NOT_FOUND) {\r\n                            return false;\r\n                        }\r\n                        httpCon = newHttpCon;\r\n                    }\r\n                }\r\n            }\r\n            if (con.getContentLengthLong() > 0) {\r\n                return true;\r\n            }\r\n            if (httpCon != null) {\r\n                // No HTTP OK status, and no content-length header: give up\r\n                httpCon.disconnect();\r\n                return false;\r\n            } else {\r\n                // Fall back to stream existence: can we open the stream?\r\n                getInputStream().close();\r\n                return true;\r\n            }\r\n        }\r\n    } catch (IOException ex) {\r\n        return false;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.AbstractFileResolvingResource#isReadable()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isReadable() {\r\n    try {\r\n        return checkReadable(getURL());\r\n    } catch (IOException ex) {\r\n        return false;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.AbstractFileResolvingResource#checkReadable(URL)",
    "entityType": "method",
    "code": "boolean checkReadable(URL url) {\r\n    try {\r\n        if (ResourceUtils.isFileURL(url)) {\r\n            // Proceed with file system resolution\r\n            File file = getFile();\r\n            return (file.canRead() && !file.isDirectory());\r\n        } else {\r\n            // Try InputStream resolution for jar resources\r\n            URLConnection con = url.openConnection();\r\n            customizeConnection(con);\r\n            if (con instanceof HttpURLConnection httpCon) {\r\n                httpCon.setRequestMethod(\"HEAD\");\r\n                int code = httpCon.getResponseCode();\r\n                if (code == HttpURLConnection.HTTP_BAD_METHOD) {\r\n                    con = url.openConnection();\r\n                    customizeConnection(con);\r\n                    if (!(con instanceof HttpURLConnection newHttpCon)) {\r\n                        return false;\r\n                    }\r\n                    code = newHttpCon.getResponseCode();\r\n                    httpCon = newHttpCon;\r\n                }\r\n                if (code != HttpURLConnection.HTTP_OK) {\r\n                    httpCon.disconnect();\r\n                    return false;\r\n                }\r\n            } else if (con instanceof JarURLConnection jarCon) {\r\n                JarEntry jarEntry = jarCon.getJarEntry();\r\n                if (jarEntry == null) {\r\n                    return false;\r\n                } else {\r\n                    return !jarEntry.isDirectory();\r\n                }\r\n            }\r\n            long contentLength = con.getContentLengthLong();\r\n            if (contentLength > 0) {\r\n                return true;\r\n            } else if (contentLength == 0) {\r\n                // Empty file or directory -> not considered readable...\r\n                return false;\r\n            } else {\r\n                // Fall back to stream existence: can we open the stream?\r\n                getInputStream().close();\r\n                return true;\r\n            }\r\n        }\r\n    } catch (IOException ex) {\r\n        return false;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.AbstractFileResolvingResource#isFile()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isFile() {\r\n    try {\r\n        URL url = getURL();\r\n        if (url.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {\r\n            return VfsResourceDelegate.getResource(url).isFile();\r\n        }\r\n        return ResourceUtils.URL_PROTOCOL_FILE.equals(url.getProtocol());\r\n    } catch (IOException ex) {\r\n        return false;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.AbstractFileResolvingResource#getFile()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns a File reference for the underlying class path\r\n * resource, provided that it refers to a file in the file system.\r\n * @see org.springframework.util.ResourceUtils#getFile(java.net.URL, String)\r\n */\r\n@Override\r\npublic File getFile() throws IOException {\r\n    URL url = getURL();\r\n    if (url.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {\r\n        return VfsResourceDelegate.getResource(url).getFile();\r\n    }\r\n    return ResourceUtils.getFile(url, getDescription());\r\n}",
    "comment": "\n\t * This implementation returns a File reference for the underlying class path\n\t * resource, provided that it refers to a file in the file system.\n\t * @see org.springframework.util.ResourceUtils#getFile(java.net.URL, String)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.AbstractFileResolvingResource#getFileForLastModifiedCheck()",
    "entityType": "method",
    "code": "/**\r\n * This implementation determines the underlying File\r\n * (or jar file, in case of a resource in a jar/zip).\r\n */\r\n@Override\r\nprotected File getFileForLastModifiedCheck() throws IOException {\r\n    URL url = getURL();\r\n    if (ResourceUtils.isJarURL(url)) {\r\n        URL actualUrl = ResourceUtils.extractArchiveURL(url);\r\n        if (actualUrl.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {\r\n            return VfsResourceDelegate.getResource(actualUrl).getFile();\r\n        }\r\n        return ResourceUtils.getFile(actualUrl, \"Jar URL\");\r\n    } else {\r\n        return getFile();\r\n    }\r\n}",
    "comment": "\n\t * This implementation determines the underlying File\n\t * (or jar file, in case of a resource in a jar/zip).\n\t "
  },
  {
    "entityId": "org.springframework.core.io.AbstractFileResolvingResource#isFile(URI)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given {@link URI} represents a file in a file system.\r\n * @since 5.0\r\n * @see #getFile(URI)\r\n */\r\nprotected boolean isFile(URI uri) {\r\n    try {\r\n        if (uri.getScheme().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {\r\n            return VfsResourceDelegate.getResource(uri).isFile();\r\n        }\r\n        return ResourceUtils.URL_PROTOCOL_FILE.equals(uri.getScheme());\r\n    } catch (IOException ex) {\r\n        return false;\r\n    }\r\n}",
    "comment": "\n\t * Determine whether the given {@link URI} represents a file in a file system.\n\t * @since 5.0\n\t * @see #getFile(URI)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.AbstractFileResolvingResource#getFile(URI)",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns a File reference for the given URI-identified\r\n * resource, provided that it refers to a file in the file system.\r\n * @see org.springframework.util.ResourceUtils#getFile(java.net.URI, String)\r\n */\r\nprotected File getFile(URI uri) throws IOException {\r\n    if (uri.getScheme().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {\r\n        return VfsResourceDelegate.getResource(uri).getFile();\r\n    }\r\n    return ResourceUtils.getFile(uri, getDescription());\r\n}",
    "comment": "\n\t * This implementation returns a File reference for the given URI-identified\n\t * resource, provided that it refers to a file in the file system.\n\t * @see org.springframework.util.ResourceUtils#getFile(java.net.URI, String)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.AbstractFileResolvingResource#readableChannel()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns a FileChannel for the given URI-identified\r\n * resource, provided that it refers to a file in the file system.\r\n * @since 5.0\r\n * @see #getFile()\r\n */\r\n@Override\r\npublic ReadableByteChannel readableChannel() throws IOException {\r\n    try {\r\n        // Try file system channel\r\n        return FileChannel.open(getFile().toPath(), StandardOpenOption.READ);\r\n    } catch (FileNotFoundException | NoSuchFileException ex) {\r\n        // Fall back to InputStream adaptation in superclass\r\n        return super.readableChannel();\r\n    }\r\n}",
    "comment": "\n\t * This implementation returns a FileChannel for the given URI-identified\n\t * resource, provided that it refers to a file in the file system.\n\t * @since 5.0\n\t * @see #getFile()\n\t "
  },
  {
    "entityId": "org.springframework.core.io.AbstractFileResolvingResource#contentLength()",
    "entityType": "method",
    "code": "@Override\r\npublic long contentLength() throws IOException {\r\n    URL url = getURL();\r\n    if (ResourceUtils.isFileURL(url)) {\r\n        // Proceed with file system resolution\r\n        File file = getFile();\r\n        long length = file.length();\r\n        if (length == 0L && !file.exists()) {\r\n            throw new FileNotFoundException(getDescription() + \" cannot be resolved in the file system for checking its content length\");\r\n        }\r\n        return length;\r\n    } else {\r\n        // Try a URL connection content-length header\r\n        URLConnection con = url.openConnection();\r\n        customizeConnection(con);\r\n        if (con instanceof HttpURLConnection httpCon) {\r\n            httpCon.setRequestMethod(\"HEAD\");\r\n        }\r\n        long length = con.getContentLengthLong();\r\n        if (length <= 0 && con instanceof HttpURLConnection httpCon && httpCon.getResponseCode() == HttpURLConnection.HTTP_BAD_METHOD) {\r\n            con = url.openConnection();\r\n            customizeConnection(con);\r\n            length = con.getContentLengthLong();\r\n        }\r\n        return length;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.AbstractFileResolvingResource#lastModified()",
    "entityType": "method",
    "code": "@Override\r\npublic long lastModified() throws IOException {\r\n    URL url = getURL();\r\n    boolean fileCheck = false;\r\n    if (ResourceUtils.isFileURL(url) || ResourceUtils.isJarURL(url)) {\r\n        // Proceed with file system resolution\r\n        fileCheck = true;\r\n        try {\r\n            File fileToCheck = getFileForLastModifiedCheck();\r\n            long lastModified = fileToCheck.lastModified();\r\n            if (lastModified > 0L || fileToCheck.exists()) {\r\n                return lastModified;\r\n            }\r\n        } catch (FileNotFoundException ex) {\r\n            // Defensively fall back to URL connection check instead\r\n        }\r\n    }\r\n    // Try a URL connection last-modified header\r\n    URLConnection con = url.openConnection();\r\n    customizeConnection(con);\r\n    if (con instanceof HttpURLConnection httpCon) {\r\n        httpCon.setRequestMethod(\"HEAD\");\r\n    }\r\n    long lastModified = con.getLastModified();\r\n    if (lastModified == 0) {\r\n        if (con instanceof HttpURLConnection httpCon && httpCon.getResponseCode() == HttpURLConnection.HTTP_BAD_METHOD) {\r\n            con = url.openConnection();\r\n            customizeConnection(con);\r\n            lastModified = con.getLastModified();\r\n        }\r\n        if (fileCheck && con.getContentLengthLong() <= 0) {\r\n            throw new FileNotFoundException(getDescription() + \" cannot be resolved in the file system for checking its last-modified timestamp\");\r\n        }\r\n    }\r\n    return lastModified;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.AbstractFileResolvingResource#customizeConnection(URLConnection)",
    "entityType": "method",
    "code": "/**\r\n * Customize the given {@link URLConnection} before fetching the resource.\r\n * <p>Calls {@link ResourceUtils#useCachesIfNecessary(URLConnection)} and\r\n * delegates to {@link #customizeConnection(HttpURLConnection)} if possible.\r\n * Can be overridden in subclasses.\r\n * @param con the URLConnection to customize\r\n * @throws IOException if thrown from URLConnection methods\r\n */\r\nprotected void customizeConnection(URLConnection con) throws IOException {\r\n    ResourceUtils.useCachesIfNecessary(con);\r\n    if (con instanceof HttpURLConnection httpConn) {\r\n        customizeConnection(httpConn);\r\n    }\r\n}",
    "comment": "\n\t * Customize the given {@link URLConnection} before fetching the resource.\n\t * <p>Calls {@link ResourceUtils#useCachesIfNecessary(URLConnection)} and\n\t * delegates to {@link #customizeConnection(HttpURLConnection)} if possible.\n\t * Can be overridden in subclasses.\n\t * @param con the URLConnection to customize\n\t * @throws IOException if thrown from URLConnection methods\n\t "
  },
  {
    "entityId": "org.springframework.core.io.AbstractFileResolvingResource#customizeConnection(HttpURLConnection)",
    "entityType": "method",
    "code": "/**\r\n * Customize the given {@link HttpURLConnection} before fetching the resource.\r\n * <p>Can be overridden in subclasses for configuring request headers and timeouts.\r\n * @param con the HttpURLConnection to customize\r\n * @throws IOException if thrown from HttpURLConnection methods\r\n */\r\nprotected void customizeConnection(HttpURLConnection con) throws IOException ;",
    "comment": "\n\t * Customize the given {@link HttpURLConnection} before fetching the resource.\n\t * <p>Can be overridden in subclasses for configuring request headers and timeouts.\n\t * @param con the HttpURLConnection to customize\n\t * @throws IOException if thrown from HttpURLConnection methods\n\t "
  },
  {
    "entityId": "org.springframework.core.io.VfsResourceDelegate",
    "entityType": "class",
    "code": "public static Resource getResource(URL url) throws IOException {\r\n    return new VfsResource(VfsUtils.getRoot(url));\r\n}\npublic static Resource getResource(URI uri) throws IOException {\r\n    return new VfsResource(VfsUtils.getRoot(uri));\r\n}",
    "comment": "\n\t * Inner delegate class, avoiding a hard JBoss VFS API dependency at runtime.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.VfsResourceDelegate#getResource(URL)",
    "entityType": "method",
    "code": "public static Resource getResource(URL url) throws IOException {\r\n    return new VfsResource(VfsUtils.getRoot(url));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.VfsResourceDelegate#getResource(URI)",
    "entityType": "method",
    "code": "public static Resource getResource(URI uri) throws IOException {\r\n    return new VfsResource(VfsUtils.getRoot(uri));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.AbstractResource",
    "entityType": "class",
    "code": "/**\r\n * This implementation checks whether a File can be opened,\r\n * falling back to whether an InputStream can be opened.\r\n * <p>This will cover both directories and content resources.\r\n */\r\n@Override\r\npublic boolean exists() {\r\n    // Try file existence: can we find the file in the file system?\r\n    if (isFile()) {\r\n        try {\r\n            return getFile().exists();\r\n        } catch (IOException ex) {\r\n            debug(() -> \"Could not retrieve File for existence check of \" + getDescription(), ex);\r\n        }\r\n    }\r\n    // Fall back to stream existence: can we open the stream?\r\n    try {\r\n        getInputStream().close();\r\n        return true;\r\n    } catch (Throwable ex) {\r\n        debug(() -> \"Could not retrieve InputStream for existence check of \" + getDescription(), ex);\r\n        return false;\r\n    }\r\n}\n/**\r\n * This implementation always returns {@code true} for a resource\r\n * that {@link #exists() exists} (revised as of 5.1).\r\n */\r\n@Override\r\npublic boolean isReadable() {\r\n    return exists();\r\n}\n/**\r\n * This implementation always returns {@code false}.\r\n */\r\n@Override\r\npublic boolean isOpen() {\r\n    return false;\r\n}\n/**\r\n * This implementation always returns {@code false}.\r\n */\r\n@Override\r\npublic boolean isFile() {\r\n    return false;\r\n}\n/**\r\n * This implementation throws a FileNotFoundException, assuming\r\n * that the resource cannot be resolved to a URL.\r\n */\r\n@Override\r\npublic URL getURL() throws IOException {\r\n    throw new FileNotFoundException(getDescription() + \" cannot be resolved to URL\");\r\n}\n/**\r\n * This implementation builds a URI based on the URL returned\r\n * by {@link #getURL()}.\r\n */\r\n@Override\r\npublic URI getURI() throws IOException {\r\n    URL url = getURL();\r\n    try {\r\n        return ResourceUtils.toURI(url);\r\n    } catch (URISyntaxException ex) {\r\n        throw new IOException(\"Invalid URI [\" + url + \"]\", ex);\r\n    }\r\n}\n/**\r\n * This implementation throws a FileNotFoundException, assuming\r\n * that the resource cannot be resolved to an absolute file path.\r\n */\r\n@Override\r\npublic File getFile() throws IOException {\r\n    throw new FileNotFoundException(getDescription() + \" cannot be resolved to absolute file path\");\r\n}\n/**\r\n * This implementation returns {@link Channels#newChannel(InputStream)}\r\n * with the result of {@link #getInputStream()}.\r\n * <p>This is the same as in {@link Resource}'s corresponding default method\r\n * but mirrored here for efficient JVM-level dispatching in a class hierarchy.\r\n */\r\n@Override\r\npublic ReadableByteChannel readableChannel() throws IOException {\r\n    return Channels.newChannel(getInputStream());\r\n}\n/**\r\n * This method reads the entire InputStream to determine the content length.\r\n * <p>For a custom subclass of {@code InputStreamResource}, we strongly\r\n * recommend overriding this method with a more optimal implementation, for example,\r\n * checking File length, or possibly simply returning -1 if the stream can\r\n * only be read once.\r\n * @see #getInputStream()\r\n */\r\n@Override\r\npublic long contentLength() throws IOException {\r\n    InputStream is = getInputStream();\r\n    try {\r\n        long size = 0;\r\n        byte[] buf = new byte[256];\r\n        int read;\r\n        while ((read = is.read(buf)) != -1) {\r\n            size += read;\r\n        }\r\n        return size;\r\n    } finally {\r\n        try {\r\n            is.close();\r\n        } catch (IOException ex) {\r\n            debug(() -> \"Could not close content-length InputStream for \" + getDescription(), ex);\r\n        }\r\n    }\r\n}\n/**\r\n * This implementation checks the timestamp of the underlying File,\r\n * if available.\r\n * @see #getFileForLastModifiedCheck()\r\n */\r\n@Override\r\npublic long lastModified() throws IOException {\r\n    File fileToCheck = getFileForLastModifiedCheck();\r\n    long lastModified = fileToCheck.lastModified();\r\n    if (lastModified == 0L && !fileToCheck.exists()) {\r\n        throw new FileNotFoundException(getDescription() + \" cannot be resolved in the file system for checking its last-modified timestamp\");\r\n    }\r\n    return lastModified;\r\n}\n/**\r\n * Determine the File to use for timestamp checking.\r\n * <p>The default implementation delegates to {@link #getFile()}.\r\n * @return the File to use for timestamp checking (never {@code null})\r\n * @throws FileNotFoundException if the resource cannot be resolved as\r\n * an absolute file path, i.e. is not available in a file system\r\n * @throws IOException in case of general resolution/reading failures\r\n */\r\nprotected File getFileForLastModifiedCheck() throws IOException {\r\n    return getFile();\r\n}\n/**\r\n * This implementation throws a FileNotFoundException, assuming\r\n * that relative resources cannot be created for this resource.\r\n */\r\n@Override\r\npublic Resource createRelative(String relativePath) throws IOException {\r\n    throw new FileNotFoundException(\"Cannot create a relative resource for \" + getDescription());\r\n}\n/**\r\n * This implementation always returns {@code null},\r\n * assuming that this resource type does not have a filename.\r\n */\r\n@Override\r\n@Nullable\r\npublic String getFilename() {\r\n    return null;\r\n}\n/**\r\n * Lazily access the logger for debug logging in case of an exception.\r\n */\r\nprivate void debug(Supplier<String> message, Throwable ex) {\r\n    Log logger = LogFactory.getLog(getClass());\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(message.get(), ex);\r\n    }\r\n}\n/**\r\n * This implementation compares description strings.\r\n * @see #getDescription()\r\n */\r\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof Resource that && getDescription().equals(that.getDescription())));\r\n}\n/**\r\n * This implementation returns the description's hash code.\r\n * @see #getDescription()\r\n */\r\n@Override\r\npublic int hashCode() {\r\n    return getDescription().hashCode();\r\n}\n/**\r\n * This implementation returns the description of this resource.\r\n * @see #getDescription()\r\n */\r\n@Override\r\npublic String toString() {\r\n    return getDescription();\r\n}",
    "comment": "\n * Convenience base class for {@link Resource} implementations,\n * pre-implementing typical behavior.\n *\n * <p>The \"exists\" method will check whether a File or InputStream can\n * be opened; \"isOpen\" will always return false; \"getURL\" and \"getFile\"\n * throw an exception; and \"toString\" will return the description.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 28.12.2003\n "
  },
  {
    "entityId": "org.springframework.core.io.AbstractResource#exists()",
    "entityType": "method",
    "code": "/**\r\n * This implementation checks whether a File can be opened,\r\n * falling back to whether an InputStream can be opened.\r\n * <p>This will cover both directories and content resources.\r\n */\r\n@Override\r\npublic boolean exists() {\r\n    // Try file existence: can we find the file in the file system?\r\n    if (isFile()) {\r\n        try {\r\n            return getFile().exists();\r\n        } catch (IOException ex) {\r\n            debug(() -> \"Could not retrieve File for existence check of \" + getDescription(), ex);\r\n        }\r\n    }\r\n    // Fall back to stream existence: can we open the stream?\r\n    try {\r\n        getInputStream().close();\r\n        return true;\r\n    } catch (Throwable ex) {\r\n        debug(() -> \"Could not retrieve InputStream for existence check of \" + getDescription(), ex);\r\n        return false;\r\n    }\r\n}",
    "comment": "\n\t * This implementation checks whether a File can be opened,\n\t * falling back to whether an InputStream can be opened.\n\t * <p>This will cover both directories and content resources.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.AbstractResource#isReadable()",
    "entityType": "method",
    "code": "/**\r\n * This implementation always returns {@code true} for a resource\r\n * that {@link #exists() exists} (revised as of 5.1).\r\n */\r\n@Override\r\npublic boolean isReadable() {\r\n    return exists();\r\n}",
    "comment": "\n\t * This implementation always returns {@code true} for a resource\n\t * that {@link #exists() exists} (revised as of 5.1).\n\t "
  },
  {
    "entityId": "org.springframework.core.io.AbstractResource#isOpen()",
    "entityType": "method",
    "code": "/**\r\n * This implementation always returns {@code false}.\r\n */\r\n@Override\r\npublic boolean isOpen() {\r\n    return false;\r\n}",
    "comment": "\n\t * This implementation always returns {@code false}.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.AbstractResource#isFile()",
    "entityType": "method",
    "code": "/**\r\n * This implementation always returns {@code false}.\r\n */\r\n@Override\r\npublic boolean isFile() {\r\n    return false;\r\n}",
    "comment": "\n\t * This implementation always returns {@code false}.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.AbstractResource#getURL()",
    "entityType": "method",
    "code": "/**\r\n * This implementation throws a FileNotFoundException, assuming\r\n * that the resource cannot be resolved to a URL.\r\n */\r\n@Override\r\npublic URL getURL() throws IOException {\r\n    throw new FileNotFoundException(getDescription() + \" cannot be resolved to URL\");\r\n}",
    "comment": "\n\t * This implementation throws a FileNotFoundException, assuming\n\t * that the resource cannot be resolved to a URL.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.AbstractResource#getURI()",
    "entityType": "method",
    "code": "/**\r\n * This implementation builds a URI based on the URL returned\r\n * by {@link #getURL()}.\r\n */\r\n@Override\r\npublic URI getURI() throws IOException {\r\n    URL url = getURL();\r\n    try {\r\n        return ResourceUtils.toURI(url);\r\n    } catch (URISyntaxException ex) {\r\n        throw new IOException(\"Invalid URI [\" + url + \"]\", ex);\r\n    }\r\n}",
    "comment": "\n\t * This implementation builds a URI based on the URL returned\n\t * by {@link #getURL()}.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.AbstractResource#getFile()",
    "entityType": "method",
    "code": "/**\r\n * This implementation throws a FileNotFoundException, assuming\r\n * that the resource cannot be resolved to an absolute file path.\r\n */\r\n@Override\r\npublic File getFile() throws IOException {\r\n    throw new FileNotFoundException(getDescription() + \" cannot be resolved to absolute file path\");\r\n}",
    "comment": "\n\t * This implementation throws a FileNotFoundException, assuming\n\t * that the resource cannot be resolved to an absolute file path.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.AbstractResource#readableChannel()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns {@link Channels#newChannel(InputStream)}\r\n * with the result of {@link #getInputStream()}.\r\n * <p>This is the same as in {@link Resource}'s corresponding default method\r\n * but mirrored here for efficient JVM-level dispatching in a class hierarchy.\r\n */\r\n@Override\r\npublic ReadableByteChannel readableChannel() throws IOException {\r\n    return Channels.newChannel(getInputStream());\r\n}",
    "comment": "\n\t * This implementation returns {@link Channels#newChannel(InputStream)}\n\t * with the result of {@link #getInputStream()}.\n\t * <p>This is the same as in {@link Resource}'s corresponding default method\n\t * but mirrored here for efficient JVM-level dispatching in a class hierarchy.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.AbstractResource#contentLength()",
    "entityType": "method",
    "code": "/**\r\n * This method reads the entire InputStream to determine the content length.\r\n * <p>For a custom subclass of {@code InputStreamResource}, we strongly\r\n * recommend overriding this method with a more optimal implementation, for example,\r\n * checking File length, or possibly simply returning -1 if the stream can\r\n * only be read once.\r\n * @see #getInputStream()\r\n */\r\n@Override\r\npublic long contentLength() throws IOException {\r\n    InputStream is = getInputStream();\r\n    try {\r\n        long size = 0;\r\n        byte[] buf = new byte[256];\r\n        int read;\r\n        while ((read = is.read(buf)) != -1) {\r\n            size += read;\r\n        }\r\n        return size;\r\n    } finally {\r\n        try {\r\n            is.close();\r\n        } catch (IOException ex) {\r\n            debug(() -> \"Could not close content-length InputStream for \" + getDescription(), ex);\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * This method reads the entire InputStream to determine the content length.\n\t * <p>For a custom subclass of {@code InputStreamResource}, we strongly\n\t * recommend overriding this method with a more optimal implementation, for example,\n\t * checking File length, or possibly simply returning -1 if the stream can\n\t * only be read once.\n\t * @see #getInputStream()\n\t "
  },
  {
    "entityId": "org.springframework.core.io.AbstractResource#lastModified()",
    "entityType": "method",
    "code": "/**\r\n * This implementation checks the timestamp of the underlying File,\r\n * if available.\r\n * @see #getFileForLastModifiedCheck()\r\n */\r\n@Override\r\npublic long lastModified() throws IOException {\r\n    File fileToCheck = getFileForLastModifiedCheck();\r\n    long lastModified = fileToCheck.lastModified();\r\n    if (lastModified == 0L && !fileToCheck.exists()) {\r\n        throw new FileNotFoundException(getDescription() + \" cannot be resolved in the file system for checking its last-modified timestamp\");\r\n    }\r\n    return lastModified;\r\n}",
    "comment": "\n\t * This implementation checks the timestamp of the underlying File,\n\t * if available.\n\t * @see #getFileForLastModifiedCheck()\n\t "
  },
  {
    "entityId": "org.springframework.core.io.AbstractResource#getFileForLastModifiedCheck()",
    "entityType": "method",
    "code": "/**\r\n * Determine the File to use for timestamp checking.\r\n * <p>The default implementation delegates to {@link #getFile()}.\r\n * @return the File to use for timestamp checking (never {@code null})\r\n * @throws FileNotFoundException if the resource cannot be resolved as\r\n * an absolute file path, i.e. is not available in a file system\r\n * @throws IOException in case of general resolution/reading failures\r\n */\r\nprotected File getFileForLastModifiedCheck() throws IOException {\r\n    return getFile();\r\n}",
    "comment": "\n\t * Determine the File to use for timestamp checking.\n\t * <p>The default implementation delegates to {@link #getFile()}.\n\t * @return the File to use for timestamp checking (never {@code null})\n\t * @throws FileNotFoundException if the resource cannot be resolved as\n\t * an absolute file path, i.e. is not available in a file system\n\t * @throws IOException in case of general resolution/reading failures\n\t "
  },
  {
    "entityId": "org.springframework.core.io.AbstractResource#createRelative(String)",
    "entityType": "method",
    "code": "/**\r\n * This implementation throws a FileNotFoundException, assuming\r\n * that relative resources cannot be created for this resource.\r\n */\r\n@Override\r\npublic Resource createRelative(String relativePath) throws IOException {\r\n    throw new FileNotFoundException(\"Cannot create a relative resource for \" + getDescription());\r\n}",
    "comment": "\n\t * This implementation throws a FileNotFoundException, assuming\n\t * that relative resources cannot be created for this resource.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.AbstractResource#getFilename()",
    "entityType": "method",
    "code": "/**\r\n * This implementation always returns {@code null},\r\n * assuming that this resource type does not have a filename.\r\n */\r\n@Override\r\n@Nullable\r\npublic String getFilename() {\r\n    return null;\r\n}",
    "comment": "\n\t * This implementation always returns {@code null},\n\t * assuming that this resource type does not have a filename.\n\t "
  }
]