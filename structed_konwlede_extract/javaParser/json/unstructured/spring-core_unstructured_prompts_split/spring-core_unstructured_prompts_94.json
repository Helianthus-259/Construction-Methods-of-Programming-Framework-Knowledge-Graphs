[
  {
    "entityId": "org.springframework.aot.hint.annotation.AnnotatedTypeTests#registerReflectionForMultipleTargets()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerReflectionForMultipleTargets() {\r\n    registerReflectionHints(RegistrationMultipleTargets.class);\r\n    assertThat(hints.reflection().typeHints()).allSatisfy(hasOnlyMemberCategories(MemberCategory.INVOKE_PUBLIC_METHODS));\r\n    assertThat(hints.reflection().typeHints().map(TypeHint::getType)).hasSameElementsAs(TypeReference.listOf(Number.class, Double.class, Integer.class, Float.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.AnnotatedTypeTests#registerReflectionOnTargetClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerReflectionOnTargetClass() {\r\n    registerReflectionHints(AnnotatedSimplePojo.class);\r\n    assertBasicTypeHint(AnnotatedSimplePojo.class, NO_METHODS, List.of(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.AnnotatedMethodTests",
    "entityType": "class",
    "code": "@Test\r\nvoid registerReflectionForStaticField() throws NoSuchMethodException {\r\n    Method method = RegistrationMethod.class.getDeclaredMethod(\"doReflection\");\r\n    registerReflectionHints(method);\r\n    assertBasicTypeHint(SimplePojo.class, NO_METHODS, List.of(MemberCategory.INVOKE_DECLARED_METHODS));\r\n}\n@Test\r\nvoid registerReflectionWithoutTarget() throws NoSuchMethodException {\r\n    Method method = RegistrationMethodWithoutTarget.class.getDeclaredMethod(\"doReflection\");\r\n    assertThatIllegalStateException().isThrownBy(() -> registerReflectionHints(method)).withMessageContaining(\"At least one class must be specified\").withMessageContaining(method.toString());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.AnnotatedMethodTests#registerReflectionForStaticField()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerReflectionForStaticField() throws NoSuchMethodException {\r\n    Method method = RegistrationMethod.class.getDeclaredMethod(\"doReflection\");\r\n    registerReflectionHints(method);\r\n    assertBasicTypeHint(SimplePojo.class, NO_METHODS, List.of(MemberCategory.INVOKE_DECLARED_METHODS));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.AnnotatedMethodTests#registerReflectionWithoutTarget()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerReflectionWithoutTarget() throws NoSuchMethodException {\r\n    Method method = RegistrationMethodWithoutTarget.class.getDeclaredMethod(\"doReflection\");\r\n    assertThatIllegalStateException().isThrownBy(() -> registerReflectionHints(method)).withMessageContaining(\"At least one class must be specified\").withMessageContaining(method.toString());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.RegistrationSimple",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.RegistrationMultipleTargets",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.RegistrationMethod",
    "entityType": "class",
    "code": "@RegisterReflection(classes = SimplePojo.class, memberCategories = MemberCategory.INVOKE_DECLARED_METHODS)\r\nprivate void doReflection() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.RegistrationMethod#doReflection()",
    "entityType": "method",
    "code": "@RegisterReflection(classes = SimplePojo.class, memberCategories = MemberCategory.INVOKE_DECLARED_METHODS)\r\nprivate void doReflection() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.RegistrationMethodWithoutTarget",
    "entityType": "class",
    "code": "@RegisterReflection(memberCategories = MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)\r\nprivate void doReflection() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.RegistrationMethodWithoutTarget#doReflection()",
    "entityType": "method",
    "code": "@RegisterReflection(memberCategories = MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)\r\nprivate void doReflection() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SimplePojo",
    "entityType": "class",
    "code": "private String name;\nprivate String description;\npublic String getName() {\r\n    return this.name;\r\n}\npublic void setName(String name) {\r\n    this.name = name;\r\n}\npublic String getDescription() {\r\n    return this.description;\r\n}\npublic void setDescription(String description) {\r\n    this.description = description;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SimplePojo#getName()",
    "entityType": "method",
    "code": "public String getName() {\r\n    return this.name;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SimplePojo#setName(String)",
    "entityType": "method",
    "code": "public void setName(String name) {\r\n    this.name = name;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SimplePojo#getDescription()",
    "entityType": "method",
    "code": "public String getDescription() {\r\n    return this.description;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SimplePojo#setDescription(String)",
    "entityType": "method",
    "code": "public void setDescription(String description) {\r\n    this.description = description;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.AnnotatedSimplePojo",
    "entityType": "class",
    "code": "AnnotatedSimplePojo(String test) {\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SimpleReflectiveProcessorTests",
    "entityType": "class",
    "code": "private final SimpleReflectiveProcessor processor = new SimpleReflectiveProcessor();\nprivate final ReflectionHints hints = new ReflectionHints();\n@Test\r\nvoid registerReflectiveHintsForClass() {\r\n    processor.registerReflectionHints(hints, SampleBean.class);\r\n    assertThat(hints.typeHints()).singleElement().satisfies(typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleBean.class));\r\n        assertThat(typeHint.getMemberCategories()).isEmpty();\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).isEmpty();\r\n    });\r\n}\n@Test\r\nvoid registerReflectiveHintsForConstructor() {\r\n    Constructor<?> constructor = SampleBean.class.getDeclaredConstructors()[0];\r\n    processor.registerReflectionHints(hints, constructor);\r\n    assertThat(hints.typeHints()).singleElement().satisfies(typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleBean.class));\r\n        assertThat(typeHint.getMemberCategories()).isEmpty();\r\n        assertThat(typeHint.constructors()).singleElement().satisfies(constructorHint -> {\r\n            assertThat(constructorHint.getName()).isEqualTo(\"<init>\");\r\n            assertThat(constructorHint.getMode()).isEqualTo(ExecutableMode.INVOKE);\r\n            assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class));\r\n        });\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).isEmpty();\r\n    });\r\n}\n@Test\r\nvoid registerReflectiveHintsForField() throws NoSuchFieldException {\r\n    Field field = SampleBean.class.getDeclaredField(\"name\");\r\n    processor.registerReflectionHints(hints, field);\r\n    assertThat(hints.typeHints()).singleElement().satisfies(typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleBean.class));\r\n        assertThat(typeHint.getMemberCategories()).isEmpty();\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).singleElement().satisfies(fieldHint -> assertThat(fieldHint.getName()).isEqualTo(\"name\"));\r\n        assertThat(typeHint.methods()).isEmpty();\r\n    });\r\n}\n@Test\r\nvoid registerReflectiveHintsForMethod() throws NoSuchMethodException {\r\n    Method method = SampleBean.class.getDeclaredMethod(\"setName\", String.class);\r\n    processor.registerReflectionHints(hints, method);\r\n    assertThat(hints.typeHints()).singleElement().satisfies(typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleBean.class));\r\n        assertThat(typeHint.getMemberCategories()).isEmpty();\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).singleElement().satisfies(methodHint -> {\r\n            assertThat(methodHint.getName()).isEqualTo(\"setName\");\r\n            assertThat(methodHint.getMode()).isEqualTo(ExecutableMode.INVOKE);\r\n            assertThat(methodHint.getParameterTypes()).containsExactly(TypeReference.of(String.class));\r\n        });\r\n    });\r\n}\nstatic class SampleBean {\r\n\r\n    @SuppressWarnings(\"unused\")\r\n    private String name;\r\n\r\n    SampleBean(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n}",
    "comment": "\n * Tests for {@link SimpleReflectiveProcessor}.\n *\n * @author Stephane Nicoll\n "
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SimpleReflectiveProcessorTests#registerReflectiveHintsForClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerReflectiveHintsForClass() {\r\n    processor.registerReflectionHints(hints, SampleBean.class);\r\n    assertThat(hints.typeHints()).singleElement().satisfies(typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleBean.class));\r\n        assertThat(typeHint.getMemberCategories()).isEmpty();\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).isEmpty();\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SimpleReflectiveProcessorTests#registerReflectiveHintsForConstructor()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerReflectiveHintsForConstructor() {\r\n    Constructor<?> constructor = SampleBean.class.getDeclaredConstructors()[0];\r\n    processor.registerReflectionHints(hints, constructor);\r\n    assertThat(hints.typeHints()).singleElement().satisfies(typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleBean.class));\r\n        assertThat(typeHint.getMemberCategories()).isEmpty();\r\n        assertThat(typeHint.constructors()).singleElement().satisfies(constructorHint -> {\r\n            assertThat(constructorHint.getName()).isEqualTo(\"<init>\");\r\n            assertThat(constructorHint.getMode()).isEqualTo(ExecutableMode.INVOKE);\r\n            assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class));\r\n        });\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).isEmpty();\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SimpleReflectiveProcessorTests#registerReflectiveHintsForField()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerReflectiveHintsForField() throws NoSuchFieldException {\r\n    Field field = SampleBean.class.getDeclaredField(\"name\");\r\n    processor.registerReflectionHints(hints, field);\r\n    assertThat(hints.typeHints()).singleElement().satisfies(typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleBean.class));\r\n        assertThat(typeHint.getMemberCategories()).isEmpty();\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).singleElement().satisfies(fieldHint -> assertThat(fieldHint.getName()).isEqualTo(\"name\"));\r\n        assertThat(typeHint.methods()).isEmpty();\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SimpleReflectiveProcessorTests#registerReflectiveHintsForMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerReflectiveHintsForMethod() throws NoSuchMethodException {\r\n    Method method = SampleBean.class.getDeclaredMethod(\"setName\", String.class);\r\n    processor.registerReflectionHints(hints, method);\r\n    assertThat(hints.typeHints()).singleElement().satisfies(typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleBean.class));\r\n        assertThat(typeHint.getMemberCategories()).isEmpty();\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).singleElement().satisfies(methodHint -> {\r\n            assertThat(methodHint.getName()).isEqualTo(\"setName\");\r\n            assertThat(methodHint.getMode()).isEqualTo(ExecutableMode.INVOKE);\r\n            assertThat(methodHint.getParameterTypes()).containsExactly(TypeReference.of(String.class));\r\n        });\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleBean",
    "entityType": "class",
    "code": "@SuppressWarnings(\"unused\")\r\nprivate String name;\nSampleBean(String name) {\r\n    this.name = name;\r\n}\npublic void setName(String name) {\r\n    this.name = name;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleBean#setName(String)",
    "entityType": "method",
    "code": "public void setName(String name) {\r\n    this.name = name;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrarTests",
    "entityType": "class",
    "code": "private final BindingReflectionHintsRegistrar bindingRegistrar = new BindingReflectionHintsRegistrar();\nprivate final RuntimeHints hints = new RuntimeHints();\n@Test\r\nvoid registerTypeForSerializationWithEmptyClass() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleEmptyClass.class);\r\n    assertThat(this.hints.reflection().typeHints()).singleElement().satisfies(typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleEmptyClass.class));\r\n        assertThat(typeHint.getMemberCategories()).containsExactlyInAnyOrder(MemberCategory.ACCESS_DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).isEmpty();\r\n    });\r\n}\n@Test\r\nvoid registerTypeForSerializationWithExtendingClass() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleExtendingClass.class);\r\n    assertThat(this.hints.reflection().typeHints()).satisfiesExactlyInAnyOrder(typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleEmptyClass.class));\r\n        assertThat(typeHint.getMemberCategories()).containsExactlyInAnyOrder(MemberCategory.ACCESS_DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).isEmpty();\r\n    }, typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleExtendingClass.class));\r\n        assertThat(typeHint.getMemberCategories()).containsExactlyInAnyOrder(MemberCategory.ACCESS_DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).isEmpty();\r\n    });\r\n}\n@Test\r\nvoid registerTypeForSerializationWithNoProperty() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleClassWithNoProperty.class);\r\n    assertThat(this.hints.reflection().typeHints()).singleElement().satisfies(typeHint -> assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleClassWithNoProperty.class)));\r\n}\n@Test\r\nvoid registerTypeForSerializationWithGetter() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleClassWithGetter.class);\r\n    assertThat(this.hints.reflection().typeHints()).satisfiesExactlyInAnyOrder(typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(String.class));\r\n        assertThat(typeHint.getMemberCategories()).isEmpty();\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).isEmpty();\r\n    }, typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleClassWithGetter.class));\r\n        assertThat(typeHint.methods()).singleElement().satisfies(methodHint -> {\r\n            assertThat(methodHint.getName()).isEqualTo(\"getName\");\r\n            assertThat(methodHint.getMode()).isEqualTo(ExecutableMode.INVOKE);\r\n        });\r\n    });\r\n}\n@Test\r\nvoid registerTypeForSerializationWithSetter() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleClassWithSetter.class);\r\n    assertThat(this.hints.reflection().typeHints()).satisfiesExactlyInAnyOrder(typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(String.class));\r\n        assertThat(typeHint.getMemberCategories()).isEmpty();\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).isEmpty();\r\n    }, typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleClassWithSetter.class));\r\n        assertThat(typeHint.methods()).singleElement().satisfies(methodHint -> {\r\n            assertThat(methodHint.getName()).isEqualTo(\"setName\");\r\n            assertThat(methodHint.getMode()).isEqualTo(ExecutableMode.INVOKE);\r\n        });\r\n    });\r\n}\n@Test\r\nvoid registerTypeForSerializationWithListProperty() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleClassWithListProperty.class);\r\n    assertThat(this.hints.reflection().typeHints()).satisfiesExactlyInAnyOrder(typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(String.class));\r\n        assertThat(typeHint.getMemberCategories()).isEmpty();\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).isEmpty();\r\n    }, typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(List.class));\r\n        assertThat(typeHint.getMemberCategories()).isEmpty();\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).isEmpty();\r\n    }, typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleClassWithListProperty.class));\r\n        assertThat(typeHint.methods()).satisfiesExactlyInAnyOrder(methodHint -> {\r\n            assertThat(methodHint.getName()).isEqualTo(\"setNames\");\r\n            assertThat(methodHint.getMode()).isEqualTo(ExecutableMode.INVOKE);\r\n        }, methodHint -> {\r\n            assertThat(methodHint.getName()).isEqualTo(\"getNames\");\r\n            assertThat(methodHint.getMode()).isEqualTo(ExecutableMode.INVOKE);\r\n        });\r\n    });\r\n}\n@Test\r\nvoid registerTypeForSerializationWithCycles() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleClassWithCycles.class);\r\n    assertThat(this.hints.reflection().typeHints()).satisfiesExactlyInAnyOrder(typeHint -> assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleClassWithCycles.class)), typeHint -> assertThat(typeHint.getType()).isEqualTo(TypeReference.of(List.class)));\r\n}\n@Test\r\nvoid registerTypeForSerializationWithResolvableType() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleClassWithResolvableType.class);\r\n    assertThat(this.hints.reflection().typeHints()).satisfiesExactlyInAnyOrder(typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(ResolvableType[].class));\r\n        assertThat(typeHint.getMemberCategories()).isEmpty();\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).isEmpty();\r\n    }, typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(Type.class));\r\n        assertThat(typeHint.getMemberCategories()).isEmpty();\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).isEmpty();\r\n    }, typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(Class.class));\r\n        assertThat(typeHint.getMemberCategories()).isEmpty();\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).isEmpty();\r\n    }, typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(ResolvableType.class));\r\n        assertThat(typeHint.getMemberCategories()).containsExactlyInAnyOrder(MemberCategory.ACCESS_DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).hasSizeGreaterThan(1);\r\n    }, typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleClassWithResolvableType.class));\r\n        assertThat(typeHint.methods()).singleElement().satisfies(methodHint -> {\r\n            assertThat(methodHint.getName()).isEqualTo(\"getResolvableType\");\r\n            assertThat(methodHint.getMode()).isEqualTo(ExecutableMode.INVOKE);\r\n        });\r\n    });\r\n}\n@Test\r\nvoid registerTypeForSerializationWithMultipleLevelsAndCollection() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleClassA.class);\r\n    assertThat(this.hints.reflection().typeHints()).satisfiesExactlyInAnyOrder(typeHint -> assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleClassA.class)), typeHint -> assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleClassB.class)), typeHint -> assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleClassC.class)), typeHint -> assertThat(typeHint.getType()).isEqualTo(TypeReference.of(String.class)), typeHint -> assertThat(typeHint.getType()).isEqualTo(TypeReference.of(Set.class)));\r\n}\n@Test\r\nvoid registerTypeForSerializationWithEnum() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleEnum.class);\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(SampleEnum.class).withMemberCategories(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS, MemberCategory.INVOKE_PUBLIC_METHODS)).accepts(this.hints);\r\n}\n@Test\r\nvoid registerTypeForSerializationWithRecord() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleRecord.class);\r\n    assertThat(this.hints.reflection().typeHints()).satisfiesExactlyInAnyOrder(typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(String.class));\r\n        assertThat(typeHint.getMemberCategories()).isEmpty();\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).isEmpty();\r\n    }, typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleRecord.class));\r\n        assertThat(typeHint.methods()).singleElement().satisfies(methodHint -> {\r\n            assertThat(methodHint.getName()).isEqualTo(\"name\");\r\n            assertThat(methodHint.getMode()).isEqualTo(ExecutableMode.INVOKE);\r\n        });\r\n    });\r\n}\n@Test\r\nvoid registerTypeForSerializationWithRecordWithProperty() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleRecordWithProperty.class);\r\n    assertThat(RuntimeHintsPredicates.reflection().onMethodInvocation(SampleRecordWithProperty.class, \"getNameProperty\")).accepts(this.hints);\r\n}\n@Test\r\nvoid registerTypeForSerializationWithAnonymousClass() {\r\n    Runnable anonymousRunnable = () -> ;;\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), anonymousRunnable.getClass());\r\n}\n@Test\r\nvoid registerTypeForJacksonAnnotations() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleClassWithJsonProperty.class);\r\n    assertThat(RuntimeHintsPredicates.reflection().onFieldAccess(SampleClassWithJsonProperty.class, \"privateField\")).accepts(this.hints);\r\n    assertThat(RuntimeHintsPredicates.reflection().onMethodInvocation(SampleClassWithJsonProperty.class, \"packagePrivateMethod\")).accepts(this.hints);\r\n}\n@Test\r\nvoid registerTypeForInheritedJacksonAnnotations() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleClassWithInheritedJsonProperty.class);\r\n    assertThat(RuntimeHintsPredicates.reflection().onFieldAccess(SampleClassWithJsonProperty.class, \"privateField\")).accepts(this.hints);\r\n    assertThat(RuntimeHintsPredicates.reflection().onMethodInvocation(SampleClassWithJsonProperty.class, \"packagePrivateMethod\")).accepts(this.hints);\r\n}\n@Test\r\nvoid registerTypeForJacksonCustomStrategy() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleRecordWithJacksonCustomStrategy.class);\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(PropertyNamingStrategies.UpperSnakeCaseStrategy.class).withMemberCategory(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)).accepts(this.hints);\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(SampleRecordWithJacksonCustomStrategy.Builder.class).withMemberCategories(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS)).accepts(this.hints);\r\n}\n@Test\r\nvoid registerTypeForAnnotationOnMethodAndField() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleClassWithJsonProperty.class);\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(CustomDeserializer1.class).withMemberCategory(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)).accepts(this.hints);\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(CustomDeserializer2.class).withMemberCategory(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)).accepts(this.hints);\r\n}\nstatic class SampleEmptyClass {\r\n}\nstatic class SampleExtendingClass extends SampleEmptyClass {\r\n}\nstatic class SampleClassWithNoProperty {\r\n\r\n    String name() {\r\n        return null;\r\n    }\r\n}\nstatic class SampleClassWithGetter {\r\n\r\n    public String getName() {\r\n        return null;\r\n    }\r\n\r\n    public SampleEmptyClass unmanaged() {\r\n        return null;\r\n    }\r\n}\nstatic class SampleClassWithSetter {\r\n\r\n    public void setName(String name) {\r\n    }\r\n\r\n    public SampleEmptyClass unmanaged() {\r\n        return null;\r\n    }\r\n}\nstatic class SampleClassWithListProperty {\r\n\r\n    public List<String> getNames() {\r\n        return null;\r\n    }\r\n\r\n    public void setNames(List<String> names) {\r\n    }\r\n}\nstatic class SampleClassWithCycles {\r\n\r\n    public SampleClassWithCycles getSampleClassWithCycles() {\r\n        return null;\r\n    }\r\n\r\n    public List<SampleClassWithCycles> getSampleClassWithCyclesList() {\r\n        return null;\r\n    }\r\n}\nstatic class SampleClassWithResolvableType {\r\n\r\n    public ResolvableType getResolvableType() {\r\n        return null;\r\n    }\r\n}\nstatic class SampleClassA {\r\n\r\n    public Set<SampleClassB> getB() {\r\n        return null;\r\n    }\r\n}\nstatic class SampleClassB {\r\n\r\n    public SampleClassC getC() {\r\n        return null;\r\n    }\r\n}\nstatic class SampleClassC {\r\n\r\n    public String getString() {\r\n        return \"\";\r\n    }\r\n}\nenum SampleEnum {\r\n\r\n    value1, value2\r\n}\nrecord SampleRecord(String name) {\r\n}\nrecord SampleRecordWithProperty(String name) {\r\n\r\n    public String getNameProperty() {\r\n        return \"\";\r\n    }\r\n}\nstatic class SampleClassWithJsonProperty {\r\n\r\n    @JsonProperty\r\n    @JsonDeserialize(using = CustomDeserializer1.class)\r\n    private String privateField = \"\";\r\n\r\n    @JsonProperty\r\n    @JsonDeserialize(using = CustomDeserializer2.class)\r\n    String packagePrivateMethod() {\r\n        return \"\";\r\n    }\r\n}\nstatic class SampleClassWithInheritedJsonProperty extends SampleClassWithJsonProperty {\r\n}\n@JsonNaming(PropertyNamingStrategies.UpperSnakeCaseStrategy.class)\r\n@JsonDeserialize(builder = SampleRecordWithJacksonCustomStrategy.Builder.class)\r\nrecord SampleRecordWithJacksonCustomStrategy(String name) {\r\n\r\n    @JsonPOJOBuilder(withPrefix = \"\")\r\n    public static class Builder {\r\n\r\n        private String name;\r\n\r\n        public static Builder newInstance() {\r\n            return new Builder();\r\n        }\r\n\r\n        public Builder name(String name) {\r\n            this.name = name;\r\n            return this;\r\n        }\r\n\r\n        public SampleRecordWithJacksonCustomStrategy build() {\r\n            return new SampleRecordWithJacksonCustomStrategy(name);\r\n        }\r\n    }\r\n}\n@SuppressWarnings(\"serial\")\r\nstatic class CustomDeserializer1 extends StdDeserializer<LocalDate> {\r\n\r\n    public CustomDeserializer1() {\r\n        super(CustomDeserializer1.class);\r\n    }\r\n\r\n    @Override\r\n    public LocalDate deserialize(JsonParser p, DeserializationContext ctxt) {\r\n        return null;\r\n    }\r\n}\n@SuppressWarnings(\"serial\")\r\nstatic class CustomDeserializer2 extends StdDeserializer<LocalDate> {\r\n\r\n    public CustomDeserializer2() {\r\n        super(CustomDeserializer2.class);\r\n    }\r\n\r\n    @Override\r\n    public LocalDate deserialize(JsonParser p, DeserializationContext ctxt) {\r\n        return null;\r\n    }\r\n}",
    "comment": "\n * Tests for {@link BindingReflectionHintsRegistrar}.\n *\n * @author Sebastien Deleuze\n "
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrarTests#registerTypeForSerializationWithEmptyClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerTypeForSerializationWithEmptyClass() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleEmptyClass.class);\r\n    assertThat(this.hints.reflection().typeHints()).singleElement().satisfies(typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleEmptyClass.class));\r\n        assertThat(typeHint.getMemberCategories()).containsExactlyInAnyOrder(MemberCategory.ACCESS_DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).isEmpty();\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrarTests#registerTypeForSerializationWithExtendingClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerTypeForSerializationWithExtendingClass() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleExtendingClass.class);\r\n    assertThat(this.hints.reflection().typeHints()).satisfiesExactlyInAnyOrder(typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleEmptyClass.class));\r\n        assertThat(typeHint.getMemberCategories()).containsExactlyInAnyOrder(MemberCategory.ACCESS_DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).isEmpty();\r\n    }, typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleExtendingClass.class));\r\n        assertThat(typeHint.getMemberCategories()).containsExactlyInAnyOrder(MemberCategory.ACCESS_DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).isEmpty();\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrarTests#registerTypeForSerializationWithNoProperty()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerTypeForSerializationWithNoProperty() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleClassWithNoProperty.class);\r\n    assertThat(this.hints.reflection().typeHints()).singleElement().satisfies(typeHint -> assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleClassWithNoProperty.class)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrarTests#registerTypeForSerializationWithGetter()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerTypeForSerializationWithGetter() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleClassWithGetter.class);\r\n    assertThat(this.hints.reflection().typeHints()).satisfiesExactlyInAnyOrder(typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(String.class));\r\n        assertThat(typeHint.getMemberCategories()).isEmpty();\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).isEmpty();\r\n    }, typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleClassWithGetter.class));\r\n        assertThat(typeHint.methods()).singleElement().satisfies(methodHint -> {\r\n            assertThat(methodHint.getName()).isEqualTo(\"getName\");\r\n            assertThat(methodHint.getMode()).isEqualTo(ExecutableMode.INVOKE);\r\n        });\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrarTests#registerTypeForSerializationWithSetter()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerTypeForSerializationWithSetter() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleClassWithSetter.class);\r\n    assertThat(this.hints.reflection().typeHints()).satisfiesExactlyInAnyOrder(typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(String.class));\r\n        assertThat(typeHint.getMemberCategories()).isEmpty();\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).isEmpty();\r\n    }, typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleClassWithSetter.class));\r\n        assertThat(typeHint.methods()).singleElement().satisfies(methodHint -> {\r\n            assertThat(methodHint.getName()).isEqualTo(\"setName\");\r\n            assertThat(methodHint.getMode()).isEqualTo(ExecutableMode.INVOKE);\r\n        });\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrarTests#registerTypeForSerializationWithListProperty()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerTypeForSerializationWithListProperty() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleClassWithListProperty.class);\r\n    assertThat(this.hints.reflection().typeHints()).satisfiesExactlyInAnyOrder(typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(String.class));\r\n        assertThat(typeHint.getMemberCategories()).isEmpty();\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).isEmpty();\r\n    }, typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(List.class));\r\n        assertThat(typeHint.getMemberCategories()).isEmpty();\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).isEmpty();\r\n    }, typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleClassWithListProperty.class));\r\n        assertThat(typeHint.methods()).satisfiesExactlyInAnyOrder(methodHint -> {\r\n            assertThat(methodHint.getName()).isEqualTo(\"setNames\");\r\n            assertThat(methodHint.getMode()).isEqualTo(ExecutableMode.INVOKE);\r\n        }, methodHint -> {\r\n            assertThat(methodHint.getName()).isEqualTo(\"getNames\");\r\n            assertThat(methodHint.getMode()).isEqualTo(ExecutableMode.INVOKE);\r\n        });\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrarTests#registerTypeForSerializationWithCycles()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerTypeForSerializationWithCycles() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleClassWithCycles.class);\r\n    assertThat(this.hints.reflection().typeHints()).satisfiesExactlyInAnyOrder(typeHint -> assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleClassWithCycles.class)), typeHint -> assertThat(typeHint.getType()).isEqualTo(TypeReference.of(List.class)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrarTests#registerTypeForSerializationWithResolvableType()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerTypeForSerializationWithResolvableType() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleClassWithResolvableType.class);\r\n    assertThat(this.hints.reflection().typeHints()).satisfiesExactlyInAnyOrder(typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(ResolvableType[].class));\r\n        assertThat(typeHint.getMemberCategories()).isEmpty();\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).isEmpty();\r\n    }, typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(Type.class));\r\n        assertThat(typeHint.getMemberCategories()).isEmpty();\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).isEmpty();\r\n    }, typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(Class.class));\r\n        assertThat(typeHint.getMemberCategories()).isEmpty();\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).isEmpty();\r\n    }, typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(ResolvableType.class));\r\n        assertThat(typeHint.getMemberCategories()).containsExactlyInAnyOrder(MemberCategory.ACCESS_DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).hasSizeGreaterThan(1);\r\n    }, typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleClassWithResolvableType.class));\r\n        assertThat(typeHint.methods()).singleElement().satisfies(methodHint -> {\r\n            assertThat(methodHint.getName()).isEqualTo(\"getResolvableType\");\r\n            assertThat(methodHint.getMode()).isEqualTo(ExecutableMode.INVOKE);\r\n        });\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrarTests#registerTypeForSerializationWithMultipleLevelsAndCollection()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerTypeForSerializationWithMultipleLevelsAndCollection() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleClassA.class);\r\n    assertThat(this.hints.reflection().typeHints()).satisfiesExactlyInAnyOrder(typeHint -> assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleClassA.class)), typeHint -> assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleClassB.class)), typeHint -> assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleClassC.class)), typeHint -> assertThat(typeHint.getType()).isEqualTo(TypeReference.of(String.class)), typeHint -> assertThat(typeHint.getType()).isEqualTo(TypeReference.of(Set.class)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrarTests#registerTypeForSerializationWithEnum()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerTypeForSerializationWithEnum() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleEnum.class);\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(SampleEnum.class).withMemberCategories(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS, MemberCategory.INVOKE_PUBLIC_METHODS)).accepts(this.hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrarTests#registerTypeForSerializationWithRecord()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerTypeForSerializationWithRecord() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleRecord.class);\r\n    assertThat(this.hints.reflection().typeHints()).satisfiesExactlyInAnyOrder(typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(String.class));\r\n        assertThat(typeHint.getMemberCategories()).isEmpty();\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).isEmpty();\r\n    }, typeHint -> {\r\n        assertThat(typeHint.getType()).isEqualTo(TypeReference.of(SampleRecord.class));\r\n        assertThat(typeHint.methods()).singleElement().satisfies(methodHint -> {\r\n            assertThat(methodHint.getName()).isEqualTo(\"name\");\r\n            assertThat(methodHint.getMode()).isEqualTo(ExecutableMode.INVOKE);\r\n        });\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrarTests#registerTypeForSerializationWithRecordWithProperty()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerTypeForSerializationWithRecordWithProperty() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleRecordWithProperty.class);\r\n    assertThat(RuntimeHintsPredicates.reflection().onMethodInvocation(SampleRecordWithProperty.class, \"getNameProperty\")).accepts(this.hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrarTests#registerTypeForSerializationWithAnonymousClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerTypeForSerializationWithAnonymousClass() {\r\n    Runnable anonymousRunnable = () -> ;;\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), anonymousRunnable.getClass());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrarTests#registerTypeForJacksonAnnotations()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerTypeForJacksonAnnotations() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleClassWithJsonProperty.class);\r\n    assertThat(RuntimeHintsPredicates.reflection().onFieldAccess(SampleClassWithJsonProperty.class, \"privateField\")).accepts(this.hints);\r\n    assertThat(RuntimeHintsPredicates.reflection().onMethodInvocation(SampleClassWithJsonProperty.class, \"packagePrivateMethod\")).accepts(this.hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrarTests#registerTypeForInheritedJacksonAnnotations()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerTypeForInheritedJacksonAnnotations() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleClassWithInheritedJsonProperty.class);\r\n    assertThat(RuntimeHintsPredicates.reflection().onFieldAccess(SampleClassWithJsonProperty.class, \"privateField\")).accepts(this.hints);\r\n    assertThat(RuntimeHintsPredicates.reflection().onMethodInvocation(SampleClassWithJsonProperty.class, \"packagePrivateMethod\")).accepts(this.hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrarTests#registerTypeForJacksonCustomStrategy()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerTypeForJacksonCustomStrategy() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleRecordWithJacksonCustomStrategy.class);\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(PropertyNamingStrategies.UpperSnakeCaseStrategy.class).withMemberCategory(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)).accepts(this.hints);\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(SampleRecordWithJacksonCustomStrategy.Builder.class).withMemberCategories(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS)).accepts(this.hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrarTests#registerTypeForAnnotationOnMethodAndField()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerTypeForAnnotationOnMethodAndField() {\r\n    bindingRegistrar.registerReflectionHints(this.hints.reflection(), SampleClassWithJsonProperty.class);\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(CustomDeserializer1.class).withMemberCategory(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)).accepts(this.hints);\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(CustomDeserializer2.class).withMemberCategory(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)).accepts(this.hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SampleEmptyClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SampleExtendingClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SampleClassWithNoProperty",
    "entityType": "class",
    "code": "String name() {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SampleClassWithNoProperty#name()",
    "entityType": "method",
    "code": "String name() {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SampleClassWithGetter",
    "entityType": "class",
    "code": "public String getName() {\r\n    return null;\r\n}\npublic SampleEmptyClass unmanaged() {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SampleClassWithGetter#getName()",
    "entityType": "method",
    "code": "public String getName() {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SampleClassWithGetter#unmanaged()",
    "entityType": "method",
    "code": "public SampleEmptyClass unmanaged() {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SampleClassWithSetter",
    "entityType": "class",
    "code": "public void setName(String name) ;\npublic SampleEmptyClass unmanaged() {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SampleClassWithSetter#setName(String)",
    "entityType": "method",
    "code": "public void setName(String name) ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SampleClassWithSetter#unmanaged()",
    "entityType": "method",
    "code": "public SampleEmptyClass unmanaged() {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SampleClassWithListProperty",
    "entityType": "class",
    "code": "public List<String> getNames() {\r\n    return null;\r\n}\npublic void setNames(List<String> names) ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SampleClassWithListProperty#getNames()",
    "entityType": "method",
    "code": "public List<String> getNames() {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SampleClassWithListProperty#setNames(List<String>)",
    "entityType": "method",
    "code": "public void setNames(List<String> names) ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SampleClassWithCycles",
    "entityType": "class",
    "code": "public SampleClassWithCycles getSampleClassWithCycles() {\r\n    return null;\r\n}\npublic List<SampleClassWithCycles> getSampleClassWithCyclesList() {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SampleClassWithCycles#getSampleClassWithCycles()",
    "entityType": "method",
    "code": "public SampleClassWithCycles getSampleClassWithCycles() {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SampleClassWithCycles#getSampleClassWithCyclesList()",
    "entityType": "method",
    "code": "public List<SampleClassWithCycles> getSampleClassWithCyclesList() {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SampleClassWithResolvableType",
    "entityType": "class",
    "code": "public ResolvableType getResolvableType() {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SampleClassWithResolvableType#getResolvableType()",
    "entityType": "method",
    "code": "public ResolvableType getResolvableType() {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SampleClassA",
    "entityType": "class",
    "code": "public Set<SampleClassB> getB() {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SampleClassA#getB()",
    "entityType": "method",
    "code": "public Set<SampleClassB> getB() {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SampleClassB",
    "entityType": "class",
    "code": "public SampleClassC getC() {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SampleClassB#getC()",
    "entityType": "method",
    "code": "public SampleClassC getC() {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SampleClassC",
    "entityType": "class",
    "code": "public String getString() {\r\n    return \"\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SampleClassC#getString()",
    "entityType": "method",
    "code": "public String getString() {\r\n    return \"\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SampleClassWithJsonProperty",
    "entityType": "class",
    "code": "@JsonProperty\r\n@JsonDeserialize(using = CustomDeserializer1.class)\r\nprivate String privateField = \"\";\n@JsonProperty\r\n@JsonDeserialize(using = CustomDeserializer2.class)\r\nString packagePrivateMethod() {\r\n    return \"\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SampleClassWithJsonProperty#packagePrivateMethod()",
    "entityType": "method",
    "code": "@JsonProperty\r\n@JsonDeserialize(using = CustomDeserializer2.class)\r\nString packagePrivateMethod() {\r\n    return \"\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SampleClassWithInheritedJsonProperty",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.Builder",
    "entityType": "class",
    "code": "private String name;\npublic static Builder newInstance() {\r\n    return new Builder();\r\n}\npublic Builder name(String name) {\r\n    this.name = name;\r\n    return this;\r\n}\npublic SampleRecordWithJacksonCustomStrategy build() {\r\n    return new SampleRecordWithJacksonCustomStrategy(name);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.Builder#newInstance()",
    "entityType": "method",
    "code": "public static Builder newInstance() {\r\n    return new Builder();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.Builder#name(String)",
    "entityType": "method",
    "code": "public Builder name(String name) {\r\n    this.name = name;\r\n    return this;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.Builder#build()",
    "entityType": "method",
    "code": "public SampleRecordWithJacksonCustomStrategy build() {\r\n    return new SampleRecordWithJacksonCustomStrategy(name);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.CustomDeserializer1",
    "entityType": "class",
    "code": "public CustomDeserializer1() {\r\n    super(CustomDeserializer1.class);\r\n}\n@Override\r\npublic LocalDate deserialize(JsonParser p, DeserializationContext ctxt) {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.CustomDeserializer1#deserialize(JsonParser,DeserializationContext)",
    "entityType": "method",
    "code": "@Override\r\npublic LocalDate deserialize(JsonParser p, DeserializationContext ctxt) {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.CustomDeserializer2",
    "entityType": "class",
    "code": "public CustomDeserializer2() {\r\n    super(CustomDeserializer2.class);\r\n}\n@Override\r\npublic LocalDate deserialize(JsonParser p, DeserializationContext ctxt) {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.CustomDeserializer2#deserialize(JsonParser,DeserializationContext)",
    "entityType": "method",
    "code": "@Override\r\npublic LocalDate deserialize(JsonParser p, DeserializationContext ctxt) {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.ExecutableHintTests",
    "entityType": "class",
    "code": "@Test\r\nvoid builtWithAppliesMode() {\r\n    ExecutableHint.Builder builder = new ExecutableHint.Builder(\"test\", Collections.emptyList());\r\n    assertThat(builder.build().getMode()).isEqualTo(ExecutableMode.INVOKE);\r\n    ExecutableHint.builtWith(ExecutableMode.INTROSPECT).accept(builder);\r\n    assertThat(builder.build().getMode()).isEqualTo(ExecutableMode.INTROSPECT);\r\n}",
    "comment": "\n * Tests for {@link ExecutableHint}.\n *\n * @author Phillip Webb\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.hint.ExecutableHintTests#builtWithAppliesMode()",
    "entityType": "method",
    "code": "@Test\r\nvoid builtWithAppliesMode() {\r\n    ExecutableHint.Builder builder = new ExecutableHint.Builder(\"test\", Collections.emptyList());\r\n    assertThat(builder.build().getMode()).isEqualTo(ExecutableMode.INVOKE);\r\n    ExecutableHint.builtWith(ExecutableMode.INTROSPECT).accept(builder);\r\n    assertThat(builder.build().getMode()).isEqualTo(ExecutableMode.INTROSPECT);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.ExecutableModeTests",
    "entityType": "class",
    "code": "@Test\r\nvoid invokeIncludesNullMode() {\r\n    assertThat(ExecutableMode.INVOKE.includes(null)).isTrue();\r\n}\n@Test\r\nvoid invokeIncludesIntrospect() {\r\n    assertThat(ExecutableMode.INVOKE.includes(ExecutableMode.INTROSPECT)).isTrue();\r\n}\n@Test\r\nvoid invokeIncludesIncludes() {\r\n    assertThat(ExecutableMode.INVOKE.includes(ExecutableMode.INVOKE)).isTrue();\r\n}\n@Test\r\nvoid introspectIncludesNullMode() {\r\n    assertThat(ExecutableMode.INTROSPECT.includes(null)).isTrue();\r\n}\n@Test\r\nvoid introspectIncludesIntrospect() {\r\n    assertThat(ExecutableMode.INTROSPECT.includes(ExecutableMode.INTROSPECT)).isTrue();\r\n}\n@Test\r\nvoid introspectDoesNotIncludeInvoke() {\r\n    assertThat(ExecutableMode.INTROSPECT.includes(ExecutableMode.INVOKE)).isFalse();\r\n}",
    "comment": "\n * Tests for {@link ExecutableMode}.\n *\n * @author Stephane Nicoll\n "
  },
  {
    "entityId": "org.springframework.aot.hint.ExecutableModeTests#invokeIncludesNullMode()",
    "entityType": "method",
    "code": "@Test\r\nvoid invokeIncludesNullMode() {\r\n    assertThat(ExecutableMode.INVOKE.includes(null)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.ExecutableModeTests#invokeIncludesIntrospect()",
    "entityType": "method",
    "code": "@Test\r\nvoid invokeIncludesIntrospect() {\r\n    assertThat(ExecutableMode.INVOKE.includes(ExecutableMode.INTROSPECT)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.ExecutableModeTests#invokeIncludesIncludes()",
    "entityType": "method",
    "code": "@Test\r\nvoid invokeIncludesIncludes() {\r\n    assertThat(ExecutableMode.INVOKE.includes(ExecutableMode.INVOKE)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.ExecutableModeTests#introspectIncludesNullMode()",
    "entityType": "method",
    "code": "@Test\r\nvoid introspectIncludesNullMode() {\r\n    assertThat(ExecutableMode.INTROSPECT.includes(null)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.ExecutableModeTests#introspectIncludesIntrospect()",
    "entityType": "method",
    "code": "@Test\r\nvoid introspectIncludesIntrospect() {\r\n    assertThat(ExecutableMode.INTROSPECT.includes(ExecutableMode.INTROSPECT)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.ExecutableModeTests#introspectDoesNotIncludeInvoke()",
    "entityType": "method",
    "code": "@Test\r\nvoid introspectDoesNotIncludeInvoke() {\r\n    assertThat(ExecutableMode.INTROSPECT.includes(ExecutableMode.INVOKE)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.JdkProxyHintTests",
    "entityType": "class",
    "code": "@Test\r\nvoid equalsWithSameInstanceIsTrue() {\r\n    JdkProxyHint hint = new Builder().proxiedInterfaces(Function.class, Consumer.class).build();\r\n    assertThat(hint).isEqualTo(hint);\r\n}\n@Test\r\nvoid equalsWithSameProxiedInterfacesIsTrue() {\r\n    JdkProxyHint first = new Builder().proxiedInterfaces(Function.class, Consumer.class).build();\r\n    JdkProxyHint second = new Builder().proxiedInterfaces(TypeReference.of(Function.class.getName()), TypeReference.of(Consumer.class)).build();\r\n    assertThat(first).isEqualTo(second);\r\n}\n@Test\r\nvoid equalsWithSameProxiedInterfacesAndDifferentConditionIsFalse() {\r\n    JdkProxyHint first = new Builder().proxiedInterfaces(Function.class, Consumer.class).onReachableType(TypeReference.of(String.class)).build();\r\n    JdkProxyHint second = new Builder().proxiedInterfaces(TypeReference.of(Function.class.getName()), TypeReference.of(Consumer.class)).onReachableType(TypeReference.of(Function.class)).build();\r\n    assertThat(first).isNotEqualTo(second);\r\n}\n@Test\r\nvoid equalsWithSameProxiedInterfacesDifferentOrderIsFalse() {\r\n    JdkProxyHint first = new Builder().proxiedInterfaces(Function.class, Consumer.class).build();\r\n    JdkProxyHint second = new Builder().proxiedInterfaces(TypeReference.of(Consumer.class), TypeReference.of(Function.class.getName())).build();\r\n    assertThat(first).isNotEqualTo(second);\r\n}\n@Test\r\nvoid equalsWithDifferentProxiedInterfacesIsFalse() {\r\n    JdkProxyHint first = new Builder().proxiedInterfaces(Function.class).build();\r\n    JdkProxyHint second = new Builder().proxiedInterfaces(TypeReference.of(Function.class.getName()), TypeReference.of(Consumer.class)).build();\r\n    assertThat(first).isNotEqualTo(second);\r\n}\n@Test\r\nvoid equalsWithNonJdkProxyHintIsFalse() {\r\n    JdkProxyHint first = new Builder().proxiedInterfaces(Function.class).build();\r\n    TypeReference second = TypeReference.of(Function.class);\r\n    assertThat(first).isNotEqualTo(second);\r\n}",
    "comment": "\n * Tests for {@link JdkProxyHint}.\n *\n * @author Stephane Nicoll\n "
  },
  {
    "entityId": "org.springframework.aot.hint.JdkProxyHintTests#equalsWithSameInstanceIsTrue()",
    "entityType": "method",
    "code": "@Test\r\nvoid equalsWithSameInstanceIsTrue() {\r\n    JdkProxyHint hint = new Builder().proxiedInterfaces(Function.class, Consumer.class).build();\r\n    assertThat(hint).isEqualTo(hint);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.JdkProxyHintTests#equalsWithSameProxiedInterfacesIsTrue()",
    "entityType": "method",
    "code": "@Test\r\nvoid equalsWithSameProxiedInterfacesIsTrue() {\r\n    JdkProxyHint first = new Builder().proxiedInterfaces(Function.class, Consumer.class).build();\r\n    JdkProxyHint second = new Builder().proxiedInterfaces(TypeReference.of(Function.class.getName()), TypeReference.of(Consumer.class)).build();\r\n    assertThat(first).isEqualTo(second);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.JdkProxyHintTests#equalsWithSameProxiedInterfacesAndDifferentConditionIsFalse()",
    "entityType": "method",
    "code": "@Test\r\nvoid equalsWithSameProxiedInterfacesAndDifferentConditionIsFalse() {\r\n    JdkProxyHint first = new Builder().proxiedInterfaces(Function.class, Consumer.class).onReachableType(TypeReference.of(String.class)).build();\r\n    JdkProxyHint second = new Builder().proxiedInterfaces(TypeReference.of(Function.class.getName()), TypeReference.of(Consumer.class)).onReachableType(TypeReference.of(Function.class)).build();\r\n    assertThat(first).isNotEqualTo(second);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.JdkProxyHintTests#equalsWithSameProxiedInterfacesDifferentOrderIsFalse()",
    "entityType": "method",
    "code": "@Test\r\nvoid equalsWithSameProxiedInterfacesDifferentOrderIsFalse() {\r\n    JdkProxyHint first = new Builder().proxiedInterfaces(Function.class, Consumer.class).build();\r\n    JdkProxyHint second = new Builder().proxiedInterfaces(TypeReference.of(Consumer.class), TypeReference.of(Function.class.getName())).build();\r\n    assertThat(first).isNotEqualTo(second);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.JdkProxyHintTests#equalsWithDifferentProxiedInterfacesIsFalse()",
    "entityType": "method",
    "code": "@Test\r\nvoid equalsWithDifferentProxiedInterfacesIsFalse() {\r\n    JdkProxyHint first = new Builder().proxiedInterfaces(Function.class).build();\r\n    JdkProxyHint second = new Builder().proxiedInterfaces(TypeReference.of(Function.class.getName()), TypeReference.of(Consumer.class)).build();\r\n    assertThat(first).isNotEqualTo(second);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.JdkProxyHintTests#equalsWithNonJdkProxyHintIsFalse()",
    "entityType": "method",
    "code": "@Test\r\nvoid equalsWithNonJdkProxyHintIsFalse() {\r\n    JdkProxyHint first = new Builder().proxiedInterfaces(Function.class).build();\r\n    TypeReference second = TypeReference.of(Function.class);\r\n    assertThat(first).isNotEqualTo(second);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ProxyHintsPredicatesTests",
    "entityType": "class",
    "code": "private final ProxyHintsPredicates proxy = new ProxyHintsPredicates();\nprivate RuntimeHints runtimeHints;\n@BeforeEach\r\nvoid setup() {\r\n    this.runtimeHints = new RuntimeHints();\r\n}\n@Test\r\nvoid shouldFailForEmptyInterfacesArray() {\r\n    assertThatThrownBy(() -> this.proxy.forInterfaces(new Class<?>[] ;)).isInstanceOf(IllegalArgumentException.class);\r\n}\n@Test\r\nvoid proxyForInterfacesMatchesProxyHint() {\r\n    this.runtimeHints.proxies().registerJdkProxy(FirstTestInterface.class, SecondTestInterface.class);\r\n    assertPredicateMatches(this.proxy.forInterfaces(FirstTestInterface.class, SecondTestInterface.class));\r\n}\n@Test\r\nvoid proxyForInterfacesDoesNotMatchProxyHintDifferentOrder() {\r\n    this.runtimeHints.proxies().registerJdkProxy(SecondTestInterface.class, FirstTestInterface.class);\r\n    assertPredicateDoesNotMatch(this.proxy.forInterfaces(FirstTestInterface.class, SecondTestInterface.class));\r\n}\ninterface FirstTestInterface {\r\n}\ninterface SecondTestInterface {\r\n}\nprivate void assertPredicateMatches(Predicate<RuntimeHints> predicate) {\r\n    assertThat(predicate.test(this.runtimeHints)).isTrue();\r\n}\nprivate void assertPredicateDoesNotMatch(Predicate<RuntimeHints> predicate) {\r\n    assertThat(predicate.test(this.runtimeHints)).isFalse();\r\n}",
    "comment": "\n * Tests for {@link ProxyHintsPredicates}.\n *\n * @author Brian Clozel\n "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ProxyHintsPredicatesTests#setup()",
    "entityType": "method",
    "code": "@BeforeEach\r\nvoid setup() {\r\n    this.runtimeHints = new RuntimeHints();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ProxyHintsPredicatesTests#shouldFailForEmptyInterfacesArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldFailForEmptyInterfacesArray() {\r\n    assertThatThrownBy(() -> this.proxy.forInterfaces(new Class<?>[] ;)).isInstanceOf(IllegalArgumentException.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ProxyHintsPredicatesTests#proxyForInterfacesMatchesProxyHint()",
    "entityType": "method",
    "code": "@Test\r\nvoid proxyForInterfacesMatchesProxyHint() {\r\n    this.runtimeHints.proxies().registerJdkProxy(FirstTestInterface.class, SecondTestInterface.class);\r\n    assertPredicateMatches(this.proxy.forInterfaces(FirstTestInterface.class, SecondTestInterface.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ProxyHintsPredicatesTests#proxyForInterfacesDoesNotMatchProxyHintDifferentOrder()",
    "entityType": "method",
    "code": "@Test\r\nvoid proxyForInterfacesDoesNotMatchProxyHintDifferentOrder() {\r\n    this.runtimeHints.proxies().registerJdkProxy(SecondTestInterface.class, FirstTestInterface.class);\r\n    assertPredicateDoesNotMatch(this.proxy.forInterfaces(FirstTestInterface.class, SecondTestInterface.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ProxyHintsPredicatesTests#assertPredicateMatches(Predicate<RuntimeHints>)",
    "entityType": "method",
    "code": "private void assertPredicateMatches(Predicate<RuntimeHints> predicate) {\r\n    assertThat(predicate.test(this.runtimeHints)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ProxyHintsPredicatesTests#assertPredicateDoesNotMatch(Predicate<RuntimeHints>)",
    "entityType": "method",
    "code": "private void assertPredicateDoesNotMatch(Predicate<RuntimeHints> predicate) {\r\n    assertThat(predicate.test(this.runtimeHints)).isFalse();\r\n}",
    "comment": ""
  }
]