[
  {
    "entityId": "org.springframework.core.convert.converter.ConvertingComparator",
    "entityType": "class",
    "code": "private final Comparator<T> comparator;\nprivate final Converter<S, T> converter;\n/**\r\n * Create a new {@link ConvertingComparator} instance.\r\n * @param converter the converter\r\n */\r\npublic ConvertingComparator(Converter<S, T> converter) {\r\n    this(Comparators.comparable(), converter);\r\n}\n/**\r\n * Create a new {@link ConvertingComparator} instance.\r\n * @param comparator the underlying comparator used to compare the converted values\r\n * @param converter the converter\r\n */\r\npublic ConvertingComparator(Comparator<T> comparator, Converter<S, T> converter) {\r\n    Assert.notNull(comparator, \"Comparator must not be null\");\r\n    Assert.notNull(converter, \"Converter must not be null\");\r\n    this.comparator = comparator;\r\n    this.converter = converter;\r\n}\n/**\r\n * Create a new {@code ConvertingComparator} instance.\r\n * @param comparator the underlying comparator\r\n * @param conversionService the conversion service\r\n * @param targetType the target type\r\n */\r\npublic ConvertingComparator(Comparator<T> comparator, ConversionService conversionService, Class<? extends T> targetType) {\r\n    this(comparator, new ConversionServiceConverter<>(conversionService, targetType));\r\n}\n@Override\r\npublic int compare(S o1, S o2) {\r\n    T c1 = this.converter.convert(o1);\r\n    T c2 = this.converter.convert(o2);\r\n    return this.comparator.compare(c1, c2);\r\n}\n/**\r\n * Create a new {@link ConvertingComparator} that compares {@linkplain java.util.Map.Entry\r\n * map entries} based on their {@linkplain java.util.Map.Entry#getKey() keys}.\r\n * @param comparator the underlying comparator used to compare keys\r\n * @return a new {@link ConvertingComparator} instance\r\n */\r\npublic static <K, V> ConvertingComparator<Map.Entry<K, V>, K> mapEntryKeys(Comparator<K> comparator) {\r\n    return new ConvertingComparator<>(comparator, Map.Entry::getKey);\r\n}\n/**\r\n * Create a new {@link ConvertingComparator} that compares {@linkplain java.util.Map.Entry\r\n * map entries} based on their {@linkplain java.util.Map.Entry#getValue() values}.\r\n * @param comparator the underlying comparator used to compare values\r\n * @return a new {@link ConvertingComparator} instance\r\n */\r\npublic static <K, V> ConvertingComparator<Map.Entry<K, V>, V> mapEntryValues(Comparator<V> comparator) {\r\n    return new ConvertingComparator<>(comparator, Map.Entry::getValue);\r\n}\n/**\r\n * Adapts a {@link ConversionService} and {@code targetType} to a {@link Converter}.\r\n */\r\nprivate static class ConversionServiceConverter<S, T> implements Converter<S, T> {\r\n\r\n    private final ConversionService conversionService;\r\n\r\n    private final Class<? extends T> targetType;\r\n\r\n    public ConversionServiceConverter(ConversionService conversionService, Class<? extends T> targetType) {\r\n        Assert.notNull(conversionService, \"ConversionService must not be null\");\r\n        Assert.notNull(targetType, \"'targetType' must not be null\");\r\n        this.conversionService = conversionService;\r\n        this.targetType = targetType;\r\n    }\r\n\r\n    @Override\r\n    @Nullable\r\n    public T convert(S source) {\r\n        return this.conversionService.convert(source, this.targetType);\r\n    }\r\n}",
    "comment": "\n * A {@link Comparator} that converts values before they are compared.\n *\n * <p>The specified {@link Converter} will be used to convert each value\n * before it is passed to the underlying {@code Comparator}.\n *\n * @author Phillip Webb\n * @since 3.2\n * @param <S> the source type\n * @param <T> the target type\n "
  },
  {
    "entityId": "org.springframework.core.convert.converter.ConvertingComparator#compare(S,S)",
    "entityType": "method",
    "code": "@Override\r\npublic int compare(S o1, S o2) {\r\n    T c1 = this.converter.convert(o1);\r\n    T c2 = this.converter.convert(o2);\r\n    return this.comparator.compare(c1, c2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.converter.ConvertingComparator#mapEntryKeys(Comparator<K>)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link ConvertingComparator} that compares {@linkplain java.util.Map.Entry\r\n * map entries} based on their {@linkplain java.util.Map.Entry#getKey() keys}.\r\n * @param comparator the underlying comparator used to compare keys\r\n * @return a new {@link ConvertingComparator} instance\r\n */\r\npublic static <K, V> ConvertingComparator<Map.Entry<K, V>, K> mapEntryKeys(Comparator<K> comparator) {\r\n    return new ConvertingComparator<>(comparator, Map.Entry::getKey);\r\n}",
    "comment": "\n\t * Create a new {@link ConvertingComparator} that compares {@linkplain java.util.Map.Entry\n\t * map entries} based on their {@linkplain java.util.Map.Entry#getKey() keys}.\n\t * @param comparator the underlying comparator used to compare keys\n\t * @return a new {@link ConvertingComparator} instance\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.converter.ConvertingComparator#mapEntryValues(Comparator<V>)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link ConvertingComparator} that compares {@linkplain java.util.Map.Entry\r\n * map entries} based on their {@linkplain java.util.Map.Entry#getValue() values}.\r\n * @param comparator the underlying comparator used to compare values\r\n * @return a new {@link ConvertingComparator} instance\r\n */\r\npublic static <K, V> ConvertingComparator<Map.Entry<K, V>, V> mapEntryValues(Comparator<V> comparator) {\r\n    return new ConvertingComparator<>(comparator, Map.Entry::getValue);\r\n}",
    "comment": "\n\t * Create a new {@link ConvertingComparator} that compares {@linkplain java.util.Map.Entry\n\t * map entries} based on their {@linkplain java.util.Map.Entry#getValue() values}.\n\t * @param comparator the underlying comparator used to compare values\n\t * @return a new {@link ConvertingComparator} instance\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.converter.ConversionServiceConverter",
    "entityType": "class",
    "code": "private final ConversionService conversionService;\nprivate final Class<? extends T> targetType;\npublic ConversionServiceConverter(ConversionService conversionService, Class<? extends T> targetType) {\r\n    Assert.notNull(conversionService, \"ConversionService must not be null\");\r\n    Assert.notNull(targetType, \"'targetType' must not be null\");\r\n    this.conversionService = conversionService;\r\n    this.targetType = targetType;\r\n}\n@Override\r\n@Nullable\r\npublic T convert(S source) {\r\n    return this.conversionService.convert(source, this.targetType);\r\n}",
    "comment": "\n\t * Adapts a {@link ConversionService} and {@code targetType} to a {@link Converter}.\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.converter.ConversionServiceConverter#convert(S)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic T convert(S source) {\r\n    return this.conversionService.convert(source, this.targetType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.converter.GenericConverter",
    "entityType": "class",
    "code": "/**\r\n * Return the source and target types that this converter can convert between.\r\n * <p>Each entry is a convertible source-to-target type pair.\r\n * <p>For {@link ConditionalConverter conditional converters} this method may return\r\n * {@code null} to indicate all source-to-target pairs should be considered.\r\n */\r\n@Nullable\r\nSet<ConvertiblePair> getConvertibleTypes();\n/**\r\n * Convert the source object to the targetType described by the {@code TypeDescriptor}.\r\n * @param source the source object to convert (may be {@code null})\r\n * @param sourceType the type descriptor of the field we are converting from\r\n * @param targetType the type descriptor of the field we are converting to\r\n * @return the converted object\r\n */\r\n@Nullable\r\nObject convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType);\n/**\r\n * Holder for a source-to-target class pair.\r\n */\r\nfinal class ConvertiblePair {\r\n\r\n    private final Class<?> sourceType;\r\n\r\n    private final Class<?> targetType;\r\n\r\n    /**\r\n     * Create a new source-to-target pair.\r\n     * @param sourceType the source type\r\n     * @param targetType the target type\r\n     */\r\n    public ConvertiblePair(Class<?> sourceType, Class<?> targetType) {\r\n        Assert.notNull(sourceType, \"Source type must not be null\");\r\n        Assert.notNull(targetType, \"Target type must not be null\");\r\n        this.sourceType = sourceType;\r\n        this.targetType = targetType;\r\n    }\r\n\r\n    public Class<?> getSourceType() {\r\n        return this.sourceType;\r\n    }\r\n\r\n    public Class<?> getTargetType() {\r\n        return this.targetType;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(@Nullable Object other) {\r\n        if (this == other) {\r\n            return true;\r\n        }\r\n        if (other == null || other.getClass() != ConvertiblePair.class) {\r\n            return false;\r\n        }\r\n        ConvertiblePair otherPair = (ConvertiblePair) other;\r\n        return (this.sourceType == otherPair.sourceType && this.targetType == otherPair.targetType);\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        return (this.sourceType.hashCode() * 31 + this.targetType.hashCode());\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return (this.sourceType.getName() + \" -> \" + this.targetType.getName());\r\n    }\r\n}",
    "comment": "\n * Generic converter interface for converting between two or more types.\n *\n * <p>This is the most flexible of the Converter SPI interfaces, but also the most complex.\n * It is flexible in that a GenericConverter may support converting between multiple source/target\n * type pairs (see {@link #getConvertibleTypes()}). In addition, GenericConverter implementations\n * have access to source/target {@link TypeDescriptor field context} during the type conversion\n * process. This allows for resolving source and target field metadata such as annotations and\n * generics information, which can be used to influence the conversion logic.\n *\n * <p>This interface should generally not be used when the simpler {@link Converter} or\n * {@link ConverterFactory} interface is sufficient.\n *\n * <p>Implementations may additionally implement {@link ConditionalConverter}.\n *\n * @author Keith Donald\n * @author Juergen Hoeller\n * @since 3.0\n * @see TypeDescriptor\n * @see Converter\n * @see ConverterFactory\n * @see ConditionalConverter\n "
  },
  {
    "entityId": "org.springframework.core.convert.converter.GenericConverter#getConvertibleTypes()",
    "entityType": "method",
    "code": "/**\r\n * Return the source and target types that this converter can convert between.\r\n * <p>Each entry is a convertible source-to-target type pair.\r\n * <p>For {@link ConditionalConverter conditional converters} this method may return\r\n * {@code null} to indicate all source-to-target pairs should be considered.\r\n */\r\n@Nullable\r\nSet<ConvertiblePair> getConvertibleTypes();",
    "comment": "\n\t * Return the source and target types that this converter can convert between.\n\t * <p>Each entry is a convertible source-to-target type pair.\n\t * <p>For {@link ConditionalConverter conditional converters} this method may return\n\t * {@code null} to indicate all source-to-target pairs should be considered.\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.converter.GenericConverter#convert(Object,TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "/**\r\n * Convert the source object to the targetType described by the {@code TypeDescriptor}.\r\n * @param source the source object to convert (may be {@code null})\r\n * @param sourceType the type descriptor of the field we are converting from\r\n * @param targetType the type descriptor of the field we are converting to\r\n * @return the converted object\r\n */\r\n@Nullable\r\nObject convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType);",
    "comment": "\n\t * Convert the source object to the targetType described by the {@code TypeDescriptor}.\n\t * @param source the source object to convert (may be {@code null})\n\t * @param sourceType the type descriptor of the field we are converting from\n\t * @param targetType the type descriptor of the field we are converting to\n\t * @return the converted object\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.converter.ConvertiblePair",
    "entityType": "class",
    "code": "private final Class<?> sourceType;\nprivate final Class<?> targetType;\n/**\r\n * Create a new source-to-target pair.\r\n * @param sourceType the source type\r\n * @param targetType the target type\r\n */\r\npublic ConvertiblePair(Class<?> sourceType, Class<?> targetType) {\r\n    Assert.notNull(sourceType, \"Source type must not be null\");\r\n    Assert.notNull(targetType, \"Target type must not be null\");\r\n    this.sourceType = sourceType;\r\n    this.targetType = targetType;\r\n}\npublic Class<?> getSourceType() {\r\n    return this.sourceType;\r\n}\npublic Class<?> getTargetType() {\r\n    return this.targetType;\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (other == null || other.getClass() != ConvertiblePair.class) {\r\n        return false;\r\n    }\r\n    ConvertiblePair otherPair = (ConvertiblePair) other;\r\n    return (this.sourceType == otherPair.sourceType && this.targetType == otherPair.targetType);\r\n}\n@Override\r\npublic int hashCode() {\r\n    return (this.sourceType.hashCode() * 31 + this.targetType.hashCode());\r\n}\n@Override\r\npublic String toString() {\r\n    return (this.sourceType.getName() + \" -> \" + this.targetType.getName());\r\n}",
    "comment": "\n\t * Holder for a source-to-target class pair.\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.converter.ConvertiblePair#getSourceType()",
    "entityType": "method",
    "code": "public Class<?> getSourceType() {\r\n    return this.sourceType;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.converter.ConvertiblePair#getTargetType()",
    "entityType": "method",
    "code": "public Class<?> getTargetType() {\r\n    return this.targetType;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.converter.ConvertiblePair#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (other == null || other.getClass() != ConvertiblePair.class) {\r\n        return false;\r\n    }\r\n    ConvertiblePair otherPair = (ConvertiblePair) other;\r\n    return (this.sourceType == otherPair.sourceType && this.targetType == otherPair.targetType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.converter.ConvertiblePair#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return (this.sourceType.hashCode() * 31 + this.targetType.hashCode());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.converter.ConvertiblePair#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return (this.sourceType.getName() + \" -> \" + this.targetType.getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.ConverterNotFoundException",
    "entityType": "class",
    "code": "@Nullable\r\nprivate final TypeDescriptor sourceType;\nprivate final TypeDescriptor targetType;\n/**\r\n * Create a new conversion executor not found exception.\r\n * @param sourceType the source type requested to convert from\r\n * @param targetType the target type requested to convert to\r\n */\r\npublic ConverterNotFoundException(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    super(\"No converter found capable of converting from type [\" + sourceType + \"] to type [\" + targetType + \"]\");\r\n    this.sourceType = sourceType;\r\n    this.targetType = targetType;\r\n}\n/**\r\n * Return the source type that was requested to convert from.\r\n */\r\n@Nullable\r\npublic TypeDescriptor getSourceType() {\r\n    return this.sourceType;\r\n}\n/**\r\n * Return the target type that was requested to convert to.\r\n */\r\npublic TypeDescriptor getTargetType() {\r\n    return this.targetType;\r\n}",
    "comment": "\n * Exception to be thrown when a suitable converter could not be found\n * in a given conversion service.\n *\n * @author Keith Donald\n * @author Juergen Hoeller\n * @since 3.0\n "
  },
  {
    "entityId": "org.springframework.core.convert.ConverterNotFoundException#getSourceType()",
    "entityType": "method",
    "code": "/**\r\n * Return the source type that was requested to convert from.\r\n */\r\n@Nullable\r\npublic TypeDescriptor getSourceType() {\r\n    return this.sourceType;\r\n}",
    "comment": "\n\t * Return the source type that was requested to convert from.\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.ConverterNotFoundException#getTargetType()",
    "entityType": "method",
    "code": "/**\r\n * Return the target type that was requested to convert to.\r\n */\r\npublic TypeDescriptor getTargetType() {\r\n    return this.targetType;\r\n}",
    "comment": "\n\t * Return the target type that was requested to convert to.\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.Property",
    "entityType": "class",
    "code": "private static final Map<Property, Annotation[]> annotationCache = new ConcurrentReferenceHashMap<>();\nprivate final Class<?> objectType;\n@Nullable\r\nprivate final Method readMethod;\n@Nullable\r\nprivate final Method writeMethod;\nprivate final String name;\nprivate final MethodParameter methodParameter;\nprivate Annotation @Nullable [] annotations;\npublic Property(Class<?> objectType, @Nullable Method readMethod, @Nullable Method writeMethod) {\r\n    this(objectType, readMethod, writeMethod, null);\r\n}\npublic Property(Class<?> objectType, @Nullable Method readMethod, @Nullable Method writeMethod, @Nullable String name) {\r\n    this.objectType = objectType;\r\n    this.readMethod = readMethod;\r\n    this.writeMethod = writeMethod;\r\n    this.methodParameter = resolveMethodParameter();\r\n    this.name = (name != null ? name : resolveName());\r\n}\n/**\r\n * The object declaring this property, either directly or in a superclass the object extends.\r\n */\r\npublic Class<?> getObjectType() {\r\n    return this.objectType;\r\n}\n/**\r\n * The name of the property: for example, 'foo'.\r\n */\r\npublic String getName() {\r\n    return this.name;\r\n}\n/**\r\n * The property type: for example, {@code java.lang.String}.\r\n */\r\npublic Class<?> getType() {\r\n    return this.methodParameter.getParameterType();\r\n}\n/**\r\n * The property getter method: for example, {@code getFoo()}.\r\n */\r\n@Nullable\r\npublic Method getReadMethod() {\r\n    return this.readMethod;\r\n}\n/**\r\n * The property setter method: for example, {@code setFoo(String)}.\r\n */\r\n@Nullable\r\npublic Method getWriteMethod() {\r\n    return this.writeMethod;\r\n}\n// Package private\r\nMethodParameter getMethodParameter() {\r\n    return this.methodParameter;\r\n}\nAnnotation[] getAnnotations() {\r\n    if (this.annotations == null) {\r\n        this.annotations = resolveAnnotations();\r\n    }\r\n    return this.annotations;\r\n}\n// Internal helpers\r\nprivate String resolveName() {\r\n    if (this.readMethod != null) {\r\n        int index = this.readMethod.getName().indexOf(\"get\");\r\n        if (index != -1) {\r\n            index += 3;\r\n        } else {\r\n            index = this.readMethod.getName().indexOf(\"is\");\r\n            if (index != -1) {\r\n                index += 2;\r\n            } else {\r\n                // Record-style plain accessor method, for example, name()\r\n                index = 0;\r\n            }\r\n        }\r\n        return StringUtils.uncapitalize(this.readMethod.getName().substring(index));\r\n    } else if (this.writeMethod != null) {\r\n        int index = this.writeMethod.getName().indexOf(\"set\");\r\n        if (index == -1) {\r\n            throw new IllegalArgumentException(\"Not a setter method\");\r\n        }\r\n        index += 3;\r\n        return StringUtils.uncapitalize(this.writeMethod.getName().substring(index));\r\n    } else {\r\n        throw new IllegalStateException(\"Property is neither readable nor writeable\");\r\n    }\r\n}\nprivate MethodParameter resolveMethodParameter() {\r\n    MethodParameter read = resolveReadMethodParameter();\r\n    MethodParameter write = resolveWriteMethodParameter();\r\n    if (write == null) {\r\n        if (read == null) {\r\n            throw new IllegalStateException(\"Property is neither readable nor writeable\");\r\n        }\r\n        return read;\r\n    }\r\n    if (read != null) {\r\n        Class<?> readType = read.getParameterType();\r\n        Class<?> writeType = write.getParameterType();\r\n        if (!writeType.equals(readType) && writeType.isAssignableFrom(readType)) {\r\n            return read;\r\n        }\r\n    }\r\n    return write;\r\n}\n@Nullable\r\nprivate MethodParameter resolveReadMethodParameter() {\r\n    if (getReadMethod() == null) {\r\n        return null;\r\n    }\r\n    return new MethodParameter(getReadMethod(), -1).withContainingClass(getObjectType());\r\n}\n@Nullable\r\nprivate MethodParameter resolveWriteMethodParameter() {\r\n    if (getWriteMethod() == null) {\r\n        return null;\r\n    }\r\n    return new MethodParameter(getWriteMethod(), 0).withContainingClass(getObjectType());\r\n}\nprivate Annotation[] resolveAnnotations() {\r\n    Annotation[] annotations = annotationCache.get(this);\r\n    if (annotations == null) {\r\n        Map<Class<? extends Annotation>, Annotation> annotationMap = new LinkedHashMap<>();\r\n        addAnnotationsToMap(annotationMap, getReadMethod());\r\n        addAnnotationsToMap(annotationMap, getWriteMethod());\r\n        addAnnotationsToMap(annotationMap, getField());\r\n        annotations = annotationMap.values().toArray(new Annotation[0]);\r\n        annotationCache.put(this, annotations);\r\n    }\r\n    return annotations;\r\n}\nprivate void addAnnotationsToMap(Map<Class<? extends Annotation>, Annotation> annotationMap, @Nullable AnnotatedElement object) {\r\n    if (object != null) {\r\n        for (Annotation annotation : object.getAnnotations()) {\r\n            annotationMap.put(annotation.annotationType(), annotation);\r\n        }\r\n    }\r\n}\n@Nullable\r\nprivate Field getField() {\r\n    String name = getName();\r\n    if (!StringUtils.hasLength(name)) {\r\n        return null;\r\n    }\r\n    Field field = null;\r\n    Class<?> declaringClass = declaringClass();\r\n    if (declaringClass != null) {\r\n        field = ReflectionUtils.findField(declaringClass, name);\r\n        if (field == null) {\r\n            // Same lenient fallback checking as in CachedIntrospectionResults...\r\n            field = ReflectionUtils.findField(declaringClass, StringUtils.uncapitalize(name));\r\n            if (field == null) {\r\n                field = ReflectionUtils.findField(declaringClass, StringUtils.capitalize(name));\r\n            }\r\n        }\r\n    }\r\n    return field;\r\n}\n@Nullable\r\nprivate Class<?> declaringClass() {\r\n    if (getReadMethod() != null) {\r\n        return getReadMethod().getDeclaringClass();\r\n    } else if (getWriteMethod() != null) {\r\n        return getWriteMethod().getDeclaringClass();\r\n    } else {\r\n        return null;\r\n    }\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof Property that && ObjectUtils.nullSafeEquals(this.objectType, that.objectType) && ObjectUtils.nullSafeEquals(this.name, that.name) && ObjectUtils.nullSafeEquals(this.readMethod, that.readMethod) && ObjectUtils.nullSafeEquals(this.writeMethod, that.writeMethod)));\r\n}\n@Override\r\npublic int hashCode() {\r\n    return Objects.hash(this.objectType, this.name);\r\n}",
    "comment": "\n * A description of a JavaBeans Property that allows us to avoid a dependency on\n * {@code java.beans.PropertyDescriptor}. The {@code java.beans} package\n * is not available in a number of environments (for example, Android, Java ME), so this is\n * desirable for portability of Spring's core conversion facility.\n *\n * <p>Used to build a {@link TypeDescriptor} from a property location. The built\n * {@code TypeDescriptor} can then be used to convert from/to the property type.\n *\n * @author Keith Donald\n * @author Phillip Webb\n * @since 3.1\n * @see TypeDescriptor#TypeDescriptor(Property)\n * @see TypeDescriptor#nested(Property, int)\n "
  },
  {
    "entityId": "org.springframework.core.convert.Property#getObjectType()",
    "entityType": "method",
    "code": "/**\r\n * The object declaring this property, either directly or in a superclass the object extends.\r\n */\r\npublic Class<?> getObjectType() {\r\n    return this.objectType;\r\n}",
    "comment": "\n\t * The object declaring this property, either directly or in a superclass the object extends.\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.Property#getName()",
    "entityType": "method",
    "code": "/**\r\n * The name of the property: for example, 'foo'.\r\n */\r\npublic String getName() {\r\n    return this.name;\r\n}",
    "comment": "\n\t * The name of the property: for example, 'foo'.\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.Property#getType()",
    "entityType": "method",
    "code": "/**\r\n * The property type: for example, {@code java.lang.String}.\r\n */\r\npublic Class<?> getType() {\r\n    return this.methodParameter.getParameterType();\r\n}",
    "comment": "\n\t * The property type: for example, {@code java.lang.String}.\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.Property#getReadMethod()",
    "entityType": "method",
    "code": "/**\r\n * The property getter method: for example, {@code getFoo()}.\r\n */\r\n@Nullable\r\npublic Method getReadMethod() {\r\n    return this.readMethod;\r\n}",
    "comment": "\n\t * The property getter method: for example, {@code getFoo()}.\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.Property#getWriteMethod()",
    "entityType": "method",
    "code": "/**\r\n * The property setter method: for example, {@code setFoo(String)}.\r\n */\r\n@Nullable\r\npublic Method getWriteMethod() {\r\n    return this.writeMethod;\r\n}",
    "comment": "\n\t * The property setter method: for example, {@code setFoo(String)}.\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.Property#getMethodParameter()",
    "entityType": "method",
    "code": "// Package private\r\nMethodParameter getMethodParameter() {\r\n    return this.methodParameter;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.Property#getAnnotations()",
    "entityType": "method",
    "code": "Annotation[] getAnnotations() {\r\n    if (this.annotations == null) {\r\n        this.annotations = resolveAnnotations();\r\n    }\r\n    return this.annotations;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.Property#resolveName()",
    "entityType": "method",
    "code": "// Internal helpers\r\nprivate String resolveName() {\r\n    if (this.readMethod != null) {\r\n        int index = this.readMethod.getName().indexOf(\"get\");\r\n        if (index != -1) {\r\n            index += 3;\r\n        } else {\r\n            index = this.readMethod.getName().indexOf(\"is\");\r\n            if (index != -1) {\r\n                index += 2;\r\n            } else {\r\n                // Record-style plain accessor method, for example, name()\r\n                index = 0;\r\n            }\r\n        }\r\n        return StringUtils.uncapitalize(this.readMethod.getName().substring(index));\r\n    } else if (this.writeMethod != null) {\r\n        int index = this.writeMethod.getName().indexOf(\"set\");\r\n        if (index == -1) {\r\n            throw new IllegalArgumentException(\"Not a setter method\");\r\n        }\r\n        index += 3;\r\n        return StringUtils.uncapitalize(this.writeMethod.getName().substring(index));\r\n    } else {\r\n        throw new IllegalStateException(\"Property is neither readable nor writeable\");\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.Property#resolveMethodParameter()",
    "entityType": "method",
    "code": "private MethodParameter resolveMethodParameter() {\r\n    MethodParameter read = resolveReadMethodParameter();\r\n    MethodParameter write = resolveWriteMethodParameter();\r\n    if (write == null) {\r\n        if (read == null) {\r\n            throw new IllegalStateException(\"Property is neither readable nor writeable\");\r\n        }\r\n        return read;\r\n    }\r\n    if (read != null) {\r\n        Class<?> readType = read.getParameterType();\r\n        Class<?> writeType = write.getParameterType();\r\n        if (!writeType.equals(readType) && writeType.isAssignableFrom(readType)) {\r\n            return read;\r\n        }\r\n    }\r\n    return write;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.Property#resolveReadMethodParameter()",
    "entityType": "method",
    "code": "@Nullable\r\nprivate MethodParameter resolveReadMethodParameter() {\r\n    if (getReadMethod() == null) {\r\n        return null;\r\n    }\r\n    return new MethodParameter(getReadMethod(), -1).withContainingClass(getObjectType());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.Property#resolveWriteMethodParameter()",
    "entityType": "method",
    "code": "@Nullable\r\nprivate MethodParameter resolveWriteMethodParameter() {\r\n    if (getWriteMethod() == null) {\r\n        return null;\r\n    }\r\n    return new MethodParameter(getWriteMethod(), 0).withContainingClass(getObjectType());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.Property#resolveAnnotations()",
    "entityType": "method",
    "code": "private Annotation[] resolveAnnotations() {\r\n    Annotation[] annotations = annotationCache.get(this);\r\n    if (annotations == null) {\r\n        Map<Class<? extends Annotation>, Annotation> annotationMap = new LinkedHashMap<>();\r\n        addAnnotationsToMap(annotationMap, getReadMethod());\r\n        addAnnotationsToMap(annotationMap, getWriteMethod());\r\n        addAnnotationsToMap(annotationMap, getField());\r\n        annotations = annotationMap.values().toArray(new Annotation[0]);\r\n        annotationCache.put(this, annotations);\r\n    }\r\n    return annotations;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.Property#addAnnotationsToMap(Map<Class<? extends Annotation>,Annotation>,AnnotatedElement)",
    "entityType": "method",
    "code": "private void addAnnotationsToMap(Map<Class<? extends Annotation>, Annotation> annotationMap, @Nullable AnnotatedElement object) {\r\n    if (object != null) {\r\n        for (Annotation annotation : object.getAnnotations()) {\r\n            annotationMap.put(annotation.annotationType(), annotation);\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.Property#getField()",
    "entityType": "method",
    "code": "@Nullable\r\nprivate Field getField() {\r\n    String name = getName();\r\n    if (!StringUtils.hasLength(name)) {\r\n        return null;\r\n    }\r\n    Field field = null;\r\n    Class<?> declaringClass = declaringClass();\r\n    if (declaringClass != null) {\r\n        field = ReflectionUtils.findField(declaringClass, name);\r\n        if (field == null) {\r\n            // Same lenient fallback checking as in CachedIntrospectionResults...\r\n            field = ReflectionUtils.findField(declaringClass, StringUtils.uncapitalize(name));\r\n            if (field == null) {\r\n                field = ReflectionUtils.findField(declaringClass, StringUtils.capitalize(name));\r\n            }\r\n        }\r\n    }\r\n    return field;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.Property#declaringClass()",
    "entityType": "method",
    "code": "@Nullable\r\nprivate Class<?> declaringClass() {\r\n    if (getReadMethod() != null) {\r\n        return getReadMethod().getDeclaringClass();\r\n    } else if (getWriteMethod() != null) {\r\n        return getWriteMethod().getDeclaringClass();\r\n    } else {\r\n        return null;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.Property#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof Property that && ObjectUtils.nullSafeEquals(this.objectType, that.objectType) && ObjectUtils.nullSafeEquals(this.name, that.name) && ObjectUtils.nullSafeEquals(this.readMethod, that.readMethod) && ObjectUtils.nullSafeEquals(this.writeMethod, that.writeMethod)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.Property#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return Objects.hash(this.objectType, this.name);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.AbstractConditionalEnumConverter",
    "entityType": "class",
    "code": "private final ConversionService conversionService;\nprotected AbstractConditionalEnumConverter(ConversionService conversionService) {\r\n    this.conversionService = conversionService;\r\n}\n@Override\r\npublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    for (Class<?> interfaceType : ClassUtils.getAllInterfacesForClassAsSet(sourceType.getType())) {\r\n        if (this.conversionService.canConvert(TypeDescriptor.valueOf(interfaceType), targetType)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "comment": "\n * A {@link ConditionalConverter} base implementation for enum-based converters.\n *\n * @author Stephane Nicoll\n * @since 4.3\n "
  },
  {
    "entityId": "org.springframework.core.convert.support.AbstractConditionalEnumConverter#matches(TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    for (Class<?> interfaceType : ClassUtils.getAllInterfacesForClassAsSet(sourceType.getType())) {\r\n        if (this.conversionService.canConvert(TypeDescriptor.valueOf(interfaceType), targetType)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ArrayToArrayConverter",
    "entityType": "class",
    "code": "private final CollectionToArrayConverter helperConverter;\nprivate final ConversionService conversionService;\npublic ArrayToArrayConverter(ConversionService conversionService) {\r\n    this.helperConverter = new CollectionToArrayConverter(conversionService);\r\n    this.conversionService = conversionService;\r\n}\n@Override\r\npublic Set<ConvertiblePair> getConvertibleTypes() {\r\n    return Collections.singleton(new ConvertiblePair(Object[].class, Object[].class));\r\n}\n@Override\r\npublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    return this.helperConverter.matches(sourceType, targetType);\r\n}\n@Override\r\n@Nullable\r\npublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    if (this.conversionService instanceof GenericConversionService genericConversionService) {\r\n        TypeDescriptor targetElement = targetType.getElementTypeDescriptor();\r\n        if (targetElement != null && targetType.getType().isInstance(source) && genericConversionService.canBypassConvert(sourceType.getElementTypeDescriptor(), targetElement)) {\r\n            return source;\r\n        }\r\n    }\r\n    List<Object> sourceList = Arrays.asList(ObjectUtils.toObjectArray(source));\r\n    return this.helperConverter.convert(sourceList, sourceType, targetType);\r\n}",
    "comment": "\n * Converts an array to another array. First adapts the source array to a List,\n * then delegates to {@link CollectionToArrayConverter} to perform the target\n * array conversion.\n *\n * @author Keith Donald\n * @author Phillip Webb\n * @author Sam Brannen\n * @since 3.0\n "
  },
  {
    "entityId": "org.springframework.core.convert.support.ArrayToArrayConverter#getConvertibleTypes()",
    "entityType": "method",
    "code": "@Override\r\npublic Set<ConvertiblePair> getConvertibleTypes() {\r\n    return Collections.singleton(new ConvertiblePair(Object[].class, Object[].class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ArrayToArrayConverter#matches(TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    return this.helperConverter.matches(sourceType, targetType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ArrayToArrayConverter#convert(Object,TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    if (this.conversionService instanceof GenericConversionService genericConversionService) {\r\n        TypeDescriptor targetElement = targetType.getElementTypeDescriptor();\r\n        if (targetElement != null && targetType.getType().isInstance(source) && genericConversionService.canBypassConvert(sourceType.getElementTypeDescriptor(), targetElement)) {\r\n            return source;\r\n        }\r\n    }\r\n    List<Object> sourceList = Arrays.asList(ObjectUtils.toObjectArray(source));\r\n    return this.helperConverter.convert(sourceList, sourceType, targetType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ArrayToCollectionConverter",
    "entityType": "class",
    "code": "private final ConversionService conversionService;\npublic ArrayToCollectionConverter(ConversionService conversionService) {\r\n    this.conversionService = conversionService;\r\n}\n@Override\r\npublic Set<ConvertiblePair> getConvertibleTypes() {\r\n    return Collections.singleton(new ConvertiblePair(Object[].class, Collection.class));\r\n}\n@Override\r\npublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    return ConversionUtils.canConvertElements(sourceType.getElementTypeDescriptor(), targetType.getElementTypeDescriptor(), this.conversionService);\r\n}\n@Override\r\n@Nullable\r\npublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    if (source == null) {\r\n        return null;\r\n    }\r\n    int length = Array.getLength(source);\r\n    TypeDescriptor elementDesc = targetType.getElementTypeDescriptor();\r\n    Collection<Object> target = createCollection(targetType.getType(), (elementDesc != null ? elementDesc.getType() : null), length);\r\n    if (elementDesc == null) {\r\n        for (int i = 0; i < length; i++) {\r\n            Object sourceElement = Array.get(source, i);\r\n            target.add(sourceElement);\r\n        }\r\n    } else {\r\n        for (int i = 0; i < length; i++) {\r\n            Object sourceElement = Array.get(source, i);\r\n            Object targetElement = this.conversionService.convert(sourceElement, sourceType.elementTypeDescriptor(sourceElement), elementDesc);\r\n            target.add(targetElement);\r\n        }\r\n    }\r\n    return target;\r\n}\nprivate Collection<Object> createCollection(Class<?> targetType, @Nullable Class<?> elementType, int length) {\r\n    if (targetType.isInterface() && targetType.isAssignableFrom(ArrayList.class)) {\r\n        // Source is an array -> prefer ArrayList for Collection and SequencedCollection.\r\n        // CollectionFactory.createCollection traditionally prefers LinkedHashSet instead.\r\n        return new ArrayList<>(length);\r\n    }\r\n    return CollectionFactory.createCollection(targetType, elementType, length);\r\n}",
    "comment": "\n * Converts an array to a Collection.\n *\n * <p>First, creates a new Collection of the requested target type.\n * Then adds each array element to the target collection.\n * Will perform an element conversion from the source component type\n * to the collection's parameterized type if necessary.\n *\n * @author Keith Donald\n * @author Juergen Hoeller\n * @since 3.0\n "
  },
  {
    "entityId": "org.springframework.core.convert.support.ArrayToCollectionConverter#getConvertibleTypes()",
    "entityType": "method",
    "code": "@Override\r\npublic Set<ConvertiblePair> getConvertibleTypes() {\r\n    return Collections.singleton(new ConvertiblePair(Object[].class, Collection.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ArrayToCollectionConverter#matches(TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    return ConversionUtils.canConvertElements(sourceType.getElementTypeDescriptor(), targetType.getElementTypeDescriptor(), this.conversionService);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ArrayToCollectionConverter#convert(Object,TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    if (source == null) {\r\n        return null;\r\n    }\r\n    int length = Array.getLength(source);\r\n    TypeDescriptor elementDesc = targetType.getElementTypeDescriptor();\r\n    Collection<Object> target = createCollection(targetType.getType(), (elementDesc != null ? elementDesc.getType() : null), length);\r\n    if (elementDesc == null) {\r\n        for (int i = 0; i < length; i++) {\r\n            Object sourceElement = Array.get(source, i);\r\n            target.add(sourceElement);\r\n        }\r\n    } else {\r\n        for (int i = 0; i < length; i++) {\r\n            Object sourceElement = Array.get(source, i);\r\n            Object targetElement = this.conversionService.convert(sourceElement, sourceType.elementTypeDescriptor(sourceElement), elementDesc);\r\n            target.add(targetElement);\r\n        }\r\n    }\r\n    return target;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ArrayToCollectionConverter#createCollection(Class<?>,Class<?>,int)",
    "entityType": "method",
    "code": "private Collection<Object> createCollection(Class<?> targetType, @Nullable Class<?> elementType, int length) {\r\n    if (targetType.isInterface() && targetType.isAssignableFrom(ArrayList.class)) {\r\n        // Source is an array -> prefer ArrayList for Collection and SequencedCollection.\r\n        // CollectionFactory.createCollection traditionally prefers LinkedHashSet instead.\r\n        return new ArrayList<>(length);\r\n    }\r\n    return CollectionFactory.createCollection(targetType, elementType, length);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ArrayToObjectConverter",
    "entityType": "class",
    "code": "private final ConversionService conversionService;\npublic ArrayToObjectConverter(ConversionService conversionService) {\r\n    this.conversionService = conversionService;\r\n}\n@Override\r\npublic Set<ConvertiblePair> getConvertibleTypes() {\r\n    return Collections.singleton(new ConvertiblePair(Object[].class, Object.class));\r\n}\n@Override\r\npublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    return ConversionUtils.canConvertElements(sourceType.getElementTypeDescriptor(), targetType, this.conversionService);\r\n}\n@Override\r\n@Nullable\r\npublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    if (source == null) {\r\n        return null;\r\n    }\r\n    if (sourceType.isAssignableTo(targetType)) {\r\n        return source;\r\n    }\r\n    if (Array.getLength(source) == 0) {\r\n        return null;\r\n    }\r\n    Object firstElement = Array.get(source, 0);\r\n    return this.conversionService.convert(firstElement, sourceType.elementTypeDescriptor(firstElement), targetType);\r\n}",
    "comment": "\n * Converts an array to an Object by returning the first array element\n * after converting it to the desired target type.\n *\n * @author Keith Donald\n * @since 3.0\n "
  },
  {
    "entityId": "org.springframework.core.convert.support.ArrayToObjectConverter#getConvertibleTypes()",
    "entityType": "method",
    "code": "@Override\r\npublic Set<ConvertiblePair> getConvertibleTypes() {\r\n    return Collections.singleton(new ConvertiblePair(Object[].class, Object.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ArrayToObjectConverter#matches(TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    return ConversionUtils.canConvertElements(sourceType.getElementTypeDescriptor(), targetType, this.conversionService);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ArrayToObjectConverter#convert(Object,TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    if (source == null) {\r\n        return null;\r\n    }\r\n    if (sourceType.isAssignableTo(targetType)) {\r\n        return source;\r\n    }\r\n    if (Array.getLength(source) == 0) {\r\n        return null;\r\n    }\r\n    Object firstElement = Array.get(source, 0);\r\n    return this.conversionService.convert(firstElement, sourceType.elementTypeDescriptor(firstElement), targetType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ArrayToStringConverter",
    "entityType": "class",
    "code": "private final CollectionToStringConverter helperConverter;\npublic ArrayToStringConverter(ConversionService conversionService) {\r\n    this.helperConverter = new CollectionToStringConverter(conversionService);\r\n}\n@Override\r\npublic Set<ConvertiblePair> getConvertibleTypes() {\r\n    return Collections.singleton(new ConvertiblePair(Object[].class, String.class));\r\n}\n@Override\r\npublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    return this.helperConverter.matches(sourceType, targetType);\r\n}\n@Override\r\n@Nullable\r\npublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    return this.helperConverter.convert(Arrays.asList(ObjectUtils.toObjectArray(source)), sourceType, targetType);\r\n}",
    "comment": "\n * Converts an array to a comma-delimited String. First adapts the source array\n * to a List, then delegates to {@link CollectionToStringConverter} to perform\n * the target String conversion.\n *\n * @author Keith Donald\n * @since 3.0\n "
  },
  {
    "entityId": "org.springframework.core.convert.support.ArrayToStringConverter#getConvertibleTypes()",
    "entityType": "method",
    "code": "@Override\r\npublic Set<ConvertiblePair> getConvertibleTypes() {\r\n    return Collections.singleton(new ConvertiblePair(Object[].class, String.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ArrayToStringConverter#matches(TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    return this.helperConverter.matches(sourceType, targetType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ArrayToStringConverter#convert(Object,TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    return this.helperConverter.convert(Arrays.asList(ObjectUtils.toObjectArray(source)), sourceType, targetType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ByteBufferConverter",
    "entityType": "class",
    "code": "private static final TypeDescriptor BYTE_BUFFER_TYPE = TypeDescriptor.valueOf(ByteBuffer.class);\nprivate static final TypeDescriptor BYTE_ARRAY_TYPE = TypeDescriptor.valueOf(byte[].class);\nprivate static final Set<ConvertiblePair> CONVERTIBLE_PAIRS = Set.of(new ConvertiblePair(ByteBuffer.class, byte[].class), new ConvertiblePair(byte[].class, ByteBuffer.class), new ConvertiblePair(ByteBuffer.class, Object.class), new ConvertiblePair(Object.class, ByteBuffer.class));\nprivate final ConversionService conversionService;\npublic ByteBufferConverter(ConversionService conversionService) {\r\n    this.conversionService = conversionService;\r\n}\n@Override\r\npublic Set<ConvertiblePair> getConvertibleTypes() {\r\n    return CONVERTIBLE_PAIRS;\r\n}\n@Override\r\npublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    boolean byteBufferTarget = targetType.isAssignableTo(BYTE_BUFFER_TYPE);\r\n    if (sourceType.isAssignableTo(BYTE_BUFFER_TYPE)) {\r\n        return (byteBufferTarget || matchesFromByteBuffer(targetType));\r\n    }\r\n    return (byteBufferTarget && matchesToByteBuffer(sourceType));\r\n}\nprivate boolean matchesFromByteBuffer(TypeDescriptor targetType) {\r\n    return (targetType.isAssignableTo(BYTE_ARRAY_TYPE) || this.conversionService.canConvert(BYTE_ARRAY_TYPE, targetType));\r\n}\nprivate boolean matchesToByteBuffer(TypeDescriptor sourceType) {\r\n    return (sourceType.isAssignableTo(BYTE_ARRAY_TYPE) || this.conversionService.canConvert(sourceType, BYTE_ARRAY_TYPE));\r\n}\n@Override\r\n@Nullable\r\npublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    boolean byteBufferTarget = targetType.isAssignableTo(BYTE_BUFFER_TYPE);\r\n    if (source instanceof ByteBuffer buffer) {\r\n        return (byteBufferTarget ? buffer.duplicate() : convertFromByteBuffer(buffer, targetType));\r\n    }\r\n    if (byteBufferTarget) {\r\n        return convertToByteBuffer(source, sourceType);\r\n    }\r\n    // Should not happen\r\n    throw new IllegalStateException(\"Unexpected source/target types\");\r\n}\n@Nullable\r\nprivate Object convertFromByteBuffer(ByteBuffer source, TypeDescriptor targetType) {\r\n    byte[] bytes = new byte[source.remaining()];\r\n    source.get(bytes);\r\n    if (targetType.isAssignableTo(BYTE_ARRAY_TYPE)) {\r\n        return bytes;\r\n    }\r\n    return this.conversionService.convert(bytes, BYTE_ARRAY_TYPE, targetType);\r\n}\nprivate Object convertToByteBuffer(@Nullable Object source, TypeDescriptor sourceType) {\r\n    byte[] bytes = (byte[]) (source instanceof byte[] ? source : this.conversionService.convert(source, sourceType, BYTE_ARRAY_TYPE));\r\n    if (bytes == null) {\r\n        return ByteBuffer.wrap(new byte[0]);\r\n    }\r\n    ByteBuffer byteBuffer = ByteBuffer.allocate(bytes.length);\r\n    byteBuffer.put(bytes);\r\n    return byteBuffer.rewind();\r\n}",
    "comment": "\n * Converts a {@link ByteBuffer} directly to and from {@code byte[] ByteBuffer} directly to and from {@code byte[]s} and indirectly\n * to any type that the {@link ConversionService} support via {@code byte[]}.\n *\n * @author Phillip Webb\n * @author Juergen Hoeller\n * @since 4.0\n "
  },
  {
    "entityId": "org.springframework.core.convert.support.ByteBufferConverter#getConvertibleTypes()",
    "entityType": "method",
    "code": "@Override\r\npublic Set<ConvertiblePair> getConvertibleTypes() {\r\n    return CONVERTIBLE_PAIRS;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ByteBufferConverter#matches(TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    boolean byteBufferTarget = targetType.isAssignableTo(BYTE_BUFFER_TYPE);\r\n    if (sourceType.isAssignableTo(BYTE_BUFFER_TYPE)) {\r\n        return (byteBufferTarget || matchesFromByteBuffer(targetType));\r\n    }\r\n    return (byteBufferTarget && matchesToByteBuffer(sourceType));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ByteBufferConverter#matchesFromByteBuffer(TypeDescriptor)",
    "entityType": "method",
    "code": "private boolean matchesFromByteBuffer(TypeDescriptor targetType) {\r\n    return (targetType.isAssignableTo(BYTE_ARRAY_TYPE) || this.conversionService.canConvert(BYTE_ARRAY_TYPE, targetType));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ByteBufferConverter#matchesToByteBuffer(TypeDescriptor)",
    "entityType": "method",
    "code": "private boolean matchesToByteBuffer(TypeDescriptor sourceType) {\r\n    return (sourceType.isAssignableTo(BYTE_ARRAY_TYPE) || this.conversionService.canConvert(sourceType, BYTE_ARRAY_TYPE));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ByteBufferConverter#convert(Object,TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    boolean byteBufferTarget = targetType.isAssignableTo(BYTE_BUFFER_TYPE);\r\n    if (source instanceof ByteBuffer buffer) {\r\n        return (byteBufferTarget ? buffer.duplicate() : convertFromByteBuffer(buffer, targetType));\r\n    }\r\n    if (byteBufferTarget) {\r\n        return convertToByteBuffer(source, sourceType);\r\n    }\r\n    // Should not happen\r\n    throw new IllegalStateException(\"Unexpected source/target types\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ByteBufferConverter#convertFromByteBuffer(ByteBuffer,TypeDescriptor)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate Object convertFromByteBuffer(ByteBuffer source, TypeDescriptor targetType) {\r\n    byte[] bytes = new byte[source.remaining()];\r\n    source.get(bytes);\r\n    if (targetType.isAssignableTo(BYTE_ARRAY_TYPE)) {\r\n        return bytes;\r\n    }\r\n    return this.conversionService.convert(bytes, BYTE_ARRAY_TYPE, targetType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ByteBufferConverter#convertToByteBuffer(Object,TypeDescriptor)",
    "entityType": "method",
    "code": "private Object convertToByteBuffer(@Nullable Object source, TypeDescriptor sourceType) {\r\n    byte[] bytes = (byte[]) (source instanceof byte[] ? source : this.conversionService.convert(source, sourceType, BYTE_ARRAY_TYPE));\r\n    if (bytes == null) {\r\n        return ByteBuffer.wrap(new byte[0]);\r\n    }\r\n    ByteBuffer byteBuffer = ByteBuffer.allocate(bytes.length);\r\n    byteBuffer.put(bytes);\r\n    return byteBuffer.rewind();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.CharacterToNumberFactory",
    "entityType": "class",
    "code": "@Override\r\npublic <T extends Number> Converter<Character, T> getConverter(Class<T> targetType) {\r\n    return new CharacterToNumber<>(targetType);\r\n}\nprivate static final class CharacterToNumber<T extends Number> implements Converter<Character, T> {\r\n\r\n    private final Class<T> targetType;\r\n\r\n    public CharacterToNumber(Class<T> targetType) {\r\n        this.targetType = targetType;\r\n    }\r\n\r\n    @Override\r\n    public T convert(Character source) {\r\n        return NumberUtils.convertNumberToTargetClass((short) source.charValue(), this.targetType);\r\n    }\r\n}",
    "comment": "\n * Converts from a Character to any JDK-standard Number implementation.\n *\n * <p>Support Number classes including Byte, Short, Integer, Float, Double, Long, BigInteger, BigDecimal. This class\n * delegates to {@link NumberUtils#convertNumberToTargetClass(Number, Class)} to perform the conversion.\n *\n * @author Keith Donald\n * @since 3.0\n * @see java.lang.Byte\n * @see java.lang.Short\n * @see java.lang.Integer\n * @see java.lang.Long\n * @see java.math.BigInteger\n * @see java.lang.Float\n * @see java.lang.Double\n * @see java.math.BigDecimal\n * @see NumberUtils\n "
  },
  {
    "entityId": "org.springframework.core.convert.support.CharacterToNumberFactory#getConverter(Class<T>)",
    "entityType": "method",
    "code": "@Override\r\npublic <T extends Number> Converter<Character, T> getConverter(Class<T> targetType) {\r\n    return new CharacterToNumber<>(targetType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.CharacterToNumber",
    "entityType": "class",
    "code": "private final Class<T> targetType;\npublic CharacterToNumber(Class<T> targetType) {\r\n    this.targetType = targetType;\r\n}\n@Override\r\npublic T convert(Character source) {\r\n    return NumberUtils.convertNumberToTargetClass((short) source.charValue(), this.targetType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.CharacterToNumber#convert(Character)",
    "entityType": "method",
    "code": "@Override\r\npublic T convert(Character source) {\r\n    return NumberUtils.convertNumberToTargetClass((short) source.charValue(), this.targetType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.CollectionToArrayConverter",
    "entityType": "class",
    "code": "private final ConversionService conversionService;\npublic CollectionToArrayConverter(ConversionService conversionService) {\r\n    this.conversionService = conversionService;\r\n}\n@Override\r\npublic Set<ConvertiblePair> getConvertibleTypes() {\r\n    return Collections.singleton(new ConvertiblePair(Collection.class, Object[].class));\r\n}\n@Override\r\npublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    return ConversionUtils.canConvertElements(sourceType.getElementTypeDescriptor(), targetType.getElementTypeDescriptor(), this.conversionService);\r\n}\n@Override\r\n@Nullable\r\npublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    if (source == null) {\r\n        return null;\r\n    }\r\n    Collection<?> sourceCollection = (Collection<?>) source;\r\n    TypeDescriptor targetElementType = targetType.getElementTypeDescriptor();\r\n    Assert.state(targetElementType != null, \"No target element type\");\r\n    Object array = Array.newInstance(targetElementType.getType(), sourceCollection.size());\r\n    int i = 0;\r\n    for (Object sourceElement : sourceCollection) {\r\n        Object targetElement = this.conversionService.convert(sourceElement, sourceType.elementTypeDescriptor(sourceElement), targetElementType);\r\n        Array.set(array, i++, targetElement);\r\n    }\r\n    return array;\r\n}",
    "comment": "\n * Converts a Collection to an array.\n *\n * <p>First, creates a new array of the requested targetType with a length equal to the\n * size of the source Collection. Then sets each collection element into the array.\n * Will perform an element conversion from the collection's parameterized type to the\n * array's component type if necessary.\n *\n * @author Keith Donald\n * @author Juergen Hoeller\n * @since 3.0\n "
  },
  {
    "entityId": "org.springframework.core.convert.support.CollectionToArrayConverter#getConvertibleTypes()",
    "entityType": "method",
    "code": "@Override\r\npublic Set<ConvertiblePair> getConvertibleTypes() {\r\n    return Collections.singleton(new ConvertiblePair(Collection.class, Object[].class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.CollectionToArrayConverter#matches(TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    return ConversionUtils.canConvertElements(sourceType.getElementTypeDescriptor(), targetType.getElementTypeDescriptor(), this.conversionService);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.CollectionToArrayConverter#convert(Object,TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    if (source == null) {\r\n        return null;\r\n    }\r\n    Collection<?> sourceCollection = (Collection<?>) source;\r\n    TypeDescriptor targetElementType = targetType.getElementTypeDescriptor();\r\n    Assert.state(targetElementType != null, \"No target element type\");\r\n    Object array = Array.newInstance(targetElementType.getType(), sourceCollection.size());\r\n    int i = 0;\r\n    for (Object sourceElement : sourceCollection) {\r\n        Object targetElement = this.conversionService.convert(sourceElement, sourceType.elementTypeDescriptor(sourceElement), targetElementType);\r\n        Array.set(array, i++, targetElement);\r\n    }\r\n    return array;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.CollectionToCollectionConverter",
    "entityType": "class",
    "code": "private final ConversionService conversionService;\npublic CollectionToCollectionConverter(ConversionService conversionService) {\r\n    this.conversionService = conversionService;\r\n}\n@Override\r\npublic Set<ConvertiblePair> getConvertibleTypes() {\r\n    return Collections.singleton(new ConvertiblePair(Collection.class, Collection.class));\r\n}\n@Override\r\npublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    return ConversionUtils.canConvertElements(sourceType.getElementTypeDescriptor(), targetType.getElementTypeDescriptor(), this.conversionService);\r\n}\n@Override\r\n@Nullable\r\npublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    if (source == null) {\r\n        return null;\r\n    }\r\n    Collection<?> sourceCollection = (Collection<?>) source;\r\n    // Shortcut if possible...\r\n    boolean copyRequired = !targetType.getType().isInstance(source);\r\n    if (!copyRequired && sourceCollection.isEmpty()) {\r\n        return source;\r\n    }\r\n    TypeDescriptor elementDesc = targetType.getElementTypeDescriptor();\r\n    if (elementDesc == null && !copyRequired) {\r\n        return source;\r\n    }\r\n    // At this point, we need a collection copy in any case, even if just for finding out about element copies...\r\n    Collection<Object> target = CollectionFactory.createCollection(targetType.getType(), (elementDesc != null ? elementDesc.getType() : null), sourceCollection.size());\r\n    if (elementDesc == null) {\r\n        target.addAll(sourceCollection);\r\n    } else {\r\n        for (Object sourceElement : sourceCollection) {\r\n            Object targetElement = this.conversionService.convert(sourceElement, sourceType.elementTypeDescriptor(sourceElement), elementDesc);\r\n            target.add(targetElement);\r\n            if (sourceElement != targetElement) {\r\n                copyRequired = true;\r\n            }\r\n        }\r\n    }\r\n    return (copyRequired ? target : source);\r\n}",
    "comment": "\n * Converts from a Collection to another Collection.\n *\n * <p>First, creates a new Collection of the requested targetType with a size equal to the\n * size of the source Collection. Then copies each element in the source collection to the\n * target collection. Will perform an element conversion from the source collection's\n * parameterized type to the target collection's parameterized type if necessary.\n *\n * @author Keith Donald\n * @author Juergen Hoeller\n * @since 3.0\n "
  },
  {
    "entityId": "org.springframework.core.convert.support.CollectionToCollectionConverter#getConvertibleTypes()",
    "entityType": "method",
    "code": "@Override\r\npublic Set<ConvertiblePair> getConvertibleTypes() {\r\n    return Collections.singleton(new ConvertiblePair(Collection.class, Collection.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.CollectionToCollectionConverter#matches(TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    return ConversionUtils.canConvertElements(sourceType.getElementTypeDescriptor(), targetType.getElementTypeDescriptor(), this.conversionService);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.CollectionToCollectionConverter#convert(Object,TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    if (source == null) {\r\n        return null;\r\n    }\r\n    Collection<?> sourceCollection = (Collection<?>) source;\r\n    // Shortcut if possible...\r\n    boolean copyRequired = !targetType.getType().isInstance(source);\r\n    if (!copyRequired && sourceCollection.isEmpty()) {\r\n        return source;\r\n    }\r\n    TypeDescriptor elementDesc = targetType.getElementTypeDescriptor();\r\n    if (elementDesc == null && !copyRequired) {\r\n        return source;\r\n    }\r\n    // At this point, we need a collection copy in any case, even if just for finding out about element copies...\r\n    Collection<Object> target = CollectionFactory.createCollection(targetType.getType(), (elementDesc != null ? elementDesc.getType() : null), sourceCollection.size());\r\n    if (elementDesc == null) {\r\n        target.addAll(sourceCollection);\r\n    } else {\r\n        for (Object sourceElement : sourceCollection) {\r\n            Object targetElement = this.conversionService.convert(sourceElement, sourceType.elementTypeDescriptor(sourceElement), elementDesc);\r\n            target.add(targetElement);\r\n            if (sourceElement != targetElement) {\r\n                copyRequired = true;\r\n            }\r\n        }\r\n    }\r\n    return (copyRequired ? target : source);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.CollectionToObjectConverter",
    "entityType": "class",
    "code": "private final ConversionService conversionService;\npublic CollectionToObjectConverter(ConversionService conversionService) {\r\n    this.conversionService = conversionService;\r\n}\n@Override\r\npublic Set<ConvertiblePair> getConvertibleTypes() {\r\n    return Collections.singleton(new ConvertiblePair(Collection.class, Object.class));\r\n}\n@Override\r\npublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    return ConversionUtils.canConvertElements(sourceType.getElementTypeDescriptor(), targetType, this.conversionService);\r\n}\n@Override\r\n@Nullable\r\npublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    if (source == null) {\r\n        return null;\r\n    }\r\n    if (sourceType.isAssignableTo(targetType)) {\r\n        return source;\r\n    }\r\n    Collection<?> sourceCollection = (Collection<?>) source;\r\n    if (sourceCollection.isEmpty()) {\r\n        return null;\r\n    }\r\n    Object firstElement = sourceCollection.iterator().next();\r\n    return this.conversionService.convert(firstElement, sourceType.elementTypeDescriptor(firstElement), targetType);\r\n}",
    "comment": "\n * Converts a Collection to an Object by returning the first collection element after converting it to the desired targetType.\n *\n * @author Keith Donald\n * @since 3.0\n "
  },
  {
    "entityId": "org.springframework.core.convert.support.CollectionToObjectConverter#getConvertibleTypes()",
    "entityType": "method",
    "code": "@Override\r\npublic Set<ConvertiblePair> getConvertibleTypes() {\r\n    return Collections.singleton(new ConvertiblePair(Collection.class, Object.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.CollectionToObjectConverter#matches(TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    return ConversionUtils.canConvertElements(sourceType.getElementTypeDescriptor(), targetType, this.conversionService);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.CollectionToObjectConverter#convert(Object,TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    if (source == null) {\r\n        return null;\r\n    }\r\n    if (sourceType.isAssignableTo(targetType)) {\r\n        return source;\r\n    }\r\n    Collection<?> sourceCollection = (Collection<?>) source;\r\n    if (sourceCollection.isEmpty()) {\r\n        return null;\r\n    }\r\n    Object firstElement = sourceCollection.iterator().next();\r\n    return this.conversionService.convert(firstElement, sourceType.elementTypeDescriptor(firstElement), targetType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.CollectionToStringConverter",
    "entityType": "class",
    "code": "private static final String DELIMITER = \",\";\nprivate final ConversionService conversionService;\npublic CollectionToStringConverter(ConversionService conversionService) {\r\n    this.conversionService = conversionService;\r\n}\n@Override\r\npublic Set<ConvertiblePair> getConvertibleTypes() {\r\n    return Collections.singleton(new ConvertiblePair(Collection.class, String.class));\r\n}\n@Override\r\npublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    return ConversionUtils.canConvertElements(sourceType.getElementTypeDescriptor(), targetType, this.conversionService);\r\n}\n@Override\r\n@Nullable\r\npublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    if (!(source instanceof Collection<?> sourceCollection)) {\r\n        return null;\r\n    }\r\n    if (sourceCollection.isEmpty()) {\r\n        return \"\";\r\n    }\r\n    StringJoiner sj = new StringJoiner(DELIMITER);\r\n    for (Object sourceElement : sourceCollection) {\r\n        Object targetElement = this.conversionService.convert(sourceElement, sourceType.elementTypeDescriptor(sourceElement), targetType);\r\n        sj.add(String.valueOf(targetElement));\r\n    }\r\n    return sj.toString();\r\n}",
    "comment": "\n * Converts a Collection to a comma-delimited String.\n *\n * @author Keith Donald\n * @since 3.0\n "
  },
  {
    "entityId": "org.springframework.core.convert.support.CollectionToStringConverter#getConvertibleTypes()",
    "entityType": "method",
    "code": "@Override\r\npublic Set<ConvertiblePair> getConvertibleTypes() {\r\n    return Collections.singleton(new ConvertiblePair(Collection.class, String.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.CollectionToStringConverter#matches(TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    return ConversionUtils.canConvertElements(sourceType.getElementTypeDescriptor(), targetType, this.conversionService);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.CollectionToStringConverter#convert(Object,TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    if (!(source instanceof Collection<?> sourceCollection)) {\r\n        return null;\r\n    }\r\n    if (sourceCollection.isEmpty()) {\r\n        return \"\";\r\n    }\r\n    StringJoiner sj = new StringJoiner(DELIMITER);\r\n    for (Object sourceElement : sourceCollection) {\r\n        Object targetElement = this.conversionService.convert(sourceElement, sourceType.elementTypeDescriptor(sourceElement), targetType);\r\n        sj.add(String.valueOf(targetElement));\r\n    }\r\n    return sj.toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ConfigurableConversionService",
    "entityType": "class",
    "code": "",
    "comment": "\n * Configuration interface to be implemented by most if not all {@link ConversionService}\n * types. Consolidates the read-only operations exposed by {@link ConversionService} and\n * the mutating operations of {@link ConverterRegistry} to allow for convenient ad-hoc\n * addition and removal of {@link org.springframework.core.convert.converter.Converter\n * Converters} through. The latter is particularly useful when working against a\n * {@link org.springframework.core.env.ConfigurableEnvironment ConfigurableEnvironment}\n * instance in application context bootstrapping code.\n *\n * @author Chris Beams\n * @since 3.1\n * @see org.springframework.core.env.ConfigurablePropertyResolver#getConversionService()\n * @see org.springframework.core.env.ConfigurableEnvironment\n * @see org.springframework.context.ConfigurableApplicationContext#getEnvironment()\n "
  },
  {
    "entityId": "org.springframework.core.convert.support.ConversionServiceFactory",
    "entityType": "class",
    "code": "private ConversionServiceFactory() {\r\n}\n/**\r\n * Register the given Converter objects with the given target ConverterRegistry.\r\n * @param converters the converter objects: implementing {@link Converter},\r\n * {@link ConverterFactory}, or {@link GenericConverter}\r\n * @param registry the target registry\r\n */\r\npublic static void registerConverters(@Nullable Set<?> converters, ConverterRegistry registry) {\r\n    if (converters != null) {\r\n        for (Object candidate : converters) {\r\n            if (candidate instanceof GenericConverter genericConverter) {\r\n                registry.addConverter(genericConverter);\r\n            } else if (candidate instanceof Converter<?, ?> converter) {\r\n                registry.addConverter(converter);\r\n            } else if (candidate instanceof ConverterFactory<?, ?> converterFactory) {\r\n                registry.addConverterFactory(converterFactory);\r\n            } else {\r\n                throw new IllegalArgumentException(\"Each converter object must implement one of the \" + \"Converter, ConverterFactory, or GenericConverter interfaces\");\r\n            }\r\n        }\r\n    }\r\n}",
    "comment": "\n * A factory for common {@link org.springframework.core.convert.ConversionService}\n * configurations.\n *\n * @author Keith Donald\n * @author Juergen Hoeller\n * @author Chris Beams\n * @since 3.0\n "
  },
  {
    "entityId": "org.springframework.core.convert.support.ConversionServiceFactory#registerConverters(Set<?>,ConverterRegistry)",
    "entityType": "method",
    "code": "/**\r\n * Register the given Converter objects with the given target ConverterRegistry.\r\n * @param converters the converter objects: implementing {@link Converter},\r\n * {@link ConverterFactory}, or {@link GenericConverter}\r\n * @param registry the target registry\r\n */\r\npublic static void registerConverters(@Nullable Set<?> converters, ConverterRegistry registry) {\r\n    if (converters != null) {\r\n        for (Object candidate : converters) {\r\n            if (candidate instanceof GenericConverter genericConverter) {\r\n                registry.addConverter(genericConverter);\r\n            } else if (candidate instanceof Converter<?, ?> converter) {\r\n                registry.addConverter(converter);\r\n            } else if (candidate instanceof ConverterFactory<?, ?> converterFactory) {\r\n                registry.addConverterFactory(converterFactory);\r\n            } else {\r\n                throw new IllegalArgumentException(\"Each converter object must implement one of the \" + \"Converter, ConverterFactory, or GenericConverter interfaces\");\r\n            }\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Register the given Converter objects with the given target ConverterRegistry.\n\t * @param converters the converter objects: implementing {@link Converter},\n\t * {@link ConverterFactory}, or {@link GenericConverter}\n\t * @param registry the target registry\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.support.ConversionUtils",
    "entityType": "class",
    "code": "@Nullable\r\npublic static Object invokeConverter(GenericConverter converter, @Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    try {\r\n        return converter.convert(source, sourceType, targetType);\r\n    } catch (ConversionFailedException ex) {\r\n        throw ex;\r\n    } catch (Throwable ex) {\r\n        throw new ConversionFailedException(sourceType, targetType, source, ex);\r\n    }\r\n}\npublic static boolean canConvertElements(@Nullable TypeDescriptor sourceElementType, @Nullable TypeDescriptor targetElementType, ConversionService conversionService) {\r\n    if (targetElementType == null) {\r\n        // yes\r\n        return true;\r\n    }\r\n    if (sourceElementType == null) {\r\n        // maybe\r\n        return true;\r\n    }\r\n    if (conversionService.canConvert(sourceElementType, targetElementType)) {\r\n        // yes\r\n        return true;\r\n    }\r\n    if (ClassUtils.isAssignable(sourceElementType.getType(), targetElementType.getType())) {\r\n        // maybe\r\n        return true;\r\n    }\r\n    // no\r\n    return false;\r\n}\npublic static Class<?> getEnumType(Class<?> targetType) {\r\n    Class<?> enumType = targetType;\r\n    while (enumType != null && !enumType.isEnum()) {\r\n        enumType = enumType.getSuperclass();\r\n    }\r\n    Assert.notNull(enumType, () -> \"The target type \" + targetType.getName() + \" does not refer to an enum\");\r\n    return enumType;\r\n}",
    "comment": "\n * Internal utilities for the conversion package.\n *\n * @author Keith Donald\n * @author Stephane Nicoll\n * @since 3.0\n "
  },
  {
    "entityId": "org.springframework.core.convert.support.ConversionUtils#invokeConverter(GenericConverter,Object,TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "@Nullable\r\npublic static Object invokeConverter(GenericConverter converter, @Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    try {\r\n        return converter.convert(source, sourceType, targetType);\r\n    } catch (ConversionFailedException ex) {\r\n        throw ex;\r\n    } catch (Throwable ex) {\r\n        throw new ConversionFailedException(sourceType, targetType, source, ex);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ConversionUtils#canConvertElements(TypeDescriptor,TypeDescriptor,ConversionService)",
    "entityType": "method",
    "code": "public static boolean canConvertElements(@Nullable TypeDescriptor sourceElementType, @Nullable TypeDescriptor targetElementType, ConversionService conversionService) {\r\n    if (targetElementType == null) {\r\n        // yes\r\n        return true;\r\n    }\r\n    if (sourceElementType == null) {\r\n        // maybe\r\n        return true;\r\n    }\r\n    if (conversionService.canConvert(sourceElementType, targetElementType)) {\r\n        // yes\r\n        return true;\r\n    }\r\n    if (ClassUtils.isAssignable(sourceElementType.getType(), targetElementType.getType())) {\r\n        // maybe\r\n        return true;\r\n    }\r\n    // no\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ConversionUtils#getEnumType(Class<?>)",
    "entityType": "method",
    "code": "public static Class<?> getEnumType(Class<?> targetType) {\r\n    Class<?> enumType = targetType;\r\n    while (enumType != null && !enumType.isEnum()) {\r\n        enumType = enumType.getSuperclass();\r\n    }\r\n    Assert.notNull(enumType, () -> \"The target type \" + targetType.getName() + \" does not refer to an enum\");\r\n    return enumType;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ConvertingPropertyEditorAdapter",
    "entityType": "class",
    "code": "private final ConversionService conversionService;\nprivate final TypeDescriptor targetDescriptor;\nprivate final boolean canConvertToString;\n/**\r\n * Create a new ConvertingPropertyEditorAdapter for a given\r\n * {@link org.springframework.core.convert.ConversionService}\r\n * and the given target type.\r\n * @param conversionService the ConversionService to delegate to\r\n * @param targetDescriptor the target type to convert to\r\n */\r\npublic ConvertingPropertyEditorAdapter(ConversionService conversionService, TypeDescriptor targetDescriptor) {\r\n    Assert.notNull(conversionService, \"ConversionService must not be null\");\r\n    Assert.notNull(targetDescriptor, \"TypeDescriptor must not be null\");\r\n    this.conversionService = conversionService;\r\n    this.targetDescriptor = targetDescriptor;\r\n    this.canConvertToString = conversionService.canConvert(this.targetDescriptor, TypeDescriptor.valueOf(String.class));\r\n}\n@Override\r\npublic void setAsText(@Nullable String text) throws IllegalArgumentException {\r\n    setValue(this.conversionService.convert(text, TypeDescriptor.valueOf(String.class), this.targetDescriptor));\r\n}\n@Override\r\n@Nullable\r\npublic String getAsText() {\r\n    if (this.canConvertToString) {\r\n        return (String) this.conversionService.convert(getValue(), this.targetDescriptor, TypeDescriptor.valueOf(String.class));\r\n    } else {\r\n        return null;\r\n    }\r\n}",
    "comment": "\n * Adapter that exposes a {@link java.beans.PropertyEditor} for any given\n * {@link org.springframework.core.convert.ConversionService} and specific target type.\n *\n * @author Juergen Hoeller\n * @since 3.0\n "
  },
  {
    "entityId": "org.springframework.core.convert.support.ConvertingPropertyEditorAdapter#setAsText(String)",
    "entityType": "method",
    "code": "@Override\r\npublic void setAsText(@Nullable String text) throws IllegalArgumentException {\r\n    setValue(this.conversionService.convert(text, TypeDescriptor.valueOf(String.class), this.targetDescriptor));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ConvertingPropertyEditorAdapter#getAsText()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic String getAsText() {\r\n    if (this.canConvertToString) {\r\n        return (String) this.conversionService.convert(getValue(), this.targetDescriptor, TypeDescriptor.valueOf(String.class));\r\n    } else {\r\n        return null;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.DefaultConversionService",
    "entityType": "class",
    "code": "@Nullable\r\nprivate static volatile DefaultConversionService sharedInstance;\n/**\r\n * Create a new {@code DefaultConversionService} with the set of\r\n * {@linkplain DefaultConversionService#addDefaultConverters(ConverterRegistry) default converters}.\r\n */\r\npublic DefaultConversionService() {\r\n    addDefaultConverters(this);\r\n}\n/**\r\n * Return a shared default {@code ConversionService} instance,\r\n * lazily building it once needed.\r\n * <p><b>NOTE:</b> We highly recommend constructing individual\r\n * {@code ConversionService} instances for customization purposes.\r\n * This accessor is only meant as a fallback for code paths which\r\n * need simple type coercion but cannot access a longer-lived\r\n * {@code ConversionService} instance any other way.\r\n * @return the shared {@code ConversionService} instance (never {@code null})\r\n * @since 4.3.5\r\n */\r\npublic static ConversionService getSharedInstance() {\r\n    DefaultConversionService cs = sharedInstance;\r\n    if (cs == null) {\r\n        synchronized (DefaultConversionService.class) {\r\n            cs = sharedInstance;\r\n            if (cs == null) {\r\n                cs = new DefaultConversionService();\r\n                sharedInstance = cs;\r\n            }\r\n        }\r\n    }\r\n    return cs;\r\n}\n/**\r\n * Add converters appropriate for most environments.\r\n * @param converterRegistry the registry of converters to add to\r\n * (must also be castable to ConversionService, for example, being a {@link ConfigurableConversionService})\r\n * @throws ClassCastException if the given ConverterRegistry could not be cast to a ConversionService\r\n */\r\npublic static void addDefaultConverters(ConverterRegistry converterRegistry) {\r\n    addScalarConverters(converterRegistry);\r\n    addCollectionConverters(converterRegistry);\r\n    converterRegistry.addConverter(new ByteBufferConverter((ConversionService) converterRegistry));\r\n    converterRegistry.addConverter(new StringToTimeZoneConverter());\r\n    converterRegistry.addConverter(new ZoneIdToTimeZoneConverter());\r\n    converterRegistry.addConverter(new ZonedDateTimeToCalendarConverter());\r\n    converterRegistry.addConverter(new ObjectToObjectConverter());\r\n    converterRegistry.addConverter(new IdToEntityConverter((ConversionService) converterRegistry));\r\n    converterRegistry.addConverter(new FallbackObjectToStringConverter());\r\n    converterRegistry.addConverter(new ObjectToOptionalConverter((ConversionService) converterRegistry));\r\n}\n/**\r\n * Add common collection converters.\r\n * @param converterRegistry the registry of converters to add to\r\n * (must also be castable to ConversionService, for example, being a {@link ConfigurableConversionService})\r\n * @throws ClassCastException if the given ConverterRegistry could not be cast to a ConversionService\r\n * @since 4.2.3\r\n */\r\npublic static void addCollectionConverters(ConverterRegistry converterRegistry) {\r\n    ConversionService conversionService = (ConversionService) converterRegistry;\r\n    converterRegistry.addConverter(new ArrayToCollectionConverter(conversionService));\r\n    converterRegistry.addConverter(new CollectionToArrayConverter(conversionService));\r\n    converterRegistry.addConverter(new ArrayToArrayConverter(conversionService));\r\n    converterRegistry.addConverter(new CollectionToCollectionConverter(conversionService));\r\n    converterRegistry.addConverter(new MapToMapConverter(conversionService));\r\n    converterRegistry.addConverter(new ArrayToStringConverter(conversionService));\r\n    converterRegistry.addConverter(new StringToArrayConverter(conversionService));\r\n    converterRegistry.addConverter(new ArrayToObjectConverter(conversionService));\r\n    converterRegistry.addConverter(new ObjectToArrayConverter(conversionService));\r\n    converterRegistry.addConverter(new CollectionToStringConverter(conversionService));\r\n    converterRegistry.addConverter(new StringToCollectionConverter(conversionService));\r\n    converterRegistry.addConverter(new CollectionToObjectConverter(conversionService));\r\n    converterRegistry.addConverter(new ObjectToCollectionConverter(conversionService));\r\n    converterRegistry.addConverter(new StreamConverter(conversionService));\r\n}\nprivate static void addScalarConverters(ConverterRegistry converterRegistry) {\r\n    converterRegistry.addConverterFactory(new NumberToNumberConverterFactory());\r\n    converterRegistry.addConverterFactory(new StringToNumberConverterFactory());\r\n    converterRegistry.addConverter(Number.class, String.class, new ObjectToStringConverter());\r\n    converterRegistry.addConverter(new StringToCharacterConverter());\r\n    converterRegistry.addConverter(Character.class, String.class, new ObjectToStringConverter());\r\n    converterRegistry.addConverter(new NumberToCharacterConverter());\r\n    converterRegistry.addConverterFactory(new CharacterToNumberFactory());\r\n    converterRegistry.addConverter(new StringToBooleanConverter());\r\n    converterRegistry.addConverter(Boolean.class, String.class, new ObjectToStringConverter());\r\n    converterRegistry.addConverterFactory(new StringToEnumConverterFactory());\r\n    converterRegistry.addConverter(new EnumToStringConverter((ConversionService) converterRegistry));\r\n    converterRegistry.addConverterFactory(new IntegerToEnumConverterFactory());\r\n    converterRegistry.addConverter(new EnumToIntegerConverter((ConversionService) converterRegistry));\r\n    converterRegistry.addConverter(new StringToLocaleConverter());\r\n    converterRegistry.addConverter(Locale.class, String.class, new ObjectToStringConverter());\r\n    converterRegistry.addConverter(new StringToCharsetConverter());\r\n    converterRegistry.addConverter(Charset.class, String.class, new ObjectToStringConverter());\r\n    converterRegistry.addConverter(new StringToCurrencyConverter());\r\n    converterRegistry.addConverter(Currency.class, String.class, new ObjectToStringConverter());\r\n    converterRegistry.addConverter(new StringToPropertiesConverter());\r\n    converterRegistry.addConverter(new PropertiesToStringConverter());\r\n    converterRegistry.addConverter(new StringToUUIDConverter());\r\n    converterRegistry.addConverter(UUID.class, String.class, new ObjectToStringConverter());\r\n    converterRegistry.addConverter(new StringToPatternConverter());\r\n    converterRegistry.addConverter(Pattern.class, String.class, new ObjectToStringConverter());\r\n    if (KotlinDetector.isKotlinPresent()) {\r\n        converterRegistry.addConverter(new StringToRegexConverter());\r\n        converterRegistry.addConverter(kotlin.text.Regex.class, String.class, new ObjectToStringConverter());\r\n    }\r\n}",
    "comment": "\n * A specialization of {@link GenericConversionService} configured by default\n * with converters appropriate for most environments.\n *\n * <p>Designed for direct instantiation but also exposes the static\n * {@link #addDefaultConverters(ConverterRegistry)} utility method for ad-hoc\n * use against any {@code ConverterRegistry} instance.\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @author Stephane Nicoll\n * @since 3.1\n "
  },
  {
    "entityId": "org.springframework.core.convert.support.DefaultConversionService#getSharedInstance()",
    "entityType": "method",
    "code": "/**\r\n * Return a shared default {@code ConversionService} instance,\r\n * lazily building it once needed.\r\n * <p><b>NOTE:</b> We highly recommend constructing individual\r\n * {@code ConversionService} instances for customization purposes.\r\n * This accessor is only meant as a fallback for code paths which\r\n * need simple type coercion but cannot access a longer-lived\r\n * {@code ConversionService} instance any other way.\r\n * @return the shared {@code ConversionService} instance (never {@code null})\r\n * @since 4.3.5\r\n */\r\npublic static ConversionService getSharedInstance() {\r\n    DefaultConversionService cs = sharedInstance;\r\n    if (cs == null) {\r\n        synchronized (DefaultConversionService.class) {\r\n            cs = sharedInstance;\r\n            if (cs == null) {\r\n                cs = new DefaultConversionService();\r\n                sharedInstance = cs;\r\n            }\r\n        }\r\n    }\r\n    return cs;\r\n}",
    "comment": "\n\t * Return a shared default {@code ConversionService} instance,\n\t * lazily building it once needed.\n\t * <p><b>NOTE:</b> We highly recommend constructing individual\n\t * {@code ConversionService} instances for customization purposes.\n\t * This accessor is only meant as a fallback for code paths which\n\t * need simple type coercion but cannot access a longer-lived\n\t * {@code ConversionService} instance any other way.\n\t * @return the shared {@code ConversionService} instance (never {@code null})\n\t * @since 4.3.5\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.support.DefaultConversionService#addDefaultConverters(ConverterRegistry)",
    "entityType": "method",
    "code": "/**\r\n * Add converters appropriate for most environments.\r\n * @param converterRegistry the registry of converters to add to\r\n * (must also be castable to ConversionService, for example, being a {@link ConfigurableConversionService})\r\n * @throws ClassCastException if the given ConverterRegistry could not be cast to a ConversionService\r\n */\r\npublic static void addDefaultConverters(ConverterRegistry converterRegistry) {\r\n    addScalarConverters(converterRegistry);\r\n    addCollectionConverters(converterRegistry);\r\n    converterRegistry.addConverter(new ByteBufferConverter((ConversionService) converterRegistry));\r\n    converterRegistry.addConverter(new StringToTimeZoneConverter());\r\n    converterRegistry.addConverter(new ZoneIdToTimeZoneConverter());\r\n    converterRegistry.addConverter(new ZonedDateTimeToCalendarConverter());\r\n    converterRegistry.addConverter(new ObjectToObjectConverter());\r\n    converterRegistry.addConverter(new IdToEntityConverter((ConversionService) converterRegistry));\r\n    converterRegistry.addConverter(new FallbackObjectToStringConverter());\r\n    converterRegistry.addConverter(new ObjectToOptionalConverter((ConversionService) converterRegistry));\r\n}",
    "comment": "\n\t * Add converters appropriate for most environments.\n\t * @param converterRegistry the registry of converters to add to\n\t * (must also be castable to ConversionService, for example, being a {@link ConfigurableConversionService})\n\t * @throws ClassCastException if the given ConverterRegistry could not be cast to a ConversionService\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.support.DefaultConversionService#addCollectionConverters(ConverterRegistry)",
    "entityType": "method",
    "code": "/**\r\n * Add common collection converters.\r\n * @param converterRegistry the registry of converters to add to\r\n * (must also be castable to ConversionService, for example, being a {@link ConfigurableConversionService})\r\n * @throws ClassCastException if the given ConverterRegistry could not be cast to a ConversionService\r\n * @since 4.2.3\r\n */\r\npublic static void addCollectionConverters(ConverterRegistry converterRegistry) {\r\n    ConversionService conversionService = (ConversionService) converterRegistry;\r\n    converterRegistry.addConverter(new ArrayToCollectionConverter(conversionService));\r\n    converterRegistry.addConverter(new CollectionToArrayConverter(conversionService));\r\n    converterRegistry.addConverter(new ArrayToArrayConverter(conversionService));\r\n    converterRegistry.addConverter(new CollectionToCollectionConverter(conversionService));\r\n    converterRegistry.addConverter(new MapToMapConverter(conversionService));\r\n    converterRegistry.addConverter(new ArrayToStringConverter(conversionService));\r\n    converterRegistry.addConverter(new StringToArrayConverter(conversionService));\r\n    converterRegistry.addConverter(new ArrayToObjectConverter(conversionService));\r\n    converterRegistry.addConverter(new ObjectToArrayConverter(conversionService));\r\n    converterRegistry.addConverter(new CollectionToStringConverter(conversionService));\r\n    converterRegistry.addConverter(new StringToCollectionConverter(conversionService));\r\n    converterRegistry.addConverter(new CollectionToObjectConverter(conversionService));\r\n    converterRegistry.addConverter(new ObjectToCollectionConverter(conversionService));\r\n    converterRegistry.addConverter(new StreamConverter(conversionService));\r\n}",
    "comment": "\n\t * Add common collection converters.\n\t * @param converterRegistry the registry of converters to add to\n\t * (must also be castable to ConversionService, for example, being a {@link ConfigurableConversionService})\n\t * @throws ClassCastException if the given ConverterRegistry could not be cast to a ConversionService\n\t * @since 4.2.3\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.support.DefaultConversionService#addScalarConverters(ConverterRegistry)",
    "entityType": "method",
    "code": "private static void addScalarConverters(ConverterRegistry converterRegistry) {\r\n    converterRegistry.addConverterFactory(new NumberToNumberConverterFactory());\r\n    converterRegistry.addConverterFactory(new StringToNumberConverterFactory());\r\n    converterRegistry.addConverter(Number.class, String.class, new ObjectToStringConverter());\r\n    converterRegistry.addConverter(new StringToCharacterConverter());\r\n    converterRegistry.addConverter(Character.class, String.class, new ObjectToStringConverter());\r\n    converterRegistry.addConverter(new NumberToCharacterConverter());\r\n    converterRegistry.addConverterFactory(new CharacterToNumberFactory());\r\n    converterRegistry.addConverter(new StringToBooleanConverter());\r\n    converterRegistry.addConverter(Boolean.class, String.class, new ObjectToStringConverter());\r\n    converterRegistry.addConverterFactory(new StringToEnumConverterFactory());\r\n    converterRegistry.addConverter(new EnumToStringConverter((ConversionService) converterRegistry));\r\n    converterRegistry.addConverterFactory(new IntegerToEnumConverterFactory());\r\n    converterRegistry.addConverter(new EnumToIntegerConverter((ConversionService) converterRegistry));\r\n    converterRegistry.addConverter(new StringToLocaleConverter());\r\n    converterRegistry.addConverter(Locale.class, String.class, new ObjectToStringConverter());\r\n    converterRegistry.addConverter(new StringToCharsetConverter());\r\n    converterRegistry.addConverter(Charset.class, String.class, new ObjectToStringConverter());\r\n    converterRegistry.addConverter(new StringToCurrencyConverter());\r\n    converterRegistry.addConverter(Currency.class, String.class, new ObjectToStringConverter());\r\n    converterRegistry.addConverter(new StringToPropertiesConverter());\r\n    converterRegistry.addConverter(new PropertiesToStringConverter());\r\n    converterRegistry.addConverter(new StringToUUIDConverter());\r\n    converterRegistry.addConverter(UUID.class, String.class, new ObjectToStringConverter());\r\n    converterRegistry.addConverter(new StringToPatternConverter());\r\n    converterRegistry.addConverter(Pattern.class, String.class, new ObjectToStringConverter());\r\n    if (KotlinDetector.isKotlinPresent()) {\r\n        converterRegistry.addConverter(new StringToRegexConverter());\r\n        converterRegistry.addConverter(kotlin.text.Regex.class, String.class, new ObjectToStringConverter());\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.EnumToIntegerConverter",
    "entityType": "class",
    "code": "public EnumToIntegerConverter(ConversionService conversionService) {\r\n    super(conversionService);\r\n}\n@Override\r\npublic Integer convert(Enum<?> source) {\r\n    return source.ordinal();\r\n}",
    "comment": "\n * Calls {@link Enum#ordinal()} to convert a source Enum to an Integer.\n * This converter will not match enums with interfaces that can be converted.\n *\n * @author Yanming Zhou\n * @since 4.3\n "
  },
  {
    "entityId": "org.springframework.core.convert.support.EnumToIntegerConverter#convert(Enum<?>)",
    "entityType": "method",
    "code": "@Override\r\npublic Integer convert(Enum<?> source) {\r\n    return source.ordinal();\r\n}",
    "comment": ""
  }
]