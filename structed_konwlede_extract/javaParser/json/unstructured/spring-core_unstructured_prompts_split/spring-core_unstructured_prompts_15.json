[
  {
    "entityId": "org.springframework.aot.hint.SimpleTypeReference#getCanonicalName()",
    "entityType": "method",
    "code": "@Override\r\npublic String getCanonicalName() {\r\n    if (this.canonicalName == null) {\r\n        StringBuilder names = new StringBuilder();\r\n        buildName(this, names);\r\n        this.canonicalName = addPackageIfNecessary(names.toString());\r\n    }\r\n    return this.canonicalName;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SimpleTypeReference#isPrimitive()",
    "entityType": "method",
    "code": "@Override\r\nprotected boolean isPrimitive() {\r\n    return isPrimitive(getSimpleName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SimpleTypeReference#isPrimitive(String)",
    "entityType": "method",
    "code": "private static boolean isPrimitive(String name) {\r\n    return PRIMITIVE_NAMES.stream().anyMatch(name::startsWith);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SimpleTypeReference#buildName(TypeReference,StringBuilder)",
    "entityType": "method",
    "code": "private static void buildName(@Nullable TypeReference type, StringBuilder sb) {\r\n    if (type == null) {\r\n        return;\r\n    }\r\n    String typeName = (type.getEnclosingType() != null ? \".\" + type.getSimpleName() : type.getSimpleName());\r\n    sb.insert(0, typeName);\r\n    buildName(type.getEnclosingType(), sb);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ExceptionTypeFilterTests",
    "entityType": "class",
    "code": "@Test\r\nvoid subClassMatch() {\r\n    ExceptionTypeFilter filter = new ExceptionTypeFilter(List.of(RuntimeException.class), null, true);\r\n    assertThat(filter.match(RuntimeException.class)).isTrue();\r\n    assertThat(filter.match(IllegalStateException.class)).isTrue();\r\n}",
    "comment": "\n * @author Stephane Nicoll\n "
  },
  {
    "entityId": "org.springframework.util.ExceptionTypeFilterTests#subClassMatch()",
    "entityType": "method",
    "code": "@Test\r\nvoid subClassMatch() {\r\n    ExceptionTypeFilter filter = new ExceptionTypeFilter(List.of(RuntimeException.class), null, true);\r\n    assertThat(filter.match(RuntimeException.class)).isTrue();\r\n    assertThat(filter.match(IllegalStateException.class)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.support.ClassHintUtils",
    "entityType": "class",
    "code": "private static final Consumer<TypeHint.Builder> asClassBasedProxy = hint -> hint.withMembers(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS, MemberCategory.ACCESS_DECLARED_FIELDS);\nprivate static final Consumer<TypeHint.Builder> asProxiedUserClass = hint -> hint.withMembers(MemberCategory.INVOKE_PUBLIC_METHODS, MemberCategory.INVOKE_DECLARED_METHODS);\n/**\r\n * Register a proxy hint for a JDK proxy or corresponding reflection hints\r\n * for a CGLIB-generated subclass, if necessary.\r\n * @param candidateClass the class to introspect\r\n * @param runtimeHints the RuntimeHints instance to register the hints on\r\n * @see Proxy#isProxyClass(Class)\r\n * @see ClassUtils#getUserClass(Class)\r\n */\r\npublic static void registerProxyIfNecessary(Class<?> candidateClass, RuntimeHints runtimeHints) {\r\n    if (Proxy.isProxyClass(candidateClass)) {\r\n        // A JDK proxy class needs an explicit hint\r\n        runtimeHints.proxies().registerJdkProxy(candidateClass.getInterfaces());\r\n    } else {\r\n        // Potentially a CGLIB-generated subclass with reflection hints\r\n        Class<?> userClass = ClassUtils.getUserClass(candidateClass);\r\n        if (userClass != candidateClass) {\r\n            runtimeHints.reflection().registerType(candidateClass, asClassBasedProxy).registerType(userClass, asProxiedUserClass);\r\n        }\r\n    }\r\n}",
    "comment": "\n * Utilities for core hint inference on Spring-managed classes,\n * specifically for proxy types such as interface-based JDK proxies\n * and CGLIB-generated subclasses which need proxy/reflection hints.\n *\n * <p>Note that this class does not take specifics of Spring AOP or\n * any other framework arrangement into account. It just operates\n * on the JDK and CGLIB proxy facilities and their core conventions.\n *\n * @author Juergen Hoeller\n * @author Sebastien Deleuze\n * @since 6.0.3\n * @see org.springframework.aot.hint.ProxyHints\n * @see org.springframework.aot.hint.ReflectionHints\n "
  },
  {
    "entityId": "org.springframework.aot.hint.support.ClassHintUtils#registerProxyIfNecessary(Class<?>,RuntimeHints)",
    "entityType": "method",
    "code": "/**\r\n * Register a proxy hint for a JDK proxy or corresponding reflection hints\r\n * for a CGLIB-generated subclass, if necessary.\r\n * @param candidateClass the class to introspect\r\n * @param runtimeHints the RuntimeHints instance to register the hints on\r\n * @see Proxy#isProxyClass(Class)\r\n * @see ClassUtils#getUserClass(Class)\r\n */\r\npublic static void registerProxyIfNecessary(Class<?> candidateClass, RuntimeHints runtimeHints) {\r\n    if (Proxy.isProxyClass(candidateClass)) {\r\n        // A JDK proxy class needs an explicit hint\r\n        runtimeHints.proxies().registerJdkProxy(candidateClass.getInterfaces());\r\n    } else {\r\n        // Potentially a CGLIB-generated subclass with reflection hints\r\n        Class<?> userClass = ClassUtils.getUserClass(candidateClass);\r\n        if (userClass != candidateClass) {\r\n            runtimeHints.reflection().registerType(candidateClass, asClassBasedProxy).registerType(userClass, asProxiedUserClass);\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Register a proxy hint for a JDK proxy or corresponding reflection hints\n\t * for a CGLIB-generated subclass, if necessary.\n\t * @param candidateClass the class to introspect\n\t * @param runtimeHints the RuntimeHints instance to register the hints on\n\t * @see Proxy#isProxyClass(Class)\n\t * @see ClassUtils#getUserClass(Class)\n\t "
  },
  {
    "entityId": "org.springframework.util.ExponentialBackOffTests",
    "entityType": "class",
    "code": "@Test\r\nvoid defaultInstance() {\r\n    ExponentialBackOff backOff = new ExponentialBackOff();\r\n    BackOffExecution execution = backOff.start();\r\n    assertThat(execution.nextBackOff()).isEqualTo(2000L);\r\n    assertThat(execution.nextBackOff()).isEqualTo(3000L);\r\n    assertThat(execution.nextBackOff()).isEqualTo(4500L);\r\n}\n@Test\r\nvoid simpleIncrease() {\r\n    ExponentialBackOff backOff = new ExponentialBackOff(100L, 2.0);\r\n    BackOffExecution execution = backOff.start();\r\n    assertThat(execution.nextBackOff()).isEqualTo(100L);\r\n    assertThat(execution.nextBackOff()).isEqualTo(200L);\r\n    assertThat(execution.nextBackOff()).isEqualTo(400L);\r\n    assertThat(execution.nextBackOff()).isEqualTo(800L);\r\n}\n@Test\r\nvoid fixedIncrease() {\r\n    ExponentialBackOff backOff = new ExponentialBackOff(100L, 1.0);\r\n    backOff.setMaxElapsedTime(300L);\r\n    BackOffExecution execution = backOff.start();\r\n    assertThat(execution.nextBackOff()).isEqualTo(100L);\r\n    assertThat(execution.nextBackOff()).isEqualTo(100L);\r\n    assertThat(execution.nextBackOff()).isEqualTo(100L);\r\n    assertThat(execution.nextBackOff()).isEqualTo(BackOffExecution.STOP);\r\n}\n@Test\r\nvoid maxIntervalReached() {\r\n    ExponentialBackOff backOff = new ExponentialBackOff(2000L, 2.0);\r\n    backOff.setMaxInterval(4000L);\r\n    BackOffExecution execution = backOff.start();\r\n    assertThat(execution.nextBackOff()).isEqualTo(2000L);\r\n    assertThat(execution.nextBackOff()).isEqualTo(4000L);\r\n    // max reached\r\n    assertThat(execution.nextBackOff()).isEqualTo(4000L);\r\n    assertThat(execution.nextBackOff()).isEqualTo(4000L);\r\n}\n@Test\r\nvoid maxAttemptsReached() {\r\n    ExponentialBackOff backOff = new ExponentialBackOff(2000L, 2.0);\r\n    backOff.setMaxElapsedTime(4000L);\r\n    BackOffExecution execution = backOff.start();\r\n    assertThat(execution.nextBackOff()).isEqualTo(2000L);\r\n    assertThat(execution.nextBackOff()).isEqualTo(4000L);\r\n    // > 4 sec wait in total\r\n    assertThat(execution.nextBackOff()).isEqualTo(BackOffExecution.STOP);\r\n}\n@Test\r\nvoid startReturnDifferentInstances() {\r\n    ExponentialBackOff backOff = new ExponentialBackOff();\r\n    backOff.setInitialInterval(2000L);\r\n    backOff.setMultiplier(2.0);\r\n    backOff.setMaxElapsedTime(4000L);\r\n    BackOffExecution execution = backOff.start();\r\n    BackOffExecution execution2 = backOff.start();\r\n    assertThat(execution.nextBackOff()).isEqualTo(2000L);\r\n    assertThat(execution2.nextBackOff()).isEqualTo(2000L);\r\n    assertThat(execution.nextBackOff()).isEqualTo(4000L);\r\n    assertThat(execution2.nextBackOff()).isEqualTo(4000L);\r\n    assertThat(execution.nextBackOff()).isEqualTo(BackOffExecution.STOP);\r\n    assertThat(execution2.nextBackOff()).isEqualTo(BackOffExecution.STOP);\r\n}\n@Test\r\nvoid invalidInterval() {\r\n    ExponentialBackOff backOff = new ExponentialBackOff();\r\n    assertThatIllegalArgumentException().isThrownBy(() -> backOff.setMultiplier(0.9));\r\n}\n@Test\r\nvoid maxIntervalReachedImmediately() {\r\n    ExponentialBackOff backOff = new ExponentialBackOff(1000L, 2.0);\r\n    backOff.setMaxInterval(50L);\r\n    BackOffExecution execution = backOff.start();\r\n    assertThat(execution.nextBackOff()).isEqualTo(50L);\r\n    assertThat(execution.nextBackOff()).isEqualTo(50L);\r\n}\n@Test\r\nvoid executionToStringContent() {\r\n    ExponentialBackOff backOff = new ExponentialBackOff(2000L, 2.0);\r\n    BackOffExecution execution = backOff.start();\r\n    assertThat(execution.toString()).isEqualTo(\"ExponentialBackOffExecution{currentInterval=n/a, multiplier=2.0, attempts=0}\");\r\n    execution.nextBackOff();\r\n    assertThat(execution.toString()).isEqualTo(\"ExponentialBackOffExecution{currentInterval=2000ms, multiplier=2.0, attempts=1}\");\r\n    execution.nextBackOff();\r\n    assertThat(execution.toString()).isEqualTo(\"ExponentialBackOffExecution{currentInterval=4000ms, multiplier=2.0, attempts=2}\");\r\n}\n@Test\r\nvoid maxAttempts() {\r\n    ExponentialBackOff backOff = new ExponentialBackOff();\r\n    backOff.setInitialInterval(1000L);\r\n    backOff.setMultiplier(2.0);\r\n    backOff.setMaxInterval(10000L);\r\n    backOff.setMaxAttempts(6);\r\n    List<Long> delays = new ArrayList<>();\r\n    BackOffExecution execution = backOff.start();\r\n    IntStream.range(0, 7).forEach(i -> delays.add(execution.nextBackOff()));\r\n    assertThat(delays).containsExactly(1000L, 2000L, 4000L, 8000L, 10000L, 10000L, BackOffExecution.STOP);\r\n}",
    "comment": "\n * Tests for {@link ExponentialBackOff}.\n *\n * @author Stephane Nicoll\n "
  },
  {
    "entityId": "org.springframework.util.ExponentialBackOffTests#defaultInstance()",
    "entityType": "method",
    "code": "@Test\r\nvoid defaultInstance() {\r\n    ExponentialBackOff backOff = new ExponentialBackOff();\r\n    BackOffExecution execution = backOff.start();\r\n    assertThat(execution.nextBackOff()).isEqualTo(2000L);\r\n    assertThat(execution.nextBackOff()).isEqualTo(3000L);\r\n    assertThat(execution.nextBackOff()).isEqualTo(4500L);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ExponentialBackOffTests#simpleIncrease()",
    "entityType": "method",
    "code": "@Test\r\nvoid simpleIncrease() {\r\n    ExponentialBackOff backOff = new ExponentialBackOff(100L, 2.0);\r\n    BackOffExecution execution = backOff.start();\r\n    assertThat(execution.nextBackOff()).isEqualTo(100L);\r\n    assertThat(execution.nextBackOff()).isEqualTo(200L);\r\n    assertThat(execution.nextBackOff()).isEqualTo(400L);\r\n    assertThat(execution.nextBackOff()).isEqualTo(800L);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ExponentialBackOffTests#fixedIncrease()",
    "entityType": "method",
    "code": "@Test\r\nvoid fixedIncrease() {\r\n    ExponentialBackOff backOff = new ExponentialBackOff(100L, 1.0);\r\n    backOff.setMaxElapsedTime(300L);\r\n    BackOffExecution execution = backOff.start();\r\n    assertThat(execution.nextBackOff()).isEqualTo(100L);\r\n    assertThat(execution.nextBackOff()).isEqualTo(100L);\r\n    assertThat(execution.nextBackOff()).isEqualTo(100L);\r\n    assertThat(execution.nextBackOff()).isEqualTo(BackOffExecution.STOP);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ExponentialBackOffTests#maxIntervalReached()",
    "entityType": "method",
    "code": "@Test\r\nvoid maxIntervalReached() {\r\n    ExponentialBackOff backOff = new ExponentialBackOff(2000L, 2.0);\r\n    backOff.setMaxInterval(4000L);\r\n    BackOffExecution execution = backOff.start();\r\n    assertThat(execution.nextBackOff()).isEqualTo(2000L);\r\n    assertThat(execution.nextBackOff()).isEqualTo(4000L);\r\n    // max reached\r\n    assertThat(execution.nextBackOff()).isEqualTo(4000L);\r\n    assertThat(execution.nextBackOff()).isEqualTo(4000L);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ExponentialBackOffTests#maxAttemptsReached()",
    "entityType": "method",
    "code": "@Test\r\nvoid maxAttemptsReached() {\r\n    ExponentialBackOff backOff = new ExponentialBackOff(2000L, 2.0);\r\n    backOff.setMaxElapsedTime(4000L);\r\n    BackOffExecution execution = backOff.start();\r\n    assertThat(execution.nextBackOff()).isEqualTo(2000L);\r\n    assertThat(execution.nextBackOff()).isEqualTo(4000L);\r\n    // > 4 sec wait in total\r\n    assertThat(execution.nextBackOff()).isEqualTo(BackOffExecution.STOP);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ExponentialBackOffTests#startReturnDifferentInstances()",
    "entityType": "method",
    "code": "@Test\r\nvoid startReturnDifferentInstances() {\r\n    ExponentialBackOff backOff = new ExponentialBackOff();\r\n    backOff.setInitialInterval(2000L);\r\n    backOff.setMultiplier(2.0);\r\n    backOff.setMaxElapsedTime(4000L);\r\n    BackOffExecution execution = backOff.start();\r\n    BackOffExecution execution2 = backOff.start();\r\n    assertThat(execution.nextBackOff()).isEqualTo(2000L);\r\n    assertThat(execution2.nextBackOff()).isEqualTo(2000L);\r\n    assertThat(execution.nextBackOff()).isEqualTo(4000L);\r\n    assertThat(execution2.nextBackOff()).isEqualTo(4000L);\r\n    assertThat(execution.nextBackOff()).isEqualTo(BackOffExecution.STOP);\r\n    assertThat(execution2.nextBackOff()).isEqualTo(BackOffExecution.STOP);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ExponentialBackOffTests#invalidInterval()",
    "entityType": "method",
    "code": "@Test\r\nvoid invalidInterval() {\r\n    ExponentialBackOff backOff = new ExponentialBackOff();\r\n    assertThatIllegalArgumentException().isThrownBy(() -> backOff.setMultiplier(0.9));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ExponentialBackOffTests#maxIntervalReachedImmediately()",
    "entityType": "method",
    "code": "@Test\r\nvoid maxIntervalReachedImmediately() {\r\n    ExponentialBackOff backOff = new ExponentialBackOff(1000L, 2.0);\r\n    backOff.setMaxInterval(50L);\r\n    BackOffExecution execution = backOff.start();\r\n    assertThat(execution.nextBackOff()).isEqualTo(50L);\r\n    assertThat(execution.nextBackOff()).isEqualTo(50L);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ExponentialBackOffTests#executionToStringContent()",
    "entityType": "method",
    "code": "@Test\r\nvoid executionToStringContent() {\r\n    ExponentialBackOff backOff = new ExponentialBackOff(2000L, 2.0);\r\n    BackOffExecution execution = backOff.start();\r\n    assertThat(execution.toString()).isEqualTo(\"ExponentialBackOffExecution{currentInterval=n/a, multiplier=2.0, attempts=0}\");\r\n    execution.nextBackOff();\r\n    assertThat(execution.toString()).isEqualTo(\"ExponentialBackOffExecution{currentInterval=2000ms, multiplier=2.0, attempts=1}\");\r\n    execution.nextBackOff();\r\n    assertThat(execution.toString()).isEqualTo(\"ExponentialBackOffExecution{currentInterval=4000ms, multiplier=2.0, attempts=2}\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ExponentialBackOffTests#maxAttempts()",
    "entityType": "method",
    "code": "@Test\r\nvoid maxAttempts() {\r\n    ExponentialBackOff backOff = new ExponentialBackOff();\r\n    backOff.setInitialInterval(1000L);\r\n    backOff.setMultiplier(2.0);\r\n    backOff.setMaxInterval(10000L);\r\n    backOff.setMaxAttempts(6);\r\n    List<Long> delays = new ArrayList<>();\r\n    BackOffExecution execution = backOff.start();\r\n    IntStream.range(0, 7).forEach(i -> delays.add(execution.nextBackOff()));\r\n    assertThat(delays).containsExactly(1000L, 2000L, 4000L, 8000L, 10000L, 10000L, BackOffExecution.STOP);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.support.FilePatternResourceHintsRegistrar",
    "entityType": "class",
    "code": "private final List<String> classpathLocations;\nprivate final List<String> filePrefixes;\nprivate final List<String> fileExtensions;\nprivate FilePatternResourceHintsRegistrar(List<String> filePrefixes, List<String> classpathLocations, List<String> fileExtensions) {\r\n    this.classpathLocations = validateClassPathLocations(classpathLocations);\r\n    this.filePrefixes = validateFilePrefixes(filePrefixes);\r\n    this.fileExtensions = validateFileExtensions(fileExtensions);\r\n}\nprivate void registerHints(ResourceHints hints, @Nullable ClassLoader classLoader) {\r\n    ClassLoader classLoaderToUse = (classLoader != null ? classLoader : getClass().getClassLoader());\r\n    List<String> includes = new ArrayList<>();\r\n    for (String location : this.classpathLocations) {\r\n        if (classLoaderToUse.getResource(location) != null) {\r\n            for (String filePrefix : this.filePrefixes) {\r\n                for (String fileExtension : this.fileExtensions) {\r\n                    includes.add(location + filePrefix + \"*\" + fileExtension);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (!includes.isEmpty()) {\r\n        hints.registerPattern(hint -> hint.includes(includes.toArray(String[]::new)));\r\n    }\r\n}\n/**\r\n * Configure the registrar with the specified\r\n * {@linkplain Builder#withClassPathLocations(String...) classpath locations}.\r\n * @param classpathLocations the classpath locations\r\n * @return a {@link Builder} to further configure the registrar\r\n * @since 6.0.12\r\n * @see #forClassPathLocations(List)\r\n */\r\npublic static Builder forClassPathLocations(String... classpathLocations) {\r\n    return forClassPathLocations(Arrays.asList(classpathLocations));\r\n}\n/**\r\n * Configure the registrar with the specified\r\n * {@linkplain Builder#withClassPathLocations(List) classpath locations}.\r\n * @param classpathLocations the classpath locations\r\n * @return a {@link Builder} to further configure the registrar\r\n * @since 6.0.12\r\n * @see #forClassPathLocations(String...)\r\n */\r\npublic static Builder forClassPathLocations(List<String> classpathLocations) {\r\n    return new Builder().withClassPathLocations(classpathLocations);\r\n}\nprivate static List<String> validateClassPathLocations(List<String> classpathLocations) {\r\n    Assert.notEmpty(classpathLocations, \"At least one classpath location must be specified\");\r\n    List<String> parsedLocations = new ArrayList<>();\r\n    for (String location : classpathLocations) {\r\n        if (location.startsWith(ResourceUtils.CLASSPATH_URL_PREFIX)) {\r\n            location = location.substring(ResourceUtils.CLASSPATH_URL_PREFIX.length());\r\n        }\r\n        if (location.startsWith(\"/\")) {\r\n            location = location.substring(1);\r\n        }\r\n        if (!location.isEmpty() && !location.endsWith(\"/\")) {\r\n            location = location + \"/\";\r\n        }\r\n        parsedLocations.add(location);\r\n    }\r\n    return parsedLocations;\r\n}\nprivate static List<String> validateFilePrefixes(List<String> filePrefixes) {\r\n    for (String filePrefix : filePrefixes) {\r\n        if (filePrefix.contains(\"*\")) {\r\n            throw new IllegalArgumentException(\"File prefix '\" + filePrefix + \"' cannot contain '*'\");\r\n        }\r\n    }\r\n    return filePrefixes;\r\n}\nprivate static List<String> validateFileExtensions(List<String> fileExtensions) {\r\n    for (String fileExtension : fileExtensions) {\r\n        if (!fileExtension.startsWith(\".\")) {\r\n            throw new IllegalArgumentException(\"Extension '\" + fileExtension + \"' must start with '.'\");\r\n        }\r\n    }\r\n    return fileExtensions;\r\n}\n/**\r\n * Builder for {@link FilePatternResourceHintsRegistrar}.\r\n * @since 6.0.12\r\n */\r\npublic static final class Builder {\r\n\r\n    private final List<String> classpathLocations = new ArrayList<>();\r\n\r\n    private final List<String> filePrefixes = new ArrayList<>();\r\n\r\n    private final List<String> fileExtensions = new ArrayList<>();\r\n\r\n    private Builder() {\r\n        // no-op\r\n    }\r\n\r\n    /**\r\n     * Consider the specified classpath locations.\r\n     * @deprecated in favor of {@link #withClassPathLocations(String...)}\r\n     */\r\n    @Deprecated(since = \"7.0\", forRemoval = true)\r\n    public Builder withClasspathLocations(String... classpathLocations) {\r\n        return withClassPathLocations(Arrays.asList(classpathLocations));\r\n    }\r\n\r\n    /**\r\n     * Consider the specified classpath locations.\r\n     * @deprecated in favor of {@link #withClassPathLocations(List)}\r\n     */\r\n    @Deprecated(since = \"7.0\", forRemoval = true)\r\n    public Builder withClasspathLocations(List<String> classpathLocations) {\r\n        return withClassPathLocations(classpathLocations);\r\n    }\r\n\r\n    /**\r\n     * Consider the specified classpath locations.\r\n     * <p>A location can either be a special {@value ResourceUtils#CLASSPATH_URL_PREFIX}\r\n     * pseudo location or a standard location, such as {@code com/example/resources}.\r\n     * An empty String represents the root of the classpath.\r\n     * @param classpathLocations the classpath locations to consider\r\n     * @return this builder\r\n     * @since 7.0\r\n     * @see #withClassPathLocations(List)\r\n     */\r\n    public Builder withClassPathLocations(String... classpathLocations) {\r\n        return withClassPathLocations(Arrays.asList(classpathLocations));\r\n    }\r\n\r\n    /**\r\n     * Consider the specified classpath locations.\r\n     * <p>A location can either be a special {@value ResourceUtils#CLASSPATH_URL_PREFIX}\r\n     * pseudo location or a standard location, such as {@code com/example/resources}.\r\n     * An empty String represents the root of the classpath.\r\n     * @param classpathLocations the classpath locations to consider\r\n     * @return this builder\r\n     * @since 7.0\r\n     * @see #withClassPathLocations(String...)\r\n     */\r\n    public Builder withClassPathLocations(List<String> classpathLocations) {\r\n        this.classpathLocations.addAll(validateClassPathLocations(classpathLocations));\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Consider the specified file prefixes. Any file whose name starts with one\r\n     * of the specified prefixes is considered. A prefix cannot contain the {@code *}\r\n     * character.\r\n     * @param filePrefixes the file prefixes to consider\r\n     * @return this builder\r\n     * @see #withFilePrefixes(List)\r\n     */\r\n    public Builder withFilePrefixes(String... filePrefixes) {\r\n        return withFilePrefixes(Arrays.asList(filePrefixes));\r\n    }\r\n\r\n    /**\r\n     * Consider the specified file prefixes. Any file whose name starts with one\r\n     * of the specified prefixes is considered. A prefix cannot contain the {@code *}\r\n     * character.\r\n     * @param filePrefixes the file prefixes to consider\r\n     * @return this builder\r\n     * @see #withFilePrefixes(String...)\r\n     */\r\n    public Builder withFilePrefixes(List<String> filePrefixes) {\r\n        this.filePrefixes.addAll(validateFilePrefixes(filePrefixes));\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Consider the specified file extensions. A file extension must start with a\r\n     * {@code .} character.\r\n     * @param fileExtensions the file extensions to consider\r\n     * @return this builder\r\n     * @see #withFileExtensions(List)\r\n     */\r\n    public Builder withFileExtensions(String... fileExtensions) {\r\n        return withFileExtensions(Arrays.asList(fileExtensions));\r\n    }\r\n\r\n    /**\r\n     * Consider the specified file extensions. A file extension must start with a\r\n     * {@code .} character.\r\n     * @param fileExtensions the file extensions to consider\r\n     * @return this builder\r\n     * @see #withFileExtensions(String...)\r\n     */\r\n    public Builder withFileExtensions(List<String> fileExtensions) {\r\n        this.fileExtensions.addAll(validateFileExtensions(fileExtensions));\r\n        return this;\r\n    }\r\n\r\n    private FilePatternResourceHintsRegistrar build() {\r\n        return new FilePatternResourceHintsRegistrar(this.filePrefixes, this.classpathLocations, this.fileExtensions);\r\n    }\r\n\r\n    /**\r\n     * Register resource hints for the current state of this builder. For each\r\n     * classpath location that resolves against the {@code ClassLoader}, files\r\n     * with the configured file prefixes and extensions are registered.\r\n     * @param hints the hints contributed so far for the deployment unit\r\n     * @param classLoader the classloader, or {@code null} if even the system\r\n     * ClassLoader isn't accessible\r\n     */\r\n    public void registerHints(ResourceHints hints, @Nullable ClassLoader classLoader) {\r\n        build().registerHints(hints, classLoader);\r\n    }\r\n}",
    "comment": "\n * Register the necessary resource hints for loading files from the classpath,\n * based on file name prefixes and file extensions with convenience to support\n * multiple classpath locations.\n *\n * <p>Only registers hints for matching classpath locations, which allows for\n * several locations to be provided without contributing unnecessary hints.\n *\n * @author Stephane Nicoll\n * @author Sam Brannen\n * @author Juergen Hoeller\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.hint.support.FilePatternResourceHintsRegistrar#registerHints(ResourceHints,ClassLoader)",
    "entityType": "method",
    "code": "private void registerHints(ResourceHints hints, @Nullable ClassLoader classLoader) {\r\n    ClassLoader classLoaderToUse = (classLoader != null ? classLoader : getClass().getClassLoader());\r\n    List<String> includes = new ArrayList<>();\r\n    for (String location : this.classpathLocations) {\r\n        if (classLoaderToUse.getResource(location) != null) {\r\n            for (String filePrefix : this.filePrefixes) {\r\n                for (String fileExtension : this.fileExtensions) {\r\n                    includes.add(location + filePrefix + \"*\" + fileExtension);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (!includes.isEmpty()) {\r\n        hints.registerPattern(hint -> hint.includes(includes.toArray(String[]::new)));\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.support.FilePatternResourceHintsRegistrar#forClassPathLocations(String)",
    "entityType": "method",
    "code": "/**\r\n * Configure the registrar with the specified\r\n * {@linkplain Builder#withClassPathLocations(String...) classpath locations}.\r\n * @param classpathLocations the classpath locations\r\n * @return a {@link Builder} to further configure the registrar\r\n * @since 6.0.12\r\n * @see #forClassPathLocations(List)\r\n */\r\npublic static Builder forClassPathLocations(String... classpathLocations) {\r\n    return forClassPathLocations(Arrays.asList(classpathLocations));\r\n}",
    "comment": "\n\t * Configure the registrar with the specified\n\t * {@linkplain Builder#withClassPathLocations(String...) classpath locations}.\n\t * @param classpathLocations the classpath locations\n\t * @return a {@link Builder} to further configure the registrar\n\t * @since 6.0.12\n\t * @see #forClassPathLocations(List)\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.support.FilePatternResourceHintsRegistrar#forClassPathLocations(List<String>)",
    "entityType": "method",
    "code": "/**\r\n * Configure the registrar with the specified\r\n * {@linkplain Builder#withClassPathLocations(List) classpath locations}.\r\n * @param classpathLocations the classpath locations\r\n * @return a {@link Builder} to further configure the registrar\r\n * @since 6.0.12\r\n * @see #forClassPathLocations(String...)\r\n */\r\npublic static Builder forClassPathLocations(List<String> classpathLocations) {\r\n    return new Builder().withClassPathLocations(classpathLocations);\r\n}",
    "comment": "\n\t * Configure the registrar with the specified\n\t * {@linkplain Builder#withClassPathLocations(List) classpath locations}.\n\t * @param classpathLocations the classpath locations\n\t * @return a {@link Builder} to further configure the registrar\n\t * @since 6.0.12\n\t * @see #forClassPathLocations(String...)\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.support.FilePatternResourceHintsRegistrar#validateClassPathLocations(List<String>)",
    "entityType": "method",
    "code": "private static List<String> validateClassPathLocations(List<String> classpathLocations) {\r\n    Assert.notEmpty(classpathLocations, \"At least one classpath location must be specified\");\r\n    List<String> parsedLocations = new ArrayList<>();\r\n    for (String location : classpathLocations) {\r\n        if (location.startsWith(ResourceUtils.CLASSPATH_URL_PREFIX)) {\r\n            location = location.substring(ResourceUtils.CLASSPATH_URL_PREFIX.length());\r\n        }\r\n        if (location.startsWith(\"/\")) {\r\n            location = location.substring(1);\r\n        }\r\n        if (!location.isEmpty() && !location.endsWith(\"/\")) {\r\n            location = location + \"/\";\r\n        }\r\n        parsedLocations.add(location);\r\n    }\r\n    return parsedLocations;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.support.FilePatternResourceHintsRegistrar#validateFilePrefixes(List<String>)",
    "entityType": "method",
    "code": "private static List<String> validateFilePrefixes(List<String> filePrefixes) {\r\n    for (String filePrefix : filePrefixes) {\r\n        if (filePrefix.contains(\"*\")) {\r\n            throw new IllegalArgumentException(\"File prefix '\" + filePrefix + \"' cannot contain '*'\");\r\n        }\r\n    }\r\n    return filePrefixes;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.support.FilePatternResourceHintsRegistrar#validateFileExtensions(List<String>)",
    "entityType": "method",
    "code": "private static List<String> validateFileExtensions(List<String> fileExtensions) {\r\n    for (String fileExtension : fileExtensions) {\r\n        if (!fileExtension.startsWith(\".\")) {\r\n            throw new IllegalArgumentException(\"Extension '\" + fileExtension + \"' must start with '.'\");\r\n        }\r\n    }\r\n    return fileExtensions;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.support.Builder",
    "entityType": "class",
    "code": "private final List<String> classpathLocations = new ArrayList<>();\nprivate final List<String> filePrefixes = new ArrayList<>();\nprivate final List<String> fileExtensions = new ArrayList<>();\nprivate Builder() {\r\n    // no-op\r\n}\n/**\r\n * Consider the specified classpath locations.\r\n * @deprecated in favor of {@link #withClassPathLocations(String...)}\r\n */\r\n@Deprecated(since = \"7.0\", forRemoval = true)\r\npublic Builder withClasspathLocations(String... classpathLocations) {\r\n    return withClassPathLocations(Arrays.asList(classpathLocations));\r\n}\n/**\r\n * Consider the specified classpath locations.\r\n * @deprecated in favor of {@link #withClassPathLocations(List)}\r\n */\r\n@Deprecated(since = \"7.0\", forRemoval = true)\r\npublic Builder withClasspathLocations(List<String> classpathLocations) {\r\n    return withClassPathLocations(classpathLocations);\r\n}\n/**\r\n * Consider the specified classpath locations.\r\n * <p>A location can either be a special {@value ResourceUtils#CLASSPATH_URL_PREFIX}\r\n * pseudo location or a standard location, such as {@code com/example/resources}.\r\n * An empty String represents the root of the classpath.\r\n * @param classpathLocations the classpath locations to consider\r\n * @return this builder\r\n * @since 7.0\r\n * @see #withClassPathLocations(List)\r\n */\r\npublic Builder withClassPathLocations(String... classpathLocations) {\r\n    return withClassPathLocations(Arrays.asList(classpathLocations));\r\n}\n/**\r\n * Consider the specified classpath locations.\r\n * <p>A location can either be a special {@value ResourceUtils#CLASSPATH_URL_PREFIX}\r\n * pseudo location or a standard location, such as {@code com/example/resources}.\r\n * An empty String represents the root of the classpath.\r\n * @param classpathLocations the classpath locations to consider\r\n * @return this builder\r\n * @since 7.0\r\n * @see #withClassPathLocations(String...)\r\n */\r\npublic Builder withClassPathLocations(List<String> classpathLocations) {\r\n    this.classpathLocations.addAll(validateClassPathLocations(classpathLocations));\r\n    return this;\r\n}\n/**\r\n * Consider the specified file prefixes. Any file whose name starts with one\r\n * of the specified prefixes is considered. A prefix cannot contain the {@code *}\r\n * character.\r\n * @param filePrefixes the file prefixes to consider\r\n * @return this builder\r\n * @see #withFilePrefixes(List)\r\n */\r\npublic Builder withFilePrefixes(String... filePrefixes) {\r\n    return withFilePrefixes(Arrays.asList(filePrefixes));\r\n}\n/**\r\n * Consider the specified file prefixes. Any file whose name starts with one\r\n * of the specified prefixes is considered. A prefix cannot contain the {@code *}\r\n * character.\r\n * @param filePrefixes the file prefixes to consider\r\n * @return this builder\r\n * @see #withFilePrefixes(String...)\r\n */\r\npublic Builder withFilePrefixes(List<String> filePrefixes) {\r\n    this.filePrefixes.addAll(validateFilePrefixes(filePrefixes));\r\n    return this;\r\n}\n/**\r\n * Consider the specified file extensions. A file extension must start with a\r\n * {@code .} character.\r\n * @param fileExtensions the file extensions to consider\r\n * @return this builder\r\n * @see #withFileExtensions(List)\r\n */\r\npublic Builder withFileExtensions(String... fileExtensions) {\r\n    return withFileExtensions(Arrays.asList(fileExtensions));\r\n}\n/**\r\n * Consider the specified file extensions. A file extension must start with a\r\n * {@code .} character.\r\n * @param fileExtensions the file extensions to consider\r\n * @return this builder\r\n * @see #withFileExtensions(String...)\r\n */\r\npublic Builder withFileExtensions(List<String> fileExtensions) {\r\n    this.fileExtensions.addAll(validateFileExtensions(fileExtensions));\r\n    return this;\r\n}\nprivate FilePatternResourceHintsRegistrar build() {\r\n    return new FilePatternResourceHintsRegistrar(this.filePrefixes, this.classpathLocations, this.fileExtensions);\r\n}\n/**\r\n * Register resource hints for the current state of this builder. For each\r\n * classpath location that resolves against the {@code ClassLoader}, files\r\n * with the configured file prefixes and extensions are registered.\r\n * @param hints the hints contributed so far for the deployment unit\r\n * @param classLoader the classloader, or {@code null} if even the system\r\n * ClassLoader isn't accessible\r\n */\r\npublic void registerHints(ResourceHints hints, @Nullable ClassLoader classLoader) {\r\n    build().registerHints(hints, classLoader);\r\n}",
    "comment": "\n\t * Builder for {@link FilePatternResourceHintsRegistrar}.\n\t * @since 6.0.12\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.support.Builder#withClasspathLocations(String)",
    "entityType": "method",
    "code": "/**\r\n * Consider the specified classpath locations.\r\n * @deprecated in favor of {@link #withClassPathLocations(String...)}\r\n */\r\n@Deprecated(since = \"7.0\", forRemoval = true)\r\npublic Builder withClasspathLocations(String... classpathLocations) {\r\n    return withClassPathLocations(Arrays.asList(classpathLocations));\r\n}",
    "comment": "\n\t\t * Consider the specified classpath locations.\n\t\t * @deprecated in favor of {@link #withClassPathLocations(String...)}\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.hint.support.Builder#withClasspathLocations(List<String>)",
    "entityType": "method",
    "code": "/**\r\n * Consider the specified classpath locations.\r\n * @deprecated in favor of {@link #withClassPathLocations(List)}\r\n */\r\n@Deprecated(since = \"7.0\", forRemoval = true)\r\npublic Builder withClasspathLocations(List<String> classpathLocations) {\r\n    return withClassPathLocations(classpathLocations);\r\n}",
    "comment": "\n\t\t * Consider the specified classpath locations.\n\t\t * @deprecated in favor of {@link #withClassPathLocations(List)}\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.hint.support.Builder#withClassPathLocations(String)",
    "entityType": "method",
    "code": "/**\r\n * Consider the specified classpath locations.\r\n * <p>A location can either be a special {@value ResourceUtils#CLASSPATH_URL_PREFIX}\r\n * pseudo location or a standard location, such as {@code com/example/resources}.\r\n * An empty String represents the root of the classpath.\r\n * @param classpathLocations the classpath locations to consider\r\n * @return this builder\r\n * @since 7.0\r\n * @see #withClassPathLocations(List)\r\n */\r\npublic Builder withClassPathLocations(String... classpathLocations) {\r\n    return withClassPathLocations(Arrays.asList(classpathLocations));\r\n}",
    "comment": "\n\t\t * Consider the specified classpath locations.\n\t\t * <p>A location can either be a special {@value ResourceUtils#CLASSPATH_URL_PREFIX}\n\t\t * pseudo location or a standard location, such as {@code com/example/resources}.\n\t\t * An empty String represents the root of the classpath.\n\t\t * @param classpathLocations the classpath locations to consider\n\t\t * @return this builder\n\t\t * @since 7.0\n\t\t * @see #withClassPathLocations(List)\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.hint.support.Builder#withClassPathLocations(List<String>)",
    "entityType": "method",
    "code": "/**\r\n * Consider the specified classpath locations.\r\n * <p>A location can either be a special {@value ResourceUtils#CLASSPATH_URL_PREFIX}\r\n * pseudo location or a standard location, such as {@code com/example/resources}.\r\n * An empty String represents the root of the classpath.\r\n * @param classpathLocations the classpath locations to consider\r\n * @return this builder\r\n * @since 7.0\r\n * @see #withClassPathLocations(String...)\r\n */\r\npublic Builder withClassPathLocations(List<String> classpathLocations) {\r\n    this.classpathLocations.addAll(validateClassPathLocations(classpathLocations));\r\n    return this;\r\n}",
    "comment": "\n\t\t * Consider the specified classpath locations.\n\t\t * <p>A location can either be a special {@value ResourceUtils#CLASSPATH_URL_PREFIX}\n\t\t * pseudo location or a standard location, such as {@code com/example/resources}.\n\t\t * An empty String represents the root of the classpath.\n\t\t * @param classpathLocations the classpath locations to consider\n\t\t * @return this builder\n\t\t * @since 7.0\n\t\t * @see #withClassPathLocations(String...)\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.hint.support.Builder#withFilePrefixes(String)",
    "entityType": "method",
    "code": "/**\r\n * Consider the specified file prefixes. Any file whose name starts with one\r\n * of the specified prefixes is considered. A prefix cannot contain the {@code *}\r\n * character.\r\n * @param filePrefixes the file prefixes to consider\r\n * @return this builder\r\n * @see #withFilePrefixes(List)\r\n */\r\npublic Builder withFilePrefixes(String... filePrefixes) {\r\n    return withFilePrefixes(Arrays.asList(filePrefixes));\r\n}",
    "comment": "\n\t\t * Consider the specified file prefixes. Any file whose name starts with one\n\t\t * of the specified prefixes is considered. A prefix cannot contain the {@code *}\n\t\t * character.\n\t\t * @param filePrefixes the file prefixes to consider\n\t\t * @return this builder\n\t\t * @see #withFilePrefixes(List)\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.hint.support.Builder#withFilePrefixes(List<String>)",
    "entityType": "method",
    "code": "/**\r\n * Consider the specified file prefixes. Any file whose name starts with one\r\n * of the specified prefixes is considered. A prefix cannot contain the {@code *}\r\n * character.\r\n * @param filePrefixes the file prefixes to consider\r\n * @return this builder\r\n * @see #withFilePrefixes(String...)\r\n */\r\npublic Builder withFilePrefixes(List<String> filePrefixes) {\r\n    this.filePrefixes.addAll(validateFilePrefixes(filePrefixes));\r\n    return this;\r\n}",
    "comment": "\n\t\t * Consider the specified file prefixes. Any file whose name starts with one\n\t\t * of the specified prefixes is considered. A prefix cannot contain the {@code *}\n\t\t * character.\n\t\t * @param filePrefixes the file prefixes to consider\n\t\t * @return this builder\n\t\t * @see #withFilePrefixes(String...)\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.hint.support.Builder#withFileExtensions(String)",
    "entityType": "method",
    "code": "/**\r\n * Consider the specified file extensions. A file extension must start with a\r\n * {@code .} character.\r\n * @param fileExtensions the file extensions to consider\r\n * @return this builder\r\n * @see #withFileExtensions(List)\r\n */\r\npublic Builder withFileExtensions(String... fileExtensions) {\r\n    return withFileExtensions(Arrays.asList(fileExtensions));\r\n}",
    "comment": "\n\t\t * Consider the specified file extensions. A file extension must start with a\n\t\t * {@code .} character.\n\t\t * @param fileExtensions the file extensions to consider\n\t\t * @return this builder\n\t\t * @see #withFileExtensions(List)\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.hint.support.Builder#withFileExtensions(List<String>)",
    "entityType": "method",
    "code": "/**\r\n * Consider the specified file extensions. A file extension must start with a\r\n * {@code .} character.\r\n * @param fileExtensions the file extensions to consider\r\n * @return this builder\r\n * @see #withFileExtensions(String...)\r\n */\r\npublic Builder withFileExtensions(List<String> fileExtensions) {\r\n    this.fileExtensions.addAll(validateFileExtensions(fileExtensions));\r\n    return this;\r\n}",
    "comment": "\n\t\t * Consider the specified file extensions. A file extension must start with a\n\t\t * {@code .} character.\n\t\t * @param fileExtensions the file extensions to consider\n\t\t * @return this builder\n\t\t * @see #withFileExtensions(String...)\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.hint.support.Builder#build()",
    "entityType": "method",
    "code": "private FilePatternResourceHintsRegistrar build() {\r\n    return new FilePatternResourceHintsRegistrar(this.filePrefixes, this.classpathLocations, this.fileExtensions);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.support.Builder#registerHints(ResourceHints,ClassLoader)",
    "entityType": "method",
    "code": "/**\r\n * Register resource hints for the current state of this builder. For each\r\n * classpath location that resolves against the {@code ClassLoader}, files\r\n * with the configured file prefixes and extensions are registered.\r\n * @param hints the hints contributed so far for the deployment unit\r\n * @param classLoader the classloader, or {@code null} if even the system\r\n * ClassLoader isn't accessible\r\n */\r\npublic void registerHints(ResourceHints hints, @Nullable ClassLoader classLoader) {\r\n    build().registerHints(hints, classLoader);\r\n}",
    "comment": "\n\t\t * Register resource hints for the current state of this builder. For each\n\t\t * classpath location that resolves against the {@code ClassLoader}, files\n\t\t * with the configured file prefixes and extensions are registered.\n\t\t * @param hints the hints contributed so far for the deployment unit\n\t\t * @param classLoader the classloader, or {@code null} if even the system\n\t\t * ClassLoader isn't accessible\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.hint.support.KotlinDetectorRuntimeHints",
    "entityType": "class",
    "code": "@Override\r\npublic void registerHints(RuntimeHints hints, @Nullable ClassLoader classLoader) {\r\n    hints.reflection().registerType(TypeReference.of(\"kotlin.Metadata\")).registerType(TypeReference.of(\"kotlin.reflect.full.KClasses\"));\r\n}",
    "comment": "\n * {@link RuntimeHintsRegistrar} to register hints for {@link org.springframework.core.KotlinDetector}.\n *\n * @author Brian Clozel\n * @since 6.1\n "
  },
  {
    "entityId": "org.springframework.aot.hint.support.KotlinDetectorRuntimeHints#registerHints(RuntimeHints,ClassLoader)",
    "entityType": "method",
    "code": "@Override\r\npublic void registerHints(RuntimeHints hints, @Nullable ClassLoader classLoader) {\r\n    hints.reflection().registerType(TypeReference.of(\"kotlin.Metadata\")).registerType(TypeReference.of(\"kotlin.reflect.full.KClasses\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStreamTests",
    "entityType": "class",
    "code": "private final FastByteArrayOutputStream os = new FastByteArrayOutputStream();\nprivate final byte[] helloBytes = \"Hello World\".getBytes(StandardCharsets.UTF_8);\n@Test\r\nvoid size() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    assertThat(this.helloBytes).hasSize(this.os.size());\r\n}\n@Test\r\nvoid resize() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    int sizeBefore = this.os.size();\r\n    this.os.resize(64);\r\n    assertByteArrayEqualsString(this.os);\r\n    assertThat(this.os.size()).isEqualTo(sizeBefore);\r\n}\n@Test\r\nvoid stringConversion() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    assertThat(this.os.toString()).isEqualTo(\"Hello World\");\r\n    assertThat(this.os.toString(StandardCharsets.UTF_8)).isEqualTo(\"Hello World\");\r\n    @SuppressWarnings(\"resource\")\r\n    FastByteArrayOutputStream empty = new FastByteArrayOutputStream();\r\n    assertThat(empty.toString()).isEqualTo(\"\");\r\n    assertThat(empty.toString(StandardCharsets.US_ASCII)).isEqualTo(\"\");\r\n    @SuppressWarnings(\"resource\")\r\n    FastByteArrayOutputStream outputStream = new FastByteArrayOutputStream(5);\r\n    // Add bytes in multiple writes to ensure we get more than one buffer internally\r\n    outputStream.write(this.helloBytes, 0, 5);\r\n    outputStream.write(this.helloBytes, 5, 6);\r\n    assertThat(outputStream.toString()).isEqualTo(\"Hello World\");\r\n    assertThat(outputStream.toString(StandardCharsets.UTF_8)).isEqualTo(\"Hello World\");\r\n}\n@Test\r\nvoid autoGrow() throws IOException {\r\n    this.os.resize(1);\r\n    for (int i = 0; i < 10; i++) {\r\n        this.os.write(1);\r\n    }\r\n    assertThat(this.os.size()).isEqualTo(10);\r\n    assertThat(new byte[] { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }).isEqualTo(this.os.toByteArray());\r\n}\n@Test\r\nvoid write() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    assertByteArrayEqualsString(this.os);\r\n}\n@Test\r\nvoid reset() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    assertByteArrayEqualsString(this.os);\r\n    this.os.reset();\r\n    assertThat(this.os.size()).isEqualTo(0);\r\n    this.os.write(this.helloBytes);\r\n    assertByteArrayEqualsString(this.os);\r\n}\n@Test\r\nvoid close() {\r\n    this.os.close();\r\n    assertThatIOException().isThrownBy(() -> this.os.write(this.helloBytes));\r\n}\n@Test\r\nvoid toByteArrayUnsafe() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    assertByteArrayEqualsString(this.os);\r\n    assertThat(this.os.toByteArrayUnsafe()).isSameAs(this.os.toByteArrayUnsafe());\r\n    assertThat(this.helloBytes).isEqualTo(this.os.toByteArray());\r\n}\n@Test\r\nvoid writeTo() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    assertByteArrayEqualsString(this.os);\r\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n    this.os.writeTo(baos);\r\n    assertThat(this.helloBytes).isEqualTo(baos.toByteArray());\r\n}\n@Test\r\nvoid failResize() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    assertThatIllegalArgumentException().isThrownBy(() -> this.os.resize(5)).withMessage(\"New capacity must not be smaller than current size\");\r\n}\n@Test\r\nvoid getInputStream() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    assertThat(this.os.getInputStream()).isNotNull();\r\n}\n@Test\r\nvoid getInputStreamAvailable() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    assertThat(this.helloBytes).hasSize(this.os.getInputStream().available());\r\n}\n@Test\r\nvoid getInputStreamRead() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    InputStream inputStream = this.os.getInputStream();\r\n    assertThat(this.helloBytes[0]).isEqualTo((byte) inputStream.read());\r\n    assertThat(this.helloBytes[1]).isEqualTo((byte) inputStream.read());\r\n    assertThat(this.helloBytes[2]).isEqualTo((byte) inputStream.read());\r\n    assertThat(this.helloBytes[3]).isEqualTo((byte) inputStream.read());\r\n}\n@Test\r\nvoid getInputStreamReadBytePromotion() throws Exception {\r\n    byte[] bytes = { -1 };\r\n    this.os.write(bytes);\r\n    InputStream inputStream = this.os.getInputStream();\r\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\r\n    assertThat(inputStream.read()).isEqualTo(bais.read());\r\n}\n@Test\r\nvoid getInputStreamReadAll() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    InputStream inputStream = this.os.getInputStream();\r\n    byte[] actual = new byte[inputStream.available()];\r\n    int bytesRead = inputStream.read(actual);\r\n    assertThat(bytesRead).isEqualTo(this.helloBytes.length);\r\n    assertThat(actual).isEqualTo(this.helloBytes);\r\n    assertThat(inputStream.available()).isEqualTo(0);\r\n}\n@Test\r\nvoid getInputStreamReadBeyondEndOfStream() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    InputStream inputStream = os.getInputStream();\r\n    byte[] actual = new byte[inputStream.available() + 1];\r\n    int bytesRead = inputStream.read(actual);\r\n    assertThat(bytesRead).isEqualTo(this.helloBytes.length);\r\n    for (int i = 0; i < bytesRead; i++) {\r\n        assertThat(actual[i]).isEqualTo(this.helloBytes[i]);\r\n    }\r\n    assertThat(actual[this.helloBytes.length]).isEqualTo((byte) 0);\r\n    assertThat(inputStream.available()).isEqualTo(0);\r\n}\n@Test\r\nvoid getInputStreamSkip() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    InputStream inputStream = this.os.getInputStream();\r\n    assertThat(this.helloBytes[0]).isEqualTo((byte) inputStream.read());\r\n    assertThat(inputStream.skip(1)).isEqualTo(1);\r\n    assertThat(this.helloBytes[2]).isEqualTo((byte) inputStream.read());\r\n    assertThat(inputStream.available()).isEqualTo((this.helloBytes.length - 3));\r\n}\n@Test\r\nvoid getInputStreamSkipAll() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    InputStream inputStream = this.os.getInputStream();\r\n    assertThat(this.helloBytes.length).isEqualTo(inputStream.skip(1000));\r\n    assertThat(inputStream.available()).isEqualTo(0);\r\n}\n@Test\r\nvoid updateMessageDigest() throws Exception {\r\n    StringBuilder builder = new StringBuilder(\"\\\"0\");\r\n    this.os.write(this.helloBytes);\r\n    InputStream inputStream = this.os.getInputStream();\r\n    DigestUtils.appendMd5DigestAsHex(inputStream, builder);\r\n    builder.append('\"');\r\n    String actual = builder.toString();\r\n    assertThat(actual).isEqualTo(\"\\\"0b10a8db164e0754105b7a99be72e3fe5\\\"\");\r\n}\n@Test\r\nvoid updateMessageDigestManyBuffers() throws Exception {\r\n    StringBuilder builder = new StringBuilder(\"\\\"0\");\r\n    // filling at least one 256 buffer\r\n    for (int i = 0; i < 30; i++) {\r\n        this.os.write(this.helloBytes);\r\n    }\r\n    InputStream inputStream = this.os.getInputStream();\r\n    DigestUtils.appendMd5DigestAsHex(inputStream, builder);\r\n    builder.append('\"');\r\n    String actual = builder.toString();\r\n    assertThat(actual).isEqualTo(\"\\\"06225ca1e4533354c516e74512065331d\\\"\");\r\n}\nprivate void assertByteArrayEqualsString(FastByteArrayOutputStream actual) {\r\n    assertThat(actual.toByteArray()).isEqualTo(this.helloBytes);\r\n}",
    "comment": "\n * Tests for {@link FastByteArrayOutputStream}.\n *\n * @author Craig Andrews\n "
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStreamTests#size()",
    "entityType": "method",
    "code": "@Test\r\nvoid size() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    assertThat(this.helloBytes).hasSize(this.os.size());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStreamTests#resize()",
    "entityType": "method",
    "code": "@Test\r\nvoid resize() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    int sizeBefore = this.os.size();\r\n    this.os.resize(64);\r\n    assertByteArrayEqualsString(this.os);\r\n    assertThat(this.os.size()).isEqualTo(sizeBefore);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStreamTests#stringConversion()",
    "entityType": "method",
    "code": "@Test\r\nvoid stringConversion() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    assertThat(this.os.toString()).isEqualTo(\"Hello World\");\r\n    assertThat(this.os.toString(StandardCharsets.UTF_8)).isEqualTo(\"Hello World\");\r\n    @SuppressWarnings(\"resource\")\r\n    FastByteArrayOutputStream empty = new FastByteArrayOutputStream();\r\n    assertThat(empty.toString()).isEqualTo(\"\");\r\n    assertThat(empty.toString(StandardCharsets.US_ASCII)).isEqualTo(\"\");\r\n    @SuppressWarnings(\"resource\")\r\n    FastByteArrayOutputStream outputStream = new FastByteArrayOutputStream(5);\r\n    // Add bytes in multiple writes to ensure we get more than one buffer internally\r\n    outputStream.write(this.helloBytes, 0, 5);\r\n    outputStream.write(this.helloBytes, 5, 6);\r\n    assertThat(outputStream.toString()).isEqualTo(\"Hello World\");\r\n    assertThat(outputStream.toString(StandardCharsets.UTF_8)).isEqualTo(\"Hello World\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStreamTests#autoGrow()",
    "entityType": "method",
    "code": "@Test\r\nvoid autoGrow() throws IOException {\r\n    this.os.resize(1);\r\n    for (int i = 0; i < 10; i++) {\r\n        this.os.write(1);\r\n    }\r\n    assertThat(this.os.size()).isEqualTo(10);\r\n    assertThat(new byte[] { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }).isEqualTo(this.os.toByteArray());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStreamTests#write()",
    "entityType": "method",
    "code": "@Test\r\nvoid write() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    assertByteArrayEqualsString(this.os);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStreamTests#reset()",
    "entityType": "method",
    "code": "@Test\r\nvoid reset() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    assertByteArrayEqualsString(this.os);\r\n    this.os.reset();\r\n    assertThat(this.os.size()).isEqualTo(0);\r\n    this.os.write(this.helloBytes);\r\n    assertByteArrayEqualsString(this.os);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStreamTests#close()",
    "entityType": "method",
    "code": "@Test\r\nvoid close() {\r\n    this.os.close();\r\n    assertThatIOException().isThrownBy(() -> this.os.write(this.helloBytes));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStreamTests#toByteArrayUnsafe()",
    "entityType": "method",
    "code": "@Test\r\nvoid toByteArrayUnsafe() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    assertByteArrayEqualsString(this.os);\r\n    assertThat(this.os.toByteArrayUnsafe()).isSameAs(this.os.toByteArrayUnsafe());\r\n    assertThat(this.helloBytes).isEqualTo(this.os.toByteArray());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStreamTests#writeTo()",
    "entityType": "method",
    "code": "@Test\r\nvoid writeTo() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    assertByteArrayEqualsString(this.os);\r\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n    this.os.writeTo(baos);\r\n    assertThat(this.helloBytes).isEqualTo(baos.toByteArray());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStreamTests#failResize()",
    "entityType": "method",
    "code": "@Test\r\nvoid failResize() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    assertThatIllegalArgumentException().isThrownBy(() -> this.os.resize(5)).withMessage(\"New capacity must not be smaller than current size\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStreamTests#getInputStream()",
    "entityType": "method",
    "code": "@Test\r\nvoid getInputStream() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    assertThat(this.os.getInputStream()).isNotNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStreamTests#getInputStreamAvailable()",
    "entityType": "method",
    "code": "@Test\r\nvoid getInputStreamAvailable() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    assertThat(this.helloBytes).hasSize(this.os.getInputStream().available());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStreamTests#getInputStreamRead()",
    "entityType": "method",
    "code": "@Test\r\nvoid getInputStreamRead() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    InputStream inputStream = this.os.getInputStream();\r\n    assertThat(this.helloBytes[0]).isEqualTo((byte) inputStream.read());\r\n    assertThat(this.helloBytes[1]).isEqualTo((byte) inputStream.read());\r\n    assertThat(this.helloBytes[2]).isEqualTo((byte) inputStream.read());\r\n    assertThat(this.helloBytes[3]).isEqualTo((byte) inputStream.read());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStreamTests#getInputStreamReadBytePromotion()",
    "entityType": "method",
    "code": "@Test\r\nvoid getInputStreamReadBytePromotion() throws Exception {\r\n    byte[] bytes = { -1 };\r\n    this.os.write(bytes);\r\n    InputStream inputStream = this.os.getInputStream();\r\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\r\n    assertThat(inputStream.read()).isEqualTo(bais.read());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStreamTests#getInputStreamReadAll()",
    "entityType": "method",
    "code": "@Test\r\nvoid getInputStreamReadAll() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    InputStream inputStream = this.os.getInputStream();\r\n    byte[] actual = new byte[inputStream.available()];\r\n    int bytesRead = inputStream.read(actual);\r\n    assertThat(bytesRead).isEqualTo(this.helloBytes.length);\r\n    assertThat(actual).isEqualTo(this.helloBytes);\r\n    assertThat(inputStream.available()).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStreamTests#getInputStreamReadBeyondEndOfStream()",
    "entityType": "method",
    "code": "@Test\r\nvoid getInputStreamReadBeyondEndOfStream() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    InputStream inputStream = os.getInputStream();\r\n    byte[] actual = new byte[inputStream.available() + 1];\r\n    int bytesRead = inputStream.read(actual);\r\n    assertThat(bytesRead).isEqualTo(this.helloBytes.length);\r\n    for (int i = 0; i < bytesRead; i++) {\r\n        assertThat(actual[i]).isEqualTo(this.helloBytes[i]);\r\n    }\r\n    assertThat(actual[this.helloBytes.length]).isEqualTo((byte) 0);\r\n    assertThat(inputStream.available()).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStreamTests#getInputStreamSkip()",
    "entityType": "method",
    "code": "@Test\r\nvoid getInputStreamSkip() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    InputStream inputStream = this.os.getInputStream();\r\n    assertThat(this.helloBytes[0]).isEqualTo((byte) inputStream.read());\r\n    assertThat(inputStream.skip(1)).isEqualTo(1);\r\n    assertThat(this.helloBytes[2]).isEqualTo((byte) inputStream.read());\r\n    assertThat(inputStream.available()).isEqualTo((this.helloBytes.length - 3));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStreamTests#getInputStreamSkipAll()",
    "entityType": "method",
    "code": "@Test\r\nvoid getInputStreamSkipAll() throws Exception {\r\n    this.os.write(this.helloBytes);\r\n    InputStream inputStream = this.os.getInputStream();\r\n    assertThat(this.helloBytes.length).isEqualTo(inputStream.skip(1000));\r\n    assertThat(inputStream.available()).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStreamTests#updateMessageDigest()",
    "entityType": "method",
    "code": "@Test\r\nvoid updateMessageDigest() throws Exception {\r\n    StringBuilder builder = new StringBuilder(\"\\\"0\");\r\n    this.os.write(this.helloBytes);\r\n    InputStream inputStream = this.os.getInputStream();\r\n    DigestUtils.appendMd5DigestAsHex(inputStream, builder);\r\n    builder.append('\"');\r\n    String actual = builder.toString();\r\n    assertThat(actual).isEqualTo(\"\\\"0b10a8db164e0754105b7a99be72e3fe5\\\"\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStreamTests#updateMessageDigestManyBuffers()",
    "entityType": "method",
    "code": "@Test\r\nvoid updateMessageDigestManyBuffers() throws Exception {\r\n    StringBuilder builder = new StringBuilder(\"\\\"0\");\r\n    // filling at least one 256 buffer\r\n    for (int i = 0; i < 30; i++) {\r\n        this.os.write(this.helloBytes);\r\n    }\r\n    InputStream inputStream = this.os.getInputStream();\r\n    DigestUtils.appendMd5DigestAsHex(inputStream, builder);\r\n    builder.append('\"');\r\n    String actual = builder.toString();\r\n    assertThat(actual).isEqualTo(\"\\\"06225ca1e4533354c516e74512065331d\\\"\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStreamTests#assertByteArrayEqualsString(FastByteArrayOutputStream)",
    "entityType": "method",
    "code": "private void assertByteArrayEqualsString(FastByteArrayOutputStream actual) {\r\n    assertThat(actual.toByteArray()).isEqualTo(this.helloBytes);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.support.ObjectToObjectConverterRuntimeHints",
    "entityType": "class",
    "code": "@Override\r\npublic void registerHints(RuntimeHints hints, @Nullable ClassLoader classLoader) {\r\n    ReflectionHints reflectionHints = hints.reflection();\r\n    TypeReference sqlDateTypeReference = TypeReference.of(\"java.sql.Date\");\r\n    reflectionHints.registerTypeIfPresent(classLoader, sqlDateTypeReference.getName(), hint -> hint.withMethod(\"toLocalDate\", Collections.emptyList(), ExecutableMode.INVOKE).onReachableType(sqlDateTypeReference).withMethod(\"valueOf\", List.of(TypeReference.of(LocalDate.class)), ExecutableMode.INVOKE).onReachableType(sqlDateTypeReference));\r\n    reflectionHints.registerTypeIfPresent(classLoader, \"org.springframework.http.HttpMethod\", builder -> builder.withMethod(\"valueOf\", List.of(TypeReference.of(String.class)), ExecutableMode.INVOKE));\r\n    reflectionHints.registerTypeIfPresent(classLoader, \"java.net.URI\", MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);\r\n}",
    "comment": "\n * {@link RuntimeHintsRegistrar} to register hints for popular conventions in\n * {@code org.springframework.core.convert.support.ObjectToObjectConverter}.\n *\n * @author Sebastien Deleuze\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.hint.support.ObjectToObjectConverterRuntimeHints#registerHints(RuntimeHints,ClassLoader)",
    "entityType": "method",
    "code": "@Override\r\npublic void registerHints(RuntimeHints hints, @Nullable ClassLoader classLoader) {\r\n    ReflectionHints reflectionHints = hints.reflection();\r\n    TypeReference sqlDateTypeReference = TypeReference.of(\"java.sql.Date\");\r\n    reflectionHints.registerTypeIfPresent(classLoader, sqlDateTypeReference.getName(), hint -> hint.withMethod(\"toLocalDate\", Collections.emptyList(), ExecutableMode.INVOKE).onReachableType(sqlDateTypeReference).withMethod(\"valueOf\", List.of(TypeReference.of(LocalDate.class)), ExecutableMode.INVOKE).onReachableType(sqlDateTypeReference));\r\n    reflectionHints.registerTypeIfPresent(classLoader, \"org.springframework.http.HttpMethod\", builder -> builder.withMethod(\"valueOf\", List.of(TypeReference.of(String.class)), ExecutableMode.INVOKE));\r\n    reflectionHints.registerTypeIfPresent(classLoader, \"java.net.URI\", MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FileCopyUtilsTests",
    "entityType": "class",
    "code": "@Test\r\nvoid copyFromInputStream() throws IOException {\r\n    byte[] content = \"content\".getBytes();\r\n    ByteArrayInputStream in = new ByteArrayInputStream(content);\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream(content.length);\r\n    int count = FileCopyUtils.copy(in, out);\r\n    assertThat(count).isEqualTo(content.length);\r\n    assertThat(Arrays.equals(content, out.toByteArray())).isTrue();\r\n}\n@Test\r\nvoid copyFromByteArray() throws IOException {\r\n    byte[] content = \"content\".getBytes();\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream(content.length);\r\n    FileCopyUtils.copy(content, out);\r\n    assertThat(Arrays.equals(content, out.toByteArray())).isTrue();\r\n}\n@Test\r\nvoid copyToByteArray() throws IOException {\r\n    byte[] content = \"content\".getBytes();\r\n    ByteArrayInputStream in = new ByteArrayInputStream(content);\r\n    byte[] result = FileCopyUtils.copyToByteArray(in);\r\n    assertThat(Arrays.equals(content, result)).isTrue();\r\n}\n@Test\r\nvoid copyFromReader() throws IOException {\r\n    String content = \"content\";\r\n    StringReader in = new StringReader(content);\r\n    StringWriter out = new StringWriter();\r\n    int count = FileCopyUtils.copy(in, out);\r\n    assertThat(count).isEqualTo(content.length());\r\n    assertThat(out.toString()).isEqualTo(content);\r\n}\n@Test\r\nvoid copyFromString() throws IOException {\r\n    String content = \"content\";\r\n    StringWriter out = new StringWriter();\r\n    FileCopyUtils.copy(content, out);\r\n    assertThat(out.toString()).isEqualTo(content);\r\n}\n@Test\r\nvoid copyToString() throws IOException {\r\n    String content = \"content\";\r\n    StringReader in = new StringReader(content);\r\n    String result = FileCopyUtils.copyToString(in);\r\n    assertThat(result).isEqualTo(content);\r\n}",
    "comment": "\n * Tests for {@link FileCopyUtils}.\n *\n * @author Juergen Hoeller\n * @since 12.03.2005\n "
  },
  {
    "entityId": "org.springframework.util.FileCopyUtilsTests#copyFromInputStream()",
    "entityType": "method",
    "code": "@Test\r\nvoid copyFromInputStream() throws IOException {\r\n    byte[] content = \"content\".getBytes();\r\n    ByteArrayInputStream in = new ByteArrayInputStream(content);\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream(content.length);\r\n    int count = FileCopyUtils.copy(in, out);\r\n    assertThat(count).isEqualTo(content.length);\r\n    assertThat(Arrays.equals(content, out.toByteArray())).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FileCopyUtilsTests#copyFromByteArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid copyFromByteArray() throws IOException {\r\n    byte[] content = \"content\".getBytes();\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream(content.length);\r\n    FileCopyUtils.copy(content, out);\r\n    assertThat(Arrays.equals(content, out.toByteArray())).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FileCopyUtilsTests#copyToByteArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid copyToByteArray() throws IOException {\r\n    byte[] content = \"content\".getBytes();\r\n    ByteArrayInputStream in = new ByteArrayInputStream(content);\r\n    byte[] result = FileCopyUtils.copyToByteArray(in);\r\n    assertThat(Arrays.equals(content, result)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FileCopyUtilsTests#copyFromReader()",
    "entityType": "method",
    "code": "@Test\r\nvoid copyFromReader() throws IOException {\r\n    String content = \"content\";\r\n    StringReader in = new StringReader(content);\r\n    StringWriter out = new StringWriter();\r\n    int count = FileCopyUtils.copy(in, out);\r\n    assertThat(count).isEqualTo(content.length());\r\n    assertThat(out.toString()).isEqualTo(content);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FileCopyUtilsTests#copyFromString()",
    "entityType": "method",
    "code": "@Test\r\nvoid copyFromString() throws IOException {\r\n    String content = \"content\";\r\n    StringWriter out = new StringWriter();\r\n    FileCopyUtils.copy(content, out);\r\n    assertThat(out.toString()).isEqualTo(content);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FileCopyUtilsTests#copyToString()",
    "entityType": "method",
    "code": "@Test\r\nvoid copyToString() throws IOException {\r\n    String content = \"content\";\r\n    StringReader in = new StringReader(content);\r\n    String result = FileCopyUtils.copyToString(in);\r\n    assertThat(result).isEqualTo(content);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FileSystemUtilsTests",
    "entityType": "class",
    "code": "@Test\r\nvoid deleteRecursively() throws Exception {\r\n    File root = new File(\"./tmp/root\");\r\n    File child = new File(root, \"child\");\r\n    File grandchild = new File(child, \"grandchild\");\r\n    grandchild.mkdirs();\r\n    File bar = new File(child, \"bar.txt\");\r\n    bar.createNewFile();\r\n    assertThat(root).exists();\r\n    assertThat(child).exists();\r\n    assertThat(grandchild).exists();\r\n    assertThat(bar).exists();\r\n    FileSystemUtils.deleteRecursively(root);\r\n    assertThat(root).doesNotExist();\r\n    assertThat(child).doesNotExist();\r\n    assertThat(grandchild).doesNotExist();\r\n    assertThat(bar).doesNotExist();\r\n}\n@Test\r\nvoid copyRecursively() throws Exception {\r\n    File src = new File(\"./tmp/src\");\r\n    File child = new File(src, \"child\");\r\n    File grandchild = new File(child, \"grandchild\");\r\n    grandchild.mkdirs();\r\n    File bar = new File(child, \"bar.txt\");\r\n    bar.createNewFile();\r\n    assertThat(src).exists();\r\n    assertThat(child).exists();\r\n    assertThat(grandchild).exists();\r\n    assertThat(bar).exists();\r\n    File dest = new File(\"./dest\");\r\n    FileSystemUtils.copyRecursively(src, dest);\r\n    assertThat(dest).exists();\r\n    assertThat(new File(dest, child.getName())).exists();\r\n    FileSystemUtils.deleteRecursively(src);\r\n    assertThat(src).doesNotExist();\r\n}\n@AfterEach\r\nvoid tearDown() {\r\n    File tmp = new File(\"./tmp\");\r\n    if (tmp.exists()) {\r\n        FileSystemUtils.deleteRecursively(tmp);\r\n    }\r\n    File dest = new File(\"./dest\");\r\n    if (dest.exists()) {\r\n        FileSystemUtils.deleteRecursively(dest);\r\n    }\r\n}",
    "comment": "\n * @author Rob Harrop\n "
  },
  {
    "entityId": "org.springframework.util.FileSystemUtilsTests#deleteRecursively()",
    "entityType": "method",
    "code": "@Test\r\nvoid deleteRecursively() throws Exception {\r\n    File root = new File(\"./tmp/root\");\r\n    File child = new File(root, \"child\");\r\n    File grandchild = new File(child, \"grandchild\");\r\n    grandchild.mkdirs();\r\n    File bar = new File(child, \"bar.txt\");\r\n    bar.createNewFile();\r\n    assertThat(root).exists();\r\n    assertThat(child).exists();\r\n    assertThat(grandchild).exists();\r\n    assertThat(bar).exists();\r\n    FileSystemUtils.deleteRecursively(root);\r\n    assertThat(root).doesNotExist();\r\n    assertThat(child).doesNotExist();\r\n    assertThat(grandchild).doesNotExist();\r\n    assertThat(bar).doesNotExist();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FileSystemUtilsTests#copyRecursively()",
    "entityType": "method",
    "code": "@Test\r\nvoid copyRecursively() throws Exception {\r\n    File src = new File(\"./tmp/src\");\r\n    File child = new File(src, \"child\");\r\n    File grandchild = new File(child, \"grandchild\");\r\n    grandchild.mkdirs();\r\n    File bar = new File(child, \"bar.txt\");\r\n    bar.createNewFile();\r\n    assertThat(src).exists();\r\n    assertThat(child).exists();\r\n    assertThat(grandchild).exists();\r\n    assertThat(bar).exists();\r\n    File dest = new File(\"./dest\");\r\n    FileSystemUtils.copyRecursively(src, dest);\r\n    assertThat(dest).exists();\r\n    assertThat(new File(dest, child.getName())).exists();\r\n    FileSystemUtils.deleteRecursively(src);\r\n    assertThat(src).doesNotExist();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FileSystemUtilsTests#tearDown()",
    "entityType": "method",
    "code": "@AfterEach\r\nvoid tearDown() {\r\n    File tmp = new File(\"./tmp\");\r\n    if (tmp.exists()) {\r\n        FileSystemUtils.deleteRecursively(tmp);\r\n    }\r\n    File dest = new File(\"./dest\");\r\n    if (dest.exists()) {\r\n        FileSystemUtils.deleteRecursively(dest);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.support.PathMatchingResourcePatternResolverRuntimeHints",
    "entityType": "class",
    "code": "@Override\r\npublic void registerHints(RuntimeHints hints, @Nullable ClassLoader classLoader) {\r\n    hints.reflection().registerType(TypeReference.of(\"org.eclipse.core.runtime.FileLocator\"));\r\n}",
    "comment": "\n * {@link RuntimeHintsRegistrar} for {@link PathMatchingResourcePatternResolver}.\n * @author Brian Clozel\n "
  },
  {
    "entityId": "org.springframework.aot.hint.support.PathMatchingResourcePatternResolverRuntimeHints#registerHints(RuntimeHints,ClassLoader)",
    "entityType": "method",
    "code": "@Override\r\npublic void registerHints(RuntimeHints hints, @Nullable ClassLoader classLoader) {\r\n    hints.reflection().registerType(TypeReference.of(\"org.eclipse.core.runtime.FileLocator\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredCollectionTests",
    "entityType": "class",
    "code": "@Test\r\nvoid size() {\r\n    List<String> list = List.of(\"foo\", \"bar\", \"baz\");\r\n    FilteredCollection<String> filtered = new FilteredCollection<>(list, s -> !s.equals(\"bar\"));\r\n    assertThat(filtered).hasSize(2);\r\n}\n@Test\r\nvoid iterator() {\r\n    List<String> list = List.of(\"foo\", \"bar\", \"baz\");\r\n    FilteredCollection<String> filtered = new FilteredCollection<>(list, s -> !s.equals(\"bar\"));\r\n    assertThat(filtered.iterator()).toIterable().containsExactly(\"foo\", \"baz\");\r\n}\n@Test\r\nvoid add() {\r\n    List<String> list = new ArrayList<>(List.of(\"foo\"));\r\n    FilteredCollection<String> filtered = new FilteredCollection<>(list, s -> !s.equals(\"bar\"));\r\n    boolean added = filtered.add(\"bar\");\r\n    assertThat(added).isFalse();\r\n    assertThat(filtered).containsExactly(\"foo\");\r\n    assertThat(list).containsExactly(\"foo\", \"bar\");\r\n}\n@Test\r\nvoid remove() {\r\n    List<String> list = new ArrayList<>(List.of(\"foo\", \"bar\"));\r\n    FilteredCollection<String> filtered = new FilteredCollection<>(list, s -> !s.equals(\"bar\"));\r\n    assertThat(list).contains(\"bar\");\r\n    assertThat(filtered).doesNotContain(\"bar\");\r\n    boolean removed = filtered.remove(\"bar\");\r\n    assertThat(removed).isFalse();\r\n    assertThat(filtered).doesNotContain(\"bar\");\r\n    assertThat(list).doesNotContain(\"bar\");\r\n}\n@Test\r\nvoid contains() {\r\n    List<String> list = List.of(\"foo\", \"bar\", \"baz\");\r\n    FilteredCollection<String> filtered = new FilteredCollection<>(list, s -> !s.equals(\"bar\"));\r\n    boolean contained = filtered.contains(\"bar\");\r\n    assertThat(contained).isFalse();\r\n}",
    "comment": "\n * @author Arjen Poutsma\n "
  },
  {
    "entityId": "org.springframework.util.FilteredCollectionTests#size()",
    "entityType": "method",
    "code": "@Test\r\nvoid size() {\r\n    List<String> list = List.of(\"foo\", \"bar\", \"baz\");\r\n    FilteredCollection<String> filtered = new FilteredCollection<>(list, s -> !s.equals(\"bar\"));\r\n    assertThat(filtered).hasSize(2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredCollectionTests#iterator()",
    "entityType": "method",
    "code": "@Test\r\nvoid iterator() {\r\n    List<String> list = List.of(\"foo\", \"bar\", \"baz\");\r\n    FilteredCollection<String> filtered = new FilteredCollection<>(list, s -> !s.equals(\"bar\"));\r\n    assertThat(filtered.iterator()).toIterable().containsExactly(\"foo\", \"baz\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredCollectionTests#add()",
    "entityType": "method",
    "code": "@Test\r\nvoid add() {\r\n    List<String> list = new ArrayList<>(List.of(\"foo\"));\r\n    FilteredCollection<String> filtered = new FilteredCollection<>(list, s -> !s.equals(\"bar\"));\r\n    boolean added = filtered.add(\"bar\");\r\n    assertThat(added).isFalse();\r\n    assertThat(filtered).containsExactly(\"foo\");\r\n    assertThat(list).containsExactly(\"foo\", \"bar\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredCollectionTests#remove()",
    "entityType": "method",
    "code": "@Test\r\nvoid remove() {\r\n    List<String> list = new ArrayList<>(List.of(\"foo\", \"bar\"));\r\n    FilteredCollection<String> filtered = new FilteredCollection<>(list, s -> !s.equals(\"bar\"));\r\n    assertThat(list).contains(\"bar\");\r\n    assertThat(filtered).doesNotContain(\"bar\");\r\n    boolean removed = filtered.remove(\"bar\");\r\n    assertThat(removed).isFalse();\r\n    assertThat(filtered).doesNotContain(\"bar\");\r\n    assertThat(list).doesNotContain(\"bar\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredCollectionTests#contains()",
    "entityType": "method",
    "code": "@Test\r\nvoid contains() {\r\n    List<String> list = List.of(\"foo\", \"bar\", \"baz\");\r\n    FilteredCollection<String> filtered = new FilteredCollection<>(list, s -> !s.equals(\"bar\"));\r\n    boolean contained = filtered.contains(\"bar\");\r\n    assertThat(contained).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.support.SpringFactoriesLoaderRuntimeHints",
    "entityType": "class",
    "code": "private static final List<String> RESOURCE_LOCATIONS = List.of(SpringFactoriesLoader.FACTORIES_RESOURCE_LOCATION);\nprivate static final Log logger = LogFactory.getLog(SpringFactoriesLoaderRuntimeHints.class);\n@Override\r\npublic void registerHints(RuntimeHints hints, @Nullable ClassLoader classLoader) {\r\n    ClassLoader classLoaderToUse = (classLoader != null ? classLoader : SpringFactoriesLoaderRuntimeHints.class.getClassLoader());\r\n    for (String resourceLocation : RESOURCE_LOCATIONS) {\r\n        registerHints(hints, classLoaderToUse, resourceLocation);\r\n    }\r\n}\nprivate void registerHints(RuntimeHints hints, ClassLoader classLoader, String resourceLocation) {\r\n    hints.resources().registerPattern(resourceLocation);\r\n    Map<String, List<String>> factories = ExtendedSpringFactoriesLoader.accessLoadFactoriesResource(classLoader, resourceLocation);\r\n    factories.forEach((factoryClassName, implementationClassNames) -> registerHints(hints, classLoader, factoryClassName, implementationClassNames));\r\n}\nprivate void registerHints(RuntimeHints hints, ClassLoader classLoader, String factoryClassName, List<String> implementationClassNames) {\r\n    Class<?> factoryClass = resolveClassName(classLoader, factoryClassName);\r\n    if (factoryClass == null) {\r\n        if (logger.isTraceEnabled()) {\r\n            logger.trace(LogMessage.format(\"Skipping factories for [%s]\", factoryClassName));\r\n        }\r\n        return;\r\n    }\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(LogMessage.format(\"Processing factories for [%s]\", factoryClassName));\r\n    }\r\n    hints.reflection().registerType(factoryClass, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);\r\n    for (String implementationClassName : implementationClassNames) {\r\n        Class<?> implementationType = resolveClassName(classLoader, implementationClassName);\r\n        if (logger.isTraceEnabled()) {\r\n            logger.trace(LogMessage.format(\"%s factory type [%s] and implementation [%s]\", (implementationType != null ? \"Processing\" : \"Skipping\"), factoryClassName, implementationClassName));\r\n        }\r\n        if (implementationType != null) {\r\n            hints.reflection().registerType(implementationType, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);\r\n        }\r\n    }\r\n}\n@Nullable\r\nprivate Class<?> resolveClassName(ClassLoader classLoader, String factoryClassName) {\r\n    try {\r\n        Class<?> clazz = ClassUtils.resolveClassName(factoryClassName, classLoader);\r\n        // Force resolution of all constructors to cache\r\n        clazz.getDeclaredConstructors();\r\n        return clazz;\r\n    } catch (Throwable ex) {\r\n        return null;\r\n    }\r\n}\nprivate static class ExtendedSpringFactoriesLoader extends SpringFactoriesLoader {\r\n\r\n    ExtendedSpringFactoriesLoader(@Nullable ClassLoader classLoader, Map<String, List<String>> factories) {\r\n        super(classLoader, factories);\r\n    }\r\n\r\n    static Map<String, List<String>> accessLoadFactoriesResource(ClassLoader classLoader, String resourceLocation) {\r\n        return SpringFactoriesLoader.loadFactoriesResource(classLoader, resourceLocation);\r\n    }\r\n}",
    "comment": "\n * {@link RuntimeHintsRegistrar} to register hints for {@code spring.factories}.\n *\n * @author Brian Clozel\n * @author Phillip Webb\n * @since 6.0\n * @see SpringFactoriesLoader\n "
  },
  {
    "entityId": "org.springframework.aot.hint.support.SpringFactoriesLoaderRuntimeHints#registerHints(RuntimeHints,ClassLoader)",
    "entityType": "method",
    "code": "@Override\r\npublic void registerHints(RuntimeHints hints, @Nullable ClassLoader classLoader) {\r\n    ClassLoader classLoaderToUse = (classLoader != null ? classLoader : SpringFactoriesLoaderRuntimeHints.class.getClassLoader());\r\n    for (String resourceLocation : RESOURCE_LOCATIONS) {\r\n        registerHints(hints, classLoaderToUse, resourceLocation);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.support.SpringFactoriesLoaderRuntimeHints#registerHints(RuntimeHints,ClassLoader,String)",
    "entityType": "method",
    "code": "private void registerHints(RuntimeHints hints, ClassLoader classLoader, String resourceLocation) {\r\n    hints.resources().registerPattern(resourceLocation);\r\n    Map<String, List<String>> factories = ExtendedSpringFactoriesLoader.accessLoadFactoriesResource(classLoader, resourceLocation);\r\n    factories.forEach((factoryClassName, implementationClassNames) -> registerHints(hints, classLoader, factoryClassName, implementationClassNames));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.support.SpringFactoriesLoaderRuntimeHints#registerHints(RuntimeHints,ClassLoader,String,List<String>)",
    "entityType": "method",
    "code": "private void registerHints(RuntimeHints hints, ClassLoader classLoader, String factoryClassName, List<String> implementationClassNames) {\r\n    Class<?> factoryClass = resolveClassName(classLoader, factoryClassName);\r\n    if (factoryClass == null) {\r\n        if (logger.isTraceEnabled()) {\r\n            logger.trace(LogMessage.format(\"Skipping factories for [%s]\", factoryClassName));\r\n        }\r\n        return;\r\n    }\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(LogMessage.format(\"Processing factories for [%s]\", factoryClassName));\r\n    }\r\n    hints.reflection().registerType(factoryClass, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);\r\n    for (String implementationClassName : implementationClassNames) {\r\n        Class<?> implementationType = resolveClassName(classLoader, implementationClassName);\r\n        if (logger.isTraceEnabled()) {\r\n            logger.trace(LogMessage.format(\"%s factory type [%s] and implementation [%s]\", (implementationType != null ? \"Processing\" : \"Skipping\"), factoryClassName, implementationClassName));\r\n        }\r\n        if (implementationType != null) {\r\n            hints.reflection().registerType(implementationType, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.support.SpringFactoriesLoaderRuntimeHints#resolveClassName(ClassLoader,String)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate Class<?> resolveClassName(ClassLoader classLoader, String factoryClassName) {\r\n    try {\r\n        Class<?> clazz = ClassUtils.resolveClassName(factoryClassName, classLoader);\r\n        // Force resolution of all constructors to cache\r\n        clazz.getDeclaredConstructors();\r\n        return clazz;\r\n    } catch (Throwable ex) {\r\n        return null;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.support.ExtendedSpringFactoriesLoader",
    "entityType": "class",
    "code": "ExtendedSpringFactoriesLoader(@Nullable ClassLoader classLoader, Map<String, List<String>> factories) {\r\n    super(classLoader, factories);\r\n}\nstatic Map<String, List<String>> accessLoadFactoriesResource(ClassLoader classLoader, String resourceLocation) {\r\n    return SpringFactoriesLoader.loadFactoriesResource(classLoader, resourceLocation);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.support.ExtendedSpringFactoriesLoader#accessLoadFactoriesResource(ClassLoader,String)",
    "entityType": "method",
    "code": "static Map<String, List<String>> accessLoadFactoriesResource(ClassLoader classLoader, String resourceLocation) {\r\n    return SpringFactoriesLoader.loadFactoriesResource(classLoader, resourceLocation);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredIteratorTests",
    "entityType": "class",
    "code": "@Test\r\nvoid filter() {\r\n    List<String> list = List.of(\"foo\", \"bar\", \"baz\");\r\n    FilteredIterator<String> filtered = new FilteredIterator<>(list.iterator(), s -> !s.equals(\"bar\"));\r\n    assertThat(filtered).toIterable().containsExactly(\"foo\", \"baz\");\r\n}",
    "comment": "\n * @author Arjen Poutsma\n "
  },
  {
    "entityId": "org.springframework.util.FilteredIteratorTests#filter()",
    "entityType": "method",
    "code": "@Test\r\nvoid filter() {\r\n    List<String> list = List.of(\"foo\", \"bar\", \"baz\");\r\n    FilteredIterator<String> filtered = new FilteredIterator<>(list.iterator(), s -> !s.equals(\"bar\"));\r\n    assertThat(filtered).toIterable().containsExactly(\"foo\", \"baz\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.support.SpringPropertiesRuntimeHints",
    "entityType": "class",
    "code": "@Override\r\npublic void registerHints(RuntimeHints hints, @Nullable ClassLoader classLoader) {\r\n    hints.resources().registerPattern(\"spring.properties\");\r\n}",
    "comment": "\n * {@link RuntimeHintsRegistrar} to register hints for {@link org.springframework.core.SpringProperties}.\n *\n * @author Brian Clozel\n * @since 6.1\n "
  },
  {
    "entityId": "org.springframework.aot.hint.support.SpringPropertiesRuntimeHints#registerHints(RuntimeHints,ClassLoader)",
    "entityType": "method",
    "code": "@Override\r\npublic void registerHints(RuntimeHints hints, @Nullable ClassLoader classLoader) {\r\n    hints.resources().registerPattern(\"spring.properties\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredMapTests",
    "entityType": "class",
    "code": "@Test\r\nvoid size() {\r\n    Map<String, String> map = Map.of(\"foo\", \"bar\", \"baz\", \"qux\", \"quux\", \"corge\");\r\n    FilteredMap<String, String> filtered = new FilteredMap<>(map, s -> !s.equals(\"baz\"));\r\n    assertThat(filtered).hasSize(2);\r\n}\n@Test\r\nvoid entrySet() {\r\n    Map<String, String> map = Map.of(\"foo\", \"bar\", \"baz\", \"qux\", \"quux\", \"corge\");\r\n    FilteredMap<String, String> filtered = new FilteredMap<>(map, s -> !s.equals(\"baz\"));\r\n    assertThat(filtered.entrySet()).containsExactlyInAnyOrder(entry(\"foo\", \"bar\"), entry(\"quux\", \"corge\"));\r\n}\n@Test\r\nvoid containsKey() {\r\n    Map<String, String> map = Map.of(\"foo\", \"bar\", \"baz\", \"qux\", \"quux\", \"corge\");\r\n    FilteredMap<String, String> filtered = new FilteredMap<>(map, s -> !s.equals(\"baz\"));\r\n    boolean contained = filtered.containsKey(\"baz\");\r\n    assertThat(contained).isFalse();\r\n}\n@Test\r\nvoid get() {\r\n    Map<String, String> map = Map.of(\"foo\", \"bar\", \"baz\", \"qux\", \"quux\", \"corge\");\r\n    FilteredMap<String, String> filtered = new FilteredMap<>(map, s -> !s.equals(\"baz\"));\r\n    String value = filtered.get(\"baz\");\r\n    assertThat(value).isNull();\r\n}\n@Test\r\nvoid put() {\r\n    Map<String, String> map = new HashMap<>(Map.of(\"foo\", \"bar\", \"quux\", \"corge\"));\r\n    FilteredMap<String, String> filtered = new FilteredMap<>(map, s -> !s.equals(\"baz\"));\r\n    String value = filtered.put(\"baz\", \"qux\");\r\n    assertThat(value).isNull();\r\n    assertThat(filtered.containsKey(\"baz\")).isFalse();\r\n    assertThat(map.get(\"baz\")).isEqualTo(\"qux\");\r\n    // overwrite\r\n    value = filtered.put(\"baz\", \"QUX\");\r\n    assertThat(value).isNull();\r\n    assertThat(filtered.containsKey(\"baz\")).isFalse();\r\n    assertThat(map.get(\"baz\")).isEqualTo(\"QUX\");\r\n}\n@Test\r\nvoid remove() {\r\n    Map<String, String> map = new HashMap<>(Map.of(\"foo\", \"bar\", \"baz\", \"qux\", \"quux\", \"corge\"));\r\n    FilteredMap<String, String> filtered = new FilteredMap<>(map, s -> !s.equals(\"baz\"));\r\n    String value = filtered.remove(\"baz\");\r\n    assertThat(value).isNull();\r\n    assertThat(filtered.containsKey(\"baz\")).isFalse();\r\n    assertThat(map.containsKey(\"baz\")).isFalse();\r\n}\n@Test\r\nvoid keySet() {\r\n    Map<String, String> map = Map.of(\"foo\", \"bar\", \"baz\", \"qux\", \"quux\", \"corge\");\r\n    FilteredMap<String, String> filtered = new FilteredMap<>(map, s -> !s.equals(\"baz\"));\r\n    Set<String> keySet = filtered.keySet();\r\n    assertThat(keySet).containsExactlyInAnyOrder(\"foo\", \"quux\");\r\n}",
    "comment": "\n * @author Arjen Poutsma\n "
  },
  {
    "entityId": "org.springframework.util.FilteredMapTests#size()",
    "entityType": "method",
    "code": "@Test\r\nvoid size() {\r\n    Map<String, String> map = Map.of(\"foo\", \"bar\", \"baz\", \"qux\", \"quux\", \"corge\");\r\n    FilteredMap<String, String> filtered = new FilteredMap<>(map, s -> !s.equals(\"baz\"));\r\n    assertThat(filtered).hasSize(2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredMapTests#entrySet()",
    "entityType": "method",
    "code": "@Test\r\nvoid entrySet() {\r\n    Map<String, String> map = Map.of(\"foo\", \"bar\", \"baz\", \"qux\", \"quux\", \"corge\");\r\n    FilteredMap<String, String> filtered = new FilteredMap<>(map, s -> !s.equals(\"baz\"));\r\n    assertThat(filtered.entrySet()).containsExactlyInAnyOrder(entry(\"foo\", \"bar\"), entry(\"quux\", \"corge\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredMapTests#containsKey()",
    "entityType": "method",
    "code": "@Test\r\nvoid containsKey() {\r\n    Map<String, String> map = Map.of(\"foo\", \"bar\", \"baz\", \"qux\", \"quux\", \"corge\");\r\n    FilteredMap<String, String> filtered = new FilteredMap<>(map, s -> !s.equals(\"baz\"));\r\n    boolean contained = filtered.containsKey(\"baz\");\r\n    assertThat(contained).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredMapTests#get()",
    "entityType": "method",
    "code": "@Test\r\nvoid get() {\r\n    Map<String, String> map = Map.of(\"foo\", \"bar\", \"baz\", \"qux\", \"quux\", \"corge\");\r\n    FilteredMap<String, String> filtered = new FilteredMap<>(map, s -> !s.equals(\"baz\"));\r\n    String value = filtered.get(\"baz\");\r\n    assertThat(value).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredMapTests#put()",
    "entityType": "method",
    "code": "@Test\r\nvoid put() {\r\n    Map<String, String> map = new HashMap<>(Map.of(\"foo\", \"bar\", \"quux\", \"corge\"));\r\n    FilteredMap<String, String> filtered = new FilteredMap<>(map, s -> !s.equals(\"baz\"));\r\n    String value = filtered.put(\"baz\", \"qux\");\r\n    assertThat(value).isNull();\r\n    assertThat(filtered.containsKey(\"baz\")).isFalse();\r\n    assertThat(map.get(\"baz\")).isEqualTo(\"qux\");\r\n    // overwrite\r\n    value = filtered.put(\"baz\", \"QUX\");\r\n    assertThat(value).isNull();\r\n    assertThat(filtered.containsKey(\"baz\")).isFalse();\r\n    assertThat(map.get(\"baz\")).isEqualTo(\"QUX\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredMapTests#remove()",
    "entityType": "method",
    "code": "@Test\r\nvoid remove() {\r\n    Map<String, String> map = new HashMap<>(Map.of(\"foo\", \"bar\", \"baz\", \"qux\", \"quux\", \"corge\"));\r\n    FilteredMap<String, String> filtered = new FilteredMap<>(map, s -> !s.equals(\"baz\"));\r\n    String value = filtered.remove(\"baz\");\r\n    assertThat(value).isNull();\r\n    assertThat(filtered.containsKey(\"baz\")).isFalse();\r\n    assertThat(map.containsKey(\"baz\")).isFalse();\r\n}",
    "comment": ""
  }
]