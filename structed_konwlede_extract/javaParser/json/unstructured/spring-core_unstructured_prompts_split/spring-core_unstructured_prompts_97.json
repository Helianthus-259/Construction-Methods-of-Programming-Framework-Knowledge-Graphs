[
  {
    "entityId": "org.springframework.aot.hint.support.KotlinDetectorRuntimeHintsTests#kotlinMetadataHasHints()",
    "entityType": "method",
    "code": "@Test\r\nvoid kotlinMetadataHasHints() {\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(kotlin.Metadata.class)).accepts(this.hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.support.KotlinDetectorRuntimeHintsTests#kotlinReflectHasHints()",
    "entityType": "method",
    "code": "@Test\r\nvoid kotlinReflectHasHints() {\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(kotlin.reflect.full.KClasses.class)).accepts(this.hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.support.ObjectToObjectConverterRuntimeHintsTests",
    "entityType": "class",
    "code": "private RuntimeHints hints;\n@BeforeEach\r\nvoid setup() {\r\n    this.hints = new RuntimeHints();\r\n    SpringFactoriesLoader.forResourceLocation(\"META-INF/spring/aot.factories\").load(RuntimeHintsRegistrar.class).forEach(registrar -> registrar.registerHints(this.hints, ClassUtils.getDefaultClassLoader()));\r\n}\n@Test\r\nvoid javaSqlDateHasHints() throws NoSuchMethodException {\r\n    assertThat(RuntimeHintsPredicates.reflection().onMethodInvocation(java.sql.Date.class, \"toLocalDate\")).accepts(this.hints);\r\n    assertThat(RuntimeHintsPredicates.reflection().onMethodInvocation(java.sql.Date.class.getMethod(\"valueOf\", LocalDate.class))).accepts(this.hints);\r\n}\n@Test\r\nvoid uriHasHints() throws NoSuchMethodException {\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(URI.class)).accepts(this.hints);\r\n}",
    "comment": "\n * Tests for {@link ObjectToObjectConverterRuntimeHints}.\n *\n * @author Sebastien Deleuze\n "
  },
  {
    "entityId": "org.springframework.aot.hint.support.ObjectToObjectConverterRuntimeHintsTests#setup()",
    "entityType": "method",
    "code": "@BeforeEach\r\nvoid setup() {\r\n    this.hints = new RuntimeHints();\r\n    SpringFactoriesLoader.forResourceLocation(\"META-INF/spring/aot.factories\").load(RuntimeHintsRegistrar.class).forEach(registrar -> registrar.registerHints(this.hints, ClassUtils.getDefaultClassLoader()));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.support.ObjectToObjectConverterRuntimeHintsTests#javaSqlDateHasHints()",
    "entityType": "method",
    "code": "@Test\r\nvoid javaSqlDateHasHints() throws NoSuchMethodException {\r\n    assertThat(RuntimeHintsPredicates.reflection().onMethodInvocation(java.sql.Date.class, \"toLocalDate\")).accepts(this.hints);\r\n    assertThat(RuntimeHintsPredicates.reflection().onMethodInvocation(java.sql.Date.class.getMethod(\"valueOf\", LocalDate.class))).accepts(this.hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.support.ObjectToObjectConverterRuntimeHintsTests#uriHasHints()",
    "entityType": "method",
    "code": "@Test\r\nvoid uriHasHints() throws NoSuchMethodException {\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(URI.class)).accepts(this.hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.support.PathMatchingResourcePatternResolverRuntimeHintsTests",
    "entityType": "class",
    "code": "private RuntimeHints hints;\n@BeforeEach\r\nvoid setup() {\r\n    this.hints = new RuntimeHints();\r\n    SpringFactoriesLoader.forResourceLocation(\"META-INF/spring/aot.factories\").load(RuntimeHintsRegistrar.class).forEach(registrar -> registrar.registerHints(this.hints, ClassUtils.getDefaultClassLoader()));\r\n}\n@Test\r\nvoid EclipseOsgiFileLocatorHasHints() {\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(TypeReference.of(\"org.eclipse.core.runtime.FileLocator\"))).accepts(this.hints);\r\n}",
    "comment": "\n * Tests for {@link PathMatchingResourcePatternResolverRuntimeHints}.\n *\n * @author Brian Clozel\n "
  },
  {
    "entityId": "org.springframework.aot.hint.support.PathMatchingResourcePatternResolverRuntimeHintsTests#setup()",
    "entityType": "method",
    "code": "@BeforeEach\r\nvoid setup() {\r\n    this.hints = new RuntimeHints();\r\n    SpringFactoriesLoader.forResourceLocation(\"META-INF/spring/aot.factories\").load(RuntimeHintsRegistrar.class).forEach(registrar -> registrar.registerHints(this.hints, ClassUtils.getDefaultClassLoader()));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.support.PathMatchingResourcePatternResolverRuntimeHintsTests#EclipseOsgiFileLocatorHasHints()",
    "entityType": "method",
    "code": "@Test\r\nvoid EclipseOsgiFileLocatorHasHints() {\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(TypeReference.of(\"org.eclipse.core.runtime.FileLocator\"))).accepts(this.hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.support.SpringFactoriesLoaderRuntimeHintsTests",
    "entityType": "class",
    "code": "private RuntimeHints hints;\n@BeforeEach\r\nvoid setup() {\r\n    this.hints = new RuntimeHints();\r\n    SpringFactoriesLoader.forResourceLocation(\"META-INF/spring/aot.factories\").load(RuntimeHintsRegistrar.class).forEach(registrar -> registrar.registerHints(this.hints, ClassUtils.getDefaultClassLoader()));\r\n}\n@Test\r\nvoid resourceLocationHasHints() {\r\n    assertThat(RuntimeHintsPredicates.resource().forResource(SpringFactoriesLoader.FACTORIES_RESOURCE_LOCATION)).accepts(this.hints);\r\n}\n@Test\r\nvoid factoryTypeHasHint() {\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(DummyFactory.class).withMemberCategory(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)).accepts(this.hints);\r\n}\n@Test\r\nvoid factoryImplementationHasHint() {\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(MyDummyFactory1.class).withMemberCategory(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)).accepts(this.hints);\r\n}",
    "comment": "\n * Tests for {@link SpringFactoriesLoaderRuntimeHints}.\n *\n * @author Phillip Webb\n "
  },
  {
    "entityId": "org.springframework.aot.hint.support.SpringFactoriesLoaderRuntimeHintsTests#setup()",
    "entityType": "method",
    "code": "@BeforeEach\r\nvoid setup() {\r\n    this.hints = new RuntimeHints();\r\n    SpringFactoriesLoader.forResourceLocation(\"META-INF/spring/aot.factories\").load(RuntimeHintsRegistrar.class).forEach(registrar -> registrar.registerHints(this.hints, ClassUtils.getDefaultClassLoader()));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.support.SpringFactoriesLoaderRuntimeHintsTests#resourceLocationHasHints()",
    "entityType": "method",
    "code": "@Test\r\nvoid resourceLocationHasHints() {\r\n    assertThat(RuntimeHintsPredicates.resource().forResource(SpringFactoriesLoader.FACTORIES_RESOURCE_LOCATION)).accepts(this.hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.support.SpringFactoriesLoaderRuntimeHintsTests#factoryTypeHasHint()",
    "entityType": "method",
    "code": "@Test\r\nvoid factoryTypeHasHint() {\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(DummyFactory.class).withMemberCategory(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)).accepts(this.hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.support.SpringFactoriesLoaderRuntimeHintsTests#factoryImplementationHasHint()",
    "entityType": "method",
    "code": "@Test\r\nvoid factoryImplementationHasHint() {\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(MyDummyFactory1.class).withMemberCategory(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)).accepts(this.hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.support.SpringPropertiesRuntimeHintsTests",
    "entityType": "class",
    "code": "private RuntimeHints hints;\n@BeforeEach\r\nvoid setup() {\r\n    this.hints = new RuntimeHints();\r\n    SpringFactoriesLoader.forResourceLocation(\"META-INF/spring/aot.factories\").load(RuntimeHintsRegistrar.class).forEach(registrar -> registrar.registerHints(this.hints, ClassUtils.getDefaultClassLoader()));\r\n}\n@Test\r\nvoid springPropertiesResourceHasHints() {\r\n    assertThat(RuntimeHintsPredicates.resource().forResource(\"spring.properties\")).accepts(this.hints);\r\n}",
    "comment": "\n * Tests for {@link SpringPropertiesRuntimeHints}.\n * @author Brian Clozel\n "
  },
  {
    "entityId": "org.springframework.aot.hint.support.SpringPropertiesRuntimeHintsTests#setup()",
    "entityType": "method",
    "code": "@BeforeEach\r\nvoid setup() {\r\n    this.hints = new RuntimeHints();\r\n    SpringFactoriesLoader.forResourceLocation(\"META-INF/spring/aot.factories\").load(RuntimeHintsRegistrar.class).forEach(registrar -> registrar.registerHints(this.hints, ClassUtils.getDefaultClassLoader()));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.support.SpringPropertiesRuntimeHintsTests#springPropertiesResourceHasHints()",
    "entityType": "method",
    "code": "@Test\r\nvoid springPropertiesResourceHasHints() {\r\n    assertThat(RuntimeHintsPredicates.resource().forResource(\"spring.properties\")).accepts(this.hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.TypeHintTests",
    "entityType": "class",
    "code": "@Test\r\nvoid createWithNullTypeReference() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> TypeHint.of(null));\r\n}\n@Test\r\nvoid createWithType() {\r\n    TypeHint hint = TypeHint.of(TypeReference.of(String.class)).build();\r\n    assertThat(hint).isNotNull();\r\n    assertThat(hint.getType().getCanonicalName()).isEqualTo(\"java.lang.String\");\r\n}\n@Test\r\nvoid createWithTypeAndReachableType() {\r\n    TypeHint hint = TypeHint.of(TypeReference.of(String.class)).onReachableType(TypeReference.of(\"com.example.Test\")).build();\r\n    assertThat(hint).isNotNull();\r\n    assertThat(hint.getReachableType()).isNotNull();\r\n    assertThat(hint.getReachableType().getCanonicalName()).isEqualTo(\"com.example.Test\");\r\n}\n@Test\r\nvoid createWithField() {\r\n    assertFieldHint(TypeHint.of(TypeReference.of(String.class)).withField(\"value\"), fieldHint -> assertThat(fieldHint.getName()).isEqualTo(\"value\"));\r\n}\nvoid assertFieldHint(Builder builder, Consumer<FieldHint> fieldHint) {\r\n    TypeHint hint = builder.build();\r\n    assertThat(hint.fields()).singleElement().satisfies(fieldHint);\r\n    assertThat(hint.constructors()).isEmpty();\r\n    assertThat(hint.methods()).isEmpty();\r\n    assertThat(hint.getMemberCategories()).isEmpty();\r\n}\n@Test\r\nvoid createWithConstructor() {\r\n    List<TypeReference> parameterTypes = TypeReference.listOf(byte[].class, int.class);\r\n    assertConstructorHint(TypeHint.of(TypeReference.of(String.class)).withConstructor(parameterTypes, ExecutableMode.INTROSPECT), constructorHint -> {\r\n        assertThat(constructorHint.getParameterTypes()).containsOnlyOnceElementsOf(parameterTypes);\r\n        assertThat(constructorHint.getMode()).isEqualTo(ExecutableMode.INTROSPECT);\r\n    });\r\n}\n@Test\r\nvoid createWithConstructorWithSameConstructorUpdatesEntry() {\r\n    List<TypeReference> parameterTypes = TypeReference.listOf(byte[].class, int.class);\r\n    Builder builder = TypeHint.of(TypeReference.of(String.class)).withConstructor(parameterTypes, ExecutableMode.INTROSPECT);\r\n    assertConstructorHint(builder.withConstructor(parameterTypes, ExecutableMode.INVOKE), constructorHint -> {\r\n        assertThat(constructorHint.getParameterTypes()).containsExactlyElementsOf(parameterTypes);\r\n        assertThat(constructorHint.getMode()).isEqualTo(ExecutableMode.INVOKE);\r\n    });\r\n}\n@Test\r\nvoid createWithConstructorAndSameConstructorAppliesExecutableModePrecedence() {\r\n    List<TypeReference> parameterTypes = TypeReference.listOf(byte[].class, int.class);\r\n    Builder builder = TypeHint.of(TypeReference.of(String.class)).withConstructor(parameterTypes, ExecutableMode.INVOKE);\r\n    assertConstructorHint(builder.withConstructor(parameterTypes, ExecutableMode.INTROSPECT), constructorHint -> {\r\n        assertThat(constructorHint.getParameterTypes()).containsExactlyElementsOf(parameterTypes);\r\n        assertThat(constructorHint.getMode()).isEqualTo(ExecutableMode.INVOKE);\r\n    });\r\n}\nvoid assertConstructorHint(Builder builder, Consumer<ExecutableHint> constructorHint) {\r\n    TypeHint hint = builder.build();\r\n    assertThat(hint.fields()).isEmpty();\r\n    assertThat(hint.constructors()).singleElement().satisfies(constructorHint);\r\n    assertThat(hint.methods()).isEmpty();\r\n    assertThat(hint.getMemberCategories()).isEmpty();\r\n}\n@Test\r\nvoid createWithMethod() {\r\n    List<TypeReference> parameterTypes = List.of(TypeReference.of(char[].class));\r\n    assertMethodHint(TypeHint.of(TypeReference.of(String.class)).withMethod(\"valueOf\", parameterTypes, ExecutableMode.INTROSPECT), methodHint -> {\r\n        assertThat(methodHint.getName()).isEqualTo(\"valueOf\");\r\n        assertThat(methodHint.getParameterTypes()).containsExactlyElementsOf(parameterTypes);\r\n        assertThat(methodHint.getMode()).isEqualTo(ExecutableMode.INTROSPECT);\r\n    });\r\n}\n@Test\r\nvoid createWithMethodWithSameMethodUpdatesEntry() {\r\n    List<TypeReference> parameterTypes = TypeReference.listOf(char[].class);\r\n    Builder builder = TypeHint.of(TypeReference.of(String.class)).withMethod(\"valueOf\", parameterTypes, ExecutableMode.INTROSPECT);\r\n    assertMethodHint(builder.withMethod(\"valueOf\", parameterTypes, ExecutableMode.INVOKE), methodHint -> {\r\n        assertThat(methodHint.getName()).isEqualTo(\"valueOf\");\r\n        assertThat(methodHint.getParameterTypes()).containsExactlyElementsOf(parameterTypes);\r\n        assertThat(methodHint.getMode()).isEqualTo(ExecutableMode.INVOKE);\r\n    });\r\n}\n@Test\r\nvoid createWithMethodAndSameMethodAppliesExecutableModePrecedence() {\r\n    List<TypeReference> parameterTypes = TypeReference.listOf(char[].class);\r\n    Builder builder = TypeHint.of(TypeReference.of(String.class)).withMethod(\"valueOf\", parameterTypes, ExecutableMode.INVOKE);\r\n    assertMethodHint(builder.withMethod(\"valueOf\", parameterTypes, ExecutableMode.INTROSPECT), methodHint -> {\r\n        assertThat(methodHint.getName()).isEqualTo(\"valueOf\");\r\n        assertThat(methodHint.getParameterTypes()).containsExactlyElementsOf(parameterTypes);\r\n        assertThat(methodHint.getMode()).isEqualTo(ExecutableMode.INVOKE);\r\n    });\r\n}\nvoid assertMethodHint(Builder builder, Consumer<ExecutableHint> methodHint) {\r\n    TypeHint hint = builder.build();\r\n    assertThat(hint.fields()).isEmpty();\r\n    assertThat(hint.constructors()).isEmpty();\r\n    assertThat(hint.methods()).singleElement().satisfies(methodHint);\r\n    assertThat(hint.getMemberCategories()).isEmpty();\r\n}\n@Test\r\nvoid createWithMemberCategory() {\r\n    TypeHint hint = TypeHint.of(TypeReference.of(String.class)).withMembers(MemberCategory.DECLARED_FIELDS).build();\r\n    assertThat(hint.getMemberCategories()).containsOnly(MemberCategory.DECLARED_FIELDS);\r\n}\n@Test\r\nvoid typeHintHasAppropriateToString() {\r\n    TypeHint hint = TypeHint.of(TypeReference.of(String.class)).build();\r\n    assertThat(hint).hasToString(\"TypeHint[type=java.lang.String]\");\r\n}\n@Test\r\nvoid builtWithAppliesMemberCategories() {\r\n    TypeHint.Builder builder = new TypeHint.Builder(TypeReference.of(String.class));\r\n    assertThat(builder.build().getMemberCategories()).isEmpty();\r\n    TypeHint.builtWith(MemberCategory.DECLARED_FIELDS).accept(builder);\r\n    assertThat(builder.build().getMemberCategories()).containsExactly(MemberCategory.DECLARED_FIELDS);\r\n}",
    "comment": "\n * Tests for {@link TypeHint}.\n *\n * @author Stephane Nicoll\n "
  },
  {
    "entityId": "org.springframework.aot.hint.TypeHintTests#createWithNullTypeReference()",
    "entityType": "method",
    "code": "@Test\r\nvoid createWithNullTypeReference() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> TypeHint.of(null));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.TypeHintTests#createWithType()",
    "entityType": "method",
    "code": "@Test\r\nvoid createWithType() {\r\n    TypeHint hint = TypeHint.of(TypeReference.of(String.class)).build();\r\n    assertThat(hint).isNotNull();\r\n    assertThat(hint.getType().getCanonicalName()).isEqualTo(\"java.lang.String\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.TypeHintTests#createWithTypeAndReachableType()",
    "entityType": "method",
    "code": "@Test\r\nvoid createWithTypeAndReachableType() {\r\n    TypeHint hint = TypeHint.of(TypeReference.of(String.class)).onReachableType(TypeReference.of(\"com.example.Test\")).build();\r\n    assertThat(hint).isNotNull();\r\n    assertThat(hint.getReachableType()).isNotNull();\r\n    assertThat(hint.getReachableType().getCanonicalName()).isEqualTo(\"com.example.Test\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.TypeHintTests#createWithField()",
    "entityType": "method",
    "code": "@Test\r\nvoid createWithField() {\r\n    assertFieldHint(TypeHint.of(TypeReference.of(String.class)).withField(\"value\"), fieldHint -> assertThat(fieldHint.getName()).isEqualTo(\"value\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.TypeHintTests#assertFieldHint(Builder,Consumer<FieldHint>)",
    "entityType": "method",
    "code": "void assertFieldHint(Builder builder, Consumer<FieldHint> fieldHint) {\r\n    TypeHint hint = builder.build();\r\n    assertThat(hint.fields()).singleElement().satisfies(fieldHint);\r\n    assertThat(hint.constructors()).isEmpty();\r\n    assertThat(hint.methods()).isEmpty();\r\n    assertThat(hint.getMemberCategories()).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.TypeHintTests#createWithConstructor()",
    "entityType": "method",
    "code": "@Test\r\nvoid createWithConstructor() {\r\n    List<TypeReference> parameterTypes = TypeReference.listOf(byte[].class, int.class);\r\n    assertConstructorHint(TypeHint.of(TypeReference.of(String.class)).withConstructor(parameterTypes, ExecutableMode.INTROSPECT), constructorHint -> {\r\n        assertThat(constructorHint.getParameterTypes()).containsOnlyOnceElementsOf(parameterTypes);\r\n        assertThat(constructorHint.getMode()).isEqualTo(ExecutableMode.INTROSPECT);\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.TypeHintTests#createWithConstructorWithSameConstructorUpdatesEntry()",
    "entityType": "method",
    "code": "@Test\r\nvoid createWithConstructorWithSameConstructorUpdatesEntry() {\r\n    List<TypeReference> parameterTypes = TypeReference.listOf(byte[].class, int.class);\r\n    Builder builder = TypeHint.of(TypeReference.of(String.class)).withConstructor(parameterTypes, ExecutableMode.INTROSPECT);\r\n    assertConstructorHint(builder.withConstructor(parameterTypes, ExecutableMode.INVOKE), constructorHint -> {\r\n        assertThat(constructorHint.getParameterTypes()).containsExactlyElementsOf(parameterTypes);\r\n        assertThat(constructorHint.getMode()).isEqualTo(ExecutableMode.INVOKE);\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.TypeHintTests#createWithConstructorAndSameConstructorAppliesExecutableModePrecedence()",
    "entityType": "method",
    "code": "@Test\r\nvoid createWithConstructorAndSameConstructorAppliesExecutableModePrecedence() {\r\n    List<TypeReference> parameterTypes = TypeReference.listOf(byte[].class, int.class);\r\n    Builder builder = TypeHint.of(TypeReference.of(String.class)).withConstructor(parameterTypes, ExecutableMode.INVOKE);\r\n    assertConstructorHint(builder.withConstructor(parameterTypes, ExecutableMode.INTROSPECT), constructorHint -> {\r\n        assertThat(constructorHint.getParameterTypes()).containsExactlyElementsOf(parameterTypes);\r\n        assertThat(constructorHint.getMode()).isEqualTo(ExecutableMode.INVOKE);\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.TypeHintTests#assertConstructorHint(Builder,Consumer<ExecutableHint>)",
    "entityType": "method",
    "code": "void assertConstructorHint(Builder builder, Consumer<ExecutableHint> constructorHint) {\r\n    TypeHint hint = builder.build();\r\n    assertThat(hint.fields()).isEmpty();\r\n    assertThat(hint.constructors()).singleElement().satisfies(constructorHint);\r\n    assertThat(hint.methods()).isEmpty();\r\n    assertThat(hint.getMemberCategories()).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.TypeHintTests#createWithMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid createWithMethod() {\r\n    List<TypeReference> parameterTypes = List.of(TypeReference.of(char[].class));\r\n    assertMethodHint(TypeHint.of(TypeReference.of(String.class)).withMethod(\"valueOf\", parameterTypes, ExecutableMode.INTROSPECT), methodHint -> {\r\n        assertThat(methodHint.getName()).isEqualTo(\"valueOf\");\r\n        assertThat(methodHint.getParameterTypes()).containsExactlyElementsOf(parameterTypes);\r\n        assertThat(methodHint.getMode()).isEqualTo(ExecutableMode.INTROSPECT);\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.TypeHintTests#createWithMethodWithSameMethodUpdatesEntry()",
    "entityType": "method",
    "code": "@Test\r\nvoid createWithMethodWithSameMethodUpdatesEntry() {\r\n    List<TypeReference> parameterTypes = TypeReference.listOf(char[].class);\r\n    Builder builder = TypeHint.of(TypeReference.of(String.class)).withMethod(\"valueOf\", parameterTypes, ExecutableMode.INTROSPECT);\r\n    assertMethodHint(builder.withMethod(\"valueOf\", parameterTypes, ExecutableMode.INVOKE), methodHint -> {\r\n        assertThat(methodHint.getName()).isEqualTo(\"valueOf\");\r\n        assertThat(methodHint.getParameterTypes()).containsExactlyElementsOf(parameterTypes);\r\n        assertThat(methodHint.getMode()).isEqualTo(ExecutableMode.INVOKE);\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.TypeHintTests#createWithMethodAndSameMethodAppliesExecutableModePrecedence()",
    "entityType": "method",
    "code": "@Test\r\nvoid createWithMethodAndSameMethodAppliesExecutableModePrecedence() {\r\n    List<TypeReference> parameterTypes = TypeReference.listOf(char[].class);\r\n    Builder builder = TypeHint.of(TypeReference.of(String.class)).withMethod(\"valueOf\", parameterTypes, ExecutableMode.INVOKE);\r\n    assertMethodHint(builder.withMethod(\"valueOf\", parameterTypes, ExecutableMode.INTROSPECT), methodHint -> {\r\n        assertThat(methodHint.getName()).isEqualTo(\"valueOf\");\r\n        assertThat(methodHint.getParameterTypes()).containsExactlyElementsOf(parameterTypes);\r\n        assertThat(methodHint.getMode()).isEqualTo(ExecutableMode.INVOKE);\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.TypeHintTests#assertMethodHint(Builder,Consumer<ExecutableHint>)",
    "entityType": "method",
    "code": "void assertMethodHint(Builder builder, Consumer<ExecutableHint> methodHint) {\r\n    TypeHint hint = builder.build();\r\n    assertThat(hint.fields()).isEmpty();\r\n    assertThat(hint.constructors()).isEmpty();\r\n    assertThat(hint.methods()).singleElement().satisfies(methodHint);\r\n    assertThat(hint.getMemberCategories()).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.TypeHintTests#createWithMemberCategory()",
    "entityType": "method",
    "code": "@Test\r\nvoid createWithMemberCategory() {\r\n    TypeHint hint = TypeHint.of(TypeReference.of(String.class)).withMembers(MemberCategory.DECLARED_FIELDS).build();\r\n    assertThat(hint.getMemberCategories()).containsOnly(MemberCategory.DECLARED_FIELDS);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.TypeHintTests#typeHintHasAppropriateToString()",
    "entityType": "method",
    "code": "@Test\r\nvoid typeHintHasAppropriateToString() {\r\n    TypeHint hint = TypeHint.of(TypeReference.of(String.class)).build();\r\n    assertThat(hint).hasToString(\"TypeHint[type=java.lang.String]\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.TypeHintTests#builtWithAppliesMemberCategories()",
    "entityType": "method",
    "code": "@Test\r\nvoid builtWithAppliesMemberCategories() {\r\n    TypeHint.Builder builder = new TypeHint.Builder(TypeReference.of(String.class));\r\n    assertThat(builder.build().getMemberCategories()).isEmpty();\r\n    TypeHint.builtWith(MemberCategory.DECLARED_FIELDS).accept(builder);\r\n    assertThat(builder.build().getMemberCategories()).containsExactly(MemberCategory.DECLARED_FIELDS);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.TypeReferenceTests",
    "entityType": "class",
    "code": "@Test\r\nvoid typeReferenceWithClassName() {\r\n    TypeReference type = TypeReference.of(\"java.lang.String\");\r\n    assertThat(type.getName()).isEqualTo(\"java.lang.String\");\r\n    assertThat(type.getCanonicalName()).isEqualTo(\"java.lang.String\");\r\n    assertThat(type.getPackageName()).isEqualTo(\"java.lang\");\r\n    assertThat(type.getSimpleName()).isEqualTo(\"String\");\r\n    assertThat(type.getEnclosingType()).isNull();\r\n}\n@Test\r\nvoid typeReferenceWithInnerClassName() {\r\n    TypeReference type = TypeReference.of(\"com.example.Example$Inner\");\r\n    assertThat(type.getName()).isEqualTo(\"com.example.Example$Inner\");\r\n    assertThat(type.getCanonicalName()).isEqualTo(\"com.example.Example.Inner\");\r\n    assertThat(type.getPackageName()).isEqualTo(\"com.example\");\r\n    assertThat(type.getSimpleName()).isEqualTo(\"Inner\");\r\n    assertThat(type.getEnclosingType()).satisfies(enclosingType -> {\r\n        assertThat(enclosingType.getCanonicalName()).isEqualTo(\"com.example.Example\");\r\n        assertThat(enclosingType.getPackageName()).isEqualTo(\"com.example\");\r\n        assertThat(enclosingType.getSimpleName()).isEqualTo(\"Example\");\r\n        assertThat(enclosingType.getEnclosingType()).isNull();\r\n    });\r\n}\n@Test\r\nvoid typeReferenceWithNestedInnerClassName() {\r\n    TypeReference type = TypeReference.of(\"com.example.Example$Inner$Nested\");\r\n    assertThat(type.getName()).isEqualTo(\"com.example.Example$Inner$Nested\");\r\n    assertThat(type.getCanonicalName()).isEqualTo(\"com.example.Example.Inner.Nested\");\r\n    assertThat(type.getPackageName()).isEqualTo(\"com.example\");\r\n    assertThat(type.getSimpleName()).isEqualTo(\"Nested\");\r\n    assertThat(type.getEnclosingType()).satisfies(enclosingType -> {\r\n        assertThat(enclosingType.getCanonicalName()).isEqualTo(\"com.example.Example.Inner\");\r\n        assertThat(enclosingType.getPackageName()).isEqualTo(\"com.example\");\r\n        assertThat(enclosingType.getSimpleName()).isEqualTo(\"Inner\");\r\n        assertThat(enclosingType.getEnclosingType()).satisfies(parentEnclosingType -> {\r\n            assertThat(parentEnclosingType.getCanonicalName()).isEqualTo(\"com.example.Example\");\r\n            assertThat(parentEnclosingType.getPackageName()).isEqualTo(\"com.example\");\r\n            assertThat(parentEnclosingType.getSimpleName()).isEqualTo(\"Example\");\r\n            assertThat(parentEnclosingType.getEnclosingType()).isNull();\r\n        });\r\n    });\r\n}\n@Test\r\nvoid equalsWithIdenticalNameIsTrue() {\r\n    assertThat(TypeReference.of(String.class)).isEqualTo(TypeReference.of(\"java.lang.String\"));\r\n}\n@Test\r\nvoid equalsWithNonTypeReferenceIsFalse() {\r\n    assertThat(TypeReference.of(String.class)).isNotEqualTo(\"java.lang.String\");\r\n}\n@Test\r\nvoid toStringUsesCanonicalName() {\r\n    assertThat(TypeReference.of(String.class)).hasToString(\"java.lang.String\");\r\n}",
    "comment": "\n * Tests for {@link TypeReference}.\n *\n * @author Stephane Nicoll\n "
  },
  {
    "entityId": "org.springframework.aot.hint.TypeReferenceTests#typeReferenceWithClassName()",
    "entityType": "method",
    "code": "@Test\r\nvoid typeReferenceWithClassName() {\r\n    TypeReference type = TypeReference.of(\"java.lang.String\");\r\n    assertThat(type.getName()).isEqualTo(\"java.lang.String\");\r\n    assertThat(type.getCanonicalName()).isEqualTo(\"java.lang.String\");\r\n    assertThat(type.getPackageName()).isEqualTo(\"java.lang\");\r\n    assertThat(type.getSimpleName()).isEqualTo(\"String\");\r\n    assertThat(type.getEnclosingType()).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.TypeReferenceTests#typeReferenceWithInnerClassName()",
    "entityType": "method",
    "code": "@Test\r\nvoid typeReferenceWithInnerClassName() {\r\n    TypeReference type = TypeReference.of(\"com.example.Example$Inner\");\r\n    assertThat(type.getName()).isEqualTo(\"com.example.Example$Inner\");\r\n    assertThat(type.getCanonicalName()).isEqualTo(\"com.example.Example.Inner\");\r\n    assertThat(type.getPackageName()).isEqualTo(\"com.example\");\r\n    assertThat(type.getSimpleName()).isEqualTo(\"Inner\");\r\n    assertThat(type.getEnclosingType()).satisfies(enclosingType -> {\r\n        assertThat(enclosingType.getCanonicalName()).isEqualTo(\"com.example.Example\");\r\n        assertThat(enclosingType.getPackageName()).isEqualTo(\"com.example\");\r\n        assertThat(enclosingType.getSimpleName()).isEqualTo(\"Example\");\r\n        assertThat(enclosingType.getEnclosingType()).isNull();\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.TypeReferenceTests#typeReferenceWithNestedInnerClassName()",
    "entityType": "method",
    "code": "@Test\r\nvoid typeReferenceWithNestedInnerClassName() {\r\n    TypeReference type = TypeReference.of(\"com.example.Example$Inner$Nested\");\r\n    assertThat(type.getName()).isEqualTo(\"com.example.Example$Inner$Nested\");\r\n    assertThat(type.getCanonicalName()).isEqualTo(\"com.example.Example.Inner.Nested\");\r\n    assertThat(type.getPackageName()).isEqualTo(\"com.example\");\r\n    assertThat(type.getSimpleName()).isEqualTo(\"Nested\");\r\n    assertThat(type.getEnclosingType()).satisfies(enclosingType -> {\r\n        assertThat(enclosingType.getCanonicalName()).isEqualTo(\"com.example.Example.Inner\");\r\n        assertThat(enclosingType.getPackageName()).isEqualTo(\"com.example\");\r\n        assertThat(enclosingType.getSimpleName()).isEqualTo(\"Inner\");\r\n        assertThat(enclosingType.getEnclosingType()).satisfies(parentEnclosingType -> {\r\n            assertThat(parentEnclosingType.getCanonicalName()).isEqualTo(\"com.example.Example\");\r\n            assertThat(parentEnclosingType.getPackageName()).isEqualTo(\"com.example\");\r\n            assertThat(parentEnclosingType.getSimpleName()).isEqualTo(\"Example\");\r\n            assertThat(parentEnclosingType.getEnclosingType()).isNull();\r\n        });\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.TypeReferenceTests#equalsWithIdenticalNameIsTrue()",
    "entityType": "method",
    "code": "@Test\r\nvoid equalsWithIdenticalNameIsTrue() {\r\n    assertThat(TypeReference.of(String.class)).isEqualTo(TypeReference.of(\"java.lang.String\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.TypeReferenceTests#equalsWithNonTypeReferenceIsFalse()",
    "entityType": "method",
    "code": "@Test\r\nvoid equalsWithNonTypeReferenceIsFalse() {\r\n    assertThat(TypeReference.of(String.class)).isNotEqualTo(\"java.lang.String\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.TypeReferenceTests#toStringUsesCanonicalName()",
    "entityType": "method",
    "code": "@Test\r\nvoid toStringUsesCanonicalName() {\r\n    assertThat(TypeReference.of(String.class)).hasToString(\"java.lang.String\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.BasicJsonWriterTests",
    "entityType": "class",
    "code": "private final StringWriter out = new StringWriter();\nprivate final BasicJsonWriter json = new BasicJsonWriter(out, \"\\t\");\n@Test\r\nvoid writeObject() {\r\n    Map<String, Object> attributes = orderedMap(\"test\", \"value\");\r\n    attributes.put(\"another\", true);\r\n    this.json.writeObject(attributes);\r\n    assertThat(out.toString()).isEqualToNormalizingNewlines(\"\"\"\r\n        {\r\n        \t\"test\": \"value\",\r\n        \t\"another\": true\r\n        }\r\n        \"\"\");\r\n}\n@Test\r\nvoid writeObjectWithNestedObject() {\r\n    Map<String, Object> attributes = orderedMap(\"test\", \"value\");\r\n    attributes.put(\"nested\", orderedMap(\"enabled\", false));\r\n    this.json.writeObject(attributes);\r\n    assertThat(out.toString()).isEqualToNormalizingNewlines(\"\"\"\r\n        {\r\n        \t\"test\": \"value\",\r\n        \t\"nested\": {\r\n        \t\t\"enabled\": false\r\n        \t}\r\n        }\r\n        \"\"\");\r\n}\n@Test\r\nvoid writeObjectWithNestedArrayOfString() {\r\n    Map<String, Object> attributes = orderedMap(\"test\", \"value\");\r\n    attributes.put(\"nested\", List.of(\"test\", \"value\", \"another\"));\r\n    this.json.writeObject(attributes);\r\n    assertThat(out.toString()).isEqualToNormalizingNewlines(\"\"\"\r\n        {\r\n        \t\"test\": \"value\",\r\n        \t\"nested\": [\r\n        \t\t\"test\",\r\n        \t\t\"value\",\r\n        \t\t\"another\"\r\n        \t]\r\n        }\r\n        \"\"\");\r\n}\n@Test\r\nvoid writeObjectWithNestedArrayOfObject() {\r\n    Map<String, Object> attributes = orderedMap(\"test\", \"value\");\r\n    LinkedHashMap<String, Object> secondNested = orderedMap(\"name\", \"second\");\r\n    secondNested.put(\"enabled\", false);\r\n    attributes.put(\"nested\", List.of(orderedMap(\"name\", \"first\"), secondNested, orderedMap(\"name\", \"third\")));\r\n    this.json.writeObject(attributes);\r\n    assertThat(out.toString()).isEqualToNormalizingNewlines(\"\"\"\r\n        {\r\n        \t\"test\": \"value\",\r\n        \t\"nested\": [\r\n        \t\t{\r\n        \t\t\t\"name\": \"first\"\r\n        \t\t},\r\n        \t\t{\r\n        \t\t\t\"name\": \"second\",\r\n        \t\t\t\"enabled\": false\r\n        \t\t},\r\n        \t\t{\r\n        \t\t\t\"name\": \"third\"\r\n        \t\t}\r\n        \t]\r\n        }\r\n        \"\"\");\r\n}\n@Test\r\nvoid writeObjectWithNestedEmptyArray() {\r\n    Map<String, Object> attributes = orderedMap(\"test\", \"value\");\r\n    attributes.put(\"nested\", Collections.emptyList());\r\n    this.json.writeObject(attributes);\r\n    assertThat(out.toString()).isEqualToNormalizingNewlines(\"\"\"\r\n        {\r\n        \t\"test\": \"value\",\r\n        \t\"nested\": [ ]\r\n        }\r\n        \"\"\");\r\n}\n@Test\r\nvoid writeObjectWithNestedEmptyObject() {\r\n    Map<String, Object> attributes = orderedMap(\"test\", \"value\");\r\n    attributes.put(\"nested\", Collections.emptyMap());\r\n    this.json.writeObject(attributes);\r\n    assertThat(out.toString()).isEqualToNormalizingNewlines(\"\"\"\r\n        {\r\n        \t\"test\": \"value\",\r\n        \t\"nested\": ;\r\n        }\r\n        \"\"\");\r\n}\n@Test\r\nvoid writeWithEscapeDoubleQuote() {\r\n    assertStringAttribute(\"foo\\\"bar\", \"foo\\\\\\\"bar\");\r\n}\n@Test\r\nvoid writeWithEscapeBackslash() {\r\n    assertStringAttribute(\"foo\\\"bar\", \"foo\\\\\\\"bar\");\r\n}\n@Test\r\nvoid writeWithEscapeBackspace() {\r\n    assertStringAttribute(\"foo\\bbar\", \"foo\\\\bbar\");\r\n}\n@Test\r\nvoid writeWithEscapeFormFeed() {\r\n    assertStringAttribute(\"foo\\fbar\", \"foo\\\\fbar\");\r\n}\n@Test\r\nvoid writeWithEscapeNewline() {\r\n    assertStringAttribute(\"foo\\nbar\", \"foo\\\\nbar\");\r\n}\n@Test\r\nvoid writeWithEscapeCarriageReturn() {\r\n    assertStringAttribute(\"foo\\rbar\", \"foo\\\\rbar\");\r\n}\n@Test\r\nvoid writeWithEscapeTab() {\r\n    assertStringAttribute(\"foo\\tbar\", \"foo\\\\tbar\");\r\n}\n@Test\r\nvoid writeWithEscapeUnicode() {\r\n    assertStringAttribute(\"foo\\u001Fbar\", \"foo\\\\u001fbar\");\r\n}\n@Test\r\nvoid writeWithTypeReferenceForSimpleClass() {\r\n    assertStringAttribute(TypeReference.of(String.class), \"java.lang.String\");\r\n}\n@Test\r\nvoid writeWithTypeReferenceForInnerClass() {\r\n    assertStringAttribute(TypeReference.of(Nested.class), \"org.springframework.aot.nativex.BasicJsonWriterTests$Nested\");\r\n}\n@Test\r\nvoid writeWithTypeReferenceForDoubleInnerClass() {\r\n    assertStringAttribute(TypeReference.of(Inner.class), \"org.springframework.aot.nativex.BasicJsonWriterTests$Nested$Inner\");\r\n}\nvoid assertStringAttribute(Object value, String expectedValue) {\r\n    Map<String, Object> attributes = new LinkedHashMap<>();\r\n    attributes.put(\"test\", value);\r\n    this.json.writeObject(attributes);\r\n    assertThat(out.toString()).contains(\"\\\"test\\\": \\\"\" + expectedValue + \"\\\"\");\r\n}\nprivate static LinkedHashMap<String, Object> orderedMap(String key, Object value) {\r\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\r\n    map.put(key, value);\r\n    return map;\r\n}\nstatic class Nested {\r\n\r\n    static class Inner {\r\n    }\r\n}",
    "comment": "\n * Tests for {@link BasicJsonWriter}.\n *\n * @author Stephane Nicoll\n "
  },
  {
    "entityId": "org.springframework.aot.nativex.BasicJsonWriterTests#writeObject()",
    "entityType": "method",
    "code": "@Test\r\nvoid writeObject() {\r\n    Map<String, Object> attributes = orderedMap(\"test\", \"value\");\r\n    attributes.put(\"another\", true);\r\n    this.json.writeObject(attributes);\r\n    assertThat(out.toString()).isEqualToNormalizingNewlines(\"\"\"\r\n        {\r\n        \t\"test\": \"value\",\r\n        \t\"another\": true\r\n        }\r\n        \"\"\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.BasicJsonWriterTests#writeObjectWithNestedObject()",
    "entityType": "method",
    "code": "@Test\r\nvoid writeObjectWithNestedObject() {\r\n    Map<String, Object> attributes = orderedMap(\"test\", \"value\");\r\n    attributes.put(\"nested\", orderedMap(\"enabled\", false));\r\n    this.json.writeObject(attributes);\r\n    assertThat(out.toString()).isEqualToNormalizingNewlines(\"\"\"\r\n        {\r\n        \t\"test\": \"value\",\r\n        \t\"nested\": {\r\n        \t\t\"enabled\": false\r\n        \t}\r\n        }\r\n        \"\"\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.BasicJsonWriterTests#writeObjectWithNestedArrayOfString()",
    "entityType": "method",
    "code": "@Test\r\nvoid writeObjectWithNestedArrayOfString() {\r\n    Map<String, Object> attributes = orderedMap(\"test\", \"value\");\r\n    attributes.put(\"nested\", List.of(\"test\", \"value\", \"another\"));\r\n    this.json.writeObject(attributes);\r\n    assertThat(out.toString()).isEqualToNormalizingNewlines(\"\"\"\r\n        {\r\n        \t\"test\": \"value\",\r\n        \t\"nested\": [\r\n        \t\t\"test\",\r\n        \t\t\"value\",\r\n        \t\t\"another\"\r\n        \t]\r\n        }\r\n        \"\"\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.BasicJsonWriterTests#writeObjectWithNestedArrayOfObject()",
    "entityType": "method",
    "code": "@Test\r\nvoid writeObjectWithNestedArrayOfObject() {\r\n    Map<String, Object> attributes = orderedMap(\"test\", \"value\");\r\n    LinkedHashMap<String, Object> secondNested = orderedMap(\"name\", \"second\");\r\n    secondNested.put(\"enabled\", false);\r\n    attributes.put(\"nested\", List.of(orderedMap(\"name\", \"first\"), secondNested, orderedMap(\"name\", \"third\")));\r\n    this.json.writeObject(attributes);\r\n    assertThat(out.toString()).isEqualToNormalizingNewlines(\"\"\"\r\n        {\r\n        \t\"test\": \"value\",\r\n        \t\"nested\": [\r\n        \t\t{\r\n        \t\t\t\"name\": \"first\"\r\n        \t\t},\r\n        \t\t{\r\n        \t\t\t\"name\": \"second\",\r\n        \t\t\t\"enabled\": false\r\n        \t\t},\r\n        \t\t{\r\n        \t\t\t\"name\": \"third\"\r\n        \t\t}\r\n        \t]\r\n        }\r\n        \"\"\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.BasicJsonWriterTests#writeObjectWithNestedEmptyArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid writeObjectWithNestedEmptyArray() {\r\n    Map<String, Object> attributes = orderedMap(\"test\", \"value\");\r\n    attributes.put(\"nested\", Collections.emptyList());\r\n    this.json.writeObject(attributes);\r\n    assertThat(out.toString()).isEqualToNormalizingNewlines(\"\"\"\r\n        {\r\n        \t\"test\": \"value\",\r\n        \t\"nested\": [ ]\r\n        }\r\n        \"\"\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.BasicJsonWriterTests#writeObjectWithNestedEmptyObject()",
    "entityType": "method",
    "code": "@Test\r\nvoid writeObjectWithNestedEmptyObject() {\r\n    Map<String, Object> attributes = orderedMap(\"test\", \"value\");\r\n    attributes.put(\"nested\", Collections.emptyMap());\r\n    this.json.writeObject(attributes);\r\n    assertThat(out.toString()).isEqualToNormalizingNewlines(\"\"\"\r\n        {\r\n        \t\"test\": \"value\",\r\n        \t\"nested\": ;\r\n        }\r\n        \"\"\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.BasicJsonWriterTests#writeWithEscapeDoubleQuote()",
    "entityType": "method",
    "code": "@Test\r\nvoid writeWithEscapeDoubleQuote() {\r\n    assertStringAttribute(\"foo\\\"bar\", \"foo\\\\\\\"bar\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.BasicJsonWriterTests#writeWithEscapeBackslash()",
    "entityType": "method",
    "code": "@Test\r\nvoid writeWithEscapeBackslash() {\r\n    assertStringAttribute(\"foo\\\"bar\", \"foo\\\\\\\"bar\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.BasicJsonWriterTests#writeWithEscapeBackspace()",
    "entityType": "method",
    "code": "@Test\r\nvoid writeWithEscapeBackspace() {\r\n    assertStringAttribute(\"foo\\bbar\", \"foo\\\\bbar\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.BasicJsonWriterTests#writeWithEscapeFormFeed()",
    "entityType": "method",
    "code": "@Test\r\nvoid writeWithEscapeFormFeed() {\r\n    assertStringAttribute(\"foo\\fbar\", \"foo\\\\fbar\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.BasicJsonWriterTests#writeWithEscapeNewline()",
    "entityType": "method",
    "code": "@Test\r\nvoid writeWithEscapeNewline() {\r\n    assertStringAttribute(\"foo\\nbar\", \"foo\\\\nbar\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.BasicJsonWriterTests#writeWithEscapeCarriageReturn()",
    "entityType": "method",
    "code": "@Test\r\nvoid writeWithEscapeCarriageReturn() {\r\n    assertStringAttribute(\"foo\\rbar\", \"foo\\\\rbar\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.BasicJsonWriterTests#writeWithEscapeTab()",
    "entityType": "method",
    "code": "@Test\r\nvoid writeWithEscapeTab() {\r\n    assertStringAttribute(\"foo\\tbar\", \"foo\\\\tbar\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.BasicJsonWriterTests#writeWithEscapeUnicode()",
    "entityType": "method",
    "code": "@Test\r\nvoid writeWithEscapeUnicode() {\r\n    assertStringAttribute(\"foo\\u001Fbar\", \"foo\\\\u001fbar\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.BasicJsonWriterTests#writeWithTypeReferenceForSimpleClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid writeWithTypeReferenceForSimpleClass() {\r\n    assertStringAttribute(TypeReference.of(String.class), \"java.lang.String\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.BasicJsonWriterTests#writeWithTypeReferenceForInnerClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid writeWithTypeReferenceForInnerClass() {\r\n    assertStringAttribute(TypeReference.of(Nested.class), \"org.springframework.aot.nativex.BasicJsonWriterTests$Nested\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.BasicJsonWriterTests#writeWithTypeReferenceForDoubleInnerClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid writeWithTypeReferenceForDoubleInnerClass() {\r\n    assertStringAttribute(TypeReference.of(Inner.class), \"org.springframework.aot.nativex.BasicJsonWriterTests$Nested$Inner\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.BasicJsonWriterTests#assertStringAttribute(Object,String)",
    "entityType": "method",
    "code": "void assertStringAttribute(Object value, String expectedValue) {\r\n    Map<String, Object> attributes = new LinkedHashMap<>();\r\n    attributes.put(\"test\", value);\r\n    this.json.writeObject(attributes);\r\n    assertThat(out.toString()).contains(\"\\\"test\\\": \\\"\" + expectedValue + \"\\\"\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.BasicJsonWriterTests#orderedMap(String,Object)",
    "entityType": "method",
    "code": "private static LinkedHashMap<String, Object> orderedMap(String key, Object value) {\r\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\r\n    map.put(key, value);\r\n    return map;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.Nested",
    "entityType": "class",
    "code": "static class Inner {\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.Inner",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.FileNativeConfigurationWriterTests",
    "entityType": "class",
    "code": "@TempDir\r\nstatic Path tempDir;\n@Test\r\nvoid emptyConfig() {\r\n    Path empty = tempDir.resolve(\"empty\");\r\n    FileNativeConfigurationWriter generator = new FileNativeConfigurationWriter(empty);\r\n    generator.write(new RuntimeHints());\r\n    assertThat(empty.toFile().listFiles()).isNull();\r\n}\n@Test\r\nvoid serializationConfig() throws IOException, JSONException {\r\n    FileNativeConfigurationWriter generator = new FileNativeConfigurationWriter(tempDir);\r\n    RuntimeHints hints = new RuntimeHints();\r\n    SerializationHints serializationHints = hints.serialization();\r\n    serializationHints.registerType(Integer.class);\r\n    serializationHints.registerType(Long.class);\r\n    generator.write(hints);\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"serialization\": [\r\n        \t\t{ \"type\": \"java.lang.Integer\" },\r\n        \t\t{ \"type\": \"java.lang.Long\" }\r\n        \t]\r\n        }\r\n        \"\"\");\r\n}\n@Test\r\nvoid proxyConfig() throws IOException, JSONException {\r\n    FileNativeConfigurationWriter generator = new FileNativeConfigurationWriter(tempDir);\r\n    RuntimeHints hints = new RuntimeHints();\r\n    ProxyHints proxyHints = hints.proxies();\r\n    proxyHints.registerJdkProxy(Function.class);\r\n    proxyHints.registerJdkProxy(Function.class, Consumer.class);\r\n    generator.write(hints);\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"reflection\": [\r\n        \t\t{ type: {\"proxy\": [ \"java.util.function.Function\" ] } },\r\n        \t\t{ type: {\"proxy\": [ \"java.util.function.Function\", \"java.util.function.Consumer\" ] } }\r\n        \t]\r\n        }\r\n        \"\"\");\r\n}\n@Test\r\nvoid reflectionConfig() throws IOException, JSONException {\r\n    FileNativeConfigurationWriter generator = new FileNativeConfigurationWriter(tempDir);\r\n    RuntimeHints hints = new RuntimeHints();\r\n    ReflectionHints reflectionHints = hints.reflection();\r\n    reflectionHints.registerType(StringDecoder.class, builder -> builder.onReachableType(String.class).withMembers(MemberCategory.ACCESS_PUBLIC_FIELDS, MemberCategory.ACCESS_DECLARED_FIELDS, MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_PUBLIC_METHODS, MemberCategory.INVOKE_DECLARED_METHODS).withField(\"DEFAULT_CHARSET\").withField(\"defaultCharset\").withMethod(\"setDefaultCharset\", TypeReference.listOf(Charset.class), ExecutableMode.INVOKE));\r\n    generator.write(hints);\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"reflection\": [\r\n        \t\t{\r\n        \t\t\t\"type\": \"org.springframework.core.codec.StringDecoder\",\r\n        \t\t\t\"condition\": { \"typeReached\": \"java.lang.String\" },\r\n        \t\t\t\"allPublicFields\": true,\r\n        \t\t\t\"allDeclaredFields\": true,\r\n        \t\t\t\"allPublicConstructors\": true,\r\n        \t\t\t\"allDeclaredConstructors\": true,\r\n        \t\t\t\"allPublicMethods\": true,\r\n        \t\t\t\"allDeclaredMethods\": true,\r\n        \t\t\t\"fields\": [\r\n        \t\t\t\t{ \"name\": \"DEFAULT_CHARSET\" },\r\n        \t\t\t\t{ \"name\": \"defaultCharset\" }\r\n        \t\t\t],\r\n        \t\t\t\"methods\": [\r\n        \t\t\t\t{ \"name\": \"setDefaultCharset\", \"parameterTypes\": [ \"java.nio.charset.Charset\" ] }\r\n        \t\t\t]\r\n        \t\t}\r\n        \t]\r\n        }\r\n        \"\"\");\r\n}\n@Test\r\nvoid jniConfig() throws IOException, JSONException {\r\n    // same format as reflection so just test basic file generation\r\n    FileNativeConfigurationWriter generator = new FileNativeConfigurationWriter(tempDir);\r\n    RuntimeHints hints = new RuntimeHints();\r\n    ReflectionHints jniHints = hints.jni();\r\n    jniHints.registerType(StringDecoder.class, builder -> builder.onReachableType(String.class));\r\n    generator.write(hints);\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"jni\": [\r\n        \t\t{\r\n        \t\t\t\"type\": \"org.springframework.core.codec.StringDecoder\",\r\n        \t\t\t\"condition\": { \"typeReached\": \"java.lang.String\" }\r\n        \t\t}\r\n        \t]\r\n        }\"\"\");\r\n}\n@Test\r\nvoid resourceConfig() throws IOException, JSONException {\r\n    FileNativeConfigurationWriter generator = new FileNativeConfigurationWriter(tempDir);\r\n    RuntimeHints hints = new RuntimeHints();\r\n    ResourceHints resourceHints = hints.resources();\r\n    resourceHints.registerPattern(\"com/example/test.properties\");\r\n    resourceHints.registerPattern(\"com/example/another.properties\");\r\n    generator.write(hints);\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"resources\": [\r\n        \t\t\t{\"glob\": \"com/example/test.properties\"},\r\n        \t\t\t{\"glob\": \"/\"},\r\n        \t\t\t{\"glob\": \"com\"},\r\n        \t\t\t{\"glob\": \"com/example\"},\r\n        \t\t\t{\"glob\": \"com/example/another.properties\"}\r\n        \t]\r\n        }\"\"\");\r\n}\n@Test\r\nvoid namespace() {\r\n    String groupId = \"foo.bar\";\r\n    String artifactId = \"baz\";\r\n    String filename = \"reachability-metadata.json\";\r\n    FileNativeConfigurationWriter generator = new FileNativeConfigurationWriter(tempDir, groupId, artifactId);\r\n    RuntimeHints hints = new RuntimeHints();\r\n    ResourceHints resourceHints = hints.resources();\r\n    resourceHints.registerPattern(\"com/example/test.properties\");\r\n    generator.write(hints);\r\n    Path jsonFile = tempDir.resolve(\"META-INF\").resolve(\"native-image\").resolve(groupId).resolve(artifactId).resolve(filename);\r\n    assertThat(jsonFile.toFile()).exists();\r\n}\nprivate void assertEquals(String expectedString) throws IOException, JSONException {\r\n    Path jsonFile = tempDir.resolve(\"META-INF\").resolve(\"native-image\").resolve(\"reachability-metadata.json\");\r\n    String content = Files.readString(jsonFile);\r\n    JSONAssert.assertEquals(expectedString, content, JSONCompareMode.NON_EXTENSIBLE);\r\n}",
    "comment": "\n * Tests for {@link FileNativeConfigurationWriter}.\n *\n * @author Sebastien Deleuze\n * @author Janne Valkealahti\n * @author Sam Brannen\n "
  },
  {
    "entityId": "org.springframework.aot.nativex.FileNativeConfigurationWriterTests#emptyConfig()",
    "entityType": "method",
    "code": "@Test\r\nvoid emptyConfig() {\r\n    Path empty = tempDir.resolve(\"empty\");\r\n    FileNativeConfigurationWriter generator = new FileNativeConfigurationWriter(empty);\r\n    generator.write(new RuntimeHints());\r\n    assertThat(empty.toFile().listFiles()).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.FileNativeConfigurationWriterTests#serializationConfig()",
    "entityType": "method",
    "code": "@Test\r\nvoid serializationConfig() throws IOException, JSONException {\r\n    FileNativeConfigurationWriter generator = new FileNativeConfigurationWriter(tempDir);\r\n    RuntimeHints hints = new RuntimeHints();\r\n    SerializationHints serializationHints = hints.serialization();\r\n    serializationHints.registerType(Integer.class);\r\n    serializationHints.registerType(Long.class);\r\n    generator.write(hints);\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"serialization\": [\r\n        \t\t{ \"type\": \"java.lang.Integer\" },\r\n        \t\t{ \"type\": \"java.lang.Long\" }\r\n        \t]\r\n        }\r\n        \"\"\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.FileNativeConfigurationWriterTests#proxyConfig()",
    "entityType": "method",
    "code": "@Test\r\nvoid proxyConfig() throws IOException, JSONException {\r\n    FileNativeConfigurationWriter generator = new FileNativeConfigurationWriter(tempDir);\r\n    RuntimeHints hints = new RuntimeHints();\r\n    ProxyHints proxyHints = hints.proxies();\r\n    proxyHints.registerJdkProxy(Function.class);\r\n    proxyHints.registerJdkProxy(Function.class, Consumer.class);\r\n    generator.write(hints);\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"reflection\": [\r\n        \t\t{ type: {\"proxy\": [ \"java.util.function.Function\" ] } },\r\n        \t\t{ type: {\"proxy\": [ \"java.util.function.Function\", \"java.util.function.Consumer\" ] } }\r\n        \t]\r\n        }\r\n        \"\"\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.FileNativeConfigurationWriterTests#reflectionConfig()",
    "entityType": "method",
    "code": "@Test\r\nvoid reflectionConfig() throws IOException, JSONException {\r\n    FileNativeConfigurationWriter generator = new FileNativeConfigurationWriter(tempDir);\r\n    RuntimeHints hints = new RuntimeHints();\r\n    ReflectionHints reflectionHints = hints.reflection();\r\n    reflectionHints.registerType(StringDecoder.class, builder -> builder.onReachableType(String.class).withMembers(MemberCategory.ACCESS_PUBLIC_FIELDS, MemberCategory.ACCESS_DECLARED_FIELDS, MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_PUBLIC_METHODS, MemberCategory.INVOKE_DECLARED_METHODS).withField(\"DEFAULT_CHARSET\").withField(\"defaultCharset\").withMethod(\"setDefaultCharset\", TypeReference.listOf(Charset.class), ExecutableMode.INVOKE));\r\n    generator.write(hints);\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"reflection\": [\r\n        \t\t{\r\n        \t\t\t\"type\": \"org.springframework.core.codec.StringDecoder\",\r\n        \t\t\t\"condition\": { \"typeReached\": \"java.lang.String\" },\r\n        \t\t\t\"allPublicFields\": true,\r\n        \t\t\t\"allDeclaredFields\": true,\r\n        \t\t\t\"allPublicConstructors\": true,\r\n        \t\t\t\"allDeclaredConstructors\": true,\r\n        \t\t\t\"allPublicMethods\": true,\r\n        \t\t\t\"allDeclaredMethods\": true,\r\n        \t\t\t\"fields\": [\r\n        \t\t\t\t{ \"name\": \"DEFAULT_CHARSET\" },\r\n        \t\t\t\t{ \"name\": \"defaultCharset\" }\r\n        \t\t\t],\r\n        \t\t\t\"methods\": [\r\n        \t\t\t\t{ \"name\": \"setDefaultCharset\", \"parameterTypes\": [ \"java.nio.charset.Charset\" ] }\r\n        \t\t\t]\r\n        \t\t}\r\n        \t]\r\n        }\r\n        \"\"\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.FileNativeConfigurationWriterTests#jniConfig()",
    "entityType": "method",
    "code": "@Test\r\nvoid jniConfig() throws IOException, JSONException {\r\n    // same format as reflection so just test basic file generation\r\n    FileNativeConfigurationWriter generator = new FileNativeConfigurationWriter(tempDir);\r\n    RuntimeHints hints = new RuntimeHints();\r\n    ReflectionHints jniHints = hints.jni();\r\n    jniHints.registerType(StringDecoder.class, builder -> builder.onReachableType(String.class));\r\n    generator.write(hints);\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"jni\": [\r\n        \t\t{\r\n        \t\t\t\"type\": \"org.springframework.core.codec.StringDecoder\",\r\n        \t\t\t\"condition\": { \"typeReached\": \"java.lang.String\" }\r\n        \t\t}\r\n        \t]\r\n        }\"\"\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.FileNativeConfigurationWriterTests#resourceConfig()",
    "entityType": "method",
    "code": "@Test\r\nvoid resourceConfig() throws IOException, JSONException {\r\n    FileNativeConfigurationWriter generator = new FileNativeConfigurationWriter(tempDir);\r\n    RuntimeHints hints = new RuntimeHints();\r\n    ResourceHints resourceHints = hints.resources();\r\n    resourceHints.registerPattern(\"com/example/test.properties\");\r\n    resourceHints.registerPattern(\"com/example/another.properties\");\r\n    generator.write(hints);\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"resources\": [\r\n        \t\t\t{\"glob\": \"com/example/test.properties\"},\r\n        \t\t\t{\"glob\": \"/\"},\r\n        \t\t\t{\"glob\": \"com\"},\r\n        \t\t\t{\"glob\": \"com/example\"},\r\n        \t\t\t{\"glob\": \"com/example/another.properties\"}\r\n        \t]\r\n        }\"\"\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.FileNativeConfigurationWriterTests#namespace()",
    "entityType": "method",
    "code": "@Test\r\nvoid namespace() {\r\n    String groupId = \"foo.bar\";\r\n    String artifactId = \"baz\";\r\n    String filename = \"reachability-metadata.json\";\r\n    FileNativeConfigurationWriter generator = new FileNativeConfigurationWriter(tempDir, groupId, artifactId);\r\n    RuntimeHints hints = new RuntimeHints();\r\n    ResourceHints resourceHints = hints.resources();\r\n    resourceHints.registerPattern(\"com/example/test.properties\");\r\n    generator.write(hints);\r\n    Path jsonFile = tempDir.resolve(\"META-INF\").resolve(\"native-image\").resolve(groupId).resolve(artifactId).resolve(filename);\r\n    assertThat(jsonFile.toFile()).exists();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.FileNativeConfigurationWriterTests#assertEquals(String)",
    "entityType": "method",
    "code": "private void assertEquals(String expectedString) throws IOException, JSONException {\r\n    Path jsonFile = tempDir.resolve(\"META-INF\").resolve(\"native-image\").resolve(\"reachability-metadata.json\");\r\n    String content = Files.readString(jsonFile);\r\n    JSONAssert.assertEquals(expectedString, content, JSONCompareMode.NON_EXTENSIBLE);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.RuntimeHintsWriterTests",
    "entityType": "class",
    "code": "private static JsonSchema JSON_SCHEMA;\n@BeforeAll\r\nstatic void setupSchemaValidator() {\r\n    JsonSchemaFactory jsonSchemaFactory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V201909, builder -> builder.schemaMappers(schemaMappers -> schemaMappers.mapPrefix(\"https://www.graalvm.org/\", \"classpath:org/springframework/aot/nativex/\")));\r\n    SchemaValidatorsConfig config = SchemaValidatorsConfig.builder().build();\r\n    JSON_SCHEMA = jsonSchemaFactory.getSchema(SchemaLocation.of(\"https://www.graalvm.org/reachability-metadata-schema-v1.0.0.json\"), config);\r\n}\n@Nested\r\nclass ReflectionHintsTests {\r\n\r\n    @Test\r\n    void empty() throws JSONException {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        assertEquals(\"{}\", hints);\r\n    }\r\n\r\n    @Test\r\n    void one() throws JSONException {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        hints.reflection().registerType(StringDecoder.class, builder -> builder.onReachableType(String.class).withMembers(MemberCategory.ACCESS_PUBLIC_FIELDS, MemberCategory.ACCESS_DECLARED_FIELDS, MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_PUBLIC_METHODS, MemberCategory.INVOKE_DECLARED_METHODS, MemberCategory.UNSAFE_ALLOCATED).withField(\"DEFAULT_CHARSET\").withField(\"defaultCharset\").withField(\"aScore\").withMethod(\"setDefaultCharset\", List.of(TypeReference.of(Charset.class)), ExecutableMode.INVOKE));\r\n        assertEquals(\"\"\"\r\n            {\r\n            \t\"reflection\": [\r\n            \t\t{\r\n            \t\t\t\"type\": \"org.springframework.core.codec.StringDecoder\",\r\n            \t\t\t\"condition\": { \"typeReached\": \"java.lang.String\" },\r\n            \t\t\t\"allPublicFields\": true,\r\n            \t\t\t\"allDeclaredFields\": true,\r\n            \t\t\t\"allPublicConstructors\": true,\r\n            \t\t\t\"allDeclaredConstructors\": true,\r\n            \t\t\t\"allPublicMethods\": true,\r\n            \t\t\t\"allDeclaredMethods\": true,\r\n            \t\t\t\"unsafeAllocated\": true,\r\n            \t\t\t\"fields\": [\r\n            \t\t\t\t{ \"name\": \"aScore\" },\r\n            \t\t\t\t{ \"name\": \"DEFAULT_CHARSET\" },\r\n            \t\t\t\t{ \"name\": \"defaultCharset\" }\r\n            \t\t\t],\r\n            \t\t\t\"methods\": [\r\n            \t\t\t\t{ \"name\": \"setDefaultCharset\", \"parameterTypes\": [ \"java.nio.charset.Charset\" ] }\r\n            \t\t\t]\r\n            \t\t}\r\n            \t]\r\n            }\r\n            \"\"\", hints);\r\n    }\r\n\r\n    @Test\r\n    void two() throws JSONException {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        hints.reflection().registerType(Integer.class, builder -> {\r\n        });\r\n        hints.reflection().registerType(Long.class, builder -> {\r\n        });\r\n        assertEquals(\"\"\"\r\n            {\r\n            \t\"reflection\": [\r\n            \t\t{ \"type\": \"java.lang.Integer\" },\r\n            \t\t{ \"type\": \"java.lang.Long\" }\r\n            \t]\r\n            }\r\n            \"\"\", hints);\r\n    }\r\n\r\n    @Test\r\n    void methods() throws JSONException {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        hints.reflection().registerType(Integer.class, builder -> builder.withMethod(\"parseInt\", TypeReference.listOf(String.class), ExecutableMode.INVOKE));\r\n        assertEquals(\"\"\"\r\n            {\r\n            \t\"reflection\": [\r\n            \t\t{\r\n            \t\t\t\"type\": \"java.lang.Integer\",\r\n            \t\t\t\"methods\": [\r\n            \t\t\t\t{\r\n            \t\t\t\t\t\"name\": \"parseInt\",\r\n            \t\t\t\t\t\"parameterTypes\": [\"java.lang.String\"]\r\n            \t\t\t\t}\r\n            \t\t\t]\r\n            \t\t}\r\n            \t]\r\n            }\r\n            \"\"\", hints);\r\n    }\r\n\r\n    @Test\r\n    void methodWithInnerClassParameter() throws JSONException {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        hints.reflection().registerType(Integer.class, builder -> builder.withMethod(\"test\", TypeReference.listOf(InnerClass.class), ExecutableMode.INVOKE));\r\n        assertEquals(\"\"\"\r\n            {\r\n            \t\"reflection\": [\r\n            \t\t{\r\n            \t\t\t\"type\": \"java.lang.Integer\",\r\n            \t\t\t\"methods\": [\r\n            \t\t\t\t{\r\n            \t\t\t\t\t\"name\": \"test\",\r\n            \t\t\t\t\t\"parameterTypes\": [\"org.springframework.aot.nativex.RuntimeHintsWriterTests$InnerClass\"]\r\n            \t\t\t\t}\r\n            \t\t\t]\r\n            \t\t}\r\n            \t]\r\n            }\r\n            \"\"\", hints);\r\n    }\r\n\r\n    @Test\r\n    void methodAndQueriedMethods() throws JSONException {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        hints.reflection().registerType(Integer.class, builder -> builder.withMethod(\"parseInt\", TypeReference.listOf(String.class), ExecutableMode.INVOKE));\r\n        assertEquals(\"\"\"\r\n            {\r\n            \t\"reflection\": [\r\n            \t\t{\r\n            \t\t\t\"type\": \"java.lang.Integer\",\r\n            \t\t\t\"methods\": [\r\n            \t\t\t\t{\r\n            \t\t\t\t\t\"name\": \"parseInt\",\r\n            \t\t\t\t\t\"parameterTypes\": [\"java.lang.String\"]\r\n            \t\t\t\t}\r\n            \t\t\t]\r\n            \t\t}\r\n            \t]\r\n            }\r\n            \"\"\", hints);\r\n    }\r\n\r\n    @Test\r\n    void ignoreLambda() throws JSONException {\r\n        Runnable anonymousRunnable = () -> {\r\n        };\r\n        RuntimeHints hints = new RuntimeHints();\r\n        hints.reflection().registerType(anonymousRunnable.getClass());\r\n        assertEquals(\"{}\", hints);\r\n    }\r\n\r\n    @Test\r\n    void sortTypeHints() {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        hints.reflection().registerType(Integer.class, builder -> {\r\n        });\r\n        hints.reflection().registerType(Long.class, builder -> {\r\n        });\r\n        RuntimeHints hints2 = new RuntimeHints();\r\n        hints2.reflection().registerType(Long.class, builder -> {\r\n        });\r\n        hints2.reflection().registerType(Integer.class, builder -> {\r\n        });\r\n        assertThat(writeJson(hints)).isEqualTo(writeJson(hints2));\r\n    }\r\n\r\n    @Test\r\n    void sortFieldHints() {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        hints.reflection().registerType(Integer.class, builder -> {\r\n            builder.withField(\"first\");\r\n            builder.withField(\"second\");\r\n        });\r\n        RuntimeHints hints2 = new RuntimeHints();\r\n        hints2.reflection().registerType(Integer.class, builder -> {\r\n            builder.withField(\"second\");\r\n            builder.withField(\"first\");\r\n        });\r\n        assertThat(writeJson(hints)).isEqualTo(writeJson(hints2));\r\n    }\r\n\r\n    @Test\r\n    void sortConstructorHints() {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        hints.reflection().registerType(Integer.class, builder -> {\r\n            builder.withConstructor(List.of(TypeReference.of(String.class)), ExecutableMode.INVOKE);\r\n            builder.withConstructor(List.of(TypeReference.of(String.class), TypeReference.of(Integer.class)), ExecutableMode.INVOKE);\r\n        });\r\n        RuntimeHints hints2 = new RuntimeHints();\r\n        hints2.reflection().registerType(Integer.class, builder -> {\r\n            builder.withConstructor(List.of(TypeReference.of(String.class), TypeReference.of(Integer.class)), ExecutableMode.INVOKE);\r\n            builder.withConstructor(List.of(TypeReference.of(String.class)), ExecutableMode.INVOKE);\r\n        });\r\n        assertThat(writeJson(hints)).isEqualTo(writeJson(hints2));\r\n    }\r\n\r\n    @Test\r\n    void sortMethodHints() {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        hints.reflection().registerType(Integer.class, builder -> {\r\n            builder.withMethod(\"test\", Collections.emptyList(), ExecutableMode.INVOKE);\r\n            builder.withMethod(\"another\", Collections.emptyList(), ExecutableMode.INVOKE);\r\n        });\r\n        RuntimeHints hints2 = new RuntimeHints();\r\n        hints2.reflection().registerType(Integer.class, builder -> {\r\n            builder.withMethod(\"another\", Collections.emptyList(), ExecutableMode.INVOKE);\r\n            builder.withMethod(\"test\", Collections.emptyList(), ExecutableMode.INVOKE);\r\n        });\r\n        assertThat(writeJson(hints)).isEqualTo(writeJson(hints2));\r\n    }\r\n}\n@Nested\r\nclass JniHints {\r\n    // TODO\r\n}\n@Nested\r\nclass ResourceHintsTests {\r\n\r\n    @Test\r\n    void empty() throws JSONException {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        assertEquals(\"{}\", hints);\r\n    }\r\n\r\n    @Test\r\n    void registerExactMatch() throws JSONException {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        hints.resources().registerPattern(\"com/example/test.properties\");\r\n        hints.resources().registerPattern(\"com/example/another.properties\");\r\n        assertEquals(\"\"\"\r\n            {\r\n            \t\"resources\": [\r\n            \t\t{ \"glob\": \"/\" },\r\n            \t\t{ \"glob\": \"com\"},\r\n            \t\t{ \"glob\": \"com/example\"},\r\n            \t\t{ \"glob\": \"com/example/another.properties\"},\r\n            \t\t{ \"glob\": \"com/example/test.properties\"}\r\n            \t]\r\n            }\"\"\", hints);\r\n    }\r\n\r\n    @Test\r\n    void registerWildcardAtTheBeginningPattern() throws JSONException {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        hints.resources().registerPattern(\"*.properties\");\r\n        assertEquals(\"\"\"\r\n            {\r\n            \t\"resources\": [\r\n            \t\t{ \"glob\": \"*.properties\"},\r\n            \t\t{ \"glob\": \"/\"}\r\n            \t]\r\n            }\"\"\", hints);\r\n    }\r\n\r\n    @Test\r\n    void registerWildcardInTheMiddlePattern() throws JSONException {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        hints.resources().registerPattern(\"com/example/*.properties\");\r\n        assertEquals(\"\"\"\r\n            {\r\n            \t\"resources\": [\r\n            \t\t{ \"glob\": \"/\" },\r\n            \t\t{ \"glob\": \"com\"},\r\n            \t\t{ \"glob\": \"com/example\"},\r\n            \t\t{ \"glob\": \"com/example/*.properties\"}\r\n            \t]\r\n            }\"\"\", hints);\r\n    }\r\n\r\n    @Test\r\n    void registerWildcardAtTheEndPattern() throws JSONException {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        hints.resources().registerPattern(\"static/*\");\r\n        assertEquals(\"\"\"\r\n            {\r\n            \t\"resources\": [\r\n            \t\t{ \"glob\": \"/\" },\r\n            \t\t{ \"glob\": \"static\"},\r\n            \t\t{ \"glob\": \"static/*\"}\r\n            \t]\r\n            }\"\"\", hints);\r\n    }\r\n\r\n    @Test\r\n    void registerPatternWithIncludesAndExcludes() throws JSONException {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        hints.resources().registerPattern(hint -> hint.includes(\"com/example/*.properties\"));\r\n        hints.resources().registerPattern(hint -> hint.includes(\"org/other/*.properties\"));\r\n        assertEquals(\"\"\"\r\n            {\r\n            \t\"resources\": [\r\n            \t\t{ \"glob\": \"/\"},\r\n            \t\t{ \"glob\": \"com\"},\r\n            \t\t{ \"glob\": \"com/example\"},\r\n            \t\t{ \"glob\": \"com/example/*.properties\"},\r\n            \t\t{ \"glob\": \"org\"},\r\n            \t\t{ \"glob\": \"org/other\"},\r\n            \t\t{ \"glob\": \"org/other/*.properties\"}\r\n            \t]\r\n            }\"\"\", hints);\r\n    }\r\n\r\n    @Test\r\n    void registerWithReachableTypeCondition() throws JSONException {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        hints.resources().registerPattern(builder -> builder.includes(TypeReference.of(\"com.example.Test\"), \"com/example/test.properties\"));\r\n        assertEquals(\"\"\"\r\n            {\r\n            \t\"resources\": [\r\n            \t\t{ \"condition\": { \"typeReached\": \"com.example.Test\"}, \"glob\": \"/\"},\r\n            \t\t{ \"condition\": { \"typeReached\": \"com.example.Test\"}, \"glob\": \"com\"},\r\n            \t\t{ \"condition\": { \"typeReached\": \"com.example.Test\"}, \"glob\": \"com/example\"},\r\n            \t\t{ \"condition\": { \"typeReached\": \"com.example.Test\"}, \"glob\": \"com/example/test.properties\"}\r\n            \t]\r\n            }\"\"\", hints);\r\n    }\r\n\r\n    @Test\r\n    void registerType() throws JSONException {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        hints.resources().registerType(String.class);\r\n        assertEquals(\"\"\"\r\n            {\r\n            \t\"resources\": [\r\n            \t\t{ \"glob\": \"/\" },\r\n            \t\t{ \"glob\": \"java\" },\r\n            \t\t{ \"glob\": \"java/lang\" },\r\n            \t\t{ \"glob\": \"java/lang/String.class\" }\r\n            \t]\r\n            }\"\"\", hints);\r\n    }\r\n\r\n    @Test\r\n    void registerResourceBundle() throws JSONException {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        hints.resources().registerResourceBundle(\"com.example.message2\");\r\n        hints.resources().registerResourceBundle(\"com.example.message\");\r\n        assertEquals(\"\"\"\r\n            {\r\n            \t\"bundles\": [\r\n            \t\t{ \"name\": \"com.example.message\"},\r\n            \t\t{ \"name\": \"com.example.message2\"}\r\n            \t]\r\n            }\"\"\", hints);\r\n    }\r\n}\n@Nested\r\nclass SerializationHintsTests {\r\n\r\n    @Test\r\n    void shouldWriteEmptyHint() throws JSONException {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        assertEquals(\"{}\", hints);\r\n    }\r\n\r\n    @Test\r\n    void shouldWriteSingleHint() throws JSONException {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        hints.serialization().registerType(TypeReference.of(String.class));\r\n        assertEquals(\"\"\"\r\n            {\r\n            \t\"serialization\": [\r\n            \t\t{ \"type\": \"java.lang.String\" }\r\n            \t]\r\n            }\r\n            \"\"\", hints);\r\n    }\r\n\r\n    @Test\r\n    void shouldWriteMultipleHints() throws JSONException {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        hints.serialization().registerType(TypeReference.of(Environment.class)).registerType(TypeReference.of(String.class));\r\n        assertEquals(\"\"\"\r\n            {\r\n            \t\"serialization\": [\r\n            \t\t{ \"type\": \"java.lang.String\" },\r\n            \t\t{ \"type\": \"org.springframework.core.env.Environment\" }\r\n            \t]\r\n            }\r\n            \"\"\", hints);\r\n    }\r\n\r\n    @Test\r\n    void shouldWriteSingleHintWithCondition() throws JSONException {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        hints.serialization().registerType(TypeReference.of(String.class), builder -> builder.onReachableType(TypeReference.of(\"org.example.Test\")));\r\n        assertEquals(\"\"\"\r\n            {\r\n            \t\"serialization\": [\r\n            \t\t{ \"condition\": { \"typeReached\": \"org.example.Test\" }, \"type\": \"java.lang.String\" }\r\n            \t]\r\n            }\r\n            \"\"\", hints);\r\n    }\r\n}\n@Nested\r\nclass ProxyHintsTests {\r\n\r\n    @Test\r\n    void empty() throws JSONException {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        assertEquals(\"{}\", hints);\r\n    }\r\n\r\n    @Test\r\n    void shouldWriteOneEntry() throws JSONException {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        hints.proxies().registerJdkProxy(Function.class);\r\n        assertEquals(\"\"\"\r\n            {\r\n            \t\"reflection\": [\r\n            \t\t{\r\n            \t\t\t\"type\": {\r\n            \t\t\t\t\"proxy\": [\"java.util.function.Function\"]\r\n            \t\t\t}\r\n            \t\t}\r\n            \t]\r\n            }\r\n            \"\"\", hints);\r\n    }\r\n\r\n    @Test\r\n    void shouldWriteMultipleEntries() throws JSONException {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        hints.proxies().registerJdkProxy(Function.class).registerJdkProxy(Function.class, Consumer.class);\r\n        assertEquals(\"\"\"\r\n            {\r\n            \t\"reflection\": [\r\n            \t\t{\r\n            \t\t\t\"type\": { \"proxy\": [\"java.util.function.Function\"] }\r\n            \t\t},\r\n            \t\t{\r\n            \t\t\t\"type\": { \"proxy\": [\"java.util.function.Function\", \"java.util.function.Consumer\"] }\r\n            \t\t}\r\n            \t]\r\n            }\r\n            \"\"\", hints);\r\n    }\r\n\r\n    @Test\r\n    void shouldWriteEntriesInNaturalOrder() throws JSONException {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        hints.proxies().registerJdkProxy(Supplier.class).registerJdkProxy(Function.class);\r\n        assertEquals(\"\"\"\r\n            {\r\n            \t\"reflection\": [\r\n            \t\t{\r\n            \t\t\t\"type\": { \"proxy\": [\"java.util.function.Function\"] }\r\n            \t\t},\r\n            \t\t{\r\n            \t\t\t\"type\": { \"proxy\": [\"java.util.function.Supplier\"] }\r\n            \t\t}\r\n            \t]\r\n            }\r\n            \"\"\", hints);\r\n    }\r\n\r\n    @Test\r\n    void shouldWriteInnerClass() throws JSONException {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        hints.proxies().registerJdkProxy(InnerInterface.class);\r\n        assertEquals(\"\"\"\r\n            {\r\n            \t\"reflection\": [\r\n            \t\t{\r\n            \t\t\t\"type\": { \"proxy\": [\"org.springframework.aot.nativex.RuntimeHintsWriterTests$InnerInterface\"] }\r\n            \t\t}\r\n            \t]\r\n            }\r\n            \"\"\", hints);\r\n    }\r\n\r\n    @Test\r\n    void shouldWriteCondition() throws JSONException {\r\n        RuntimeHints hints = new RuntimeHints();\r\n        hints.proxies().registerJdkProxy(builder -> builder.proxiedInterfaces(Function.class).onReachableType(TypeReference.of(\"org.example.Test\")));\r\n        assertEquals(\"\"\"\r\n            {\r\n            \t\"reflection\": [\r\n            \t\t{\r\n            \t\t\t\"type\": { \"proxy\": [\"java.util.function.Function\"] },\r\n            \t\t\t\"condition\": { \"typeReached\": \"org.example.Test\" }\r\n            \t\t}\r\n            \t]\r\n            }\r\n            \"\"\", hints);\r\n    }\r\n}\nprivate void assertEquals(String expectedString, RuntimeHints hints) throws JSONException {\r\n    String json = writeJson(hints);\r\n    JSONAssert.assertEquals(expectedString, json, JSONCompareMode.LENIENT);\r\n    Set<ValidationMessage> validationMessages = JSON_SCHEMA.validate(json, InputFormat.JSON, executionContext -> executionContext.getExecutionConfig().setFormatAssertionsEnabled(true));\r\n    assertThat(validationMessages).isEmpty();\r\n}\nprivate String writeJson(RuntimeHints hints) {\r\n    StringWriter out = new StringWriter();\r\n    BasicJsonWriter writer = new BasicJsonWriter(out, \"\\t\");\r\n    new RuntimeHintsWriter().write(writer, hints);\r\n    return out.toString();\r\n}\nstatic class InnerClass {\r\n}\ninterface InnerInterface {\r\n}",
    "comment": "\n * Tests for {@link RuntimeHintsWriter}.\n *\n * @author Brian Clozel\n * @author Sebastien Deleuze\n * @author Stephane Nicoll\n "
  },
  {
    "entityId": "org.springframework.aot.nativex.RuntimeHintsWriterTests#setupSchemaValidator()",
    "entityType": "method",
    "code": "@BeforeAll\r\nstatic void setupSchemaValidator() {\r\n    JsonSchemaFactory jsonSchemaFactory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V201909, builder -> builder.schemaMappers(schemaMappers -> schemaMappers.mapPrefix(\"https://www.graalvm.org/\", \"classpath:org/springframework/aot/nativex/\")));\r\n    SchemaValidatorsConfig config = SchemaValidatorsConfig.builder().build();\r\n    JSON_SCHEMA = jsonSchemaFactory.getSchema(SchemaLocation.of(\"https://www.graalvm.org/reachability-metadata-schema-v1.0.0.json\"), config);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.RuntimeHintsWriterTests#assertEquals(String,RuntimeHints)",
    "entityType": "method",
    "code": "private void assertEquals(String expectedString, RuntimeHints hints) throws JSONException {\r\n    String json = writeJson(hints);\r\n    JSONAssert.assertEquals(expectedString, json, JSONCompareMode.LENIENT);\r\n    Set<ValidationMessage> validationMessages = JSON_SCHEMA.validate(json, InputFormat.JSON, executionContext -> executionContext.getExecutionConfig().setFormatAssertionsEnabled(true));\r\n    assertThat(validationMessages).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.RuntimeHintsWriterTests#writeJson(RuntimeHints)",
    "entityType": "method",
    "code": "private String writeJson(RuntimeHints hints) {\r\n    StringWriter out = new StringWriter();\r\n    BasicJsonWriter writer = new BasicJsonWriter(out, \"\\t\");\r\n    new RuntimeHintsWriter().write(writer, hints);\r\n    return out.toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ReflectionHintsTests",
    "entityType": "class",
    "code": "@Test\r\nvoid empty() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    assertEquals(\";\", hints);\r\n}\n@Test\r\nvoid one() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.reflection().registerType(StringDecoder.class, builder -> builder.onReachableType(String.class).withMembers(MemberCategory.ACCESS_PUBLIC_FIELDS, MemberCategory.ACCESS_DECLARED_FIELDS, MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_PUBLIC_METHODS, MemberCategory.INVOKE_DECLARED_METHODS, MemberCategory.UNSAFE_ALLOCATED).withField(\"DEFAULT_CHARSET\").withField(\"defaultCharset\").withField(\"aScore\").withMethod(\"setDefaultCharset\", List.of(TypeReference.of(Charset.class)), ExecutableMode.INVOKE));\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"reflection\": [\r\n        \t\t{\r\n        \t\t\t\"type\": \"org.springframework.core.codec.StringDecoder\",\r\n        \t\t\t\"condition\": { \"typeReached\": \"java.lang.String\" },\r\n        \t\t\t\"allPublicFields\": true,\r\n        \t\t\t\"allDeclaredFields\": true,\r\n        \t\t\t\"allPublicConstructors\": true,\r\n        \t\t\t\"allDeclaredConstructors\": true,\r\n        \t\t\t\"allPublicMethods\": true,\r\n        \t\t\t\"allDeclaredMethods\": true,\r\n        \t\t\t\"unsafeAllocated\": true,\r\n        \t\t\t\"fields\": [\r\n        \t\t\t\t{ \"name\": \"aScore\" },\r\n        \t\t\t\t{ \"name\": \"DEFAULT_CHARSET\" },\r\n        \t\t\t\t{ \"name\": \"defaultCharset\" }\r\n        \t\t\t],\r\n        \t\t\t\"methods\": [\r\n        \t\t\t\t{ \"name\": \"setDefaultCharset\", \"parameterTypes\": [ \"java.nio.charset.Charset\" ] }\r\n        \t\t\t]\r\n        \t\t}\r\n        \t]\r\n        }\r\n        \"\"\", hints);\r\n}\n@Test\r\nvoid two() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.reflection().registerType(Integer.class, builder -> ;);\r\n    hints.reflection().registerType(Long.class, builder -> ;);\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"reflection\": [\r\n        \t\t{ \"type\": \"java.lang.Integer\" },\r\n        \t\t{ \"type\": \"java.lang.Long\" }\r\n        \t]\r\n        }\r\n        \"\"\", hints);\r\n}\n@Test\r\nvoid methods() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.reflection().registerType(Integer.class, builder -> builder.withMethod(\"parseInt\", TypeReference.listOf(String.class), ExecutableMode.INVOKE));\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"reflection\": [\r\n        \t\t{\r\n        \t\t\t\"type\": \"java.lang.Integer\",\r\n        \t\t\t\"methods\": [\r\n        \t\t\t\t{\r\n        \t\t\t\t\t\"name\": \"parseInt\",\r\n        \t\t\t\t\t\"parameterTypes\": [\"java.lang.String\"]\r\n        \t\t\t\t}\r\n        \t\t\t]\r\n        \t\t}\r\n        \t]\r\n        }\r\n        \"\"\", hints);\r\n}\n@Test\r\nvoid methodWithInnerClassParameter() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.reflection().registerType(Integer.class, builder -> builder.withMethod(\"test\", TypeReference.listOf(InnerClass.class), ExecutableMode.INVOKE));\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"reflection\": [\r\n        \t\t{\r\n        \t\t\t\"type\": \"java.lang.Integer\",\r\n        \t\t\t\"methods\": [\r\n        \t\t\t\t{\r\n        \t\t\t\t\t\"name\": \"test\",\r\n        \t\t\t\t\t\"parameterTypes\": [\"org.springframework.aot.nativex.RuntimeHintsWriterTests$InnerClass\"]\r\n        \t\t\t\t}\r\n        \t\t\t]\r\n        \t\t}\r\n        \t]\r\n        }\r\n        \"\"\", hints);\r\n}\n@Test\r\nvoid methodAndQueriedMethods() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.reflection().registerType(Integer.class, builder -> builder.withMethod(\"parseInt\", TypeReference.listOf(String.class), ExecutableMode.INVOKE));\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"reflection\": [\r\n        \t\t{\r\n        \t\t\t\"type\": \"java.lang.Integer\",\r\n        \t\t\t\"methods\": [\r\n        \t\t\t\t{\r\n        \t\t\t\t\t\"name\": \"parseInt\",\r\n        \t\t\t\t\t\"parameterTypes\": [\"java.lang.String\"]\r\n        \t\t\t\t}\r\n        \t\t\t]\r\n        \t\t}\r\n        \t]\r\n        }\r\n        \"\"\", hints);\r\n}\n@Test\r\nvoid ignoreLambda() throws JSONException {\r\n    Runnable anonymousRunnable = () -> ;;\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.reflection().registerType(anonymousRunnable.getClass());\r\n    assertEquals(\";\", hints);\r\n}\n@Test\r\nvoid sortTypeHints() {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.reflection().registerType(Integer.class, builder -> ;);\r\n    hints.reflection().registerType(Long.class, builder -> ;);\r\n    RuntimeHints hints2 = new RuntimeHints();\r\n    hints2.reflection().registerType(Long.class, builder -> ;);\r\n    hints2.reflection().registerType(Integer.class, builder -> ;);\r\n    assertThat(writeJson(hints)).isEqualTo(writeJson(hints2));\r\n}\n@Test\r\nvoid sortFieldHints() {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.reflection().registerType(Integer.class, builder -> {\r\n        builder.withField(\"first\");\r\n        builder.withField(\"second\");\r\n    });\r\n    RuntimeHints hints2 = new RuntimeHints();\r\n    hints2.reflection().registerType(Integer.class, builder -> {\r\n        builder.withField(\"second\");\r\n        builder.withField(\"first\");\r\n    });\r\n    assertThat(writeJson(hints)).isEqualTo(writeJson(hints2));\r\n}\n@Test\r\nvoid sortConstructorHints() {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.reflection().registerType(Integer.class, builder -> {\r\n        builder.withConstructor(List.of(TypeReference.of(String.class)), ExecutableMode.INVOKE);\r\n        builder.withConstructor(List.of(TypeReference.of(String.class), TypeReference.of(Integer.class)), ExecutableMode.INVOKE);\r\n    });\r\n    RuntimeHints hints2 = new RuntimeHints();\r\n    hints2.reflection().registerType(Integer.class, builder -> {\r\n        builder.withConstructor(List.of(TypeReference.of(String.class), TypeReference.of(Integer.class)), ExecutableMode.INVOKE);\r\n        builder.withConstructor(List.of(TypeReference.of(String.class)), ExecutableMode.INVOKE);\r\n    });\r\n    assertThat(writeJson(hints)).isEqualTo(writeJson(hints2));\r\n}\n@Test\r\nvoid sortMethodHints() {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.reflection().registerType(Integer.class, builder -> {\r\n        builder.withMethod(\"test\", Collections.emptyList(), ExecutableMode.INVOKE);\r\n        builder.withMethod(\"another\", Collections.emptyList(), ExecutableMode.INVOKE);\r\n    });\r\n    RuntimeHints hints2 = new RuntimeHints();\r\n    hints2.reflection().registerType(Integer.class, builder -> {\r\n        builder.withMethod(\"another\", Collections.emptyList(), ExecutableMode.INVOKE);\r\n        builder.withMethod(\"test\", Collections.emptyList(), ExecutableMode.INVOKE);\r\n    });\r\n    assertThat(writeJson(hints)).isEqualTo(writeJson(hints2));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ReflectionHintsTests#empty()",
    "entityType": "method",
    "code": "@Test\r\nvoid empty() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    assertEquals(\";\", hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ReflectionHintsTests#one()",
    "entityType": "method",
    "code": "@Test\r\nvoid one() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.reflection().registerType(StringDecoder.class, builder -> builder.onReachableType(String.class).withMembers(MemberCategory.ACCESS_PUBLIC_FIELDS, MemberCategory.ACCESS_DECLARED_FIELDS, MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_PUBLIC_METHODS, MemberCategory.INVOKE_DECLARED_METHODS, MemberCategory.UNSAFE_ALLOCATED).withField(\"DEFAULT_CHARSET\").withField(\"defaultCharset\").withField(\"aScore\").withMethod(\"setDefaultCharset\", List.of(TypeReference.of(Charset.class)), ExecutableMode.INVOKE));\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"reflection\": [\r\n        \t\t{\r\n        \t\t\t\"type\": \"org.springframework.core.codec.StringDecoder\",\r\n        \t\t\t\"condition\": { \"typeReached\": \"java.lang.String\" },\r\n        \t\t\t\"allPublicFields\": true,\r\n        \t\t\t\"allDeclaredFields\": true,\r\n        \t\t\t\"allPublicConstructors\": true,\r\n        \t\t\t\"allDeclaredConstructors\": true,\r\n        \t\t\t\"allPublicMethods\": true,\r\n        \t\t\t\"allDeclaredMethods\": true,\r\n        \t\t\t\"unsafeAllocated\": true,\r\n        \t\t\t\"fields\": [\r\n        \t\t\t\t{ \"name\": \"aScore\" },\r\n        \t\t\t\t{ \"name\": \"DEFAULT_CHARSET\" },\r\n        \t\t\t\t{ \"name\": \"defaultCharset\" }\r\n        \t\t\t],\r\n        \t\t\t\"methods\": [\r\n        \t\t\t\t{ \"name\": \"setDefaultCharset\", \"parameterTypes\": [ \"java.nio.charset.Charset\" ] }\r\n        \t\t\t]\r\n        \t\t}\r\n        \t]\r\n        }\r\n        \"\"\", hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ReflectionHintsTests#two()",
    "entityType": "method",
    "code": "@Test\r\nvoid two() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.reflection().registerType(Integer.class, builder -> ;);\r\n    hints.reflection().registerType(Long.class, builder -> ;);\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"reflection\": [\r\n        \t\t{ \"type\": \"java.lang.Integer\" },\r\n        \t\t{ \"type\": \"java.lang.Long\" }\r\n        \t]\r\n        }\r\n        \"\"\", hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ReflectionHintsTests#methods()",
    "entityType": "method",
    "code": "@Test\r\nvoid methods() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.reflection().registerType(Integer.class, builder -> builder.withMethod(\"parseInt\", TypeReference.listOf(String.class), ExecutableMode.INVOKE));\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"reflection\": [\r\n        \t\t{\r\n        \t\t\t\"type\": \"java.lang.Integer\",\r\n        \t\t\t\"methods\": [\r\n        \t\t\t\t{\r\n        \t\t\t\t\t\"name\": \"parseInt\",\r\n        \t\t\t\t\t\"parameterTypes\": [\"java.lang.String\"]\r\n        \t\t\t\t}\r\n        \t\t\t]\r\n        \t\t}\r\n        \t]\r\n        }\r\n        \"\"\", hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ReflectionHintsTests#methodWithInnerClassParameter()",
    "entityType": "method",
    "code": "@Test\r\nvoid methodWithInnerClassParameter() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.reflection().registerType(Integer.class, builder -> builder.withMethod(\"test\", TypeReference.listOf(InnerClass.class), ExecutableMode.INVOKE));\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"reflection\": [\r\n        \t\t{\r\n        \t\t\t\"type\": \"java.lang.Integer\",\r\n        \t\t\t\"methods\": [\r\n        \t\t\t\t{\r\n        \t\t\t\t\t\"name\": \"test\",\r\n        \t\t\t\t\t\"parameterTypes\": [\"org.springframework.aot.nativex.RuntimeHintsWriterTests$InnerClass\"]\r\n        \t\t\t\t}\r\n        \t\t\t]\r\n        \t\t}\r\n        \t]\r\n        }\r\n        \"\"\", hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ReflectionHintsTests#methodAndQueriedMethods()",
    "entityType": "method",
    "code": "@Test\r\nvoid methodAndQueriedMethods() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.reflection().registerType(Integer.class, builder -> builder.withMethod(\"parseInt\", TypeReference.listOf(String.class), ExecutableMode.INVOKE));\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"reflection\": [\r\n        \t\t{\r\n        \t\t\t\"type\": \"java.lang.Integer\",\r\n        \t\t\t\"methods\": [\r\n        \t\t\t\t{\r\n        \t\t\t\t\t\"name\": \"parseInt\",\r\n        \t\t\t\t\t\"parameterTypes\": [\"java.lang.String\"]\r\n        \t\t\t\t}\r\n        \t\t\t]\r\n        \t\t}\r\n        \t]\r\n        }\r\n        \"\"\", hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ReflectionHintsTests#ignoreLambda()",
    "entityType": "method",
    "code": "@Test\r\nvoid ignoreLambda() throws JSONException {\r\n    Runnable anonymousRunnable = () -> ;;\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.reflection().registerType(anonymousRunnable.getClass());\r\n    assertEquals(\";\", hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ReflectionHintsTests#sortTypeHints()",
    "entityType": "method",
    "code": "@Test\r\nvoid sortTypeHints() {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.reflection().registerType(Integer.class, builder -> ;);\r\n    hints.reflection().registerType(Long.class, builder -> ;);\r\n    RuntimeHints hints2 = new RuntimeHints();\r\n    hints2.reflection().registerType(Long.class, builder -> ;);\r\n    hints2.reflection().registerType(Integer.class, builder -> ;);\r\n    assertThat(writeJson(hints)).isEqualTo(writeJson(hints2));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ReflectionHintsTests#sortFieldHints()",
    "entityType": "method",
    "code": "@Test\r\nvoid sortFieldHints() {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.reflection().registerType(Integer.class, builder -> {\r\n        builder.withField(\"first\");\r\n        builder.withField(\"second\");\r\n    });\r\n    RuntimeHints hints2 = new RuntimeHints();\r\n    hints2.reflection().registerType(Integer.class, builder -> {\r\n        builder.withField(\"second\");\r\n        builder.withField(\"first\");\r\n    });\r\n    assertThat(writeJson(hints)).isEqualTo(writeJson(hints2));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ReflectionHintsTests#sortConstructorHints()",
    "entityType": "method",
    "code": "@Test\r\nvoid sortConstructorHints() {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.reflection().registerType(Integer.class, builder -> {\r\n        builder.withConstructor(List.of(TypeReference.of(String.class)), ExecutableMode.INVOKE);\r\n        builder.withConstructor(List.of(TypeReference.of(String.class), TypeReference.of(Integer.class)), ExecutableMode.INVOKE);\r\n    });\r\n    RuntimeHints hints2 = new RuntimeHints();\r\n    hints2.reflection().registerType(Integer.class, builder -> {\r\n        builder.withConstructor(List.of(TypeReference.of(String.class), TypeReference.of(Integer.class)), ExecutableMode.INVOKE);\r\n        builder.withConstructor(List.of(TypeReference.of(String.class)), ExecutableMode.INVOKE);\r\n    });\r\n    assertThat(writeJson(hints)).isEqualTo(writeJson(hints2));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ReflectionHintsTests#sortMethodHints()",
    "entityType": "method",
    "code": "@Test\r\nvoid sortMethodHints() {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.reflection().registerType(Integer.class, builder -> {\r\n        builder.withMethod(\"test\", Collections.emptyList(), ExecutableMode.INVOKE);\r\n        builder.withMethod(\"another\", Collections.emptyList(), ExecutableMode.INVOKE);\r\n    });\r\n    RuntimeHints hints2 = new RuntimeHints();\r\n    hints2.reflection().registerType(Integer.class, builder -> {\r\n        builder.withMethod(\"another\", Collections.emptyList(), ExecutableMode.INVOKE);\r\n        builder.withMethod(\"test\", Collections.emptyList(), ExecutableMode.INVOKE);\r\n    });\r\n    assertThat(writeJson(hints)).isEqualTo(writeJson(hints2));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.JniHints",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ResourceHintsTests",
    "entityType": "class",
    "code": "@Test\r\nvoid empty() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    assertEquals(\";\", hints);\r\n}\n@Test\r\nvoid registerExactMatch() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.resources().registerPattern(\"com/example/test.properties\");\r\n    hints.resources().registerPattern(\"com/example/another.properties\");\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"resources\": [\r\n        \t\t{ \"glob\": \"/\" },\r\n        \t\t{ \"glob\": \"com\"},\r\n        \t\t{ \"glob\": \"com/example\"},\r\n        \t\t{ \"glob\": \"com/example/another.properties\"},\r\n        \t\t{ \"glob\": \"com/example/test.properties\"}\r\n        \t]\r\n        }\"\"\", hints);\r\n}\n@Test\r\nvoid registerWildcardAtTheBeginningPattern() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.resources().registerPattern(\"*.properties\");\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"resources\": [\r\n        \t\t{ \"glob\": \"*.properties\"},\r\n        \t\t{ \"glob\": \"/\"}\r\n        \t]\r\n        }\"\"\", hints);\r\n}\n@Test\r\nvoid registerWildcardInTheMiddlePattern() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.resources().registerPattern(\"com/example/*.properties\");\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"resources\": [\r\n        \t\t{ \"glob\": \"/\" },\r\n        \t\t{ \"glob\": \"com\"},\r\n        \t\t{ \"glob\": \"com/example\"},\r\n        \t\t{ \"glob\": \"com/example/*.properties\"}\r\n        \t]\r\n        }\"\"\", hints);\r\n}\n@Test\r\nvoid registerWildcardAtTheEndPattern() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.resources().registerPattern(\"static/*\");\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"resources\": [\r\n        \t\t{ \"glob\": \"/\" },\r\n        \t\t{ \"glob\": \"static\"},\r\n        \t\t{ \"glob\": \"static/*\"}\r\n        \t]\r\n        }\"\"\", hints);\r\n}\n@Test\r\nvoid registerPatternWithIncludesAndExcludes() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.resources().registerPattern(hint -> hint.includes(\"com/example/*.properties\"));\r\n    hints.resources().registerPattern(hint -> hint.includes(\"org/other/*.properties\"));\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"resources\": [\r\n        \t\t{ \"glob\": \"/\"},\r\n        \t\t{ \"glob\": \"com\"},\r\n        \t\t{ \"glob\": \"com/example\"},\r\n        \t\t{ \"glob\": \"com/example/*.properties\"},\r\n        \t\t{ \"glob\": \"org\"},\r\n        \t\t{ \"glob\": \"org/other\"},\r\n        \t\t{ \"glob\": \"org/other/*.properties\"}\r\n        \t]\r\n        }\"\"\", hints);\r\n}\n@Test\r\nvoid registerWithReachableTypeCondition() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.resources().registerPattern(builder -> builder.includes(TypeReference.of(\"com.example.Test\"), \"com/example/test.properties\"));\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"resources\": [\r\n        \t\t{ \"condition\": { \"typeReached\": \"com.example.Test\"}, \"glob\": \"/\"},\r\n        \t\t{ \"condition\": { \"typeReached\": \"com.example.Test\"}, \"glob\": \"com\"},\r\n        \t\t{ \"condition\": { \"typeReached\": \"com.example.Test\"}, \"glob\": \"com/example\"},\r\n        \t\t{ \"condition\": { \"typeReached\": \"com.example.Test\"}, \"glob\": \"com/example/test.properties\"}\r\n        \t]\r\n        }\"\"\", hints);\r\n}\n@Test\r\nvoid registerType() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.resources().registerType(String.class);\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"resources\": [\r\n        \t\t{ \"glob\": \"/\" },\r\n        \t\t{ \"glob\": \"java\" },\r\n        \t\t{ \"glob\": \"java/lang\" },\r\n        \t\t{ \"glob\": \"java/lang/String.class\" }\r\n        \t]\r\n        }\"\"\", hints);\r\n}\n@Test\r\nvoid registerResourceBundle() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.resources().registerResourceBundle(\"com.example.message2\");\r\n    hints.resources().registerResourceBundle(\"com.example.message\");\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"bundles\": [\r\n        \t\t{ \"name\": \"com.example.message\"},\r\n        \t\t{ \"name\": \"com.example.message2\"}\r\n        \t]\r\n        }\"\"\", hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ResourceHintsTests#empty()",
    "entityType": "method",
    "code": "@Test\r\nvoid empty() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    assertEquals(\";\", hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ResourceHintsTests#registerExactMatch()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerExactMatch() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.resources().registerPattern(\"com/example/test.properties\");\r\n    hints.resources().registerPattern(\"com/example/another.properties\");\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"resources\": [\r\n        \t\t{ \"glob\": \"/\" },\r\n        \t\t{ \"glob\": \"com\"},\r\n        \t\t{ \"glob\": \"com/example\"},\r\n        \t\t{ \"glob\": \"com/example/another.properties\"},\r\n        \t\t{ \"glob\": \"com/example/test.properties\"}\r\n        \t]\r\n        }\"\"\", hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ResourceHintsTests#registerWildcardAtTheBeginningPattern()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerWildcardAtTheBeginningPattern() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.resources().registerPattern(\"*.properties\");\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"resources\": [\r\n        \t\t{ \"glob\": \"*.properties\"},\r\n        \t\t{ \"glob\": \"/\"}\r\n        \t]\r\n        }\"\"\", hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ResourceHintsTests#registerWildcardInTheMiddlePattern()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerWildcardInTheMiddlePattern() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.resources().registerPattern(\"com/example/*.properties\");\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"resources\": [\r\n        \t\t{ \"glob\": \"/\" },\r\n        \t\t{ \"glob\": \"com\"},\r\n        \t\t{ \"glob\": \"com/example\"},\r\n        \t\t{ \"glob\": \"com/example/*.properties\"}\r\n        \t]\r\n        }\"\"\", hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ResourceHintsTests#registerWildcardAtTheEndPattern()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerWildcardAtTheEndPattern() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.resources().registerPattern(\"static/*\");\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"resources\": [\r\n        \t\t{ \"glob\": \"/\" },\r\n        \t\t{ \"glob\": \"static\"},\r\n        \t\t{ \"glob\": \"static/*\"}\r\n        \t]\r\n        }\"\"\", hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ResourceHintsTests#registerPatternWithIncludesAndExcludes()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerPatternWithIncludesAndExcludes() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.resources().registerPattern(hint -> hint.includes(\"com/example/*.properties\"));\r\n    hints.resources().registerPattern(hint -> hint.includes(\"org/other/*.properties\"));\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"resources\": [\r\n        \t\t{ \"glob\": \"/\"},\r\n        \t\t{ \"glob\": \"com\"},\r\n        \t\t{ \"glob\": \"com/example\"},\r\n        \t\t{ \"glob\": \"com/example/*.properties\"},\r\n        \t\t{ \"glob\": \"org\"},\r\n        \t\t{ \"glob\": \"org/other\"},\r\n        \t\t{ \"glob\": \"org/other/*.properties\"}\r\n        \t]\r\n        }\"\"\", hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ResourceHintsTests#registerWithReachableTypeCondition()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerWithReachableTypeCondition() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.resources().registerPattern(builder -> builder.includes(TypeReference.of(\"com.example.Test\"), \"com/example/test.properties\"));\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"resources\": [\r\n        \t\t{ \"condition\": { \"typeReached\": \"com.example.Test\"}, \"glob\": \"/\"},\r\n        \t\t{ \"condition\": { \"typeReached\": \"com.example.Test\"}, \"glob\": \"com\"},\r\n        \t\t{ \"condition\": { \"typeReached\": \"com.example.Test\"}, \"glob\": \"com/example\"},\r\n        \t\t{ \"condition\": { \"typeReached\": \"com.example.Test\"}, \"glob\": \"com/example/test.properties\"}\r\n        \t]\r\n        }\"\"\", hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ResourceHintsTests#registerType()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerType() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.resources().registerType(String.class);\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"resources\": [\r\n        \t\t{ \"glob\": \"/\" },\r\n        \t\t{ \"glob\": \"java\" },\r\n        \t\t{ \"glob\": \"java/lang\" },\r\n        \t\t{ \"glob\": \"java/lang/String.class\" }\r\n        \t]\r\n        }\"\"\", hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ResourceHintsTests#registerResourceBundle()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerResourceBundle() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.resources().registerResourceBundle(\"com.example.message2\");\r\n    hints.resources().registerResourceBundle(\"com.example.message\");\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"bundles\": [\r\n        \t\t{ \"name\": \"com.example.message\"},\r\n        \t\t{ \"name\": \"com.example.message2\"}\r\n        \t]\r\n        }\"\"\", hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.SerializationHintsTests",
    "entityType": "class",
    "code": "@Test\r\nvoid shouldWriteEmptyHint() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    assertEquals(\";\", hints);\r\n}\n@Test\r\nvoid shouldWriteSingleHint() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.serialization().registerType(TypeReference.of(String.class));\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"serialization\": [\r\n        \t\t{ \"type\": \"java.lang.String\" }\r\n        \t]\r\n        }\r\n        \"\"\", hints);\r\n}\n@Test\r\nvoid shouldWriteMultipleHints() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.serialization().registerType(TypeReference.of(Environment.class)).registerType(TypeReference.of(String.class));\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"serialization\": [\r\n        \t\t{ \"type\": \"java.lang.String\" },\r\n        \t\t{ \"type\": \"org.springframework.core.env.Environment\" }\r\n        \t]\r\n        }\r\n        \"\"\", hints);\r\n}\n@Test\r\nvoid shouldWriteSingleHintWithCondition() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.serialization().registerType(TypeReference.of(String.class), builder -> builder.onReachableType(TypeReference.of(\"org.example.Test\")));\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"serialization\": [\r\n        \t\t{ \"condition\": { \"typeReached\": \"org.example.Test\" }, \"type\": \"java.lang.String\" }\r\n        \t]\r\n        }\r\n        \"\"\", hints);\r\n}",
    "comment": ""
  }
]