[
  {
    "entityId": "org.springframework.cglib.beans.BeanGenerator#setSuperclass(Class)",
    "entityType": "method",
    "code": "/**\r\n * Set the class which the generated class will extend. The class\r\n * must not be declared as final, and must have a non-private\r\n * no-argument constructor.\r\n * @param superclass class to extend, or null to extend Object\r\n */\r\npublic void setSuperclass(Class superclass) {\r\n    if (superclass != null && superclass.equals(Object.class)) {\r\n        superclass = null;\r\n    }\r\n    this.superclass = superclass;\r\n    // SPRING PATCH BEGIN\r\n    setContextClass(superclass);\r\n    // SPRING PATCH END\r\n}",
    "comment": "\n\t * Set the class which the generated class will extend. The class\n\t * must not be declared as final, and must have a non-private\n\t * no-argument constructor.\n\t * @param superclass class to extend, or null to extend Object\n\t "
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanGenerator#addProperty(String,Class)",
    "entityType": "method",
    "code": "public void addProperty(String name, Class type) {\r\n    if (props.containsKey(name)) {\r\n        throw new IllegalArgumentException(\"Duplicate property name \\\"\" + name + \"\\\"\");\r\n    }\r\n    props.put(name, Type.getType(type));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanGenerator#getDefaultClassLoader()",
    "entityType": "method",
    "code": "@Override\r\nprotected ClassLoader getDefaultClassLoader() {\r\n    if (superclass != null) {\r\n        return superclass.getClassLoader();\r\n    } else {\r\n        return null;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanGenerator#getProtectionDomain()",
    "entityType": "method",
    "code": "@Override\r\nprotected ProtectionDomain getProtectionDomain() {\r\n    return ReflectUtils.getProtectionDomain(superclass);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanGenerator#create()",
    "entityType": "method",
    "code": "public Object create() {\r\n    classOnly = false;\r\n    return createHelper();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanGenerator#createClass()",
    "entityType": "method",
    "code": "public Object createClass() {\r\n    classOnly = true;\r\n    return createHelper();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanGenerator#createHelper()",
    "entityType": "method",
    "code": "private Object createHelper() {\r\n    if (superclass != null) {\r\n        setNamePrefix(superclass.getName());\r\n    }\r\n    String superName = (superclass != null) ? superclass.getName() : \"java.lang.Object\";\r\n    Object key = KEY_FACTORY.newInstance(superName, props);\r\n    return super.create(key);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanGenerator#generateClass(ClassVisitor)",
    "entityType": "method",
    "code": "@Override\r\npublic void generateClass(ClassVisitor v) throws Exception {\r\n    int size = props.size();\r\n    String[] names = (String[]) props.keySet().toArray(new String[size]);\r\n    Type[] types = new Type[size];\r\n    for (int i = 0; i < size; i++) {\r\n        types[i] = (Type) props.get(names[i]);\r\n    }\r\n    ClassEmitter ce = new ClassEmitter(v);\r\n    ce.begin_class(Constants.V1_8, Constants.ACC_PUBLIC, getClassName(), superclass != null ? Type.getType(superclass) : Constants.TYPE_OBJECT, null, null);\r\n    EmitUtils.null_constructor(ce);\r\n    EmitUtils.add_properties(ce, names, types);\r\n    ce.end_class();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanGenerator#firstInstance(Class)",
    "entityType": "method",
    "code": "@Override\r\nprotected Object firstInstance(Class type) {\r\n    if (classOnly) {\r\n        return type;\r\n    } else {\r\n        return ReflectUtils.newInstance(type);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanGenerator#nextInstance(Object)",
    "entityType": "method",
    "code": "@Override\r\nprotected Object nextInstance(Object instance) {\r\n    Class protoclass = (instance instanceof Class<?> clazz) ? clazz : instance.getClass();\r\n    if (classOnly) {\r\n        return protoclass;\r\n    } else {\r\n        return ReflectUtils.newInstance(protoclass);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanGenerator#addProperties(BeanGenerator,Map)",
    "entityType": "method",
    "code": "public static void addProperties(BeanGenerator gen, Map props) {\r\n    for (Iterator it = props.keySet().iterator(); it.hasNext(); ) {\r\n        String name = (String) it.next();\r\n        gen.addProperty(name, (Class) props.get(name));\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanGenerator#addProperties(BeanGenerator,Class)",
    "entityType": "method",
    "code": "public static void addProperties(BeanGenerator gen, Class type) {\r\n    addProperties(gen, ReflectUtils.getBeanProperties(type));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanGenerator#addProperties(BeanGenerator,PropertyDescriptor[])",
    "entityType": "method",
    "code": "public static void addProperties(BeanGenerator gen, PropertyDescriptor[] descriptors) {\r\n    for (PropertyDescriptor descriptor : descriptors) {\r\n        gen.addProperty(descriptor.getName(), descriptor.getPropertyType());\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanGeneratorKey",
    "entityType": "class",
    "code": "public Object newInstance(String superclass, Map props);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanGeneratorKey#newInstance(String,Map)",
    "entityType": "method",
    "code": "public Object newInstance(String superclass, Map props);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.security.TestPrincipal",
    "entityType": "class",
    "code": "private final String name;\npublic TestPrincipal(String name) {\r\n    this.name = name;\r\n}\n@Override\r\npublic String getName() {\r\n    return this.name;\r\n}\n@Override\r\npublic boolean equals(@Nullable Object obj) {\r\n    if (obj == this) {\r\n        return true;\r\n    }\r\n    if (!(obj instanceof TestPrincipal p)) {\r\n        return false;\r\n    }\r\n    return this.name.equals(p.name);\r\n}\n@Override\r\npublic int hashCode() {\r\n    return this.name.hashCode();\r\n}",
    "comment": "\n * An implementation of {@link Principal} for testing.\n *\n * @author Rossen Stoyanchev\n "
  },
  {
    "entityId": "org.springframework.core.testfixture.security.TestPrincipal#getName()",
    "entityType": "method",
    "code": "@Override\r\npublic String getName() {\r\n    return this.name;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.security.TestPrincipal#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object obj) {\r\n    if (obj == this) {\r\n        return true;\r\n    }\r\n    if (!(obj instanceof TestPrincipal p)) {\r\n        return false;\r\n    }\r\n    return this.name.equals(p.name);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.security.TestPrincipal#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return this.name.hashCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMap",
    "entityType": "class",
    "code": "/**\r\n * Limit the properties reflected in the key set of the map\r\n * to readable properties.\r\n * @see BeanMap.Generator#setRequire\r\n */\r\npublic static final int REQUIRE_GETTER = 1;\n/**\r\n * Limit the properties reflected in the key set of the map\r\n * to writable properties.\r\n * @see BeanMap.Generator#setRequire\r\n */\r\npublic static final int REQUIRE_SETTER = 2;\n/**\r\n * Helper method to create a new <code>BeanMap</code>.  For finer\r\n * control over the generated instance, use a new instance of\r\n * <code>BeanMap.Generator</code> instead of this static method.\r\n * @param bean the JavaBean underlying the map\r\n * @return a new <code>BeanMap</code> instance\r\n */\r\npublic static BeanMap create(Object bean) {\r\n    Generator gen = new Generator();\r\n    gen.setBean(bean);\r\n    return gen.create();\r\n}\npublic static class Generator extends AbstractClassGenerator {\r\n\r\n    private static final Source SOURCE = new Source(BeanMap.class.getName());\r\n\r\n    private static final BeanMapKey KEY_FACTORY = (BeanMapKey) KeyFactory.create(BeanMapKey.class, KeyFactory.CLASS_BY_NAME);\r\n\r\n    interface BeanMapKey {\r\n\r\n        public Object newInstance(Class type, int require);\r\n    }\r\n\r\n    private Object bean;\r\n\r\n    private Class beanClass;\r\n\r\n    private int require;\r\n\r\n    public Generator() {\r\n        super(SOURCE);\r\n    }\r\n\r\n    /**\r\n     * Set the bean that the generated map should reflect. The bean may be swapped\r\n     * out for another bean of the same type using {@link #setBean}.\r\n     * Calling this method overrides any value previously set using {@link #setBeanClass}.\r\n     * You must call either this method or {@link #setBeanClass} before {@link #create}.\r\n     * @param bean the initial bean\r\n     */\r\n    public void setBean(Object bean) {\r\n        this.bean = bean;\r\n        if (bean != null) {\r\n            beanClass = bean.getClass();\r\n            // SPRING PATCH BEGIN\r\n            setContextClass(beanClass);\r\n            // SPRING PATCH END\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the class of the bean that the generated map should support.\r\n     * You must call either this method or {@link #setBeanClass} before {@link #create}.\r\n     * @param beanClass the class of the bean\r\n     */\r\n    public void setBeanClass(Class beanClass) {\r\n        this.beanClass = beanClass;\r\n    }\r\n\r\n    /**\r\n     * Limit the properties reflected by the generated map.\r\n     * @param require any combination of {@link #REQUIRE_GETTER} and\r\n     * {@link #REQUIRE_SETTER}; default is zero (any property allowed)\r\n     */\r\n    public void setRequire(int require) {\r\n        this.require = require;\r\n    }\r\n\r\n    @Override\r\n    protected ClassLoader getDefaultClassLoader() {\r\n        return beanClass.getClassLoader();\r\n    }\r\n\r\n    @Override\r\n    protected ProtectionDomain getProtectionDomain() {\r\n        return ReflectUtils.getProtectionDomain(beanClass);\r\n    }\r\n\r\n    /**\r\n     * Create a new instance of the <code>BeanMap</code>. An existing\r\n     * generated class will be reused if possible.\r\n     */\r\n    public BeanMap create() {\r\n        if (beanClass == null) {\r\n            throw new IllegalArgumentException(\"Class of bean unknown\");\r\n        }\r\n        setNamePrefix(beanClass.getName());\r\n        return (BeanMap) super.create(KEY_FACTORY.newInstance(beanClass, require));\r\n    }\r\n\r\n    @Override\r\n    public void generateClass(ClassVisitor v) throws Exception {\r\n        new BeanMapEmitter(v, getClassName(), beanClass, require);\r\n    }\r\n\r\n    @Override\r\n    protected Object firstInstance(Class type) {\r\n        return ((BeanMap) ReflectUtils.newInstance(type)).newInstance(bean);\r\n    }\r\n\r\n    @Override\r\n    protected Object nextInstance(Object instance) {\r\n        return ((BeanMap) instance).newInstance(bean);\r\n    }\r\n}\n/**\r\n * Create a new <code>BeanMap</code> instance using the specified bean.\r\n * This is faster than using the {@link #create} static method.\r\n * @param bean the JavaBean underlying the map\r\n * @return a new <code>BeanMap</code> instance\r\n */\r\nabstract public BeanMap newInstance(Object bean);\n/**\r\n * Get the type of a property.\r\n * @param name the name of the JavaBean property\r\n * @return the type of the property, or null if the property does not exist\r\n */\r\nabstract public Class getPropertyType(String name);\nprotected Object bean;\nprotected BeanMap() {\r\n}\nprotected BeanMap(Object bean) {\r\n    setBean(bean);\r\n}\n@Override\r\npublic Object get(Object key) {\r\n    return get(bean, key);\r\n}\n@Override\r\npublic Object put(Object key, Object value) {\r\n    return put(bean, key, value);\r\n}\n/**\r\n * Get the property of a bean. This allows a <code>BeanMap</code>\r\n * to be used statically for multiple beans--the bean instance tied to the\r\n * map is ignored and the bean passed to this method is used instead.\r\n * @param bean the bean to query; must be compatible with the type of\r\n * this <code>BeanMap</code>\r\n * @param key must be a String\r\n * @return the current value, or null if there is no matching property\r\n */\r\nabstract public Object get(Object bean, Object key);\n/**\r\n * Set the property of a bean. This allows a <code>BeanMap</code>\r\n * to be used statically for multiple beans--the bean instance tied to the\r\n * map is ignored and the bean passed to this method is used instead.\r\n * @param key must be a String\r\n * @return the old value, if there was one, or null\r\n */\r\nabstract public Object put(Object bean, Object key, Object value);\n/**\r\n * Change the underlying bean this map should use.\r\n * @param bean the new JavaBean\r\n * @see #getBean\r\n */\r\npublic void setBean(Object bean) {\r\n    this.bean = bean;\r\n}\n/**\r\n * Return the bean currently in use by this map.\r\n * @return the current JavaBean\r\n * @see #setBean\r\n */\r\npublic Object getBean() {\r\n    return bean;\r\n}\n@Override\r\npublic void clear() {\r\n    throw new UnsupportedOperationException();\r\n}\n@Override\r\npublic boolean containsKey(Object key) {\r\n    return keySet().contains(key);\r\n}\n@Override\r\npublic boolean containsValue(Object value) {\r\n    for (Iterator it = keySet().iterator(); it.hasNext(); ) {\r\n        Object v = get(it.next());\r\n        if (((value == null) && (v == null)) || (value != null && value.equals(v))) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n@Override\r\npublic int size() {\r\n    return keySet().size();\r\n}\n@Override\r\npublic boolean isEmpty() {\r\n    return size() == 0;\r\n}\n@Override\r\npublic Object remove(Object key) {\r\n    throw new UnsupportedOperationException();\r\n}\n@Override\r\npublic void putAll(Map t) {\r\n    for (Object key : t.keySet()) {\r\n        put(key, t.get(key));\r\n    }\r\n}\n@Override\r\npublic boolean equals(Object o) {\r\n    if (o == null || !(o instanceof Map other)) {\r\n        return false;\r\n    }\r\n    if (size() != other.size()) {\r\n        return false;\r\n    }\r\n    for (Object key : keySet()) {\r\n        if (!other.containsKey(key)) {\r\n            return false;\r\n        }\r\n        Object v1 = get(key);\r\n        Object v2 = other.get(key);\r\n        if (!(Objects.equals(v1, v2))) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\n@Override\r\npublic int hashCode() {\r\n    int code = 0;\r\n    for (Object key : keySet()) {\r\n        Object value = get(key);\r\n        code += ((key == null) ? 0 : key.hashCode()) ^ ((value == null) ? 0 : value.hashCode());\r\n    }\r\n    return code;\r\n}\n// TODO: optimize\r\n@Override\r\npublic Set entrySet() {\r\n    HashMap copy = new HashMap();\r\n    for (Object key : keySet()) {\r\n        copy.put(key, get(key));\r\n    }\r\n    return Collections.unmodifiableMap(copy).entrySet();\r\n}\n@Override\r\npublic Collection values() {\r\n    Set keys = keySet();\r\n    List values = new ArrayList(keys.size());\r\n    for (Iterator it = keys.iterator(); it.hasNext(); ) {\r\n        values.add(get(it.next()));\r\n    }\r\n    return Collections.unmodifiableCollection(values);\r\n}\n/*\r\n\t * @see java.util.AbstractMap#toString\r\n\t */\r\n@Override\r\npublic String toString() {\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append('{');\r\n    for (Iterator it = keySet().iterator(); it.hasNext(); ) {\r\n        Object key = it.next();\r\n        sb.append(key);\r\n        sb.append('=');\r\n        sb.append(get(key));\r\n        if (it.hasNext()) {\r\n            sb.append(\", \");\r\n        }\r\n    }\r\n    sb.append('}');\r\n    return sb.toString();\r\n}",
    "comment": "\n * A <code>Map</code>-based view of a JavaBean.  The default set of keys is the\n * union of all property names (getters or setters). An attempt to set\n * a read-only property will be ignored, and write-only properties will\n * be returned as <code>null</code>. Removal of objects is not a\n * supported (the key set is fixed).\n * @author Chris Nokleberg\n "
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMap#create(Object)",
    "entityType": "method",
    "code": "/**\r\n * Helper method to create a new <code>BeanMap</code>.  For finer\r\n * control over the generated instance, use a new instance of\r\n * <code>BeanMap.Generator</code> instead of this static method.\r\n * @param bean the JavaBean underlying the map\r\n * @return a new <code>BeanMap</code> instance\r\n */\r\npublic static BeanMap create(Object bean) {\r\n    Generator gen = new Generator();\r\n    gen.setBean(bean);\r\n    return gen.create();\r\n}",
    "comment": "\n\t * Helper method to create a new <code>BeanMap</code>.  For finer\n\t * control over the generated instance, use a new instance of\n\t * <code>BeanMap.Generator</code> instead of this static method.\n\t * @param bean the JavaBean underlying the map\n\t * @return a new <code>BeanMap</code> instance\n\t "
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMap#newInstance(Object)",
    "entityType": "method",
    "code": "/**\r\n * Create a new <code>BeanMap</code> instance using the specified bean.\r\n * This is faster than using the {@link #create} static method.\r\n * @param bean the JavaBean underlying the map\r\n * @return a new <code>BeanMap</code> instance\r\n */\r\nabstract public BeanMap newInstance(Object bean);",
    "comment": "\n\t * Create a new <code>BeanMap</code> instance using the specified bean.\n\t * This is faster than using the {@link #create} static method.\n\t * @param bean the JavaBean underlying the map\n\t * @return a new <code>BeanMap</code> instance\n\t "
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMap#getPropertyType(String)",
    "entityType": "method",
    "code": "/**\r\n * Get the type of a property.\r\n * @param name the name of the JavaBean property\r\n * @return the type of the property, or null if the property does not exist\r\n */\r\nabstract public Class getPropertyType(String name);",
    "comment": "\n\t * Get the type of a property.\n\t * @param name the name of the JavaBean property\n\t * @return the type of the property, or null if the property does not exist\n\t "
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMap#get(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic Object get(Object key) {\r\n    return get(bean, key);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMap#put(Object,Object)",
    "entityType": "method",
    "code": "@Override\r\npublic Object put(Object key, Object value) {\r\n    return put(bean, key, value);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMap#get(Object,Object)",
    "entityType": "method",
    "code": "/**\r\n * Get the property of a bean. This allows a <code>BeanMap</code>\r\n * to be used statically for multiple beans--the bean instance tied to the\r\n * map is ignored and the bean passed to this method is used instead.\r\n * @param bean the bean to query; must be compatible with the type of\r\n * this <code>BeanMap</code>\r\n * @param key must be a String\r\n * @return the current value, or null if there is no matching property\r\n */\r\nabstract public Object get(Object bean, Object key);",
    "comment": "\n\t * Get the property of a bean. This allows a <code>BeanMap</code>\n\t * to be used statically for multiple beans--the bean instance tied to the\n\t * map is ignored and the bean passed to this method is used instead.\n\t * @param bean the bean to query; must be compatible with the type of\n\t * this <code>BeanMap</code>\n\t * @param key must be a String\n\t * @return the current value, or null if there is no matching property\n\t "
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMap#put(Object,Object,Object)",
    "entityType": "method",
    "code": "/**\r\n * Set the property of a bean. This allows a <code>BeanMap</code>\r\n * to be used statically for multiple beans--the bean instance tied to the\r\n * map is ignored and the bean passed to this method is used instead.\r\n * @param key must be a String\r\n * @return the old value, if there was one, or null\r\n */\r\nabstract public Object put(Object bean, Object key, Object value);",
    "comment": "\n\t * Set the property of a bean. This allows a <code>BeanMap</code>\n\t * to be used statically for multiple beans--the bean instance tied to the\n\t * map is ignored and the bean passed to this method is used instead.\n\t * @param key must be a String\n\t * @return the old value, if there was one, or null\n\t "
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMap#setBean(Object)",
    "entityType": "method",
    "code": "/**\r\n * Change the underlying bean this map should use.\r\n * @param bean the new JavaBean\r\n * @see #getBean\r\n */\r\npublic void setBean(Object bean) {\r\n    this.bean = bean;\r\n}",
    "comment": "\n\t * Change the underlying bean this map should use.\n\t * @param bean the new JavaBean\n\t * @see #getBean\n\t "
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMap#getBean()",
    "entityType": "method",
    "code": "/**\r\n * Return the bean currently in use by this map.\r\n * @return the current JavaBean\r\n * @see #setBean\r\n */\r\npublic Object getBean() {\r\n    return bean;\r\n}",
    "comment": "\n\t * Return the bean currently in use by this map.\n\t * @return the current JavaBean\n\t * @see #setBean\n\t "
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMap#clear()",
    "entityType": "method",
    "code": "@Override\r\npublic void clear() {\r\n    throw new UnsupportedOperationException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMap#containsKey(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean containsKey(Object key) {\r\n    return keySet().contains(key);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMap#containsValue(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean containsValue(Object value) {\r\n    for (Iterator it = keySet().iterator(); it.hasNext(); ) {\r\n        Object v = get(it.next());\r\n        if (((value == null) && (v == null)) || (value != null && value.equals(v))) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMap#size()",
    "entityType": "method",
    "code": "@Override\r\npublic int size() {\r\n    return keySet().size();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMap#isEmpty()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isEmpty() {\r\n    return size() == 0;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMap#remove(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic Object remove(Object key) {\r\n    throw new UnsupportedOperationException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMap#putAll(Map)",
    "entityType": "method",
    "code": "@Override\r\npublic void putAll(Map t) {\r\n    for (Object key : t.keySet()) {\r\n        put(key, t.get(key));\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMap#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(Object o) {\r\n    if (o == null || !(o instanceof Map other)) {\r\n        return false;\r\n    }\r\n    if (size() != other.size()) {\r\n        return false;\r\n    }\r\n    for (Object key : keySet()) {\r\n        if (!other.containsKey(key)) {\r\n            return false;\r\n        }\r\n        Object v1 = get(key);\r\n        Object v2 = other.get(key);\r\n        if (!(Objects.equals(v1, v2))) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMap#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    int code = 0;\r\n    for (Object key : keySet()) {\r\n        Object value = get(key);\r\n        code += ((key == null) ? 0 : key.hashCode()) ^ ((value == null) ? 0 : value.hashCode());\r\n    }\r\n    return code;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMap#entrySet()",
    "entityType": "method",
    "code": "// TODO: optimize\r\n@Override\r\npublic Set entrySet() {\r\n    HashMap copy = new HashMap();\r\n    for (Object key : keySet()) {\r\n        copy.put(key, get(key));\r\n    }\r\n    return Collections.unmodifiableMap(copy).entrySet();\r\n}",
    "comment": " TODO: optimize"
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMap#values()",
    "entityType": "method",
    "code": "@Override\r\npublic Collection values() {\r\n    Set keys = keySet();\r\n    List values = new ArrayList(keys.size());\r\n    for (Iterator it = keys.iterator(); it.hasNext(); ) {\r\n        values.add(get(it.next()));\r\n    }\r\n    return Collections.unmodifiableCollection(values);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMap#toString()",
    "entityType": "method",
    "code": "/*\r\n\t * @see java.util.AbstractMap#toString\r\n\t */\r\n@Override\r\npublic String toString() {\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append('{');\r\n    for (Iterator it = keySet().iterator(); it.hasNext(); ) {\r\n        Object key = it.next();\r\n        sb.append(key);\r\n        sb.append('=');\r\n        sb.append(get(key));\r\n        if (it.hasNext()) {\r\n            sb.append(\", \");\r\n        }\r\n    }\r\n    sb.append('}');\r\n    return sb.toString();\r\n}",
    "comment": "\n\t * @see java.util.AbstractMap#toString\n\t "
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator",
    "entityType": "class",
    "code": "private static final Source SOURCE = new Source(BeanMap.class.getName());\nprivate static final BeanMapKey KEY_FACTORY = (BeanMapKey) KeyFactory.create(BeanMapKey.class, KeyFactory.CLASS_BY_NAME);\ninterface BeanMapKey {\r\n\r\n    public Object newInstance(Class type, int require);\r\n}\nprivate Object bean;\nprivate Class beanClass;\nprivate int require;\npublic Generator() {\r\n    super(SOURCE);\r\n}\n/**\r\n * Set the bean that the generated map should reflect. The bean may be swapped\r\n * out for another bean of the same type using {@link #setBean}.\r\n * Calling this method overrides any value previously set using {@link #setBeanClass}.\r\n * You must call either this method or {@link #setBeanClass} before {@link #create}.\r\n * @param bean the initial bean\r\n */\r\npublic void setBean(Object bean) {\r\n    this.bean = bean;\r\n    if (bean != null) {\r\n        beanClass = bean.getClass();\r\n        // SPRING PATCH BEGIN\r\n        setContextClass(beanClass);\r\n        // SPRING PATCH END\r\n    }\r\n}\n/**\r\n * Set the class of the bean that the generated map should support.\r\n * You must call either this method or {@link #setBeanClass} before {@link #create}.\r\n * @param beanClass the class of the bean\r\n */\r\npublic void setBeanClass(Class beanClass) {\r\n    this.beanClass = beanClass;\r\n}\n/**\r\n * Limit the properties reflected by the generated map.\r\n * @param require any combination of {@link #REQUIRE_GETTER} and\r\n * {@link #REQUIRE_SETTER}; default is zero (any property allowed)\r\n */\r\npublic void setRequire(int require) {\r\n    this.require = require;\r\n}\n@Override\r\nprotected ClassLoader getDefaultClassLoader() {\r\n    return beanClass.getClassLoader();\r\n}\n@Override\r\nprotected ProtectionDomain getProtectionDomain() {\r\n    return ReflectUtils.getProtectionDomain(beanClass);\r\n}\n/**\r\n * Create a new instance of the <code>BeanMap</code>. An existing\r\n * generated class will be reused if possible.\r\n */\r\npublic BeanMap create() {\r\n    if (beanClass == null) {\r\n        throw new IllegalArgumentException(\"Class of bean unknown\");\r\n    }\r\n    setNamePrefix(beanClass.getName());\r\n    return (BeanMap) super.create(KEY_FACTORY.newInstance(beanClass, require));\r\n}\n@Override\r\npublic void generateClass(ClassVisitor v) throws Exception {\r\n    new BeanMapEmitter(v, getClassName(), beanClass, require);\r\n}\n@Override\r\nprotected Object firstInstance(Class type) {\r\n    return ((BeanMap) ReflectUtils.newInstance(type)).newInstance(bean);\r\n}\n@Override\r\nprotected Object nextInstance(Object instance) {\r\n    return ((BeanMap) instance).newInstance(bean);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#setBean(Object)",
    "entityType": "method",
    "code": "/**\r\n * Set the bean that the generated map should reflect. The bean may be swapped\r\n * out for another bean of the same type using {@link #setBean}.\r\n * Calling this method overrides any value previously set using {@link #setBeanClass}.\r\n * You must call either this method or {@link #setBeanClass} before {@link #create}.\r\n * @param bean the initial bean\r\n */\r\npublic void setBean(Object bean) {\r\n    this.bean = bean;\r\n    if (bean != null) {\r\n        beanClass = bean.getClass();\r\n        // SPRING PATCH BEGIN\r\n        setContextClass(beanClass);\r\n        // SPRING PATCH END\r\n    }\r\n}",
    "comment": "\n\t\t * Set the bean that the generated map should reflect. The bean may be swapped\n\t\t * out for another bean of the same type using {@link #setBean}.\n\t\t * Calling this method overrides any value previously set using {@link #setBeanClass}.\n\t\t * You must call either this method or {@link #setBeanClass} before {@link #create}.\n\t\t * @param bean the initial bean\n\t\t "
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#setBeanClass(Class)",
    "entityType": "method",
    "code": "/**\r\n * Set the class of the bean that the generated map should support.\r\n * You must call either this method or {@link #setBeanClass} before {@link #create}.\r\n * @param beanClass the class of the bean\r\n */\r\npublic void setBeanClass(Class beanClass) {\r\n    this.beanClass = beanClass;\r\n}",
    "comment": "\n\t\t * Set the class of the bean that the generated map should support.\n\t\t * You must call either this method or {@link #setBeanClass} before {@link #create}.\n\t\t * @param beanClass the class of the bean\n\t\t "
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#setRequire(int)",
    "entityType": "method",
    "code": "/**\r\n * Limit the properties reflected by the generated map.\r\n * @param require any combination of {@link #REQUIRE_GETTER} and\r\n * {@link #REQUIRE_SETTER}; default is zero (any property allowed)\r\n */\r\npublic void setRequire(int require) {\r\n    this.require = require;\r\n}",
    "comment": "\n\t\t * Limit the properties reflected by the generated map.\n\t\t * @param require any combination of {@link #REQUIRE_GETTER} and\n\t\t * {@link #REQUIRE_SETTER}; default is zero (any property allowed)\n\t\t "
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#getDefaultClassLoader()",
    "entityType": "method",
    "code": "@Override\r\nprotected ClassLoader getDefaultClassLoader() {\r\n    return beanClass.getClassLoader();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#getProtectionDomain()",
    "entityType": "method",
    "code": "@Override\r\nprotected ProtectionDomain getProtectionDomain() {\r\n    return ReflectUtils.getProtectionDomain(beanClass);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#create()",
    "entityType": "method",
    "code": "/**\r\n * Create a new instance of the <code>BeanMap</code>. An existing\r\n * generated class will be reused if possible.\r\n */\r\npublic BeanMap create() {\r\n    if (beanClass == null) {\r\n        throw new IllegalArgumentException(\"Class of bean unknown\");\r\n    }\r\n    setNamePrefix(beanClass.getName());\r\n    return (BeanMap) super.create(KEY_FACTORY.newInstance(beanClass, require));\r\n}",
    "comment": "\n\t\t * Create a new instance of the <code>BeanMap</code>. An existing\n\t\t * generated class will be reused if possible.\n\t\t "
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#generateClass(ClassVisitor)",
    "entityType": "method",
    "code": "@Override\r\npublic void generateClass(ClassVisitor v) throws Exception {\r\n    new BeanMapEmitter(v, getClassName(), beanClass, require);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#firstInstance(Class)",
    "entityType": "method",
    "code": "@Override\r\nprotected Object firstInstance(Class type) {\r\n    return ((BeanMap) ReflectUtils.newInstance(type)).newInstance(bean);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#nextInstance(Object)",
    "entityType": "method",
    "code": "@Override\r\nprotected Object nextInstance(Object instance) {\r\n    return ((BeanMap) instance).newInstance(bean);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMapKey",
    "entityType": "class",
    "code": "public Object newInstance(Class type, int require);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMapKey#newInstance(Class,int)",
    "entityType": "method",
    "code": "public Object newInstance(Class type, int require);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMapEmitter",
    "entityType": "class",
    "code": "private static final Type BEAN_MAP = TypeUtils.parseType(\"org.springframework.cglib.beans.BeanMap\");\nprivate static final Type FIXED_KEY_SET = TypeUtils.parseType(\"org.springframework.cglib.beans.FixedKeySet\");\nprivate static final Signature CSTRUCT_OBJECT = TypeUtils.parseConstructor(\"Object\");\nprivate static final Signature CSTRUCT_STRING_ARRAY = TypeUtils.parseConstructor(\"String[]\");\nprivate static final Signature BEAN_MAP_GET = TypeUtils.parseSignature(\"Object get(Object, Object)\");\nprivate static final Signature BEAN_MAP_PUT = TypeUtils.parseSignature(\"Object put(Object, Object, Object)\");\nprivate static final Signature KEY_SET = TypeUtils.parseSignature(\"java.util.Set keySet()\");\nprivate static final Signature NEW_INSTANCE = new Signature(\"newInstance\", BEAN_MAP, new Type[] { Constants.TYPE_OBJECT });\nprivate static final Signature GET_PROPERTY_TYPE = TypeUtils.parseSignature(\"Class getPropertyType(String)\");\npublic BeanMapEmitter(ClassVisitor v, String className, Class type, int require) {\r\n    super(v);\r\n    begin_class(Constants.V1_8, Constants.ACC_PUBLIC, className, BEAN_MAP, null, Constants.SOURCE_FILE);\r\n    EmitUtils.null_constructor(this);\r\n    EmitUtils.factory_method(this, NEW_INSTANCE);\r\n    generateConstructor();\r\n    Map getters = makePropertyMap(ReflectUtils.getBeanGetters(type));\r\n    Map setters = makePropertyMap(ReflectUtils.getBeanSetters(type));\r\n    Map allProps = new HashMap();\r\n    allProps.putAll(getters);\r\n    allProps.putAll(setters);\r\n    if (require != 0) {\r\n        for (Iterator it = allProps.keySet().iterator(); it.hasNext(); ) {\r\n            String name = (String) it.next();\r\n            if ((((require & BeanMap.REQUIRE_GETTER) != 0) && !getters.containsKey(name)) || (((require & BeanMap.REQUIRE_SETTER) != 0) && !setters.containsKey(name))) {\r\n                it.remove();\r\n                getters.remove(name);\r\n                setters.remove(name);\r\n            }\r\n        }\r\n    }\r\n    generateGet(type, getters);\r\n    generatePut(type, setters);\r\n    String[] allNames = getNames(allProps);\r\n    generateKeySet(allNames);\r\n    generateGetPropertyType(allProps, allNames);\r\n    end_class();\r\n}\nprivate Map makePropertyMap(PropertyDescriptor[] props) {\r\n    Map names = new HashMap();\r\n    for (PropertyDescriptor prop : props) {\r\n        names.put(prop.getName(), prop);\r\n    }\r\n    return names;\r\n}\nprivate String[] getNames(Map propertyMap) {\r\n    return (String[]) propertyMap.keySet().toArray(new String[propertyMap.size()]);\r\n}\nprivate void generateConstructor() {\r\n    CodeEmitter e = begin_method(Constants.ACC_PUBLIC, CSTRUCT_OBJECT, null);\r\n    e.load_this();\r\n    e.load_arg(0);\r\n    e.super_invoke_constructor(CSTRUCT_OBJECT);\r\n    e.return_value();\r\n    e.end_method();\r\n}\nprivate void generateGet(Class type, final Map getters) {\r\n    final CodeEmitter e = begin_method(Constants.ACC_PUBLIC, BEAN_MAP_GET, null);\r\n    e.load_arg(0);\r\n    e.checkcast(Type.getType(type));\r\n    e.load_arg(1);\r\n    e.checkcast(Constants.TYPE_STRING);\r\n    EmitUtils.string_switch(e, getNames(getters), Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(Object key, Label end) {\r\n            PropertyDescriptor pd = (PropertyDescriptor) getters.get(key);\r\n            MethodInfo method = ReflectUtils.getMethodInfo(pd.getReadMethod());\r\n            e.invoke(method);\r\n            e.box(method.getSignature().getReturnType());\r\n            e.return_value();\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            e.aconst_null();\r\n            e.return_value();\r\n        }\r\n    });\r\n    e.end_method();\r\n}\nprivate void generatePut(Class type, final Map setters) {\r\n    final CodeEmitter e = begin_method(Constants.ACC_PUBLIC, BEAN_MAP_PUT, null);\r\n    e.load_arg(0);\r\n    e.checkcast(Type.getType(type));\r\n    e.load_arg(1);\r\n    e.checkcast(Constants.TYPE_STRING);\r\n    EmitUtils.string_switch(e, getNames(setters), Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(Object key, Label end) {\r\n            PropertyDescriptor pd = (PropertyDescriptor) setters.get(key);\r\n            if (pd.getReadMethod() == null) {\r\n                e.aconst_null();\r\n            } else {\r\n                MethodInfo read = ReflectUtils.getMethodInfo(pd.getReadMethod());\r\n                e.dup();\r\n                e.invoke(read);\r\n                e.box(read.getSignature().getReturnType());\r\n            }\r\n            // move old value behind bean\r\n            e.swap();\r\n            // new value\r\n            e.load_arg(2);\r\n            MethodInfo write = ReflectUtils.getMethodInfo(pd.getWriteMethod());\r\n            e.unbox(write.getSignature().getArgumentTypes()[0]);\r\n            e.invoke(write);\r\n            e.return_value();\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            // fall-through\r\n        }\r\n    });\r\n    e.aconst_null();\r\n    e.return_value();\r\n    e.end_method();\r\n}\nprivate void generateKeySet(String[] allNames) {\r\n    // static initializer\r\n    declare_field(Constants.ACC_STATIC | Constants.ACC_PRIVATE, \"keys\", FIXED_KEY_SET, null);\r\n    CodeEmitter e = begin_static();\r\n    e.new_instance(FIXED_KEY_SET);\r\n    e.dup();\r\n    EmitUtils.push_array(e, allNames);\r\n    e.invoke_constructor(FIXED_KEY_SET, CSTRUCT_STRING_ARRAY);\r\n    e.putfield(\"keys\");\r\n    e.return_value();\r\n    e.end_method();\r\n    // keySet\r\n    e = begin_method(Constants.ACC_PUBLIC, KEY_SET, null);\r\n    e.load_this();\r\n    e.getfield(\"keys\");\r\n    e.return_value();\r\n    e.end_method();\r\n}\nprivate void generateGetPropertyType(final Map allProps, String[] allNames) {\r\n    final CodeEmitter e = begin_method(Constants.ACC_PUBLIC, GET_PROPERTY_TYPE, null);\r\n    e.load_arg(0);\r\n    EmitUtils.string_switch(e, allNames, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(Object key, Label end) {\r\n            PropertyDescriptor pd = (PropertyDescriptor) allProps.get(key);\r\n            EmitUtils.load_class(e, Type.getType(pd.getPropertyType()));\r\n            e.return_value();\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            e.aconst_null();\r\n            e.return_value();\r\n        }\r\n    });\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMapEmitter#makePropertyMap(PropertyDescriptor[])",
    "entityType": "method",
    "code": "private Map makePropertyMap(PropertyDescriptor[] props) {\r\n    Map names = new HashMap();\r\n    for (PropertyDescriptor prop : props) {\r\n        names.put(prop.getName(), prop);\r\n    }\r\n    return names;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMapEmitter#getNames(Map)",
    "entityType": "method",
    "code": "private String[] getNames(Map propertyMap) {\r\n    return (String[]) propertyMap.keySet().toArray(new String[propertyMap.size()]);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMapEmitter#generateConstructor()",
    "entityType": "method",
    "code": "private void generateConstructor() {\r\n    CodeEmitter e = begin_method(Constants.ACC_PUBLIC, CSTRUCT_OBJECT, null);\r\n    e.load_this();\r\n    e.load_arg(0);\r\n    e.super_invoke_constructor(CSTRUCT_OBJECT);\r\n    e.return_value();\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMapEmitter#generateGet(Class,Map)",
    "entityType": "method",
    "code": "private void generateGet(Class type, final Map getters) {\r\n    final CodeEmitter e = begin_method(Constants.ACC_PUBLIC, BEAN_MAP_GET, null);\r\n    e.load_arg(0);\r\n    e.checkcast(Type.getType(type));\r\n    e.load_arg(1);\r\n    e.checkcast(Constants.TYPE_STRING);\r\n    EmitUtils.string_switch(e, getNames(getters), Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(Object key, Label end) {\r\n            PropertyDescriptor pd = (PropertyDescriptor) getters.get(key);\r\n            MethodInfo method = ReflectUtils.getMethodInfo(pd.getReadMethod());\r\n            e.invoke(method);\r\n            e.box(method.getSignature().getReturnType());\r\n            e.return_value();\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            e.aconst_null();\r\n            e.return_value();\r\n        }\r\n    });\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMapEmitter#generatePut(Class,Map)",
    "entityType": "method",
    "code": "private void generatePut(Class type, final Map setters) {\r\n    final CodeEmitter e = begin_method(Constants.ACC_PUBLIC, BEAN_MAP_PUT, null);\r\n    e.load_arg(0);\r\n    e.checkcast(Type.getType(type));\r\n    e.load_arg(1);\r\n    e.checkcast(Constants.TYPE_STRING);\r\n    EmitUtils.string_switch(e, getNames(setters), Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(Object key, Label end) {\r\n            PropertyDescriptor pd = (PropertyDescriptor) setters.get(key);\r\n            if (pd.getReadMethod() == null) {\r\n                e.aconst_null();\r\n            } else {\r\n                MethodInfo read = ReflectUtils.getMethodInfo(pd.getReadMethod());\r\n                e.dup();\r\n                e.invoke(read);\r\n                e.box(read.getSignature().getReturnType());\r\n            }\r\n            // move old value behind bean\r\n            e.swap();\r\n            // new value\r\n            e.load_arg(2);\r\n            MethodInfo write = ReflectUtils.getMethodInfo(pd.getWriteMethod());\r\n            e.unbox(write.getSignature().getArgumentTypes()[0]);\r\n            e.invoke(write);\r\n            e.return_value();\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            // fall-through\r\n        }\r\n    });\r\n    e.aconst_null();\r\n    e.return_value();\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMapEmitter#generateKeySet(String[])",
    "entityType": "method",
    "code": "private void generateKeySet(String[] allNames) {\r\n    // static initializer\r\n    declare_field(Constants.ACC_STATIC | Constants.ACC_PRIVATE, \"keys\", FIXED_KEY_SET, null);\r\n    CodeEmitter e = begin_static();\r\n    e.new_instance(FIXED_KEY_SET);\r\n    e.dup();\r\n    EmitUtils.push_array(e, allNames);\r\n    e.invoke_constructor(FIXED_KEY_SET, CSTRUCT_STRING_ARRAY);\r\n    e.putfield(\"keys\");\r\n    e.return_value();\r\n    e.end_method();\r\n    // keySet\r\n    e = begin_method(Constants.ACC_PUBLIC, KEY_SET, null);\r\n    e.load_this();\r\n    e.getfield(\"keys\");\r\n    e.return_value();\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanMapEmitter#generateGetPropertyType(Map,String[])",
    "entityType": "method",
    "code": "private void generateGetPropertyType(final Map allProps, String[] allNames) {\r\n    final CodeEmitter e = begin_method(Constants.ACC_PUBLIC, GET_PROPERTY_TYPE, null);\r\n    e.load_arg(0);\r\n    EmitUtils.string_switch(e, allNames, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(Object key, Label end) {\r\n            PropertyDescriptor pd = (PropertyDescriptor) allProps.get(key);\r\n            EmitUtils.load_class(e, Type.getType(pd.getPropertyType()));\r\n            e.return_value();\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            e.aconst_null();\r\n            e.return_value();\r\n        }\r\n    });\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BulkBean",
    "entityType": "class",
    "code": "private static final BulkBeanKey KEY_FACTORY = (BulkBeanKey) KeyFactory.create(BulkBeanKey.class);\ninterface BulkBeanKey {\r\n\r\n    public Object newInstance(String target, String[] getters, String[] setters, String[] types);\r\n}\nprotected Class target;\nprotected String[] getters, setters;\nprotected Class[] types;\nprotected BulkBean() {\r\n}\nabstract public void getPropertyValues(Object bean, Object[] values);\nabstract public void setPropertyValues(Object bean, Object[] values);\npublic Object[] getPropertyValues(Object bean) {\r\n    Object[] values = new Object[getters.length];\r\n    getPropertyValues(bean, values);\r\n    return values;\r\n}\npublic Class[] getPropertyTypes() {\r\n    return types.clone();\r\n}\npublic String[] getGetters() {\r\n    return getters.clone();\r\n}\npublic String[] getSetters() {\r\n    return setters.clone();\r\n}\npublic static BulkBean create(Class target, String[] getters, String[] setters, Class[] types) {\r\n    Generator gen = new Generator();\r\n    gen.setTarget(target);\r\n    gen.setGetters(getters);\r\n    gen.setSetters(setters);\r\n    gen.setTypes(types);\r\n    return gen.create();\r\n}\npublic static class Generator extends AbstractClassGenerator {\r\n\r\n    private static final Source SOURCE = new Source(BulkBean.class.getName());\r\n\r\n    private Class target;\r\n\r\n    private String[] getters;\r\n\r\n    private String[] setters;\r\n\r\n    private Class[] types;\r\n\r\n    public Generator() {\r\n        super(SOURCE);\r\n    }\r\n\r\n    public void setTarget(Class target) {\r\n        this.target = target;\r\n        // SPRING PATCH BEGIN\r\n        setContextClass(target);\r\n        // SPRING PATCH END\r\n    }\r\n\r\n    public void setGetters(String[] getters) {\r\n        this.getters = getters;\r\n    }\r\n\r\n    public void setSetters(String[] setters) {\r\n        this.setters = setters;\r\n    }\r\n\r\n    public void setTypes(Class[] types) {\r\n        this.types = types;\r\n    }\r\n\r\n    @Override\r\n    protected ClassLoader getDefaultClassLoader() {\r\n        return target.getClassLoader();\r\n    }\r\n\r\n    @Override\r\n    protected ProtectionDomain getProtectionDomain() {\r\n        return ReflectUtils.getProtectionDomain(target);\r\n    }\r\n\r\n    public BulkBean create() {\r\n        setNamePrefix(target.getName());\r\n        String targetClassName = target.getName();\r\n        String[] typeClassNames = ReflectUtils.getNames(types);\r\n        Object key = KEY_FACTORY.newInstance(targetClassName, getters, setters, typeClassNames);\r\n        return (BulkBean) super.create(key);\r\n    }\r\n\r\n    @Override\r\n    public void generateClass(ClassVisitor v) throws Exception {\r\n        new BulkBeanEmitter(v, getClassName(), target, getters, setters, types);\r\n    }\r\n\r\n    @Override\r\n    protected Object firstInstance(Class type) {\r\n        BulkBean instance = (BulkBean) ReflectUtils.newInstance(type);\r\n        instance.target = target;\r\n        int length = getters.length;\r\n        instance.getters = new String[length];\r\n        System.arraycopy(getters, 0, instance.getters, 0, length);\r\n        instance.setters = new String[length];\r\n        System.arraycopy(setters, 0, instance.setters, 0, length);\r\n        instance.types = new Class[types.length];\r\n        System.arraycopy(types, 0, instance.types, 0, types.length);\r\n        return instance;\r\n    }\r\n\r\n    @Override\r\n    protected Object nextInstance(Object instance) {\r\n        return instance;\r\n    }\r\n}",
    "comment": "\n * @author Juozas Baliuka\n "
  },
  {
    "entityId": "org.springframework.cglib.beans.BulkBean#getPropertyValues(Object,Object[])",
    "entityType": "method",
    "code": "abstract public void getPropertyValues(Object bean, Object[] values);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BulkBean#setPropertyValues(Object,Object[])",
    "entityType": "method",
    "code": "abstract public void setPropertyValues(Object bean, Object[] values);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BulkBean#getPropertyValues(Object)",
    "entityType": "method",
    "code": "public Object[] getPropertyValues(Object bean) {\r\n    Object[] values = new Object[getters.length];\r\n    getPropertyValues(bean, values);\r\n    return values;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BulkBean#getPropertyTypes()",
    "entityType": "method",
    "code": "public Class[] getPropertyTypes() {\r\n    return types.clone();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BulkBean#getGetters()",
    "entityType": "method",
    "code": "public String[] getGetters() {\r\n    return getters.clone();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BulkBean#getSetters()",
    "entityType": "method",
    "code": "public String[] getSetters() {\r\n    return setters.clone();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BulkBean#create(Class,String[],String[],Class[])",
    "entityType": "method",
    "code": "public static BulkBean create(Class target, String[] getters, String[] setters, Class[] types) {\r\n    Generator gen = new Generator();\r\n    gen.setTarget(target);\r\n    gen.setGetters(getters);\r\n    gen.setSetters(setters);\r\n    gen.setTypes(types);\r\n    return gen.create();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BulkBeanKey",
    "entityType": "class",
    "code": "public Object newInstance(String target, String[] getters, String[] setters, String[] types);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BulkBeanKey#newInstance(String,String[],String[],String[])",
    "entityType": "method",
    "code": "public Object newInstance(String target, String[] getters, String[] setters, String[] types);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator",
    "entityType": "class",
    "code": "private static final Source SOURCE = new Source(BulkBean.class.getName());\nprivate Class target;\nprivate String[] getters;\nprivate String[] setters;\nprivate Class[] types;\npublic Generator() {\r\n    super(SOURCE);\r\n}\npublic void setTarget(Class target) {\r\n    this.target = target;\r\n    // SPRING PATCH BEGIN\r\n    setContextClass(target);\r\n    // SPRING PATCH END\r\n}\npublic void setGetters(String[] getters) {\r\n    this.getters = getters;\r\n}\npublic void setSetters(String[] setters) {\r\n    this.setters = setters;\r\n}\npublic void setTypes(Class[] types) {\r\n    this.types = types;\r\n}\n@Override\r\nprotected ClassLoader getDefaultClassLoader() {\r\n    return target.getClassLoader();\r\n}\n@Override\r\nprotected ProtectionDomain getProtectionDomain() {\r\n    return ReflectUtils.getProtectionDomain(target);\r\n}\npublic BulkBean create() {\r\n    setNamePrefix(target.getName());\r\n    String targetClassName = target.getName();\r\n    String[] typeClassNames = ReflectUtils.getNames(types);\r\n    Object key = KEY_FACTORY.newInstance(targetClassName, getters, setters, typeClassNames);\r\n    return (BulkBean) super.create(key);\r\n}\n@Override\r\npublic void generateClass(ClassVisitor v) throws Exception {\r\n    new BulkBeanEmitter(v, getClassName(), target, getters, setters, types);\r\n}\n@Override\r\nprotected Object firstInstance(Class type) {\r\n    BulkBean instance = (BulkBean) ReflectUtils.newInstance(type);\r\n    instance.target = target;\r\n    int length = getters.length;\r\n    instance.getters = new String[length];\r\n    System.arraycopy(getters, 0, instance.getters, 0, length);\r\n    instance.setters = new String[length];\r\n    System.arraycopy(setters, 0, instance.setters, 0, length);\r\n    instance.types = new Class[types.length];\r\n    System.arraycopy(types, 0, instance.types, 0, types.length);\r\n    return instance;\r\n}\n@Override\r\nprotected Object nextInstance(Object instance) {\r\n    return instance;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#setTarget(Class)",
    "entityType": "method",
    "code": "public void setTarget(Class target) {\r\n    this.target = target;\r\n    // SPRING PATCH BEGIN\r\n    setContextClass(target);\r\n    // SPRING PATCH END\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#setGetters(String[])",
    "entityType": "method",
    "code": "public void setGetters(String[] getters) {\r\n    this.getters = getters;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#setSetters(String[])",
    "entityType": "method",
    "code": "public void setSetters(String[] setters) {\r\n    this.setters = setters;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#setTypes(Class[])",
    "entityType": "method",
    "code": "public void setTypes(Class[] types) {\r\n    this.types = types;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#getDefaultClassLoader()",
    "entityType": "method",
    "code": "@Override\r\nprotected ClassLoader getDefaultClassLoader() {\r\n    return target.getClassLoader();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#getProtectionDomain()",
    "entityType": "method",
    "code": "@Override\r\nprotected ProtectionDomain getProtectionDomain() {\r\n    return ReflectUtils.getProtectionDomain(target);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#create()",
    "entityType": "method",
    "code": "public BulkBean create() {\r\n    setNamePrefix(target.getName());\r\n    String targetClassName = target.getName();\r\n    String[] typeClassNames = ReflectUtils.getNames(types);\r\n    Object key = KEY_FACTORY.newInstance(targetClassName, getters, setters, typeClassNames);\r\n    return (BulkBean) super.create(key);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#generateClass(ClassVisitor)",
    "entityType": "method",
    "code": "@Override\r\npublic void generateClass(ClassVisitor v) throws Exception {\r\n    new BulkBeanEmitter(v, getClassName(), target, getters, setters, types);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#firstInstance(Class)",
    "entityType": "method",
    "code": "@Override\r\nprotected Object firstInstance(Class type) {\r\n    BulkBean instance = (BulkBean) ReflectUtils.newInstance(type);\r\n    instance.target = target;\r\n    int length = getters.length;\r\n    instance.getters = new String[length];\r\n    System.arraycopy(getters, 0, instance.getters, 0, length);\r\n    instance.setters = new String[length];\r\n    System.arraycopy(setters, 0, instance.setters, 0, length);\r\n    instance.types = new Class[types.length];\r\n    System.arraycopy(types, 0, instance.types, 0, types.length);\r\n    return instance;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#nextInstance(Object)",
    "entityType": "method",
    "code": "@Override\r\nprotected Object nextInstance(Object instance) {\r\n    return instance;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.TestGroupsCondition",
    "entityType": "class",
    "code": "private static final ConditionEvaluationResult ENABLED_BY_DEFAULT = enabled(\"@EnabledForTestGroups is not present\");\n@Override\r\npublic ConditionEvaluationResult evaluateExecutionCondition(ExtensionContext context) {\r\n    Optional<EnabledForTestGroups> optional = findAnnotation(context.getElement(), EnabledForTestGroups.class);\r\n    if (optional.isEmpty()) {\r\n        return ENABLED_BY_DEFAULT;\r\n    }\r\n    TestGroup[] testGroups = optional.get().value();\r\n    Assert.state(testGroups.length > 0, \"You must declare at least one TestGroup in @EnabledForTestGroups\");\r\n    return (Arrays.stream(testGroups).anyMatch(TestGroup::isActive)) ? enabled(\"Enabled for TestGroups: \" + Arrays.toString(testGroups)) : disabled(\"Disabled for TestGroups: \" + Arrays.toString(testGroups));\r\n}",
    "comment": "\n * {@link ExecutionCondition} for Spring's {@link TestGroup} support.\n *\n * @author Sam Brannen\n * @since 5.2\n * @see EnabledForTestGroups @EnabledForTestGroups\n "
  },
  {
    "entityId": "org.springframework.core.testfixture.TestGroupsCondition#evaluateExecutionCondition(ExtensionContext)",
    "entityType": "method",
    "code": "@Override\r\npublic ConditionEvaluationResult evaluateExecutionCondition(ExtensionContext context) {\r\n    Optional<EnabledForTestGroups> optional = findAnnotation(context.getElement(), EnabledForTestGroups.class);\r\n    if (optional.isEmpty()) {\r\n        return ENABLED_BY_DEFAULT;\r\n    }\r\n    TestGroup[] testGroups = optional.get().value();\r\n    Assert.state(testGroups.length > 0, \"You must declare at least one TestGroup in @EnabledForTestGroups\");\r\n    return (Arrays.stream(testGroups).anyMatch(TestGroup::isActive)) ? enabled(\"Enabled for TestGroups: \" + Arrays.toString(testGroups)) : disabled(\"Disabled for TestGroups: \" + Arrays.toString(testGroups));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.TimeStamped",
    "entityType": "class",
    "code": "/**\r\n * Return the timestamp for this object.\r\n * @return long the timestamp for this object,\r\n * as returned by System.currentTimeMillis()\r\n */\r\nlong getTimeStamp();",
    "comment": "\n * This interface can be implemented by cacheable objects or cache entries,\n * to enable the freshness of objects to be checked.\n *\n * @author Rod Johnson\n "
  },
  {
    "entityId": "org.springframework.core.testfixture.TimeStamped#getTimeStamp()",
    "entityType": "method",
    "code": "/**\r\n * Return the timestamp for this object.\r\n * @return long the timestamp for this object,\r\n * as returned by System.currentTimeMillis()\r\n */\r\nlong getTimeStamp();",
    "comment": "\n\t * Return the timestamp for this object.\n\t * @return long the timestamp for this object,\n\t * as returned by System.currentTimeMillis()\n\t "
  },
  {
    "entityId": "org.springframework.cglib.beans.BulkBeanEmitter",
    "entityType": "class",
    "code": "private static final Signature GET_PROPERTY_VALUES = TypeUtils.parseSignature(\"void getPropertyValues(Object, Object[])\");\nprivate static final Signature SET_PROPERTY_VALUES = TypeUtils.parseSignature(\"void setPropertyValues(Object, Object[])\");\nprivate static final Signature CSTRUCT_EXCEPTION = TypeUtils.parseConstructor(\"Throwable, int\");\nprivate static final Type BULK_BEAN = TypeUtils.parseType(\"org.springframework.cglib.beans.BulkBean\");\nprivate static final Type BULK_BEAN_EXCEPTION = TypeUtils.parseType(\"org.springframework.cglib.beans.BulkBeanException\");\npublic BulkBeanEmitter(ClassVisitor v, String className, Class target, String[] getterNames, String[] setterNames, Class[] types) {\r\n    super(v);\r\n    Method[] getters = new Method[getterNames.length];\r\n    Method[] setters = new Method[setterNames.length];\r\n    validate(target, getterNames, setterNames, types, getters, setters);\r\n    begin_class(Constants.V1_8, Constants.ACC_PUBLIC, className, BULK_BEAN, null, Constants.SOURCE_FILE);\r\n    EmitUtils.null_constructor(this);\r\n    generateGet(target, getters);\r\n    generateSet(target, setters);\r\n    end_class();\r\n}\nprivate void generateGet(final Class target, final Method[] getters) {\r\n    CodeEmitter e = begin_method(Constants.ACC_PUBLIC, GET_PROPERTY_VALUES, null);\r\n    if (getters.length > 0) {\r\n        e.load_arg(0);\r\n        e.checkcast(Type.getType(target));\r\n        Local bean = e.make_local();\r\n        e.store_local(bean);\r\n        for (int i = 0; i < getters.length; i++) {\r\n            if (getters[i] != null) {\r\n                MethodInfo getter = ReflectUtils.getMethodInfo(getters[i]);\r\n                e.load_arg(1);\r\n                e.push(i);\r\n                e.load_local(bean);\r\n                e.invoke(getter);\r\n                e.box(getter.getSignature().getReturnType());\r\n                e.aastore();\r\n            }\r\n        }\r\n    }\r\n    e.return_value();\r\n    e.end_method();\r\n}\nprivate void generateSet(final Class target, final Method[] setters) {\r\n    // setPropertyValues\r\n    CodeEmitter e = begin_method(Constants.ACC_PUBLIC, SET_PROPERTY_VALUES, null);\r\n    if (setters.length > 0) {\r\n        Local index = e.make_local(Type.INT_TYPE);\r\n        e.push(0);\r\n        e.store_local(index);\r\n        e.load_arg(0);\r\n        e.checkcast(Type.getType(target));\r\n        e.load_arg(1);\r\n        Block handler = e.begin_block();\r\n        int lastIndex = 0;\r\n        for (int i = 0; i < setters.length; i++) {\r\n            if (setters[i] != null) {\r\n                MethodInfo setter = ReflectUtils.getMethodInfo(setters[i]);\r\n                int diff = i - lastIndex;\r\n                if (diff > 0) {\r\n                    e.iinc(index, diff);\r\n                    lastIndex = i;\r\n                }\r\n                e.dup2();\r\n                e.aaload(i);\r\n                e.unbox(setter.getSignature().getArgumentTypes()[0]);\r\n                e.invoke(setter);\r\n            }\r\n        }\r\n        handler.end();\r\n        e.return_value();\r\n        e.catch_exception(handler, Constants.TYPE_THROWABLE);\r\n        e.new_instance(BULK_BEAN_EXCEPTION);\r\n        e.dup_x1();\r\n        e.swap();\r\n        e.load_local(index);\r\n        e.invoke_constructor(BULK_BEAN_EXCEPTION, CSTRUCT_EXCEPTION);\r\n        e.athrow();\r\n    } else {\r\n        e.return_value();\r\n    }\r\n    e.end_method();\r\n}\nprivate static void validate(Class target, String[] getters, String[] setters, Class[] types, Method[] getters_out, Method[] setters_out) {\r\n    int i = -1;\r\n    if (setters.length != types.length || getters.length != types.length) {\r\n        throw new BulkBeanException(\"accessor array length must be equal type array length\", i);\r\n    }\r\n    try {\r\n        for (i = 0; i < types.length; i++) {\r\n            if (getters[i] != null) {\r\n                Method method = ReflectUtils.findDeclaredMethod(target, getters[i], null);\r\n                if (method.getReturnType() != types[i]) {\r\n                    throw new BulkBeanException(\"Specified type \" + types[i] + \" does not match declared type \" + method.getReturnType(), i);\r\n                }\r\n                if (Modifier.isPrivate(method.getModifiers())) {\r\n                    throw new BulkBeanException(\"Property is private\", i);\r\n                }\r\n                getters_out[i] = method;\r\n            }\r\n            if (setters[i] != null) {\r\n                Method method = ReflectUtils.findDeclaredMethod(target, setters[i], new Class[] { types[i] });\r\n                if (Modifier.isPrivate(method.getModifiers())) {\r\n                    throw new BulkBeanException(\"Property is private\", i);\r\n                }\r\n                setters_out[i] = method;\r\n            }\r\n        }\r\n    } catch (NoSuchMethodException e) {\r\n        throw new BulkBeanException(\"Cannot find specified property\", i);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BulkBeanEmitter#generateGet(Class,Method[])",
    "entityType": "method",
    "code": "private void generateGet(final Class target, final Method[] getters) {\r\n    CodeEmitter e = begin_method(Constants.ACC_PUBLIC, GET_PROPERTY_VALUES, null);\r\n    if (getters.length > 0) {\r\n        e.load_arg(0);\r\n        e.checkcast(Type.getType(target));\r\n        Local bean = e.make_local();\r\n        e.store_local(bean);\r\n        for (int i = 0; i < getters.length; i++) {\r\n            if (getters[i] != null) {\r\n                MethodInfo getter = ReflectUtils.getMethodInfo(getters[i]);\r\n                e.load_arg(1);\r\n                e.push(i);\r\n                e.load_local(bean);\r\n                e.invoke(getter);\r\n                e.box(getter.getSignature().getReturnType());\r\n                e.aastore();\r\n            }\r\n        }\r\n    }\r\n    e.return_value();\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BulkBeanEmitter#generateSet(Class,Method[])",
    "entityType": "method",
    "code": "private void generateSet(final Class target, final Method[] setters) {\r\n    // setPropertyValues\r\n    CodeEmitter e = begin_method(Constants.ACC_PUBLIC, SET_PROPERTY_VALUES, null);\r\n    if (setters.length > 0) {\r\n        Local index = e.make_local(Type.INT_TYPE);\r\n        e.push(0);\r\n        e.store_local(index);\r\n        e.load_arg(0);\r\n        e.checkcast(Type.getType(target));\r\n        e.load_arg(1);\r\n        Block handler = e.begin_block();\r\n        int lastIndex = 0;\r\n        for (int i = 0; i < setters.length; i++) {\r\n            if (setters[i] != null) {\r\n                MethodInfo setter = ReflectUtils.getMethodInfo(setters[i]);\r\n                int diff = i - lastIndex;\r\n                if (diff > 0) {\r\n                    e.iinc(index, diff);\r\n                    lastIndex = i;\r\n                }\r\n                e.dup2();\r\n                e.aaload(i);\r\n                e.unbox(setter.getSignature().getArgumentTypes()[0]);\r\n                e.invoke(setter);\r\n            }\r\n        }\r\n        handler.end();\r\n        e.return_value();\r\n        e.catch_exception(handler, Constants.TYPE_THROWABLE);\r\n        e.new_instance(BULK_BEAN_EXCEPTION);\r\n        e.dup_x1();\r\n        e.swap();\r\n        e.load_local(index);\r\n        e.invoke_constructor(BULK_BEAN_EXCEPTION, CSTRUCT_EXCEPTION);\r\n        e.athrow();\r\n    } else {\r\n        e.return_value();\r\n    }\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BulkBeanEmitter#validate(Class,String[],String[],Class[],Method[],Method[])",
    "entityType": "method",
    "code": "private static void validate(Class target, String[] getters, String[] setters, Class[] types, Method[] getters_out, Method[] setters_out) {\r\n    int i = -1;\r\n    if (setters.length != types.length || getters.length != types.length) {\r\n        throw new BulkBeanException(\"accessor array length must be equal type array length\", i);\r\n    }\r\n    try {\r\n        for (i = 0; i < types.length; i++) {\r\n            if (getters[i] != null) {\r\n                Method method = ReflectUtils.findDeclaredMethod(target, getters[i], null);\r\n                if (method.getReturnType() != types[i]) {\r\n                    throw new BulkBeanException(\"Specified type \" + types[i] + \" does not match declared type \" + method.getReturnType(), i);\r\n                }\r\n                if (Modifier.isPrivate(method.getModifiers())) {\r\n                    throw new BulkBeanException(\"Property is private\", i);\r\n                }\r\n                getters_out[i] = method;\r\n            }\r\n            if (setters[i] != null) {\r\n                Method method = ReflectUtils.findDeclaredMethod(target, setters[i], new Class[] { types[i] });\r\n                if (Modifier.isPrivate(method.getModifiers())) {\r\n                    throw new BulkBeanException(\"Property is private\", i);\r\n                }\r\n                setters_out[i] = method;\r\n            }\r\n        }\r\n    } catch (NoSuchMethodException e) {\r\n        throw new BulkBeanException(\"Cannot find specified property\", i);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.xml.XmlContent",
    "entityType": "class",
    "code": "private final Object source;\nprivate XmlContent(Object source) {\r\n    this.source = source;\r\n}\n@Override\r\npublic XmlContentAssert assertThat() {\r\n    return new XmlContentAssert(this.source);\r\n}\npublic static XmlContent from(Object source) {\r\n    return of(source);\r\n}\npublic static XmlContent of(Object source) {\r\n    if (source instanceof StringWriter) {\r\n        return of(source.toString());\r\n    }\r\n    return new XmlContent(source);\r\n}",
    "comment": "\n * {@link AssertProvider} to allow XML content assertions. Ultimately delegates\n * to {@link XmlAssert}.\n *\n * @author Phillip Webb\n "
  },
  {
    "entityId": "org.springframework.core.testfixture.xml.XmlContent#assertThat()",
    "entityType": "method",
    "code": "@Override\r\npublic XmlContentAssert assertThat() {\r\n    return new XmlContentAssert(this.source);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.xml.XmlContent#from(Object)",
    "entityType": "method",
    "code": "public static XmlContent from(Object source) {\r\n    return of(source);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.xml.XmlContent#of(Object)",
    "entityType": "method",
    "code": "public static XmlContent of(Object source) {\r\n    if (source instanceof StringWriter) {\r\n        return of(source.toString());\r\n    }\r\n    return new XmlContent(source);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BulkBeanException",
    "entityType": "class",
    "code": "private int index;\nprivate Throwable cause;\npublic BulkBeanException(String message, int index) {\r\n    super(message);\r\n    this.index = index;\r\n}\npublic BulkBeanException(Throwable cause, int index) {\r\n    super(cause.getMessage());\r\n    this.index = index;\r\n    this.cause = cause;\r\n}\npublic int getIndex() {\r\n    return index;\r\n}\n@Override\r\npublic Throwable getCause() {\r\n    return cause;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BulkBeanException#getIndex()",
    "entityType": "method",
    "code": "public int getIndex() {\r\n    return index;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BulkBeanException#getCause()",
    "entityType": "method",
    "code": "@Override\r\npublic Throwable getCause() {\r\n    return cause;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.xml.XmlContentAssert",
    "entityType": "class",
    "code": "XmlContentAssert(Object actual) {\r\n    super(actual, XmlContentAssert.class);\r\n}\npublic XmlContentAssert isSimilarTo(Object control) {\r\n    XmlAssert.assertThat(super.actual).and(control).areSimilar();\r\n    return this;\r\n}\npublic XmlContentAssert isSimilarTo(Object control, Predicate<Node> nodeFilter) {\r\n    XmlAssert.assertThat(super.actual).and(control).withNodeFilter(nodeFilter).areSimilar();\r\n    return this;\r\n}\npublic XmlContentAssert isSimilarTo(String control, DifferenceEvaluator differenceEvaluator) {\r\n    XmlAssert.assertThat(super.actual).and(control).withDifferenceEvaluator(differenceEvaluator).areSimilar();\r\n    return this;\r\n}\npublic XmlContentAssert isSimilarToIgnoringWhitespace(Object control) {\r\n    XmlAssert.assertThat(super.actual).and(control).ignoreWhitespace().areSimilar();\r\n    return this;\r\n}\npublic XmlContentAssert isSimilarToIgnoringWhitespace(String control, NodeMatcher nodeMatcher) {\r\n    XmlAssert.assertThat(super.actual).and(control).ignoreWhitespace().withNodeMatcher(nodeMatcher).areSimilar();\r\n    return this;\r\n}",
    "comment": "\n * Assertions exposed by {@link XmlContent}.\n *\n * @author Phillip Webb\n "
  },
  {
    "entityId": "org.springframework.core.testfixture.xml.XmlContentAssert#isSimilarTo(Object)",
    "entityType": "method",
    "code": "public XmlContentAssert isSimilarTo(Object control) {\r\n    XmlAssert.assertThat(super.actual).and(control).areSimilar();\r\n    return this;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.xml.XmlContentAssert#isSimilarTo(Object,Predicate<Node>)",
    "entityType": "method",
    "code": "public XmlContentAssert isSimilarTo(Object control, Predicate<Node> nodeFilter) {\r\n    XmlAssert.assertThat(super.actual).and(control).withNodeFilter(nodeFilter).areSimilar();\r\n    return this;\r\n}",
    "comment": ""
  }
]