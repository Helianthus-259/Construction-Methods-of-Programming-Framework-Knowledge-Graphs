[
  {
    "entityId": "org.springframework.cglib.proxy.InterfaceMaker#firstInstance(Class)",
    "entityType": "method",
    "code": "@Override\r\nprotected Object firstInstance(Class type) {\r\n    return type;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.InterfaceMaker#nextInstance(Object)",
    "entityType": "method",
    "code": "@Override\r\nprotected Object nextInstance(Object instance) {\r\n    throw new IllegalStateException(\"InterfaceMaker does not cache\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.InterfaceMaker#generateClass(ClassVisitor)",
    "entityType": "method",
    "code": "@Override\r\npublic void generateClass(ClassVisitor v) throws Exception {\r\n    ClassEmitter ce = new ClassEmitter(v);\r\n    ce.begin_class(Constants.V1_8, Constants.ACC_PUBLIC | Constants.ACC_INTERFACE | Constants.ACC_ABSTRACT, getClassName(), null, null, Constants.SOURCE_FILE);\r\n    for (Iterator it = signatures.keySet().iterator(); it.hasNext(); ) {\r\n        Signature sig = (Signature) it.next();\r\n        Type[] exceptions = (Type[]) signatures.get(sig);\r\n        ce.begin_method(Constants.ACC_PUBLIC | Constants.ACC_ABSTRACT, sig, exceptions).end_method();\r\n    }\r\n    ce.end_class();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.InvocationHandler",
    "entityType": "class",
    "code": "/**\r\n * @see java.lang.reflect.InvocationHandler#invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])\r\n */\r\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable;",
    "comment": "\n * {@link java.lang.reflect.InvocationHandler} replacement (unavailable under JDK 1.2).\n * This callback type is primarily for use by the {@link Proxy} class but\n * may be used with {@link Enhancer} as well.\n * @author Neeme Praks <a href=\"mailto:neeme@apache.org\">neeme@apache.org</a>\n * @version $Id: InvocationHandler.java,v 1.3 2004/06/24 21:15:20 herbyderby Exp $\n "
  },
  {
    "entityId": "org.springframework.cglib.proxy.InvocationHandler#invoke(Object,Method,Object[])",
    "entityType": "method",
    "code": "/**\r\n * @see java.lang.reflect.InvocationHandler#invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])\r\n */\r\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable;",
    "comment": "\n     * @see java.lang.reflect.InvocationHandler#invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])\n     "
  },
  {
    "entityId": "org.springframework.cglib.proxy.InvocationHandlerGenerator",
    "entityType": "class",
    "code": "public static final InvocationHandlerGenerator INSTANCE = new InvocationHandlerGenerator();\nprivate static final Type INVOCATION_HANDLER = TypeUtils.parseType(\"org.springframework.cglib.proxy.InvocationHandler\");\nprivate static final Type UNDECLARED_THROWABLE_EXCEPTION = TypeUtils.parseType(\"org.springframework.cglib.proxy.UndeclaredThrowableException\");\nprivate static final Type METHOD = TypeUtils.parseType(\"java.lang.reflect.Method\");\nprivate static final Signature INVOKE = TypeUtils.parseSignature(\"Object invoke(Object, java.lang.reflect.Method, Object[])\");\n@Override\r\npublic void generate(ClassEmitter ce, Context context, List methods) {\r\n    for (Iterator it = methods.iterator(); it.hasNext(); ) {\r\n        MethodInfo method = (MethodInfo) it.next();\r\n        Signature impl = context.getImplSignature(method);\r\n        ce.declare_field(Constants.PRIVATE_FINAL_STATIC, impl.getName(), METHOD, null);\r\n        CodeEmitter e = context.beginMethod(ce, method);\r\n        Block handler = e.begin_block();\r\n        context.emitCallback(e, context.getIndex(method));\r\n        e.load_this();\r\n        e.getfield(impl.getName());\r\n        e.create_arg_array();\r\n        e.invoke_interface(INVOCATION_HANDLER, INVOKE);\r\n        e.unbox(method.getSignature().getReturnType());\r\n        e.return_value();\r\n        handler.end();\r\n        EmitUtils.wrap_undeclared_throwable(e, handler, method.getExceptionTypes(), UNDECLARED_THROWABLE_EXCEPTION);\r\n        e.end_method();\r\n    }\r\n}\n@Override\r\npublic void generateStatic(CodeEmitter e, Context context, List methods) {\r\n    for (Iterator it = methods.iterator(); it.hasNext(); ) {\r\n        MethodInfo method = (MethodInfo) it.next();\r\n        EmitUtils.load_method(e, method);\r\n        e.putfield(context.getImplSignature(method).getName());\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.InvocationHandlerGenerator#generate(ClassEmitter,Context,List)",
    "entityType": "method",
    "code": "@Override\r\npublic void generate(ClassEmitter ce, Context context, List methods) {\r\n    for (Iterator it = methods.iterator(); it.hasNext(); ) {\r\n        MethodInfo method = (MethodInfo) it.next();\r\n        Signature impl = context.getImplSignature(method);\r\n        ce.declare_field(Constants.PRIVATE_FINAL_STATIC, impl.getName(), METHOD, null);\r\n        CodeEmitter e = context.beginMethod(ce, method);\r\n        Block handler = e.begin_block();\r\n        context.emitCallback(e, context.getIndex(method));\r\n        e.load_this();\r\n        e.getfield(impl.getName());\r\n        e.create_arg_array();\r\n        e.invoke_interface(INVOCATION_HANDLER, INVOKE);\r\n        e.unbox(method.getSignature().getReturnType());\r\n        e.return_value();\r\n        handler.end();\r\n        EmitUtils.wrap_undeclared_throwable(e, handler, method.getExceptionTypes(), UNDECLARED_THROWABLE_EXCEPTION);\r\n        e.end_method();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.InvocationHandlerGenerator#generateStatic(CodeEmitter,Context,List)",
    "entityType": "method",
    "code": "@Override\r\npublic void generateStatic(CodeEmitter e, Context context, List methods) {\r\n    for (Iterator it = methods.iterator(); it.hasNext(); ) {\r\n        MethodInfo method = (MethodInfo) it.next();\r\n        EmitUtils.load_method(e, method);\r\n        e.putfield(context.getImplSignature(method).getName());\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.LazyLoader",
    "entityType": "class",
    "code": "/**\r\n * Return the object which the original method invocation should be\r\n * dispatched. Called as soon as the first lazily-loaded method in\r\n * the enhanced instance is invoked. The same object is then used\r\n * for every future method call to the proxy instance.\r\n * @return an object that can invoke the method\r\n */\r\nObject loadObject() throws Exception;",
    "comment": "\n * Lazy-loading {@link Enhancer} callback.\n "
  },
  {
    "entityId": "org.springframework.cglib.proxy.LazyLoader#loadObject()",
    "entityType": "method",
    "code": "/**\r\n * Return the object which the original method invocation should be\r\n * dispatched. Called as soon as the first lazily-loaded method in\r\n * the enhanced instance is invoked. The same object is then used\r\n * for every future method call to the proxy instance.\r\n * @return an object that can invoke the method\r\n */\r\nObject loadObject() throws Exception;",
    "comment": "\n     * Return the object which the original method invocation should be\n     * dispatched. Called as soon as the first lazily-loaded method in\n     * the enhanced instance is invoked. The same object is then used\n     * for every future method call to the proxy instance.\n     * @return an object that can invoke the method\n     "
  },
  {
    "entityId": "org.springframework.cglib.proxy.LazyLoaderGenerator",
    "entityType": "class",
    "code": "public static final LazyLoaderGenerator INSTANCE = new LazyLoaderGenerator();\nprivate static final Signature LOAD_OBJECT = TypeUtils.parseSignature(\"Object loadObject()\");\nprivate static final Type LAZY_LOADER = TypeUtils.parseType(\"org.springframework.cglib.proxy.LazyLoader\");\n@Override\r\npublic void generate(ClassEmitter ce, Context context, List methods) {\r\n    Set indexes = new HashSet();\r\n    for (Iterator it = methods.iterator(); it.hasNext(); ) {\r\n        MethodInfo method = (MethodInfo) it.next();\r\n        if (TypeUtils.isProtected(method.getModifiers())) {\r\n            // ignore protected methods\r\n        } else {\r\n            int index = context.getIndex(method);\r\n            indexes.add(index);\r\n            CodeEmitter e = context.beginMethod(ce, method);\r\n            e.load_this();\r\n            e.dup();\r\n            e.invoke_virtual_this(loadMethod(index));\r\n            e.checkcast(method.getClassInfo().getType());\r\n            e.load_args();\r\n            e.invoke(method);\r\n            e.return_value();\r\n            e.end_method();\r\n        }\r\n    }\r\n    for (Iterator it = indexes.iterator(); it.hasNext(); ) {\r\n        int index = ((Integer) it.next());\r\n        String delegate = \"CGLIB$LAZY_LOADER_\" + index;\r\n        ce.declare_field(Constants.ACC_PRIVATE, delegate, Constants.TYPE_OBJECT, null);\r\n        CodeEmitter e = ce.begin_method(Constants.ACC_PRIVATE | Constants.ACC_SYNCHRONIZED | Constants.ACC_FINAL, loadMethod(index), null);\r\n        e.load_this();\r\n        e.getfield(delegate);\r\n        e.dup();\r\n        Label end = e.make_label();\r\n        e.ifnonnull(end);\r\n        e.pop();\r\n        e.load_this();\r\n        context.emitCallback(e, index);\r\n        e.invoke_interface(LAZY_LOADER, LOAD_OBJECT);\r\n        e.dup_x1();\r\n        e.putfield(delegate);\r\n        e.mark(end);\r\n        e.return_value();\r\n        e.end_method();\r\n    }\r\n}\nprivate Signature loadMethod(int index) {\r\n    return new Signature(\"CGLIB$LOAD_PRIVATE_\" + index, Constants.TYPE_OBJECT, Constants.TYPES_EMPTY);\r\n}\n@Override\r\npublic void generateStatic(CodeEmitter e, Context context, List methods) ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.LazyLoaderGenerator#generate(ClassEmitter,Context,List)",
    "entityType": "method",
    "code": "@Override\r\npublic void generate(ClassEmitter ce, Context context, List methods) {\r\n    Set indexes = new HashSet();\r\n    for (Iterator it = methods.iterator(); it.hasNext(); ) {\r\n        MethodInfo method = (MethodInfo) it.next();\r\n        if (TypeUtils.isProtected(method.getModifiers())) {\r\n            // ignore protected methods\r\n        } else {\r\n            int index = context.getIndex(method);\r\n            indexes.add(index);\r\n            CodeEmitter e = context.beginMethod(ce, method);\r\n            e.load_this();\r\n            e.dup();\r\n            e.invoke_virtual_this(loadMethod(index));\r\n            e.checkcast(method.getClassInfo().getType());\r\n            e.load_args();\r\n            e.invoke(method);\r\n            e.return_value();\r\n            e.end_method();\r\n        }\r\n    }\r\n    for (Iterator it = indexes.iterator(); it.hasNext(); ) {\r\n        int index = ((Integer) it.next());\r\n        String delegate = \"CGLIB$LAZY_LOADER_\" + index;\r\n        ce.declare_field(Constants.ACC_PRIVATE, delegate, Constants.TYPE_OBJECT, null);\r\n        CodeEmitter e = ce.begin_method(Constants.ACC_PRIVATE | Constants.ACC_SYNCHRONIZED | Constants.ACC_FINAL, loadMethod(index), null);\r\n        e.load_this();\r\n        e.getfield(delegate);\r\n        e.dup();\r\n        Label end = e.make_label();\r\n        e.ifnonnull(end);\r\n        e.pop();\r\n        e.load_this();\r\n        context.emitCallback(e, index);\r\n        e.invoke_interface(LAZY_LOADER, LOAD_OBJECT);\r\n        e.dup_x1();\r\n        e.putfield(delegate);\r\n        e.mark(end);\r\n        e.return_value();\r\n        e.end_method();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.LazyLoaderGenerator#loadMethod(int)",
    "entityType": "method",
    "code": "private Signature loadMethod(int index) {\r\n    return new Signature(\"CGLIB$LOAD_PRIVATE_\" + index, Constants.TYPE_OBJECT, Constants.TYPES_EMPTY);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.LazyLoaderGenerator#generateStatic(CodeEmitter,Context,List)",
    "entityType": "method",
    "code": "@Override\r\npublic void generateStatic(CodeEmitter e, Context context, List methods) ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.MethodInterceptor",
    "entityType": "class",
    "code": "/**\r\n * All generated proxied methods call this method instead of the original method.\r\n * The original method may either be invoked by normal reflection using the Method object,\r\n * or by using the MethodProxy (faster).\r\n * @param obj \"this\", the enhanced object\r\n * @param method intercepted Method\r\n * @param args argument array; primitive types are wrapped\r\n * @param proxy used to invoke super (non-intercepted method); may be called\r\n * as many times as needed\r\n * @throws Throwable any exception may be thrown; if so, super method will not be invoked\r\n * @return any value compatible with the signature of the proxied method. Method returning void will ignore this value.\r\n * @see MethodProxy\r\n */\r\npublic Object intercept(Object obj, java.lang.reflect.Method method, Object[] args, MethodProxy proxy) throws Throwable;",
    "comment": "\n * General-purpose {@link Enhancer} callback which provides for \"around advice\".\n * @author Juozas Baliuka <a href=\"mailto:baliuka@mwm.lt\">baliuka@mwm.lt</a>\n * @version $Id: MethodInterceptor.java,v 1.8 2004/06/24 21:15:20 herbyderby Exp $\n "
  },
  {
    "entityId": "org.springframework.cglib.proxy.MethodInterceptor#intercept(Object,java.lang.reflect.Method,Object[],MethodProxy)",
    "entityType": "method",
    "code": "/**\r\n * All generated proxied methods call this method instead of the original method.\r\n * The original method may either be invoked by normal reflection using the Method object,\r\n * or by using the MethodProxy (faster).\r\n * @param obj \"this\", the enhanced object\r\n * @param method intercepted Method\r\n * @param args argument array; primitive types are wrapped\r\n * @param proxy used to invoke super (non-intercepted method); may be called\r\n * as many times as needed\r\n * @throws Throwable any exception may be thrown; if so, super method will not be invoked\r\n * @return any value compatible with the signature of the proxied method. Method returning void will ignore this value.\r\n * @see MethodProxy\r\n */\r\npublic Object intercept(Object obj, java.lang.reflect.Method method, Object[] args, MethodProxy proxy) throws Throwable;",
    "comment": "\n     * All generated proxied methods call this method instead of the original method.\n     * The original method may either be invoked by normal reflection using the Method object,\n     * or by using the MethodProxy (faster).\n     * @param obj \"this\", the enhanced object\n     * @param method intercepted Method\n     * @param args argument array; primitive types are wrapped\n     * @param proxy used to invoke super (non-intercepted method); may be called\n     * as many times as needed\n     * @throws Throwable any exception may be thrown; if so, super method will not be invoked\n     * @return any value compatible with the signature of the proxied method. Method returning void will ignore this value.\n     * @see MethodProxy\n     "
  },
  {
    "entityId": "org.springframework.cglib.proxy.MethodInterceptorGenerator",
    "entityType": "class",
    "code": "public static final MethodInterceptorGenerator INSTANCE = new MethodInterceptorGenerator();\nstatic final String EMPTY_ARGS_NAME = \"CGLIB$emptyArgs\";\nstatic final String FIND_PROXY_NAME = \"CGLIB$findMethodProxy\";\nstatic final Class[] FIND_PROXY_TYPES = { Signature.class };\nprivate static final Type ABSTRACT_METHOD_ERROR = TypeUtils.parseType(\"AbstractMethodError\");\nprivate static final Type METHOD = TypeUtils.parseType(\"java.lang.reflect.Method\");\nprivate static final Type REFLECT_UTILS = TypeUtils.parseType(\"org.springframework.cglib.core.ReflectUtils\");\nprivate static final Type METHOD_PROXY = TypeUtils.parseType(\"org.springframework.cglib.proxy.MethodProxy\");\nprivate static final Type METHOD_INTERCEPTOR = TypeUtils.parseType(\"org.springframework.cglib.proxy.MethodInterceptor\");\nprivate static final Signature GET_DECLARED_METHODS = TypeUtils.parseSignature(\"java.lang.reflect.Method[] getDeclaredMethods()\");\nprivate static final Signature FIND_METHODS = TypeUtils.parseSignature(\"java.lang.reflect.Method[] findMethods(String[], java.lang.reflect.Method[])\");\nprivate static final Signature MAKE_PROXY = new Signature(\"create\", METHOD_PROXY, new Type[] { Constants.TYPE_CLASS, Constants.TYPE_CLASS, Constants.TYPE_STRING, Constants.TYPE_STRING, Constants.TYPE_STRING });\nprivate static final Signature INTERCEPT = new Signature(\"intercept\", Constants.TYPE_OBJECT, new Type[] { Constants.TYPE_OBJECT, METHOD, Constants.TYPE_OBJECT_ARRAY, METHOD_PROXY });\nprivate static final Signature FIND_PROXY = new Signature(FIND_PROXY_NAME, METHOD_PROXY, new Type[] { Constants.TYPE_SIGNATURE });\nprivate static final Signature TO_STRING = TypeUtils.parseSignature(\"String toString()\");\nprivate static final Transformer METHOD_TO_CLASS = value -> ((MethodInfo) value).getClassInfo();\nprivate String getMethodField(Signature impl) {\r\n    return impl.getName() + \"$Method\";\r\n}\nprivate String getMethodProxyField(Signature impl) {\r\n    return impl.getName() + \"$Proxy\";\r\n}\n@Override\r\npublic void generate(ClassEmitter ce, Context context, List methods) {\r\n    Map sigMap = new HashMap();\r\n    for (Iterator it = methods.iterator(); it.hasNext(); ) {\r\n        MethodInfo method = (MethodInfo) it.next();\r\n        Signature sig = method.getSignature();\r\n        Signature impl = context.getImplSignature(method);\r\n        String methodField = getMethodField(impl);\r\n        String methodProxyField = getMethodProxyField(impl);\r\n        sigMap.put(sig.toString(), methodProxyField);\r\n        ce.declare_field(Constants.PRIVATE_FINAL_STATIC, methodField, METHOD, null);\r\n        ce.declare_field(Constants.PRIVATE_FINAL_STATIC, methodProxyField, METHOD_PROXY, null);\r\n        ce.declare_field(Constants.PRIVATE_FINAL_STATIC, EMPTY_ARGS_NAME, Constants.TYPE_OBJECT_ARRAY, null);\r\n        CodeEmitter e;\r\n        // access method\r\n        e = ce.begin_method(Constants.ACC_FINAL, impl, method.getExceptionTypes());\r\n        superHelper(e, method, context);\r\n        e.return_value();\r\n        e.end_method();\r\n        // around method\r\n        e = context.beginMethod(ce, method);\r\n        Label nullInterceptor = e.make_label();\r\n        context.emitCallback(e, context.getIndex(method));\r\n        e.dup();\r\n        e.ifnull(nullInterceptor);\r\n        e.load_this();\r\n        e.getfield(methodField);\r\n        if (sig.getArgumentTypes().length == 0) {\r\n            e.getfield(EMPTY_ARGS_NAME);\r\n        } else {\r\n            e.create_arg_array();\r\n        }\r\n        e.getfield(methodProxyField);\r\n        e.invoke_interface(METHOD_INTERCEPTOR, INTERCEPT);\r\n        e.unbox_or_zero(sig.getReturnType());\r\n        e.return_value();\r\n        e.mark(nullInterceptor);\r\n        superHelper(e, method, context);\r\n        e.return_value();\r\n        e.end_method();\r\n    }\r\n    generateFindProxy(ce, sigMap);\r\n}\nprivate static void superHelper(CodeEmitter e, MethodInfo method, Context context) {\r\n    if (TypeUtils.isAbstract(method.getModifiers())) {\r\n        e.throw_exception(ABSTRACT_METHOD_ERROR, method.toString() + \" is abstract\");\r\n    } else {\r\n        e.load_this();\r\n        context.emitLoadArgsAndInvoke(e, method);\r\n    }\r\n}\n@Override\r\npublic void generateStatic(CodeEmitter e, Context context, List methods) throws Exception {\r\n    /* generates:\r\n           static {\r\n             Class thisClass = Class.forName(\"NameOfThisClass\");\r\n             Class cls = Class.forName(\"java.lang.Object\");\r\n             String[] sigs = new String[]{ \"toString\", \"()Ljava/lang/String;\", ... };\r\n             Method[] methods = cls.getDeclaredMethods();\r\n             methods = ReflectUtils.findMethods(sigs, methods);\r\n             METHOD_0 = methods[0];\r\n             CGLIB$ACCESS_0 = MethodProxy.create(cls, thisClass, \"()Ljava/lang/String;\", \"toString\", \"CGLIB$ACCESS_0\");\r\n             ...\r\n           }\r\n        */\r\n    e.push(0);\r\n    e.newarray();\r\n    e.putfield(EMPTY_ARGS_NAME);\r\n    Local thisclass = e.make_local();\r\n    Local declaringclass = e.make_local();\r\n    EmitUtils.load_class_this(e);\r\n    e.store_local(thisclass);\r\n    Map methodsByClass = CollectionUtils.bucket(methods, METHOD_TO_CLASS);\r\n    for (Iterator i = methodsByClass.keySet().iterator(); i.hasNext(); ) {\r\n        ClassInfo classInfo = (ClassInfo) i.next();\r\n        List classMethods = (List) methodsByClass.get(classInfo);\r\n        e.push(2 * classMethods.size());\r\n        e.newarray(Constants.TYPE_STRING);\r\n        for (int index = 0; index < classMethods.size(); index++) {\r\n            MethodInfo method = (MethodInfo) classMethods.get(index);\r\n            Signature sig = method.getSignature();\r\n            e.dup();\r\n            e.push(2 * index);\r\n            e.push(sig.getName());\r\n            e.aastore();\r\n            e.dup();\r\n            e.push(2 * index + 1);\r\n            e.push(sig.getDescriptor());\r\n            e.aastore();\r\n        }\r\n        EmitUtils.load_class(e, classInfo.getType());\r\n        e.dup();\r\n        e.store_local(declaringclass);\r\n        e.invoke_virtual(Constants.TYPE_CLASS, GET_DECLARED_METHODS);\r\n        e.invoke_static(REFLECT_UTILS, FIND_METHODS);\r\n        for (int index = 0; index < classMethods.size(); index++) {\r\n            MethodInfo method = (MethodInfo) classMethods.get(index);\r\n            Signature sig = method.getSignature();\r\n            Signature impl = context.getImplSignature(method);\r\n            e.dup();\r\n            e.push(index);\r\n            e.array_load(METHOD);\r\n            e.putfield(getMethodField(impl));\r\n            e.load_local(declaringclass);\r\n            e.load_local(thisclass);\r\n            e.push(sig.getDescriptor());\r\n            e.push(sig.getName());\r\n            e.push(impl.getName());\r\n            e.invoke_static(METHOD_PROXY, MAKE_PROXY);\r\n            e.putfield(getMethodProxyField(impl));\r\n        }\r\n        e.pop();\r\n    }\r\n}\npublic void generateFindProxy(ClassEmitter ce, final Map sigMap) {\r\n    final CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC | Constants.ACC_STATIC, FIND_PROXY, null);\r\n    e.load_arg(0);\r\n    e.invoke_virtual(Constants.TYPE_OBJECT, TO_STRING);\r\n    ObjectSwitchCallback callback = new ObjectSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(Object key, Label end) {\r\n            e.getfield((String) sigMap.get(key));\r\n            e.return_value();\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            e.aconst_null();\r\n            e.return_value();\r\n        }\r\n    };\r\n    EmitUtils.string_switch(e, (String[]) sigMap.keySet().toArray(new String[0]), Constants.SWITCH_STYLE_HASH, callback);\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.MethodInterceptorGenerator#getMethodField(Signature)",
    "entityType": "method",
    "code": "private String getMethodField(Signature impl) {\r\n    return impl.getName() + \"$Method\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.MethodInterceptorGenerator#getMethodProxyField(Signature)",
    "entityType": "method",
    "code": "private String getMethodProxyField(Signature impl) {\r\n    return impl.getName() + \"$Proxy\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.MethodInterceptorGenerator#generate(ClassEmitter,Context,List)",
    "entityType": "method",
    "code": "@Override\r\npublic void generate(ClassEmitter ce, Context context, List methods) {\r\n    Map sigMap = new HashMap();\r\n    for (Iterator it = methods.iterator(); it.hasNext(); ) {\r\n        MethodInfo method = (MethodInfo) it.next();\r\n        Signature sig = method.getSignature();\r\n        Signature impl = context.getImplSignature(method);\r\n        String methodField = getMethodField(impl);\r\n        String methodProxyField = getMethodProxyField(impl);\r\n        sigMap.put(sig.toString(), methodProxyField);\r\n        ce.declare_field(Constants.PRIVATE_FINAL_STATIC, methodField, METHOD, null);\r\n        ce.declare_field(Constants.PRIVATE_FINAL_STATIC, methodProxyField, METHOD_PROXY, null);\r\n        ce.declare_field(Constants.PRIVATE_FINAL_STATIC, EMPTY_ARGS_NAME, Constants.TYPE_OBJECT_ARRAY, null);\r\n        CodeEmitter e;\r\n        // access method\r\n        e = ce.begin_method(Constants.ACC_FINAL, impl, method.getExceptionTypes());\r\n        superHelper(e, method, context);\r\n        e.return_value();\r\n        e.end_method();\r\n        // around method\r\n        e = context.beginMethod(ce, method);\r\n        Label nullInterceptor = e.make_label();\r\n        context.emitCallback(e, context.getIndex(method));\r\n        e.dup();\r\n        e.ifnull(nullInterceptor);\r\n        e.load_this();\r\n        e.getfield(methodField);\r\n        if (sig.getArgumentTypes().length == 0) {\r\n            e.getfield(EMPTY_ARGS_NAME);\r\n        } else {\r\n            e.create_arg_array();\r\n        }\r\n        e.getfield(methodProxyField);\r\n        e.invoke_interface(METHOD_INTERCEPTOR, INTERCEPT);\r\n        e.unbox_or_zero(sig.getReturnType());\r\n        e.return_value();\r\n        e.mark(nullInterceptor);\r\n        superHelper(e, method, context);\r\n        e.return_value();\r\n        e.end_method();\r\n    }\r\n    generateFindProxy(ce, sigMap);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.MethodInterceptorGenerator#superHelper(CodeEmitter,MethodInfo,Context)",
    "entityType": "method",
    "code": "private static void superHelper(CodeEmitter e, MethodInfo method, Context context) {\r\n    if (TypeUtils.isAbstract(method.getModifiers())) {\r\n        e.throw_exception(ABSTRACT_METHOD_ERROR, method.toString() + \" is abstract\");\r\n    } else {\r\n        e.load_this();\r\n        context.emitLoadArgsAndInvoke(e, method);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.MethodInterceptorGenerator#generateStatic(CodeEmitter,Context,List)",
    "entityType": "method",
    "code": "@Override\r\npublic void generateStatic(CodeEmitter e, Context context, List methods) throws Exception {\r\n    /* generates:\r\n           static {\r\n             Class thisClass = Class.forName(\"NameOfThisClass\");\r\n             Class cls = Class.forName(\"java.lang.Object\");\r\n             String[] sigs = new String[]{ \"toString\", \"()Ljava/lang/String;\", ... };\r\n             Method[] methods = cls.getDeclaredMethods();\r\n             methods = ReflectUtils.findMethods(sigs, methods);\r\n             METHOD_0 = methods[0];\r\n             CGLIB$ACCESS_0 = MethodProxy.create(cls, thisClass, \"()Ljava/lang/String;\", \"toString\", \"CGLIB$ACCESS_0\");\r\n             ...\r\n           }\r\n        */\r\n    e.push(0);\r\n    e.newarray();\r\n    e.putfield(EMPTY_ARGS_NAME);\r\n    Local thisclass = e.make_local();\r\n    Local declaringclass = e.make_local();\r\n    EmitUtils.load_class_this(e);\r\n    e.store_local(thisclass);\r\n    Map methodsByClass = CollectionUtils.bucket(methods, METHOD_TO_CLASS);\r\n    for (Iterator i = methodsByClass.keySet().iterator(); i.hasNext(); ) {\r\n        ClassInfo classInfo = (ClassInfo) i.next();\r\n        List classMethods = (List) methodsByClass.get(classInfo);\r\n        e.push(2 * classMethods.size());\r\n        e.newarray(Constants.TYPE_STRING);\r\n        for (int index = 0; index < classMethods.size(); index++) {\r\n            MethodInfo method = (MethodInfo) classMethods.get(index);\r\n            Signature sig = method.getSignature();\r\n            e.dup();\r\n            e.push(2 * index);\r\n            e.push(sig.getName());\r\n            e.aastore();\r\n            e.dup();\r\n            e.push(2 * index + 1);\r\n            e.push(sig.getDescriptor());\r\n            e.aastore();\r\n        }\r\n        EmitUtils.load_class(e, classInfo.getType());\r\n        e.dup();\r\n        e.store_local(declaringclass);\r\n        e.invoke_virtual(Constants.TYPE_CLASS, GET_DECLARED_METHODS);\r\n        e.invoke_static(REFLECT_UTILS, FIND_METHODS);\r\n        for (int index = 0; index < classMethods.size(); index++) {\r\n            MethodInfo method = (MethodInfo) classMethods.get(index);\r\n            Signature sig = method.getSignature();\r\n            Signature impl = context.getImplSignature(method);\r\n            e.dup();\r\n            e.push(index);\r\n            e.array_load(METHOD);\r\n            e.putfield(getMethodField(impl));\r\n            e.load_local(declaringclass);\r\n            e.load_local(thisclass);\r\n            e.push(sig.getDescriptor());\r\n            e.push(sig.getName());\r\n            e.push(impl.getName());\r\n            e.invoke_static(METHOD_PROXY, MAKE_PROXY);\r\n            e.putfield(getMethodProxyField(impl));\r\n        }\r\n        e.pop();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.MethodInterceptorGenerator#generateFindProxy(ClassEmitter,Map)",
    "entityType": "method",
    "code": "public void generateFindProxy(ClassEmitter ce, final Map sigMap) {\r\n    final CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC | Constants.ACC_STATIC, FIND_PROXY, null);\r\n    e.load_arg(0);\r\n    e.invoke_virtual(Constants.TYPE_OBJECT, TO_STRING);\r\n    ObjectSwitchCallback callback = new ObjectSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(Object key, Label end) {\r\n            e.getfield((String) sigMap.get(key));\r\n            e.return_value();\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            e.aconst_null();\r\n            e.return_value();\r\n        }\r\n    };\r\n    EmitUtils.string_switch(e, (String[]) sigMap.keySet().toArray(new String[0]), Constants.SWITCH_STYLE_HASH, callback);\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.MethodProxy",
    "entityType": "class",
    "code": "private Signature sig1;\nprivate Signature sig2;\nprivate CreateInfo createInfo;\nprivate final Object initLock = new Object();\nprivate volatile FastClassInfo fastClassInfo;\n/**\r\n * For internal use by {@link Enhancer} only; see the {@link org.springframework.cglib.reflect.FastMethod} class\r\n * for similar functionality.\r\n */\r\npublic static MethodProxy create(Class c1, Class c2, String desc, String name1, String name2) {\r\n    MethodProxy proxy = new MethodProxy();\r\n    proxy.sig1 = new Signature(name1, desc);\r\n    proxy.sig2 = new Signature(name2, desc);\r\n    proxy.createInfo = new CreateInfo(c1, c2);\r\n    // SPRING PATCH BEGIN\r\n    if (c1 != Object.class && c1.isAssignableFrom(c2.getSuperclass()) && !Factory.class.isAssignableFrom(c2)) {\r\n        // Try early initialization for overridden methods on specifically purposed subclasses\r\n        try {\r\n            proxy.init();\r\n        } catch (CodeGenerationException ex) {\r\n            // Ignore - to be retried when actually needed later on (possibly not at all)\r\n        }\r\n    }\r\n    // SPRING PATCH END\r\n    return proxy;\r\n}\nprivate void init() {\r\n    /*\r\n\t\t * Using a volatile invariant allows us to initialize the FastClass and\r\n\t\t * method index pairs atomically.\r\n\t\t *\r\n\t\t * Double-checked locking is safe with volatile in Java 5.  Before 1.5 this\r\n\t\t * code could allow fastClassInfo to be instantiated more than once, which\r\n\t\t * appears to be benign.\r\n\t\t */\r\n    if (fastClassInfo == null) {\r\n        synchronized (initLock) {\r\n            if (fastClassInfo == null) {\r\n                CreateInfo ci = createInfo;\r\n                FastClassInfo fci = new FastClassInfo();\r\n                fci.f1 = helper(ci, ci.c1);\r\n                fci.f2 = helper(ci, ci.c2);\r\n                fci.i1 = fci.f1.getIndex(sig1);\r\n                fci.i2 = fci.f2.getIndex(sig2);\r\n                fastClassInfo = fci;\r\n                createInfo = null;\r\n            }\r\n        }\r\n    }\r\n}\nprivate static class FastClassInfo {\r\n\r\n    FastClass f1;\r\n\r\n    FastClass f2;\r\n\r\n    int i1;\r\n\r\n    int i2;\r\n}\nprivate static class CreateInfo {\r\n\r\n    Class c1;\r\n\r\n    Class c2;\r\n\r\n    NamingPolicy namingPolicy;\r\n\r\n    GeneratorStrategy strategy;\r\n\r\n    boolean attemptLoad;\r\n\r\n    public CreateInfo(Class c1, Class c2) {\r\n        this.c1 = c1;\r\n        this.c2 = c2;\r\n        AbstractClassGenerator fromEnhancer = AbstractClassGenerator.getCurrent();\r\n        if (fromEnhancer != null) {\r\n            namingPolicy = fromEnhancer.getNamingPolicy();\r\n            strategy = fromEnhancer.getStrategy();\r\n            attemptLoad = fromEnhancer.getAttemptLoad();\r\n        }\r\n    }\r\n}\nprivate static FastClass helper(CreateInfo ci, Class type) {\r\n    FastClass.Generator g = new FastClass.Generator();\r\n    g.setType(type);\r\n    // SPRING PATCH BEGIN\r\n    g.setContextClass(type);\r\n    // SPRING PATCH END\r\n    g.setClassLoader(ci.c2.getClassLoader());\r\n    g.setNamingPolicy(ci.namingPolicy);\r\n    g.setStrategy(ci.strategy);\r\n    g.setAttemptLoad(ci.attemptLoad);\r\n    return g.create();\r\n}\nprivate MethodProxy() {\r\n}\n/**\r\n * Return the signature of the proxied method.\r\n */\r\npublic Signature getSignature() {\r\n    return sig1;\r\n}\n/**\r\n * Return the name of the synthetic method created by CGLIB which is\r\n * used by {@link #invokeSuper} to invoke the superclass\r\n * (non-intercepted) method implementation. The parameter types are\r\n * the same as the proxied method.\r\n */\r\npublic String getSuperName() {\r\n    return sig2.getName();\r\n}\n/**\r\n * Return the {@link org.springframework.cglib.reflect.FastClass} method index\r\n * for the method used by {@link #invokeSuper}. This index uniquely\r\n * identifies the method within the generated proxy, and therefore\r\n * can be useful to reference external metadata.\r\n * @see #getSuperName\r\n */\r\npublic int getSuperIndex() {\r\n    init();\r\n    return fastClassInfo.i2;\r\n}\n// For testing\r\nFastClass getFastClass() {\r\n    init();\r\n    return fastClassInfo.f1;\r\n}\n// For testing\r\nFastClass getSuperFastClass() {\r\n    init();\r\n    return fastClassInfo.f2;\r\n}\n/**\r\n * Return the <code>MethodProxy</code> used when intercepting the method\r\n * matching the given signature.\r\n * @param type the class generated by Enhancer\r\n * @param sig the signature to match\r\n * @return the MethodProxy instance, or null if no applicable matching method is found\r\n * @throws IllegalArgumentException if the Class was not created by Enhancer or does not use a MethodInterceptor\r\n */\r\npublic static MethodProxy find(Class type, Signature sig) {\r\n    try {\r\n        Method m = type.getDeclaredMethod(MethodInterceptorGenerator.FIND_PROXY_NAME, MethodInterceptorGenerator.FIND_PROXY_TYPES);\r\n        return (MethodProxy) m.invoke(null, new Object[] { sig });\r\n    } catch (NoSuchMethodException ex) {\r\n        throw new IllegalArgumentException(\"Class \" + type + \" does not use a MethodInterceptor\");\r\n    } catch (IllegalAccessException | InvocationTargetException ex) {\r\n        throw new CodeGenerationException(ex);\r\n    }\r\n}\n/**\r\n * Invoke the original method, on a different object of the same type.\r\n * @param obj the compatible object; recursion will result if you use the object passed as the first\r\n * argument to the MethodInterceptor (usually not what you want)\r\n * @param args the arguments passed to the intercepted method; you may substitute a different\r\n * argument array as long as the types are compatible\r\n * @throws Throwable the bare exceptions thrown by the called method are passed through\r\n * without wrapping in an <code>InvocationTargetException</code>\r\n * @see MethodInterceptor#intercept\r\n */\r\npublic Object invoke(Object obj, Object[] args) throws Throwable {\r\n    try {\r\n        init();\r\n        FastClassInfo fci = fastClassInfo;\r\n        return fci.f1.invoke(fci.i1, obj, args);\r\n    } catch (InvocationTargetException ex) {\r\n        throw ex.getTargetException();\r\n    } catch (IllegalArgumentException ex) {\r\n        if (fastClassInfo.i1 < 0) {\r\n            throw new IllegalArgumentException(\"Protected method: \" + sig1);\r\n        }\r\n        throw ex;\r\n    }\r\n}\n/**\r\n * Invoke the original (super) method on the specified object.\r\n * @param obj the enhanced object, must be the object passed as the first\r\n * argument to the MethodInterceptor\r\n * @param args the arguments passed to the intercepted method; you may substitute a different\r\n * argument array as long as the types are compatible\r\n * @throws Throwable the bare exceptions thrown by the called method are passed through\r\n * without wrapping in an <code>InvocationTargetException</code>\r\n * @see MethodInterceptor#intercept\r\n */\r\npublic Object invokeSuper(Object obj, Object[] args) throws Throwable {\r\n    try {\r\n        init();\r\n        FastClassInfo fci = fastClassInfo;\r\n        return fci.f2.invoke(fci.i2, obj, args);\r\n    } catch (InvocationTargetException e) {\r\n        throw e.getTargetException();\r\n    }\r\n}",
    "comment": "\n * Classes generated by {@link Enhancer} pass this object to the\n * registered {@link MethodInterceptor} objects when an intercepted method is invoked. It can\n * be used to either invoke the original method, or call the same method on a different\n * object of the same type.\n * @version $Id: MethodProxy.java,v 1.16 2009/01/11 20:09:48 herbyderby Exp $\n "
  },
  {
    "entityId": "org.springframework.cglib.proxy.MethodProxy#create(Class,Class,String,String,String)",
    "entityType": "method",
    "code": "/**\r\n * For internal use by {@link Enhancer} only; see the {@link org.springframework.cglib.reflect.FastMethod} class\r\n * for similar functionality.\r\n */\r\npublic static MethodProxy create(Class c1, Class c2, String desc, String name1, String name2) {\r\n    MethodProxy proxy = new MethodProxy();\r\n    proxy.sig1 = new Signature(name1, desc);\r\n    proxy.sig2 = new Signature(name2, desc);\r\n    proxy.createInfo = new CreateInfo(c1, c2);\r\n    // SPRING PATCH BEGIN\r\n    if (c1 != Object.class && c1.isAssignableFrom(c2.getSuperclass()) && !Factory.class.isAssignableFrom(c2)) {\r\n        // Try early initialization for overridden methods on specifically purposed subclasses\r\n        try {\r\n            proxy.init();\r\n        } catch (CodeGenerationException ex) {\r\n            // Ignore - to be retried when actually needed later on (possibly not at all)\r\n        }\r\n    }\r\n    // SPRING PATCH END\r\n    return proxy;\r\n}",
    "comment": "\n\t * For internal use by {@link Enhancer} only; see the {@link org.springframework.cglib.reflect.FastMethod} class\n\t * for similar functionality.\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.MethodProxy#init()",
    "entityType": "method",
    "code": "private void init() {\r\n    /*\r\n\t\t * Using a volatile invariant allows us to initialize the FastClass and\r\n\t\t * method index pairs atomically.\r\n\t\t *\r\n\t\t * Double-checked locking is safe with volatile in Java 5.  Before 1.5 this\r\n\t\t * code could allow fastClassInfo to be instantiated more than once, which\r\n\t\t * appears to be benign.\r\n\t\t */\r\n    if (fastClassInfo == null) {\r\n        synchronized (initLock) {\r\n            if (fastClassInfo == null) {\r\n                CreateInfo ci = createInfo;\r\n                FastClassInfo fci = new FastClassInfo();\r\n                fci.f1 = helper(ci, ci.c1);\r\n                fci.f2 = helper(ci, ci.c2);\r\n                fci.i1 = fci.f1.getIndex(sig1);\r\n                fci.i2 = fci.f2.getIndex(sig2);\r\n                fastClassInfo = fci;\r\n                createInfo = null;\r\n            }\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.MethodProxy#helper(CreateInfo,Class)",
    "entityType": "method",
    "code": "private static FastClass helper(CreateInfo ci, Class type) {\r\n    FastClass.Generator g = new FastClass.Generator();\r\n    g.setType(type);\r\n    // SPRING PATCH BEGIN\r\n    g.setContextClass(type);\r\n    // SPRING PATCH END\r\n    g.setClassLoader(ci.c2.getClassLoader());\r\n    g.setNamingPolicy(ci.namingPolicy);\r\n    g.setStrategy(ci.strategy);\r\n    g.setAttemptLoad(ci.attemptLoad);\r\n    return g.create();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.MethodProxy#getSignature()",
    "entityType": "method",
    "code": "/**\r\n * Return the signature of the proxied method.\r\n */\r\npublic Signature getSignature() {\r\n    return sig1;\r\n}",
    "comment": "\n\t * Return the signature of the proxied method.\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.MethodProxy#getSuperName()",
    "entityType": "method",
    "code": "/**\r\n * Return the name of the synthetic method created by CGLIB which is\r\n * used by {@link #invokeSuper} to invoke the superclass\r\n * (non-intercepted) method implementation. The parameter types are\r\n * the same as the proxied method.\r\n */\r\npublic String getSuperName() {\r\n    return sig2.getName();\r\n}",
    "comment": "\n\t * Return the name of the synthetic method created by CGLIB which is\n\t * used by {@link #invokeSuper} to invoke the superclass\n\t * (non-intercepted) method implementation. The parameter types are\n\t * the same as the proxied method.\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.MethodProxy#getSuperIndex()",
    "entityType": "method",
    "code": "/**\r\n * Return the {@link org.springframework.cglib.reflect.FastClass} method index\r\n * for the method used by {@link #invokeSuper}. This index uniquely\r\n * identifies the method within the generated proxy, and therefore\r\n * can be useful to reference external metadata.\r\n * @see #getSuperName\r\n */\r\npublic int getSuperIndex() {\r\n    init();\r\n    return fastClassInfo.i2;\r\n}",
    "comment": "\n\t * Return the {@link org.springframework.cglib.reflect.FastClass} method index\n\t * for the method used by {@link #invokeSuper}. This index uniquely\n\t * identifies the method within the generated proxy, and therefore\n\t * can be useful to reference external metadata.\n\t * @see #getSuperName\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.MethodProxy#getFastClass()",
    "entityType": "method",
    "code": "// For testing\r\nFastClass getFastClass() {\r\n    init();\r\n    return fastClassInfo.f1;\r\n}",
    "comment": " For testing"
  },
  {
    "entityId": "org.springframework.cglib.proxy.MethodProxy#getSuperFastClass()",
    "entityType": "method",
    "code": "// For testing\r\nFastClass getSuperFastClass() {\r\n    init();\r\n    return fastClassInfo.f2;\r\n}",
    "comment": " For testing"
  },
  {
    "entityId": "org.springframework.cglib.proxy.MethodProxy#find(Class,Signature)",
    "entityType": "method",
    "code": "/**\r\n * Return the <code>MethodProxy</code> used when intercepting the method\r\n * matching the given signature.\r\n * @param type the class generated by Enhancer\r\n * @param sig the signature to match\r\n * @return the MethodProxy instance, or null if no applicable matching method is found\r\n * @throws IllegalArgumentException if the Class was not created by Enhancer or does not use a MethodInterceptor\r\n */\r\npublic static MethodProxy find(Class type, Signature sig) {\r\n    try {\r\n        Method m = type.getDeclaredMethod(MethodInterceptorGenerator.FIND_PROXY_NAME, MethodInterceptorGenerator.FIND_PROXY_TYPES);\r\n        return (MethodProxy) m.invoke(null, new Object[] { sig });\r\n    } catch (NoSuchMethodException ex) {\r\n        throw new IllegalArgumentException(\"Class \" + type + \" does not use a MethodInterceptor\");\r\n    } catch (IllegalAccessException | InvocationTargetException ex) {\r\n        throw new CodeGenerationException(ex);\r\n    }\r\n}",
    "comment": "\n\t * Return the <code>MethodProxy</code> used when intercepting the method\n\t * matching the given signature.\n\t * @param type the class generated by Enhancer\n\t * @param sig the signature to match\n\t * @return the MethodProxy instance, or null if no applicable matching method is found\n\t * @throws IllegalArgumentException if the Class was not created by Enhancer or does not use a MethodInterceptor\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.MethodProxy#invoke(Object,Object[])",
    "entityType": "method",
    "code": "/**\r\n * Invoke the original method, on a different object of the same type.\r\n * @param obj the compatible object; recursion will result if you use the object passed as the first\r\n * argument to the MethodInterceptor (usually not what you want)\r\n * @param args the arguments passed to the intercepted method; you may substitute a different\r\n * argument array as long as the types are compatible\r\n * @throws Throwable the bare exceptions thrown by the called method are passed through\r\n * without wrapping in an <code>InvocationTargetException</code>\r\n * @see MethodInterceptor#intercept\r\n */\r\npublic Object invoke(Object obj, Object[] args) throws Throwable {\r\n    try {\r\n        init();\r\n        FastClassInfo fci = fastClassInfo;\r\n        return fci.f1.invoke(fci.i1, obj, args);\r\n    } catch (InvocationTargetException ex) {\r\n        throw ex.getTargetException();\r\n    } catch (IllegalArgumentException ex) {\r\n        if (fastClassInfo.i1 < 0) {\r\n            throw new IllegalArgumentException(\"Protected method: \" + sig1);\r\n        }\r\n        throw ex;\r\n    }\r\n}",
    "comment": "\n\t * Invoke the original method, on a different object of the same type.\n\t * @param obj the compatible object; recursion will result if you use the object passed as the first\n\t * argument to the MethodInterceptor (usually not what you want)\n\t * @param args the arguments passed to the intercepted method; you may substitute a different\n\t * argument array as long as the types are compatible\n\t * @throws Throwable the bare exceptions thrown by the called method are passed through\n\t * without wrapping in an <code>InvocationTargetException</code>\n\t * @see MethodInterceptor#intercept\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.MethodProxy#invokeSuper(Object,Object[])",
    "entityType": "method",
    "code": "/**\r\n * Invoke the original (super) method on the specified object.\r\n * @param obj the enhanced object, must be the object passed as the first\r\n * argument to the MethodInterceptor\r\n * @param args the arguments passed to the intercepted method; you may substitute a different\r\n * argument array as long as the types are compatible\r\n * @throws Throwable the bare exceptions thrown by the called method are passed through\r\n * without wrapping in an <code>InvocationTargetException</code>\r\n * @see MethodInterceptor#intercept\r\n */\r\npublic Object invokeSuper(Object obj, Object[] args) throws Throwable {\r\n    try {\r\n        init();\r\n        FastClassInfo fci = fastClassInfo;\r\n        return fci.f2.invoke(fci.i2, obj, args);\r\n    } catch (InvocationTargetException e) {\r\n        throw e.getTargetException();\r\n    }\r\n}",
    "comment": "\n\t * Invoke the original (super) method on the specified object.\n\t * @param obj the enhanced object, must be the object passed as the first\n\t * argument to the MethodInterceptor\n\t * @param args the arguments passed to the intercepted method; you may substitute a different\n\t * argument array as long as the types are compatible\n\t * @throws Throwable the bare exceptions thrown by the called method are passed through\n\t * without wrapping in an <code>InvocationTargetException</code>\n\t * @see MethodInterceptor#intercept\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.FastClassInfo",
    "entityType": "class",
    "code": "FastClass f1;\nFastClass f2;\nint i1;\nint i2;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.CreateInfo",
    "entityType": "class",
    "code": "Class c1;\nClass c2;\nNamingPolicy namingPolicy;\nGeneratorStrategy strategy;\nboolean attemptLoad;\npublic CreateInfo(Class c1, Class c2) {\r\n    this.c1 = c1;\r\n    this.c2 = c2;\r\n    AbstractClassGenerator fromEnhancer = AbstractClassGenerator.getCurrent();\r\n    if (fromEnhancer != null) {\r\n        namingPolicy = fromEnhancer.getNamingPolicy();\r\n        strategy = fromEnhancer.getStrategy();\r\n        attemptLoad = fromEnhancer.getAttemptLoad();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Mixin",
    "entityType": "class",
    "code": "private static final MixinKey KEY_FACTORY = (MixinKey) KeyFactory.create(MixinKey.class, KeyFactory.CLASS_BY_NAME);\nprivate static final Map ROUTE_CACHE = Collections.synchronizedMap(new HashMap());\npublic static final int STYLE_INTERFACES = 0;\npublic static final int STYLE_BEANS = 1;\npublic static final int STYLE_EVERYTHING = 2;\ninterface MixinKey {\r\n\r\n    public Object newInstance(int style, String[] classes, int[] route);\r\n}\nabstract public Mixin newInstance(Object[] delegates);\n/**\r\n * Helper method to create an interface mixin. For finer control over the\r\n * generated instance, use a new instance of <code>Mixin</code>\r\n * instead of this static method.\r\n * TODO\r\n */\r\npublic static Mixin create(Object[] delegates) {\r\n    Generator gen = new Generator();\r\n    gen.setDelegates(delegates);\r\n    return gen.create();\r\n}\n/**\r\n * Helper method to create an interface mixin. For finer control over the\r\n * generated instance, use a new instance of <code>Mixin</code>\r\n * instead of this static method.\r\n * TODO\r\n */\r\npublic static Mixin create(Class[] interfaces, Object[] delegates) {\r\n    Generator gen = new Generator();\r\n    gen.setClasses(interfaces);\r\n    gen.setDelegates(delegates);\r\n    return gen.create();\r\n}\npublic static Mixin createBean(Object[] beans) {\r\n    return createBean(null, beans);\r\n}\n/**\r\n * Helper method to create a bean mixin. For finer control over the\r\n * generated instance, use a new instance of <code>Mixin</code>\r\n * instead of this static method.\r\n * TODO\r\n */\r\npublic static Mixin createBean(ClassLoader loader, Object[] beans) {\r\n    Generator gen = new Generator();\r\n    gen.setStyle(STYLE_BEANS);\r\n    gen.setDelegates(beans);\r\n    gen.setClassLoader(loader);\r\n    return gen.create();\r\n}\npublic static class Generator extends AbstractClassGenerator {\r\n\r\n    private static final Source SOURCE = new Source(Mixin.class.getName());\r\n\r\n    private Class[] classes;\r\n\r\n    private Object[] delegates;\r\n\r\n    private int style = STYLE_INTERFACES;\r\n\r\n    private int[] route;\r\n\r\n    public Generator() {\r\n        super(SOURCE);\r\n    }\r\n\r\n    @Override\r\n    protected ClassLoader getDefaultClassLoader() {\r\n        // is this right?\r\n        return classes[0].getClassLoader();\r\n    }\r\n\r\n    @Override\r\n    protected ProtectionDomain getProtectionDomain() {\r\n        return ReflectUtils.getProtectionDomain(classes[0]);\r\n    }\r\n\r\n    public void setStyle(int style) {\r\n        switch(style) {\r\n            case STYLE_INTERFACES:\r\n            case STYLE_BEANS:\r\n            case STYLE_EVERYTHING:\r\n                this.style = style;\r\n                break;\r\n            default:\r\n                throw new IllegalArgumentException(\"Unknown mixin style: \" + style);\r\n        }\r\n    }\r\n\r\n    public void setClasses(Class[] classes) {\r\n        this.classes = classes;\r\n    }\r\n\r\n    public void setDelegates(Object[] delegates) {\r\n        this.delegates = delegates;\r\n    }\r\n\r\n    public Mixin create() {\r\n        if (classes == null && delegates == null) {\r\n            throw new IllegalStateException(\"Either classes or delegates must be set\");\r\n        }\r\n        switch(style) {\r\n            case STYLE_INTERFACES:\r\n                if (classes == null) {\r\n                    Route r = route(delegates);\r\n                    classes = r.classes;\r\n                    route = r.route;\r\n                }\r\n                break;\r\n            case STYLE_BEANS:\r\n            // fall-through\r\n            case STYLE_EVERYTHING:\r\n                if (classes == null) {\r\n                    classes = ReflectUtils.getClasses(delegates);\r\n                } else {\r\n                    if (delegates != null) {\r\n                        Class[] temp = ReflectUtils.getClasses(delegates);\r\n                        if (classes.length != temp.length) {\r\n                            throw new IllegalStateException(\"Specified classes are incompatible with delegates\");\r\n                        }\r\n                        for (int i = 0; i < classes.length; i++) {\r\n                            if (!classes[i].isAssignableFrom(temp[i])) {\r\n                                throw new IllegalStateException(\"Specified class \" + classes[i] + \" is incompatible with delegate class \" + temp[i] + \" (index \" + i + \")\");\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n        }\r\n        setNamePrefix(classes[ReflectUtils.findPackageProtected(classes)].getName());\r\n        return (Mixin) super.create(KEY_FACTORY.newInstance(style, ReflectUtils.getNames(classes), route));\r\n    }\r\n\r\n    @Override\r\n    public void generateClass(ClassVisitor v) {\r\n        switch(style) {\r\n            case STYLE_INTERFACES:\r\n                new MixinEmitter(v, getClassName(), classes, route);\r\n                break;\r\n            case STYLE_BEANS:\r\n                new MixinBeanEmitter(v, getClassName(), classes);\r\n                break;\r\n            case STYLE_EVERYTHING:\r\n                new MixinEverythingEmitter(v, getClassName(), classes);\r\n                break;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    protected Object firstInstance(Class type) {\r\n        return ((Mixin) ReflectUtils.newInstance(type)).newInstance(delegates);\r\n    }\r\n\r\n    @Override\r\n    protected Object nextInstance(Object instance) {\r\n        return ((Mixin) instance).newInstance(delegates);\r\n    }\r\n}\npublic static Class[] getClasses(Object[] delegates) {\r\n    return route(delegates).classes.clone();\r\n}\n//     public static int[] getRoute(Object[] delegates) {\r\n//         return (int[])route(delegates).route.clone();\r\n//     }\r\nprivate static Route route(Object[] delegates) {\r\n    Object key = ClassesKey.create(delegates);\r\n    Route route = (Route) ROUTE_CACHE.get(key);\r\n    if (route == null) {\r\n        ROUTE_CACHE.put(key, route = new Route(delegates));\r\n    }\r\n    return route;\r\n}\nprivate static class Route {\r\n\r\n    private Class[] classes;\r\n\r\n    private int[] route;\r\n\r\n    Route(Object[] delegates) {\r\n        Map map = new HashMap();\r\n        ArrayList collect = new ArrayList();\r\n        for (int i = 0; i < delegates.length; i++) {\r\n            Class delegate = delegates[i].getClass();\r\n            collect.clear();\r\n            ReflectUtils.addAllInterfaces(delegate, collect);\r\n            for (Iterator it = collect.iterator(); it.hasNext(); ) {\r\n                Class iface = (Class) it.next();\r\n                if (!map.containsKey(iface)) {\r\n                    map.put(iface, i);\r\n                }\r\n            }\r\n        }\r\n        classes = new Class[map.size()];\r\n        route = new int[map.size()];\r\n        int index = 0;\r\n        for (Iterator it = map.keySet().iterator(); it.hasNext(); ) {\r\n            Class key = (Class) it.next();\r\n            classes[index] = key;\r\n            route[index] = ((Integer) map.get(key));\r\n            index++;\r\n        }\r\n    }\r\n}",
    "comment": "\n * <code>Mixin</code> allows\n * multiple objects to be combined into a single larger object. The\n * methods in the generated object simply call the original methods in the\n * underlying \"delegate\" objects.\n * @author Chris Nokleberg\n * @version $Id: Mixin.java,v 1.7 2005/09/27 11:42:27 baliuka Exp $\n "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Mixin#newInstance(Object[])",
    "entityType": "method",
    "code": "abstract public Mixin newInstance(Object[] delegates);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Mixin#create(Object[])",
    "entityType": "method",
    "code": "/**\r\n * Helper method to create an interface mixin. For finer control over the\r\n * generated instance, use a new instance of <code>Mixin</code>\r\n * instead of this static method.\r\n * TODO\r\n */\r\npublic static Mixin create(Object[] delegates) {\r\n    Generator gen = new Generator();\r\n    gen.setDelegates(delegates);\r\n    return gen.create();\r\n}",
    "comment": "\n     * Helper method to create an interface mixin. For finer control over the\n     * generated instance, use a new instance of <code>Mixin</code>\n     * instead of this static method.\n     * TODO\n     "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Mixin#create(Class[],Object[])",
    "entityType": "method",
    "code": "/**\r\n * Helper method to create an interface mixin. For finer control over the\r\n * generated instance, use a new instance of <code>Mixin</code>\r\n * instead of this static method.\r\n * TODO\r\n */\r\npublic static Mixin create(Class[] interfaces, Object[] delegates) {\r\n    Generator gen = new Generator();\r\n    gen.setClasses(interfaces);\r\n    gen.setDelegates(delegates);\r\n    return gen.create();\r\n}",
    "comment": "\n     * Helper method to create an interface mixin. For finer control over the\n     * generated instance, use a new instance of <code>Mixin</code>\n     * instead of this static method.\n     * TODO\n     "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Mixin#createBean(Object[])",
    "entityType": "method",
    "code": "public static Mixin createBean(Object[] beans) {\r\n    return createBean(null, beans);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Mixin#createBean(ClassLoader,Object[])",
    "entityType": "method",
    "code": "/**\r\n * Helper method to create a bean mixin. For finer control over the\r\n * generated instance, use a new instance of <code>Mixin</code>\r\n * instead of this static method.\r\n * TODO\r\n */\r\npublic static Mixin createBean(ClassLoader loader, Object[] beans) {\r\n    Generator gen = new Generator();\r\n    gen.setStyle(STYLE_BEANS);\r\n    gen.setDelegates(beans);\r\n    gen.setClassLoader(loader);\r\n    return gen.create();\r\n}",
    "comment": "\n     * Helper method to create a bean mixin. For finer control over the\n     * generated instance, use a new instance of <code>Mixin</code>\n     * instead of this static method.\n     * TODO\n     "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Mixin#getClasses(Object[])",
    "entityType": "method",
    "code": "public static Class[] getClasses(Object[] delegates) {\r\n    return route(delegates).classes.clone();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Mixin#route(Object[])",
    "entityType": "method",
    "code": "//     public static int[] getRoute(Object[] delegates) {\r\n//         return (int[])route(delegates).route.clone();\r\n//     }\r\nprivate static Route route(Object[] delegates) {\r\n    Object key = ClassesKey.create(delegates);\r\n    Route route = (Route) ROUTE_CACHE.get(key);\r\n    if (route == null) {\r\n        ROUTE_CACHE.put(key, route = new Route(delegates));\r\n    }\r\n    return route;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.MixinKey",
    "entityType": "class",
    "code": "public Object newInstance(int style, String[] classes, int[] route);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.MixinKey#newInstance(int,String[],int[])",
    "entityType": "method",
    "code": "public Object newInstance(int style, String[] classes, int[] route);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Generator",
    "entityType": "class",
    "code": "private static final Source SOURCE = new Source(Mixin.class.getName());\nprivate Class[] classes;\nprivate Object[] delegates;\nprivate int style = STYLE_INTERFACES;\nprivate int[] route;\npublic Generator() {\r\n    super(SOURCE);\r\n}\n@Override\r\nprotected ClassLoader getDefaultClassLoader() {\r\n    // is this right?\r\n    return classes[0].getClassLoader();\r\n}\n@Override\r\nprotected ProtectionDomain getProtectionDomain() {\r\n    return ReflectUtils.getProtectionDomain(classes[0]);\r\n}\npublic void setStyle(int style) {\r\n    switch(style) {\r\n        case STYLE_INTERFACES:\r\n        case STYLE_BEANS:\r\n        case STYLE_EVERYTHING:\r\n            this.style = style;\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException(\"Unknown mixin style: \" + style);\r\n    }\r\n}\npublic void setClasses(Class[] classes) {\r\n    this.classes = classes;\r\n}\npublic void setDelegates(Object[] delegates) {\r\n    this.delegates = delegates;\r\n}\npublic Mixin create() {\r\n    if (classes == null && delegates == null) {\r\n        throw new IllegalStateException(\"Either classes or delegates must be set\");\r\n    }\r\n    switch(style) {\r\n        case STYLE_INTERFACES:\r\n            if (classes == null) {\r\n                Route r = route(delegates);\r\n                classes = r.classes;\r\n                route = r.route;\r\n            }\r\n            break;\r\n        case STYLE_BEANS:\r\n        // fall-through\r\n        case STYLE_EVERYTHING:\r\n            if (classes == null) {\r\n                classes = ReflectUtils.getClasses(delegates);\r\n            } else {\r\n                if (delegates != null) {\r\n                    Class[] temp = ReflectUtils.getClasses(delegates);\r\n                    if (classes.length != temp.length) {\r\n                        throw new IllegalStateException(\"Specified classes are incompatible with delegates\");\r\n                    }\r\n                    for (int i = 0; i < classes.length; i++) {\r\n                        if (!classes[i].isAssignableFrom(temp[i])) {\r\n                            throw new IllegalStateException(\"Specified class \" + classes[i] + \" is incompatible with delegate class \" + temp[i] + \" (index \" + i + \")\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n    }\r\n    setNamePrefix(classes[ReflectUtils.findPackageProtected(classes)].getName());\r\n    return (Mixin) super.create(KEY_FACTORY.newInstance(style, ReflectUtils.getNames(classes), route));\r\n}\n@Override\r\npublic void generateClass(ClassVisitor v) {\r\n    switch(style) {\r\n        case STYLE_INTERFACES:\r\n            new MixinEmitter(v, getClassName(), classes, route);\r\n            break;\r\n        case STYLE_BEANS:\r\n            new MixinBeanEmitter(v, getClassName(), classes);\r\n            break;\r\n        case STYLE_EVERYTHING:\r\n            new MixinEverythingEmitter(v, getClassName(), classes);\r\n            break;\r\n    }\r\n}\n@Override\r\nprotected Object firstInstance(Class type) {\r\n    return ((Mixin) ReflectUtils.newInstance(type)).newInstance(delegates);\r\n}\n@Override\r\nprotected Object nextInstance(Object instance) {\r\n    return ((Mixin) instance).newInstance(delegates);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Generator#getDefaultClassLoader()",
    "entityType": "method",
    "code": "@Override\r\nprotected ClassLoader getDefaultClassLoader() {\r\n    // is this right?\r\n    return classes[0].getClassLoader();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Generator#getProtectionDomain()",
    "entityType": "method",
    "code": "@Override\r\nprotected ProtectionDomain getProtectionDomain() {\r\n    return ReflectUtils.getProtectionDomain(classes[0]);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Generator#setStyle(int)",
    "entityType": "method",
    "code": "public void setStyle(int style) {\r\n    switch(style) {\r\n        case STYLE_INTERFACES:\r\n        case STYLE_BEANS:\r\n        case STYLE_EVERYTHING:\r\n            this.style = style;\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException(\"Unknown mixin style: \" + style);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Generator#setClasses(Class[])",
    "entityType": "method",
    "code": "public void setClasses(Class[] classes) {\r\n    this.classes = classes;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Generator#setDelegates(Object[])",
    "entityType": "method",
    "code": "public void setDelegates(Object[] delegates) {\r\n    this.delegates = delegates;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Generator#create()",
    "entityType": "method",
    "code": "public Mixin create() {\r\n    if (classes == null && delegates == null) {\r\n        throw new IllegalStateException(\"Either classes or delegates must be set\");\r\n    }\r\n    switch(style) {\r\n        case STYLE_INTERFACES:\r\n            if (classes == null) {\r\n                Route r = route(delegates);\r\n                classes = r.classes;\r\n                route = r.route;\r\n            }\r\n            break;\r\n        case STYLE_BEANS:\r\n        // fall-through\r\n        case STYLE_EVERYTHING:\r\n            if (classes == null) {\r\n                classes = ReflectUtils.getClasses(delegates);\r\n            } else {\r\n                if (delegates != null) {\r\n                    Class[] temp = ReflectUtils.getClasses(delegates);\r\n                    if (classes.length != temp.length) {\r\n                        throw new IllegalStateException(\"Specified classes are incompatible with delegates\");\r\n                    }\r\n                    for (int i = 0; i < classes.length; i++) {\r\n                        if (!classes[i].isAssignableFrom(temp[i])) {\r\n                            throw new IllegalStateException(\"Specified class \" + classes[i] + \" is incompatible with delegate class \" + temp[i] + \" (index \" + i + \")\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n    }\r\n    setNamePrefix(classes[ReflectUtils.findPackageProtected(classes)].getName());\r\n    return (Mixin) super.create(KEY_FACTORY.newInstance(style, ReflectUtils.getNames(classes), route));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Generator#generateClass(ClassVisitor)",
    "entityType": "method",
    "code": "@Override\r\npublic void generateClass(ClassVisitor v) {\r\n    switch(style) {\r\n        case STYLE_INTERFACES:\r\n            new MixinEmitter(v, getClassName(), classes, route);\r\n            break;\r\n        case STYLE_BEANS:\r\n            new MixinBeanEmitter(v, getClassName(), classes);\r\n            break;\r\n        case STYLE_EVERYTHING:\r\n            new MixinEverythingEmitter(v, getClassName(), classes);\r\n            break;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Generator#firstInstance(Class)",
    "entityType": "method",
    "code": "@Override\r\nprotected Object firstInstance(Class type) {\r\n    return ((Mixin) ReflectUtils.newInstance(type)).newInstance(delegates);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Generator#nextInstance(Object)",
    "entityType": "method",
    "code": "@Override\r\nprotected Object nextInstance(Object instance) {\r\n    return ((Mixin) instance).newInstance(delegates);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Route",
    "entityType": "class",
    "code": "private Class[] classes;\nprivate int[] route;\nRoute(Object[] delegates) {\r\n    Map map = new HashMap();\r\n    ArrayList collect = new ArrayList();\r\n    for (int i = 0; i < delegates.length; i++) {\r\n        Class delegate = delegates[i].getClass();\r\n        collect.clear();\r\n        ReflectUtils.addAllInterfaces(delegate, collect);\r\n        for (Iterator it = collect.iterator(); it.hasNext(); ) {\r\n            Class iface = (Class) it.next();\r\n            if (!map.containsKey(iface)) {\r\n                map.put(iface, i);\r\n            }\r\n        }\r\n    }\r\n    classes = new Class[map.size()];\r\n    route = new int[map.size()];\r\n    int index = 0;\r\n    for (Iterator it = map.keySet().iterator(); it.hasNext(); ) {\r\n        Class key = (Class) it.next();\r\n        classes[index] = key;\r\n        route[index] = ((Integer) map.get(key));\r\n        index++;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.MixinBeanEmitter",
    "entityType": "class",
    "code": "public MixinBeanEmitter(ClassVisitor v, String className, Class[] classes) {\r\n    super(v, className, classes, null);\r\n}\n@Override\r\nprotected Class[] getInterfaces(Class[] classes) {\r\n    return null;\r\n}\n@Override\r\nprotected Method[] getMethods(Class type) {\r\n    return ReflectUtils.getPropertyMethods(ReflectUtils.getBeanProperties(type), true, true);\r\n}",
    "comment": "\n * @author Chris Nokleberg\n * @version $Id: MixinBeanEmitter.java,v 1.2 2004/06/24 21:15:20 herbyderby Exp $\n "
  },
  {
    "entityId": "org.springframework.cglib.proxy.MixinBeanEmitter#getInterfaces(Class[])",
    "entityType": "method",
    "code": "@Override\r\nprotected Class[] getInterfaces(Class[] classes) {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.MixinBeanEmitter#getMethods(Class)",
    "entityType": "method",
    "code": "@Override\r\nprotected Method[] getMethods(Class type) {\r\n    return ReflectUtils.getPropertyMethods(ReflectUtils.getBeanProperties(type), true, true);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.MixinEmitter",
    "entityType": "class",
    "code": "private static final String FIELD_NAME = \"CGLIB$DELEGATES\";\nprivate static final Signature CSTRUCT_OBJECT_ARRAY = TypeUtils.parseConstructor(\"Object[]\");\nprivate static final Type MIXIN = TypeUtils.parseType(\"org.springframework.cglib.proxy.Mixin\");\nprivate static final Signature NEW_INSTANCE = new Signature(\"newInstance\", MIXIN, new Type[] { Constants.TYPE_OBJECT_ARRAY });\npublic MixinEmitter(ClassVisitor v, String className, Class[] classes, int[] route) {\r\n    super(v);\r\n    begin_class(Constants.V1_8, Constants.ACC_PUBLIC, className, MIXIN, TypeUtils.getTypes(getInterfaces(classes)), Constants.SOURCE_FILE);\r\n    EmitUtils.null_constructor(this);\r\n    EmitUtils.factory_method(this, NEW_INSTANCE);\r\n    declare_field(Constants.ACC_PRIVATE, FIELD_NAME, Constants.TYPE_OBJECT_ARRAY, null);\r\n    CodeEmitter e = begin_method(Constants.ACC_PUBLIC, CSTRUCT_OBJECT_ARRAY, null);\r\n    e.load_this();\r\n    e.super_invoke_constructor();\r\n    e.load_this();\r\n    e.load_arg(0);\r\n    e.putfield(FIELD_NAME);\r\n    e.return_value();\r\n    e.end_method();\r\n    Set unique = new HashSet();\r\n    for (int i = 0; i < classes.length; i++) {\r\n        Method[] methods = getMethods(classes[i]);\r\n        for (Method method : methods) {\r\n            if (unique.add(MethodWrapper.create(method))) {\r\n                MethodInfo methodInfo = ReflectUtils.getMethodInfo(method);\r\n                int modifiers = Constants.ACC_PUBLIC;\r\n                if ((methodInfo.getModifiers() & Constants.ACC_VARARGS) == Constants.ACC_VARARGS) {\r\n                    modifiers |= Constants.ACC_VARARGS;\r\n                }\r\n                e = EmitUtils.begin_method(this, methodInfo, modifiers);\r\n                e.load_this();\r\n                e.getfield(FIELD_NAME);\r\n                e.aaload((route != null) ? route[i] : i);\r\n                e.checkcast(methodInfo.getClassInfo().getType());\r\n                e.load_args();\r\n                e.invoke(methodInfo);\r\n                e.return_value();\r\n                e.end_method();\r\n            }\r\n        }\r\n    }\r\n    end_class();\r\n}\nprotected Class[] getInterfaces(Class[] classes) {\r\n    return classes;\r\n}\nprotected Method[] getMethods(Class type) {\r\n    return type.getMethods();\r\n}",
    "comment": "\n * @author Chris Nokleberg\n * @version $Id: MixinEmitter.java,v 1.9 2006/08/27 21:04:37 herbyderby Exp $\n "
  },
  {
    "entityId": "org.springframework.cglib.proxy.MixinEmitter#getInterfaces(Class[])",
    "entityType": "method",
    "code": "protected Class[] getInterfaces(Class[] classes) {\r\n    return classes;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.MixinEmitter#getMethods(Class)",
    "entityType": "method",
    "code": "protected Method[] getMethods(Class type) {\r\n    return type.getMethods();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.MixinEverythingEmitter",
    "entityType": "class",
    "code": "public MixinEverythingEmitter(ClassVisitor v, String className, Class[] classes) {\r\n    super(v, className, classes, null);\r\n}\n@Override\r\nprotected Class[] getInterfaces(Class[] classes) {\r\n    List list = new ArrayList();\r\n    for (Class clazz : classes) {\r\n        ReflectUtils.addAllInterfaces(clazz, list);\r\n    }\r\n    return (Class[]) list.toArray(new Class[list.size()]);\r\n}\n@Override\r\nprotected Method[] getMethods(Class type) {\r\n    List methods = new ArrayList(Arrays.asList(type.getMethods()));\r\n    CollectionUtils.filter(methods, new RejectModifierPredicate(Modifier.FINAL | Modifier.STATIC));\r\n    return (Method[]) methods.toArray(new Method[methods.size()]);\r\n}",
    "comment": "\n * @author Chris Nokleberg\n * @version $Id: MixinEverythingEmitter.java,v 1.3 2004/06/24 21:15:19 herbyderby Exp $\n "
  },
  {
    "entityId": "org.springframework.cglib.proxy.MixinEverythingEmitter#getInterfaces(Class[])",
    "entityType": "method",
    "code": "@Override\r\nprotected Class[] getInterfaces(Class[] classes) {\r\n    List list = new ArrayList();\r\n    for (Class clazz : classes) {\r\n        ReflectUtils.addAllInterfaces(clazz, list);\r\n    }\r\n    return (Class[]) list.toArray(new Class[list.size()]);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.MixinEverythingEmitter#getMethods(Class)",
    "entityType": "method",
    "code": "@Override\r\nprotected Method[] getMethods(Class type) {\r\n    List methods = new ArrayList(Arrays.asList(type.getMethods()));\r\n    CollectionUtils.filter(methods, new RejectModifierPredicate(Modifier.FINAL | Modifier.STATIC));\r\n    return (Method[]) methods.toArray(new Method[methods.size()]);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.NoOp",
    "entityType": "class",
    "code": "/**\r\n * A thread-safe singleton instance of the <code>NoOp</code> callback.\r\n */\r\npublic static final NoOp INSTANCE = new NoOp() {\r\n};",
    "comment": "\n * Methods using this {@link Enhancer} callback will delegate directly to the\n * default (super) implementation in the base class.\n "
  },
  {
    "entityId": "org.springframework.cglib.proxy.NoOpGenerator",
    "entityType": "class",
    "code": "public static final NoOpGenerator INSTANCE = new NoOpGenerator();\n@Override\r\npublic void generate(ClassEmitter ce, Context context, List methods) {\r\n    for (Iterator it = methods.iterator(); it.hasNext(); ) {\r\n        MethodInfo method = (MethodInfo) it.next();\r\n        if (TypeUtils.isBridge(method.getModifiers()) || (TypeUtils.isProtected(context.getOriginalModifiers(method)) && TypeUtils.isPublic(method.getModifiers()))) {\r\n            CodeEmitter e = EmitUtils.begin_method(ce, method);\r\n            e.load_this();\r\n            context.emitLoadArgsAndInvoke(e, method);\r\n            e.return_value();\r\n            e.end_method();\r\n        }\r\n    }\r\n}\n@Override\r\npublic void generateStatic(CodeEmitter e, Context context, List methods) ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.NoOpGenerator#generate(ClassEmitter,Context,List)",
    "entityType": "method",
    "code": "@Override\r\npublic void generate(ClassEmitter ce, Context context, List methods) {\r\n    for (Iterator it = methods.iterator(); it.hasNext(); ) {\r\n        MethodInfo method = (MethodInfo) it.next();\r\n        if (TypeUtils.isBridge(method.getModifiers()) || (TypeUtils.isProtected(context.getOriginalModifiers(method)) && TypeUtils.isPublic(method.getModifiers()))) {\r\n            CodeEmitter e = EmitUtils.begin_method(ce, method);\r\n            e.load_this();\r\n            context.emitLoadArgsAndInvoke(e, method);\r\n            e.return_value();\r\n            e.end_method();\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.NoOpGenerator#generateStatic(CodeEmitter,Context,List)",
    "entityType": "method",
    "code": "@Override\r\npublic void generateStatic(CodeEmitter e, Context context, List methods) ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Proxy",
    "entityType": "class",
    "code": "protected InvocationHandler h;\nprivate static final CallbackFilter BAD_OBJECT_METHOD_FILTER = method -> {\r\n    if (method.getDeclaringClass().getName().equals(\"java.lang.Object\")) {\r\n        String name = method.getName();\r\n        if (!(name.equals(\"hashCode\") || name.equals(\"equals\") || name.equals(\"toString\"))) {\r\n            return 1;\r\n        }\r\n    }\r\n    return 0;\r\n};\nprotected Proxy(InvocationHandler h) {\r\n    Enhancer.registerCallbacks(getClass(), new Callback[] { h, null });\r\n    this.h = h;\r\n}\n// private for security of isProxyClass\r\nprivate static class ProxyImpl extends Proxy {\r\n\r\n    protected ProxyImpl(InvocationHandler h) {\r\n        super(h);\r\n    }\r\n}\npublic static InvocationHandler getInvocationHandler(Object proxy) {\r\n    if (!(proxy instanceof ProxyImpl)) {\r\n        throw new IllegalArgumentException(\"Object is not a proxy\");\r\n    }\r\n    return ((Proxy) proxy).h;\r\n}\npublic static Class getProxyClass(ClassLoader loader, Class[] interfaces) {\r\n    Enhancer e = new Enhancer();\r\n    e.setSuperclass(ProxyImpl.class);\r\n    e.setInterfaces(interfaces);\r\n    e.setCallbackTypes(new Class[] { InvocationHandler.class, NoOp.class });\r\n    e.setCallbackFilter(BAD_OBJECT_METHOD_FILTER);\r\n    e.setUseFactory(false);\r\n    return e.createClass();\r\n}\npublic static boolean isProxyClass(Class cl) {\r\n    return cl.getSuperclass().equals(ProxyImpl.class);\r\n}\npublic static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) {\r\n    try {\r\n        Class clazz = getProxyClass(loader, interfaces);\r\n        return clazz.getConstructor(new Class[] { InvocationHandler.class }).newInstance(new Object[] { h });\r\n    } catch (RuntimeException e) {\r\n        throw e;\r\n    } catch (Exception e) {\r\n        throw new CodeGenerationException(e);\r\n    }\r\n}",
    "comment": "\n * This class is meant to be used as replacement for\n * <code>java.lang.reflect.Proxy</code> under JDK 1.2. There are some known\n * subtle differences:\n * <ul>\n * <li>The exceptions returned by invoking <code>getExceptionTypes</code>\n * on the <code>Method</code> passed to the <code>invoke</code> method\n * <b>are</b> the exact set that can be thrown without resulting in an\n * <code>UndeclaredThrowableException</code> being thrown.\n * <li>{@link UndeclaredThrowableException} is used instead\n * of <code>java.lang.reflect.UndeclaredThrowableException</code>.\n * </ul>\n * <p>\n * @version $Id: Proxy.java,v 1.6 2004/06/24 21:15:19 herbyderby Exp $\n "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Proxy#getInvocationHandler(Object)",
    "entityType": "method",
    "code": "public static InvocationHandler getInvocationHandler(Object proxy) {\r\n    if (!(proxy instanceof ProxyImpl)) {\r\n        throw new IllegalArgumentException(\"Object is not a proxy\");\r\n    }\r\n    return ((Proxy) proxy).h;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Proxy#getProxyClass(ClassLoader,Class[])",
    "entityType": "method",
    "code": "public static Class getProxyClass(ClassLoader loader, Class[] interfaces) {\r\n    Enhancer e = new Enhancer();\r\n    e.setSuperclass(ProxyImpl.class);\r\n    e.setInterfaces(interfaces);\r\n    e.setCallbackTypes(new Class[] { InvocationHandler.class, NoOp.class });\r\n    e.setCallbackFilter(BAD_OBJECT_METHOD_FILTER);\r\n    e.setUseFactory(false);\r\n    return e.createClass();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Proxy#isProxyClass(Class)",
    "entityType": "method",
    "code": "public static boolean isProxyClass(Class cl) {\r\n    return cl.getSuperclass().equals(ProxyImpl.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Proxy#newProxyInstance(ClassLoader,Class[],InvocationHandler)",
    "entityType": "method",
    "code": "public static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) {\r\n    try {\r\n        Class clazz = getProxyClass(loader, interfaces);\r\n        return clazz.getConstructor(new Class[] { InvocationHandler.class }).newInstance(new Object[] { h });\r\n    } catch (RuntimeException e) {\r\n        throw e;\r\n    } catch (Exception e) {\r\n        throw new CodeGenerationException(e);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.ProxyImpl",
    "entityType": "class",
    "code": "protected ProxyImpl(InvocationHandler h) {\r\n    super(h);\r\n}",
    "comment": " private for security of isProxyClass"
  },
  {
    "entityId": "org.springframework.cglib.proxy.ProxyRefDispatcher",
    "entityType": "class",
    "code": "/**\r\n * Return the object which the original method invocation should\r\n * be dispatched. This method is called for <b>every</b> method invocation.\r\n * @param proxy a reference to the proxy (generated) object\r\n * @return an object that can invoke the method\r\n */\r\nObject loadObject(Object proxy) throws Exception;",
    "comment": "\n * Dispatching {@link Enhancer} callback. This is the same as the\n * {@link Dispatcher} except for the addition of an argument\n * which references the proxy object.\n "
  },
  {
    "entityId": "org.springframework.cglib.proxy.ProxyRefDispatcher#loadObject(Object)",
    "entityType": "method",
    "code": "/**\r\n * Return the object which the original method invocation should\r\n * be dispatched. This method is called for <b>every</b> method invocation.\r\n * @param proxy a reference to the proxy (generated) object\r\n * @return an object that can invoke the method\r\n */\r\nObject loadObject(Object proxy) throws Exception;",
    "comment": "\n     * Return the object which the original method invocation should\n     * be dispatched. This method is called for <b>every</b> method invocation.\n     * @param proxy a reference to the proxy (generated) object\n     * @return an object that can invoke the method\n     "
  },
  {
    "entityId": "org.springframework.cglib.proxy.UndeclaredThrowableException",
    "entityType": "class",
    "code": "/**\r\n * Creates a new instance of <code>UndeclaredThrowableException</code> without detail message.\r\n */\r\npublic UndeclaredThrowableException(Throwable t) {\r\n    super(t);\r\n}\npublic Throwable getUndeclaredThrowable() {\r\n    return getCause();\r\n}",
    "comment": "\n * Used by {@link Proxy} as a replacement for <code>java.lang.reflect.UndeclaredThrowableException</code>.\n * @author Juozas Baliuka\n "
  },
  {
    "entityId": "org.springframework.cglib.proxy.UndeclaredThrowableException#getUndeclaredThrowable()",
    "entityType": "method",
    "code": "public Throwable getUndeclaredThrowable() {\r\n    return getCause();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.ConstructorDelegate",
    "entityType": "class",
    "code": "private static final ConstructorKey KEY_FACTORY = (ConstructorKey) KeyFactory.create(ConstructorKey.class, KeyFactory.CLASS_BY_NAME);\ninterface ConstructorKey {\r\n\r\n    public Object newInstance(String declaring, String iface);\r\n}\nprotected ConstructorDelegate() {\r\n}\npublic static ConstructorDelegate create(Class targetClass, Class iface) {\r\n    Generator gen = new Generator();\r\n    gen.setTargetClass(targetClass);\r\n    gen.setInterface(iface);\r\n    return gen.create();\r\n}\npublic static class Generator extends AbstractClassGenerator {\r\n\r\n    private static final Source SOURCE = new Source(ConstructorDelegate.class.getName());\r\n\r\n    private static final Type CONSTRUCTOR_DELEGATE = TypeUtils.parseType(\"org.springframework.cglib.reflect.ConstructorDelegate\");\r\n\r\n    private Class iface;\r\n\r\n    private Class targetClass;\r\n\r\n    public Generator() {\r\n        super(SOURCE);\r\n    }\r\n\r\n    public void setInterface(Class iface) {\r\n        this.iface = iface;\r\n    }\r\n\r\n    public void setTargetClass(Class targetClass) {\r\n        this.targetClass = targetClass;\r\n    }\r\n\r\n    public ConstructorDelegate create() {\r\n        setNamePrefix(targetClass.getName());\r\n        Object key = KEY_FACTORY.newInstance(iface.getName(), targetClass.getName());\r\n        return (ConstructorDelegate) super.create(key);\r\n    }\r\n\r\n    @Override\r\n    protected ClassLoader getDefaultClassLoader() {\r\n        return targetClass.getClassLoader();\r\n    }\r\n\r\n    @Override\r\n    protected ProtectionDomain getProtectionDomain() {\r\n        return ReflectUtils.getProtectionDomain(targetClass);\r\n    }\r\n\r\n    @Override\r\n    public void generateClass(ClassVisitor v) {\r\n        setNamePrefix(targetClass.getName());\r\n        final Method newInstance = ReflectUtils.findNewInstance(iface);\r\n        if (!newInstance.getReturnType().isAssignableFrom(targetClass)) {\r\n            throw new IllegalArgumentException(\"incompatible return type\");\r\n        }\r\n        final Constructor constructor;\r\n        try {\r\n            constructor = targetClass.getDeclaredConstructor(newInstance.getParameterTypes());\r\n        } catch (NoSuchMethodException e) {\r\n            throw new IllegalArgumentException(\"interface does not match any known constructor\");\r\n        }\r\n        ClassEmitter ce = new ClassEmitter(v);\r\n        ce.begin_class(Constants.V1_8, Constants.ACC_PUBLIC, getClassName(), CONSTRUCTOR_DELEGATE, new Type[] { Type.getType(iface) }, Constants.SOURCE_FILE);\r\n        Type declaring = Type.getType(constructor.getDeclaringClass());\r\n        EmitUtils.null_constructor(ce);\r\n        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, ReflectUtils.getSignature(newInstance), ReflectUtils.getExceptionTypes(newInstance));\r\n        e.new_instance(declaring);\r\n        e.dup();\r\n        e.load_args();\r\n        e.invoke_constructor(declaring, ReflectUtils.getSignature(constructor));\r\n        e.return_value();\r\n        e.end_method();\r\n        ce.end_class();\r\n    }\r\n\r\n    @Override\r\n    protected Object firstInstance(Class type) {\r\n        return ReflectUtils.newInstance(type);\r\n    }\r\n\r\n    @Override\r\n    protected Object nextInstance(Object instance) {\r\n        return instance;\r\n    }\r\n}",
    "comment": "\n * @author Chris Nokleberg\n * @version $Id: ConstructorDelegate.java,v 1.20 2006/03/05 02:43:19 herbyderby Exp $\n "
  },
  {
    "entityId": "org.springframework.cglib.reflect.ConstructorDelegate#create(Class,Class)",
    "entityType": "method",
    "code": "public static ConstructorDelegate create(Class targetClass, Class iface) {\r\n    Generator gen = new Generator();\r\n    gen.setTargetClass(targetClass);\r\n    gen.setInterface(iface);\r\n    return gen.create();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.ConstructorKey",
    "entityType": "class",
    "code": "public Object newInstance(String declaring, String iface);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.ConstructorKey#newInstance(String,String)",
    "entityType": "method",
    "code": "public Object newInstance(String declaring, String iface);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator",
    "entityType": "class",
    "code": "private static final Source SOURCE = new Source(ConstructorDelegate.class.getName());\nprivate static final Type CONSTRUCTOR_DELEGATE = TypeUtils.parseType(\"org.springframework.cglib.reflect.ConstructorDelegate\");\nprivate Class iface;\nprivate Class targetClass;\npublic Generator() {\r\n    super(SOURCE);\r\n}\npublic void setInterface(Class iface) {\r\n    this.iface = iface;\r\n}\npublic void setTargetClass(Class targetClass) {\r\n    this.targetClass = targetClass;\r\n}\npublic ConstructorDelegate create() {\r\n    setNamePrefix(targetClass.getName());\r\n    Object key = KEY_FACTORY.newInstance(iface.getName(), targetClass.getName());\r\n    return (ConstructorDelegate) super.create(key);\r\n}\n@Override\r\nprotected ClassLoader getDefaultClassLoader() {\r\n    return targetClass.getClassLoader();\r\n}\n@Override\r\nprotected ProtectionDomain getProtectionDomain() {\r\n    return ReflectUtils.getProtectionDomain(targetClass);\r\n}\n@Override\r\npublic void generateClass(ClassVisitor v) {\r\n    setNamePrefix(targetClass.getName());\r\n    final Method newInstance = ReflectUtils.findNewInstance(iface);\r\n    if (!newInstance.getReturnType().isAssignableFrom(targetClass)) {\r\n        throw new IllegalArgumentException(\"incompatible return type\");\r\n    }\r\n    final Constructor constructor;\r\n    try {\r\n        constructor = targetClass.getDeclaredConstructor(newInstance.getParameterTypes());\r\n    } catch (NoSuchMethodException e) {\r\n        throw new IllegalArgumentException(\"interface does not match any known constructor\");\r\n    }\r\n    ClassEmitter ce = new ClassEmitter(v);\r\n    ce.begin_class(Constants.V1_8, Constants.ACC_PUBLIC, getClassName(), CONSTRUCTOR_DELEGATE, new Type[] { Type.getType(iface) }, Constants.SOURCE_FILE);\r\n    Type declaring = Type.getType(constructor.getDeclaringClass());\r\n    EmitUtils.null_constructor(ce);\r\n    CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, ReflectUtils.getSignature(newInstance), ReflectUtils.getExceptionTypes(newInstance));\r\n    e.new_instance(declaring);\r\n    e.dup();\r\n    e.load_args();\r\n    e.invoke_constructor(declaring, ReflectUtils.getSignature(constructor));\r\n    e.return_value();\r\n    e.end_method();\r\n    ce.end_class();\r\n}\n@Override\r\nprotected Object firstInstance(Class type) {\r\n    return ReflectUtils.newInstance(type);\r\n}\n@Override\r\nprotected Object nextInstance(Object instance) {\r\n    return instance;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#setInterface(Class)",
    "entityType": "method",
    "code": "public void setInterface(Class iface) {\r\n    this.iface = iface;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#setTargetClass(Class)",
    "entityType": "method",
    "code": "public void setTargetClass(Class targetClass) {\r\n    this.targetClass = targetClass;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#create()",
    "entityType": "method",
    "code": "public ConstructorDelegate create() {\r\n    setNamePrefix(targetClass.getName());\r\n    Object key = KEY_FACTORY.newInstance(iface.getName(), targetClass.getName());\r\n    return (ConstructorDelegate) super.create(key);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#getDefaultClassLoader()",
    "entityType": "method",
    "code": "@Override\r\nprotected ClassLoader getDefaultClassLoader() {\r\n    return targetClass.getClassLoader();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#getProtectionDomain()",
    "entityType": "method",
    "code": "@Override\r\nprotected ProtectionDomain getProtectionDomain() {\r\n    return ReflectUtils.getProtectionDomain(targetClass);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#generateClass(ClassVisitor)",
    "entityType": "method",
    "code": "@Override\r\npublic void generateClass(ClassVisitor v) {\r\n    setNamePrefix(targetClass.getName());\r\n    final Method newInstance = ReflectUtils.findNewInstance(iface);\r\n    if (!newInstance.getReturnType().isAssignableFrom(targetClass)) {\r\n        throw new IllegalArgumentException(\"incompatible return type\");\r\n    }\r\n    final Constructor constructor;\r\n    try {\r\n        constructor = targetClass.getDeclaredConstructor(newInstance.getParameterTypes());\r\n    } catch (NoSuchMethodException e) {\r\n        throw new IllegalArgumentException(\"interface does not match any known constructor\");\r\n    }\r\n    ClassEmitter ce = new ClassEmitter(v);\r\n    ce.begin_class(Constants.V1_8, Constants.ACC_PUBLIC, getClassName(), CONSTRUCTOR_DELEGATE, new Type[] { Type.getType(iface) }, Constants.SOURCE_FILE);\r\n    Type declaring = Type.getType(constructor.getDeclaringClass());\r\n    EmitUtils.null_constructor(ce);\r\n    CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, ReflectUtils.getSignature(newInstance), ReflectUtils.getExceptionTypes(newInstance));\r\n    e.new_instance(declaring);\r\n    e.dup();\r\n    e.load_args();\r\n    e.invoke_constructor(declaring, ReflectUtils.getSignature(constructor));\r\n    e.return_value();\r\n    e.end_method();\r\n    ce.end_class();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#firstInstance(Class)",
    "entityType": "method",
    "code": "@Override\r\nprotected Object firstInstance(Class type) {\r\n    return ReflectUtils.newInstance(type);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#nextInstance(Object)",
    "entityType": "method",
    "code": "@Override\r\nprotected Object nextInstance(Object instance) {\r\n    return instance;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastClass",
    "entityType": "class",
    "code": "private Class type;\nprotected FastClass() {\r\n    throw new Error(\"Using the FastClass empty constructor--please report to the cglib-devel mailing list\");\r\n}\nprotected FastClass(Class type) {\r\n    this.type = type;\r\n}\npublic static FastClass create(Class type) {\r\n    return create(type.getClassLoader(), type);\r\n}\npublic static FastClass create(ClassLoader loader, Class type) {\r\n    Generator gen = new Generator();\r\n    gen.setType(type);\r\n    gen.setClassLoader(loader);\r\n    return gen.create();\r\n}\npublic static class Generator extends AbstractClassGenerator {\r\n\r\n    private static final Source SOURCE = new Source(FastClass.class.getName());\r\n\r\n    private Class type;\r\n\r\n    public Generator() {\r\n        super(SOURCE);\r\n    }\r\n\r\n    public void setType(Class type) {\r\n        this.type = type;\r\n    }\r\n\r\n    public FastClass create() {\r\n        setNamePrefix(type.getName());\r\n        return (FastClass) super.create(type.getName());\r\n    }\r\n\r\n    @Override\r\n    protected ClassLoader getDefaultClassLoader() {\r\n        return type.getClassLoader();\r\n    }\r\n\r\n    @Override\r\n    protected ProtectionDomain getProtectionDomain() {\r\n        return ReflectUtils.getProtectionDomain(type);\r\n    }\r\n\r\n    @Override\r\n    public void generateClass(ClassVisitor v) throws Exception {\r\n        new FastClassEmitter(v, getClassName(), type);\r\n    }\r\n\r\n    @Override\r\n    protected Object firstInstance(Class type) {\r\n        return ReflectUtils.newInstance(type, new Class[] { Class.class }, new Object[] { this.type });\r\n    }\r\n\r\n    @Override\r\n    protected Object nextInstance(Object instance) {\r\n        return instance;\r\n    }\r\n}\npublic Object invoke(String name, Class[] parameterTypes, Object obj, Object[] args) throws InvocationTargetException {\r\n    return invoke(getIndex(name, parameterTypes), obj, args);\r\n}\npublic Object newInstance() throws InvocationTargetException {\r\n    return newInstance(getIndex(Constants.EMPTY_CLASS_ARRAY), null);\r\n}\npublic Object newInstance(Class[] parameterTypes, Object[] args) throws InvocationTargetException {\r\n    return newInstance(getIndex(parameterTypes), args);\r\n}\npublic FastMethod getMethod(Method method) {\r\n    return new FastMethod(this, method);\r\n}\npublic FastConstructor getConstructor(Constructor constructor) {\r\n    return new FastConstructor(this, constructor);\r\n}\npublic FastMethod getMethod(String name, Class[] parameterTypes) {\r\n    try {\r\n        return getMethod(type.getMethod(name, parameterTypes));\r\n    } catch (NoSuchMethodException e) {\r\n        throw new NoSuchMethodError(e.getMessage());\r\n    }\r\n}\npublic FastConstructor getConstructor(Class[] parameterTypes) {\r\n    try {\r\n        return getConstructor(type.getConstructor(parameterTypes));\r\n    } catch (NoSuchMethodException e) {\r\n        throw new NoSuchMethodError(e.getMessage());\r\n    }\r\n}\npublic String getName() {\r\n    return type.getName();\r\n}\npublic Class getJavaClass() {\r\n    return type;\r\n}\n@Override\r\npublic String toString() {\r\n    return type.toString();\r\n}\n@Override\r\npublic int hashCode() {\r\n    return type.hashCode();\r\n}\n@Override\r\npublic boolean equals(Object o) {\r\n    if (o == null || !(o instanceof FastClass that)) {\r\n        return false;\r\n    }\r\n    return type.equals(that.type);\r\n}\n/**\r\n * Return the index of the matching method. The index may be used\r\n * later to invoke the method with less overhead. If more than one\r\n * method matches (i.e. they differ by return type only), one is\r\n * chosen arbitrarily.\r\n * @see #invoke(int, Object, Object[])\r\n * @param name the method name\r\n * @param parameterTypes the parameter array\r\n * @return the index, or <code>-1</code> if none is found.\r\n */\r\nabstract public int getIndex(String name, Class[] parameterTypes);\n/**\r\n * Return the index of the matching constructor. The index may be used\r\n * later to create a new instance with less overhead.\r\n * @see #newInstance(int, Object[])\r\n * @param parameterTypes the parameter array\r\n * @return the constructor index, or <code>-1</code> if none is found.\r\n */\r\nabstract public int getIndex(Class[] parameterTypes);\n/**\r\n * Invoke the method with the specified index.\r\n * @see getIndex(name, Class[])\r\n * @param index the method index\r\n * @param obj the object the underlying method is invoked from\r\n * @param args the arguments used for the method call\r\n * @throws java.lang.reflect.InvocationTargetException if the underlying method throws an exception\r\n */\r\nabstract public Object invoke(int index, Object obj, Object[] args) throws InvocationTargetException;\n/**\r\n * Create a new instance using the specified constructor index and arguments.\r\n * @see getIndex(Class[])\r\n * @param index the constructor index\r\n * @param args the arguments passed to the constructor\r\n * @throws java.lang.reflect.InvocationTargetException if the constructor throws an exception\r\n */\r\nabstract public Object newInstance(int index, Object[] args) throws InvocationTargetException;\nabstract public int getIndex(Signature sig);\n/**\r\n * Returns the maximum method index for this class.\r\n */\r\nabstract public int getMaxIndex();\nprotected static String getSignatureWithoutReturnType(String name, Class[] parameterTypes) {\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(name);\r\n    sb.append('(');\r\n    for (Class parameterType : parameterTypes) {\r\n        sb.append(Type.getDescriptor(parameterType));\r\n    }\r\n    sb.append(')');\r\n    return sb.toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastClass#create(Class)",
    "entityType": "method",
    "code": "public static FastClass create(Class type) {\r\n    return create(type.getClassLoader(), type);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastClass#create(ClassLoader,Class)",
    "entityType": "method",
    "code": "public static FastClass create(ClassLoader loader, Class type) {\r\n    Generator gen = new Generator();\r\n    gen.setType(type);\r\n    gen.setClassLoader(loader);\r\n    return gen.create();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastClass#invoke(String,Class[],Object,Object[])",
    "entityType": "method",
    "code": "public Object invoke(String name, Class[] parameterTypes, Object obj, Object[] args) throws InvocationTargetException {\r\n    return invoke(getIndex(name, parameterTypes), obj, args);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastClass#newInstance()",
    "entityType": "method",
    "code": "public Object newInstance() throws InvocationTargetException {\r\n    return newInstance(getIndex(Constants.EMPTY_CLASS_ARRAY), null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastClass#newInstance(Class[],Object[])",
    "entityType": "method",
    "code": "public Object newInstance(Class[] parameterTypes, Object[] args) throws InvocationTargetException {\r\n    return newInstance(getIndex(parameterTypes), args);\r\n}",
    "comment": ""
  }
]