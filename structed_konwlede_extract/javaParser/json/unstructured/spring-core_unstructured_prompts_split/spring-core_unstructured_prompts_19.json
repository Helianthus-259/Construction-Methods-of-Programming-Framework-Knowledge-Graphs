[
  {
    "entityId": "org.springframework.util.NumberUtilsTests#parseNumberRequiringTrimUsingNumberFormat()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseNumberRequiringTrimUsingNumberFormat() {\r\n    NumberFormat nf = NumberFormat.getNumberInstance(Locale.US);\r\n    String aByte = \" \" + Byte.MAX_VALUE + \" \";\r\n    String aShort = \" \" + Short.MAX_VALUE + \" \";\r\n    String anInteger = \" \" + Integer.MAX_VALUE + \" \";\r\n    String aLong = \" \" + Long.MAX_VALUE + \" \";\r\n    String aFloat = \" \" + Float.MAX_VALUE + \" \";\r\n    String aDouble = \" \" + Double.MAX_VALUE + \" \";\r\n    assertThat(NumberUtils.parseNumber(aByte, Byte.class, nf)).as(\"Byte did not parse\").isEqualTo(Byte.valueOf(Byte.MAX_VALUE));\r\n    assertThat(NumberUtils.parseNumber(aShort, Short.class, nf)).as(\"Short did not parse\").isEqualTo(Short.valueOf(Short.MAX_VALUE));\r\n    assertThat(NumberUtils.parseNumber(anInteger, Integer.class, nf)).as(\"Integer did not parse\").isEqualTo(Integer.valueOf(Integer.MAX_VALUE));\r\n    assertThat(NumberUtils.parseNumber(aLong, Long.class, nf)).as(\"Long did not parse\").isEqualTo(Long.valueOf(Long.MAX_VALUE));\r\n    assertThat(NumberUtils.parseNumber(aFloat, Float.class, nf)).as(\"Float did not parse\").isEqualTo(Float.valueOf(Float.MAX_VALUE));\r\n    assertThat(NumberUtils.parseNumber(aDouble, Double.class, nf)).as(\"Double did not parse\").isEqualTo(Double.valueOf(Double.MAX_VALUE));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.NumberUtilsTests#parseNumberAsHex()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseNumberAsHex() {\r\n    String aByte = \"0x\" + Integer.toHexString(Byte.MAX_VALUE);\r\n    String aShort = \"0x\" + Integer.toHexString(Short.MAX_VALUE);\r\n    String anInteger = \"0x\" + Integer.toHexString(Integer.MAX_VALUE);\r\n    String aLong = \"0x\" + Long.toHexString(Long.MAX_VALUE);\r\n    String aReallyBigInt = \"FEBD4E677898DFEBFFEE44\";\r\n    assertByteEquals(aByte);\r\n    assertShortEquals(aShort);\r\n    assertIntegerEquals(anInteger);\r\n    assertLongEquals(aLong);\r\n    assertThat(NumberUtils.parseNumber(\"0x\" + aReallyBigInt, BigInteger.class)).as(\"BigInteger did not parse\").isEqualTo(new BigInteger(aReallyBigInt, 16));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.NumberUtilsTests#parseNumberAsNegativeHex()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseNumberAsNegativeHex() {\r\n    String aByte = \"-0x80\";\r\n    String aShort = \"-0x8000\";\r\n    String anInteger = \"-0x80000000\";\r\n    String aLong = \"-0x8000000000000000\";\r\n    String aReallyBigInt = \"FEBD4E677898DFEBFFEE44\";\r\n    assertNegativeByteEquals(aByte);\r\n    assertNegativeShortEquals(aShort);\r\n    assertNegativeIntegerEquals(anInteger);\r\n    assertNegativeLongEquals(aLong);\r\n    assertThat(NumberUtils.parseNumber(\"-0x\" + aReallyBigInt, BigInteger.class)).as(\"BigInteger did not parse\").isEqualTo(new BigInteger(aReallyBigInt, 16).negate());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.NumberUtilsTests#convertDoubleToBigInteger()",
    "entityType": "method",
    "code": "@Test\r\nvoid convertDoubleToBigInteger() {\r\n    Double decimal = 3.14d;\r\n    assertThat(NumberUtils.convertNumberToTargetClass(decimal, BigInteger.class)).isEqualTo(new BigInteger(\"3\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.NumberUtilsTests#convertBigDecimalToBigInteger()",
    "entityType": "method",
    "code": "@Test\r\nvoid convertBigDecimalToBigInteger() {\r\n    String number = \"987459837583750387355346\";\r\n    BigDecimal decimal = new BigDecimal(number);\r\n    assertThat(NumberUtils.convertNumberToTargetClass(decimal, BigInteger.class)).isEqualTo(new BigInteger(number));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.NumberUtilsTests#convertNonExactBigDecimalToBigInteger()",
    "entityType": "method",
    "code": "@Test\r\nvoid convertNonExactBigDecimalToBigInteger() {\r\n    BigDecimal decimal = new BigDecimal(\"987459837583750387355346.14\");\r\n    assertThat(NumberUtils.convertNumberToTargetClass(decimal, BigInteger.class)).isEqualTo(new BigInteger(\"987459837583750387355346\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.NumberUtilsTests#parseBigDecimalNumber1()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseBigDecimalNumber1() {\r\n    String bigDecimalAsString = \"0.10\";\r\n    Number bigDecimal = NumberUtils.parseNumber(bigDecimalAsString, BigDecimal.class);\r\n    assertThat(bigDecimal).isEqualTo(new BigDecimal(bigDecimalAsString));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.NumberUtilsTests#parseBigDecimalNumber2()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseBigDecimalNumber2() {\r\n    String bigDecimalAsString = \"0.001\";\r\n    Number bigDecimal = NumberUtils.parseNumber(bigDecimalAsString, BigDecimal.class);\r\n    assertThat(bigDecimal).isEqualTo(new BigDecimal(bigDecimalAsString));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.NumberUtilsTests#parseBigDecimalNumber3()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseBigDecimalNumber3() {\r\n    String bigDecimalAsString = \"3.14159265358979323846\";\r\n    Number bigDecimal = NumberUtils.parseNumber(bigDecimalAsString, BigDecimal.class);\r\n    assertThat(bigDecimal).isEqualTo(new BigDecimal(bigDecimalAsString));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.NumberUtilsTests#parseLocalizedBigDecimalNumber1()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseLocalizedBigDecimalNumber1() {\r\n    String bigDecimalAsString = \"0.10\";\r\n    NumberFormat numberFormat = NumberFormat.getInstance(Locale.ENGLISH);\r\n    Number bigDecimal = NumberUtils.parseNumber(bigDecimalAsString, BigDecimal.class, numberFormat);\r\n    assertThat(bigDecimal).isEqualTo(new BigDecimal(bigDecimalAsString));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.NumberUtilsTests#parseLocalizedBigDecimalNumber2()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseLocalizedBigDecimalNumber2() {\r\n    String bigDecimalAsString = \"0.001\";\r\n    NumberFormat numberFormat = NumberFormat.getInstance(Locale.ENGLISH);\r\n    Number bigDecimal = NumberUtils.parseNumber(bigDecimalAsString, BigDecimal.class, numberFormat);\r\n    assertThat(bigDecimal).isEqualTo(new BigDecimal(bigDecimalAsString));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.NumberUtilsTests#parseLocalizedBigDecimalNumber3()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseLocalizedBigDecimalNumber3() {\r\n    String bigDecimalAsString = \"3.14159265358979323846\";\r\n    NumberFormat numberFormat = NumberFormat.getInstance(Locale.ENGLISH);\r\n    Number bigDecimal = NumberUtils.parseNumber(bigDecimalAsString, BigDecimal.class, numberFormat);\r\n    assertThat(bigDecimal).isEqualTo(new BigDecimal(bigDecimalAsString));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.NumberUtilsTests#parseOverflow()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseOverflow() {\r\n    String aLong = \"\" + Long.MAX_VALUE;\r\n    String aDouble = \"\" + Double.MAX_VALUE;\r\n    assertThatIllegalArgumentException().isThrownBy(() -> NumberUtils.parseNumber(aLong, Byte.class));\r\n    assertThatIllegalArgumentException().isThrownBy(() -> NumberUtils.parseNumber(aLong, Short.class));\r\n    assertThatIllegalArgumentException().isThrownBy(() -> NumberUtils.parseNumber(aLong, Integer.class));\r\n    assertThat(NumberUtils.parseNumber(aLong, Long.class)).isEqualTo(Long.valueOf(Long.MAX_VALUE));\r\n    assertThat(NumberUtils.parseNumber(aDouble, Double.class)).isEqualTo(Double.valueOf(Double.MAX_VALUE));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.NumberUtilsTests#parseNegativeOverflow()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseNegativeOverflow() {\r\n    String aLong = \"\" + Long.MIN_VALUE;\r\n    String aDouble = \"\" + Double.MIN_VALUE;\r\n    assertThatIllegalArgumentException().isThrownBy(() -> NumberUtils.parseNumber(aLong, Byte.class));\r\n    assertThatIllegalArgumentException().isThrownBy(() -> NumberUtils.parseNumber(aLong, Short.class));\r\n    assertThatIllegalArgumentException().isThrownBy(() -> NumberUtils.parseNumber(aLong, Integer.class));\r\n    assertThat(NumberUtils.parseNumber(aLong, Long.class)).isEqualTo(Long.valueOf(Long.MIN_VALUE));\r\n    assertThat(NumberUtils.parseNumber(aDouble, Double.class)).isEqualTo(Double.valueOf(Double.MIN_VALUE));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.NumberUtilsTests#parseOverflowUsingNumberFormat()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseOverflowUsingNumberFormat() {\r\n    NumberFormat nf = NumberFormat.getNumberInstance(Locale.US);\r\n    String aLong = \"\" + Long.MAX_VALUE;\r\n    String aDouble = \"\" + Double.MAX_VALUE;\r\n    assertThatIllegalArgumentException().isThrownBy(() -> NumberUtils.parseNumber(aLong, Byte.class, nf));\r\n    assertThatIllegalArgumentException().isThrownBy(() -> NumberUtils.parseNumber(aLong, Short.class, nf));\r\n    assertThatIllegalArgumentException().isThrownBy(() -> NumberUtils.parseNumber(aLong, Integer.class, nf));\r\n    assertThat(NumberUtils.parseNumber(aLong, Long.class, nf)).isEqualTo(Long.valueOf(Long.MAX_VALUE));\r\n    assertThat(NumberUtils.parseNumber(aDouble, Double.class, nf)).isEqualTo(Double.valueOf(Double.MAX_VALUE));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.NumberUtilsTests#parseNegativeOverflowUsingNumberFormat()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseNegativeOverflowUsingNumberFormat() {\r\n    NumberFormat nf = NumberFormat.getNumberInstance(Locale.US);\r\n    String aLong = \"\" + Long.MIN_VALUE;\r\n    String aDouble = \"\" + Double.MIN_VALUE;\r\n    assertThatIllegalArgumentException().isThrownBy(() -> NumberUtils.parseNumber(aLong, Byte.class, nf));\r\n    assertThatIllegalArgumentException().isThrownBy(() -> NumberUtils.parseNumber(aLong, Short.class, nf));\r\n    assertThatIllegalArgumentException().isThrownBy(() -> NumberUtils.parseNumber(aLong, Integer.class, nf));\r\n    assertThat(NumberUtils.parseNumber(aLong, Long.class, nf)).isEqualTo(Long.valueOf(Long.MIN_VALUE));\r\n    assertThat(NumberUtils.parseNumber(aDouble, Double.class, nf)).isEqualTo(Double.valueOf(Double.MIN_VALUE));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.NumberUtilsTests#convertToInteger()",
    "entityType": "method",
    "code": "@Test\r\nvoid convertToInteger() {\r\n    assertThat(NumberUtils.convertNumberToTargetClass(BigInteger.valueOf(-1), Integer.class)).isEqualTo(Integer.valueOf(-1));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(BigInteger.valueOf(0), Integer.class)).isEqualTo(Integer.valueOf(0));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(BigInteger.valueOf(1), Integer.class)).isEqualTo(Integer.valueOf(1));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(BigInteger.valueOf(Integer.MAX_VALUE), Integer.class)).isEqualTo(Integer.valueOf(Integer.MAX_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(BigInteger.valueOf(Integer.MAX_VALUE + 1), Integer.class)).isEqualTo(Integer.valueOf(Integer.MIN_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(BigInteger.valueOf(Integer.MIN_VALUE), Integer.class)).isEqualTo(Integer.valueOf(Integer.MIN_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(BigInteger.valueOf(Integer.MIN_VALUE - 1), Integer.class)).isEqualTo(Integer.valueOf(Integer.MAX_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass((long) -1, Integer.class)).isEqualTo(Integer.valueOf(-1));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(0L, Integer.class)).isEqualTo(Integer.valueOf(0));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(1L, Integer.class)).isEqualTo(Integer.valueOf(1));\r\n    assertThat(NumberUtils.convertNumberToTargetClass((long) Integer.MAX_VALUE, Integer.class)).isEqualTo(Integer.valueOf(Integer.MAX_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass((long) (Integer.MAX_VALUE + 1), Integer.class)).isEqualTo(Integer.valueOf(Integer.MIN_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass((long) Integer.MIN_VALUE, Integer.class)).isEqualTo(Integer.valueOf(Integer.MIN_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass((long) (Integer.MIN_VALUE - 1), Integer.class)).isEqualTo(Integer.valueOf(Integer.MAX_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(-1, Integer.class)).isEqualTo(Integer.valueOf(-1));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(0, Integer.class)).isEqualTo(Integer.valueOf(0));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(1, Integer.class)).isEqualTo(Integer.valueOf(1));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(Integer.MAX_VALUE, Integer.class)).isEqualTo(Integer.valueOf(Integer.MAX_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(Integer.MAX_VALUE + 1, Integer.class)).isEqualTo(Integer.valueOf(Integer.MIN_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(Integer.MIN_VALUE, Integer.class)).isEqualTo(Integer.valueOf(Integer.MIN_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(Integer.MIN_VALUE - 1, Integer.class)).isEqualTo(Integer.valueOf(Integer.MAX_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass((short) -1, Integer.class)).isEqualTo(Integer.valueOf(-1));\r\n    assertThat(NumberUtils.convertNumberToTargetClass((short) 0, Integer.class)).isEqualTo(Integer.valueOf(0));\r\n    assertThat(NumberUtils.convertNumberToTargetClass((short) 1, Integer.class)).isEqualTo(Integer.valueOf(1));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(Short.MAX_VALUE, Integer.class)).isEqualTo(Integer.valueOf(Short.MAX_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass((short) (Short.MAX_VALUE + 1), Integer.class)).isEqualTo(Integer.valueOf(Short.MIN_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(Short.MIN_VALUE, Integer.class)).isEqualTo(Integer.valueOf(Short.MIN_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass((short) (Short.MIN_VALUE - 1), Integer.class)).isEqualTo(Integer.valueOf(Short.MAX_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass((byte) -1, Integer.class)).isEqualTo(Integer.valueOf(-1));\r\n    assertThat(NumberUtils.convertNumberToTargetClass((byte) 0, Integer.class)).isEqualTo(Integer.valueOf(0));\r\n    assertThat(NumberUtils.convertNumberToTargetClass((byte) 1, Integer.class)).isEqualTo(Integer.valueOf(1));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(Byte.MAX_VALUE, Integer.class)).isEqualTo(Integer.valueOf(Byte.MAX_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass((byte) (Byte.MAX_VALUE + 1), Integer.class)).isEqualTo(Integer.valueOf(Byte.MIN_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(Byte.MIN_VALUE, Integer.class)).isEqualTo(Integer.valueOf(Byte.MIN_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass((byte) (Byte.MIN_VALUE - 1), Integer.class)).isEqualTo(Integer.valueOf(Byte.MAX_VALUE));\r\n    assertToNumberOverflow(Long.MAX_VALUE + 1, Integer.class);\r\n    assertToNumberOverflow(Long.MIN_VALUE - 1, Integer.class);\r\n    assertToNumberOverflow(BigInteger.valueOf(Integer.MAX_VALUE).add(BigInteger.ONE), Integer.class);\r\n    assertToNumberOverflow(BigInteger.valueOf(Integer.MIN_VALUE).subtract(BigInteger.ONE), Integer.class);\r\n    assertToNumberOverflow(new BigDecimal(\"18446744073709551611\"), Integer.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.NumberUtilsTests#convertToLong()",
    "entityType": "method",
    "code": "@Test\r\nvoid convertToLong() {\r\n    assertThat(NumberUtils.convertNumberToTargetClass(BigInteger.valueOf(-1), Long.class)).isEqualTo(Long.valueOf(-1));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(BigInteger.valueOf(0), Long.class)).isEqualTo(Long.valueOf(0));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(BigInteger.valueOf(1), Long.class)).isEqualTo(Long.valueOf(1));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(BigInteger.valueOf(Long.MAX_VALUE), Long.class)).isEqualTo(Long.valueOf(Long.MAX_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(BigInteger.valueOf(Long.MAX_VALUE + 1), Long.class)).isEqualTo(Long.valueOf(Long.MIN_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(BigInteger.valueOf(Long.MIN_VALUE), Long.class)).isEqualTo(Long.valueOf(Long.MIN_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(BigInteger.valueOf(Long.MIN_VALUE - 1), Long.class)).isEqualTo(Long.valueOf(Long.MAX_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass((long) -1, Long.class)).isEqualTo(Long.valueOf(-1));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(0L, Long.class)).isEqualTo(Long.valueOf(0));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(1L, Long.class)).isEqualTo(Long.valueOf(1));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(Long.MAX_VALUE, Long.class)).isEqualTo(Long.valueOf(Long.MAX_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(Long.MAX_VALUE + 1, Long.class)).isEqualTo(Long.valueOf(Long.MIN_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(Long.MIN_VALUE, Long.class)).isEqualTo(Long.valueOf(Long.MIN_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(Long.MIN_VALUE - 1, Long.class)).isEqualTo(Long.valueOf(Long.MAX_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(-1, Long.class)).isEqualTo(Long.valueOf(-1));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(0, Long.class)).isEqualTo(Long.valueOf(0));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(1, Long.class)).isEqualTo(Long.valueOf(1));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(Integer.MAX_VALUE, Long.class)).isEqualTo(Long.valueOf(Integer.MAX_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(Integer.MAX_VALUE + 1, Long.class)).isEqualTo(Long.valueOf(Integer.MIN_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(Integer.MIN_VALUE, Long.class)).isEqualTo(Long.valueOf(Integer.MIN_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(Integer.MIN_VALUE - 1, Long.class)).isEqualTo(Long.valueOf(Integer.MAX_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass((short) -1, Long.class)).isEqualTo(Long.valueOf(-1));\r\n    assertThat(NumberUtils.convertNumberToTargetClass((short) 0, Long.class)).isEqualTo(Long.valueOf(0));\r\n    assertThat(NumberUtils.convertNumberToTargetClass((short) 1, Long.class)).isEqualTo(Long.valueOf(1));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(Short.MAX_VALUE, Long.class)).isEqualTo(Long.valueOf(Short.MAX_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass((short) (Short.MAX_VALUE + 1), Long.class)).isEqualTo(Long.valueOf(Short.MIN_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(Short.MIN_VALUE, Long.class)).isEqualTo(Long.valueOf(Short.MIN_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass((short) (Short.MIN_VALUE - 1), Long.class)).isEqualTo(Long.valueOf(Short.MAX_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass((byte) -1, Long.class)).isEqualTo(Long.valueOf(-1));\r\n    assertThat(NumberUtils.convertNumberToTargetClass((byte) 0, Long.class)).isEqualTo(Long.valueOf(0));\r\n    assertThat(NumberUtils.convertNumberToTargetClass((byte) 1, Long.class)).isEqualTo(Long.valueOf(1));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(Byte.MAX_VALUE, Long.class)).isEqualTo(Long.valueOf(Byte.MAX_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass((byte) (Byte.MAX_VALUE + 1), Long.class)).isEqualTo(Long.valueOf(Byte.MIN_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass(Byte.MIN_VALUE, Long.class)).isEqualTo(Long.valueOf(Byte.MIN_VALUE));\r\n    assertThat(NumberUtils.convertNumberToTargetClass((byte) (Byte.MIN_VALUE - 1), Long.class)).isEqualTo(Long.valueOf(Byte.MAX_VALUE));\r\n    assertToNumberOverflow(BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE), Long.class);\r\n    assertToNumberOverflow(BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.ONE), Long.class);\r\n    assertToNumberOverflow(new BigDecimal(\"18446744073709551611\"), Long.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.NumberUtilsTests#assertLongEquals(String)",
    "entityType": "method",
    "code": "private void assertLongEquals(String aLong) {\r\n    assertThat(NumberUtils.parseNumber(aLong, Long.class)).as(\"Long did not parse\").isEqualTo(Long.MAX_VALUE);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.NumberUtilsTests#assertIntegerEquals(String)",
    "entityType": "method",
    "code": "private void assertIntegerEquals(String anInteger) {\r\n    assertThat(NumberUtils.parseNumber(anInteger, Integer.class)).as(\"Integer did not parse\").isEqualTo(Integer.MAX_VALUE);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.NumberUtilsTests#assertShortEquals(String)",
    "entityType": "method",
    "code": "private void assertShortEquals(String aShort) {\r\n    assertThat(NumberUtils.parseNumber(aShort, Short.class)).as(\"Short did not parse\").isEqualTo(Short.MAX_VALUE);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.NumberUtilsTests#assertByteEquals(String)",
    "entityType": "method",
    "code": "private void assertByteEquals(String aByte) {\r\n    assertThat(NumberUtils.parseNumber(aByte, Byte.class)).as(\"Byte did not parse\").isEqualTo(Byte.MAX_VALUE);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.NumberUtilsTests#assertNegativeLongEquals(String)",
    "entityType": "method",
    "code": "private void assertNegativeLongEquals(String aLong) {\r\n    assertThat(NumberUtils.parseNumber(aLong, Long.class)).as(\"Long did not parse\").isEqualTo(Long.MIN_VALUE);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.NumberUtilsTests#assertNegativeIntegerEquals(String)",
    "entityType": "method",
    "code": "private void assertNegativeIntegerEquals(String anInteger) {\r\n    assertThat(NumberUtils.parseNumber(anInteger, Integer.class)).as(\"Integer did not parse\").isEqualTo(Integer.MIN_VALUE);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.NumberUtilsTests#assertNegativeShortEquals(String)",
    "entityType": "method",
    "code": "private void assertNegativeShortEquals(String aShort) {\r\n    assertThat(NumberUtils.parseNumber(aShort, Short.class)).as(\"Short did not parse\").isEqualTo(Short.MIN_VALUE);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.NumberUtilsTests#assertNegativeByteEquals(String)",
    "entityType": "method",
    "code": "private void assertNegativeByteEquals(String aByte) {\r\n    assertThat(NumberUtils.parseNumber(aByte, Byte.class)).as(\"Byte did not parse\").isEqualTo(Byte.MIN_VALUE);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.NumberUtilsTests#assertToNumberOverflow(Number,Class<? extends Number>)",
    "entityType": "method",
    "code": "private void assertToNumberOverflow(Number number, Class<? extends Number> targetClass) {\r\n    String msg = \"overflow: from=\" + number + \", toClass=\" + targetClass;\r\n    assertThatIllegalArgumentException().as(msg).isThrownBy(() -> NumberUtils.convertNumberToTargetClass(number, targetClass)).withMessageEndingWith(\"overflow\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.substitution.Target_Introspector",
    "entityType": "class",
    "code": "@Substitute\r\nprivate static Class<?> findCustomizerClass(Class<?> type) {\r\n    String name = type.getName() + \"Customizer\";\r\n    try {\r\n        type = Target_ClassFinder.findClass(name, type.getClassLoader());\r\n        if (Customizer.class.isAssignableFrom(type)) {\r\n            Class<?> c = type;\r\n            do {\r\n                c = c.getSuperclass();\r\n                if (c.getName().equals(\"java.awt.Component\")) {\r\n                    return type;\r\n                }\r\n            } while (!c.getName().equals(\"java.lang.Object\"));\r\n        }\r\n    } catch (Exception exception) ;\r\n    return null;\r\n}",
    "comment": "\n * {@link java.beans.Introspector} substitution with a refined {@code findCustomizerClass} implementation\n * designed to avoid thousands of AWT classes to be included in the native image.\n *\n * TODO Remove once Spring Framework requires GraalVM 23.0+, see <a href=\"https://github.com/oracle/graal/pull/5224\">graal#5224</a>.\n *\n * @author Sebastien Deleuze\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.nativex.substitution.Target_Introspector#findCustomizerClass(Class<?>)",
    "entityType": "method",
    "code": "@Substitute\r\nprivate static Class<?> findCustomizerClass(Class<?> type) {\r\n    String name = type.getName() + \"Customizer\";\r\n    try {\r\n        type = Target_ClassFinder.findClass(name, type.getClassLoader());\r\n        if (Customizer.class.isAssignableFrom(type)) {\r\n            Class<?> c = type;\r\n            do {\r\n                c = c.getSuperclass();\r\n                if (c.getName().equals(\"java.awt.Component\")) {\r\n                    return type;\r\n                }\r\n            } while (!c.getName().equals(\"java.lang.Object\"));\r\n        }\r\n    } catch (Exception exception) ;\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.AnnotationVisitor",
    "entityType": "class",
    "code": "/**\r\n * The ASM API version implemented by this visitor. The value of this field must be one of the\r\n * {@code ASM}<i>x</i> values in {@link Opcodes}.\r\n */\r\nprotected final int api;\n/**\r\n * The annotation visitor to which this visitor must delegate method calls. May be {@literal\r\n * null}.\r\n */\r\nprotected AnnotationVisitor av;\n/**\r\n * Constructs a new {@link AnnotationVisitor}.\r\n *\r\n * @param api the ASM API version implemented by this visitor. Must be one of the {@code\r\n *     ASM}<i>x</i> values in {@link Opcodes}.\r\n */\r\nprotected AnnotationVisitor(final int api) {\r\n    this(api, null);\r\n}\n/**\r\n * Constructs a new {@link AnnotationVisitor}.\r\n *\r\n * @param api the ASM API version implemented by this visitor. Must be one of the {@code\r\n *     ASM}<i>x</i> values in {@link Opcodes}.\r\n * @param annotationVisitor the annotation visitor to which this visitor must delegate method\r\n *     calls. May be {@literal null}.\r\n */\r\nprotected AnnotationVisitor(final int api, final AnnotationVisitor annotationVisitor) {\r\n    if (api != Opcodes.ASM9 && api != Opcodes.ASM8 && api != Opcodes.ASM7 && api != Opcodes.ASM6 && api != Opcodes.ASM5 && api != Opcodes.ASM4 && api != Opcodes.ASM10_EXPERIMENTAL) {\r\n        throw new IllegalArgumentException(\"Unsupported api \" + api);\r\n    }\r\n    // SPRING PATCH: no preview mode check for ASM experimental\r\n    this.api = api;\r\n    this.av = annotationVisitor;\r\n}\n/**\r\n * The annotation visitor to which this visitor must delegate method calls. May be {@literal\r\n * null}.\r\n *\r\n * @return the annotation visitor to which this visitor must delegate method calls, or {@literal\r\n *     null}.\r\n */\r\npublic AnnotationVisitor getDelegate() {\r\n    return av;\r\n}\n/**\r\n * Visits a primitive value of the annotation.\r\n *\r\n * @param name the value name.\r\n * @param value the actual value, whose type must be {@link Byte}, {@link Boolean}, {@link\r\n *     Character}, {@link Short}, {@link Integer} , {@link Long}, {@link Float}, {@link Double},\r\n *     {@link String} or {@link Type} of {@link Type#OBJECT} or {@link Type#ARRAY} sort. This\r\n *     value can also be an array of byte, boolean, short, char, int, long, float or double values\r\n *     (this is equivalent to using {@link #visitArray} and visiting each array element in turn,\r\n *     but is more convenient).\r\n */\r\npublic void visit(final String name, final Object value) {\r\n    if (av != null) {\r\n        av.visit(name, value);\r\n    }\r\n}\n/**\r\n * Visits an enumeration value of the annotation.\r\n *\r\n * @param name the value name.\r\n * @param descriptor the class descriptor of the enumeration class.\r\n * @param value the actual enumeration value.\r\n */\r\npublic void visitEnum(final String name, final String descriptor, final String value) {\r\n    if (av != null) {\r\n        av.visitEnum(name, descriptor, value);\r\n    }\r\n}\n/**\r\n * Visits a nested annotation value of the annotation.\r\n *\r\n * @param name the value name.\r\n * @param descriptor the class descriptor of the nested annotation class.\r\n * @return a visitor to visit the actual nested annotation value, or {@literal null} if this\r\n *     visitor is not interested in visiting this nested annotation. <i>The nested annotation\r\n *     value must be fully visited before calling other methods on this annotation visitor</i>.\r\n */\r\npublic AnnotationVisitor visitAnnotation(final String name, final String descriptor) {\r\n    if (av != null) {\r\n        return av.visitAnnotation(name, descriptor);\r\n    }\r\n    return null;\r\n}\n/**\r\n * Visits an array value of the annotation. Note that arrays of primitive values (such as byte,\r\n * boolean, short, char, int, long, float or double) can be passed as value to {@link #visit\r\n * visit}. This is what {@link ClassReader} does for non empty arrays of primitive values.\r\n *\r\n * @param name the value name.\r\n * @return a visitor to visit the actual array value elements, or {@literal null} if this visitor\r\n *     is not interested in visiting these values. The 'name' parameters passed to the methods of\r\n *     this visitor are ignored. <i>All the array values must be visited before calling other\r\n *     methods on this annotation visitor</i>.\r\n */\r\npublic AnnotationVisitor visitArray(final String name) {\r\n    if (av != null) {\r\n        return av.visitArray(name);\r\n    }\r\n    return null;\r\n}\n/**\r\n * Visits the end of the annotation.\r\n */\r\npublic void visitEnd() {\r\n    if (av != null) {\r\n        av.visitEnd();\r\n    }\r\n}",
    "comment": "\n * A visitor to visit a Java annotation. The methods of this class must be called in the following\n * order: ( {@code visit} | {@code visitEnum} | {@code visitAnnotation} | {@code visitArray} )*\n * {@code visitEnd}.\n *\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n "
  },
  {
    "entityId": "org.springframework.asm.AnnotationVisitor#getDelegate()",
    "entityType": "method",
    "code": "/**\r\n * The annotation visitor to which this visitor must delegate method calls. May be {@literal\r\n * null}.\r\n *\r\n * @return the annotation visitor to which this visitor must delegate method calls, or {@literal\r\n *     null}.\r\n */\r\npublic AnnotationVisitor getDelegate() {\r\n    return av;\r\n}",
    "comment": "\n   * The annotation visitor to which this visitor must delegate method calls. May be {@literal\n   * null}.\n   *\n   * @return the annotation visitor to which this visitor must delegate method calls, or {@literal\n   *     null}.\n   "
  },
  {
    "entityId": "org.springframework.asm.AnnotationVisitor#visit(String,Object)",
    "entityType": "method",
    "code": "/**\r\n * Visits a primitive value of the annotation.\r\n *\r\n * @param name the value name.\r\n * @param value the actual value, whose type must be {@link Byte}, {@link Boolean}, {@link\r\n *     Character}, {@link Short}, {@link Integer} , {@link Long}, {@link Float}, {@link Double},\r\n *     {@link String} or {@link Type} of {@link Type#OBJECT} or {@link Type#ARRAY} sort. This\r\n *     value can also be an array of byte, boolean, short, char, int, long, float or double values\r\n *     (this is equivalent to using {@link #visitArray} and visiting each array element in turn,\r\n *     but is more convenient).\r\n */\r\npublic void visit(final String name, final Object value) {\r\n    if (av != null) {\r\n        av.visit(name, value);\r\n    }\r\n}",
    "comment": "\n   * Visits a primitive value of the annotation.\n   *\n   * @param name the value name.\n   * @param value the actual value, whose type must be {@link Byte}, {@link Boolean}, {@link\n   *     Character}, {@link Short}, {@link Integer} , {@link Long}, {@link Float}, {@link Double},\n   *     {@link String} or {@link Type} of {@link Type#OBJECT} or {@link Type#ARRAY} sort. This\n   *     value can also be an array of byte, boolean, short, char, int, long, float or double values\n   *     (this is equivalent to using {@link #visitArray} and visiting each array element in turn,\n   *     but is more convenient).\n   "
  },
  {
    "entityId": "org.springframework.asm.AnnotationVisitor#visitEnum(String,String,String)",
    "entityType": "method",
    "code": "/**\r\n * Visits an enumeration value of the annotation.\r\n *\r\n * @param name the value name.\r\n * @param descriptor the class descriptor of the enumeration class.\r\n * @param value the actual enumeration value.\r\n */\r\npublic void visitEnum(final String name, final String descriptor, final String value) {\r\n    if (av != null) {\r\n        av.visitEnum(name, descriptor, value);\r\n    }\r\n}",
    "comment": "\n   * Visits an enumeration value of the annotation.\n   *\n   * @param name the value name.\n   * @param descriptor the class descriptor of the enumeration class.\n   * @param value the actual enumeration value.\n   "
  },
  {
    "entityId": "org.springframework.asm.AnnotationVisitor#visitAnnotation(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Visits a nested annotation value of the annotation.\r\n *\r\n * @param name the value name.\r\n * @param descriptor the class descriptor of the nested annotation class.\r\n * @return a visitor to visit the actual nested annotation value, or {@literal null} if this\r\n *     visitor is not interested in visiting this nested annotation. <i>The nested annotation\r\n *     value must be fully visited before calling other methods on this annotation visitor</i>.\r\n */\r\npublic AnnotationVisitor visitAnnotation(final String name, final String descriptor) {\r\n    if (av != null) {\r\n        return av.visitAnnotation(name, descriptor);\r\n    }\r\n    return null;\r\n}",
    "comment": "\n   * Visits a nested annotation value of the annotation.\n   *\n   * @param name the value name.\n   * @param descriptor the class descriptor of the nested annotation class.\n   * @return a visitor to visit the actual nested annotation value, or {@literal null} if this\n   *     visitor is not interested in visiting this nested annotation. <i>The nested annotation\n   *     value must be fully visited before calling other methods on this annotation visitor</i>.\n   "
  },
  {
    "entityId": "org.springframework.asm.AnnotationVisitor#visitArray(String)",
    "entityType": "method",
    "code": "/**\r\n * Visits an array value of the annotation. Note that arrays of primitive values (such as byte,\r\n * boolean, short, char, int, long, float or double) can be passed as value to {@link #visit\r\n * visit}. This is what {@link ClassReader} does for non empty arrays of primitive values.\r\n *\r\n * @param name the value name.\r\n * @return a visitor to visit the actual array value elements, or {@literal null} if this visitor\r\n *     is not interested in visiting these values. The 'name' parameters passed to the methods of\r\n *     this visitor are ignored. <i>All the array values must be visited before calling other\r\n *     methods on this annotation visitor</i>.\r\n */\r\npublic AnnotationVisitor visitArray(final String name) {\r\n    if (av != null) {\r\n        return av.visitArray(name);\r\n    }\r\n    return null;\r\n}",
    "comment": "\n   * Visits an array value of the annotation. Note that arrays of primitive values (such as byte,\n   * boolean, short, char, int, long, float or double) can be passed as value to {@link #visit\n   * visit}. This is what {@link ClassReader} does for non empty arrays of primitive values.\n   *\n   * @param name the value name.\n   * @return a visitor to visit the actual array value elements, or {@literal null} if this visitor\n   *     is not interested in visiting these values. The 'name' parameters passed to the methods of\n   *     this visitor are ignored. <i>All the array values must be visited before calling other\n   *     methods on this annotation visitor</i>.\n   "
  },
  {
    "entityId": "org.springframework.asm.AnnotationVisitor#visitEnd()",
    "entityType": "method",
    "code": "/**\r\n * Visits the end of the annotation.\r\n */\r\npublic void visitEnd() {\r\n    if (av != null) {\r\n        av.visitEnd();\r\n    }\r\n}",
    "comment": " Visits the end of the annotation. "
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests",
    "entityType": "class",
    "code": "@Test\r\nvoid isCheckedException() {\r\n    assertThat(ObjectUtils.isCheckedException(new Exception())).isTrue();\r\n    assertThat(ObjectUtils.isCheckedException(new SQLException())).isTrue();\r\n    assertThat(ObjectUtils.isCheckedException(new RuntimeException())).isFalse();\r\n    assertThat(ObjectUtils.isCheckedException(new IllegalArgumentException(\"\"))).isFalse();\r\n    // Any Throwable other than RuntimeException and Error\r\n    // has to be considered checked according to the JLS.\r\n    assertThat(ObjectUtils.isCheckedException(new Throwable())).isTrue();\r\n}\n@Test\r\nvoid isCompatibleWithThrowsClause() {\r\n    Class<?>[] empty = new Class<?>[0];\r\n    Class<?>[] exception = new Class<?>[] { Exception.class };\r\n    Class<?>[] sqlAndIO = new Class<?>[] { SQLException.class, IOException.class };\r\n    Class<?>[] throwable = new Class<?>[] { Throwable.class };\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new RuntimeException())).isTrue();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new RuntimeException(), empty)).isTrue();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new RuntimeException(), exception)).isTrue();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new RuntimeException(), sqlAndIO)).isTrue();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new RuntimeException(), throwable)).isTrue();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new Exception())).isFalse();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new Exception(), empty)).isFalse();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new Exception(), exception)).isTrue();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new Exception(), sqlAndIO)).isFalse();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new Exception(), throwable)).isTrue();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new SQLException())).isFalse();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new SQLException(), empty)).isFalse();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new SQLException(), exception)).isTrue();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new SQLException(), sqlAndIO)).isTrue();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new SQLException(), throwable)).isTrue();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new Throwable())).isFalse();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new Throwable(), empty)).isFalse();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new Throwable(), exception)).isFalse();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new Throwable(), sqlAndIO)).isFalse();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new Throwable(), throwable)).isTrue();\r\n}\n@Test\r\nvoid isEmptyNull() {\r\n    assertThat(isEmpty(null)).isTrue();\r\n}\n@Test\r\nvoid isEmptyArray() {\r\n    assertThat(isEmpty(new char[0])).isTrue();\r\n    assertThat(isEmpty(new Object[0])).isTrue();\r\n    assertThat(isEmpty(new Integer[0])).isTrue();\r\n    assertThat(isEmpty(new int[] { 42 })).isFalse();\r\n    assertThat(isEmpty(new Integer[] { 42 })).isFalse();\r\n}\n@Test\r\nvoid isEmptyCollection() {\r\n    assertThat(isEmpty(Collections.emptyList())).isTrue();\r\n    assertThat(isEmpty(Collections.emptySet())).isTrue();\r\n    Set<String> set = new HashSet<>();\r\n    set.add(\"foo\");\r\n    assertThat(isEmpty(set)).isFalse();\r\n    assertThat(isEmpty(Collections.singletonList(\"foo\"))).isFalse();\r\n}\n@Test\r\nvoid isEmptyMap() {\r\n    assertThat(isEmpty(Collections.emptyMap())).isTrue();\r\n    HashMap<String, Object> map = new HashMap<>();\r\n    map.put(\"foo\", 42L);\r\n    assertThat(isEmpty(map)).isFalse();\r\n}\n@Test\r\nvoid isEmptyCharSequence() {\r\n    assertThat(isEmpty(new StringBuilder())).isTrue();\r\n    assertThat(isEmpty(\"\")).isTrue();\r\n    assertThat(isEmpty(new StringBuilder(\"foo\"))).isFalse();\r\n    assertThat(isEmpty(\"   \")).isFalse();\r\n    assertThat(isEmpty(\"\\t\")).isFalse();\r\n    assertThat(isEmpty(\"foo\")).isFalse();\r\n}\n@Test\r\nvoid isEmptyUnsupportedObjectType() {\r\n    assertThat(isEmpty(42L)).isFalse();\r\n    assertThat(isEmpty(new Object())).isFalse();\r\n}\n@Test\r\nvoid toObjectArray() {\r\n    int[] a = new int[] { 1, 2, 3, 4, 5 };\r\n    Integer[] wrapper = (Integer[]) ObjectUtils.toObjectArray(a);\r\n    assertThat(wrapper).hasSize(5);\r\n    for (int i = 0; i < wrapper.length; i++) {\r\n        assertThat(wrapper[i]).isEqualTo(a[i]);\r\n    }\r\n}\n@Test\r\nvoid toObjectArrayWithNull() {\r\n    Object[] objects = ObjectUtils.toObjectArray(null);\r\n    assertThat(objects).isNotNull();\r\n    assertThat(objects).isEmpty();\r\n}\n@Test\r\nvoid toObjectArrayWithEmptyPrimitiveArray() {\r\n    Object[] objects = ObjectUtils.toObjectArray(new byte[] ;);\r\n    assertThat(objects).isNotNull();\r\n    assertThat(objects).isEmpty();\r\n}\n@Test\r\nvoid toObjectArrayWithNonArrayType() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> ObjectUtils.toObjectArray(\"Not an []\")).withMessageStartingWith(\"Source is not an array\");\r\n}\n@Test\r\nvoid toObjectArrayWithNonPrimitiveArray() {\r\n    String[] source = { \"Bingo\" };\r\n    assertThat(ObjectUtils.toObjectArray(source)).isSameAs(source);\r\n}\n@Test\r\nvoid addObjectToArraySunnyDay() {\r\n    String[] array = { \"foo\", \"bar\" };\r\n    String newElement = \"baz\";\r\n    Object[] newArray = ObjectUtils.addObjectToArray(array, newElement);\r\n    assertThat(newArray).hasSize(3);\r\n    assertThat(newArray[2]).isEqualTo(newElement);\r\n}\n@Test\r\nvoid addObjectToArraysAtPosition() {\r\n    String[] array = { \"foo\", \"bar\", \"baz\" };\r\n    assertThat(ObjectUtils.addObjectToArray(array, \"bat\", 3)).containsExactly(\"foo\", \"bar\", \"baz\", \"bat\");\r\n    assertThat(ObjectUtils.addObjectToArray(array, \"bat\", 2)).containsExactly(\"foo\", \"bar\", \"bat\", \"baz\");\r\n    assertThat(ObjectUtils.addObjectToArray(array, \"bat\", 1)).containsExactly(\"foo\", \"bat\", \"bar\", \"baz\");\r\n    assertThat(ObjectUtils.addObjectToArray(array, \"bat\", 0)).containsExactly(\"bat\", \"foo\", \"bar\", \"baz\");\r\n}\n@Test\r\nvoid addObjectToArrayWhenEmpty() {\r\n    String[] array = new String[0];\r\n    String newElement = \"foo\";\r\n    String[] newArray = ObjectUtils.addObjectToArray(array, newElement);\r\n    assertThat(newArray).hasSize(1);\r\n    assertThat(newArray[0]).isEqualTo(newElement);\r\n}\n@Test\r\nvoid addObjectToSingleNonNullElementArray() {\r\n    String existingElement = \"foo\";\r\n    String[] array = { existingElement };\r\n    String newElement = \"bar\";\r\n    String[] newArray = ObjectUtils.addObjectToArray(array, newElement);\r\n    assertThat(newArray).hasSize(2);\r\n    assertThat(newArray[0]).isEqualTo(existingElement);\r\n    assertThat(newArray[1]).isEqualTo(newElement);\r\n}\n@Test\r\nvoid addObjectToSingleNullElementArray() {\r\n    String[] array = { null };\r\n    String newElement = \"bar\";\r\n    String[] newArray = ObjectUtils.addObjectToArray(array, newElement);\r\n    assertThat(newArray).hasSize(2);\r\n    assertThat(newArray[0]).isNull();\r\n    assertThat(newArray[1]).isEqualTo(newElement);\r\n}\n@Test\r\nvoid addObjectToNullArray() {\r\n    String newElement = \"foo\";\r\n    String[] newArray = ObjectUtils.addObjectToArray(null, newElement);\r\n    assertThat(newArray).hasSize(1);\r\n    assertThat(newArray[0]).isEqualTo(newElement);\r\n}\n@Test\r\nvoid addNullObjectToNullArray() {\r\n    Object[] newArray = ObjectUtils.addObjectToArray(null, null);\r\n    assertThat(newArray).hasSize(1);\r\n    assertThat(newArray[0]).isNull();\r\n}\n@Test\r\nvoid nullSafeEqualsWithArrays() {\r\n    assertThat(ObjectUtils.nullSafeEquals(new String[] { \"a\", \"b\", \"c\" }, new String[] { \"a\", \"b\", \"c\" })).isTrue();\r\n    assertThat(ObjectUtils.nullSafeEquals(new int[] { 1, 2, 3 }, new int[] { 1, 2, 3 })).isTrue();\r\n}\n@Test\r\nvoid identityToString() {\r\n    Object obj = new Object();\r\n    String expected = obj.getClass().getName() + \"@\" + ObjectUtils.getIdentityHexString(obj);\r\n    String actual = ObjectUtils.identityToString(obj);\r\n    assertThat(actual).isEqualTo(expected);\r\n}\n@Test\r\nvoid identityToStringWithNullObject() {\r\n    assertThat(ObjectUtils.identityToString(null)).isEmpty();\r\n}\n@Test\r\nvoid isArrayOfPrimitivesWithBooleanArray() {\r\n    assertThat(ClassUtils.isPrimitiveArray(boolean[].class)).isTrue();\r\n}\n@Test\r\nvoid isArrayOfPrimitivesWithObjectArray() {\r\n    assertThat(ClassUtils.isPrimitiveArray(Object[].class)).isFalse();\r\n}\n@Test\r\nvoid isArrayOfPrimitivesWithNonArray() {\r\n    assertThat(ClassUtils.isPrimitiveArray(String.class)).isFalse();\r\n}\n@Test\r\nvoid isPrimitiveOrWrapperWithBooleanPrimitiveClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(boolean.class)).isTrue();\r\n}\n@Test\r\nvoid isPrimitiveOrWrapperWithBooleanWrapperClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(Boolean.class)).isTrue();\r\n}\n@Test\r\nvoid isPrimitiveOrWrapperWithBytePrimitiveClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(byte.class)).isTrue();\r\n}\n@Test\r\nvoid isPrimitiveOrWrapperWithByteWrapperClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(Byte.class)).isTrue();\r\n}\n@Test\r\nvoid isPrimitiveOrWrapperWithCharacterClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(Character.class)).isTrue();\r\n}\n@Test\r\nvoid isPrimitiveOrWrapperWithCharClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(char.class)).isTrue();\r\n}\n@Test\r\nvoid isPrimitiveOrWrapperWithDoublePrimitiveClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(double.class)).isTrue();\r\n}\n@Test\r\nvoid isPrimitiveOrWrapperWithDoubleWrapperClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(Double.class)).isTrue();\r\n}\n@Test\r\nvoid isPrimitiveOrWrapperWithFloatPrimitiveClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(float.class)).isTrue();\r\n}\n@Test\r\nvoid isPrimitiveOrWrapperWithFloatWrapperClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(Float.class)).isTrue();\r\n}\n@Test\r\nvoid isPrimitiveOrWrapperWithIntClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(int.class)).isTrue();\r\n}\n@Test\r\nvoid isPrimitiveOrWrapperWithIntegerClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(Integer.class)).isTrue();\r\n}\n@Test\r\nvoid isPrimitiveOrWrapperWithLongPrimitiveClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(long.class)).isTrue();\r\n}\n@Test\r\nvoid isPrimitiveOrWrapperWithLongWrapperClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(Long.class)).isTrue();\r\n}\n@Test\r\nvoid isPrimitiveOrWrapperWithNonPrimitiveOrWrapperClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(Object.class)).isFalse();\r\n}\n@Test\r\nvoid isPrimitiveOrWrapperWithShortPrimitiveClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(short.class)).isTrue();\r\n}\n@Test\r\nvoid isPrimitiveOrWrapperWithShortWrapperClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(Short.class)).isTrue();\r\n}\n@Test\r\nvoid nullSafeHashWithNull() {\r\n    assertThat(ObjectUtils.nullSafeHash((Object[]) null)).isEqualTo(0);\r\n}\n@Test\r\nvoid nullSafeHashWithIntermediateNullElements() {\r\n    assertThat(ObjectUtils.nullSafeHash(3, null, 5)).isEqualTo(Objects.hash(3, null, 5));\r\n}\n@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithNullBooleanArray() {\r\n    boolean[] array = null;\r\n    assertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\r\n}\n@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithBooleanArray() {\r\n    boolean[] array = { true, false };\r\n    int actual = ObjectUtils.nullSafeHashCode(array);\r\n    assertThat(actual).isEqualTo(Arrays.hashCode(array));\r\n}\n@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithObjectBeingBooleanArray() {\r\n    Object array = new boolean[] { true, false };\r\n    int expected = ObjectUtils.nullSafeHashCode((boolean[]) array);\r\n    assertEqualHashCodes(expected, array);\r\n}\n@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithNullByteArray() {\r\n    byte[] array = null;\r\n    assertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\r\n}\n@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithByteArray() {\r\n    byte[] array = { 8, 10 };\r\n    int actual = ObjectUtils.nullSafeHashCode(array);\r\n    assertThat(actual).isEqualTo(Arrays.hashCode(array));\r\n}\n@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithObjectBeingByteArray() {\r\n    Object array = new byte[] { 6, 39 };\r\n    int expected = ObjectUtils.nullSafeHashCode((byte[]) array);\r\n    assertEqualHashCodes(expected, array);\r\n}\n@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithNullCharArray() {\r\n    char[] array = null;\r\n    assertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\r\n}\n@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithCharArray() {\r\n    char[] array = { 'a', 'E' };\r\n    int actual = ObjectUtils.nullSafeHashCode(array);\r\n    assertThat(actual).isEqualTo(Arrays.hashCode(array));\r\n}\n@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithObjectBeingCharArray() {\r\n    Object array = new char[] { 'l', 'M' };\r\n    int expected = ObjectUtils.nullSafeHashCode((char[]) array);\r\n    assertEqualHashCodes(expected, array);\r\n}\n@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithNullDoubleArray() {\r\n    double[] array = null;\r\n    assertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\r\n}\n@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithDoubleArray() {\r\n    double[] array = { 8449.65, 9944.923 };\r\n    int actual = ObjectUtils.nullSafeHashCode(array);\r\n    assertThat(actual).isEqualTo(Arrays.hashCode(array));\r\n}\n@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithObjectBeingDoubleArray() {\r\n    Object array = new double[] { 68930.993, 9022.009 };\r\n    int expected = ObjectUtils.nullSafeHashCode((double[]) array);\r\n    assertEqualHashCodes(expected, array);\r\n}\n@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithNullFloatArray() {\r\n    float[] array = null;\r\n    assertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\r\n}\n@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithFloatArray() {\r\n    float[] array = { 9.6f, 7.4f };\r\n    int actual = ObjectUtils.nullSafeHashCode(array);\r\n    assertThat(actual).isEqualTo(Arrays.hashCode(array));\r\n}\n@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithObjectBeingFloatArray() {\r\n    Object array = new float[] { 9.9f, 9.54f };\r\n    int expected = ObjectUtils.nullSafeHashCode((float[]) array);\r\n    assertEqualHashCodes(expected, array);\r\n}\n@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithNullIntArray() {\r\n    int[] array = null;\r\n    assertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\r\n}\n@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithIntArray() {\r\n    int[] array = { 884, 340 };\r\n    int actual = ObjectUtils.nullSafeHashCode(array);\r\n    assertThat(actual).isEqualTo(Arrays.hashCode(array));\r\n}\n@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithObjectBeingIntArray() {\r\n    Object array = new int[] { 89, 32 };\r\n    int expected = ObjectUtils.nullSafeHashCode((int[]) array);\r\n    assertEqualHashCodes(expected, array);\r\n}\n@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithNullLongArray() {\r\n    long[] array = null;\r\n    assertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\r\n}\n@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithLongArray() {\r\n    long[] array = { 7993L, 84320L };\r\n    int actual = ObjectUtils.nullSafeHashCode(array);\r\n    assertThat(actual).isEqualTo(Arrays.hashCode(array));\r\n}\n@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithObjectBeingLongArray() {\r\n    Object array = new long[] { 4389, 320 };\r\n    int expected = ObjectUtils.nullSafeHashCode((long[]) array);\r\n    assertEqualHashCodes(expected, array);\r\n}\n@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithNullShortArray() {\r\n    short[] array = null;\r\n    assertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\r\n}\n@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithShortArray() {\r\n    short[] array = { 4, 25 };\r\n    int actual = ObjectUtils.nullSafeHashCode(array);\r\n    assertThat(actual).isEqualTo(Arrays.hashCode(array));\r\n}\n@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithObjectBeingShortArray() {\r\n    Object array = new short[] { 5, 3 };\r\n    int expected = ObjectUtils.nullSafeHashCode((short[]) array);\r\n    assertEqualHashCodes(expected, array);\r\n}\n@Test\r\nvoid nullSafeHashCodeWithObject() {\r\n    String str = \"Luke\";\r\n    assertThat(ObjectUtils.nullSafeHashCode(str)).isEqualTo(str.hashCode());\r\n}\n@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithObjectArray() {\r\n    Object[] array = { \"Leia\", \"Han\" };\r\n    int actual = ObjectUtils.nullSafeHashCode(array);\r\n    assertThat(actual).isEqualTo(Arrays.hashCode(array));\r\n}\n@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithObjectArrayEqualToNull() {\r\n    assertThat(ObjectUtils.nullSafeHashCode((Object[]) null)).isEqualTo(0);\r\n}\n@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithObjectBeingObjectArray() {\r\n    Object array = new Object[] { \"Luke\", \"Anakin\" };\r\n    int expected = ObjectUtils.nullSafeHashCode((Object[]) array);\r\n    assertEqualHashCodes(expected, array);\r\n}\n@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithObjectEqualToNull() {\r\n    Object[] array = null;\r\n    assertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\r\n}\n@Test\r\nvoid nullSafeToStringWithBooleanArray() {\r\n    boolean[] array = { true, false };\r\n    assertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{true, false}\");\r\n}\n@Test\r\nvoid nullSafeToStringWithBooleanArrayBeingEmpty() {\r\n    boolean[] array = ;;\r\n    assertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\";\");\r\n}\n@Test\r\nvoid nullSafeToStringWithBooleanArrayEqualToNull() {\r\n    assertThat(ObjectUtils.nullSafeToString((boolean[]) null)).isEqualTo(\"null\");\r\n}\n@Test\r\nvoid nullSafeToStringWithByteArray() {\r\n    byte[] array = { 5, 8 };\r\n    assertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{5, 8}\");\r\n}\n@Test\r\nvoid nullSafeToStringWithByteArrayBeingEmpty() {\r\n    byte[] array = ;;\r\n    assertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\";\");\r\n}\n@Test\r\nvoid nullSafeToStringWithByteArrayEqualToNull() {\r\n    assertThat(ObjectUtils.nullSafeToString((byte[]) null)).isEqualTo(\"null\");\r\n}\n@Test\r\nvoid nullSafeToStringWithCharArray() {\r\n    char[] array = { 'A', 'B' };\r\n    assertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{'A', 'B'}\");\r\n}\n@Test\r\nvoid nullSafeToStringWithCharArrayBeingEmpty() {\r\n    char[] array = ;;\r\n    assertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\";\");\r\n}\n@Test\r\nvoid nullSafeToStringWithCharArrayEqualToNull() {\r\n    assertThat(ObjectUtils.nullSafeToString((char[]) null)).isEqualTo(\"null\");\r\n}\n@Test\r\nvoid nullSafeToStringWithDoubleArray() {\r\n    double[] array = { 8594.93, 8594023.95 };\r\n    assertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{8594.93, 8594023.95}\");\r\n}\n@Test\r\nvoid nullSafeToStringWithDoubleArrayBeingEmpty() {\r\n    double[] array = ;;\r\n    assertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\";\");\r\n}\n@Test\r\nvoid nullSafeToStringWithDoubleArrayEqualToNull() {\r\n    assertThat(ObjectUtils.nullSafeToString((double[]) null)).isEqualTo(\"null\");\r\n}\n@Test\r\nvoid nullSafeToStringWithFloatArray() {\r\n    float[] array = { 8.6f, 43.8f };\r\n    assertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{8.6, 43.8}\");\r\n}\n@Test\r\nvoid nullSafeToStringWithFloatArrayBeingEmpty() {\r\n    float[] array = ;;\r\n    assertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\";\");\r\n}\n@Test\r\nvoid nullSafeToStringWithFloatArrayEqualToNull() {\r\n    assertThat(ObjectUtils.nullSafeToString((float[]) null)).isEqualTo(\"null\");\r\n}\n@Test\r\nvoid nullSafeToStringWithIntArray() {\r\n    int[] array = { 9, 64 };\r\n    assertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{9, 64}\");\r\n}\n@Test\r\nvoid nullSafeToStringWithIntArrayBeingEmpty() {\r\n    int[] array = ;;\r\n    assertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\";\");\r\n}\n@Test\r\nvoid nullSafeToStringWithIntArrayEqualToNull() {\r\n    assertThat(ObjectUtils.nullSafeToString((int[]) null)).isEqualTo(\"null\");\r\n}\n@Test\r\nvoid nullSafeToStringWithLongArray() {\r\n    long[] array = { 434L, 23423L };\r\n    assertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{434, 23423}\");\r\n}\n@Test\r\nvoid nullSafeToStringWithLongArrayBeingEmpty() {\r\n    long[] array = ;;\r\n    assertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\";\");\r\n}\n@Test\r\nvoid nullSafeToStringWithLongArrayEqualToNull() {\r\n    assertThat(ObjectUtils.nullSafeToString((long[]) null)).isEqualTo(\"null\");\r\n}\n@Test\r\nvoid nullSafeToStringWithPlainOldString() {\r\n    assertThat(ObjectUtils.nullSafeToString(\"I shoh love tha taste of mangoes\")).isEqualTo(\"I shoh love tha taste of mangoes\");\r\n}\n@Test\r\nvoid nullSafeToStringWithObjectArray() {\r\n    Object[] array = { \"Han\", 43L };\r\n    assertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{Han, 43}\");\r\n}\n@Test\r\nvoid nullSafeToStringWithObjectArrayBeingEmpty() {\r\n    Object[] array = ;;\r\n    assertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\";\");\r\n}\n@Test\r\nvoid nullSafeToStringWithObjectArrayEqualToNull() {\r\n    assertThat(ObjectUtils.nullSafeToString((Object[]) null)).isEqualTo(\"null\");\r\n}\n@Test\r\nvoid nullSafeToStringWithShortArray() {\r\n    short[] array = { 7, 9 };\r\n    assertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{7, 9}\");\r\n}\n@Test\r\nvoid nullSafeToStringWithShortArrayBeingEmpty() {\r\n    short[] array = ;;\r\n    assertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\";\");\r\n}\n@Test\r\nvoid nullSafeToStringWithShortArrayEqualToNull() {\r\n    assertThat(ObjectUtils.nullSafeToString((short[]) null)).isEqualTo(\"null\");\r\n}\n@Test\r\nvoid nullSafeToStringWithStringArray() {\r\n    String[] array = { \"Luke\", \"Anakin\" };\r\n    assertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\"{Luke, Anakin}\");\r\n}\n@Test\r\nvoid nullSafeToStringWithStringArrayBeingEmpty() {\r\n    String[] array = ;;\r\n    assertThat(ObjectUtils.nullSafeToString(array)).isEqualTo(\";\");\r\n}\n@Test\r\nvoid nullSafeToStringWithStringArrayEqualToNull() {\r\n    assertThat(ObjectUtils.nullSafeToString((String[]) null)).isEqualTo(\"null\");\r\n}\n@Test\r\nvoid containsConstant() {\r\n    assertThat(ObjectUtils.containsConstant(Tropes.values(), \"FOO\")).isTrue();\r\n    assertThat(ObjectUtils.containsConstant(Tropes.values(), \"foo\")).isTrue();\r\n    assertThat(ObjectUtils.containsConstant(Tropes.values(), \"BaR\")).isTrue();\r\n    assertThat(ObjectUtils.containsConstant(Tropes.values(), \"bar\")).isTrue();\r\n    assertThat(ObjectUtils.containsConstant(Tropes.values(), \"BAZ\")).isTrue();\r\n    assertThat(ObjectUtils.containsConstant(Tropes.values(), \"baz\")).isTrue();\r\n    assertThat(ObjectUtils.containsConstant(Tropes.values(), \"BOGUS\")).isFalse();\r\n    assertThat(ObjectUtils.containsConstant(Tropes.values(), \"FOO\", true)).isTrue();\r\n    assertThat(ObjectUtils.containsConstant(Tropes.values(), \"foo\", true)).isFalse();\r\n}\n@Test\r\nvoid containsElement() {\r\n    Object[] array = { \"foo\", \"bar\", 42, new String[] { \"baz\", \"quux\" } };\r\n    assertThat(ObjectUtils.containsElement(null, \"foo\")).isFalse();\r\n    assertThat(ObjectUtils.containsElement(array, null)).isFalse();\r\n    assertThat(ObjectUtils.containsElement(array, \"bogus\")).isFalse();\r\n    assertThat(ObjectUtils.containsElement(array, \"foo\")).isTrue();\r\n    assertThat(ObjectUtils.containsElement(array, \"bar\")).isTrue();\r\n    assertThat(ObjectUtils.containsElement(array, 42)).isTrue();\r\n    assertThat(ObjectUtils.containsElement(array, new String[] { \"baz\", \"quux\" })).isTrue();\r\n}\n@Test\r\nvoid caseInsensitiveValueOf() {\r\n    assertThat(ObjectUtils.caseInsensitiveValueOf(Tropes.values(), \"foo\")).isEqualTo(Tropes.FOO);\r\n    assertThat(ObjectUtils.caseInsensitiveValueOf(Tropes.values(), \"BAR\")).isEqualTo(Tropes.BAR);\r\n    assertThatIllegalArgumentException().isThrownBy(() -> ObjectUtils.caseInsensitiveValueOf(Tropes.values(), \"bogus\")).withMessage(\"Constant [bogus] does not exist in enum type org.springframework.util.ObjectUtilsTests$Tropes\");\r\n}\nprivate static void assertEqualHashCodes(int expected, Object array) {\r\n    int actual = ObjectUtils.nullSafeHashCode(array);\r\n    assertThat(actual).isEqualTo(expected);\r\n    assertThat(array.hashCode()).isNotEqualTo(actual);\r\n}\nenum Tropes {\r\n\r\n    FOO, BAR, baz\r\n}\n@Nested\r\nclass NullSafeConciseToStringTests {\r\n\r\n    private static final String truncated = \" (truncated)...\";\r\n\r\n    private static final int truncatedLength = 100 + truncated.length();\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForNull() {\r\n        assertThat(ObjectUtils.nullSafeConciseToString(null)).isEqualTo(\"null\");\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForEmptyOptional() {\r\n        Optional<String> optional = Optional.empty();\r\n        assertThat(ObjectUtils.nullSafeConciseToString(optional)).isEqualTo(\"Optional.empty\");\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForNonEmptyOptionals() {\r\n        Optional<Tropes> optionalEnum = Optional.of(Tropes.BAR);\r\n        String expected = \"Optional[BAR]\";\r\n        assertThat(ObjectUtils.nullSafeConciseToString(optionalEnum)).isEqualTo(expected);\r\n        String repeat100 = \"X\".repeat(100);\r\n        String repeat101 = \"X\".repeat(101);\r\n        Optional<String> optionalString = Optional.of(repeat100);\r\n        expected = \"Optional[%s]\".formatted(repeat100);\r\n        assertThat(ObjectUtils.nullSafeConciseToString(optionalString)).isEqualTo(expected);\r\n        optionalString = Optional.of(repeat101);\r\n        expected = \"Optional[%s]\".formatted(repeat100 + truncated);\r\n        assertThat(ObjectUtils.nullSafeConciseToString(optionalString)).isEqualTo(expected);\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForNonEmptyOptionalCustomType() {\r\n        class CustomType {\r\n        }\r\n        CustomType customType = new CustomType();\r\n        Optional<CustomType> optional = Optional.of(customType);\r\n        String expected = \"Optional[%s]\".formatted(ObjectUtils.nullSafeConciseToString(customType));\r\n        assertThat(ObjectUtils.nullSafeConciseToString(optional)).isEqualTo(expected);\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForClass() {\r\n        assertThat(ObjectUtils.nullSafeConciseToString(String.class)).isEqualTo(\"java.lang.String\");\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForStrings() {\r\n        String repeat100 = \"X\".repeat(100);\r\n        String repeat101 = \"X\".repeat(101);\r\n        assertThat(ObjectUtils.nullSafeConciseToString(\"\")).isEqualTo(\"\");\r\n        assertThat(ObjectUtils.nullSafeConciseToString(\"foo\")).isEqualTo(\"foo\");\r\n        assertThat(ObjectUtils.nullSafeConciseToString(repeat100)).isEqualTo(repeat100);\r\n        assertThat(ObjectUtils.nullSafeConciseToString(repeat101)).hasSize(truncatedLength).endsWith(truncated);\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForStringBuilders() {\r\n        String repeat100 = \"X\".repeat(100);\r\n        String repeat101 = \"X\".repeat(101);\r\n        assertThat(ObjectUtils.nullSafeConciseToString(new StringBuilder(\"foo\"))).isEqualTo(\"foo\");\r\n        assertThat(ObjectUtils.nullSafeConciseToString(new StringBuilder(repeat100))).isEqualTo(repeat100);\r\n        assertThat(ObjectUtils.nullSafeConciseToString(new StringBuilder(repeat101))).hasSize(truncatedLength).endsWith(truncated);\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForEnum() {\r\n        assertThat(ObjectUtils.nullSafeConciseToString(Tropes.FOO)).isEqualTo(\"FOO\");\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForPrimitivesAndWrappers() {\r\n        assertThat(ObjectUtils.nullSafeConciseToString(true)).isEqualTo(\"true\");\r\n        assertThat(ObjectUtils.nullSafeConciseToString('X')).isEqualTo(\"X\");\r\n        assertThat(ObjectUtils.nullSafeConciseToString(42L)).isEqualTo(\"42\");\r\n        assertThat(ObjectUtils.nullSafeConciseToString(99.1234D)).isEqualTo(\"99.1234\");\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForBigNumbers() {\r\n        assertThat(ObjectUtils.nullSafeConciseToString(BigInteger.valueOf(42L))).isEqualTo(\"42\");\r\n        assertThat(ObjectUtils.nullSafeConciseToString(BigDecimal.valueOf(99.1234D))).isEqualTo(\"99.1234\");\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForDate() {\r\n        Date date = new Date();\r\n        assertThat(ObjectUtils.nullSafeConciseToString(date)).isEqualTo(date.toString());\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForTemporal() {\r\n        LocalDate localDate = LocalDate.now();\r\n        assertThat(ObjectUtils.nullSafeConciseToString(localDate)).isEqualTo(localDate.toString());\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForUUID() {\r\n        UUID id = UUID.randomUUID();\r\n        assertThat(ObjectUtils.nullSafeConciseToString(id)).isEqualTo(id.toString());\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForFile() {\r\n        String path = \"/tmp/file.txt\".replace('/', File.separatorChar);\r\n        assertThat(ObjectUtils.nullSafeConciseToString(new File(path))).isEqualTo(path);\r\n        path = (\"/tmp/\" + \"xyz\".repeat(32)).replace('/', File.separatorChar);\r\n        assertThat(ObjectUtils.nullSafeConciseToString(new File(path))).hasSize(truncatedLength).startsWith(path.subSequence(0, 100)).endsWith(truncated);\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForPath() {\r\n        String path = \"/tmp/file.txt\".replace('/', File.separatorChar);\r\n        assertThat(ObjectUtils.nullSafeConciseToString(Path.of(path))).isEqualTo(path);\r\n        path = (\"/tmp/\" + \"xyz\".repeat(32)).replace('/', File.separatorChar);\r\n        assertThat(ObjectUtils.nullSafeConciseToString(Path.of(path))).hasSize(truncatedLength).startsWith(path.subSequence(0, 100)).endsWith(truncated);\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForURI() {\r\n        String uri = \"https://www.example.com/?foo=1&bar=2&baz=3\";\r\n        assertThat(ObjectUtils.nullSafeConciseToString(URI.create(uri))).isEqualTo(uri);\r\n        uri += \"&qux=\" + \"4\".repeat(60);\r\n        assertThat(ObjectUtils.nullSafeConciseToString(URI.create(uri))).hasSize(truncatedLength).startsWith(uri.subSequence(0, 100)).endsWith(truncated);\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForURL() throws Exception {\r\n        String url = \"https://www.example.com/?foo=1&bar=2&baz=3\";\r\n        assertThat(ObjectUtils.nullSafeConciseToString(new URL(url))).isEqualTo(url);\r\n        url += \"&qux=\" + \"4\".repeat(60);\r\n        assertThat(ObjectUtils.nullSafeConciseToString(new URL(url))).hasSize(truncatedLength).startsWith(url.subSequence(0, 100)).endsWith(truncated);\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForInetAddress() {\r\n        InetAddress localhost = getLocalhost();\r\n        assertThat(ObjectUtils.nullSafeConciseToString(localhost)).isEqualTo(localhost.toString());\r\n    }\r\n\r\n    private static InetAddress getLocalhost() {\r\n        try {\r\n            return InetAddress.getLocalHost();\r\n        } catch (UnknownHostException ex) {\r\n            return InetAddress.getLoopbackAddress();\r\n        }\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForCharset() {\r\n        Charset charset = StandardCharsets.UTF_8;\r\n        assertThat(ObjectUtils.nullSafeConciseToString(charset)).isEqualTo(charset.name());\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForCurrency() {\r\n        Currency currency = Currency.getInstance(Locale.US);\r\n        assertThat(ObjectUtils.nullSafeConciseToString(currency)).isEqualTo(currency.toString());\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForLocale() {\r\n        assertThat(ObjectUtils.nullSafeConciseToString(Locale.GERMANY)).isEqualTo(\"de_DE\");\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForRegExPattern() {\r\n        Pattern pattern = Pattern.compile(\"^(foo|bar)$\");\r\n        assertThat(ObjectUtils.nullSafeConciseToString(pattern)).isEqualTo(pattern.toString());\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForTimeZone() {\r\n        TimeZone timeZone = TimeZone.getDefault();\r\n        assertThat(ObjectUtils.nullSafeConciseToString(timeZone)).isEqualTo(timeZone.getID());\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForZoneId() {\r\n        ZoneId zoneId = ZoneId.systemDefault();\r\n        assertThat(ObjectUtils.nullSafeConciseToString(zoneId)).isEqualTo(zoneId.getId());\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForEmptyArrays() {\r\n        assertThat(ObjectUtils.nullSafeConciseToString(new char[] {})).isEqualTo(\"{}\");\r\n        assertThat(ObjectUtils.nullSafeConciseToString(new int[][] {})).isEqualTo(\"{}\");\r\n        assertThat(ObjectUtils.nullSafeConciseToString(new String[] {})).isEqualTo(\"{}\");\r\n        assertThat(ObjectUtils.nullSafeConciseToString(new Integer[][] {})).isEqualTo(\"{}\");\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForNonEmptyArrays() {\r\n        assertThat(ObjectUtils.nullSafeConciseToString(new char[] { 'a' })).isEqualTo(\"{...}\");\r\n        assertThat(ObjectUtils.nullSafeConciseToString(new int[][] { { 1 }, { 2 } })).isEqualTo(\"{...}\");\r\n        assertThat(ObjectUtils.nullSafeConciseToString(new String[] { \"enigma\" })).isEqualTo(\"{...}\");\r\n        assertThat(ObjectUtils.nullSafeConciseToString(new Integer[][] { { 1 }, { 2 } })).isEqualTo(\"{...}\");\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForEmptyCollections() {\r\n        List<String> list = List.of();\r\n        Set<Integer> set = Set.of();\r\n        assertThat(ObjectUtils.nullSafeConciseToString(list)).isEqualTo(\"[...]\");\r\n        assertThat(ObjectUtils.nullSafeConciseToString(set)).isEqualTo(\"[...]\");\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForNonEmptyCollections() {\r\n        List<String> list = List.of(\"a\", \"b\");\r\n        Set<Integer> set = Set.of(1);\r\n        assertThat(ObjectUtils.nullSafeConciseToString(list)).isEqualTo(\"[...]\");\r\n        assertThat(ObjectUtils.nullSafeConciseToString(set)).isEqualTo(\"[...]\");\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForEmptyMaps() {\r\n        Map<String, String> map = Map.of();\r\n        assertThat(ObjectUtils.nullSafeConciseToString(map)).isEqualTo(\"{...}\");\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForNonEmptyMaps() {\r\n        Map<String, Integer> map = Map.of(\"a\", 1, \"b\", 2, \"c\", 3);\r\n        assertThat(ObjectUtils.nullSafeConciseToString(map)).isEqualTo(\"{...}\");\r\n    }\r\n\r\n    @Test\r\n    void nullSafeConciseToStringForCustomTypes() {\r\n        class ExplosiveType {\r\n\r\n            @Override\r\n            public String toString() {\r\n                throw new UnsupportedOperationException(\"no-go\");\r\n            }\r\n        }\r\n        ExplosiveType explosiveType = new ExplosiveType();\r\n        assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(explosiveType::toString);\r\n        assertThat(ObjectUtils.nullSafeConciseToString(explosiveType)).startsWith(prefix(ExplosiveType.class));\r\n        class WordyType {\r\n\r\n            @Override\r\n            public String toString() {\r\n                return \"blah blah\".repeat(20);\r\n            }\r\n        }\r\n        WordyType wordyType = new WordyType();\r\n        assertThat(wordyType).asString().hasSizeGreaterThanOrEqualTo(180);\r\n        assertThat(ObjectUtils.nullSafeConciseToString(wordyType)).startsWith(prefix(WordyType.class));\r\n    }\r\n\r\n    private static String prefix(Class<?> clazz) {\r\n        return clazz.getTypeName() + \"@\";\r\n    }\r\n}\n@Test\r\nvoid unwrapOptional() {\r\n    assertThat(ObjectUtils.unwrapOptional(null)).isNull();\r\n    assertThat(ObjectUtils.unwrapOptional(\"some value\")).isEqualTo(\"some value\");\r\n    assertThat(ObjectUtils.unwrapOptional(Optional.empty())).isNull();\r\n    assertThat(ObjectUtils.unwrapOptional(Optional.of(\"some value\"))).isEqualTo(\"some value\");\r\n    Optional<Optional<Object>> nestedEmptyOptional = Optional.of(Optional.empty());\r\n    assertThatIllegalArgumentException().isThrownBy(() -> ObjectUtils.unwrapOptional(nestedEmptyOptional)).withMessage(\"Multi-level Optional usage not supported\");\r\n    Optional<Optional<String>> nestedStringOptional = Optional.of(Optional.of(\"some value\"));\r\n    assertThatIllegalArgumentException().isThrownBy(() -> ObjectUtils.unwrapOptional(nestedStringOptional)).withMessage(\"Multi-level Optional usage not supported\");\r\n}",
    "comment": "\n * Tests for {@link ObjectUtils}.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Rick Evans\n * @author Sam Brannen\n * @author Hyunjin Choi\n * @author Ngoc Nhan\n "
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#isCheckedException()",
    "entityType": "method",
    "code": "@Test\r\nvoid isCheckedException() {\r\n    assertThat(ObjectUtils.isCheckedException(new Exception())).isTrue();\r\n    assertThat(ObjectUtils.isCheckedException(new SQLException())).isTrue();\r\n    assertThat(ObjectUtils.isCheckedException(new RuntimeException())).isFalse();\r\n    assertThat(ObjectUtils.isCheckedException(new IllegalArgumentException(\"\"))).isFalse();\r\n    // Any Throwable other than RuntimeException and Error\r\n    // has to be considered checked according to the JLS.\r\n    assertThat(ObjectUtils.isCheckedException(new Throwable())).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#isCompatibleWithThrowsClause()",
    "entityType": "method",
    "code": "@Test\r\nvoid isCompatibleWithThrowsClause() {\r\n    Class<?>[] empty = new Class<?>[0];\r\n    Class<?>[] exception = new Class<?>[] { Exception.class };\r\n    Class<?>[] sqlAndIO = new Class<?>[] { SQLException.class, IOException.class };\r\n    Class<?>[] throwable = new Class<?>[] { Throwable.class };\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new RuntimeException())).isTrue();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new RuntimeException(), empty)).isTrue();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new RuntimeException(), exception)).isTrue();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new RuntimeException(), sqlAndIO)).isTrue();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new RuntimeException(), throwable)).isTrue();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new Exception())).isFalse();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new Exception(), empty)).isFalse();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new Exception(), exception)).isTrue();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new Exception(), sqlAndIO)).isFalse();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new Exception(), throwable)).isTrue();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new SQLException())).isFalse();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new SQLException(), empty)).isFalse();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new SQLException(), exception)).isTrue();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new SQLException(), sqlAndIO)).isTrue();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new SQLException(), throwable)).isTrue();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new Throwable())).isFalse();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new Throwable(), empty)).isFalse();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new Throwable(), exception)).isFalse();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new Throwable(), sqlAndIO)).isFalse();\r\n    assertThat(ObjectUtils.isCompatibleWithThrowsClause(new Throwable(), throwable)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#isEmptyNull()",
    "entityType": "method",
    "code": "@Test\r\nvoid isEmptyNull() {\r\n    assertThat(isEmpty(null)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#isEmptyArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid isEmptyArray() {\r\n    assertThat(isEmpty(new char[0])).isTrue();\r\n    assertThat(isEmpty(new Object[0])).isTrue();\r\n    assertThat(isEmpty(new Integer[0])).isTrue();\r\n    assertThat(isEmpty(new int[] { 42 })).isFalse();\r\n    assertThat(isEmpty(new Integer[] { 42 })).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#isEmptyCollection()",
    "entityType": "method",
    "code": "@Test\r\nvoid isEmptyCollection() {\r\n    assertThat(isEmpty(Collections.emptyList())).isTrue();\r\n    assertThat(isEmpty(Collections.emptySet())).isTrue();\r\n    Set<String> set = new HashSet<>();\r\n    set.add(\"foo\");\r\n    assertThat(isEmpty(set)).isFalse();\r\n    assertThat(isEmpty(Collections.singletonList(\"foo\"))).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#isEmptyMap()",
    "entityType": "method",
    "code": "@Test\r\nvoid isEmptyMap() {\r\n    assertThat(isEmpty(Collections.emptyMap())).isTrue();\r\n    HashMap<String, Object> map = new HashMap<>();\r\n    map.put(\"foo\", 42L);\r\n    assertThat(isEmpty(map)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#isEmptyCharSequence()",
    "entityType": "method",
    "code": "@Test\r\nvoid isEmptyCharSequence() {\r\n    assertThat(isEmpty(new StringBuilder())).isTrue();\r\n    assertThat(isEmpty(\"\")).isTrue();\r\n    assertThat(isEmpty(new StringBuilder(\"foo\"))).isFalse();\r\n    assertThat(isEmpty(\"   \")).isFalse();\r\n    assertThat(isEmpty(\"\\t\")).isFalse();\r\n    assertThat(isEmpty(\"foo\")).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#isEmptyUnsupportedObjectType()",
    "entityType": "method",
    "code": "@Test\r\nvoid isEmptyUnsupportedObjectType() {\r\n    assertThat(isEmpty(42L)).isFalse();\r\n    assertThat(isEmpty(new Object())).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#toObjectArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid toObjectArray() {\r\n    int[] a = new int[] { 1, 2, 3, 4, 5 };\r\n    Integer[] wrapper = (Integer[]) ObjectUtils.toObjectArray(a);\r\n    assertThat(wrapper).hasSize(5);\r\n    for (int i = 0; i < wrapper.length; i++) {\r\n        assertThat(wrapper[i]).isEqualTo(a[i]);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#toObjectArrayWithNull()",
    "entityType": "method",
    "code": "@Test\r\nvoid toObjectArrayWithNull() {\r\n    Object[] objects = ObjectUtils.toObjectArray(null);\r\n    assertThat(objects).isNotNull();\r\n    assertThat(objects).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#toObjectArrayWithEmptyPrimitiveArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid toObjectArrayWithEmptyPrimitiveArray() {\r\n    Object[] objects = ObjectUtils.toObjectArray(new byte[] ;);\r\n    assertThat(objects).isNotNull();\r\n    assertThat(objects).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#toObjectArrayWithNonArrayType()",
    "entityType": "method",
    "code": "@Test\r\nvoid toObjectArrayWithNonArrayType() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> ObjectUtils.toObjectArray(\"Not an []\")).withMessageStartingWith(\"Source is not an array\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#toObjectArrayWithNonPrimitiveArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid toObjectArrayWithNonPrimitiveArray() {\r\n    String[] source = { \"Bingo\" };\r\n    assertThat(ObjectUtils.toObjectArray(source)).isSameAs(source);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#addObjectToArraySunnyDay()",
    "entityType": "method",
    "code": "@Test\r\nvoid addObjectToArraySunnyDay() {\r\n    String[] array = { \"foo\", \"bar\" };\r\n    String newElement = \"baz\";\r\n    Object[] newArray = ObjectUtils.addObjectToArray(array, newElement);\r\n    assertThat(newArray).hasSize(3);\r\n    assertThat(newArray[2]).isEqualTo(newElement);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#addObjectToArraysAtPosition()",
    "entityType": "method",
    "code": "@Test\r\nvoid addObjectToArraysAtPosition() {\r\n    String[] array = { \"foo\", \"bar\", \"baz\" };\r\n    assertThat(ObjectUtils.addObjectToArray(array, \"bat\", 3)).containsExactly(\"foo\", \"bar\", \"baz\", \"bat\");\r\n    assertThat(ObjectUtils.addObjectToArray(array, \"bat\", 2)).containsExactly(\"foo\", \"bar\", \"bat\", \"baz\");\r\n    assertThat(ObjectUtils.addObjectToArray(array, \"bat\", 1)).containsExactly(\"foo\", \"bat\", \"bar\", \"baz\");\r\n    assertThat(ObjectUtils.addObjectToArray(array, \"bat\", 0)).containsExactly(\"bat\", \"foo\", \"bar\", \"baz\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#addObjectToArrayWhenEmpty()",
    "entityType": "method",
    "code": "@Test\r\nvoid addObjectToArrayWhenEmpty() {\r\n    String[] array = new String[0];\r\n    String newElement = \"foo\";\r\n    String[] newArray = ObjectUtils.addObjectToArray(array, newElement);\r\n    assertThat(newArray).hasSize(1);\r\n    assertThat(newArray[0]).isEqualTo(newElement);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#addObjectToSingleNonNullElementArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid addObjectToSingleNonNullElementArray() {\r\n    String existingElement = \"foo\";\r\n    String[] array = { existingElement };\r\n    String newElement = \"bar\";\r\n    String[] newArray = ObjectUtils.addObjectToArray(array, newElement);\r\n    assertThat(newArray).hasSize(2);\r\n    assertThat(newArray[0]).isEqualTo(existingElement);\r\n    assertThat(newArray[1]).isEqualTo(newElement);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#addObjectToSingleNullElementArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid addObjectToSingleNullElementArray() {\r\n    String[] array = { null };\r\n    String newElement = \"bar\";\r\n    String[] newArray = ObjectUtils.addObjectToArray(array, newElement);\r\n    assertThat(newArray).hasSize(2);\r\n    assertThat(newArray[0]).isNull();\r\n    assertThat(newArray[1]).isEqualTo(newElement);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#addObjectToNullArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid addObjectToNullArray() {\r\n    String newElement = \"foo\";\r\n    String[] newArray = ObjectUtils.addObjectToArray(null, newElement);\r\n    assertThat(newArray).hasSize(1);\r\n    assertThat(newArray[0]).isEqualTo(newElement);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#addNullObjectToNullArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid addNullObjectToNullArray() {\r\n    Object[] newArray = ObjectUtils.addObjectToArray(null, null);\r\n    assertThat(newArray).hasSize(1);\r\n    assertThat(newArray[0]).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#nullSafeEqualsWithArrays()",
    "entityType": "method",
    "code": "@Test\r\nvoid nullSafeEqualsWithArrays() {\r\n    assertThat(ObjectUtils.nullSafeEquals(new String[] { \"a\", \"b\", \"c\" }, new String[] { \"a\", \"b\", \"c\" })).isTrue();\r\n    assertThat(ObjectUtils.nullSafeEquals(new int[] { 1, 2, 3 }, new int[] { 1, 2, 3 })).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#identityToString()",
    "entityType": "method",
    "code": "@Test\r\nvoid identityToString() {\r\n    Object obj = new Object();\r\n    String expected = obj.getClass().getName() + \"@\" + ObjectUtils.getIdentityHexString(obj);\r\n    String actual = ObjectUtils.identityToString(obj);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#identityToStringWithNullObject()",
    "entityType": "method",
    "code": "@Test\r\nvoid identityToStringWithNullObject() {\r\n    assertThat(ObjectUtils.identityToString(null)).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#isArrayOfPrimitivesWithBooleanArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid isArrayOfPrimitivesWithBooleanArray() {\r\n    assertThat(ClassUtils.isPrimitiveArray(boolean[].class)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#isArrayOfPrimitivesWithObjectArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid isArrayOfPrimitivesWithObjectArray() {\r\n    assertThat(ClassUtils.isPrimitiveArray(Object[].class)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#isArrayOfPrimitivesWithNonArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid isArrayOfPrimitivesWithNonArray() {\r\n    assertThat(ClassUtils.isPrimitiveArray(String.class)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#isPrimitiveOrWrapperWithBooleanPrimitiveClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid isPrimitiveOrWrapperWithBooleanPrimitiveClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(boolean.class)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#isPrimitiveOrWrapperWithBooleanWrapperClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid isPrimitiveOrWrapperWithBooleanWrapperClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(Boolean.class)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#isPrimitiveOrWrapperWithBytePrimitiveClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid isPrimitiveOrWrapperWithBytePrimitiveClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(byte.class)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#isPrimitiveOrWrapperWithByteWrapperClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid isPrimitiveOrWrapperWithByteWrapperClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(Byte.class)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#isPrimitiveOrWrapperWithCharacterClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid isPrimitiveOrWrapperWithCharacterClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(Character.class)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#isPrimitiveOrWrapperWithCharClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid isPrimitiveOrWrapperWithCharClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(char.class)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#isPrimitiveOrWrapperWithDoublePrimitiveClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid isPrimitiveOrWrapperWithDoublePrimitiveClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(double.class)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#isPrimitiveOrWrapperWithDoubleWrapperClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid isPrimitiveOrWrapperWithDoubleWrapperClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(Double.class)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#isPrimitiveOrWrapperWithFloatPrimitiveClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid isPrimitiveOrWrapperWithFloatPrimitiveClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(float.class)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#isPrimitiveOrWrapperWithFloatWrapperClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid isPrimitiveOrWrapperWithFloatWrapperClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(Float.class)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#isPrimitiveOrWrapperWithIntClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid isPrimitiveOrWrapperWithIntClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(int.class)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#isPrimitiveOrWrapperWithIntegerClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid isPrimitiveOrWrapperWithIntegerClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(Integer.class)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#isPrimitiveOrWrapperWithLongPrimitiveClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid isPrimitiveOrWrapperWithLongPrimitiveClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(long.class)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#isPrimitiveOrWrapperWithLongWrapperClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid isPrimitiveOrWrapperWithLongWrapperClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(Long.class)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#isPrimitiveOrWrapperWithNonPrimitiveOrWrapperClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid isPrimitiveOrWrapperWithNonPrimitiveOrWrapperClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(Object.class)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#isPrimitiveOrWrapperWithShortPrimitiveClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid isPrimitiveOrWrapperWithShortPrimitiveClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(short.class)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#isPrimitiveOrWrapperWithShortWrapperClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid isPrimitiveOrWrapperWithShortWrapperClass() {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(Short.class)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#nullSafeHashWithNull()",
    "entityType": "method",
    "code": "@Test\r\nvoid nullSafeHashWithNull() {\r\n    assertThat(ObjectUtils.nullSafeHash((Object[]) null)).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#nullSafeHashWithIntermediateNullElements()",
    "entityType": "method",
    "code": "@Test\r\nvoid nullSafeHashWithIntermediateNullElements() {\r\n    assertThat(ObjectUtils.nullSafeHash(3, null, 5)).isEqualTo(Objects.hash(3, null, 5));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#nullSafeHashCodeWithNullBooleanArray()",
    "entityType": "method",
    "code": "@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithNullBooleanArray() {\r\n    boolean[] array = null;\r\n    assertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#nullSafeHashCodeWithBooleanArray()",
    "entityType": "method",
    "code": "@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithBooleanArray() {\r\n    boolean[] array = { true, false };\r\n    int actual = ObjectUtils.nullSafeHashCode(array);\r\n    assertThat(actual).isEqualTo(Arrays.hashCode(array));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.AnnotationWriter",
    "entityType": "class",
    "code": "/**\r\n * Where the constants used in this AnnotationWriter must be stored.\r\n */\r\nprivate final SymbolTable symbolTable;\n/**\r\n * Whether values are named or not. AnnotationWriter instances used for annotation default and\r\n * annotation arrays use unnamed values (i.e. they generate an 'element_value' structure for each\r\n * value, instead of an element_name_index followed by an element_value).\r\n */\r\nprivate final boolean useNamedValues;\n/**\r\n * The 'annotation' or 'type_annotation' JVMS structure corresponding to the annotation values\r\n * visited so far. All the fields of these structures, except the last one - the\r\n * element_value_pairs array, must be set before this ByteVector is passed to the constructor\r\n * (num_element_value_pairs can be set to 0, it is reset to the correct value in {@link\r\n * #visitEnd()}). The element_value_pairs array is filled incrementally in the various visit()\r\n * methods.\r\n *\r\n * <p>Note: as an exception to the above rules, for AnnotationDefault attributes (which contain a\r\n * single element_value by definition), this ByteVector is initially empty when passed to the\r\n * constructor, and {@link #numElementValuePairsOffset} is set to -1.\r\n */\r\nprivate final ByteVector annotation;\n/**\r\n * The offset in {@link #annotation} where {@link #numElementValuePairs} must be stored (or -1 for\r\n * the case of AnnotationDefault attributes).\r\n */\r\nprivate final int numElementValuePairsOffset;\n/**\r\n * The number of element value pairs visited so far.\r\n */\r\nprivate int numElementValuePairs;\n/**\r\n * The previous AnnotationWriter. This field is used to store the list of annotations of a\r\n * Runtime[In]Visible[Type]Annotations attribute. It is unused for nested or array annotations\r\n * (annotation values of annotation type), or for AnnotationDefault attributes.\r\n */\r\nprivate final AnnotationWriter previousAnnotation;\n/**\r\n * The next AnnotationWriter. This field is used to store the list of annotations of a\r\n * Runtime[In]Visible[Type]Annotations attribute. It is unused for nested or array annotations\r\n * (annotation values of annotation type), or for AnnotationDefault attributes.\r\n */\r\nprivate AnnotationWriter nextAnnotation;\n// -----------------------------------------------------------------------------------------------\r\n// Constructors and factories\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Constructs a new {@link AnnotationWriter}.\r\n *\r\n * @param symbolTable where the constants used in this AnnotationWriter must be stored.\r\n * @param useNamedValues whether values are named or not. AnnotationDefault and annotation arrays\r\n *     use unnamed values.\r\n * @param annotation where the 'annotation' or 'type_annotation' JVMS structure corresponding to\r\n *     the visited content must be stored. This ByteVector must already contain all the fields of\r\n *     the structure except the last one (the element_value_pairs array).\r\n * @param previousAnnotation the previously visited annotation of the\r\n *     Runtime[In]Visible[Type]Annotations attribute to which this annotation belongs, or\r\n *     {@literal null} in other cases (for example, nested or array annotations).\r\n */\r\nAnnotationWriter(final SymbolTable symbolTable, final boolean useNamedValues, final ByteVector annotation, final AnnotationWriter previousAnnotation) {\r\n    super(/* latest api = */\r\n    Opcodes.ASM9);\r\n    this.symbolTable = symbolTable;\r\n    this.useNamedValues = useNamedValues;\r\n    this.annotation = annotation;\r\n    // By hypothesis, num_element_value_pairs is stored in the last unsigned short of 'annotation'.\r\n    this.numElementValuePairsOffset = annotation.length == 0 ? -1 : annotation.length - 2;\r\n    this.previousAnnotation = previousAnnotation;\r\n    if (previousAnnotation != null) {\r\n        previousAnnotation.nextAnnotation = this;\r\n    }\r\n}\n/**\r\n * Creates a new {@link AnnotationWriter} using named values.\r\n *\r\n * @param symbolTable where the constants used in this AnnotationWriter must be stored.\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param previousAnnotation the previously visited annotation of the\r\n *     Runtime[In]Visible[Type]Annotations attribute to which this annotation belongs, or\r\n *     {@literal null} in other cases (for example, nested or array annotations).\r\n * @return a new {@link AnnotationWriter} for the given annotation descriptor.\r\n */\r\nstatic AnnotationWriter create(final SymbolTable symbolTable, final String descriptor, final AnnotationWriter previousAnnotation) {\r\n    // Create a ByteVector to hold an 'annotation' JVMS structure.\r\n    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16.\r\n    ByteVector annotation = new ByteVector();\r\n    // Write type_index and reserve space for num_element_value_pairs.\r\n    annotation.putShort(symbolTable.addConstantUtf8(descriptor)).putShort(0);\r\n    return new AnnotationWriter(symbolTable, /* useNamedValues= */\r\n    true, annotation, previousAnnotation);\r\n}\n/**\r\n * Creates a new {@link AnnotationWriter} using named values.\r\n *\r\n * @param symbolTable where the constants used in this AnnotationWriter must be stored.\r\n * @param typeRef a reference to the annotated type. The sort of this type reference must be\r\n *     {@link TypeReference#CLASS_TYPE_PARAMETER}, {@link\r\n *     TypeReference#CLASS_TYPE_PARAMETER_BOUND} or {@link TypeReference#CLASS_EXTENDS}. See\r\n *     {@link TypeReference}.\r\n * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\r\n *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\r\n *     'typeRef' as a whole.\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param previousAnnotation the previously visited annotation of the\r\n *     Runtime[In]Visible[Type]Annotations attribute to which this annotation belongs, or\r\n *     {@literal null} in other cases (for example, nested or array annotations).\r\n * @return a new {@link AnnotationWriter} for the given type annotation reference and descriptor.\r\n */\r\nstatic AnnotationWriter create(final SymbolTable symbolTable, final int typeRef, final TypePath typePath, final String descriptor, final AnnotationWriter previousAnnotation) {\r\n    // Create a ByteVector to hold a 'type_annotation' JVMS structure.\r\n    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20.\r\n    ByteVector typeAnnotation = new ByteVector();\r\n    // Write target_type, target_info, and target_path.\r\n    TypeReference.putTarget(typeRef, typeAnnotation);\r\n    TypePath.put(typePath, typeAnnotation);\r\n    // Write type_index and reserve space for num_element_value_pairs.\r\n    typeAnnotation.putShort(symbolTable.addConstantUtf8(descriptor)).putShort(0);\r\n    return new AnnotationWriter(symbolTable, /* useNamedValues= */\r\n    true, typeAnnotation, previousAnnotation);\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Implementation of the AnnotationVisitor abstract class\r\n// -----------------------------------------------------------------------------------------------\r\n@Override\r\npublic void visit(final String name, final Object value) {\r\n    // Case of an element_value with a const_value_index, class_info_index or array_index field.\r\n    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16.1.\r\n    ++numElementValuePairs;\r\n    if (useNamedValues) {\r\n        annotation.putShort(symbolTable.addConstantUtf8(name));\r\n    }\r\n    if (value instanceof String) {\r\n        annotation.put12('s', symbolTable.addConstantUtf8((String) value));\r\n    } else if (value instanceof Byte) {\r\n        annotation.put12('B', symbolTable.addConstantInteger(((Byte) value).byteValue()).index);\r\n    } else if (value instanceof Boolean) {\r\n        int booleanValue = ((Boolean) value).booleanValue() ? 1 : 0;\r\n        annotation.put12('Z', symbolTable.addConstantInteger(booleanValue).index);\r\n    } else if (value instanceof Character) {\r\n        annotation.put12('C', symbolTable.addConstantInteger(((Character) value).charValue()).index);\r\n    } else if (value instanceof Short) {\r\n        annotation.put12('S', symbolTable.addConstantInteger(((Short) value).shortValue()).index);\r\n    } else if (value instanceof Type) {\r\n        annotation.put12('c', symbolTable.addConstantUtf8(((Type) value).getDescriptor()));\r\n    } else if (value instanceof byte[]) {\r\n        byte[] byteArray = (byte[]) value;\r\n        annotation.put12('[', byteArray.length);\r\n        for (byte byteValue : byteArray) {\r\n            annotation.put12('B', symbolTable.addConstantInteger(byteValue).index);\r\n        }\r\n    } else if (value instanceof boolean[]) {\r\n        boolean[] booleanArray = (boolean[]) value;\r\n        annotation.put12('[', booleanArray.length);\r\n        for (boolean booleanValue : booleanArray) {\r\n            annotation.put12('Z', symbolTable.addConstantInteger(booleanValue ? 1 : 0).index);\r\n        }\r\n    } else if (value instanceof short[]) {\r\n        short[] shortArray = (short[]) value;\r\n        annotation.put12('[', shortArray.length);\r\n        for (short shortValue : shortArray) {\r\n            annotation.put12('S', symbolTable.addConstantInteger(shortValue).index);\r\n        }\r\n    } else if (value instanceof char[]) {\r\n        char[] charArray = (char[]) value;\r\n        annotation.put12('[', charArray.length);\r\n        for (char charValue : charArray) {\r\n            annotation.put12('C', symbolTable.addConstantInteger(charValue).index);\r\n        }\r\n    } else if (value instanceof int[]) {\r\n        int[] intArray = (int[]) value;\r\n        annotation.put12('[', intArray.length);\r\n        for (int intValue : intArray) {\r\n            annotation.put12('I', symbolTable.addConstantInteger(intValue).index);\r\n        }\r\n    } else if (value instanceof long[]) {\r\n        long[] longArray = (long[]) value;\r\n        annotation.put12('[', longArray.length);\r\n        for (long longValue : longArray) {\r\n            annotation.put12('J', symbolTable.addConstantLong(longValue).index);\r\n        }\r\n    } else if (value instanceof float[]) {\r\n        float[] floatArray = (float[]) value;\r\n        annotation.put12('[', floatArray.length);\r\n        for (float floatValue : floatArray) {\r\n            annotation.put12('F', symbolTable.addConstantFloat(floatValue).index);\r\n        }\r\n    } else if (value instanceof double[]) {\r\n        double[] doubleArray = (double[]) value;\r\n        annotation.put12('[', doubleArray.length);\r\n        for (double doubleValue : doubleArray) {\r\n            annotation.put12('D', symbolTable.addConstantDouble(doubleValue).index);\r\n        }\r\n    } else {\r\n        Symbol symbol = symbolTable.addConstant(value);\r\n        annotation.put12(\".s.IFJDCS\".charAt(symbol.tag), symbol.index);\r\n    }\r\n}\n@Override\r\npublic void visitEnum(final String name, final String descriptor, final String value) {\r\n    // Case of an element_value with an enum_const_value field.\r\n    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16.1.\r\n    ++numElementValuePairs;\r\n    if (useNamedValues) {\r\n        annotation.putShort(symbolTable.addConstantUtf8(name));\r\n    }\r\n    annotation.put12('e', symbolTable.addConstantUtf8(descriptor)).putShort(symbolTable.addConstantUtf8(value));\r\n}\n@Override\r\npublic AnnotationVisitor visitAnnotation(final String name, final String descriptor) {\r\n    // Case of an element_value with an annotation_value field.\r\n    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16.1.\r\n    ++numElementValuePairs;\r\n    if (useNamedValues) {\r\n        annotation.putShort(symbolTable.addConstantUtf8(name));\r\n    }\r\n    // Write tag and type_index, and reserve 2 bytes for num_element_value_pairs.\r\n    annotation.put12('@', symbolTable.addConstantUtf8(descriptor)).putShort(0);\r\n    return new AnnotationWriter(symbolTable, /* useNamedValues= */\r\n    true, annotation, null);\r\n}\n@Override\r\npublic AnnotationVisitor visitArray(final String name) {\r\n    // Case of an element_value with an array_value field.\r\n    // https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16.1\r\n    ++numElementValuePairs;\r\n    if (useNamedValues) {\r\n        annotation.putShort(symbolTable.addConstantUtf8(name));\r\n    }\r\n    // Write tag, and reserve 2 bytes for num_values. Here we take advantage of the fact that the\r\n    // end of an element_value of array type is similar to the end of an 'annotation' structure: an\r\n    // unsigned short num_values followed by num_values element_value, versus an unsigned short\r\n    // num_element_value_pairs, followed by num_element_value_pairs { element_name_index,\r\n    // element_value } tuples. This allows us to use an AnnotationWriter with unnamed values to\r\n    // visit the array elements. Its num_element_value_pairs will correspond to the number of array\r\n    // elements and will be stored in what is in fact num_values.\r\n    annotation.put12('[', 0);\r\n    return new AnnotationWriter(symbolTable, /* useNamedValues= */\r\n    false, annotation, null);\r\n}\n@Override\r\npublic void visitEnd() {\r\n    if (numElementValuePairsOffset != -1) {\r\n        byte[] data = annotation.data;\r\n        data[numElementValuePairsOffset] = (byte) (numElementValuePairs >>> 8);\r\n        data[numElementValuePairsOffset + 1] = (byte) numElementValuePairs;\r\n    }\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Utility methods\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the size of a Runtime[In]Visible[Type]Annotations attribute containing this annotation\r\n * and all its <i>predecessors</i> (see {@link #previousAnnotation}. Also adds the attribute name\r\n * to the constant pool of the class (if not null).\r\n *\r\n * @param attributeName one of \"Runtime[In]Visible[Type]Annotations\", or {@literal null}.\r\n * @return the size in bytes of a Runtime[In]Visible[Type]Annotations attribute containing this\r\n *     annotation and all its predecessors. This includes the size of the attribute_name_index and\r\n *     attribute_length fields.\r\n */\r\nint computeAnnotationsSize(final String attributeName) {\r\n    if (attributeName != null) {\r\n        symbolTable.addConstantUtf8(attributeName);\r\n    }\r\n    // The attribute_name_index, attribute_length and num_annotations fields use 8 bytes.\r\n    int attributeSize = 8;\r\n    AnnotationWriter annotationWriter = this;\r\n    while (annotationWriter != null) {\r\n        attributeSize += annotationWriter.annotation.length;\r\n        annotationWriter = annotationWriter.previousAnnotation;\r\n    }\r\n    return attributeSize;\r\n}\n/**\r\n * Returns the size of the Runtime[In]Visible[Type]Annotations attributes containing the given\r\n * annotations and all their <i>predecessors</i> (see {@link #previousAnnotation}. Also adds the\r\n * attribute names to the constant pool of the class (if not null).\r\n *\r\n * @param lastRuntimeVisibleAnnotation The last runtime visible annotation of a field, method or\r\n *     class. The previous ones can be accessed with the {@link #previousAnnotation} field. May be\r\n *     {@literal null}.\r\n * @param lastRuntimeInvisibleAnnotation The last runtime invisible annotation of this a field,\r\n *     method or class. The previous ones can be accessed with the {@link #previousAnnotation}\r\n *     field. May be {@literal null}.\r\n * @param lastRuntimeVisibleTypeAnnotation The last runtime visible type annotation of this a\r\n *     field, method or class. The previous ones can be accessed with the {@link\r\n *     #previousAnnotation} field. May be {@literal null}.\r\n * @param lastRuntimeInvisibleTypeAnnotation The last runtime invisible type annotation of a\r\n *     field, method or class field. The previous ones can be accessed with the {@link\r\n *     #previousAnnotation} field. May be {@literal null}.\r\n * @return the size in bytes of a Runtime[In]Visible[Type]Annotations attribute containing the\r\n *     given annotations and all their predecessors. This includes the size of the\r\n *     attribute_name_index and attribute_length fields.\r\n */\r\nstatic int computeAnnotationsSize(final AnnotationWriter lastRuntimeVisibleAnnotation, final AnnotationWriter lastRuntimeInvisibleAnnotation, final AnnotationWriter lastRuntimeVisibleTypeAnnotation, final AnnotationWriter lastRuntimeInvisibleTypeAnnotation) {\r\n    int size = 0;\r\n    if (lastRuntimeVisibleAnnotation != null) {\r\n        size += lastRuntimeVisibleAnnotation.computeAnnotationsSize(Constants.RUNTIME_VISIBLE_ANNOTATIONS);\r\n    }\r\n    if (lastRuntimeInvisibleAnnotation != null) {\r\n        size += lastRuntimeInvisibleAnnotation.computeAnnotationsSize(Constants.RUNTIME_INVISIBLE_ANNOTATIONS);\r\n    }\r\n    if (lastRuntimeVisibleTypeAnnotation != null) {\r\n        size += lastRuntimeVisibleTypeAnnotation.computeAnnotationsSize(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\r\n    }\r\n    if (lastRuntimeInvisibleTypeAnnotation != null) {\r\n        size += lastRuntimeInvisibleTypeAnnotation.computeAnnotationsSize(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\r\n    }\r\n    return size;\r\n}\n/**\r\n * Puts a Runtime[In]Visible[Type]Annotations attribute containing this annotations and all its\r\n * <i>predecessors</i> (see {@link #previousAnnotation} in the given ByteVector. Annotations are\r\n * put in the same order they have been visited.\r\n *\r\n * @param attributeNameIndex the constant pool index of the attribute name (one of\r\n *     \"Runtime[In]Visible[Type]Annotations\").\r\n * @param output where the attribute must be put.\r\n */\r\nvoid putAnnotations(final int attributeNameIndex, final ByteVector output) {\r\n    // For num_annotations.\r\n    int attributeLength = 2;\r\n    int numAnnotations = 0;\r\n    AnnotationWriter annotationWriter = this;\r\n    AnnotationWriter firstAnnotation = null;\r\n    while (annotationWriter != null) {\r\n        // In case the user forgot to call visitEnd().\r\n        annotationWriter.visitEnd();\r\n        attributeLength += annotationWriter.annotation.length;\r\n        numAnnotations++;\r\n        firstAnnotation = annotationWriter;\r\n        annotationWriter = annotationWriter.previousAnnotation;\r\n    }\r\n    output.putShort(attributeNameIndex);\r\n    output.putInt(attributeLength);\r\n    output.putShort(numAnnotations);\r\n    annotationWriter = firstAnnotation;\r\n    while (annotationWriter != null) {\r\n        output.putByteArray(annotationWriter.annotation.data, 0, annotationWriter.annotation.length);\r\n        annotationWriter = annotationWriter.nextAnnotation;\r\n    }\r\n}\n/**\r\n * Puts the Runtime[In]Visible[Type]Annotations attributes containing the given annotations and\r\n * all their <i>predecessors</i> (see {@link #previousAnnotation} in the given ByteVector.\r\n * Annotations are put in the same order they have been visited.\r\n *\r\n * @param symbolTable where the constants used in the AnnotationWriter instances are stored.\r\n * @param lastRuntimeVisibleAnnotation The last runtime visible annotation of a field, method or\r\n *     class. The previous ones can be accessed with the {@link #previousAnnotation} field. May be\r\n *     {@literal null}.\r\n * @param lastRuntimeInvisibleAnnotation The last runtime invisible annotation of this a field,\r\n *     method or class. The previous ones can be accessed with the {@link #previousAnnotation}\r\n *     field. May be {@literal null}.\r\n * @param lastRuntimeVisibleTypeAnnotation The last runtime visible type annotation of this a\r\n *     field, method or class. The previous ones can be accessed with the {@link\r\n *     #previousAnnotation} field. May be {@literal null}.\r\n * @param lastRuntimeInvisibleTypeAnnotation The last runtime invisible type annotation of a\r\n *     field, method or class field. The previous ones can be accessed with the {@link\r\n *     #previousAnnotation} field. May be {@literal null}.\r\n * @param output where the attributes must be put.\r\n */\r\nstatic void putAnnotations(final SymbolTable symbolTable, final AnnotationWriter lastRuntimeVisibleAnnotation, final AnnotationWriter lastRuntimeInvisibleAnnotation, final AnnotationWriter lastRuntimeVisibleTypeAnnotation, final AnnotationWriter lastRuntimeInvisibleTypeAnnotation, final ByteVector output) {\r\n    if (lastRuntimeVisibleAnnotation != null) {\r\n        lastRuntimeVisibleAnnotation.putAnnotations(symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_ANNOTATIONS), output);\r\n    }\r\n    if (lastRuntimeInvisibleAnnotation != null) {\r\n        lastRuntimeInvisibleAnnotation.putAnnotations(symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_ANNOTATIONS), output);\r\n    }\r\n    if (lastRuntimeVisibleTypeAnnotation != null) {\r\n        lastRuntimeVisibleTypeAnnotation.putAnnotations(symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS), output);\r\n    }\r\n    if (lastRuntimeInvisibleTypeAnnotation != null) {\r\n        lastRuntimeInvisibleTypeAnnotation.putAnnotations(symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS), output);\r\n    }\r\n}\n/**\r\n * Returns the size of a Runtime[In]VisibleParameterAnnotations attribute containing all the\r\n * annotation lists from the given AnnotationWriter sub-array. Also adds the attribute name to the\r\n * constant pool of the class.\r\n *\r\n * @param attributeName one of \"Runtime[In]VisibleParameterAnnotations\".\r\n * @param annotationWriters an array of AnnotationWriter lists (designated by their <i>last</i>\r\n *     element).\r\n * @param annotableParameterCount the number of elements in annotationWriters to take into account\r\n *     (elements [0..annotableParameterCount[ are taken into account).\r\n * @return the size in bytes of a Runtime[In]VisibleParameterAnnotations attribute corresponding\r\n *     to the given sub-array of AnnotationWriter lists. This includes the size of the\r\n *     attribute_name_index and attribute_length fields.\r\n */\r\nstatic int computeParameterAnnotationsSize(final String attributeName, final AnnotationWriter[] annotationWriters, final int annotableParameterCount) {\r\n    // Note: attributeName is added to the constant pool by the call to computeAnnotationsSize\r\n    // below. This assumes that there is at least one non-null element in the annotationWriters\r\n    // sub-array (which is ensured by the lazy instantiation of this array in MethodWriter).\r\n    // The attribute_name_index, attribute_length and num_parameters fields use 7 bytes, and each\r\n    // element of the parameter_annotations array uses 2 bytes for its num_annotations field.\r\n    int attributeSize = 7 + 2 * annotableParameterCount;\r\n    for (int i = 0; i < annotableParameterCount; ++i) {\r\n        AnnotationWriter annotationWriter = annotationWriters[i];\r\n        attributeSize += annotationWriter == null ? 0 : annotationWriter.computeAnnotationsSize(attributeName) - 8;\r\n    }\r\n    return attributeSize;\r\n}\n/**\r\n * Puts a Runtime[In]VisibleParameterAnnotations attribute containing all the annotation lists\r\n * from the given AnnotationWriter sub-array in the given ByteVector.\r\n *\r\n * @param attributeNameIndex constant pool index of the attribute name (one of\r\n *     Runtime[In]VisibleParameterAnnotations).\r\n * @param annotationWriters an array of AnnotationWriter lists (designated by their <i>last</i>\r\n *     element).\r\n * @param annotableParameterCount the number of elements in annotationWriters to put (elements\r\n *     [0..annotableParameterCount[ are put).\r\n * @param output where the attribute must be put.\r\n */\r\nstatic void putParameterAnnotations(final int attributeNameIndex, final AnnotationWriter[] annotationWriters, final int annotableParameterCount, final ByteVector output) {\r\n    // The num_parameters field uses 1 byte, and each element of the parameter_annotations array\r\n    // uses 2 bytes for its num_annotations field.\r\n    int attributeLength = 1 + 2 * annotableParameterCount;\r\n    for (int i = 0; i < annotableParameterCount; ++i) {\r\n        AnnotationWriter annotationWriter = annotationWriters[i];\r\n        attributeLength += annotationWriter == null ? 0 : annotationWriter.computeAnnotationsSize(null) - 8;\r\n    }\r\n    output.putShort(attributeNameIndex);\r\n    output.putInt(attributeLength);\r\n    output.putByte(annotableParameterCount);\r\n    for (int i = 0; i < annotableParameterCount; ++i) {\r\n        AnnotationWriter annotationWriter = annotationWriters[i];\r\n        AnnotationWriter firstAnnotation = null;\r\n        int numAnnotations = 0;\r\n        while (annotationWriter != null) {\r\n            // In case user the forgot to call visitEnd().\r\n            annotationWriter.visitEnd();\r\n            numAnnotations++;\r\n            firstAnnotation = annotationWriter;\r\n            annotationWriter = annotationWriter.previousAnnotation;\r\n        }\r\n        output.putShort(numAnnotations);\r\n        annotationWriter = firstAnnotation;\r\n        while (annotationWriter != null) {\r\n            output.putByteArray(annotationWriter.annotation.data, 0, annotationWriter.annotation.length);\r\n            annotationWriter = annotationWriter.nextAnnotation;\r\n        }\r\n    }\r\n}",
    "comment": "\n * An {@link AnnotationVisitor} that generates a corresponding 'annotation' or 'type_annotation'\n * structure, as defined in the Java Virtual Machine Specification (JVMS). AnnotationWriter\n * instances can be chained in a doubly linked list, from which Runtime[In]Visible[Type]Annotations\n * attributes can be generated with the {@link #putAnnotations} method. Similarly, arrays of such\n * lists can be used to generate Runtime[In]VisibleParameterAnnotations attributes.\n *\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16\">JVMS\n *     4.7.16</a>\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20\">JVMS\n *     4.7.20</a>\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n "
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#nullSafeHashCodeWithObjectBeingBooleanArray()",
    "entityType": "method",
    "code": "@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithObjectBeingBooleanArray() {\r\n    Object array = new boolean[] { true, false };\r\n    int expected = ObjectUtils.nullSafeHashCode((boolean[]) array);\r\n    assertEqualHashCodes(expected, array);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#nullSafeHashCodeWithNullByteArray()",
    "entityType": "method",
    "code": "@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithNullByteArray() {\r\n    byte[] array = null;\r\n    assertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.AnnotationWriter#create(SymbolTable,String,AnnotationWriter)",
    "entityType": "method",
    "code": "/**\r\n * Creates a new {@link AnnotationWriter} using named values.\r\n *\r\n * @param symbolTable where the constants used in this AnnotationWriter must be stored.\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param previousAnnotation the previously visited annotation of the\r\n *     Runtime[In]Visible[Type]Annotations attribute to which this annotation belongs, or\r\n *     {@literal null} in other cases (for example, nested or array annotations).\r\n * @return a new {@link AnnotationWriter} for the given annotation descriptor.\r\n */\r\nstatic AnnotationWriter create(final SymbolTable symbolTable, final String descriptor, final AnnotationWriter previousAnnotation) {\r\n    // Create a ByteVector to hold an 'annotation' JVMS structure.\r\n    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16.\r\n    ByteVector annotation = new ByteVector();\r\n    // Write type_index and reserve space for num_element_value_pairs.\r\n    annotation.putShort(symbolTable.addConstantUtf8(descriptor)).putShort(0);\r\n    return new AnnotationWriter(symbolTable, /* useNamedValues= */\r\n    true, annotation, previousAnnotation);\r\n}",
    "comment": "\n   * Creates a new {@link AnnotationWriter} using named values.\n   *\n   * @param symbolTable where the constants used in this AnnotationWriter must be stored.\n   * @param descriptor the class descriptor of the annotation class.\n   * @param previousAnnotation the previously visited annotation of the\n   *     Runtime[In]Visible[Type]Annotations attribute to which this annotation belongs, or\n   *     {@literal null} in other cases (for example, nested or array annotations).\n   * @return a new {@link AnnotationWriter} for the given annotation descriptor.\n   "
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#nullSafeHashCodeWithByteArray()",
    "entityType": "method",
    "code": "@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithByteArray() {\r\n    byte[] array = { 8, 10 };\r\n    int actual = ObjectUtils.nullSafeHashCode(array);\r\n    assertThat(actual).isEqualTo(Arrays.hashCode(array));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#nullSafeHashCodeWithObjectBeingByteArray()",
    "entityType": "method",
    "code": "@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithObjectBeingByteArray() {\r\n    Object array = new byte[] { 6, 39 };\r\n    int expected = ObjectUtils.nullSafeHashCode((byte[]) array);\r\n    assertEqualHashCodes(expected, array);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.AnnotationWriter#create(SymbolTable,int,TypePath,String,AnnotationWriter)",
    "entityType": "method",
    "code": "/**\r\n * Creates a new {@link AnnotationWriter} using named values.\r\n *\r\n * @param symbolTable where the constants used in this AnnotationWriter must be stored.\r\n * @param typeRef a reference to the annotated type. The sort of this type reference must be\r\n *     {@link TypeReference#CLASS_TYPE_PARAMETER}, {@link\r\n *     TypeReference#CLASS_TYPE_PARAMETER_BOUND} or {@link TypeReference#CLASS_EXTENDS}. See\r\n *     {@link TypeReference}.\r\n * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\r\n *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\r\n *     'typeRef' as a whole.\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param previousAnnotation the previously visited annotation of the\r\n *     Runtime[In]Visible[Type]Annotations attribute to which this annotation belongs, or\r\n *     {@literal null} in other cases (for example, nested or array annotations).\r\n * @return a new {@link AnnotationWriter} for the given type annotation reference and descriptor.\r\n */\r\nstatic AnnotationWriter create(final SymbolTable symbolTable, final int typeRef, final TypePath typePath, final String descriptor, final AnnotationWriter previousAnnotation) {\r\n    // Create a ByteVector to hold a 'type_annotation' JVMS structure.\r\n    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20.\r\n    ByteVector typeAnnotation = new ByteVector();\r\n    // Write target_type, target_info, and target_path.\r\n    TypeReference.putTarget(typeRef, typeAnnotation);\r\n    TypePath.put(typePath, typeAnnotation);\r\n    // Write type_index and reserve space for num_element_value_pairs.\r\n    typeAnnotation.putShort(symbolTable.addConstantUtf8(descriptor)).putShort(0);\r\n    return new AnnotationWriter(symbolTable, /* useNamedValues= */\r\n    true, typeAnnotation, previousAnnotation);\r\n}",
    "comment": "\n   * Creates a new {@link AnnotationWriter} using named values.\n   *\n   * @param symbolTable where the constants used in this AnnotationWriter must be stored.\n   * @param typeRef a reference to the annotated type. The sort of this type reference must be\n   *     {@link TypeReference#CLASS_TYPE_PARAMETER}, {@link\n   *     TypeReference#CLASS_TYPE_PARAMETER_BOUND} or {@link TypeReference#CLASS_EXTENDS}. See\n   *     {@link TypeReference}.\n   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\n   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\n   *     'typeRef' as a whole.\n   * @param descriptor the class descriptor of the annotation class.\n   * @param previousAnnotation the previously visited annotation of the\n   *     Runtime[In]Visible[Type]Annotations attribute to which this annotation belongs, or\n   *     {@literal null} in other cases (for example, nested or array annotations).\n   * @return a new {@link AnnotationWriter} for the given type annotation reference and descriptor.\n   "
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#nullSafeHashCodeWithNullCharArray()",
    "entityType": "method",
    "code": "@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithNullCharArray() {\r\n    char[] array = null;\r\n    assertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#nullSafeHashCodeWithCharArray()",
    "entityType": "method",
    "code": "@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithCharArray() {\r\n    char[] array = { 'a', 'E' };\r\n    int actual = ObjectUtils.nullSafeHashCode(array);\r\n    assertThat(actual).isEqualTo(Arrays.hashCode(array));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#nullSafeHashCodeWithObjectBeingCharArray()",
    "entityType": "method",
    "code": "@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithObjectBeingCharArray() {\r\n    Object array = new char[] { 'l', 'M' };\r\n    int expected = ObjectUtils.nullSafeHashCode((char[]) array);\r\n    assertEqualHashCodes(expected, array);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#nullSafeHashCodeWithNullDoubleArray()",
    "entityType": "method",
    "code": "@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithNullDoubleArray() {\r\n    double[] array = null;\r\n    assertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#nullSafeHashCodeWithDoubleArray()",
    "entityType": "method",
    "code": "@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithDoubleArray() {\r\n    double[] array = { 8449.65, 9944.923 };\r\n    int actual = ObjectUtils.nullSafeHashCode(array);\r\n    assertThat(actual).isEqualTo(Arrays.hashCode(array));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#nullSafeHashCodeWithObjectBeingDoubleArray()",
    "entityType": "method",
    "code": "@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithObjectBeingDoubleArray() {\r\n    Object array = new double[] { 68930.993, 9022.009 };\r\n    int expected = ObjectUtils.nullSafeHashCode((double[]) array);\r\n    assertEqualHashCodes(expected, array);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#nullSafeHashCodeWithNullFloatArray()",
    "entityType": "method",
    "code": "@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithNullFloatArray() {\r\n    float[] array = null;\r\n    assertThat(ObjectUtils.nullSafeHashCode(array)).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ObjectUtilsTests#nullSafeHashCodeWithFloatArray()",
    "entityType": "method",
    "code": "@Test\r\n@Deprecated\r\nvoid nullSafeHashCodeWithFloatArray() {\r\n    float[] array = { 9.6f, 7.4f };\r\n    int actual = ObjectUtils.nullSafeHashCode(array);\r\n    assertThat(actual).isEqualTo(Arrays.hashCode(array));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.AnnotationWriter#visit(String,Object)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Implementation of the AnnotationVisitor abstract class\r\n// -----------------------------------------------------------------------------------------------\r\n@Override\r\npublic void visit(final String name, final Object value) {\r\n    // Case of an element_value with a const_value_index, class_info_index or array_index field.\r\n    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16.1.\r\n    ++numElementValuePairs;\r\n    if (useNamedValues) {\r\n        annotation.putShort(symbolTable.addConstantUtf8(name));\r\n    }\r\n    if (value instanceof String) {\r\n        annotation.put12('s', symbolTable.addConstantUtf8((String) value));\r\n    } else if (value instanceof Byte) {\r\n        annotation.put12('B', symbolTable.addConstantInteger(((Byte) value).byteValue()).index);\r\n    } else if (value instanceof Boolean) {\r\n        int booleanValue = ((Boolean) value).booleanValue() ? 1 : 0;\r\n        annotation.put12('Z', symbolTable.addConstantInteger(booleanValue).index);\r\n    } else if (value instanceof Character) {\r\n        annotation.put12('C', symbolTable.addConstantInteger(((Character) value).charValue()).index);\r\n    } else if (value instanceof Short) {\r\n        annotation.put12('S', symbolTable.addConstantInteger(((Short) value).shortValue()).index);\r\n    } else if (value instanceof Type) {\r\n        annotation.put12('c', symbolTable.addConstantUtf8(((Type) value).getDescriptor()));\r\n    } else if (value instanceof byte[]) {\r\n        byte[] byteArray = (byte[]) value;\r\n        annotation.put12('[', byteArray.length);\r\n        for (byte byteValue : byteArray) {\r\n            annotation.put12('B', symbolTable.addConstantInteger(byteValue).index);\r\n        }\r\n    } else if (value instanceof boolean[]) {\r\n        boolean[] booleanArray = (boolean[]) value;\r\n        annotation.put12('[', booleanArray.length);\r\n        for (boolean booleanValue : booleanArray) {\r\n            annotation.put12('Z', symbolTable.addConstantInteger(booleanValue ? 1 : 0).index);\r\n        }\r\n    } else if (value instanceof short[]) {\r\n        short[] shortArray = (short[]) value;\r\n        annotation.put12('[', shortArray.length);\r\n        for (short shortValue : shortArray) {\r\n            annotation.put12('S', symbolTable.addConstantInteger(shortValue).index);\r\n        }\r\n    } else if (value instanceof char[]) {\r\n        char[] charArray = (char[]) value;\r\n        annotation.put12('[', charArray.length);\r\n        for (char charValue : charArray) {\r\n            annotation.put12('C', symbolTable.addConstantInteger(charValue).index);\r\n        }\r\n    } else if (value instanceof int[]) {\r\n        int[] intArray = (int[]) value;\r\n        annotation.put12('[', intArray.length);\r\n        for (int intValue : intArray) {\r\n            annotation.put12('I', symbolTable.addConstantInteger(intValue).index);\r\n        }\r\n    } else if (value instanceof long[]) {\r\n        long[] longArray = (long[]) value;\r\n        annotation.put12('[', longArray.length);\r\n        for (long longValue : longArray) {\r\n            annotation.put12('J', symbolTable.addConstantLong(longValue).index);\r\n        }\r\n    } else if (value instanceof float[]) {\r\n        float[] floatArray = (float[]) value;\r\n        annotation.put12('[', floatArray.length);\r\n        for (float floatValue : floatArray) {\r\n            annotation.put12('F', symbolTable.addConstantFloat(floatValue).index);\r\n        }\r\n    } else if (value instanceof double[]) {\r\n        double[] doubleArray = (double[]) value;\r\n        annotation.put12('[', doubleArray.length);\r\n        for (double doubleValue : doubleArray) {\r\n            annotation.put12('D', symbolTable.addConstantDouble(doubleValue).index);\r\n        }\r\n    } else {\r\n        Symbol symbol = symbolTable.addConstant(value);\r\n        annotation.put12(\".s.IFJDCS\".charAt(symbol.tag), symbol.index);\r\n    }\r\n}",
    "comment": ""
  }
]