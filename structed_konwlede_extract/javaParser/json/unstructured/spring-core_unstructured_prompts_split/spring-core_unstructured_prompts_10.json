[
  {
    "entityId": "org.springframework.util.AssertTests#notEmptyCollectionWithMessageSupplier()",
    "entityType": "method",
    "code": "@Test\r\nvoid notEmptyCollectionWithMessageSupplier() {\r\n    Assert.notEmpty(singletonList(\"foo\"), () -> \"enigma\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#notEmptyCollectionWithEmptyCollectionAndMessageSupplier()",
    "entityType": "method",
    "code": "@Test\r\nvoid notEmptyCollectionWithEmptyCollectionAndMessageSupplier() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> Assert.notEmpty(emptyList(), () -> \"enigma\")).withMessageContaining(\"enigma\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#notEmptyCollectionWithNullCollectionAndMessageSupplier()",
    "entityType": "method",
    "code": "@Test\r\nvoid notEmptyCollectionWithNullCollectionAndMessageSupplier() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> Assert.notEmpty((Collection<?>) null, () -> \"enigma\")).withMessageContaining(\"enigma\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#notEmptyCollectionWithEmptyCollectionAndNullMessageSupplier()",
    "entityType": "method",
    "code": "@Test\r\nvoid notEmptyCollectionWithEmptyCollectionAndNullMessageSupplier() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> Assert.notEmpty(emptyList(), (Supplier<String>) null)).withMessage(null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#notEmptyMap()",
    "entityType": "method",
    "code": "@Test\r\nvoid notEmptyMap() {\r\n    Assert.notEmpty(singletonMap(\"foo\", \"bar\"), \"enigma\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#notEmptyMapWithNullMap()",
    "entityType": "method",
    "code": "@Test\r\nvoid notEmptyMapWithNullMap() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> Assert.notEmpty((Map<?, ?>) null, \"enigma\")).withMessageContaining(\"enigma\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#notEmptyMapWithEmptyMap()",
    "entityType": "method",
    "code": "@Test\r\nvoid notEmptyMapWithEmptyMap() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> Assert.notEmpty(emptyMap(), \"enigma\")).withMessageContaining(\"enigma\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#notEmptyMapWithMessageSupplier()",
    "entityType": "method",
    "code": "@Test\r\nvoid notEmptyMapWithMessageSupplier() {\r\n    Assert.notEmpty(singletonMap(\"foo\", \"bar\"), () -> \"enigma\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#notEmptyMapWithEmptyMapAndMessageSupplier()",
    "entityType": "method",
    "code": "@Test\r\nvoid notEmptyMapWithEmptyMapAndMessageSupplier() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> Assert.notEmpty(emptyMap(), () -> \"enigma\")).withMessageContaining(\"enigma\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#notEmptyMapWithNullMapAndMessageSupplier()",
    "entityType": "method",
    "code": "@Test\r\nvoid notEmptyMapWithNullMapAndMessageSupplier() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> Assert.notEmpty((Map<?, ?>) null, () -> \"enigma\")).withMessageContaining(\"enigma\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#notEmptyMapWithEmptyMapAndNullMessageSupplier()",
    "entityType": "method",
    "code": "@Test\r\nvoid notEmptyMapWithEmptyMapAndNullMessageSupplier() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> Assert.notEmpty(emptyMap(), (Supplier<String>) null)).withMessage(null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#isInstanceOf()",
    "entityType": "method",
    "code": "@Test\r\nvoid isInstanceOf() {\r\n    Assert.isInstanceOf(String.class, \"foo\", \"enigma\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#isInstanceOfWithNullType()",
    "entityType": "method",
    "code": "@Test\r\nvoid isInstanceOfWithNullType() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> Assert.isInstanceOf(null, \"foo\", \"enigma\")).withMessageContaining(\"Type to check against must not be null\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#isInstanceOfWithNullInstance()",
    "entityType": "method",
    "code": "@Test\r\nvoid isInstanceOfWithNullInstance() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> Assert.isInstanceOf(String.class, null, \"enigma\")).withMessageContaining(\"enigma: null\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#isInstanceOfWithTypeMismatchAndNullMessage()",
    "entityType": "method",
    "code": "@Test\r\nvoid isInstanceOfWithTypeMismatchAndNullMessage() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> Assert.isInstanceOf(String.class, 42L, (String) null)).withMessageContaining(\"Object of class [java.lang.Long] must be an instance of class java.lang.String\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#isInstanceOfWithTypeMismatchAndCustomMessage()",
    "entityType": "method",
    "code": "@Test\r\nvoid isInstanceOfWithTypeMismatchAndCustomMessage() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> Assert.isInstanceOf(String.class, 42L, \"Custom message\")).withMessageContaining(\"Custom message: java.lang.Long\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#isInstanceOfWithTypeMismatchAndCustomMessageWithSeparator()",
    "entityType": "method",
    "code": "@Test\r\nvoid isInstanceOfWithTypeMismatchAndCustomMessageWithSeparator() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> Assert.isInstanceOf(String.class, 42L, \"Custom message:\")).withMessageContaining(\"Custom message: Object of class [java.lang.Long] must be an instance of class java.lang.String\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#isInstanceOfWithTypeMismatchAndCustomMessageWithSpace()",
    "entityType": "method",
    "code": "@Test\r\nvoid isInstanceOfWithTypeMismatchAndCustomMessageWithSpace() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> Assert.isInstanceOf(String.class, 42L, \"Custom message for \")).withMessageContaining(\"Custom message for java.lang.Long\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#isInstanceOfWithMessageSupplier()",
    "entityType": "method",
    "code": "@Test\r\nvoid isInstanceOfWithMessageSupplier() {\r\n    Assert.isInstanceOf(String.class, \"foo\", () -> \"enigma\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#isInstanceOfWithNullTypeAndMessageSupplier()",
    "entityType": "method",
    "code": "@Test\r\nvoid isInstanceOfWithNullTypeAndMessageSupplier() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> Assert.isInstanceOf(null, \"foo\", () -> \"enigma\")).withMessageContaining(\"Type to check against must not be null\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#isInstanceOfWithNullInstanceAndMessageSupplier()",
    "entityType": "method",
    "code": "@Test\r\nvoid isInstanceOfWithNullInstanceAndMessageSupplier() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> Assert.isInstanceOf(String.class, null, () -> \"enigma\")).withMessageContaining(\"enigma: null\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#isInstanceOfWithTypeMismatchAndNullMessageSupplier()",
    "entityType": "method",
    "code": "@Test\r\nvoid isInstanceOfWithTypeMismatchAndNullMessageSupplier() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> Assert.isInstanceOf(String.class, 42L, (Supplier<String>) null)).withMessageContaining(\"Object of class [java.lang.Long] must be an instance of class java.lang.String\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#isInstanceOfWithTypeMismatchAndMessageSupplier()",
    "entityType": "method",
    "code": "@Test\r\nvoid isInstanceOfWithTypeMismatchAndMessageSupplier() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> Assert.isInstanceOf(String.class, 42L, () -> \"enigma\")).withMessageContaining(\"enigma: java.lang.Long\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#isAssignable()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAssignable() {\r\n    Assert.isAssignable(Number.class, Integer.class, \"enigma\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#isAssignableWithNullSupertype()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAssignableWithNullSupertype() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> Assert.isAssignable(null, Integer.class, \"enigma\")).withMessageContaining(\"Supertype to check against must not be null\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#isAssignableWithNullSubtype()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAssignableWithNullSubtype() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> Assert.isAssignable(Integer.class, null, \"enigma\")).withMessageContaining(\"enigma: null\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#isAssignableWithTypeMismatchAndNullMessage()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAssignableWithTypeMismatchAndNullMessage() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> Assert.isAssignable(String.class, Integer.class, (String) null)).withMessageContaining(\"class java.lang.Integer is not assignable to class java.lang.String\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#isAssignableWithTypeMismatchAndCustomMessage()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAssignableWithTypeMismatchAndCustomMessage() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> Assert.isAssignable(String.class, Integer.class, \"Custom message\")).withMessageContaining(\"Custom message: class java.lang.Integer\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#isAssignableWithTypeMismatchAndCustomMessageWithSeparator()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAssignableWithTypeMismatchAndCustomMessageWithSeparator() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> Assert.isAssignable(String.class, Integer.class, \"Custom message:\")).withMessageContaining(\"Custom message: class java.lang.Integer is not assignable to class java.lang.String\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#isAssignableWithTypeMismatchAndCustomMessageWithSpace()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAssignableWithTypeMismatchAndCustomMessageWithSpace() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> Assert.isAssignable(String.class, Integer.class, \"Custom message for \")).withMessageContaining(\"Custom message for class java.lang.Integer\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#isAssignableWithMessageSupplier()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAssignableWithMessageSupplier() {\r\n    Assert.isAssignable(Number.class, Integer.class, () -> \"enigma\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#isAssignableWithNullSupertypeAndMessageSupplier()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAssignableWithNullSupertypeAndMessageSupplier() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> Assert.isAssignable(null, Integer.class, () -> \"enigma\")).withMessageContaining(\"Supertype to check against must not be null\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#isAssignableWithNullSubtypeAndMessageSupplier()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAssignableWithNullSubtypeAndMessageSupplier() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> Assert.isAssignable(Integer.class, null, () -> \"enigma\")).withMessageContaining(\"enigma: null\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#isAssignableWithTypeMismatchAndNullMessageSupplier()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAssignableWithTypeMismatchAndNullMessageSupplier() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> Assert.isAssignable(String.class, Integer.class, (Supplier<String>) null)).withMessageContaining(\"class java.lang.Integer is not assignable to class java.lang.String\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#isAssignableWithTypeMismatchAndMessageSupplier()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAssignableWithTypeMismatchAndMessageSupplier() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> Assert.isAssignable(String.class, Integer.class, () -> \"enigma\")).withMessageContaining(\"enigma: class java.lang.Integer\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#state()",
    "entityType": "method",
    "code": "@Test\r\nvoid state() {\r\n    Assert.state(true, \"enigma\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AssertTests#stateWithFalseExpression()",
    "entityType": "method",
    "code": "@Test\r\nvoid stateWithFalseExpression() {\r\n    assertThatIllegalStateException().isThrownBy(() -> Assert.state(false, \"enigma\")).withMessageContaining(\"enigma\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.JavaSerializationHint",
    "entityType": "class",
    "code": "private final TypeReference type;\n@Nullable\r\nprivate final TypeReference reachableType;\nJavaSerializationHint(Builder builder) {\r\n    this.type = builder.type;\r\n    this.reachableType = builder.reachableType;\r\n}\n/**\r\n * Return the {@link TypeReference type} that needs to be serialized using Java serialization at runtime.\r\n * @return a {@link Serializable} type\r\n */\r\npublic TypeReference getType() {\r\n    return this.type;\r\n}\n@Override\r\n@Nullable\r\npublic TypeReference getReachableType() {\r\n    return this.reachableType;\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof JavaSerializationHint that && this.type.equals(that.type) && Objects.equals(this.reachableType, that.reachableType)));\r\n}\n@Override\r\npublic int hashCode() {\r\n    return Objects.hash(this.type, this.reachableType);\r\n}\n/**\r\n * Builder for {@link JavaSerializationHint}.\r\n */\r\npublic static class Builder {\r\n\r\n    private final TypeReference type;\r\n\r\n    @Nullable\r\n    private TypeReference reachableType;\r\n\r\n    Builder(TypeReference type) {\r\n        this.type = type;\r\n    }\r\n\r\n    /**\r\n     * Make this hint conditional on the fact that the specified type can be resolved.\r\n     * @param reachableType the type that should be reachable for this hint to apply\r\n     * @return {@code this}, to facilitate method chaining\r\n     */\r\n    public Builder onReachableType(TypeReference reachableType) {\r\n        this.reachableType = reachableType;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Create a {@link JavaSerializationHint} based on the state of this builder.\r\n     * @return a java serialization hint\r\n     */\r\n    JavaSerializationHint build() {\r\n        return new JavaSerializationHint(this);\r\n    }\r\n}",
    "comment": "\n * A hint that describes the need for Java serialization at runtime.\n *\n * @author Brian Clozel\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.hint.JavaSerializationHint#getType()",
    "entityType": "method",
    "code": "/**\r\n * Return the {@link TypeReference type} that needs to be serialized using Java serialization at runtime.\r\n * @return a {@link Serializable} type\r\n */\r\npublic TypeReference getType() {\r\n    return this.type;\r\n}",
    "comment": "\n\t * Return the {@link TypeReference type} that needs to be serialized using Java serialization at runtime.\n\t * @return a {@link Serializable} type\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.JavaSerializationHint#getReachableType()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic TypeReference getReachableType() {\r\n    return this.reachableType;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.JavaSerializationHint#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof JavaSerializationHint that && this.type.equals(that.type) && Objects.equals(this.reachableType, that.reachableType)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.JavaSerializationHint#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return Objects.hash(this.type, this.reachableType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.Builder",
    "entityType": "class",
    "code": "private final TypeReference type;\n@Nullable\r\nprivate TypeReference reachableType;\nBuilder(TypeReference type) {\r\n    this.type = type;\r\n}\n/**\r\n * Make this hint conditional on the fact that the specified type can be resolved.\r\n * @param reachableType the type that should be reachable for this hint to apply\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic Builder onReachableType(TypeReference reachableType) {\r\n    this.reachableType = reachableType;\r\n    return this;\r\n}\n/**\r\n * Create a {@link JavaSerializationHint} based on the state of this builder.\r\n * @return a java serialization hint\r\n */\r\nJavaSerializationHint build() {\r\n    return new JavaSerializationHint(this);\r\n}",
    "comment": "\n\t * Builder for {@link JavaSerializationHint}.\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.Builder#onReachableType(TypeReference)",
    "entityType": "method",
    "code": "/**\r\n * Make this hint conditional on the fact that the specified type can be resolved.\r\n * @param reachableType the type that should be reachable for this hint to apply\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic Builder onReachableType(TypeReference reachableType) {\r\n    this.reachableType = reachableType;\r\n    return this;\r\n}",
    "comment": "\n\t\t * Make this hint conditional on the fact that the specified type can be resolved.\n\t\t * @param reachableType the type that should be reachable for this hint to apply\n\t\t * @return {@code this}, to facilitate method chaining\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.hint.Builder#build()",
    "entityType": "method",
    "code": "/**\r\n * Create a {@link JavaSerializationHint} based on the state of this builder.\r\n * @return a java serialization hint\r\n */\r\nJavaSerializationHint build() {\r\n    return new JavaSerializationHint(this);\r\n}",
    "comment": "\n\t\t * Create a {@link JavaSerializationHint} based on the state of this builder.\n\t\t * @return a java serialization hint\n\t\t "
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingListTests",
    "entityType": "class",
    "code": "@Test\r\nvoid withClass() {\r\n    doTestWithClass(new AutoPopulatingList<>(TestObject.class));\r\n}\n@Test\r\nvoid withClassAndUserSuppliedBackingList() {\r\n    doTestWithClass(new AutoPopulatingList<>(new ArrayList<>(), TestObject.class));\r\n}\n@Test\r\nvoid withElementFactory() {\r\n    doTestWithElementFactory(new AutoPopulatingList<>(new MockElementFactory()));\r\n}\n@Test\r\nvoid withElementFactoryAndUserSuppliedBackingList() {\r\n    doTestWithElementFactory(new AutoPopulatingList<>(new ArrayList<>(), new MockElementFactory()));\r\n}\nprivate void doTestWithClass(AutoPopulatingList<Object> list) {\r\n    Object lastElement = null;\r\n    for (int x = 0; x < 10; x++) {\r\n        Object element = list.get(x);\r\n        assertThat(list.get(x)).as(\"Element is null\").isNotNull();\r\n        boolean condition = element instanceof TestObject;\r\n        assertThat(condition).as(\"Element is incorrect type\").isTrue();\r\n        assertThat(element).isNotSameAs(lastElement);\r\n        lastElement = element;\r\n    }\r\n    String helloWorld = \"Hello World!\";\r\n    list.add(10, null);\r\n    list.add(11, helloWorld);\r\n    assertThat(list).element(11, InstanceOfAssertFactories.STRING).isEqualTo(helloWorld);\r\n    boolean condition3 = list.get(10) instanceof TestObject;\r\n    assertThat(condition3).isTrue();\r\n    boolean condition2 = list.get(12) instanceof TestObject;\r\n    assertThat(condition2).isTrue();\r\n    boolean condition1 = list.get(13) instanceof TestObject;\r\n    assertThat(condition1).isTrue();\r\n    boolean condition = list.get(20) instanceof TestObject;\r\n    assertThat(condition).isTrue();\r\n}\nprivate void doTestWithElementFactory(AutoPopulatingList<Object> list) {\r\n    doTestWithClass(list);\r\n    for (int x = 0; x < list.size(); x++) {\r\n        Object element = list.get(x);\r\n        if (element instanceof TestObject) {\r\n            assertThat(((TestObject) element).getAge()).isEqualTo(x);\r\n        }\r\n    }\r\n}\n@Test\r\nvoid serialization() throws Exception {\r\n    AutoPopulatingList<?> list = new AutoPopulatingList<Object>(TestObject.class);\r\n    assertThat(SerializationTestUtils.serializeAndDeserialize(list)).isEqualTo(list);\r\n}\nprivate static class MockElementFactory implements AutoPopulatingList.ElementFactory<Object> {\r\n\r\n    @Override\r\n    public Object createElement(int index) {\r\n        TestObject bean = new TestObject();\r\n        bean.setAge(index);\r\n        return bean;\r\n    }\r\n}",
    "comment": "\n * @author Rob Harrop\n * @author Juergen Hoeller\n "
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingListTests#withClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid withClass() {\r\n    doTestWithClass(new AutoPopulatingList<>(TestObject.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingListTests#withClassAndUserSuppliedBackingList()",
    "entityType": "method",
    "code": "@Test\r\nvoid withClassAndUserSuppliedBackingList() {\r\n    doTestWithClass(new AutoPopulatingList<>(new ArrayList<>(), TestObject.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingListTests#withElementFactory()",
    "entityType": "method",
    "code": "@Test\r\nvoid withElementFactory() {\r\n    doTestWithElementFactory(new AutoPopulatingList<>(new MockElementFactory()));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingListTests#withElementFactoryAndUserSuppliedBackingList()",
    "entityType": "method",
    "code": "@Test\r\nvoid withElementFactoryAndUserSuppliedBackingList() {\r\n    doTestWithElementFactory(new AutoPopulatingList<>(new ArrayList<>(), new MockElementFactory()));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingListTests#doTestWithClass(AutoPopulatingList<Object>)",
    "entityType": "method",
    "code": "private void doTestWithClass(AutoPopulatingList<Object> list) {\r\n    Object lastElement = null;\r\n    for (int x = 0; x < 10; x++) {\r\n        Object element = list.get(x);\r\n        assertThat(list.get(x)).as(\"Element is null\").isNotNull();\r\n        boolean condition = element instanceof TestObject;\r\n        assertThat(condition).as(\"Element is incorrect type\").isTrue();\r\n        assertThat(element).isNotSameAs(lastElement);\r\n        lastElement = element;\r\n    }\r\n    String helloWorld = \"Hello World!\";\r\n    list.add(10, null);\r\n    list.add(11, helloWorld);\r\n    assertThat(list).element(11, InstanceOfAssertFactories.STRING).isEqualTo(helloWorld);\r\n    boolean condition3 = list.get(10) instanceof TestObject;\r\n    assertThat(condition3).isTrue();\r\n    boolean condition2 = list.get(12) instanceof TestObject;\r\n    assertThat(condition2).isTrue();\r\n    boolean condition1 = list.get(13) instanceof TestObject;\r\n    assertThat(condition1).isTrue();\r\n    boolean condition = list.get(20) instanceof TestObject;\r\n    assertThat(condition).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingListTests#doTestWithElementFactory(AutoPopulatingList<Object>)",
    "entityType": "method",
    "code": "private void doTestWithElementFactory(AutoPopulatingList<Object> list) {\r\n    doTestWithClass(list);\r\n    for (int x = 0; x < list.size(); x++) {\r\n        Object element = list.get(x);\r\n        if (element instanceof TestObject) {\r\n            assertThat(((TestObject) element).getAge()).isEqualTo(x);\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AutoPopulatingListTests#serialization()",
    "entityType": "method",
    "code": "@Test\r\nvoid serialization() throws Exception {\r\n    AutoPopulatingList<?> list = new AutoPopulatingList<Object>(TestObject.class);\r\n    assertThat(SerializationTestUtils.serializeAndDeserialize(list)).isEqualTo(list);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MockElementFactory",
    "entityType": "class",
    "code": "@Override\r\npublic Object createElement(int index) {\r\n    TestObject bean = new TestObject();\r\n    bean.setAge(index);\r\n    return bean;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MockElementFactory#createElement(int)",
    "entityType": "method",
    "code": "@Override\r\npublic Object createElement(int index) {\r\n    TestObject bean = new TestObject();\r\n    bean.setAge(index);\r\n    return bean;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.JdkProxyHint",
    "entityType": "class",
    "code": "private final List<TypeReference> proxiedInterfaces;\n@Nullable\r\nprivate final TypeReference reachableType;\nprivate JdkProxyHint(Builder builder) {\r\n    this.proxiedInterfaces = List.copyOf(builder.proxiedInterfaces);\r\n    this.reachableType = builder.reachableType;\r\n}\n/**\r\n * Initialize a builder with the proxied interfaces to use.\r\n * @param proxiedInterfaces the interfaces the proxy should implement\r\n * @return a builder for the hint\r\n */\r\npublic static Builder of(TypeReference... proxiedInterfaces) {\r\n    return new Builder().proxiedInterfaces(proxiedInterfaces);\r\n}\n/**\r\n * Initialize a builder with the proxied interfaces to use.\r\n * @param proxiedInterfaces the interfaces the proxy should implement\r\n * @return a builder for the hint\r\n */\r\npublic static Builder of(Class<?>... proxiedInterfaces) {\r\n    return new Builder().proxiedInterfaces(proxiedInterfaces);\r\n}\n/**\r\n * Return the interfaces to be proxied.\r\n * @return the interfaces that the proxy should implement\r\n */\r\npublic List<TypeReference> getProxiedInterfaces() {\r\n    return this.proxiedInterfaces;\r\n}\n@Override\r\n@Nullable\r\npublic TypeReference getReachableType() {\r\n    return this.reachableType;\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof JdkProxyHint that && this.proxiedInterfaces.equals(that.proxiedInterfaces) && Objects.equals(this.reachableType, that.reachableType)));\r\n}\n@Override\r\npublic int hashCode() {\r\n    return Objects.hash(this.proxiedInterfaces);\r\n}\n/**\r\n * Builder for {@link JdkProxyHint}.\r\n */\r\npublic static class Builder {\r\n\r\n    private final LinkedList<TypeReference> proxiedInterfaces;\r\n\r\n    @Nullable\r\n    private TypeReference reachableType;\r\n\r\n    Builder() {\r\n        this.proxiedInterfaces = new LinkedList<>();\r\n    }\r\n\r\n    /**\r\n     * Add the specified interfaces that the proxy should implement.\r\n     * @param proxiedInterfaces the interfaces the proxy should implement\r\n     * @return {@code this}, to facilitate method chaining\r\n     */\r\n    public Builder proxiedInterfaces(TypeReference... proxiedInterfaces) {\r\n        this.proxiedInterfaces.addAll(Arrays.asList(proxiedInterfaces));\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add the specified interfaces that the proxy should implement.\r\n     * @param proxiedInterfaces the interfaces the proxy should implement\r\n     * @return {@code this}, to facilitate method chaining\r\n     */\r\n    public Builder proxiedInterfaces(Class<?>... proxiedInterfaces) {\r\n        this.proxiedInterfaces.addAll(toTypeReferences(proxiedInterfaces));\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Make this hint conditional on the fact that the specified type can be resolved.\r\n     * @param reachableType the type that should be reachable for this hint to apply\r\n     * @return {@code this}, to facilitate method chaining\r\n     */\r\n    public Builder onReachableType(TypeReference reachableType) {\r\n        this.reachableType = reachableType;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Create a {@link JdkProxyHint} based on the state of this builder.\r\n     * @return a JDK proxy hint\r\n     */\r\n    JdkProxyHint build() {\r\n        return new JdkProxyHint(this);\r\n    }\r\n\r\n    private static List<TypeReference> toTypeReferences(Class<?>... proxiedInterfaces) {\r\n        List<String> invalidTypes = Arrays.stream(proxiedInterfaces).filter(candidate -> !candidate.isInterface() || candidate.isSealed()).map(Class::getName).toList();\r\n        if (!invalidTypes.isEmpty()) {\r\n            throw new IllegalArgumentException(\"The following must be non-sealed interfaces: \" + invalidTypes);\r\n        }\r\n        return TypeReference.listOf(proxiedInterfaces);\r\n    }\r\n}",
    "comment": "\n * A hint that describes the need for a JDK interface-based {@link Proxy}.\n *\n * @author Stephane Nicoll\n * @author Brian Clozel\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.hint.JdkProxyHint#of(TypeReference)",
    "entityType": "method",
    "code": "/**\r\n * Initialize a builder with the proxied interfaces to use.\r\n * @param proxiedInterfaces the interfaces the proxy should implement\r\n * @return a builder for the hint\r\n */\r\npublic static Builder of(TypeReference... proxiedInterfaces) {\r\n    return new Builder().proxiedInterfaces(proxiedInterfaces);\r\n}",
    "comment": "\n\t * Initialize a builder with the proxied interfaces to use.\n\t * @param proxiedInterfaces the interfaces the proxy should implement\n\t * @return a builder for the hint\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.JdkProxyHint#of(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Initialize a builder with the proxied interfaces to use.\r\n * @param proxiedInterfaces the interfaces the proxy should implement\r\n * @return a builder for the hint\r\n */\r\npublic static Builder of(Class<?>... proxiedInterfaces) {\r\n    return new Builder().proxiedInterfaces(proxiedInterfaces);\r\n}",
    "comment": "\n\t * Initialize a builder with the proxied interfaces to use.\n\t * @param proxiedInterfaces the interfaces the proxy should implement\n\t * @return a builder for the hint\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.JdkProxyHint#getProxiedInterfaces()",
    "entityType": "method",
    "code": "/**\r\n * Return the interfaces to be proxied.\r\n * @return the interfaces that the proxy should implement\r\n */\r\npublic List<TypeReference> getProxiedInterfaces() {\r\n    return this.proxiedInterfaces;\r\n}",
    "comment": "\n\t * Return the interfaces to be proxied.\n\t * @return the interfaces that the proxy should implement\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.JdkProxyHint#getReachableType()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic TypeReference getReachableType() {\r\n    return this.reachableType;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.JdkProxyHint#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof JdkProxyHint that && this.proxiedInterfaces.equals(that.proxiedInterfaces) && Objects.equals(this.reachableType, that.reachableType)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.JdkProxyHint#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return Objects.hash(this.proxiedInterfaces);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.Builder",
    "entityType": "class",
    "code": "private final LinkedList<TypeReference> proxiedInterfaces;\n@Nullable\r\nprivate TypeReference reachableType;\nBuilder() {\r\n    this.proxiedInterfaces = new LinkedList<>();\r\n}\n/**\r\n * Add the specified interfaces that the proxy should implement.\r\n * @param proxiedInterfaces the interfaces the proxy should implement\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic Builder proxiedInterfaces(TypeReference... proxiedInterfaces) {\r\n    this.proxiedInterfaces.addAll(Arrays.asList(proxiedInterfaces));\r\n    return this;\r\n}\n/**\r\n * Add the specified interfaces that the proxy should implement.\r\n * @param proxiedInterfaces the interfaces the proxy should implement\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic Builder proxiedInterfaces(Class<?>... proxiedInterfaces) {\r\n    this.proxiedInterfaces.addAll(toTypeReferences(proxiedInterfaces));\r\n    return this;\r\n}\n/**\r\n * Make this hint conditional on the fact that the specified type can be resolved.\r\n * @param reachableType the type that should be reachable for this hint to apply\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic Builder onReachableType(TypeReference reachableType) {\r\n    this.reachableType = reachableType;\r\n    return this;\r\n}\n/**\r\n * Create a {@link JdkProxyHint} based on the state of this builder.\r\n * @return a JDK proxy hint\r\n */\r\nJdkProxyHint build() {\r\n    return new JdkProxyHint(this);\r\n}\nprivate static List<TypeReference> toTypeReferences(Class<?>... proxiedInterfaces) {\r\n    List<String> invalidTypes = Arrays.stream(proxiedInterfaces).filter(candidate -> !candidate.isInterface() || candidate.isSealed()).map(Class::getName).toList();\r\n    if (!invalidTypes.isEmpty()) {\r\n        throw new IllegalArgumentException(\"The following must be non-sealed interfaces: \" + invalidTypes);\r\n    }\r\n    return TypeReference.listOf(proxiedInterfaces);\r\n}",
    "comment": "\n\t * Builder for {@link JdkProxyHint}.\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.Builder#proxiedInterfaces(TypeReference)",
    "entityType": "method",
    "code": "/**\r\n * Add the specified interfaces that the proxy should implement.\r\n * @param proxiedInterfaces the interfaces the proxy should implement\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic Builder proxiedInterfaces(TypeReference... proxiedInterfaces) {\r\n    this.proxiedInterfaces.addAll(Arrays.asList(proxiedInterfaces));\r\n    return this;\r\n}",
    "comment": "\n\t\t * Add the specified interfaces that the proxy should implement.\n\t\t * @param proxiedInterfaces the interfaces the proxy should implement\n\t\t * @return {@code this}, to facilitate method chaining\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.hint.Builder#proxiedInterfaces(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Add the specified interfaces that the proxy should implement.\r\n * @param proxiedInterfaces the interfaces the proxy should implement\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic Builder proxiedInterfaces(Class<?>... proxiedInterfaces) {\r\n    this.proxiedInterfaces.addAll(toTypeReferences(proxiedInterfaces));\r\n    return this;\r\n}",
    "comment": "\n\t\t * Add the specified interfaces that the proxy should implement.\n\t\t * @param proxiedInterfaces the interfaces the proxy should implement\n\t\t * @return {@code this}, to facilitate method chaining\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.hint.Builder#onReachableType(TypeReference)",
    "entityType": "method",
    "code": "/**\r\n * Make this hint conditional on the fact that the specified type can be resolved.\r\n * @param reachableType the type that should be reachable for this hint to apply\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic Builder onReachableType(TypeReference reachableType) {\r\n    this.reachableType = reachableType;\r\n    return this;\r\n}",
    "comment": "\n\t\t * Make this hint conditional on the fact that the specified type can be resolved.\n\t\t * @param reachableType the type that should be reachable for this hint to apply\n\t\t * @return {@code this}, to facilitate method chaining\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.hint.Builder#build()",
    "entityType": "method",
    "code": "/**\r\n * Create a {@link JdkProxyHint} based on the state of this builder.\r\n * @return a JDK proxy hint\r\n */\r\nJdkProxyHint build() {\r\n    return new JdkProxyHint(this);\r\n}",
    "comment": "\n\t\t * Create a {@link JdkProxyHint} based on the state of this builder.\n\t\t * @return a JDK proxy hint\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.hint.Builder#toTypeReferences(Class<?>)",
    "entityType": "method",
    "code": "private static List<TypeReference> toTypeReferences(Class<?>... proxiedInterfaces) {\r\n    List<String> invalidTypes = Arrays.stream(proxiedInterfaces).filter(candidate -> !candidate.isInterface() || candidate.isSealed()).map(Class::getName).toList();\r\n    if (!invalidTypes.isEmpty()) {\r\n        throw new IllegalArgumentException(\"The following must be non-sealed interfaces: \" + invalidTypes);\r\n    }\r\n    return TypeReference.listOf(proxiedInterfaces);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.MemberHint",
    "entityType": "class",
    "code": "private final String name;\nprotected MemberHint(String name) {\r\n    this.name = name;\r\n}\n/**\r\n * Return the name of the member.\r\n * @return the name\r\n */\r\npublic String getName() {\r\n    return this.name;\r\n}",
    "comment": "\n * Base hint that describes the need for reflection on a {@link Member}.\n *\n * @author Stephane Nicoll\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.hint.MemberHint#getName()",
    "entityType": "method",
    "code": "/**\r\n * Return the name of the member.\r\n * @return the name\r\n */\r\npublic String getName() {\r\n    return this.name;\r\n}",
    "comment": "\n\t * Return the name of the member.\n\t * @return the name\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests",
    "entityType": "class",
    "code": "private final ClassLoader classLoader = getClass().getClassLoader();\n@Test\r\nvoid isPresent() {\r\n    assertThat(ClassUtils.isPresent(\"java.lang.String\", classLoader)).isTrue();\r\n    assertThat(ClassUtils.isPresent(\"java.lang.MySpecialString\", classLoader)).isFalse();\r\n}\n@Test\r\nvoid forName() throws ClassNotFoundException {\r\n    assertThat(ClassUtils.forName(\"java.lang.String\", classLoader)).isEqualTo(String.class);\r\n    assertThat(ClassUtils.forName(\"java.lang.String[]\", classLoader)).isEqualTo(String[].class);\r\n    assertThat(ClassUtils.forName(String[].class.getName(), classLoader)).isEqualTo(String[].class);\r\n    assertThat(ClassUtils.forName(String[][].class.getName(), classLoader)).isEqualTo(String[][].class);\r\n    assertThat(ClassUtils.forName(String[][][].class.getName(), classLoader)).isEqualTo(String[][][].class);\r\n    assertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject\", classLoader)).isEqualTo(TestObject.class);\r\n    assertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject[]\", classLoader)).isEqualTo(TestObject[].class);\r\n    assertThat(ClassUtils.forName(TestObject[].class.getName(), classLoader)).isEqualTo(TestObject[].class);\r\n    assertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject[][]\", classLoader)).isEqualTo(TestObject[][].class);\r\n    assertThat(ClassUtils.forName(TestObject[][].class.getName(), classLoader)).isEqualTo(TestObject[][].class);\r\n    assertThat(ClassUtils.forName(\"[[[S\", classLoader)).isEqualTo(short[][][].class);\r\n}\n@Test\r\nvoid forNameWithNestedType() throws ClassNotFoundException {\r\n    assertThat(ClassUtils.forName(\"org.springframework.util.ClassUtilsTests$NestedClass\", classLoader)).isEqualTo(NestedClass.class);\r\n    assertThat(ClassUtils.forName(\"org.springframework.util.ClassUtilsTests.NestedClass\", classLoader)).isEqualTo(NestedClass.class);\r\n    // Precondition: package name must have length == 1.\r\n    assertThat(ClassHavingNestedClass.class.getPackageName().length()).isEqualTo(1);\r\n    assertThat(ClassUtils.forName(\"a.ClassHavingNestedClass$NestedClass\", classLoader)).isEqualTo(ClassHavingNestedClass.NestedClass.class);\r\n    assertThat(ClassUtils.forName(\"a.ClassHavingNestedClass.NestedClass\", classLoader)).isEqualTo(ClassHavingNestedClass.NestedClass.class);\r\n}\n@Test\r\nvoid forNameWithPrimitiveClasses() throws ClassNotFoundException {\r\n    assertThat(ClassUtils.forName(\"boolean\", classLoader)).isEqualTo(boolean.class);\r\n    assertThat(ClassUtils.forName(\"byte\", classLoader)).isEqualTo(byte.class);\r\n    assertThat(ClassUtils.forName(\"char\", classLoader)).isEqualTo(char.class);\r\n    assertThat(ClassUtils.forName(\"short\", classLoader)).isEqualTo(short.class);\r\n    assertThat(ClassUtils.forName(\"int\", classLoader)).isEqualTo(int.class);\r\n    assertThat(ClassUtils.forName(\"long\", classLoader)).isEqualTo(long.class);\r\n    assertThat(ClassUtils.forName(\"float\", classLoader)).isEqualTo(float.class);\r\n    assertThat(ClassUtils.forName(\"double\", classLoader)).isEqualTo(double.class);\r\n    assertThat(ClassUtils.forName(\"void\", classLoader)).isEqualTo(void.class);\r\n}\n@Test\r\nvoid forNameWithPrimitiveArrays() throws ClassNotFoundException {\r\n    assertThat(ClassUtils.forName(\"boolean[]\", classLoader)).isEqualTo(boolean[].class);\r\n    assertThat(ClassUtils.forName(\"byte[]\", classLoader)).isEqualTo(byte[].class);\r\n    assertThat(ClassUtils.forName(\"char[]\", classLoader)).isEqualTo(char[].class);\r\n    assertThat(ClassUtils.forName(\"short[]\", classLoader)).isEqualTo(short[].class);\r\n    assertThat(ClassUtils.forName(\"int[]\", classLoader)).isEqualTo(int[].class);\r\n    assertThat(ClassUtils.forName(\"long[]\", classLoader)).isEqualTo(long[].class);\r\n    assertThat(ClassUtils.forName(\"float[]\", classLoader)).isEqualTo(float[].class);\r\n    assertThat(ClassUtils.forName(\"double[]\", classLoader)).isEqualTo(double[].class);\r\n}\n@Test\r\nvoid forNameWithPrimitiveArraysInternalName() throws ClassNotFoundException {\r\n    assertThat(ClassUtils.forName(boolean[].class.getName(), classLoader)).isEqualTo(boolean[].class);\r\n    assertThat(ClassUtils.forName(byte[].class.getName(), classLoader)).isEqualTo(byte[].class);\r\n    assertThat(ClassUtils.forName(char[].class.getName(), classLoader)).isEqualTo(char[].class);\r\n    assertThat(ClassUtils.forName(short[].class.getName(), classLoader)).isEqualTo(short[].class);\r\n    assertThat(ClassUtils.forName(int[].class.getName(), classLoader)).isEqualTo(int[].class);\r\n    assertThat(ClassUtils.forName(long[].class.getName(), classLoader)).isEqualTo(long[].class);\r\n    assertThat(ClassUtils.forName(float[].class.getName(), classLoader)).isEqualTo(float[].class);\r\n    assertThat(ClassUtils.forName(double[].class.getName(), classLoader)).isEqualTo(double[].class);\r\n}\n@Test\r\nvoid isCacheSafe() {\r\n    ClassLoader childLoader1 = new ClassLoader(classLoader) ;;\r\n    ClassLoader childLoader2 = new ClassLoader(classLoader) ;;\r\n    ClassLoader childLoader3 = new ClassLoader(classLoader) {\r\n\r\n        @Override\r\n        public Class<?> loadClass(String name) throws ClassNotFoundException {\r\n            return childLoader1.loadClass(name);\r\n        }\r\n    };\r\n    Class<?> composite = ClassUtils.createCompositeInterface(new Class<?>[] { Serializable.class, Externalizable.class }, childLoader1);\r\n    assertThat(ClassUtils.isCacheSafe(String.class, null)).isTrue();\r\n    assertThat(ClassUtils.isCacheSafe(String.class, classLoader)).isTrue();\r\n    assertThat(ClassUtils.isCacheSafe(String.class, childLoader1)).isTrue();\r\n    assertThat(ClassUtils.isCacheSafe(String.class, childLoader2)).isTrue();\r\n    assertThat(ClassUtils.isCacheSafe(String.class, childLoader3)).isTrue();\r\n    assertThat(ClassUtils.isCacheSafe(NestedClass.class, null)).isFalse();\r\n    assertThat(ClassUtils.isCacheSafe(NestedClass.class, classLoader)).isTrue();\r\n    assertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader1)).isTrue();\r\n    assertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader2)).isTrue();\r\n    assertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader3)).isTrue();\r\n    assertThat(ClassUtils.isCacheSafe(composite, null)).isFalse();\r\n    assertThat(ClassUtils.isCacheSafe(composite, classLoader)).isFalse();\r\n    assertThat(ClassUtils.isCacheSafe(composite, childLoader1)).isTrue();\r\n    assertThat(ClassUtils.isCacheSafe(composite, childLoader2)).isFalse();\r\n    assertThat(ClassUtils.isCacheSafe(composite, childLoader3)).isTrue();\r\n}\n@ParameterizedTest(name = \"''{0}'' -> {1}\")\r\n@CsvSource(textBlock = \"\"\"\r\n    boolean, boolean\r\n    byte, byte\r\n    char, char\r\n    short, short\r\n    int, int\r\n    long, long\r\n    float, float\r\n    double, double\r\n    [Z, boolean[]\r\n    [B, byte[]\r\n    [C, char[]\r\n    [S, short[]\r\n    [I, int[]\r\n    [J, long[]\r\n    [F, float[]\r\n    [D, double[]\r\n    \"\"\")\r\nvoid resolvePrimitiveClassName(String input, Class<?> output) {\r\n    assertThat(ClassUtils.resolvePrimitiveClassName(input)).isEqualTo(output);\r\n}\n@Test\r\nvoid getShortName() {\r\n    String className = ClassUtils.getShortName(getClass());\r\n    assertThat(className).as(\"Class name did not match\").isEqualTo(\"ClassUtilsTests\");\r\n}\n@Test\r\nvoid getShortNameForObjectArrayClass() {\r\n    String className = ClassUtils.getShortName(Object[].class);\r\n    assertThat(className).as(\"Class name did not match\").isEqualTo(\"Object[]\");\r\n}\n@Test\r\nvoid getShortNameForMultiDimensionalObjectArrayClass() {\r\n    String className = ClassUtils.getShortName(Object[][].class);\r\n    assertThat(className).as(\"Class name did not match\").isEqualTo(\"Object[][]\");\r\n}\n@Test\r\nvoid getShortNameForPrimitiveArrayClass() {\r\n    String className = ClassUtils.getShortName(byte[].class);\r\n    assertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[]\");\r\n}\n@Test\r\nvoid getShortNameForMultiDimensionalPrimitiveArrayClass() {\r\n    String className = ClassUtils.getShortName(byte[][][].class);\r\n    assertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[][][]\");\r\n}\n@Test\r\nvoid getShortNameForNestedClass() {\r\n    String className = ClassUtils.getShortName(NestedClass.class);\r\n    assertThat(className).as(\"Class name did not match\").isEqualTo(\"ClassUtilsTests.NestedClass\");\r\n}\n@Test\r\nvoid getShortNameAsProperty() {\r\n    String shortName = ClassUtils.getShortNameAsProperty(this.getClass());\r\n    assertThat(shortName).as(\"Class name did not match\").isEqualTo(\"classUtilsTests\");\r\n}\n@Test\r\nvoid getClassFileName() {\r\n    assertThat(ClassUtils.getClassFileName(String.class)).isEqualTo(\"String.class\");\r\n    assertThat(ClassUtils.getClassFileName(getClass())).isEqualTo(\"ClassUtilsTests.class\");\r\n}\n@Test\r\nvoid getPackageName() {\r\n    assertThat(ClassUtils.getPackageName(String.class)).isEqualTo(\"java.lang\");\r\n    assertThat(ClassUtils.getPackageName(getClass())).isEqualTo(getClass().getPackage().getName());\r\n}\n@Test\r\nvoid getQualifiedName() {\r\n    String className = ClassUtils.getQualifiedName(getClass());\r\n    assertThat(className).as(\"Class name did not match\").isEqualTo(\"org.springframework.util.ClassUtilsTests\");\r\n}\n@Test\r\nvoid getQualifiedNameForObjectArrayClass() {\r\n    String className = ClassUtils.getQualifiedName(Object[].class);\r\n    assertThat(className).as(\"Class name did not match\").isEqualTo(\"java.lang.Object[]\");\r\n}\n@Test\r\nvoid getQualifiedNameForMultiDimensionalObjectArrayClass() {\r\n    String className = ClassUtils.getQualifiedName(Object[][].class);\r\n    assertThat(className).as(\"Class name did not match\").isEqualTo(\"java.lang.Object[][]\");\r\n}\n@Test\r\nvoid getQualifiedNameForPrimitiveArrayClass() {\r\n    String className = ClassUtils.getQualifiedName(byte[].class);\r\n    assertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[]\");\r\n}\n@Test\r\nvoid getQualifiedNameForMultiDimensionalPrimitiveArrayClass() {\r\n    String className = ClassUtils.getQualifiedName(byte[][].class);\r\n    assertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[][]\");\r\n}\n@Test\r\nvoid hasMethod() {\r\n    assertThat(ClassUtils.hasMethod(Collection.class, \"size\")).isTrue();\r\n    assertThat(ClassUtils.hasMethod(Collection.class, \"remove\", Object.class)).isTrue();\r\n    assertThat(ClassUtils.hasMethod(Collection.class, \"remove\")).isFalse();\r\n    assertThat(ClassUtils.hasMethod(Collection.class, \"someOtherMethod\")).isFalse();\r\n}\n@Test\r\nvoid getMethodIfAvailable() {\r\n    Method method = ClassUtils.getMethodIfAvailable(Collection.class, \"size\");\r\n    assertThat(method).isNotNull();\r\n    assertThat(method.getName()).isEqualTo(\"size\");\r\n    method = ClassUtils.getMethodIfAvailable(Collection.class, \"remove\", Object.class);\r\n    assertThat(method).isNotNull();\r\n    assertThat(method.getName()).isEqualTo(\"remove\");\r\n    assertThat(ClassUtils.getMethodIfAvailable(Collection.class, \"remove\")).isNull();\r\n    assertThat(ClassUtils.getMethodIfAvailable(Collection.class, \"someOtherMethod\")).isNull();\r\n}\n@Test\r\nvoid getMethodCountForName() {\r\n    assertThat(ClassUtils.getMethodCountForName(OverloadedMethodsClass.class, \"print\")).as(\"Verifying number of overloaded 'print' methods for OverloadedMethodsClass.\").isEqualTo(2);\r\n    assertThat(ClassUtils.getMethodCountForName(SubOverloadedMethodsClass.class, \"print\")).as(\"Verifying number of overloaded 'print' methods for SubOverloadedMethodsClass.\").isEqualTo(4);\r\n}\n@Test\r\nvoid countOverloadedMethods() {\r\n    assertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"foobar\")).isFalse();\r\n    // no args\r\n    assertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"hashCode\")).isTrue();\r\n    // matches although it takes an arg\r\n    assertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"setAge\")).isTrue();\r\n}\n@Test\r\nvoid isAssignable() {\r\n    assertThat(ClassUtils.isAssignable(Object.class, Object.class)).isTrue();\r\n    assertThat(ClassUtils.isAssignable(String.class, String.class)).isTrue();\r\n    assertThat(ClassUtils.isAssignable(Object.class, String.class)).isTrue();\r\n    assertThat(ClassUtils.isAssignable(Object.class, Integer.class)).isTrue();\r\n    assertThat(ClassUtils.isAssignable(Number.class, Integer.class)).isTrue();\r\n    assertThat(ClassUtils.isAssignable(Number.class, int.class)).isTrue();\r\n    assertThat(ClassUtils.isAssignable(Integer.class, int.class)).isTrue();\r\n    assertThat(ClassUtils.isAssignable(int.class, Integer.class)).isTrue();\r\n    assertThat(ClassUtils.isAssignable(String.class, Object.class)).isFalse();\r\n    assertThat(ClassUtils.isAssignable(Integer.class, Number.class)).isFalse();\r\n    assertThat(ClassUtils.isAssignable(Integer.class, double.class)).isFalse();\r\n    assertThat(ClassUtils.isAssignable(double.class, Integer.class)).isFalse();\r\n}\n@Test\r\nvoid classPackageAsResourcePath() {\r\n    String result = ClassUtils.classPackageAsResourcePath(Proxy.class);\r\n    assertThat(result).isEqualTo(\"java/lang/reflect\");\r\n}\n@Test\r\nvoid addResourcePathToPackagePath() {\r\n    String result = \"java/lang/reflect/xyzabc.xml\";\r\n    assertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"xyzabc.xml\")).isEqualTo(result);\r\n    assertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"/xyzabc.xml\")).isEqualTo(result);\r\n    assertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"a/b/c/d.xml\")).isEqualTo(\"java/lang/reflect/a/b/c/d.xml\");\r\n}\n@Test\r\nvoid getAllInterfaces() {\r\n    DerivedTestObject testBean = new DerivedTestObject();\r\n    List<Class<?>> ifcs = Arrays.asList(ClassUtils.getAllInterfaces(testBean));\r\n    assertThat(ifcs).as(\"Correct number of interfaces\").hasSize(4);\r\n    assertThat(ifcs.contains(Serializable.class)).as(\"Contains Serializable\").isTrue();\r\n    assertThat(ifcs.contains(ITestObject.class)).as(\"Contains ITestBean\").isTrue();\r\n    assertThat(ifcs.contains(ITestInterface.class)).as(\"Contains IOther\").isTrue();\r\n}\n@Test\r\nvoid classNamesToString() {\r\n    List<Class<?>> ifcs = new ArrayList<>();\r\n    ifcs.add(Serializable.class);\r\n    ifcs.add(Runnable.class);\r\n    assertThat(ifcs.toString()).isEqualTo(\"[interface java.io.Serializable, interface java.lang.Runnable]\");\r\n    assertThat(ClassUtils.classNamesToString(ifcs)).isEqualTo(\"[java.io.Serializable, java.lang.Runnable]\");\r\n    List<Class<?>> classes = new ArrayList<>();\r\n    classes.add(ArrayList.class);\r\n    classes.add(Integer.class);\r\n    assertThat(classes.toString()).isEqualTo(\"[class java.util.ArrayList, class java.lang.Integer]\");\r\n    assertThat(ClassUtils.classNamesToString(classes)).isEqualTo(\"[java.util.ArrayList, java.lang.Integer]\");\r\n    assertThat(Collections.singletonList(List.class).toString()).isEqualTo(\"[interface java.util.List]\");\r\n    assertThat(ClassUtils.classNamesToString(List.class)).isEqualTo(\"[java.util.List]\");\r\n    assertThat(Collections.EMPTY_LIST.toString()).isEqualTo(\"[]\");\r\n    assertThat(ClassUtils.classNamesToString(Collections.emptyList())).isEqualTo(\"[]\");\r\n}\n@Test\r\nvoid determineCommonAncestor() {\r\n    assertThat(ClassUtils.determineCommonAncestor(Integer.class, Number.class)).isEqualTo(Number.class);\r\n    assertThat(ClassUtils.determineCommonAncestor(Number.class, Integer.class)).isEqualTo(Number.class);\r\n    assertThat(ClassUtils.determineCommonAncestor(Number.class, null)).isEqualTo(Number.class);\r\n    assertThat(ClassUtils.determineCommonAncestor(null, Integer.class)).isEqualTo(Integer.class);\r\n    assertThat(ClassUtils.determineCommonAncestor(Integer.class, Integer.class)).isEqualTo(Integer.class);\r\n    assertThat(ClassUtils.determineCommonAncestor(Integer.class, Float.class)).isEqualTo(Number.class);\r\n    assertThat(ClassUtils.determineCommonAncestor(Float.class, Integer.class)).isEqualTo(Number.class);\r\n    assertThat(ClassUtils.determineCommonAncestor(Integer.class, String.class)).isNull();\r\n    assertThat(ClassUtils.determineCommonAncestor(String.class, Integer.class)).isNull();\r\n    assertThat(ClassUtils.determineCommonAncestor(List.class, Collection.class)).isEqualTo(Collection.class);\r\n    assertThat(ClassUtils.determineCommonAncestor(Collection.class, List.class)).isEqualTo(Collection.class);\r\n    assertThat(ClassUtils.determineCommonAncestor(Collection.class, null)).isEqualTo(Collection.class);\r\n    assertThat(ClassUtils.determineCommonAncestor(null, List.class)).isEqualTo(List.class);\r\n    assertThat(ClassUtils.determineCommonAncestor(List.class, List.class)).isEqualTo(List.class);\r\n    assertThat(ClassUtils.determineCommonAncestor(List.class, Set.class)).isNull();\r\n    assertThat(ClassUtils.determineCommonAncestor(Set.class, List.class)).isNull();\r\n    assertThat(ClassUtils.determineCommonAncestor(List.class, Runnable.class)).isNull();\r\n    assertThat(ClassUtils.determineCommonAncestor(Runnable.class, List.class)).isNull();\r\n    assertThat(ClassUtils.determineCommonAncestor(List.class, ArrayList.class)).isEqualTo(List.class);\r\n    assertThat(ClassUtils.determineCommonAncestor(ArrayList.class, List.class)).isEqualTo(List.class);\r\n    assertThat(ClassUtils.determineCommonAncestor(List.class, String.class)).isNull();\r\n    assertThat(ClassUtils.determineCommonAncestor(String.class, List.class)).isNull();\r\n}\n@Test\r\nvoid getMostSpecificMethod() throws NoSuchMethodException {\r\n    Method defaultPrintMethod = ClassUtils.getMethod(MethodsInterface.class, \"defaultPrint\");\r\n    assertThat(ClassUtils.getMostSpecificMethod(defaultPrintMethod, MethodsInterfaceImplementation.class)).isEqualTo(defaultPrintMethod);\r\n    assertThat(ClassUtils.getMostSpecificMethod(defaultPrintMethod, SubMethodsInterfaceImplementation.class)).isEqualTo(defaultPrintMethod);\r\n    Method printMethod = ClassUtils.getMethod(MethodsInterface.class, \"print\", String.class);\r\n    assertThat(ClassUtils.getMostSpecificMethod(printMethod, MethodsInterfaceImplementation.class)).isNotEqualTo(printMethod);\r\n    assertThat(ClassUtils.getMostSpecificMethod(printMethod, MethodsInterfaceImplementation.class)).isEqualTo(ClassUtils.getMethod(MethodsInterfaceImplementation.class, \"print\", String.class));\r\n    assertThat(ClassUtils.getMostSpecificMethod(printMethod, SubMethodsInterfaceImplementation.class)).isEqualTo(ClassUtils.getMethod(MethodsInterfaceImplementation.class, \"print\", String.class));\r\n    Method protectedPrintMethod = MethodsInterfaceImplementation.class.getDeclaredMethod(\"protectedPrint\");\r\n    assertThat(ClassUtils.getMostSpecificMethod(protectedPrintMethod, MethodsInterfaceImplementation.class)).isEqualTo(protectedPrintMethod);\r\n    assertThat(ClassUtils.getMostSpecificMethod(protectedPrintMethod, SubMethodsInterfaceImplementation.class)).isEqualTo(SubMethodsInterfaceImplementation.class.getDeclaredMethod(\"protectedPrint\"));\r\n    Method packageAccessiblePrintMethod = MethodsInterfaceImplementation.class.getDeclaredMethod(\"packageAccessiblePrint\");\r\n    assertThat(ClassUtils.getMostSpecificMethod(packageAccessiblePrintMethod, MethodsInterfaceImplementation.class)).isEqualTo(packageAccessiblePrintMethod);\r\n    assertThat(ClassUtils.getMostSpecificMethod(packageAccessiblePrintMethod, SubMethodsInterfaceImplementation.class)).isEqualTo(ClassUtils.getMethod(SubMethodsInterfaceImplementation.class, \"packageAccessiblePrint\"));\r\n}\n@ParameterizedTest\r\n@WrapperTypes\r\nvoid isPrimitiveWrapper(Class<?> type) {\r\n    assertThat(ClassUtils.isPrimitiveWrapper(type)).isTrue();\r\n}\n@ParameterizedTest\r\n@PrimitiveTypes\r\nvoid isPrimitiveOrWrapperWithPrimitive(Class<?> type) {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(type)).isTrue();\r\n}\n@ParameterizedTest\r\n@WrapperTypes\r\nvoid isPrimitiveOrWrapperWithWrapper(Class<?> type) {\r\n    assertThat(ClassUtils.isPrimitiveOrWrapper(type)).isTrue();\r\n}\n@Test\r\nvoid isLambda() {\r\n    assertIsLambda(ClassUtilsTests.staticLambdaExpression);\r\n    assertIsLambda(ClassUtilsTests::staticStringFactory);\r\n    assertIsLambda(this.instanceLambdaExpression);\r\n    assertIsLambda(this::instanceStringFactory);\r\n}\n@Test\r\n@SuppressWarnings(\"Convert2Lambda\")\r\nvoid isNotLambda() {\r\n    assertIsNotLambda(new EnigmaSupplier());\r\n    assertIsNotLambda(new Supplier<>() {\r\n\r\n        @Override\r\n        public String get() {\r\n            return \"anonymous inner class\";\r\n        }\r\n    });\r\n    assertIsNotLambda(new Fake$$LambdaSupplier());\r\n}\n@Nested\r\nclass GetStaticMethodTests {\r\n\r\n    @BeforeEach\r\n    void clearStatics() {\r\n        NestedClass.noArgCalled = false;\r\n        NestedClass.argCalled = false;\r\n        NestedClass.overloadedCalled = false;\r\n    }\r\n\r\n    @Test\r\n    void noArgsStaticMethod() throws IllegalAccessException, InvocationTargetException {\r\n        Method method = ClassUtils.getStaticMethod(NestedClass.class, \"staticMethod\");\r\n        method.invoke(null, (Object[]) null);\r\n        assertThat(NestedClass.noArgCalled).as(\"no argument method was not invoked.\").isTrue();\r\n    }\r\n\r\n    @Test\r\n    void argsStaticMethod() throws IllegalAccessException, InvocationTargetException {\r\n        Method method = ClassUtils.getStaticMethod(NestedClass.class, \"argStaticMethod\", String.class);\r\n        method.invoke(null, \"test\");\r\n        assertThat(NestedClass.argCalled).as(\"argument method was not invoked.\").isTrue();\r\n    }\r\n\r\n    @Test\r\n    void overloadedStaticMethod() throws IllegalAccessException, InvocationTargetException {\r\n        Method method = ClassUtils.getStaticMethod(NestedClass.class, \"staticMethod\", String.class);\r\n        method.invoke(null, \"test\");\r\n        assertThat(NestedClass.overloadedCalled).as(\"argument method was not invoked.\").isTrue();\r\n    }\r\n}\n// gh-33216\r\n@Nested\r\nclass GetInterfaceMethodTests {\r\n\r\n    @Test\r\n    void publicMethodInPublicClass() throws Exception {\r\n        Class<?> originalType = String.class;\r\n        Method originalMethod = originalType.getDeclaredMethod(\"getBytes\");\r\n        Method interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, null);\r\n        assertThat(interfaceMethod.getDeclaringClass()).isEqualTo(originalType);\r\n        assertThat(interfaceMethod).isSameAs(originalMethod);\r\n        assertNotInterfaceMethod(interfaceMethod);\r\n        assertPubliclyAccessible(interfaceMethod);\r\n    }\r\n\r\n    @Test\r\n    void publicMethodInNonPublicInterface() throws Exception {\r\n        Class<?> originalType = PrivateInterface.class;\r\n        Method originalMethod = originalType.getDeclaredMethod(\"getMessage\");\r\n        // Prerequisites for this use case:\r\n        assertPublic(originalMethod);\r\n        assertNotPublic(originalMethod.getDeclaringClass());\r\n        Method interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, null);\r\n        assertThat(interfaceMethod).isSameAs(originalMethod);\r\n        assertInterfaceMethod(interfaceMethod);\r\n        assertNotPubliclyAccessible(interfaceMethod);\r\n    }\r\n\r\n    @Test\r\n    void publicInterfaceMethodInPublicClass() throws Exception {\r\n        Class<?> originalType = ArrayList.class;\r\n        Method originalMethod = originalType.getDeclaredMethod(\"size\");\r\n        Method interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, null);\r\n        assertThat(interfaceMethod.getDeclaringClass()).isEqualTo(List.class);\r\n        assertThat(interfaceMethod.getName()).isEqualTo(\"size\");\r\n        assertThat(interfaceMethod.getParameterTypes()).isEmpty();\r\n        assertInterfaceMethod(interfaceMethod);\r\n        assertPubliclyAccessible(interfaceMethod);\r\n    }\r\n\r\n    @Test\r\n    void publicInterfaceMethodDeclaredInNonPublicClassWithLateBindingOfClassMethodToSubclassDeclaredInterface() throws Exception {\r\n        HashMap<String, String> hashMap = new HashMap<>();\r\n        // Returns a package-private java.util.HashMap.KeyIterator which extends java.util.HashMap.HashIterator\r\n        // which declares hasNext(), even though HashIterator does not implement Iterator. Rather, KeyIterator\r\n        // implements HashIterator.\r\n        Iterator<String> iterator = hashMap.keySet().iterator();\r\n        Class<?> targetClass = iterator.getClass();\r\n        // Prerequisites for this use case:\r\n        assertNotPublic(targetClass);\r\n        Method originalMethod = targetClass.getMethod(\"hasNext\");\r\n        Method interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, targetClass);\r\n        assertThat(interfaceMethod.getDeclaringClass()).isEqualTo(Iterator.class);\r\n        assertThat(interfaceMethod.getName()).isEqualTo(\"hasNext\");\r\n        assertThat(interfaceMethod.getParameterTypes()).isEmpty();\r\n        assertInterfaceMethod(interfaceMethod);\r\n        assertPubliclyAccessible(interfaceMethod);\r\n    }\r\n\r\n    @Test\r\n    void privateSubclassOverridesPropertyInPublicInterface() throws Exception {\r\n        Method originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getText\");\r\n        // Prerequisite: type must not be public for this use case.\r\n        assertNotPublic(originalMethod.getDeclaringClass());\r\n        Method interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, null);\r\n        assertThat(interfaceMethod.getDeclaringClass()).isEqualTo(PublicInterface.class);\r\n        assertThat(interfaceMethod.getName()).isEqualTo(\"getText\");\r\n        assertThat(interfaceMethod.getParameterTypes()).isEmpty();\r\n        assertInterfaceMethod(interfaceMethod);\r\n        assertPubliclyAccessible(interfaceMethod);\r\n    }\r\n\r\n    @Test\r\n    void privateSubclassOverridesPropertyInPrivateInterface() throws Exception {\r\n        Method originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getMessage\");\r\n        // Prerequisite: type must not be public for this use case.\r\n        assertNotPublic(originalMethod.getDeclaringClass());\r\n        Method interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, null);\r\n        assertThat(interfaceMethod.getDeclaringClass()).isEqualTo(PrivateInterface.class);\r\n        assertThat(interfaceMethod.getName()).isEqualTo(\"getMessage\");\r\n        assertThat(interfaceMethod.getParameterTypes()).isEmpty();\r\n        assertInterfaceMethod(interfaceMethod);\r\n        assertNotPubliclyAccessible(interfaceMethod);\r\n    }\r\n\r\n    @Test\r\n    void packagePrivateSubclassOverridesMethodInPublicInterface() throws Exception {\r\n        List<String> unmodifiableList = Collections.unmodifiableList(Arrays.asList(\"foo\", \"bar\"));\r\n        Class<?> targetClass = unmodifiableList.getClass();\r\n        // Prerequisites for this use case:\r\n        assertNotPublic(targetClass);\r\n        Method originalMethod = targetClass.getMethod(\"contains\", Object.class);\r\n        // Prerequisite: type must not be public for this use case.\r\n        assertNotPublic(originalMethod.getDeclaringClass());\r\n        Method interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, null);\r\n        assertThat(interfaceMethod.getDeclaringClass()).isEqualTo(Collection.class);\r\n        assertThat(interfaceMethod.getName()).isEqualTo(\"contains\");\r\n        assertThat(interfaceMethod.getParameterTypes()).containsExactly(Object.class);\r\n        assertInterfaceMethod(interfaceMethod);\r\n        assertPubliclyAccessible(interfaceMethod);\r\n    }\r\n\r\n    @Test\r\n    void privateSubclassOverridesMethodInPrivateInterface() throws Exception {\r\n        Method originalMethod = PrivateSubclass.class.getMethod(\"greet\", String.class);\r\n        // Prerequisite: type must not be public for this use case.\r\n        assertNotPublic(originalMethod.getDeclaringClass());\r\n        Method interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(originalMethod, null);\r\n        assertThat(interfaceMethod.getDeclaringClass()).isEqualTo(PrivateInterface.class);\r\n        assertThat(interfaceMethod.getName()).isEqualTo(\"greet\");\r\n        assertThat(interfaceMethod.getParameterTypes()).containsExactly(String.class);\r\n        assertInterfaceMethod(interfaceMethod);\r\n        assertNotPubliclyAccessible(interfaceMethod);\r\n    }\r\n}\n// gh-33216\r\n@Nested\r\nclass GetPubliclyAccessibleMethodTests {\r\n\r\n    @Test\r\n    void nonPublicMethod(TestInfo testInfo) {\r\n        Method originalMethod = testInfo.getTestMethod().get();\r\n        // Prerequisites for this use case:\r\n        assertNotPublic(originalMethod);\r\n        Method publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\r\n        assertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\r\n        assertNotPubliclyAccessible(publiclyAccessibleMethod);\r\n    }\r\n\r\n    @Test\r\n    public // This method is intentionally public.\r\n    void publicMethodInNonPublicClass(TestInfo testInfo) {\r\n        Method originalMethod = testInfo.getTestMethod().get();\r\n        // Prerequisites for this use case:\r\n        assertPublic(originalMethod);\r\n        assertNotPublic(originalMethod.getDeclaringClass());\r\n        Method publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\r\n        assertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\r\n        assertNotPubliclyAccessible(publiclyAccessibleMethod);\r\n    }\r\n\r\n    @Test\r\n    void publicMethodInNonPublicInterface() throws Exception {\r\n        Class<?> originalType = PrivateInterface.class;\r\n        Method originalMethod = originalType.getDeclaredMethod(\"getMessage\");\r\n        // Prerequisites for this use case:\r\n        assertPublic(originalMethod);\r\n        assertNotPublic(originalMethod.getDeclaringClass());\r\n        Method publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\r\n        assertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\r\n        assertNotPubliclyAccessible(publiclyAccessibleMethod);\r\n    }\r\n\r\n    @Test\r\n    void publicMethodInPublicClass() throws Exception {\r\n        Class<?> originalType = String.class;\r\n        Method originalMethod = originalType.getDeclaredMethod(\"toString\");\r\n        Method publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\r\n        assertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(originalType);\r\n        assertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\r\n        assertPubliclyAccessible(publiclyAccessibleMethod);\r\n    }\r\n\r\n    @Test\r\n    void publicInterfaceMethodInPublicClass() throws Exception {\r\n        Class<?> originalType = ArrayList.class;\r\n        Method originalMethod = originalType.getDeclaredMethod(\"size\");\r\n        Method publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\r\n        // Should not find the interface method in List.\r\n        assertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(originalType);\r\n        assertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\r\n        assertPubliclyAccessible(publiclyAccessibleMethod);\r\n    }\r\n\r\n    @Test\r\n    void publicMethodInJavaLangObjectDeclaredInNonPublicClass() throws Exception {\r\n        List<String> unmodifiableList = Collections.unmodifiableList(Arrays.asList(\"foo\", \"bar\"));\r\n        Class<?> targetClass = unmodifiableList.getClass();\r\n        // Prerequisites for this use case:\r\n        assertNotPublic(targetClass);\r\n        Method originalMethod = targetClass.getMethod(\"toString\");\r\n        Method publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\r\n        assertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Object.class);\r\n        assertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"toString\");\r\n        assertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\r\n        assertPubliclyAccessible(publiclyAccessibleMethod);\r\n    }\r\n\r\n    @Test\r\n    void publicMethodInJavaTimeZoneIdDeclaredInNonPublicSubclass() throws Exception {\r\n        // Returns a package-private java.time.ZoneRegion.\r\n        ZoneId zoneId = ZoneId.of(\"CET\");\r\n        Class<?> targetClass = zoneId.getClass();\r\n        // Prerequisites for this use case:\r\n        assertNotPublic(targetClass);\r\n        Method originalMethod = targetClass.getDeclaredMethod(\"getId\");\r\n        Method publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\r\n        assertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(ZoneId.class);\r\n        assertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getId\");\r\n        assertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\r\n        assertPubliclyAccessible(publiclyAccessibleMethod);\r\n    }\r\n\r\n    @Test\r\n    void publicInterfaceMethodDeclaredInNonPublicClassWithLateBindingOfClassMethodToSubclassDeclaredInterface() throws Exception {\r\n        HashMap<String, String> hashMap = new HashMap<>();\r\n        // Returns a package-private java.util.HashMap.KeyIterator which extends java.util.HashMap.HashIterator\r\n        // which declares hasNext(), even though HashIterator does not implement Iterator. Rather, KeyIterator\r\n        // implements HashIterator.\r\n        Iterator<String> iterator = hashMap.keySet().iterator();\r\n        Class<?> targetClass = iterator.getClass();\r\n        // Prerequisites for this use case:\r\n        assertNotPublic(targetClass);\r\n        Method originalMethod = targetClass.getMethod(\"hasNext\");\r\n        Method publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, targetClass);\r\n        assertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Iterator.class);\r\n        assertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"hasNext\");\r\n        assertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\r\n        assertPubliclyAccessible(publiclyAccessibleMethod);\r\n    }\r\n\r\n    @Test\r\n    void privateSubclassOverridesPropertyInPublicInterface() throws Exception {\r\n        Method originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getText\");\r\n        // Prerequisite: type must not be public for this use case.\r\n        assertNotPublic(originalMethod.getDeclaringClass());\r\n        Method publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\r\n        assertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicInterface.class);\r\n        assertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getText\");\r\n        assertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\r\n        assertPubliclyAccessible(publiclyAccessibleMethod);\r\n    }\r\n\r\n    @Test\r\n    void privateSubclassOverridesPropertyInPrivateInterface() throws Exception {\r\n        Method originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getMessage\");\r\n        // Prerequisite: type must not be public for this use case.\r\n        assertNotPublic(originalMethod.getDeclaringClass());\r\n        Method publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\r\n        // Should not find the interface method in PrivateInterface.\r\n        assertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\r\n        assertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getMessage\");\r\n        assertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\r\n        assertPubliclyAccessible(publiclyAccessibleMethod);\r\n    }\r\n\r\n    @Test\r\n    void privateSubclassOverridesPropertyInPublicSuperclass() throws Exception {\r\n        Method originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getNumber\");\r\n        // Prerequisite: type must not be public for this use case.\r\n        assertNotPublic(originalMethod.getDeclaringClass());\r\n        Method publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\r\n        assertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\r\n        assertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getNumber\");\r\n        assertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\r\n        assertPubliclyAccessible(publiclyAccessibleMethod);\r\n    }\r\n\r\n    @Test\r\n    void packagePrivateSubclassOverridesMethodInPublicInterface() throws Exception {\r\n        List<String> unmodifiableList = Collections.unmodifiableList(Arrays.asList(\"foo\", \"bar\"));\r\n        Class<?> targetClass = unmodifiableList.getClass();\r\n        // Prerequisites for this use case:\r\n        assertNotPublic(targetClass);\r\n        Method originalMethod = targetClass.getMethod(\"contains\", Object.class);\r\n        // Prerequisite: type must not be public for this use case.\r\n        assertNotPublic(originalMethod.getDeclaringClass());\r\n        Method publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\r\n        assertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Collection.class);\r\n        assertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"contains\");\r\n        assertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(Object.class);\r\n        assertPubliclyAccessible(publiclyAccessibleMethod);\r\n    }\r\n\r\n    @Test\r\n    void privateSubclassOverridesMethodInPrivateInterface() throws Exception {\r\n        Method originalMethod = PrivateSubclass.class.getMethod(\"greet\", String.class);\r\n        // Prerequisite: type must not be public for this use case.\r\n        assertNotPublic(originalMethod.getDeclaringClass());\r\n        Method publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\r\n        assertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\r\n        assertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"greet\");\r\n        assertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(String.class);\r\n        assertPubliclyAccessible(publiclyAccessibleMethod);\r\n    }\r\n\r\n    @Test\r\n    void privateSubclassOverridesMethodInPublicSuperclass() throws Exception {\r\n        Method originalMethod = PrivateSubclass.class.getMethod(\"process\", int.class);\r\n        // Prerequisite: type must not be public for this use case.\r\n        assertNotPublic(originalMethod.getDeclaringClass());\r\n        Method publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\r\n        assertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\r\n        assertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"process\");\r\n        assertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(int.class);\r\n        assertPubliclyAccessible(publiclyAccessibleMethod);\r\n    }\r\n}\nprivate static void assertInterfaceMethod(Method method) {\r\n    assertThat(method.getDeclaringClass()).as(\"%s must be an interface method\", method).isInterface();\r\n}\nprivate static void assertNotInterfaceMethod(Method method) {\r\n    assertThat(method.getDeclaringClass()).as(\"%s must not be an interface method\", method).isNotInterface();\r\n}\nprivate static void assertPubliclyAccessible(Method method) {\r\n    assertPublic(method);\r\n    assertPublic(method.getDeclaringClass());\r\n}\nprivate static void assertNotPubliclyAccessible(Method method) {\r\n    assertThat(!isPublic(method) || !isPublic(method.getDeclaringClass())).as(\"%s must not be publicly accessible\", method).isTrue();\r\n}\nprivate static void assertPublic(Member member) {\r\n    assertThat(isPublic(member)).as(\"%s must be public\", member).isTrue();\r\n}\nprivate static void assertPublic(Class<?> clazz) {\r\n    assertThat(isPublic(clazz)).as(\"%s must be public\", clazz).isTrue();\r\n}\nprivate static void assertNotPublic(Member member) {\r\n    assertThat(!isPublic(member)).as(\"%s must be not be public\", member).isTrue();\r\n}\nprivate static void assertNotPublic(Class<?> clazz) {\r\n    assertThat(!isPublic(clazz)).as(\"%s must be not be public\", clazz).isTrue();\r\n}\nprivate static boolean isPublic(Class<?> clazz) {\r\n    return Modifier.isPublic(clazz.getModifiers());\r\n}\nprivate static boolean isPublic(Member member) {\r\n    return Modifier.isPublic(member.getModifiers());\r\n}\n@Target(ElementType.METHOD)\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@ValueSource(classes = { Boolean.class, Character.class, Byte.class, Short.class, Integer.class, Long.class, Float.class, Double.class, Void.class })\r\n@interface WrapperTypes {\r\n}\n@Target(ElementType.METHOD)\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@ValueSource(classes = { boolean.class, char.class, byte.class, short.class, int.class, long.class, float.class, double.class, void.class })\r\n@interface PrimitiveTypes {\r\n}\npublic static class NestedClass {\r\n\r\n    static boolean noArgCalled;\r\n\r\n    static boolean argCalled;\r\n\r\n    static boolean overloadedCalled;\r\n\r\n    public static void staticMethod() {\r\n        noArgCalled = true;\r\n    }\r\n\r\n    public static void staticMethod(String anArg) {\r\n        overloadedCalled = true;\r\n    }\r\n\r\n    public static void argStaticMethod(String anArg) {\r\n        argCalled = true;\r\n    }\r\n}\n@SuppressWarnings(\"unused\")\r\nprivate static class OverloadedMethodsClass {\r\n\r\n    public void print(String messages) {\r\n        /* no-op */\r\n    }\r\n\r\n    public void print(String[] messages) {\r\n        /* no-op */\r\n    }\r\n}\n@SuppressWarnings(\"unused\")\r\nprivate static class SubOverloadedMethodsClass extends OverloadedMethodsClass {\r\n\r\n    public void print(String header, String[] messages) {\r\n        /* no-op */\r\n    }\r\n\r\n    void print(String header, String[] messages, String footer) {\r\n        /* no-op */\r\n    }\r\n}\nprivate static void assertIsLambda(Supplier<String> supplier) {\r\n    assertThat(ClassUtils.isLambdaClass(supplier.getClass())).isTrue();\r\n}\nprivate static void assertIsNotLambda(Supplier<String> supplier) {\r\n    assertThat(ClassUtils.isLambdaClass(supplier.getClass())).isFalse();\r\n}\nprivate static final Supplier<String> staticLambdaExpression = () -> \"static lambda expression\";\nprivate final Supplier<String> instanceLambdaExpression = () -> \"instance lambda expressions\";\nprivate static String staticStringFactory() {\r\n    return \"static string factory\";\r\n}\nprivate String instanceStringFactory() {\r\n    return \"instance string factory\";\r\n}\nprivate static class EnigmaSupplier implements Supplier<String> {\r\n\r\n    @Override\r\n    public String get() {\r\n        return \"enigma\";\r\n    }\r\n}\nprivate static class Fake$$LambdaSupplier implements Supplier<String> {\r\n\r\n    @Override\r\n    public String get() {\r\n        return \"fake lambda\";\r\n    }\r\n}\n@SuppressWarnings(\"unused\")\r\nprivate interface MethodsInterface {\r\n\r\n    default void defaultPrint() {\r\n    }\r\n\r\n    void print(String messages);\r\n}\n@SuppressWarnings(\"unused\")\r\nprivate class MethodsInterfaceImplementation implements MethodsInterface {\r\n\r\n    @Override\r\n    public void print(String message) {\r\n    }\r\n\r\n    protected void protectedPrint() {\r\n    }\r\n\r\n    void packageAccessiblePrint() {\r\n    }\r\n}\n@SuppressWarnings(\"unused\")\r\nprivate class SubMethodsInterfaceImplementation extends MethodsInterfaceImplementation {\r\n\r\n    @Override\r\n    protected void protectedPrint() {\r\n    }\r\n\r\n    @Override\r\n    public void packageAccessiblePrint() {\r\n    }\r\n}\nprivate interface PrivateInterface {\r\n\r\n    String getMessage();\r\n\r\n    String greet(String name);\r\n}\nprivate static class PrivateSubclass extends PublicSuperclass implements PublicInterface, PrivateInterface {\r\n\r\n    @Override\r\n    public int getNumber() {\r\n        return 2;\r\n    }\r\n\r\n    @Override\r\n    public String getMessage() {\r\n        return \"hello\";\r\n    }\r\n\r\n    @Override\r\n    public String greet(String name) {\r\n        return \"Hello, \" + name;\r\n    }\r\n\r\n    @Override\r\n    public int process(int num) {\r\n        return num * 2;\r\n    }\r\n\r\n    @Override\r\n    public String getText() {\r\n        return \"enigma\";\r\n    }\r\n}",
    "comment": "\n * Tests for {@link ClassUtils}.\n *\n * @author Colin Sampaleanu\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Rick Evans\n * @author Sam Brannen\n "
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#isPresent()",
    "entityType": "method",
    "code": "@Test\r\nvoid isPresent() {\r\n    assertThat(ClassUtils.isPresent(\"java.lang.String\", classLoader)).isTrue();\r\n    assertThat(ClassUtils.isPresent(\"java.lang.MySpecialString\", classLoader)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#forName()",
    "entityType": "method",
    "code": "@Test\r\nvoid forName() throws ClassNotFoundException {\r\n    assertThat(ClassUtils.forName(\"java.lang.String\", classLoader)).isEqualTo(String.class);\r\n    assertThat(ClassUtils.forName(\"java.lang.String[]\", classLoader)).isEqualTo(String[].class);\r\n    assertThat(ClassUtils.forName(String[].class.getName(), classLoader)).isEqualTo(String[].class);\r\n    assertThat(ClassUtils.forName(String[][].class.getName(), classLoader)).isEqualTo(String[][].class);\r\n    assertThat(ClassUtils.forName(String[][][].class.getName(), classLoader)).isEqualTo(String[][][].class);\r\n    assertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject\", classLoader)).isEqualTo(TestObject.class);\r\n    assertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject[]\", classLoader)).isEqualTo(TestObject[].class);\r\n    assertThat(ClassUtils.forName(TestObject[].class.getName(), classLoader)).isEqualTo(TestObject[].class);\r\n    assertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject[][]\", classLoader)).isEqualTo(TestObject[][].class);\r\n    assertThat(ClassUtils.forName(TestObject[][].class.getName(), classLoader)).isEqualTo(TestObject[][].class);\r\n    assertThat(ClassUtils.forName(\"[[[S\", classLoader)).isEqualTo(short[][][].class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#forNameWithNestedType()",
    "entityType": "method",
    "code": "@Test\r\nvoid forNameWithNestedType() throws ClassNotFoundException {\r\n    assertThat(ClassUtils.forName(\"org.springframework.util.ClassUtilsTests$NestedClass\", classLoader)).isEqualTo(NestedClass.class);\r\n    assertThat(ClassUtils.forName(\"org.springframework.util.ClassUtilsTests.NestedClass\", classLoader)).isEqualTo(NestedClass.class);\r\n    // Precondition: package name must have length == 1.\r\n    assertThat(ClassHavingNestedClass.class.getPackageName().length()).isEqualTo(1);\r\n    assertThat(ClassUtils.forName(\"a.ClassHavingNestedClass$NestedClass\", classLoader)).isEqualTo(ClassHavingNestedClass.NestedClass.class);\r\n    assertThat(ClassUtils.forName(\"a.ClassHavingNestedClass.NestedClass\", classLoader)).isEqualTo(ClassHavingNestedClass.NestedClass.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#forNameWithPrimitiveClasses()",
    "entityType": "method",
    "code": "@Test\r\nvoid forNameWithPrimitiveClasses() throws ClassNotFoundException {\r\n    assertThat(ClassUtils.forName(\"boolean\", classLoader)).isEqualTo(boolean.class);\r\n    assertThat(ClassUtils.forName(\"byte\", classLoader)).isEqualTo(byte.class);\r\n    assertThat(ClassUtils.forName(\"char\", classLoader)).isEqualTo(char.class);\r\n    assertThat(ClassUtils.forName(\"short\", classLoader)).isEqualTo(short.class);\r\n    assertThat(ClassUtils.forName(\"int\", classLoader)).isEqualTo(int.class);\r\n    assertThat(ClassUtils.forName(\"long\", classLoader)).isEqualTo(long.class);\r\n    assertThat(ClassUtils.forName(\"float\", classLoader)).isEqualTo(float.class);\r\n    assertThat(ClassUtils.forName(\"double\", classLoader)).isEqualTo(double.class);\r\n    assertThat(ClassUtils.forName(\"void\", classLoader)).isEqualTo(void.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#forNameWithPrimitiveArrays()",
    "entityType": "method",
    "code": "@Test\r\nvoid forNameWithPrimitiveArrays() throws ClassNotFoundException {\r\n    assertThat(ClassUtils.forName(\"boolean[]\", classLoader)).isEqualTo(boolean[].class);\r\n    assertThat(ClassUtils.forName(\"byte[]\", classLoader)).isEqualTo(byte[].class);\r\n    assertThat(ClassUtils.forName(\"char[]\", classLoader)).isEqualTo(char[].class);\r\n    assertThat(ClassUtils.forName(\"short[]\", classLoader)).isEqualTo(short[].class);\r\n    assertThat(ClassUtils.forName(\"int[]\", classLoader)).isEqualTo(int[].class);\r\n    assertThat(ClassUtils.forName(\"long[]\", classLoader)).isEqualTo(long[].class);\r\n    assertThat(ClassUtils.forName(\"float[]\", classLoader)).isEqualTo(float[].class);\r\n    assertThat(ClassUtils.forName(\"double[]\", classLoader)).isEqualTo(double[].class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#forNameWithPrimitiveArraysInternalName()",
    "entityType": "method",
    "code": "@Test\r\nvoid forNameWithPrimitiveArraysInternalName() throws ClassNotFoundException {\r\n    assertThat(ClassUtils.forName(boolean[].class.getName(), classLoader)).isEqualTo(boolean[].class);\r\n    assertThat(ClassUtils.forName(byte[].class.getName(), classLoader)).isEqualTo(byte[].class);\r\n    assertThat(ClassUtils.forName(char[].class.getName(), classLoader)).isEqualTo(char[].class);\r\n    assertThat(ClassUtils.forName(short[].class.getName(), classLoader)).isEqualTo(short[].class);\r\n    assertThat(ClassUtils.forName(int[].class.getName(), classLoader)).isEqualTo(int[].class);\r\n    assertThat(ClassUtils.forName(long[].class.getName(), classLoader)).isEqualTo(long[].class);\r\n    assertThat(ClassUtils.forName(float[].class.getName(), classLoader)).isEqualTo(float[].class);\r\n    assertThat(ClassUtils.forName(double[].class.getName(), classLoader)).isEqualTo(double[].class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#isCacheSafe()",
    "entityType": "method",
    "code": "@Test\r\nvoid isCacheSafe() {\r\n    ClassLoader childLoader1 = new ClassLoader(classLoader) ;;\r\n    ClassLoader childLoader2 = new ClassLoader(classLoader) ;;\r\n    ClassLoader childLoader3 = new ClassLoader(classLoader) {\r\n\r\n        @Override\r\n        public Class<?> loadClass(String name) throws ClassNotFoundException {\r\n            return childLoader1.loadClass(name);\r\n        }\r\n    };\r\n    Class<?> composite = ClassUtils.createCompositeInterface(new Class<?>[] { Serializable.class, Externalizable.class }, childLoader1);\r\n    assertThat(ClassUtils.isCacheSafe(String.class, null)).isTrue();\r\n    assertThat(ClassUtils.isCacheSafe(String.class, classLoader)).isTrue();\r\n    assertThat(ClassUtils.isCacheSafe(String.class, childLoader1)).isTrue();\r\n    assertThat(ClassUtils.isCacheSafe(String.class, childLoader2)).isTrue();\r\n    assertThat(ClassUtils.isCacheSafe(String.class, childLoader3)).isTrue();\r\n    assertThat(ClassUtils.isCacheSafe(NestedClass.class, null)).isFalse();\r\n    assertThat(ClassUtils.isCacheSafe(NestedClass.class, classLoader)).isTrue();\r\n    assertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader1)).isTrue();\r\n    assertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader2)).isTrue();\r\n    assertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader3)).isTrue();\r\n    assertThat(ClassUtils.isCacheSafe(composite, null)).isFalse();\r\n    assertThat(ClassUtils.isCacheSafe(composite, classLoader)).isFalse();\r\n    assertThat(ClassUtils.isCacheSafe(composite, childLoader1)).isTrue();\r\n    assertThat(ClassUtils.isCacheSafe(composite, childLoader2)).isFalse();\r\n    assertThat(ClassUtils.isCacheSafe(composite, childLoader3)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#resolvePrimitiveClassName(String,Class<?>)",
    "entityType": "method",
    "code": "@ParameterizedTest(name = \"''{0}'' -> {1}\")\r\n@CsvSource(textBlock = \"\"\"\r\n    boolean, boolean\r\n    byte, byte\r\n    char, char\r\n    short, short\r\n    int, int\r\n    long, long\r\n    float, float\r\n    double, double\r\n    [Z, boolean[]\r\n    [B, byte[]\r\n    [C, char[]\r\n    [S, short[]\r\n    [I, int[]\r\n    [J, long[]\r\n    [F, float[]\r\n    [D, double[]\r\n    \"\"\")\r\nvoid resolvePrimitiveClassName(String input, Class<?> output) {\r\n    assertThat(ClassUtils.resolvePrimitiveClassName(input)).isEqualTo(output);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#getShortName()",
    "entityType": "method",
    "code": "@Test\r\nvoid getShortName() {\r\n    String className = ClassUtils.getShortName(getClass());\r\n    assertThat(className).as(\"Class name did not match\").isEqualTo(\"ClassUtilsTests\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#getShortNameForObjectArrayClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getShortNameForObjectArrayClass() {\r\n    String className = ClassUtils.getShortName(Object[].class);\r\n    assertThat(className).as(\"Class name did not match\").isEqualTo(\"Object[]\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#getShortNameForMultiDimensionalObjectArrayClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getShortNameForMultiDimensionalObjectArrayClass() {\r\n    String className = ClassUtils.getShortName(Object[][].class);\r\n    assertThat(className).as(\"Class name did not match\").isEqualTo(\"Object[][]\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#getShortNameForPrimitiveArrayClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getShortNameForPrimitiveArrayClass() {\r\n    String className = ClassUtils.getShortName(byte[].class);\r\n    assertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[]\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#getShortNameForMultiDimensionalPrimitiveArrayClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getShortNameForMultiDimensionalPrimitiveArrayClass() {\r\n    String className = ClassUtils.getShortName(byte[][][].class);\r\n    assertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[][][]\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#getShortNameForNestedClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getShortNameForNestedClass() {\r\n    String className = ClassUtils.getShortName(NestedClass.class);\r\n    assertThat(className).as(\"Class name did not match\").isEqualTo(\"ClassUtilsTests.NestedClass\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#getShortNameAsProperty()",
    "entityType": "method",
    "code": "@Test\r\nvoid getShortNameAsProperty() {\r\n    String shortName = ClassUtils.getShortNameAsProperty(this.getClass());\r\n    assertThat(shortName).as(\"Class name did not match\").isEqualTo(\"classUtilsTests\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#getClassFileName()",
    "entityType": "method",
    "code": "@Test\r\nvoid getClassFileName() {\r\n    assertThat(ClassUtils.getClassFileName(String.class)).isEqualTo(\"String.class\");\r\n    assertThat(ClassUtils.getClassFileName(getClass())).isEqualTo(\"ClassUtilsTests.class\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#getPackageName()",
    "entityType": "method",
    "code": "@Test\r\nvoid getPackageName() {\r\n    assertThat(ClassUtils.getPackageName(String.class)).isEqualTo(\"java.lang\");\r\n    assertThat(ClassUtils.getPackageName(getClass())).isEqualTo(getClass().getPackage().getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#getQualifiedName()",
    "entityType": "method",
    "code": "@Test\r\nvoid getQualifiedName() {\r\n    String className = ClassUtils.getQualifiedName(getClass());\r\n    assertThat(className).as(\"Class name did not match\").isEqualTo(\"org.springframework.util.ClassUtilsTests\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#getQualifiedNameForObjectArrayClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getQualifiedNameForObjectArrayClass() {\r\n    String className = ClassUtils.getQualifiedName(Object[].class);\r\n    assertThat(className).as(\"Class name did not match\").isEqualTo(\"java.lang.Object[]\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#getQualifiedNameForMultiDimensionalObjectArrayClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getQualifiedNameForMultiDimensionalObjectArrayClass() {\r\n    String className = ClassUtils.getQualifiedName(Object[][].class);\r\n    assertThat(className).as(\"Class name did not match\").isEqualTo(\"java.lang.Object[][]\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#getQualifiedNameForPrimitiveArrayClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getQualifiedNameForPrimitiveArrayClass() {\r\n    String className = ClassUtils.getQualifiedName(byte[].class);\r\n    assertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[]\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#getQualifiedNameForMultiDimensionalPrimitiveArrayClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getQualifiedNameForMultiDimensionalPrimitiveArrayClass() {\r\n    String className = ClassUtils.getQualifiedName(byte[][].class);\r\n    assertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[][]\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#hasMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasMethod() {\r\n    assertThat(ClassUtils.hasMethod(Collection.class, \"size\")).isTrue();\r\n    assertThat(ClassUtils.hasMethod(Collection.class, \"remove\", Object.class)).isTrue();\r\n    assertThat(ClassUtils.hasMethod(Collection.class, \"remove\")).isFalse();\r\n    assertThat(ClassUtils.hasMethod(Collection.class, \"someOtherMethod\")).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#getMethodIfAvailable()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMethodIfAvailable() {\r\n    Method method = ClassUtils.getMethodIfAvailable(Collection.class, \"size\");\r\n    assertThat(method).isNotNull();\r\n    assertThat(method.getName()).isEqualTo(\"size\");\r\n    method = ClassUtils.getMethodIfAvailable(Collection.class, \"remove\", Object.class);\r\n    assertThat(method).isNotNull();\r\n    assertThat(method.getName()).isEqualTo(\"remove\");\r\n    assertThat(ClassUtils.getMethodIfAvailable(Collection.class, \"remove\")).isNull();\r\n    assertThat(ClassUtils.getMethodIfAvailable(Collection.class, \"someOtherMethod\")).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#getMethodCountForName()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMethodCountForName() {\r\n    assertThat(ClassUtils.getMethodCountForName(OverloadedMethodsClass.class, \"print\")).as(\"Verifying number of overloaded 'print' methods for OverloadedMethodsClass.\").isEqualTo(2);\r\n    assertThat(ClassUtils.getMethodCountForName(SubOverloadedMethodsClass.class, \"print\")).as(\"Verifying number of overloaded 'print' methods for SubOverloadedMethodsClass.\").isEqualTo(4);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#countOverloadedMethods()",
    "entityType": "method",
    "code": "@Test\r\nvoid countOverloadedMethods() {\r\n    assertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"foobar\")).isFalse();\r\n    // no args\r\n    assertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"hashCode\")).isTrue();\r\n    // matches although it takes an arg\r\n    assertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"setAge\")).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#isAssignable()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAssignable() {\r\n    assertThat(ClassUtils.isAssignable(Object.class, Object.class)).isTrue();\r\n    assertThat(ClassUtils.isAssignable(String.class, String.class)).isTrue();\r\n    assertThat(ClassUtils.isAssignable(Object.class, String.class)).isTrue();\r\n    assertThat(ClassUtils.isAssignable(Object.class, Integer.class)).isTrue();\r\n    assertThat(ClassUtils.isAssignable(Number.class, Integer.class)).isTrue();\r\n    assertThat(ClassUtils.isAssignable(Number.class, int.class)).isTrue();\r\n    assertThat(ClassUtils.isAssignable(Integer.class, int.class)).isTrue();\r\n    assertThat(ClassUtils.isAssignable(int.class, Integer.class)).isTrue();\r\n    assertThat(ClassUtils.isAssignable(String.class, Object.class)).isFalse();\r\n    assertThat(ClassUtils.isAssignable(Integer.class, Number.class)).isFalse();\r\n    assertThat(ClassUtils.isAssignable(Integer.class, double.class)).isFalse();\r\n    assertThat(ClassUtils.isAssignable(double.class, Integer.class)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#classPackageAsResourcePath()",
    "entityType": "method",
    "code": "@Test\r\nvoid classPackageAsResourcePath() {\r\n    String result = ClassUtils.classPackageAsResourcePath(Proxy.class);\r\n    assertThat(result).isEqualTo(\"java/lang/reflect\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtilsTests#addResourcePathToPackagePath()",
    "entityType": "method",
    "code": "@Test\r\nvoid addResourcePathToPackagePath() {\r\n    String result = \"java/lang/reflect/xyzabc.xml\";\r\n    assertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"xyzabc.xml\")).isEqualTo(result);\r\n    assertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"/xyzabc.xml\")).isEqualTo(result);\r\n    assertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"a/b/c/d.xml\")).isEqualTo(\"java/lang/reflect/a/b/c/d.xml\");\r\n}",
    "comment": ""
  }
]