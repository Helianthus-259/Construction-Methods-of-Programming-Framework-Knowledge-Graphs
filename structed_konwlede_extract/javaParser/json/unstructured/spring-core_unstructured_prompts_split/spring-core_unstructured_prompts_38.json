[
  {
    "entityId": "org.springframework.cglib.proxy.CallbackHelper",
    "entityType": "class",
    "code": "private Map methodMap = new HashMap();\nprivate List callbacks = new ArrayList();\npublic CallbackHelper(Class superclass, Class[] interfaces) {\r\n    List methods = new ArrayList();\r\n    Enhancer.getMethods(superclass, interfaces, methods);\r\n    Map indexes = new HashMap();\r\n    for (int i = 0, size = methods.size(); i < size; i++) {\r\n        Method method = (Method) methods.get(i);\r\n        Object callback = getCallback(method);\r\n        if (callback == null) {\r\n            throw new IllegalStateException(\"getCallback cannot return null\");\r\n        }\r\n        boolean isCallback = callback instanceof Callback;\r\n        if (!(isCallback || (callback instanceof Class))) {\r\n            throw new IllegalStateException(\"getCallback must return a Callback or a Class\");\r\n        }\r\n        if (i > 0 && ((callbacks.get(i - 1) instanceof Callback) ^ isCallback)) {\r\n            throw new IllegalStateException(\"getCallback must return a Callback or a Class consistently for every Method\");\r\n        }\r\n        Integer index = (Integer) indexes.get(callback);\r\n        if (index == null) {\r\n            index = callbacks.size();\r\n            indexes.put(callback, index);\r\n        }\r\n        methodMap.put(method, index);\r\n        callbacks.add(callback);\r\n    }\r\n}\nabstract protected Object getCallback(Method method);\npublic Callback[] getCallbacks() {\r\n    if (callbacks.size() == 0) {\r\n        return new Callback[0];\r\n    }\r\n    if (callbacks.get(0) instanceof Callback) {\r\n        return (Callback[]) callbacks.toArray(new Callback[callbacks.size()]);\r\n    } else {\r\n        throw new IllegalStateException(\"getCallback returned classes, not callbacks; call getCallbackTypes instead\");\r\n    }\r\n}\npublic Class[] getCallbackTypes() {\r\n    if (callbacks.size() == 0) {\r\n        return new Class[0];\r\n    }\r\n    if (callbacks.get(0) instanceof Callback) {\r\n        return ReflectUtils.getClasses(getCallbacks());\r\n    } else {\r\n        return (Class[]) callbacks.toArray(new Class[callbacks.size()]);\r\n    }\r\n}\n@Override\r\npublic int accept(Method method) {\r\n    return ((Integer) methodMap.get(method)).intValue();\r\n}\n@Override\r\npublic int hashCode() {\r\n    return methodMap.hashCode();\r\n}\n@Override\r\npublic boolean equals(Object o) {\r\n    if (o == null) {\r\n        return false;\r\n    }\r\n    if (!(o instanceof CallbackHelper other)) {\r\n        return false;\r\n    }\r\n    return this.methodMap.equals(other.methodMap);\r\n}",
    "comment": "\n * @version $Id: CallbackHelper.java,v 1.2 2004/06/24 21:15:20 herbyderby Exp $\n "
  },
  {
    "entityId": "org.springframework.cglib.proxy.CallbackHelper#getCallback(Method)",
    "entityType": "method",
    "code": "abstract protected Object getCallback(Method method);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.CallbackHelper#getCallbacks()",
    "entityType": "method",
    "code": "public Callback[] getCallbacks() {\r\n    if (callbacks.size() == 0) {\r\n        return new Callback[0];\r\n    }\r\n    if (callbacks.get(0) instanceof Callback) {\r\n        return (Callback[]) callbacks.toArray(new Callback[callbacks.size()]);\r\n    } else {\r\n        throw new IllegalStateException(\"getCallback returned classes, not callbacks; call getCallbackTypes instead\");\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.CallbackHelper#getCallbackTypes()",
    "entityType": "method",
    "code": "public Class[] getCallbackTypes() {\r\n    if (callbacks.size() == 0) {\r\n        return new Class[0];\r\n    }\r\n    if (callbacks.get(0) instanceof Callback) {\r\n        return ReflectUtils.getClasses(getCallbacks());\r\n    } else {\r\n        return (Class[]) callbacks.toArray(new Class[callbacks.size()]);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.CallbackHelper#accept(Method)",
    "entityType": "method",
    "code": "@Override\r\npublic int accept(Method method) {\r\n    return ((Integer) methodMap.get(method)).intValue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.CallbackHelper#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return methodMap.hashCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.CallbackHelper#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(Object o) {\r\n    if (o == null) {\r\n        return false;\r\n    }\r\n    if (!(o instanceof CallbackHelper other)) {\r\n        return false;\r\n    }\r\n    return this.methodMap.equals(other.methodMap);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.CallbackInfo",
    "entityType": "class",
    "code": "public static Type[] determineTypes(Class[] callbackTypes) {\r\n    return determineTypes(callbackTypes, true);\r\n}\npublic static Type[] determineTypes(Class[] callbackTypes, boolean checkAll) {\r\n    Type[] types = new Type[callbackTypes.length];\r\n    for (int i = 0; i < types.length; i++) {\r\n        types[i] = determineType(callbackTypes[i], checkAll);\r\n    }\r\n    return types;\r\n}\npublic static Type[] determineTypes(Callback[] callbacks) {\r\n    return determineTypes(callbacks, true);\r\n}\npublic static Type[] determineTypes(Callback[] callbacks, boolean checkAll) {\r\n    Type[] types = new Type[callbacks.length];\r\n    for (int i = 0; i < types.length; i++) {\r\n        types[i] = determineType(callbacks[i], checkAll);\r\n    }\r\n    return types;\r\n}\npublic static CallbackGenerator[] getGenerators(Type[] callbackTypes) {\r\n    CallbackGenerator[] generators = new CallbackGenerator[callbackTypes.length];\r\n    for (int i = 0; i < generators.length; i++) {\r\n        generators[i] = getGenerator(callbackTypes[i]);\r\n    }\r\n    return generators;\r\n}\n//////////////////// PRIVATE ////////////////////\r\nprivate Class cls;\nprivate CallbackGenerator generator;\nprivate Type type;\nprivate static final CallbackInfo[] CALLBACKS = { new CallbackInfo(NoOp.class, NoOpGenerator.INSTANCE), new CallbackInfo(MethodInterceptor.class, MethodInterceptorGenerator.INSTANCE), new CallbackInfo(InvocationHandler.class, InvocationHandlerGenerator.INSTANCE), new CallbackInfo(LazyLoader.class, LazyLoaderGenerator.INSTANCE), new CallbackInfo(Dispatcher.class, DispatcherGenerator.INSTANCE), new CallbackInfo(FixedValue.class, FixedValueGenerator.INSTANCE), new CallbackInfo(ProxyRefDispatcher.class, DispatcherGenerator.PROXY_REF_INSTANCE) };\nprivate CallbackInfo(Class cls, CallbackGenerator generator) {\r\n    this.cls = cls;\r\n    this.generator = generator;\r\n    type = Type.getType(cls);\r\n}\nprivate static Type determineType(Callback callback, boolean checkAll) {\r\n    if (callback == null) {\r\n        throw new IllegalStateException(\"Callback is null\");\r\n    }\r\n    return determineType(callback.getClass(), checkAll);\r\n}\nprivate static Type determineType(Class callbackType, boolean checkAll) {\r\n    Class cur = null;\r\n    Type type = null;\r\n    for (CallbackInfo info : CALLBACKS) {\r\n        if (info.cls.isAssignableFrom(callbackType)) {\r\n            if (cur != null) {\r\n                throw new IllegalStateException(\"Callback implements both \" + cur + \" and \" + info.cls);\r\n            }\r\n            cur = info.cls;\r\n            type = info.type;\r\n            if (!checkAll) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (cur == null) {\r\n        throw new IllegalStateException(\"Unknown callback type \" + callbackType);\r\n    }\r\n    return type;\r\n}\nprivate static CallbackGenerator getGenerator(Type callbackType) {\r\n    for (CallbackInfo info : CALLBACKS) {\r\n        if (info.type.equals(callbackType)) {\r\n            return info.generator;\r\n        }\r\n    }\r\n    throw new IllegalStateException(\"Unknown callback type \" + callbackType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.CallbackInfo#determineTypes(Class[])",
    "entityType": "method",
    "code": "public static Type[] determineTypes(Class[] callbackTypes) {\r\n    return determineTypes(callbackTypes, true);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.CallbackInfo#determineTypes(Class[],boolean)",
    "entityType": "method",
    "code": "public static Type[] determineTypes(Class[] callbackTypes, boolean checkAll) {\r\n    Type[] types = new Type[callbackTypes.length];\r\n    for (int i = 0; i < types.length; i++) {\r\n        types[i] = determineType(callbackTypes[i], checkAll);\r\n    }\r\n    return types;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.CallbackInfo#determineTypes(Callback[])",
    "entityType": "method",
    "code": "public static Type[] determineTypes(Callback[] callbacks) {\r\n    return determineTypes(callbacks, true);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.CallbackInfo#determineTypes(Callback[],boolean)",
    "entityType": "method",
    "code": "public static Type[] determineTypes(Callback[] callbacks, boolean checkAll) {\r\n    Type[] types = new Type[callbacks.length];\r\n    for (int i = 0; i < types.length; i++) {\r\n        types[i] = determineType(callbacks[i], checkAll);\r\n    }\r\n    return types;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.CallbackInfo#getGenerators(Type[])",
    "entityType": "method",
    "code": "public static CallbackGenerator[] getGenerators(Type[] callbackTypes) {\r\n    CallbackGenerator[] generators = new CallbackGenerator[callbackTypes.length];\r\n    for (int i = 0; i < generators.length; i++) {\r\n        generators[i] = getGenerator(callbackTypes[i]);\r\n    }\r\n    return generators;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.CallbackInfo#determineType(Callback,boolean)",
    "entityType": "method",
    "code": "private static Type determineType(Callback callback, boolean checkAll) {\r\n    if (callback == null) {\r\n        throw new IllegalStateException(\"Callback is null\");\r\n    }\r\n    return determineType(callback.getClass(), checkAll);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.CallbackInfo#determineType(Class,boolean)",
    "entityType": "method",
    "code": "private static Type determineType(Class callbackType, boolean checkAll) {\r\n    Class cur = null;\r\n    Type type = null;\r\n    for (CallbackInfo info : CALLBACKS) {\r\n        if (info.cls.isAssignableFrom(callbackType)) {\r\n            if (cur != null) {\r\n                throw new IllegalStateException(\"Callback implements both \" + cur + \" and \" + info.cls);\r\n            }\r\n            cur = info.cls;\r\n            type = info.type;\r\n            if (!checkAll) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (cur == null) {\r\n        throw new IllegalStateException(\"Unknown callback type \" + callbackType);\r\n    }\r\n    return type;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.CallbackInfo#getGenerator(Type)",
    "entityType": "method",
    "code": "private static CallbackGenerator getGenerator(Type callbackType) {\r\n    for (CallbackInfo info : CALLBACKS) {\r\n        if (info.type.equals(callbackType)) {\r\n            return info.generator;\r\n        }\r\n    }\r\n    throw new IllegalStateException(\"Unknown callback type \" + callbackType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Dispatcher",
    "entityType": "class",
    "code": "/**\r\n * Return the object which the original method invocation should\r\n * be dispatched. This method is called for <b>every</b> method invocation.\r\n * @return an object that can invoke the method\r\n */\r\nObject loadObject() throws Exception;",
    "comment": "\n * Dispatching {@link Enhancer} callback. This is identical to the\n * {@link LazyLoader} interface but needs to be separate so that <code>Enhancer</code>\n * knows which type of code to generate.\n "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Dispatcher#loadObject()",
    "entityType": "method",
    "code": "/**\r\n * Return the object which the original method invocation should\r\n * be dispatched. This method is called for <b>every</b> method invocation.\r\n * @return an object that can invoke the method\r\n */\r\nObject loadObject() throws Exception;",
    "comment": "\n     * Return the object which the original method invocation should\n     * be dispatched. This method is called for <b>every</b> method invocation.\n     * @return an object that can invoke the method\n     "
  },
  {
    "entityId": "org.springframework.cglib.proxy.DispatcherGenerator",
    "entityType": "class",
    "code": "public static final DispatcherGenerator INSTANCE = new DispatcherGenerator(false);\npublic static final DispatcherGenerator PROXY_REF_INSTANCE = new DispatcherGenerator(true);\nprivate static final Type DISPATCHER = TypeUtils.parseType(\"org.springframework.cglib.proxy.Dispatcher\");\nprivate static final Type PROXY_REF_DISPATCHER = TypeUtils.parseType(\"org.springframework.cglib.proxy.ProxyRefDispatcher\");\nprivate static final Signature LOAD_OBJECT = TypeUtils.parseSignature(\"Object loadObject()\");\nprivate static final Signature PROXY_REF_LOAD_OBJECT = TypeUtils.parseSignature(\"Object loadObject(Object)\");\nprivate boolean proxyRef;\nprivate DispatcherGenerator(boolean proxyRef) {\r\n    this.proxyRef = proxyRef;\r\n}\n@Override\r\npublic void generate(ClassEmitter ce, Context context, List methods) {\r\n    for (Iterator it = methods.iterator(); it.hasNext(); ) {\r\n        MethodInfo method = (MethodInfo) it.next();\r\n        if (!TypeUtils.isProtected(method.getModifiers())) {\r\n            CodeEmitter e = context.beginMethod(ce, method);\r\n            context.emitCallback(e, context.getIndex(method));\r\n            if (proxyRef) {\r\n                e.load_this();\r\n                e.invoke_interface(PROXY_REF_DISPATCHER, PROXY_REF_LOAD_OBJECT);\r\n            } else {\r\n                e.invoke_interface(DISPATCHER, LOAD_OBJECT);\r\n            }\r\n            e.checkcast(method.getClassInfo().getType());\r\n            e.load_args();\r\n            e.invoke(method);\r\n            e.return_value();\r\n            e.end_method();\r\n        }\r\n    }\r\n}\n@Override\r\npublic void generateStatic(CodeEmitter e, Context context, List methods) ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.DispatcherGenerator#generate(ClassEmitter,Context,List)",
    "entityType": "method",
    "code": "@Override\r\npublic void generate(ClassEmitter ce, Context context, List methods) {\r\n    for (Iterator it = methods.iterator(); it.hasNext(); ) {\r\n        MethodInfo method = (MethodInfo) it.next();\r\n        if (!TypeUtils.isProtected(method.getModifiers())) {\r\n            CodeEmitter e = context.beginMethod(ce, method);\r\n            context.emitCallback(e, context.getIndex(method));\r\n            if (proxyRef) {\r\n                e.load_this();\r\n                e.invoke_interface(PROXY_REF_DISPATCHER, PROXY_REF_LOAD_OBJECT);\r\n            } else {\r\n                e.invoke_interface(DISPATCHER, LOAD_OBJECT);\r\n            }\r\n            e.checkcast(method.getClassInfo().getType());\r\n            e.load_args();\r\n            e.invoke(method);\r\n            e.return_value();\r\n            e.end_method();\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.DispatcherGenerator#generateStatic(CodeEmitter,Context,List)",
    "entityType": "method",
    "code": "@Override\r\npublic void generateStatic(CodeEmitter e, Context context, List methods) ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer",
    "entityType": "class",
    "code": "private static final CallbackFilter ALL_ZERO = method -> 0;\nprivate static final Source SOURCE = new Source(Enhancer.class.getName());\nprivate static final String BOUND_FIELD = \"CGLIB$BOUND\";\nprivate static final String FACTORY_DATA_FIELD = \"CGLIB$FACTORY_DATA\";\nprivate static final String THREAD_CALLBACKS_FIELD = \"CGLIB$THREAD_CALLBACKS\";\nprivate static final String STATIC_CALLBACKS_FIELD = \"CGLIB$STATIC_CALLBACKS\";\nprivate static final String SET_THREAD_CALLBACKS_NAME = \"CGLIB$SET_THREAD_CALLBACKS\";\nprivate static final String SET_STATIC_CALLBACKS_NAME = \"CGLIB$SET_STATIC_CALLBACKS\";\nprivate static final String CONSTRUCTED_FIELD = \"CGLIB$CONSTRUCTED\";\n/**\r\n * {@link org.springframework.cglib.core.AbstractClassGenerator.ClassLoaderData#generatedClasses} requires to keep cache key\r\n * in a good shape (the keys should be up and running if the proxy class is alive), and one of the cache keys is\r\n * {@link CallbackFilter}. That is why the generated class contains static field that keeps strong reference to\r\n * the {@link #filter}.\r\n * <p>This dance achieves two goals: ensures generated class is reusable and available through generatedClasses\r\n * cache, and it enables to unload classloader and the related {@link CallbackFilter} in case user does not need\r\n * that</p>\r\n */\r\nprivate static final String CALLBACK_FILTER_FIELD = \"CGLIB$CALLBACK_FILTER\";\nprivate static final Type OBJECT_TYPE = TypeUtils.parseType(\"Object\");\nprivate static final Type FACTORY = TypeUtils.parseType(\"org.springframework.cglib.proxy.Factory\");\nprivate static final Type ILLEGAL_STATE_EXCEPTION = TypeUtils.parseType(\"IllegalStateException\");\nprivate static final Type ILLEGAL_ARGUMENT_EXCEPTION = TypeUtils.parseType(\"IllegalArgumentException\");\nprivate static final Type THREAD_LOCAL = TypeUtils.parseType(\"ThreadLocal\");\nprivate static final Type CALLBACK = TypeUtils.parseType(\"org.springframework.cglib.proxy.Callback\");\nprivate static final Type CALLBACK_ARRAY = Type.getType(Callback[].class);\nprivate static final Signature CSTRUCT_NULL = TypeUtils.parseConstructor(\"\");\nprivate static final Signature SET_THREAD_CALLBACKS = new Signature(SET_THREAD_CALLBACKS_NAME, Type.VOID_TYPE, new Type[] { CALLBACK_ARRAY });\nprivate static final Signature SET_STATIC_CALLBACKS = new Signature(SET_STATIC_CALLBACKS_NAME, Type.VOID_TYPE, new Type[] { CALLBACK_ARRAY });\nprivate static final Signature NEW_INSTANCE = new Signature(\"newInstance\", Constants.TYPE_OBJECT, new Type[] { CALLBACK_ARRAY });\nprivate static final Signature MULTIARG_NEW_INSTANCE = new Signature(\"newInstance\", Constants.TYPE_OBJECT, new Type[] { Constants.TYPE_CLASS_ARRAY, Constants.TYPE_OBJECT_ARRAY, CALLBACK_ARRAY });\nprivate static final Signature SINGLE_NEW_INSTANCE = new Signature(\"newInstance\", Constants.TYPE_OBJECT, new Type[] { CALLBACK });\nprivate static final Signature SET_CALLBACK = new Signature(\"setCallback\", Type.VOID_TYPE, new Type[] { Type.INT_TYPE, CALLBACK });\nprivate static final Signature GET_CALLBACK = new Signature(\"getCallback\", CALLBACK, new Type[] { Type.INT_TYPE });\nprivate static final Signature SET_CALLBACKS = new Signature(\"setCallbacks\", Type.VOID_TYPE, new Type[] { CALLBACK_ARRAY });\nprivate static final Signature GET_CALLBACKS = new Signature(\"getCallbacks\", CALLBACK_ARRAY, new Type[0]);\nprivate static final Signature THREAD_LOCAL_GET = TypeUtils.parseSignature(\"Object get()\");\nprivate static final Signature THREAD_LOCAL_SET = TypeUtils.parseSignature(\"void set(Object)\");\nprivate static final Signature BIND_CALLBACKS = TypeUtils.parseSignature(\"void CGLIB$BIND_CALLBACKS(Object)\");\nprivate EnhancerFactoryData currentData;\nprivate Object currentKey;\n// SPRING PATCH BEGIN\r\nprivate record EnhancerKey(String type, List<String> interfaces, WeakCacheKey<CallbackFilter> filter, List<Type> callbackTypes, boolean useFactory, boolean interceptDuringConstruction, Long serialVersionUID) {\r\n}\n// SPRING PATCH END\r\nprivate Class[] interfaces;\nprivate CallbackFilter filter;\nprivate Callback[] callbacks;\nprivate Type[] callbackTypes;\nprivate boolean validateCallbackTypes;\nprivate boolean classOnly;\nprivate Class superclass;\nprivate Class[] argumentTypes;\nprivate Object[] arguments;\nprivate boolean useFactory = true;\nprivate Long serialVersionUID;\nprivate boolean interceptDuringConstruction = true;\n/**\r\n * Create a new <code>Enhancer</code>. A new <code>Enhancer</code>\r\n * object should be used for each generated object, and should not\r\n * be shared across threads. To create additional instances of a\r\n * generated class, use the <code>Factory</code> interface.\r\n * @see Factory\r\n */\r\npublic Enhancer() {\r\n    super(SOURCE);\r\n}\n/**\r\n * Set the class which the generated class will extend. As a convenience,\r\n * if the supplied superclass is actually an interface, <code>setInterfaces</code>\r\n * will be called with the appropriate argument instead.\r\n * A non-interface argument must not be declared as final, and must have an\r\n * accessible constructor.\r\n * @param superclass class to extend or interface to implement\r\n * @see #setInterfaces(Class[])\r\n */\r\npublic void setSuperclass(Class superclass) {\r\n    if (superclass != null && superclass.isInterface()) {\r\n        setInterfaces(new Class[] { superclass });\r\n        // SPRING PATCH BEGIN\r\n        setContextClass(superclass);\r\n        // SPRING PATCH END\r\n    } else if (superclass != null && superclass.equals(Object.class)) {\r\n        // affects choice of ClassLoader\r\n        this.superclass = null;\r\n    } else {\r\n        this.superclass = superclass;\r\n        // SPRING PATCH BEGIN\r\n        setContextClass(superclass);\r\n        // SPRING PATCH END\r\n    }\r\n}\n/**\r\n * Set the interfaces to implement. The <code>Factory</code> interface will\r\n * always be implemented regardless of what is specified here.\r\n * @param interfaces array of interfaces to implement, or null\r\n * @see Factory\r\n */\r\npublic void setInterfaces(Class[] interfaces) {\r\n    this.interfaces = interfaces;\r\n}\n/**\r\n * Set the {@link CallbackFilter} used to map the generated class' methods\r\n * to a particular callback index.\r\n * New object instances will always use the same mapping, but may use different\r\n * actual callback objects.\r\n * @param filter the callback filter to use when generating a new class\r\n * @see #setCallbacks\r\n */\r\npublic void setCallbackFilter(CallbackFilter filter) {\r\n    this.filter = filter;\r\n}\n/**\r\n * Set the single {@link Callback} to use.\r\n * Ignored if you use {@link #createClass}.\r\n * @param callback the callback to use for all methods\r\n * @see #setCallbacks\r\n */\r\npublic void setCallback(final Callback callback) {\r\n    setCallbacks(new Callback[] { callback });\r\n}\n/**\r\n * Set the array of callbacks to use.\r\n * Ignored if you use {@link #createClass}.\r\n * You must use a {@link CallbackFilter} to specify the index into this\r\n * array for each method in the proxied class.\r\n * @param callbacks the callback array\r\n * @see #setCallbackFilter\r\n * @see #setCallback\r\n */\r\npublic void setCallbacks(Callback[] callbacks) {\r\n    if (callbacks != null && callbacks.length == 0) {\r\n        throw new IllegalArgumentException(\"Array cannot be empty\");\r\n    }\r\n    this.callbacks = callbacks;\r\n}\n/**\r\n * Set whether the enhanced object instances should implement\r\n * the {@link Factory} interface.\r\n * This was added for tools that need for proxies to be more\r\n * indistinguishable from their targets. Also, in some cases it may\r\n * be necessary to disable the <code>Factory</code> interface to\r\n * prevent code from changing the underlying callbacks.\r\n * @param useFactory whether to implement <code>Factory</code>; default is <code>true</code>\r\n */\r\npublic void setUseFactory(boolean useFactory) {\r\n    this.useFactory = useFactory;\r\n}\n/**\r\n * Set whether methods called from within the proxy's constructer\r\n * will be intercepted. The default value is true. Unintercepted methods\r\n * will call the method of the proxy's base class, if it exists.\r\n * @param interceptDuringConstruction whether to intercept methods called from the constructor\r\n */\r\npublic void setInterceptDuringConstruction(boolean interceptDuringConstruction) {\r\n    this.interceptDuringConstruction = interceptDuringConstruction;\r\n}\n/**\r\n * Set the single type of {@link Callback} to use.\r\n * This may be used instead of {@link #setCallback} when calling\r\n * {@link #createClass}, since it may not be possible to have\r\n * an array of actual callback instances.\r\n * @param callbackType the type of callback to use for all methods\r\n * @see #setCallbackTypes\r\n */\r\npublic void setCallbackType(Class callbackType) {\r\n    setCallbackTypes(new Class[] { callbackType });\r\n}\n/**\r\n * Set the array of callback types to use.\r\n * This may be used instead of {@link #setCallbacks} when calling\r\n * {@link #createClass}, since it may not be possible to have\r\n * an array of actual callback instances.\r\n * You must use a {@link CallbackFilter} to specify the index into this\r\n * array for each method in the proxied class.\r\n * @param callbackTypes the array of callback types\r\n */\r\npublic void setCallbackTypes(Class[] callbackTypes) {\r\n    if (callbackTypes != null && callbackTypes.length == 0) {\r\n        throw new IllegalArgumentException(\"Array cannot be empty\");\r\n    }\r\n    this.callbackTypes = CallbackInfo.determineTypes(callbackTypes);\r\n}\n/**\r\n * Generate a new class if necessary and uses the specified\r\n * callbacks (if any) to create a new object instance.\r\n * Uses the no-arg constructor of the superclass.\r\n * @return a new instance\r\n */\r\npublic Object create() {\r\n    classOnly = false;\r\n    argumentTypes = null;\r\n    return createHelper();\r\n}\n/**\r\n * Generate a new class if necessary and uses the specified\r\n * callbacks (if any) to create a new object instance.\r\n * Uses the constructor of the superclass matching the <code>argumentTypes</code>\r\n * parameter, with the given arguments.\r\n * @param argumentTypes constructor signature\r\n * @param arguments compatible wrapped arguments to pass to constructor\r\n * @return a new instance\r\n */\r\npublic Object create(Class[] argumentTypes, Object[] arguments) {\r\n    classOnly = false;\r\n    if (argumentTypes == null || arguments == null || argumentTypes.length != arguments.length) {\r\n        throw new IllegalArgumentException(\"Arguments must be non-null and of equal length\");\r\n    }\r\n    this.argumentTypes = argumentTypes;\r\n    this.arguments = arguments;\r\n    return createHelper();\r\n}\n/**\r\n * Generate a new class if necessary and return it without creating a new instance.\r\n * This ignores any callbacks that have been set.\r\n * To create a new instance you will have to use reflection, and methods\r\n * called during the constructor will not be intercepted. To avoid this problem,\r\n * use the multi-arg <code>create</code> method.\r\n * @see #create(Class[], Object[])\r\n */\r\npublic Class createClass() {\r\n    classOnly = true;\r\n    return (Class) createHelper();\r\n}\n/**\r\n * Insert a static serialVersionUID field into the generated class.\r\n * @param sUID the field value, or null to avoid generating field.\r\n */\r\npublic void setSerialVersionUID(Long sUID) {\r\n    serialVersionUID = sUID;\r\n}\nprivate void preValidate() {\r\n    if (callbackTypes == null) {\r\n        callbackTypes = CallbackInfo.determineTypes(callbacks, false);\r\n        validateCallbackTypes = true;\r\n    }\r\n    if (filter == null) {\r\n        if (callbackTypes.length > 1) {\r\n            throw new IllegalStateException(\"Multiple callback types possible but no filter specified\");\r\n        }\r\n        filter = ALL_ZERO;\r\n    }\r\n}\nprivate void validate() {\r\n    if (classOnly ^ (callbacks == null)) {\r\n        if (classOnly) {\r\n            throw new IllegalStateException(\"createClass does not accept callbacks\");\r\n        } else {\r\n            throw new IllegalStateException(\"Callbacks are required\");\r\n        }\r\n    }\r\n    if (classOnly && (callbackTypes == null)) {\r\n        throw new IllegalStateException(\"Callback types are required\");\r\n    }\r\n    if (validateCallbackTypes) {\r\n        callbackTypes = null;\r\n    }\r\n    if (callbacks != null && callbackTypes != null) {\r\n        if (callbacks.length != callbackTypes.length) {\r\n            throw new IllegalStateException(\"Lengths of callback and callback types array must be the same\");\r\n        }\r\n        Type[] check = CallbackInfo.determineTypes(callbacks);\r\n        for (int i = 0; i < check.length; i++) {\r\n            if (!check[i].equals(callbackTypes[i])) {\r\n                throw new IllegalStateException(\"Callback \" + check[i] + \" is not assignable to \" + callbackTypes[i]);\r\n            }\r\n        }\r\n    } else if (callbacks != null) {\r\n        callbackTypes = CallbackInfo.determineTypes(callbacks);\r\n    }\r\n    if (interfaces != null) {\r\n        for (Class element : interfaces) {\r\n            if (element == null) {\r\n                throw new IllegalStateException(\"Interfaces cannot be null\");\r\n            }\r\n            if (!element.isInterface()) {\r\n                throw new IllegalStateException(element + \" is not an interface\");\r\n            }\r\n        }\r\n    }\r\n}\n/**\r\n * The idea of the class is to cache relevant java.lang.reflect instances so\r\n * proxy-class can be instantiated faster that when using {@link ReflectUtils#newInstance(Class, Class[], Object[])}\r\n * and {@link Enhancer#setThreadCallbacks(Class, Callback[])}\r\n */\r\nstatic class EnhancerFactoryData {\r\n\r\n    public final Class generatedClass;\r\n\r\n    private final Method setThreadCallbacks;\r\n\r\n    private final Class[] primaryConstructorArgTypes;\r\n\r\n    private final Constructor primaryConstructor;\r\n\r\n    public EnhancerFactoryData(Class generatedClass, Class[] primaryConstructorArgTypes, boolean classOnly) {\r\n        this.generatedClass = generatedClass;\r\n        try {\r\n            setThreadCallbacks = getCallbacksSetter(generatedClass, SET_THREAD_CALLBACKS_NAME);\r\n            if (classOnly) {\r\n                this.primaryConstructorArgTypes = null;\r\n                this.primaryConstructor = null;\r\n            } else {\r\n                this.primaryConstructorArgTypes = primaryConstructorArgTypes;\r\n                this.primaryConstructor = ReflectUtils.getConstructor(generatedClass, primaryConstructorArgTypes);\r\n            }\r\n        } catch (NoSuchMethodException e) {\r\n            throw new CodeGenerationException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates proxy instance for given argument types, and assigns the callbacks.\r\n     * Ideally, for each proxy class, just one set of argument types should be used,\r\n     * otherwise it would have to spend time on constructor lookup.\r\n     * Technically, it is a re-implementation of {@link Enhancer#createUsingReflection(Class)},\r\n     * with \"cache {@link #setThreadCallbacks} and {@link #primaryConstructor}\"\r\n     * @param argumentTypes constructor argument types\r\n     * @param arguments constructor arguments\r\n     * @param callbacks callbacks to set for the new instance\r\n     * @return newly created proxy\r\n     * @see #createUsingReflection(Class)\r\n     */\r\n    public Object newInstance(Class[] argumentTypes, Object[] arguments, Callback[] callbacks) {\r\n        setThreadCallbacks(callbacks);\r\n        try {\r\n            // Explicit reference equality is added here just in case Arrays.equals does not have one\r\n            if (primaryConstructorArgTypes == argumentTypes || Arrays.equals(primaryConstructorArgTypes, argumentTypes)) {\r\n                // If we have relevant Constructor instance at hand, just call it\r\n                // This skips \"get constructors\" machinery\r\n                return ReflectUtils.newInstance(primaryConstructor, arguments);\r\n            }\r\n            // Take a slow path if observing unexpected argument types\r\n            return ReflectUtils.newInstance(generatedClass, argumentTypes, arguments);\r\n        } finally {\r\n            // clear thread callbacks to allow them to be gc'd\r\n            setThreadCallbacks(null);\r\n        }\r\n    }\r\n\r\n    private void setThreadCallbacks(Callback[] callbacks) {\r\n        try {\r\n            setThreadCallbacks.invoke(generatedClass, (Object) callbacks);\r\n        } catch (IllegalAccessException e) {\r\n            throw new CodeGenerationException(e);\r\n        } catch (InvocationTargetException e) {\r\n            throw new CodeGenerationException(e.getTargetException());\r\n        }\r\n    }\r\n}\nprivate Object createHelper() {\r\n    preValidate();\r\n    // SPRING PATCH BEGIN\r\n    Object key = new EnhancerKey((superclass != null ? superclass.getName() : null), (interfaces != null ? Arrays.asList(ReflectUtils.getNames(interfaces)) : null), (filter == ALL_ZERO ? null : new WeakCacheKey<>(filter)), Arrays.asList(callbackTypes), useFactory, interceptDuringConstruction, serialVersionUID);\r\n    // SPRING PATCH END\r\n    this.currentKey = key;\r\n    Object result = super.create(key);\r\n    return result;\r\n}\n@Override\r\nprotected Class generate(ClassLoaderData data) {\r\n    validate();\r\n    if (superclass != null) {\r\n        setNamePrefix(superclass.getName());\r\n    } else if (interfaces != null) {\r\n        setNamePrefix(interfaces[ReflectUtils.findPackageProtected(interfaces)].getName());\r\n    }\r\n    return super.generate(data);\r\n}\n@Override\r\nprotected ClassLoader getDefaultClassLoader() {\r\n    if (superclass != null) {\r\n        return superclass.getClassLoader();\r\n    } else if (interfaces != null) {\r\n        return interfaces[0].getClassLoader();\r\n    } else {\r\n        return null;\r\n    }\r\n}\n@Override\r\nprotected ProtectionDomain getProtectionDomain() {\r\n    if (superclass != null) {\r\n        return ReflectUtils.getProtectionDomain(superclass);\r\n    } else if (interfaces != null) {\r\n        return ReflectUtils.getProtectionDomain(interfaces[0]);\r\n    } else {\r\n        return null;\r\n    }\r\n}\nprivate Signature rename(Signature sig, int index) {\r\n    return new Signature(\"CGLIB$\" + sig.getName() + \"$\" + index, sig.getDescriptor());\r\n}\n/**\r\n * Finds all of the methods that will be extended by an\r\n * Enhancer-generated class using the specified superclass and\r\n * interfaces. This can be useful in building a list of Callback\r\n * objects. The methods are added to the end of the given list.  Due\r\n * to the subclassing nature of the classes generated by Enhancer,\r\n * the methods are guaranteed to be non-static, non-final, and\r\n * non-private. Each method signature will only occur once, even if\r\n * it occurs in multiple classes.\r\n * @param superclass the class that will be extended, or null\r\n * @param interfaces the list of interfaces that will be implemented, or null\r\n * @param methods the list into which to copy the applicable methods\r\n */\r\npublic static void getMethods(Class superclass, Class[] interfaces, List methods) {\r\n    getMethods(superclass, interfaces, methods, null, null);\r\n}\nprivate static void getMethods(Class superclass, Class[] interfaces, List methods, List interfaceMethods, Set forcePublic) {\r\n    ReflectUtils.addAllMethods(superclass, methods);\r\n    List target = (interfaceMethods != null) ? interfaceMethods : methods;\r\n    if (interfaces != null) {\r\n        for (Class element : interfaces) {\r\n            if (element != Factory.class) {\r\n                ReflectUtils.addAllMethods(element, target);\r\n            }\r\n        }\r\n    }\r\n    if (interfaceMethods != null) {\r\n        if (forcePublic != null) {\r\n            forcePublic.addAll(MethodWrapper.createSet(interfaceMethods));\r\n        }\r\n        methods.addAll(interfaceMethods);\r\n    }\r\n    CollectionUtils.filter(methods, new RejectModifierPredicate(Constants.ACC_STATIC));\r\n    CollectionUtils.filter(methods, new VisibilityPredicate(superclass, true));\r\n    CollectionUtils.filter(methods, new DuplicatesPredicate());\r\n    CollectionUtils.filter(methods, new RejectModifierPredicate(Constants.ACC_FINAL));\r\n}\n@Override\r\npublic void generateClass(ClassVisitor v) throws Exception {\r\n    Class sc = (superclass == null) ? Object.class : superclass;\r\n    if (TypeUtils.isFinal(sc.getModifiers())) {\r\n        throw new IllegalArgumentException(\"Cannot subclass final class \" + sc.getName());\r\n    }\r\n    List constructors = new ArrayList(Arrays.asList(sc.getDeclaredConstructors()));\r\n    filterConstructors(sc, constructors);\r\n    // Order is very important: must add superclass, then\r\n    // its superclass chain, then each interface and\r\n    // its superinterfaces.\r\n    List actualMethods = new ArrayList();\r\n    List interfaceMethods = new ArrayList();\r\n    final Set forcePublic = new HashSet();\r\n    getMethods(sc, interfaces, actualMethods, interfaceMethods, forcePublic);\r\n    List methods = CollectionUtils.transform(actualMethods, value -> {\r\n        Method method = (Method) value;\r\n        int modifiers = Constants.ACC_FINAL | (method.getModifiers() & ~Constants.ACC_ABSTRACT & ~Constants.ACC_NATIVE & ~Constants.ACC_SYNCHRONIZED);\r\n        if (forcePublic.contains(MethodWrapper.create(method))) {\r\n            modifiers = (modifiers & ~Constants.ACC_PROTECTED) | Constants.ACC_PUBLIC;\r\n        }\r\n        return ReflectUtils.getMethodInfo(method, modifiers);\r\n    });\r\n    ClassEmitter e = new ClassEmitter(v);\r\n    if (currentData == null) {\r\n        e.begin_class(Constants.V1_8, Constants.ACC_PUBLIC, getClassName(), Type.getType(sc), (useFactory ? TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) : TypeUtils.getTypes(interfaces)), Constants.SOURCE_FILE);\r\n    } else {\r\n        e.begin_class(Constants.V1_8, Constants.ACC_PUBLIC, getClassName(), null, new Type[] { FACTORY }, Constants.SOURCE_FILE);\r\n    }\r\n    List constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());\r\n    e.declare_field(Constants.ACC_PRIVATE, BOUND_FIELD, Type.BOOLEAN_TYPE, null);\r\n    e.declare_field(Constants.ACC_PUBLIC | Constants.ACC_STATIC, FACTORY_DATA_FIELD, OBJECT_TYPE, null);\r\n    if (!interceptDuringConstruction) {\r\n        e.declare_field(Constants.ACC_PRIVATE, CONSTRUCTED_FIELD, Type.BOOLEAN_TYPE, null);\r\n    }\r\n    e.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, null);\r\n    e.declare_field(Constants.PRIVATE_FINAL_STATIC, STATIC_CALLBACKS_FIELD, CALLBACK_ARRAY, null);\r\n    if (serialVersionUID != null) {\r\n        e.declare_field(Constants.PRIVATE_FINAL_STATIC, Constants.SUID_FIELD_NAME, Type.LONG_TYPE, serialVersionUID);\r\n    }\r\n    for (int i = 0; i < callbackTypes.length; i++) {\r\n        e.declare_field(Constants.ACC_PRIVATE, getCallbackField(i), callbackTypes[i], null);\r\n    }\r\n    // This is declared private to avoid \"public field\" pollution\r\n    e.declare_field(Constants.ACC_PRIVATE | Constants.ACC_STATIC, CALLBACK_FILTER_FIELD, OBJECT_TYPE, null);\r\n    if (currentData == null) {\r\n        emitMethods(e, methods, actualMethods);\r\n        emitConstructors(e, constructorInfo);\r\n    } else {\r\n        emitDefaultConstructor(e);\r\n    }\r\n    emitSetThreadCallbacks(e);\r\n    emitSetStaticCallbacks(e);\r\n    emitBindCallbacks(e);\r\n    if (useFactory || currentData != null) {\r\n        int[] keys = getCallbackKeys();\r\n        emitNewInstanceCallbacks(e);\r\n        emitNewInstanceCallback(e);\r\n        emitNewInstanceMultiarg(e, constructorInfo);\r\n        emitGetCallback(e, keys);\r\n        emitSetCallback(e, keys);\r\n        emitGetCallbacks(e);\r\n        emitSetCallbacks(e);\r\n    }\r\n    e.end_class();\r\n}\n/**\r\n * Filter the list of constructors from the superclass. The\r\n * constructors which remain will be included in the generated\r\n * class. The default implementation is to filter out all private\r\n * constructors, but subclasses may extend Enhancer to override this\r\n * behavior.\r\n * @param sc the superclass\r\n * @param constructors the list of all declared constructors from the superclass\r\n * @throws IllegalArgumentException if there are no non-private constructors\r\n */\r\nprotected void filterConstructors(Class sc, List constructors) {\r\n    CollectionUtils.filter(constructors, new VisibilityPredicate(sc, true));\r\n    if (constructors.size() == 0) {\r\n        throw new IllegalArgumentException(\"No visible constructors in \" + sc);\r\n    }\r\n}\n/**\r\n * This method should not be called in regular flow.\r\n * Technically speaking {@link #wrapCachedClass(Class)} uses {@link Enhancer.EnhancerFactoryData} as a cache value,\r\n * and the latter enables faster instantiation than plain old reflection lookup and invoke.\r\n * This method is left intact for backward compatibility reasons: just in case it was ever used.\r\n * @param type class to instantiate\r\n * @return newly created proxy instance\r\n * @throws Exception if something goes wrong\r\n */\r\n@Override\r\nprotected Object firstInstance(Class type) throws Exception {\r\n    if (classOnly) {\r\n        return type;\r\n    } else {\r\n        return createUsingReflection(type);\r\n    }\r\n}\n@Override\r\nprotected Object nextInstance(Object instance) {\r\n    EnhancerFactoryData data = (EnhancerFactoryData) instance;\r\n    if (classOnly) {\r\n        return data.generatedClass;\r\n    }\r\n    Class[] argumentTypes = this.argumentTypes;\r\n    Object[] arguments = this.arguments;\r\n    if (argumentTypes == null) {\r\n        argumentTypes = Constants.EMPTY_CLASS_ARRAY;\r\n        arguments = null;\r\n    }\r\n    return data.newInstance(argumentTypes, arguments, callbacks);\r\n}\n@Override\r\nprotected Object wrapCachedClass(Class klass) {\r\n    Class[] argumentTypes = this.argumentTypes;\r\n    if (argumentTypes == null) {\r\n        argumentTypes = Constants.EMPTY_CLASS_ARRAY;\r\n    }\r\n    EnhancerFactoryData factoryData = new EnhancerFactoryData(klass, argumentTypes, classOnly);\r\n    Field factoryDataField = null;\r\n    try {\r\n        // The subsequent dance is performed just once for each class,\r\n        // so it does not matter much how fast it goes\r\n        factoryDataField = klass.getField(FACTORY_DATA_FIELD);\r\n        factoryDataField.set(null, factoryData);\r\n        Field callbackFilterField = klass.getDeclaredField(CALLBACK_FILTER_FIELD);\r\n        callbackFilterField.setAccessible(true);\r\n        callbackFilterField.set(null, this.filter);\r\n    } catch (NoSuchFieldException | IllegalAccessException e) {\r\n        throw new CodeGenerationException(e);\r\n    }\r\n    return new WeakReference<>(factoryData);\r\n}\n@Override\r\nprotected Object unwrapCachedValue(Object cached) {\r\n    if (currentKey instanceof EnhancerKey) {\r\n        EnhancerFactoryData data = ((WeakReference<EnhancerFactoryData>) cached).get();\r\n        return data;\r\n    }\r\n    return super.unwrapCachedValue(cached);\r\n}\n/**\r\n * Call this method to register the {@link Callback} array to use before\r\n * creating a new instance of the generated class via reflection. If you are using\r\n * an instance of <code>Enhancer</code> or the {@link Factory} interface to create\r\n * new instances, this method is unnecessary. Its primary use is for when you want to\r\n * cache and reuse a generated class yourself, and the generated class does\r\n * <i>not</i> implement the {@link Factory} interface.\r\n * <p>\r\n * Note that this method only registers the callbacks on the current thread.\r\n * If you want to register callbacks for instances created by multiple threads,\r\n * use {@link #registerStaticCallbacks}.\r\n * <p>\r\n * The registered callbacks are overwritten and subsequently cleared\r\n * when calling any of the <code>create</code> methods (such as\r\n * {@link #create}), or any {@link Factory} <code>newInstance</code> method.\r\n * Otherwise they are <i>not</i> cleared, and you should be careful to set them\r\n * back to <code>null</code> after creating new instances via reflection if\r\n * memory leakage is a concern.\r\n * @param generatedClass a class previously created by {@link Enhancer}\r\n * @param callbacks the array of callbacks to use when instances of the generated\r\n * class are created\r\n * @see #setUseFactory\r\n */\r\npublic static void registerCallbacks(Class generatedClass, Callback[] callbacks) {\r\n    setThreadCallbacks(generatedClass, callbacks);\r\n}\n/**\r\n * Similar to {@link #registerCallbacks}, but suitable for use\r\n * when multiple threads will be creating instances of the generated class.\r\n * The thread-level callbacks will always override the static callbacks.\r\n * Static callbacks are never cleared.\r\n * @param generatedClass a class previously created by {@link Enhancer}\r\n * @param callbacks the array of callbacks to use when instances of the generated\r\n * class are created\r\n */\r\npublic static void registerStaticCallbacks(Class generatedClass, Callback[] callbacks) {\r\n    setCallbacksHelper(generatedClass, callbacks, SET_STATIC_CALLBACKS_NAME);\r\n}\n/**\r\n * Determine if a class was generated using <code>Enhancer</code>.\r\n * @param type any class\r\n * @return whether the class was generated  using <code>Enhancer</code>\r\n */\r\npublic static boolean isEnhanced(Class type) {\r\n    try {\r\n        getCallbacksSetter(type, SET_THREAD_CALLBACKS_NAME);\r\n        return true;\r\n    } catch (NoSuchMethodException e) {\r\n        return false;\r\n    }\r\n}\nprivate static void setThreadCallbacks(Class type, Callback[] callbacks) {\r\n    setCallbacksHelper(type, callbacks, SET_THREAD_CALLBACKS_NAME);\r\n}\nprivate static void setCallbacksHelper(Class type, Callback[] callbacks, String methodName) {\r\n    // TODO: optimize\r\n    try {\r\n        Method setter = getCallbacksSetter(type, methodName);\r\n        setter.invoke(null, new Object[] { callbacks });\r\n    } catch (NoSuchMethodException e) {\r\n        throw new IllegalArgumentException(type + \" is not an enhanced class\");\r\n    } catch (IllegalAccessException | InvocationTargetException e) {\r\n        throw new CodeGenerationException(e);\r\n    }\r\n}\nprivate static Method getCallbacksSetter(Class type, String methodName) throws NoSuchMethodException {\r\n    return type.getDeclaredMethod(methodName, new Class[] { Callback[].class });\r\n}\n/**\r\n * Instantiates a proxy instance and assigns callback values.\r\n * Implementation detail: java.lang.reflect instances are not cached, so this method should not\r\n * be used on a hot path.\r\n * This method is used when {@link #setUseCache(boolean)} is set to {@code false}.\r\n * @param type class to instantiate\r\n * @return newly created instance\r\n */\r\nprivate Object createUsingReflection(Class type) {\r\n    setThreadCallbacks(type, callbacks);\r\n    try {\r\n        if (argumentTypes != null) {\r\n            return ReflectUtils.newInstance(type, argumentTypes, arguments);\r\n        } else {\r\n            return ReflectUtils.newInstance(type);\r\n        }\r\n    } finally {\r\n        // clear thread callbacks to allow them to be gc'd\r\n        setThreadCallbacks(type, null);\r\n    }\r\n}\n/**\r\n * Helper method to create an intercepted object.\r\n * For finer control over the generated instance, use a new instance of <code>Enhancer</code>\r\n * instead of this static method.\r\n * @param type class to extend or interface to implement\r\n * @param callback the callback to use for all methods\r\n */\r\npublic static Object create(Class type, Callback callback) {\r\n    Enhancer e = new Enhancer();\r\n    e.setSuperclass(type);\r\n    e.setCallback(callback);\r\n    return e.create();\r\n}\n/**\r\n * Helper method to create an intercepted object.\r\n * For finer control over the generated instance, use a new instance of <code>Enhancer</code>\r\n * instead of this static method.\r\n * @param superclass class to extend or interface to implement\r\n * @param interfaces array of interfaces to implement, or null\r\n * @param callback the callback to use for all methods\r\n */\r\npublic static Object create(Class superclass, Class[] interfaces, Callback callback) {\r\n    Enhancer e = new Enhancer();\r\n    e.setSuperclass(superclass);\r\n    e.setInterfaces(interfaces);\r\n    e.setCallback(callback);\r\n    return e.create();\r\n}\n/**\r\n * Helper method to create an intercepted object.\r\n * For finer control over the generated instance, use a new instance of <code>Enhancer</code>\r\n * instead of this static method.\r\n * @param superclass class to extend or interface to implement\r\n * @param interfaces array of interfaces to implement, or null\r\n * @param filter the callback filter to use when generating a new class\r\n * @param callbacks callback implementations to use for the enhanced object\r\n */\r\npublic static Object create(Class superclass, Class[] interfaces, CallbackFilter filter, Callback[] callbacks) {\r\n    Enhancer e = new Enhancer();\r\n    e.setSuperclass(superclass);\r\n    e.setInterfaces(interfaces);\r\n    e.setCallbackFilter(filter);\r\n    e.setCallbacks(callbacks);\r\n    return e.create();\r\n}\nprivate void emitDefaultConstructor(ClassEmitter ce) {\r\n    Constructor<Object> declaredConstructor;\r\n    try {\r\n        declaredConstructor = Object.class.getDeclaredConstructor();\r\n    } catch (NoSuchMethodException e) {\r\n        throw new IllegalStateException(\"Object should have default constructor \", e);\r\n    }\r\n    MethodInfo constructor = (MethodInfo) MethodInfoTransformer.getInstance().transform(declaredConstructor);\r\n    CodeEmitter e = EmitUtils.begin_method(ce, constructor, Constants.ACC_PUBLIC);\r\n    e.load_this();\r\n    e.dup();\r\n    Signature sig = constructor.getSignature();\r\n    e.super_invoke_constructor(sig);\r\n    e.return_value();\r\n    e.end_method();\r\n}\nprivate void emitConstructors(ClassEmitter ce, List constructors) {\r\n    boolean seenNull = false;\r\n    for (Iterator it = constructors.iterator(); it.hasNext(); ) {\r\n        MethodInfo constructor = (MethodInfo) it.next();\r\n        if (currentData != null && !\"()V\".equals(constructor.getSignature().getDescriptor())) {\r\n            continue;\r\n        }\r\n        CodeEmitter e = EmitUtils.begin_method(ce, constructor, Constants.ACC_PUBLIC);\r\n        e.load_this();\r\n        e.dup();\r\n        e.load_args();\r\n        Signature sig = constructor.getSignature();\r\n        seenNull = seenNull || sig.getDescriptor().equals(\"()V\");\r\n        e.super_invoke_constructor(sig);\r\n        if (currentData == null) {\r\n            e.invoke_static_this(BIND_CALLBACKS);\r\n            if (!interceptDuringConstruction) {\r\n                e.load_this();\r\n                e.push(1);\r\n                e.putfield(CONSTRUCTED_FIELD);\r\n            }\r\n        }\r\n        e.return_value();\r\n        e.end_method();\r\n    }\r\n    if (!classOnly && !seenNull && arguments == null) {\r\n        throw new IllegalArgumentException(\"Superclass has no null constructors but no arguments were given\");\r\n    }\r\n}\nprivate int[] getCallbackKeys() {\r\n    int[] keys = new int[callbackTypes.length];\r\n    for (int i = 0; i < callbackTypes.length; i++) {\r\n        keys[i] = i;\r\n    }\r\n    return keys;\r\n}\nprivate void emitGetCallback(ClassEmitter ce, int[] keys) {\r\n    final CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, GET_CALLBACK, null);\r\n    e.load_this();\r\n    e.invoke_static_this(BIND_CALLBACKS);\r\n    e.load_this();\r\n    e.load_arg(0);\r\n    e.process_switch(keys, new ProcessSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(int key, Label end) {\r\n            e.getfield(getCallbackField(key));\r\n            e.goTo(end);\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            // stack height\r\n            e.pop();\r\n            e.aconst_null();\r\n        }\r\n    });\r\n    e.return_value();\r\n    e.end_method();\r\n}\nprivate void emitSetCallback(ClassEmitter ce, int[] keys) {\r\n    final CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, SET_CALLBACK, null);\r\n    e.load_arg(0);\r\n    e.process_switch(keys, new ProcessSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(int key, Label end) {\r\n            e.load_this();\r\n            e.load_arg(1);\r\n            e.checkcast(callbackTypes[key]);\r\n            e.putfield(getCallbackField(key));\r\n            e.goTo(end);\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            // TODO: error?\r\n        }\r\n    });\r\n    e.return_value();\r\n    e.end_method();\r\n}\nprivate void emitSetCallbacks(ClassEmitter ce) {\r\n    CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, SET_CALLBACKS, null);\r\n    e.load_this();\r\n    e.load_arg(0);\r\n    for (int i = 0; i < callbackTypes.length; i++) {\r\n        e.dup2();\r\n        e.aaload(i);\r\n        e.checkcast(callbackTypes[i]);\r\n        e.putfield(getCallbackField(i));\r\n    }\r\n    e.return_value();\r\n    e.end_method();\r\n}\nprivate void emitGetCallbacks(ClassEmitter ce) {\r\n    CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, GET_CALLBACKS, null);\r\n    e.load_this();\r\n    e.invoke_static_this(BIND_CALLBACKS);\r\n    e.load_this();\r\n    e.push(callbackTypes.length);\r\n    e.newarray(CALLBACK);\r\n    for (int i = 0; i < callbackTypes.length; i++) {\r\n        e.dup();\r\n        e.push(i);\r\n        e.load_this();\r\n        e.getfield(getCallbackField(i));\r\n        e.aastore();\r\n    }\r\n    e.return_value();\r\n    e.end_method();\r\n}\nprivate void emitNewInstanceCallbacks(ClassEmitter ce) {\r\n    CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, NEW_INSTANCE, null);\r\n    Type thisType = getThisType(e);\r\n    e.load_arg(0);\r\n    e.invoke_static(thisType, SET_THREAD_CALLBACKS, false);\r\n    emitCommonNewInstance(e);\r\n}\nprivate Type getThisType(CodeEmitter e) {\r\n    if (currentData == null) {\r\n        return e.getClassEmitter().getClassType();\r\n    } else {\r\n        return Type.getType(currentData.generatedClass);\r\n    }\r\n}\nprivate void emitCommonNewInstance(CodeEmitter e) {\r\n    Type thisType = getThisType(e);\r\n    e.new_instance(thisType);\r\n    e.dup();\r\n    e.invoke_constructor(thisType);\r\n    e.aconst_null();\r\n    e.invoke_static(thisType, SET_THREAD_CALLBACKS, false);\r\n    e.return_value();\r\n    e.end_method();\r\n}\nprivate void emitNewInstanceCallback(ClassEmitter ce) {\r\n    CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, SINGLE_NEW_INSTANCE, null);\r\n    switch(callbackTypes.length) {\r\n        case 0:\r\n            // TODO: make sure Callback is null\r\n            break;\r\n        case 1:\r\n            // for now just make a new array; TODO: optimize\r\n            e.push(1);\r\n            e.newarray(CALLBACK);\r\n            e.dup();\r\n            e.push(0);\r\n            e.load_arg(0);\r\n            e.aastore();\r\n            e.invoke_static(getThisType(e), SET_THREAD_CALLBACKS, false);\r\n            break;\r\n        default:\r\n            e.throw_exception(ILLEGAL_STATE_EXCEPTION, \"More than one callback object required\");\r\n    }\r\n    emitCommonNewInstance(e);\r\n}\nprivate void emitNewInstanceMultiarg(ClassEmitter ce, List constructors) {\r\n    final CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, MULTIARG_NEW_INSTANCE, null);\r\n    final Type thisType = getThisType(e);\r\n    e.load_arg(2);\r\n    e.invoke_static(thisType, SET_THREAD_CALLBACKS, false);\r\n    e.new_instance(thisType);\r\n    e.dup();\r\n    e.load_arg(0);\r\n    EmitUtils.constructor_switch(e, constructors, new ObjectSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(Object key, Label end) {\r\n            MethodInfo constructor = (MethodInfo) key;\r\n            Type[] types = constructor.getSignature().getArgumentTypes();\r\n            for (int i = 0; i < types.length; i++) {\r\n                e.load_arg(1);\r\n                e.push(i);\r\n                e.aaload();\r\n                e.unbox(types[i]);\r\n            }\r\n            e.invoke_constructor(thisType, constructor.getSignature());\r\n            e.goTo(end);\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            e.throw_exception(ILLEGAL_ARGUMENT_EXCEPTION, \"Constructor not found\");\r\n        }\r\n    });\r\n    e.aconst_null();\r\n    e.invoke_static(thisType, SET_THREAD_CALLBACKS, false);\r\n    e.return_value();\r\n    e.end_method();\r\n}\nprivate void emitMethods(final ClassEmitter ce, List methods, List actualMethods) {\r\n    CallbackGenerator[] generators = CallbackInfo.getGenerators(callbackTypes);\r\n    Map groups = new HashMap();\r\n    final Map indexes = new HashMap();\r\n    final Map originalModifiers = new HashMap();\r\n    final Map positions = CollectionUtils.getIndexMap(methods);\r\n    final Map declToBridge = new HashMap();\r\n    Iterator it1 = methods.iterator();\r\n    Iterator it2 = (actualMethods != null) ? actualMethods.iterator() : null;\r\n    while (it1.hasNext()) {\r\n        MethodInfo method = (MethodInfo) it1.next();\r\n        Method actualMethod = (it2 != null) ? (Method) it2.next() : null;\r\n        int index = filter.accept(actualMethod);\r\n        if (index >= callbackTypes.length) {\r\n            throw new IllegalArgumentException(\"Callback filter returned an index that is too large: \" + index);\r\n        }\r\n        originalModifiers.put(method, (actualMethod != null ? actualMethod.getModifiers() : method.getModifiers()));\r\n        indexes.put(method, index);\r\n        List group = (List) groups.get(generators[index]);\r\n        if (group == null) {\r\n            groups.put(generators[index], group = new ArrayList(methods.size()));\r\n        }\r\n        group.add(method);\r\n        // Optimization: build up a map of Class -> bridge methods in class\r\n        // so that we can look up all the bridge methods in one pass for a class.\r\n        if (TypeUtils.isBridge(actualMethod.getModifiers())) {\r\n            Set bridges = (Set) declToBridge.get(actualMethod.getDeclaringClass());\r\n            if (bridges == null) {\r\n                bridges = new HashSet();\r\n                declToBridge.put(actualMethod.getDeclaringClass(), bridges);\r\n            }\r\n            bridges.add(method.getSignature());\r\n        }\r\n    }\r\n    final Map bridgeToTarget = new BridgeMethodResolver(declToBridge, getClassLoader()).resolveAll();\r\n    Set seenGen = new HashSet();\r\n    CodeEmitter se = ce.getStaticHook();\r\n    se.new_instance(THREAD_LOCAL);\r\n    se.dup();\r\n    se.invoke_constructor(THREAD_LOCAL, CSTRUCT_NULL);\r\n    se.putfield(THREAD_CALLBACKS_FIELD);\r\n    CallbackGenerator.Context context = new CallbackGenerator.Context() {\r\n\r\n        @Override\r\n        public ClassLoader getClassLoader() {\r\n            return Enhancer.this.getClassLoader();\r\n        }\r\n\r\n        @Override\r\n        public int getOriginalModifiers(MethodInfo method) {\r\n            return ((Integer) originalModifiers.get(method)).intValue();\r\n        }\r\n\r\n        @Override\r\n        public int getIndex(MethodInfo method) {\r\n            return ((Integer) indexes.get(method)).intValue();\r\n        }\r\n\r\n        @Override\r\n        public void emitCallback(CodeEmitter e, int index) {\r\n            emitCurrentCallback(e, index);\r\n        }\r\n\r\n        @Override\r\n        public Signature getImplSignature(MethodInfo method) {\r\n            return rename(method.getSignature(), ((Integer) positions.get(method)).intValue());\r\n        }\r\n\r\n        @Override\r\n        public void emitLoadArgsAndInvoke(CodeEmitter e, MethodInfo method) {\r\n            // If this is a bridge and we know the target was called from invokespecial,\r\n            // then we need to invoke_virtual w/ the bridge target instead of doing\r\n            // a super, because super may itself be using super, which would bypass\r\n            // any proxies on the target.\r\n            Signature bridgeTarget = (Signature) bridgeToTarget.get(method.getSignature());\r\n            if (bridgeTarget != null) {\r\n                // checkcast each argument against the target's argument types\r\n                for (int i = 0; i < bridgeTarget.getArgumentTypes().length; i++) {\r\n                    e.load_arg(i);\r\n                    Type target = bridgeTarget.getArgumentTypes()[i];\r\n                    if (!target.equals(method.getSignature().getArgumentTypes()[i])) {\r\n                        e.checkcast(target);\r\n                    }\r\n                }\r\n                e.invoke_virtual_this(bridgeTarget);\r\n                Type retType = method.getSignature().getReturnType();\r\n                // Not necessary to cast if the target & bridge have\r\n                // the same return type.\r\n                // (This conveniently includes void and primitive types,\r\n                // which would fail if casted.  It's not possible to\r\n                // covariant from boxed to unbox (or vice versa), so no having\r\n                // to box/unbox for bridges).\r\n                // TODO: It also isn't necessary to checkcast if the return is\r\n                // assignable from the target.  (This would happen if a subclass\r\n                // used covariant returns to narrow the return type within a bridge\r\n                // method.)\r\n                if (!retType.equals(bridgeTarget.getReturnType())) {\r\n                    e.checkcast(retType);\r\n                }\r\n            } else {\r\n                e.load_args();\r\n                e.super_invoke(method.getSignature());\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public CodeEmitter beginMethod(ClassEmitter ce, MethodInfo method) {\r\n            CodeEmitter e = EmitUtils.begin_method(ce, method);\r\n            if (!interceptDuringConstruction && !TypeUtils.isAbstract(method.getModifiers())) {\r\n                Label constructed = e.make_label();\r\n                e.load_this();\r\n                e.getfield(CONSTRUCTED_FIELD);\r\n                e.if_jump(CodeEmitter.NE, constructed);\r\n                e.load_this();\r\n                e.load_args();\r\n                e.super_invoke();\r\n                e.return_value();\r\n                e.mark(constructed);\r\n            }\r\n            return e;\r\n        }\r\n    };\r\n    for (int i = 0; i < callbackTypes.length; i++) {\r\n        CallbackGenerator gen = generators[i];\r\n        if (!seenGen.contains(gen)) {\r\n            seenGen.add(gen);\r\n            final List fmethods = (List) groups.get(gen);\r\n            if (fmethods != null) {\r\n                try {\r\n                    gen.generate(ce, context, fmethods);\r\n                    gen.generateStatic(se, context, fmethods);\r\n                } catch (RuntimeException x) {\r\n                    throw x;\r\n                } catch (Exception x) {\r\n                    throw new CodeGenerationException(x);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    se.return_value();\r\n    se.end_method();\r\n}\nprivate void emitSetThreadCallbacks(ClassEmitter ce) {\r\n    CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC | Constants.ACC_STATIC, SET_THREAD_CALLBACKS, null);\r\n    e.getfield(THREAD_CALLBACKS_FIELD);\r\n    e.load_arg(0);\r\n    e.invoke_virtual(THREAD_LOCAL, THREAD_LOCAL_SET);\r\n    e.return_value();\r\n    e.end_method();\r\n}\nprivate void emitSetStaticCallbacks(ClassEmitter ce) {\r\n    CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC | Constants.ACC_STATIC, SET_STATIC_CALLBACKS, null);\r\n    e.load_arg(0);\r\n    e.putfield(STATIC_CALLBACKS_FIELD);\r\n    e.return_value();\r\n    e.end_method();\r\n}\nprivate void emitCurrentCallback(CodeEmitter e, int index) {\r\n    e.load_this();\r\n    e.getfield(getCallbackField(index));\r\n    e.dup();\r\n    Label end = e.make_label();\r\n    e.ifnonnull(end);\r\n    // stack height\r\n    e.pop();\r\n    e.load_this();\r\n    e.invoke_static_this(BIND_CALLBACKS);\r\n    e.load_this();\r\n    e.getfield(getCallbackField(index));\r\n    e.mark(end);\r\n}\nprivate void emitBindCallbacks(ClassEmitter ce) {\r\n    CodeEmitter e = ce.begin_method(Constants.PRIVATE_FINAL_STATIC, BIND_CALLBACKS, null);\r\n    Local me = e.make_local();\r\n    e.load_arg(0);\r\n    e.checkcast_this();\r\n    e.store_local(me);\r\n    Label end = e.make_label();\r\n    e.load_local(me);\r\n    e.getfield(BOUND_FIELD);\r\n    e.if_jump(CodeEmitter.NE, end);\r\n    e.load_local(me);\r\n    e.push(1);\r\n    e.putfield(BOUND_FIELD);\r\n    e.getfield(THREAD_CALLBACKS_FIELD);\r\n    e.invoke_virtual(THREAD_LOCAL, THREAD_LOCAL_GET);\r\n    e.dup();\r\n    Label found_callback = e.make_label();\r\n    e.ifnonnull(found_callback);\r\n    e.pop();\r\n    e.getfield(STATIC_CALLBACKS_FIELD);\r\n    e.dup();\r\n    e.ifnonnull(found_callback);\r\n    e.pop();\r\n    e.goTo(end);\r\n    e.mark(found_callback);\r\n    e.checkcast(CALLBACK_ARRAY);\r\n    e.load_local(me);\r\n    e.swap();\r\n    for (int i = callbackTypes.length - 1; i >= 0; i--) {\r\n        if (i != 0) {\r\n            e.dup2();\r\n        }\r\n        e.aaload(i);\r\n        e.checkcast(callbackTypes[i]);\r\n        e.putfield(getCallbackField(i));\r\n    }\r\n    e.mark(end);\r\n    e.return_value();\r\n    e.end_method();\r\n}\nprivate static String getCallbackField(int index) {\r\n    return \"CGLIB$CALLBACK_\" + index;\r\n}",
    "comment": "\n * Generates dynamic subclasses to enable method interception. This\n * class started as a substitute for the standard Dynamic Proxy support\n * included with JDK 1.3, but one that allowed the proxies to extend a\n * concrete base class, in addition to implementing interfaces. The dynamically\n * generated subclasses override the non-final methods of the superclass and\n * have hooks which callback to user-defined interceptor\n * implementations.\n * <p>\n * The original and most general callback type is the {@link MethodInterceptor}, which\n * in AOP terms enables \"around advice\"--that is, you can invoke custom code both before\n * and after the invocation of the \"super\" method. In addition you can modify the\n * arguments before calling the super method, or not call it at all.\n * <p>\n * Although <code>MethodInterceptor</code> is generic enough to meet any\n * interception need, it is often overkill. For simplicity and performance, additional\n * specialized callback types, such as {@link LazyLoader} are also available.\n * Often a single callback will be used per enhanced class, but you can control\n * which callback is used on a per-method basis with a {@link CallbackFilter}.\n * <p>\n * The most common uses of this class are embodied in the static helper methods. For\n * advanced needs, such as customizing the <code>ClassLoader</code> to use, you should create\n * a new instance of <code>Enhancer</code>. Other classes within CGLIB follow a similar pattern.\n * <p>\n * All enhanced objects implement the {@link Factory} interface, unless {@link #setUseFactory} is\n * used to explicitly disable this feature. The <code>Factory</code> interface provides an API\n * to change the callbacks of an existing object, as well as a faster and easier way to create\n * new instances of the same type.\n * <p>\n * For an almost drop-in replacement for\n * <code>java.lang.reflect.Proxy</code>, see the {@link Proxy} class.\n "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#setSuperclass(Class)",
    "entityType": "method",
    "code": "/**\r\n * Set the class which the generated class will extend. As a convenience,\r\n * if the supplied superclass is actually an interface, <code>setInterfaces</code>\r\n * will be called with the appropriate argument instead.\r\n * A non-interface argument must not be declared as final, and must have an\r\n * accessible constructor.\r\n * @param superclass class to extend or interface to implement\r\n * @see #setInterfaces(Class[])\r\n */\r\npublic void setSuperclass(Class superclass) {\r\n    if (superclass != null && superclass.isInterface()) {\r\n        setInterfaces(new Class[] { superclass });\r\n        // SPRING PATCH BEGIN\r\n        setContextClass(superclass);\r\n        // SPRING PATCH END\r\n    } else if (superclass != null && superclass.equals(Object.class)) {\r\n        // affects choice of ClassLoader\r\n        this.superclass = null;\r\n    } else {\r\n        this.superclass = superclass;\r\n        // SPRING PATCH BEGIN\r\n        setContextClass(superclass);\r\n        // SPRING PATCH END\r\n    }\r\n}",
    "comment": "\n\t * Set the class which the generated class will extend. As a convenience,\n\t * if the supplied superclass is actually an interface, <code>setInterfaces</code>\n\t * will be called with the appropriate argument instead.\n\t * A non-interface argument must not be declared as final, and must have an\n\t * accessible constructor.\n\t * @param superclass class to extend or interface to implement\n\t * @see #setInterfaces(Class[])\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#setInterfaces(Class[])",
    "entityType": "method",
    "code": "/**\r\n * Set the interfaces to implement. The <code>Factory</code> interface will\r\n * always be implemented regardless of what is specified here.\r\n * @param interfaces array of interfaces to implement, or null\r\n * @see Factory\r\n */\r\npublic void setInterfaces(Class[] interfaces) {\r\n    this.interfaces = interfaces;\r\n}",
    "comment": "\n\t * Set the interfaces to implement. The <code>Factory</code> interface will\n\t * always be implemented regardless of what is specified here.\n\t * @param interfaces array of interfaces to implement, or null\n\t * @see Factory\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#setCallbackFilter(CallbackFilter)",
    "entityType": "method",
    "code": "/**\r\n * Set the {@link CallbackFilter} used to map the generated class' methods\r\n * to a particular callback index.\r\n * New object instances will always use the same mapping, but may use different\r\n * actual callback objects.\r\n * @param filter the callback filter to use when generating a new class\r\n * @see #setCallbacks\r\n */\r\npublic void setCallbackFilter(CallbackFilter filter) {\r\n    this.filter = filter;\r\n}",
    "comment": "\n\t * Set the {@link CallbackFilter} used to map the generated class' methods\n\t * to a particular callback index.\n\t * New object instances will always use the same mapping, but may use different\n\t * actual callback objects.\n\t * @param filter the callback filter to use when generating a new class\n\t * @see #setCallbacks\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#setCallback(Callback)",
    "entityType": "method",
    "code": "/**\r\n * Set the single {@link Callback} to use.\r\n * Ignored if you use {@link #createClass}.\r\n * @param callback the callback to use for all methods\r\n * @see #setCallbacks\r\n */\r\npublic void setCallback(final Callback callback) {\r\n    setCallbacks(new Callback[] { callback });\r\n}",
    "comment": "\n\t * Set the single {@link Callback} to use.\n\t * Ignored if you use {@link #createClass}.\n\t * @param callback the callback to use for all methods\n\t * @see #setCallbacks\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#setCallbacks(Callback[])",
    "entityType": "method",
    "code": "/**\r\n * Set the array of callbacks to use.\r\n * Ignored if you use {@link #createClass}.\r\n * You must use a {@link CallbackFilter} to specify the index into this\r\n * array for each method in the proxied class.\r\n * @param callbacks the callback array\r\n * @see #setCallbackFilter\r\n * @see #setCallback\r\n */\r\npublic void setCallbacks(Callback[] callbacks) {\r\n    if (callbacks != null && callbacks.length == 0) {\r\n        throw new IllegalArgumentException(\"Array cannot be empty\");\r\n    }\r\n    this.callbacks = callbacks;\r\n}",
    "comment": "\n\t * Set the array of callbacks to use.\n\t * Ignored if you use {@link #createClass}.\n\t * You must use a {@link CallbackFilter} to specify the index into this\n\t * array for each method in the proxied class.\n\t * @param callbacks the callback array\n\t * @see #setCallbackFilter\n\t * @see #setCallback\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#setUseFactory(boolean)",
    "entityType": "method",
    "code": "/**\r\n * Set whether the enhanced object instances should implement\r\n * the {@link Factory} interface.\r\n * This was added for tools that need for proxies to be more\r\n * indistinguishable from their targets. Also, in some cases it may\r\n * be necessary to disable the <code>Factory</code> interface to\r\n * prevent code from changing the underlying callbacks.\r\n * @param useFactory whether to implement <code>Factory</code>; default is <code>true</code>\r\n */\r\npublic void setUseFactory(boolean useFactory) {\r\n    this.useFactory = useFactory;\r\n}",
    "comment": "\n\t * Set whether the enhanced object instances should implement\n\t * the {@link Factory} interface.\n\t * This was added for tools that need for proxies to be more\n\t * indistinguishable from their targets. Also, in some cases it may\n\t * be necessary to disable the <code>Factory</code> interface to\n\t * prevent code from changing the underlying callbacks.\n\t * @param useFactory whether to implement <code>Factory</code>; default is <code>true</code>\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#setInterceptDuringConstruction(boolean)",
    "entityType": "method",
    "code": "/**\r\n * Set whether methods called from within the proxy's constructer\r\n * will be intercepted. The default value is true. Unintercepted methods\r\n * will call the method of the proxy's base class, if it exists.\r\n * @param interceptDuringConstruction whether to intercept methods called from the constructor\r\n */\r\npublic void setInterceptDuringConstruction(boolean interceptDuringConstruction) {\r\n    this.interceptDuringConstruction = interceptDuringConstruction;\r\n}",
    "comment": "\n\t * Set whether methods called from within the proxy's constructer\n\t * will be intercepted. The default value is true. Unintercepted methods\n\t * will call the method of the proxy's base class, if it exists.\n\t * @param interceptDuringConstruction whether to intercept methods called from the constructor\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#setCallbackType(Class)",
    "entityType": "method",
    "code": "/**\r\n * Set the single type of {@link Callback} to use.\r\n * This may be used instead of {@link #setCallback} when calling\r\n * {@link #createClass}, since it may not be possible to have\r\n * an array of actual callback instances.\r\n * @param callbackType the type of callback to use for all methods\r\n * @see #setCallbackTypes\r\n */\r\npublic void setCallbackType(Class callbackType) {\r\n    setCallbackTypes(new Class[] { callbackType });\r\n}",
    "comment": "\n\t * Set the single type of {@link Callback} to use.\n\t * This may be used instead of {@link #setCallback} when calling\n\t * {@link #createClass}, since it may not be possible to have\n\t * an array of actual callback instances.\n\t * @param callbackType the type of callback to use for all methods\n\t * @see #setCallbackTypes\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#setCallbackTypes(Class[])",
    "entityType": "method",
    "code": "/**\r\n * Set the array of callback types to use.\r\n * This may be used instead of {@link #setCallbacks} when calling\r\n * {@link #createClass}, since it may not be possible to have\r\n * an array of actual callback instances.\r\n * You must use a {@link CallbackFilter} to specify the index into this\r\n * array for each method in the proxied class.\r\n * @param callbackTypes the array of callback types\r\n */\r\npublic void setCallbackTypes(Class[] callbackTypes) {\r\n    if (callbackTypes != null && callbackTypes.length == 0) {\r\n        throw new IllegalArgumentException(\"Array cannot be empty\");\r\n    }\r\n    this.callbackTypes = CallbackInfo.determineTypes(callbackTypes);\r\n}",
    "comment": "\n\t * Set the array of callback types to use.\n\t * This may be used instead of {@link #setCallbacks} when calling\n\t * {@link #createClass}, since it may not be possible to have\n\t * an array of actual callback instances.\n\t * You must use a {@link CallbackFilter} to specify the index into this\n\t * array for each method in the proxied class.\n\t * @param callbackTypes the array of callback types\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#create()",
    "entityType": "method",
    "code": "/**\r\n * Generate a new class if necessary and uses the specified\r\n * callbacks (if any) to create a new object instance.\r\n * Uses the no-arg constructor of the superclass.\r\n * @return a new instance\r\n */\r\npublic Object create() {\r\n    classOnly = false;\r\n    argumentTypes = null;\r\n    return createHelper();\r\n}",
    "comment": "\n\t * Generate a new class if necessary and uses the specified\n\t * callbacks (if any) to create a new object instance.\n\t * Uses the no-arg constructor of the superclass.\n\t * @return a new instance\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#create(Class[],Object[])",
    "entityType": "method",
    "code": "/**\r\n * Generate a new class if necessary and uses the specified\r\n * callbacks (if any) to create a new object instance.\r\n * Uses the constructor of the superclass matching the <code>argumentTypes</code>\r\n * parameter, with the given arguments.\r\n * @param argumentTypes constructor signature\r\n * @param arguments compatible wrapped arguments to pass to constructor\r\n * @return a new instance\r\n */\r\npublic Object create(Class[] argumentTypes, Object[] arguments) {\r\n    classOnly = false;\r\n    if (argumentTypes == null || arguments == null || argumentTypes.length != arguments.length) {\r\n        throw new IllegalArgumentException(\"Arguments must be non-null and of equal length\");\r\n    }\r\n    this.argumentTypes = argumentTypes;\r\n    this.arguments = arguments;\r\n    return createHelper();\r\n}",
    "comment": "\n\t * Generate a new class if necessary and uses the specified\n\t * callbacks (if any) to create a new object instance.\n\t * Uses the constructor of the superclass matching the <code>argumentTypes</code>\n\t * parameter, with the given arguments.\n\t * @param argumentTypes constructor signature\n\t * @param arguments compatible wrapped arguments to pass to constructor\n\t * @return a new instance\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#createClass()",
    "entityType": "method",
    "code": "/**\r\n * Generate a new class if necessary and return it without creating a new instance.\r\n * This ignores any callbacks that have been set.\r\n * To create a new instance you will have to use reflection, and methods\r\n * called during the constructor will not be intercepted. To avoid this problem,\r\n * use the multi-arg <code>create</code> method.\r\n * @see #create(Class[], Object[])\r\n */\r\npublic Class createClass() {\r\n    classOnly = true;\r\n    return (Class) createHelper();\r\n}",
    "comment": "\n\t * Generate a new class if necessary and return it without creating a new instance.\n\t * This ignores any callbacks that have been set.\n\t * To create a new instance you will have to use reflection, and methods\n\t * called during the constructor will not be intercepted. To avoid this problem,\n\t * use the multi-arg <code>create</code> method.\n\t * @see #create(Class[], Object[])\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#setSerialVersionUID(Long)",
    "entityType": "method",
    "code": "/**\r\n * Insert a static serialVersionUID field into the generated class.\r\n * @param sUID the field value, or null to avoid generating field.\r\n */\r\npublic void setSerialVersionUID(Long sUID) {\r\n    serialVersionUID = sUID;\r\n}",
    "comment": "\n\t * Insert a static serialVersionUID field into the generated class.\n\t * @param sUID the field value, or null to avoid generating field.\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#preValidate()",
    "entityType": "method",
    "code": "private void preValidate() {\r\n    if (callbackTypes == null) {\r\n        callbackTypes = CallbackInfo.determineTypes(callbacks, false);\r\n        validateCallbackTypes = true;\r\n    }\r\n    if (filter == null) {\r\n        if (callbackTypes.length > 1) {\r\n            throw new IllegalStateException(\"Multiple callback types possible but no filter specified\");\r\n        }\r\n        filter = ALL_ZERO;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#validate()",
    "entityType": "method",
    "code": "private void validate() {\r\n    if (classOnly ^ (callbacks == null)) {\r\n        if (classOnly) {\r\n            throw new IllegalStateException(\"createClass does not accept callbacks\");\r\n        } else {\r\n            throw new IllegalStateException(\"Callbacks are required\");\r\n        }\r\n    }\r\n    if (classOnly && (callbackTypes == null)) {\r\n        throw new IllegalStateException(\"Callback types are required\");\r\n    }\r\n    if (validateCallbackTypes) {\r\n        callbackTypes = null;\r\n    }\r\n    if (callbacks != null && callbackTypes != null) {\r\n        if (callbacks.length != callbackTypes.length) {\r\n            throw new IllegalStateException(\"Lengths of callback and callback types array must be the same\");\r\n        }\r\n        Type[] check = CallbackInfo.determineTypes(callbacks);\r\n        for (int i = 0; i < check.length; i++) {\r\n            if (!check[i].equals(callbackTypes[i])) {\r\n                throw new IllegalStateException(\"Callback \" + check[i] + \" is not assignable to \" + callbackTypes[i]);\r\n            }\r\n        }\r\n    } else if (callbacks != null) {\r\n        callbackTypes = CallbackInfo.determineTypes(callbacks);\r\n    }\r\n    if (interfaces != null) {\r\n        for (Class element : interfaces) {\r\n            if (element == null) {\r\n                throw new IllegalStateException(\"Interfaces cannot be null\");\r\n            }\r\n            if (!element.isInterface()) {\r\n                throw new IllegalStateException(element + \" is not an interface\");\r\n            }\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#createHelper()",
    "entityType": "method",
    "code": "private Object createHelper() {\r\n    preValidate();\r\n    // SPRING PATCH BEGIN\r\n    Object key = new EnhancerKey((superclass != null ? superclass.getName() : null), (interfaces != null ? Arrays.asList(ReflectUtils.getNames(interfaces)) : null), (filter == ALL_ZERO ? null : new WeakCacheKey<>(filter)), Arrays.asList(callbackTypes), useFactory, interceptDuringConstruction, serialVersionUID);\r\n    // SPRING PATCH END\r\n    this.currentKey = key;\r\n    Object result = super.create(key);\r\n    return result;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#generate(ClassLoaderData)",
    "entityType": "method",
    "code": "@Override\r\nprotected Class generate(ClassLoaderData data) {\r\n    validate();\r\n    if (superclass != null) {\r\n        setNamePrefix(superclass.getName());\r\n    } else if (interfaces != null) {\r\n        setNamePrefix(interfaces[ReflectUtils.findPackageProtected(interfaces)].getName());\r\n    }\r\n    return super.generate(data);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#getDefaultClassLoader()",
    "entityType": "method",
    "code": "@Override\r\nprotected ClassLoader getDefaultClassLoader() {\r\n    if (superclass != null) {\r\n        return superclass.getClassLoader();\r\n    } else if (interfaces != null) {\r\n        return interfaces[0].getClassLoader();\r\n    } else {\r\n        return null;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#getProtectionDomain()",
    "entityType": "method",
    "code": "@Override\r\nprotected ProtectionDomain getProtectionDomain() {\r\n    if (superclass != null) {\r\n        return ReflectUtils.getProtectionDomain(superclass);\r\n    } else if (interfaces != null) {\r\n        return ReflectUtils.getProtectionDomain(interfaces[0]);\r\n    } else {\r\n        return null;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#rename(Signature,int)",
    "entityType": "method",
    "code": "private Signature rename(Signature sig, int index) {\r\n    return new Signature(\"CGLIB$\" + sig.getName() + \"$\" + index, sig.getDescriptor());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#getMethods(Class,Class[],List)",
    "entityType": "method",
    "code": "/**\r\n * Finds all of the methods that will be extended by an\r\n * Enhancer-generated class using the specified superclass and\r\n * interfaces. This can be useful in building a list of Callback\r\n * objects. The methods are added to the end of the given list.  Due\r\n * to the subclassing nature of the classes generated by Enhancer,\r\n * the methods are guaranteed to be non-static, non-final, and\r\n * non-private. Each method signature will only occur once, even if\r\n * it occurs in multiple classes.\r\n * @param superclass the class that will be extended, or null\r\n * @param interfaces the list of interfaces that will be implemented, or null\r\n * @param methods the list into which to copy the applicable methods\r\n */\r\npublic static void getMethods(Class superclass, Class[] interfaces, List methods) {\r\n    getMethods(superclass, interfaces, methods, null, null);\r\n}",
    "comment": "\n\t * Finds all of the methods that will be extended by an\n\t * Enhancer-generated class using the specified superclass and\n\t * interfaces. This can be useful in building a list of Callback\n\t * objects. The methods are added to the end of the given list.  Due\n\t * to the subclassing nature of the classes generated by Enhancer,\n\t * the methods are guaranteed to be non-static, non-final, and\n\t * non-private. Each method signature will only occur once, even if\n\t * it occurs in multiple classes.\n\t * @param superclass the class that will be extended, or null\n\t * @param interfaces the list of interfaces that will be implemented, or null\n\t * @param methods the list into which to copy the applicable methods\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#getMethods(Class,Class[],List,List,Set)",
    "entityType": "method",
    "code": "private static void getMethods(Class superclass, Class[] interfaces, List methods, List interfaceMethods, Set forcePublic) {\r\n    ReflectUtils.addAllMethods(superclass, methods);\r\n    List target = (interfaceMethods != null) ? interfaceMethods : methods;\r\n    if (interfaces != null) {\r\n        for (Class element : interfaces) {\r\n            if (element != Factory.class) {\r\n                ReflectUtils.addAllMethods(element, target);\r\n            }\r\n        }\r\n    }\r\n    if (interfaceMethods != null) {\r\n        if (forcePublic != null) {\r\n            forcePublic.addAll(MethodWrapper.createSet(interfaceMethods));\r\n        }\r\n        methods.addAll(interfaceMethods);\r\n    }\r\n    CollectionUtils.filter(methods, new RejectModifierPredicate(Constants.ACC_STATIC));\r\n    CollectionUtils.filter(methods, new VisibilityPredicate(superclass, true));\r\n    CollectionUtils.filter(methods, new DuplicatesPredicate());\r\n    CollectionUtils.filter(methods, new RejectModifierPredicate(Constants.ACC_FINAL));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#generateClass(ClassVisitor)",
    "entityType": "method",
    "code": "@Override\r\npublic void generateClass(ClassVisitor v) throws Exception {\r\n    Class sc = (superclass == null) ? Object.class : superclass;\r\n    if (TypeUtils.isFinal(sc.getModifiers())) {\r\n        throw new IllegalArgumentException(\"Cannot subclass final class \" + sc.getName());\r\n    }\r\n    List constructors = new ArrayList(Arrays.asList(sc.getDeclaredConstructors()));\r\n    filterConstructors(sc, constructors);\r\n    // Order is very important: must add superclass, then\r\n    // its superclass chain, then each interface and\r\n    // its superinterfaces.\r\n    List actualMethods = new ArrayList();\r\n    List interfaceMethods = new ArrayList();\r\n    final Set forcePublic = new HashSet();\r\n    getMethods(sc, interfaces, actualMethods, interfaceMethods, forcePublic);\r\n    List methods = CollectionUtils.transform(actualMethods, value -> {\r\n        Method method = (Method) value;\r\n        int modifiers = Constants.ACC_FINAL | (method.getModifiers() & ~Constants.ACC_ABSTRACT & ~Constants.ACC_NATIVE & ~Constants.ACC_SYNCHRONIZED);\r\n        if (forcePublic.contains(MethodWrapper.create(method))) {\r\n            modifiers = (modifiers & ~Constants.ACC_PROTECTED) | Constants.ACC_PUBLIC;\r\n        }\r\n        return ReflectUtils.getMethodInfo(method, modifiers);\r\n    });\r\n    ClassEmitter e = new ClassEmitter(v);\r\n    if (currentData == null) {\r\n        e.begin_class(Constants.V1_8, Constants.ACC_PUBLIC, getClassName(), Type.getType(sc), (useFactory ? TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) : TypeUtils.getTypes(interfaces)), Constants.SOURCE_FILE);\r\n    } else {\r\n        e.begin_class(Constants.V1_8, Constants.ACC_PUBLIC, getClassName(), null, new Type[] { FACTORY }, Constants.SOURCE_FILE);\r\n    }\r\n    List constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());\r\n    e.declare_field(Constants.ACC_PRIVATE, BOUND_FIELD, Type.BOOLEAN_TYPE, null);\r\n    e.declare_field(Constants.ACC_PUBLIC | Constants.ACC_STATIC, FACTORY_DATA_FIELD, OBJECT_TYPE, null);\r\n    if (!interceptDuringConstruction) {\r\n        e.declare_field(Constants.ACC_PRIVATE, CONSTRUCTED_FIELD, Type.BOOLEAN_TYPE, null);\r\n    }\r\n    e.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, null);\r\n    e.declare_field(Constants.PRIVATE_FINAL_STATIC, STATIC_CALLBACKS_FIELD, CALLBACK_ARRAY, null);\r\n    if (serialVersionUID != null) {\r\n        e.declare_field(Constants.PRIVATE_FINAL_STATIC, Constants.SUID_FIELD_NAME, Type.LONG_TYPE, serialVersionUID);\r\n    }\r\n    for (int i = 0; i < callbackTypes.length; i++) {\r\n        e.declare_field(Constants.ACC_PRIVATE, getCallbackField(i), callbackTypes[i], null);\r\n    }\r\n    // This is declared private to avoid \"public field\" pollution\r\n    e.declare_field(Constants.ACC_PRIVATE | Constants.ACC_STATIC, CALLBACK_FILTER_FIELD, OBJECT_TYPE, null);\r\n    if (currentData == null) {\r\n        emitMethods(e, methods, actualMethods);\r\n        emitConstructors(e, constructorInfo);\r\n    } else {\r\n        emitDefaultConstructor(e);\r\n    }\r\n    emitSetThreadCallbacks(e);\r\n    emitSetStaticCallbacks(e);\r\n    emitBindCallbacks(e);\r\n    if (useFactory || currentData != null) {\r\n        int[] keys = getCallbackKeys();\r\n        emitNewInstanceCallbacks(e);\r\n        emitNewInstanceCallback(e);\r\n        emitNewInstanceMultiarg(e, constructorInfo);\r\n        emitGetCallback(e, keys);\r\n        emitSetCallback(e, keys);\r\n        emitGetCallbacks(e);\r\n        emitSetCallbacks(e);\r\n    }\r\n    e.end_class();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#filterConstructors(Class,List)",
    "entityType": "method",
    "code": "/**\r\n * Filter the list of constructors from the superclass. The\r\n * constructors which remain will be included in the generated\r\n * class. The default implementation is to filter out all private\r\n * constructors, but subclasses may extend Enhancer to override this\r\n * behavior.\r\n * @param sc the superclass\r\n * @param constructors the list of all declared constructors from the superclass\r\n * @throws IllegalArgumentException if there are no non-private constructors\r\n */\r\nprotected void filterConstructors(Class sc, List constructors) {\r\n    CollectionUtils.filter(constructors, new VisibilityPredicate(sc, true));\r\n    if (constructors.size() == 0) {\r\n        throw new IllegalArgumentException(\"No visible constructors in \" + sc);\r\n    }\r\n}",
    "comment": "\n\t * Filter the list of constructors from the superclass. The\n\t * constructors which remain will be included in the generated\n\t * class. The default implementation is to filter out all private\n\t * constructors, but subclasses may extend Enhancer to override this\n\t * behavior.\n\t * @param sc the superclass\n\t * @param constructors the list of all declared constructors from the superclass\n\t * @throws IllegalArgumentException if there are no non-private constructors\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#firstInstance(Class)",
    "entityType": "method",
    "code": "/**\r\n * This method should not be called in regular flow.\r\n * Technically speaking {@link #wrapCachedClass(Class)} uses {@link Enhancer.EnhancerFactoryData} as a cache value,\r\n * and the latter enables faster instantiation than plain old reflection lookup and invoke.\r\n * This method is left intact for backward compatibility reasons: just in case it was ever used.\r\n * @param type class to instantiate\r\n * @return newly created proxy instance\r\n * @throws Exception if something goes wrong\r\n */\r\n@Override\r\nprotected Object firstInstance(Class type) throws Exception {\r\n    if (classOnly) {\r\n        return type;\r\n    } else {\r\n        return createUsingReflection(type);\r\n    }\r\n}",
    "comment": "\n\t * This method should not be called in regular flow.\n\t * Technically speaking {@link #wrapCachedClass(Class)} uses {@link Enhancer.EnhancerFactoryData} as a cache value,\n\t * and the latter enables faster instantiation than plain old reflection lookup and invoke.\n\t * This method is left intact for backward compatibility reasons: just in case it was ever used.\n\t * @param type class to instantiate\n\t * @return newly created proxy instance\n\t * @throws Exception if something goes wrong\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#nextInstance(Object)",
    "entityType": "method",
    "code": "@Override\r\nprotected Object nextInstance(Object instance) {\r\n    EnhancerFactoryData data = (EnhancerFactoryData) instance;\r\n    if (classOnly) {\r\n        return data.generatedClass;\r\n    }\r\n    Class[] argumentTypes = this.argumentTypes;\r\n    Object[] arguments = this.arguments;\r\n    if (argumentTypes == null) {\r\n        argumentTypes = Constants.EMPTY_CLASS_ARRAY;\r\n        arguments = null;\r\n    }\r\n    return data.newInstance(argumentTypes, arguments, callbacks);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#wrapCachedClass(Class)",
    "entityType": "method",
    "code": "@Override\r\nprotected Object wrapCachedClass(Class klass) {\r\n    Class[] argumentTypes = this.argumentTypes;\r\n    if (argumentTypes == null) {\r\n        argumentTypes = Constants.EMPTY_CLASS_ARRAY;\r\n    }\r\n    EnhancerFactoryData factoryData = new EnhancerFactoryData(klass, argumentTypes, classOnly);\r\n    Field factoryDataField = null;\r\n    try {\r\n        // The subsequent dance is performed just once for each class,\r\n        // so it does not matter much how fast it goes\r\n        factoryDataField = klass.getField(FACTORY_DATA_FIELD);\r\n        factoryDataField.set(null, factoryData);\r\n        Field callbackFilterField = klass.getDeclaredField(CALLBACK_FILTER_FIELD);\r\n        callbackFilterField.setAccessible(true);\r\n        callbackFilterField.set(null, this.filter);\r\n    } catch (NoSuchFieldException | IllegalAccessException e) {\r\n        throw new CodeGenerationException(e);\r\n    }\r\n    return new WeakReference<>(factoryData);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#unwrapCachedValue(Object)",
    "entityType": "method",
    "code": "@Override\r\nprotected Object unwrapCachedValue(Object cached) {\r\n    if (currentKey instanceof EnhancerKey) {\r\n        EnhancerFactoryData data = ((WeakReference<EnhancerFactoryData>) cached).get();\r\n        return data;\r\n    }\r\n    return super.unwrapCachedValue(cached);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#registerCallbacks(Class,Callback[])",
    "entityType": "method",
    "code": "/**\r\n * Call this method to register the {@link Callback} array to use before\r\n * creating a new instance of the generated class via reflection. If you are using\r\n * an instance of <code>Enhancer</code> or the {@link Factory} interface to create\r\n * new instances, this method is unnecessary. Its primary use is for when you want to\r\n * cache and reuse a generated class yourself, and the generated class does\r\n * <i>not</i> implement the {@link Factory} interface.\r\n * <p>\r\n * Note that this method only registers the callbacks on the current thread.\r\n * If you want to register callbacks for instances created by multiple threads,\r\n * use {@link #registerStaticCallbacks}.\r\n * <p>\r\n * The registered callbacks are overwritten and subsequently cleared\r\n * when calling any of the <code>create</code> methods (such as\r\n * {@link #create}), or any {@link Factory} <code>newInstance</code> method.\r\n * Otherwise they are <i>not</i> cleared, and you should be careful to set them\r\n * back to <code>null</code> after creating new instances via reflection if\r\n * memory leakage is a concern.\r\n * @param generatedClass a class previously created by {@link Enhancer}\r\n * @param callbacks the array of callbacks to use when instances of the generated\r\n * class are created\r\n * @see #setUseFactory\r\n */\r\npublic static void registerCallbacks(Class generatedClass, Callback[] callbacks) {\r\n    setThreadCallbacks(generatedClass, callbacks);\r\n}",
    "comment": "\n\t * Call this method to register the {@link Callback} array to use before\n\t * creating a new instance of the generated class via reflection. If you are using\n\t * an instance of <code>Enhancer</code> or the {@link Factory} interface to create\n\t * new instances, this method is unnecessary. Its primary use is for when you want to\n\t * cache and reuse a generated class yourself, and the generated class does\n\t * <i>not</i> implement the {@link Factory} interface.\n\t * <p>\n\t * Note that this method only registers the callbacks on the current thread.\n\t * If you want to register callbacks for instances created by multiple threads,\n\t * use {@link #registerStaticCallbacks}.\n\t * <p>\n\t * The registered callbacks are overwritten and subsequently cleared\n\t * when calling any of the <code>create</code> methods (such as\n\t * {@link #create}), or any {@link Factory} <code>newInstance</code> method.\n\t * Otherwise they are <i>not</i> cleared, and you should be careful to set them\n\t * back to <code>null</code> after creating new instances via reflection if\n\t * memory leakage is a concern.\n\t * @param generatedClass a class previously created by {@link Enhancer}\n\t * @param callbacks the array of callbacks to use when instances of the generated\n\t * class are created\n\t * @see #setUseFactory\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#registerStaticCallbacks(Class,Callback[])",
    "entityType": "method",
    "code": "/**\r\n * Similar to {@link #registerCallbacks}, but suitable for use\r\n * when multiple threads will be creating instances of the generated class.\r\n * The thread-level callbacks will always override the static callbacks.\r\n * Static callbacks are never cleared.\r\n * @param generatedClass a class previously created by {@link Enhancer}\r\n * @param callbacks the array of callbacks to use when instances of the generated\r\n * class are created\r\n */\r\npublic static void registerStaticCallbacks(Class generatedClass, Callback[] callbacks) {\r\n    setCallbacksHelper(generatedClass, callbacks, SET_STATIC_CALLBACKS_NAME);\r\n}",
    "comment": "\n\t * Similar to {@link #registerCallbacks}, but suitable for use\n\t * when multiple threads will be creating instances of the generated class.\n\t * The thread-level callbacks will always override the static callbacks.\n\t * Static callbacks are never cleared.\n\t * @param generatedClass a class previously created by {@link Enhancer}\n\t * @param callbacks the array of callbacks to use when instances of the generated\n\t * class are created\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#isEnhanced(Class)",
    "entityType": "method",
    "code": "/**\r\n * Determine if a class was generated using <code>Enhancer</code>.\r\n * @param type any class\r\n * @return whether the class was generated  using <code>Enhancer</code>\r\n */\r\npublic static boolean isEnhanced(Class type) {\r\n    try {\r\n        getCallbacksSetter(type, SET_THREAD_CALLBACKS_NAME);\r\n        return true;\r\n    } catch (NoSuchMethodException e) {\r\n        return false;\r\n    }\r\n}",
    "comment": "\n\t * Determine if a class was generated using <code>Enhancer</code>.\n\t * @param type any class\n\t * @return whether the class was generated  using <code>Enhancer</code>\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#setThreadCallbacks(Class,Callback[])",
    "entityType": "method",
    "code": "private static void setThreadCallbacks(Class type, Callback[] callbacks) {\r\n    setCallbacksHelper(type, callbacks, SET_THREAD_CALLBACKS_NAME);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#setCallbacksHelper(Class,Callback[],String)",
    "entityType": "method",
    "code": "private static void setCallbacksHelper(Class type, Callback[] callbacks, String methodName) {\r\n    // TODO: optimize\r\n    try {\r\n        Method setter = getCallbacksSetter(type, methodName);\r\n        setter.invoke(null, new Object[] { callbacks });\r\n    } catch (NoSuchMethodException e) {\r\n        throw new IllegalArgumentException(type + \" is not an enhanced class\");\r\n    } catch (IllegalAccessException | InvocationTargetException e) {\r\n        throw new CodeGenerationException(e);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#getCallbacksSetter(Class,String)",
    "entityType": "method",
    "code": "private static Method getCallbacksSetter(Class type, String methodName) throws NoSuchMethodException {\r\n    return type.getDeclaredMethod(methodName, new Class[] { Callback[].class });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#createUsingReflection(Class)",
    "entityType": "method",
    "code": "/**\r\n * Instantiates a proxy instance and assigns callback values.\r\n * Implementation detail: java.lang.reflect instances are not cached, so this method should not\r\n * be used on a hot path.\r\n * This method is used when {@link #setUseCache(boolean)} is set to {@code false}.\r\n * @param type class to instantiate\r\n * @return newly created instance\r\n */\r\nprivate Object createUsingReflection(Class type) {\r\n    setThreadCallbacks(type, callbacks);\r\n    try {\r\n        if (argumentTypes != null) {\r\n            return ReflectUtils.newInstance(type, argumentTypes, arguments);\r\n        } else {\r\n            return ReflectUtils.newInstance(type);\r\n        }\r\n    } finally {\r\n        // clear thread callbacks to allow them to be gc'd\r\n        setThreadCallbacks(type, null);\r\n    }\r\n}",
    "comment": "\n\t * Instantiates a proxy instance and assigns callback values.\n\t * Implementation detail: java.lang.reflect instances are not cached, so this method should not\n\t * be used on a hot path.\n\t * This method is used when {@link #setUseCache(boolean)} is set to {@code false}.\n\t * @param type class to instantiate\n\t * @return newly created instance\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#create(Class,Callback)",
    "entityType": "method",
    "code": "/**\r\n * Helper method to create an intercepted object.\r\n * For finer control over the generated instance, use a new instance of <code>Enhancer</code>\r\n * instead of this static method.\r\n * @param type class to extend or interface to implement\r\n * @param callback the callback to use for all methods\r\n */\r\npublic static Object create(Class type, Callback callback) {\r\n    Enhancer e = new Enhancer();\r\n    e.setSuperclass(type);\r\n    e.setCallback(callback);\r\n    return e.create();\r\n}",
    "comment": "\n\t * Helper method to create an intercepted object.\n\t * For finer control over the generated instance, use a new instance of <code>Enhancer</code>\n\t * instead of this static method.\n\t * @param type class to extend or interface to implement\n\t * @param callback the callback to use for all methods\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#create(Class,Class[],Callback)",
    "entityType": "method",
    "code": "/**\r\n * Helper method to create an intercepted object.\r\n * For finer control over the generated instance, use a new instance of <code>Enhancer</code>\r\n * instead of this static method.\r\n * @param superclass class to extend or interface to implement\r\n * @param interfaces array of interfaces to implement, or null\r\n * @param callback the callback to use for all methods\r\n */\r\npublic static Object create(Class superclass, Class[] interfaces, Callback callback) {\r\n    Enhancer e = new Enhancer();\r\n    e.setSuperclass(superclass);\r\n    e.setInterfaces(interfaces);\r\n    e.setCallback(callback);\r\n    return e.create();\r\n}",
    "comment": "\n\t * Helper method to create an intercepted object.\n\t * For finer control over the generated instance, use a new instance of <code>Enhancer</code>\n\t * instead of this static method.\n\t * @param superclass class to extend or interface to implement\n\t * @param interfaces array of interfaces to implement, or null\n\t * @param callback the callback to use for all methods\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#create(Class,Class[],CallbackFilter,Callback[])",
    "entityType": "method",
    "code": "/**\r\n * Helper method to create an intercepted object.\r\n * For finer control over the generated instance, use a new instance of <code>Enhancer</code>\r\n * instead of this static method.\r\n * @param superclass class to extend or interface to implement\r\n * @param interfaces array of interfaces to implement, or null\r\n * @param filter the callback filter to use when generating a new class\r\n * @param callbacks callback implementations to use for the enhanced object\r\n */\r\npublic static Object create(Class superclass, Class[] interfaces, CallbackFilter filter, Callback[] callbacks) {\r\n    Enhancer e = new Enhancer();\r\n    e.setSuperclass(superclass);\r\n    e.setInterfaces(interfaces);\r\n    e.setCallbackFilter(filter);\r\n    e.setCallbacks(callbacks);\r\n    return e.create();\r\n}",
    "comment": "\n\t * Helper method to create an intercepted object.\n\t * For finer control over the generated instance, use a new instance of <code>Enhancer</code>\n\t * instead of this static method.\n\t * @param superclass class to extend or interface to implement\n\t * @param interfaces array of interfaces to implement, or null\n\t * @param filter the callback filter to use when generating a new class\n\t * @param callbacks callback implementations to use for the enhanced object\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#emitDefaultConstructor(ClassEmitter)",
    "entityType": "method",
    "code": "private void emitDefaultConstructor(ClassEmitter ce) {\r\n    Constructor<Object> declaredConstructor;\r\n    try {\r\n        declaredConstructor = Object.class.getDeclaredConstructor();\r\n    } catch (NoSuchMethodException e) {\r\n        throw new IllegalStateException(\"Object should have default constructor \", e);\r\n    }\r\n    MethodInfo constructor = (MethodInfo) MethodInfoTransformer.getInstance().transform(declaredConstructor);\r\n    CodeEmitter e = EmitUtils.begin_method(ce, constructor, Constants.ACC_PUBLIC);\r\n    e.load_this();\r\n    e.dup();\r\n    Signature sig = constructor.getSignature();\r\n    e.super_invoke_constructor(sig);\r\n    e.return_value();\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#emitConstructors(ClassEmitter,List)",
    "entityType": "method",
    "code": "private void emitConstructors(ClassEmitter ce, List constructors) {\r\n    boolean seenNull = false;\r\n    for (Iterator it = constructors.iterator(); it.hasNext(); ) {\r\n        MethodInfo constructor = (MethodInfo) it.next();\r\n        if (currentData != null && !\"()V\".equals(constructor.getSignature().getDescriptor())) {\r\n            continue;\r\n        }\r\n        CodeEmitter e = EmitUtils.begin_method(ce, constructor, Constants.ACC_PUBLIC);\r\n        e.load_this();\r\n        e.dup();\r\n        e.load_args();\r\n        Signature sig = constructor.getSignature();\r\n        seenNull = seenNull || sig.getDescriptor().equals(\"()V\");\r\n        e.super_invoke_constructor(sig);\r\n        if (currentData == null) {\r\n            e.invoke_static_this(BIND_CALLBACKS);\r\n            if (!interceptDuringConstruction) {\r\n                e.load_this();\r\n                e.push(1);\r\n                e.putfield(CONSTRUCTED_FIELD);\r\n            }\r\n        }\r\n        e.return_value();\r\n        e.end_method();\r\n    }\r\n    if (!classOnly && !seenNull && arguments == null) {\r\n        throw new IllegalArgumentException(\"Superclass has no null constructors but no arguments were given\");\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#getCallbackKeys()",
    "entityType": "method",
    "code": "private int[] getCallbackKeys() {\r\n    int[] keys = new int[callbackTypes.length];\r\n    for (int i = 0; i < callbackTypes.length; i++) {\r\n        keys[i] = i;\r\n    }\r\n    return keys;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#emitGetCallback(ClassEmitter,int[])",
    "entityType": "method",
    "code": "private void emitGetCallback(ClassEmitter ce, int[] keys) {\r\n    final CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, GET_CALLBACK, null);\r\n    e.load_this();\r\n    e.invoke_static_this(BIND_CALLBACKS);\r\n    e.load_this();\r\n    e.load_arg(0);\r\n    e.process_switch(keys, new ProcessSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(int key, Label end) {\r\n            e.getfield(getCallbackField(key));\r\n            e.goTo(end);\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            // stack height\r\n            e.pop();\r\n            e.aconst_null();\r\n        }\r\n    });\r\n    e.return_value();\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#emitSetCallback(ClassEmitter,int[])",
    "entityType": "method",
    "code": "private void emitSetCallback(ClassEmitter ce, int[] keys) {\r\n    final CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, SET_CALLBACK, null);\r\n    e.load_arg(0);\r\n    e.process_switch(keys, new ProcessSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(int key, Label end) {\r\n            e.load_this();\r\n            e.load_arg(1);\r\n            e.checkcast(callbackTypes[key]);\r\n            e.putfield(getCallbackField(key));\r\n            e.goTo(end);\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            // TODO: error?\r\n        }\r\n    });\r\n    e.return_value();\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#emitSetCallbacks(ClassEmitter)",
    "entityType": "method",
    "code": "private void emitSetCallbacks(ClassEmitter ce) {\r\n    CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, SET_CALLBACKS, null);\r\n    e.load_this();\r\n    e.load_arg(0);\r\n    for (int i = 0; i < callbackTypes.length; i++) {\r\n        e.dup2();\r\n        e.aaload(i);\r\n        e.checkcast(callbackTypes[i]);\r\n        e.putfield(getCallbackField(i));\r\n    }\r\n    e.return_value();\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#emitGetCallbacks(ClassEmitter)",
    "entityType": "method",
    "code": "private void emitGetCallbacks(ClassEmitter ce) {\r\n    CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, GET_CALLBACKS, null);\r\n    e.load_this();\r\n    e.invoke_static_this(BIND_CALLBACKS);\r\n    e.load_this();\r\n    e.push(callbackTypes.length);\r\n    e.newarray(CALLBACK);\r\n    for (int i = 0; i < callbackTypes.length; i++) {\r\n        e.dup();\r\n        e.push(i);\r\n        e.load_this();\r\n        e.getfield(getCallbackField(i));\r\n        e.aastore();\r\n    }\r\n    e.return_value();\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#emitNewInstanceCallbacks(ClassEmitter)",
    "entityType": "method",
    "code": "private void emitNewInstanceCallbacks(ClassEmitter ce) {\r\n    CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, NEW_INSTANCE, null);\r\n    Type thisType = getThisType(e);\r\n    e.load_arg(0);\r\n    e.invoke_static(thisType, SET_THREAD_CALLBACKS, false);\r\n    emitCommonNewInstance(e);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#getThisType(CodeEmitter)",
    "entityType": "method",
    "code": "private Type getThisType(CodeEmitter e) {\r\n    if (currentData == null) {\r\n        return e.getClassEmitter().getClassType();\r\n    } else {\r\n        return Type.getType(currentData.generatedClass);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#emitCommonNewInstance(CodeEmitter)",
    "entityType": "method",
    "code": "private void emitCommonNewInstance(CodeEmitter e) {\r\n    Type thisType = getThisType(e);\r\n    e.new_instance(thisType);\r\n    e.dup();\r\n    e.invoke_constructor(thisType);\r\n    e.aconst_null();\r\n    e.invoke_static(thisType, SET_THREAD_CALLBACKS, false);\r\n    e.return_value();\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#emitNewInstanceCallback(ClassEmitter)",
    "entityType": "method",
    "code": "private void emitNewInstanceCallback(ClassEmitter ce) {\r\n    CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, SINGLE_NEW_INSTANCE, null);\r\n    switch(callbackTypes.length) {\r\n        case 0:\r\n            // TODO: make sure Callback is null\r\n            break;\r\n        case 1:\r\n            // for now just make a new array; TODO: optimize\r\n            e.push(1);\r\n            e.newarray(CALLBACK);\r\n            e.dup();\r\n            e.push(0);\r\n            e.load_arg(0);\r\n            e.aastore();\r\n            e.invoke_static(getThisType(e), SET_THREAD_CALLBACKS, false);\r\n            break;\r\n        default:\r\n            e.throw_exception(ILLEGAL_STATE_EXCEPTION, \"More than one callback object required\");\r\n    }\r\n    emitCommonNewInstance(e);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#emitNewInstanceMultiarg(ClassEmitter,List)",
    "entityType": "method",
    "code": "private void emitNewInstanceMultiarg(ClassEmitter ce, List constructors) {\r\n    final CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, MULTIARG_NEW_INSTANCE, null);\r\n    final Type thisType = getThisType(e);\r\n    e.load_arg(2);\r\n    e.invoke_static(thisType, SET_THREAD_CALLBACKS, false);\r\n    e.new_instance(thisType);\r\n    e.dup();\r\n    e.load_arg(0);\r\n    EmitUtils.constructor_switch(e, constructors, new ObjectSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(Object key, Label end) {\r\n            MethodInfo constructor = (MethodInfo) key;\r\n            Type[] types = constructor.getSignature().getArgumentTypes();\r\n            for (int i = 0; i < types.length; i++) {\r\n                e.load_arg(1);\r\n                e.push(i);\r\n                e.aaload();\r\n                e.unbox(types[i]);\r\n            }\r\n            e.invoke_constructor(thisType, constructor.getSignature());\r\n            e.goTo(end);\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            e.throw_exception(ILLEGAL_ARGUMENT_EXCEPTION, \"Constructor not found\");\r\n        }\r\n    });\r\n    e.aconst_null();\r\n    e.invoke_static(thisType, SET_THREAD_CALLBACKS, false);\r\n    e.return_value();\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#emitMethods(ClassEmitter,List,List)",
    "entityType": "method",
    "code": "private void emitMethods(final ClassEmitter ce, List methods, List actualMethods) {\r\n    CallbackGenerator[] generators = CallbackInfo.getGenerators(callbackTypes);\r\n    Map groups = new HashMap();\r\n    final Map indexes = new HashMap();\r\n    final Map originalModifiers = new HashMap();\r\n    final Map positions = CollectionUtils.getIndexMap(methods);\r\n    final Map declToBridge = new HashMap();\r\n    Iterator it1 = methods.iterator();\r\n    Iterator it2 = (actualMethods != null) ? actualMethods.iterator() : null;\r\n    while (it1.hasNext()) {\r\n        MethodInfo method = (MethodInfo) it1.next();\r\n        Method actualMethod = (it2 != null) ? (Method) it2.next() : null;\r\n        int index = filter.accept(actualMethod);\r\n        if (index >= callbackTypes.length) {\r\n            throw new IllegalArgumentException(\"Callback filter returned an index that is too large: \" + index);\r\n        }\r\n        originalModifiers.put(method, (actualMethod != null ? actualMethod.getModifiers() : method.getModifiers()));\r\n        indexes.put(method, index);\r\n        List group = (List) groups.get(generators[index]);\r\n        if (group == null) {\r\n            groups.put(generators[index], group = new ArrayList(methods.size()));\r\n        }\r\n        group.add(method);\r\n        // Optimization: build up a map of Class -> bridge methods in class\r\n        // so that we can look up all the bridge methods in one pass for a class.\r\n        if (TypeUtils.isBridge(actualMethod.getModifiers())) {\r\n            Set bridges = (Set) declToBridge.get(actualMethod.getDeclaringClass());\r\n            if (bridges == null) {\r\n                bridges = new HashSet();\r\n                declToBridge.put(actualMethod.getDeclaringClass(), bridges);\r\n            }\r\n            bridges.add(method.getSignature());\r\n        }\r\n    }\r\n    final Map bridgeToTarget = new BridgeMethodResolver(declToBridge, getClassLoader()).resolveAll();\r\n    Set seenGen = new HashSet();\r\n    CodeEmitter se = ce.getStaticHook();\r\n    se.new_instance(THREAD_LOCAL);\r\n    se.dup();\r\n    se.invoke_constructor(THREAD_LOCAL, CSTRUCT_NULL);\r\n    se.putfield(THREAD_CALLBACKS_FIELD);\r\n    CallbackGenerator.Context context = new CallbackGenerator.Context() {\r\n\r\n        @Override\r\n        public ClassLoader getClassLoader() {\r\n            return Enhancer.this.getClassLoader();\r\n        }\r\n\r\n        @Override\r\n        public int getOriginalModifiers(MethodInfo method) {\r\n            return ((Integer) originalModifiers.get(method)).intValue();\r\n        }\r\n\r\n        @Override\r\n        public int getIndex(MethodInfo method) {\r\n            return ((Integer) indexes.get(method)).intValue();\r\n        }\r\n\r\n        @Override\r\n        public void emitCallback(CodeEmitter e, int index) {\r\n            emitCurrentCallback(e, index);\r\n        }\r\n\r\n        @Override\r\n        public Signature getImplSignature(MethodInfo method) {\r\n            return rename(method.getSignature(), ((Integer) positions.get(method)).intValue());\r\n        }\r\n\r\n        @Override\r\n        public void emitLoadArgsAndInvoke(CodeEmitter e, MethodInfo method) {\r\n            // If this is a bridge and we know the target was called from invokespecial,\r\n            // then we need to invoke_virtual w/ the bridge target instead of doing\r\n            // a super, because super may itself be using super, which would bypass\r\n            // any proxies on the target.\r\n            Signature bridgeTarget = (Signature) bridgeToTarget.get(method.getSignature());\r\n            if (bridgeTarget != null) {\r\n                // checkcast each argument against the target's argument types\r\n                for (int i = 0; i < bridgeTarget.getArgumentTypes().length; i++) {\r\n                    e.load_arg(i);\r\n                    Type target = bridgeTarget.getArgumentTypes()[i];\r\n                    if (!target.equals(method.getSignature().getArgumentTypes()[i])) {\r\n                        e.checkcast(target);\r\n                    }\r\n                }\r\n                e.invoke_virtual_this(bridgeTarget);\r\n                Type retType = method.getSignature().getReturnType();\r\n                // Not necessary to cast if the target & bridge have\r\n                // the same return type.\r\n                // (This conveniently includes void and primitive types,\r\n                // which would fail if casted.  It's not possible to\r\n                // covariant from boxed to unbox (or vice versa), so no having\r\n                // to box/unbox for bridges).\r\n                // TODO: It also isn't necessary to checkcast if the return is\r\n                // assignable from the target.  (This would happen if a subclass\r\n                // used covariant returns to narrow the return type within a bridge\r\n                // method.)\r\n                if (!retType.equals(bridgeTarget.getReturnType())) {\r\n                    e.checkcast(retType);\r\n                }\r\n            } else {\r\n                e.load_args();\r\n                e.super_invoke(method.getSignature());\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public CodeEmitter beginMethod(ClassEmitter ce, MethodInfo method) {\r\n            CodeEmitter e = EmitUtils.begin_method(ce, method);\r\n            if (!interceptDuringConstruction && !TypeUtils.isAbstract(method.getModifiers())) {\r\n                Label constructed = e.make_label();\r\n                e.load_this();\r\n                e.getfield(CONSTRUCTED_FIELD);\r\n                e.if_jump(CodeEmitter.NE, constructed);\r\n                e.load_this();\r\n                e.load_args();\r\n                e.super_invoke();\r\n                e.return_value();\r\n                e.mark(constructed);\r\n            }\r\n            return e;\r\n        }\r\n    };\r\n    for (int i = 0; i < callbackTypes.length; i++) {\r\n        CallbackGenerator gen = generators[i];\r\n        if (!seenGen.contains(gen)) {\r\n            seenGen.add(gen);\r\n            final List fmethods = (List) groups.get(gen);\r\n            if (fmethods != null) {\r\n                try {\r\n                    gen.generate(ce, context, fmethods);\r\n                    gen.generateStatic(se, context, fmethods);\r\n                } catch (RuntimeException x) {\r\n                    throw x;\r\n                } catch (Exception x) {\r\n                    throw new CodeGenerationException(x);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    se.return_value();\r\n    se.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#emitSetThreadCallbacks(ClassEmitter)",
    "entityType": "method",
    "code": "private void emitSetThreadCallbacks(ClassEmitter ce) {\r\n    CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC | Constants.ACC_STATIC, SET_THREAD_CALLBACKS, null);\r\n    e.getfield(THREAD_CALLBACKS_FIELD);\r\n    e.load_arg(0);\r\n    e.invoke_virtual(THREAD_LOCAL, THREAD_LOCAL_SET);\r\n    e.return_value();\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#emitSetStaticCallbacks(ClassEmitter)",
    "entityType": "method",
    "code": "private void emitSetStaticCallbacks(ClassEmitter ce) {\r\n    CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC | Constants.ACC_STATIC, SET_STATIC_CALLBACKS, null);\r\n    e.load_arg(0);\r\n    e.putfield(STATIC_CALLBACKS_FIELD);\r\n    e.return_value();\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#emitCurrentCallback(CodeEmitter,int)",
    "entityType": "method",
    "code": "private void emitCurrentCallback(CodeEmitter e, int index) {\r\n    e.load_this();\r\n    e.getfield(getCallbackField(index));\r\n    e.dup();\r\n    Label end = e.make_label();\r\n    e.ifnonnull(end);\r\n    // stack height\r\n    e.pop();\r\n    e.load_this();\r\n    e.invoke_static_this(BIND_CALLBACKS);\r\n    e.load_this();\r\n    e.getfield(getCallbackField(index));\r\n    e.mark(end);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#emitBindCallbacks(ClassEmitter)",
    "entityType": "method",
    "code": "private void emitBindCallbacks(ClassEmitter ce) {\r\n    CodeEmitter e = ce.begin_method(Constants.PRIVATE_FINAL_STATIC, BIND_CALLBACKS, null);\r\n    Local me = e.make_local();\r\n    e.load_arg(0);\r\n    e.checkcast_this();\r\n    e.store_local(me);\r\n    Label end = e.make_label();\r\n    e.load_local(me);\r\n    e.getfield(BOUND_FIELD);\r\n    e.if_jump(CodeEmitter.NE, end);\r\n    e.load_local(me);\r\n    e.push(1);\r\n    e.putfield(BOUND_FIELD);\r\n    e.getfield(THREAD_CALLBACKS_FIELD);\r\n    e.invoke_virtual(THREAD_LOCAL, THREAD_LOCAL_GET);\r\n    e.dup();\r\n    Label found_callback = e.make_label();\r\n    e.ifnonnull(found_callback);\r\n    e.pop();\r\n    e.getfield(STATIC_CALLBACKS_FIELD);\r\n    e.dup();\r\n    e.ifnonnull(found_callback);\r\n    e.pop();\r\n    e.goTo(end);\r\n    e.mark(found_callback);\r\n    e.checkcast(CALLBACK_ARRAY);\r\n    e.load_local(me);\r\n    e.swap();\r\n    for (int i = callbackTypes.length - 1; i >= 0; i--) {\r\n        if (i != 0) {\r\n            e.dup2();\r\n        }\r\n        e.aaload(i);\r\n        e.checkcast(callbackTypes[i]);\r\n        e.putfield(getCallbackField(i));\r\n    }\r\n    e.mark(end);\r\n    e.return_value();\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Enhancer#getCallbackField(int)",
    "entityType": "method",
    "code": "private static String getCallbackField(int index) {\r\n    return \"CGLIB$CALLBACK_\" + index;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.EnhancerFactoryData",
    "entityType": "class",
    "code": "public final Class generatedClass;\nprivate final Method setThreadCallbacks;\nprivate final Class[] primaryConstructorArgTypes;\nprivate final Constructor primaryConstructor;\npublic EnhancerFactoryData(Class generatedClass, Class[] primaryConstructorArgTypes, boolean classOnly) {\r\n    this.generatedClass = generatedClass;\r\n    try {\r\n        setThreadCallbacks = getCallbacksSetter(generatedClass, SET_THREAD_CALLBACKS_NAME);\r\n        if (classOnly) {\r\n            this.primaryConstructorArgTypes = null;\r\n            this.primaryConstructor = null;\r\n        } else {\r\n            this.primaryConstructorArgTypes = primaryConstructorArgTypes;\r\n            this.primaryConstructor = ReflectUtils.getConstructor(generatedClass, primaryConstructorArgTypes);\r\n        }\r\n    } catch (NoSuchMethodException e) {\r\n        throw new CodeGenerationException(e);\r\n    }\r\n}\n/**\r\n * Creates proxy instance for given argument types, and assigns the callbacks.\r\n * Ideally, for each proxy class, just one set of argument types should be used,\r\n * otherwise it would have to spend time on constructor lookup.\r\n * Technically, it is a re-implementation of {@link Enhancer#createUsingReflection(Class)},\r\n * with \"cache {@link #setThreadCallbacks} and {@link #primaryConstructor}\"\r\n * @param argumentTypes constructor argument types\r\n * @param arguments constructor arguments\r\n * @param callbacks callbacks to set for the new instance\r\n * @return newly created proxy\r\n * @see #createUsingReflection(Class)\r\n */\r\npublic Object newInstance(Class[] argumentTypes, Object[] arguments, Callback[] callbacks) {\r\n    setThreadCallbacks(callbacks);\r\n    try {\r\n        // Explicit reference equality is added here just in case Arrays.equals does not have one\r\n        if (primaryConstructorArgTypes == argumentTypes || Arrays.equals(primaryConstructorArgTypes, argumentTypes)) {\r\n            // If we have relevant Constructor instance at hand, just call it\r\n            // This skips \"get constructors\" machinery\r\n            return ReflectUtils.newInstance(primaryConstructor, arguments);\r\n        }\r\n        // Take a slow path if observing unexpected argument types\r\n        return ReflectUtils.newInstance(generatedClass, argumentTypes, arguments);\r\n    } finally {\r\n        // clear thread callbacks to allow them to be gc'd\r\n        setThreadCallbacks(null);\r\n    }\r\n}\nprivate void setThreadCallbacks(Callback[] callbacks) {\r\n    try {\r\n        setThreadCallbacks.invoke(generatedClass, (Object) callbacks);\r\n    } catch (IllegalAccessException e) {\r\n        throw new CodeGenerationException(e);\r\n    } catch (InvocationTargetException e) {\r\n        throw new CodeGenerationException(e.getTargetException());\r\n    }\r\n}",
    "comment": "\n\t * The idea of the class is to cache relevant java.lang.reflect instances so\n\t * proxy-class can be instantiated faster that when using {@link ReflectUtils#newInstance(Class, Class[], Object[])}\n\t * and {@link Enhancer#setThreadCallbacks(Class, Callback[])}\n\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.EnhancerFactoryData#newInstance(Class[],Object[],Callback[])",
    "entityType": "method",
    "code": "/**\r\n * Creates proxy instance for given argument types, and assigns the callbacks.\r\n * Ideally, for each proxy class, just one set of argument types should be used,\r\n * otherwise it would have to spend time on constructor lookup.\r\n * Technically, it is a re-implementation of {@link Enhancer#createUsingReflection(Class)},\r\n * with \"cache {@link #setThreadCallbacks} and {@link #primaryConstructor}\"\r\n * @param argumentTypes constructor argument types\r\n * @param arguments constructor arguments\r\n * @param callbacks callbacks to set for the new instance\r\n * @return newly created proxy\r\n * @see #createUsingReflection(Class)\r\n */\r\npublic Object newInstance(Class[] argumentTypes, Object[] arguments, Callback[] callbacks) {\r\n    setThreadCallbacks(callbacks);\r\n    try {\r\n        // Explicit reference equality is added here just in case Arrays.equals does not have one\r\n        if (primaryConstructorArgTypes == argumentTypes || Arrays.equals(primaryConstructorArgTypes, argumentTypes)) {\r\n            // If we have relevant Constructor instance at hand, just call it\r\n            // This skips \"get constructors\" machinery\r\n            return ReflectUtils.newInstance(primaryConstructor, arguments);\r\n        }\r\n        // Take a slow path if observing unexpected argument types\r\n        return ReflectUtils.newInstance(generatedClass, argumentTypes, arguments);\r\n    } finally {\r\n        // clear thread callbacks to allow them to be gc'd\r\n        setThreadCallbacks(null);\r\n    }\r\n}",
    "comment": "\n\t\t * Creates proxy instance for given argument types, and assigns the callbacks.\n\t\t * Ideally, for each proxy class, just one set of argument types should be used,\n\t\t * otherwise it would have to spend time on constructor lookup.\n\t\t * Technically, it is a re-implementation of {@link Enhancer#createUsingReflection(Class)},\n\t\t * with \"cache {@link #setThreadCallbacks} and {@link #primaryConstructor}\"\n\t\t * @param argumentTypes constructor argument types\n\t\t * @param arguments constructor arguments\n\t\t * @param callbacks callbacks to set for the new instance\n\t\t * @return newly created proxy\n\t\t * @see #createUsingReflection(Class)\n\t\t "
  },
  {
    "entityId": "org.springframework.cglib.proxy.EnhancerFactoryData#setThreadCallbacks(Callback[])",
    "entityType": "method",
    "code": "private void setThreadCallbacks(Callback[] callbacks) {\r\n    try {\r\n        setThreadCallbacks.invoke(generatedClass, (Object) callbacks);\r\n    } catch (IllegalAccessException e) {\r\n        throw new CodeGenerationException(e);\r\n    } catch (InvocationTargetException e) {\r\n        throw new CodeGenerationException(e.getTargetException());\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.Factory",
    "entityType": "class",
    "code": "/**\r\n * Creates new instance of the same type, using the no-arg constructor.\r\n * The class of this object must have been created using a single Callback type.\r\n * If multiple callbacks are required an exception will be thrown.\r\n * @param callback the new interceptor to use\r\n * @return new instance of the same type\r\n */\r\nObject newInstance(Callback callback);\n/**\r\n * Creates new instance of the same type, using the no-arg constructor.\r\n * @param callbacks the new callbacks(s) to use\r\n * @return new instance of the same type\r\n */\r\nObject newInstance(Callback[] callbacks);\n/**\r\n * Creates a new instance of the same type, using the constructor\r\n * matching the given signature.\r\n * @param types the constructor argument types\r\n * @param args the constructor arguments\r\n * @param callbacks the new interceptor(s) to use\r\n * @return new instance of the same type\r\n */\r\nObject newInstance(Class[] types, Object[] args, Callback[] callbacks);\n/**\r\n * Return the <code>Callback</code> implementation at the specified index.\r\n * @param index the callback index\r\n * @return the callback implementation\r\n */\r\nCallback getCallback(int index);\n/**\r\n * Set the callback for this object for the given type.\r\n * @param index the callback index to replace\r\n * @param callback the new callback\r\n */\r\nvoid setCallback(int index, Callback callback);\n/**\r\n * Replace all of the callbacks for this object at once.\r\n * @param callbacks the new callbacks(s) to use\r\n */\r\nvoid setCallbacks(Callback[] callbacks);\n/**\r\n * Get the current set of callbacks for ths object.\r\n * @return a new array instance\r\n */\r\nCallback[] getCallbacks();",
    "comment": "\n * All enhanced instances returned by the {@link Enhancer} class implement this interface.\n * Using this interface for new instances is faster than going through the <code>Enhancer</code>\n * interface or using reflection. In addition, to intercept methods called during\n * object construction you <b>must</b> use these methods instead of reflection.\n * @author Juozas Baliuka <a href=\"mailto:baliuka@mwm.lt\">baliuka@mwm.lt</a>\n * @version $Id: Factory.java,v 1.13 2004/06/24 21:15:20 herbyderby Exp $\n "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Factory#newInstance(Callback)",
    "entityType": "method",
    "code": "/**\r\n * Creates new instance of the same type, using the no-arg constructor.\r\n * The class of this object must have been created using a single Callback type.\r\n * If multiple callbacks are required an exception will be thrown.\r\n * @param callback the new interceptor to use\r\n * @return new instance of the same type\r\n */\r\nObject newInstance(Callback callback);",
    "comment": "\n     * Creates new instance of the same type, using the no-arg constructor.\n     * The class of this object must have been created using a single Callback type.\n     * If multiple callbacks are required an exception will be thrown.\n     * @param callback the new interceptor to use\n     * @return new instance of the same type\n     "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Factory#newInstance(Callback[])",
    "entityType": "method",
    "code": "/**\r\n * Creates new instance of the same type, using the no-arg constructor.\r\n * @param callbacks the new callbacks(s) to use\r\n * @return new instance of the same type\r\n */\r\nObject newInstance(Callback[] callbacks);",
    "comment": "\n     * Creates new instance of the same type, using the no-arg constructor.\n     * @param callbacks the new callbacks(s) to use\n     * @return new instance of the same type\n     "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Factory#newInstance(Class[],Object[],Callback[])",
    "entityType": "method",
    "code": "/**\r\n * Creates a new instance of the same type, using the constructor\r\n * matching the given signature.\r\n * @param types the constructor argument types\r\n * @param args the constructor arguments\r\n * @param callbacks the new interceptor(s) to use\r\n * @return new instance of the same type\r\n */\r\nObject newInstance(Class[] types, Object[] args, Callback[] callbacks);",
    "comment": "\n     * Creates a new instance of the same type, using the constructor\n     * matching the given signature.\n     * @param types the constructor argument types\n     * @param args the constructor arguments\n     * @param callbacks the new interceptor(s) to use\n     * @return new instance of the same type\n     "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Factory#getCallback(int)",
    "entityType": "method",
    "code": "/**\r\n * Return the <code>Callback</code> implementation at the specified index.\r\n * @param index the callback index\r\n * @return the callback implementation\r\n */\r\nCallback getCallback(int index);",
    "comment": "\n     * Return the <code>Callback</code> implementation at the specified index.\n     * @param index the callback index\n     * @return the callback implementation\n     "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Factory#setCallback(int,Callback)",
    "entityType": "method",
    "code": "/**\r\n * Set the callback for this object for the given type.\r\n * @param index the callback index to replace\r\n * @param callback the new callback\r\n */\r\nvoid setCallback(int index, Callback callback);",
    "comment": "\n     * Set the callback for this object for the given type.\n     * @param index the callback index to replace\n     * @param callback the new callback\n     "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Factory#setCallbacks(Callback[])",
    "entityType": "method",
    "code": "/**\r\n * Replace all of the callbacks for this object at once.\r\n * @param callbacks the new callbacks(s) to use\r\n */\r\nvoid setCallbacks(Callback[] callbacks);",
    "comment": "\n     * Replace all of the callbacks for this object at once.\n     * @param callbacks the new callbacks(s) to use\n     "
  },
  {
    "entityId": "org.springframework.cglib.proxy.Factory#getCallbacks()",
    "entityType": "method",
    "code": "/**\r\n * Get the current set of callbacks for ths object.\r\n * @return a new array instance\r\n */\r\nCallback[] getCallbacks();",
    "comment": "\n     * Get the current set of callbacks for ths object.\n     * @return a new array instance\n     "
  },
  {
    "entityId": "org.springframework.cglib.proxy.FixedValue",
    "entityType": "class",
    "code": "/**\r\n * Return the object which the original method invocation should\r\n * return. This method is called for <b>every</b> method invocation.\r\n * @return an object matching the type of the return value for every\r\n * method this callback is mapped to\r\n */\r\nObject loadObject() throws Exception;",
    "comment": "\n * {@link Enhancer} callback that simply returns the value to return\n * from the proxied method. No information about what method\n * is being called is available to the callback, and the type of\n * the returned object must be compatible with the return type of\n * the proxied method. This makes this callback primarily useful\n * for forcing a particular method (through the use of a {@link CallbackFilter}\n * to return a fixed value with little overhead.\n "
  },
  {
    "entityId": "org.springframework.cglib.proxy.FixedValue#loadObject()",
    "entityType": "method",
    "code": "/**\r\n * Return the object which the original method invocation should\r\n * return. This method is called for <b>every</b> method invocation.\r\n * @return an object matching the type of the return value for every\r\n * method this callback is mapped to\r\n */\r\nObject loadObject() throws Exception;",
    "comment": "\n     * Return the object which the original method invocation should\n     * return. This method is called for <b>every</b> method invocation.\n     * @return an object matching the type of the return value for every\n     * method this callback is mapped to\n     "
  },
  {
    "entityId": "org.springframework.cglib.proxy.FixedValueGenerator",
    "entityType": "class",
    "code": "public static final FixedValueGenerator INSTANCE = new FixedValueGenerator();\nprivate static final Type FIXED_VALUE = TypeUtils.parseType(\"org.springframework.cglib.proxy.FixedValue\");\nprivate static final Signature LOAD_OBJECT = TypeUtils.parseSignature(\"Object loadObject()\");\n@Override\r\npublic void generate(ClassEmitter ce, Context context, List methods) {\r\n    for (Iterator it = methods.iterator(); it.hasNext(); ) {\r\n        MethodInfo method = (MethodInfo) it.next();\r\n        CodeEmitter e = context.beginMethod(ce, method);\r\n        context.emitCallback(e, context.getIndex(method));\r\n        e.invoke_interface(FIXED_VALUE, LOAD_OBJECT);\r\n        e.unbox_or_zero(e.getReturnType());\r\n        e.return_value();\r\n        e.end_method();\r\n    }\r\n}\n@Override\r\npublic void generateStatic(CodeEmitter e, Context context, List methods) ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.FixedValueGenerator#generate(ClassEmitter,Context,List)",
    "entityType": "method",
    "code": "@Override\r\npublic void generate(ClassEmitter ce, Context context, List methods) {\r\n    for (Iterator it = methods.iterator(); it.hasNext(); ) {\r\n        MethodInfo method = (MethodInfo) it.next();\r\n        CodeEmitter e = context.beginMethod(ce, method);\r\n        context.emitCallback(e, context.getIndex(method));\r\n        e.invoke_interface(FIXED_VALUE, LOAD_OBJECT);\r\n        e.unbox_or_zero(e.getReturnType());\r\n        e.return_value();\r\n        e.end_method();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.FixedValueGenerator#generateStatic(CodeEmitter,Context,List)",
    "entityType": "method",
    "code": "@Override\r\npublic void generateStatic(CodeEmitter e, Context context, List methods) ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.proxy.InterfaceMaker",
    "entityType": "class",
    "code": "private static final Source SOURCE = new Source(InterfaceMaker.class.getName());\nprivate Map signatures = new HashMap();\n/**\r\n * Create a new <code>InterfaceMaker</code>. A new <code>InterfaceMaker</code>\r\n * object should be used for each generated interface, and should not\r\n * be shared across threads.\r\n */\r\npublic InterfaceMaker() {\r\n    super(SOURCE);\r\n}\n/**\r\n * Add a method signature to the interface.\r\n * @param sig the method signature to add to the interface\r\n * @param exceptions an array of exception types to declare for the method\r\n */\r\npublic void add(Signature sig, Type[] exceptions) {\r\n    signatures.put(sig, exceptions);\r\n}\n/**\r\n * Add a method signature to the interface. The method modifiers are ignored,\r\n * since interface methods are by definition abstract and public.\r\n * @param method the method to add to the interface\r\n */\r\npublic void add(Method method) {\r\n    add(ReflectUtils.getSignature(method), ReflectUtils.getExceptionTypes(method));\r\n}\n/**\r\n * Add all the public methods in the specified class.\r\n * Methods from superclasses are included, except for methods declared in the base\r\n * Object class (for example, <code>getClass</code>, <code>equals</code>, <code>hashCode</code>).\r\n * @param clazz the class containing the methods to add to the interface\r\n */\r\npublic void add(Class clazz) {\r\n    Method[] methods = clazz.getMethods();\r\n    for (Method m : methods) {\r\n        if (!m.getDeclaringClass().getName().equals(\"java.lang.Object\")) {\r\n            add(m);\r\n        }\r\n    }\r\n}\n/**\r\n * Create an interface using the current set of method signatures.\r\n */\r\npublic Class create() {\r\n    setUseCache(false);\r\n    return (Class) super.create(this);\r\n}\n@Override\r\nprotected ClassLoader getDefaultClassLoader() {\r\n    return null;\r\n}\n@Override\r\nprotected Object firstInstance(Class type) {\r\n    return type;\r\n}\n@Override\r\nprotected Object nextInstance(Object instance) {\r\n    throw new IllegalStateException(\"InterfaceMaker does not cache\");\r\n}\n@Override\r\npublic void generateClass(ClassVisitor v) throws Exception {\r\n    ClassEmitter ce = new ClassEmitter(v);\r\n    ce.begin_class(Constants.V1_8, Constants.ACC_PUBLIC | Constants.ACC_INTERFACE | Constants.ACC_ABSTRACT, getClassName(), null, null, Constants.SOURCE_FILE);\r\n    for (Iterator it = signatures.keySet().iterator(); it.hasNext(); ) {\r\n        Signature sig = (Signature) it.next();\r\n        Type[] exceptions = (Type[]) signatures.get(sig);\r\n        ce.begin_method(Constants.ACC_PUBLIC | Constants.ACC_ABSTRACT, sig, exceptions).end_method();\r\n    }\r\n    ce.end_class();\r\n}",
    "comment": "\n * Generates new interfaces at runtime.\n * By passing a generated interface to the Enhancer's list of interfaces to\n * implement, you can make your enhanced classes handle an arbitrary set\n * of method signatures.\n * @author Chris Nokleberg\n * @version $Id: InterfaceMaker.java,v 1.4 2006/03/05 02:43:19 herbyderby Exp $\n "
  },
  {
    "entityId": "org.springframework.cglib.proxy.InterfaceMaker#add(Signature,Type[])",
    "entityType": "method",
    "code": "/**\r\n * Add a method signature to the interface.\r\n * @param sig the method signature to add to the interface\r\n * @param exceptions an array of exception types to declare for the method\r\n */\r\npublic void add(Signature sig, Type[] exceptions) {\r\n    signatures.put(sig, exceptions);\r\n}",
    "comment": "\n     * Add a method signature to the interface.\n     * @param sig the method signature to add to the interface\n     * @param exceptions an array of exception types to declare for the method\n     "
  },
  {
    "entityId": "org.springframework.cglib.proxy.InterfaceMaker#add(Method)",
    "entityType": "method",
    "code": "/**\r\n * Add a method signature to the interface. The method modifiers are ignored,\r\n * since interface methods are by definition abstract and public.\r\n * @param method the method to add to the interface\r\n */\r\npublic void add(Method method) {\r\n    add(ReflectUtils.getSignature(method), ReflectUtils.getExceptionTypes(method));\r\n}",
    "comment": "\n     * Add a method signature to the interface. The method modifiers are ignored,\n     * since interface methods are by definition abstract and public.\n     * @param method the method to add to the interface\n     "
  },
  {
    "entityId": "org.springframework.cglib.proxy.InterfaceMaker#add(Class)",
    "entityType": "method",
    "code": "/**\r\n * Add all the public methods in the specified class.\r\n * Methods from superclasses are included, except for methods declared in the base\r\n * Object class (for example, <code>getClass</code>, <code>equals</code>, <code>hashCode</code>).\r\n * @param clazz the class containing the methods to add to the interface\r\n */\r\npublic void add(Class clazz) {\r\n    Method[] methods = clazz.getMethods();\r\n    for (Method m : methods) {\r\n        if (!m.getDeclaringClass().getName().equals(\"java.lang.Object\")) {\r\n            add(m);\r\n        }\r\n    }\r\n}",
    "comment": "\n     * Add all the public methods in the specified class.\n     * Methods from superclasses are included, except for methods declared in the base\n     * Object class (for example, <code>getClass</code>, <code>equals</code>, <code>hashCode</code>).\n     * @param clazz the class containing the methods to add to the interface\n     "
  },
  {
    "entityId": "org.springframework.cglib.proxy.InterfaceMaker#create()",
    "entityType": "method",
    "code": "/**\r\n * Create an interface using the current set of method signatures.\r\n */\r\npublic Class create() {\r\n    setUseCache(false);\r\n    return (Class) super.create(this);\r\n}",
    "comment": "\n     * Create an interface using the current set of method signatures.\n     "
  },
  {
    "entityId": "org.springframework.cglib.proxy.InterfaceMaker#getDefaultClassLoader()",
    "entityType": "method",
    "code": "@Override\r\nprotected ClassLoader getDefaultClassLoader() {\r\n    return null;\r\n}",
    "comment": ""
  }
]