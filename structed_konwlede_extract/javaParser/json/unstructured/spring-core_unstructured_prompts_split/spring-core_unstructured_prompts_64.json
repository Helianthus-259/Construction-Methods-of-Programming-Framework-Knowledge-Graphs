[
  {
    "entityId": "org.springframework.core.io.ProtocolResolver",
    "entityType": "class",
    "code": "/**\r\n * Resolve the given location against the given resource loader\r\n * if this implementation's protocol matches.\r\n * @param location the user-specified resource location\r\n * @param resourceLoader the associated resource loader\r\n * @return a corresponding {@code Resource} handle if the given location\r\n * matches this resolver's protocol, or {@code null} otherwise\r\n */\r\n@Nullable\r\nResource resolve(String location, ResourceLoader resourceLoader);",
    "comment": "\n * A resolution strategy for protocol-specific resource handles.\n *\n * <p>Used as an SPI for {@link DefaultResourceLoader}, allowing for\n * custom protocols to be handled without subclassing the loader\n * implementation (or application context implementation).\n *\n * @author Juergen Hoeller\n * @since 4.3\n * @see DefaultResourceLoader#addProtocolResolver\n "
  },
  {
    "entityId": "org.springframework.core.io.ProtocolResolver#resolve(String,ResourceLoader)",
    "entityType": "method",
    "code": "/**\r\n * Resolve the given location against the given resource loader\r\n * if this implementation's protocol matches.\r\n * @param location the user-specified resource location\r\n * @param resourceLoader the associated resource loader\r\n * @return a corresponding {@code Resource} handle if the given location\r\n * matches this resolver's protocol, or {@code null} otherwise\r\n */\r\n@Nullable\r\nResource resolve(String location, ResourceLoader resourceLoader);",
    "comment": "\n\t * Resolve the given location against the given resource loader\n\t * if this implementation's protocol matches.\n\t * @param location the user-specified resource location\n\t * @param resourceLoader the associated resource loader\n\t * @return a corresponding {@code Resource} handle if the given location\n\t * matches this resolver's protocol, or {@code null} otherwise\n\t "
  },
  {
    "entityId": "org.springframework.core.io.Resource",
    "entityType": "class",
    "code": "/**\r\n * Determine whether this resource actually exists in physical form.\r\n * <p>This method performs a definitive existence check, whereas the\r\n * existence of a {@code Resource} handle only guarantees a valid\r\n * descriptor handle.\r\n */\r\nboolean exists();\n/**\r\n * Indicate whether non-empty contents of this resource can be read via\r\n * {@link #getInputStream()}.\r\n * <p>Will be {@code true} for typical resource descriptors that exist\r\n * since it strictly implies {@link #exists()} semantics as of 5.1.\r\n * Note that actual content reading may still fail when attempted.\r\n * However, a value of {@code false} is a definitive indication\r\n * that the resource content cannot be read.\r\n * @see #getInputStream()\r\n * @see #exists()\r\n */\r\ndefault boolean isReadable() {\r\n    return exists();\r\n}\n/**\r\n * Indicate whether this resource represents a handle with an open stream.\r\n * If {@code true}, the InputStream cannot be read multiple times,\r\n * and must be read and closed to avoid resource leaks.\r\n * <p>Will be {@code false} for typical resource descriptors.\r\n */\r\ndefault boolean isOpen() {\r\n    return false;\r\n}\n/**\r\n * Determine whether this resource represents a file in a file system.\r\n * <p>A value of {@code true} strongly suggests (but does not guarantee)\r\n * that a {@link #getFile()} call will succeed.\r\n * <p>This is conservatively {@code false} by default.\r\n * @since 5.0\r\n * @see #getFile()\r\n */\r\ndefault boolean isFile() {\r\n    return false;\r\n}\n/**\r\n * Return a URL handle for this resource.\r\n * @throws IOException if the resource cannot be resolved as URL,\r\n * i.e. if the resource is not available as a descriptor\r\n */\r\nURL getURL() throws IOException;\n/**\r\n * Return a URI handle for this resource.\r\n * @throws IOException if the resource cannot be resolved as URI,\r\n * i.e. if the resource is not available as a descriptor\r\n * @since 2.5\r\n */\r\nURI getURI() throws IOException;\n/**\r\n * Return a File handle for this resource.\r\n * @throws java.io.FileNotFoundException if the resource cannot be resolved as\r\n * absolute file path, i.e. if the resource is not available in a file system\r\n * @throws IOException in case of general resolution/reading failures\r\n * @see #getInputStream()\r\n */\r\nFile getFile() throws IOException;\n/**\r\n * Return a {@link ReadableByteChannel}.\r\n * <p>It is expected that each call creates a <i>fresh</i> channel.\r\n * <p>The default implementation returns {@link Channels#newChannel(InputStream)}\r\n * with the result of {@link #getInputStream()}.\r\n * @return the byte channel for the underlying resource (must not be {@code null})\r\n * @throws java.io.FileNotFoundException if the underlying resource doesn't exist\r\n * @throws IOException if the content channel could not be opened\r\n * @since 5.0\r\n * @see #getInputStream()\r\n */\r\ndefault ReadableByteChannel readableChannel() throws IOException {\r\n    return Channels.newChannel(getInputStream());\r\n}\n/**\r\n * Return the contents of this resource as a byte array.\r\n * @return the contents of this resource as byte array\r\n * @throws java.io.FileNotFoundException if the resource cannot be resolved as\r\n * absolute file path, i.e. if the resource is not available in a file system\r\n * @throws IOException in case of general resolution/reading failures\r\n * @since 6.0.5\r\n */\r\ndefault byte[] getContentAsByteArray() throws IOException {\r\n    return FileCopyUtils.copyToByteArray(getInputStream());\r\n}\n/**\r\n * Return the contents of this resource as a string, using the specified charset.\r\n * @param charset the charset to use for decoding\r\n * @return the contents of this resource as a {@code String}\r\n * @throws java.io.FileNotFoundException if the resource cannot be resolved as\r\n * absolute file path, i.e. if the resource is not available in a file system\r\n * @throws IOException in case of general resolution/reading failures\r\n * @since 6.0.5\r\n */\r\ndefault String getContentAsString(Charset charset) throws IOException {\r\n    return FileCopyUtils.copyToString(new InputStreamReader(getInputStream(), charset));\r\n}\n/**\r\n * Determine the content length for this resource.\r\n * @throws IOException if the resource cannot be resolved\r\n * (in the file system or as some other known physical resource type)\r\n */\r\nlong contentLength() throws IOException;\n/**\r\n * Determine the last-modified timestamp for this resource.\r\n * @throws IOException if the resource cannot be resolved\r\n * (in the file system or as some other known physical resource type)\r\n */\r\nlong lastModified() throws IOException;\n/**\r\n * Create a resource relative to this resource.\r\n * @param relativePath the relative path (relative to this resource)\r\n * @return the resource handle for the relative resource\r\n * @throws IOException if the relative resource cannot be determined\r\n */\r\nResource createRelative(String relativePath) throws IOException;\n/**\r\n * Determine the filename for this resource &mdash; typically the last\r\n * part of the path &mdash; for example, {@code \"myfile.txt\"}.\r\n * <p>Returns {@code null} if this type of resource does not\r\n * have a filename.\r\n * <p>Implementations are encouraged to return the filename unencoded.\r\n */\r\n@Nullable\r\nString getFilename();\n/**\r\n * Return a description for this resource,\r\n * to be used for error output when working with the resource.\r\n * <p>Implementations are also encouraged to return this value\r\n * from their {@code toString} method.\r\n * @see Object#toString()\r\n */\r\nString getDescription();",
    "comment": "\n * Interface for a resource descriptor that abstracts from the actual\n * type of underlying resource, such as a file or class path resource.\n *\n * <p>An InputStream can be opened for every resource if it exists in\n * physical form, but a URL or File handle can just be returned for\n * certain resources. The actual behavior is implementation-specific.\n *\n * @author Juergen Hoeller\n * @author Arjen Poutsma\n * @since 28.12.2003\n * @see #getInputStream()\n * @see #getURL()\n * @see #getURI()\n * @see #getFile()\n * @see WritableResource\n * @see ContextResource\n * @see UrlResource\n * @see FileUrlResource\n * @see FileSystemResource\n * @see ClassPathResource\n * @see ByteArrayResource\n * @see InputStreamResource\n "
  },
  {
    "entityId": "org.springframework.core.io.Resource#exists()",
    "entityType": "method",
    "code": "/**\r\n * Determine whether this resource actually exists in physical form.\r\n * <p>This method performs a definitive existence check, whereas the\r\n * existence of a {@code Resource} handle only guarantees a valid\r\n * descriptor handle.\r\n */\r\nboolean exists();",
    "comment": "\n\t * Determine whether this resource actually exists in physical form.\n\t * <p>This method performs a definitive existence check, whereas the\n\t * existence of a {@code Resource} handle only guarantees a valid\n\t * descriptor handle.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.Resource#isReadable()",
    "entityType": "method",
    "code": "/**\r\n * Indicate whether non-empty contents of this resource can be read via\r\n * {@link #getInputStream()}.\r\n * <p>Will be {@code true} for typical resource descriptors that exist\r\n * since it strictly implies {@link #exists()} semantics as of 5.1.\r\n * Note that actual content reading may still fail when attempted.\r\n * However, a value of {@code false} is a definitive indication\r\n * that the resource content cannot be read.\r\n * @see #getInputStream()\r\n * @see #exists()\r\n */\r\ndefault boolean isReadable() {\r\n    return exists();\r\n}",
    "comment": "\n\t * Indicate whether non-empty contents of this resource can be read via\n\t * {@link #getInputStream()}.\n\t * <p>Will be {@code true} for typical resource descriptors that exist\n\t * since it strictly implies {@link #exists()} semantics as of 5.1.\n\t * Note that actual content reading may still fail when attempted.\n\t * However, a value of {@code false} is a definitive indication\n\t * that the resource content cannot be read.\n\t * @see #getInputStream()\n\t * @see #exists()\n\t "
  },
  {
    "entityId": "org.springframework.core.io.Resource#isOpen()",
    "entityType": "method",
    "code": "/**\r\n * Indicate whether this resource represents a handle with an open stream.\r\n * If {@code true}, the InputStream cannot be read multiple times,\r\n * and must be read and closed to avoid resource leaks.\r\n * <p>Will be {@code false} for typical resource descriptors.\r\n */\r\ndefault boolean isOpen() {\r\n    return false;\r\n}",
    "comment": "\n\t * Indicate whether this resource represents a handle with an open stream.\n\t * If {@code true}, the InputStream cannot be read multiple times,\n\t * and must be read and closed to avoid resource leaks.\n\t * <p>Will be {@code false} for typical resource descriptors.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.Resource#isFile()",
    "entityType": "method",
    "code": "/**\r\n * Determine whether this resource represents a file in a file system.\r\n * <p>A value of {@code true} strongly suggests (but does not guarantee)\r\n * that a {@link #getFile()} call will succeed.\r\n * <p>This is conservatively {@code false} by default.\r\n * @since 5.0\r\n * @see #getFile()\r\n */\r\ndefault boolean isFile() {\r\n    return false;\r\n}",
    "comment": "\n\t * Determine whether this resource represents a file in a file system.\n\t * <p>A value of {@code true} strongly suggests (but does not guarantee)\n\t * that a {@link #getFile()} call will succeed.\n\t * <p>This is conservatively {@code false} by default.\n\t * @since 5.0\n\t * @see #getFile()\n\t "
  },
  {
    "entityId": "org.springframework.core.io.Resource#getURL()",
    "entityType": "method",
    "code": "/**\r\n * Return a URL handle for this resource.\r\n * @throws IOException if the resource cannot be resolved as URL,\r\n * i.e. if the resource is not available as a descriptor\r\n */\r\nURL getURL() throws IOException;",
    "comment": "\n\t * Return a URL handle for this resource.\n\t * @throws IOException if the resource cannot be resolved as URL,\n\t * i.e. if the resource is not available as a descriptor\n\t "
  },
  {
    "entityId": "org.springframework.core.io.Resource#getURI()",
    "entityType": "method",
    "code": "/**\r\n * Return a URI handle for this resource.\r\n * @throws IOException if the resource cannot be resolved as URI,\r\n * i.e. if the resource is not available as a descriptor\r\n * @since 2.5\r\n */\r\nURI getURI() throws IOException;",
    "comment": "\n\t * Return a URI handle for this resource.\n\t * @throws IOException if the resource cannot be resolved as URI,\n\t * i.e. if the resource is not available as a descriptor\n\t * @since 2.5\n\t "
  },
  {
    "entityId": "org.springframework.core.io.Resource#getFile()",
    "entityType": "method",
    "code": "/**\r\n * Return a File handle for this resource.\r\n * @throws java.io.FileNotFoundException if the resource cannot be resolved as\r\n * absolute file path, i.e. if the resource is not available in a file system\r\n * @throws IOException in case of general resolution/reading failures\r\n * @see #getInputStream()\r\n */\r\nFile getFile() throws IOException;",
    "comment": "\n\t * Return a File handle for this resource.\n\t * @throws java.io.FileNotFoundException if the resource cannot be resolved as\n\t * absolute file path, i.e. if the resource is not available in a file system\n\t * @throws IOException in case of general resolution/reading failures\n\t * @see #getInputStream()\n\t "
  },
  {
    "entityId": "org.springframework.core.io.Resource#readableChannel()",
    "entityType": "method",
    "code": "/**\r\n * Return a {@link ReadableByteChannel}.\r\n * <p>It is expected that each call creates a <i>fresh</i> channel.\r\n * <p>The default implementation returns {@link Channels#newChannel(InputStream)}\r\n * with the result of {@link #getInputStream()}.\r\n * @return the byte channel for the underlying resource (must not be {@code null})\r\n * @throws java.io.FileNotFoundException if the underlying resource doesn't exist\r\n * @throws IOException if the content channel could not be opened\r\n * @since 5.0\r\n * @see #getInputStream()\r\n */\r\ndefault ReadableByteChannel readableChannel() throws IOException {\r\n    return Channels.newChannel(getInputStream());\r\n}",
    "comment": "\n\t * Return a {@link ReadableByteChannel}.\n\t * <p>It is expected that each call creates a <i>fresh</i> channel.\n\t * <p>The default implementation returns {@link Channels#newChannel(InputStream)}\n\t * with the result of {@link #getInputStream()}.\n\t * @return the byte channel for the underlying resource (must not be {@code null})\n\t * @throws java.io.FileNotFoundException if the underlying resource doesn't exist\n\t * @throws IOException if the content channel could not be opened\n\t * @since 5.0\n\t * @see #getInputStream()\n\t "
  },
  {
    "entityId": "org.springframework.core.io.Resource#getContentAsByteArray()",
    "entityType": "method",
    "code": "/**\r\n * Return the contents of this resource as a byte array.\r\n * @return the contents of this resource as byte array\r\n * @throws java.io.FileNotFoundException if the resource cannot be resolved as\r\n * absolute file path, i.e. if the resource is not available in a file system\r\n * @throws IOException in case of general resolution/reading failures\r\n * @since 6.0.5\r\n */\r\ndefault byte[] getContentAsByteArray() throws IOException {\r\n    return FileCopyUtils.copyToByteArray(getInputStream());\r\n}",
    "comment": "\n\t * Return the contents of this resource as a byte array.\n\t * @return the contents of this resource as byte array\n\t * @throws java.io.FileNotFoundException if the resource cannot be resolved as\n\t * absolute file path, i.e. if the resource is not available in a file system\n\t * @throws IOException in case of general resolution/reading failures\n\t * @since 6.0.5\n\t "
  },
  {
    "entityId": "org.springframework.core.io.Resource#getContentAsString(Charset)",
    "entityType": "method",
    "code": "/**\r\n * Return the contents of this resource as a string, using the specified charset.\r\n * @param charset the charset to use for decoding\r\n * @return the contents of this resource as a {@code String}\r\n * @throws java.io.FileNotFoundException if the resource cannot be resolved as\r\n * absolute file path, i.e. if the resource is not available in a file system\r\n * @throws IOException in case of general resolution/reading failures\r\n * @since 6.0.5\r\n */\r\ndefault String getContentAsString(Charset charset) throws IOException {\r\n    return FileCopyUtils.copyToString(new InputStreamReader(getInputStream(), charset));\r\n}",
    "comment": "\n\t * Return the contents of this resource as a string, using the specified charset.\n\t * @param charset the charset to use for decoding\n\t * @return the contents of this resource as a {@code String}\n\t * @throws java.io.FileNotFoundException if the resource cannot be resolved as\n\t * absolute file path, i.e. if the resource is not available in a file system\n\t * @throws IOException in case of general resolution/reading failures\n\t * @since 6.0.5\n\t "
  },
  {
    "entityId": "org.springframework.core.io.Resource#contentLength()",
    "entityType": "method",
    "code": "/**\r\n * Determine the content length for this resource.\r\n * @throws IOException if the resource cannot be resolved\r\n * (in the file system or as some other known physical resource type)\r\n */\r\nlong contentLength() throws IOException;",
    "comment": "\n\t * Determine the content length for this resource.\n\t * @throws IOException if the resource cannot be resolved\n\t * (in the file system or as some other known physical resource type)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.Resource#lastModified()",
    "entityType": "method",
    "code": "/**\r\n * Determine the last-modified timestamp for this resource.\r\n * @throws IOException if the resource cannot be resolved\r\n * (in the file system or as some other known physical resource type)\r\n */\r\nlong lastModified() throws IOException;",
    "comment": "\n\t * Determine the last-modified timestamp for this resource.\n\t * @throws IOException if the resource cannot be resolved\n\t * (in the file system or as some other known physical resource type)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.Resource#createRelative(String)",
    "entityType": "method",
    "code": "/**\r\n * Create a resource relative to this resource.\r\n * @param relativePath the relative path (relative to this resource)\r\n * @return the resource handle for the relative resource\r\n * @throws IOException if the relative resource cannot be determined\r\n */\r\nResource createRelative(String relativePath) throws IOException;",
    "comment": "\n\t * Create a resource relative to this resource.\n\t * @param relativePath the relative path (relative to this resource)\n\t * @return the resource handle for the relative resource\n\t * @throws IOException if the relative resource cannot be determined\n\t "
  },
  {
    "entityId": "org.springframework.core.io.Resource#getFilename()",
    "entityType": "method",
    "code": "/**\r\n * Determine the filename for this resource &mdash; typically the last\r\n * part of the path &mdash; for example, {@code \"myfile.txt\"}.\r\n * <p>Returns {@code null} if this type of resource does not\r\n * have a filename.\r\n * <p>Implementations are encouraged to return the filename unencoded.\r\n */\r\n@Nullable\r\nString getFilename();",
    "comment": "\n\t * Determine the filename for this resource &mdash; typically the last\n\t * part of the path &mdash; for example, {@code \"myfile.txt\"}.\n\t * <p>Returns {@code null} if this type of resource does not\n\t * have a filename.\n\t * <p>Implementations are encouraged to return the filename unencoded.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.Resource#getDescription()",
    "entityType": "method",
    "code": "/**\r\n * Return a description for this resource,\r\n * to be used for error output when working with the resource.\r\n * <p>Implementations are also encouraged to return this value\r\n * from their {@code toString} method.\r\n * @see Object#toString()\r\n */\r\nString getDescription();",
    "comment": "\n\t * Return a description for this resource,\n\t * to be used for error output when working with the resource.\n\t * <p>Implementations are also encouraged to return this value\n\t * from their {@code toString} method.\n\t * @see Object#toString()\n\t "
  },
  {
    "entityId": "org.springframework.core.io.ResourceEditor",
    "entityType": "class",
    "code": "private final ResourceLoader resourceLoader;\n@Nullable\r\nprivate PropertyResolver propertyResolver;\nprivate final boolean ignoreUnresolvablePlaceholders;\n/**\r\n * Create a new instance of the {@link ResourceEditor} class\r\n * using a {@link DefaultResourceLoader} and {@link StandardEnvironment}.\r\n */\r\npublic ResourceEditor() {\r\n    this(new DefaultResourceLoader(), null);\r\n}\n/**\r\n * Create a new instance of the {@link ResourceEditor} class\r\n * using the given {@link ResourceLoader} and {@link PropertyResolver}.\r\n * @param resourceLoader the {@code ResourceLoader} to use\r\n * @param propertyResolver the {@code PropertyResolver} to use\r\n */\r\npublic ResourceEditor(ResourceLoader resourceLoader, @Nullable PropertyResolver propertyResolver) {\r\n    this(resourceLoader, propertyResolver, true);\r\n}\n/**\r\n * Create a new instance of the {@link ResourceEditor} class\r\n * using the given {@link ResourceLoader}.\r\n * @param resourceLoader the {@code ResourceLoader} to use\r\n * @param propertyResolver the {@code PropertyResolver} to use\r\n * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholders\r\n * if no corresponding property could be found in the given {@code propertyResolver}\r\n */\r\npublic ResourceEditor(ResourceLoader resourceLoader, @Nullable PropertyResolver propertyResolver, boolean ignoreUnresolvablePlaceholders) {\r\n    Assert.notNull(resourceLoader, \"ResourceLoader must not be null\");\r\n    this.resourceLoader = resourceLoader;\r\n    this.propertyResolver = propertyResolver;\r\n    this.ignoreUnresolvablePlaceholders = ignoreUnresolvablePlaceholders;\r\n}\n@Override\r\npublic void setAsText(String text) {\r\n    if (StringUtils.hasText(text)) {\r\n        String locationToUse = resolvePath(text).trim();\r\n        setValue(this.resourceLoader.getResource(locationToUse));\r\n    } else {\r\n        setValue(null);\r\n    }\r\n}\n/**\r\n * Resolve the given path, replacing placeholders with corresponding\r\n * property values from the {@code environment} if necessary.\r\n * @param path the original file path\r\n * @return the resolved file path\r\n * @see PropertyResolver#resolvePlaceholders\r\n * @see PropertyResolver#resolveRequiredPlaceholders\r\n */\r\nprotected String resolvePath(String path) {\r\n    if (this.propertyResolver == null) {\r\n        this.propertyResolver = new StandardEnvironment();\r\n    }\r\n    return (this.ignoreUnresolvablePlaceholders ? this.propertyResolver.resolvePlaceholders(path) : this.propertyResolver.resolveRequiredPlaceholders(path));\r\n}\n@Override\r\n@Nullable\r\npublic String getAsText() {\r\n    Resource value = (Resource) getValue();\r\n    try {\r\n        // Try to determine URL for resource.\r\n        return (value != null ? value.getURL().toExternalForm() : \"\");\r\n    } catch (IOException ex) {\r\n        // Couldn't determine resource URL - return null to indicate\r\n        // that there is no appropriate text representation.\r\n        return null;\r\n    }\r\n}",
    "comment": "\n * {@link java.beans.PropertyEditor Editor} for {@link Resource}\n * descriptors, to automatically convert {@code String} locations\n * for example, {@code file:C:/myfile.txt} or {@code classpath:myfile.txt} to\n * {@code Resource} properties instead of using a {@code String} location property.\n *\n * <p>The path may contain {@code ${...}} placeholders, to be\n * resolved as {@link org.springframework.core.env.Environment} properties:\n * for example, {@code ${user.dir}}. Unresolvable placeholders are ignored by default.\n *\n * <p>Delegates to a {@link ResourceLoader} to do the heavy lifting,\n * by default using a {@link DefaultResourceLoader}.\n *\n * @author Juergen Hoeller\n * @author Dave Syer\n * @author Chris Beams\n * @since 28.12.2003\n * @see Resource\n * @see ResourceLoader\n * @see DefaultResourceLoader\n * @see PropertyResolver#resolvePlaceholders\n "
  },
  {
    "entityId": "org.springframework.core.io.ResourceEditor#setAsText(String)",
    "entityType": "method",
    "code": "@Override\r\npublic void setAsText(String text) {\r\n    if (StringUtils.hasText(text)) {\r\n        String locationToUse = resolvePath(text).trim();\r\n        setValue(this.resourceLoader.getResource(locationToUse));\r\n    } else {\r\n        setValue(null);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.ResourceEditor#resolvePath(String)",
    "entityType": "method",
    "code": "/**\r\n * Resolve the given path, replacing placeholders with corresponding\r\n * property values from the {@code environment} if necessary.\r\n * @param path the original file path\r\n * @return the resolved file path\r\n * @see PropertyResolver#resolvePlaceholders\r\n * @see PropertyResolver#resolveRequiredPlaceholders\r\n */\r\nprotected String resolvePath(String path) {\r\n    if (this.propertyResolver == null) {\r\n        this.propertyResolver = new StandardEnvironment();\r\n    }\r\n    return (this.ignoreUnresolvablePlaceholders ? this.propertyResolver.resolvePlaceholders(path) : this.propertyResolver.resolveRequiredPlaceholders(path));\r\n}",
    "comment": "\n\t * Resolve the given path, replacing placeholders with corresponding\n\t * property values from the {@code environment} if necessary.\n\t * @param path the original file path\n\t * @return the resolved file path\n\t * @see PropertyResolver#resolvePlaceholders\n\t * @see PropertyResolver#resolveRequiredPlaceholders\n\t "
  },
  {
    "entityId": "org.springframework.core.io.ResourceEditor#getAsText()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic String getAsText() {\r\n    Resource value = (Resource) getValue();\r\n    try {\r\n        // Try to determine URL for resource.\r\n        return (value != null ? value.getURL().toExternalForm() : \"\");\r\n    } catch (IOException ex) {\r\n        // Couldn't determine resource URL - return null to indicate\r\n        // that there is no appropriate text representation.\r\n        return null;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.ResourceLoader",
    "entityType": "class",
    "code": "/**\r\n * Pseudo URL prefix for loading from the class path: \"classpath:\".\r\n */\r\nString CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX;\n/**\r\n * Return a {@code Resource} handle for the specified resource location.\r\n * <p>The handle should always be a reusable resource descriptor,\r\n * allowing for multiple {@link Resource#getInputStream()} calls.\r\n * <p><ul>\r\n * <li>Must support fully qualified URLs, for example, \"file:C:/test.dat\".\r\n * <li>Must support classpath pseudo-URLs, for example, \"classpath:test.dat\".\r\n * <li>Should support relative file paths, for example, \"WEB-INF/test.dat\".\r\n * (This will be implementation-specific, typically provided by an\r\n * ApplicationContext implementation.)\r\n * </ul>\r\n * <p>Note that a {@code Resource} handle does not imply an existing resource;\r\n * you need to invoke {@link Resource#exists} to check for existence.\r\n * @param location the resource location\r\n * @return a corresponding {@code Resource} handle (never {@code null})\r\n * @see #CLASSPATH_URL_PREFIX\r\n * @see Resource#exists()\r\n * @see Resource#getInputStream()\r\n */\r\nResource getResource(String location);\n/**\r\n * Expose the {@link ClassLoader} used by this {@code ResourceLoader}.\r\n * <p>Clients which need to access the {@code ClassLoader} directly can do so\r\n * in a uniform manner with the {@code ResourceLoader}, rather than relying\r\n * on the thread context {@code ClassLoader}.\r\n * @return the {@code ClassLoader}\r\n * (only {@code null} if even the system {@code ClassLoader} isn't accessible)\r\n * @see org.springframework.util.ClassUtils#getDefaultClassLoader()\r\n * @see org.springframework.util.ClassUtils#forName(String, ClassLoader)\r\n */\r\n@Nullable\r\nClassLoader getClassLoader();",
    "comment": "\n * Strategy interface for loading resources (for example, class path or file system\n * resources). An {@link org.springframework.context.ApplicationContext}\n * is required to provide this functionality plus extended\n * {@link org.springframework.core.io.support.ResourcePatternResolver} support.\n *\n * <p>{@link DefaultResourceLoader} is a standalone implementation that is\n * usable outside an ApplicationContext and is also used by {@link ResourceEditor}.\n *\n * <p>Bean properties of type {@code Resource} and {@code Resource[]} can be populated\n * from Strings when running in an ApplicationContext, using the particular\n * context's resource loading strategy.\n *\n * @author Juergen Hoeller\n * @since 10.03.2004\n * @see Resource\n * @see org.springframework.core.io.support.ResourcePatternResolver\n * @see org.springframework.context.ApplicationContext\n * @see org.springframework.context.ResourceLoaderAware\n "
  },
  {
    "entityId": "org.springframework.core.io.ResourceLoader#getResource(String)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code Resource} handle for the specified resource location.\r\n * <p>The handle should always be a reusable resource descriptor,\r\n * allowing for multiple {@link Resource#getInputStream()} calls.\r\n * <p><ul>\r\n * <li>Must support fully qualified URLs, for example, \"file:C:/test.dat\".\r\n * <li>Must support classpath pseudo-URLs, for example, \"classpath:test.dat\".\r\n * <li>Should support relative file paths, for example, \"WEB-INF/test.dat\".\r\n * (This will be implementation-specific, typically provided by an\r\n * ApplicationContext implementation.)\r\n * </ul>\r\n * <p>Note that a {@code Resource} handle does not imply an existing resource;\r\n * you need to invoke {@link Resource#exists} to check for existence.\r\n * @param location the resource location\r\n * @return a corresponding {@code Resource} handle (never {@code null})\r\n * @see #CLASSPATH_URL_PREFIX\r\n * @see Resource#exists()\r\n * @see Resource#getInputStream()\r\n */\r\nResource getResource(String location);",
    "comment": "\n\t * Return a {@code Resource} handle for the specified resource location.\n\t * <p>The handle should always be a reusable resource descriptor,\n\t * allowing for multiple {@link Resource#getInputStream()} calls.\n\t * <p><ul>\n\t * <li>Must support fully qualified URLs, for example, \"file:C:/test.dat\".\n\t * <li>Must support classpath pseudo-URLs, for example, \"classpath:test.dat\".\n\t * <li>Should support relative file paths, for example, \"WEB-INF/test.dat\".\n\t * (This will be implementation-specific, typically provided by an\n\t * ApplicationContext implementation.)\n\t * </ul>\n\t * <p>Note that a {@code Resource} handle does not imply an existing resource;\n\t * you need to invoke {@link Resource#exists} to check for existence.\n\t * @param location the resource location\n\t * @return a corresponding {@code Resource} handle (never {@code null})\n\t * @see #CLASSPATH_URL_PREFIX\n\t * @see Resource#exists()\n\t * @see Resource#getInputStream()\n\t "
  },
  {
    "entityId": "org.springframework.core.io.ResourceLoader#getClassLoader()",
    "entityType": "method",
    "code": "/**\r\n * Expose the {@link ClassLoader} used by this {@code ResourceLoader}.\r\n * <p>Clients which need to access the {@code ClassLoader} directly can do so\r\n * in a uniform manner with the {@code ResourceLoader}, rather than relying\r\n * on the thread context {@code ClassLoader}.\r\n * @return the {@code ClassLoader}\r\n * (only {@code null} if even the system {@code ClassLoader} isn't accessible)\r\n * @see org.springframework.util.ClassUtils#getDefaultClassLoader()\r\n * @see org.springframework.util.ClassUtils#forName(String, ClassLoader)\r\n */\r\n@Nullable\r\nClassLoader getClassLoader();",
    "comment": "\n\t * Expose the {@link ClassLoader} used by this {@code ResourceLoader}.\n\t * <p>Clients which need to access the {@code ClassLoader} directly can do so\n\t * in a uniform manner with the {@code ResourceLoader}, rather than relying\n\t * on the thread context {@code ClassLoader}.\n\t * @return the {@code ClassLoader}\n\t * (only {@code null} if even the system {@code ClassLoader} isn't accessible)\n\t * @see org.springframework.util.ClassUtils#getDefaultClassLoader()\n\t * @see org.springframework.util.ClassUtils#forName(String, ClassLoader)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.DefaultPropertySourceFactory",
    "entityType": "class",
    "code": "@Override\r\npublic PropertySource<?> createPropertySource(@Nullable String name, EncodedResource resource) throws IOException {\r\n    return (name != null ? new ResourcePropertySource(name, resource) : new ResourcePropertySource(resource));\r\n}",
    "comment": "\n * The default implementation for {@link PropertySourceFactory},\n * wrapping every resource in a {@link ResourcePropertySource}.\n *\n * @author Juergen Hoeller\n * @since 4.3\n * @see PropertySourceFactory\n * @see ResourcePropertySource\n "
  },
  {
    "entityId": "org.springframework.core.io.support.DefaultPropertySourceFactory#createPropertySource(String,EncodedResource)",
    "entityType": "method",
    "code": "@Override\r\npublic PropertySource<?> createPropertySource(@Nullable String name, EncodedResource resource) throws IOException {\r\n    return (name != null ? new ResourcePropertySource(name, resource) : new ResourcePropertySource(resource));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.EncodedResource",
    "entityType": "class",
    "code": "private final Resource resource;\n@Nullable\r\nprivate final String encoding;\n@Nullable\r\nprivate final Charset charset;\n/**\r\n * Create a new {@code EncodedResource} for the given {@code Resource},\r\n * not specifying an explicit encoding or {@code Charset}.\r\n * @param resource the {@code Resource} to hold (never {@code null})\r\n */\r\npublic EncodedResource(Resource resource) {\r\n    this(resource, null, null);\r\n}\n/**\r\n * Create a new {@code EncodedResource} for the given {@code Resource},\r\n * using the specified {@code encoding}.\r\n * @param resource the {@code Resource} to hold (never {@code null})\r\n * @param encoding the encoding to use for reading from the resource\r\n */\r\npublic EncodedResource(Resource resource, @Nullable String encoding) {\r\n    this(resource, encoding, null);\r\n}\n/**\r\n * Create a new {@code EncodedResource} for the given {@code Resource},\r\n * using the specified {@code Charset}.\r\n * @param resource the {@code Resource} to hold (never {@code null})\r\n * @param charset the {@code Charset} to use for reading from the resource\r\n */\r\npublic EncodedResource(Resource resource, @Nullable Charset charset) {\r\n    this(resource, null, charset);\r\n}\nprivate EncodedResource(Resource resource, @Nullable String encoding, @Nullable Charset charset) {\r\n    super();\r\n    Assert.notNull(resource, \"Resource must not be null\");\r\n    this.resource = resource;\r\n    this.encoding = encoding;\r\n    this.charset = charset;\r\n}\n/**\r\n * Return the {@code Resource} held by this {@code EncodedResource}.\r\n */\r\npublic final Resource getResource() {\r\n    return this.resource;\r\n}\n/**\r\n * Return the encoding to use for reading from the {@linkplain #getResource() resource},\r\n * or {@code null} if none specified.\r\n */\r\n@Nullable\r\npublic final String getEncoding() {\r\n    return this.encoding;\r\n}\n/**\r\n * Return the {@code Charset} to use for reading from the {@linkplain #getResource() resource},\r\n * or {@code null} if none specified.\r\n */\r\n@Nullable\r\npublic final Charset getCharset() {\r\n    return this.charset;\r\n}\n/**\r\n * Determine whether a {@link Reader} is required as opposed to an {@link InputStream},\r\n * i.e. whether an {@linkplain #getEncoding() encoding} or a {@link #getCharset() Charset}\r\n * has been specified.\r\n * @see #getReader()\r\n * @see #getInputStream()\r\n */\r\npublic boolean requiresReader() {\r\n    return (this.encoding != null || this.charset != null);\r\n}\n/**\r\n * Open a {@code java.io.Reader} for the specified resource, using the specified\r\n * {@link #getCharset() Charset} or {@linkplain #getEncoding() encoding}\r\n * (if any).\r\n * @throws IOException if opening the Reader failed\r\n * @see #requiresReader()\r\n * @see #getInputStream()\r\n */\r\npublic Reader getReader() throws IOException {\r\n    if (this.charset != null) {\r\n        return new InputStreamReader(this.resource.getInputStream(), this.charset);\r\n    } else if (this.encoding != null) {\r\n        return new InputStreamReader(this.resource.getInputStream(), this.encoding);\r\n    } else {\r\n        return new InputStreamReader(this.resource.getInputStream());\r\n    }\r\n}\n/**\r\n * Open an {@code InputStream} for the specified resource, ignoring any specified\r\n * {@link #getCharset() Charset} or {@linkplain #getEncoding() encoding}.\r\n * @throws IOException if opening the InputStream failed\r\n * @see #requiresReader()\r\n * @see #getReader()\r\n */\r\n@Override\r\npublic InputStream getInputStream() throws IOException {\r\n    return this.resource.getInputStream();\r\n}\n/**\r\n * Returns the contents of the specified resource as a string, using the specified\r\n * {@link #getCharset() Charset} or {@linkplain #getEncoding() encoding} (if any).\r\n * @throws IOException if opening the resource failed\r\n * @since 6.0.5\r\n * @see Resource#getContentAsString(Charset)\r\n */\r\npublic String getContentAsString() throws IOException {\r\n    Charset charset;\r\n    if (this.charset != null) {\r\n        charset = this.charset;\r\n    } else if (this.encoding != null) {\r\n        charset = Charset.forName(this.encoding);\r\n    } else {\r\n        charset = Charset.defaultCharset();\r\n    }\r\n    return this.resource.getContentAsString(charset);\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof EncodedResource that && this.resource.equals(that.resource) && ObjectUtils.nullSafeEquals(this.charset, that.charset) && ObjectUtils.nullSafeEquals(this.encoding, that.encoding)));\r\n}\n@Override\r\npublic int hashCode() {\r\n    return this.resource.hashCode();\r\n}\n@Override\r\npublic String toString() {\r\n    return this.resource.toString();\r\n}",
    "comment": "\n * Holder that combines a {@link Resource} descriptor with a specific encoding\n * or {@code Charset} to be used for reading from the resource.\n *\n * <p>Used as an argument for operations that support reading content with\n * a specific encoding, typically via a {@code java.io.Reader}.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Arjen Poutsma\n * @since 1.2.6\n * @see Resource#getInputStream()\n * @see java.io.Reader\n * @see java.nio.charset.Charset\n "
  },
  {
    "entityId": "org.springframework.core.io.support.EncodedResource#getResource()",
    "entityType": "method",
    "code": "/**\r\n * Return the {@code Resource} held by this {@code EncodedResource}.\r\n */\r\npublic final Resource getResource() {\r\n    return this.resource;\r\n}",
    "comment": "\n\t * Return the {@code Resource} held by this {@code EncodedResource}.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.EncodedResource#getEncoding()",
    "entityType": "method",
    "code": "/**\r\n * Return the encoding to use for reading from the {@linkplain #getResource() resource},\r\n * or {@code null} if none specified.\r\n */\r\n@Nullable\r\npublic final String getEncoding() {\r\n    return this.encoding;\r\n}",
    "comment": "\n\t * Return the encoding to use for reading from the {@linkplain #getResource() resource},\n\t * or {@code null} if none specified.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.EncodedResource#getCharset()",
    "entityType": "method",
    "code": "/**\r\n * Return the {@code Charset} to use for reading from the {@linkplain #getResource() resource},\r\n * or {@code null} if none specified.\r\n */\r\n@Nullable\r\npublic final Charset getCharset() {\r\n    return this.charset;\r\n}",
    "comment": "\n\t * Return the {@code Charset} to use for reading from the {@linkplain #getResource() resource},\n\t * or {@code null} if none specified.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.EncodedResource#requiresReader()",
    "entityType": "method",
    "code": "/**\r\n * Determine whether a {@link Reader} is required as opposed to an {@link InputStream},\r\n * i.e. whether an {@linkplain #getEncoding() encoding} or a {@link #getCharset() Charset}\r\n * has been specified.\r\n * @see #getReader()\r\n * @see #getInputStream()\r\n */\r\npublic boolean requiresReader() {\r\n    return (this.encoding != null || this.charset != null);\r\n}",
    "comment": "\n\t * Determine whether a {@link Reader} is required as opposed to an {@link InputStream},\n\t * i.e. whether an {@linkplain #getEncoding() encoding} or a {@link #getCharset() Charset}\n\t * has been specified.\n\t * @see #getReader()\n\t * @see #getInputStream()\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.EncodedResource#getReader()",
    "entityType": "method",
    "code": "/**\r\n * Open a {@code java.io.Reader} for the specified resource, using the specified\r\n * {@link #getCharset() Charset} or {@linkplain #getEncoding() encoding}\r\n * (if any).\r\n * @throws IOException if opening the Reader failed\r\n * @see #requiresReader()\r\n * @see #getInputStream()\r\n */\r\npublic Reader getReader() throws IOException {\r\n    if (this.charset != null) {\r\n        return new InputStreamReader(this.resource.getInputStream(), this.charset);\r\n    } else if (this.encoding != null) {\r\n        return new InputStreamReader(this.resource.getInputStream(), this.encoding);\r\n    } else {\r\n        return new InputStreamReader(this.resource.getInputStream());\r\n    }\r\n}",
    "comment": "\n\t * Open a {@code java.io.Reader} for the specified resource, using the specified\n\t * {@link #getCharset() Charset} or {@linkplain #getEncoding() encoding}\n\t * (if any).\n\t * @throws IOException if opening the Reader failed\n\t * @see #requiresReader()\n\t * @see #getInputStream()\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.EncodedResource#getInputStream()",
    "entityType": "method",
    "code": "/**\r\n * Open an {@code InputStream} for the specified resource, ignoring any specified\r\n * {@link #getCharset() Charset} or {@linkplain #getEncoding() encoding}.\r\n * @throws IOException if opening the InputStream failed\r\n * @see #requiresReader()\r\n * @see #getReader()\r\n */\r\n@Override\r\npublic InputStream getInputStream() throws IOException {\r\n    return this.resource.getInputStream();\r\n}",
    "comment": "\n\t * Open an {@code InputStream} for the specified resource, ignoring any specified\n\t * {@link #getCharset() Charset} or {@linkplain #getEncoding() encoding}.\n\t * @throws IOException if opening the InputStream failed\n\t * @see #requiresReader()\n\t * @see #getReader()\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.EncodedResource#getContentAsString()",
    "entityType": "method",
    "code": "/**\r\n * Returns the contents of the specified resource as a string, using the specified\r\n * {@link #getCharset() Charset} or {@linkplain #getEncoding() encoding} (if any).\r\n * @throws IOException if opening the resource failed\r\n * @since 6.0.5\r\n * @see Resource#getContentAsString(Charset)\r\n */\r\npublic String getContentAsString() throws IOException {\r\n    Charset charset;\r\n    if (this.charset != null) {\r\n        charset = this.charset;\r\n    } else if (this.encoding != null) {\r\n        charset = Charset.forName(this.encoding);\r\n    } else {\r\n        charset = Charset.defaultCharset();\r\n    }\r\n    return this.resource.getContentAsString(charset);\r\n}",
    "comment": "\n\t * Returns the contents of the specified resource as a string, using the specified\n\t * {@link #getCharset() Charset} or {@linkplain #getEncoding() encoding} (if any).\n\t * @throws IOException if opening the resource failed\n\t * @since 6.0.5\n\t * @see Resource#getContentAsString(Charset)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.EncodedResource#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof EncodedResource that && this.resource.equals(that.resource) && ObjectUtils.nullSafeEquals(this.charset, that.charset) && ObjectUtils.nullSafeEquals(this.encoding, that.encoding)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.EncodedResource#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return this.resource.hashCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.EncodedResource#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return this.resource.toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.LocalizedResourceHelper",
    "entityType": "class",
    "code": "/**\r\n * The default separator to use in-between file name parts: an underscore.\r\n */\r\npublic static final String DEFAULT_SEPARATOR = \"_\";\nprivate final ResourceLoader resourceLoader;\nprivate String separator = DEFAULT_SEPARATOR;\n/**\r\n * Create a new LocalizedResourceHelper with a DefaultResourceLoader.\r\n * @see org.springframework.core.io.DefaultResourceLoader\r\n */\r\npublic LocalizedResourceHelper() {\r\n    this.resourceLoader = new DefaultResourceLoader();\r\n}\n/**\r\n * Create a new LocalizedResourceHelper with the given ResourceLoader.\r\n * @param resourceLoader the ResourceLoader to use\r\n */\r\npublic LocalizedResourceHelper(ResourceLoader resourceLoader) {\r\n    Assert.notNull(resourceLoader, \"ResourceLoader must not be null\");\r\n    this.resourceLoader = resourceLoader;\r\n}\n/**\r\n * Set the separator to use in-between file name parts.\r\n * Default is an underscore (\"_\").\r\n */\r\npublic void setSeparator(@Nullable String separator) {\r\n    this.separator = (separator != null ? separator : DEFAULT_SEPARATOR);\r\n}\n/**\r\n * Find the most specific localized resource for the given name,\r\n * extension and locale:\r\n * <p>The file will be searched with locations in the following order,\r\n * similar to {@code java.util.ResourceBundle}'s search order:\r\n * <ul>\r\n * <li>[name]_[language]_[country]_[variant][extension]\r\n * <li>[name]_[language]_[country][extension]\r\n * <li>[name]_[language][extension]\r\n * <li>[name][extension]\r\n * </ul>\r\n * <p>If none of the specific files can be found, a resource\r\n * descriptor for the default location will be returned.\r\n * @param name the name of the file, without localization part nor extension\r\n * @param extension the file extension (for example, \".xls\")\r\n * @param locale the current locale (may be {@code null})\r\n * @return the most specific localized resource found\r\n * @see java.util.ResourceBundle\r\n */\r\npublic Resource findLocalizedResource(String name, String extension, @Nullable Locale locale) {\r\n    Assert.notNull(name, \"Name must not be null\");\r\n    Assert.notNull(extension, \"Extension must not be null\");\r\n    Resource resource = null;\r\n    if (locale != null) {\r\n        String lang = locale.getLanguage();\r\n        String country = locale.getCountry();\r\n        String variant = locale.getVariant();\r\n        // Check for file with language, country and variant localization.\r\n        if (variant.length() > 0) {\r\n            String location = name + this.separator + lang + this.separator + country + this.separator + variant + extension;\r\n            resource = this.resourceLoader.getResource(location);\r\n        }\r\n        // Check for file with language and country localization.\r\n        if ((resource == null || !resource.exists()) && country.length() > 0) {\r\n            String location = name + this.separator + lang + this.separator + country + extension;\r\n            resource = this.resourceLoader.getResource(location);\r\n        }\r\n        // Check for document with language localization.\r\n        if ((resource == null || !resource.exists()) && lang.length() > 0) {\r\n            String location = name + this.separator + lang + extension;\r\n            resource = this.resourceLoader.getResource(location);\r\n        }\r\n    }\r\n    // Check for document without localization.\r\n    if (resource == null || !resource.exists()) {\r\n        String location = name + extension;\r\n        resource = this.resourceLoader.getResource(location);\r\n    }\r\n    return resource;\r\n}",
    "comment": "\n * Helper class for loading a localized resource,\n * specified through name, extension and current locale.\n *\n * @author Juergen Hoeller\n * @since 1.2.5\n "
  },
  {
    "entityId": "org.springframework.core.io.support.LocalizedResourceHelper#setSeparator(String)",
    "entityType": "method",
    "code": "/**\r\n * Set the separator to use in-between file name parts.\r\n * Default is an underscore (\"_\").\r\n */\r\npublic void setSeparator(@Nullable String separator) {\r\n    this.separator = (separator != null ? separator : DEFAULT_SEPARATOR);\r\n}",
    "comment": "\n\t * Set the separator to use in-between file name parts.\n\t * Default is an underscore (\"_\").\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.LocalizedResourceHelper#findLocalizedResource(String,String,Locale)",
    "entityType": "method",
    "code": "/**\r\n * Find the most specific localized resource for the given name,\r\n * extension and locale:\r\n * <p>The file will be searched with locations in the following order,\r\n * similar to {@code java.util.ResourceBundle}'s search order:\r\n * <ul>\r\n * <li>[name]_[language]_[country]_[variant][extension]\r\n * <li>[name]_[language]_[country][extension]\r\n * <li>[name]_[language][extension]\r\n * <li>[name][extension]\r\n * </ul>\r\n * <p>If none of the specific files can be found, a resource\r\n * descriptor for the default location will be returned.\r\n * @param name the name of the file, without localization part nor extension\r\n * @param extension the file extension (for example, \".xls\")\r\n * @param locale the current locale (may be {@code null})\r\n * @return the most specific localized resource found\r\n * @see java.util.ResourceBundle\r\n */\r\npublic Resource findLocalizedResource(String name, String extension, @Nullable Locale locale) {\r\n    Assert.notNull(name, \"Name must not be null\");\r\n    Assert.notNull(extension, \"Extension must not be null\");\r\n    Resource resource = null;\r\n    if (locale != null) {\r\n        String lang = locale.getLanguage();\r\n        String country = locale.getCountry();\r\n        String variant = locale.getVariant();\r\n        // Check for file with language, country and variant localization.\r\n        if (variant.length() > 0) {\r\n            String location = name + this.separator + lang + this.separator + country + this.separator + variant + extension;\r\n            resource = this.resourceLoader.getResource(location);\r\n        }\r\n        // Check for file with language and country localization.\r\n        if ((resource == null || !resource.exists()) && country.length() > 0) {\r\n            String location = name + this.separator + lang + this.separator + country + extension;\r\n            resource = this.resourceLoader.getResource(location);\r\n        }\r\n        // Check for document with language localization.\r\n        if ((resource == null || !resource.exists()) && lang.length() > 0) {\r\n            String location = name + this.separator + lang + extension;\r\n            resource = this.resourceLoader.getResource(location);\r\n        }\r\n    }\r\n    // Check for document without localization.\r\n    if (resource == null || !resource.exists()) {\r\n        String location = name + extension;\r\n        resource = this.resourceLoader.getResource(location);\r\n    }\r\n    return resource;\r\n}",
    "comment": "\n\t * Find the most specific localized resource for the given name,\n\t * extension and locale:\n\t * <p>The file will be searched with locations in the following order,\n\t * similar to {@code java.util.ResourceBundle}'s search order:\n\t * <ul>\n\t * <li>[name]_[language]_[country]_[variant][extension]\n\t * <li>[name]_[language]_[country][extension]\n\t * <li>[name]_[language][extension]\n\t * <li>[name][extension]\n\t * </ul>\n\t * <p>If none of the specific files can be found, a resource\n\t * descriptor for the default location will be returned.\n\t * @param name the name of the file, without localization part nor extension\n\t * @param extension the file extension (for example, \".xls\")\n\t * @param locale the current locale (may be {@code null})\n\t * @return the most specific localized resource found\n\t * @see java.util.ResourceBundle\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PathMatchingResourcePatternResolver",
    "entityType": "class",
    "code": "private static final Log logger = LogFactory.getLog(PathMatchingResourcePatternResolver.class);\n/**\r\n * {@link Set} of {@linkplain ModuleFinder#ofSystem() system module} names.\r\n * @since 6.0\r\n * @see #isNotSystemModule\r\n */\r\nprivate static final Set<String> systemModuleNames = NativeDetector.inNativeImage() ? Collections.emptySet() : ModuleFinder.ofSystem().findAll().stream().map(moduleReference -> moduleReference.descriptor().name()).collect(Collectors.toSet());\n/**\r\n * {@link Predicate} that tests whether the supplied {@link ResolvedModule}\r\n * is not a {@linkplain ModuleFinder#ofSystem() system module}.\r\n * @since 6.0\r\n * @see #systemModuleNames\r\n */\r\nprivate static final Predicate<ResolvedModule> isNotSystemModule = resolvedModule -> !systemModuleNames.contains(resolvedModule.name());\n@Nullable\r\nprivate static Method equinoxResolveMethod;\nstatic {\r\n    try {\r\n        // Detect Equinox OSGi (for example, on WebSphere 6.1)\r\n        Class<?> fileLocatorClass = ClassUtils.forName(\"org.eclipse.core.runtime.FileLocator\", PathMatchingResourcePatternResolver.class.getClassLoader());\r\n        equinoxResolveMethod = fileLocatorClass.getMethod(\"resolve\", URL.class);\r\n        logger.trace(\"Found Equinox FileLocator for OSGi bundle URL resolution\");\r\n    } catch (Throwable ex) {\r\n        equinoxResolveMethod = null;\r\n    }\r\n}\nprivate final ResourceLoader resourceLoader;\nprivate PathMatcher pathMatcher = new AntPathMatcher();\nprivate final Map<String, Resource[]> rootDirCache = new ConcurrentHashMap<>();\nprivate final Map<String, NavigableSet<String>> jarEntriesCache = new ConcurrentHashMap<>();\n@Nullable\r\nprivate volatile Set<ClassPathManifestEntry> manifestEntriesCache;\n/**\r\n * Create a {@code PathMatchingResourcePatternResolver} with a\r\n * {@link DefaultResourceLoader}.\r\n * <p>ClassLoader access will happen via the thread context class loader.\r\n * @see DefaultResourceLoader\r\n */\r\npublic PathMatchingResourcePatternResolver() {\r\n    this.resourceLoader = new DefaultResourceLoader();\r\n}\n/**\r\n * Create a {@code PathMatchingResourcePatternResolver} with the supplied\r\n * {@link ResourceLoader}.\r\n * <p>ClassLoader access will happen via the thread context class loader.\r\n * @param resourceLoader the {@code ResourceLoader} to load root directories\r\n * and actual resources with\r\n */\r\npublic PathMatchingResourcePatternResolver(ResourceLoader resourceLoader) {\r\n    Assert.notNull(resourceLoader, \"ResourceLoader must not be null\");\r\n    this.resourceLoader = resourceLoader;\r\n}\n/**\r\n * Create a {@code PathMatchingResourcePatternResolver} with a\r\n * {@link DefaultResourceLoader} and the supplied {@link ClassLoader}.\r\n * @param classLoader the ClassLoader to load class path resources with,\r\n * or {@code null} for using the thread context class loader\r\n * at the time of actual resource access\r\n * @see org.springframework.core.io.DefaultResourceLoader\r\n */\r\npublic PathMatchingResourcePatternResolver(@Nullable ClassLoader classLoader) {\r\n    this.resourceLoader = new DefaultResourceLoader(classLoader);\r\n}\n/**\r\n * Return the {@link ResourceLoader} that this pattern resolver works with.\r\n */\r\npublic ResourceLoader getResourceLoader() {\r\n    return this.resourceLoader;\r\n}\n@Override\r\n@Nullable\r\npublic ClassLoader getClassLoader() {\r\n    return getResourceLoader().getClassLoader();\r\n}\n/**\r\n * Set the {@link PathMatcher} implementation to use for this\r\n * resource pattern resolver.\r\n * <p>Default is {@link AntPathMatcher}.\r\n * @see AntPathMatcher\r\n */\r\npublic void setPathMatcher(PathMatcher pathMatcher) {\r\n    Assert.notNull(pathMatcher, \"PathMatcher must not be null\");\r\n    this.pathMatcher = pathMatcher;\r\n}\n/**\r\n * Return the {@link PathMatcher} that this resource pattern resolver uses.\r\n */\r\npublic PathMatcher getPathMatcher() {\r\n    return this.pathMatcher;\r\n}\n@Override\r\npublic Resource getResource(String location) {\r\n    return getResourceLoader().getResource(location);\r\n}\n@Override\r\npublic Resource[] getResources(String locationPattern) throws IOException {\r\n    Assert.notNull(locationPattern, \"Location pattern must not be null\");\r\n    if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) {\r\n        // a class path resource (multiple resources for same name possible)\r\n        String locationPatternWithoutPrefix = locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length());\r\n        // Search the module path first.\r\n        Set<Resource> resources = findAllModulePathResources(locationPatternWithoutPrefix);\r\n        // Search the class path next.\r\n        if (getPathMatcher().isPattern(locationPatternWithoutPrefix)) {\r\n            // a class path resource pattern\r\n            Collections.addAll(resources, findPathMatchingResources(locationPattern));\r\n        } else {\r\n            // all class path resources with the given name\r\n            Collections.addAll(resources, findAllClassPathResources(locationPatternWithoutPrefix));\r\n        }\r\n        return resources.toArray(new Resource[0]);\r\n    } else {\r\n        // Generally only look for a pattern after a prefix here,\r\n        // and on Tomcat only after the \"*/\" separator for its \"war:\" protocol.\r\n        int prefixEnd = (locationPattern.startsWith(\"war:\") ? locationPattern.indexOf(\"*/\") + 1 : locationPattern.indexOf(':') + 1);\r\n        if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) {\r\n            // a file pattern\r\n            return findPathMatchingResources(locationPattern);\r\n        } else {\r\n            // a single resource with the given name\r\n            return new Resource[] { getResourceLoader().getResource(locationPattern) };\r\n        }\r\n    }\r\n}\n/**\r\n * Clear the local resource cache, removing all cached classpath/jar structures.\r\n * @since 6.2\r\n */\r\npublic void clearCache() {\r\n    this.rootDirCache.clear();\r\n    this.jarEntriesCache.clear();\r\n    this.manifestEntriesCache = null;\r\n}\n/**\r\n * Find all class location resources with the given location via the ClassLoader.\r\n * <p>Delegates to {@link #doFindAllClassPathResources(String)}.\r\n * @param location the absolute path within the class path\r\n * @return the result as Resource array\r\n * @throws IOException in case of I/O errors\r\n * @see java.lang.ClassLoader#getResources\r\n * @see #convertClassLoaderURL\r\n */\r\nprotected Resource[] findAllClassPathResources(String location) throws IOException {\r\n    String path = stripLeadingSlash(location);\r\n    Set<Resource> result = doFindAllClassPathResources(path);\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(\"Resolved class path location [\" + path + \"] to resources \" + result);\r\n    }\r\n    return result.toArray(new Resource[0]);\r\n}\n/**\r\n * Find all class path resources with the given path via the configured\r\n * {@link #getClassLoader() ClassLoader}.\r\n * <p>Called by {@link #findAllClassPathResources(String)}.\r\n * @param path the absolute path within the class path (never a leading slash)\r\n * @return a mutable Set of matching Resource instances\r\n * @since 4.1.1\r\n */\r\nprotected Set<Resource> doFindAllClassPathResources(String path) throws IOException {\r\n    Set<Resource> result = new LinkedHashSet<>(16);\r\n    ClassLoader cl = getClassLoader();\r\n    Enumeration<URL> resourceUrls = (cl != null ? cl.getResources(path) : ClassLoader.getSystemResources(path));\r\n    while (resourceUrls.hasMoreElements()) {\r\n        URL url = resourceUrls.nextElement();\r\n        result.add(convertClassLoaderURL(url));\r\n    }\r\n    if (!StringUtils.hasLength(path)) {\r\n        // The above result is likely to be incomplete, i.e. only containing file system references.\r\n        // We need to have pointers to each of the jar files on the class path as well...\r\n        addAllClassLoaderJarRoots(cl, result);\r\n    }\r\n    return result;\r\n}\n/**\r\n * Convert the given URL as returned from the configured\r\n * {@link #getClassLoader() ClassLoader} into a {@link Resource}, applying\r\n * to path lookups without a pattern (see {@link #findAllClassPathResources}).\r\n * <p>As of 6.0.5, the default implementation creates a {@link FileSystemResource}\r\n * in case of the \"file\" protocol or a {@link UrlResource} otherwise, matching\r\n * the outcome of pattern-based class path traversal in the same resource layout,\r\n * as well as matching the outcome of module path searches.\r\n * @param url a URL as returned from the configured ClassLoader\r\n * @return the corresponding Resource object\r\n * @see java.lang.ClassLoader#getResources\r\n * @see #doFindAllClassPathResources\r\n * @see #doFindPathMatchingFileResources\r\n */\r\n// on JDK 20 (deprecated URL constructor)\r\n@SuppressWarnings(\"deprecation\")\r\nprotected Resource convertClassLoaderURL(URL url) {\r\n    if (ResourceUtils.URL_PROTOCOL_FILE.equals(url.getProtocol())) {\r\n        try {\r\n            // URI decoding for special characters such as spaces.\r\n            return new FileSystemResource(ResourceUtils.toURI(url).getSchemeSpecificPart());\r\n        } catch (URISyntaxException ex) {\r\n            // Fallback for URLs that are not valid URIs (should hardly ever happen).\r\n            return new FileSystemResource(url.getFile());\r\n        }\r\n    } else {\r\n        String urlString = url.toString();\r\n        String cleanedPath = StringUtils.cleanPath(urlString);\r\n        if (!cleanedPath.equals(urlString)) {\r\n            // Prefer cleaned URL, aligned with UrlResource#createRelative(String)\r\n            try {\r\n                // Retain original URL instance, potentially including custom URLStreamHandler.\r\n                return new UrlResource(new URL(url, cleanedPath));\r\n            } catch (MalformedURLException ex) {\r\n                // Fallback to regular URL construction below...\r\n            }\r\n        }\r\n        // Retain original URL instance, potentially including custom URLStreamHandler.\r\n        return new UrlResource(url);\r\n    }\r\n}\n/**\r\n * Search all {@link URLClassLoader} URLs for jar file references and add each to the\r\n * given set of resources in the form of a pointer to the root of the jar file content.\r\n * @param classLoader the ClassLoader to search (including its ancestors)\r\n * @param result the set of resources to add jar roots to\r\n * @since 4.1.1\r\n */\r\nprotected void addAllClassLoaderJarRoots(@Nullable ClassLoader classLoader, Set<Resource> result) {\r\n    if (classLoader instanceof URLClassLoader urlClassLoader) {\r\n        try {\r\n            for (URL url : urlClassLoader.getURLs()) {\r\n                try {\r\n                    UrlResource jarResource = (ResourceUtils.URL_PROTOCOL_JAR.equals(url.getProtocol()) ? new UrlResource(url) : new UrlResource(ResourceUtils.JAR_URL_PREFIX + url + ResourceUtils.JAR_URL_SEPARATOR));\r\n                    if (jarResource.exists()) {\r\n                        result.add(jarResource);\r\n                    }\r\n                } catch (MalformedURLException ex) {\r\n                    if (logger.isDebugEnabled()) {\r\n                        logger.debug(\"Cannot search for matching files underneath [\" + url + \"] because it cannot be converted to a valid 'jar:' URL: \" + ex.getMessage());\r\n                    }\r\n                }\r\n            }\r\n        } catch (Exception ex) {\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"Cannot introspect jar files since ClassLoader [\" + classLoader + \"] does not support 'getURLs()': \" + ex);\r\n            }\r\n        }\r\n    }\r\n    if (classLoader == ClassLoader.getSystemClassLoader()) {\r\n        // JAR \"Class-Path\" manifest header evaluation...\r\n        addClassPathManifestEntries(result);\r\n    }\r\n    if (classLoader != null) {\r\n        try {\r\n            // Hierarchy traversal...\r\n            addAllClassLoaderJarRoots(classLoader.getParent(), result);\r\n        } catch (Exception ex) {\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"Cannot introspect jar files in parent ClassLoader since [\" + classLoader + \"] does not support 'getParent()': \" + ex);\r\n            }\r\n        }\r\n    }\r\n}\n/**\r\n * Determine jar file references from {@code Class-Path} manifest entries (which\r\n * are added to the {@code java.class.path} JVM system property by the system\r\n * class loader) and add each to the given set of resources in the form of\r\n * a pointer to the root of the jar file content.\r\n * @param result the set of resources to add jar roots to\r\n * @since 4.3\r\n */\r\nprotected void addClassPathManifestEntries(Set<Resource> result) {\r\n    Set<ClassPathManifestEntry> entries = this.manifestEntriesCache;\r\n    if (entries == null) {\r\n        entries = getClassPathManifestEntries();\r\n        this.manifestEntriesCache = entries;\r\n    }\r\n    for (ClassPathManifestEntry entry : entries) {\r\n        if (!result.contains(entry.resource()) && (entry.alternative() != null && !result.contains(entry.alternative()))) {\r\n            result.add(entry.resource());\r\n        }\r\n    }\r\n}\nprivate Set<ClassPathManifestEntry> getClassPathManifestEntries() {\r\n    Set<ClassPathManifestEntry> manifestEntries = new LinkedHashSet<>();\r\n    Set<File> seen = new HashSet<>();\r\n    try {\r\n        String paths = System.getProperty(\"java.class.path\");\r\n        for (String path : StringUtils.delimitedListToStringArray(paths, File.pathSeparator)) {\r\n            try {\r\n                File jar = new File(path).getAbsoluteFile();\r\n                if (jar.isFile() && seen.add(jar)) {\r\n                    manifestEntries.add(ClassPathManifestEntry.of(jar));\r\n                    manifestEntries.addAll(getClassPathManifestEntriesFromJar(jar));\r\n                }\r\n            } catch (MalformedURLException ex) {\r\n                if (logger.isDebugEnabled()) {\r\n                    logger.debug(\"Cannot search for matching files underneath [\" + path + \"] because it cannot be converted to a valid 'jar:' URL: \" + ex.getMessage());\r\n                }\r\n            }\r\n        }\r\n        return Collections.unmodifiableSet(manifestEntries);\r\n    } catch (Exception ex) {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"Failed to evaluate 'java.class.path' manifest entries: \" + ex);\r\n        }\r\n        return Collections.emptySet();\r\n    }\r\n}\nprivate Set<ClassPathManifestEntry> getClassPathManifestEntriesFromJar(File jar) throws IOException {\r\n    URL base = jar.toURI().toURL();\r\n    File parent = jar.getAbsoluteFile().getParentFile();\r\n    try (JarFile jarFile = new JarFile(jar)) {\r\n        Manifest manifest = jarFile.getManifest();\r\n        Attributes attributes = (manifest != null ? manifest.getMainAttributes() : null);\r\n        String classPath = (attributes != null ? attributes.getValue(Name.CLASS_PATH) : null);\r\n        Set<ClassPathManifestEntry> manifestEntries = new LinkedHashSet<>();\r\n        if (StringUtils.hasLength(classPath)) {\r\n            StringTokenizer tokenizer = new StringTokenizer(classPath);\r\n            while (tokenizer.hasMoreTokens()) {\r\n                String path = tokenizer.nextToken();\r\n                if (path.indexOf(':') >= 0 && !\"file\".equalsIgnoreCase(new URL(base, path).getProtocol())) {\r\n                    // See jdk.internal.loader.URLClassPath.JarLoader.tryResolveFile(URL, String)\r\n                    continue;\r\n                }\r\n                File candidate = new File(parent, path);\r\n                if (candidate.isFile() && candidate.getCanonicalPath().contains(parent.getCanonicalPath())) {\r\n                    manifestEntries.add(ClassPathManifestEntry.of(candidate));\r\n                }\r\n            }\r\n        }\r\n        return Collections.unmodifiableSet(manifestEntries);\r\n    } catch (Exception ex) {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"Failed to load manifest entries from jar file '\" + jar + \"': \" + ex);\r\n        }\r\n        return Collections.emptySet();\r\n    }\r\n}\n/**\r\n * Find all resources that match the given location pattern via the Ant-style\r\n * {@link #getPathMatcher() PathMatcher}.\r\n * <p>Supports resources in OSGi bundles, JBoss VFS, jar files, zip files,\r\n * and file systems.\r\n * @param locationPattern the location pattern to match\r\n * @return the result as Resource array\r\n * @throws IOException in case of I/O errors\r\n * @see #determineRootDir(String)\r\n * @see #resolveRootDirResource(Resource)\r\n * @see #isJarResource(Resource)\r\n * @see #doFindPathMatchingJarResources(Resource, URL, String)\r\n * @see #doFindPathMatchingFileResources(Resource, String)\r\n * @see org.springframework.util.PathMatcher\r\n */\r\nprotected Resource[] findPathMatchingResources(String locationPattern) throws IOException {\r\n    String rootDirPath = determineRootDir(locationPattern);\r\n    String subPattern = locationPattern.substring(rootDirPath.length());\r\n    // Look for pre-cached root dir resources, either a direct match or\r\n    // a match for a parent directory in the same classpath locations.\r\n    Resource[] rootDirResources = this.rootDirCache.get(rootDirPath);\r\n    String actualRootPath = null;\r\n    if (rootDirResources == null) {\r\n        // No direct match -> search for a common parent directory match\r\n        // (cached based on repeated searches in the same base location,\r\n        // in particular for different root directories in the same jar).\r\n        String commonPrefix = null;\r\n        String existingPath = null;\r\n        boolean commonUnique = true;\r\n        for (String path : this.rootDirCache.keySet()) {\r\n            String currentPrefix = null;\r\n            for (int i = 0; i < path.length(); i++) {\r\n                if (i == rootDirPath.length() || path.charAt(i) != rootDirPath.charAt(i)) {\r\n                    currentPrefix = path.substring(0, path.lastIndexOf('/', i - 1) + 1);\r\n                    break;\r\n                }\r\n            }\r\n            if (currentPrefix != null) {\r\n                if (checkPathWithinPackage(path.substring(currentPrefix.length()))) {\r\n                    // A prefix match found, potentially to be turned into a common parent cache entry.\r\n                    if (commonPrefix == null || !commonUnique || currentPrefix.length() > commonPrefix.length()) {\r\n                        commonPrefix = currentPrefix;\r\n                        existingPath = path;\r\n                    } else if (currentPrefix.equals(commonPrefix)) {\r\n                        commonUnique = false;\r\n                    }\r\n                }\r\n            } else if (actualRootPath == null || path.length() > actualRootPath.length()) {\r\n                // A direct match found for a parent directory -> use it.\r\n                rootDirResources = this.rootDirCache.get(path);\r\n                actualRootPath = path;\r\n            }\r\n        }\r\n        if (rootDirResources == null && StringUtils.hasLength(commonPrefix)) {\r\n            // Try common parent directory as long as it points to the same classpath locations.\r\n            rootDirResources = getResources(commonPrefix);\r\n            Resource[] existingResources = this.rootDirCache.get(existingPath);\r\n            if (existingResources != null && rootDirResources.length == existingResources.length) {\r\n                // Replace existing subdirectory cache entry with common parent directory,\r\n                // avoiding repeated determination of root directories in the same jar.\r\n                this.rootDirCache.remove(existingPath);\r\n                this.rootDirCache.put(commonPrefix, rootDirResources);\r\n                actualRootPath = commonPrefix;\r\n            } else if (commonPrefix.equals(rootDirPath)) {\r\n                // The identified common directory is equal to the currently requested path ->\r\n                // worth caching specifically, even if it cannot replace the existing sub-entry.\r\n                this.rootDirCache.put(rootDirPath, rootDirResources);\r\n            } else {\r\n                // Mismatch: parent directory points to more classpath locations.\r\n                rootDirResources = null;\r\n            }\r\n        }\r\n        if (rootDirResources == null) {\r\n            // Lookup for specific directory, creating a cache entry for it.\r\n            rootDirResources = getResources(rootDirPath);\r\n            this.rootDirCache.put(rootDirPath, rootDirResources);\r\n        }\r\n    }\r\n    Set<Resource> result = new LinkedHashSet<>(64);\r\n    for (Resource rootDirResource : rootDirResources) {\r\n        if (actualRootPath != null && actualRootPath.length() < rootDirPath.length()) {\r\n            // Create sub-resource for requested sub-location from cached common root directory.\r\n            rootDirResource = rootDirResource.createRelative(rootDirPath.substring(actualRootPath.length()));\r\n        }\r\n        rootDirResource = resolveRootDirResource(rootDirResource);\r\n        URL rootDirUrl = rootDirResource.getURL();\r\n        if (equinoxResolveMethod != null && rootDirUrl.getProtocol().startsWith(\"bundle\")) {\r\n            URL resolvedUrl = (URL) ReflectionUtils.invokeMethod(equinoxResolveMethod, null, rootDirUrl);\r\n            if (resolvedUrl != null) {\r\n                rootDirUrl = resolvedUrl;\r\n            }\r\n            rootDirResource = new UrlResource(rootDirUrl);\r\n        }\r\n        if (rootDirUrl.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {\r\n            result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirUrl, subPattern, getPathMatcher()));\r\n        } else if (ResourceUtils.isJarURL(rootDirUrl) || isJarResource(rootDirResource)) {\r\n            result.addAll(doFindPathMatchingJarResources(rootDirResource, rootDirUrl, subPattern));\r\n        } else {\r\n            result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern));\r\n        }\r\n    }\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(\"Resolved location pattern [\" + locationPattern + \"] to resources \" + result);\r\n    }\r\n    return result.toArray(new Resource[0]);\r\n}\n/**\r\n * Determine the root directory for the given location.\r\n * <p>Used for determining the starting point for file matching, resolving the\r\n * root directory location to be passed into {@link #getResources(String)},\r\n * with the remainder of the location to be used as the sub pattern.\r\n * <p>Will return \"/WEB-INF/\" for the location \"/WEB-INF/*.xml\", for example.\r\n * @param location the location to check\r\n * @return the part of the location that denotes the root directory\r\n * @see #findPathMatchingResources(String)\r\n */\r\nprotected String determineRootDir(String location) {\r\n    int prefixEnd = location.indexOf(':') + 1;\r\n    int rootDirEnd = location.length();\r\n    while (rootDirEnd > prefixEnd && getPathMatcher().isPattern(location.substring(prefixEnd, rootDirEnd))) {\r\n        rootDirEnd = location.lastIndexOf('/', rootDirEnd - 2) + 1;\r\n    }\r\n    if (rootDirEnd == 0) {\r\n        rootDirEnd = prefixEnd;\r\n    }\r\n    return location.substring(0, rootDirEnd);\r\n}\n/**\r\n * Resolve the supplied root directory resource for path matching.\r\n * <p>By default, {@link #findPathMatchingResources(String)} resolves Equinox\r\n * OSGi \"bundleresource:\" and \"bundleentry:\" URLs into standard jar file URLs\r\n * that will be traversed using Spring's standard jar file traversal algorithm.\r\n * <p>For any custom resolution, override this template method and replace the\r\n * supplied resource handle accordingly.\r\n * <p>The default implementation of this method returns the supplied resource\r\n * unmodified.\r\n * @param original the resource to resolve\r\n * @return the resolved resource (may be identical to the supplied resource)\r\n * @throws IOException in case of resolution failure\r\n * @see #findPathMatchingResources(String)\r\n */\r\nprotected Resource resolveRootDirResource(Resource original) throws IOException {\r\n    return original;\r\n}\n/**\r\n * Determine if the given resource handle indicates a jar resource that the\r\n * {@link #doFindPathMatchingJarResources} method can handle.\r\n * <p>{@link #findPathMatchingResources(String)} delegates to\r\n * {@link ResourceUtils#isJarURL(URL)} to determine whether the given URL\r\n * points to a resource in a jar file, and only invokes this method as a fallback.\r\n * <p>This template method therefore allows for detecting further kinds of\r\n * jar-like resources &mdash; for example, via {@code instanceof} checks on\r\n * the resource handle type.\r\n * <p>The default implementation of this method returns {@code false}.\r\n * @param resource the resource handle to check (usually the root directory\r\n * to start path matching from)\r\n * @return {@code true} if the given resource handle indicates a jar resource\r\n * @throws IOException in case of I/O errors\r\n * @see #findPathMatchingResources(String)\r\n * @see #doFindPathMatchingJarResources(Resource, URL, String)\r\n * @see org.springframework.util.ResourceUtils#isJarURL\r\n */\r\nprotected boolean isJarResource(Resource resource) throws IOException {\r\n    return false;\r\n}\n/**\r\n * Find all resources in jar files that match the given location pattern\r\n * via the Ant-style {@link #getPathMatcher() PathMatcher}.\r\n * @param rootDirResource the root directory as Resource\r\n * @param rootDirUrl the pre-resolved root directory URL\r\n * @param subPattern the sub pattern to match (below the root directory)\r\n * @return a mutable Set of matching Resource instances\r\n * @throws IOException in case of I/O errors\r\n * @since 4.3\r\n * @see java.net.JarURLConnection\r\n * @see org.springframework.util.PathMatcher\r\n */\r\nprotected Set<Resource> doFindPathMatchingJarResources(Resource rootDirResource, URL rootDirUrl, String subPattern) throws IOException {\r\n    String jarFileUrl = null;\r\n    String rootEntryPath = \"\";\r\n    String urlFile = rootDirUrl.getFile();\r\n    int separatorIndex = urlFile.indexOf(ResourceUtils.WAR_URL_SEPARATOR);\r\n    if (separatorIndex == -1) {\r\n        separatorIndex = urlFile.indexOf(ResourceUtils.JAR_URL_SEPARATOR);\r\n    }\r\n    if (separatorIndex >= 0) {\r\n        jarFileUrl = urlFile.substring(0, separatorIndex);\r\n        // both separators are 2 chars\r\n        rootEntryPath = urlFile.substring(separatorIndex + 2);\r\n        NavigableSet<String> entriesCache = this.jarEntriesCache.get(jarFileUrl);\r\n        if (entriesCache != null) {\r\n            Set<Resource> result = new LinkedHashSet<>(64);\r\n            // Search sorted entries from first entry with rootEntryPath prefix\r\n            for (String entryPath : entriesCache.tailSet(rootEntryPath, false)) {\r\n                if (!entryPath.startsWith(rootEntryPath)) {\r\n                    // We are beyond the potential matches in the current TreeSet.\r\n                    break;\r\n                }\r\n                String relativePath = entryPath.substring(rootEntryPath.length());\r\n                if (getPathMatcher().match(subPattern, relativePath)) {\r\n                    result.add(rootDirResource.createRelative(relativePath));\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n    URLConnection con = rootDirUrl.openConnection();\r\n    JarFile jarFile;\r\n    boolean closeJarFile;\r\n    if (con instanceof JarURLConnection jarCon) {\r\n        // Should usually be the case for traditional JAR files.\r\n        try {\r\n            jarFile = jarCon.getJarFile();\r\n            jarFileUrl = jarCon.getJarFileURL().toExternalForm();\r\n            JarEntry jarEntry = jarCon.getJarEntry();\r\n            rootEntryPath = (jarEntry != null ? jarEntry.getName() : \"\");\r\n            closeJarFile = !jarCon.getUseCaches();\r\n        } catch (FileNotFoundException ex) {\r\n            // Happens in case of cached root directory without specific subdirectory present.\r\n            return Collections.emptySet();\r\n        }\r\n    } else {\r\n        // No JarURLConnection -> need to resort to URL file parsing.\r\n        // We'll assume URLs of the format \"jar:path!/entry\", with the protocol\r\n        // being arbitrary as long as following the entry format.\r\n        // We'll also handle paths with and without leading \"file:\" prefix.\r\n        try {\r\n            if (jarFileUrl != null) {\r\n                jarFile = getJarFile(jarFileUrl);\r\n            } else {\r\n                jarFile = new JarFile(urlFile);\r\n                jarFileUrl = urlFile;\r\n                rootEntryPath = \"\";\r\n            }\r\n            closeJarFile = true;\r\n        } catch (ZipException ex) {\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"Skipping invalid jar class path entry [\" + urlFile + \"]\");\r\n            }\r\n            return Collections.emptySet();\r\n        }\r\n    }\r\n    try {\r\n        if (logger.isTraceEnabled()) {\r\n            logger.trace(\"Looking for matching resources in jar file [\" + jarFileUrl + \"]\");\r\n        }\r\n        if (StringUtils.hasLength(rootEntryPath) && !rootEntryPath.endsWith(\"/\")) {\r\n            // Root entry path must end with slash to allow for proper matching.\r\n            // The Sun JRE does not return a slash here, but BEA JRockit does.\r\n            rootEntryPath = rootEntryPath + \"/\";\r\n        }\r\n        Set<Resource> result = new LinkedHashSet<>(64);\r\n        NavigableSet<String> entriesCache = new TreeSet<>();\r\n        Iterator<String> entryIterator = jarFile.stream().map(JarEntry::getName).sorted().iterator();\r\n        while (entryIterator.hasNext()) {\r\n            String entryPath = entryIterator.next();\r\n            int entrySeparatorIndex = entryPath.indexOf(ResourceUtils.JAR_URL_SEPARATOR);\r\n            if (entrySeparatorIndex >= 0) {\r\n                entryPath = entryPath.substring(entrySeparatorIndex + ResourceUtils.JAR_URL_SEPARATOR.length());\r\n            }\r\n            entriesCache.add(entryPath);\r\n            if (entryPath.startsWith(rootEntryPath)) {\r\n                String relativePath = entryPath.substring(rootEntryPath.length());\r\n                if (getPathMatcher().match(subPattern, relativePath)) {\r\n                    result.add(rootDirResource.createRelative(relativePath));\r\n                }\r\n            }\r\n        }\r\n        // Cache jar entries in TreeSet for efficient searching on re-encounter.\r\n        this.jarEntriesCache.put(jarFileUrl, entriesCache);\r\n        return result;\r\n    } finally {\r\n        if (closeJarFile) {\r\n            jarFile.close();\r\n        }\r\n    }\r\n}\n/**\r\n * Resolve the given jar file URL into a JarFile object.\r\n */\r\nprotected JarFile getJarFile(String jarFileUrl) throws IOException {\r\n    if (jarFileUrl.startsWith(ResourceUtils.FILE_URL_PREFIX)) {\r\n        try {\r\n            return new JarFile(ResourceUtils.toURI(jarFileUrl).getSchemeSpecificPart());\r\n        } catch (URISyntaxException ex) {\r\n            // Fallback for URLs that are not valid URIs (should hardly ever happen).\r\n            return new JarFile(jarFileUrl.substring(ResourceUtils.FILE_URL_PREFIX.length()));\r\n        }\r\n    } else {\r\n        return new JarFile(jarFileUrl);\r\n    }\r\n}\n/**\r\n * Find all resources in the file system of the supplied root directory that\r\n * match the given location sub pattern via the Ant-style {@link #getPathMatcher()\r\n * PathMatcher}.\r\n * @param rootDirResource the root directory as a Resource\r\n * @param subPattern the sub pattern to match (below the root directory)\r\n * @return a mutable Set of matching Resource instances\r\n * @throws IOException in case of I/O errors\r\n * @see org.springframework.util.PathMatcher\r\n */\r\nprotected Set<Resource> doFindPathMatchingFileResources(Resource rootDirResource, String subPattern) throws IOException {\r\n    Set<Resource> result = new LinkedHashSet<>(64);\r\n    URI rootDirUri;\r\n    try {\r\n        rootDirUri = rootDirResource.getURI();\r\n    } catch (Exception ex) {\r\n        if (logger.isWarnEnabled()) {\r\n            logger.warn(\"Failed to resolve directory [%s] as URI: %s\".formatted(rootDirResource, ex));\r\n        }\r\n        return result;\r\n    }\r\n    Path rootPath = null;\r\n    if (rootDirUri.isAbsolute() && !rootDirUri.isOpaque()) {\r\n        // Prefer Path resolution from URI if possible\r\n        try {\r\n            try {\r\n                rootPath = Path.of(rootDirUri);\r\n            } catch (FileSystemNotFoundException ex) {\r\n                // If the file system was not found, assume it's a custom file system that needs to be installed.\r\n                FileSystems.newFileSystem(rootDirUri, Map.of(), ClassUtils.getDefaultClassLoader());\r\n                rootPath = Path.of(rootDirUri);\r\n            }\r\n        } catch (Exception ex) {\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"Failed to resolve %s in file system: %s\".formatted(rootDirUri, ex));\r\n            }\r\n            // Fallback via Resource.getFile() below\r\n        }\r\n    }\r\n    if (rootPath == null) {\r\n        // Resource.getFile() resolution as a fallback -\r\n        // for custom URI formats and custom Resource implementations\r\n        try {\r\n            rootPath = Path.of(rootDirResource.getFile().getAbsolutePath());\r\n        } catch (FileNotFoundException ex) {\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"Cannot search for matching files underneath \" + rootDirResource + \" in the file system: \" + ex.getMessage());\r\n            }\r\n            return result;\r\n        } catch (Exception ex) {\r\n            if (logger.isInfoEnabled()) {\r\n                logger.info(\"Failed to resolve \" + rootDirResource + \" in the file system: \" + ex);\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n    if (!Files.exists(rootPath)) {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"Skipping search for files matching pattern [%s]: directory [%s] does not exist\".formatted(subPattern, rootPath.toAbsolutePath()));\r\n        }\r\n        return result;\r\n    }\r\n    String rootDir = StringUtils.cleanPath(rootPath.toString());\r\n    if (!rootDir.endsWith(\"/\")) {\r\n        rootDir += \"/\";\r\n    }\r\n    Path rootPathForPattern = rootPath;\r\n    String resourcePattern = rootDir + StringUtils.cleanPath(subPattern);\r\n    Predicate<Path> isMatchingFile = path -> (!path.equals(rootPathForPattern) && getPathMatcher().match(resourcePattern, StringUtils.cleanPath(path.toString())));\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(\"Searching directory [%s] for files matching pattern [%s]\".formatted(rootPath.toAbsolutePath(), subPattern));\r\n    }\r\n    try (Stream<Path> files = Files.walk(rootPath, FileVisitOption.FOLLOW_LINKS)) {\r\n        files.filter(isMatchingFile).sorted().map(FileSystemResource::new).forEach(result::add);\r\n    } catch (Exception ex) {\r\n        if (logger.isWarnEnabled()) {\r\n            logger.warn(\"Failed to search in directory [%s] for files matching pattern [%s]: %s\".formatted(rootPath.toAbsolutePath(), subPattern, ex));\r\n        }\r\n    }\r\n    return result;\r\n}\n/**\r\n * Resolve the given location pattern into {@code Resource} objects for all\r\n * matching resources found in the module path.\r\n * <p>The location pattern may be an explicit resource path such as\r\n * {@code \"com/example/config.xml\"} or a pattern such as\r\n * <code>\"com/example/**&#47;config-*.xml\"</code> to be matched using the\r\n * configured {@link #getPathMatcher() PathMatcher}.\r\n * <p>The default implementation scans all modules in the {@linkplain ModuleLayer#boot()\r\n * boot layer}, excluding {@linkplain ModuleFinder#ofSystem() system modules}.\r\n * @param locationPattern the location pattern to resolve\r\n * @return a modifiable {@code Set} containing the corresponding {@code Resource}\r\n * objects\r\n * @throws IOException in case of I/O errors\r\n * @since 6.0\r\n * @see ModuleLayer#boot()\r\n * @see ModuleFinder#ofSystem()\r\n * @see ModuleReader\r\n * @see PathMatcher#match(String, String)\r\n */\r\nprotected Set<Resource> findAllModulePathResources(String locationPattern) throws IOException {\r\n    Set<Resource> result = new LinkedHashSet<>(64);\r\n    // Skip scanning the module path when running in a native image.\r\n    if (NativeDetector.inNativeImage()) {\r\n        return result;\r\n    }\r\n    String resourcePattern = stripLeadingSlash(locationPattern);\r\n    Predicate<String> resourcePatternMatches = (getPathMatcher().isPattern(resourcePattern) ? path -> getPathMatcher().match(resourcePattern, path) : resourcePattern::equals);\r\n    try {\r\n        ModuleLayer.boot().configuration().modules().stream().filter(isNotSystemModule).forEach(resolvedModule -> {\r\n            // NOTE: a ModuleReader and a Stream returned from ModuleReader.list() must be closed.\r\n            try (ModuleReader moduleReader = resolvedModule.reference().open();\r\n                Stream<String> names = moduleReader.list()) {\r\n                names.filter(resourcePatternMatches).map(name -> findResource(moduleReader, name)).filter(Objects::nonNull).forEach(result::add);\r\n            } catch (IOException ex) {\r\n                if (logger.isDebugEnabled()) {\r\n                    logger.debug(\"Failed to read contents of module [%s]\".formatted(resolvedModule), ex);\r\n                }\r\n                throw new UncheckedIOException(ex);\r\n            }\r\n        });\r\n    } catch (UncheckedIOException ex) {\r\n        // Unwrap IOException to conform to this method's contract.\r\n        throw ex.getCause();\r\n    }\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(\"Resolved module-path location pattern [%s] to resources %s\".formatted(resourcePattern, result));\r\n    }\r\n    return result;\r\n}\n@Nullable\r\nprivate Resource findResource(ModuleReader moduleReader, String name) {\r\n    try {\r\n        return moduleReader.find(name).map(this::convertModuleSystemURI).orElse(null);\r\n    } catch (Exception ex) {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"Failed to find resource [%s] in module path\".formatted(name), ex);\r\n        }\r\n        return null;\r\n    }\r\n}\n/**\r\n * If it's a \"file:\" URI, use {@link FileSystemResource} to avoid duplicates\r\n * for the same path discovered via class path scanning.\r\n */\r\nprivate Resource convertModuleSystemURI(URI uri) {\r\n    return (ResourceUtils.URL_PROTOCOL_FILE.equals(uri.getScheme()) ? new FileSystemResource(uri.getPath()) : UrlResource.from(uri));\r\n}\nprivate static String stripLeadingSlash(String path) {\r\n    return (path.startsWith(\"/\") ? path.substring(1) : path);\r\n}\nprivate static boolean checkPathWithinPackage(String path) {\r\n    return (path.contains(\"/\") && !path.contains(ResourceUtils.JAR_URL_SEPARATOR));\r\n}\n/**\r\n * Inner delegate class, avoiding a hard JBoss VFS API dependency at runtime.\r\n */\r\nprivate static class VfsResourceMatchingDelegate {\r\n\r\n    public static Set<Resource> findMatchingResources(URL rootDirUrl, String locationPattern, PathMatcher pathMatcher) throws IOException {\r\n        Object root = VfsPatternUtils.findRoot(rootDirUrl);\r\n        PatternVirtualFileVisitor visitor = new PatternVirtualFileVisitor(VfsPatternUtils.getPath(root), locationPattern, pathMatcher);\r\n        VfsPatternUtils.visit(root, visitor);\r\n        return visitor.getResources();\r\n    }\r\n}\n/**\r\n * VFS visitor for path matching purposes.\r\n */\r\n@SuppressWarnings(\"unused\")\r\nprivate static class PatternVirtualFileVisitor implements InvocationHandler {\r\n\r\n    private final String subPattern;\r\n\r\n    private final PathMatcher pathMatcher;\r\n\r\n    private final String rootPath;\r\n\r\n    private final Set<Resource> resources = new LinkedHashSet<>(64);\r\n\r\n    public PatternVirtualFileVisitor(String rootPath, String subPattern, PathMatcher pathMatcher) {\r\n        this.subPattern = subPattern;\r\n        this.pathMatcher = pathMatcher;\r\n        this.rootPath = (rootPath.isEmpty() || rootPath.endsWith(\"/\") ? rootPath : rootPath + \"/\");\r\n    }\r\n\r\n    @Override\r\n    @Nullable\r\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n        String methodName = method.getName();\r\n        if (Object.class == method.getDeclaringClass()) {\r\n            switch(methodName) {\r\n                case \"equals\" ->\r\n                    {\r\n                        // Only consider equal when proxies are identical.\r\n                        return (proxy == args[0]);\r\n                    }\r\n                case \"hashCode\" ->\r\n                    {\r\n                        return System.identityHashCode(proxy);\r\n                    }\r\n            }\r\n        }\r\n        return switch(methodName) {\r\n            case \"getAttributes\" ->\r\n                getAttributes();\r\n            case \"visit\" ->\r\n                {\r\n                    visit(args[0]);\r\n                    yield null;\r\n                }\r\n            case \"toString\" ->\r\n                toString();\r\n            default ->\r\n                throw new IllegalStateException(\"Unexpected method invocation: \" + method);\r\n        };\r\n    }\r\n\r\n    public void visit(Object vfsResource) {\r\n        if (this.pathMatcher.match(this.subPattern, VfsPatternUtils.getPath(vfsResource).substring(this.rootPath.length()))) {\r\n            this.resources.add(new VfsResource(vfsResource));\r\n        }\r\n    }\r\n\r\n    @Nullable\r\n    public Object getAttributes() {\r\n        return VfsPatternUtils.getVisitorAttributes();\r\n    }\r\n\r\n    public Set<Resource> getResources() {\r\n        return this.resources;\r\n    }\r\n\r\n    public int size() {\r\n        return this.resources.size();\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"sub-pattern: \" + this.subPattern + \", resources: \" + this.resources;\r\n    }\r\n}\n/**\r\n * A single {@code Class-Path} manifest entry.\r\n */\r\nprivate record ClassPathManifestEntry(Resource resource, @Nullable Resource alternative) {\r\n\r\n    private static final String JARFILE_URL_PREFIX = ResourceUtils.JAR_URL_PREFIX + ResourceUtils.FILE_URL_PREFIX;\r\n\r\n    static ClassPathManifestEntry of(File file) throws MalformedURLException {\r\n        String path = fixPath(file.getAbsolutePath());\r\n        Resource resource = asJarFileResource(path);\r\n        Resource alternative = createAlternative(path);\r\n        return new ClassPathManifestEntry(resource, alternative);\r\n    }\r\n\r\n    private static String fixPath(String path) {\r\n        int prefixIndex = path.indexOf(':');\r\n        if (prefixIndex == 1) {\r\n            // Possibly a drive prefix on Windows (for example, \"c:\"), so we prepend a slash\r\n            // and convert the drive letter to uppercase for consistent duplicate detection.\r\n            path = \"/\" + StringUtils.capitalize(path);\r\n        }\r\n        // Since '#' can appear in directories/filenames, java.net.URL should not treat it as a fragment\r\n        return StringUtils.replace(path, \"#\", \"%23\");\r\n    }\r\n\r\n    /**\r\n     * Return a alternative form of the resource, i.e. with or without a leading slash.\r\n     * @param path the file path (with or without a leading slash)\r\n     * @return the alternative form or {@code null}\r\n     */\r\n    @Nullable\r\n    private static Resource createAlternative(String path) {\r\n        try {\r\n            String alternativePath = path.startsWith(\"/\") ? path.substring(1) : \"/\" + path;\r\n            return asJarFileResource(alternativePath);\r\n        } catch (MalformedURLException ex) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private static Resource asJarFileResource(String path) throws MalformedURLException {\r\n        return new UrlResource(JARFILE_URL_PREFIX + path + ResourceUtils.JAR_URL_SEPARATOR);\r\n    }\r\n}",
    "comment": "\n * A {@link ResourcePatternResolver} implementation that is able to resolve a\n * specified resource location path into one or more matching Resources.\n *\n * <p>The source path may be a simple path which has a one-to-one mapping to a\n * target {@link org.springframework.core.io.Resource}, or alternatively may\n * contain the special \"{@code classpath*:}\" prefix and/or internal Ant-style\n * path patterns (matched using Spring's {@link AntPathMatcher} utility). Both\n * of the latter are effectively wildcards.\n *\n * <h3>No Wildcards</h3>\n *\n * <p>In the simple case, if the specified location path does not start with the\n * {@code \"classpath*:}\" prefix and does not contain a {@link PathMatcher}\n * pattern, this resolver will simply return a single resource via a\n * {@code getResource()} call on the underlying {@code ResourceLoader}.\n * Examples are real URLs such as \"{@code file:C:/context.xml}\", pseudo-URLs\n * such as \"{@code classpath:/context.xml}\", and simple unprefixed paths\n * such as \"{@code /WEB-INF/context.xml}\". The latter will resolve in a\n * fashion specific to the underlying {@code ResourceLoader} (for example,\n * {@code ServletContextResource} for a {@code WebApplicationContext}).\n *\n * <h3>Ant-style Patterns</h3>\n *\n * <p>When the path location contains an Ant-style pattern, for example:\n * <pre class=\"code\">\n * /WEB-INF/*-context.xml\n * com/example/**&#47;applicationContext.xml\n * file:C:/some/path/*-context.xml\n * classpath:com/example/**&#47;applicationContext.xml</pre>\n * the resolver follows a more complex but defined procedure to try to resolve\n * the wildcard. It produces a {@code Resource} for the path up to the last\n * non-wildcard segment and obtains a {@code URL} from it. If this URL is not a\n * \"{@code jar:}\" URL or container-specific variant (for example, \"{@code zip:}\" in WebLogic,\n * \"{@code wsjar}\" in WebSphere\", etc.), then the root directory of the filesystem\n * associated with the URL is obtained and used to resolve the wildcards by walking\n * the filesystem. In the case of a jar URL, the resolver either gets a\n * {@code java.net.JarURLConnection} from it, or manually parses the jar URL, and\n * then traverses the contents of the jar file, to resolve the wildcards.\n *\n * <h3>Implications on Portability</h3>\n *\n * <p>If the specified path is already a file URL (either explicitly, or\n * implicitly because the base {@code ResourceLoader} is a filesystem one),\n * then wildcarding is guaranteed to work in a completely portable fashion.\n *\n * <p>If the specified path is a class path location, then the resolver must\n * obtain the last non-wildcard path segment URL via a\n * {@code Classloader.getResource()} call. Since this is just a\n * node of the path (not the file at the end) it is actually undefined\n * (in the ClassLoader Javadocs) exactly what sort of URL is returned in\n * this case. In practice, it is usually a {@code java.io.File} representing\n * the directory, where the class path resource resolves to a filesystem\n * location, or a jar URL of some sort, where the class path resource resolves\n * to a jar location. Still, there is a portability concern on this operation.\n *\n * <p>If a jar URL is obtained for the last non-wildcard segment, the resolver\n * must be able to get a {@code java.net.JarURLConnection} from it, or\n * manually parse the jar URL, to be able to walk the contents of the jar\n * and resolve the wildcard. This will work in most environments but will\n * fail in others, and it is strongly recommended that the wildcard\n * resolution of resources coming from jars be thoroughly tested in your\n * specific environment before you rely on it.\n *\n * <h3>{@code classpath*:} Prefix</h3>\n *\n * <p>There is special support for retrieving multiple class path resources with\n * the same name, via the \"{@code classpath*:}\" prefix. For example,\n * \"{@code classpath*:META-INF/beans.xml}\" will find all \"META-INF/beans.xml\"\n * files in the class path, be it in \"classes\" directories or in JAR files.\n * This is particularly useful for autodetecting config files of the same name\n * at the same location within each jar file. Internally, this happens via a\n * {@code ClassLoader.getResources()} call, and is completely portable.\n *\n * <p>The \"{@code classpath*:}\" prefix can also be combined with a {@code PathMatcher}\n * pattern in the rest of the location path &mdash; for example,\n * \"{@code classpath*:META-INF/*-beans.xml\"}. In this case, the resolution strategy\n * is fairly simple: a {@code ClassLoader.getResources()} call is used on the last\n * non-wildcard path segment to get all the matching resources in the class loader\n * hierarchy, and then off each resource the same {@code PathMatcher} resolution\n * strategy described above is used for the wildcard sub pattern.\n *\n * <h3>Other Notes</h3>\n *\n * <p>As of Spring Framework 6.0, if {@link #getResources(String)} is invoked with\n * a location pattern using the \"{@code classpath*:}\" prefix it will first search\n * all modules in the {@linkplain ModuleLayer#boot() boot layer}, excluding\n * {@linkplain ModuleFinder#ofSystem() system modules}. It will then search the\n * class path using {@link ClassLoader} APIs as described previously and return the\n * combined results. Consequently, some of the limitations of class path searches\n * may not apply when applications are deployed as modules.\n *\n * <p><b>WARNING:</b> Note that \"{@code classpath*:}\" when combined with\n * Ant-style patterns will only work reliably with at least one root directory\n * before the pattern starts, unless the actual target files reside in the file\n * system. This means that a pattern like \"{@code classpath*:*.xml}\" will\n * <i>not</i> retrieve files from the root of jar files but rather only from the\n * root of expanded directories. This originates from a limitation in the JDK's\n * {@code ClassLoader.getResources()} method which only returns file system\n * locations for a passed-in empty String (indicating potential roots to search).\n * This {@code ResourcePatternResolver} implementation tries to mitigate the\n * jar root lookup limitation through {@link URLClassLoader} introspection and\n * \"{@code java.class.path}\" manifest evaluation; however, without portability\n * guarantees.\n *\n * <p><b>WARNING:</b> Ant-style patterns with \"{@code classpath:}\" resources are not\n * guaranteed to find matching resources if the base package to search is available\n * in multiple class path locations. This is because a resource such as\n * <pre class=\"code\">\n *   com/example/package1/service-context.xml</pre>\n * may exist in only one class path location, but when a location pattern such as\n * <pre class=\"code\">\n *   classpath:com/example/**&#47;service-context.xml</pre>\n * is used to try to resolve it, the resolver will work off the (first) URL\n * returned by {@code getResource(\"com/example\")}. If the {@code com/example} base\n * package node exists in multiple class path locations, the actual desired resource\n * may not be present under the {@code com/example} base package in the first URL.\n * Therefore, preferably, use \"{@code classpath*:}\" with the same Ant-style pattern\n * in such a case, which will search <i>all</i> class path locations that contain\n * the base package.\n *\n * @author Juergen Hoeller\n * @author Colin Sampaleanu\n * @author Marius Bogoevici\n * @author Costin Leau\n * @author Phillip Webb\n * @author Sam Brannen\n * @author Sebastien Deleuze\n * @author Dave Syer\n * @since 1.0.2\n * @see #CLASSPATH_ALL_URL_PREFIX\n * @see org.springframework.util.AntPathMatcher\n * @see org.springframework.core.io.ResourceLoader#getResource(String)\n * @see ClassLoader#getResources(String)\n "
  },
  {
    "entityId": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#getResourceLoader()",
    "entityType": "method",
    "code": "/**\r\n * Return the {@link ResourceLoader} that this pattern resolver works with.\r\n */\r\npublic ResourceLoader getResourceLoader() {\r\n    return this.resourceLoader;\r\n}",
    "comment": "\n\t * Return the {@link ResourceLoader} that this pattern resolver works with.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#getClassLoader()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic ClassLoader getClassLoader() {\r\n    return getResourceLoader().getClassLoader();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#setPathMatcher(PathMatcher)",
    "entityType": "method",
    "code": "/**\r\n * Set the {@link PathMatcher} implementation to use for this\r\n * resource pattern resolver.\r\n * <p>Default is {@link AntPathMatcher}.\r\n * @see AntPathMatcher\r\n */\r\npublic void setPathMatcher(PathMatcher pathMatcher) {\r\n    Assert.notNull(pathMatcher, \"PathMatcher must not be null\");\r\n    this.pathMatcher = pathMatcher;\r\n}",
    "comment": "\n\t * Set the {@link PathMatcher} implementation to use for this\n\t * resource pattern resolver.\n\t * <p>Default is {@link AntPathMatcher}.\n\t * @see AntPathMatcher\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#getPathMatcher()",
    "entityType": "method",
    "code": "/**\r\n * Return the {@link PathMatcher} that this resource pattern resolver uses.\r\n */\r\npublic PathMatcher getPathMatcher() {\r\n    return this.pathMatcher;\r\n}",
    "comment": "\n\t * Return the {@link PathMatcher} that this resource pattern resolver uses.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#getResource(String)",
    "entityType": "method",
    "code": "@Override\r\npublic Resource getResource(String location) {\r\n    return getResourceLoader().getResource(location);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#getResources(String)",
    "entityType": "method",
    "code": "@Override\r\npublic Resource[] getResources(String locationPattern) throws IOException {\r\n    Assert.notNull(locationPattern, \"Location pattern must not be null\");\r\n    if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) {\r\n        // a class path resource (multiple resources for same name possible)\r\n        String locationPatternWithoutPrefix = locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length());\r\n        // Search the module path first.\r\n        Set<Resource> resources = findAllModulePathResources(locationPatternWithoutPrefix);\r\n        // Search the class path next.\r\n        if (getPathMatcher().isPattern(locationPatternWithoutPrefix)) {\r\n            // a class path resource pattern\r\n            Collections.addAll(resources, findPathMatchingResources(locationPattern));\r\n        } else {\r\n            // all class path resources with the given name\r\n            Collections.addAll(resources, findAllClassPathResources(locationPatternWithoutPrefix));\r\n        }\r\n        return resources.toArray(new Resource[0]);\r\n    } else {\r\n        // Generally only look for a pattern after a prefix here,\r\n        // and on Tomcat only after the \"*/\" separator for its \"war:\" protocol.\r\n        int prefixEnd = (locationPattern.startsWith(\"war:\") ? locationPattern.indexOf(\"*/\") + 1 : locationPattern.indexOf(':') + 1);\r\n        if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) {\r\n            // a file pattern\r\n            return findPathMatchingResources(locationPattern);\r\n        } else {\r\n            // a single resource with the given name\r\n            return new Resource[] { getResourceLoader().getResource(locationPattern) };\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#clearCache()",
    "entityType": "method",
    "code": "/**\r\n * Clear the local resource cache, removing all cached classpath/jar structures.\r\n * @since 6.2\r\n */\r\npublic void clearCache() {\r\n    this.rootDirCache.clear();\r\n    this.jarEntriesCache.clear();\r\n    this.manifestEntriesCache = null;\r\n}",
    "comment": "\n\t * Clear the local resource cache, removing all cached classpath/jar structures.\n\t * @since 6.2\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#findAllClassPathResources(String)",
    "entityType": "method",
    "code": "/**\r\n * Find all class location resources with the given location via the ClassLoader.\r\n * <p>Delegates to {@link #doFindAllClassPathResources(String)}.\r\n * @param location the absolute path within the class path\r\n * @return the result as Resource array\r\n * @throws IOException in case of I/O errors\r\n * @see java.lang.ClassLoader#getResources\r\n * @see #convertClassLoaderURL\r\n */\r\nprotected Resource[] findAllClassPathResources(String location) throws IOException {\r\n    String path = stripLeadingSlash(location);\r\n    Set<Resource> result = doFindAllClassPathResources(path);\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(\"Resolved class path location [\" + path + \"] to resources \" + result);\r\n    }\r\n    return result.toArray(new Resource[0]);\r\n}",
    "comment": "\n\t * Find all class location resources with the given location via the ClassLoader.\n\t * <p>Delegates to {@link #doFindAllClassPathResources(String)}.\n\t * @param location the absolute path within the class path\n\t * @return the result as Resource array\n\t * @throws IOException in case of I/O errors\n\t * @see java.lang.ClassLoader#getResources\n\t * @see #convertClassLoaderURL\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#doFindAllClassPathResources(String)",
    "entityType": "method",
    "code": "/**\r\n * Find all class path resources with the given path via the configured\r\n * {@link #getClassLoader() ClassLoader}.\r\n * <p>Called by {@link #findAllClassPathResources(String)}.\r\n * @param path the absolute path within the class path (never a leading slash)\r\n * @return a mutable Set of matching Resource instances\r\n * @since 4.1.1\r\n */\r\nprotected Set<Resource> doFindAllClassPathResources(String path) throws IOException {\r\n    Set<Resource> result = new LinkedHashSet<>(16);\r\n    ClassLoader cl = getClassLoader();\r\n    Enumeration<URL> resourceUrls = (cl != null ? cl.getResources(path) : ClassLoader.getSystemResources(path));\r\n    while (resourceUrls.hasMoreElements()) {\r\n        URL url = resourceUrls.nextElement();\r\n        result.add(convertClassLoaderURL(url));\r\n    }\r\n    if (!StringUtils.hasLength(path)) {\r\n        // The above result is likely to be incomplete, i.e. only containing file system references.\r\n        // We need to have pointers to each of the jar files on the class path as well...\r\n        addAllClassLoaderJarRoots(cl, result);\r\n    }\r\n    return result;\r\n}",
    "comment": "\n\t * Find all class path resources with the given path via the configured\n\t * {@link #getClassLoader() ClassLoader}.\n\t * <p>Called by {@link #findAllClassPathResources(String)}.\n\t * @param path the absolute path within the class path (never a leading slash)\n\t * @return a mutable Set of matching Resource instances\n\t * @since 4.1.1\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#convertClassLoaderURL(URL)",
    "entityType": "method",
    "code": "/**\r\n * Convert the given URL as returned from the configured\r\n * {@link #getClassLoader() ClassLoader} into a {@link Resource}, applying\r\n * to path lookups without a pattern (see {@link #findAllClassPathResources}).\r\n * <p>As of 6.0.5, the default implementation creates a {@link FileSystemResource}\r\n * in case of the \"file\" protocol or a {@link UrlResource} otherwise, matching\r\n * the outcome of pattern-based class path traversal in the same resource layout,\r\n * as well as matching the outcome of module path searches.\r\n * @param url a URL as returned from the configured ClassLoader\r\n * @return the corresponding Resource object\r\n * @see java.lang.ClassLoader#getResources\r\n * @see #doFindAllClassPathResources\r\n * @see #doFindPathMatchingFileResources\r\n */\r\n// on JDK 20 (deprecated URL constructor)\r\n@SuppressWarnings(\"deprecation\")\r\nprotected Resource convertClassLoaderURL(URL url) {\r\n    if (ResourceUtils.URL_PROTOCOL_FILE.equals(url.getProtocol())) {\r\n        try {\r\n            // URI decoding for special characters such as spaces.\r\n            return new FileSystemResource(ResourceUtils.toURI(url).getSchemeSpecificPart());\r\n        } catch (URISyntaxException ex) {\r\n            // Fallback for URLs that are not valid URIs (should hardly ever happen).\r\n            return new FileSystemResource(url.getFile());\r\n        }\r\n    } else {\r\n        String urlString = url.toString();\r\n        String cleanedPath = StringUtils.cleanPath(urlString);\r\n        if (!cleanedPath.equals(urlString)) {\r\n            // Prefer cleaned URL, aligned with UrlResource#createRelative(String)\r\n            try {\r\n                // Retain original URL instance, potentially including custom URLStreamHandler.\r\n                return new UrlResource(new URL(url, cleanedPath));\r\n            } catch (MalformedURLException ex) {\r\n                // Fallback to regular URL construction below...\r\n            }\r\n        }\r\n        // Retain original URL instance, potentially including custom URLStreamHandler.\r\n        return new UrlResource(url);\r\n    }\r\n}",
    "comment": "\n\t * Convert the given URL as returned from the configured\n\t * {@link #getClassLoader() ClassLoader} into a {@link Resource}, applying\n\t * to path lookups without a pattern (see {@link #findAllClassPathResources}).\n\t * <p>As of 6.0.5, the default implementation creates a {@link FileSystemResource}\n\t * in case of the \"file\" protocol or a {@link UrlResource} otherwise, matching\n\t * the outcome of pattern-based class path traversal in the same resource layout,\n\t * as well as matching the outcome of module path searches.\n\t * @param url a URL as returned from the configured ClassLoader\n\t * @return the corresponding Resource object\n\t * @see java.lang.ClassLoader#getResources\n\t * @see #doFindAllClassPathResources\n\t * @see #doFindPathMatchingFileResources\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#addAllClassLoaderJarRoots(ClassLoader,Set<Resource>)",
    "entityType": "method",
    "code": "/**\r\n * Search all {@link URLClassLoader} URLs for jar file references and add each to the\r\n * given set of resources in the form of a pointer to the root of the jar file content.\r\n * @param classLoader the ClassLoader to search (including its ancestors)\r\n * @param result the set of resources to add jar roots to\r\n * @since 4.1.1\r\n */\r\nprotected void addAllClassLoaderJarRoots(@Nullable ClassLoader classLoader, Set<Resource> result) {\r\n    if (classLoader instanceof URLClassLoader urlClassLoader) {\r\n        try {\r\n            for (URL url : urlClassLoader.getURLs()) {\r\n                try {\r\n                    UrlResource jarResource = (ResourceUtils.URL_PROTOCOL_JAR.equals(url.getProtocol()) ? new UrlResource(url) : new UrlResource(ResourceUtils.JAR_URL_PREFIX + url + ResourceUtils.JAR_URL_SEPARATOR));\r\n                    if (jarResource.exists()) {\r\n                        result.add(jarResource);\r\n                    }\r\n                } catch (MalformedURLException ex) {\r\n                    if (logger.isDebugEnabled()) {\r\n                        logger.debug(\"Cannot search for matching files underneath [\" + url + \"] because it cannot be converted to a valid 'jar:' URL: \" + ex.getMessage());\r\n                    }\r\n                }\r\n            }\r\n        } catch (Exception ex) {\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"Cannot introspect jar files since ClassLoader [\" + classLoader + \"] does not support 'getURLs()': \" + ex);\r\n            }\r\n        }\r\n    }\r\n    if (classLoader == ClassLoader.getSystemClassLoader()) {\r\n        // JAR \"Class-Path\" manifest header evaluation...\r\n        addClassPathManifestEntries(result);\r\n    }\r\n    if (classLoader != null) {\r\n        try {\r\n            // Hierarchy traversal...\r\n            addAllClassLoaderJarRoots(classLoader.getParent(), result);\r\n        } catch (Exception ex) {\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"Cannot introspect jar files in parent ClassLoader since [\" + classLoader + \"] does not support 'getParent()': \" + ex);\r\n            }\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Search all {@link URLClassLoader} URLs for jar file references and add each to the\n\t * given set of resources in the form of a pointer to the root of the jar file content.\n\t * @param classLoader the ClassLoader to search (including its ancestors)\n\t * @param result the set of resources to add jar roots to\n\t * @since 4.1.1\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#addClassPathManifestEntries(Set<Resource>)",
    "entityType": "method",
    "code": "/**\r\n * Determine jar file references from {@code Class-Path} manifest entries (which\r\n * are added to the {@code java.class.path} JVM system property by the system\r\n * class loader) and add each to the given set of resources in the form of\r\n * a pointer to the root of the jar file content.\r\n * @param result the set of resources to add jar roots to\r\n * @since 4.3\r\n */\r\nprotected void addClassPathManifestEntries(Set<Resource> result) {\r\n    Set<ClassPathManifestEntry> entries = this.manifestEntriesCache;\r\n    if (entries == null) {\r\n        entries = getClassPathManifestEntries();\r\n        this.manifestEntriesCache = entries;\r\n    }\r\n    for (ClassPathManifestEntry entry : entries) {\r\n        if (!result.contains(entry.resource()) && (entry.alternative() != null && !result.contains(entry.alternative()))) {\r\n            result.add(entry.resource());\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Determine jar file references from {@code Class-Path} manifest entries (which\n\t * are added to the {@code java.class.path} JVM system property by the system\n\t * class loader) and add each to the given set of resources in the form of\n\t * a pointer to the root of the jar file content.\n\t * @param result the set of resources to add jar roots to\n\t * @since 4.3\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#getClassPathManifestEntries()",
    "entityType": "method",
    "code": "private Set<ClassPathManifestEntry> getClassPathManifestEntries() {\r\n    Set<ClassPathManifestEntry> manifestEntries = new LinkedHashSet<>();\r\n    Set<File> seen = new HashSet<>();\r\n    try {\r\n        String paths = System.getProperty(\"java.class.path\");\r\n        for (String path : StringUtils.delimitedListToStringArray(paths, File.pathSeparator)) {\r\n            try {\r\n                File jar = new File(path).getAbsoluteFile();\r\n                if (jar.isFile() && seen.add(jar)) {\r\n                    manifestEntries.add(ClassPathManifestEntry.of(jar));\r\n                    manifestEntries.addAll(getClassPathManifestEntriesFromJar(jar));\r\n                }\r\n            } catch (MalformedURLException ex) {\r\n                if (logger.isDebugEnabled()) {\r\n                    logger.debug(\"Cannot search for matching files underneath [\" + path + \"] because it cannot be converted to a valid 'jar:' URL: \" + ex.getMessage());\r\n                }\r\n            }\r\n        }\r\n        return Collections.unmodifiableSet(manifestEntries);\r\n    } catch (Exception ex) {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"Failed to evaluate 'java.class.path' manifest entries: \" + ex);\r\n        }\r\n        return Collections.emptySet();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#getClassPathManifestEntriesFromJar(File)",
    "entityType": "method",
    "code": "private Set<ClassPathManifestEntry> getClassPathManifestEntriesFromJar(File jar) throws IOException {\r\n    URL base = jar.toURI().toURL();\r\n    File parent = jar.getAbsoluteFile().getParentFile();\r\n    try (JarFile jarFile = new JarFile(jar)) {\r\n        Manifest manifest = jarFile.getManifest();\r\n        Attributes attributes = (manifest != null ? manifest.getMainAttributes() : null);\r\n        String classPath = (attributes != null ? attributes.getValue(Name.CLASS_PATH) : null);\r\n        Set<ClassPathManifestEntry> manifestEntries = new LinkedHashSet<>();\r\n        if (StringUtils.hasLength(classPath)) {\r\n            StringTokenizer tokenizer = new StringTokenizer(classPath);\r\n            while (tokenizer.hasMoreTokens()) {\r\n                String path = tokenizer.nextToken();\r\n                if (path.indexOf(':') >= 0 && !\"file\".equalsIgnoreCase(new URL(base, path).getProtocol())) {\r\n                    // See jdk.internal.loader.URLClassPath.JarLoader.tryResolveFile(URL, String)\r\n                    continue;\r\n                }\r\n                File candidate = new File(parent, path);\r\n                if (candidate.isFile() && candidate.getCanonicalPath().contains(parent.getCanonicalPath())) {\r\n                    manifestEntries.add(ClassPathManifestEntry.of(candidate));\r\n                }\r\n            }\r\n        }\r\n        return Collections.unmodifiableSet(manifestEntries);\r\n    } catch (Exception ex) {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"Failed to load manifest entries from jar file '\" + jar + \"': \" + ex);\r\n        }\r\n        return Collections.emptySet();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#findPathMatchingResources(String)",
    "entityType": "method",
    "code": "/**\r\n * Find all resources that match the given location pattern via the Ant-style\r\n * {@link #getPathMatcher() PathMatcher}.\r\n * <p>Supports resources in OSGi bundles, JBoss VFS, jar files, zip files,\r\n * and file systems.\r\n * @param locationPattern the location pattern to match\r\n * @return the result as Resource array\r\n * @throws IOException in case of I/O errors\r\n * @see #determineRootDir(String)\r\n * @see #resolveRootDirResource(Resource)\r\n * @see #isJarResource(Resource)\r\n * @see #doFindPathMatchingJarResources(Resource, URL, String)\r\n * @see #doFindPathMatchingFileResources(Resource, String)\r\n * @see org.springframework.util.PathMatcher\r\n */\r\nprotected Resource[] findPathMatchingResources(String locationPattern) throws IOException {\r\n    String rootDirPath = determineRootDir(locationPattern);\r\n    String subPattern = locationPattern.substring(rootDirPath.length());\r\n    // Look for pre-cached root dir resources, either a direct match or\r\n    // a match for a parent directory in the same classpath locations.\r\n    Resource[] rootDirResources = this.rootDirCache.get(rootDirPath);\r\n    String actualRootPath = null;\r\n    if (rootDirResources == null) {\r\n        // No direct match -> search for a common parent directory match\r\n        // (cached based on repeated searches in the same base location,\r\n        // in particular for different root directories in the same jar).\r\n        String commonPrefix = null;\r\n        String existingPath = null;\r\n        boolean commonUnique = true;\r\n        for (String path : this.rootDirCache.keySet()) {\r\n            String currentPrefix = null;\r\n            for (int i = 0; i < path.length(); i++) {\r\n                if (i == rootDirPath.length() || path.charAt(i) != rootDirPath.charAt(i)) {\r\n                    currentPrefix = path.substring(0, path.lastIndexOf('/', i - 1) + 1);\r\n                    break;\r\n                }\r\n            }\r\n            if (currentPrefix != null) {\r\n                if (checkPathWithinPackage(path.substring(currentPrefix.length()))) {\r\n                    // A prefix match found, potentially to be turned into a common parent cache entry.\r\n                    if (commonPrefix == null || !commonUnique || currentPrefix.length() > commonPrefix.length()) {\r\n                        commonPrefix = currentPrefix;\r\n                        existingPath = path;\r\n                    } else if (currentPrefix.equals(commonPrefix)) {\r\n                        commonUnique = false;\r\n                    }\r\n                }\r\n            } else if (actualRootPath == null || path.length() > actualRootPath.length()) {\r\n                // A direct match found for a parent directory -> use it.\r\n                rootDirResources = this.rootDirCache.get(path);\r\n                actualRootPath = path;\r\n            }\r\n        }\r\n        if (rootDirResources == null && StringUtils.hasLength(commonPrefix)) {\r\n            // Try common parent directory as long as it points to the same classpath locations.\r\n            rootDirResources = getResources(commonPrefix);\r\n            Resource[] existingResources = this.rootDirCache.get(existingPath);\r\n            if (existingResources != null && rootDirResources.length == existingResources.length) {\r\n                // Replace existing subdirectory cache entry with common parent directory,\r\n                // avoiding repeated determination of root directories in the same jar.\r\n                this.rootDirCache.remove(existingPath);\r\n                this.rootDirCache.put(commonPrefix, rootDirResources);\r\n                actualRootPath = commonPrefix;\r\n            } else if (commonPrefix.equals(rootDirPath)) {\r\n                // The identified common directory is equal to the currently requested path ->\r\n                // worth caching specifically, even if it cannot replace the existing sub-entry.\r\n                this.rootDirCache.put(rootDirPath, rootDirResources);\r\n            } else {\r\n                // Mismatch: parent directory points to more classpath locations.\r\n                rootDirResources = null;\r\n            }\r\n        }\r\n        if (rootDirResources == null) {\r\n            // Lookup for specific directory, creating a cache entry for it.\r\n            rootDirResources = getResources(rootDirPath);\r\n            this.rootDirCache.put(rootDirPath, rootDirResources);\r\n        }\r\n    }\r\n    Set<Resource> result = new LinkedHashSet<>(64);\r\n    for (Resource rootDirResource : rootDirResources) {\r\n        if (actualRootPath != null && actualRootPath.length() < rootDirPath.length()) {\r\n            // Create sub-resource for requested sub-location from cached common root directory.\r\n            rootDirResource = rootDirResource.createRelative(rootDirPath.substring(actualRootPath.length()));\r\n        }\r\n        rootDirResource = resolveRootDirResource(rootDirResource);\r\n        URL rootDirUrl = rootDirResource.getURL();\r\n        if (equinoxResolveMethod != null && rootDirUrl.getProtocol().startsWith(\"bundle\")) {\r\n            URL resolvedUrl = (URL) ReflectionUtils.invokeMethod(equinoxResolveMethod, null, rootDirUrl);\r\n            if (resolvedUrl != null) {\r\n                rootDirUrl = resolvedUrl;\r\n            }\r\n            rootDirResource = new UrlResource(rootDirUrl);\r\n        }\r\n        if (rootDirUrl.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {\r\n            result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirUrl, subPattern, getPathMatcher()));\r\n        } else if (ResourceUtils.isJarURL(rootDirUrl) || isJarResource(rootDirResource)) {\r\n            result.addAll(doFindPathMatchingJarResources(rootDirResource, rootDirUrl, subPattern));\r\n        } else {\r\n            result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern));\r\n        }\r\n    }\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(\"Resolved location pattern [\" + locationPattern + \"] to resources \" + result);\r\n    }\r\n    return result.toArray(new Resource[0]);\r\n}",
    "comment": "\n\t * Find all resources that match the given location pattern via the Ant-style\n\t * {@link #getPathMatcher() PathMatcher}.\n\t * <p>Supports resources in OSGi bundles, JBoss VFS, jar files, zip files,\n\t * and file systems.\n\t * @param locationPattern the location pattern to match\n\t * @return the result as Resource array\n\t * @throws IOException in case of I/O errors\n\t * @see #determineRootDir(String)\n\t * @see #resolveRootDirResource(Resource)\n\t * @see #isJarResource(Resource)\n\t * @see #doFindPathMatchingJarResources(Resource, URL, String)\n\t * @see #doFindPathMatchingFileResources(Resource, String)\n\t * @see org.springframework.util.PathMatcher\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#determineRootDir(String)",
    "entityType": "method",
    "code": "/**\r\n * Determine the root directory for the given location.\r\n * <p>Used for determining the starting point for file matching, resolving the\r\n * root directory location to be passed into {@link #getResources(String)},\r\n * with the remainder of the location to be used as the sub pattern.\r\n * <p>Will return \"/WEB-INF/\" for the location \"/WEB-INF/*.xml\", for example.\r\n * @param location the location to check\r\n * @return the part of the location that denotes the root directory\r\n * @see #findPathMatchingResources(String)\r\n */\r\nprotected String determineRootDir(String location) {\r\n    int prefixEnd = location.indexOf(':') + 1;\r\n    int rootDirEnd = location.length();\r\n    while (rootDirEnd > prefixEnd && getPathMatcher().isPattern(location.substring(prefixEnd, rootDirEnd))) {\r\n        rootDirEnd = location.lastIndexOf('/', rootDirEnd - 2) + 1;\r\n    }\r\n    if (rootDirEnd == 0) {\r\n        rootDirEnd = prefixEnd;\r\n    }\r\n    return location.substring(0, rootDirEnd);\r\n}",
    "comment": "\n\t * Determine the root directory for the given location.\n\t * <p>Used for determining the starting point for file matching, resolving the\n\t * root directory location to be passed into {@link #getResources(String)},\n\t * with the remainder of the location to be used as the sub pattern.\n\t * <p>Will return \"/WEB-INF/\" for the location \"/WEB-INF/*.xml\", for example.\n\t * @param location the location to check\n\t * @return the part of the location that denotes the root directory\n\t * @see #findPathMatchingResources(String)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#resolveRootDirResource(Resource)",
    "entityType": "method",
    "code": "/**\r\n * Resolve the supplied root directory resource for path matching.\r\n * <p>By default, {@link #findPathMatchingResources(String)} resolves Equinox\r\n * OSGi \"bundleresource:\" and \"bundleentry:\" URLs into standard jar file URLs\r\n * that will be traversed using Spring's standard jar file traversal algorithm.\r\n * <p>For any custom resolution, override this template method and replace the\r\n * supplied resource handle accordingly.\r\n * <p>The default implementation of this method returns the supplied resource\r\n * unmodified.\r\n * @param original the resource to resolve\r\n * @return the resolved resource (may be identical to the supplied resource)\r\n * @throws IOException in case of resolution failure\r\n * @see #findPathMatchingResources(String)\r\n */\r\nprotected Resource resolveRootDirResource(Resource original) throws IOException {\r\n    return original;\r\n}",
    "comment": "\n\t * Resolve the supplied root directory resource for path matching.\n\t * <p>By default, {@link #findPathMatchingResources(String)} resolves Equinox\n\t * OSGi \"bundleresource:\" and \"bundleentry:\" URLs into standard jar file URLs\n\t * that will be traversed using Spring's standard jar file traversal algorithm.\n\t * <p>For any custom resolution, override this template method and replace the\n\t * supplied resource handle accordingly.\n\t * <p>The default implementation of this method returns the supplied resource\n\t * unmodified.\n\t * @param original the resource to resolve\n\t * @return the resolved resource (may be identical to the supplied resource)\n\t * @throws IOException in case of resolution failure\n\t * @see #findPathMatchingResources(String)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#isJarResource(Resource)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the given resource handle indicates a jar resource that the\r\n * {@link #doFindPathMatchingJarResources} method can handle.\r\n * <p>{@link #findPathMatchingResources(String)} delegates to\r\n * {@link ResourceUtils#isJarURL(URL)} to determine whether the given URL\r\n * points to a resource in a jar file, and only invokes this method as a fallback.\r\n * <p>This template method therefore allows for detecting further kinds of\r\n * jar-like resources &mdash; for example, via {@code instanceof} checks on\r\n * the resource handle type.\r\n * <p>The default implementation of this method returns {@code false}.\r\n * @param resource the resource handle to check (usually the root directory\r\n * to start path matching from)\r\n * @return {@code true} if the given resource handle indicates a jar resource\r\n * @throws IOException in case of I/O errors\r\n * @see #findPathMatchingResources(String)\r\n * @see #doFindPathMatchingJarResources(Resource, URL, String)\r\n * @see org.springframework.util.ResourceUtils#isJarURL\r\n */\r\nprotected boolean isJarResource(Resource resource) throws IOException {\r\n    return false;\r\n}",
    "comment": "\n\t * Determine if the given resource handle indicates a jar resource that the\n\t * {@link #doFindPathMatchingJarResources} method can handle.\n\t * <p>{@link #findPathMatchingResources(String)} delegates to\n\t * {@link ResourceUtils#isJarURL(URL)} to determine whether the given URL\n\t * points to a resource in a jar file, and only invokes this method as a fallback.\n\t * <p>This template method therefore allows for detecting further kinds of\n\t * jar-like resources &mdash; for example, via {@code instanceof} checks on\n\t * the resource handle type.\n\t * <p>The default implementation of this method returns {@code false}.\n\t * @param resource the resource handle to check (usually the root directory\n\t * to start path matching from)\n\t * @return {@code true} if the given resource handle indicates a jar resource\n\t * @throws IOException in case of I/O errors\n\t * @see #findPathMatchingResources(String)\n\t * @see #doFindPathMatchingJarResources(Resource, URL, String)\n\t * @see org.springframework.util.ResourceUtils#isJarURL\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#doFindPathMatchingJarResources(Resource,URL,String)",
    "entityType": "method",
    "code": "/**\r\n * Find all resources in jar files that match the given location pattern\r\n * via the Ant-style {@link #getPathMatcher() PathMatcher}.\r\n * @param rootDirResource the root directory as Resource\r\n * @param rootDirUrl the pre-resolved root directory URL\r\n * @param subPattern the sub pattern to match (below the root directory)\r\n * @return a mutable Set of matching Resource instances\r\n * @throws IOException in case of I/O errors\r\n * @since 4.3\r\n * @see java.net.JarURLConnection\r\n * @see org.springframework.util.PathMatcher\r\n */\r\nprotected Set<Resource> doFindPathMatchingJarResources(Resource rootDirResource, URL rootDirUrl, String subPattern) throws IOException {\r\n    String jarFileUrl = null;\r\n    String rootEntryPath = \"\";\r\n    String urlFile = rootDirUrl.getFile();\r\n    int separatorIndex = urlFile.indexOf(ResourceUtils.WAR_URL_SEPARATOR);\r\n    if (separatorIndex == -1) {\r\n        separatorIndex = urlFile.indexOf(ResourceUtils.JAR_URL_SEPARATOR);\r\n    }\r\n    if (separatorIndex >= 0) {\r\n        jarFileUrl = urlFile.substring(0, separatorIndex);\r\n        // both separators are 2 chars\r\n        rootEntryPath = urlFile.substring(separatorIndex + 2);\r\n        NavigableSet<String> entriesCache = this.jarEntriesCache.get(jarFileUrl);\r\n        if (entriesCache != null) {\r\n            Set<Resource> result = new LinkedHashSet<>(64);\r\n            // Search sorted entries from first entry with rootEntryPath prefix\r\n            for (String entryPath : entriesCache.tailSet(rootEntryPath, false)) {\r\n                if (!entryPath.startsWith(rootEntryPath)) {\r\n                    // We are beyond the potential matches in the current TreeSet.\r\n                    break;\r\n                }\r\n                String relativePath = entryPath.substring(rootEntryPath.length());\r\n                if (getPathMatcher().match(subPattern, relativePath)) {\r\n                    result.add(rootDirResource.createRelative(relativePath));\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n    URLConnection con = rootDirUrl.openConnection();\r\n    JarFile jarFile;\r\n    boolean closeJarFile;\r\n    if (con instanceof JarURLConnection jarCon) {\r\n        // Should usually be the case for traditional JAR files.\r\n        try {\r\n            jarFile = jarCon.getJarFile();\r\n            jarFileUrl = jarCon.getJarFileURL().toExternalForm();\r\n            JarEntry jarEntry = jarCon.getJarEntry();\r\n            rootEntryPath = (jarEntry != null ? jarEntry.getName() : \"\");\r\n            closeJarFile = !jarCon.getUseCaches();\r\n        } catch (FileNotFoundException ex) {\r\n            // Happens in case of cached root directory without specific subdirectory present.\r\n            return Collections.emptySet();\r\n        }\r\n    } else {\r\n        // No JarURLConnection -> need to resort to URL file parsing.\r\n        // We'll assume URLs of the format \"jar:path!/entry\", with the protocol\r\n        // being arbitrary as long as following the entry format.\r\n        // We'll also handle paths with and without leading \"file:\" prefix.\r\n        try {\r\n            if (jarFileUrl != null) {\r\n                jarFile = getJarFile(jarFileUrl);\r\n            } else {\r\n                jarFile = new JarFile(urlFile);\r\n                jarFileUrl = urlFile;\r\n                rootEntryPath = \"\";\r\n            }\r\n            closeJarFile = true;\r\n        } catch (ZipException ex) {\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"Skipping invalid jar class path entry [\" + urlFile + \"]\");\r\n            }\r\n            return Collections.emptySet();\r\n        }\r\n    }\r\n    try {\r\n        if (logger.isTraceEnabled()) {\r\n            logger.trace(\"Looking for matching resources in jar file [\" + jarFileUrl + \"]\");\r\n        }\r\n        if (StringUtils.hasLength(rootEntryPath) && !rootEntryPath.endsWith(\"/\")) {\r\n            // Root entry path must end with slash to allow for proper matching.\r\n            // The Sun JRE does not return a slash here, but BEA JRockit does.\r\n            rootEntryPath = rootEntryPath + \"/\";\r\n        }\r\n        Set<Resource> result = new LinkedHashSet<>(64);\r\n        NavigableSet<String> entriesCache = new TreeSet<>();\r\n        Iterator<String> entryIterator = jarFile.stream().map(JarEntry::getName).sorted().iterator();\r\n        while (entryIterator.hasNext()) {\r\n            String entryPath = entryIterator.next();\r\n            int entrySeparatorIndex = entryPath.indexOf(ResourceUtils.JAR_URL_SEPARATOR);\r\n            if (entrySeparatorIndex >= 0) {\r\n                entryPath = entryPath.substring(entrySeparatorIndex + ResourceUtils.JAR_URL_SEPARATOR.length());\r\n            }\r\n            entriesCache.add(entryPath);\r\n            if (entryPath.startsWith(rootEntryPath)) {\r\n                String relativePath = entryPath.substring(rootEntryPath.length());\r\n                if (getPathMatcher().match(subPattern, relativePath)) {\r\n                    result.add(rootDirResource.createRelative(relativePath));\r\n                }\r\n            }\r\n        }\r\n        // Cache jar entries in TreeSet for efficient searching on re-encounter.\r\n        this.jarEntriesCache.put(jarFileUrl, entriesCache);\r\n        return result;\r\n    } finally {\r\n        if (closeJarFile) {\r\n            jarFile.close();\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Find all resources in jar files that match the given location pattern\n\t * via the Ant-style {@link #getPathMatcher() PathMatcher}.\n\t * @param rootDirResource the root directory as Resource\n\t * @param rootDirUrl the pre-resolved root directory URL\n\t * @param subPattern the sub pattern to match (below the root directory)\n\t * @return a mutable Set of matching Resource instances\n\t * @throws IOException in case of I/O errors\n\t * @since 4.3\n\t * @see java.net.JarURLConnection\n\t * @see org.springframework.util.PathMatcher\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#getJarFile(String)",
    "entityType": "method",
    "code": "/**\r\n * Resolve the given jar file URL into a JarFile object.\r\n */\r\nprotected JarFile getJarFile(String jarFileUrl) throws IOException {\r\n    if (jarFileUrl.startsWith(ResourceUtils.FILE_URL_PREFIX)) {\r\n        try {\r\n            return new JarFile(ResourceUtils.toURI(jarFileUrl).getSchemeSpecificPart());\r\n        } catch (URISyntaxException ex) {\r\n            // Fallback for URLs that are not valid URIs (should hardly ever happen).\r\n            return new JarFile(jarFileUrl.substring(ResourceUtils.FILE_URL_PREFIX.length()));\r\n        }\r\n    } else {\r\n        return new JarFile(jarFileUrl);\r\n    }\r\n}",
    "comment": "\n\t * Resolve the given jar file URL into a JarFile object.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#doFindPathMatchingFileResources(Resource,String)",
    "entityType": "method",
    "code": "/**\r\n * Find all resources in the file system of the supplied root directory that\r\n * match the given location sub pattern via the Ant-style {@link #getPathMatcher()\r\n * PathMatcher}.\r\n * @param rootDirResource the root directory as a Resource\r\n * @param subPattern the sub pattern to match (below the root directory)\r\n * @return a mutable Set of matching Resource instances\r\n * @throws IOException in case of I/O errors\r\n * @see org.springframework.util.PathMatcher\r\n */\r\nprotected Set<Resource> doFindPathMatchingFileResources(Resource rootDirResource, String subPattern) throws IOException {\r\n    Set<Resource> result = new LinkedHashSet<>(64);\r\n    URI rootDirUri;\r\n    try {\r\n        rootDirUri = rootDirResource.getURI();\r\n    } catch (Exception ex) {\r\n        if (logger.isWarnEnabled()) {\r\n            logger.warn(\"Failed to resolve directory [%s] as URI: %s\".formatted(rootDirResource, ex));\r\n        }\r\n        return result;\r\n    }\r\n    Path rootPath = null;\r\n    if (rootDirUri.isAbsolute() && !rootDirUri.isOpaque()) {\r\n        // Prefer Path resolution from URI if possible\r\n        try {\r\n            try {\r\n                rootPath = Path.of(rootDirUri);\r\n            } catch (FileSystemNotFoundException ex) {\r\n                // If the file system was not found, assume it's a custom file system that needs to be installed.\r\n                FileSystems.newFileSystem(rootDirUri, Map.of(), ClassUtils.getDefaultClassLoader());\r\n                rootPath = Path.of(rootDirUri);\r\n            }\r\n        } catch (Exception ex) {\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"Failed to resolve %s in file system: %s\".formatted(rootDirUri, ex));\r\n            }\r\n            // Fallback via Resource.getFile() below\r\n        }\r\n    }\r\n    if (rootPath == null) {\r\n        // Resource.getFile() resolution as a fallback -\r\n        // for custom URI formats and custom Resource implementations\r\n        try {\r\n            rootPath = Path.of(rootDirResource.getFile().getAbsolutePath());\r\n        } catch (FileNotFoundException ex) {\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"Cannot search for matching files underneath \" + rootDirResource + \" in the file system: \" + ex.getMessage());\r\n            }\r\n            return result;\r\n        } catch (Exception ex) {\r\n            if (logger.isInfoEnabled()) {\r\n                logger.info(\"Failed to resolve \" + rootDirResource + \" in the file system: \" + ex);\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n    if (!Files.exists(rootPath)) {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"Skipping search for files matching pattern [%s]: directory [%s] does not exist\".formatted(subPattern, rootPath.toAbsolutePath()));\r\n        }\r\n        return result;\r\n    }\r\n    String rootDir = StringUtils.cleanPath(rootPath.toString());\r\n    if (!rootDir.endsWith(\"/\")) {\r\n        rootDir += \"/\";\r\n    }\r\n    Path rootPathForPattern = rootPath;\r\n    String resourcePattern = rootDir + StringUtils.cleanPath(subPattern);\r\n    Predicate<Path> isMatchingFile = path -> (!path.equals(rootPathForPattern) && getPathMatcher().match(resourcePattern, StringUtils.cleanPath(path.toString())));\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(\"Searching directory [%s] for files matching pattern [%s]\".formatted(rootPath.toAbsolutePath(), subPattern));\r\n    }\r\n    try (Stream<Path> files = Files.walk(rootPath, FileVisitOption.FOLLOW_LINKS)) {\r\n        files.filter(isMatchingFile).sorted().map(FileSystemResource::new).forEach(result::add);\r\n    } catch (Exception ex) {\r\n        if (logger.isWarnEnabled()) {\r\n            logger.warn(\"Failed to search in directory [%s] for files matching pattern [%s]: %s\".formatted(rootPath.toAbsolutePath(), subPattern, ex));\r\n        }\r\n    }\r\n    return result;\r\n}",
    "comment": "\n\t * Find all resources in the file system of the supplied root directory that\n\t * match the given location sub pattern via the Ant-style {@link #getPathMatcher()\n\t * PathMatcher}.\n\t * @param rootDirResource the root directory as a Resource\n\t * @param subPattern the sub pattern to match (below the root directory)\n\t * @return a mutable Set of matching Resource instances\n\t * @throws IOException in case of I/O errors\n\t * @see org.springframework.util.PathMatcher\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#findAllModulePathResources(String)",
    "entityType": "method",
    "code": "/**\r\n * Resolve the given location pattern into {@code Resource} objects for all\r\n * matching resources found in the module path.\r\n * <p>The location pattern may be an explicit resource path such as\r\n * {@code \"com/example/config.xml\"} or a pattern such as\r\n * <code>\"com/example/**&#47;config-*.xml\"</code> to be matched using the\r\n * configured {@link #getPathMatcher() PathMatcher}.\r\n * <p>The default implementation scans all modules in the {@linkplain ModuleLayer#boot()\r\n * boot layer}, excluding {@linkplain ModuleFinder#ofSystem() system modules}.\r\n * @param locationPattern the location pattern to resolve\r\n * @return a modifiable {@code Set} containing the corresponding {@code Resource}\r\n * objects\r\n * @throws IOException in case of I/O errors\r\n * @since 6.0\r\n * @see ModuleLayer#boot()\r\n * @see ModuleFinder#ofSystem()\r\n * @see ModuleReader\r\n * @see PathMatcher#match(String, String)\r\n */\r\nprotected Set<Resource> findAllModulePathResources(String locationPattern) throws IOException {\r\n    Set<Resource> result = new LinkedHashSet<>(64);\r\n    // Skip scanning the module path when running in a native image.\r\n    if (NativeDetector.inNativeImage()) {\r\n        return result;\r\n    }\r\n    String resourcePattern = stripLeadingSlash(locationPattern);\r\n    Predicate<String> resourcePatternMatches = (getPathMatcher().isPattern(resourcePattern) ? path -> getPathMatcher().match(resourcePattern, path) : resourcePattern::equals);\r\n    try {\r\n        ModuleLayer.boot().configuration().modules().stream().filter(isNotSystemModule).forEach(resolvedModule -> {\r\n            // NOTE: a ModuleReader and a Stream returned from ModuleReader.list() must be closed.\r\n            try (ModuleReader moduleReader = resolvedModule.reference().open();\r\n                Stream<String> names = moduleReader.list()) {\r\n                names.filter(resourcePatternMatches).map(name -> findResource(moduleReader, name)).filter(Objects::nonNull).forEach(result::add);\r\n            } catch (IOException ex) {\r\n                if (logger.isDebugEnabled()) {\r\n                    logger.debug(\"Failed to read contents of module [%s]\".formatted(resolvedModule), ex);\r\n                }\r\n                throw new UncheckedIOException(ex);\r\n            }\r\n        });\r\n    } catch (UncheckedIOException ex) {\r\n        // Unwrap IOException to conform to this method's contract.\r\n        throw ex.getCause();\r\n    }\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(\"Resolved module-path location pattern [%s] to resources %s\".formatted(resourcePattern, result));\r\n    }\r\n    return result;\r\n}",
    "comment": "\n\t * Resolve the given location pattern into {@code Resource} objects for all\n\t * matching resources found in the module path.\n\t * <p>The location pattern may be an explicit resource path such as\n\t * {@code \"com/example/config.xml\"} or a pattern such as\n\t * <code>\"com/example/**&#47;config-*.xml\"</code> to be matched using the\n\t * configured {@link #getPathMatcher() PathMatcher}.\n\t * <p>The default implementation scans all modules in the {@linkplain ModuleLayer#boot()\n\t * boot layer}, excluding {@linkplain ModuleFinder#ofSystem() system modules}.\n\t * @param locationPattern the location pattern to resolve\n\t * @return a modifiable {@code Set} containing the corresponding {@code Resource}\n\t * objects\n\t * @throws IOException in case of I/O errors\n\t * @since 6.0\n\t * @see ModuleLayer#boot()\n\t * @see ModuleFinder#ofSystem()\n\t * @see ModuleReader\n\t * @see PathMatcher#match(String, String)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#findResource(ModuleReader,String)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate Resource findResource(ModuleReader moduleReader, String name) {\r\n    try {\r\n        return moduleReader.find(name).map(this::convertModuleSystemURI).orElse(null);\r\n    } catch (Exception ex) {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"Failed to find resource [%s] in module path\".formatted(name), ex);\r\n        }\r\n        return null;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#convertModuleSystemURI(URI)",
    "entityType": "method",
    "code": "/**\r\n * If it's a \"file:\" URI, use {@link FileSystemResource} to avoid duplicates\r\n * for the same path discovered via class path scanning.\r\n */\r\nprivate Resource convertModuleSystemURI(URI uri) {\r\n    return (ResourceUtils.URL_PROTOCOL_FILE.equals(uri.getScheme()) ? new FileSystemResource(uri.getPath()) : UrlResource.from(uri));\r\n}",
    "comment": "\n\t * If it's a \"file:\" URI, use {@link FileSystemResource} to avoid duplicates\n\t * for the same path discovered via class path scanning.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#stripLeadingSlash(String)",
    "entityType": "method",
    "code": "private static String stripLeadingSlash(String path) {\r\n    return (path.startsWith(\"/\") ? path.substring(1) : path);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.PathMatchingResourcePatternResolver#checkPathWithinPackage(String)",
    "entityType": "method",
    "code": "private static boolean checkPathWithinPackage(String path) {\r\n    return (path.contains(\"/\") && !path.contains(ResourceUtils.JAR_URL_SEPARATOR));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.VfsResourceMatchingDelegate",
    "entityType": "class",
    "code": "public static Set<Resource> findMatchingResources(URL rootDirUrl, String locationPattern, PathMatcher pathMatcher) throws IOException {\r\n    Object root = VfsPatternUtils.findRoot(rootDirUrl);\r\n    PatternVirtualFileVisitor visitor = new PatternVirtualFileVisitor(VfsPatternUtils.getPath(root), locationPattern, pathMatcher);\r\n    VfsPatternUtils.visit(root, visitor);\r\n    return visitor.getResources();\r\n}",
    "comment": "\n\t * Inner delegate class, avoiding a hard JBoss VFS API dependency at runtime.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.VfsResourceMatchingDelegate#findMatchingResources(URL,String,PathMatcher)",
    "entityType": "method",
    "code": "public static Set<Resource> findMatchingResources(URL rootDirUrl, String locationPattern, PathMatcher pathMatcher) throws IOException {\r\n    Object root = VfsPatternUtils.findRoot(rootDirUrl);\r\n    PatternVirtualFileVisitor visitor = new PatternVirtualFileVisitor(VfsPatternUtils.getPath(root), locationPattern, pathMatcher);\r\n    VfsPatternUtils.visit(root, visitor);\r\n    return visitor.getResources();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.PatternVirtualFileVisitor",
    "entityType": "class",
    "code": "private final String subPattern;\nprivate final PathMatcher pathMatcher;\nprivate final String rootPath;\nprivate final Set<Resource> resources = new LinkedHashSet<>(64);\npublic PatternVirtualFileVisitor(String rootPath, String subPattern, PathMatcher pathMatcher) {\r\n    this.subPattern = subPattern;\r\n    this.pathMatcher = pathMatcher;\r\n    this.rootPath = (rootPath.isEmpty() || rootPath.endsWith(\"/\") ? rootPath : rootPath + \"/\");\r\n}\n@Override\r\n@Nullable\r\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n    String methodName = method.getName();\r\n    if (Object.class == method.getDeclaringClass()) {\r\n        switch(methodName) {\r\n            case \"equals\" ->\r\n                {\r\n                    // Only consider equal when proxies are identical.\r\n                    return (proxy == args[0]);\r\n                }\r\n            case \"hashCode\" ->\r\n                {\r\n                    return System.identityHashCode(proxy);\r\n                }\r\n        }\r\n    }\r\n    return switch(methodName) {\r\n        case \"getAttributes\" ->\r\n            getAttributes();\r\n        case \"visit\" ->\r\n            {\r\n                visit(args[0]);\r\n                yield null;\r\n            }\r\n        case \"toString\" ->\r\n            toString();\r\n        default ->\r\n            throw new IllegalStateException(\"Unexpected method invocation: \" + method);\r\n    };\r\n}\npublic void visit(Object vfsResource) {\r\n    if (this.pathMatcher.match(this.subPattern, VfsPatternUtils.getPath(vfsResource).substring(this.rootPath.length()))) {\r\n        this.resources.add(new VfsResource(vfsResource));\r\n    }\r\n}\n@Nullable\r\npublic Object getAttributes() {\r\n    return VfsPatternUtils.getVisitorAttributes();\r\n}\npublic Set<Resource> getResources() {\r\n    return this.resources;\r\n}\npublic int size() {\r\n    return this.resources.size();\r\n}\n@Override\r\npublic String toString() {\r\n    return \"sub-pattern: \" + this.subPattern + \", resources: \" + this.resources;\r\n}",
    "comment": "\n\t * VFS visitor for path matching purposes.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PatternVirtualFileVisitor#invoke(Object,Method,Object[])",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n    String methodName = method.getName();\r\n    if (Object.class == method.getDeclaringClass()) {\r\n        switch(methodName) {\r\n            case \"equals\" ->\r\n                {\r\n                    // Only consider equal when proxies are identical.\r\n                    return (proxy == args[0]);\r\n                }\r\n            case \"hashCode\" ->\r\n                {\r\n                    return System.identityHashCode(proxy);\r\n                }\r\n        }\r\n    }\r\n    return switch(methodName) {\r\n        case \"getAttributes\" ->\r\n            getAttributes();\r\n        case \"visit\" ->\r\n            {\r\n                visit(args[0]);\r\n                yield null;\r\n            }\r\n        case \"toString\" ->\r\n            toString();\r\n        default ->\r\n            throw new IllegalStateException(\"Unexpected method invocation: \" + method);\r\n    };\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.PatternVirtualFileVisitor#visit(Object)",
    "entityType": "method",
    "code": "public void visit(Object vfsResource) {\r\n    if (this.pathMatcher.match(this.subPattern, VfsPatternUtils.getPath(vfsResource).substring(this.rootPath.length()))) {\r\n        this.resources.add(new VfsResource(vfsResource));\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.PatternVirtualFileVisitor#getAttributes()",
    "entityType": "method",
    "code": "@Nullable\r\npublic Object getAttributes() {\r\n    return VfsPatternUtils.getVisitorAttributes();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.PatternVirtualFileVisitor#getResources()",
    "entityType": "method",
    "code": "public Set<Resource> getResources() {\r\n    return this.resources;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.PatternVirtualFileVisitor#size()",
    "entityType": "method",
    "code": "public int size() {\r\n    return this.resources.size();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.PatternVirtualFileVisitor#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return \"sub-pattern: \" + this.subPattern + \", resources: \" + this.resources;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.PropertiesLoaderSupport",
    "entityType": "class",
    "code": "/**\r\n * Logger available to subclasses.\r\n */\r\nprotected final Log logger = LogFactory.getLog(getClass());\nprotected Properties @Nullable [] localProperties;\nprotected boolean localOverride = false;\nprivate Resource @Nullable [] locations;\nprivate boolean ignoreResourceNotFound = false;\n@Nullable\r\nprivate String fileEncoding;\nprivate PropertiesPersister propertiesPersister = DefaultPropertiesPersister.INSTANCE;\n/**\r\n * Set local properties, for example, via the \"props\" tag in XML bean definitions.\r\n * These can be considered defaults, to be overridden by properties\r\n * loaded from files.\r\n */\r\npublic void setProperties(Properties properties) {\r\n    this.localProperties = new Properties[] { properties };\r\n}\n/**\r\n * Set local properties, for example, via the \"props\" tag in XML bean definitions,\r\n * allowing for merging multiple properties sets into one.\r\n */\r\npublic void setPropertiesArray(Properties... propertiesArray) {\r\n    this.localProperties = propertiesArray;\r\n}\n/**\r\n * Set a location of a properties file to be loaded.\r\n * <p>Can point to a classic properties file or to an XML file\r\n * that follows Java's properties XML format.\r\n */\r\npublic void setLocation(Resource location) {\r\n    this.locations = new Resource[] { location };\r\n}\n/**\r\n * Set locations of properties files to be loaded.\r\n * <p>Can point to classic properties files or to XML files\r\n * that follow Java's properties XML format.\r\n * <p>Note: Properties defined in later files will override\r\n * properties defined earlier files, in case of overlapping keys.\r\n * Hence, make sure that the most specific files are the last\r\n * ones in the given list of locations.\r\n */\r\npublic void setLocations(Resource... locations) {\r\n    this.locations = locations;\r\n}\n/**\r\n * Set whether local properties override properties from files.\r\n * <p>Default is \"false\": Properties from files override local defaults.\r\n * Can be switched to \"true\" to let local properties override defaults\r\n * from files.\r\n */\r\npublic void setLocalOverride(boolean localOverride) {\r\n    this.localOverride = localOverride;\r\n}\n/**\r\n * Set if failure to find the property resource should be ignored.\r\n * <p>\"true\" is appropriate if the properties file is completely optional.\r\n * Default is \"false\".\r\n */\r\npublic void setIgnoreResourceNotFound(boolean ignoreResourceNotFound) {\r\n    this.ignoreResourceNotFound = ignoreResourceNotFound;\r\n}\n/**\r\n * Set the encoding to use for parsing properties files.\r\n * <p>Default is none, using the {@code java.util.Properties}\r\n * default encoding.\r\n * <p>Only applies to classic properties files, not to XML files.\r\n * @see org.springframework.util.PropertiesPersister#load\r\n */\r\npublic void setFileEncoding(String encoding) {\r\n    this.fileEncoding = encoding;\r\n}\n/**\r\n * Set the PropertiesPersister to use for parsing properties files.\r\n * The default is {@code DefaultPropertiesPersister}.\r\n * @see DefaultPropertiesPersister#INSTANCE\r\n */\r\npublic void setPropertiesPersister(@Nullable PropertiesPersister propertiesPersister) {\r\n    this.propertiesPersister = (propertiesPersister != null ? propertiesPersister : DefaultPropertiesPersister.INSTANCE);\r\n}\n/**\r\n * Return a merged Properties instance containing both the\r\n * loaded properties and properties set on this FactoryBean.\r\n */\r\nprotected Properties mergeProperties() throws IOException {\r\n    Properties result = new Properties();\r\n    if (this.localOverride) {\r\n        // Load properties from file upfront, to let local properties override.\r\n        loadProperties(result);\r\n    }\r\n    if (this.localProperties != null) {\r\n        for (Properties localProp : this.localProperties) {\r\n            CollectionUtils.mergePropertiesIntoMap(localProp, result);\r\n        }\r\n    }\r\n    if (!this.localOverride) {\r\n        // Load properties from file afterwards, to let those properties override.\r\n        loadProperties(result);\r\n    }\r\n    return result;\r\n}\n/**\r\n * Load properties into the given instance.\r\n * @param props the Properties instance to load into\r\n * @throws IOException in case of I/O errors\r\n * @see #setLocations\r\n */\r\nprotected void loadProperties(Properties props) throws IOException {\r\n    if (this.locations != null) {\r\n        for (Resource location : this.locations) {\r\n            if (logger.isTraceEnabled()) {\r\n                logger.trace(\"Loading properties file from \" + location);\r\n            }\r\n            try {\r\n                PropertiesLoaderUtils.fillProperties(props, new EncodedResource(location, this.fileEncoding), this.propertiesPersister);\r\n            } catch (FileNotFoundException | UnknownHostException | SocketException ex) {\r\n                if (this.ignoreResourceNotFound) {\r\n                    if (logger.isDebugEnabled()) {\r\n                        logger.debug(\"Properties resource not found: \" + ex.getMessage());\r\n                    }\r\n                } else {\r\n                    throw ex;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}",
    "comment": "\n * Base class for JavaBean-style components that need to load properties\n * from one or more resources. Supports local properties as well, with\n * configurable overriding.\n *\n * @author Juergen Hoeller\n * @since 1.2.2\n "
  },
  {
    "entityId": "org.springframework.core.io.support.PropertiesLoaderSupport#setProperties(Properties)",
    "entityType": "method",
    "code": "/**\r\n * Set local properties, for example, via the \"props\" tag in XML bean definitions.\r\n * These can be considered defaults, to be overridden by properties\r\n * loaded from files.\r\n */\r\npublic void setProperties(Properties properties) {\r\n    this.localProperties = new Properties[] { properties };\r\n}",
    "comment": "\n\t * Set local properties, for example, via the \"props\" tag in XML bean definitions.\n\t * These can be considered defaults, to be overridden by properties\n\t * loaded from files.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PropertiesLoaderSupport#setPropertiesArray(Properties)",
    "entityType": "method",
    "code": "/**\r\n * Set local properties, for example, via the \"props\" tag in XML bean definitions,\r\n * allowing for merging multiple properties sets into one.\r\n */\r\npublic void setPropertiesArray(Properties... propertiesArray) {\r\n    this.localProperties = propertiesArray;\r\n}",
    "comment": "\n\t * Set local properties, for example, via the \"props\" tag in XML bean definitions,\n\t * allowing for merging multiple properties sets into one.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PropertiesLoaderSupport#setLocation(Resource)",
    "entityType": "method",
    "code": "/**\r\n * Set a location of a properties file to be loaded.\r\n * <p>Can point to a classic properties file or to an XML file\r\n * that follows Java's properties XML format.\r\n */\r\npublic void setLocation(Resource location) {\r\n    this.locations = new Resource[] { location };\r\n}",
    "comment": "\n\t * Set a location of a properties file to be loaded.\n\t * <p>Can point to a classic properties file or to an XML file\n\t * that follows Java's properties XML format.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PropertiesLoaderSupport#setLocations(Resource)",
    "entityType": "method",
    "code": "/**\r\n * Set locations of properties files to be loaded.\r\n * <p>Can point to classic properties files or to XML files\r\n * that follow Java's properties XML format.\r\n * <p>Note: Properties defined in later files will override\r\n * properties defined earlier files, in case of overlapping keys.\r\n * Hence, make sure that the most specific files are the last\r\n * ones in the given list of locations.\r\n */\r\npublic void setLocations(Resource... locations) {\r\n    this.locations = locations;\r\n}",
    "comment": "\n\t * Set locations of properties files to be loaded.\n\t * <p>Can point to classic properties files or to XML files\n\t * that follow Java's properties XML format.\n\t * <p>Note: Properties defined in later files will override\n\t * properties defined earlier files, in case of overlapping keys.\n\t * Hence, make sure that the most specific files are the last\n\t * ones in the given list of locations.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PropertiesLoaderSupport#setLocalOverride(boolean)",
    "entityType": "method",
    "code": "/**\r\n * Set whether local properties override properties from files.\r\n * <p>Default is \"false\": Properties from files override local defaults.\r\n * Can be switched to \"true\" to let local properties override defaults\r\n * from files.\r\n */\r\npublic void setLocalOverride(boolean localOverride) {\r\n    this.localOverride = localOverride;\r\n}",
    "comment": "\n\t * Set whether local properties override properties from files.\n\t * <p>Default is \"false\": Properties from files override local defaults.\n\t * Can be switched to \"true\" to let local properties override defaults\n\t * from files.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PropertiesLoaderSupport#setIgnoreResourceNotFound(boolean)",
    "entityType": "method",
    "code": "/**\r\n * Set if failure to find the property resource should be ignored.\r\n * <p>\"true\" is appropriate if the properties file is completely optional.\r\n * Default is \"false\".\r\n */\r\npublic void setIgnoreResourceNotFound(boolean ignoreResourceNotFound) {\r\n    this.ignoreResourceNotFound = ignoreResourceNotFound;\r\n}",
    "comment": "\n\t * Set if failure to find the property resource should be ignored.\n\t * <p>\"true\" is appropriate if the properties file is completely optional.\n\t * Default is \"false\".\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PropertiesLoaderSupport#setFileEncoding(String)",
    "entityType": "method",
    "code": "/**\r\n * Set the encoding to use for parsing properties files.\r\n * <p>Default is none, using the {@code java.util.Properties}\r\n * default encoding.\r\n * <p>Only applies to classic properties files, not to XML files.\r\n * @see org.springframework.util.PropertiesPersister#load\r\n */\r\npublic void setFileEncoding(String encoding) {\r\n    this.fileEncoding = encoding;\r\n}",
    "comment": "\n\t * Set the encoding to use for parsing properties files.\n\t * <p>Default is none, using the {@code java.util.Properties}\n\t * default encoding.\n\t * <p>Only applies to classic properties files, not to XML files.\n\t * @see org.springframework.util.PropertiesPersister#load\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PropertiesLoaderSupport#setPropertiesPersister(PropertiesPersister)",
    "entityType": "method",
    "code": "/**\r\n * Set the PropertiesPersister to use for parsing properties files.\r\n * The default is {@code DefaultPropertiesPersister}.\r\n * @see DefaultPropertiesPersister#INSTANCE\r\n */\r\npublic void setPropertiesPersister(@Nullable PropertiesPersister propertiesPersister) {\r\n    this.propertiesPersister = (propertiesPersister != null ? propertiesPersister : DefaultPropertiesPersister.INSTANCE);\r\n}",
    "comment": "\n\t * Set the PropertiesPersister to use for parsing properties files.\n\t * The default is {@code DefaultPropertiesPersister}.\n\t * @see DefaultPropertiesPersister#INSTANCE\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PropertiesLoaderSupport#mergeProperties()",
    "entityType": "method",
    "code": "/**\r\n * Return a merged Properties instance containing both the\r\n * loaded properties and properties set on this FactoryBean.\r\n */\r\nprotected Properties mergeProperties() throws IOException {\r\n    Properties result = new Properties();\r\n    if (this.localOverride) {\r\n        // Load properties from file upfront, to let local properties override.\r\n        loadProperties(result);\r\n    }\r\n    if (this.localProperties != null) {\r\n        for (Properties localProp : this.localProperties) {\r\n            CollectionUtils.mergePropertiesIntoMap(localProp, result);\r\n        }\r\n    }\r\n    if (!this.localOverride) {\r\n        // Load properties from file afterwards, to let those properties override.\r\n        loadProperties(result);\r\n    }\r\n    return result;\r\n}",
    "comment": "\n\t * Return a merged Properties instance containing both the\n\t * loaded properties and properties set on this FactoryBean.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PropertiesLoaderSupport#loadProperties(Properties)",
    "entityType": "method",
    "code": "/**\r\n * Load properties into the given instance.\r\n * @param props the Properties instance to load into\r\n * @throws IOException in case of I/O errors\r\n * @see #setLocations\r\n */\r\nprotected void loadProperties(Properties props) throws IOException {\r\n    if (this.locations != null) {\r\n        for (Resource location : this.locations) {\r\n            if (logger.isTraceEnabled()) {\r\n                logger.trace(\"Loading properties file from \" + location);\r\n            }\r\n            try {\r\n                PropertiesLoaderUtils.fillProperties(props, new EncodedResource(location, this.fileEncoding), this.propertiesPersister);\r\n            } catch (FileNotFoundException | UnknownHostException | SocketException ex) {\r\n                if (this.ignoreResourceNotFound) {\r\n                    if (logger.isDebugEnabled()) {\r\n                        logger.debug(\"Properties resource not found: \" + ex.getMessage());\r\n                    }\r\n                } else {\r\n                    throw ex;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Load properties into the given instance.\n\t * @param props the Properties instance to load into\n\t * @throws IOException in case of I/O errors\n\t * @see #setLocations\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PropertiesLoaderUtils",
    "entityType": "class",
    "code": "private static final String XML_FILE_EXTENSION = \".xml\";\n/**\r\n * Load properties from the given EncodedResource,\r\n * potentially defining a specific encoding for the properties file.\r\n * @see #fillProperties(java.util.Properties, EncodedResource)\r\n */\r\npublic static Properties loadProperties(EncodedResource resource) throws IOException {\r\n    Properties props = new Properties();\r\n    fillProperties(props, resource);\r\n    return props;\r\n}\n/**\r\n * Fill the given properties from the given EncodedResource,\r\n * potentially defining a specific encoding for the properties file.\r\n * @param props the Properties instance to load into\r\n * @param resource the resource to load from\r\n * @throws IOException in case of I/O errors\r\n */\r\npublic static void fillProperties(Properties props, EncodedResource resource) throws IOException {\r\n    fillProperties(props, resource, DefaultPropertiesPersister.INSTANCE);\r\n}\n/**\r\n * Actually load properties from the given EncodedResource into the given Properties instance.\r\n * @param props the Properties instance to load into\r\n * @param resource the resource to load from\r\n * @param persister the PropertiesPersister to use\r\n * @throws IOException in case of I/O errors\r\n */\r\nstatic void fillProperties(Properties props, EncodedResource resource, PropertiesPersister persister) throws IOException {\r\n    InputStream stream = null;\r\n    Reader reader = null;\r\n    try {\r\n        String filename = resource.getResource().getFilename();\r\n        if (filename != null && filename.endsWith(XML_FILE_EXTENSION)) {\r\n            stream = resource.getInputStream();\r\n            persister.loadFromXml(props, stream);\r\n        } else if (resource.requiresReader()) {\r\n            reader = resource.getReader();\r\n            persister.load(props, reader);\r\n        } else {\r\n            stream = resource.getInputStream();\r\n            persister.load(props, stream);\r\n        }\r\n    } finally {\r\n        if (stream != null) {\r\n            stream.close();\r\n        }\r\n        if (reader != null) {\r\n            reader.close();\r\n        }\r\n    }\r\n}\n/**\r\n * Load properties from the given resource (in ISO-8859-1 encoding).\r\n * @param resource the resource to load from\r\n * @return the populated Properties instance\r\n * @throws IOException if loading failed\r\n * @see #fillProperties(java.util.Properties, Resource)\r\n */\r\npublic static Properties loadProperties(Resource resource) throws IOException {\r\n    Properties props = new Properties();\r\n    fillProperties(props, resource);\r\n    return props;\r\n}\n/**\r\n * Fill the given properties from the given resource (in ISO-8859-1 encoding).\r\n * @param props the Properties instance to fill\r\n * @param resource the resource to load from\r\n * @throws IOException if loading failed\r\n */\r\npublic static void fillProperties(Properties props, Resource resource) throws IOException {\r\n    try (InputStream is = resource.getInputStream()) {\r\n        String filename = resource.getFilename();\r\n        if (filename != null && filename.endsWith(XML_FILE_EXTENSION)) {\r\n            props.loadFromXML(is);\r\n        } else {\r\n            props.load(is);\r\n        }\r\n    }\r\n}\n/**\r\n * Load all properties from the specified class path resource\r\n * (in ISO-8859-1 encoding), using the default class loader.\r\n * <p>Merges properties if more than one resource of the same name\r\n * found in the class path.\r\n * @param resourceName the name of the class path resource\r\n * @return the populated Properties instance\r\n * @throws IOException if loading failed\r\n */\r\npublic static Properties loadAllProperties(String resourceName) throws IOException {\r\n    return loadAllProperties(resourceName, null);\r\n}\n/**\r\n * Load all properties from the specified class path resource\r\n * (in ISO-8859-1 encoding), using the given class loader.\r\n * <p>Merges properties if more than one resource of the same name\r\n * found in the class path.\r\n * @param resourceName the name of the class path resource\r\n * @param classLoader the ClassLoader to use for loading\r\n * (or {@code null} to use the default class loader)\r\n * @return the populated Properties instance\r\n * @throws IOException if loading failed\r\n */\r\npublic static Properties loadAllProperties(String resourceName, @Nullable ClassLoader classLoader) throws IOException {\r\n    Assert.notNull(resourceName, \"Resource name must not be null\");\r\n    ClassLoader classLoaderToUse = classLoader;\r\n    if (classLoaderToUse == null) {\r\n        classLoaderToUse = ClassUtils.getDefaultClassLoader();\r\n    }\r\n    Enumeration<URL> urls = (classLoaderToUse != null ? classLoaderToUse.getResources(resourceName) : ClassLoader.getSystemResources(resourceName));\r\n    Properties props = new Properties();\r\n    while (urls.hasMoreElements()) {\r\n        URL url = urls.nextElement();\r\n        URLConnection con = url.openConnection();\r\n        ResourceUtils.useCachesIfNecessary(con);\r\n        try (InputStream is = con.getInputStream()) {\r\n            if (resourceName.endsWith(XML_FILE_EXTENSION)) {\r\n                props.loadFromXML(is);\r\n            } else {\r\n                props.load(is);\r\n            }\r\n        }\r\n    }\r\n    return props;\r\n}",
    "comment": "\n * Convenient utility methods for loading of {@code java.util.Properties},\n * performing standard handling of input streams.\n *\n * <p>For more configurable properties loading, including the option of a\n * customized encoding, consider using the PropertiesLoaderSupport class.\n *\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Sebastien Deleuze\n * @since 2.0\n * @see PropertiesLoaderSupport\n "
  },
  {
    "entityId": "org.springframework.core.io.support.PropertiesLoaderUtils#loadProperties(EncodedResource)",
    "entityType": "method",
    "code": "/**\r\n * Load properties from the given EncodedResource,\r\n * potentially defining a specific encoding for the properties file.\r\n * @see #fillProperties(java.util.Properties, EncodedResource)\r\n */\r\npublic static Properties loadProperties(EncodedResource resource) throws IOException {\r\n    Properties props = new Properties();\r\n    fillProperties(props, resource);\r\n    return props;\r\n}",
    "comment": "\n\t * Load properties from the given EncodedResource,\n\t * potentially defining a specific encoding for the properties file.\n\t * @see #fillProperties(java.util.Properties, EncodedResource)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PropertiesLoaderUtils#fillProperties(Properties,EncodedResource)",
    "entityType": "method",
    "code": "/**\r\n * Fill the given properties from the given EncodedResource,\r\n * potentially defining a specific encoding for the properties file.\r\n * @param props the Properties instance to load into\r\n * @param resource the resource to load from\r\n * @throws IOException in case of I/O errors\r\n */\r\npublic static void fillProperties(Properties props, EncodedResource resource) throws IOException {\r\n    fillProperties(props, resource, DefaultPropertiesPersister.INSTANCE);\r\n}",
    "comment": "\n\t * Fill the given properties from the given EncodedResource,\n\t * potentially defining a specific encoding for the properties file.\n\t * @param props the Properties instance to load into\n\t * @param resource the resource to load from\n\t * @throws IOException in case of I/O errors\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PropertiesLoaderUtils#fillProperties(Properties,EncodedResource,PropertiesPersister)",
    "entityType": "method",
    "code": "/**\r\n * Actually load properties from the given EncodedResource into the given Properties instance.\r\n * @param props the Properties instance to load into\r\n * @param resource the resource to load from\r\n * @param persister the PropertiesPersister to use\r\n * @throws IOException in case of I/O errors\r\n */\r\nstatic void fillProperties(Properties props, EncodedResource resource, PropertiesPersister persister) throws IOException {\r\n    InputStream stream = null;\r\n    Reader reader = null;\r\n    try {\r\n        String filename = resource.getResource().getFilename();\r\n        if (filename != null && filename.endsWith(XML_FILE_EXTENSION)) {\r\n            stream = resource.getInputStream();\r\n            persister.loadFromXml(props, stream);\r\n        } else if (resource.requiresReader()) {\r\n            reader = resource.getReader();\r\n            persister.load(props, reader);\r\n        } else {\r\n            stream = resource.getInputStream();\r\n            persister.load(props, stream);\r\n        }\r\n    } finally {\r\n        if (stream != null) {\r\n            stream.close();\r\n        }\r\n        if (reader != null) {\r\n            reader.close();\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Actually load properties from the given EncodedResource into the given Properties instance.\n\t * @param props the Properties instance to load into\n\t * @param resource the resource to load from\n\t * @param persister the PropertiesPersister to use\n\t * @throws IOException in case of I/O errors\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PropertiesLoaderUtils#loadProperties(Resource)",
    "entityType": "method",
    "code": "/**\r\n * Load properties from the given resource (in ISO-8859-1 encoding).\r\n * @param resource the resource to load from\r\n * @return the populated Properties instance\r\n * @throws IOException if loading failed\r\n * @see #fillProperties(java.util.Properties, Resource)\r\n */\r\npublic static Properties loadProperties(Resource resource) throws IOException {\r\n    Properties props = new Properties();\r\n    fillProperties(props, resource);\r\n    return props;\r\n}",
    "comment": "\n\t * Load properties from the given resource (in ISO-8859-1 encoding).\n\t * @param resource the resource to load from\n\t * @return the populated Properties instance\n\t * @throws IOException if loading failed\n\t * @see #fillProperties(java.util.Properties, Resource)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PropertiesLoaderUtils#fillProperties(Properties,Resource)",
    "entityType": "method",
    "code": "/**\r\n * Fill the given properties from the given resource (in ISO-8859-1 encoding).\r\n * @param props the Properties instance to fill\r\n * @param resource the resource to load from\r\n * @throws IOException if loading failed\r\n */\r\npublic static void fillProperties(Properties props, Resource resource) throws IOException {\r\n    try (InputStream is = resource.getInputStream()) {\r\n        String filename = resource.getFilename();\r\n        if (filename != null && filename.endsWith(XML_FILE_EXTENSION)) {\r\n            props.loadFromXML(is);\r\n        } else {\r\n            props.load(is);\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Fill the given properties from the given resource (in ISO-8859-1 encoding).\n\t * @param props the Properties instance to fill\n\t * @param resource the resource to load from\n\t * @throws IOException if loading failed\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PropertiesLoaderUtils#loadAllProperties(String)",
    "entityType": "method",
    "code": "/**\r\n * Load all properties from the specified class path resource\r\n * (in ISO-8859-1 encoding), using the default class loader.\r\n * <p>Merges properties if more than one resource of the same name\r\n * found in the class path.\r\n * @param resourceName the name of the class path resource\r\n * @return the populated Properties instance\r\n * @throws IOException if loading failed\r\n */\r\npublic static Properties loadAllProperties(String resourceName) throws IOException {\r\n    return loadAllProperties(resourceName, null);\r\n}",
    "comment": "\n\t * Load all properties from the specified class path resource\n\t * (in ISO-8859-1 encoding), using the default class loader.\n\t * <p>Merges properties if more than one resource of the same name\n\t * found in the class path.\n\t * @param resourceName the name of the class path resource\n\t * @return the populated Properties instance\n\t * @throws IOException if loading failed\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PropertiesLoaderUtils#loadAllProperties(String,ClassLoader)",
    "entityType": "method",
    "code": "/**\r\n * Load all properties from the specified class path resource\r\n * (in ISO-8859-1 encoding), using the given class loader.\r\n * <p>Merges properties if more than one resource of the same name\r\n * found in the class path.\r\n * @param resourceName the name of the class path resource\r\n * @param classLoader the ClassLoader to use for loading\r\n * (or {@code null} to use the default class loader)\r\n * @return the populated Properties instance\r\n * @throws IOException if loading failed\r\n */\r\npublic static Properties loadAllProperties(String resourceName, @Nullable ClassLoader classLoader) throws IOException {\r\n    Assert.notNull(resourceName, \"Resource name must not be null\");\r\n    ClassLoader classLoaderToUse = classLoader;\r\n    if (classLoaderToUse == null) {\r\n        classLoaderToUse = ClassUtils.getDefaultClassLoader();\r\n    }\r\n    Enumeration<URL> urls = (classLoaderToUse != null ? classLoaderToUse.getResources(resourceName) : ClassLoader.getSystemResources(resourceName));\r\n    Properties props = new Properties();\r\n    while (urls.hasMoreElements()) {\r\n        URL url = urls.nextElement();\r\n        URLConnection con = url.openConnection();\r\n        ResourceUtils.useCachesIfNecessary(con);\r\n        try (InputStream is = con.getInputStream()) {\r\n            if (resourceName.endsWith(XML_FILE_EXTENSION)) {\r\n                props.loadFromXML(is);\r\n            } else {\r\n                props.load(is);\r\n            }\r\n        }\r\n    }\r\n    return props;\r\n}",
    "comment": "\n\t * Load all properties from the specified class path resource\n\t * (in ISO-8859-1 encoding), using the given class loader.\n\t * <p>Merges properties if more than one resource of the same name\n\t * found in the class path.\n\t * @param resourceName the name of the class path resource\n\t * @param classLoader the ClassLoader to use for loading\n\t * (or {@code null} to use the default class loader)\n\t * @return the populated Properties instance\n\t * @throws IOException if loading failed\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PropertySourceFactory",
    "entityType": "class",
    "code": "/**\r\n * Create a {@link PropertySource} that wraps the given resource.\r\n * <p>Implementations will typically create {@link ResourcePropertySource}\r\n * instances, with {@link PropertySourceProcessor} automatically adapting\r\n * property source names via {@link ResourcePropertySource#withResourceName()}\r\n * if necessary, for example, when combining multiple sources for the same name\r\n * into a {@link org.springframework.core.env.CompositePropertySource}.\r\n * Custom implementations with custom {@link PropertySource} types need\r\n * to make sure to expose distinct enough names, possibly deriving from\r\n * {@link ResourcePropertySource} where possible.\r\n * @param name the name of the property source\r\n * (can be {@code null} in which case the factory implementation\r\n * will have to generate a name based on the given resource)\r\n * @param resource the resource (potentially encoded) to wrap\r\n * @return the new {@link PropertySource} (never {@code null})\r\n * @throws IOException if resource resolution failed\r\n */\r\nPropertySource<?> createPropertySource(@Nullable String name, EncodedResource resource) throws IOException;",
    "comment": "\n * Strategy interface for creating resource-based {@link PropertySource} wrappers.\n *\n * @author Juergen Hoeller\n * @since 4.3\n * @see DefaultPropertySourceFactory\n * @see ResourcePropertySource\n "
  },
  {
    "entityId": "org.springframework.core.io.support.PropertySourceFactory#createPropertySource(String,EncodedResource)",
    "entityType": "method",
    "code": "/**\r\n * Create a {@link PropertySource} that wraps the given resource.\r\n * <p>Implementations will typically create {@link ResourcePropertySource}\r\n * instances, with {@link PropertySourceProcessor} automatically adapting\r\n * property source names via {@link ResourcePropertySource#withResourceName()}\r\n * if necessary, for example, when combining multiple sources for the same name\r\n * into a {@link org.springframework.core.env.CompositePropertySource}.\r\n * Custom implementations with custom {@link PropertySource} types need\r\n * to make sure to expose distinct enough names, possibly deriving from\r\n * {@link ResourcePropertySource} where possible.\r\n * @param name the name of the property source\r\n * (can be {@code null} in which case the factory implementation\r\n * will have to generate a name based on the given resource)\r\n * @param resource the resource (potentially encoded) to wrap\r\n * @return the new {@link PropertySource} (never {@code null})\r\n * @throws IOException if resource resolution failed\r\n */\r\nPropertySource<?> createPropertySource(@Nullable String name, EncodedResource resource) throws IOException;",
    "comment": "\n\t * Create a {@link PropertySource} that wraps the given resource.\n\t * <p>Implementations will typically create {@link ResourcePropertySource}\n\t * instances, with {@link PropertySourceProcessor} automatically adapting\n\t * property source names via {@link ResourcePropertySource#withResourceName()}\n\t * if necessary, for example, when combining multiple sources for the same name\n\t * into a {@link org.springframework.core.env.CompositePropertySource}.\n\t * Custom implementations with custom {@link PropertySource} types need\n\t * to make sure to expose distinct enough names, possibly deriving from\n\t * {@link ResourcePropertySource} where possible.\n\t * @param name the name of the property source\n\t * (can be {@code null} in which case the factory implementation\n\t * will have to generate a name based on the given resource)\n\t * @param resource the resource (potentially encoded) to wrap\n\t * @return the new {@link PropertySource} (never {@code null})\n\t * @throws IOException if resource resolution failed\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.PropertySourceProcessor",
    "entityType": "class",
    "code": "private static final PropertySourceFactory defaultPropertySourceFactory = new DefaultPropertySourceFactory();\nprivate static final Log logger = LogFactory.getLog(PropertySourceProcessor.class);\nprivate final ConfigurableEnvironment environment;\nprivate final ResourcePatternResolver resourcePatternResolver;\nprivate final List<String> propertySourceNames = new ArrayList<>();\npublic PropertySourceProcessor(ConfigurableEnvironment environment, ResourceLoader resourceLoader) {\r\n    this.environment = environment;\r\n    this.resourcePatternResolver = ResourcePatternUtils.getResourcePatternResolver(resourceLoader);\r\n}\n/**\r\n * Process the specified {@link PropertySourceDescriptor} against the\r\n * environment managed by this instance.\r\n * @param descriptor the descriptor to process\r\n * @throws IOException if loading the properties failed\r\n */\r\npublic void processPropertySource(PropertySourceDescriptor descriptor) throws IOException {\r\n    String name = descriptor.name();\r\n    String encoding = descriptor.encoding();\r\n    List<String> locations = descriptor.locations();\r\n    Assert.isTrue(locations.size() > 0, \"At least one @PropertySource(value) location is required\");\r\n    boolean ignoreResourceNotFound = descriptor.ignoreResourceNotFound();\r\n    PropertySourceFactory factory = (descriptor.propertySourceFactory() != null ? instantiateClass(descriptor.propertySourceFactory()) : defaultPropertySourceFactory);\r\n    for (String location : locations) {\r\n        try {\r\n            String resolvedLocation = this.environment.resolveRequiredPlaceholders(location);\r\n            for (Resource resource : this.resourcePatternResolver.getResources(resolvedLocation)) {\r\n                addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)));\r\n            }\r\n        } catch (RuntimeException | IOException ex) {\r\n            // Placeholders not resolvable or resource not found when trying to open it\r\n            if (ignoreResourceNotFound && (ex instanceof PlaceholderResolutionException || isIgnorableException(ex) || isIgnorableException(ex.getCause()))) {\r\n                if (logger.isInfoEnabled()) {\r\n                    logger.info(\"Properties location [\" + location + \"] not resolvable: \" + ex.getMessage());\r\n                }\r\n            } else {\r\n                throw ex;\r\n            }\r\n        }\r\n    }\r\n}\nprivate void addPropertySource(PropertySource<?> propertySource) {\r\n    String name = propertySource.getName();\r\n    MutablePropertySources propertySources = this.environment.getPropertySources();\r\n    if (this.propertySourceNames.contains(name)) {\r\n        // We've already added a version, we need to extend it\r\n        PropertySource<?> existing = propertySources.get(name);\r\n        if (existing != null) {\r\n            PropertySource<?> newSource = (propertySource instanceof ResourcePropertySource rps ? rps.withResourceName() : propertySource);\r\n            if (existing instanceof CompositePropertySource cps) {\r\n                cps.addFirstPropertySource(newSource);\r\n            } else {\r\n                if (existing instanceof ResourcePropertySource rps) {\r\n                    existing = rps.withResourceName();\r\n                }\r\n                CompositePropertySource composite = new CompositePropertySource(name);\r\n                composite.addPropertySource(newSource);\r\n                composite.addPropertySource(existing);\r\n                propertySources.replace(name, composite);\r\n            }\r\n            return;\r\n        }\r\n    }\r\n    if (this.propertySourceNames.isEmpty()) {\r\n        propertySources.addLast(propertySource);\r\n    } else {\r\n        String lastAdded = this.propertySourceNames.get(this.propertySourceNames.size() - 1);\r\n        propertySources.addBefore(lastAdded, propertySource);\r\n    }\r\n    this.propertySourceNames.add(name);\r\n}\nprivate static PropertySourceFactory instantiateClass(Class<? extends PropertySourceFactory> type) {\r\n    try {\r\n        Constructor<? extends PropertySourceFactory> constructor = type.getDeclaredConstructor();\r\n        ReflectionUtils.makeAccessible(constructor);\r\n        return constructor.newInstance();\r\n    } catch (Exception ex) {\r\n        throw new IllegalStateException(\"Failed to instantiate \" + type, ex);\r\n    }\r\n}\n/**\r\n * Determine if the supplied exception can be ignored according to\r\n * {@code ignoreResourceNotFound} semantics.\r\n */\r\nprivate static boolean isIgnorableException(@Nullable Throwable ex) {\r\n    return (ex instanceof FileNotFoundException || ex instanceof UnknownHostException || ex instanceof SocketException);\r\n}",
    "comment": "\n * Contribute {@link PropertySource property sources} to the {@link Environment}.\n *\n * <p>This class is stateful and merges descriptors with the same name in a\n * single {@link PropertySource} rather than creating dedicated ones.\n *\n * @author Stephane Nicoll\n * @author Sam Brannen\n * @author Juergen Hoeller\n * @since 6.0\n * @see PropertySourceDescriptor\n "
  },
  {
    "entityId": "org.springframework.core.io.support.PropertySourceProcessor#processPropertySource(PropertySourceDescriptor)",
    "entityType": "method",
    "code": "/**\r\n * Process the specified {@link PropertySourceDescriptor} against the\r\n * environment managed by this instance.\r\n * @param descriptor the descriptor to process\r\n * @throws IOException if loading the properties failed\r\n */\r\npublic void processPropertySource(PropertySourceDescriptor descriptor) throws IOException {\r\n    String name = descriptor.name();\r\n    String encoding = descriptor.encoding();\r\n    List<String> locations = descriptor.locations();\r\n    Assert.isTrue(locations.size() > 0, \"At least one @PropertySource(value) location is required\");\r\n    boolean ignoreResourceNotFound = descriptor.ignoreResourceNotFound();\r\n    PropertySourceFactory factory = (descriptor.propertySourceFactory() != null ? instantiateClass(descriptor.propertySourceFactory()) : defaultPropertySourceFactory);\r\n    for (String location : locations) {\r\n        try {\r\n            String resolvedLocation = this.environment.resolveRequiredPlaceholders(location);\r\n            for (Resource resource : this.resourcePatternResolver.getResources(resolvedLocation)) {\r\n                addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)));\r\n            }\r\n        } catch (RuntimeException | IOException ex) {\r\n            // Placeholders not resolvable or resource not found when trying to open it\r\n            if (ignoreResourceNotFound && (ex instanceof PlaceholderResolutionException || isIgnorableException(ex) || isIgnorableException(ex.getCause()))) {\r\n                if (logger.isInfoEnabled()) {\r\n                    logger.info(\"Properties location [\" + location + \"] not resolvable: \" + ex.getMessage());\r\n                }\r\n            } else {\r\n                throw ex;\r\n            }\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Process the specified {@link PropertySourceDescriptor} against the\n\t * environment managed by this instance.\n\t * @param descriptor the descriptor to process\n\t * @throws IOException if loading the properties failed\n\t "
  }
]