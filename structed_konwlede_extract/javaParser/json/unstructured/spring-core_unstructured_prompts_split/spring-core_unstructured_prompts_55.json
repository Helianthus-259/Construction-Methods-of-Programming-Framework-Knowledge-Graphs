[
  {
    "entityId": "org.springframework.core.convert.TypeDescriptor#nested(MethodParameter,int)",
    "entityType": "method",
    "code": "/**\r\n * Create a type descriptor for a nested type declared within the method parameter.\r\n * <p>For example, if the methodParameter is a {@code List<String>} and the\r\n * nesting level is 1, the nested type descriptor will be String.class.\r\n * <p>If the methodParameter is a {@code List<List<String>>} and the nesting\r\n * level is 2, the nested type descriptor will also be a String.class.\r\n * <p>If the methodParameter is a {@code Map<Integer, String>} and the nesting\r\n * level is 1, the nested type descriptor will be String, derived from the map value.\r\n * <p>If the methodParameter is a {@code List<Map<Integer, String>>} and the\r\n * nesting level is 2, the nested type descriptor will be String, derived from the map value.\r\n * <p>Returns {@code null} if a nested type cannot be obtained because it was not declared.\r\n * For example, if the method parameter is a {@code List<?>}, the nested type\r\n * descriptor returned will be {@code null}.\r\n * @param methodParameter the method parameter with a nestingLevel of 1\r\n * @param nestingLevel the nesting level of the collection/array element or\r\n * map key/value declaration within the method parameter\r\n * @return the nested type descriptor at the specified nesting level,\r\n * or {@code null} if it could not be obtained\r\n * @throws IllegalArgumentException if the nesting level of the input\r\n * {@link MethodParameter} argument is not 1, or if the types up to the\r\n * specified nesting level are not of collection, array, or map types\r\n */\r\n@Nullable\r\npublic static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {\r\n    if (methodParameter.getNestingLevel() != 1) {\r\n        throw new IllegalArgumentException(\"MethodParameter nesting level must be 1: \" + \"use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal\");\r\n    }\r\n    return new TypeDescriptor(methodParameter).nested(nestingLevel);\r\n}",
    "comment": "\n\t * Create a type descriptor for a nested type declared within the method parameter.\n\t * <p>For example, if the methodParameter is a {@code List<String>} and the\n\t * nesting level is 1, the nested type descriptor will be String.class.\n\t * <p>If the methodParameter is a {@code List<List<String>>} and the nesting\n\t * level is 2, the nested type descriptor will also be a String.class.\n\t * <p>If the methodParameter is a {@code Map<Integer, String>} and the nesting\n\t * level is 1, the nested type descriptor will be String, derived from the map value.\n\t * <p>If the methodParameter is a {@code List<Map<Integer, String>>} and the\n\t * nesting level is 2, the nested type descriptor will be String, derived from the map value.\n\t * <p>Returns {@code null} if a nested type cannot be obtained because it was not declared.\n\t * For example, if the method parameter is a {@code List<?>}, the nested type\n\t * descriptor returned will be {@code null}.\n\t * @param methodParameter the method parameter with a nestingLevel of 1\n\t * @param nestingLevel the nesting level of the collection/array element or\n\t * map key/value declaration within the method parameter\n\t * @return the nested type descriptor at the specified nesting level,\n\t * or {@code null} if it could not be obtained\n\t * @throws IllegalArgumentException if the nesting level of the input\n\t * {@link MethodParameter} argument is not 1, or if the types up to the\n\t * specified nesting level are not of collection, array, or map types\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.TypeDescriptor#nested(Field,int)",
    "entityType": "method",
    "code": "/**\r\n * Create a type descriptor for a nested type declared within the field.\r\n * <p>For example, if the field is a {@code List<String>} and the nesting\r\n * level is 1, the nested type descriptor will be {@code String.class}.\r\n * <p>If the field is a {@code List<List<String>>} and the nesting level is\r\n * 2, the nested type descriptor will also be a {@code String.class}.\r\n * <p>If the field is a {@code Map<Integer, String>} and the nesting level\r\n * is 1, the nested type descriptor will be String, derived from the map value.\r\n * <p>If the field is a {@code List<Map<Integer, String>>} and the nesting\r\n * level is 2, the nested type descriptor will be String, derived from the map value.\r\n * <p>Returns {@code null} if a nested type cannot be obtained because it was not\r\n * declared. For example, if the field is a {@code List<?>}, the nested type\r\n * descriptor returned will be {@code null}.\r\n * @param field the field\r\n * @param nestingLevel the nesting level of the collection/array element or\r\n * map key/value declaration within the field\r\n * @return the nested type descriptor at the specified nesting level,\r\n * or {@code null} if it could not be obtained\r\n * @throws IllegalArgumentException if the types up to the specified nesting\r\n * level are not of collection, array, or map types\r\n */\r\n@Nullable\r\npublic static TypeDescriptor nested(Field field, int nestingLevel) {\r\n    return new TypeDescriptor(field).nested(nestingLevel);\r\n}",
    "comment": "\n\t * Create a type descriptor for a nested type declared within the field.\n\t * <p>For example, if the field is a {@code List<String>} and the nesting\n\t * level is 1, the nested type descriptor will be {@code String.class}.\n\t * <p>If the field is a {@code List<List<String>>} and the nesting level is\n\t * 2, the nested type descriptor will also be a {@code String.class}.\n\t * <p>If the field is a {@code Map<Integer, String>} and the nesting level\n\t * is 1, the nested type descriptor will be String, derived from the map value.\n\t * <p>If the field is a {@code List<Map<Integer, String>>} and the nesting\n\t * level is 2, the nested type descriptor will be String, derived from the map value.\n\t * <p>Returns {@code null} if a nested type cannot be obtained because it was not\n\t * declared. For example, if the field is a {@code List<?>}, the nested type\n\t * descriptor returned will be {@code null}.\n\t * @param field the field\n\t * @param nestingLevel the nesting level of the collection/array element or\n\t * map key/value declaration within the field\n\t * @return the nested type descriptor at the specified nesting level,\n\t * or {@code null} if it could not be obtained\n\t * @throws IllegalArgumentException if the types up to the specified nesting\n\t * level are not of collection, array, or map types\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.TypeDescriptor#nested(Property,int)",
    "entityType": "method",
    "code": "/**\r\n * Create a type descriptor for a nested type declared within the property.\r\n * <p>For example, if the property is a {@code List<String>} and the nesting\r\n * level is 1, the nested type descriptor will be {@code String.class}.\r\n * <p>If the property is a {@code List<List<String>>} and the nesting level\r\n * is 2, the nested type descriptor will also be a {@code String.class}.\r\n * <p>If the property is a {@code Map<Integer, String>} and the nesting level\r\n * is 1, the nested type descriptor will be String, derived from the map value.\r\n * <p>If the property is a {@code List<Map<Integer, String>>} and the nesting\r\n * level is 2, the nested type descriptor will be String, derived from the map value.\r\n * <p>Returns {@code null} if a nested type cannot be obtained because it was not\r\n * declared. For example, if the property is a {@code List<?>}, the nested type\r\n * descriptor returned will be {@code null}.\r\n * @param property the property\r\n * @param nestingLevel the nesting level of the collection/array element or\r\n * map key/value declaration within the property\r\n * @return the nested type descriptor at the specified nesting level, or\r\n * {@code null} if it could not be obtained\r\n * @throws IllegalArgumentException if the types up to the specified nesting\r\n * level are not of collection, array, or map types\r\n */\r\n@Nullable\r\npublic static TypeDescriptor nested(Property property, int nestingLevel) {\r\n    return new TypeDescriptor(property).nested(nestingLevel);\r\n}",
    "comment": "\n\t * Create a type descriptor for a nested type declared within the property.\n\t * <p>For example, if the property is a {@code List<String>} and the nesting\n\t * level is 1, the nested type descriptor will be {@code String.class}.\n\t * <p>If the property is a {@code List<List<String>>} and the nesting level\n\t * is 2, the nested type descriptor will also be a {@code String.class}.\n\t * <p>If the property is a {@code Map<Integer, String>} and the nesting level\n\t * is 1, the nested type descriptor will be String, derived from the map value.\n\t * <p>If the property is a {@code List<Map<Integer, String>>} and the nesting\n\t * level is 2, the nested type descriptor will be String, derived from the map value.\n\t * <p>Returns {@code null} if a nested type cannot be obtained because it was not\n\t * declared. For example, if the property is a {@code List<?>}, the nested type\n\t * descriptor returned will be {@code null}.\n\t * @param property the property\n\t * @param nestingLevel the nesting level of the collection/array element or\n\t * map key/value declaration within the property\n\t * @return the nested type descriptor at the specified nesting level, or\n\t * {@code null} if it could not be obtained\n\t * @throws IllegalArgumentException if the types up to the specified nesting\n\t * level are not of collection, array, or map types\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.TypeDescriptor#getName(Class<?>)",
    "entityType": "method",
    "code": "private static String getName(Class<?> clazz) {\r\n    String canonicalName = clazz.getCanonicalName();\r\n    return (canonicalName != null ? canonicalName : clazz.getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.AnnotatedElementAdapter",
    "entityType": "class",
    "code": "private static final AnnotatedElementAdapter EMPTY = new AnnotatedElementAdapter(new Annotation[0]);\nprivate final Annotation[] annotations;\nprivate AnnotatedElementAdapter(Annotation[] annotations) {\r\n    this.annotations = annotations;\r\n}\nprivate static AnnotatedElementAdapter from(Annotation @Nullable [] annotations) {\r\n    if (annotations == null || annotations.length == 0) {\r\n        return EMPTY;\r\n    }\r\n    return new AnnotatedElementAdapter(annotations);\r\n}\n@Override\r\npublic boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) {\r\n    for (Annotation annotation : this.annotations) {\r\n        if (annotation.annotationType() == annotationClass) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n@Override\r\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\npublic <T extends Annotation> T getAnnotation(Class<T> annotationClass) {\r\n    for (Annotation annotation : this.annotations) {\r\n        if (annotation.annotationType() == annotationClass) {\r\n            return (T) annotation;\r\n        }\r\n    }\r\n    return null;\r\n}\n@Override\r\npublic Annotation[] getAnnotations() {\r\n    return (isEmpty() ? this.annotations : this.annotations.clone());\r\n}\n@Override\r\npublic Annotation[] getDeclaredAnnotations() {\r\n    return getAnnotations();\r\n}\npublic boolean isEmpty() {\r\n    return (this.annotations.length == 0);\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof AnnotatedElementAdapter that && Arrays.equals(this.annotations, that.annotations)));\r\n}\n@Override\r\npublic int hashCode() {\r\n    return Arrays.hashCode(this.annotations);\r\n}\n@Override\r\npublic String toString() {\r\n    return Arrays.toString(this.annotations);\r\n}",
    "comment": "\n\t * Adapter class for exposing a {@code TypeDescriptor}'s annotations as an\n\t * {@link AnnotatedElement}, in particular to {@link AnnotatedElementUtils}.\n\t * @see AnnotatedElementUtils#isAnnotated(AnnotatedElement, Class)\n\t * @see AnnotatedElementUtils#getMergedAnnotation(AnnotatedElement, Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.AnnotatedElementAdapter#from(Annotation[])",
    "entityType": "method",
    "code": "private static AnnotatedElementAdapter from(Annotation @Nullable [] annotations) {\r\n    if (annotations == null || annotations.length == 0) {\r\n        return EMPTY;\r\n    }\r\n    return new AnnotatedElementAdapter(annotations);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.AnnotatedElementAdapter#isAnnotationPresent(Class<? extends Annotation>)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) {\r\n    for (Annotation annotation : this.annotations) {\r\n        if (annotation.annotationType() == annotationClass) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.AnnotatedElementAdapter#getAnnotation(Class<T>)",
    "entityType": "method",
    "code": "@Override\r\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\npublic <T extends Annotation> T getAnnotation(Class<T> annotationClass) {\r\n    for (Annotation annotation : this.annotations) {\r\n        if (annotation.annotationType() == annotationClass) {\r\n            return (T) annotation;\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.AnnotatedElementAdapter#getAnnotations()",
    "entityType": "method",
    "code": "@Override\r\npublic Annotation[] getAnnotations() {\r\n    return (isEmpty() ? this.annotations : this.annotations.clone());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.AnnotatedElementAdapter#getDeclaredAnnotations()",
    "entityType": "method",
    "code": "@Override\r\npublic Annotation[] getDeclaredAnnotations() {\r\n    return getAnnotations();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.AnnotatedElementAdapter#isEmpty()",
    "entityType": "method",
    "code": "public boolean isEmpty() {\r\n    return (this.annotations.length == 0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.AnnotatedElementAdapter#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof AnnotatedElementAdapter that && Arrays.equals(this.annotations, that.annotations)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.AnnotatedElementAdapter#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return Arrays.hashCode(this.annotations);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.AnnotatedElementAdapter#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return Arrays.toString(this.annotations);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.CoroutinesUtils",
    "entityType": "class",
    "code": "private static final KType flowType = KClassifiers.getStarProjectedType(JvmClassMappingKt.getKotlinClass(Flow.class));\nprivate static final KType monoType = KClassifiers.getStarProjectedType(JvmClassMappingKt.getKotlinClass(Mono.class));\nprivate static final KType publisherType = KClassifiers.getStarProjectedType(JvmClassMappingKt.getKotlinClass(Publisher.class));\n/**\r\n * Convert a {@link Deferred} instance to a {@link Mono}.\r\n */\r\npublic static <T> Mono<T> deferredToMono(Deferred<T> source) {\r\n    return MonoKt.mono(Dispatchers.getUnconfined(), (scope, continuation) -> source.await(continuation));\r\n}\n/**\r\n * Convert a {@link Mono} instance to a {@link Deferred}.\r\n */\r\npublic static <T> Deferred<T> monoToDeferred(Mono<T> source) {\r\n    return BuildersKt.async(GlobalScope.INSTANCE, Dispatchers.getUnconfined(), CoroutineStart.DEFAULT, (scope, continuation) -> MonoKt.awaitSingleOrNull(source, continuation));\r\n}\n/**\r\n * Invoke a suspending function and convert it to {@link Mono} or {@link Flux}.\r\n * Uses an {@linkplain Dispatchers#getUnconfined() unconfined} dispatcher.\r\n * @param method the suspending function to invoke\r\n * @param target the target to invoke {@code method} on\r\n * @param args the function arguments. If the {@code Continuation} argument is specified as the last argument\r\n * (typically {@code null}), it is ignored.\r\n * @return the method invocation result as reactive stream\r\n * @throws IllegalArgumentException if {@code method} is not a suspending function\r\n */\r\npublic static Publisher<?> invokeSuspendingFunction(Method method, Object target, @Nullable Object... args) {\r\n    return invokeSuspendingFunction(Dispatchers.getUnconfined(), method, target, args);\r\n}\n/**\r\n * Invoke a suspending function and convert it to {@link Mono} or\r\n * {@link Flux}.\r\n * @param context the coroutine context to use\r\n * @param method the suspending function to invoke\r\n * @param target the target to invoke {@code method} on\r\n * @param args the function arguments. If the {@code Continuation} argument is specified as the last argument\r\n * (typically {@code null}), it is ignored.\r\n * @return the method invocation result as reactive stream\r\n * @throws IllegalArgumentException if {@code method} is not a suspending function\r\n * @since 6.0\r\n */\r\n@SuppressWarnings({ \"DataFlowIssue\", \"NullAway\" })\r\npublic static Publisher<?> invokeSuspendingFunction(CoroutineContext context, Method method, @Nullable Object target, @Nullable Object... args) {\r\n    Assert.isTrue(KotlinDetector.isSuspendingFunction(method), \"Method must be a suspending function\");\r\n    KFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\r\n    Assert.notNull(function, () -> \"Failed to get Kotlin function for method: \" + method);\r\n    if (!KCallablesJvm.isAccessible(function)) {\r\n        KCallablesJvm.setAccessible(function, true);\r\n    }\r\n    Mono<Object> mono = MonoKt.mono(context, (scope, continuation) -> {\r\n        Map<KParameter, Object> argMap = CollectionUtils.newHashMap(args.length + 1);\r\n        int index = 0;\r\n        for (KParameter parameter : function.getParameters()) {\r\n            switch(parameter.getKind()) {\r\n                case INSTANCE ->\r\n                    argMap.put(parameter, target);\r\n                case VALUE, EXTENSION_RECEIVER ->\r\n                    {\r\n                        Object arg = args[index];\r\n                        if (!(parameter.isOptional() && arg == null)) {\r\n                            KType type = parameter.getType();\r\n                            if (!(type.isMarkedNullable() && arg == null) && type.getClassifier() instanceof KClass<?> kClass && KotlinDetector.isInlineClass(JvmClassMappingKt.getJavaClass(kClass))) {\r\n                                KFunction<?> constructor = KClasses.getPrimaryConstructor(kClass);\r\n                                if (!KCallablesJvm.isAccessible(constructor)) {\r\n                                    KCallablesJvm.setAccessible(constructor, true);\r\n                                }\r\n                                arg = constructor.call(arg);\r\n                            }\r\n                            argMap.put(parameter, arg);\r\n                        }\r\n                        index++;\r\n                    }\r\n            }\r\n        }\r\n        return KCallables.callSuspendBy(function, argMap, continuation);\r\n    }).filter(result -> result != Unit.INSTANCE).onErrorMap(InvocationTargetException.class, InvocationTargetException::getTargetException);\r\n    KType returnType = function.getReturnType();\r\n    if (KTypes.isSubtypeOf(returnType, flowType)) {\r\n        return mono.flatMapMany(CoroutinesUtils::asFlux);\r\n    }\r\n    if (KTypes.isSubtypeOf(returnType, publisherType)) {\r\n        if (KTypes.isSubtypeOf(returnType, monoType)) {\r\n            return mono.flatMap(o -> ((Mono<?>) o));\r\n        }\r\n        return mono.flatMapMany(o -> ((Publisher<?>) o));\r\n    }\r\n    return mono;\r\n}\nprivate static Flux<?> asFlux(Object flow) {\r\n    return ReactorFlowKt.asFlux(((Flow<?>) flow));\r\n}",
    "comment": "\n * Utilities for working with Kotlin Coroutines.\n *\n * @author Sebastien Deleuze\n * @author Phillip Webb\n * @since 5.2\n "
  },
  {
    "entityId": "org.springframework.core.CoroutinesUtils#deferredToMono(Deferred<T>)",
    "entityType": "method",
    "code": "/**\r\n * Convert a {@link Deferred} instance to a {@link Mono}.\r\n */\r\npublic static <T> Mono<T> deferredToMono(Deferred<T> source) {\r\n    return MonoKt.mono(Dispatchers.getUnconfined(), (scope, continuation) -> source.await(continuation));\r\n}",
    "comment": "\n\t * Convert a {@link Deferred} instance to a {@link Mono}.\n\t "
  },
  {
    "entityId": "org.springframework.core.CoroutinesUtils#monoToDeferred(Mono<T>)",
    "entityType": "method",
    "code": "/**\r\n * Convert a {@link Mono} instance to a {@link Deferred}.\r\n */\r\npublic static <T> Deferred<T> monoToDeferred(Mono<T> source) {\r\n    return BuildersKt.async(GlobalScope.INSTANCE, Dispatchers.getUnconfined(), CoroutineStart.DEFAULT, (scope, continuation) -> MonoKt.awaitSingleOrNull(source, continuation));\r\n}",
    "comment": "\n\t * Convert a {@link Mono} instance to a {@link Deferred}.\n\t "
  },
  {
    "entityId": "org.springframework.core.CoroutinesUtils#invokeSuspendingFunction(Method,Object,Object)",
    "entityType": "method",
    "code": "/**\r\n * Invoke a suspending function and convert it to {@link Mono} or {@link Flux}.\r\n * Uses an {@linkplain Dispatchers#getUnconfined() unconfined} dispatcher.\r\n * @param method the suspending function to invoke\r\n * @param target the target to invoke {@code method} on\r\n * @param args the function arguments. If the {@code Continuation} argument is specified as the last argument\r\n * (typically {@code null}), it is ignored.\r\n * @return the method invocation result as reactive stream\r\n * @throws IllegalArgumentException if {@code method} is not a suspending function\r\n */\r\npublic static Publisher<?> invokeSuspendingFunction(Method method, Object target, @Nullable Object... args) {\r\n    return invokeSuspendingFunction(Dispatchers.getUnconfined(), method, target, args);\r\n}",
    "comment": "\n\t * Invoke a suspending function and convert it to {@link Mono} or {@link Flux}.\n\t * Uses an {@linkplain Dispatchers#getUnconfined() unconfined} dispatcher.\n\t * @param method the suspending function to invoke\n\t * @param target the target to invoke {@code method} on\n\t * @param args the function arguments. If the {@code Continuation} argument is specified as the last argument\n\t * (typically {@code null}), it is ignored.\n\t * @return the method invocation result as reactive stream\n\t * @throws IllegalArgumentException if {@code method} is not a suspending function\n\t "
  },
  {
    "entityId": "org.springframework.core.CoroutinesUtils#invokeSuspendingFunction(CoroutineContext,Method,Object,Object)",
    "entityType": "method",
    "code": "/**\r\n * Invoke a suspending function and convert it to {@link Mono} or\r\n * {@link Flux}.\r\n * @param context the coroutine context to use\r\n * @param method the suspending function to invoke\r\n * @param target the target to invoke {@code method} on\r\n * @param args the function arguments. If the {@code Continuation} argument is specified as the last argument\r\n * (typically {@code null}), it is ignored.\r\n * @return the method invocation result as reactive stream\r\n * @throws IllegalArgumentException if {@code method} is not a suspending function\r\n * @since 6.0\r\n */\r\n@SuppressWarnings({ \"DataFlowIssue\", \"NullAway\" })\r\npublic static Publisher<?> invokeSuspendingFunction(CoroutineContext context, Method method, @Nullable Object target, @Nullable Object... args) {\r\n    Assert.isTrue(KotlinDetector.isSuspendingFunction(method), \"Method must be a suspending function\");\r\n    KFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\r\n    Assert.notNull(function, () -> \"Failed to get Kotlin function for method: \" + method);\r\n    if (!KCallablesJvm.isAccessible(function)) {\r\n        KCallablesJvm.setAccessible(function, true);\r\n    }\r\n    Mono<Object> mono = MonoKt.mono(context, (scope, continuation) -> {\r\n        Map<KParameter, Object> argMap = CollectionUtils.newHashMap(args.length + 1);\r\n        int index = 0;\r\n        for (KParameter parameter : function.getParameters()) {\r\n            switch(parameter.getKind()) {\r\n                case INSTANCE ->\r\n                    argMap.put(parameter, target);\r\n                case VALUE, EXTENSION_RECEIVER ->\r\n                    {\r\n                        Object arg = args[index];\r\n                        if (!(parameter.isOptional() && arg == null)) {\r\n                            KType type = parameter.getType();\r\n                            if (!(type.isMarkedNullable() && arg == null) && type.getClassifier() instanceof KClass<?> kClass && KotlinDetector.isInlineClass(JvmClassMappingKt.getJavaClass(kClass))) {\r\n                                KFunction<?> constructor = KClasses.getPrimaryConstructor(kClass);\r\n                                if (!KCallablesJvm.isAccessible(constructor)) {\r\n                                    KCallablesJvm.setAccessible(constructor, true);\r\n                                }\r\n                                arg = constructor.call(arg);\r\n                            }\r\n                            argMap.put(parameter, arg);\r\n                        }\r\n                        index++;\r\n                    }\r\n            }\r\n        }\r\n        return KCallables.callSuspendBy(function, argMap, continuation);\r\n    }).filter(result -> result != Unit.INSTANCE).onErrorMap(InvocationTargetException.class, InvocationTargetException::getTargetException);\r\n    KType returnType = function.getReturnType();\r\n    if (KTypes.isSubtypeOf(returnType, flowType)) {\r\n        return mono.flatMapMany(CoroutinesUtils::asFlux);\r\n    }\r\n    if (KTypes.isSubtypeOf(returnType, publisherType)) {\r\n        if (KTypes.isSubtypeOf(returnType, monoType)) {\r\n            return mono.flatMap(o -> ((Mono<?>) o));\r\n        }\r\n        return mono.flatMapMany(o -> ((Publisher<?>) o));\r\n    }\r\n    return mono;\r\n}",
    "comment": "\n\t * Invoke a suspending function and convert it to {@link Mono} or\n\t * {@link Flux}.\n\t * @param context the coroutine context to use\n\t * @param method the suspending function to invoke\n\t * @param target the target to invoke {@code method} on\n\t * @param args the function arguments. If the {@code Continuation} argument is specified as the last argument\n\t * (typically {@code null}), it is ignored.\n\t * @return the method invocation result as reactive stream\n\t * @throws IllegalArgumentException if {@code method} is not a suspending function\n\t * @since 6.0\n\t "
  },
  {
    "entityId": "org.springframework.core.CoroutinesUtils#asFlux(Object)",
    "entityType": "method",
    "code": "private static Flux<?> asFlux(Object flow) {\r\n    return ReactorFlowKt.asFlux(((Flow<?>) flow));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.DecoratingClassLoader",
    "entityType": "class",
    "code": "static {\r\n    ClassLoader.registerAsParallelCapable();\r\n}\nprivate final Set<String> excludedPackages = ConcurrentHashMap.newKeySet(8);\nprivate final Set<String> excludedClasses = ConcurrentHashMap.newKeySet(8);\n/**\r\n * Create a new DecoratingClassLoader with no parent ClassLoader.\r\n */\r\npublic DecoratingClassLoader() {\r\n}\n/**\r\n * Create a new DecoratingClassLoader using the given parent ClassLoader\r\n * for delegation.\r\n */\r\npublic DecoratingClassLoader(@Nullable ClassLoader parent) {\r\n    super(parent);\r\n}\n/**\r\n * Add a package name to exclude from decoration (for example, overriding).\r\n * <p>Any class whose fully-qualified name starts with the name registered\r\n * here will be handled by the parent ClassLoader in the usual fashion.\r\n * @param packageName the package name to exclude\r\n */\r\npublic void excludePackage(String packageName) {\r\n    Assert.notNull(packageName, \"Package name must not be null\");\r\n    this.excludedPackages.add(packageName);\r\n}\n/**\r\n * Add a class name to exclude from decoration (for example, overriding).\r\n * <p>Any class name registered here will be handled by the parent\r\n * ClassLoader in the usual fashion.\r\n * @param className the class name to exclude\r\n */\r\npublic void excludeClass(String className) {\r\n    Assert.notNull(className, \"Class name must not be null\");\r\n    this.excludedClasses.add(className);\r\n}\n/**\r\n * Determine whether the specified class is excluded from decoration\r\n * by this class loader.\r\n * <p>The default implementation checks against excluded packages and classes.\r\n * @param className the class name to check\r\n * @return whether the specified class is eligible\r\n * @see #excludePackage\r\n * @see #excludeClass\r\n */\r\nprotected boolean isExcluded(String className) {\r\n    if (this.excludedClasses.contains(className)) {\r\n        return true;\r\n    }\r\n    for (String packageName : this.excludedPackages) {\r\n        if (className.startsWith(packageName)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": "\n * Base class for decorating ClassLoaders such as {@link OverridingClassLoader}\n * and {@link org.springframework.instrument.classloading.ShadowingClassLoader},\n * providing common handling of excluded packages and classes.\n *\n * @author Juergen Hoeller\n * @author Rod Johnson\n * @since 2.5.2\n "
  },
  {
    "entityId": "org.springframework.core.DecoratingClassLoader#excludePackage(String)",
    "entityType": "method",
    "code": "/**\r\n * Add a package name to exclude from decoration (for example, overriding).\r\n * <p>Any class whose fully-qualified name starts with the name registered\r\n * here will be handled by the parent ClassLoader in the usual fashion.\r\n * @param packageName the package name to exclude\r\n */\r\npublic void excludePackage(String packageName) {\r\n    Assert.notNull(packageName, \"Package name must not be null\");\r\n    this.excludedPackages.add(packageName);\r\n}",
    "comment": "\n\t * Add a package name to exclude from decoration (for example, overriding).\n\t * <p>Any class whose fully-qualified name starts with the name registered\n\t * here will be handled by the parent ClassLoader in the usual fashion.\n\t * @param packageName the package name to exclude\n\t "
  },
  {
    "entityId": "org.springframework.core.DecoratingClassLoader#excludeClass(String)",
    "entityType": "method",
    "code": "/**\r\n * Add a class name to exclude from decoration (for example, overriding).\r\n * <p>Any class name registered here will be handled by the parent\r\n * ClassLoader in the usual fashion.\r\n * @param className the class name to exclude\r\n */\r\npublic void excludeClass(String className) {\r\n    Assert.notNull(className, \"Class name must not be null\");\r\n    this.excludedClasses.add(className);\r\n}",
    "comment": "\n\t * Add a class name to exclude from decoration (for example, overriding).\n\t * <p>Any class name registered here will be handled by the parent\n\t * ClassLoader in the usual fashion.\n\t * @param className the class name to exclude\n\t "
  },
  {
    "entityId": "org.springframework.core.DecoratingClassLoader#isExcluded(String)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the specified class is excluded from decoration\r\n * by this class loader.\r\n * <p>The default implementation checks against excluded packages and classes.\r\n * @param className the class name to check\r\n * @return whether the specified class is eligible\r\n * @see #excludePackage\r\n * @see #excludeClass\r\n */\r\nprotected boolean isExcluded(String className) {\r\n    if (this.excludedClasses.contains(className)) {\r\n        return true;\r\n    }\r\n    for (String packageName : this.excludedPackages) {\r\n        if (className.startsWith(packageName)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": "\n\t * Determine whether the specified class is excluded from decoration\n\t * by this class loader.\n\t * <p>The default implementation checks against excluded packages and classes.\n\t * @param className the class name to check\n\t * @return whether the specified class is eligible\n\t * @see #excludePackage\n\t * @see #excludeClass\n\t "
  },
  {
    "entityId": "org.springframework.core.DecoratingProxy",
    "entityType": "class",
    "code": "/**\r\n * Return the (ultimate) decorated class behind this proxy.\r\n * <p>In case of an AOP proxy, this will be the ultimate target class,\r\n * not just the immediate target (in case of multiple nested proxies).\r\n * @return the decorated class (never {@code null})\r\n */\r\nClass<?> getDecoratedClass();",
    "comment": "\n * Interface to be implemented by decorating proxies, in particular Spring AOP\n * proxies but potentially also custom proxies with decorator semantics.\n *\n * <p>Note that this interface should just be implemented if the decorated class\n * is not within the hierarchy of the proxy class to begin with. In particular,\n * a \"target-class\" proxy such as a Spring AOP CGLIB proxy should not implement\n * it since any lookup on the target class can simply be performed on the proxy\n * class there anyway.\n *\n * <p>Defined in the core module in order to allow\n * {@link org.springframework.core.annotation.AnnotationAwareOrderComparator}\n * (and potential other candidates without spring-aop dependencies) to use it\n * for introspection purposes, in particular annotation lookups.\n *\n * @author Juergen Hoeller\n * @since 4.3\n "
  },
  {
    "entityId": "org.springframework.core.DecoratingProxy#getDecoratedClass()",
    "entityType": "method",
    "code": "/**\r\n * Return the (ultimate) decorated class behind this proxy.\r\n * <p>In case of an AOP proxy, this will be the ultimate target class,\r\n * not just the immediate target (in case of multiple nested proxies).\r\n * @return the decorated class (never {@code null})\r\n */\r\nClass<?> getDecoratedClass();",
    "comment": "\n\t * Return the (ultimate) decorated class behind this proxy.\n\t * <p>In case of an AOP proxy, this will be the ultimate target class,\n\t * not just the immediate target (in case of multiple nested proxies).\n\t * @return the decorated class (never {@code null})\n\t "
  },
  {
    "entityId": "org.springframework.core.DefaultParameterNameDiscoverer",
    "entityType": "class",
    "code": "public DefaultParameterNameDiscoverer() {\r\n    if (KotlinDetector.isKotlinReflectPresent()) {\r\n        addDiscoverer(new KotlinReflectionParameterNameDiscoverer());\r\n    }\r\n    // Recommended approach on Java 8+: compilation with -parameters.\r\n    addDiscoverer(new StandardReflectionParameterNameDiscoverer());\r\n}",
    "comment": "\n * Default implementation of the {@link ParameterNameDiscoverer} strategy interface,\n * delegating to the Java 8 standard reflection mechanism.\n *\n * <p>If a Kotlin reflection implementation is present,\n * {@link KotlinReflectionParameterNameDiscoverer} is added first in the list and\n * used for Kotlin classes and interfaces.\n *\n * <p>Further discoverers may be added through {@link #addDiscoverer(ParameterNameDiscoverer)}.\n *\n * @author Juergen Hoeller\n * @author Sebastien Deleuze\n * @author Sam Brannen\n * @since 4.0\n * @see StandardReflectionParameterNameDiscoverer\n * @see KotlinReflectionParameterNameDiscoverer\n "
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment",
    "entityType": "class",
    "code": "/**\r\n * System property that instructs Spring to ignore system environment variables,\r\n * i.e. to never attempt to retrieve such a variable via {@link System#getenv()}.\r\n * <p>The default is \"false\", falling back to system environment variable checks if a\r\n * Spring environment property (for example, a placeholder in a configuration String) isn't\r\n * resolvable otherwise. Consider switching this flag to \"true\" if you experience\r\n * log warnings from {@code getenv} calls coming from Spring.\r\n * @see #suppressGetenvAccess()\r\n */\r\npublic static final String IGNORE_GETENV_PROPERTY_NAME = \"spring.getenv.ignore\";\n/**\r\n * Name of the property to set to specify active profiles: {@value}.\r\n * <p>The value may be comma delimited.\r\n * <p>Note that certain shell environments such as Bash disallow the use of the period\r\n * character in variable names. Assuming that Spring's {@link SystemEnvironmentPropertySource}\r\n * is in use, this property may be specified as an environment variable named\r\n * {@code SPRING_PROFILES_ACTIVE}.\r\n * @see ConfigurableEnvironment#setActiveProfiles\r\n */\r\npublic static final String ACTIVE_PROFILES_PROPERTY_NAME = \"spring.profiles.active\";\n/**\r\n * Name of the property to set to specify profiles that are active by default: {@value}.\r\n * <p>The value may be comma delimited.\r\n * <p>Note that certain shell environments such as Bash disallow the use of the period\r\n * character in variable names. Assuming that Spring's {@link SystemEnvironmentPropertySource}\r\n * is in use, this property may be specified as an environment variable named\r\n * {@code SPRING_PROFILES_DEFAULT}.\r\n * @see ConfigurableEnvironment#setDefaultProfiles\r\n */\r\npublic static final String DEFAULT_PROFILES_PROPERTY_NAME = \"spring.profiles.default\";\n/**\r\n * Name of the reserved default profile name: {@value}.\r\n * <p>If no default profile names are explicitly set and no active profile names\r\n * are explicitly set, this profile will automatically be activated by default.\r\n * @see #getReservedDefaultProfiles\r\n * @see ConfigurableEnvironment#setDefaultProfiles\r\n * @see ConfigurableEnvironment#setActiveProfiles\r\n * @see AbstractEnvironment#DEFAULT_PROFILES_PROPERTY_NAME\r\n * @see AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME\r\n */\r\npublic static final String RESERVED_DEFAULT_PROFILE_NAME = \"default\";\nprotected final Log logger = LogFactory.getLog(getClass());\nprivate final Set<String> activeProfiles = new LinkedHashSet<>();\nprivate final Set<String> defaultProfiles = new LinkedHashSet<>(getReservedDefaultProfiles());\nprivate final MutablePropertySources propertySources;\nprivate final ConfigurablePropertyResolver propertyResolver;\n/**\r\n * Create a new {@code Environment} instance, calling back to\r\n * {@link #customizePropertySources(MutablePropertySources)} during construction to\r\n * allow subclasses to contribute or manipulate {@link PropertySource} instances as\r\n * appropriate.\r\n * @see #customizePropertySources(MutablePropertySources)\r\n */\r\npublic AbstractEnvironment() {\r\n    this(new MutablePropertySources());\r\n}\n/**\r\n * Create a new {@code Environment} instance with a specific\r\n * {@link MutablePropertySources} instance, calling back to\r\n * {@link #customizePropertySources(MutablePropertySources)} during\r\n * construction to allow subclasses to contribute or manipulate\r\n * {@link PropertySource} instances as appropriate.\r\n * @param propertySources property sources to use\r\n * @since 5.3.4\r\n * @see #customizePropertySources(MutablePropertySources)\r\n */\r\nprotected AbstractEnvironment(MutablePropertySources propertySources) {\r\n    this.propertySources = propertySources;\r\n    this.propertyResolver = createPropertyResolver(propertySources);\r\n    customizePropertySources(propertySources);\r\n}\n/**\r\n * Factory method used to create the {@link ConfigurablePropertyResolver}\r\n * instance used by the Environment.\r\n * @since 5.3.4\r\n * @see #getPropertyResolver()\r\n */\r\nprotected ConfigurablePropertyResolver createPropertyResolver(MutablePropertySources propertySources) {\r\n    return new PropertySourcesPropertyResolver(propertySources);\r\n}\n/**\r\n * Return the {@link ConfigurablePropertyResolver} being used by the\r\n * {@link Environment}.\r\n * @since 5.3.4\r\n * @see #createPropertyResolver(MutablePropertySources)\r\n */\r\nprotected final ConfigurablePropertyResolver getPropertyResolver() {\r\n    return this.propertyResolver;\r\n}\n/**\r\n * Customize the set of {@link PropertySource} objects to be searched by this\r\n * {@code Environment} during calls to {@link #getProperty(String)} and related\r\n * methods.\r\n *\r\n * <p>Subclasses that override this method are encouraged to add property\r\n * sources using {@link MutablePropertySources#addLast(PropertySource)} such that\r\n * further subclasses may call {@code super.customizePropertySources()} with\r\n * predictable results. For example:\r\n *\r\n * <pre class=\"code\">\r\n * public class Level1Environment extends AbstractEnvironment {\r\n *     &#064;Override\r\n *     protected void customizePropertySources(MutablePropertySources propertySources) {\r\n *         super.customizePropertySources(propertySources); // no-op from base class\r\n *         propertySources.addLast(new PropertySourceA(...));\r\n *         propertySources.addLast(new PropertySourceB(...));\r\n *     }\r\n * }\r\n *\r\n * public class Level2Environment extends Level1Environment {\r\n *     &#064;Override\r\n *     protected void customizePropertySources(MutablePropertySources propertySources) {\r\n *         super.customizePropertySources(propertySources); // add all from superclass\r\n *         propertySources.addLast(new PropertySourceC(...));\r\n *         propertySources.addLast(new PropertySourceD(...));\r\n *     }\r\n * }\r\n * </pre>\r\n *\r\n * <p>In this arrangement, properties will be resolved against sources A, B, C, D in that\r\n * order. That is to say that property source \"A\" has precedence over property source\r\n * \"D\". If the {@code Level2Environment} subclass wished to give property sources C\r\n * and D higher precedence than A and B, it could simply call\r\n * {@code super.customizePropertySources} after, rather than before adding its own:\r\n *\r\n * <pre class=\"code\">\r\n * public class Level2Environment extends Level1Environment {\r\n *     &#064;Override\r\n *     protected void customizePropertySources(MutablePropertySources propertySources) {\r\n *         propertySources.addLast(new PropertySourceC(...));\r\n *         propertySources.addLast(new PropertySourceD(...));\r\n *         super.customizePropertySources(propertySources); // add all from superclass\r\n *     }\r\n * }\r\n * </pre>\r\n *\r\n * <p>The search order is now C, D, A, B as desired.\r\n *\r\n * <p>Beyond these recommendations, subclasses may use any of the {@code add*},\r\n * {@code remove}, or {@code replace} methods exposed by {@link MutablePropertySources}\r\n * in order to create the exact arrangement of property sources desired.\r\n *\r\n * <p>The base implementation registers no property sources.\r\n *\r\n * <p>Note that clients of any {@link ConfigurableEnvironment} may further customize\r\n * property sources via the {@link #getPropertySources()} accessor, typically within\r\n * an {@link org.springframework.context.ApplicationContextInitializer\r\n * ApplicationContextInitializer}. For example:\r\n *\r\n * <pre class=\"code\">\r\n * ConfigurableEnvironment env = new StandardEnvironment();\r\n * env.getPropertySources().addLast(new PropertySourceX(...));\r\n * </pre>\r\n *\r\n * <h2>A warning about instance variable access</h2>\r\n * <p>Instance variables declared in subclasses and having default initial values should\r\n * <em>not</em> be accessed from within this method. Due to Java object creation\r\n * lifecycle constraints, any initial value will not yet be assigned when this\r\n * callback is invoked by the {@link #AbstractEnvironment()} constructor, which may\r\n * lead to a {@code NullPointerException} or other problems. If you need to access\r\n * default values of instance variables, leave this method as a no-op and perform\r\n * property source manipulation and instance variable access directly within the\r\n * subclass constructor. Note that <em>assigning</em> values to instance variables is\r\n * not problematic; it is only attempting to read default values that must be avoided.\r\n * @see MutablePropertySources\r\n * @see PropertySourcesPropertyResolver\r\n * @see org.springframework.context.ApplicationContextInitializer\r\n */\r\nprotected void customizePropertySources(MutablePropertySources propertySources) ;\n/**\r\n * Return the set of reserved default profile names. This implementation returns\r\n * {@value #RESERVED_DEFAULT_PROFILE_NAME}. Subclasses may override in order to\r\n * customize the set of reserved names.\r\n * @see #RESERVED_DEFAULT_PROFILE_NAME\r\n * @see #doGetDefaultProfiles()\r\n */\r\nprotected Set<String> getReservedDefaultProfiles() {\r\n    return Collections.singleton(RESERVED_DEFAULT_PROFILE_NAME);\r\n}\n//---------------------------------------------------------------------\r\n// Implementation of ConfigurableEnvironment interface\r\n//---------------------------------------------------------------------\r\n@Override\r\npublic String[] getActiveProfiles() {\r\n    return StringUtils.toStringArray(doGetActiveProfiles());\r\n}\n/**\r\n * Return the set of active profiles as explicitly set through\r\n * {@link #setActiveProfiles} or if the current set of active profiles\r\n * is empty, check for the presence of {@link #doGetActiveProfilesProperty()}\r\n * and assign its value to the set of active profiles.\r\n * @see #getActiveProfiles()\r\n * @see #doGetActiveProfilesProperty()\r\n */\r\nprotected Set<String> doGetActiveProfiles() {\r\n    synchronized (this.activeProfiles) {\r\n        if (this.activeProfiles.isEmpty()) {\r\n            String profiles = doGetActiveProfilesProperty();\r\n            if (StringUtils.hasText(profiles)) {\r\n                setActiveProfiles(StringUtils.commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(profiles)));\r\n            }\r\n        }\r\n        return this.activeProfiles;\r\n    }\r\n}\n/**\r\n * Return the property value for the active profiles.\r\n * @since 5.3.4\r\n * @see #ACTIVE_PROFILES_PROPERTY_NAME\r\n */\r\n@Nullable\r\nprotected String doGetActiveProfilesProperty() {\r\n    return getProperty(ACTIVE_PROFILES_PROPERTY_NAME);\r\n}\n@Override\r\npublic void setActiveProfiles(String... profiles) {\r\n    Assert.notNull(profiles, \"Profile array must not be null\");\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(\"Activating profiles \" + Arrays.toString(profiles));\r\n    }\r\n    synchronized (this.activeProfiles) {\r\n        this.activeProfiles.clear();\r\n        for (String profile : profiles) {\r\n            validateProfile(profile);\r\n            this.activeProfiles.add(profile);\r\n        }\r\n    }\r\n}\n@Override\r\npublic void addActiveProfile(String profile) {\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(\"Activating profile '\" + profile + \"'\");\r\n    }\r\n    validateProfile(profile);\r\n    doGetActiveProfiles();\r\n    synchronized (this.activeProfiles) {\r\n        this.activeProfiles.add(profile);\r\n    }\r\n}\n@Override\r\npublic String[] getDefaultProfiles() {\r\n    return StringUtils.toStringArray(doGetDefaultProfiles());\r\n}\n/**\r\n * Return the set of default profiles explicitly set via\r\n * {@link #setDefaultProfiles(String...)} or if the current set of default profiles\r\n * consists only of {@linkplain #getReservedDefaultProfiles() reserved default\r\n * profiles}, then check for the presence of {@link #doGetActiveProfilesProperty()}\r\n * and assign its value (if any) to the set of default profiles.\r\n * @see #AbstractEnvironment()\r\n * @see #getDefaultProfiles()\r\n * @see #getReservedDefaultProfiles()\r\n * @see #doGetDefaultProfilesProperty()\r\n */\r\nprotected Set<String> doGetDefaultProfiles() {\r\n    synchronized (this.defaultProfiles) {\r\n        if (this.defaultProfiles.equals(getReservedDefaultProfiles())) {\r\n            String profiles = doGetDefaultProfilesProperty();\r\n            if (StringUtils.hasText(profiles)) {\r\n                setDefaultProfiles(StringUtils.commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(profiles)));\r\n            }\r\n        }\r\n        return this.defaultProfiles;\r\n    }\r\n}\n/**\r\n * Return the property value for the default profiles.\r\n * @since 5.3.4\r\n * @see #DEFAULT_PROFILES_PROPERTY_NAME\r\n */\r\n@Nullable\r\nprotected String doGetDefaultProfilesProperty() {\r\n    return getProperty(DEFAULT_PROFILES_PROPERTY_NAME);\r\n}\n/**\r\n * Specify the set of profiles to be made active by default if no other profiles\r\n * are explicitly made active through {@link #setActiveProfiles}.\r\n * <p>Calling this method removes overrides any reserved default profiles\r\n * that may have been added during construction of the environment.\r\n * @see #AbstractEnvironment()\r\n * @see #getReservedDefaultProfiles()\r\n */\r\n@Override\r\npublic void setDefaultProfiles(String... profiles) {\r\n    Assert.notNull(profiles, \"Profile array must not be null\");\r\n    synchronized (this.defaultProfiles) {\r\n        this.defaultProfiles.clear();\r\n        for (String profile : profiles) {\r\n            validateProfile(profile);\r\n            this.defaultProfiles.add(profile);\r\n        }\r\n    }\r\n}\n@Override\r\n@Deprecated\r\npublic boolean acceptsProfiles(String... profiles) {\r\n    Assert.notEmpty(profiles, \"Must specify at least one profile\");\r\n    for (String profile : profiles) {\r\n        if (StringUtils.hasLength(profile) && profile.charAt(0) == '!') {\r\n            if (!isProfileActive(profile.substring(1))) {\r\n                return true;\r\n            }\r\n        } else if (isProfileActive(profile)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n@Override\r\npublic boolean acceptsProfiles(Profiles profiles) {\r\n    Assert.notNull(profiles, \"Profiles must not be null\");\r\n    return profiles.matches(this::isProfileActive);\r\n}\n/**\r\n * Return whether the given profile is active, or if active profiles are empty\r\n * whether the profile should be active by default.\r\n * @throws IllegalArgumentException per {@link #validateProfile(String)}\r\n */\r\nprotected boolean isProfileActive(String profile) {\r\n    validateProfile(profile);\r\n    Set<String> currentActiveProfiles = doGetActiveProfiles();\r\n    return (currentActiveProfiles.contains(profile) || (currentActiveProfiles.isEmpty() && doGetDefaultProfiles().contains(profile)));\r\n}\n/**\r\n * Validate the given profile, called internally prior to adding to the set of\r\n * active or default profiles.\r\n * <p>Subclasses may override to impose further restrictions on profile syntax.\r\n * @throws IllegalArgumentException if the profile is null, empty, whitespace-only or\r\n * begins with the profile NOT operator (!).\r\n * @see #acceptsProfiles\r\n * @see #addActiveProfile\r\n * @see #setDefaultProfiles\r\n */\r\nprotected void validateProfile(String profile) {\r\n    if (!StringUtils.hasText(profile)) {\r\n        throw new IllegalArgumentException(\"Invalid profile [\" + profile + \"]: must contain text\");\r\n    }\r\n    if (profile.charAt(0) == '!') {\r\n        throw new IllegalArgumentException(\"Invalid profile [\" + profile + \"]: must not begin with ! operator\");\r\n    }\r\n}\n@Override\r\npublic MutablePropertySources getPropertySources() {\r\n    return this.propertySources;\r\n}\n@Override\r\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\r\npublic Map<String, Object> getSystemProperties() {\r\n    return (Map) System.getProperties();\r\n}\n@Override\r\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\r\npublic Map<String, Object> getSystemEnvironment() {\r\n    if (suppressGetenvAccess()) {\r\n        return Collections.emptyMap();\r\n    }\r\n    return (Map) System.getenv();\r\n}\n/**\r\n * Determine whether to suppress {@link System#getenv()}/{@link System#getenv(String)}\r\n * access for the purposes of {@link #getSystemEnvironment()}.\r\n * <p>If this method returns {@code true}, an empty dummy Map will be used instead\r\n * of the regular system environment Map, never even trying to call {@code getenv}\r\n * and therefore avoiding security manager warnings (if any).\r\n * <p>The default implementation checks for the \"spring.getenv.ignore\" system property,\r\n * returning {@code true} if its value equals \"true\" in any case.\r\n * @see #IGNORE_GETENV_PROPERTY_NAME\r\n * @see SpringProperties#getFlag\r\n */\r\nprotected boolean suppressGetenvAccess() {\r\n    return SpringProperties.getFlag(IGNORE_GETENV_PROPERTY_NAME);\r\n}\n@Override\r\npublic void merge(ConfigurableEnvironment parent) {\r\n    for (PropertySource<?> ps : parent.getPropertySources()) {\r\n        if (!this.propertySources.contains(ps.getName())) {\r\n            this.propertySources.addLast(ps);\r\n        }\r\n    }\r\n    String[] parentActiveProfiles = parent.getActiveProfiles();\r\n    if (!ObjectUtils.isEmpty(parentActiveProfiles)) {\r\n        synchronized (this.activeProfiles) {\r\n            Collections.addAll(this.activeProfiles, parentActiveProfiles);\r\n        }\r\n    }\r\n    String[] parentDefaultProfiles = parent.getDefaultProfiles();\r\n    if (!ObjectUtils.isEmpty(parentDefaultProfiles)) {\r\n        synchronized (this.defaultProfiles) {\r\n            this.defaultProfiles.remove(RESERVED_DEFAULT_PROFILE_NAME);\r\n            Collections.addAll(this.defaultProfiles, parentDefaultProfiles);\r\n        }\r\n    }\r\n}\n//---------------------------------------------------------------------\r\n// Implementation of ConfigurablePropertyResolver interface\r\n//---------------------------------------------------------------------\r\n@Override\r\npublic ConfigurableConversionService getConversionService() {\r\n    return this.propertyResolver.getConversionService();\r\n}\n@Override\r\npublic void setConversionService(ConfigurableConversionService conversionService) {\r\n    this.propertyResolver.setConversionService(conversionService);\r\n}\n@Override\r\npublic void setPlaceholderPrefix(String placeholderPrefix) {\r\n    this.propertyResolver.setPlaceholderPrefix(placeholderPrefix);\r\n}\n@Override\r\npublic void setPlaceholderSuffix(String placeholderSuffix) {\r\n    this.propertyResolver.setPlaceholderSuffix(placeholderSuffix);\r\n}\n@Override\r\npublic void setValueSeparator(@Nullable String valueSeparator) {\r\n    this.propertyResolver.setValueSeparator(valueSeparator);\r\n}\n@Override\r\npublic void setEscapeCharacter(@Nullable Character escapeCharacter) {\r\n    this.propertyResolver.setEscapeCharacter(escapeCharacter);\r\n}\n@Override\r\npublic void setIgnoreUnresolvableNestedPlaceholders(boolean ignoreUnresolvableNestedPlaceholders) {\r\n    this.propertyResolver.setIgnoreUnresolvableNestedPlaceholders(ignoreUnresolvableNestedPlaceholders);\r\n}\n@Override\r\npublic void setRequiredProperties(String... requiredProperties) {\r\n    this.propertyResolver.setRequiredProperties(requiredProperties);\r\n}\n@Override\r\npublic void validateRequiredProperties() throws MissingRequiredPropertiesException {\r\n    this.propertyResolver.validateRequiredProperties();\r\n}\n//---------------------------------------------------------------------\r\n// Implementation of PropertyResolver interface\r\n//---------------------------------------------------------------------\r\n@Override\r\npublic boolean containsProperty(String key) {\r\n    return this.propertyResolver.containsProperty(key);\r\n}\n@Override\r\n@Nullable\r\npublic String getProperty(String key) {\r\n    return this.propertyResolver.getProperty(key);\r\n}\n@Override\r\npublic String getProperty(String key, String defaultValue) {\r\n    return this.propertyResolver.getProperty(key, defaultValue);\r\n}\n@Override\r\n@Nullable\r\npublic <T> T getProperty(String key, Class<T> targetType) {\r\n    return this.propertyResolver.getProperty(key, targetType);\r\n}\n@Override\r\npublic <T> T getProperty(String key, Class<T> targetType, T defaultValue) {\r\n    return this.propertyResolver.getProperty(key, targetType, defaultValue);\r\n}\n@Override\r\npublic String getRequiredProperty(String key) throws IllegalStateException {\r\n    return this.propertyResolver.getRequiredProperty(key);\r\n}\n@Override\r\npublic <T> T getRequiredProperty(String key, Class<T> targetType) throws IllegalStateException {\r\n    return this.propertyResolver.getRequiredProperty(key, targetType);\r\n}\n@Override\r\npublic String resolvePlaceholders(String text) {\r\n    return this.propertyResolver.resolvePlaceholders(text);\r\n}\n@Override\r\npublic String resolveRequiredPlaceholders(String text) throws IllegalArgumentException {\r\n    return this.propertyResolver.resolveRequiredPlaceholders(text);\r\n}\n@Override\r\npublic String toString() {\r\n    return getClass().getSimpleName() + \" {activeProfiles=\" + this.activeProfiles + \", defaultProfiles=\" + this.defaultProfiles + \", propertySources=\" + this.propertySources + \"}\";\r\n}",
    "comment": "\n * Abstract base class for {@link Environment} implementations. Supports the notion of\n * reserved default profile names and enables specifying active and default profiles\n * through the {@link #ACTIVE_PROFILES_PROPERTY_NAME} and\n * {@link #DEFAULT_PROFILES_PROPERTY_NAME} properties.\n *\n * <p>Concrete subclasses differ primarily on which {@link PropertySource} objects they\n * add by default. {@code AbstractEnvironment} adds none. Subclasses should contribute\n * property sources through the protected {@link #customizePropertySources(MutablePropertySources)}\n * hook, while clients should customize using {@link ConfigurableEnvironment#getPropertySources()}\n * and working against the {@link MutablePropertySources} API.\n * See {@link ConfigurableEnvironment} javadoc for usage examples.\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @author Phillip Webb\n * @since 3.1\n * @see ConfigurableEnvironment\n * @see StandardEnvironment\n "
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#createPropertyResolver(MutablePropertySources)",
    "entityType": "method",
    "code": "/**\r\n * Factory method used to create the {@link ConfigurablePropertyResolver}\r\n * instance used by the Environment.\r\n * @since 5.3.4\r\n * @see #getPropertyResolver()\r\n */\r\nprotected ConfigurablePropertyResolver createPropertyResolver(MutablePropertySources propertySources) {\r\n    return new PropertySourcesPropertyResolver(propertySources);\r\n}",
    "comment": "\n\t * Factory method used to create the {@link ConfigurablePropertyResolver}\n\t * instance used by the Environment.\n\t * @since 5.3.4\n\t * @see #getPropertyResolver()\n\t "
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#getPropertyResolver()",
    "entityType": "method",
    "code": "/**\r\n * Return the {@link ConfigurablePropertyResolver} being used by the\r\n * {@link Environment}.\r\n * @since 5.3.4\r\n * @see #createPropertyResolver(MutablePropertySources)\r\n */\r\nprotected final ConfigurablePropertyResolver getPropertyResolver() {\r\n    return this.propertyResolver;\r\n}",
    "comment": "\n\t * Return the {@link ConfigurablePropertyResolver} being used by the\n\t * {@link Environment}.\n\t * @since 5.3.4\n\t * @see #createPropertyResolver(MutablePropertySources)\n\t "
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#customizePropertySources(MutablePropertySources)",
    "entityType": "method",
    "code": "/**\r\n * Customize the set of {@link PropertySource} objects to be searched by this\r\n * {@code Environment} during calls to {@link #getProperty(String)} and related\r\n * methods.\r\n *\r\n * <p>Subclasses that override this method are encouraged to add property\r\n * sources using {@link MutablePropertySources#addLast(PropertySource)} such that\r\n * further subclasses may call {@code super.customizePropertySources()} with\r\n * predictable results. For example:\r\n *\r\n * <pre class=\"code\">\r\n * public class Level1Environment extends AbstractEnvironment {\r\n *     &#064;Override\r\n *     protected void customizePropertySources(MutablePropertySources propertySources) {\r\n *         super.customizePropertySources(propertySources); // no-op from base class\r\n *         propertySources.addLast(new PropertySourceA(...));\r\n *         propertySources.addLast(new PropertySourceB(...));\r\n *     }\r\n * }\r\n *\r\n * public class Level2Environment extends Level1Environment {\r\n *     &#064;Override\r\n *     protected void customizePropertySources(MutablePropertySources propertySources) {\r\n *         super.customizePropertySources(propertySources); // add all from superclass\r\n *         propertySources.addLast(new PropertySourceC(...));\r\n *         propertySources.addLast(new PropertySourceD(...));\r\n *     }\r\n * }\r\n * </pre>\r\n *\r\n * <p>In this arrangement, properties will be resolved against sources A, B, C, D in that\r\n * order. That is to say that property source \"A\" has precedence over property source\r\n * \"D\". If the {@code Level2Environment} subclass wished to give property sources C\r\n * and D higher precedence than A and B, it could simply call\r\n * {@code super.customizePropertySources} after, rather than before adding its own:\r\n *\r\n * <pre class=\"code\">\r\n * public class Level2Environment extends Level1Environment {\r\n *     &#064;Override\r\n *     protected void customizePropertySources(MutablePropertySources propertySources) {\r\n *         propertySources.addLast(new PropertySourceC(...));\r\n *         propertySources.addLast(new PropertySourceD(...));\r\n *         super.customizePropertySources(propertySources); // add all from superclass\r\n *     }\r\n * }\r\n * </pre>\r\n *\r\n * <p>The search order is now C, D, A, B as desired.\r\n *\r\n * <p>Beyond these recommendations, subclasses may use any of the {@code add*},\r\n * {@code remove}, or {@code replace} methods exposed by {@link MutablePropertySources}\r\n * in order to create the exact arrangement of property sources desired.\r\n *\r\n * <p>The base implementation registers no property sources.\r\n *\r\n * <p>Note that clients of any {@link ConfigurableEnvironment} may further customize\r\n * property sources via the {@link #getPropertySources()} accessor, typically within\r\n * an {@link org.springframework.context.ApplicationContextInitializer\r\n * ApplicationContextInitializer}. For example:\r\n *\r\n * <pre class=\"code\">\r\n * ConfigurableEnvironment env = new StandardEnvironment();\r\n * env.getPropertySources().addLast(new PropertySourceX(...));\r\n * </pre>\r\n *\r\n * <h2>A warning about instance variable access</h2>\r\n * <p>Instance variables declared in subclasses and having default initial values should\r\n * <em>not</em> be accessed from within this method. Due to Java object creation\r\n * lifecycle constraints, any initial value will not yet be assigned when this\r\n * callback is invoked by the {@link #AbstractEnvironment()} constructor, which may\r\n * lead to a {@code NullPointerException} or other problems. If you need to access\r\n * default values of instance variables, leave this method as a no-op and perform\r\n * property source manipulation and instance variable access directly within the\r\n * subclass constructor. Note that <em>assigning</em> values to instance variables is\r\n * not problematic; it is only attempting to read default values that must be avoided.\r\n * @see MutablePropertySources\r\n * @see PropertySourcesPropertyResolver\r\n * @see org.springframework.context.ApplicationContextInitializer\r\n */\r\nprotected void customizePropertySources(MutablePropertySources propertySources) ;",
    "comment": "\n\t * Customize the set of {@link PropertySource} objects to be searched by this\n\t * {@code Environment} during calls to {@link #getProperty(String)} and related\n\t * methods.\n\t *\n\t * <p>Subclasses that override this method are encouraged to add property\n\t * sources using {@link MutablePropertySources#addLast(PropertySource)} such that\n\t * further subclasses may call {@code super.customizePropertySources()} with\n\t * predictable results. For example:\n\t *\n\t * <pre class=\"code\">\n\t * public class Level1Environment extends AbstractEnvironment {\n\t *     &#064;Override\n\t *     protected void customizePropertySources(MutablePropertySources propertySources) {\n\t *         super.customizePropertySources(propertySources); // no-op from base class\n\t *         propertySources.addLast(new PropertySourceA(...));\n\t *         propertySources.addLast(new PropertySourceB(...));\n\t *     }\n\t * }\n\t *\n\t * public class Level2Environment extends Level1Environment {\n\t *     &#064;Override\n\t *     protected void customizePropertySources(MutablePropertySources propertySources) {\n\t *         super.customizePropertySources(propertySources); // add all from superclass\n\t *         propertySources.addLast(new PropertySourceC(...));\n\t *         propertySources.addLast(new PropertySourceD(...));\n\t *     }\n\t * }\n\t * </pre>\n\t *\n\t * <p>In this arrangement, properties will be resolved against sources A, B, C, D in that\n\t * order. That is to say that property source \"A\" has precedence over property source\n\t * \"D\". If the {@code Level2Environment} subclass wished to give property sources C\n\t * and D higher precedence than A and B, it could simply call\n\t * {@code super.customizePropertySources} after, rather than before adding its own:\n\t *\n\t * <pre class=\"code\">\n\t * public class Level2Environment extends Level1Environment {\n\t *     &#064;Override\n\t *     protected void customizePropertySources(MutablePropertySources propertySources) {\n\t *         propertySources.addLast(new PropertySourceC(...));\n\t *         propertySources.addLast(new PropertySourceD(...));\n\t *         super.customizePropertySources(propertySources); // add all from superclass\n\t *     }\n\t * }\n\t * </pre>\n\t *\n\t * <p>The search order is now C, D, A, B as desired.\n\t *\n\t * <p>Beyond these recommendations, subclasses may use any of the {@code add*},\n\t * {@code remove}, or {@code replace} methods exposed by {@link MutablePropertySources}\n\t * in order to create the exact arrangement of property sources desired.\n\t *\n\t * <p>The base implementation registers no property sources.\n\t *\n\t * <p>Note that clients of any {@link ConfigurableEnvironment} may further customize\n\t * property sources via the {@link #getPropertySources()} accessor, typically within\n\t * an {@link org.springframework.context.ApplicationContextInitializer\n\t * ApplicationContextInitializer}. For example:\n\t *\n\t * <pre class=\"code\">\n\t * ConfigurableEnvironment env = new StandardEnvironment();\n\t * env.getPropertySources().addLast(new PropertySourceX(...));\n\t * </pre>\n\t *\n\t * <h2>A warning about instance variable access</h2>\n\t * <p>Instance variables declared in subclasses and having default initial values should\n\t * <em>not</em> be accessed from within this method. Due to Java object creation\n\t * lifecycle constraints, any initial value will not yet be assigned when this\n\t * callback is invoked by the {@link #AbstractEnvironment()} constructor, which may\n\t * lead to a {@code NullPointerException} or other problems. If you need to access\n\t * default values of instance variables, leave this method as a no-op and perform\n\t * property source manipulation and instance variable access directly within the\n\t * subclass constructor. Note that <em>assigning</em> values to instance variables is\n\t * not problematic; it is only attempting to read default values that must be avoided.\n\t * @see MutablePropertySources\n\t * @see PropertySourcesPropertyResolver\n\t * @see org.springframework.context.ApplicationContextInitializer\n\t "
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#getReservedDefaultProfiles()",
    "entityType": "method",
    "code": "/**\r\n * Return the set of reserved default profile names. This implementation returns\r\n * {@value #RESERVED_DEFAULT_PROFILE_NAME}. Subclasses may override in order to\r\n * customize the set of reserved names.\r\n * @see #RESERVED_DEFAULT_PROFILE_NAME\r\n * @see #doGetDefaultProfiles()\r\n */\r\nprotected Set<String> getReservedDefaultProfiles() {\r\n    return Collections.singleton(RESERVED_DEFAULT_PROFILE_NAME);\r\n}",
    "comment": "\n\t * Return the set of reserved default profile names. This implementation returns\n\t * {@value #RESERVED_DEFAULT_PROFILE_NAME}. Subclasses may override in order to\n\t * customize the set of reserved names.\n\t * @see #RESERVED_DEFAULT_PROFILE_NAME\n\t * @see #doGetDefaultProfiles()\n\t "
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#getActiveProfiles()",
    "entityType": "method",
    "code": "//---------------------------------------------------------------------\r\n// Implementation of ConfigurableEnvironment interface\r\n//---------------------------------------------------------------------\r\n@Override\r\npublic String[] getActiveProfiles() {\r\n    return StringUtils.toStringArray(doGetActiveProfiles());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#doGetActiveProfiles()",
    "entityType": "method",
    "code": "/**\r\n * Return the set of active profiles as explicitly set through\r\n * {@link #setActiveProfiles} or if the current set of active profiles\r\n * is empty, check for the presence of {@link #doGetActiveProfilesProperty()}\r\n * and assign its value to the set of active profiles.\r\n * @see #getActiveProfiles()\r\n * @see #doGetActiveProfilesProperty()\r\n */\r\nprotected Set<String> doGetActiveProfiles() {\r\n    synchronized (this.activeProfiles) {\r\n        if (this.activeProfiles.isEmpty()) {\r\n            String profiles = doGetActiveProfilesProperty();\r\n            if (StringUtils.hasText(profiles)) {\r\n                setActiveProfiles(StringUtils.commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(profiles)));\r\n            }\r\n        }\r\n        return this.activeProfiles;\r\n    }\r\n}",
    "comment": "\n\t * Return the set of active profiles as explicitly set through\n\t * {@link #setActiveProfiles} or if the current set of active profiles\n\t * is empty, check for the presence of {@link #doGetActiveProfilesProperty()}\n\t * and assign its value to the set of active profiles.\n\t * @see #getActiveProfiles()\n\t * @see #doGetActiveProfilesProperty()\n\t "
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#doGetActiveProfilesProperty()",
    "entityType": "method",
    "code": "/**\r\n * Return the property value for the active profiles.\r\n * @since 5.3.4\r\n * @see #ACTIVE_PROFILES_PROPERTY_NAME\r\n */\r\n@Nullable\r\nprotected String doGetActiveProfilesProperty() {\r\n    return getProperty(ACTIVE_PROFILES_PROPERTY_NAME);\r\n}",
    "comment": "\n\t * Return the property value for the active profiles.\n\t * @since 5.3.4\n\t * @see #ACTIVE_PROFILES_PROPERTY_NAME\n\t "
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#setActiveProfiles(String)",
    "entityType": "method",
    "code": "@Override\r\npublic void setActiveProfiles(String... profiles) {\r\n    Assert.notNull(profiles, \"Profile array must not be null\");\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(\"Activating profiles \" + Arrays.toString(profiles));\r\n    }\r\n    synchronized (this.activeProfiles) {\r\n        this.activeProfiles.clear();\r\n        for (String profile : profiles) {\r\n            validateProfile(profile);\r\n            this.activeProfiles.add(profile);\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#addActiveProfile(String)",
    "entityType": "method",
    "code": "@Override\r\npublic void addActiveProfile(String profile) {\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(\"Activating profile '\" + profile + \"'\");\r\n    }\r\n    validateProfile(profile);\r\n    doGetActiveProfiles();\r\n    synchronized (this.activeProfiles) {\r\n        this.activeProfiles.add(profile);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#getDefaultProfiles()",
    "entityType": "method",
    "code": "@Override\r\npublic String[] getDefaultProfiles() {\r\n    return StringUtils.toStringArray(doGetDefaultProfiles());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#doGetDefaultProfiles()",
    "entityType": "method",
    "code": "/**\r\n * Return the set of default profiles explicitly set via\r\n * {@link #setDefaultProfiles(String...)} or if the current set of default profiles\r\n * consists only of {@linkplain #getReservedDefaultProfiles() reserved default\r\n * profiles}, then check for the presence of {@link #doGetActiveProfilesProperty()}\r\n * and assign its value (if any) to the set of default profiles.\r\n * @see #AbstractEnvironment()\r\n * @see #getDefaultProfiles()\r\n * @see #getReservedDefaultProfiles()\r\n * @see #doGetDefaultProfilesProperty()\r\n */\r\nprotected Set<String> doGetDefaultProfiles() {\r\n    synchronized (this.defaultProfiles) {\r\n        if (this.defaultProfiles.equals(getReservedDefaultProfiles())) {\r\n            String profiles = doGetDefaultProfilesProperty();\r\n            if (StringUtils.hasText(profiles)) {\r\n                setDefaultProfiles(StringUtils.commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(profiles)));\r\n            }\r\n        }\r\n        return this.defaultProfiles;\r\n    }\r\n}",
    "comment": "\n\t * Return the set of default profiles explicitly set via\n\t * {@link #setDefaultProfiles(String...)} or if the current set of default profiles\n\t * consists only of {@linkplain #getReservedDefaultProfiles() reserved default\n\t * profiles}, then check for the presence of {@link #doGetActiveProfilesProperty()}\n\t * and assign its value (if any) to the set of default profiles.\n\t * @see #AbstractEnvironment()\n\t * @see #getDefaultProfiles()\n\t * @see #getReservedDefaultProfiles()\n\t * @see #doGetDefaultProfilesProperty()\n\t "
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#doGetDefaultProfilesProperty()",
    "entityType": "method",
    "code": "/**\r\n * Return the property value for the default profiles.\r\n * @since 5.3.4\r\n * @see #DEFAULT_PROFILES_PROPERTY_NAME\r\n */\r\n@Nullable\r\nprotected String doGetDefaultProfilesProperty() {\r\n    return getProperty(DEFAULT_PROFILES_PROPERTY_NAME);\r\n}",
    "comment": "\n\t * Return the property value for the default profiles.\n\t * @since 5.3.4\n\t * @see #DEFAULT_PROFILES_PROPERTY_NAME\n\t "
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#setDefaultProfiles(String)",
    "entityType": "method",
    "code": "/**\r\n * Specify the set of profiles to be made active by default if no other profiles\r\n * are explicitly made active through {@link #setActiveProfiles}.\r\n * <p>Calling this method removes overrides any reserved default profiles\r\n * that may have been added during construction of the environment.\r\n * @see #AbstractEnvironment()\r\n * @see #getReservedDefaultProfiles()\r\n */\r\n@Override\r\npublic void setDefaultProfiles(String... profiles) {\r\n    Assert.notNull(profiles, \"Profile array must not be null\");\r\n    synchronized (this.defaultProfiles) {\r\n        this.defaultProfiles.clear();\r\n        for (String profile : profiles) {\r\n            validateProfile(profile);\r\n            this.defaultProfiles.add(profile);\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Specify the set of profiles to be made active by default if no other profiles\n\t * are explicitly made active through {@link #setActiveProfiles}.\n\t * <p>Calling this method removes overrides any reserved default profiles\n\t * that may have been added during construction of the environment.\n\t * @see #AbstractEnvironment()\n\t * @see #getReservedDefaultProfiles()\n\t "
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#acceptsProfiles(String)",
    "entityType": "method",
    "code": "@Override\r\n@Deprecated\r\npublic boolean acceptsProfiles(String... profiles) {\r\n    Assert.notEmpty(profiles, \"Must specify at least one profile\");\r\n    for (String profile : profiles) {\r\n        if (StringUtils.hasLength(profile) && profile.charAt(0) == '!') {\r\n            if (!isProfileActive(profile.substring(1))) {\r\n                return true;\r\n            }\r\n        } else if (isProfileActive(profile)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#acceptsProfiles(Profiles)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean acceptsProfiles(Profiles profiles) {\r\n    Assert.notNull(profiles, \"Profiles must not be null\");\r\n    return profiles.matches(this::isProfileActive);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#isProfileActive(String)",
    "entityType": "method",
    "code": "/**\r\n * Return whether the given profile is active, or if active profiles are empty\r\n * whether the profile should be active by default.\r\n * @throws IllegalArgumentException per {@link #validateProfile(String)}\r\n */\r\nprotected boolean isProfileActive(String profile) {\r\n    validateProfile(profile);\r\n    Set<String> currentActiveProfiles = doGetActiveProfiles();\r\n    return (currentActiveProfiles.contains(profile) || (currentActiveProfiles.isEmpty() && doGetDefaultProfiles().contains(profile)));\r\n}",
    "comment": "\n\t * Return whether the given profile is active, or if active profiles are empty\n\t * whether the profile should be active by default.\n\t * @throws IllegalArgumentException per {@link #validateProfile(String)}\n\t "
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#validateProfile(String)",
    "entityType": "method",
    "code": "/**\r\n * Validate the given profile, called internally prior to adding to the set of\r\n * active or default profiles.\r\n * <p>Subclasses may override to impose further restrictions on profile syntax.\r\n * @throws IllegalArgumentException if the profile is null, empty, whitespace-only or\r\n * begins with the profile NOT operator (!).\r\n * @see #acceptsProfiles\r\n * @see #addActiveProfile\r\n * @see #setDefaultProfiles\r\n */\r\nprotected void validateProfile(String profile) {\r\n    if (!StringUtils.hasText(profile)) {\r\n        throw new IllegalArgumentException(\"Invalid profile [\" + profile + \"]: must contain text\");\r\n    }\r\n    if (profile.charAt(0) == '!') {\r\n        throw new IllegalArgumentException(\"Invalid profile [\" + profile + \"]: must not begin with ! operator\");\r\n    }\r\n}",
    "comment": "\n\t * Validate the given profile, called internally prior to adding to the set of\n\t * active or default profiles.\n\t * <p>Subclasses may override to impose further restrictions on profile syntax.\n\t * @throws IllegalArgumentException if the profile is null, empty, whitespace-only or\n\t * begins with the profile NOT operator (!).\n\t * @see #acceptsProfiles\n\t * @see #addActiveProfile\n\t * @see #setDefaultProfiles\n\t "
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#getPropertySources()",
    "entityType": "method",
    "code": "@Override\r\npublic MutablePropertySources getPropertySources() {\r\n    return this.propertySources;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#getSystemProperties()",
    "entityType": "method",
    "code": "@Override\r\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\r\npublic Map<String, Object> getSystemProperties() {\r\n    return (Map) System.getProperties();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#getSystemEnvironment()",
    "entityType": "method",
    "code": "@Override\r\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\r\npublic Map<String, Object> getSystemEnvironment() {\r\n    if (suppressGetenvAccess()) {\r\n        return Collections.emptyMap();\r\n    }\r\n    return (Map) System.getenv();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#suppressGetenvAccess()",
    "entityType": "method",
    "code": "/**\r\n * Determine whether to suppress {@link System#getenv()}/{@link System#getenv(String)}\r\n * access for the purposes of {@link #getSystemEnvironment()}.\r\n * <p>If this method returns {@code true}, an empty dummy Map will be used instead\r\n * of the regular system environment Map, never even trying to call {@code getenv}\r\n * and therefore avoiding security manager warnings (if any).\r\n * <p>The default implementation checks for the \"spring.getenv.ignore\" system property,\r\n * returning {@code true} if its value equals \"true\" in any case.\r\n * @see #IGNORE_GETENV_PROPERTY_NAME\r\n * @see SpringProperties#getFlag\r\n */\r\nprotected boolean suppressGetenvAccess() {\r\n    return SpringProperties.getFlag(IGNORE_GETENV_PROPERTY_NAME);\r\n}",
    "comment": "\n\t * Determine whether to suppress {@link System#getenv()}/{@link System#getenv(String)}\n\t * access for the purposes of {@link #getSystemEnvironment()}.\n\t * <p>If this method returns {@code true}, an empty dummy Map will be used instead\n\t * of the regular system environment Map, never even trying to call {@code getenv}\n\t * and therefore avoiding security manager warnings (if any).\n\t * <p>The default implementation checks for the \"spring.getenv.ignore\" system property,\n\t * returning {@code true} if its value equals \"true\" in any case.\n\t * @see #IGNORE_GETENV_PROPERTY_NAME\n\t * @see SpringProperties#getFlag\n\t "
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#merge(ConfigurableEnvironment)",
    "entityType": "method",
    "code": "@Override\r\npublic void merge(ConfigurableEnvironment parent) {\r\n    for (PropertySource<?> ps : parent.getPropertySources()) {\r\n        if (!this.propertySources.contains(ps.getName())) {\r\n            this.propertySources.addLast(ps);\r\n        }\r\n    }\r\n    String[] parentActiveProfiles = parent.getActiveProfiles();\r\n    if (!ObjectUtils.isEmpty(parentActiveProfiles)) {\r\n        synchronized (this.activeProfiles) {\r\n            Collections.addAll(this.activeProfiles, parentActiveProfiles);\r\n        }\r\n    }\r\n    String[] parentDefaultProfiles = parent.getDefaultProfiles();\r\n    if (!ObjectUtils.isEmpty(parentDefaultProfiles)) {\r\n        synchronized (this.defaultProfiles) {\r\n            this.defaultProfiles.remove(RESERVED_DEFAULT_PROFILE_NAME);\r\n            Collections.addAll(this.defaultProfiles, parentDefaultProfiles);\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#getConversionService()",
    "entityType": "method",
    "code": "//---------------------------------------------------------------------\r\n// Implementation of ConfigurablePropertyResolver interface\r\n//---------------------------------------------------------------------\r\n@Override\r\npublic ConfigurableConversionService getConversionService() {\r\n    return this.propertyResolver.getConversionService();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#setConversionService(ConfigurableConversionService)",
    "entityType": "method",
    "code": "@Override\r\npublic void setConversionService(ConfigurableConversionService conversionService) {\r\n    this.propertyResolver.setConversionService(conversionService);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#setPlaceholderPrefix(String)",
    "entityType": "method",
    "code": "@Override\r\npublic void setPlaceholderPrefix(String placeholderPrefix) {\r\n    this.propertyResolver.setPlaceholderPrefix(placeholderPrefix);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#setPlaceholderSuffix(String)",
    "entityType": "method",
    "code": "@Override\r\npublic void setPlaceholderSuffix(String placeholderSuffix) {\r\n    this.propertyResolver.setPlaceholderSuffix(placeholderSuffix);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#setValueSeparator(String)",
    "entityType": "method",
    "code": "@Override\r\npublic void setValueSeparator(@Nullable String valueSeparator) {\r\n    this.propertyResolver.setValueSeparator(valueSeparator);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#setEscapeCharacter(Character)",
    "entityType": "method",
    "code": "@Override\r\npublic void setEscapeCharacter(@Nullable Character escapeCharacter) {\r\n    this.propertyResolver.setEscapeCharacter(escapeCharacter);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#setIgnoreUnresolvableNestedPlaceholders(boolean)",
    "entityType": "method",
    "code": "@Override\r\npublic void setIgnoreUnresolvableNestedPlaceholders(boolean ignoreUnresolvableNestedPlaceholders) {\r\n    this.propertyResolver.setIgnoreUnresolvableNestedPlaceholders(ignoreUnresolvableNestedPlaceholders);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#setRequiredProperties(String)",
    "entityType": "method",
    "code": "@Override\r\npublic void setRequiredProperties(String... requiredProperties) {\r\n    this.propertyResolver.setRequiredProperties(requiredProperties);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#validateRequiredProperties()",
    "entityType": "method",
    "code": "@Override\r\npublic void validateRequiredProperties() throws MissingRequiredPropertiesException {\r\n    this.propertyResolver.validateRequiredProperties();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#containsProperty(String)",
    "entityType": "method",
    "code": "//---------------------------------------------------------------------\r\n// Implementation of PropertyResolver interface\r\n//---------------------------------------------------------------------\r\n@Override\r\npublic boolean containsProperty(String key) {\r\n    return this.propertyResolver.containsProperty(key);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#getProperty(String)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic String getProperty(String key) {\r\n    return this.propertyResolver.getProperty(key);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#getProperty(String,String)",
    "entityType": "method",
    "code": "@Override\r\npublic String getProperty(String key, String defaultValue) {\r\n    return this.propertyResolver.getProperty(key, defaultValue);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#getProperty(String,Class<T>)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic <T> T getProperty(String key, Class<T> targetType) {\r\n    return this.propertyResolver.getProperty(key, targetType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#getProperty(String,Class<T>,T)",
    "entityType": "method",
    "code": "@Override\r\npublic <T> T getProperty(String key, Class<T> targetType, T defaultValue) {\r\n    return this.propertyResolver.getProperty(key, targetType, defaultValue);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#getRequiredProperty(String)",
    "entityType": "method",
    "code": "@Override\r\npublic String getRequiredProperty(String key) throws IllegalStateException {\r\n    return this.propertyResolver.getRequiredProperty(key);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#getRequiredProperty(String,Class<T>)",
    "entityType": "method",
    "code": "@Override\r\npublic <T> T getRequiredProperty(String key, Class<T> targetType) throws IllegalStateException {\r\n    return this.propertyResolver.getRequiredProperty(key, targetType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#resolvePlaceholders(String)",
    "entityType": "method",
    "code": "@Override\r\npublic String resolvePlaceholders(String text) {\r\n    return this.propertyResolver.resolvePlaceholders(text);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#resolveRequiredPlaceholders(String)",
    "entityType": "method",
    "code": "@Override\r\npublic String resolveRequiredPlaceholders(String text) throws IllegalArgumentException {\r\n    return this.propertyResolver.resolveRequiredPlaceholders(text);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractEnvironment#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return getClass().getSimpleName() + \" {activeProfiles=\" + this.activeProfiles + \", defaultProfiles=\" + this.defaultProfiles + \", propertySources=\" + this.propertySources + \"}\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractPropertyResolver",
    "entityType": "class",
    "code": "protected final Log logger = LogFactory.getLog(getClass());\n@Nullable\r\nprivate volatile ConfigurableConversionService conversionService;\n@Nullable\r\nprivate PropertyPlaceholderHelper nonStrictHelper;\n@Nullable\r\nprivate PropertyPlaceholderHelper strictHelper;\nprivate boolean ignoreUnresolvableNestedPlaceholders = false;\nprivate String placeholderPrefix = SystemPropertyUtils.PLACEHOLDER_PREFIX;\nprivate String placeholderSuffix = SystemPropertyUtils.PLACEHOLDER_SUFFIX;\n@Nullable\r\nprivate String valueSeparator = SystemPropertyUtils.VALUE_SEPARATOR;\n@Nullable\r\nprivate Character escapeCharacter = SystemPropertyUtils.ESCAPE_CHARACTER;\nprivate final Set<String> requiredProperties = new LinkedHashSet<>();\n@Override\r\npublic ConfigurableConversionService getConversionService() {\r\n    // Need to provide an independent DefaultConversionService, not the\r\n    // shared DefaultConversionService used by PropertySourcesPropertyResolver.\r\n    ConfigurableConversionService cs = this.conversionService;\r\n    if (cs == null) {\r\n        synchronized (this) {\r\n            cs = this.conversionService;\r\n            if (cs == null) {\r\n                cs = new DefaultConversionService();\r\n                this.conversionService = cs;\r\n            }\r\n        }\r\n    }\r\n    return cs;\r\n}\n@Override\r\npublic void setConversionService(ConfigurableConversionService conversionService) {\r\n    Assert.notNull(conversionService, \"ConversionService must not be null\");\r\n    this.conversionService = conversionService;\r\n}\n/**\r\n * Set the prefix that placeholders replaced by this resolver must begin with.\r\n * <p>The default is \"${\".\r\n * @see org.springframework.util.SystemPropertyUtils#PLACEHOLDER_PREFIX\r\n */\r\n@Override\r\npublic void setPlaceholderPrefix(String placeholderPrefix) {\r\n    Assert.notNull(placeholderPrefix, \"'placeholderPrefix' must not be null\");\r\n    this.placeholderPrefix = placeholderPrefix;\r\n}\n/**\r\n * Set the suffix that placeholders replaced by this resolver must end with.\r\n * <p>The default is \"}\".\r\n * @see org.springframework.util.SystemPropertyUtils#PLACEHOLDER_SUFFIX\r\n */\r\n@Override\r\npublic void setPlaceholderSuffix(String placeholderSuffix) {\r\n    Assert.notNull(placeholderSuffix, \"'placeholderSuffix' must not be null\");\r\n    this.placeholderSuffix = placeholderSuffix;\r\n}\n/**\r\n * Specify the separating character between the placeholders replaced by this\r\n * resolver and their associated default value, or {@code null} if no such\r\n * special character should be processed as a value separator.\r\n * <p>The default is \":\".\r\n * @see org.springframework.util.SystemPropertyUtils#VALUE_SEPARATOR\r\n */\r\n@Override\r\npublic void setValueSeparator(@Nullable String valueSeparator) {\r\n    this.valueSeparator = valueSeparator;\r\n}\n/**\r\n * Specify the escape character to use to ignore placeholder prefix\r\n * or value separator, or {@code null} if no escaping should take\r\n * place.\r\n * <p>The default is \"\\\".\r\n * @since 6.2\r\n * @see org.springframework.util.SystemPropertyUtils#ESCAPE_CHARACTER\r\n */\r\n@Override\r\npublic void setEscapeCharacter(@Nullable Character escapeCharacter) {\r\n    this.escapeCharacter = escapeCharacter;\r\n}\n/**\r\n * Set whether to throw an exception when encountering an unresolvable placeholder\r\n * nested within the value of a given property. A {@code false} value indicates strict\r\n * resolution, i.e. that an exception will be thrown. A {@code true} value indicates\r\n * that unresolvable nested placeholders should be passed through in their unresolved\r\n * ${...} form.\r\n * <p>The default is {@code false}.\r\n * @since 3.2\r\n */\r\n@Override\r\npublic void setIgnoreUnresolvableNestedPlaceholders(boolean ignoreUnresolvableNestedPlaceholders) {\r\n    this.ignoreUnresolvableNestedPlaceholders = ignoreUnresolvableNestedPlaceholders;\r\n}\n@Override\r\npublic void setRequiredProperties(String... requiredProperties) {\r\n    Collections.addAll(this.requiredProperties, requiredProperties);\r\n}\n@Override\r\npublic void validateRequiredProperties() {\r\n    MissingRequiredPropertiesException ex = new MissingRequiredPropertiesException();\r\n    for (String key : this.requiredProperties) {\r\n        if (this.getProperty(key) == null) {\r\n            ex.addMissingRequiredProperty(key);\r\n        }\r\n    }\r\n    if (!ex.getMissingRequiredProperties().isEmpty()) {\r\n        throw ex;\r\n    }\r\n}\n@Override\r\npublic boolean containsProperty(String key) {\r\n    return (getProperty(key) != null);\r\n}\n@Override\r\n@Nullable\r\npublic String getProperty(String key) {\r\n    return getProperty(key, String.class);\r\n}\n@Override\r\npublic String getProperty(String key, String defaultValue) {\r\n    String value = getProperty(key);\r\n    return (value != null ? value : defaultValue);\r\n}\n@Override\r\npublic <T> T getProperty(String key, Class<T> targetType, T defaultValue) {\r\n    T value = getProperty(key, targetType);\r\n    return (value != null ? value : defaultValue);\r\n}\n@Override\r\npublic String getRequiredProperty(String key) throws IllegalStateException {\r\n    String value = getProperty(key);\r\n    if (value == null) {\r\n        throw new IllegalStateException(\"Required key '\" + key + \"' not found\");\r\n    }\r\n    return value;\r\n}\n@Override\r\npublic <T> T getRequiredProperty(String key, Class<T> valueType) throws IllegalStateException {\r\n    T value = getProperty(key, valueType);\r\n    if (value == null) {\r\n        throw new IllegalStateException(\"Required key '\" + key + \"' not found\");\r\n    }\r\n    return value;\r\n}\n@Override\r\npublic String resolvePlaceholders(String text) {\r\n    if (this.nonStrictHelper == null) {\r\n        this.nonStrictHelper = createPlaceholderHelper(true);\r\n    }\r\n    return doResolvePlaceholders(text, this.nonStrictHelper);\r\n}\n@Override\r\npublic String resolveRequiredPlaceholders(String text) throws IllegalArgumentException {\r\n    if (this.strictHelper == null) {\r\n        this.strictHelper = createPlaceholderHelper(false);\r\n    }\r\n    return doResolvePlaceholders(text, this.strictHelper);\r\n}\n/**\r\n * Resolve placeholders within the given string, deferring to the value of\r\n * {@link #setIgnoreUnresolvableNestedPlaceholders} to determine whether any\r\n * unresolvable placeholders should raise an exception or be ignored.\r\n * <p>Invoked from {@link #getProperty} and its variants, implicitly resolving\r\n * nested placeholders. In contrast, {@link #resolvePlaceholders} and\r\n * {@link #resolveRequiredPlaceholders} do <i>not</i> delegate\r\n * to this method but rather perform their own handling of unresolvable\r\n * placeholders, as specified by each of those methods.\r\n * @since 3.2\r\n * @see #setIgnoreUnresolvableNestedPlaceholders\r\n */\r\nprotected String resolveNestedPlaceholders(String value) {\r\n    if (value.isEmpty()) {\r\n        return value;\r\n    }\r\n    return (this.ignoreUnresolvableNestedPlaceholders ? resolvePlaceholders(value) : resolveRequiredPlaceholders(value));\r\n}\nprivate PropertyPlaceholderHelper createPlaceholderHelper(boolean ignoreUnresolvablePlaceholders) {\r\n    return new PropertyPlaceholderHelper(this.placeholderPrefix, this.placeholderSuffix, this.valueSeparator, this.escapeCharacter, ignoreUnresolvablePlaceholders);\r\n}\nprivate String doResolvePlaceholders(String text, PropertyPlaceholderHelper helper) {\r\n    return helper.replacePlaceholders(text, this::getPropertyAsRawString);\r\n}\n/**\r\n * Convert the given value to the specified target type, if necessary.\r\n * @param value the original property value\r\n * @param targetType the specified target type for property retrieval\r\n * @return the converted value, or the original value if no conversion\r\n * is necessary\r\n * @since 4.3.5\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\nprotected <T> T convertValueIfNecessary(Object value, @Nullable Class<T> targetType) {\r\n    if (targetType == null) {\r\n        return (T) value;\r\n    }\r\n    ConversionService conversionServiceToUse = this.conversionService;\r\n    if (conversionServiceToUse == null) {\r\n        // Avoid initialization of shared DefaultConversionService if\r\n        // no standard type conversion is needed in the first place...\r\n        if (ClassUtils.isAssignableValue(targetType, value)) {\r\n            return (T) value;\r\n        }\r\n        conversionServiceToUse = DefaultConversionService.getSharedInstance();\r\n    }\r\n    return conversionServiceToUse.convert(value, targetType);\r\n}\n/**\r\n * Retrieve the specified property as a raw String,\r\n * i.e. without resolution of nested placeholders.\r\n * @param key the property name to resolve\r\n * @return the property value or {@code null} if none found\r\n */\r\n@Nullable\r\nprotected abstract String getPropertyAsRawString(String key);",
    "comment": "\n * Abstract base class for resolving properties against any underlying source.\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @since 3.1\n "
  },
  {
    "entityId": "org.springframework.core.env.AbstractPropertyResolver#getConversionService()",
    "entityType": "method",
    "code": "@Override\r\npublic ConfigurableConversionService getConversionService() {\r\n    // Need to provide an independent DefaultConversionService, not the\r\n    // shared DefaultConversionService used by PropertySourcesPropertyResolver.\r\n    ConfigurableConversionService cs = this.conversionService;\r\n    if (cs == null) {\r\n        synchronized (this) {\r\n            cs = this.conversionService;\r\n            if (cs == null) {\r\n                cs = new DefaultConversionService();\r\n                this.conversionService = cs;\r\n            }\r\n        }\r\n    }\r\n    return cs;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractPropertyResolver#setConversionService(ConfigurableConversionService)",
    "entityType": "method",
    "code": "@Override\r\npublic void setConversionService(ConfigurableConversionService conversionService) {\r\n    Assert.notNull(conversionService, \"ConversionService must not be null\");\r\n    this.conversionService = conversionService;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractPropertyResolver#setPlaceholderPrefix(String)",
    "entityType": "method",
    "code": "/**\r\n * Set the prefix that placeholders replaced by this resolver must begin with.\r\n * <p>The default is \"${\".\r\n * @see org.springframework.util.SystemPropertyUtils#PLACEHOLDER_PREFIX\r\n */\r\n@Override\r\npublic void setPlaceholderPrefix(String placeholderPrefix) {\r\n    Assert.notNull(placeholderPrefix, \"'placeholderPrefix' must not be null\");\r\n    this.placeholderPrefix = placeholderPrefix;\r\n}",
    "comment": "\n\t * Set the prefix that placeholders replaced by this resolver must begin with.\n\t * <p>The default is \"${\".\n\t * @see org.springframework.util.SystemPropertyUtils#PLACEHOLDER_PREFIX\n\t "
  },
  {
    "entityId": "org.springframework.core.env.AbstractPropertyResolver#setPlaceholderSuffix(String)",
    "entityType": "method",
    "code": "/**\r\n * Set the suffix that placeholders replaced by this resolver must end with.\r\n * <p>The default is \"}\".\r\n * @see org.springframework.util.SystemPropertyUtils#PLACEHOLDER_SUFFIX\r\n */\r\n@Override\r\npublic void setPlaceholderSuffix(String placeholderSuffix) {\r\n    Assert.notNull(placeholderSuffix, \"'placeholderSuffix' must not be null\");\r\n    this.placeholderSuffix = placeholderSuffix;\r\n}",
    "comment": "\n\t * Set the suffix that placeholders replaced by this resolver must end with.\n\t * <p>The default is \"}\".\n\t * @see org.springframework.util.SystemPropertyUtils#PLACEHOLDER_SUFFIX\n\t "
  },
  {
    "entityId": "org.springframework.core.env.AbstractPropertyResolver#setValueSeparator(String)",
    "entityType": "method",
    "code": "/**\r\n * Specify the separating character between the placeholders replaced by this\r\n * resolver and their associated default value, or {@code null} if no such\r\n * special character should be processed as a value separator.\r\n * <p>The default is \":\".\r\n * @see org.springframework.util.SystemPropertyUtils#VALUE_SEPARATOR\r\n */\r\n@Override\r\npublic void setValueSeparator(@Nullable String valueSeparator) {\r\n    this.valueSeparator = valueSeparator;\r\n}",
    "comment": "\n\t * Specify the separating character between the placeholders replaced by this\n\t * resolver and their associated default value, or {@code null} if no such\n\t * special character should be processed as a value separator.\n\t * <p>The default is \":\".\n\t * @see org.springframework.util.SystemPropertyUtils#VALUE_SEPARATOR\n\t "
  },
  {
    "entityId": "org.springframework.core.env.AbstractPropertyResolver#setEscapeCharacter(Character)",
    "entityType": "method",
    "code": "/**\r\n * Specify the escape character to use to ignore placeholder prefix\r\n * or value separator, or {@code null} if no escaping should take\r\n * place.\r\n * <p>The default is \"\\\".\r\n * @since 6.2\r\n * @see org.springframework.util.SystemPropertyUtils#ESCAPE_CHARACTER\r\n */\r\n@Override\r\npublic void setEscapeCharacter(@Nullable Character escapeCharacter) {\r\n    this.escapeCharacter = escapeCharacter;\r\n}",
    "comment": "\n\t * Specify the escape character to use to ignore placeholder prefix\n\t * or value separator, or {@code null} if no escaping should take\n\t * place.\n\t * <p>The default is \"\\\".\n\t * @since 6.2\n\t * @see org.springframework.util.SystemPropertyUtils#ESCAPE_CHARACTER\n\t "
  },
  {
    "entityId": "org.springframework.core.env.AbstractPropertyResolver#setIgnoreUnresolvableNestedPlaceholders(boolean)",
    "entityType": "method",
    "code": "/**\r\n * Set whether to throw an exception when encountering an unresolvable placeholder\r\n * nested within the value of a given property. A {@code false} value indicates strict\r\n * resolution, i.e. that an exception will be thrown. A {@code true} value indicates\r\n * that unresolvable nested placeholders should be passed through in their unresolved\r\n * ${...} form.\r\n * <p>The default is {@code false}.\r\n * @since 3.2\r\n */\r\n@Override\r\npublic void setIgnoreUnresolvableNestedPlaceholders(boolean ignoreUnresolvableNestedPlaceholders) {\r\n    this.ignoreUnresolvableNestedPlaceholders = ignoreUnresolvableNestedPlaceholders;\r\n}",
    "comment": "\n\t * Set whether to throw an exception when encountering an unresolvable placeholder\n\t * nested within the value of a given property. A {@code false} value indicates strict\n\t * resolution, i.e. that an exception will be thrown. A {@code true} value indicates\n\t * that unresolvable nested placeholders should be passed through in their unresolved\n\t * ${...} form.\n\t * <p>The default is {@code false}.\n\t * @since 3.2\n\t "
  },
  {
    "entityId": "org.springframework.core.env.AbstractPropertyResolver#setRequiredProperties(String)",
    "entityType": "method",
    "code": "@Override\r\npublic void setRequiredProperties(String... requiredProperties) {\r\n    Collections.addAll(this.requiredProperties, requiredProperties);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractPropertyResolver#validateRequiredProperties()",
    "entityType": "method",
    "code": "@Override\r\npublic void validateRequiredProperties() {\r\n    MissingRequiredPropertiesException ex = new MissingRequiredPropertiesException();\r\n    for (String key : this.requiredProperties) {\r\n        if (this.getProperty(key) == null) {\r\n            ex.addMissingRequiredProperty(key);\r\n        }\r\n    }\r\n    if (!ex.getMissingRequiredProperties().isEmpty()) {\r\n        throw ex;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractPropertyResolver#containsProperty(String)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean containsProperty(String key) {\r\n    return (getProperty(key) != null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractPropertyResolver#getProperty(String)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic String getProperty(String key) {\r\n    return getProperty(key, String.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractPropertyResolver#getProperty(String,String)",
    "entityType": "method",
    "code": "@Override\r\npublic String getProperty(String key, String defaultValue) {\r\n    String value = getProperty(key);\r\n    return (value != null ? value : defaultValue);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractPropertyResolver#getProperty(String,Class<T>,T)",
    "entityType": "method",
    "code": "@Override\r\npublic <T> T getProperty(String key, Class<T> targetType, T defaultValue) {\r\n    T value = getProperty(key, targetType);\r\n    return (value != null ? value : defaultValue);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractPropertyResolver#getRequiredProperty(String)",
    "entityType": "method",
    "code": "@Override\r\npublic String getRequiredProperty(String key) throws IllegalStateException {\r\n    String value = getProperty(key);\r\n    if (value == null) {\r\n        throw new IllegalStateException(\"Required key '\" + key + \"' not found\");\r\n    }\r\n    return value;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractPropertyResolver#getRequiredProperty(String,Class<T>)",
    "entityType": "method",
    "code": "@Override\r\npublic <T> T getRequiredProperty(String key, Class<T> valueType) throws IllegalStateException {\r\n    T value = getProperty(key, valueType);\r\n    if (value == null) {\r\n        throw new IllegalStateException(\"Required key '\" + key + \"' not found\");\r\n    }\r\n    return value;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractPropertyResolver#resolvePlaceholders(String)",
    "entityType": "method",
    "code": "@Override\r\npublic String resolvePlaceholders(String text) {\r\n    if (this.nonStrictHelper == null) {\r\n        this.nonStrictHelper = createPlaceholderHelper(true);\r\n    }\r\n    return doResolvePlaceholders(text, this.nonStrictHelper);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractPropertyResolver#resolveRequiredPlaceholders(String)",
    "entityType": "method",
    "code": "@Override\r\npublic String resolveRequiredPlaceholders(String text) throws IllegalArgumentException {\r\n    if (this.strictHelper == null) {\r\n        this.strictHelper = createPlaceholderHelper(false);\r\n    }\r\n    return doResolvePlaceholders(text, this.strictHelper);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractPropertyResolver#resolveNestedPlaceholders(String)",
    "entityType": "method",
    "code": "/**\r\n * Resolve placeholders within the given string, deferring to the value of\r\n * {@link #setIgnoreUnresolvableNestedPlaceholders} to determine whether any\r\n * unresolvable placeholders should raise an exception or be ignored.\r\n * <p>Invoked from {@link #getProperty} and its variants, implicitly resolving\r\n * nested placeholders. In contrast, {@link #resolvePlaceholders} and\r\n * {@link #resolveRequiredPlaceholders} do <i>not</i> delegate\r\n * to this method but rather perform their own handling of unresolvable\r\n * placeholders, as specified by each of those methods.\r\n * @since 3.2\r\n * @see #setIgnoreUnresolvableNestedPlaceholders\r\n */\r\nprotected String resolveNestedPlaceholders(String value) {\r\n    if (value.isEmpty()) {\r\n        return value;\r\n    }\r\n    return (this.ignoreUnresolvableNestedPlaceholders ? resolvePlaceholders(value) : resolveRequiredPlaceholders(value));\r\n}",
    "comment": "\n\t * Resolve placeholders within the given string, deferring to the value of\n\t * {@link #setIgnoreUnresolvableNestedPlaceholders} to determine whether any\n\t * unresolvable placeholders should raise an exception or be ignored.\n\t * <p>Invoked from {@link #getProperty} and its variants, implicitly resolving\n\t * nested placeholders. In contrast, {@link #resolvePlaceholders} and\n\t * {@link #resolveRequiredPlaceholders} do <i>not</i> delegate\n\t * to this method but rather perform their own handling of unresolvable\n\t * placeholders, as specified by each of those methods.\n\t * @since 3.2\n\t * @see #setIgnoreUnresolvableNestedPlaceholders\n\t "
  },
  {
    "entityId": "org.springframework.core.env.AbstractPropertyResolver#createPlaceholderHelper(boolean)",
    "entityType": "method",
    "code": "private PropertyPlaceholderHelper createPlaceholderHelper(boolean ignoreUnresolvablePlaceholders) {\r\n    return new PropertyPlaceholderHelper(this.placeholderPrefix, this.placeholderSuffix, this.valueSeparator, this.escapeCharacter, ignoreUnresolvablePlaceholders);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractPropertyResolver#doResolvePlaceholders(String,PropertyPlaceholderHelper)",
    "entityType": "method",
    "code": "private String doResolvePlaceholders(String text, PropertyPlaceholderHelper helper) {\r\n    return helper.replacePlaceholders(text, this::getPropertyAsRawString);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.AbstractPropertyResolver#convertValueIfNecessary(Object,Class<T>)",
    "entityType": "method",
    "code": "/**\r\n * Convert the given value to the specified target type, if necessary.\r\n * @param value the original property value\r\n * @param targetType the specified target type for property retrieval\r\n * @return the converted value, or the original value if no conversion\r\n * is necessary\r\n * @since 4.3.5\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\nprotected <T> T convertValueIfNecessary(Object value, @Nullable Class<T> targetType) {\r\n    if (targetType == null) {\r\n        return (T) value;\r\n    }\r\n    ConversionService conversionServiceToUse = this.conversionService;\r\n    if (conversionServiceToUse == null) {\r\n        // Avoid initialization of shared DefaultConversionService if\r\n        // no standard type conversion is needed in the first place...\r\n        if (ClassUtils.isAssignableValue(targetType, value)) {\r\n            return (T) value;\r\n        }\r\n        conversionServiceToUse = DefaultConversionService.getSharedInstance();\r\n    }\r\n    return conversionServiceToUse.convert(value, targetType);\r\n}",
    "comment": "\n\t * Convert the given value to the specified target type, if necessary.\n\t * @param value the original property value\n\t * @param targetType the specified target type for property retrieval\n\t * @return the converted value, or the original value if no conversion\n\t * is necessary\n\t * @since 4.3.5\n\t "
  },
  {
    "entityId": "org.springframework.core.env.AbstractPropertyResolver#getPropertyAsRawString(String)",
    "entityType": "method",
    "code": "/**\r\n * Retrieve the specified property as a raw String,\r\n * i.e. without resolution of nested placeholders.\r\n * @param key the property name to resolve\r\n * @return the property value or {@code null} if none found\r\n */\r\n@Nullable\r\nprotected abstract String getPropertyAsRawString(String key);",
    "comment": "\n\t * Retrieve the specified property as a raw String,\n\t * i.e. without resolution of nested placeholders.\n\t * @param key the property name to resolve\n\t * @return the property value or {@code null} if none found\n\t "
  },
  {
    "entityId": "org.springframework.core.env.CommandLineArgs",
    "entityType": "class",
    "code": "private final Map<String, List<String>> optionArgs = new HashMap<>();\nprivate final List<String> nonOptionArgs = new ArrayList<>();\n/**\r\n * Add an option argument for the given option name, and add the given value to the\r\n * list of values associated with this option (of which there may be zero or more).\r\n * <p>The given value may be {@code null}, indicating that the option was specified\r\n * without an associated value &mdash; for example, \"--foo\" vs. \"--foo=bar\".\r\n */\r\npublic void addOptionArg(String optionName, @Nullable String optionValue) {\r\n    if (!this.optionArgs.containsKey(optionName)) {\r\n        this.optionArgs.put(optionName, new ArrayList<>());\r\n    }\r\n    if (optionValue != null) {\r\n        this.optionArgs.get(optionName).add(optionValue);\r\n    }\r\n}\n/**\r\n * Return the set of the names of all option arguments present on the command line.\r\n */\r\npublic Set<String> getOptionNames() {\r\n    return Collections.unmodifiableSet(this.optionArgs.keySet());\r\n}\n/**\r\n * Return whether the option with the given name was present on the command line.\r\n */\r\npublic boolean containsOption(String optionName) {\r\n    return this.optionArgs.containsKey(optionName);\r\n}\n/**\r\n * Return the list of values associated with the given option.\r\n * <p>{@code null} signifies that the option was not present on the command\r\n * line. An empty list signifies that no values were associated with this option.\r\n */\r\n@Nullable\r\npublic List<String> getOptionValues(String optionName) {\r\n    return this.optionArgs.get(optionName);\r\n}\n/**\r\n * Add the given value to the list of non-option arguments.\r\n */\r\npublic void addNonOptionArg(String value) {\r\n    this.nonOptionArgs.add(value);\r\n}\n/**\r\n * Return the list of non-option arguments specified on the command line.\r\n */\r\npublic List<String> getNonOptionArgs() {\r\n    return Collections.unmodifiableList(this.nonOptionArgs);\r\n}",
    "comment": "\n * A simple representation of command line arguments, broken into\n * {@linkplain #addOptionArg(String, String) option arguments} and\n * {@linkplain #addNonOptionArg(String) non-option arguments}.\n *\n * @author Chris Beams\n * @since 3.1\n * @see SimpleCommandLineArgsParser\n "
  },
  {
    "entityId": "org.springframework.core.env.CommandLineArgs#addOptionArg(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Add an option argument for the given option name, and add the given value to the\r\n * list of values associated with this option (of which there may be zero or more).\r\n * <p>The given value may be {@code null}, indicating that the option was specified\r\n * without an associated value &mdash; for example, \"--foo\" vs. \"--foo=bar\".\r\n */\r\npublic void addOptionArg(String optionName, @Nullable String optionValue) {\r\n    if (!this.optionArgs.containsKey(optionName)) {\r\n        this.optionArgs.put(optionName, new ArrayList<>());\r\n    }\r\n    if (optionValue != null) {\r\n        this.optionArgs.get(optionName).add(optionValue);\r\n    }\r\n}",
    "comment": "\n\t * Add an option argument for the given option name, and add the given value to the\n\t * list of values associated with this option (of which there may be zero or more).\n\t * <p>The given value may be {@code null}, indicating that the option was specified\n\t * without an associated value &mdash; for example, \"--foo\" vs. \"--foo=bar\".\n\t "
  },
  {
    "entityId": "org.springframework.core.env.CommandLineArgs#getOptionNames()",
    "entityType": "method",
    "code": "/**\r\n * Return the set of the names of all option arguments present on the command line.\r\n */\r\npublic Set<String> getOptionNames() {\r\n    return Collections.unmodifiableSet(this.optionArgs.keySet());\r\n}",
    "comment": "\n\t * Return the set of the names of all option arguments present on the command line.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.CommandLineArgs#containsOption(String)",
    "entityType": "method",
    "code": "/**\r\n * Return whether the option with the given name was present on the command line.\r\n */\r\npublic boolean containsOption(String optionName) {\r\n    return this.optionArgs.containsKey(optionName);\r\n}",
    "comment": "\n\t * Return whether the option with the given name was present on the command line.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.CommandLineArgs#getOptionValues(String)",
    "entityType": "method",
    "code": "/**\r\n * Return the list of values associated with the given option.\r\n * <p>{@code null} signifies that the option was not present on the command\r\n * line. An empty list signifies that no values were associated with this option.\r\n */\r\n@Nullable\r\npublic List<String> getOptionValues(String optionName) {\r\n    return this.optionArgs.get(optionName);\r\n}",
    "comment": "\n\t * Return the list of values associated with the given option.\n\t * <p>{@code null} signifies that the option was not present on the command\n\t * line. An empty list signifies that no values were associated with this option.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.CommandLineArgs#addNonOptionArg(String)",
    "entityType": "method",
    "code": "/**\r\n * Add the given value to the list of non-option arguments.\r\n */\r\npublic void addNonOptionArg(String value) {\r\n    this.nonOptionArgs.add(value);\r\n}",
    "comment": "\n\t * Add the given value to the list of non-option arguments.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.CommandLineArgs#getNonOptionArgs()",
    "entityType": "method",
    "code": "/**\r\n * Return the list of non-option arguments specified on the command line.\r\n */\r\npublic List<String> getNonOptionArgs() {\r\n    return Collections.unmodifiableList(this.nonOptionArgs);\r\n}",
    "comment": "\n\t * Return the list of non-option arguments specified on the command line.\n\t "
  },
  {
    "entityId": "org.springframework.core.env.CommandLinePropertySource",
    "entityType": "class",
    "code": "/**\r\n * The default name given to {@link CommandLinePropertySource} instances: {@value}.\r\n */\r\npublic static final String COMMAND_LINE_PROPERTY_SOURCE_NAME = \"commandLineArgs\";\n/**\r\n * The default name of the property representing non-option arguments: {@value}.\r\n */\r\npublic static final String DEFAULT_NON_OPTION_ARGS_PROPERTY_NAME = \"nonOptionArgs\";\nprivate String nonOptionArgsPropertyName = DEFAULT_NON_OPTION_ARGS_PROPERTY_NAME;\n/**\r\n * Create a new {@code CommandLinePropertySource} having the default name\r\n * {@value #COMMAND_LINE_PROPERTY_SOURCE_NAME} and backed by the given source object.\r\n */\r\npublic CommandLinePropertySource(T source) {\r\n    super(COMMAND_LINE_PROPERTY_SOURCE_NAME, source);\r\n}\n/**\r\n * Create a new {@link CommandLinePropertySource} having the given name\r\n * and backed by the given source object.\r\n */\r\npublic CommandLinePropertySource(String name, T source) {\r\n    super(name, source);\r\n}\n/**\r\n * Specify the name of the special \"non-option arguments\" property.\r\n * The default is {@value #DEFAULT_NON_OPTION_ARGS_PROPERTY_NAME}.\r\n */\r\npublic void setNonOptionArgsPropertyName(String nonOptionArgsPropertyName) {\r\n    this.nonOptionArgsPropertyName = nonOptionArgsPropertyName;\r\n}\n/**\r\n * This implementation first checks to see if the name specified is the special\r\n * {@linkplain #setNonOptionArgsPropertyName(String) \"non-option arguments\" property},\r\n * and if so delegates to the abstract {@link #getNonOptionArgs()} method\r\n * checking to see whether it returns an empty collection. Otherwise, delegates to and\r\n * returns the value of the abstract {@link #containsOption(String)} method.\r\n */\r\n@Override\r\npublic final boolean containsProperty(String name) {\r\n    if (this.nonOptionArgsPropertyName.equals(name)) {\r\n        return !getNonOptionArgs().isEmpty();\r\n    }\r\n    return this.containsOption(name);\r\n}\n/**\r\n * This implementation first checks to see if the name specified is the special\r\n * {@linkplain #setNonOptionArgsPropertyName(String) \"non-option arguments\" property},\r\n * and if so delegates to the abstract {@link #getNonOptionArgs()} method. If so\r\n * and the collection of non-option arguments is empty, this method returns\r\n * {@code null}. If not empty, it returns a comma-separated String of all non-option\r\n * arguments. Otherwise, this method delegates to and returns a comma-separated String\r\n * of the results of the abstract {@link #getOptionValues(String)} method or\r\n * {@code null} if there are no such option values.\r\n */\r\n@Override\r\n@Nullable\r\npublic final String getProperty(String name) {\r\n    if (this.nonOptionArgsPropertyName.equals(name)) {\r\n        Collection<String> nonOptionArguments = getNonOptionArgs();\r\n        if (nonOptionArguments.isEmpty()) {\r\n            return null;\r\n        } else {\r\n            return StringUtils.collectionToCommaDelimitedString(nonOptionArguments);\r\n        }\r\n    }\r\n    Collection<String> optionValues = getOptionValues(name);\r\n    if (optionValues == null) {\r\n        return null;\r\n    } else {\r\n        return StringUtils.collectionToCommaDelimitedString(optionValues);\r\n    }\r\n}\n/**\r\n * Return whether the set of option arguments parsed from the command line contains\r\n * an option with the given name.\r\n */\r\nprotected abstract boolean containsOption(String name);\n/**\r\n * Return the collection of values associated with the command line option having the\r\n * given name.\r\n * <ul>\r\n * <li>if the option is present and has no argument (for example: \"--foo\"), return an empty\r\n * collection ({@code []})</li>\r\n * <li>if the option is present and has a single value (for example, \"--foo=bar\"), return a\r\n * collection having one element ({@code [\"bar\"]})</li>\r\n * <li>if the option is present and the underlying command line parsing library\r\n * supports multiple arguments (for example, \"--foo=bar --foo=baz\"), return a collection\r\n * having elements for each value ({@code [\"bar\", \"baz\"]})</li>\r\n * <li>if the option is not present, return {@code null}</li>\r\n * </ul>\r\n */\r\n@Nullable\r\nprotected abstract List<String> getOptionValues(String name);\n/**\r\n * Return the collection of non-option arguments parsed from the command line.\r\n * Never {@code null}.\r\n */\r\nprotected abstract List<String> getNonOptionArgs();",
    "comment": "\n * Abstract base class for {@link PropertySource} implementations backed by command line\n * arguments. The parameterized type {@code T} represents the underlying source of command\n * line options.\n *\n * <h3>Purpose and General Usage</h3>\n *\n * For use in standalone Spring-based applications, i.e. those that are bootstrapped via\n * a traditional {@code main} method accepting a {@code String[]} of arguments from the\n * command line. In many cases, processing command-line arguments directly within the\n * {@code main} method may be sufficient, but in other cases, it may be desirable to\n * inject arguments as values into Spring beans. It is this latter set of cases in which\n * a {@code CommandLinePropertySource} becomes useful. A {@code CommandLinePropertySource}\n * will typically be added to the {@link Environment} of the Spring\n * {@code ApplicationContext}, at which point all command line arguments become available\n * through the {@link Environment#getProperty(String)} family of methods. For example:\n *\n * <pre class=\"code\">\n * public static void main(String[] args) {\n *     CommandLinePropertySource clps = ...;\n *     AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();\n *     ctx.getEnvironment().getPropertySources().addFirst(clps);\n *     ctx.register(AppConfig.class);\n *     ctx.refresh();\n * }</pre>\n *\n * With the bootstrap logic above, the {@code AppConfig} class may {@code @Inject} the\n * Spring {@code Environment} and query it directly for properties:\n *\n * <pre class=\"code\">\n * &#064;Configuration\n * public class AppConfig {\n *\n *     &#064;Inject Environment env;\n *\n *     &#064;Bean\n *     public void DataSource dataSource() {\n *         MyVendorDataSource dataSource = new MyVendorDataSource();\n *         dataSource.setHostname(env.getProperty(\"db.hostname\", \"localhost\"));\n *         dataSource.setUsername(env.getRequiredProperty(\"db.username\"));\n *         dataSource.setPassword(env.getRequiredProperty(\"db.password\"));\n *         // ...\n *         return dataSource;\n *     }\n * }</pre>\n *\n * Because the {@code CommandLinePropertySource} was added to the {@code Environment}'s\n * set of {@link MutablePropertySources} using the {@code #addFirst} method, it has\n * the highest search precedence, meaning that while \"db.hostname\" and other properties\n * may exist in other property sources such as the system environment variables, it will\n * be chosen from the command line property source first. This is a reasonable approach\n * given that arguments specified on the command line are naturally more specific than\n * those specified as environment variables.\n *\n * <p>As an alternative to injecting the {@code Environment}, Spring's {@code @Value}\n * annotation may be used to inject these properties, given that a {@link\n * PropertySourcesPropertyResolver} bean has been registered, either directly or through\n * using the {@code <context:property-placeholder>} element. For example:\n *\n * <pre class=\"code\">\n * &#064;Component\n * public class MyComponent {\n *\n *     &#064;Value(\"my.property:defaultVal\")\n *     private String myProperty;\n *\n *     public void getMyProperty() {\n *         return this.myProperty;\n *     }\n *\n *     // ...\n * }</pre>\n *\n * <h3>Working with option arguments</h3>\n *\n * <p>Individual command line arguments are represented as properties through the usual\n * {@link PropertySource#getProperty(String)} and\n * {@link PropertySource#containsProperty(String)} methods. For example, given the\n * following command line:\n *\n * <pre class=\"code\">--o1=v1 --o2</pre>\n *\n * 'o1' and 'o2' are treated as \"option arguments\", and the following assertions would\n * evaluate true:\n *\n * <pre class=\"code\">\n * CommandLinePropertySource&lt;?&gt; ps = ...\n * assert ps.containsProperty(\"o1\") == true;\n * assert ps.containsProperty(\"o2\") == true;\n * assert ps.containsProperty(\"o3\") == false;\n * assert ps.getProperty(\"o1\").equals(\"v1\");\n * assert ps.getProperty(\"o2\").equals(\"\");\n * assert ps.getProperty(\"o3\") == null;\n * </pre>\n *\n * Note that the 'o2' option has no argument, but {@code getProperty(\"o2\")} resolves to\n * empty string ({@code \"\"}) as opposed to {@code null}, while {@code getProperty(\"o3\")}\n * resolves to {@code null} because it was not specified. This behavior is consistent with\n * the general contract to be followed by all {@code PropertySource} implementations.\n *\n * <p>Note also that while \"--\" was used in the examples above to denote an option\n * argument, this syntax may vary across individual command line argument libraries. For\n * example, a JOpt- or Commons CLI-based implementation may allow for single dash (\"-\")\n * \"short\" option arguments, etc.\n *\n * <h3>Working with non-option arguments</h3>\n *\n * <p>Non-option arguments are also supported through this abstraction. Any arguments\n * supplied without an option-style prefix such as \"-\" or \"--\" are considered \"non-option\n * arguments\" and available through the special {@linkplain\n * #DEFAULT_NON_OPTION_ARGS_PROPERTY_NAME \"nonOptionArgs\"} property.  If multiple\n * non-option arguments are specified, the value of this property will be a\n * comma-delimited string containing all the arguments. This approach ensures a simple\n * and consistent return type (String) for all properties from a {@code\n * CommandLinePropertySource} and at the same time lends itself to conversion when used\n * in conjunction with the Spring {@link Environment} and its built-in {@code\n * ConversionService}. Consider the following example:\n *\n * <pre class=\"code\">--o1=v1 --o2=v2 /path/to/file1 /path/to/file2</pre>\n *\n * In this example, \"o1\" and \"o2\" would be considered \"option arguments\", while the two\n * filesystem paths qualify as \"non-option arguments\".  As such, the following assertions\n * will evaluate true:\n *\n * <pre class=\"code\">\n * CommandLinePropertySource&lt;?&gt; ps = ...\n * assert ps.containsProperty(\"o1\") == true;\n * assert ps.containsProperty(\"o2\") == true;\n * assert ps.containsProperty(\"nonOptionArgs\") == true;\n * assert ps.getProperty(\"o1\").equals(\"v1\");\n * assert ps.getProperty(\"o2\").equals(\"v2\");\n * assert ps.getProperty(\"nonOptionArgs\").equals(\"/path/to/file1,/path/to/file2\");\n * </pre>\n *\n * <p>As mentioned above, when used in conjunction with the Spring {@code Environment}\n * abstraction, this comma-delimited string may easily be converted to a String array or\n * list:\n *\n * <pre class=\"code\">\n * Environment env = applicationContext.getEnvironment();\n * String[] nonOptionArgs = env.getProperty(\"nonOptionArgs\", String[].class);\n * assert nonOptionArgs[0].equals(\"/path/to/file1\");\n * assert nonOptionArgs[1].equals(\"/path/to/file2\");\n * </pre>\n *\n * <p>The name of the special \"non-option arguments\" property may be customized through\n * the {@link #setNonOptionArgsPropertyName(String)} method. Doing so is recommended as\n * it gives proper semantic value to non-option arguments. For example, if filesystem\n * paths are being specified as non-option arguments, it is likely preferable to refer to\n * these as something like \"file.locations\" than the default of \"nonOptionArgs\":\n *\n * <pre class=\"code\">\n * public static void main(String[] args) {\n *     CommandLinePropertySource clps = ...;\n *     clps.setNonOptionArgsPropertyName(\"file.locations\");\n *\n *     AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();\n *     ctx.getEnvironment().getPropertySources().addFirst(clps);\n *     ctx.register(AppConfig.class);\n *     ctx.refresh();\n * }</pre>\n *\n * <h3>Limitations</h3>\n *\n * This abstraction is not intended to expose the full power of underlying command line\n * parsing APIs such as JOpt or Commons CLI. Its intent is rather just the opposite: to\n * provide the simplest possible abstraction for accessing command line arguments\n * <em>after</em> they have been parsed. So the typical case will involve fully configuring\n * the underlying command line parsing API, parsing the {@code String[]} of arguments\n * coming into the main method, and then simply providing the parsing results to an\n * implementation of {@code CommandLinePropertySource}. At that point, all arguments can\n * be considered either 'option' or 'non-option' arguments and as described above can be\n * accessed through the normal {@code PropertySource} and {@code Environment} APIs.\n *\n * @author Chris Beams\n * @since 3.1\n * @param <T> the source type\n * @see PropertySource\n * @see SimpleCommandLinePropertySource\n "
  }
]