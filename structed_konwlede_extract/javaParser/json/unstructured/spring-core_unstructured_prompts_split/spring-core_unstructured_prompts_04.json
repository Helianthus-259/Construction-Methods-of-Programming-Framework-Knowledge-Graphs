[
  {
    "entityId": "org.springframework.core.testfixture.TestGroupParsingTests#parseMissing()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseMissing() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> TestGroup.parse(\"long_running, missing\")).withMessageContaining(\"Unable to find test group 'missing' when parsing \" + \"testGroups value: 'long_running, missing'. Available groups include: \" + \"[LONG_RUNNING]\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.TestGroupParsingTests#parseAll()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseAll() {\r\n    assertThat(TestGroup.parse(\"all\")).isEqualTo(EnumSet.allOf(TestGroup.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.TestGroupParsingTests#parseAllExceptLongRunning()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseAllExceptLongRunning() {\r\n    Set<TestGroup> expected = EnumSet.allOf(TestGroup.class);\r\n    expected.remove(TestGroup.LONG_RUNNING);\r\n    assertThat(TestGroup.parse(\"all-long_running\")).isEqualTo(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.TestGroupParsingTests#parseAllExceptMissing()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseAllExceptMissing() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> TestGroup.parse(\"all-missing\")).withMessageContaining(\"Unable to find test group 'missing' when parsing \" + \"testGroups value: 'all-missing'. Available groups include: \" + \"[LONG_RUNNING]\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.DefaultGenerationContext",
    "entityType": "class",
    "code": "private final Map<String, AtomicInteger> sequenceGenerator;\nprivate final GeneratedClasses generatedClasses;\nprivate final GeneratedFiles generatedFiles;\nprivate final RuntimeHints runtimeHints;\n/**\r\n * Create a new {@link DefaultGenerationContext} instance backed by the\r\n * specified {@link ClassNameGenerator} and {@link GeneratedFiles}.\r\n * @param classNameGenerator the naming convention to use for generated\r\n * class names\r\n * @param generatedFiles the generated files\r\n */\r\npublic DefaultGenerationContext(ClassNameGenerator classNameGenerator, GeneratedFiles generatedFiles) {\r\n    this(classNameGenerator, generatedFiles, new RuntimeHints());\r\n}\n/**\r\n * Create a new {@link DefaultGenerationContext} instance backed by the\r\n * specified {@link ClassNameGenerator}, {@link GeneratedFiles}, and\r\n * {@link RuntimeHints}.\r\n * @param classNameGenerator the naming convention to use for generated\r\n * class names\r\n * @param generatedFiles the generated files\r\n * @param runtimeHints the runtime hints\r\n */\r\npublic DefaultGenerationContext(ClassNameGenerator classNameGenerator, GeneratedFiles generatedFiles, RuntimeHints runtimeHints) {\r\n    this(new GeneratedClasses(classNameGenerator), generatedFiles, runtimeHints);\r\n}\n/**\r\n * Create a new {@link DefaultGenerationContext} instance backed by the\r\n * specified items.\r\n * @param generatedClasses the generated classes\r\n * @param generatedFiles the generated files\r\n * @param runtimeHints the runtime hints\r\n */\r\nDefaultGenerationContext(GeneratedClasses generatedClasses, GeneratedFiles generatedFiles, RuntimeHints runtimeHints) {\r\n    Assert.notNull(generatedClasses, \"'generatedClasses' must not be null\");\r\n    Assert.notNull(generatedFiles, \"'generatedFiles' must not be null\");\r\n    Assert.notNull(runtimeHints, \"'runtimeHints' must not be null\");\r\n    this.sequenceGenerator = new ConcurrentHashMap<>();\r\n    this.generatedClasses = generatedClasses;\r\n    this.generatedFiles = generatedFiles;\r\n    this.runtimeHints = runtimeHints;\r\n}\n/**\r\n * Create a new {@link DefaultGenerationContext} instance based on the\r\n * supplied {@code existing} context and feature name.\r\n * @param existing the existing context upon which to base the new one\r\n * @param featureName the feature name to use\r\n * @since 6.0.12\r\n */\r\nprotected DefaultGenerationContext(DefaultGenerationContext existing, String featureName) {\r\n    int sequence = existing.sequenceGenerator.computeIfAbsent(featureName, key -> new AtomicInteger()).getAndIncrement();\r\n    if (sequence > 0) {\r\n        featureName += sequence;\r\n    }\r\n    this.sequenceGenerator = existing.sequenceGenerator;\r\n    this.generatedClasses = existing.generatedClasses.withFeatureNamePrefix(featureName);\r\n    this.generatedFiles = existing.generatedFiles;\r\n    this.runtimeHints = existing.runtimeHints;\r\n}\n@Override\r\npublic GeneratedClasses getGeneratedClasses() {\r\n    return this.generatedClasses;\r\n}\n@Override\r\npublic GeneratedFiles getGeneratedFiles() {\r\n    return this.generatedFiles;\r\n}\n@Override\r\npublic RuntimeHints getRuntimeHints() {\r\n    return this.runtimeHints;\r\n}\n@Override\r\npublic DefaultGenerationContext withName(String name) {\r\n    return new DefaultGenerationContext(this, name);\r\n}\n/**\r\n * Write any generated content out to the generated files.\r\n */\r\npublic void writeGeneratedContent() {\r\n    this.generatedClasses.writeTo(this.generatedFiles);\r\n}",
    "comment": "\n * Default {@link GenerationContext} implementation.\n *\n * <p>Generated classes can be flushed out using {@link #writeGeneratedContent()}\n * which should be called only once after the generation process using this instance\n * has completed.\n *\n * @author Phillip Webb\n * @author Stephane Nicoll\n * @author Sam Brannen\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.generate.DefaultGenerationContext#getGeneratedClasses()",
    "entityType": "method",
    "code": "@Override\r\npublic GeneratedClasses getGeneratedClasses() {\r\n    return this.generatedClasses;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.DefaultGenerationContext#getGeneratedFiles()",
    "entityType": "method",
    "code": "@Override\r\npublic GeneratedFiles getGeneratedFiles() {\r\n    return this.generatedFiles;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.DefaultGenerationContext#getRuntimeHints()",
    "entityType": "method",
    "code": "@Override\r\npublic RuntimeHints getRuntimeHints() {\r\n    return this.runtimeHints;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.DefaultGenerationContext#withName(String)",
    "entityType": "method",
    "code": "@Override\r\npublic DefaultGenerationContext withName(String name) {\r\n    return new DefaultGenerationContext(this, name);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.DefaultGenerationContext#writeGeneratedContent()",
    "entityType": "method",
    "code": "/**\r\n * Write any generated content out to the generated files.\r\n */\r\npublic void writeGeneratedContent() {\r\n    this.generatedClasses.writeTo(this.generatedFiles);\r\n}",
    "comment": "\n\t * Write any generated content out to the generated files.\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.TestGroupTests",
    "entityType": "class",
    "code": "private static final String TEST_GROUPS_SYSTEM_PROPERTY = \"testGroups\";\nprivate String originalTestGroups;\n@BeforeEach\r\nvoid trackOriginalTestGroups() {\r\n    this.originalTestGroups = System.getProperty(TEST_GROUPS_SYSTEM_PROPERTY);\r\n}\n@AfterEach\r\nvoid restoreOriginalTestGroups() {\r\n    setTestGroups(Objects.requireNonNullElse(this.originalTestGroups, \"\"));\r\n}\n@Test\r\nvoid assumeGroupWithNoActiveTestGroups() {\r\n    setTestGroups(\"\");\r\n    assertThatExceptionOfType(TestAbortedException.class).isThrownBy(() -> assumeGroup(LONG_RUNNING));\r\n}\n@Test\r\nvoid assumeGroupWithMatchingActiveTestGroup() {\r\n    setTestGroups(LONG_RUNNING);\r\n    assertThatCode(() -> assumeGroup(LONG_RUNNING)).as(\"assumption should NOT have failed\").doesNotThrowAnyException();\r\n}\n@Test\r\nvoid assumeGroupWithBogusActiveTestGroup() {\r\n    assertBogusActiveTestGroupBehavior(\"bogus\");\r\n}\n@Test\r\nvoid assumeGroupWithAllMinusBogusActiveTestGroup() {\r\n    assertBogusActiveTestGroupBehavior(\"all-bogus\");\r\n}\nprivate void assertBogusActiveTestGroupBehavior(String testGroups) {\r\n    // Should result in something similar to the following:\r\n    //\r\n    // java.lang.IllegalStateException: Failed to parse 'testGroups' system property:\r\n    // Unable to find test group 'bogus' when parsing testGroups value: 'all-bogus'.\r\n    // Available groups include: [LONG_RUNNING,PERFORMANCE]\r\n    setTestGroups(testGroups);\r\n    assertThatIllegalStateException().isThrownBy(() -> assumeGroup(LONG_RUNNING)).withMessageStartingWith(\"Failed to parse '\" + TEST_GROUPS_SYSTEM_PROPERTY + \"' system property: \").havingCause().isInstanceOf(IllegalArgumentException.class).withMessage(\"Unable to find test group 'bogus' when parsing testGroups value: '\" + testGroups + \"'. Available groups include: [LONG_RUNNING]\");\r\n}\nprivate void setTestGroups(TestGroup... testGroups) {\r\n    setTestGroups(Arrays.stream(testGroups).map(TestGroup::name).collect(joining(\", \")));\r\n}\nprivate void setTestGroups(String testGroups) {\r\n    System.setProperty(TEST_GROUPS_SYSTEM_PROPERTY, testGroups);\r\n}\n/**\r\n * Assume that a particular {@link TestGroup} is active.\r\n * @param group the group that must be active\r\n * @throws org.opentest4j.TestAbortedException if the assumption fails\r\n */\r\nprivate static void assumeGroup(TestGroup group) {\r\n    Set<TestGroup> testGroups = TestGroup.loadTestGroups();\r\n    assumeTrue(testGroups.contains(group), () -> \"Requires inactive test group \" + group + \"; active test groups: \" + testGroups);\r\n}",
    "comment": "\n * Tests for {@link TestGroup}.\n *\n * @author Sam Brannen\n * @since 5.0\n "
  },
  {
    "entityId": "org.springframework.core.testfixture.TestGroupTests#trackOriginalTestGroups()",
    "entityType": "method",
    "code": "@BeforeEach\r\nvoid trackOriginalTestGroups() {\r\n    this.originalTestGroups = System.getProperty(TEST_GROUPS_SYSTEM_PROPERTY);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.TestGroupTests#restoreOriginalTestGroups()",
    "entityType": "method",
    "code": "@AfterEach\r\nvoid restoreOriginalTestGroups() {\r\n    setTestGroups(Objects.requireNonNullElse(this.originalTestGroups, \"\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.TestGroupTests#assumeGroupWithNoActiveTestGroups()",
    "entityType": "method",
    "code": "@Test\r\nvoid assumeGroupWithNoActiveTestGroups() {\r\n    setTestGroups(\"\");\r\n    assertThatExceptionOfType(TestAbortedException.class).isThrownBy(() -> assumeGroup(LONG_RUNNING));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.TestGroupTests#assumeGroupWithMatchingActiveTestGroup()",
    "entityType": "method",
    "code": "@Test\r\nvoid assumeGroupWithMatchingActiveTestGroup() {\r\n    setTestGroups(LONG_RUNNING);\r\n    assertThatCode(() -> assumeGroup(LONG_RUNNING)).as(\"assumption should NOT have failed\").doesNotThrowAnyException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.TestGroupTests#assumeGroupWithBogusActiveTestGroup()",
    "entityType": "method",
    "code": "@Test\r\nvoid assumeGroupWithBogusActiveTestGroup() {\r\n    assertBogusActiveTestGroupBehavior(\"bogus\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.TestGroupTests#assumeGroupWithAllMinusBogusActiveTestGroup()",
    "entityType": "method",
    "code": "@Test\r\nvoid assumeGroupWithAllMinusBogusActiveTestGroup() {\r\n    assertBogusActiveTestGroupBehavior(\"all-bogus\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.TestGroupTests#assertBogusActiveTestGroupBehavior(String)",
    "entityType": "method",
    "code": "private void assertBogusActiveTestGroupBehavior(String testGroups) {\r\n    // Should result in something similar to the following:\r\n    //\r\n    // java.lang.IllegalStateException: Failed to parse 'testGroups' system property:\r\n    // Unable to find test group 'bogus' when parsing testGroups value: 'all-bogus'.\r\n    // Available groups include: [LONG_RUNNING,PERFORMANCE]\r\n    setTestGroups(testGroups);\r\n    assertThatIllegalStateException().isThrownBy(() -> assumeGroup(LONG_RUNNING)).withMessageStartingWith(\"Failed to parse '\" + TEST_GROUPS_SYSTEM_PROPERTY + \"' system property: \").havingCause().isInstanceOf(IllegalArgumentException.class).withMessage(\"Unable to find test group 'bogus' when parsing testGroups value: '\" + testGroups + \"'. Available groups include: [LONG_RUNNING]\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.TestGroupTests#setTestGroups(TestGroup)",
    "entityType": "method",
    "code": "private void setTestGroups(TestGroup... testGroups) {\r\n    setTestGroups(Arrays.stream(testGroups).map(TestGroup::name).collect(joining(\", \")));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.TestGroupTests#setTestGroups(String)",
    "entityType": "method",
    "code": "private void setTestGroups(String testGroups) {\r\n    System.setProperty(TEST_GROUPS_SYSTEM_PROPERTY, testGroups);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.TestGroupTests#assumeGroup(TestGroup)",
    "entityType": "method",
    "code": "/**\r\n * Assume that a particular {@link TestGroup} is active.\r\n * @param group the group that must be active\r\n * @throws org.opentest4j.TestAbortedException if the assumption fails\r\n */\r\nprivate static void assumeGroup(TestGroup group) {\r\n    Set<TestGroup> testGroups = TestGroup.loadTestGroups();\r\n    assumeTrue(testGroups.contains(group), () -> \"Requires inactive test group \" + group + \"; active test groups: \" + testGroups);\r\n}",
    "comment": "\n\t * Assume that a particular {@link TestGroup} is active.\n\t * @param group the group that must be active\n\t * @throws org.opentest4j.TestAbortedException if the assumption fails\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.DefaultMethodReference",
    "entityType": "class",
    "code": "private final MethodSpec method;\n@Nullable\r\nprivate final ClassName declaringClass;\npublic DefaultMethodReference(MethodSpec method, @Nullable ClassName declaringClass) {\r\n    this.method = method;\r\n    this.declaringClass = declaringClass;\r\n}\n@Override\r\npublic CodeBlock toCodeBlock() {\r\n    String methodName = this.method.name;\r\n    if (isStatic()) {\r\n        Assert.state(this.declaringClass != null, \"Static method reference must define a declaring class\");\r\n        return CodeBlock.of(\"$T::$L\", this.declaringClass, methodName);\r\n    } else {\r\n        return CodeBlock.of(\"this::$L\", methodName);\r\n    }\r\n}\n@Override\r\npublic CodeBlock toInvokeCodeBlock(ArgumentCodeGenerator argumentCodeGenerator, @Nullable ClassName targetClassName) {\r\n    String methodName = this.method.name;\r\n    CodeBlock.Builder code = CodeBlock.builder();\r\n    if (isStatic()) {\r\n        Assert.state(this.declaringClass != null, \"Static method reference must define a declaring class\");\r\n        if (this.declaringClass.equals(targetClassName)) {\r\n            code.add(\"$L\", methodName);\r\n        } else {\r\n            code.add(\"$T.$L\", this.declaringClass, methodName);\r\n        }\r\n    } else {\r\n        if (this.declaringClass != null && !this.declaringClass.equals(targetClassName)) {\r\n            code.add(instantiateDeclaringClass(this.declaringClass));\r\n        }\r\n        code.add(\"$L\", methodName);\r\n    }\r\n    code.add(\"(\");\r\n    addArguments(code, argumentCodeGenerator);\r\n    code.add(\")\");\r\n    return code.build();\r\n}\n/**\r\n * Add the code for the method arguments using the specified\r\n * {@link ArgumentCodeGenerator} if necessary.\r\n * @param code the code builder to use to add method arguments\r\n * @param argumentCodeGenerator the code generator to use\r\n */\r\nprotected void addArguments(CodeBlock.Builder code, ArgumentCodeGenerator argumentCodeGenerator) {\r\n    List<CodeBlock> arguments = new ArrayList<>();\r\n    TypeName[] argumentTypes = this.method.parameters.stream().map(parameter -> parameter.type).toArray(TypeName[]::new);\r\n    for (int i = 0; i < argumentTypes.length; i++) {\r\n        TypeName argumentType = argumentTypes[i];\r\n        CodeBlock argumentCode = argumentCodeGenerator.generateCode(argumentType);\r\n        if (argumentCode == null) {\r\n            throw new IllegalArgumentException(\"Could not generate code for \" + this + \": parameter \" + i + \" of type \" + argumentType + \" is not supported\");\r\n        }\r\n        arguments.add(argumentCode);\r\n    }\r\n    code.add(CodeBlock.join(arguments, \", \"));\r\n}\nprotected CodeBlock instantiateDeclaringClass(ClassName declaringClass) {\r\n    return CodeBlock.of(\"new $T().\", declaringClass);\r\n}\nprivate boolean isStatic() {\r\n    return this.method.modifiers.contains(Modifier.STATIC);\r\n}\n@Override\r\npublic String toString() {\r\n    String methodName = this.method.name;\r\n    if (isStatic()) {\r\n        return this.declaringClass + \"::\" + methodName;\r\n    } else {\r\n        return (this.declaringClass != null ? \"<\" + this.declaringClass + \">\" : \"<instance>\") + \"::\" + methodName;\r\n    }\r\n}",
    "comment": "\n * Default {@link MethodReference} implementation based on a {@link MethodSpec}.\n *\n * @author Stephane Nicoll\n * @author Phillip Webb\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.generate.DefaultMethodReference#toCodeBlock()",
    "entityType": "method",
    "code": "@Override\r\npublic CodeBlock toCodeBlock() {\r\n    String methodName = this.method.name;\r\n    if (isStatic()) {\r\n        Assert.state(this.declaringClass != null, \"Static method reference must define a declaring class\");\r\n        return CodeBlock.of(\"$T::$L\", this.declaringClass, methodName);\r\n    } else {\r\n        return CodeBlock.of(\"this::$L\", methodName);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.DefaultMethodReference#toInvokeCodeBlock(ArgumentCodeGenerator,ClassName)",
    "entityType": "method",
    "code": "@Override\r\npublic CodeBlock toInvokeCodeBlock(ArgumentCodeGenerator argumentCodeGenerator, @Nullable ClassName targetClassName) {\r\n    String methodName = this.method.name;\r\n    CodeBlock.Builder code = CodeBlock.builder();\r\n    if (isStatic()) {\r\n        Assert.state(this.declaringClass != null, \"Static method reference must define a declaring class\");\r\n        if (this.declaringClass.equals(targetClassName)) {\r\n            code.add(\"$L\", methodName);\r\n        } else {\r\n            code.add(\"$T.$L\", this.declaringClass, methodName);\r\n        }\r\n    } else {\r\n        if (this.declaringClass != null && !this.declaringClass.equals(targetClassName)) {\r\n            code.add(instantiateDeclaringClass(this.declaringClass));\r\n        }\r\n        code.add(\"$L\", methodName);\r\n    }\r\n    code.add(\"(\");\r\n    addArguments(code, argumentCodeGenerator);\r\n    code.add(\")\");\r\n    return code.build();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.DefaultMethodReference#addArguments(CodeBlock.Builder,ArgumentCodeGenerator)",
    "entityType": "method",
    "code": "/**\r\n * Add the code for the method arguments using the specified\r\n * {@link ArgumentCodeGenerator} if necessary.\r\n * @param code the code builder to use to add method arguments\r\n * @param argumentCodeGenerator the code generator to use\r\n */\r\nprotected void addArguments(CodeBlock.Builder code, ArgumentCodeGenerator argumentCodeGenerator) {\r\n    List<CodeBlock> arguments = new ArrayList<>();\r\n    TypeName[] argumentTypes = this.method.parameters.stream().map(parameter -> parameter.type).toArray(TypeName[]::new);\r\n    for (int i = 0; i < argumentTypes.length; i++) {\r\n        TypeName argumentType = argumentTypes[i];\r\n        CodeBlock argumentCode = argumentCodeGenerator.generateCode(argumentType);\r\n        if (argumentCode == null) {\r\n            throw new IllegalArgumentException(\"Could not generate code for \" + this + \": parameter \" + i + \" of type \" + argumentType + \" is not supported\");\r\n        }\r\n        arguments.add(argumentCode);\r\n    }\r\n    code.add(CodeBlock.join(arguments, \", \"));\r\n}",
    "comment": "\n\t * Add the code for the method arguments using the specified\n\t * {@link ArgumentCodeGenerator} if necessary.\n\t * @param code the code builder to use to add method arguments\n\t * @param argumentCodeGenerator the code generator to use\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.DefaultMethodReference#instantiateDeclaringClass(ClassName)",
    "entityType": "method",
    "code": "protected CodeBlock instantiateDeclaringClass(ClassName declaringClass) {\r\n    return CodeBlock.of(\"new $T().\", declaringClass);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.DefaultMethodReference#isStatic()",
    "entityType": "method",
    "code": "private boolean isStatic() {\r\n    return this.method.modifiers.contains(Modifier.STATIC);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.DefaultMethodReference#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    String methodName = this.method.name;\r\n    if (isStatic()) {\r\n        return this.declaringClass + \"::\" + methodName;\r\n    } else {\r\n        return (this.declaringClass != null ? \"<\" + this.declaringClass + \">\" : \"<instance>\") + \"::\" + methodName;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests",
    "entityType": "class",
    "code": "@Test\r\nvoid verifyEquals() {\r\n    AnnotationMetadata testClass1 = get(TestClass.class);\r\n    AnnotationMetadata testClass2 = get(TestClass.class);\r\n    AnnotationMetadata testMemberClass1 = get(TestMemberClass.class);\r\n    AnnotationMetadata testMemberClass2 = get(TestMemberClass.class);\r\n    assertThat(testClass1).isNotEqualTo(null);\r\n    assertThat(testClass1).isEqualTo(testClass1);\r\n    assertThat(testClass2).isEqualTo(testClass2);\r\n    assertThat(testClass1).isEqualTo(testClass2);\r\n    assertThat(testClass2).isEqualTo(testClass1);\r\n    assertThat(testMemberClass1).isEqualTo(testMemberClass1);\r\n    assertThat(testMemberClass2).isEqualTo(testMemberClass2);\r\n    assertThat(testMemberClass1).isEqualTo(testMemberClass2);\r\n    assertThat(testMemberClass2).isEqualTo(testMemberClass1);\r\n    assertThat(testClass1).isNotEqualTo(testMemberClass1);\r\n    assertThat(testMemberClass1).isNotEqualTo(testClass1);\r\n}\n@Test\r\nvoid verifyHashCode() {\r\n    AnnotationMetadata testClass1 = get(TestClass.class);\r\n    AnnotationMetadata testClass2 = get(TestClass.class);\r\n    AnnotationMetadata testMemberClass1 = get(TestMemberClass.class);\r\n    AnnotationMetadata testMemberClass2 = get(TestMemberClass.class);\r\n    assertThat(testClass1).hasSameHashCodeAs(testClass2);\r\n    assertThat(testMemberClass1).hasSameHashCodeAs(testMemberClass2);\r\n    assertThat(testClass1).doesNotHaveSameHashCodeAs(testMemberClass1);\r\n}\n@Test\r\nvoid verifyToString() {\r\n    assertThat(get(TestClass.class).toString()).isEqualTo(TestClass.class.getName());\r\n}\n@Test\r\nvoid getClassNameReturnsClassName() {\r\n    assertThat(get(TestClass.class).getClassName()).isEqualTo(TestClass.class.getName());\r\n}\n@Test\r\nvoid isInterfaceWhenInterfaceReturnsTrue() {\r\n    assertThat(get(TestInterface.class).isInterface()).isTrue();\r\n    assertThat(get(TestAnnotation.class).isInterface()).isTrue();\r\n}\n@Test\r\nvoid isInterfaceWhenNotInterfaceReturnsFalse() {\r\n    assertThat(get(TestClass.class).isInterface()).isFalse();\r\n}\n@Test\r\nvoid isAnnotationWhenAnnotationReturnsTrue() {\r\n    assertThat(get(TestAnnotation.class).isAnnotation()).isTrue();\r\n}\n@Test\r\nvoid isAnnotationWhenNotAnnotationReturnsFalse() {\r\n    assertThat(get(TestClass.class).isAnnotation()).isFalse();\r\n    assertThat(get(TestInterface.class).isAnnotation()).isFalse();\r\n}\n@Test\r\nvoid isFinalWhenFinalReturnsTrue() {\r\n    assertThat(get(TestFinalClass.class).isFinal()).isTrue();\r\n}\n@Test\r\nvoid isFinalWhenNonFinalReturnsFalse() {\r\n    assertThat(get(TestClass.class).isFinal()).isFalse();\r\n}\n@Test\r\nvoid isIndependentWhenIndependentReturnsTrue() {\r\n    assertThat(get(AbstractAnnotationMetadataTests.class).isIndependent()).isTrue();\r\n    assertThat(get(TestClass.class).isIndependent()).isTrue();\r\n}\n@Test\r\nvoid isIndependentWhenNotIndependentReturnsFalse() {\r\n    assertThat(get(TestNonStaticInnerClass.class).isIndependent()).isFalse();\r\n}\n@Test\r\nvoid getEnclosingClassNameWhenHasEnclosingClassReturnsEnclosingClass() {\r\n    assertThat(get(TestClass.class).getEnclosingClassName()).isEqualTo(AbstractAnnotationMetadataTests.class.getName());\r\n}\n@Test\r\nvoid getEnclosingClassNameWhenHasNoEnclosingClassReturnsNull() {\r\n    assertThat(get(AbstractAnnotationMetadataTests.class).getEnclosingClassName()).isNull();\r\n}\n@Test\r\nvoid getSuperClassNameWhenHasSuperClassReturnsName() {\r\n    assertThat(get(TestSubclass.class).getSuperClassName()).isEqualTo(TestClass.class.getName());\r\n    assertThat(get(TestClass.class).getSuperClassName()).isEqualTo(Object.class.getName());\r\n}\n@Test\r\nvoid getSuperClassNameWhenHasNoSuperClassReturnsNull() {\r\n    assertThat(get(Object.class).getSuperClassName()).isNull();\r\n    assertThat(get(TestInterface.class).getSuperClassName()).isNull();\r\n    assertThat(get(TestSubInterface.class).getSuperClassName()).isNull();\r\n}\n@Test\r\nvoid getInterfaceNamesWhenHasInterfacesReturnsNames() {\r\n    assertThat(get(TestSubclass.class).getInterfaceNames()).containsExactlyInAnyOrder(TestInterface.class.getName());\r\n    assertThat(get(TestSubInterface.class).getInterfaceNames()).containsExactlyInAnyOrder(TestInterface.class.getName());\r\n}\n@Test\r\nvoid getInterfaceNamesWhenHasNoInterfacesReturnsEmptyArray() {\r\n    assertThat(get(TestClass.class).getInterfaceNames()).isEmpty();\r\n}\n@Test\r\nvoid getMemberClassNamesWhenHasMemberClassesReturnsNames() {\r\n    assertThat(get(TestMemberClass.class).getMemberClassNames()).containsExactlyInAnyOrder(TestMemberClassInnerClass.class.getName(), TestMemberClassInnerInterface.class.getName());\r\n}\n@Test\r\nvoid getMemberClassNamesWhenHasNoMemberClassesReturnsEmptyArray() {\r\n    assertThat(get(TestClass.class).getMemberClassNames()).isEmpty();\r\n}\n@Test\r\nvoid getAnnotationsReturnsDirectAnnotations() {\r\n    assertThat(get(WithDirectAnnotations.class).getAnnotations().stream()).filteredOn(MergedAnnotation::isDirectlyPresent).extracting(a -> a.getType().getName()).containsExactlyInAnyOrder(DirectAnnotation1.class.getName(), DirectAnnotation2.class.getName());\r\n}\n@Test\r\nvoid isAnnotatedWhenMatchesDirectAnnotationReturnsTrue() {\r\n    assertThat(get(WithDirectAnnotations.class).isAnnotated(DirectAnnotation1.class.getName())).isTrue();\r\n}\n@Test\r\nvoid isAnnotatedWhenMatchesMetaAnnotationReturnsTrue() {\r\n    assertThat(get(WithMetaAnnotations.class).isAnnotated(MetaAnnotation2.class.getName())).isTrue();\r\n}\n@Test\r\nvoid isAnnotatedWhenDoesNotMatchDirectOrMetaAnnotationReturnsFalse() {\r\n    assertThat(get(TestClass.class).isAnnotated(DirectAnnotation1.class.getName())).isFalse();\r\n}\n@Test\r\nvoid getAnnotationAttributesReturnsAttributes() {\r\n    assertThat(get(WithAnnotationAttributes.class).getAnnotationAttributes(AnnotationAttributes.class.getName())).containsOnly(entry(\"name\", \"test\"), entry(\"size\", 1));\r\n}\n@Test\r\nvoid getAllAnnotationAttributesReturnsAllAttributes() {\r\n    MultiValueMap<String, Object> attributes = get(WithMetaAnnotationAttributes.class).getAllAnnotationAttributes(AnnotationAttributes.class.getName());\r\n    assertThat(attributes).containsOnlyKeys(\"name\", \"size\");\r\n    assertThat(attributes.get(\"name\")).containsExactlyInAnyOrder(\"m1\", \"m2\");\r\n    assertThat(attributes.get(\"size\")).containsExactlyInAnyOrder(1, 2);\r\n}\n@Test\r\nvoid getAnnotationTypesReturnsDirectAnnotations() {\r\n    AnnotationMetadata metadata = get(WithDirectAnnotations.class);\r\n    assertThat(metadata.getAnnotationTypes()).containsExactlyInAnyOrder(DirectAnnotation1.class.getName(), DirectAnnotation2.class.getName());\r\n}\n@Test\r\nvoid getMetaAnnotationTypesReturnsMetaAnnotations() {\r\n    AnnotationMetadata metadata = get(WithMetaAnnotations.class);\r\n    assertThat(metadata.getMetaAnnotationTypes(MetaAnnotationRoot.class.getName())).containsExactlyInAnyOrder(MetaAnnotation1.class.getName(), MetaAnnotation2.class.getName());\r\n}\n@Test\r\nvoid hasAnnotationWhenMatchesDirectAnnotationReturnsTrue() {\r\n    assertThat(get(WithDirectAnnotations.class).hasAnnotation(DirectAnnotation1.class.getName())).isTrue();\r\n}\n@Test\r\nvoid hasAnnotationWhenMatchesMetaAnnotationReturnsFalse() {\r\n    assertThat(get(WithMetaAnnotations.class).hasAnnotation(MetaAnnotation1.class.getName())).isFalse();\r\n    assertThat(get(WithMetaAnnotations.class).hasAnnotation(MetaAnnotation2.class.getName())).isFalse();\r\n}\n@Test\r\nvoid hasAnnotationWhenDoesNotMatchDirectOrMetaAnnotationReturnsFalse() {\r\n    assertThat(get(TestClass.class).hasAnnotation(DirectAnnotation1.class.getName())).isFalse();\r\n}\n@Test\r\nvoid hasMetaAnnotationWhenMatchesDirectReturnsFalse() {\r\n    assertThat(get(WithDirectAnnotations.class).hasMetaAnnotation(DirectAnnotation1.class.getName())).isFalse();\r\n}\n@Test\r\nvoid hasMetaAnnotationWhenMatchesMetaAnnotationReturnsTrue() {\r\n    assertThat(get(WithMetaAnnotations.class).hasMetaAnnotation(MetaAnnotation1.class.getName())).isTrue();\r\n    assertThat(get(WithMetaAnnotations.class).hasMetaAnnotation(MetaAnnotation2.class.getName())).isTrue();\r\n}\n@Test\r\nvoid hasMetaAnnotationWhenDoesNotMatchDirectOrMetaAnnotationReturnsFalse() {\r\n    assertThat(get(TestClass.class).hasMetaAnnotation(MetaAnnotation1.class.getName())).isFalse();\r\n}\n@Test\r\nvoid hasAnnotatedMethodsWhenMatchesDirectAnnotationReturnsTrue() {\r\n    assertThat(get(WithAnnotatedMethod.class).hasAnnotatedMethods(DirectAnnotation1.class.getName())).isTrue();\r\n}\n@Test\r\nvoid hasAnnotatedMethodsWhenMatchesMetaAnnotationReturnsTrue() {\r\n    assertThat(get(WithMetaAnnotatedMethod.class).hasAnnotatedMethods(MetaAnnotation2.class.getName())).isTrue();\r\n}\n@Test\r\nvoid hasAnnotatedMethodsWhenDoesNotMatchAnyAnnotationReturnsFalse() {\r\n    assertThat(get(WithAnnotatedMethod.class).hasAnnotatedMethods(MetaAnnotation2.class.getName())).isFalse();\r\n    assertThat(get(WithNonAnnotatedMethod.class).hasAnnotatedMethods(DirectAnnotation1.class.getName())).isFalse();\r\n}\n@Test\r\nvoid getAnnotatedMethodsReturnsMatchingAnnotatedAndMetaAnnotatedMethods() {\r\n    assertThat(get(WithDirectAndMetaAnnotatedMethods.class).getAnnotatedMethods(MetaAnnotation2.class.getName())).extracting(MethodMetadata::getMethodName).containsExactlyInAnyOrder(\"direct\", \"meta\");\r\n}\nprotected abstract AnnotationMetadata get(Class<?> source);\n@Retention(RetentionPolicy.RUNTIME)\r\npublic @interface DirectAnnotation1 {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\npublic @interface DirectAnnotation2 {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@MetaAnnotation1\r\npublic @interface MetaAnnotationRoot {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@MetaAnnotation2\r\npublic @interface MetaAnnotation1 {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\npublic @interface MetaAnnotation2 {\r\n}\npublic static class TestClass {\r\n}\npublic interface TestInterface {\r\n}\npublic interface TestSubInterface extends TestInterface {\r\n}\npublic @interface TestAnnotation {\r\n}\npublic static final class TestFinalClass {\r\n}\npublic class TestNonStaticInnerClass {\r\n}\npublic static class TestSubclass extends TestClass implements TestInterface {\r\n}\n@DirectAnnotation1\r\n@DirectAnnotation2\r\npublic static class WithDirectAnnotations {\r\n}\n@MetaAnnotationRoot\r\npublic static class WithMetaAnnotations {\r\n}\npublic static class TestMemberClass {\r\n\r\n    public static class TestMemberClassInnerClass {\r\n    }\r\n\r\n    interface TestMemberClassInnerInterface {\r\n    }\r\n}\npublic static class WithAnnotatedMethod {\r\n\r\n    @DirectAnnotation1\r\n    public void test() {\r\n    }\r\n}\npublic static class WithMetaAnnotatedMethod {\r\n\r\n    @MetaAnnotationRoot\r\n    public void test() {\r\n    }\r\n}\npublic static class WithNonAnnotatedMethod {\r\n\r\n    public void test() {\r\n    }\r\n}\npublic static class WithDirectAndMetaAnnotatedMethods {\r\n\r\n    @MetaAnnotation2\r\n    public void direct() {\r\n    }\r\n\r\n    @MetaAnnotationRoot\r\n    public void meta() {\r\n    }\r\n}\n@AnnotationAttributes(name = \"test\", size = 1)\r\npublic static class WithAnnotationAttributes {\r\n}\n@MetaAnnotationAttributes1\r\n@MetaAnnotationAttributes2\r\npublic static class WithMetaAnnotationAttributes {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@AnnotationAttributes(name = \"m1\", size = 1)\r\npublic @interface MetaAnnotationAttributes1 {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@AnnotationAttributes(name = \"m2\", size = 2)\r\npublic @interface MetaAnnotationAttributes2 {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\npublic @interface AnnotationAttributes {\r\n\r\n    String name();\r\n\r\n    int size();\r\n}",
    "comment": "\n * Base class for {@link AnnotationMetadata} tests.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n "
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#verifyEquals()",
    "entityType": "method",
    "code": "@Test\r\nvoid verifyEquals() {\r\n    AnnotationMetadata testClass1 = get(TestClass.class);\r\n    AnnotationMetadata testClass2 = get(TestClass.class);\r\n    AnnotationMetadata testMemberClass1 = get(TestMemberClass.class);\r\n    AnnotationMetadata testMemberClass2 = get(TestMemberClass.class);\r\n    assertThat(testClass1).isNotEqualTo(null);\r\n    assertThat(testClass1).isEqualTo(testClass1);\r\n    assertThat(testClass2).isEqualTo(testClass2);\r\n    assertThat(testClass1).isEqualTo(testClass2);\r\n    assertThat(testClass2).isEqualTo(testClass1);\r\n    assertThat(testMemberClass1).isEqualTo(testMemberClass1);\r\n    assertThat(testMemberClass2).isEqualTo(testMemberClass2);\r\n    assertThat(testMemberClass1).isEqualTo(testMemberClass2);\r\n    assertThat(testMemberClass2).isEqualTo(testMemberClass1);\r\n    assertThat(testClass1).isNotEqualTo(testMemberClass1);\r\n    assertThat(testMemberClass1).isNotEqualTo(testClass1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#verifyHashCode()",
    "entityType": "method",
    "code": "@Test\r\nvoid verifyHashCode() {\r\n    AnnotationMetadata testClass1 = get(TestClass.class);\r\n    AnnotationMetadata testClass2 = get(TestClass.class);\r\n    AnnotationMetadata testMemberClass1 = get(TestMemberClass.class);\r\n    AnnotationMetadata testMemberClass2 = get(TestMemberClass.class);\r\n    assertThat(testClass1).hasSameHashCodeAs(testClass2);\r\n    assertThat(testMemberClass1).hasSameHashCodeAs(testMemberClass2);\r\n    assertThat(testClass1).doesNotHaveSameHashCodeAs(testMemberClass1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#verifyToString()",
    "entityType": "method",
    "code": "@Test\r\nvoid verifyToString() {\r\n    assertThat(get(TestClass.class).toString()).isEqualTo(TestClass.class.getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#getClassNameReturnsClassName()",
    "entityType": "method",
    "code": "@Test\r\nvoid getClassNameReturnsClassName() {\r\n    assertThat(get(TestClass.class).getClassName()).isEqualTo(TestClass.class.getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#isInterfaceWhenInterfaceReturnsTrue()",
    "entityType": "method",
    "code": "@Test\r\nvoid isInterfaceWhenInterfaceReturnsTrue() {\r\n    assertThat(get(TestInterface.class).isInterface()).isTrue();\r\n    assertThat(get(TestAnnotation.class).isInterface()).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#isInterfaceWhenNotInterfaceReturnsFalse()",
    "entityType": "method",
    "code": "@Test\r\nvoid isInterfaceWhenNotInterfaceReturnsFalse() {\r\n    assertThat(get(TestClass.class).isInterface()).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#isAnnotationWhenAnnotationReturnsTrue()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAnnotationWhenAnnotationReturnsTrue() {\r\n    assertThat(get(TestAnnotation.class).isAnnotation()).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#isAnnotationWhenNotAnnotationReturnsFalse()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAnnotationWhenNotAnnotationReturnsFalse() {\r\n    assertThat(get(TestClass.class).isAnnotation()).isFalse();\r\n    assertThat(get(TestInterface.class).isAnnotation()).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#isFinalWhenFinalReturnsTrue()",
    "entityType": "method",
    "code": "@Test\r\nvoid isFinalWhenFinalReturnsTrue() {\r\n    assertThat(get(TestFinalClass.class).isFinal()).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#isFinalWhenNonFinalReturnsFalse()",
    "entityType": "method",
    "code": "@Test\r\nvoid isFinalWhenNonFinalReturnsFalse() {\r\n    assertThat(get(TestClass.class).isFinal()).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#isIndependentWhenIndependentReturnsTrue()",
    "entityType": "method",
    "code": "@Test\r\nvoid isIndependentWhenIndependentReturnsTrue() {\r\n    assertThat(get(AbstractAnnotationMetadataTests.class).isIndependent()).isTrue();\r\n    assertThat(get(TestClass.class).isIndependent()).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#isIndependentWhenNotIndependentReturnsFalse()",
    "entityType": "method",
    "code": "@Test\r\nvoid isIndependentWhenNotIndependentReturnsFalse() {\r\n    assertThat(get(TestNonStaticInnerClass.class).isIndependent()).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#getEnclosingClassNameWhenHasEnclosingClassReturnsEnclosingClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getEnclosingClassNameWhenHasEnclosingClassReturnsEnclosingClass() {\r\n    assertThat(get(TestClass.class).getEnclosingClassName()).isEqualTo(AbstractAnnotationMetadataTests.class.getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#getEnclosingClassNameWhenHasNoEnclosingClassReturnsNull()",
    "entityType": "method",
    "code": "@Test\r\nvoid getEnclosingClassNameWhenHasNoEnclosingClassReturnsNull() {\r\n    assertThat(get(AbstractAnnotationMetadataTests.class).getEnclosingClassName()).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#getSuperClassNameWhenHasSuperClassReturnsName()",
    "entityType": "method",
    "code": "@Test\r\nvoid getSuperClassNameWhenHasSuperClassReturnsName() {\r\n    assertThat(get(TestSubclass.class).getSuperClassName()).isEqualTo(TestClass.class.getName());\r\n    assertThat(get(TestClass.class).getSuperClassName()).isEqualTo(Object.class.getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#getSuperClassNameWhenHasNoSuperClassReturnsNull()",
    "entityType": "method",
    "code": "@Test\r\nvoid getSuperClassNameWhenHasNoSuperClassReturnsNull() {\r\n    assertThat(get(Object.class).getSuperClassName()).isNull();\r\n    assertThat(get(TestInterface.class).getSuperClassName()).isNull();\r\n    assertThat(get(TestSubInterface.class).getSuperClassName()).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#getInterfaceNamesWhenHasInterfacesReturnsNames()",
    "entityType": "method",
    "code": "@Test\r\nvoid getInterfaceNamesWhenHasInterfacesReturnsNames() {\r\n    assertThat(get(TestSubclass.class).getInterfaceNames()).containsExactlyInAnyOrder(TestInterface.class.getName());\r\n    assertThat(get(TestSubInterface.class).getInterfaceNames()).containsExactlyInAnyOrder(TestInterface.class.getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#getInterfaceNamesWhenHasNoInterfacesReturnsEmptyArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid getInterfaceNamesWhenHasNoInterfacesReturnsEmptyArray() {\r\n    assertThat(get(TestClass.class).getInterfaceNames()).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#getMemberClassNamesWhenHasMemberClassesReturnsNames()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMemberClassNamesWhenHasMemberClassesReturnsNames() {\r\n    assertThat(get(TestMemberClass.class).getMemberClassNames()).containsExactlyInAnyOrder(TestMemberClassInnerClass.class.getName(), TestMemberClassInnerInterface.class.getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#getMemberClassNamesWhenHasNoMemberClassesReturnsEmptyArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMemberClassNamesWhenHasNoMemberClassesReturnsEmptyArray() {\r\n    assertThat(get(TestClass.class).getMemberClassNames()).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#getAnnotationsReturnsDirectAnnotations()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAnnotationsReturnsDirectAnnotations() {\r\n    assertThat(get(WithDirectAnnotations.class).getAnnotations().stream()).filteredOn(MergedAnnotation::isDirectlyPresent).extracting(a -> a.getType().getName()).containsExactlyInAnyOrder(DirectAnnotation1.class.getName(), DirectAnnotation2.class.getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#isAnnotatedWhenMatchesDirectAnnotationReturnsTrue()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAnnotatedWhenMatchesDirectAnnotationReturnsTrue() {\r\n    assertThat(get(WithDirectAnnotations.class).isAnnotated(DirectAnnotation1.class.getName())).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#isAnnotatedWhenMatchesMetaAnnotationReturnsTrue()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAnnotatedWhenMatchesMetaAnnotationReturnsTrue() {\r\n    assertThat(get(WithMetaAnnotations.class).isAnnotated(MetaAnnotation2.class.getName())).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#isAnnotatedWhenDoesNotMatchDirectOrMetaAnnotationReturnsFalse()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAnnotatedWhenDoesNotMatchDirectOrMetaAnnotationReturnsFalse() {\r\n    assertThat(get(TestClass.class).isAnnotated(DirectAnnotation1.class.getName())).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#getAnnotationAttributesReturnsAttributes()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAnnotationAttributesReturnsAttributes() {\r\n    assertThat(get(WithAnnotationAttributes.class).getAnnotationAttributes(AnnotationAttributes.class.getName())).containsOnly(entry(\"name\", \"test\"), entry(\"size\", 1));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#getAllAnnotationAttributesReturnsAllAttributes()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAllAnnotationAttributesReturnsAllAttributes() {\r\n    MultiValueMap<String, Object> attributes = get(WithMetaAnnotationAttributes.class).getAllAnnotationAttributes(AnnotationAttributes.class.getName());\r\n    assertThat(attributes).containsOnlyKeys(\"name\", \"size\");\r\n    assertThat(attributes.get(\"name\")).containsExactlyInAnyOrder(\"m1\", \"m2\");\r\n    assertThat(attributes.get(\"size\")).containsExactlyInAnyOrder(1, 2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#getAnnotationTypesReturnsDirectAnnotations()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAnnotationTypesReturnsDirectAnnotations() {\r\n    AnnotationMetadata metadata = get(WithDirectAnnotations.class);\r\n    assertThat(metadata.getAnnotationTypes()).containsExactlyInAnyOrder(DirectAnnotation1.class.getName(), DirectAnnotation2.class.getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#getMetaAnnotationTypesReturnsMetaAnnotations()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMetaAnnotationTypesReturnsMetaAnnotations() {\r\n    AnnotationMetadata metadata = get(WithMetaAnnotations.class);\r\n    assertThat(metadata.getMetaAnnotationTypes(MetaAnnotationRoot.class.getName())).containsExactlyInAnyOrder(MetaAnnotation1.class.getName(), MetaAnnotation2.class.getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#hasAnnotationWhenMatchesDirectAnnotationReturnsTrue()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasAnnotationWhenMatchesDirectAnnotationReturnsTrue() {\r\n    assertThat(get(WithDirectAnnotations.class).hasAnnotation(DirectAnnotation1.class.getName())).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#hasAnnotationWhenMatchesMetaAnnotationReturnsFalse()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasAnnotationWhenMatchesMetaAnnotationReturnsFalse() {\r\n    assertThat(get(WithMetaAnnotations.class).hasAnnotation(MetaAnnotation1.class.getName())).isFalse();\r\n    assertThat(get(WithMetaAnnotations.class).hasAnnotation(MetaAnnotation2.class.getName())).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#hasAnnotationWhenDoesNotMatchDirectOrMetaAnnotationReturnsFalse()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasAnnotationWhenDoesNotMatchDirectOrMetaAnnotationReturnsFalse() {\r\n    assertThat(get(TestClass.class).hasAnnotation(DirectAnnotation1.class.getName())).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#hasMetaAnnotationWhenMatchesDirectReturnsFalse()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasMetaAnnotationWhenMatchesDirectReturnsFalse() {\r\n    assertThat(get(WithDirectAnnotations.class).hasMetaAnnotation(DirectAnnotation1.class.getName())).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#hasMetaAnnotationWhenMatchesMetaAnnotationReturnsTrue()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasMetaAnnotationWhenMatchesMetaAnnotationReturnsTrue() {\r\n    assertThat(get(WithMetaAnnotations.class).hasMetaAnnotation(MetaAnnotation1.class.getName())).isTrue();\r\n    assertThat(get(WithMetaAnnotations.class).hasMetaAnnotation(MetaAnnotation2.class.getName())).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#hasMetaAnnotationWhenDoesNotMatchDirectOrMetaAnnotationReturnsFalse()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasMetaAnnotationWhenDoesNotMatchDirectOrMetaAnnotationReturnsFalse() {\r\n    assertThat(get(TestClass.class).hasMetaAnnotation(MetaAnnotation1.class.getName())).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#hasAnnotatedMethodsWhenMatchesDirectAnnotationReturnsTrue()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasAnnotatedMethodsWhenMatchesDirectAnnotationReturnsTrue() {\r\n    assertThat(get(WithAnnotatedMethod.class).hasAnnotatedMethods(DirectAnnotation1.class.getName())).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#hasAnnotatedMethodsWhenMatchesMetaAnnotationReturnsTrue()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasAnnotatedMethodsWhenMatchesMetaAnnotationReturnsTrue() {\r\n    assertThat(get(WithMetaAnnotatedMethod.class).hasAnnotatedMethods(MetaAnnotation2.class.getName())).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#hasAnnotatedMethodsWhenDoesNotMatchAnyAnnotationReturnsFalse()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasAnnotatedMethodsWhenDoesNotMatchAnyAnnotationReturnsFalse() {\r\n    assertThat(get(WithAnnotatedMethod.class).hasAnnotatedMethods(MetaAnnotation2.class.getName())).isFalse();\r\n    assertThat(get(WithNonAnnotatedMethod.class).hasAnnotatedMethods(DirectAnnotation1.class.getName())).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#getAnnotatedMethodsReturnsMatchingAnnotatedAndMetaAnnotatedMethods()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAnnotatedMethodsReturnsMatchingAnnotatedAndMetaAnnotatedMethods() {\r\n    assertThat(get(WithDirectAndMetaAnnotatedMethods.class).getAnnotatedMethods(MetaAnnotation2.class.getName())).extracting(MethodMetadata::getMethodName).containsExactlyInAnyOrder(\"direct\", \"meta\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractAnnotationMetadataTests#get(Class<?>)",
    "entityType": "method",
    "code": "protected abstract AnnotationMetadata get(Class<?> source);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.TestClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.TestInterface",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.TestSubInterface",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.TestFinalClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.TestNonStaticInnerClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.TestSubclass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.WithDirectAnnotations",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.WithMetaAnnotations",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.TestMemberClass",
    "entityType": "class",
    "code": "public static class TestMemberClassInnerClass {\r\n}\ninterface TestMemberClassInnerInterface {\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.TestMemberClassInnerClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.TestMemberClassInnerInterface",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.WithAnnotatedMethod",
    "entityType": "class",
    "code": "@DirectAnnotation1\r\npublic void test() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.WithAnnotatedMethod#test()",
    "entityType": "method",
    "code": "@DirectAnnotation1\r\npublic void test() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.WithMetaAnnotatedMethod",
    "entityType": "class",
    "code": "@MetaAnnotationRoot\r\npublic void test() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.WithMetaAnnotatedMethod#test()",
    "entityType": "method",
    "code": "@MetaAnnotationRoot\r\npublic void test() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.WithNonAnnotatedMethod",
    "entityType": "class",
    "code": "public void test() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.WithNonAnnotatedMethod#test()",
    "entityType": "method",
    "code": "public void test() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.WithDirectAndMetaAnnotatedMethods",
    "entityType": "class",
    "code": "@MetaAnnotation2\r\npublic void direct() ;\n@MetaAnnotationRoot\r\npublic void meta() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.WithDirectAndMetaAnnotatedMethods#direct()",
    "entityType": "method",
    "code": "@MetaAnnotation2\r\npublic void direct() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.WithDirectAndMetaAnnotatedMethods#meta()",
    "entityType": "method",
    "code": "@MetaAnnotationRoot\r\npublic void meta() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.WithAnnotationAttributes",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.WithMetaAnnotationAttributes",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.FileSystemGeneratedFiles",
    "entityType": "class",
    "code": "private final Function<Kind, Path> roots;\n/**\r\n * Create a new {@link FileSystemGeneratedFiles} instance with all files\r\n * stored under the specific {@code root}. The following subdirectories are\r\n * created for the different file {@link Kind kinds}:\r\n * <ul>\r\n * <li>{@code sources}</li>\r\n * <li>{@code resources}</li>\r\n * <li>{@code classes}</li>\r\n * </ul>\r\n * @param root the root path\r\n * @see #FileSystemGeneratedFiles(Function)\r\n */\r\npublic FileSystemGeneratedFiles(Path root) {\r\n    this(conventionRoots(root));\r\n}\n/**\r\n * Create a new {@link FileSystemGeneratedFiles} instance with all files\r\n * stored under the root provided by the given {@link Function}.\r\n * @param roots a function that returns the root to use for the given\r\n * {@link Kind}\r\n */\r\npublic FileSystemGeneratedFiles(Function<Kind, Path> roots) {\r\n    Assert.notNull(roots, \"'roots' must not be null\");\r\n    Assert.isTrue(Arrays.stream(Kind.values()).map(roots).noneMatch(Objects::isNull), \"'roots' must return a value for all file kinds\");\r\n    this.roots = roots;\r\n}\nprivate static Function<Kind, Path> conventionRoots(Path root) {\r\n    Assert.notNull(root, \"'root' must not be null\");\r\n    return kind -> switch(kind) {\r\n        case SOURCE ->\r\n            root.resolve(\"sources\");\r\n        case RESOURCE ->\r\n            root.resolve(\"resources\");\r\n        case CLASS ->\r\n            root.resolve(\"classes\");\r\n    };\r\n}\n@Override\r\npublic void handleFile(Kind kind, String path, ThrowingConsumer<FileHandler> handler) {\r\n    FileSystemFileHandler fileHandler = new FileSystemFileHandler(toPath(kind, path));\r\n    handler.accept(fileHandler);\r\n}\nprivate Path toPath(Kind kind, String path) {\r\n    Assert.notNull(kind, \"'kind' must not be null\");\r\n    Assert.hasLength(path, \"'path' must not be empty\");\r\n    Path root = this.roots.apply(kind).toAbsolutePath().normalize();\r\n    Path relativePath = root.resolve(path).toAbsolutePath().normalize();\r\n    Assert.isTrue(relativePath.startsWith(root), \"'path' must be relative\");\r\n    return relativePath;\r\n}\nstatic final class FileSystemFileHandler extends FileHandler {\r\n\r\n    private final Path path;\r\n\r\n    FileSystemFileHandler(Path path) {\r\n        super(Files.exists(path), () -> new FileSystemResource(path));\r\n        this.path = path;\r\n    }\r\n\r\n    @Override\r\n    protected void copy(InputStreamSource content, boolean override) {\r\n        if (override) {\r\n            copy(content, StandardCopyOption.REPLACE_EXISTING);\r\n        } else {\r\n            copy(content);\r\n        }\r\n    }\r\n\r\n    private void copy(InputStreamSource content, CopyOption... copyOptions) {\r\n        try {\r\n            try (InputStream inputStream = content.getInputStream()) {\r\n                Files.createDirectories(this.path.getParent());\r\n                Files.copy(inputStream, this.path, copyOptions);\r\n            }\r\n        } catch (IOException ex) {\r\n            throw new IllegalStateException(ex);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return this.path.toString();\r\n    }\r\n}",
    "comment": "\n * {@link GeneratedFiles} implementation that stores generated files using a\n * {@link FileSystem}.\n *\n * @author Phillip Webb\n * @author Stephane Nicoll\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.generate.FileSystemGeneratedFiles#conventionRoots(Path)",
    "entityType": "method",
    "code": "private static Function<Kind, Path> conventionRoots(Path root) {\r\n    Assert.notNull(root, \"'root' must not be null\");\r\n    return kind -> switch(kind) {\r\n        case SOURCE ->\r\n            root.resolve(\"sources\");\r\n        case RESOURCE ->\r\n            root.resolve(\"resources\");\r\n        case CLASS ->\r\n            root.resolve(\"classes\");\r\n    };\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.FileSystemGeneratedFiles#handleFile(Kind,String,ThrowingConsumer<FileHandler>)",
    "entityType": "method",
    "code": "@Override\r\npublic void handleFile(Kind kind, String path, ThrowingConsumer<FileHandler> handler) {\r\n    FileSystemFileHandler fileHandler = new FileSystemFileHandler(toPath(kind, path));\r\n    handler.accept(fileHandler);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.FileSystemGeneratedFiles#toPath(Kind,String)",
    "entityType": "method",
    "code": "private Path toPath(Kind kind, String path) {\r\n    Assert.notNull(kind, \"'kind' must not be null\");\r\n    Assert.hasLength(path, \"'path' must not be empty\");\r\n    Path root = this.roots.apply(kind).toAbsolutePath().normalize();\r\n    Path relativePath = root.resolve(path).toAbsolutePath().normalize();\r\n    Assert.isTrue(relativePath.startsWith(root), \"'path' must be relative\");\r\n    return relativePath;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.FileSystemFileHandler",
    "entityType": "class",
    "code": "private final Path path;\nFileSystemFileHandler(Path path) {\r\n    super(Files.exists(path), () -> new FileSystemResource(path));\r\n    this.path = path;\r\n}\n@Override\r\nprotected void copy(InputStreamSource content, boolean override) {\r\n    if (override) {\r\n        copy(content, StandardCopyOption.REPLACE_EXISTING);\r\n    } else {\r\n        copy(content);\r\n    }\r\n}\nprivate void copy(InputStreamSource content, CopyOption... copyOptions) {\r\n    try {\r\n        try (InputStream inputStream = content.getInputStream()) {\r\n            Files.createDirectories(this.path.getParent());\r\n            Files.copy(inputStream, this.path, copyOptions);\r\n        }\r\n    } catch (IOException ex) {\r\n        throw new IllegalStateException(ex);\r\n    }\r\n}\n@Override\r\npublic String toString() {\r\n    return this.path.toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.FileSystemFileHandler#copy(InputStreamSource,boolean)",
    "entityType": "method",
    "code": "@Override\r\nprotected void copy(InputStreamSource content, boolean override) {\r\n    if (override) {\r\n        copy(content, StandardCopyOption.REPLACE_EXISTING);\r\n    } else {\r\n        copy(content);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.FileSystemFileHandler#copy(InputStreamSource,CopyOption)",
    "entityType": "method",
    "code": "private void copy(InputStreamSource content, CopyOption... copyOptions) {\r\n    try {\r\n        try (InputStream inputStream = content.getInputStream()) {\r\n            Files.createDirectories(this.path.getParent());\r\n            Files.copy(inputStream, this.path, copyOptions);\r\n        }\r\n    } catch (IOException ex) {\r\n        throw new IllegalStateException(ex);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.FileSystemFileHandler#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return this.path.toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AbstractClassMetadataMemberClassTests",
    "entityType": "class",
    "code": "protected abstract ClassMetadata getClassMetadataFor(Class<?> clazz);\n@Test\r\nvoid withNoMemberClasses() {\r\n    ClassMetadata metadata = getClassMetadataFor(L0_a.class);\r\n    String[] nestedClasses = metadata.getMemberClassNames();\r\n    assertThat(nestedClasses).isEmpty();\r\n}\n@Test\r\nvoid withPublicMemberClasses() {\r\n    ClassMetadata metadata = getClassMetadataFor(L0_b.class);\r\n    String[] nestedClasses = metadata.getMemberClassNames();\r\n    assertThat(nestedClasses).containsOnly(L0_b.L1.class.getName());\r\n}\n@Test\r\nvoid withNonPublicMemberClasses() {\r\n    ClassMetadata metadata = getClassMetadataFor(L0_c.class);\r\n    String[] nestedClasses = metadata.getMemberClassNames();\r\n    assertThat(nestedClasses).containsOnly(L0_c.L1.class.getName());\r\n}\n@Test\r\nvoid againstMemberClass() {\r\n    ClassMetadata metadata = getClassMetadataFor(L0_b.L1.class);\r\n    String[] nestedClasses = metadata.getMemberClassNames();\r\n    assertThat(nestedClasses).isEmpty();\r\n}\npublic static class L0_a {\r\n}\npublic static class L0_b {\r\n\r\n    public static class L1 {\r\n    }\r\n}\npublic static class L0_c {\r\n\r\n    private static class L1 {\r\n    }\r\n}",
    "comment": "\n * Abstract base class for testing implementations of\n * {@link ClassMetadata#getMemberClassNames()}.\n *\n * @author Chris Beams\n * @since 3.1\n "
  },
  {
    "entityId": "org.springframework.core.type.AbstractClassMetadataMemberClassTests#getClassMetadataFor(Class<?>)",
    "entityType": "method",
    "code": "protected abstract ClassMetadata getClassMetadataFor(Class<?> clazz);",
    "comment": ""
  }
]