[
  {
    "entityId": "org.springframework.core.task.VirtualThreadTaskExecutorTests#executeAndWait(TaskExecutor,Runnable,Object)",
    "entityType": "method",
    "code": "private void executeAndWait(TaskExecutor executor, Runnable task, Object monitor) {\r\n    synchronized (monitor) {\r\n        executor.execute(task);\r\n        try {\r\n            monitor.wait();\r\n        } catch (InterruptedException ignored) ;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.task.NoOpRunnable",
    "entityType": "class",
    "code": "@Override\r\npublic void run() {\r\n    // no-op\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.task.NoOpRunnable#run()",
    "entityType": "method",
    "code": "@Override\r\npublic void run() {\r\n    // no-op\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.task.AbstractNotifyingRunnable",
    "entityType": "class",
    "code": "private final Object monitor;\nprotected AbstractNotifyingRunnable(Object monitor) {\r\n    this.monitor = monitor;\r\n}\n@Override\r\npublic final void run() {\r\n    synchronized (this.monitor) {\r\n        try {\r\n            doRun();\r\n        } finally {\r\n            this.monitor.notifyAll();\r\n        }\r\n    }\r\n}\nprotected abstract void doRun();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.task.AbstractNotifyingRunnable#run()",
    "entityType": "method",
    "code": "@Override\r\npublic final void run() {\r\n    synchronized (this.monitor) {\r\n        try {\r\n            doRun();\r\n        } finally {\r\n            this.monitor.notifyAll();\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.task.AbstractNotifyingRunnable#doRun()",
    "entityType": "method",
    "code": "protected abstract void doRun();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.task.ThreadNameHarvester",
    "entityType": "class",
    "code": "private final AtomicInteger runCount = new AtomicInteger();\nprivate String threadName;\nprivate boolean virtual;\nprotected ThreadNameHarvester(Object monitor) {\r\n    super(monitor);\r\n}\npublic String getThreadName() {\r\n    return this.threadName;\r\n}\npublic boolean isVirtual() {\r\n    return this.virtual;\r\n}\npublic int runCount() {\r\n    return this.runCount.get();\r\n}\n@Override\r\nprotected void doRun() {\r\n    Thread thread = Thread.currentThread();\r\n    this.threadName = thread.getName();\r\n    this.virtual = thread.isVirtual();\r\n    runCount.incrementAndGet();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.task.ThreadNameHarvester#getThreadName()",
    "entityType": "method",
    "code": "public String getThreadName() {\r\n    return this.threadName;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.task.ThreadNameHarvester#isVirtual()",
    "entityType": "method",
    "code": "public boolean isVirtual() {\r\n    return this.virtual;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.task.ThreadNameHarvester#runCount()",
    "entityType": "method",
    "code": "public int runCount() {\r\n    return this.runCount.get();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.task.ThreadNameHarvester#doRun()",
    "entityType": "method",
    "code": "@Override\r\nprotected void doRun() {\r\n    Thread thread = Thread.currentThread();\r\n    this.threadName = thread.getName();\r\n    this.virtual = thread.isVirtual();\r\n    runCount.incrementAndGet();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor",
    "entityType": "class",
    "code": "private static final String REQUIRES_ASM5 = \"This feature requires ASM5\";\n/**\r\n * The ASM API version implemented by this visitor. The value of this field must be one of the\r\n * {@code ASM}<i>x</i> values in {@link Opcodes}.\r\n */\r\nprotected final int api;\n/**\r\n * The method visitor to which this visitor must delegate method calls. May be {@literal null}.\r\n */\r\nprotected MethodVisitor mv;\n/**\r\n * Constructs a new {@link MethodVisitor}.\r\n *\r\n * @param api the ASM API version implemented by this visitor. Must be one of the {@code\r\n *     ASM}<i>x</i> values in {@link Opcodes}.\r\n */\r\nprotected MethodVisitor(final int api) {\r\n    this(api, null);\r\n}\n/**\r\n * Constructs a new {@link MethodVisitor}.\r\n *\r\n * @param api the ASM API version implemented by this visitor. Must be one of the {@code\r\n *     ASM}<i>x</i> values in {@link Opcodes}.\r\n * @param methodVisitor the method visitor to which this visitor must delegate method calls. May\r\n *     be null.\r\n */\r\nprotected MethodVisitor(final int api, final MethodVisitor methodVisitor) {\r\n    if (api != Opcodes.ASM9 && api != Opcodes.ASM8 && api != Opcodes.ASM7 && api != Opcodes.ASM6 && api != Opcodes.ASM5 && api != Opcodes.ASM4 && api != Opcodes.ASM10_EXPERIMENTAL) {\r\n        throw new IllegalArgumentException(\"Unsupported api \" + api);\r\n    }\r\n    // SPRING PATCH: no preview mode check for ASM experimental\r\n    this.api = api;\r\n    this.mv = methodVisitor;\r\n}\n/**\r\n * The method visitor to which this visitor must delegate method calls. May be {@literal null}.\r\n *\r\n * @return the method visitor to which this visitor must delegate method calls, or {@literal\r\n *     null}.\r\n */\r\npublic MethodVisitor getDelegate() {\r\n    return mv;\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Parameters, annotations and non standard attributes\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Visits a parameter of this method.\r\n *\r\n * @param name parameter name or {@literal null} if none is provided.\r\n * @param access the parameter's access flags, only {@code ACC_FINAL}, {@code ACC_SYNTHETIC}\r\n *     or/and {@code ACC_MANDATED} are allowed (see {@link Opcodes}).\r\n */\r\npublic void visitParameter(final String name, final int access) {\r\n    if (api < Opcodes.ASM5) {\r\n        throw new UnsupportedOperationException(REQUIRES_ASM5);\r\n    }\r\n    if (mv != null) {\r\n        mv.visitParameter(name, access);\r\n    }\r\n}\n/**\r\n * Visits the default value of this annotation interface method.\r\n *\r\n * @return a visitor to the visit the actual default value of this annotation interface method, or\r\n *     {@literal null} if this visitor is not interested in visiting this default value. The\r\n *     'name' parameters passed to the methods of this annotation visitor are ignored. Moreover,\r\n *     exactly one visit method must be called on this annotation visitor, followed by visitEnd.\r\n */\r\npublic AnnotationVisitor visitAnnotationDefault() {\r\n    if (mv != null) {\r\n        return mv.visitAnnotationDefault();\r\n    }\r\n    return null;\r\n}\n/**\r\n * Visits an annotation of this method.\r\n *\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param visible {@literal true} if the annotation is visible at runtime.\r\n * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\r\n *     interested in visiting this annotation.\r\n */\r\npublic AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\r\n    if (mv != null) {\r\n        return mv.visitAnnotation(descriptor, visible);\r\n    }\r\n    return null;\r\n}\n/**\r\n * Visits an annotation on a type in the method signature.\r\n *\r\n * @param typeRef a reference to the annotated type. The sort of this type reference must be\r\n *     {@link TypeReference#METHOD_TYPE_PARAMETER}, {@link\r\n *     TypeReference#METHOD_TYPE_PARAMETER_BOUND}, {@link TypeReference#METHOD_RETURN}, {@link\r\n *     TypeReference#METHOD_RECEIVER}, {@link TypeReference#METHOD_FORMAL_PARAMETER} or {@link\r\n *     TypeReference#THROWS}. See {@link TypeReference}.\r\n * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\r\n *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\r\n *     'typeRef' as a whole.\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param visible {@literal true} if the annotation is visible at runtime.\r\n * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\r\n *     interested in visiting this annotation.\r\n */\r\npublic AnnotationVisitor visitTypeAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\r\n    if (api < Opcodes.ASM5) {\r\n        throw new UnsupportedOperationException(REQUIRES_ASM5);\r\n    }\r\n    if (mv != null) {\r\n        return mv.visitTypeAnnotation(typeRef, typePath, descriptor, visible);\r\n    }\r\n    return null;\r\n}\n/**\r\n * Visits the number of method parameters that can have annotations. By default (i.e. when this\r\n * method is not called), all the method parameters defined by the method descriptor can have\r\n * annotations.\r\n *\r\n * @param parameterCount the number of method parameters than can have annotations. This number\r\n *     must be less or equal than the number of parameter types in the method descriptor. It can\r\n *     be strictly less when a method has synthetic parameters and when these parameters are\r\n *     ignored when computing parameter indices for the purpose of parameter annotations (see\r\n *     https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.18).\r\n * @param visible {@literal true} to define the number of method parameters that can have\r\n *     annotations visible at runtime, {@literal false} to define the number of method parameters\r\n *     that can have annotations invisible at runtime.\r\n */\r\npublic void visitAnnotableParameterCount(final int parameterCount, final boolean visible) {\r\n    if (mv != null) {\r\n        mv.visitAnnotableParameterCount(parameterCount, visible);\r\n    }\r\n}\n/**\r\n * Visits an annotation of a parameter this method.\r\n *\r\n * @param parameter the parameter index. This index must be strictly smaller than the number of\r\n *     parameters in the method descriptor, and strictly smaller than the parameter count\r\n *     specified in {@link #visitAnnotableParameterCount}. Important note: <i>a parameter index i\r\n *     is not required to correspond to the i'th parameter descriptor in the method\r\n *     descriptor</i>, in particular in case of synthetic parameters (see\r\n *     https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.18).\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param visible {@literal true} if the annotation is visible at runtime.\r\n * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\r\n *     interested in visiting this annotation.\r\n */\r\npublic AnnotationVisitor visitParameterAnnotation(final int parameter, final String descriptor, final boolean visible) {\r\n    if (mv != null) {\r\n        return mv.visitParameterAnnotation(parameter, descriptor, visible);\r\n    }\r\n    return null;\r\n}\n/**\r\n * Visits a non standard attribute of this method.\r\n *\r\n * @param attribute an attribute.\r\n */\r\npublic void visitAttribute(final Attribute attribute) {\r\n    if (mv != null) {\r\n        mv.visitAttribute(attribute);\r\n    }\r\n}\n/**\r\n * Starts the visit of the method's code, if any (i.e. non abstract method).\r\n */\r\npublic void visitCode() {\r\n    if (mv != null) {\r\n        mv.visitCode();\r\n    }\r\n}\n/**\r\n * Visits the current state of the local variables and operand stack elements. This method must(*)\r\n * be called <i>just before</i> any instruction <b>i</b> that follows an unconditional branch\r\n * instruction such as GOTO or THROW, that is the target of a jump instruction, or that starts an\r\n * exception handler block. The visited types must describe the values of the local variables and\r\n * of the operand stack elements <i>just before</i> <b>i</b> is executed.<br>\r\n * <br>\r\n * (*) this is mandatory only for classes whose version is greater than or equal to {@link\r\n * Opcodes#V1_6}. <br>\r\n * <br>\r\n * The frames of a method must be given either in expanded form, or in compressed form (all frames\r\n * must use the same format, i.e. you must not mix expanded and compressed frames within a single\r\n * method):\r\n *\r\n * <ul>\r\n *   <li>In expanded form, all frames must have the F_NEW type.\r\n *   <li>In compressed form, frames are basically \"deltas\" from the state of the previous frame:\r\n *       <ul>\r\n *         <li>{@link Opcodes#F_SAME} representing frame with exactly the same locals as the\r\n *             previous frame and with the empty stack.\r\n *         <li>{@link Opcodes#F_SAME1} representing frame with exactly the same locals as the\r\n *             previous frame and with single value on the stack ( <code>numStack</code> is 1 and\r\n *             <code>stack[0]</code> contains value for the type of the stack item).\r\n *         <li>{@link Opcodes#F_APPEND} representing frame with current locals are the same as the\r\n *             locals in the previous frame, except that additional locals are defined (<code>\r\n *             numLocal</code> is 1, 2 or 3 and <code>local</code> elements contains values\r\n *             representing added types).\r\n *         <li>{@link Opcodes#F_CHOP} representing frame with current locals are the same as the\r\n *             locals in the previous frame, except that the last 1-3 locals are absent and with\r\n *             the empty stack (<code>numLocal</code> is 1, 2 or 3).\r\n *         <li>{@link Opcodes#F_FULL} representing complete frame data.\r\n *       </ul>\r\n * </ul>\r\n *\r\n * <br>\r\n * In both cases the first frame, corresponding to the method's parameters and access flags, is\r\n * implicit and must not be visited. Also, it is illegal to visit two or more frames for the same\r\n * code location (i.e., at least one instruction must be visited between two calls to visitFrame).\r\n *\r\n * @param type the type of this stack map frame. Must be {@link Opcodes#F_NEW} for expanded\r\n *     frames, or {@link Opcodes#F_FULL}, {@link Opcodes#F_APPEND}, {@link Opcodes#F_CHOP}, {@link\r\n *     Opcodes#F_SAME} or {@link Opcodes#F_APPEND}, {@link Opcodes#F_SAME1} for compressed frames.\r\n * @param numLocal the number of local variables in the visited frame. Long and double values\r\n *     count for one variable.\r\n * @param local the local variable types in this frame. This array must not be modified. Primitive\r\n *     types are represented by {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link\r\n *     Opcodes#FLOAT}, {@link Opcodes#LONG}, {@link Opcodes#DOUBLE}, {@link Opcodes#NULL} or\r\n *     {@link Opcodes#UNINITIALIZED_THIS} (long and double are represented by a single element).\r\n *     Reference types are represented by String objects (representing internal names, see {@link\r\n *     Type#getInternalName()}), and uninitialized types by Label objects (this label designates\r\n *     the NEW instruction that created this uninitialized value).\r\n * @param numStack the number of operand stack elements in the visited frame. Long and double\r\n *     values count for one stack element.\r\n * @param stack the operand stack types in this frame. This array must not be modified. Its\r\n *     content has the same format as the \"local\" array.\r\n * @throws IllegalStateException if a frame is visited just after another one, without any\r\n *     instruction between the two (unless this frame is a Opcodes#F_SAME frame, in which case it\r\n *     is silently ignored).\r\n */\r\npublic void visitFrame(final int type, final int numLocal, final Object[] local, final int numStack, final Object[] stack) {\r\n    if (mv != null) {\r\n        mv.visitFrame(type, numLocal, local, numStack, stack);\r\n    }\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Normal instructions\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Visits a zero operand instruction.\r\n *\r\n * @param opcode the opcode of the instruction to be visited. This opcode is either NOP,\r\n *     ACONST_NULL, ICONST_M1, ICONST_0, ICONST_1, ICONST_2, ICONST_3, ICONST_4, ICONST_5,\r\n *     LCONST_0, LCONST_1, FCONST_0, FCONST_1, FCONST_2, DCONST_0, DCONST_1, IALOAD, LALOAD,\r\n *     FALOAD, DALOAD, AALOAD, BALOAD, CALOAD, SALOAD, IASTORE, LASTORE, FASTORE, DASTORE,\r\n *     AASTORE, BASTORE, CASTORE, SASTORE, POP, POP2, DUP, DUP_X1, DUP_X2, DUP2, DUP2_X1, DUP2_X2,\r\n *     SWAP, IADD, LADD, FADD, DADD, ISUB, LSUB, FSUB, DSUB, IMUL, LMUL, FMUL, DMUL, IDIV, LDIV,\r\n *     FDIV, DDIV, IREM, LREM, FREM, DREM, INEG, LNEG, FNEG, DNEG, ISHL, LSHL, ISHR, LSHR, IUSHR,\r\n *     LUSHR, IAND, LAND, IOR, LOR, IXOR, LXOR, I2L, I2F, I2D, L2I, L2F, L2D, F2I, F2L, F2D, D2I,\r\n *     D2L, D2F, I2B, I2C, I2S, LCMP, FCMPL, FCMPG, DCMPL, DCMPG, IRETURN, LRETURN, FRETURN,\r\n *     DRETURN, ARETURN, RETURN, ARRAYLENGTH, ATHROW, MONITORENTER, or MONITOREXIT.\r\n */\r\npublic void visitInsn(final int opcode) {\r\n    if (mv != null) {\r\n        mv.visitInsn(opcode);\r\n    }\r\n}\n/**\r\n * Visits an instruction with a single int operand.\r\n *\r\n * @param opcode the opcode of the instruction to be visited. This opcode is either BIPUSH, SIPUSH\r\n *     or NEWARRAY.\r\n * @param operand the operand of the instruction to be visited.<br>\r\n *     When opcode is BIPUSH, operand value should be between Byte.MIN_VALUE and Byte.MAX_VALUE.\r\n *     <br>\r\n *     When opcode is SIPUSH, operand value should be between Short.MIN_VALUE and Short.MAX_VALUE.\r\n *     <br>\r\n *     When opcode is NEWARRAY, operand value should be one of {@link Opcodes#T_BOOLEAN}, {@link\r\n *     Opcodes#T_CHAR}, {@link Opcodes#T_FLOAT}, {@link Opcodes#T_DOUBLE}, {@link Opcodes#T_BYTE},\r\n *     {@link Opcodes#T_SHORT}, {@link Opcodes#T_INT} or {@link Opcodes#T_LONG}.\r\n */\r\npublic void visitIntInsn(final int opcode, final int operand) {\r\n    if (mv != null) {\r\n        mv.visitIntInsn(opcode, operand);\r\n    }\r\n}\n/**\r\n * Visits a local variable instruction. A local variable instruction is an instruction that loads\r\n * or stores the value of a local variable.\r\n *\r\n * @param opcode the opcode of the local variable instruction to be visited. This opcode is either\r\n *     ILOAD, LLOAD, FLOAD, DLOAD, ALOAD, ISTORE, LSTORE, FSTORE, DSTORE, ASTORE or RET.\r\n * @param varIndex the operand of the instruction to be visited. This operand is the index of a\r\n *     local variable.\r\n */\r\npublic void visitVarInsn(final int opcode, final int varIndex) {\r\n    if (mv != null) {\r\n        mv.visitVarInsn(opcode, varIndex);\r\n    }\r\n}\n/**\r\n * Visits a type instruction. A type instruction is an instruction that takes the internal name of\r\n * a class as parameter (see {@link Type#getInternalName()}).\r\n *\r\n * @param opcode the opcode of the type instruction to be visited. This opcode is either NEW,\r\n *     ANEWARRAY, CHECKCAST or INSTANCEOF.\r\n * @param type the operand of the instruction to be visited. This operand must be the internal\r\n *     name of an object or array class (see {@link Type#getInternalName()}).\r\n */\r\npublic void visitTypeInsn(final int opcode, final String type) {\r\n    if (mv != null) {\r\n        mv.visitTypeInsn(opcode, type);\r\n    }\r\n}\n/**\r\n * Visits a field instruction. A field instruction is an instruction that loads or stores the\r\n * value of a field of an object.\r\n *\r\n * @param opcode the opcode of the type instruction to be visited. This opcode is either\r\n *     GETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD.\r\n * @param owner the internal name of the field's owner class (see {@link Type#getInternalName()}).\r\n * @param name the field's name.\r\n * @param descriptor the field's descriptor (see {@link Type}).\r\n */\r\npublic void visitFieldInsn(final int opcode, final String owner, final String name, final String descriptor) {\r\n    if (mv != null) {\r\n        mv.visitFieldInsn(opcode, owner, name, descriptor);\r\n    }\r\n}\n/**\r\n * Visits a method instruction. A method instruction is an instruction that invokes a method.\r\n *\r\n * @param opcode the opcode of the type instruction to be visited. This opcode is either\r\n *     INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.\r\n * @param owner the internal name of the method's owner class (see {@link\r\n *     Type#getInternalName()}).\r\n * @param name the method's name.\r\n * @param descriptor the method's descriptor (see {@link Type}).\r\n * @deprecated use {@link #visitMethodInsn(int, String, String, String, boolean)} instead.\r\n */\r\n@Deprecated\r\npublic void visitMethodInsn(final int opcode, final String owner, final String name, final String descriptor) {\r\n    int opcodeAndSource = opcode | (api < Opcodes.ASM5 ? Opcodes.SOURCE_DEPRECATED : 0);\r\n    visitMethodInsn(opcodeAndSource, owner, name, descriptor, opcode == Opcodes.INVOKEINTERFACE);\r\n}\n/**\r\n * Visits a method instruction. A method instruction is an instruction that invokes a method.\r\n *\r\n * @param opcode the opcode of the type instruction to be visited. This opcode is either\r\n *     INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.\r\n * @param owner the internal name of the method's owner class (see {@link\r\n *     Type#getInternalName()}).\r\n * @param name the method's name.\r\n * @param descriptor the method's descriptor (see {@link Type}).\r\n * @param isInterface if the method's owner class is an interface.\r\n */\r\npublic void visitMethodInsn(final int opcode, final String owner, final String name, final String descriptor, final boolean isInterface) {\r\n    if (api < Opcodes.ASM5 && (opcode & Opcodes.SOURCE_DEPRECATED) == 0) {\r\n        if (isInterface != (opcode == Opcodes.INVOKEINTERFACE)) {\r\n            throw new UnsupportedOperationException(\"INVOKESPECIAL/STATIC on interfaces requires ASM5\");\r\n        }\r\n        visitMethodInsn(opcode, owner, name, descriptor);\r\n        return;\r\n    }\r\n    if (mv != null) {\r\n        mv.visitMethodInsn(opcode & ~Opcodes.SOURCE_MASK, owner, name, descriptor, isInterface);\r\n    }\r\n}\n/**\r\n * Visits an invokedynamic instruction.\r\n *\r\n * @param name the method's name.\r\n * @param descriptor the method's descriptor (see {@link Type}).\r\n * @param bootstrapMethodHandle the bootstrap method.\r\n * @param bootstrapMethodArguments the bootstrap method constant arguments. Each argument must be\r\n *     an {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String}, {@link\r\n *     Type}, {@link Handle} or {@link ConstantDynamic} value. This method is allowed to modify\r\n *     the content of the array so a caller should expect that this array may change.\r\n */\r\npublic void visitInvokeDynamicInsn(final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\r\n    if (api < Opcodes.ASM5) {\r\n        throw new UnsupportedOperationException(REQUIRES_ASM5);\r\n    }\r\n    if (mv != null) {\r\n        mv.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);\r\n    }\r\n}\n/**\r\n * Visits a jump instruction. A jump instruction is an instruction that may jump to another\r\n * instruction.\r\n *\r\n * @param opcode the opcode of the type instruction to be visited. This opcode is either IFEQ,\r\n *     IFNE, IFLT, IFGE, IFGT, IFLE, IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT,\r\n *     IF_ICMPLE, IF_ACMPEQ, IF_ACMPNE, GOTO, JSR, IFNULL or IFNONNULL.\r\n * @param label the operand of the instruction to be visited. This operand is a label that\r\n *     designates the instruction to which the jump instruction may jump.\r\n */\r\npublic void visitJumpInsn(final int opcode, final Label label) {\r\n    if (mv != null) {\r\n        mv.visitJumpInsn(opcode, label);\r\n    }\r\n}\n/**\r\n * Visits a label. A label designates the instruction that will be visited just after it.\r\n *\r\n * @param label a {@link Label} object.\r\n */\r\npublic void visitLabel(final Label label) {\r\n    if (mv != null) {\r\n        mv.visitLabel(label);\r\n    }\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Special instructions\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Visits a LDC instruction. Note that new constant types may be added in future versions of the\r\n * Java Virtual Machine. To easily detect new constant types, implementations of this method\r\n * should check for unexpected constant types, like this:\r\n *\r\n * <pre>\r\n * if (cst instanceof Integer) {\r\n *     // ...\r\n * } else if (cst instanceof Float) {\r\n *     // ...\r\n * } else if (cst instanceof Long) {\r\n *     // ...\r\n * } else if (cst instanceof Double) {\r\n *     // ...\r\n * } else if (cst instanceof String) {\r\n *     // ...\r\n * } else if (cst instanceof Type) {\r\n *     int sort = ((Type) cst).getSort();\r\n *     if (sort == Type.OBJECT) {\r\n *         // ...\r\n *     } else if (sort == Type.ARRAY) {\r\n *         // ...\r\n *     } else if (sort == Type.METHOD) {\r\n *         // ...\r\n *     } else {\r\n *         // throw an exception\r\n *     }\r\n * } else if (cst instanceof Handle) {\r\n *     // ...\r\n * } else if (cst instanceof ConstantDynamic) {\r\n *     // ...\r\n * } else {\r\n *     // throw an exception\r\n * }\r\n * </pre>\r\n *\r\n * @param value the constant to be loaded on the stack. This parameter must be a non null {@link\r\n *     Integer}, a {@link Float}, a {@link Long}, a {@link Double}, a {@link String}, a {@link\r\n *     Type} of OBJECT or ARRAY sort for {@code .class} constants, for classes whose version is\r\n *     49, a {@link Type} of METHOD sort for MethodType, a {@link Handle} for MethodHandle\r\n *     constants, for classes whose version is 51 or a {@link ConstantDynamic} for a constant\r\n *     dynamic for classes whose version is 55.\r\n */\r\npublic void visitLdcInsn(final Object value) {\r\n    if (api < Opcodes.ASM5 && (value instanceof Handle || (value instanceof Type && ((Type) value).getSort() == Type.METHOD))) {\r\n        throw new UnsupportedOperationException(REQUIRES_ASM5);\r\n    }\r\n    if (api < Opcodes.ASM7 && value instanceof ConstantDynamic) {\r\n        throw new UnsupportedOperationException(\"This feature requires ASM7\");\r\n    }\r\n    if (mv != null) {\r\n        mv.visitLdcInsn(value);\r\n    }\r\n}\n/**\r\n * Visits an IINC instruction.\r\n *\r\n * @param varIndex index of the local variable to be incremented.\r\n * @param increment amount to increment the local variable by.\r\n */\r\npublic void visitIincInsn(final int varIndex, final int increment) {\r\n    if (mv != null) {\r\n        mv.visitIincInsn(varIndex, increment);\r\n    }\r\n}\n/**\r\n * Visits a TABLESWITCH instruction.\r\n *\r\n * @param min the minimum key value.\r\n * @param max the maximum key value.\r\n * @param dflt beginning of the default handler block.\r\n * @param labels beginnings of the handler blocks. {@code labels[i]} is the beginning of the\r\n *     handler block for the {@code min + i} key.\r\n */\r\npublic void visitTableSwitchInsn(final int min, final int max, final Label dflt, final Label... labels) {\r\n    if (mv != null) {\r\n        mv.visitTableSwitchInsn(min, max, dflt, labels);\r\n    }\r\n}\n/**\r\n * Visits a LOOKUPSWITCH instruction.\r\n *\r\n * @param dflt beginning of the default handler block.\r\n * @param keys the values of the keys.\r\n * @param labels beginnings of the handler blocks. {@code labels[i]} is the beginning of the\r\n *     handler block for the {@code keys[i]} key.\r\n */\r\npublic void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {\r\n    if (mv != null) {\r\n        mv.visitLookupSwitchInsn(dflt, keys, labels);\r\n    }\r\n}\n/**\r\n * Visits a MULTIANEWARRAY instruction.\r\n *\r\n * @param descriptor an array type descriptor (see {@link Type}).\r\n * @param numDimensions the number of dimensions of the array to allocate.\r\n */\r\npublic void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {\r\n    if (mv != null) {\r\n        mv.visitMultiANewArrayInsn(descriptor, numDimensions);\r\n    }\r\n}\n/**\r\n * Visits an annotation on an instruction. This method must be called just <i>after</i> the\r\n * annotated instruction. It can be called several times for the same instruction.\r\n *\r\n * @param typeRef a reference to the annotated type. The sort of this type reference must be\r\n *     {@link TypeReference#INSTANCEOF}, {@link TypeReference#NEW}, {@link\r\n *     TypeReference#CONSTRUCTOR_REFERENCE}, {@link TypeReference#METHOD_REFERENCE}, {@link\r\n *     TypeReference#CAST}, {@link TypeReference#CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT}, {@link\r\n *     TypeReference#METHOD_INVOCATION_TYPE_ARGUMENT}, {@link\r\n *     TypeReference#CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or {@link\r\n *     TypeReference#METHOD_REFERENCE_TYPE_ARGUMENT}. See {@link TypeReference}.\r\n * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\r\n *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\r\n *     'typeRef' as a whole.\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param visible {@literal true} if the annotation is visible at runtime.\r\n * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\r\n *     interested in visiting this annotation.\r\n */\r\npublic AnnotationVisitor visitInsnAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\r\n    if (api < Opcodes.ASM5) {\r\n        throw new UnsupportedOperationException(REQUIRES_ASM5);\r\n    }\r\n    if (mv != null) {\r\n        return mv.visitInsnAnnotation(typeRef, typePath, descriptor, visible);\r\n    }\r\n    return null;\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Exceptions table entries, debug information, max stack and max locals\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Visits a try catch block.\r\n *\r\n * @param start the beginning of the exception handler's scope (inclusive).\r\n * @param end the end of the exception handler's scope (exclusive).\r\n * @param handler the beginning of the exception handler's code.\r\n * @param type the internal name of the type of exceptions handled by the handler (see {@link\r\n *     Type#getInternalName()}), or {@literal null} to catch any exceptions (for \"finally\"\r\n *     blocks).\r\n * @throws IllegalArgumentException if one of the labels has already been visited by this visitor\r\n *     (by the {@link #visitLabel} method).\r\n */\r\npublic void visitTryCatchBlock(final Label start, final Label end, final Label handler, final String type) {\r\n    if (mv != null) {\r\n        mv.visitTryCatchBlock(start, end, handler, type);\r\n    }\r\n}\n/**\r\n * Visits an annotation on an exception handler type. This method must be called <i>after</i> the\r\n * {@link #visitTryCatchBlock} for the annotated exception handler. It can be called several times\r\n * for the same exception handler.\r\n *\r\n * @param typeRef a reference to the annotated type. The sort of this type reference must be\r\n *     {@link TypeReference#EXCEPTION_PARAMETER}. See {@link TypeReference}.\r\n * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\r\n *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\r\n *     'typeRef' as a whole.\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param visible {@literal true} if the annotation is visible at runtime.\r\n * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\r\n *     interested in visiting this annotation.\r\n */\r\npublic AnnotationVisitor visitTryCatchAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\r\n    if (api < Opcodes.ASM5) {\r\n        throw new UnsupportedOperationException(REQUIRES_ASM5);\r\n    }\r\n    if (mv != null) {\r\n        return mv.visitTryCatchAnnotation(typeRef, typePath, descriptor, visible);\r\n    }\r\n    return null;\r\n}\n/**\r\n * Visits a local variable declaration.\r\n *\r\n * @param name the name of a local variable.\r\n * @param descriptor the type descriptor of this local variable.\r\n * @param signature the type signature of this local variable. May be {@literal null} if the local\r\n *     variable type does not use generic types.\r\n * @param start the first instruction corresponding to the scope of this local variable\r\n *     (inclusive).\r\n * @param end the last instruction corresponding to the scope of this local variable (exclusive).\r\n * @param index the local variable's index.\r\n * @throws IllegalArgumentException if one of the labels has not already been visited by this\r\n *     visitor (by the {@link #visitLabel} method).\r\n */\r\npublic void visitLocalVariable(final String name, final String descriptor, final String signature, final Label start, final Label end, final int index) {\r\n    if (mv != null) {\r\n        mv.visitLocalVariable(name, descriptor, signature, start, end, index);\r\n    }\r\n}\n/**\r\n * Visits an annotation on a local variable type.\r\n *\r\n * @param typeRef a reference to the annotated type. The sort of this type reference must be\r\n *     {@link TypeReference#LOCAL_VARIABLE} or {@link TypeReference#RESOURCE_VARIABLE}. See {@link\r\n *     TypeReference}.\r\n * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\r\n *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\r\n *     'typeRef' as a whole.\r\n * @param start the fist instructions corresponding to the continuous ranges that make the scope\r\n *     of this local variable (inclusive).\r\n * @param end the last instructions corresponding to the continuous ranges that make the scope of\r\n *     this local variable (exclusive). This array must have the same size as the 'start' array.\r\n * @param index the local variable's index in each range. This array must have the same size as\r\n *     the 'start' array.\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param visible {@literal true} if the annotation is visible at runtime.\r\n * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\r\n *     interested in visiting this annotation.\r\n */\r\npublic AnnotationVisitor visitLocalVariableAnnotation(final int typeRef, final TypePath typePath, final Label[] start, final Label[] end, final int[] index, final String descriptor, final boolean visible) {\r\n    if (api < Opcodes.ASM5) {\r\n        throw new UnsupportedOperationException(REQUIRES_ASM5);\r\n    }\r\n    if (mv != null) {\r\n        return mv.visitLocalVariableAnnotation(typeRef, typePath, start, end, index, descriptor, visible);\r\n    }\r\n    return null;\r\n}\n/**\r\n * Visits a line number declaration.\r\n *\r\n * @param line a line number. This number refers to the source file from which the class was\r\n *     compiled.\r\n * @param start the first instruction corresponding to this line number.\r\n * @throws IllegalArgumentException if {@code start} has not already been visited by this visitor\r\n *     (by the {@link #visitLabel} method).\r\n */\r\npublic void visitLineNumber(final int line, final Label start) {\r\n    if (mv != null) {\r\n        mv.visitLineNumber(line, start);\r\n    }\r\n}\n/**\r\n * Visits the maximum stack size and the maximum number of local variables of the method.\r\n *\r\n * @param maxStack maximum stack size of the method.\r\n * @param maxLocals maximum number of local variables for the method.\r\n */\r\npublic void visitMaxs(final int maxStack, final int maxLocals) {\r\n    if (mv != null) {\r\n        mv.visitMaxs(maxStack, maxLocals);\r\n    }\r\n}\n/**\r\n * Visits the end of the method. This method, which is the last one to be called, is used to\r\n * inform the visitor that all the annotations and attributes of the method have been visited.\r\n */\r\npublic void visitEnd() {\r\n    if (mv != null) {\r\n        mv.visitEnd();\r\n    }\r\n}",
    "comment": "\n * A visitor to visit a Java method. The methods of this class must be called in the following\n * order: ( {@code visitParameter} )* [ {@code visitAnnotationDefault} ] ( {@code visitAnnotation} |\n * {@code visitAnnotableParameterCount} | {@code visitParameterAnnotation} | {@code\n * visitTypeAnnotation} | {@code visitAttribute} )* [ {@code visitCode} ( {@code visitFrame} |\n * {@code visit<i>X</i>Insn} | {@code visitLabel} | {@code visitInsnAnnotation} | {@code\n * visitTryCatchBlock} | {@code visitTryCatchAnnotation} | {@code visitLocalVariable} | {@code\n * visitLocalVariableAnnotation} | {@code visitLineNumber} | {@code visitAttribute} )* {@code\n * visitMaxs} ] {@code visitEnd}. In addition, the {@code visit<i>X</i>Insn} and {@code visitLabel}\n * methods must be called in the sequential order of the bytecode instructions of the visited code,\n * {@code visitInsnAnnotation} must be called <i>after</i> the annotated instruction, {@code\n * visitTryCatchBlock} must be called <i>before</i> the labels passed as arguments have been\n * visited, {@code visitTryCatchBlockAnnotation} must be called <i>after</i> the corresponding try\n * catch block has been visited, and the {@code visitLocalVariable}, {@code\n * visitLocalVariableAnnotation} and {@code visitLineNumber} methods must be called <i>after</i> the\n * labels passed as arguments have been visited. Finally, the {@code visitAttribute} method must be\n * called before {@code visitCode} for non-code attributes, and after it for code attributes.\n *\n * @author Eric Bruneton\n "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#getDelegate()",
    "entityType": "method",
    "code": "/**\r\n * The method visitor to which this visitor must delegate method calls. May be {@literal null}.\r\n *\r\n * @return the method visitor to which this visitor must delegate method calls, or {@literal\r\n *     null}.\r\n */\r\npublic MethodVisitor getDelegate() {\r\n    return mv;\r\n}",
    "comment": "\n   * The method visitor to which this visitor must delegate method calls. May be {@literal null}.\n   *\n   * @return the method visitor to which this visitor must delegate method calls, or {@literal\n   *     null}.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitParameter(String,int)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Parameters, annotations and non standard attributes\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Visits a parameter of this method.\r\n *\r\n * @param name parameter name or {@literal null} if none is provided.\r\n * @param access the parameter's access flags, only {@code ACC_FINAL}, {@code ACC_SYNTHETIC}\r\n *     or/and {@code ACC_MANDATED} are allowed (see {@link Opcodes}).\r\n */\r\npublic void visitParameter(final String name, final int access) {\r\n    if (api < Opcodes.ASM5) {\r\n        throw new UnsupportedOperationException(REQUIRES_ASM5);\r\n    }\r\n    if (mv != null) {\r\n        mv.visitParameter(name, access);\r\n    }\r\n}",
    "comment": "\n   * Visits a parameter of this method.\n   *\n   * @param name parameter name or {@literal null} if none is provided.\n   * @param access the parameter's access flags, only {@code ACC_FINAL}, {@code ACC_SYNTHETIC}\n   *     or/and {@code ACC_MANDATED} are allowed (see {@link Opcodes}).\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitAnnotationDefault()",
    "entityType": "method",
    "code": "/**\r\n * Visits the default value of this annotation interface method.\r\n *\r\n * @return a visitor to the visit the actual default value of this annotation interface method, or\r\n *     {@literal null} if this visitor is not interested in visiting this default value. The\r\n *     'name' parameters passed to the methods of this annotation visitor are ignored. Moreover,\r\n *     exactly one visit method must be called on this annotation visitor, followed by visitEnd.\r\n */\r\npublic AnnotationVisitor visitAnnotationDefault() {\r\n    if (mv != null) {\r\n        return mv.visitAnnotationDefault();\r\n    }\r\n    return null;\r\n}",
    "comment": "\n   * Visits the default value of this annotation interface method.\n   *\n   * @return a visitor to the visit the actual default value of this annotation interface method, or\n   *     {@literal null} if this visitor is not interested in visiting this default value. The\n   *     'name' parameters passed to the methods of this annotation visitor are ignored. Moreover,\n   *     exactly one visit method must be called on this annotation visitor, followed by visitEnd.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitAnnotation(String,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Visits an annotation of this method.\r\n *\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param visible {@literal true} if the annotation is visible at runtime.\r\n * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\r\n *     interested in visiting this annotation.\r\n */\r\npublic AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\r\n    if (mv != null) {\r\n        return mv.visitAnnotation(descriptor, visible);\r\n    }\r\n    return null;\r\n}",
    "comment": "\n   * Visits an annotation of this method.\n   *\n   * @param descriptor the class descriptor of the annotation class.\n   * @param visible {@literal true} if the annotation is visible at runtime.\n   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\n   *     interested in visiting this annotation.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitTypeAnnotation(int,TypePath,String,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Visits an annotation on a type in the method signature.\r\n *\r\n * @param typeRef a reference to the annotated type. The sort of this type reference must be\r\n *     {@link TypeReference#METHOD_TYPE_PARAMETER}, {@link\r\n *     TypeReference#METHOD_TYPE_PARAMETER_BOUND}, {@link TypeReference#METHOD_RETURN}, {@link\r\n *     TypeReference#METHOD_RECEIVER}, {@link TypeReference#METHOD_FORMAL_PARAMETER} or {@link\r\n *     TypeReference#THROWS}. See {@link TypeReference}.\r\n * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\r\n *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\r\n *     'typeRef' as a whole.\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param visible {@literal true} if the annotation is visible at runtime.\r\n * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\r\n *     interested in visiting this annotation.\r\n */\r\npublic AnnotationVisitor visitTypeAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\r\n    if (api < Opcodes.ASM5) {\r\n        throw new UnsupportedOperationException(REQUIRES_ASM5);\r\n    }\r\n    if (mv != null) {\r\n        return mv.visitTypeAnnotation(typeRef, typePath, descriptor, visible);\r\n    }\r\n    return null;\r\n}",
    "comment": "\n   * Visits an annotation on a type in the method signature.\n   *\n   * @param typeRef a reference to the annotated type. The sort of this type reference must be\n   *     {@link TypeReference#METHOD_TYPE_PARAMETER}, {@link\n   *     TypeReference#METHOD_TYPE_PARAMETER_BOUND}, {@link TypeReference#METHOD_RETURN}, {@link\n   *     TypeReference#METHOD_RECEIVER}, {@link TypeReference#METHOD_FORMAL_PARAMETER} or {@link\n   *     TypeReference#THROWS}. See {@link TypeReference}.\n   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\n   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\n   *     'typeRef' as a whole.\n   * @param descriptor the class descriptor of the annotation class.\n   * @param visible {@literal true} if the annotation is visible at runtime.\n   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\n   *     interested in visiting this annotation.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitAnnotableParameterCount(int,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Visits the number of method parameters that can have annotations. By default (i.e. when this\r\n * method is not called), all the method parameters defined by the method descriptor can have\r\n * annotations.\r\n *\r\n * @param parameterCount the number of method parameters than can have annotations. This number\r\n *     must be less or equal than the number of parameter types in the method descriptor. It can\r\n *     be strictly less when a method has synthetic parameters and when these parameters are\r\n *     ignored when computing parameter indices for the purpose of parameter annotations (see\r\n *     https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.18).\r\n * @param visible {@literal true} to define the number of method parameters that can have\r\n *     annotations visible at runtime, {@literal false} to define the number of method parameters\r\n *     that can have annotations invisible at runtime.\r\n */\r\npublic void visitAnnotableParameterCount(final int parameterCount, final boolean visible) {\r\n    if (mv != null) {\r\n        mv.visitAnnotableParameterCount(parameterCount, visible);\r\n    }\r\n}",
    "comment": "\n   * Visits the number of method parameters that can have annotations. By default (i.e. when this\n   * method is not called), all the method parameters defined by the method descriptor can have\n   * annotations.\n   *\n   * @param parameterCount the number of method parameters than can have annotations. This number\n   *     must be less or equal than the number of parameter types in the method descriptor. It can\n   *     be strictly less when a method has synthetic parameters and when these parameters are\n   *     ignored when computing parameter indices for the purpose of parameter annotations (see\n   *     https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.18).\n   * @param visible {@literal true} to define the number of method parameters that can have\n   *     annotations visible at runtime, {@literal false} to define the number of method parameters\n   *     that can have annotations invisible at runtime.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitParameterAnnotation(int,String,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Visits an annotation of a parameter this method.\r\n *\r\n * @param parameter the parameter index. This index must be strictly smaller than the number of\r\n *     parameters in the method descriptor, and strictly smaller than the parameter count\r\n *     specified in {@link #visitAnnotableParameterCount}. Important note: <i>a parameter index i\r\n *     is not required to correspond to the i'th parameter descriptor in the method\r\n *     descriptor</i>, in particular in case of synthetic parameters (see\r\n *     https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.18).\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param visible {@literal true} if the annotation is visible at runtime.\r\n * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\r\n *     interested in visiting this annotation.\r\n */\r\npublic AnnotationVisitor visitParameterAnnotation(final int parameter, final String descriptor, final boolean visible) {\r\n    if (mv != null) {\r\n        return mv.visitParameterAnnotation(parameter, descriptor, visible);\r\n    }\r\n    return null;\r\n}",
    "comment": "\n   * Visits an annotation of a parameter this method.\n   *\n   * @param parameter the parameter index. This index must be strictly smaller than the number of\n   *     parameters in the method descriptor, and strictly smaller than the parameter count\n   *     specified in {@link #visitAnnotableParameterCount}. Important note: <i>a parameter index i\n   *     is not required to correspond to the i'th parameter descriptor in the method\n   *     descriptor</i>, in particular in case of synthetic parameters (see\n   *     https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.18).\n   * @param descriptor the class descriptor of the annotation class.\n   * @param visible {@literal true} if the annotation is visible at runtime.\n   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\n   *     interested in visiting this annotation.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitAttribute(Attribute)",
    "entityType": "method",
    "code": "/**\r\n * Visits a non standard attribute of this method.\r\n *\r\n * @param attribute an attribute.\r\n */\r\npublic void visitAttribute(final Attribute attribute) {\r\n    if (mv != null) {\r\n        mv.visitAttribute(attribute);\r\n    }\r\n}",
    "comment": "\n   * Visits a non standard attribute of this method.\n   *\n   * @param attribute an attribute.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitCode()",
    "entityType": "method",
    "code": "/**\r\n * Starts the visit of the method's code, if any (i.e. non abstract method).\r\n */\r\npublic void visitCode() {\r\n    if (mv != null) {\r\n        mv.visitCode();\r\n    }\r\n}",
    "comment": " Starts the visit of the method's code, if any (i.e. non abstract method). "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitFrame(int,int,Object[],int,Object[])",
    "entityType": "method",
    "code": "/**\r\n * Visits the current state of the local variables and operand stack elements. This method must(*)\r\n * be called <i>just before</i> any instruction <b>i</b> that follows an unconditional branch\r\n * instruction such as GOTO or THROW, that is the target of a jump instruction, or that starts an\r\n * exception handler block. The visited types must describe the values of the local variables and\r\n * of the operand stack elements <i>just before</i> <b>i</b> is executed.<br>\r\n * <br>\r\n * (*) this is mandatory only for classes whose version is greater than or equal to {@link\r\n * Opcodes#V1_6}. <br>\r\n * <br>\r\n * The frames of a method must be given either in expanded form, or in compressed form (all frames\r\n * must use the same format, i.e. you must not mix expanded and compressed frames within a single\r\n * method):\r\n *\r\n * <ul>\r\n *   <li>In expanded form, all frames must have the F_NEW type.\r\n *   <li>In compressed form, frames are basically \"deltas\" from the state of the previous frame:\r\n *       <ul>\r\n *         <li>{@link Opcodes#F_SAME} representing frame with exactly the same locals as the\r\n *             previous frame and with the empty stack.\r\n *         <li>{@link Opcodes#F_SAME1} representing frame with exactly the same locals as the\r\n *             previous frame and with single value on the stack ( <code>numStack</code> is 1 and\r\n *             <code>stack[0]</code> contains value for the type of the stack item).\r\n *         <li>{@link Opcodes#F_APPEND} representing frame with current locals are the same as the\r\n *             locals in the previous frame, except that additional locals are defined (<code>\r\n *             numLocal</code> is 1, 2 or 3 and <code>local</code> elements contains values\r\n *             representing added types).\r\n *         <li>{@link Opcodes#F_CHOP} representing frame with current locals are the same as the\r\n *             locals in the previous frame, except that the last 1-3 locals are absent and with\r\n *             the empty stack (<code>numLocal</code> is 1, 2 or 3).\r\n *         <li>{@link Opcodes#F_FULL} representing complete frame data.\r\n *       </ul>\r\n * </ul>\r\n *\r\n * <br>\r\n * In both cases the first frame, corresponding to the method's parameters and access flags, is\r\n * implicit and must not be visited. Also, it is illegal to visit two or more frames for the same\r\n * code location (i.e., at least one instruction must be visited between two calls to visitFrame).\r\n *\r\n * @param type the type of this stack map frame. Must be {@link Opcodes#F_NEW} for expanded\r\n *     frames, or {@link Opcodes#F_FULL}, {@link Opcodes#F_APPEND}, {@link Opcodes#F_CHOP}, {@link\r\n *     Opcodes#F_SAME} or {@link Opcodes#F_APPEND}, {@link Opcodes#F_SAME1} for compressed frames.\r\n * @param numLocal the number of local variables in the visited frame. Long and double values\r\n *     count for one variable.\r\n * @param local the local variable types in this frame. This array must not be modified. Primitive\r\n *     types are represented by {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link\r\n *     Opcodes#FLOAT}, {@link Opcodes#LONG}, {@link Opcodes#DOUBLE}, {@link Opcodes#NULL} or\r\n *     {@link Opcodes#UNINITIALIZED_THIS} (long and double are represented by a single element).\r\n *     Reference types are represented by String objects (representing internal names, see {@link\r\n *     Type#getInternalName()}), and uninitialized types by Label objects (this label designates\r\n *     the NEW instruction that created this uninitialized value).\r\n * @param numStack the number of operand stack elements in the visited frame. Long and double\r\n *     values count for one stack element.\r\n * @param stack the operand stack types in this frame. This array must not be modified. Its\r\n *     content has the same format as the \"local\" array.\r\n * @throws IllegalStateException if a frame is visited just after another one, without any\r\n *     instruction between the two (unless this frame is a Opcodes#F_SAME frame, in which case it\r\n *     is silently ignored).\r\n */\r\npublic void visitFrame(final int type, final int numLocal, final Object[] local, final int numStack, final Object[] stack) {\r\n    if (mv != null) {\r\n        mv.visitFrame(type, numLocal, local, numStack, stack);\r\n    }\r\n}",
    "comment": "\n   * Visits the current state of the local variables and operand stack elements. This method must(*)\n   * be called <i>just before</i> any instruction <b>i</b> that follows an unconditional branch\n   * instruction such as GOTO or THROW, that is the target of a jump instruction, or that starts an\n   * exception handler block. The visited types must describe the values of the local variables and\n   * of the operand stack elements <i>just before</i> <b>i</b> is executed.<br>\n   * <br>\n   * (*) this is mandatory only for classes whose version is greater than or equal to {@link\n   * Opcodes#V1_6}. <br>\n   * <br>\n   * The frames of a method must be given either in expanded form, or in compressed form (all frames\n   * must use the same format, i.e. you must not mix expanded and compressed frames within a single\n   * method):\n   *\n   * <ul>\n   *   <li>In expanded form, all frames must have the F_NEW type.\n   *   <li>In compressed form, frames are basically \"deltas\" from the state of the previous frame:\n   *       <ul>\n   *         <li>{@link Opcodes#F_SAME} representing frame with exactly the same locals as the\n   *             previous frame and with the empty stack.\n   *         <li>{@link Opcodes#F_SAME1} representing frame with exactly the same locals as the\n   *             previous frame and with single value on the stack ( <code>numStack</code> is 1 and\n   *             <code>stack[0]</code> contains value for the type of the stack item).\n   *         <li>{@link Opcodes#F_APPEND} representing frame with current locals are the same as the\n   *             locals in the previous frame, except that additional locals are defined (<code>\n   *             numLocal</code> is 1, 2 or 3 and <code>local</code> elements contains values\n   *             representing added types).\n   *         <li>{@link Opcodes#F_CHOP} representing frame with current locals are the same as the\n   *             locals in the previous frame, except that the last 1-3 locals are absent and with\n   *             the empty stack (<code>numLocal</code> is 1, 2 or 3).\n   *         <li>{@link Opcodes#F_FULL} representing complete frame data.\n   *       </ul>\n   * </ul>\n   *\n   * <br>\n   * In both cases the first frame, corresponding to the method's parameters and access flags, is\n   * implicit and must not be visited. Also, it is illegal to visit two or more frames for the same\n   * code location (i.e., at least one instruction must be visited between two calls to visitFrame).\n   *\n   * @param type the type of this stack map frame. Must be {@link Opcodes#F_NEW} for expanded\n   *     frames, or {@link Opcodes#F_FULL}, {@link Opcodes#F_APPEND}, {@link Opcodes#F_CHOP}, {@link\n   *     Opcodes#F_SAME} or {@link Opcodes#F_APPEND}, {@link Opcodes#F_SAME1} for compressed frames.\n   * @param numLocal the number of local variables in the visited frame. Long and double values\n   *     count for one variable.\n   * @param local the local variable types in this frame. This array must not be modified. Primitive\n   *     types are represented by {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link\n   *     Opcodes#FLOAT}, {@link Opcodes#LONG}, {@link Opcodes#DOUBLE}, {@link Opcodes#NULL} or\n   *     {@link Opcodes#UNINITIALIZED_THIS} (long and double are represented by a single element).\n   *     Reference types are represented by String objects (representing internal names, see {@link\n   *     Type#getInternalName()}), and uninitialized types by Label objects (this label designates\n   *     the NEW instruction that created this uninitialized value).\n   * @param numStack the number of operand stack elements in the visited frame. Long and double\n   *     values count for one stack element.\n   * @param stack the operand stack types in this frame. This array must not be modified. Its\n   *     content has the same format as the \"local\" array.\n   * @throws IllegalStateException if a frame is visited just after another one, without any\n   *     instruction between the two (unless this frame is a Opcodes#F_SAME frame, in which case it\n   *     is silently ignored).\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitInsn(int)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Normal instructions\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Visits a zero operand instruction.\r\n *\r\n * @param opcode the opcode of the instruction to be visited. This opcode is either NOP,\r\n *     ACONST_NULL, ICONST_M1, ICONST_0, ICONST_1, ICONST_2, ICONST_3, ICONST_4, ICONST_5,\r\n *     LCONST_0, LCONST_1, FCONST_0, FCONST_1, FCONST_2, DCONST_0, DCONST_1, IALOAD, LALOAD,\r\n *     FALOAD, DALOAD, AALOAD, BALOAD, CALOAD, SALOAD, IASTORE, LASTORE, FASTORE, DASTORE,\r\n *     AASTORE, BASTORE, CASTORE, SASTORE, POP, POP2, DUP, DUP_X1, DUP_X2, DUP2, DUP2_X1, DUP2_X2,\r\n *     SWAP, IADD, LADD, FADD, DADD, ISUB, LSUB, FSUB, DSUB, IMUL, LMUL, FMUL, DMUL, IDIV, LDIV,\r\n *     FDIV, DDIV, IREM, LREM, FREM, DREM, INEG, LNEG, FNEG, DNEG, ISHL, LSHL, ISHR, LSHR, IUSHR,\r\n *     LUSHR, IAND, LAND, IOR, LOR, IXOR, LXOR, I2L, I2F, I2D, L2I, L2F, L2D, F2I, F2L, F2D, D2I,\r\n *     D2L, D2F, I2B, I2C, I2S, LCMP, FCMPL, FCMPG, DCMPL, DCMPG, IRETURN, LRETURN, FRETURN,\r\n *     DRETURN, ARETURN, RETURN, ARRAYLENGTH, ATHROW, MONITORENTER, or MONITOREXIT.\r\n */\r\npublic void visitInsn(final int opcode) {\r\n    if (mv != null) {\r\n        mv.visitInsn(opcode);\r\n    }\r\n}",
    "comment": "\n   * Visits a zero operand instruction.\n   *\n   * @param opcode the opcode of the instruction to be visited. This opcode is either NOP,\n   *     ACONST_NULL, ICONST_M1, ICONST_0, ICONST_1, ICONST_2, ICONST_3, ICONST_4, ICONST_5,\n   *     LCONST_0, LCONST_1, FCONST_0, FCONST_1, FCONST_2, DCONST_0, DCONST_1, IALOAD, LALOAD,\n   *     FALOAD, DALOAD, AALOAD, BALOAD, CALOAD, SALOAD, IASTORE, LASTORE, FASTORE, DASTORE,\n   *     AASTORE, BASTORE, CASTORE, SASTORE, POP, POP2, DUP, DUP_X1, DUP_X2, DUP2, DUP2_X1, DUP2_X2,\n   *     SWAP, IADD, LADD, FADD, DADD, ISUB, LSUB, FSUB, DSUB, IMUL, LMUL, FMUL, DMUL, IDIV, LDIV,\n   *     FDIV, DDIV, IREM, LREM, FREM, DREM, INEG, LNEG, FNEG, DNEG, ISHL, LSHL, ISHR, LSHR, IUSHR,\n   *     LUSHR, IAND, LAND, IOR, LOR, IXOR, LXOR, I2L, I2F, I2D, L2I, L2F, L2D, F2I, F2L, F2D, D2I,\n   *     D2L, D2F, I2B, I2C, I2S, LCMP, FCMPL, FCMPG, DCMPL, DCMPG, IRETURN, LRETURN, FRETURN,\n   *     DRETURN, ARETURN, RETURN, ARRAYLENGTH, ATHROW, MONITORENTER, or MONITOREXIT.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitIntInsn(int,int)",
    "entityType": "method",
    "code": "/**\r\n * Visits an instruction with a single int operand.\r\n *\r\n * @param opcode the opcode of the instruction to be visited. This opcode is either BIPUSH, SIPUSH\r\n *     or NEWARRAY.\r\n * @param operand the operand of the instruction to be visited.<br>\r\n *     When opcode is BIPUSH, operand value should be between Byte.MIN_VALUE and Byte.MAX_VALUE.\r\n *     <br>\r\n *     When opcode is SIPUSH, operand value should be between Short.MIN_VALUE and Short.MAX_VALUE.\r\n *     <br>\r\n *     When opcode is NEWARRAY, operand value should be one of {@link Opcodes#T_BOOLEAN}, {@link\r\n *     Opcodes#T_CHAR}, {@link Opcodes#T_FLOAT}, {@link Opcodes#T_DOUBLE}, {@link Opcodes#T_BYTE},\r\n *     {@link Opcodes#T_SHORT}, {@link Opcodes#T_INT} or {@link Opcodes#T_LONG}.\r\n */\r\npublic void visitIntInsn(final int opcode, final int operand) {\r\n    if (mv != null) {\r\n        mv.visitIntInsn(opcode, operand);\r\n    }\r\n}",
    "comment": "\n   * Visits an instruction with a single int operand.\n   *\n   * @param opcode the opcode of the instruction to be visited. This opcode is either BIPUSH, SIPUSH\n   *     or NEWARRAY.\n   * @param operand the operand of the instruction to be visited.<br>\n   *     When opcode is BIPUSH, operand value should be between Byte.MIN_VALUE and Byte.MAX_VALUE.\n   *     <br>\n   *     When opcode is SIPUSH, operand value should be between Short.MIN_VALUE and Short.MAX_VALUE.\n   *     <br>\n   *     When opcode is NEWARRAY, operand value should be one of {@link Opcodes#T_BOOLEAN}, {@link\n   *     Opcodes#T_CHAR}, {@link Opcodes#T_FLOAT}, {@link Opcodes#T_DOUBLE}, {@link Opcodes#T_BYTE},\n   *     {@link Opcodes#T_SHORT}, {@link Opcodes#T_INT} or {@link Opcodes#T_LONG}.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitVarInsn(int,int)",
    "entityType": "method",
    "code": "/**\r\n * Visits a local variable instruction. A local variable instruction is an instruction that loads\r\n * or stores the value of a local variable.\r\n *\r\n * @param opcode the opcode of the local variable instruction to be visited. This opcode is either\r\n *     ILOAD, LLOAD, FLOAD, DLOAD, ALOAD, ISTORE, LSTORE, FSTORE, DSTORE, ASTORE or RET.\r\n * @param varIndex the operand of the instruction to be visited. This operand is the index of a\r\n *     local variable.\r\n */\r\npublic void visitVarInsn(final int opcode, final int varIndex) {\r\n    if (mv != null) {\r\n        mv.visitVarInsn(opcode, varIndex);\r\n    }\r\n}",
    "comment": "\n   * Visits a local variable instruction. A local variable instruction is an instruction that loads\n   * or stores the value of a local variable.\n   *\n   * @param opcode the opcode of the local variable instruction to be visited. This opcode is either\n   *     ILOAD, LLOAD, FLOAD, DLOAD, ALOAD, ISTORE, LSTORE, FSTORE, DSTORE, ASTORE or RET.\n   * @param varIndex the operand of the instruction to be visited. This operand is the index of a\n   *     local variable.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitTypeInsn(int,String)",
    "entityType": "method",
    "code": "/**\r\n * Visits a type instruction. A type instruction is an instruction that takes the internal name of\r\n * a class as parameter (see {@link Type#getInternalName()}).\r\n *\r\n * @param opcode the opcode of the type instruction to be visited. This opcode is either NEW,\r\n *     ANEWARRAY, CHECKCAST or INSTANCEOF.\r\n * @param type the operand of the instruction to be visited. This operand must be the internal\r\n *     name of an object or array class (see {@link Type#getInternalName()}).\r\n */\r\npublic void visitTypeInsn(final int opcode, final String type) {\r\n    if (mv != null) {\r\n        mv.visitTypeInsn(opcode, type);\r\n    }\r\n}",
    "comment": "\n   * Visits a type instruction. A type instruction is an instruction that takes the internal name of\n   * a class as parameter (see {@link Type#getInternalName()}).\n   *\n   * @param opcode the opcode of the type instruction to be visited. This opcode is either NEW,\n   *     ANEWARRAY, CHECKCAST or INSTANCEOF.\n   * @param type the operand of the instruction to be visited. This operand must be the internal\n   *     name of an object or array class (see {@link Type#getInternalName()}).\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitFieldInsn(int,String,String,String)",
    "entityType": "method",
    "code": "/**\r\n * Visits a field instruction. A field instruction is an instruction that loads or stores the\r\n * value of a field of an object.\r\n *\r\n * @param opcode the opcode of the type instruction to be visited. This opcode is either\r\n *     GETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD.\r\n * @param owner the internal name of the field's owner class (see {@link Type#getInternalName()}).\r\n * @param name the field's name.\r\n * @param descriptor the field's descriptor (see {@link Type}).\r\n */\r\npublic void visitFieldInsn(final int opcode, final String owner, final String name, final String descriptor) {\r\n    if (mv != null) {\r\n        mv.visitFieldInsn(opcode, owner, name, descriptor);\r\n    }\r\n}",
    "comment": "\n   * Visits a field instruction. A field instruction is an instruction that loads or stores the\n   * value of a field of an object.\n   *\n   * @param opcode the opcode of the type instruction to be visited. This opcode is either\n   *     GETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD.\n   * @param owner the internal name of the field's owner class (see {@link Type#getInternalName()}).\n   * @param name the field's name.\n   * @param descriptor the field's descriptor (see {@link Type}).\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitMethodInsn(int,String,String,String)",
    "entityType": "method",
    "code": "/**\r\n * Visits a method instruction. A method instruction is an instruction that invokes a method.\r\n *\r\n * @param opcode the opcode of the type instruction to be visited. This opcode is either\r\n *     INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.\r\n * @param owner the internal name of the method's owner class (see {@link\r\n *     Type#getInternalName()}).\r\n * @param name the method's name.\r\n * @param descriptor the method's descriptor (see {@link Type}).\r\n * @deprecated use {@link #visitMethodInsn(int, String, String, String, boolean)} instead.\r\n */\r\n@Deprecated\r\npublic void visitMethodInsn(final int opcode, final String owner, final String name, final String descriptor) {\r\n    int opcodeAndSource = opcode | (api < Opcodes.ASM5 ? Opcodes.SOURCE_DEPRECATED : 0);\r\n    visitMethodInsn(opcodeAndSource, owner, name, descriptor, opcode == Opcodes.INVOKEINTERFACE);\r\n}",
    "comment": "\n   * Visits a method instruction. A method instruction is an instruction that invokes a method.\n   *\n   * @param opcode the opcode of the type instruction to be visited. This opcode is either\n   *     INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.\n   * @param owner the internal name of the method's owner class (see {@link\n   *     Type#getInternalName()}).\n   * @param name the method's name.\n   * @param descriptor the method's descriptor (see {@link Type}).\n   * @deprecated use {@link #visitMethodInsn(int, String, String, String, boolean)} instead.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitMethodInsn(int,String,String,String,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Visits a method instruction. A method instruction is an instruction that invokes a method.\r\n *\r\n * @param opcode the opcode of the type instruction to be visited. This opcode is either\r\n *     INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.\r\n * @param owner the internal name of the method's owner class (see {@link\r\n *     Type#getInternalName()}).\r\n * @param name the method's name.\r\n * @param descriptor the method's descriptor (see {@link Type}).\r\n * @param isInterface if the method's owner class is an interface.\r\n */\r\npublic void visitMethodInsn(final int opcode, final String owner, final String name, final String descriptor, final boolean isInterface) {\r\n    if (api < Opcodes.ASM5 && (opcode & Opcodes.SOURCE_DEPRECATED) == 0) {\r\n        if (isInterface != (opcode == Opcodes.INVOKEINTERFACE)) {\r\n            throw new UnsupportedOperationException(\"INVOKESPECIAL/STATIC on interfaces requires ASM5\");\r\n        }\r\n        visitMethodInsn(opcode, owner, name, descriptor);\r\n        return;\r\n    }\r\n    if (mv != null) {\r\n        mv.visitMethodInsn(opcode & ~Opcodes.SOURCE_MASK, owner, name, descriptor, isInterface);\r\n    }\r\n}",
    "comment": "\n   * Visits a method instruction. A method instruction is an instruction that invokes a method.\n   *\n   * @param opcode the opcode of the type instruction to be visited. This opcode is either\n   *     INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.\n   * @param owner the internal name of the method's owner class (see {@link\n   *     Type#getInternalName()}).\n   * @param name the method's name.\n   * @param descriptor the method's descriptor (see {@link Type}).\n   * @param isInterface if the method's owner class is an interface.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitInvokeDynamicInsn(String,String,Handle,Object)",
    "entityType": "method",
    "code": "/**\r\n * Visits an invokedynamic instruction.\r\n *\r\n * @param name the method's name.\r\n * @param descriptor the method's descriptor (see {@link Type}).\r\n * @param bootstrapMethodHandle the bootstrap method.\r\n * @param bootstrapMethodArguments the bootstrap method constant arguments. Each argument must be\r\n *     an {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String}, {@link\r\n *     Type}, {@link Handle} or {@link ConstantDynamic} value. This method is allowed to modify\r\n *     the content of the array so a caller should expect that this array may change.\r\n */\r\npublic void visitInvokeDynamicInsn(final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\r\n    if (api < Opcodes.ASM5) {\r\n        throw new UnsupportedOperationException(REQUIRES_ASM5);\r\n    }\r\n    if (mv != null) {\r\n        mv.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);\r\n    }\r\n}",
    "comment": "\n   * Visits an invokedynamic instruction.\n   *\n   * @param name the method's name.\n   * @param descriptor the method's descriptor (see {@link Type}).\n   * @param bootstrapMethodHandle the bootstrap method.\n   * @param bootstrapMethodArguments the bootstrap method constant arguments. Each argument must be\n   *     an {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String}, {@link\n   *     Type}, {@link Handle} or {@link ConstantDynamic} value. This method is allowed to modify\n   *     the content of the array so a caller should expect that this array may change.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitJumpInsn(int,Label)",
    "entityType": "method",
    "code": "/**\r\n * Visits a jump instruction. A jump instruction is an instruction that may jump to another\r\n * instruction.\r\n *\r\n * @param opcode the opcode of the type instruction to be visited. This opcode is either IFEQ,\r\n *     IFNE, IFLT, IFGE, IFGT, IFLE, IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT,\r\n *     IF_ICMPLE, IF_ACMPEQ, IF_ACMPNE, GOTO, JSR, IFNULL or IFNONNULL.\r\n * @param label the operand of the instruction to be visited. This operand is a label that\r\n *     designates the instruction to which the jump instruction may jump.\r\n */\r\npublic void visitJumpInsn(final int opcode, final Label label) {\r\n    if (mv != null) {\r\n        mv.visitJumpInsn(opcode, label);\r\n    }\r\n}",
    "comment": "\n   * Visits a jump instruction. A jump instruction is an instruction that may jump to another\n   * instruction.\n   *\n   * @param opcode the opcode of the type instruction to be visited. This opcode is either IFEQ,\n   *     IFNE, IFLT, IFGE, IFGT, IFLE, IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT,\n   *     IF_ICMPLE, IF_ACMPEQ, IF_ACMPNE, GOTO, JSR, IFNULL or IFNONNULL.\n   * @param label the operand of the instruction to be visited. This operand is a label that\n   *     designates the instruction to which the jump instruction may jump.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitLabel(Label)",
    "entityType": "method",
    "code": "/**\r\n * Visits a label. A label designates the instruction that will be visited just after it.\r\n *\r\n * @param label a {@link Label} object.\r\n */\r\npublic void visitLabel(final Label label) {\r\n    if (mv != null) {\r\n        mv.visitLabel(label);\r\n    }\r\n}",
    "comment": "\n   * Visits a label. A label designates the instruction that will be visited just after it.\n   *\n   * @param label a {@link Label} object.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitLdcInsn(Object)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Special instructions\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Visits a LDC instruction. Note that new constant types may be added in future versions of the\r\n * Java Virtual Machine. To easily detect new constant types, implementations of this method\r\n * should check for unexpected constant types, like this:\r\n *\r\n * <pre>\r\n * if (cst instanceof Integer) {\r\n *     // ...\r\n * } else if (cst instanceof Float) {\r\n *     // ...\r\n * } else if (cst instanceof Long) {\r\n *     // ...\r\n * } else if (cst instanceof Double) {\r\n *     // ...\r\n * } else if (cst instanceof String) {\r\n *     // ...\r\n * } else if (cst instanceof Type) {\r\n *     int sort = ((Type) cst).getSort();\r\n *     if (sort == Type.OBJECT) {\r\n *         // ...\r\n *     } else if (sort == Type.ARRAY) {\r\n *         // ...\r\n *     } else if (sort == Type.METHOD) {\r\n *         // ...\r\n *     } else {\r\n *         // throw an exception\r\n *     }\r\n * } else if (cst instanceof Handle) {\r\n *     // ...\r\n * } else if (cst instanceof ConstantDynamic) {\r\n *     // ...\r\n * } else {\r\n *     // throw an exception\r\n * }\r\n * </pre>\r\n *\r\n * @param value the constant to be loaded on the stack. This parameter must be a non null {@link\r\n *     Integer}, a {@link Float}, a {@link Long}, a {@link Double}, a {@link String}, a {@link\r\n *     Type} of OBJECT or ARRAY sort for {@code .class} constants, for classes whose version is\r\n *     49, a {@link Type} of METHOD sort for MethodType, a {@link Handle} for MethodHandle\r\n *     constants, for classes whose version is 51 or a {@link ConstantDynamic} for a constant\r\n *     dynamic for classes whose version is 55.\r\n */\r\npublic void visitLdcInsn(final Object value) {\r\n    if (api < Opcodes.ASM5 && (value instanceof Handle || (value instanceof Type && ((Type) value).getSort() == Type.METHOD))) {\r\n        throw new UnsupportedOperationException(REQUIRES_ASM5);\r\n    }\r\n    if (api < Opcodes.ASM7 && value instanceof ConstantDynamic) {\r\n        throw new UnsupportedOperationException(\"This feature requires ASM7\");\r\n    }\r\n    if (mv != null) {\r\n        mv.visitLdcInsn(value);\r\n    }\r\n}",
    "comment": "\n   * Visits a LDC instruction. Note that new constant types may be added in future versions of the\n   * Java Virtual Machine. To easily detect new constant types, implementations of this method\n   * should check for unexpected constant types, like this:\n   *\n   * <pre>\n   * if (cst instanceof Integer) {\n   *     // ...\n   * } else if (cst instanceof Float) {\n   *     // ...\n   * } else if (cst instanceof Long) {\n   *     // ...\n   * } else if (cst instanceof Double) {\n   *     // ...\n   * } else if (cst instanceof String) {\n   *     // ...\n   * } else if (cst instanceof Type) {\n   *     int sort = ((Type) cst).getSort();\n   *     if (sort == Type.OBJECT) {\n   *         // ...\n   *     } else if (sort == Type.ARRAY) {\n   *         // ...\n   *     } else if (sort == Type.METHOD) {\n   *         // ...\n   *     } else {\n   *         // throw an exception\n   *     }\n   * } else if (cst instanceof Handle) {\n   *     // ...\n   * } else if (cst instanceof ConstantDynamic) {\n   *     // ...\n   * } else {\n   *     // throw an exception\n   * }\n   * </pre>\n   *\n   * @param value the constant to be loaded on the stack. This parameter must be a non null {@link\n   *     Integer}, a {@link Float}, a {@link Long}, a {@link Double}, a {@link String}, a {@link\n   *     Type} of OBJECT or ARRAY sort for {@code .class} constants, for classes whose version is\n   *     49, a {@link Type} of METHOD sort for MethodType, a {@link Handle} for MethodHandle\n   *     constants, for classes whose version is 51 or a {@link ConstantDynamic} for a constant\n   *     dynamic for classes whose version is 55.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitIincInsn(int,int)",
    "entityType": "method",
    "code": "/**\r\n * Visits an IINC instruction.\r\n *\r\n * @param varIndex index of the local variable to be incremented.\r\n * @param increment amount to increment the local variable by.\r\n */\r\npublic void visitIincInsn(final int varIndex, final int increment) {\r\n    if (mv != null) {\r\n        mv.visitIincInsn(varIndex, increment);\r\n    }\r\n}",
    "comment": "\n   * Visits an IINC instruction.\n   *\n   * @param varIndex index of the local variable to be incremented.\n   * @param increment amount to increment the local variable by.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitTableSwitchInsn(int,int,Label,Label)",
    "entityType": "method",
    "code": "/**\r\n * Visits a TABLESWITCH instruction.\r\n *\r\n * @param min the minimum key value.\r\n * @param max the maximum key value.\r\n * @param dflt beginning of the default handler block.\r\n * @param labels beginnings of the handler blocks. {@code labels[i]} is the beginning of the\r\n *     handler block for the {@code min + i} key.\r\n */\r\npublic void visitTableSwitchInsn(final int min, final int max, final Label dflt, final Label... labels) {\r\n    if (mv != null) {\r\n        mv.visitTableSwitchInsn(min, max, dflt, labels);\r\n    }\r\n}",
    "comment": "\n   * Visits a TABLESWITCH instruction.\n   *\n   * @param min the minimum key value.\n   * @param max the maximum key value.\n   * @param dflt beginning of the default handler block.\n   * @param labels beginnings of the handler blocks. {@code labels[i]} is the beginning of the\n   *     handler block for the {@code min + i} key.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitLookupSwitchInsn(Label,int[],Label[])",
    "entityType": "method",
    "code": "/**\r\n * Visits a LOOKUPSWITCH instruction.\r\n *\r\n * @param dflt beginning of the default handler block.\r\n * @param keys the values of the keys.\r\n * @param labels beginnings of the handler blocks. {@code labels[i]} is the beginning of the\r\n *     handler block for the {@code keys[i]} key.\r\n */\r\npublic void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {\r\n    if (mv != null) {\r\n        mv.visitLookupSwitchInsn(dflt, keys, labels);\r\n    }\r\n}",
    "comment": "\n   * Visits a LOOKUPSWITCH instruction.\n   *\n   * @param dflt beginning of the default handler block.\n   * @param keys the values of the keys.\n   * @param labels beginnings of the handler blocks. {@code labels[i]} is the beginning of the\n   *     handler block for the {@code keys[i]} key.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitMultiANewArrayInsn(String,int)",
    "entityType": "method",
    "code": "/**\r\n * Visits a MULTIANEWARRAY instruction.\r\n *\r\n * @param descriptor an array type descriptor (see {@link Type}).\r\n * @param numDimensions the number of dimensions of the array to allocate.\r\n */\r\npublic void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {\r\n    if (mv != null) {\r\n        mv.visitMultiANewArrayInsn(descriptor, numDimensions);\r\n    }\r\n}",
    "comment": "\n   * Visits a MULTIANEWARRAY instruction.\n   *\n   * @param descriptor an array type descriptor (see {@link Type}).\n   * @param numDimensions the number of dimensions of the array to allocate.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitInsnAnnotation(int,TypePath,String,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Visits an annotation on an instruction. This method must be called just <i>after</i> the\r\n * annotated instruction. It can be called several times for the same instruction.\r\n *\r\n * @param typeRef a reference to the annotated type. The sort of this type reference must be\r\n *     {@link TypeReference#INSTANCEOF}, {@link TypeReference#NEW}, {@link\r\n *     TypeReference#CONSTRUCTOR_REFERENCE}, {@link TypeReference#METHOD_REFERENCE}, {@link\r\n *     TypeReference#CAST}, {@link TypeReference#CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT}, {@link\r\n *     TypeReference#METHOD_INVOCATION_TYPE_ARGUMENT}, {@link\r\n *     TypeReference#CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or {@link\r\n *     TypeReference#METHOD_REFERENCE_TYPE_ARGUMENT}. See {@link TypeReference}.\r\n * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\r\n *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\r\n *     'typeRef' as a whole.\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param visible {@literal true} if the annotation is visible at runtime.\r\n * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\r\n *     interested in visiting this annotation.\r\n */\r\npublic AnnotationVisitor visitInsnAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\r\n    if (api < Opcodes.ASM5) {\r\n        throw new UnsupportedOperationException(REQUIRES_ASM5);\r\n    }\r\n    if (mv != null) {\r\n        return mv.visitInsnAnnotation(typeRef, typePath, descriptor, visible);\r\n    }\r\n    return null;\r\n}",
    "comment": "\n   * Visits an annotation on an instruction. This method must be called just <i>after</i> the\n   * annotated instruction. It can be called several times for the same instruction.\n   *\n   * @param typeRef a reference to the annotated type. The sort of this type reference must be\n   *     {@link TypeReference#INSTANCEOF}, {@link TypeReference#NEW}, {@link\n   *     TypeReference#CONSTRUCTOR_REFERENCE}, {@link TypeReference#METHOD_REFERENCE}, {@link\n   *     TypeReference#CAST}, {@link TypeReference#CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT}, {@link\n   *     TypeReference#METHOD_INVOCATION_TYPE_ARGUMENT}, {@link\n   *     TypeReference#CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or {@link\n   *     TypeReference#METHOD_REFERENCE_TYPE_ARGUMENT}. See {@link TypeReference}.\n   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\n   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\n   *     'typeRef' as a whole.\n   * @param descriptor the class descriptor of the annotation class.\n   * @param visible {@literal true} if the annotation is visible at runtime.\n   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\n   *     interested in visiting this annotation.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitTryCatchBlock(Label,Label,Label,String)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Exceptions table entries, debug information, max stack and max locals\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Visits a try catch block.\r\n *\r\n * @param start the beginning of the exception handler's scope (inclusive).\r\n * @param end the end of the exception handler's scope (exclusive).\r\n * @param handler the beginning of the exception handler's code.\r\n * @param type the internal name of the type of exceptions handled by the handler (see {@link\r\n *     Type#getInternalName()}), or {@literal null} to catch any exceptions (for \"finally\"\r\n *     blocks).\r\n * @throws IllegalArgumentException if one of the labels has already been visited by this visitor\r\n *     (by the {@link #visitLabel} method).\r\n */\r\npublic void visitTryCatchBlock(final Label start, final Label end, final Label handler, final String type) {\r\n    if (mv != null) {\r\n        mv.visitTryCatchBlock(start, end, handler, type);\r\n    }\r\n}",
    "comment": "\n   * Visits a try catch block.\n   *\n   * @param start the beginning of the exception handler's scope (inclusive).\n   * @param end the end of the exception handler's scope (exclusive).\n   * @param handler the beginning of the exception handler's code.\n   * @param type the internal name of the type of exceptions handled by the handler (see {@link\n   *     Type#getInternalName()}), or {@literal null} to catch any exceptions (for \"finally\"\n   *     blocks).\n   * @throws IllegalArgumentException if one of the labels has already been visited by this visitor\n   *     (by the {@link #visitLabel} method).\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitTryCatchAnnotation(int,TypePath,String,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Visits an annotation on an exception handler type. This method must be called <i>after</i> the\r\n * {@link #visitTryCatchBlock} for the annotated exception handler. It can be called several times\r\n * for the same exception handler.\r\n *\r\n * @param typeRef a reference to the annotated type. The sort of this type reference must be\r\n *     {@link TypeReference#EXCEPTION_PARAMETER}. See {@link TypeReference}.\r\n * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\r\n *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\r\n *     'typeRef' as a whole.\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param visible {@literal true} if the annotation is visible at runtime.\r\n * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\r\n *     interested in visiting this annotation.\r\n */\r\npublic AnnotationVisitor visitTryCatchAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\r\n    if (api < Opcodes.ASM5) {\r\n        throw new UnsupportedOperationException(REQUIRES_ASM5);\r\n    }\r\n    if (mv != null) {\r\n        return mv.visitTryCatchAnnotation(typeRef, typePath, descriptor, visible);\r\n    }\r\n    return null;\r\n}",
    "comment": "\n   * Visits an annotation on an exception handler type. This method must be called <i>after</i> the\n   * {@link #visitTryCatchBlock} for the annotated exception handler. It can be called several times\n   * for the same exception handler.\n   *\n   * @param typeRef a reference to the annotated type. The sort of this type reference must be\n   *     {@link TypeReference#EXCEPTION_PARAMETER}. See {@link TypeReference}.\n   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\n   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\n   *     'typeRef' as a whole.\n   * @param descriptor the class descriptor of the annotation class.\n   * @param visible {@literal true} if the annotation is visible at runtime.\n   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\n   *     interested in visiting this annotation.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitLocalVariable(String,String,String,Label,Label,int)",
    "entityType": "method",
    "code": "/**\r\n * Visits a local variable declaration.\r\n *\r\n * @param name the name of a local variable.\r\n * @param descriptor the type descriptor of this local variable.\r\n * @param signature the type signature of this local variable. May be {@literal null} if the local\r\n *     variable type does not use generic types.\r\n * @param start the first instruction corresponding to the scope of this local variable\r\n *     (inclusive).\r\n * @param end the last instruction corresponding to the scope of this local variable (exclusive).\r\n * @param index the local variable's index.\r\n * @throws IllegalArgumentException if one of the labels has not already been visited by this\r\n *     visitor (by the {@link #visitLabel} method).\r\n */\r\npublic void visitLocalVariable(final String name, final String descriptor, final String signature, final Label start, final Label end, final int index) {\r\n    if (mv != null) {\r\n        mv.visitLocalVariable(name, descriptor, signature, start, end, index);\r\n    }\r\n}",
    "comment": "\n   * Visits a local variable declaration.\n   *\n   * @param name the name of a local variable.\n   * @param descriptor the type descriptor of this local variable.\n   * @param signature the type signature of this local variable. May be {@literal null} if the local\n   *     variable type does not use generic types.\n   * @param start the first instruction corresponding to the scope of this local variable\n   *     (inclusive).\n   * @param end the last instruction corresponding to the scope of this local variable (exclusive).\n   * @param index the local variable's index.\n   * @throws IllegalArgumentException if one of the labels has not already been visited by this\n   *     visitor (by the {@link #visitLabel} method).\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitLocalVariableAnnotation(int,TypePath,Label[],Label[],int[],String,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Visits an annotation on a local variable type.\r\n *\r\n * @param typeRef a reference to the annotated type. The sort of this type reference must be\r\n *     {@link TypeReference#LOCAL_VARIABLE} or {@link TypeReference#RESOURCE_VARIABLE}. See {@link\r\n *     TypeReference}.\r\n * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\r\n *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\r\n *     'typeRef' as a whole.\r\n * @param start the fist instructions corresponding to the continuous ranges that make the scope\r\n *     of this local variable (inclusive).\r\n * @param end the last instructions corresponding to the continuous ranges that make the scope of\r\n *     this local variable (exclusive). This array must have the same size as the 'start' array.\r\n * @param index the local variable's index in each range. This array must have the same size as\r\n *     the 'start' array.\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param visible {@literal true} if the annotation is visible at runtime.\r\n * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\r\n *     interested in visiting this annotation.\r\n */\r\npublic AnnotationVisitor visitLocalVariableAnnotation(final int typeRef, final TypePath typePath, final Label[] start, final Label[] end, final int[] index, final String descriptor, final boolean visible) {\r\n    if (api < Opcodes.ASM5) {\r\n        throw new UnsupportedOperationException(REQUIRES_ASM5);\r\n    }\r\n    if (mv != null) {\r\n        return mv.visitLocalVariableAnnotation(typeRef, typePath, start, end, index, descriptor, visible);\r\n    }\r\n    return null;\r\n}",
    "comment": "\n   * Visits an annotation on a local variable type.\n   *\n   * @param typeRef a reference to the annotated type. The sort of this type reference must be\n   *     {@link TypeReference#LOCAL_VARIABLE} or {@link TypeReference#RESOURCE_VARIABLE}. See {@link\n   *     TypeReference}.\n   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\n   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\n   *     'typeRef' as a whole.\n   * @param start the fist instructions corresponding to the continuous ranges that make the scope\n   *     of this local variable (inclusive).\n   * @param end the last instructions corresponding to the continuous ranges that make the scope of\n   *     this local variable (exclusive). This array must have the same size as the 'start' array.\n   * @param index the local variable's index in each range. This array must have the same size as\n   *     the 'start' array.\n   * @param descriptor the class descriptor of the annotation class.\n   * @param visible {@literal true} if the annotation is visible at runtime.\n   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\n   *     interested in visiting this annotation.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitLineNumber(int,Label)",
    "entityType": "method",
    "code": "/**\r\n * Visits a line number declaration.\r\n *\r\n * @param line a line number. This number refers to the source file from which the class was\r\n *     compiled.\r\n * @param start the first instruction corresponding to this line number.\r\n * @throws IllegalArgumentException if {@code start} has not already been visited by this visitor\r\n *     (by the {@link #visitLabel} method).\r\n */\r\npublic void visitLineNumber(final int line, final Label start) {\r\n    if (mv != null) {\r\n        mv.visitLineNumber(line, start);\r\n    }\r\n}",
    "comment": "\n   * Visits a line number declaration.\n   *\n   * @param line a line number. This number refers to the source file from which the class was\n   *     compiled.\n   * @param start the first instruction corresponding to this line number.\n   * @throws IllegalArgumentException if {@code start} has not already been visited by this visitor\n   *     (by the {@link #visitLabel} method).\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitMaxs(int,int)",
    "entityType": "method",
    "code": "/**\r\n * Visits the maximum stack size and the maximum number of local variables of the method.\r\n *\r\n * @param maxStack maximum stack size of the method.\r\n * @param maxLocals maximum number of local variables for the method.\r\n */\r\npublic void visitMaxs(final int maxStack, final int maxLocals) {\r\n    if (mv != null) {\r\n        mv.visitMaxs(maxStack, maxLocals);\r\n    }\r\n}",
    "comment": "\n   * Visits the maximum stack size and the maximum number of local variables of the method.\n   *\n   * @param maxStack maximum stack size of the method.\n   * @param maxLocals maximum number of local variables for the method.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodVisitor#visitEnd()",
    "entityType": "method",
    "code": "/**\r\n * Visits the end of the method. This method, which is the last one to be called, is used to\r\n * inform the visitor that all the annotations and attributes of the method have been visited.\r\n */\r\npublic void visitEnd() {\r\n    if (mv != null) {\r\n        mv.visitEnd();\r\n    }\r\n}",
    "comment": "\n   * Visits the end of the method. This method, which is the last one to be called, is used to\n   * inform the visitor that all the annotations and attributes of the method have been visited.\n   "
  },
  {
    "entityId": "org.springframework.core.testfixture.aot.generate.value.ExampleClass$$GeneratedBy",
    "entityType": "class",
    "code": "",
    "comment": "\n * Fake CGLIB generated class.\n *\n * @author Phillip Webb\n "
  },
  {
    "entityId": "org.springframework.core.testfixture.aot.generate.value.ExampleClass",
    "entityType": "class",
    "code": "",
    "comment": "\n * Public example class used for test.\n *\n * @author Phillip Webb\n "
  },
  {
    "entityId": "org.springframework.core.testfixture.aot.generator.visibility.ProtectedGenericParameter",
    "entityType": "class",
    "code": "public ProtectedGenericParameter(List<ProtectedType> types) {\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.aot.generator.visibility.ProtectedParameter",
    "entityType": "class",
    "code": "public ProtectedParameter(ProtectedType type) {\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.aot.generator.visibility.ProtectedType",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.aot.generator.visibility.PublicFactoryBean",
    "entityType": "class",
    "code": "PublicFactoryBean(Class<T> type) {\r\n}\npublic static PublicFactoryBean<ProtectedType> protectedTypeFactoryBean() {\r\n    return new PublicFactoryBean<>(ProtectedType.class);\r\n}\npublic static ResolvableType resolveToProtectedGenericParameter() {\r\n    return ResolvableType.forClassWithGenerics(PublicFactoryBean.class, ProtectedType.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.aot.generator.visibility.PublicFactoryBean#protectedTypeFactoryBean()",
    "entityType": "method",
    "code": "public static PublicFactoryBean<ProtectedType> protectedTypeFactoryBean() {\r\n    return new PublicFactoryBean<>(ProtectedType.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.aot.generator.visibility.PublicFactoryBean#resolveToProtectedGenericParameter()",
    "entityType": "method",
    "code": "public static ResolvableType resolveToProtectedGenericParameter() {\r\n    return ResolvableType.forClassWithGenerics(PublicFactoryBean.class, ProtectedType.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.MethodWriter",
    "entityType": "class",
    "code": "/**\r\n * Indicates that nothing must be computed.\r\n */\r\nstatic final int COMPUTE_NOTHING = 0;\n/**\r\n * Indicates that the maximum stack size and the maximum number of local variables must be\r\n * computed, from scratch.\r\n */\r\nstatic final int COMPUTE_MAX_STACK_AND_LOCAL = 1;\n/**\r\n * Indicates that the maximum stack size and the maximum number of local variables must be\r\n * computed, from the existing stack map frames. This can be done more efficiently than with the\r\n * control flow graph algorithm used for {@link #COMPUTE_MAX_STACK_AND_LOCAL}, by using a linear\r\n * scan of the bytecode instructions.\r\n */\r\nstatic final int COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES = 2;\n/**\r\n * Indicates that the stack map frames of type F_INSERT must be computed. The other frames are not\r\n * computed. They should all be of type F_NEW and should be sufficient to compute the content of\r\n * the F_INSERT frames, together with the bytecode instructions between a F_NEW and a F_INSERT\r\n * frame - and without any knowledge of the type hierarchy (by definition of F_INSERT).\r\n */\r\nstatic final int COMPUTE_INSERTED_FRAMES = 3;\n/**\r\n * Indicates that all the stack map frames must be computed. In this case the maximum stack size\r\n * and the maximum number of local variables is also computed.\r\n */\r\nstatic final int COMPUTE_ALL_FRAMES = 4;\n/**\r\n * Indicates that {@link #STACK_SIZE_DELTA} is not applicable (not constant or never used).\r\n */\r\nprivate static final int NA = 0;\n/**\r\n * The stack size variation corresponding to each JVM opcode. The stack size variation for opcode\r\n * 'o' is given by the array element at index 'o'.\r\n *\r\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-6.html\">JVMS 6</a>\r\n */\r\nprivate static final int[] STACK_SIZE_DELTA = { // nop = 0 (0x0)\r\n0, // aconst_null = 1 (0x1)\r\n1, // iconst_m1 = 2 (0x2)\r\n1, // iconst_0 = 3 (0x3)\r\n1, // iconst_1 = 4 (0x4)\r\n1, // iconst_2 = 5 (0x5)\r\n1, // iconst_3 = 6 (0x6)\r\n1, // iconst_4 = 7 (0x7)\r\n1, // iconst_5 = 8 (0x8)\r\n1, // lconst_0 = 9 (0x9)\r\n2, // lconst_1 = 10 (0xa)\r\n2, // fconst_0 = 11 (0xb)\r\n1, // fconst_1 = 12 (0xc)\r\n1, // fconst_2 = 13 (0xd)\r\n1, // dconst_0 = 14 (0xe)\r\n2, // dconst_1 = 15 (0xf)\r\n2, // bipush = 16 (0x10)\r\n1, // sipush = 17 (0x11)\r\n1, // ldc = 18 (0x12)\r\n1, // ldc_w = 19 (0x13)\r\nNA, // ldc2_w = 20 (0x14)\r\nNA, // iload = 21 (0x15)\r\n1, // lload = 22 (0x16)\r\n2, // fload = 23 (0x17)\r\n1, // dload = 24 (0x18)\r\n2, // aload = 25 (0x19)\r\n1, // iload_0 = 26 (0x1a)\r\nNA, // iload_1 = 27 (0x1b)\r\nNA, // iload_2 = 28 (0x1c)\r\nNA, // iload_3 = 29 (0x1d)\r\nNA, // lload_0 = 30 (0x1e)\r\nNA, // lload_1 = 31 (0x1f)\r\nNA, // lload_2 = 32 (0x20)\r\nNA, // lload_3 = 33 (0x21)\r\nNA, // fload_0 = 34 (0x22)\r\nNA, // fload_1 = 35 (0x23)\r\nNA, // fload_2 = 36 (0x24)\r\nNA, // fload_3 = 37 (0x25)\r\nNA, // dload_0 = 38 (0x26)\r\nNA, // dload_1 = 39 (0x27)\r\nNA, // dload_2 = 40 (0x28)\r\nNA, // dload_3 = 41 (0x29)\r\nNA, // aload_0 = 42 (0x2a)\r\nNA, // aload_1 = 43 (0x2b)\r\nNA, // aload_2 = 44 (0x2c)\r\nNA, // aload_3 = 45 (0x2d)\r\nNA, // iaload = 46 (0x2e)\r\n-1, // laload = 47 (0x2f)\r\n0, // faload = 48 (0x30)\r\n-1, // daload = 49 (0x31)\r\n0, // aaload = 50 (0x32)\r\n-1, // baload = 51 (0x33)\r\n-1, // caload = 52 (0x34)\r\n-1, // saload = 53 (0x35)\r\n-1, // istore = 54 (0x36)\r\n-1, // lstore = 55 (0x37)\r\n-2, // fstore = 56 (0x38)\r\n-1, // dstore = 57 (0x39)\r\n-2, // astore = 58 (0x3a)\r\n-1, // istore_0 = 59 (0x3b)\r\nNA, // istore_1 = 60 (0x3c)\r\nNA, // istore_2 = 61 (0x3d)\r\nNA, // istore_3 = 62 (0x3e)\r\nNA, // lstore_0 = 63 (0x3f)\r\nNA, // lstore_1 = 64 (0x40)\r\nNA, // lstore_2 = 65 (0x41)\r\nNA, // lstore_3 = 66 (0x42)\r\nNA, // fstore_0 = 67 (0x43)\r\nNA, // fstore_1 = 68 (0x44)\r\nNA, // fstore_2 = 69 (0x45)\r\nNA, // fstore_3 = 70 (0x46)\r\nNA, // dstore_0 = 71 (0x47)\r\nNA, // dstore_1 = 72 (0x48)\r\nNA, // dstore_2 = 73 (0x49)\r\nNA, // dstore_3 = 74 (0x4a)\r\nNA, // astore_0 = 75 (0x4b)\r\nNA, // astore_1 = 76 (0x4c)\r\nNA, // astore_2 = 77 (0x4d)\r\nNA, // astore_3 = 78 (0x4e)\r\nNA, // iastore = 79 (0x4f)\r\n-3, // lastore = 80 (0x50)\r\n-4, // fastore = 81 (0x51)\r\n-3, // dastore = 82 (0x52)\r\n-4, // aastore = 83 (0x53)\r\n-3, // bastore = 84 (0x54)\r\n-3, // castore = 85 (0x55)\r\n-3, // sastore = 86 (0x56)\r\n-3, // pop = 87 (0x57)\r\n-1, // pop2 = 88 (0x58)\r\n-2, // dup = 89 (0x59)\r\n1, // dup_x1 = 90 (0x5a)\r\n1, // dup_x2 = 91 (0x5b)\r\n1, // dup2 = 92 (0x5c)\r\n2, // dup2_x1 = 93 (0x5d)\r\n2, // dup2_x2 = 94 (0x5e)\r\n2, // swap = 95 (0x5f)\r\n0, // iadd = 96 (0x60)\r\n-1, // ladd = 97 (0x61)\r\n-2, // fadd = 98 (0x62)\r\n-1, // dadd = 99 (0x63)\r\n-2, // isub = 100 (0x64)\r\n-1, // lsub = 101 (0x65)\r\n-2, // fsub = 102 (0x66)\r\n-1, // dsub = 103 (0x67)\r\n-2, // imul = 104 (0x68)\r\n-1, // lmul = 105 (0x69)\r\n-2, // fmul = 106 (0x6a)\r\n-1, // dmul = 107 (0x6b)\r\n-2, // idiv = 108 (0x6c)\r\n-1, // ldiv = 109 (0x6d)\r\n-2, // fdiv = 110 (0x6e)\r\n-1, // ddiv = 111 (0x6f)\r\n-2, // irem = 112 (0x70)\r\n-1, // lrem = 113 (0x71)\r\n-2, // frem = 114 (0x72)\r\n-1, // drem = 115 (0x73)\r\n-2, // ineg = 116 (0x74)\r\n0, // lneg = 117 (0x75)\r\n0, // fneg = 118 (0x76)\r\n0, // dneg = 119 (0x77)\r\n0, // ishl = 120 (0x78)\r\n-1, // lshl = 121 (0x79)\r\n-1, // ishr = 122 (0x7a)\r\n-1, // lshr = 123 (0x7b)\r\n-1, // iushr = 124 (0x7c)\r\n-1, // lushr = 125 (0x7d)\r\n-1, // iand = 126 (0x7e)\r\n-1, // land = 127 (0x7f)\r\n-2, // ior = 128 (0x80)\r\n-1, // lor = 129 (0x81)\r\n-2, // ixor = 130 (0x82)\r\n-1, // lxor = 131 (0x83)\r\n-2, // iinc = 132 (0x84)\r\n0, // i2l = 133 (0x85)\r\n1, // i2f = 134 (0x86)\r\n0, // i2d = 135 (0x87)\r\n1, // l2i = 136 (0x88)\r\n-1, // l2f = 137 (0x89)\r\n-1, // l2d = 138 (0x8a)\r\n0, // f2i = 139 (0x8b)\r\n0, // f2l = 140 (0x8c)\r\n1, // f2d = 141 (0x8d)\r\n1, // d2i = 142 (0x8e)\r\n-1, // d2l = 143 (0x8f)\r\n0, // d2f = 144 (0x90)\r\n-1, // i2b = 145 (0x91)\r\n0, // i2c = 146 (0x92)\r\n0, // i2s = 147 (0x93)\r\n0, // lcmp = 148 (0x94)\r\n-3, // fcmpl = 149 (0x95)\r\n-1, // fcmpg = 150 (0x96)\r\n-1, // dcmpl = 151 (0x97)\r\n-3, // dcmpg = 152 (0x98)\r\n-3, // ifeq = 153 (0x99)\r\n-1, // ifne = 154 (0x9a)\r\n-1, // iflt = 155 (0x9b)\r\n-1, // ifge = 156 (0x9c)\r\n-1, // ifgt = 157 (0x9d)\r\n-1, // ifle = 158 (0x9e)\r\n-1, // if_icmpeq = 159 (0x9f)\r\n-2, // if_icmpne = 160 (0xa0)\r\n-2, // if_icmplt = 161 (0xa1)\r\n-2, // if_icmpge = 162 (0xa2)\r\n-2, // if_icmpgt = 163 (0xa3)\r\n-2, // if_icmple = 164 (0xa4)\r\n-2, // if_acmpeq = 165 (0xa5)\r\n-2, // if_acmpne = 166 (0xa6)\r\n-2, // goto = 167 (0xa7)\r\n0, // jsr = 168 (0xa8)\r\n1, // ret = 169 (0xa9)\r\n0, // tableswitch = 170 (0xaa)\r\n-1, // lookupswitch = 171 (0xab)\r\n-1, // ireturn = 172 (0xac)\r\n-1, // lreturn = 173 (0xad)\r\n-2, // freturn = 174 (0xae)\r\n-1, // dreturn = 175 (0xaf)\r\n-2, // areturn = 176 (0xb0)\r\n-1, // return = 177 (0xb1)\r\n0, // getstatic = 178 (0xb2)\r\nNA, // putstatic = 179 (0xb3)\r\nNA, // getfield = 180 (0xb4)\r\nNA, // putfield = 181 (0xb5)\r\nNA, // invokevirtual = 182 (0xb6)\r\nNA, // invokespecial = 183 (0xb7)\r\nNA, // invokestatic = 184 (0xb8)\r\nNA, // invokeinterface = 185 (0xb9)\r\nNA, // invokedynamic = 186 (0xba)\r\nNA, // new = 187 (0xbb)\r\n1, // newarray = 188 (0xbc)\r\n0, // anewarray = 189 (0xbd)\r\n0, // arraylength = 190 (0xbe)\r\n0, // athrow = 191 (0xbf)\r\nNA, // checkcast = 192 (0xc0)\r\n0, // instanceof = 193 (0xc1)\r\n0, // monitorenter = 194 (0xc2)\r\n-1, // monitorexit = 195 (0xc3)\r\n-1, // wide = 196 (0xc4)\r\nNA, // multianewarray = 197 (0xc5)\r\nNA, // ifnull = 198 (0xc6)\r\n-1, // ifnonnull = 199 (0xc7)\r\n-1, // goto_w = 200 (0xc8)\r\nNA, // jsr_w = 201 (0xc9)\r\nNA };\n/**\r\n * Where the constants used in this MethodWriter must be stored.\r\n */\r\nprivate final SymbolTable symbolTable;\n// Note: fields are ordered as in the method_info structure, and those related to attributes are\r\n// ordered as in Section 4.7 of the JVMS.\r\n/**\r\n * The access_flags field of the method_info JVMS structure. This field can contain ASM specific\r\n * access flags, such as {@link Opcodes#ACC_DEPRECATED}, which are removed when generating the\r\n * ClassFile structure.\r\n */\r\nprivate final int accessFlags;\n/**\r\n * The name_index field of the method_info JVMS structure.\r\n */\r\nprivate final int nameIndex;\n/**\r\n * The name of this method.\r\n */\r\nprivate final String name;\n/**\r\n * The descriptor_index field of the method_info JVMS structure.\r\n */\r\nprivate final int descriptorIndex;\n/**\r\n * The descriptor of this method.\r\n */\r\nprivate final String descriptor;\n// Code attribute fields and sub attributes:\r\n/**\r\n * The max_stack field of the Code attribute.\r\n */\r\nprivate int maxStack;\n/**\r\n * The max_locals field of the Code attribute.\r\n */\r\nprivate int maxLocals;\n/**\r\n * The 'code' field of the Code attribute.\r\n */\r\nprivate final ByteVector code = new ByteVector();\n/**\r\n * The first element in the exception handler list (used to generate the exception_table of the\r\n * Code attribute). The next ones can be accessed with the {@link Handler#nextHandler} field. May\r\n * be {@literal null}.\r\n */\r\nprivate Handler firstHandler;\n/**\r\n * The last element in the exception handler list (used to generate the exception_table of the\r\n * Code attribute). The next ones can be accessed with the {@link Handler#nextHandler} field. May\r\n * be {@literal null}.\r\n */\r\nprivate Handler lastHandler;\n/**\r\n * The line_number_table_length field of the LineNumberTable code attribute.\r\n */\r\nprivate int lineNumberTableLength;\n/**\r\n * The line_number_table array of the LineNumberTable code attribute, or {@literal null}.\r\n */\r\nprivate ByteVector lineNumberTable;\n/**\r\n * The local_variable_table_length field of the LocalVariableTable code attribute.\r\n */\r\nprivate int localVariableTableLength;\n/**\r\n * The local_variable_table array of the LocalVariableTable code attribute, or {@literal null}.\r\n */\r\nprivate ByteVector localVariableTable;\n/**\r\n * The local_variable_type_table_length field of the LocalVariableTypeTable code attribute.\r\n */\r\nprivate int localVariableTypeTableLength;\n/**\r\n * The local_variable_type_table array of the LocalVariableTypeTable code attribute, or {@literal\r\n * null}.\r\n */\r\nprivate ByteVector localVariableTypeTable;\n/**\r\n * The number_of_entries field of the StackMapTable code attribute.\r\n */\r\nprivate int stackMapTableNumberOfEntries;\n/**\r\n * The 'entries' array of the StackMapTable code attribute.\r\n */\r\nprivate ByteVector stackMapTableEntries;\n/**\r\n * The last runtime visible type annotation of the Code attribute. The previous ones can be\r\n * accessed with the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\r\n */\r\nprivate AnnotationWriter lastCodeRuntimeVisibleTypeAnnotation;\n/**\r\n * The last runtime invisible type annotation of the Code attribute. The previous ones can be\r\n * accessed with the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\r\n */\r\nprivate AnnotationWriter lastCodeRuntimeInvisibleTypeAnnotation;\n/**\r\n * The first non standard attribute of the Code attribute. The next ones can be accessed with the\r\n * {@link Attribute#nextAttribute} field. May be {@literal null}.\r\n *\r\n * <p><b>WARNING</b>: this list stores the attributes in the <i>reverse</i> order of their visit.\r\n * firstAttribute is actually the last attribute visited in {@link #visitAttribute}. The {@link\r\n * #putMethodInfo} method writes the attributes in the order defined by this list, i.e. in the\r\n * reverse order specified by the user.\r\n */\r\nprivate Attribute firstCodeAttribute;\n// Other method_info attributes:\r\n/**\r\n * The number_of_exceptions field of the Exceptions attribute.\r\n */\r\nprivate final int numberOfExceptions;\n/**\r\n * The exception_index_table array of the Exceptions attribute, or {@literal null}.\r\n */\r\nprivate final int[] exceptionIndexTable;\n/**\r\n * The signature_index field of the Signature attribute.\r\n */\r\nprivate final int signatureIndex;\n/**\r\n * The last runtime visible annotation of this method. The previous ones can be accessed with the\r\n * {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\r\n */\r\nprivate AnnotationWriter lastRuntimeVisibleAnnotation;\n/**\r\n * The last runtime invisible annotation of this method. The previous ones can be accessed with\r\n * the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\r\n */\r\nprivate AnnotationWriter lastRuntimeInvisibleAnnotation;\n/**\r\n * The number of method parameters that can have runtime visible annotations, or 0.\r\n */\r\nprivate int visibleAnnotableParameterCount;\n/**\r\n * The runtime visible parameter annotations of this method. Each array element contains the last\r\n * annotation of a parameter (which can be {@literal null} - the previous ones can be accessed\r\n * with the {@link AnnotationWriter#previousAnnotation} field). May be {@literal null}.\r\n */\r\nprivate AnnotationWriter[] lastRuntimeVisibleParameterAnnotations;\n/**\r\n * The number of method parameters that can have runtime visible annotations, or 0.\r\n */\r\nprivate int invisibleAnnotableParameterCount;\n/**\r\n * The runtime invisible parameter annotations of this method. Each array element contains the\r\n * last annotation of a parameter (which can be {@literal null} - the previous ones can be\r\n * accessed with the {@link AnnotationWriter#previousAnnotation} field). May be {@literal null}.\r\n */\r\nprivate AnnotationWriter[] lastRuntimeInvisibleParameterAnnotations;\n/**\r\n * The last runtime visible type annotation of this method. The previous ones can be accessed with\r\n * the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\r\n */\r\nprivate AnnotationWriter lastRuntimeVisibleTypeAnnotation;\n/**\r\n * The last runtime invisible type annotation of this method. The previous ones can be accessed\r\n * with the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\r\n */\r\nprivate AnnotationWriter lastRuntimeInvisibleTypeAnnotation;\n/**\r\n * The default_value field of the AnnotationDefault attribute, or {@literal null}.\r\n */\r\nprivate ByteVector defaultValue;\n/**\r\n * The parameters_count field of the MethodParameters attribute.\r\n */\r\nprivate int parametersCount;\n/**\r\n * The 'parameters' array of the MethodParameters attribute, or {@literal null}.\r\n */\r\nprivate ByteVector parameters;\n/**\r\n * The first non standard attribute of this method. The next ones can be accessed with the {@link\r\n * Attribute#nextAttribute} field. May be {@literal null}.\r\n *\r\n * <p><b>WARNING</b>: this list stores the attributes in the <i>reverse</i> order of their visit.\r\n * firstAttribute is actually the last attribute visited in {@link #visitAttribute}. The {@link\r\n * #putMethodInfo} method writes the attributes in the order defined by this list, i.e. in the\r\n * reverse order specified by the user.\r\n */\r\nprivate Attribute firstAttribute;\n// -----------------------------------------------------------------------------------------------\r\n// Fields used to compute the maximum stack size and number of locals, and the stack map frames\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Indicates what must be computed. Must be one of {@link #COMPUTE_ALL_FRAMES}, {@link\r\n * #COMPUTE_INSERTED_FRAMES}, {@link COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES}, {@link\r\n * #COMPUTE_MAX_STACK_AND_LOCAL} or {@link #COMPUTE_NOTHING}.\r\n */\r\nprivate final int compute;\n/**\r\n * The first basic block of the method. The next ones (in bytecode offset order) can be accessed\r\n * with the {@link Label#nextBasicBlock} field.\r\n */\r\nprivate Label firstBasicBlock;\n/**\r\n * The last basic block of the method (in bytecode offset order). This field is updated each time\r\n * a basic block is encountered, and is used to append it at the end of the basic block list.\r\n */\r\nprivate Label lastBasicBlock;\n/**\r\n * The current basic block, i.e. the basic block of the last visited instruction. When {@link\r\n * #compute} is equal to {@link #COMPUTE_MAX_STACK_AND_LOCAL} or {@link #COMPUTE_ALL_FRAMES}, this\r\n * field is {@literal null} for unreachable code. When {@link #compute} is equal to {@link\r\n * #COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES} or {@link #COMPUTE_INSERTED_FRAMES}, this field stays\r\n * unchanged throughout the whole method (i.e. the whole code is seen as a single basic block;\r\n * indeed, the existing frames are sufficient by hypothesis to compute any intermediate frame -\r\n * and the maximum stack size as well - without using any control flow graph).\r\n */\r\nprivate Label currentBasicBlock;\n/**\r\n * The relative stack size after the last visited instruction. This size is relative to the\r\n * beginning of {@link #currentBasicBlock}, i.e. the true stack size after the last visited\r\n * instruction is equal to the {@link Label#inputStackSize} of the current basic block plus {@link\r\n * #relativeStackSize}. When {@link #compute} is equal to {@link\r\n * #COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES}, {@link #currentBasicBlock} is always the start of\r\n * the method, so this relative size is also equal to the absolute stack size after the last\r\n * visited instruction.\r\n */\r\nprivate int relativeStackSize;\n/**\r\n * The maximum relative stack size after the last visited instruction. This size is relative to\r\n * the beginning of {@link #currentBasicBlock}, i.e. the true maximum stack size after the last\r\n * visited instruction is equal to the {@link Label#inputStackSize} of the current basic block\r\n * plus {@link #maxRelativeStackSize}.When {@link #compute} is equal to {@link\r\n * #COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES}, {@link #currentBasicBlock} is always the start of\r\n * the method, so this relative size is also equal to the absolute maximum stack size after the\r\n * last visited instruction.\r\n */\r\nprivate int maxRelativeStackSize;\n/**\r\n * The number of local variables in the last visited stack map frame.\r\n */\r\nprivate int currentLocals;\n/**\r\n * The bytecode offset of the last frame that was written in {@link #stackMapTableEntries}.\r\n */\r\nprivate int previousFrameOffset;\n/**\r\n * The last frame that was written in {@link #stackMapTableEntries}. This field has the same\r\n * format as {@link #currentFrame}.\r\n */\r\nprivate int[] previousFrame;\n/**\r\n * The current stack map frame. The first element contains the bytecode offset of the instruction\r\n * to which the frame corresponds, the second element is the number of locals and the third one is\r\n * the number of stack elements. The local variables start at index 3 and are followed by the\r\n * operand stack elements. In summary frame[0] = offset, frame[1] = numLocal, frame[2] = numStack.\r\n * Local variables and operand stack entries contain abstract types, as defined in {@link Frame},\r\n * but restricted to {@link Frame#CONSTANT_KIND}, {@link Frame#REFERENCE_KIND}, {@link\r\n * Frame#UNINITIALIZED_KIND} or {@link Frame#FORWARD_UNINITIALIZED_KIND} abstract types. Long and\r\n * double types use only one array entry.\r\n */\r\nprivate int[] currentFrame;\n/**\r\n * Whether this method contains subroutines.\r\n */\r\nprivate boolean hasSubroutines;\n// -----------------------------------------------------------------------------------------------\r\n// Other miscellaneous status fields\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Whether the bytecode of this method contains ASM specific instructions.\r\n */\r\nprivate boolean hasAsmInstructions;\n/**\r\n * The start offset of the last visited instruction. Used to set the offset field of type\r\n * annotations of type 'offset_target' (see <a\r\n * href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20.1\">JVMS\r\n * 4.7.20.1</a>).\r\n */\r\nprivate int lastBytecodeOffset;\n/**\r\n * The offset in bytes in {@link SymbolTable#getSource} from which the method_info for this method\r\n * (excluding its first 6 bytes) must be copied, or 0.\r\n */\r\nprivate int sourceOffset;\n/**\r\n * The length in bytes in {@link SymbolTable#getSource} which must be copied to get the\r\n * method_info for this method (excluding its first 6 bytes for access_flags, name_index and\r\n * descriptor_index).\r\n */\r\nprivate int sourceLength;\n// -----------------------------------------------------------------------------------------------\r\n// Constructor and accessors\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Constructs a new {@link MethodWriter}.\r\n *\r\n * @param symbolTable where the constants used in this AnnotationWriter must be stored.\r\n * @param access the method's access flags (see {@link Opcodes}).\r\n * @param name the method's name.\r\n * @param descriptor the method's descriptor (see {@link Type}).\r\n * @param signature the method's signature. May be {@literal null}.\r\n * @param exceptions the internal names of the method's exceptions. May be {@literal null}.\r\n * @param compute indicates what must be computed (see #compute).\r\n */\r\nMethodWriter(final SymbolTable symbolTable, final int access, final String name, final String descriptor, final String signature, final String[] exceptions, final int compute) {\r\n    super(/* latest api = */\r\n    Opcodes.ASM9);\r\n    this.symbolTable = symbolTable;\r\n    this.accessFlags = \"<init>\".equals(name) ? access | Constants.ACC_CONSTRUCTOR : access;\r\n    this.nameIndex = symbolTable.addConstantUtf8(name);\r\n    this.name = name;\r\n    this.descriptorIndex = symbolTable.addConstantUtf8(descriptor);\r\n    this.descriptor = descriptor;\r\n    this.signatureIndex = signature == null ? 0 : symbolTable.addConstantUtf8(signature);\r\n    if (exceptions != null && exceptions.length > 0) {\r\n        numberOfExceptions = exceptions.length;\r\n        this.exceptionIndexTable = new int[numberOfExceptions];\r\n        for (int i = 0; i < numberOfExceptions; ++i) {\r\n            this.exceptionIndexTable[i] = symbolTable.addConstantClass(exceptions[i]).index;\r\n        }\r\n    } else {\r\n        numberOfExceptions = 0;\r\n        this.exceptionIndexTable = null;\r\n    }\r\n    this.compute = compute;\r\n    if (compute != COMPUTE_NOTHING) {\r\n        // Update maxLocals and currentLocals.\r\n        int argumentsSize = Type.getArgumentsAndReturnSizes(descriptor) >> 2;\r\n        if ((access & Opcodes.ACC_STATIC) != 0) {\r\n            --argumentsSize;\r\n        }\r\n        maxLocals = argumentsSize;\r\n        currentLocals = argumentsSize;\r\n        // Create and visit the label for the first basic block.\r\n        firstBasicBlock = new Label();\r\n        visitLabel(firstBasicBlock);\r\n    }\r\n}\nboolean hasFrames() {\r\n    return stackMapTableNumberOfEntries > 0;\r\n}\nboolean hasAsmInstructions() {\r\n    return hasAsmInstructions;\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Implementation of the MethodVisitor abstract class\r\n// -----------------------------------------------------------------------------------------------\r\n@Override\r\npublic void visitParameter(final String name, final int access) {\r\n    if (parameters == null) {\r\n        parameters = new ByteVector();\r\n    }\r\n    ++parametersCount;\r\n    parameters.putShort((name == null) ? 0 : symbolTable.addConstantUtf8(name)).putShort(access);\r\n}\n@Override\r\npublic AnnotationVisitor visitAnnotationDefault() {\r\n    defaultValue = new ByteVector();\r\n    return new AnnotationWriter(symbolTable, /* useNamedValues= */\r\n    false, defaultValue, null);\r\n}\n@Override\r\npublic AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\r\n    if (visible) {\r\n        return lastRuntimeVisibleAnnotation = AnnotationWriter.create(symbolTable, descriptor, lastRuntimeVisibleAnnotation);\r\n    } else {\r\n        return lastRuntimeInvisibleAnnotation = AnnotationWriter.create(symbolTable, descriptor, lastRuntimeInvisibleAnnotation);\r\n    }\r\n}\n@Override\r\npublic AnnotationVisitor visitTypeAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\r\n    if (visible) {\r\n        return lastRuntimeVisibleTypeAnnotation = AnnotationWriter.create(symbolTable, typeRef, typePath, descriptor, lastRuntimeVisibleTypeAnnotation);\r\n    } else {\r\n        return lastRuntimeInvisibleTypeAnnotation = AnnotationWriter.create(symbolTable, typeRef, typePath, descriptor, lastRuntimeInvisibleTypeAnnotation);\r\n    }\r\n}\n@Override\r\npublic void visitAnnotableParameterCount(final int parameterCount, final boolean visible) {\r\n    if (visible) {\r\n        visibleAnnotableParameterCount = parameterCount;\r\n    } else {\r\n        invisibleAnnotableParameterCount = parameterCount;\r\n    }\r\n}\n@Override\r\npublic AnnotationVisitor visitParameterAnnotation(final int parameter, final String annotationDescriptor, final boolean visible) {\r\n    if (visible) {\r\n        if (lastRuntimeVisibleParameterAnnotations == null) {\r\n            lastRuntimeVisibleParameterAnnotations = new AnnotationWriter[Type.getArgumentCount(descriptor)];\r\n        }\r\n        return lastRuntimeVisibleParameterAnnotations[parameter] = AnnotationWriter.create(symbolTable, annotationDescriptor, lastRuntimeVisibleParameterAnnotations[parameter]);\r\n    } else {\r\n        if (lastRuntimeInvisibleParameterAnnotations == null) {\r\n            lastRuntimeInvisibleParameterAnnotations = new AnnotationWriter[Type.getArgumentCount(descriptor)];\r\n        }\r\n        return lastRuntimeInvisibleParameterAnnotations[parameter] = AnnotationWriter.create(symbolTable, annotationDescriptor, lastRuntimeInvisibleParameterAnnotations[parameter]);\r\n    }\r\n}\n@Override\r\npublic void visitAttribute(final Attribute attribute) {\r\n    // Store the attributes in the <i>reverse</i> order of their visit by this method.\r\n    if (attribute.isCodeAttribute()) {\r\n        attribute.nextAttribute = firstCodeAttribute;\r\n        firstCodeAttribute = attribute;\r\n    } else {\r\n        attribute.nextAttribute = firstAttribute;\r\n        firstAttribute = attribute;\r\n    }\r\n}\n@Override\r\npublic void visitCode() {\r\n    // Nothing to do.\r\n}\n@Override\r\npublic void visitFrame(final int type, final int numLocal, final Object[] local, final int numStack, final Object[] stack) {\r\n    if (compute == COMPUTE_ALL_FRAMES) {\r\n        return;\r\n    }\r\n    if (compute == COMPUTE_INSERTED_FRAMES) {\r\n        if (currentBasicBlock.frame == null) {\r\n            // This should happen only once, for the implicit first frame (which is explicitly visited\r\n            // in ClassReader if the EXPAND_ASM_INSNS option is used - and COMPUTE_INSERTED_FRAMES\r\n            // can't be set if EXPAND_ASM_INSNS is not used).\r\n            currentBasicBlock.frame = new CurrentFrame(currentBasicBlock);\r\n            currentBasicBlock.frame.setInputFrameFromDescriptor(symbolTable, accessFlags, descriptor, numLocal);\r\n            currentBasicBlock.frame.accept(this);\r\n        } else {\r\n            if (type == Opcodes.F_NEW) {\r\n                currentBasicBlock.frame.setInputFrameFromApiFormat(symbolTable, numLocal, local, numStack, stack);\r\n            }\r\n            // If type is not F_NEW then it is F_INSERT by hypothesis, and currentBlock.frame contains\r\n            // the stack map frame at the current instruction, computed from the last F_NEW frame and\r\n            // the bytecode instructions in between (via calls to CurrentFrame#execute).\r\n            currentBasicBlock.frame.accept(this);\r\n        }\r\n    } else if (type == Opcodes.F_NEW) {\r\n        if (previousFrame == null) {\r\n            int argumentsSize = Type.getArgumentsAndReturnSizes(descriptor) >> 2;\r\n            Frame implicitFirstFrame = new Frame(new Label());\r\n            implicitFirstFrame.setInputFrameFromDescriptor(symbolTable, accessFlags, descriptor, argumentsSize);\r\n            implicitFirstFrame.accept(this);\r\n        }\r\n        currentLocals = numLocal;\r\n        int frameIndex = visitFrameStart(code.length, numLocal, numStack);\r\n        for (int i = 0; i < numLocal; ++i) {\r\n            currentFrame[frameIndex++] = Frame.getAbstractTypeFromApiFormat(symbolTable, local[i]);\r\n        }\r\n        for (int i = 0; i < numStack; ++i) {\r\n            currentFrame[frameIndex++] = Frame.getAbstractTypeFromApiFormat(symbolTable, stack[i]);\r\n        }\r\n        visitFrameEnd();\r\n    } else {\r\n        if (symbolTable.getMajorVersion() < Opcodes.V1_6) {\r\n            throw new IllegalArgumentException(\"Class versions V1_5 or less must use F_NEW frames.\");\r\n        }\r\n        int offsetDelta;\r\n        if (stackMapTableEntries == null) {\r\n            stackMapTableEntries = new ByteVector();\r\n            offsetDelta = code.length;\r\n        } else {\r\n            offsetDelta = code.length - previousFrameOffset - 1;\r\n            if (offsetDelta < 0) {\r\n                if (type == Opcodes.F_SAME) {\r\n                    return;\r\n                } else {\r\n                    throw new IllegalStateException();\r\n                }\r\n            }\r\n        }\r\n        switch(type) {\r\n            case Opcodes.F_FULL:\r\n                currentLocals = numLocal;\r\n                stackMapTableEntries.putByte(Frame.FULL_FRAME).putShort(offsetDelta).putShort(numLocal);\r\n                for (int i = 0; i < numLocal; ++i) {\r\n                    putFrameType(local[i]);\r\n                }\r\n                stackMapTableEntries.putShort(numStack);\r\n                for (int i = 0; i < numStack; ++i) {\r\n                    putFrameType(stack[i]);\r\n                }\r\n                break;\r\n            case Opcodes.F_APPEND:\r\n                currentLocals += numLocal;\r\n                stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED + numLocal).putShort(offsetDelta);\r\n                for (int i = 0; i < numLocal; ++i) {\r\n                    putFrameType(local[i]);\r\n                }\r\n                break;\r\n            case Opcodes.F_CHOP:\r\n                currentLocals -= numLocal;\r\n                stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED - numLocal).putShort(offsetDelta);\r\n                break;\r\n            case Opcodes.F_SAME:\r\n                if (offsetDelta < 64) {\r\n                    stackMapTableEntries.putByte(offsetDelta);\r\n                } else {\r\n                    stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED).putShort(offsetDelta);\r\n                }\r\n                break;\r\n            case Opcodes.F_SAME1:\r\n                if (offsetDelta < 64) {\r\n                    stackMapTableEntries.putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME + offsetDelta);\r\n                } else {\r\n                    stackMapTableEntries.putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED).putShort(offsetDelta);\r\n                }\r\n                putFrameType(stack[0]);\r\n                break;\r\n            default:\r\n                throw new IllegalArgumentException();\r\n        }\r\n        previousFrameOffset = code.length;\r\n        ++stackMapTableNumberOfEntries;\r\n    }\r\n    if (compute == COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES) {\r\n        relativeStackSize = numStack;\r\n        for (int i = 0; i < numStack; ++i) {\r\n            if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) {\r\n                relativeStackSize++;\r\n            }\r\n        }\r\n        if (relativeStackSize > maxRelativeStackSize) {\r\n            maxRelativeStackSize = relativeStackSize;\r\n        }\r\n    }\r\n    maxStack = Math.max(maxStack, numStack);\r\n    maxLocals = Math.max(maxLocals, currentLocals);\r\n}\n@Override\r\npublic void visitInsn(final int opcode) {\r\n    lastBytecodeOffset = code.length;\r\n    // Add the instruction to the bytecode of the method.\r\n    code.putByte(opcode);\r\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\r\n    if (currentBasicBlock != null) {\r\n        if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\r\n            currentBasicBlock.frame.execute(opcode, 0, null, null);\r\n        } else {\r\n            int size = relativeStackSize + STACK_SIZE_DELTA[opcode];\r\n            if (size > maxRelativeStackSize) {\r\n                maxRelativeStackSize = size;\r\n            }\r\n            relativeStackSize = size;\r\n        }\r\n        if ((opcode >= Opcodes.IRETURN && opcode <= Opcodes.RETURN) || opcode == Opcodes.ATHROW) {\r\n            endCurrentBasicBlockWithNoSuccessor();\r\n        }\r\n    }\r\n}\n@Override\r\npublic void visitIntInsn(final int opcode, final int operand) {\r\n    lastBytecodeOffset = code.length;\r\n    // Add the instruction to the bytecode of the method.\r\n    if (opcode == Opcodes.SIPUSH) {\r\n        code.put12(opcode, operand);\r\n    } else {\r\n        // BIPUSH or NEWARRAY\r\n        code.put11(opcode, operand);\r\n    }\r\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\r\n    if (currentBasicBlock != null) {\r\n        if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\r\n            currentBasicBlock.frame.execute(opcode, operand, null, null);\r\n        } else if (opcode != Opcodes.NEWARRAY) {\r\n            // The stack size delta is 1 for BIPUSH or SIPUSH, and 0 for NEWARRAY.\r\n            int size = relativeStackSize + 1;\r\n            if (size > maxRelativeStackSize) {\r\n                maxRelativeStackSize = size;\r\n            }\r\n            relativeStackSize = size;\r\n        }\r\n    }\r\n}\n@Override\r\npublic void visitVarInsn(final int opcode, final int varIndex) {\r\n    lastBytecodeOffset = code.length;\r\n    // Add the instruction to the bytecode of the method.\r\n    if (varIndex < 4 && opcode != Opcodes.RET) {\r\n        int optimizedOpcode;\r\n        if (opcode < Opcodes.ISTORE) {\r\n            optimizedOpcode = Constants.ILOAD_0 + ((opcode - Opcodes.ILOAD) << 2) + varIndex;\r\n        } else {\r\n            optimizedOpcode = Constants.ISTORE_0 + ((opcode - Opcodes.ISTORE) << 2) + varIndex;\r\n        }\r\n        code.putByte(optimizedOpcode);\r\n    } else if (varIndex >= 256) {\r\n        code.putByte(Constants.WIDE).put12(opcode, varIndex);\r\n    } else {\r\n        code.put11(opcode, varIndex);\r\n    }\r\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\r\n    if (currentBasicBlock != null) {\r\n        if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\r\n            currentBasicBlock.frame.execute(opcode, varIndex, null, null);\r\n        } else {\r\n            if (opcode == Opcodes.RET) {\r\n                // No stack size delta.\r\n                currentBasicBlock.flags |= Label.FLAG_SUBROUTINE_END;\r\n                currentBasicBlock.outputStackSize = (short) relativeStackSize;\r\n                endCurrentBasicBlockWithNoSuccessor();\r\n            } else {\r\n                // xLOAD or xSTORE\r\n                int size = relativeStackSize + STACK_SIZE_DELTA[opcode];\r\n                if (size > maxRelativeStackSize) {\r\n                    maxRelativeStackSize = size;\r\n                }\r\n                relativeStackSize = size;\r\n            }\r\n        }\r\n    }\r\n    if (compute != COMPUTE_NOTHING) {\r\n        int currentMaxLocals;\r\n        if (opcode == Opcodes.LLOAD || opcode == Opcodes.DLOAD || opcode == Opcodes.LSTORE || opcode == Opcodes.DSTORE) {\r\n            currentMaxLocals = varIndex + 2;\r\n        } else {\r\n            currentMaxLocals = varIndex + 1;\r\n        }\r\n        if (currentMaxLocals > maxLocals) {\r\n            maxLocals = currentMaxLocals;\r\n        }\r\n    }\r\n    if (opcode >= Opcodes.ISTORE && compute == COMPUTE_ALL_FRAMES && firstHandler != null) {\r\n        // If there are exception handler blocks, each instruction within a handler range is, in\r\n        // theory, a basic block (since execution can jump from this instruction to the exception\r\n        // handler). As a consequence, the local variable types at the beginning of the handler\r\n        // block should be the merge of the local variable types at all the instructions within the\r\n        // handler range. However, instead of creating a basic block for each instruction, we can\r\n        // get the same result in a more efficient way. Namely, by starting a new basic block after\r\n        // each xSTORE instruction, which is what we do here.\r\n        visitLabel(new Label());\r\n    }\r\n}\n@Override\r\npublic void visitTypeInsn(final int opcode, final String type) {\r\n    lastBytecodeOffset = code.length;\r\n    // Add the instruction to the bytecode of the method.\r\n    Symbol typeSymbol = symbolTable.addConstantClass(type);\r\n    code.put12(opcode, typeSymbol.index);\r\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\r\n    if (currentBasicBlock != null) {\r\n        if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\r\n            currentBasicBlock.frame.execute(opcode, lastBytecodeOffset, typeSymbol, symbolTable);\r\n        } else if (opcode == Opcodes.NEW) {\r\n            // The stack size delta is 1 for NEW, and 0 for ANEWARRAY, CHECKCAST, or INSTANCEOF.\r\n            int size = relativeStackSize + 1;\r\n            if (size > maxRelativeStackSize) {\r\n                maxRelativeStackSize = size;\r\n            }\r\n            relativeStackSize = size;\r\n        }\r\n    }\r\n}\n@Override\r\npublic void visitFieldInsn(final int opcode, final String owner, final String name, final String descriptor) {\r\n    lastBytecodeOffset = code.length;\r\n    // Add the instruction to the bytecode of the method.\r\n    Symbol fieldrefSymbol = symbolTable.addConstantFieldref(owner, name, descriptor);\r\n    code.put12(opcode, fieldrefSymbol.index);\r\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\r\n    if (currentBasicBlock != null) {\r\n        if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\r\n            currentBasicBlock.frame.execute(opcode, 0, fieldrefSymbol, symbolTable);\r\n        } else {\r\n            int size;\r\n            char firstDescChar = descriptor.charAt(0);\r\n            switch(opcode) {\r\n                case Opcodes.GETSTATIC:\r\n                    size = relativeStackSize + (firstDescChar == 'D' || firstDescChar == 'J' ? 2 : 1);\r\n                    break;\r\n                case Opcodes.PUTSTATIC:\r\n                    size = relativeStackSize + (firstDescChar == 'D' || firstDescChar == 'J' ? -2 : -1);\r\n                    break;\r\n                case Opcodes.GETFIELD:\r\n                    size = relativeStackSize + (firstDescChar == 'D' || firstDescChar == 'J' ? 1 : 0);\r\n                    break;\r\n                case Opcodes.PUTFIELD:\r\n                default:\r\n                    size = relativeStackSize + (firstDescChar == 'D' || firstDescChar == 'J' ? -3 : -2);\r\n                    break;\r\n            }\r\n            if (size > maxRelativeStackSize) {\r\n                maxRelativeStackSize = size;\r\n            }\r\n            relativeStackSize = size;\r\n        }\r\n    }\r\n}\n@Override\r\npublic void visitMethodInsn(final int opcode, final String owner, final String name, final String descriptor, final boolean isInterface) {\r\n    lastBytecodeOffset = code.length;\r\n    // Add the instruction to the bytecode of the method.\r\n    Symbol methodrefSymbol = symbolTable.addConstantMethodref(owner, name, descriptor, isInterface);\r\n    if (opcode == Opcodes.INVOKEINTERFACE) {\r\n        code.put12(Opcodes.INVOKEINTERFACE, methodrefSymbol.index).put11(methodrefSymbol.getArgumentsAndReturnSizes() >> 2, 0);\r\n    } else {\r\n        code.put12(opcode, methodrefSymbol.index);\r\n    }\r\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\r\n    if (currentBasicBlock != null) {\r\n        if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\r\n            currentBasicBlock.frame.execute(opcode, 0, methodrefSymbol, symbolTable);\r\n        } else {\r\n            int argumentsAndReturnSize = methodrefSymbol.getArgumentsAndReturnSizes();\r\n            int stackSizeDelta = (argumentsAndReturnSize & 3) - (argumentsAndReturnSize >> 2);\r\n            int size;\r\n            if (opcode == Opcodes.INVOKESTATIC) {\r\n                size = relativeStackSize + stackSizeDelta + 1;\r\n            } else {\r\n                size = relativeStackSize + stackSizeDelta;\r\n            }\r\n            if (size > maxRelativeStackSize) {\r\n                maxRelativeStackSize = size;\r\n            }\r\n            relativeStackSize = size;\r\n        }\r\n    }\r\n}\n@Override\r\npublic void visitInvokeDynamicInsn(final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\r\n    lastBytecodeOffset = code.length;\r\n    // Add the instruction to the bytecode of the method.\r\n    Symbol invokeDynamicSymbol = symbolTable.addConstantInvokeDynamic(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);\r\n    code.put12(Opcodes.INVOKEDYNAMIC, invokeDynamicSymbol.index);\r\n    code.putShort(0);\r\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\r\n    if (currentBasicBlock != null) {\r\n        if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\r\n            currentBasicBlock.frame.execute(Opcodes.INVOKEDYNAMIC, 0, invokeDynamicSymbol, symbolTable);\r\n        } else {\r\n            int argumentsAndReturnSize = invokeDynamicSymbol.getArgumentsAndReturnSizes();\r\n            int stackSizeDelta = (argumentsAndReturnSize & 3) - (argumentsAndReturnSize >> 2) + 1;\r\n            int size = relativeStackSize + stackSizeDelta;\r\n            if (size > maxRelativeStackSize) {\r\n                maxRelativeStackSize = size;\r\n            }\r\n            relativeStackSize = size;\r\n        }\r\n    }\r\n}\n@Override\r\npublic void visitJumpInsn(final int opcode, final Label label) {\r\n    lastBytecodeOffset = code.length;\r\n    // Add the instruction to the bytecode of the method.\r\n    // Compute the 'base' opcode, i.e. GOTO or JSR if opcode is GOTO_W or JSR_W, otherwise opcode.\r\n    int baseOpcode = opcode >= Constants.GOTO_W ? opcode - Constants.WIDE_JUMP_OPCODE_DELTA : opcode;\r\n    boolean nextInsnIsJumpTarget = false;\r\n    if ((label.flags & Label.FLAG_RESOLVED) != 0 && label.bytecodeOffset - code.length < Short.MIN_VALUE) {\r\n        // Case of a backward jump with an offset < -32768. In this case we automatically replace GOTO\r\n        // with GOTO_W, JSR with JSR_W and IFxxx <l> with IFNOTxxx <L> GOTO_W <l> L:..., where\r\n        // IFNOTxxx is the \"opposite\" opcode of IFxxx (for example, IFNE for IFEQ) and where <L> designates\r\n        // the instruction just after the GOTO_W.\r\n        if (baseOpcode == Opcodes.GOTO) {\r\n            code.putByte(Constants.GOTO_W);\r\n        } else if (baseOpcode == Opcodes.JSR) {\r\n            code.putByte(Constants.JSR_W);\r\n        } else {\r\n            // Put the \"opposite\" opcode of baseOpcode. This can be done by flipping the least\r\n            // significant bit for IFNULL and IFNONNULL, and similarly for IFEQ ... IF_ACMPEQ (with a\r\n            // pre and post offset by 1). The jump offset is 8 bytes (3 for IFNOTxxx, 5 for GOTO_W).\r\n            code.putByte(baseOpcode >= Opcodes.IFNULL ? baseOpcode ^ 1 : ((baseOpcode + 1) ^ 1) - 1);\r\n            code.putShort(8);\r\n            // Here we could put a GOTO_W in theory, but if ASM specific instructions are used in this\r\n            // method or another one, and if the class has frames, we will need to insert a frame after\r\n            // this GOTO_W during the additional ClassReader -> ClassWriter round trip to remove the ASM\r\n            // specific instructions. To not miss this additional frame, we need to use an ASM_GOTO_W\r\n            // here, which has the unfortunate effect of forcing this additional round trip (which in\r\n            // some case would not have been really necessary, but we can't know this at this point).\r\n            code.putByte(Constants.ASM_GOTO_W);\r\n            hasAsmInstructions = true;\r\n            // The instruction after the GOTO_W becomes the target of the IFNOT instruction.\r\n            nextInsnIsJumpTarget = true;\r\n        }\r\n        label.put(code, code.length - 1, true);\r\n    } else if (baseOpcode != opcode) {\r\n        // Case of a GOTO_W or JSR_W specified by the user (normally ClassReader when used to remove\r\n        // ASM specific instructions). In this case we keep the original instruction.\r\n        code.putByte(opcode);\r\n        label.put(code, code.length - 1, true);\r\n    } else {\r\n        // Case of a jump with an offset >= -32768, or of a jump with an unknown offset. In these\r\n        // cases we store the offset in 2 bytes (which will be increased via a ClassReader ->\r\n        // ClassWriter round trip if it turns out that 2 bytes are not sufficient).\r\n        code.putByte(baseOpcode);\r\n        label.put(code, code.length - 1, false);\r\n    }\r\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\r\n    if (currentBasicBlock != null) {\r\n        Label nextBasicBlock = null;\r\n        if (compute == COMPUTE_ALL_FRAMES) {\r\n            currentBasicBlock.frame.execute(baseOpcode, 0, null, null);\r\n            // Record the fact that 'label' is the target of a jump instruction.\r\n            label.getCanonicalInstance().flags |= Label.FLAG_JUMP_TARGET;\r\n            // Add 'label' as a successor of the current basic block.\r\n            addSuccessorToCurrentBasicBlock(Edge.JUMP, label);\r\n            if (baseOpcode != Opcodes.GOTO) {\r\n                // The next instruction starts a new basic block (except for GOTO: by default the code\r\n                // following a goto is unreachable - unless there is an explicit label for it - and we\r\n                // should not compute stack frame types for its instructions).\r\n                nextBasicBlock = new Label();\r\n            }\r\n        } else if (compute == COMPUTE_INSERTED_FRAMES) {\r\n            currentBasicBlock.frame.execute(baseOpcode, 0, null, null);\r\n        } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES) {\r\n            // No need to update maxRelativeStackSize (the stack size delta is always negative).\r\n            relativeStackSize += STACK_SIZE_DELTA[baseOpcode];\r\n        } else {\r\n            if (baseOpcode == Opcodes.JSR) {\r\n                // Record the fact that 'label' designates a subroutine, if not already done.\r\n                if ((label.flags & Label.FLAG_SUBROUTINE_START) == 0) {\r\n                    label.flags |= Label.FLAG_SUBROUTINE_START;\r\n                    hasSubroutines = true;\r\n                }\r\n                currentBasicBlock.flags |= Label.FLAG_SUBROUTINE_CALLER;\r\n                // Note that, by construction in this method, a block which calls a subroutine has at\r\n                // least two successors in the control flow graph: the first one (added below) leads to\r\n                // the instruction after the JSR, while the second one (added here) leads to the JSR\r\n                // target. Note that the first successor is virtual (it does not correspond to a possible\r\n                // execution path): it is only used to compute the successors of the basic blocks ending\r\n                // with a ret, in {@link Label#addSubroutineRetSuccessors}.\r\n                addSuccessorToCurrentBasicBlock(relativeStackSize + 1, label);\r\n                // The instruction after the JSR starts a new basic block.\r\n                nextBasicBlock = new Label();\r\n            } else {\r\n                // No need to update maxRelativeStackSize (the stack size delta is always negative).\r\n                relativeStackSize += STACK_SIZE_DELTA[baseOpcode];\r\n                addSuccessorToCurrentBasicBlock(relativeStackSize, label);\r\n            }\r\n        }\r\n        // If the next instruction starts a new basic block, call visitLabel to add the label of this\r\n        // instruction as a successor of the current block, and to start a new basic block.\r\n        if (nextBasicBlock != null) {\r\n            if (nextInsnIsJumpTarget) {\r\n                nextBasicBlock.flags |= Label.FLAG_JUMP_TARGET;\r\n            }\r\n            visitLabel(nextBasicBlock);\r\n        }\r\n        if (baseOpcode == Opcodes.GOTO) {\r\n            endCurrentBasicBlockWithNoSuccessor();\r\n        }\r\n    }\r\n}\n@Override\r\npublic void visitLabel(final Label label) {\r\n    // Resolve the forward references to this label, if any.\r\n    hasAsmInstructions |= label.resolve(code.data, stackMapTableEntries, code.length);\r\n    // visitLabel starts a new basic block (except for debug only labels), so we need to update the\r\n    // previous and current block references and list of successors.\r\n    if ((label.flags & Label.FLAG_DEBUG_ONLY) != 0) {\r\n        return;\r\n    }\r\n    if (compute == COMPUTE_ALL_FRAMES) {\r\n        if (currentBasicBlock != null) {\r\n            if (label.bytecodeOffset == currentBasicBlock.bytecodeOffset) {\r\n                // We use {@link Label#getCanonicalInstance} to store the state of a basic block in only\r\n                // one place, but this does not work for labels which have not been visited yet.\r\n                // Therefore, when we detect here two labels having the same bytecode offset, we need to\r\n                // - consolidate the state scattered in these two instances into the canonical instance:\r\n                currentBasicBlock.flags |= (label.flags & Label.FLAG_JUMP_TARGET);\r\n                // - make sure the two instances share the same Frame instance (the implementation of\r\n                // {@link Label#getCanonicalInstance} relies on this property; here label.frame should be\r\n                // null):\r\n                label.frame = currentBasicBlock.frame;\r\n                // - and make sure to NOT assign 'label' into 'currentBasicBlock' or 'lastBasicBlock', so\r\n                // that they still refer to the canonical instance for this bytecode offset.\r\n                return;\r\n            }\r\n            // End the current basic block (with one new successor).\r\n            addSuccessorToCurrentBasicBlock(Edge.JUMP, label);\r\n        }\r\n        // Append 'label' at the end of the basic block list.\r\n        if (lastBasicBlock != null) {\r\n            if (label.bytecodeOffset == lastBasicBlock.bytecodeOffset) {\r\n                // Same comment as above.\r\n                lastBasicBlock.flags |= (label.flags & Label.FLAG_JUMP_TARGET);\r\n                // Here label.frame should be null.\r\n                label.frame = lastBasicBlock.frame;\r\n                currentBasicBlock = lastBasicBlock;\r\n                return;\r\n            }\r\n            lastBasicBlock.nextBasicBlock = label;\r\n        }\r\n        lastBasicBlock = label;\r\n        // Make it the new current basic block.\r\n        currentBasicBlock = label;\r\n        // Here label.frame should be null.\r\n        label.frame = new Frame(label);\r\n    } else if (compute == COMPUTE_INSERTED_FRAMES) {\r\n        if (currentBasicBlock == null) {\r\n            // This case should happen only once, for the visitLabel call in the constructor. Indeed, if\r\n            // compute is equal to COMPUTE_INSERTED_FRAMES, currentBasicBlock stays unchanged.\r\n            currentBasicBlock = label;\r\n        } else {\r\n            // Update the frame owner so that a correct frame offset is computed in Frame.accept().\r\n            currentBasicBlock.frame.owner = label;\r\n        }\r\n    } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) {\r\n        if (currentBasicBlock != null) {\r\n            // End the current basic block (with one new successor).\r\n            currentBasicBlock.outputStackMax = (short) maxRelativeStackSize;\r\n            addSuccessorToCurrentBasicBlock(relativeStackSize, label);\r\n        }\r\n        // Start a new current basic block, and reset the current and maximum relative stack sizes.\r\n        currentBasicBlock = label;\r\n        relativeStackSize = 0;\r\n        maxRelativeStackSize = 0;\r\n        // Append the new basic block at the end of the basic block list.\r\n        if (lastBasicBlock != null) {\r\n            lastBasicBlock.nextBasicBlock = label;\r\n        }\r\n        lastBasicBlock = label;\r\n    } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES && currentBasicBlock == null) {\r\n        // This case should happen only once, for the visitLabel call in the constructor. Indeed, if\r\n        // compute is equal to COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES, currentBasicBlock stays\r\n        // unchanged.\r\n        currentBasicBlock = label;\r\n    }\r\n}\n@Override\r\npublic void visitLdcInsn(final Object value) {\r\n    lastBytecodeOffset = code.length;\r\n    // Add the instruction to the bytecode of the method.\r\n    Symbol constantSymbol = symbolTable.addConstant(value);\r\n    int constantIndex = constantSymbol.index;\r\n    char firstDescriptorChar;\r\n    boolean isLongOrDouble = constantSymbol.tag == Symbol.CONSTANT_LONG_TAG || constantSymbol.tag == Symbol.CONSTANT_DOUBLE_TAG || (constantSymbol.tag == Symbol.CONSTANT_DYNAMIC_TAG && ((firstDescriptorChar = constantSymbol.value.charAt(0)) == 'J' || firstDescriptorChar == 'D'));\r\n    if (isLongOrDouble) {\r\n        code.put12(Constants.LDC2_W, constantIndex);\r\n    } else if (constantIndex >= 256) {\r\n        code.put12(Constants.LDC_W, constantIndex);\r\n    } else {\r\n        code.put11(Opcodes.LDC, constantIndex);\r\n    }\r\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\r\n    if (currentBasicBlock != null) {\r\n        if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\r\n            currentBasicBlock.frame.execute(Opcodes.LDC, 0, constantSymbol, symbolTable);\r\n        } else {\r\n            int size = relativeStackSize + (isLongOrDouble ? 2 : 1);\r\n            if (size > maxRelativeStackSize) {\r\n                maxRelativeStackSize = size;\r\n            }\r\n            relativeStackSize = size;\r\n        }\r\n    }\r\n}\n@Override\r\npublic void visitIincInsn(final int varIndex, final int increment) {\r\n    lastBytecodeOffset = code.length;\r\n    // Add the instruction to the bytecode of the method.\r\n    if ((varIndex > 255) || (increment > 127) || (increment < -128)) {\r\n        code.putByte(Constants.WIDE).put12(Opcodes.IINC, varIndex).putShort(increment);\r\n    } else {\r\n        code.putByte(Opcodes.IINC).put11(varIndex, increment);\r\n    }\r\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\r\n    if (currentBasicBlock != null && (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES)) {\r\n        currentBasicBlock.frame.execute(Opcodes.IINC, varIndex, null, null);\r\n    }\r\n    if (compute != COMPUTE_NOTHING) {\r\n        int currentMaxLocals = varIndex + 1;\r\n        if (currentMaxLocals > maxLocals) {\r\n            maxLocals = currentMaxLocals;\r\n        }\r\n    }\r\n}\n@Override\r\npublic void visitTableSwitchInsn(final int min, final int max, final Label dflt, final Label... labels) {\r\n    lastBytecodeOffset = code.length;\r\n    // Add the instruction to the bytecode of the method.\r\n    code.putByte(Opcodes.TABLESWITCH).putByteArray(null, 0, (4 - code.length % 4) % 4);\r\n    dflt.put(code, lastBytecodeOffset, true);\r\n    code.putInt(min).putInt(max);\r\n    for (Label label : labels) {\r\n        label.put(code, lastBytecodeOffset, true);\r\n    }\r\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\r\n    visitSwitchInsn(dflt, labels);\r\n}\n@Override\r\npublic void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {\r\n    lastBytecodeOffset = code.length;\r\n    // Add the instruction to the bytecode of the method.\r\n    code.putByte(Opcodes.LOOKUPSWITCH).putByteArray(null, 0, (4 - code.length % 4) % 4);\r\n    dflt.put(code, lastBytecodeOffset, true);\r\n    code.putInt(labels.length);\r\n    for (int i = 0; i < labels.length; ++i) {\r\n        code.putInt(keys[i]);\r\n        labels[i].put(code, lastBytecodeOffset, true);\r\n    }\r\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\r\n    visitSwitchInsn(dflt, labels);\r\n}\nprivate void visitSwitchInsn(final Label dflt, final Label[] labels) {\r\n    if (currentBasicBlock != null) {\r\n        if (compute == COMPUTE_ALL_FRAMES) {\r\n            currentBasicBlock.frame.execute(Opcodes.LOOKUPSWITCH, 0, null, null);\r\n            // Add all the labels as successors of the current basic block.\r\n            addSuccessorToCurrentBasicBlock(Edge.JUMP, dflt);\r\n            dflt.getCanonicalInstance().flags |= Label.FLAG_JUMP_TARGET;\r\n            for (Label label : labels) {\r\n                addSuccessorToCurrentBasicBlock(Edge.JUMP, label);\r\n                label.getCanonicalInstance().flags |= Label.FLAG_JUMP_TARGET;\r\n            }\r\n        } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) {\r\n            // No need to update maxRelativeStackSize (the stack size delta is always negative).\r\n            --relativeStackSize;\r\n            // Add all the labels as successors of the current basic block.\r\n            addSuccessorToCurrentBasicBlock(relativeStackSize, dflt);\r\n            for (Label label : labels) {\r\n                addSuccessorToCurrentBasicBlock(relativeStackSize, label);\r\n            }\r\n        }\r\n        // End the current basic block.\r\n        endCurrentBasicBlockWithNoSuccessor();\r\n    }\r\n}\n@Override\r\npublic void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {\r\n    lastBytecodeOffset = code.length;\r\n    // Add the instruction to the bytecode of the method.\r\n    Symbol descSymbol = symbolTable.addConstantClass(descriptor);\r\n    code.put12(Opcodes.MULTIANEWARRAY, descSymbol.index).putByte(numDimensions);\r\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\r\n    if (currentBasicBlock != null) {\r\n        if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\r\n            currentBasicBlock.frame.execute(Opcodes.MULTIANEWARRAY, numDimensions, descSymbol, symbolTable);\r\n        } else {\r\n            // No need to update maxRelativeStackSize (the stack size delta is always negative).\r\n            relativeStackSize += 1 - numDimensions;\r\n        }\r\n    }\r\n}\n@Override\r\npublic AnnotationVisitor visitInsnAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\r\n    if (visible) {\r\n        return lastCodeRuntimeVisibleTypeAnnotation = AnnotationWriter.create(symbolTable, (typeRef & 0xFF0000FF) | (lastBytecodeOffset << 8), typePath, descriptor, lastCodeRuntimeVisibleTypeAnnotation);\r\n    } else {\r\n        return lastCodeRuntimeInvisibleTypeAnnotation = AnnotationWriter.create(symbolTable, (typeRef & 0xFF0000FF) | (lastBytecodeOffset << 8), typePath, descriptor, lastCodeRuntimeInvisibleTypeAnnotation);\r\n    }\r\n}\n@Override\r\npublic void visitTryCatchBlock(final Label start, final Label end, final Label handler, final String type) {\r\n    Handler newHandler = new Handler(start, end, handler, type != null ? symbolTable.addConstantClass(type).index : 0, type);\r\n    if (firstHandler == null) {\r\n        firstHandler = newHandler;\r\n    } else {\r\n        lastHandler.nextHandler = newHandler;\r\n    }\r\n    lastHandler = newHandler;\r\n}\n@Override\r\npublic AnnotationVisitor visitTryCatchAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\r\n    if (visible) {\r\n        return lastCodeRuntimeVisibleTypeAnnotation = AnnotationWriter.create(symbolTable, typeRef, typePath, descriptor, lastCodeRuntimeVisibleTypeAnnotation);\r\n    } else {\r\n        return lastCodeRuntimeInvisibleTypeAnnotation = AnnotationWriter.create(symbolTable, typeRef, typePath, descriptor, lastCodeRuntimeInvisibleTypeAnnotation);\r\n    }\r\n}\n@Override\r\npublic void visitLocalVariable(final String name, final String descriptor, final String signature, final Label start, final Label end, final int index) {\r\n    if (signature != null) {\r\n        if (localVariableTypeTable == null) {\r\n            localVariableTypeTable = new ByteVector();\r\n        }\r\n        ++localVariableTypeTableLength;\r\n        localVariableTypeTable.putShort(start.bytecodeOffset).putShort(end.bytecodeOffset - start.bytecodeOffset).putShort(symbolTable.addConstantUtf8(name)).putShort(symbolTable.addConstantUtf8(signature)).putShort(index);\r\n    }\r\n    if (localVariableTable == null) {\r\n        localVariableTable = new ByteVector();\r\n    }\r\n    ++localVariableTableLength;\r\n    localVariableTable.putShort(start.bytecodeOffset).putShort(end.bytecodeOffset - start.bytecodeOffset).putShort(symbolTable.addConstantUtf8(name)).putShort(symbolTable.addConstantUtf8(descriptor)).putShort(index);\r\n    if (compute != COMPUTE_NOTHING) {\r\n        char firstDescChar = descriptor.charAt(0);\r\n        int currentMaxLocals = index + (firstDescChar == 'J' || firstDescChar == 'D' ? 2 : 1);\r\n        if (currentMaxLocals > maxLocals) {\r\n            maxLocals = currentMaxLocals;\r\n        }\r\n    }\r\n}\n@Override\r\npublic AnnotationVisitor visitLocalVariableAnnotation(final int typeRef, final TypePath typePath, final Label[] start, final Label[] end, final int[] index, final String descriptor, final boolean visible) {\r\n    // Create a ByteVector to hold a 'type_annotation' JVMS structure.\r\n    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20.\r\n    ByteVector typeAnnotation = new ByteVector();\r\n    // Write target_type, target_info, and target_path.\r\n    typeAnnotation.putByte(typeRef >>> 24).putShort(start.length);\r\n    for (int i = 0; i < start.length; ++i) {\r\n        typeAnnotation.putShort(start[i].bytecodeOffset).putShort(end[i].bytecodeOffset - start[i].bytecodeOffset).putShort(index[i]);\r\n    }\r\n    TypePath.put(typePath, typeAnnotation);\r\n    // Write type_index and reserve space for num_element_value_pairs.\r\n    typeAnnotation.putShort(symbolTable.addConstantUtf8(descriptor)).putShort(0);\r\n    if (visible) {\r\n        return lastCodeRuntimeVisibleTypeAnnotation = new AnnotationWriter(symbolTable, /* useNamedValues= */\r\n        true, typeAnnotation, lastCodeRuntimeVisibleTypeAnnotation);\r\n    } else {\r\n        return lastCodeRuntimeInvisibleTypeAnnotation = new AnnotationWriter(symbolTable, /* useNamedValues= */\r\n        true, typeAnnotation, lastCodeRuntimeInvisibleTypeAnnotation);\r\n    }\r\n}\n@Override\r\npublic void visitLineNumber(final int line, final Label start) {\r\n    if (lineNumberTable == null) {\r\n        lineNumberTable = new ByteVector();\r\n    }\r\n    ++lineNumberTableLength;\r\n    lineNumberTable.putShort(start.bytecodeOffset);\r\n    lineNumberTable.putShort(line);\r\n}\n@Override\r\npublic void visitMaxs(final int maxStack, final int maxLocals) {\r\n    if (compute == COMPUTE_ALL_FRAMES) {\r\n        computeAllFrames();\r\n    } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) {\r\n        computeMaxStackAndLocal();\r\n    } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES) {\r\n        this.maxStack = maxRelativeStackSize;\r\n    } else {\r\n        this.maxStack = maxStack;\r\n        this.maxLocals = maxLocals;\r\n    }\r\n}\n/**\r\n * Computes all the stack map frames of the method, from scratch.\r\n */\r\nprivate void computeAllFrames() {\r\n    // Complete the control flow graph with exception handler blocks.\r\n    Handler handler = firstHandler;\r\n    while (handler != null) {\r\n        String catchTypeDescriptor = handler.catchTypeDescriptor == null ? \"java/lang/Throwable\" : handler.catchTypeDescriptor;\r\n        int catchType = Frame.getAbstractTypeFromInternalName(symbolTable, catchTypeDescriptor);\r\n        // Mark handlerBlock as an exception handler.\r\n        Label handlerBlock = handler.handlerPc.getCanonicalInstance();\r\n        handlerBlock.flags |= Label.FLAG_JUMP_TARGET;\r\n        // Add handlerBlock as a successor of all the basic blocks in the exception handler range.\r\n        Label handlerRangeBlock = handler.startPc.getCanonicalInstance();\r\n        Label handlerRangeEnd = handler.endPc.getCanonicalInstance();\r\n        while (handlerRangeBlock != handlerRangeEnd) {\r\n            handlerRangeBlock.outgoingEdges = new Edge(catchType, handlerBlock, handlerRangeBlock.outgoingEdges);\r\n            handlerRangeBlock = handlerRangeBlock.nextBasicBlock;\r\n        }\r\n        handler = handler.nextHandler;\r\n    }\r\n    // Create and visit the first (implicit) frame.\r\n    Frame firstFrame = firstBasicBlock.frame;\r\n    firstFrame.setInputFrameFromDescriptor(symbolTable, accessFlags, descriptor, this.maxLocals);\r\n    firstFrame.accept(this);\r\n    // Fix point algorithm: add the first basic block to a list of blocks to process (i.e. blocks\r\n    // whose stack map frame has changed) and, while there are blocks to process, remove one from\r\n    // the list and update the stack map frames of its successor blocks in the control flow graph\r\n    // (which might change them, in which case these blocks must be processed too, and are thus\r\n    // added to the list of blocks to process). Also compute the maximum stack size of the method,\r\n    // as a by-product.\r\n    Label listOfBlocksToProcess = firstBasicBlock;\r\n    listOfBlocksToProcess.nextListElement = Label.EMPTY_LIST;\r\n    int maxStackSize = 0;\r\n    while (listOfBlocksToProcess != Label.EMPTY_LIST) {\r\n        // Remove a basic block from the list of blocks to process.\r\n        Label basicBlock = listOfBlocksToProcess;\r\n        listOfBlocksToProcess = listOfBlocksToProcess.nextListElement;\r\n        basicBlock.nextListElement = null;\r\n        // By definition, basicBlock is reachable.\r\n        basicBlock.flags |= Label.FLAG_REACHABLE;\r\n        // Update the (absolute) maximum stack size.\r\n        int maxBlockStackSize = basicBlock.frame.getInputStackSize() + basicBlock.outputStackMax;\r\n        if (maxBlockStackSize > maxStackSize) {\r\n            maxStackSize = maxBlockStackSize;\r\n        }\r\n        // Update the successor blocks of basicBlock in the control flow graph.\r\n        Edge outgoingEdge = basicBlock.outgoingEdges;\r\n        while (outgoingEdge != null) {\r\n            Label successorBlock = outgoingEdge.successor.getCanonicalInstance();\r\n            boolean successorBlockChanged = basicBlock.frame.merge(symbolTable, successorBlock.frame, outgoingEdge.info);\r\n            if (successorBlockChanged && successorBlock.nextListElement == null) {\r\n                // If successorBlock has changed it must be processed. Thus, if it is not already in the\r\n                // list of blocks to process, add it to this list.\r\n                successorBlock.nextListElement = listOfBlocksToProcess;\r\n                listOfBlocksToProcess = successorBlock;\r\n            }\r\n            outgoingEdge = outgoingEdge.nextEdge;\r\n        }\r\n    }\r\n    // Loop over all the basic blocks and visit the stack map frames that must be stored in the\r\n    // StackMapTable attribute. Also replace unreachable code with NOP* ATHROW, and remove it from\r\n    // exception handler ranges.\r\n    Label basicBlock = firstBasicBlock;\r\n    while (basicBlock != null) {\r\n        if ((basicBlock.flags & (Label.FLAG_JUMP_TARGET | Label.FLAG_REACHABLE)) == (Label.FLAG_JUMP_TARGET | Label.FLAG_REACHABLE)) {\r\n            basicBlock.frame.accept(this);\r\n        }\r\n        if ((basicBlock.flags & Label.FLAG_REACHABLE) == 0) {\r\n            // Find the start and end bytecode offsets of this unreachable block.\r\n            Label nextBasicBlock = basicBlock.nextBasicBlock;\r\n            int startOffset = basicBlock.bytecodeOffset;\r\n            int endOffset = (nextBasicBlock == null ? code.length : nextBasicBlock.bytecodeOffset) - 1;\r\n            if (endOffset >= startOffset) {\r\n                // Replace its instructions with NOP ... NOP ATHROW.\r\n                for (int i = startOffset; i < endOffset; ++i) {\r\n                    code.data[i] = Opcodes.NOP;\r\n                }\r\n                code.data[endOffset] = (byte) Opcodes.ATHROW;\r\n                // Emit a frame for this unreachable block, with no local and a Throwable on the stack\r\n                // (so that the ATHROW could consume this Throwable if it were reachable).\r\n                int frameIndex = visitFrameStart(startOffset, /* numLocal = */\r\n                0, /* numStack = */\r\n                1);\r\n                currentFrame[frameIndex] = Frame.getAbstractTypeFromInternalName(symbolTable, \"java/lang/Throwable\");\r\n                visitFrameEnd();\r\n                // Remove this unreachable basic block from the exception handler ranges.\r\n                firstHandler = Handler.removeRange(firstHandler, basicBlock, nextBasicBlock);\r\n                // The maximum stack size is now at least one, because of the Throwable declared above.\r\n                maxStackSize = Math.max(maxStackSize, 1);\r\n            }\r\n        }\r\n        basicBlock = basicBlock.nextBasicBlock;\r\n    }\r\n    this.maxStack = maxStackSize;\r\n}\n/**\r\n * Computes the maximum stack size of the method.\r\n */\r\nprivate void computeMaxStackAndLocal() {\r\n    // Complete the control flow graph with exception handler blocks.\r\n    Handler handler = firstHandler;\r\n    while (handler != null) {\r\n        Label handlerBlock = handler.handlerPc;\r\n        Label handlerRangeBlock = handler.startPc;\r\n        Label handlerRangeEnd = handler.endPc;\r\n        // Add handlerBlock as a successor of all the basic blocks in the exception handler range.\r\n        while (handlerRangeBlock != handlerRangeEnd) {\r\n            if ((handlerRangeBlock.flags & Label.FLAG_SUBROUTINE_CALLER) == 0) {\r\n                handlerRangeBlock.outgoingEdges = new Edge(Edge.EXCEPTION, handlerBlock, handlerRangeBlock.outgoingEdges);\r\n            } else {\r\n                // If handlerRangeBlock is a JSR block, add handlerBlock after the first two outgoing\r\n                // edges to preserve the hypothesis about JSR block successors order (see\r\n                // {@link #visitJumpInsn}).\r\n                handlerRangeBlock.outgoingEdges.nextEdge.nextEdge = new Edge(Edge.EXCEPTION, handlerBlock, handlerRangeBlock.outgoingEdges.nextEdge.nextEdge);\r\n            }\r\n            handlerRangeBlock = handlerRangeBlock.nextBasicBlock;\r\n        }\r\n        handler = handler.nextHandler;\r\n    }\r\n    // Complete the control flow graph with the successor blocks of subroutines, if needed.\r\n    if (hasSubroutines) {\r\n        // First step: find the subroutines. This step determines, for each basic block, to which\r\n        // subroutine(s) it belongs. Start with the main \"subroutine\":\r\n        short numSubroutines = 1;\r\n        firstBasicBlock.markSubroutine(numSubroutines);\r\n        // Then, mark the subroutines called by the main subroutine, then the subroutines called by\r\n        // those called by the main subroutine, etc.\r\n        for (short currentSubroutine = 1; currentSubroutine <= numSubroutines; ++currentSubroutine) {\r\n            Label basicBlock = firstBasicBlock;\r\n            while (basicBlock != null) {\r\n                if ((basicBlock.flags & Label.FLAG_SUBROUTINE_CALLER) != 0 && basicBlock.subroutineId == currentSubroutine) {\r\n                    Label jsrTarget = basicBlock.outgoingEdges.nextEdge.successor;\r\n                    if (jsrTarget.subroutineId == 0) {\r\n                        // If this subroutine has not been marked yet, find its basic blocks.\r\n                        jsrTarget.markSubroutine(++numSubroutines);\r\n                    }\r\n                }\r\n                basicBlock = basicBlock.nextBasicBlock;\r\n            }\r\n        }\r\n        // Second step: find the successors in the control flow graph of each subroutine basic block\r\n        // 'r' ending with a RET instruction. These successors are the virtual successors of the basic\r\n        // blocks ending with JSR instructions (see {@link #visitJumpInsn)} that can reach 'r'.\r\n        Label basicBlock = firstBasicBlock;\r\n        while (basicBlock != null) {\r\n            if ((basicBlock.flags & Label.FLAG_SUBROUTINE_CALLER) != 0) {\r\n                // By construction, jsr targets are stored in the second outgoing edge of basic blocks\r\n                // that ends with a jsr instruction (see {@link #FLAG_SUBROUTINE_CALLER}).\r\n                Label subroutine = basicBlock.outgoingEdges.nextEdge.successor;\r\n                subroutine.addSubroutineRetSuccessors(basicBlock);\r\n            }\r\n            basicBlock = basicBlock.nextBasicBlock;\r\n        }\r\n    }\r\n    // Data flow algorithm: put the first basic block in a list of blocks to process (i.e. blocks\r\n    // whose input stack size has changed) and, while there are blocks to process, remove one\r\n    // from the list, update the input stack size of its successor blocks in the control flow\r\n    // graph, and add these blocks to the list of blocks to process (if not already done).\r\n    Label listOfBlocksToProcess = firstBasicBlock;\r\n    listOfBlocksToProcess.nextListElement = Label.EMPTY_LIST;\r\n    int maxStackSize = maxStack;\r\n    while (listOfBlocksToProcess != Label.EMPTY_LIST) {\r\n        // Remove a basic block from the list of blocks to process. Note that we don't reset\r\n        // basicBlock.nextListElement to null on purpose, to make sure we don't reprocess already\r\n        // processed basic blocks.\r\n        Label basicBlock = listOfBlocksToProcess;\r\n        listOfBlocksToProcess = listOfBlocksToProcess.nextListElement;\r\n        // Compute the (absolute) input stack size and maximum stack size of this block.\r\n        int inputStackTop = basicBlock.inputStackSize;\r\n        int maxBlockStackSize = inputStackTop + basicBlock.outputStackMax;\r\n        // Update the absolute maximum stack size of the method.\r\n        if (maxBlockStackSize > maxStackSize) {\r\n            maxStackSize = maxBlockStackSize;\r\n        }\r\n        // Update the input stack size of the successor blocks of basicBlock in the control flow\r\n        // graph, and add these blocks to the list of blocks to process, if not already done.\r\n        Edge outgoingEdge = basicBlock.outgoingEdges;\r\n        if ((basicBlock.flags & Label.FLAG_SUBROUTINE_CALLER) != 0) {\r\n            // Ignore the first outgoing edge of the basic blocks ending with a jsr: these are virtual\r\n            // edges which lead to the instruction just after the jsr, and do not correspond to a\r\n            // possible execution path (see {@link #visitJumpInsn} and\r\n            // {@link Label#FLAG_SUBROUTINE_CALLER}).\r\n            outgoingEdge = outgoingEdge.nextEdge;\r\n        }\r\n        while (outgoingEdge != null) {\r\n            Label successorBlock = outgoingEdge.successor;\r\n            if (successorBlock.nextListElement == null) {\r\n                successorBlock.inputStackSize = (short) (outgoingEdge.info == Edge.EXCEPTION ? 1 : inputStackTop + outgoingEdge.info);\r\n                successorBlock.nextListElement = listOfBlocksToProcess;\r\n                listOfBlocksToProcess = successorBlock;\r\n            }\r\n            outgoingEdge = outgoingEdge.nextEdge;\r\n        }\r\n    }\r\n    this.maxStack = maxStackSize;\r\n}\n@Override\r\npublic void visitEnd() {\r\n    // Nothing to do.\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Utility methods: control flow analysis algorithm\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Adds a successor to {@link #currentBasicBlock} in the control flow graph.\r\n *\r\n * @param info information about the control flow edge to be added.\r\n * @param successor the successor block to be added to the current basic block.\r\n */\r\nprivate void addSuccessorToCurrentBasicBlock(final int info, final Label successor) {\r\n    currentBasicBlock.outgoingEdges = new Edge(info, successor, currentBasicBlock.outgoingEdges);\r\n}\n/**\r\n * Ends the current basic block. This method must be used in the case where the current basic\r\n * block does not have any successor.\r\n *\r\n * <p>WARNING: this method must be called after the currently visited instruction has been put in\r\n * {@link #code} (if frames are computed, this method inserts a new Label to start a new basic\r\n * block after the current instruction).\r\n */\r\nprivate void endCurrentBasicBlockWithNoSuccessor() {\r\n    if (compute == COMPUTE_ALL_FRAMES) {\r\n        Label nextBasicBlock = new Label();\r\n        nextBasicBlock.frame = new Frame(nextBasicBlock);\r\n        nextBasicBlock.resolve(code.data, stackMapTableEntries, code.length);\r\n        lastBasicBlock.nextBasicBlock = nextBasicBlock;\r\n        lastBasicBlock = nextBasicBlock;\r\n        currentBasicBlock = null;\r\n    } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) {\r\n        currentBasicBlock.outputStackMax = (short) maxRelativeStackSize;\r\n        currentBasicBlock = null;\r\n    }\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Utility methods: stack map frames\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Starts the visit of a new stack map frame, stored in {@link #currentFrame}.\r\n *\r\n * @param offset the bytecode offset of the instruction to which the frame corresponds.\r\n * @param numLocal the number of local variables in the frame.\r\n * @param numStack the number of stack elements in the frame.\r\n * @return the index of the next element to be written in this frame.\r\n */\r\nint visitFrameStart(final int offset, final int numLocal, final int numStack) {\r\n    int frameLength = 3 + numLocal + numStack;\r\n    if (currentFrame == null || currentFrame.length < frameLength) {\r\n        currentFrame = new int[frameLength];\r\n    }\r\n    currentFrame[0] = offset;\r\n    currentFrame[1] = numLocal;\r\n    currentFrame[2] = numStack;\r\n    return 3;\r\n}\n/**\r\n * Sets an abstract type in {@link #currentFrame}.\r\n *\r\n * @param frameIndex the index of the element to be set in {@link #currentFrame}.\r\n * @param abstractType an abstract type.\r\n */\r\nvoid visitAbstractType(final int frameIndex, final int abstractType) {\r\n    currentFrame[frameIndex] = abstractType;\r\n}\n/**\r\n * Ends the visit of {@link #currentFrame} by writing it in the StackMapTable entries and by\r\n * updating the StackMapTable number_of_entries (except if the current frame is the first one,\r\n * which is implicit in StackMapTable). Then resets {@link #currentFrame} to {@literal null}.\r\n */\r\nvoid visitFrameEnd() {\r\n    if (previousFrame != null) {\r\n        if (stackMapTableEntries == null) {\r\n            stackMapTableEntries = new ByteVector();\r\n        }\r\n        putFrame();\r\n        ++stackMapTableNumberOfEntries;\r\n    }\r\n    previousFrame = currentFrame;\r\n    currentFrame = null;\r\n}\n/**\r\n * Compresses and writes {@link #currentFrame} in a new StackMapTable entry.\r\n */\r\nprivate void putFrame() {\r\n    final int numLocal = currentFrame[1];\r\n    final int numStack = currentFrame[2];\r\n    if (symbolTable.getMajorVersion() < Opcodes.V1_6) {\r\n        // Generate a StackMap attribute entry, which are always uncompressed.\r\n        stackMapTableEntries.putShort(currentFrame[0]).putShort(numLocal);\r\n        putAbstractTypes(3, 3 + numLocal);\r\n        stackMapTableEntries.putShort(numStack);\r\n        putAbstractTypes(3 + numLocal, 3 + numLocal + numStack);\r\n        return;\r\n    }\r\n    final int offsetDelta = stackMapTableNumberOfEntries == 0 ? currentFrame[0] : currentFrame[0] - previousFrame[0] - 1;\r\n    final int previousNumlocal = previousFrame[1];\r\n    final int numLocalDelta = numLocal - previousNumlocal;\r\n    int type = Frame.FULL_FRAME;\r\n    if (numStack == 0) {\r\n        switch(numLocalDelta) {\r\n            case -3:\r\n            case -2:\r\n            case -1:\r\n                type = Frame.CHOP_FRAME;\r\n                break;\r\n            case 0:\r\n                type = offsetDelta < 64 ? Frame.SAME_FRAME : Frame.SAME_FRAME_EXTENDED;\r\n                break;\r\n            case 1:\r\n            case 2:\r\n            case 3:\r\n                type = Frame.APPEND_FRAME;\r\n                break;\r\n            default:\r\n                // Keep the FULL_FRAME type.\r\n                break;\r\n        }\r\n    } else if (numLocalDelta == 0 && numStack == 1) {\r\n        type = offsetDelta < 63 ? Frame.SAME_LOCALS_1_STACK_ITEM_FRAME : Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;\r\n    }\r\n    if (type != Frame.FULL_FRAME) {\r\n        // Verify if locals are the same as in the previous frame.\r\n        int frameIndex = 3;\r\n        for (int i = 0; i < previousNumlocal && i < numLocal; i++) {\r\n            if (currentFrame[frameIndex] != previousFrame[frameIndex]) {\r\n                type = Frame.FULL_FRAME;\r\n                break;\r\n            }\r\n            frameIndex++;\r\n        }\r\n    }\r\n    switch(type) {\r\n        case Frame.SAME_FRAME:\r\n            stackMapTableEntries.putByte(offsetDelta);\r\n            break;\r\n        case Frame.SAME_LOCALS_1_STACK_ITEM_FRAME:\r\n            stackMapTableEntries.putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME + offsetDelta);\r\n            putAbstractTypes(3 + numLocal, 4 + numLocal);\r\n            break;\r\n        case Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED:\r\n            stackMapTableEntries.putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED).putShort(offsetDelta);\r\n            putAbstractTypes(3 + numLocal, 4 + numLocal);\r\n            break;\r\n        case Frame.SAME_FRAME_EXTENDED:\r\n            stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED).putShort(offsetDelta);\r\n            break;\r\n        case Frame.CHOP_FRAME:\r\n            stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED + numLocalDelta).putShort(offsetDelta);\r\n            break;\r\n        case Frame.APPEND_FRAME:\r\n            stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED + numLocalDelta).putShort(offsetDelta);\r\n            putAbstractTypes(3 + previousNumlocal, 3 + numLocal);\r\n            break;\r\n        case Frame.FULL_FRAME:\r\n        default:\r\n            stackMapTableEntries.putByte(Frame.FULL_FRAME).putShort(offsetDelta).putShort(numLocal);\r\n            putAbstractTypes(3, 3 + numLocal);\r\n            stackMapTableEntries.putShort(numStack);\r\n            putAbstractTypes(3 + numLocal, 3 + numLocal + numStack);\r\n            break;\r\n    }\r\n}\n/**\r\n * Puts some abstract types of {@link #currentFrame} in {@link #stackMapTableEntries} , using the\r\n * JVMS verification_type_info format used in StackMapTable attributes.\r\n *\r\n * @param start index of the first type in {@link #currentFrame} to write.\r\n * @param end index of last type in {@link #currentFrame} to write (exclusive).\r\n */\r\nprivate void putAbstractTypes(final int start, final int end) {\r\n    for (int i = start; i < end; ++i) {\r\n        Frame.putAbstractType(symbolTable, currentFrame[i], stackMapTableEntries);\r\n    }\r\n}\n/**\r\n * Puts the given public API frame element type in {@link #stackMapTableEntries} , using the JVMS\r\n * verification_type_info format used in StackMapTable attributes.\r\n *\r\n * @param type a frame element type described using the same format as in {@link\r\n *     MethodVisitor#visitFrame}, i.e. either {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link\r\n *     Opcodes#FLOAT}, {@link Opcodes#LONG}, {@link Opcodes#DOUBLE}, {@link Opcodes#NULL}, or\r\n *     {@link Opcodes#UNINITIALIZED_THIS}, or the internal name of a class, or a Label designating\r\n *     a NEW instruction (for uninitialized types).\r\n */\r\nprivate void putFrameType(final Object type) {\r\n    if (type instanceof Integer) {\r\n        stackMapTableEntries.putByte(((Integer) type).intValue());\r\n    } else if (type instanceof String) {\r\n        stackMapTableEntries.putByte(Frame.ITEM_OBJECT).putShort(symbolTable.addConstantClass((String) type).index);\r\n    } else {\r\n        stackMapTableEntries.putByte(Frame.ITEM_UNINITIALIZED);\r\n        ((Label) type).put(stackMapTableEntries);\r\n    }\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Utility methods\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns whether the attributes of this method can be copied from the attributes of the given\r\n * method (assuming there is no method visitor between the given ClassReader and this\r\n * MethodWriter). This method should only be called just after this MethodWriter has been created,\r\n * and before any content is visited. It returns true if the attributes corresponding to the\r\n * constructor arguments (at most a Signature, an Exception, a Deprecated and a Synthetic\r\n * attribute) are the same as the corresponding attributes in the given method.\r\n *\r\n * @param source the source ClassReader from which the attributes of this method might be copied.\r\n * @param hasSyntheticAttribute whether the method_info JVMS structure from which the attributes\r\n *     of this method might be copied contains a Synthetic attribute.\r\n * @param hasDeprecatedAttribute whether the method_info JVMS structure from which the attributes\r\n *     of this method might be copied contains a Deprecated attribute.\r\n * @param descriptorIndex the descriptor_index field of the method_info JVMS structure from which\r\n *     the attributes of this method might be copied.\r\n * @param signatureIndex the constant pool index contained in the Signature attribute of the\r\n *     method_info JVMS structure from which the attributes of this method might be copied, or 0.\r\n * @param exceptionsOffset the offset in 'source.b' of the Exceptions attribute of the method_info\r\n *     JVMS structure from which the attributes of this method might be copied, or 0.\r\n * @return whether the attributes of this method can be copied from the attributes of the\r\n *     method_info JVMS structure in 'source.b', between 'methodInfoOffset' and 'methodInfoOffset'\r\n *     + 'methodInfoLength'.\r\n */\r\nboolean canCopyMethodAttributes(final ClassReader source, final boolean hasSyntheticAttribute, final boolean hasDeprecatedAttribute, final int descriptorIndex, final int signatureIndex, final int exceptionsOffset) {\r\n    // If the method descriptor has changed, with more locals than the max_locals field of the\r\n    // original Code attribute, if any, then the original method attributes can't be copied. A\r\n    // conservative check on the descriptor changes alone ensures this (being more precise is not\r\n    // worth the additional complexity, because these cases should be rare -- if a transform changes\r\n    // a method descriptor, most of the time it needs to change the method's code too).\r\n    if (source != symbolTable.getSource() || descriptorIndex != this.descriptorIndex || signatureIndex != this.signatureIndex || hasDeprecatedAttribute != ((accessFlags & Opcodes.ACC_DEPRECATED) != 0)) {\r\n        return false;\r\n    }\r\n    boolean needSyntheticAttribute = symbolTable.getMajorVersion() < Opcodes.V1_5 && (accessFlags & Opcodes.ACC_SYNTHETIC) != 0;\r\n    if (hasSyntheticAttribute != needSyntheticAttribute) {\r\n        return false;\r\n    }\r\n    if (exceptionsOffset == 0) {\r\n        if (numberOfExceptions != 0) {\r\n            return false;\r\n        }\r\n    } else if (source.readUnsignedShort(exceptionsOffset) == numberOfExceptions) {\r\n        int currentExceptionOffset = exceptionsOffset + 2;\r\n        for (int i = 0; i < numberOfExceptions; ++i) {\r\n            if (source.readUnsignedShort(currentExceptionOffset) != exceptionIndexTable[i]) {\r\n                return false;\r\n            }\r\n            currentExceptionOffset += 2;\r\n        }\r\n    }\r\n    return true;\r\n}\n/**\r\n * Sets the source from which the attributes of this method will be copied.\r\n *\r\n * @param methodInfoOffset the offset in 'symbolTable.getSource()' of the method_info JVMS\r\n *     structure from which the attributes of this method will be copied.\r\n * @param methodInfoLength the length in 'symbolTable.getSource()' of the method_info JVMS\r\n *     structure from which the attributes of this method will be copied.\r\n */\r\nvoid setMethodAttributesSource(final int methodInfoOffset, final int methodInfoLength) {\r\n    // Don't copy the attributes yet, instead store their location in the source class reader so\r\n    // they can be copied later, in {@link #putMethodInfo}. Note that we skip the 6 header bytes\r\n    // of the method_info JVMS structure.\r\n    this.sourceOffset = methodInfoOffset + 6;\r\n    this.sourceLength = methodInfoLength - 6;\r\n}\n/**\r\n * Returns the size of the method_info JVMS structure generated by this MethodWriter. Also add the\r\n * names of the attributes of this method in the constant pool.\r\n *\r\n * @return the size in bytes of the method_info JVMS structure.\r\n */\r\nint computeMethodInfoSize() {\r\n    // If this method_info must be copied from an existing one, the size computation is trivial.\r\n    if (sourceOffset != 0) {\r\n        // sourceLength excludes the first 6 bytes for access_flags, name_index and descriptor_index.\r\n        return 6 + sourceLength;\r\n    }\r\n    // 2 bytes each for access_flags, name_index, descriptor_index and attributes_count.\r\n    int size = 8;\r\n    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\r\n    if (code.length > 0) {\r\n        if (code.length > 65535) {\r\n            throw new MethodTooLargeException(symbolTable.getClassName(), name, descriptor, code.length);\r\n        }\r\n        symbolTable.addConstantUtf8(Constants.CODE);\r\n        // The Code attribute has 6 header bytes, plus 2, 2, 4 and 2 bytes respectively for max_stack,\r\n        // max_locals, code_length and attributes_count, plus the bytecode and the exception table.\r\n        size += 16 + code.length + Handler.getExceptionTableSize(firstHandler);\r\n        if (stackMapTableEntries != null) {\r\n            boolean useStackMapTable = symbolTable.getMajorVersion() >= Opcodes.V1_6;\r\n            symbolTable.addConstantUtf8(useStackMapTable ? Constants.STACK_MAP_TABLE : \"StackMap\");\r\n            // 6 header bytes and 2 bytes for number_of_entries.\r\n            size += 8 + stackMapTableEntries.length;\r\n        }\r\n        if (lineNumberTable != null) {\r\n            symbolTable.addConstantUtf8(Constants.LINE_NUMBER_TABLE);\r\n            // 6 header bytes and 2 bytes for line_number_table_length.\r\n            size += 8 + lineNumberTable.length;\r\n        }\r\n        if (localVariableTable != null) {\r\n            symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TABLE);\r\n            // 6 header bytes and 2 bytes for local_variable_table_length.\r\n            size += 8 + localVariableTable.length;\r\n        }\r\n        if (localVariableTypeTable != null) {\r\n            symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TYPE_TABLE);\r\n            // 6 header bytes and 2 bytes for local_variable_type_table_length.\r\n            size += 8 + localVariableTypeTable.length;\r\n        }\r\n        if (lastCodeRuntimeVisibleTypeAnnotation != null) {\r\n            size += lastCodeRuntimeVisibleTypeAnnotation.computeAnnotationsSize(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\r\n        }\r\n        if (lastCodeRuntimeInvisibleTypeAnnotation != null) {\r\n            size += lastCodeRuntimeInvisibleTypeAnnotation.computeAnnotationsSize(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\r\n        }\r\n        if (firstCodeAttribute != null) {\r\n            size += firstCodeAttribute.computeAttributesSize(symbolTable, code.data, code.length, maxStack, maxLocals);\r\n        }\r\n    }\r\n    if (numberOfExceptions > 0) {\r\n        symbolTable.addConstantUtf8(Constants.EXCEPTIONS);\r\n        size += 8 + 2 * numberOfExceptions;\r\n    }\r\n    size += Attribute.computeAttributesSize(symbolTable, accessFlags, signatureIndex);\r\n    size += AnnotationWriter.computeAnnotationsSize(lastRuntimeVisibleAnnotation, lastRuntimeInvisibleAnnotation, lastRuntimeVisibleTypeAnnotation, lastRuntimeInvisibleTypeAnnotation);\r\n    if (lastRuntimeVisibleParameterAnnotations != null) {\r\n        size += AnnotationWriter.computeParameterAnnotationsSize(Constants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS, lastRuntimeVisibleParameterAnnotations, visibleAnnotableParameterCount == 0 ? lastRuntimeVisibleParameterAnnotations.length : visibleAnnotableParameterCount);\r\n    }\r\n    if (lastRuntimeInvisibleParameterAnnotations != null) {\r\n        size += AnnotationWriter.computeParameterAnnotationsSize(Constants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS, lastRuntimeInvisibleParameterAnnotations, invisibleAnnotableParameterCount == 0 ? lastRuntimeInvisibleParameterAnnotations.length : invisibleAnnotableParameterCount);\r\n    }\r\n    if (defaultValue != null) {\r\n        symbolTable.addConstantUtf8(Constants.ANNOTATION_DEFAULT);\r\n        size += 6 + defaultValue.length;\r\n    }\r\n    if (parameters != null) {\r\n        symbolTable.addConstantUtf8(Constants.METHOD_PARAMETERS);\r\n        // 6 header bytes and 1 byte for parameters_count.\r\n        size += 7 + parameters.length;\r\n    }\r\n    if (firstAttribute != null) {\r\n        size += firstAttribute.computeAttributesSize(symbolTable);\r\n    }\r\n    return size;\r\n}\n/**\r\n * Puts the content of the method_info JVMS structure generated by this MethodWriter into the\r\n * given ByteVector.\r\n *\r\n * @param output where the method_info structure must be put.\r\n */\r\nvoid putMethodInfo(final ByteVector output) {\r\n    boolean useSyntheticAttribute = symbolTable.getMajorVersion() < Opcodes.V1_5;\r\n    int mask = useSyntheticAttribute ? Opcodes.ACC_SYNTHETIC : 0;\r\n    output.putShort(accessFlags & ~mask).putShort(nameIndex).putShort(descriptorIndex);\r\n    // If this method_info must be copied from an existing one, copy it now and return early.\r\n    if (sourceOffset != 0) {\r\n        output.putByteArray(symbolTable.getSource().classFileBuffer, sourceOffset, sourceLength);\r\n        return;\r\n    }\r\n    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\r\n    int attributeCount = 0;\r\n    if (code.length > 0) {\r\n        ++attributeCount;\r\n    }\r\n    if (numberOfExceptions > 0) {\r\n        ++attributeCount;\r\n    }\r\n    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && useSyntheticAttribute) {\r\n        ++attributeCount;\r\n    }\r\n    if (signatureIndex != 0) {\r\n        ++attributeCount;\r\n    }\r\n    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {\r\n        ++attributeCount;\r\n    }\r\n    if (lastRuntimeVisibleAnnotation != null) {\r\n        ++attributeCount;\r\n    }\r\n    if (lastRuntimeInvisibleAnnotation != null) {\r\n        ++attributeCount;\r\n    }\r\n    if (lastRuntimeVisibleParameterAnnotations != null) {\r\n        ++attributeCount;\r\n    }\r\n    if (lastRuntimeInvisibleParameterAnnotations != null) {\r\n        ++attributeCount;\r\n    }\r\n    if (lastRuntimeVisibleTypeAnnotation != null) {\r\n        ++attributeCount;\r\n    }\r\n    if (lastRuntimeInvisibleTypeAnnotation != null) {\r\n        ++attributeCount;\r\n    }\r\n    if (defaultValue != null) {\r\n        ++attributeCount;\r\n    }\r\n    if (parameters != null) {\r\n        ++attributeCount;\r\n    }\r\n    if (firstAttribute != null) {\r\n        attributeCount += firstAttribute.getAttributeCount();\r\n    }\r\n    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\r\n    output.putShort(attributeCount);\r\n    if (code.length > 0) {\r\n        // 2, 2, 4 and 2 bytes respectively for max_stack, max_locals, code_length and\r\n        // attributes_count, plus the bytecode and the exception table.\r\n        int size = 10 + code.length + Handler.getExceptionTableSize(firstHandler);\r\n        int codeAttributeCount = 0;\r\n        if (stackMapTableEntries != null) {\r\n            // 6 header bytes and 2 bytes for number_of_entries.\r\n            size += 8 + stackMapTableEntries.length;\r\n            ++codeAttributeCount;\r\n        }\r\n        if (lineNumberTable != null) {\r\n            // 6 header bytes and 2 bytes for line_number_table_length.\r\n            size += 8 + lineNumberTable.length;\r\n            ++codeAttributeCount;\r\n        }\r\n        if (localVariableTable != null) {\r\n            // 6 header bytes and 2 bytes for local_variable_table_length.\r\n            size += 8 + localVariableTable.length;\r\n            ++codeAttributeCount;\r\n        }\r\n        if (localVariableTypeTable != null) {\r\n            // 6 header bytes and 2 bytes for local_variable_type_table_length.\r\n            size += 8 + localVariableTypeTable.length;\r\n            ++codeAttributeCount;\r\n        }\r\n        if (lastCodeRuntimeVisibleTypeAnnotation != null) {\r\n            size += lastCodeRuntimeVisibleTypeAnnotation.computeAnnotationsSize(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\r\n            ++codeAttributeCount;\r\n        }\r\n        if (lastCodeRuntimeInvisibleTypeAnnotation != null) {\r\n            size += lastCodeRuntimeInvisibleTypeAnnotation.computeAnnotationsSize(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\r\n            ++codeAttributeCount;\r\n        }\r\n        if (firstCodeAttribute != null) {\r\n            size += firstCodeAttribute.computeAttributesSize(symbolTable, code.data, code.length, maxStack, maxLocals);\r\n            codeAttributeCount += firstCodeAttribute.getAttributeCount();\r\n        }\r\n        output.putShort(symbolTable.addConstantUtf8(Constants.CODE)).putInt(size).putShort(maxStack).putShort(maxLocals).putInt(code.length).putByteArray(code.data, 0, code.length);\r\n        Handler.putExceptionTable(firstHandler, output);\r\n        output.putShort(codeAttributeCount);\r\n        if (stackMapTableEntries != null) {\r\n            boolean useStackMapTable = symbolTable.getMajorVersion() >= Opcodes.V1_6;\r\n            output.putShort(symbolTable.addConstantUtf8(useStackMapTable ? Constants.STACK_MAP_TABLE : \"StackMap\")).putInt(2 + stackMapTableEntries.length).putShort(stackMapTableNumberOfEntries).putByteArray(stackMapTableEntries.data, 0, stackMapTableEntries.length);\r\n        }\r\n        if (lineNumberTable != null) {\r\n            output.putShort(symbolTable.addConstantUtf8(Constants.LINE_NUMBER_TABLE)).putInt(2 + lineNumberTable.length).putShort(lineNumberTableLength).putByteArray(lineNumberTable.data, 0, lineNumberTable.length);\r\n        }\r\n        if (localVariableTable != null) {\r\n            output.putShort(symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TABLE)).putInt(2 + localVariableTable.length).putShort(localVariableTableLength).putByteArray(localVariableTable.data, 0, localVariableTable.length);\r\n        }\r\n        if (localVariableTypeTable != null) {\r\n            output.putShort(symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TYPE_TABLE)).putInt(2 + localVariableTypeTable.length).putShort(localVariableTypeTableLength).putByteArray(localVariableTypeTable.data, 0, localVariableTypeTable.length);\r\n        }\r\n        if (lastCodeRuntimeVisibleTypeAnnotation != null) {\r\n            lastCodeRuntimeVisibleTypeAnnotation.putAnnotations(symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS), output);\r\n        }\r\n        if (lastCodeRuntimeInvisibleTypeAnnotation != null) {\r\n            lastCodeRuntimeInvisibleTypeAnnotation.putAnnotations(symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS), output);\r\n        }\r\n        if (firstCodeAttribute != null) {\r\n            firstCodeAttribute.putAttributes(symbolTable, code.data, code.length, maxStack, maxLocals, output);\r\n        }\r\n    }\r\n    if (numberOfExceptions > 0) {\r\n        output.putShort(symbolTable.addConstantUtf8(Constants.EXCEPTIONS)).putInt(2 + 2 * numberOfExceptions).putShort(numberOfExceptions);\r\n        for (int exceptionIndex : exceptionIndexTable) {\r\n            output.putShort(exceptionIndex);\r\n        }\r\n    }\r\n    Attribute.putAttributes(symbolTable, accessFlags, signatureIndex, output);\r\n    AnnotationWriter.putAnnotations(symbolTable, lastRuntimeVisibleAnnotation, lastRuntimeInvisibleAnnotation, lastRuntimeVisibleTypeAnnotation, lastRuntimeInvisibleTypeAnnotation, output);\r\n    if (lastRuntimeVisibleParameterAnnotations != null) {\r\n        AnnotationWriter.putParameterAnnotations(symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS), lastRuntimeVisibleParameterAnnotations, visibleAnnotableParameterCount == 0 ? lastRuntimeVisibleParameterAnnotations.length : visibleAnnotableParameterCount, output);\r\n    }\r\n    if (lastRuntimeInvisibleParameterAnnotations != null) {\r\n        AnnotationWriter.putParameterAnnotations(symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS), lastRuntimeInvisibleParameterAnnotations, invisibleAnnotableParameterCount == 0 ? lastRuntimeInvisibleParameterAnnotations.length : invisibleAnnotableParameterCount, output);\r\n    }\r\n    if (defaultValue != null) {\r\n        output.putShort(symbolTable.addConstantUtf8(Constants.ANNOTATION_DEFAULT)).putInt(defaultValue.length).putByteArray(defaultValue.data, 0, defaultValue.length);\r\n    }\r\n    if (parameters != null) {\r\n        output.putShort(symbolTable.addConstantUtf8(Constants.METHOD_PARAMETERS)).putInt(1 + parameters.length).putByte(parametersCount).putByteArray(parameters.data, 0, parameters.length);\r\n    }\r\n    if (firstAttribute != null) {\r\n        firstAttribute.putAttributes(symbolTable, output);\r\n    }\r\n}\n/**\r\n * Collects the attributes of this method into the given set of attribute prototypes.\r\n *\r\n * @param attributePrototypes a set of attribute prototypes.\r\n */\r\nfinal void collectAttributePrototypes(final Attribute.Set attributePrototypes) {\r\n    attributePrototypes.addAttributes(firstAttribute);\r\n    attributePrototypes.addAttributes(firstCodeAttribute);\r\n}",
    "comment": "\n * A {@link MethodVisitor} that generates a corresponding 'method_info' structure, as defined in the\n * Java Virtual Machine Specification (JVMS).\n *\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.6\">JVMS\n *     4.6</a>\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n "
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#hasFrames()",
    "entityType": "method",
    "code": "boolean hasFrames() {\r\n    return stackMapTableNumberOfEntries > 0;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#hasAsmInstructions()",
    "entityType": "method",
    "code": "boolean hasAsmInstructions() {\r\n    return hasAsmInstructions;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitParameter(String,int)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Implementation of the MethodVisitor abstract class\r\n// -----------------------------------------------------------------------------------------------\r\n@Override\r\npublic void visitParameter(final String name, final int access) {\r\n    if (parameters == null) {\r\n        parameters = new ByteVector();\r\n    }\r\n    ++parametersCount;\r\n    parameters.putShort((name == null) ? 0 : symbolTable.addConstantUtf8(name)).putShort(access);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitAnnotationDefault()",
    "entityType": "method",
    "code": "@Override\r\npublic AnnotationVisitor visitAnnotationDefault() {\r\n    defaultValue = new ByteVector();\r\n    return new AnnotationWriter(symbolTable, /* useNamedValues= */\r\n    false, defaultValue, null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitAnnotation(String,boolean)",
    "entityType": "method",
    "code": "@Override\r\npublic AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\r\n    if (visible) {\r\n        return lastRuntimeVisibleAnnotation = AnnotationWriter.create(symbolTable, descriptor, lastRuntimeVisibleAnnotation);\r\n    } else {\r\n        return lastRuntimeInvisibleAnnotation = AnnotationWriter.create(symbolTable, descriptor, lastRuntimeInvisibleAnnotation);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitTypeAnnotation(int,TypePath,String,boolean)",
    "entityType": "method",
    "code": "@Override\r\npublic AnnotationVisitor visitTypeAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\r\n    if (visible) {\r\n        return lastRuntimeVisibleTypeAnnotation = AnnotationWriter.create(symbolTable, typeRef, typePath, descriptor, lastRuntimeVisibleTypeAnnotation);\r\n    } else {\r\n        return lastRuntimeInvisibleTypeAnnotation = AnnotationWriter.create(symbolTable, typeRef, typePath, descriptor, lastRuntimeInvisibleTypeAnnotation);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitAnnotableParameterCount(int,boolean)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitAnnotableParameterCount(final int parameterCount, final boolean visible) {\r\n    if (visible) {\r\n        visibleAnnotableParameterCount = parameterCount;\r\n    } else {\r\n        invisibleAnnotableParameterCount = parameterCount;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitParameterAnnotation(int,String,boolean)",
    "entityType": "method",
    "code": "@Override\r\npublic AnnotationVisitor visitParameterAnnotation(final int parameter, final String annotationDescriptor, final boolean visible) {\r\n    if (visible) {\r\n        if (lastRuntimeVisibleParameterAnnotations == null) {\r\n            lastRuntimeVisibleParameterAnnotations = new AnnotationWriter[Type.getArgumentCount(descriptor)];\r\n        }\r\n        return lastRuntimeVisibleParameterAnnotations[parameter] = AnnotationWriter.create(symbolTable, annotationDescriptor, lastRuntimeVisibleParameterAnnotations[parameter]);\r\n    } else {\r\n        if (lastRuntimeInvisibleParameterAnnotations == null) {\r\n            lastRuntimeInvisibleParameterAnnotations = new AnnotationWriter[Type.getArgumentCount(descriptor)];\r\n        }\r\n        return lastRuntimeInvisibleParameterAnnotations[parameter] = AnnotationWriter.create(symbolTable, annotationDescriptor, lastRuntimeInvisibleParameterAnnotations[parameter]);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitAttribute(Attribute)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitAttribute(final Attribute attribute) {\r\n    // Store the attributes in the <i>reverse</i> order of their visit by this method.\r\n    if (attribute.isCodeAttribute()) {\r\n        attribute.nextAttribute = firstCodeAttribute;\r\n        firstCodeAttribute = attribute;\r\n    } else {\r\n        attribute.nextAttribute = firstAttribute;\r\n        firstAttribute = attribute;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitCode()",
    "entityType": "method",
    "code": "@Override\r\npublic void visitCode() {\r\n    // Nothing to do.\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitFrame(int,int,Object[],int,Object[])",
    "entityType": "method",
    "code": "@Override\r\npublic void visitFrame(final int type, final int numLocal, final Object[] local, final int numStack, final Object[] stack) {\r\n    if (compute == COMPUTE_ALL_FRAMES) {\r\n        return;\r\n    }\r\n    if (compute == COMPUTE_INSERTED_FRAMES) {\r\n        if (currentBasicBlock.frame == null) {\r\n            // This should happen only once, for the implicit first frame (which is explicitly visited\r\n            // in ClassReader if the EXPAND_ASM_INSNS option is used - and COMPUTE_INSERTED_FRAMES\r\n            // can't be set if EXPAND_ASM_INSNS is not used).\r\n            currentBasicBlock.frame = new CurrentFrame(currentBasicBlock);\r\n            currentBasicBlock.frame.setInputFrameFromDescriptor(symbolTable, accessFlags, descriptor, numLocal);\r\n            currentBasicBlock.frame.accept(this);\r\n        } else {\r\n            if (type == Opcodes.F_NEW) {\r\n                currentBasicBlock.frame.setInputFrameFromApiFormat(symbolTable, numLocal, local, numStack, stack);\r\n            }\r\n            // If type is not F_NEW then it is F_INSERT by hypothesis, and currentBlock.frame contains\r\n            // the stack map frame at the current instruction, computed from the last F_NEW frame and\r\n            // the bytecode instructions in between (via calls to CurrentFrame#execute).\r\n            currentBasicBlock.frame.accept(this);\r\n        }\r\n    } else if (type == Opcodes.F_NEW) {\r\n        if (previousFrame == null) {\r\n            int argumentsSize = Type.getArgumentsAndReturnSizes(descriptor) >> 2;\r\n            Frame implicitFirstFrame = new Frame(new Label());\r\n            implicitFirstFrame.setInputFrameFromDescriptor(symbolTable, accessFlags, descriptor, argumentsSize);\r\n            implicitFirstFrame.accept(this);\r\n        }\r\n        currentLocals = numLocal;\r\n        int frameIndex = visitFrameStart(code.length, numLocal, numStack);\r\n        for (int i = 0; i < numLocal; ++i) {\r\n            currentFrame[frameIndex++] = Frame.getAbstractTypeFromApiFormat(symbolTable, local[i]);\r\n        }\r\n        for (int i = 0; i < numStack; ++i) {\r\n            currentFrame[frameIndex++] = Frame.getAbstractTypeFromApiFormat(symbolTable, stack[i]);\r\n        }\r\n        visitFrameEnd();\r\n    } else {\r\n        if (symbolTable.getMajorVersion() < Opcodes.V1_6) {\r\n            throw new IllegalArgumentException(\"Class versions V1_5 or less must use F_NEW frames.\");\r\n        }\r\n        int offsetDelta;\r\n        if (stackMapTableEntries == null) {\r\n            stackMapTableEntries = new ByteVector();\r\n            offsetDelta = code.length;\r\n        } else {\r\n            offsetDelta = code.length - previousFrameOffset - 1;\r\n            if (offsetDelta < 0) {\r\n                if (type == Opcodes.F_SAME) {\r\n                    return;\r\n                } else {\r\n                    throw new IllegalStateException();\r\n                }\r\n            }\r\n        }\r\n        switch(type) {\r\n            case Opcodes.F_FULL:\r\n                currentLocals = numLocal;\r\n                stackMapTableEntries.putByte(Frame.FULL_FRAME).putShort(offsetDelta).putShort(numLocal);\r\n                for (int i = 0; i < numLocal; ++i) {\r\n                    putFrameType(local[i]);\r\n                }\r\n                stackMapTableEntries.putShort(numStack);\r\n                for (int i = 0; i < numStack; ++i) {\r\n                    putFrameType(stack[i]);\r\n                }\r\n                break;\r\n            case Opcodes.F_APPEND:\r\n                currentLocals += numLocal;\r\n                stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED + numLocal).putShort(offsetDelta);\r\n                for (int i = 0; i < numLocal; ++i) {\r\n                    putFrameType(local[i]);\r\n                }\r\n                break;\r\n            case Opcodes.F_CHOP:\r\n                currentLocals -= numLocal;\r\n                stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED - numLocal).putShort(offsetDelta);\r\n                break;\r\n            case Opcodes.F_SAME:\r\n                if (offsetDelta < 64) {\r\n                    stackMapTableEntries.putByte(offsetDelta);\r\n                } else {\r\n                    stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED).putShort(offsetDelta);\r\n                }\r\n                break;\r\n            case Opcodes.F_SAME1:\r\n                if (offsetDelta < 64) {\r\n                    stackMapTableEntries.putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME + offsetDelta);\r\n                } else {\r\n                    stackMapTableEntries.putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED).putShort(offsetDelta);\r\n                }\r\n                putFrameType(stack[0]);\r\n                break;\r\n            default:\r\n                throw new IllegalArgumentException();\r\n        }\r\n        previousFrameOffset = code.length;\r\n        ++stackMapTableNumberOfEntries;\r\n    }\r\n    if (compute == COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES) {\r\n        relativeStackSize = numStack;\r\n        for (int i = 0; i < numStack; ++i) {\r\n            if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) {\r\n                relativeStackSize++;\r\n            }\r\n        }\r\n        if (relativeStackSize > maxRelativeStackSize) {\r\n            maxRelativeStackSize = relativeStackSize;\r\n        }\r\n    }\r\n    maxStack = Math.max(maxStack, numStack);\r\n    maxLocals = Math.max(maxLocals, currentLocals);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitInsn(int)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitInsn(final int opcode) {\r\n    lastBytecodeOffset = code.length;\r\n    // Add the instruction to the bytecode of the method.\r\n    code.putByte(opcode);\r\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\r\n    if (currentBasicBlock != null) {\r\n        if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\r\n            currentBasicBlock.frame.execute(opcode, 0, null, null);\r\n        } else {\r\n            int size = relativeStackSize + STACK_SIZE_DELTA[opcode];\r\n            if (size > maxRelativeStackSize) {\r\n                maxRelativeStackSize = size;\r\n            }\r\n            relativeStackSize = size;\r\n        }\r\n        if ((opcode >= Opcodes.IRETURN && opcode <= Opcodes.RETURN) || opcode == Opcodes.ATHROW) {\r\n            endCurrentBasicBlockWithNoSuccessor();\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitIntInsn(int,int)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitIntInsn(final int opcode, final int operand) {\r\n    lastBytecodeOffset = code.length;\r\n    // Add the instruction to the bytecode of the method.\r\n    if (opcode == Opcodes.SIPUSH) {\r\n        code.put12(opcode, operand);\r\n    } else {\r\n        // BIPUSH or NEWARRAY\r\n        code.put11(opcode, operand);\r\n    }\r\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\r\n    if (currentBasicBlock != null) {\r\n        if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\r\n            currentBasicBlock.frame.execute(opcode, operand, null, null);\r\n        } else if (opcode != Opcodes.NEWARRAY) {\r\n            // The stack size delta is 1 for BIPUSH or SIPUSH, and 0 for NEWARRAY.\r\n            int size = relativeStackSize + 1;\r\n            if (size > maxRelativeStackSize) {\r\n                maxRelativeStackSize = size;\r\n            }\r\n            relativeStackSize = size;\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractDecoderTests",
    "entityType": "class",
    "code": "/**\r\n * The decoder to test.\r\n */\r\nprotected D decoder;\n/**\r\n * Construct a new {@code AbstractDecoderTests} instance for the given decoder.\r\n * @param decoder the decoder\r\n */\r\nprotected AbstractDecoderTests(D decoder) {\r\n    Assert.notNull(decoder, \"Encoder must not be null\");\r\n    this.decoder = decoder;\r\n}\n/**\r\n * Subclasses should implement this method to test {@link Decoder#canDecode}.\r\n */\r\n@Test\r\nprotected abstract void canDecode() throws Exception;\n/**\r\n * Subclasses should implement this method to test {@link Decoder#decode}, possibly using\r\n * {@link #testDecodeAll} or other helper methods.\r\n */\r\n@Test\r\nprotected abstract void decode() throws Exception;\n/**\r\n * Subclasses should implement this method to test {@link Decoder#decodeToMono}, possibly using\r\n * {@link #testDecodeToMonoAll}.\r\n */\r\n@Test\r\nprotected abstract void decodeToMono() throws Exception;\n// Flux\r\n/**\r\n * Helper method that tests for a variety of {@link Flux} decoding scenarios. This method\r\n * invokes:\r\n * <ul>\r\n *     <li>{@link #testDecode(Publisher, ResolvableType, Consumer, MimeType, Map)}</li>\r\n *     <li>{@link #testDecodeError(Publisher, ResolvableType, MimeType, Map)}</li>\r\n *     <li>{@link #testDecodeCancel(Publisher, ResolvableType, MimeType, Map)}</li>\r\n *     <li>{@link #testDecodeEmpty(ResolvableType, MimeType, Map)}</li>\r\n * </ul>\r\n *\r\n * @param input the input to be provided to the decoder\r\n * @param outputClass the desired output class\r\n * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\r\n * @param <T> the output type\r\n */\r\nprotected <T> void testDecodeAll(Publisher<DataBuffer> input, Class<? extends T> outputClass, Consumer<StepVerifier.FirstStep<T>> stepConsumer) {\r\n    testDecodeAll(input, ResolvableType.forClass(outputClass), stepConsumer, null, null);\r\n}\n/**\r\n * Helper method that tests for a variety of {@link Flux} decoding scenarios. This method\r\n * invokes:\r\n * <ul>\r\n *     <li>{@link #testDecode(Publisher, ResolvableType, Consumer, MimeType, Map)}</li>\r\n *     <li>{@link #testDecodeError(Publisher, ResolvableType, MimeType, Map)}</li>\r\n *     <li>{@link #testDecodeCancel(Publisher, ResolvableType, MimeType, Map)}</li>\r\n *     <li>{@link #testDecodeEmpty(ResolvableType, MimeType, Map)}</li>\r\n * </ul>\r\n *\r\n * @param input the input to be provided to the decoder\r\n * @param outputType the desired output type\r\n * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n * @param <T> the output type\r\n */\r\nprotected <T> void testDecodeAll(Publisher<DataBuffer> input, ResolvableType outputType, Consumer<StepVerifier.FirstStep<T>> stepConsumer, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    testDecode(input, outputType, stepConsumer, mimeType, hints);\r\n    testDecodeError(input, outputType, mimeType, hints);\r\n    testDecodeCancel(input, outputType, mimeType, hints);\r\n    testDecodeEmpty(outputType, mimeType, hints);\r\n}\n/**\r\n * Test a standard {@link Decoder#decode decode} scenario. For example:\r\n * <pre class=\"code\">\r\n * byte[] bytes1 = ...\r\n * byte[] bytes2 = ...\r\n *\r\n * Flux&lt;DataBuffer&gt; input = Flux.concat(\r\n *   dataBuffer(bytes1),\r\n *   dataBuffer(bytes2));\r\n *\r\n * testDecodeAll(input, byte[].class, step -&gt; step\r\n *   .consumeNextWith(expectBytes(bytes1))\r\n *   .consumeNextWith(expectBytes(bytes2))\r\n * \t .verifyComplete());\r\n * </pre>\r\n *\r\n * @param input the input to be provided to the decoder\r\n * @param outputClass the desired output class\r\n * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\r\n * @param <T> the output type\r\n */\r\nprotected <T> void testDecode(Publisher<DataBuffer> input, Class<? extends T> outputClass, Consumer<StepVerifier.FirstStep<T>> stepConsumer) {\r\n    testDecode(input, ResolvableType.forClass(outputClass), stepConsumer, null, null);\r\n}\n/**\r\n * Test a standard {@link Decoder#decode decode} scenario. For example:\r\n * <pre class=\"code\">\r\n * byte[] bytes1 = ...\r\n * byte[] bytes2 = ...\r\n *\r\n * Flux&lt;DataBuffer&gt; input = Flux.concat(\r\n *   dataBuffer(bytes1),\r\n *   dataBuffer(bytes2));\r\n *\r\n * testDecodeAll(input, byte[].class, step -&gt; step\r\n *   .consumeNextWith(expectBytes(bytes1))\r\n *   .consumeNextWith(expectBytes(bytes2))\r\n * \t .verifyComplete());\r\n * </pre>\r\n *\r\n * @param input the input to be provided to the decoder\r\n * @param outputType the desired output type\r\n * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n * @param <T> the output type\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\nprotected <T> void testDecode(Publisher<DataBuffer> input, ResolvableType outputType, Consumer<StepVerifier.FirstStep<T>> stepConsumer, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    Flux<T> result = (Flux<T>) this.decoder.decode(input, outputType, mimeType, hints);\r\n    StepVerifier.FirstStep<T> step = StepVerifier.create(result);\r\n    stepConsumer.accept(step);\r\n}\n/**\r\n * Test a {@link Decoder#decode decode} scenario where the input stream contains an error.\r\n * This test method will feed the first element of the {@code input} stream to the decoder,\r\n * followed by an {@link InputException}.\r\n * The result is expected to contain one \"normal\" element, followed by the error.\r\n *\r\n * @param input the input to be provided to the decoder\r\n * @param outputType the desired output type\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n * @see InputException\r\n */\r\nprotected void testDecodeError(Publisher<DataBuffer> input, ResolvableType outputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    Flux<DataBuffer> flux = Mono.from(input).concatWith(Flux.error(new InputException()));\r\n    assertThatExceptionOfType(InputException.class).isThrownBy(() -> this.decoder.decode(flux, outputType, mimeType, hints).doOnNext(object -> {\r\n        if (object instanceof Buffer buffer) {\r\n            buffer.close();\r\n        }\r\n    }).blockLast(Duration.ofSeconds(5)));\r\n}\n/**\r\n * Test a {@link Decoder#decode decode} scenario where the input stream is canceled.\r\n * This test method will feed the first element of the {@code input} stream to the decoder,\r\n * followed by a cancel signal.\r\n * The result is expected to contain one \"normal\" element.\r\n *\r\n * @param input the input to be provided to the decoder\r\n * @param outputType the desired output type\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n */\r\nprotected void testDecodeCancel(Publisher<DataBuffer> input, ResolvableType outputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    Flux<?> result = this.decoder.decode(input, outputType, mimeType, hints).doOnNext(object -> {\r\n        if (object instanceof Buffer buffer) {\r\n            buffer.close();\r\n        }\r\n    });\r\n    StepVerifier.create(result).expectNextCount(1).thenCancel().verify();\r\n}\n/**\r\n * Test a {@link Decoder#decode decode} scenario where the input stream is empty.\r\n * The output is expected to be empty as well.\r\n *\r\n * @param outputType the desired output type\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n */\r\nprotected void testDecodeEmpty(ResolvableType outputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    Flux<DataBuffer> input = Flux.empty();\r\n    Flux<?> result = this.decoder.decode(input, outputType, mimeType, hints);\r\n    StepVerifier.create(result).verifyComplete();\r\n}\n// Mono\r\n/**\r\n * Helper method that tests for a variety of {@link Mono} decoding scenarios. This method\r\n * invokes:\r\n * <ul>\r\n *     <li>{@link #testDecodeToMono(Publisher, ResolvableType, Consumer, MimeType, Map)}</li>\r\n *     <li>{@link #testDecodeToMonoError(Publisher, ResolvableType, MimeType, Map)}</li>\r\n *     <li>{@link #testDecodeToMonoCancel(Publisher, ResolvableType, MimeType, Map)}</li>\r\n *     <li>{@link #testDecodeToMonoEmpty(ResolvableType, MimeType, Map)}</li>\r\n * </ul>\r\n *\r\n * @param input the input to be provided to the decoder\r\n * @param outputClass the desired output class\r\n * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\r\n * @param <T> the output type\r\n */\r\nprotected <T> void testDecodeToMonoAll(Publisher<DataBuffer> input, Class<? extends T> outputClass, Consumer<StepVerifier.FirstStep<T>> stepConsumer) {\r\n    testDecodeToMonoAll(input, ResolvableType.forClass(outputClass), stepConsumer, null, null);\r\n}\n/**\r\n * Helper method that tests for a variety of {@link Mono} decoding scenarios. This method\r\n * invokes:\r\n * <ul>\r\n *     <li>{@link #testDecodeToMono(Publisher, ResolvableType, Consumer, MimeType, Map)}</li>\r\n *     <li>{@link #testDecodeToMonoError(Publisher, ResolvableType, MimeType, Map)}</li>\r\n *     <li>{@link #testDecodeToMonoCancel(Publisher, ResolvableType, MimeType, Map)}</li>\r\n *     <li>{@link #testDecodeToMonoEmpty(ResolvableType, MimeType, Map)}</li>\r\n * </ul>\r\n *\r\n * @param input the input to be provided to the decoder\r\n * @param outputType the desired output type\r\n * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n * @param <T> the output type\r\n */\r\nprotected <T> void testDecodeToMonoAll(Publisher<DataBuffer> input, ResolvableType outputType, Consumer<StepVerifier.FirstStep<T>> stepConsumer, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    testDecodeToMono(input, outputType, stepConsumer, mimeType, hints);\r\n    testDecodeToMonoError(input, outputType, mimeType, hints);\r\n    testDecodeToMonoCancel(input, outputType, mimeType, hints);\r\n    testDecodeToMonoEmpty(outputType, mimeType, hints);\r\n}\n/**\r\n * Test a standard {@link Decoder#decodeToMono decode} scenario. For example:\r\n * <pre class=\"code\">\r\n * byte[] bytes1 = ...\r\n * byte[] bytes2 = ...\r\n * byte[] allBytes = ... // bytes1 + bytes2\r\n *\r\n * Flux&lt;DataBuffer&gt; input = Flux.concat(\r\n *   dataBuffer(bytes1),\r\n *   dataBuffer(bytes2));\r\n *\r\n * testDecodeAll(input, byte[].class, step -&gt; step\r\n *   .consumeNextWith(expectBytes(allBytes))\r\n * \t .verifyComplete());\r\n * </pre>\r\n *\r\n * @param input the input to be provided to the decoder\r\n * @param outputClass the desired output class\r\n * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\r\n * @param <T> the output type\r\n */\r\nprotected <T> void testDecodeToMono(Publisher<DataBuffer> input, Class<? extends T> outputClass, Consumer<StepVerifier.FirstStep<T>> stepConsumer) {\r\n    testDecodeToMono(input, ResolvableType.forClass(outputClass), stepConsumer, null, null);\r\n}\n/**\r\n * Test a standard {@link Decoder#decodeToMono decode} scenario. For example:\r\n * <pre class=\"code\">\r\n * byte[] bytes1 = ...\r\n * byte[] bytes2 = ...\r\n * byte[] allBytes = ... // bytes1 + bytes2\r\n *\r\n * Flux&lt;DataBuffer&gt; input = Flux.concat(\r\n *   dataBuffer(bytes1),\r\n *   dataBuffer(bytes2));\r\n *\r\n * testDecodeAll(input, byte[].class, step -&gt; step\r\n *   .consumeNextWith(expectBytes(allBytes))\r\n * \t .verifyComplete());\r\n * </pre>\r\n *\r\n * @param input the input to be provided to the decoder\r\n * @param outputType the desired output type\r\n * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n * @param <T> the output type\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\nprotected <T> void testDecodeToMono(Publisher<DataBuffer> input, ResolvableType outputType, Consumer<StepVerifier.FirstStep<T>> stepConsumer, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    Mono<T> result = (Mono<T>) this.decoder.decodeToMono(input, outputType, mimeType, hints);\r\n    StepVerifier.FirstStep<T> step = StepVerifier.create(result);\r\n    stepConsumer.accept(step);\r\n}\n/**\r\n * Test a {@link Decoder#decodeToMono decode} scenario where the input stream contains an error.\r\n * This test method will feed the first element of the {@code input} stream to the decoder,\r\n * followed by an {@link InputException}.\r\n * The result is expected to contain the error.\r\n *\r\n * @param input the input to be provided to the decoder\r\n * @param outputType the desired output type\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n * @see InputException\r\n */\r\nprotected void testDecodeToMonoError(Publisher<DataBuffer> input, ResolvableType outputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    input = Mono.from(input).concatWith(Flux.error(new InputException()));\r\n    Mono<?> result = this.decoder.decodeToMono(input, outputType, mimeType, hints);\r\n    StepVerifier.create(result).expectError(InputException.class).verify();\r\n}\n/**\r\n * Test a {@link Decoder#decodeToMono decode} scenario where the input stream is canceled.\r\n * This test method will immediately cancel the output stream.\r\n *\r\n * @param input the input to be provided to the decoder\r\n * @param outputType the desired output type\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n */\r\nprotected void testDecodeToMonoCancel(Publisher<DataBuffer> input, ResolvableType outputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    Mono<?> result = this.decoder.decodeToMono(input, outputType, mimeType, hints);\r\n    StepVerifier.create(result).thenCancel().verify();\r\n}\n/**\r\n * Test a {@link Decoder#decodeToMono decode} scenario where the input stream is empty.\r\n * The output is expected to be empty as well.\r\n *\r\n * @param outputType the desired output type\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n */\r\nprotected void testDecodeToMonoEmpty(ResolvableType outputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    Mono<?> result = this.decoder.decodeToMono(Flux.empty(), outputType, mimeType, hints);\r\n    StepVerifier.create(result).verifyComplete();\r\n}\n/**\r\n * Creates a deferred {@link DataBuffer} containing the given bytes.\r\n * @param bytes the bytes that are to be stored in the buffer\r\n * @return the deferred buffer\r\n */\r\nprotected Mono<DataBuffer> dataBuffer(byte[] bytes) {\r\n    return Mono.fromCallable(() -> {\r\n        DataBuffer dataBuffer = this.bufferFactory.allocateBuffer(bytes.length);\r\n        dataBuffer.write(bytes);\r\n        return dataBuffer;\r\n    });\r\n}\n/**\r\n * Exception used in {@link #testDecodeError} and {@link #testDecodeToMonoError}\r\n */\r\n@SuppressWarnings(\"serial\")\r\npublic static class InputException extends RuntimeException {\r\n}",
    "comment": "\n * Abstract base class for {@link Decoder} unit tests. Subclasses need to implement\n * {@link #canDecode()}, {@link #decode()} and {@link #decodeToMono()}, possibly using the wide\n * variety of helper methods like {@link #testDecodeAll} or {@link #testDecodeToMonoAll}.\n *\n * @author Arjen Poutsma\n * @since 5.1.3\n "
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractDecoderTests#canDecode()",
    "entityType": "method",
    "code": "/**\r\n * Subclasses should implement this method to test {@link Decoder#canDecode}.\r\n */\r\n@Test\r\nprotected abstract void canDecode() throws Exception;",
    "comment": "\n\t * Subclasses should implement this method to test {@link Decoder#canDecode}.\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractDecoderTests#decode()",
    "entityType": "method",
    "code": "/**\r\n * Subclasses should implement this method to test {@link Decoder#decode}, possibly using\r\n * {@link #testDecodeAll} or other helper methods.\r\n */\r\n@Test\r\nprotected abstract void decode() throws Exception;",
    "comment": "\n\t * Subclasses should implement this method to test {@link Decoder#decode}, possibly using\n\t * {@link #testDecodeAll} or other helper methods.\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractDecoderTests#decodeToMono()",
    "entityType": "method",
    "code": "/**\r\n * Subclasses should implement this method to test {@link Decoder#decodeToMono}, possibly using\r\n * {@link #testDecodeToMonoAll}.\r\n */\r\n@Test\r\nprotected abstract void decodeToMono() throws Exception;",
    "comment": "\n\t * Subclasses should implement this method to test {@link Decoder#decodeToMono}, possibly using\n\t * {@link #testDecodeToMonoAll}.\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeAll(Publisher<DataBuffer>,Class<? extends T>,Consumer<StepVerifier.FirstStep<T>>)",
    "entityType": "method",
    "code": "// Flux\r\n/**\r\n * Helper method that tests for a variety of {@link Flux} decoding scenarios. This method\r\n * invokes:\r\n * <ul>\r\n *     <li>{@link #testDecode(Publisher, ResolvableType, Consumer, MimeType, Map)}</li>\r\n *     <li>{@link #testDecodeError(Publisher, ResolvableType, MimeType, Map)}</li>\r\n *     <li>{@link #testDecodeCancel(Publisher, ResolvableType, MimeType, Map)}</li>\r\n *     <li>{@link #testDecodeEmpty(ResolvableType, MimeType, Map)}</li>\r\n * </ul>\r\n *\r\n * @param input the input to be provided to the decoder\r\n * @param outputClass the desired output class\r\n * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\r\n * @param <T> the output type\r\n */\r\nprotected <T> void testDecodeAll(Publisher<DataBuffer> input, Class<? extends T> outputClass, Consumer<StepVerifier.FirstStep<T>> stepConsumer) {\r\n    testDecodeAll(input, ResolvableType.forClass(outputClass), stepConsumer, null, null);\r\n}",
    "comment": "\n\t * Helper method that tests for a variety of {@link Flux} decoding scenarios. This method\n\t * invokes:\n\t * <ul>\n\t *     <li>{@link #testDecode(Publisher, ResolvableType, Consumer, MimeType, Map)}</li>\n\t *     <li>{@link #testDecodeError(Publisher, ResolvableType, MimeType, Map)}</li>\n\t *     <li>{@link #testDecodeCancel(Publisher, ResolvableType, MimeType, Map)}</li>\n\t *     <li>{@link #testDecodeEmpty(ResolvableType, MimeType, Map)}</li>\n\t * </ul>\n\t *\n\t * @param input the input to be provided to the decoder\n\t * @param outputClass the desired output class\n\t * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\n\t * @param <T> the output type\n\t "
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitVarInsn(int,int)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitVarInsn(final int opcode, final int varIndex) {\r\n    lastBytecodeOffset = code.length;\r\n    // Add the instruction to the bytecode of the method.\r\n    if (varIndex < 4 && opcode != Opcodes.RET) {\r\n        int optimizedOpcode;\r\n        if (opcode < Opcodes.ISTORE) {\r\n            optimizedOpcode = Constants.ILOAD_0 + ((opcode - Opcodes.ILOAD) << 2) + varIndex;\r\n        } else {\r\n            optimizedOpcode = Constants.ISTORE_0 + ((opcode - Opcodes.ISTORE) << 2) + varIndex;\r\n        }\r\n        code.putByte(optimizedOpcode);\r\n    } else if (varIndex >= 256) {\r\n        code.putByte(Constants.WIDE).put12(opcode, varIndex);\r\n    } else {\r\n        code.put11(opcode, varIndex);\r\n    }\r\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\r\n    if (currentBasicBlock != null) {\r\n        if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\r\n            currentBasicBlock.frame.execute(opcode, varIndex, null, null);\r\n        } else {\r\n            if (opcode == Opcodes.RET) {\r\n                // No stack size delta.\r\n                currentBasicBlock.flags |= Label.FLAG_SUBROUTINE_END;\r\n                currentBasicBlock.outputStackSize = (short) relativeStackSize;\r\n                endCurrentBasicBlockWithNoSuccessor();\r\n            } else {\r\n                // xLOAD or xSTORE\r\n                int size = relativeStackSize + STACK_SIZE_DELTA[opcode];\r\n                if (size > maxRelativeStackSize) {\r\n                    maxRelativeStackSize = size;\r\n                }\r\n                relativeStackSize = size;\r\n            }\r\n        }\r\n    }\r\n    if (compute != COMPUTE_NOTHING) {\r\n        int currentMaxLocals;\r\n        if (opcode == Opcodes.LLOAD || opcode == Opcodes.DLOAD || opcode == Opcodes.LSTORE || opcode == Opcodes.DSTORE) {\r\n            currentMaxLocals = varIndex + 2;\r\n        } else {\r\n            currentMaxLocals = varIndex + 1;\r\n        }\r\n        if (currentMaxLocals > maxLocals) {\r\n            maxLocals = currentMaxLocals;\r\n        }\r\n    }\r\n    if (opcode >= Opcodes.ISTORE && compute == COMPUTE_ALL_FRAMES && firstHandler != null) {\r\n        // If there are exception handler blocks, each instruction within a handler range is, in\r\n        // theory, a basic block (since execution can jump from this instruction to the exception\r\n        // handler). As a consequence, the local variable types at the beginning of the handler\r\n        // block should be the merge of the local variable types at all the instructions within the\r\n        // handler range. However, instead of creating a basic block for each instruction, we can\r\n        // get the same result in a more efficient way. Namely, by starting a new basic block after\r\n        // each xSTORE instruction, which is what we do here.\r\n        visitLabel(new Label());\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeAll(Publisher<DataBuffer>,ResolvableType,Consumer<StepVerifier.FirstStep<T>>,MimeType,Map<String,Object>)",
    "entityType": "method",
    "code": "/**\r\n * Helper method that tests for a variety of {@link Flux} decoding scenarios. This method\r\n * invokes:\r\n * <ul>\r\n *     <li>{@link #testDecode(Publisher, ResolvableType, Consumer, MimeType, Map)}</li>\r\n *     <li>{@link #testDecodeError(Publisher, ResolvableType, MimeType, Map)}</li>\r\n *     <li>{@link #testDecodeCancel(Publisher, ResolvableType, MimeType, Map)}</li>\r\n *     <li>{@link #testDecodeEmpty(ResolvableType, MimeType, Map)}</li>\r\n * </ul>\r\n *\r\n * @param input the input to be provided to the decoder\r\n * @param outputType the desired output type\r\n * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n * @param <T> the output type\r\n */\r\nprotected <T> void testDecodeAll(Publisher<DataBuffer> input, ResolvableType outputType, Consumer<StepVerifier.FirstStep<T>> stepConsumer, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    testDecode(input, outputType, stepConsumer, mimeType, hints);\r\n    testDecodeError(input, outputType, mimeType, hints);\r\n    testDecodeCancel(input, outputType, mimeType, hints);\r\n    testDecodeEmpty(outputType, mimeType, hints);\r\n}",
    "comment": "\n\t * Helper method that tests for a variety of {@link Flux} decoding scenarios. This method\n\t * invokes:\n\t * <ul>\n\t *     <li>{@link #testDecode(Publisher, ResolvableType, Consumer, MimeType, Map)}</li>\n\t *     <li>{@link #testDecodeError(Publisher, ResolvableType, MimeType, Map)}</li>\n\t *     <li>{@link #testDecodeCancel(Publisher, ResolvableType, MimeType, Map)}</li>\n\t *     <li>{@link #testDecodeEmpty(ResolvableType, MimeType, Map)}</li>\n\t * </ul>\n\t *\n\t * @param input the input to be provided to the decoder\n\t * @param outputType the desired output type\n\t * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t * @param <T> the output type\n\t "
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitTypeInsn(int,String)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitTypeInsn(final int opcode, final String type) {\r\n    lastBytecodeOffset = code.length;\r\n    // Add the instruction to the bytecode of the method.\r\n    Symbol typeSymbol = symbolTable.addConstantClass(type);\r\n    code.put12(opcode, typeSymbol.index);\r\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\r\n    if (currentBasicBlock != null) {\r\n        if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\r\n            currentBasicBlock.frame.execute(opcode, lastBytecodeOffset, typeSymbol, symbolTable);\r\n        } else if (opcode == Opcodes.NEW) {\r\n            // The stack size delta is 1 for NEW, and 0 for ANEWARRAY, CHECKCAST, or INSTANCEOF.\r\n            int size = relativeStackSize + 1;\r\n            if (size > maxRelativeStackSize) {\r\n                maxRelativeStackSize = size;\r\n            }\r\n            relativeStackSize = size;\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecode(Publisher<DataBuffer>,Class<? extends T>,Consumer<StepVerifier.FirstStep<T>>)",
    "entityType": "method",
    "code": "/**\r\n * Test a standard {@link Decoder#decode decode} scenario. For example:\r\n * <pre class=\"code\">\r\n * byte[] bytes1 = ...\r\n * byte[] bytes2 = ...\r\n *\r\n * Flux&lt;DataBuffer&gt; input = Flux.concat(\r\n *   dataBuffer(bytes1),\r\n *   dataBuffer(bytes2));\r\n *\r\n * testDecodeAll(input, byte[].class, step -&gt; step\r\n *   .consumeNextWith(expectBytes(bytes1))\r\n *   .consumeNextWith(expectBytes(bytes2))\r\n * \t .verifyComplete());\r\n * </pre>\r\n *\r\n * @param input the input to be provided to the decoder\r\n * @param outputClass the desired output class\r\n * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\r\n * @param <T> the output type\r\n */\r\nprotected <T> void testDecode(Publisher<DataBuffer> input, Class<? extends T> outputClass, Consumer<StepVerifier.FirstStep<T>> stepConsumer) {\r\n    testDecode(input, ResolvableType.forClass(outputClass), stepConsumer, null, null);\r\n}",
    "comment": "\n\t * Test a standard {@link Decoder#decode decode} scenario. For example:\n\t * <pre class=\"code\">\n\t * byte[] bytes1 = ...\n\t * byte[] bytes2 = ...\n\t *\n\t * Flux&lt;DataBuffer&gt; input = Flux.concat(\n\t *   dataBuffer(bytes1),\n\t *   dataBuffer(bytes2));\n\t *\n\t * testDecodeAll(input, byte[].class, step -&gt; step\n\t *   .consumeNextWith(expectBytes(bytes1))\n\t *   .consumeNextWith(expectBytes(bytes2))\n\t * \t .verifyComplete());\n\t * </pre>\n\t *\n\t * @param input the input to be provided to the decoder\n\t * @param outputClass the desired output class\n\t * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\n\t * @param <T> the output type\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecode(Publisher<DataBuffer>,ResolvableType,Consumer<StepVerifier.FirstStep<T>>,MimeType,Map<String,Object>)",
    "entityType": "method",
    "code": "/**\r\n * Test a standard {@link Decoder#decode decode} scenario. For example:\r\n * <pre class=\"code\">\r\n * byte[] bytes1 = ...\r\n * byte[] bytes2 = ...\r\n *\r\n * Flux&lt;DataBuffer&gt; input = Flux.concat(\r\n *   dataBuffer(bytes1),\r\n *   dataBuffer(bytes2));\r\n *\r\n * testDecodeAll(input, byte[].class, step -&gt; step\r\n *   .consumeNextWith(expectBytes(bytes1))\r\n *   .consumeNextWith(expectBytes(bytes2))\r\n * \t .verifyComplete());\r\n * </pre>\r\n *\r\n * @param input the input to be provided to the decoder\r\n * @param outputType the desired output type\r\n * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n * @param <T> the output type\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\nprotected <T> void testDecode(Publisher<DataBuffer> input, ResolvableType outputType, Consumer<StepVerifier.FirstStep<T>> stepConsumer, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    Flux<T> result = (Flux<T>) this.decoder.decode(input, outputType, mimeType, hints);\r\n    StepVerifier.FirstStep<T> step = StepVerifier.create(result);\r\n    stepConsumer.accept(step);\r\n}",
    "comment": "\n\t * Test a standard {@link Decoder#decode decode} scenario. For example:\n\t * <pre class=\"code\">\n\t * byte[] bytes1 = ...\n\t * byte[] bytes2 = ...\n\t *\n\t * Flux&lt;DataBuffer&gt; input = Flux.concat(\n\t *   dataBuffer(bytes1),\n\t *   dataBuffer(bytes2));\n\t *\n\t * testDecodeAll(input, byte[].class, step -&gt; step\n\t *   .consumeNextWith(expectBytes(bytes1))\n\t *   .consumeNextWith(expectBytes(bytes2))\n\t * \t .verifyComplete());\n\t * </pre>\n\t *\n\t * @param input the input to be provided to the decoder\n\t * @param outputType the desired output type\n\t * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t * @param <T> the output type\n\t "
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitFieldInsn(int,String,String,String)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitFieldInsn(final int opcode, final String owner, final String name, final String descriptor) {\r\n    lastBytecodeOffset = code.length;\r\n    // Add the instruction to the bytecode of the method.\r\n    Symbol fieldrefSymbol = symbolTable.addConstantFieldref(owner, name, descriptor);\r\n    code.put12(opcode, fieldrefSymbol.index);\r\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\r\n    if (currentBasicBlock != null) {\r\n        if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\r\n            currentBasicBlock.frame.execute(opcode, 0, fieldrefSymbol, symbolTable);\r\n        } else {\r\n            int size;\r\n            char firstDescChar = descriptor.charAt(0);\r\n            switch(opcode) {\r\n                case Opcodes.GETSTATIC:\r\n                    size = relativeStackSize + (firstDescChar == 'D' || firstDescChar == 'J' ? 2 : 1);\r\n                    break;\r\n                case Opcodes.PUTSTATIC:\r\n                    size = relativeStackSize + (firstDescChar == 'D' || firstDescChar == 'J' ? -2 : -1);\r\n                    break;\r\n                case Opcodes.GETFIELD:\r\n                    size = relativeStackSize + (firstDescChar == 'D' || firstDescChar == 'J' ? 1 : 0);\r\n                    break;\r\n                case Opcodes.PUTFIELD:\r\n                default:\r\n                    size = relativeStackSize + (firstDescChar == 'D' || firstDescChar == 'J' ? -3 : -2);\r\n                    break;\r\n            }\r\n            if (size > maxRelativeStackSize) {\r\n                maxRelativeStackSize = size;\r\n            }\r\n            relativeStackSize = size;\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeError(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
    "entityType": "method",
    "code": "/**\r\n * Test a {@link Decoder#decode decode} scenario where the input stream contains an error.\r\n * This test method will feed the first element of the {@code input} stream to the decoder,\r\n * followed by an {@link InputException}.\r\n * The result is expected to contain one \"normal\" element, followed by the error.\r\n *\r\n * @param input the input to be provided to the decoder\r\n * @param outputType the desired output type\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n * @see InputException\r\n */\r\nprotected void testDecodeError(Publisher<DataBuffer> input, ResolvableType outputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    Flux<DataBuffer> flux = Mono.from(input).concatWith(Flux.error(new InputException()));\r\n    assertThatExceptionOfType(InputException.class).isThrownBy(() -> this.decoder.decode(flux, outputType, mimeType, hints).doOnNext(object -> {\r\n        if (object instanceof Buffer buffer) {\r\n            buffer.close();\r\n        }\r\n    }).blockLast(Duration.ofSeconds(5)));\r\n}",
    "comment": "\n\t * Test a {@link Decoder#decode decode} scenario where the input stream contains an error.\n\t * This test method will feed the first element of the {@code input} stream to the decoder,\n\t * followed by an {@link InputException}.\n\t * The result is expected to contain one \"normal\" element, followed by the error.\n\t *\n\t * @param input the input to be provided to the decoder\n\t * @param outputType the desired output type\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t * @see InputException\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeCancel(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
    "entityType": "method",
    "code": "/**\r\n * Test a {@link Decoder#decode decode} scenario where the input stream is canceled.\r\n * This test method will feed the first element of the {@code input} stream to the decoder,\r\n * followed by a cancel signal.\r\n * The result is expected to contain one \"normal\" element.\r\n *\r\n * @param input the input to be provided to the decoder\r\n * @param outputType the desired output type\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n */\r\nprotected void testDecodeCancel(Publisher<DataBuffer> input, ResolvableType outputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    Flux<?> result = this.decoder.decode(input, outputType, mimeType, hints).doOnNext(object -> {\r\n        if (object instanceof Buffer buffer) {\r\n            buffer.close();\r\n        }\r\n    });\r\n    StepVerifier.create(result).expectNextCount(1).thenCancel().verify();\r\n}",
    "comment": "\n\t * Test a {@link Decoder#decode decode} scenario where the input stream is canceled.\n\t * This test method will feed the first element of the {@code input} stream to the decoder,\n\t * followed by a cancel signal.\n\t * The result is expected to contain one \"normal\" element.\n\t *\n\t * @param input the input to be provided to the decoder\n\t * @param outputType the desired output type\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t "
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitMethodInsn(int,String,String,String,boolean)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitMethodInsn(final int opcode, final String owner, final String name, final String descriptor, final boolean isInterface) {\r\n    lastBytecodeOffset = code.length;\r\n    // Add the instruction to the bytecode of the method.\r\n    Symbol methodrefSymbol = symbolTable.addConstantMethodref(owner, name, descriptor, isInterface);\r\n    if (opcode == Opcodes.INVOKEINTERFACE) {\r\n        code.put12(Opcodes.INVOKEINTERFACE, methodrefSymbol.index).put11(methodrefSymbol.getArgumentsAndReturnSizes() >> 2, 0);\r\n    } else {\r\n        code.put12(opcode, methodrefSymbol.index);\r\n    }\r\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\r\n    if (currentBasicBlock != null) {\r\n        if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\r\n            currentBasicBlock.frame.execute(opcode, 0, methodrefSymbol, symbolTable);\r\n        } else {\r\n            int argumentsAndReturnSize = methodrefSymbol.getArgumentsAndReturnSizes();\r\n            int stackSizeDelta = (argumentsAndReturnSize & 3) - (argumentsAndReturnSize >> 2);\r\n            int size;\r\n            if (opcode == Opcodes.INVOKESTATIC) {\r\n                size = relativeStackSize + stackSizeDelta + 1;\r\n            } else {\r\n                size = relativeStackSize + stackSizeDelta;\r\n            }\r\n            if (size > maxRelativeStackSize) {\r\n                maxRelativeStackSize = size;\r\n            }\r\n            relativeStackSize = size;\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeEmpty(ResolvableType,MimeType,Map<String,Object>)",
    "entityType": "method",
    "code": "/**\r\n * Test a {@link Decoder#decode decode} scenario where the input stream is empty.\r\n * The output is expected to be empty as well.\r\n *\r\n * @param outputType the desired output type\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n */\r\nprotected void testDecodeEmpty(ResolvableType outputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    Flux<DataBuffer> input = Flux.empty();\r\n    Flux<?> result = this.decoder.decode(input, outputType, mimeType, hints);\r\n    StepVerifier.create(result).verifyComplete();\r\n}",
    "comment": "\n\t * Test a {@link Decoder#decode decode} scenario where the input stream is empty.\n\t * The output is expected to be empty as well.\n\t *\n\t * @param outputType the desired output type\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t "
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitInvokeDynamicInsn(String,String,Handle,Object)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitInvokeDynamicInsn(final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\r\n    lastBytecodeOffset = code.length;\r\n    // Add the instruction to the bytecode of the method.\r\n    Symbol invokeDynamicSymbol = symbolTable.addConstantInvokeDynamic(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);\r\n    code.put12(Opcodes.INVOKEDYNAMIC, invokeDynamicSymbol.index);\r\n    code.putShort(0);\r\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\r\n    if (currentBasicBlock != null) {\r\n        if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\r\n            currentBasicBlock.frame.execute(Opcodes.INVOKEDYNAMIC, 0, invokeDynamicSymbol, symbolTable);\r\n        } else {\r\n            int argumentsAndReturnSize = invokeDynamicSymbol.getArgumentsAndReturnSizes();\r\n            int stackSizeDelta = (argumentsAndReturnSize & 3) - (argumentsAndReturnSize >> 2) + 1;\r\n            int size = relativeStackSize + stackSizeDelta;\r\n            if (size > maxRelativeStackSize) {\r\n                maxRelativeStackSize = size;\r\n            }\r\n            relativeStackSize = size;\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoAll(Publisher<DataBuffer>,Class<? extends T>,Consumer<StepVerifier.FirstStep<T>>)",
    "entityType": "method",
    "code": "// Mono\r\n/**\r\n * Helper method that tests for a variety of {@link Mono} decoding scenarios. This method\r\n * invokes:\r\n * <ul>\r\n *     <li>{@link #testDecodeToMono(Publisher, ResolvableType, Consumer, MimeType, Map)}</li>\r\n *     <li>{@link #testDecodeToMonoError(Publisher, ResolvableType, MimeType, Map)}</li>\r\n *     <li>{@link #testDecodeToMonoCancel(Publisher, ResolvableType, MimeType, Map)}</li>\r\n *     <li>{@link #testDecodeToMonoEmpty(ResolvableType, MimeType, Map)}</li>\r\n * </ul>\r\n *\r\n * @param input the input to be provided to the decoder\r\n * @param outputClass the desired output class\r\n * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\r\n * @param <T> the output type\r\n */\r\nprotected <T> void testDecodeToMonoAll(Publisher<DataBuffer> input, Class<? extends T> outputClass, Consumer<StepVerifier.FirstStep<T>> stepConsumer) {\r\n    testDecodeToMonoAll(input, ResolvableType.forClass(outputClass), stepConsumer, null, null);\r\n}",
    "comment": "\n\t * Helper method that tests for a variety of {@link Mono} decoding scenarios. This method\n\t * invokes:\n\t * <ul>\n\t *     <li>{@link #testDecodeToMono(Publisher, ResolvableType, Consumer, MimeType, Map)}</li>\n\t *     <li>{@link #testDecodeToMonoError(Publisher, ResolvableType, MimeType, Map)}</li>\n\t *     <li>{@link #testDecodeToMonoCancel(Publisher, ResolvableType, MimeType, Map)}</li>\n\t *     <li>{@link #testDecodeToMonoEmpty(ResolvableType, MimeType, Map)}</li>\n\t * </ul>\n\t *\n\t * @param input the input to be provided to the decoder\n\t * @param outputClass the desired output class\n\t * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\n\t * @param <T> the output type\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoAll(Publisher<DataBuffer>,ResolvableType,Consumer<StepVerifier.FirstStep<T>>,MimeType,Map<String,Object>)",
    "entityType": "method",
    "code": "/**\r\n * Helper method that tests for a variety of {@link Mono} decoding scenarios. This method\r\n * invokes:\r\n * <ul>\r\n *     <li>{@link #testDecodeToMono(Publisher, ResolvableType, Consumer, MimeType, Map)}</li>\r\n *     <li>{@link #testDecodeToMonoError(Publisher, ResolvableType, MimeType, Map)}</li>\r\n *     <li>{@link #testDecodeToMonoCancel(Publisher, ResolvableType, MimeType, Map)}</li>\r\n *     <li>{@link #testDecodeToMonoEmpty(ResolvableType, MimeType, Map)}</li>\r\n * </ul>\r\n *\r\n * @param input the input to be provided to the decoder\r\n * @param outputType the desired output type\r\n * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n * @param <T> the output type\r\n */\r\nprotected <T> void testDecodeToMonoAll(Publisher<DataBuffer> input, ResolvableType outputType, Consumer<StepVerifier.FirstStep<T>> stepConsumer, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    testDecodeToMono(input, outputType, stepConsumer, mimeType, hints);\r\n    testDecodeToMonoError(input, outputType, mimeType, hints);\r\n    testDecodeToMonoCancel(input, outputType, mimeType, hints);\r\n    testDecodeToMonoEmpty(outputType, mimeType, hints);\r\n}",
    "comment": "\n\t * Helper method that tests for a variety of {@link Mono} decoding scenarios. This method\n\t * invokes:\n\t * <ul>\n\t *     <li>{@link #testDecodeToMono(Publisher, ResolvableType, Consumer, MimeType, Map)}</li>\n\t *     <li>{@link #testDecodeToMonoError(Publisher, ResolvableType, MimeType, Map)}</li>\n\t *     <li>{@link #testDecodeToMonoCancel(Publisher, ResolvableType, MimeType, Map)}</li>\n\t *     <li>{@link #testDecodeToMonoEmpty(ResolvableType, MimeType, Map)}</li>\n\t * </ul>\n\t *\n\t * @param input the input to be provided to the decoder\n\t * @param outputType the desired output type\n\t * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t * @param <T> the output type\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMono(Publisher<DataBuffer>,Class<? extends T>,Consumer<StepVerifier.FirstStep<T>>)",
    "entityType": "method",
    "code": "/**\r\n * Test a standard {@link Decoder#decodeToMono decode} scenario. For example:\r\n * <pre class=\"code\">\r\n * byte[] bytes1 = ...\r\n * byte[] bytes2 = ...\r\n * byte[] allBytes = ... // bytes1 + bytes2\r\n *\r\n * Flux&lt;DataBuffer&gt; input = Flux.concat(\r\n *   dataBuffer(bytes1),\r\n *   dataBuffer(bytes2));\r\n *\r\n * testDecodeAll(input, byte[].class, step -&gt; step\r\n *   .consumeNextWith(expectBytes(allBytes))\r\n * \t .verifyComplete());\r\n * </pre>\r\n *\r\n * @param input the input to be provided to the decoder\r\n * @param outputClass the desired output class\r\n * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\r\n * @param <T> the output type\r\n */\r\nprotected <T> void testDecodeToMono(Publisher<DataBuffer> input, Class<? extends T> outputClass, Consumer<StepVerifier.FirstStep<T>> stepConsumer) {\r\n    testDecodeToMono(input, ResolvableType.forClass(outputClass), stepConsumer, null, null);\r\n}",
    "comment": "\n\t * Test a standard {@link Decoder#decodeToMono decode} scenario. For example:\n\t * <pre class=\"code\">\n\t * byte[] bytes1 = ...\n\t * byte[] bytes2 = ...\n\t * byte[] allBytes = ... // bytes1 + bytes2\n\t *\n\t * Flux&lt;DataBuffer&gt; input = Flux.concat(\n\t *   dataBuffer(bytes1),\n\t *   dataBuffer(bytes2));\n\t *\n\t * testDecodeAll(input, byte[].class, step -&gt; step\n\t *   .consumeNextWith(expectBytes(allBytes))\n\t * \t .verifyComplete());\n\t * </pre>\n\t *\n\t * @param input the input to be provided to the decoder\n\t * @param outputClass the desired output class\n\t * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\n\t * @param <T> the output type\n\t "
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitJumpInsn(int,Label)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitJumpInsn(final int opcode, final Label label) {\r\n    lastBytecodeOffset = code.length;\r\n    // Add the instruction to the bytecode of the method.\r\n    // Compute the 'base' opcode, i.e. GOTO or JSR if opcode is GOTO_W or JSR_W, otherwise opcode.\r\n    int baseOpcode = opcode >= Constants.GOTO_W ? opcode - Constants.WIDE_JUMP_OPCODE_DELTA : opcode;\r\n    boolean nextInsnIsJumpTarget = false;\r\n    if ((label.flags & Label.FLAG_RESOLVED) != 0 && label.bytecodeOffset - code.length < Short.MIN_VALUE) {\r\n        // Case of a backward jump with an offset < -32768. In this case we automatically replace GOTO\r\n        // with GOTO_W, JSR with JSR_W and IFxxx <l> with IFNOTxxx <L> GOTO_W <l> L:..., where\r\n        // IFNOTxxx is the \"opposite\" opcode of IFxxx (for example, IFNE for IFEQ) and where <L> designates\r\n        // the instruction just after the GOTO_W.\r\n        if (baseOpcode == Opcodes.GOTO) {\r\n            code.putByte(Constants.GOTO_W);\r\n        } else if (baseOpcode == Opcodes.JSR) {\r\n            code.putByte(Constants.JSR_W);\r\n        } else {\r\n            // Put the \"opposite\" opcode of baseOpcode. This can be done by flipping the least\r\n            // significant bit for IFNULL and IFNONNULL, and similarly for IFEQ ... IF_ACMPEQ (with a\r\n            // pre and post offset by 1). The jump offset is 8 bytes (3 for IFNOTxxx, 5 for GOTO_W).\r\n            code.putByte(baseOpcode >= Opcodes.IFNULL ? baseOpcode ^ 1 : ((baseOpcode + 1) ^ 1) - 1);\r\n            code.putShort(8);\r\n            // Here we could put a GOTO_W in theory, but if ASM specific instructions are used in this\r\n            // method or another one, and if the class has frames, we will need to insert a frame after\r\n            // this GOTO_W during the additional ClassReader -> ClassWriter round trip to remove the ASM\r\n            // specific instructions. To not miss this additional frame, we need to use an ASM_GOTO_W\r\n            // here, which has the unfortunate effect of forcing this additional round trip (which in\r\n            // some case would not have been really necessary, but we can't know this at this point).\r\n            code.putByte(Constants.ASM_GOTO_W);\r\n            hasAsmInstructions = true;\r\n            // The instruction after the GOTO_W becomes the target of the IFNOT instruction.\r\n            nextInsnIsJumpTarget = true;\r\n        }\r\n        label.put(code, code.length - 1, true);\r\n    } else if (baseOpcode != opcode) {\r\n        // Case of a GOTO_W or JSR_W specified by the user (normally ClassReader when used to remove\r\n        // ASM specific instructions). In this case we keep the original instruction.\r\n        code.putByte(opcode);\r\n        label.put(code, code.length - 1, true);\r\n    } else {\r\n        // Case of a jump with an offset >= -32768, or of a jump with an unknown offset. In these\r\n        // cases we store the offset in 2 bytes (which will be increased via a ClassReader ->\r\n        // ClassWriter round trip if it turns out that 2 bytes are not sufficient).\r\n        code.putByte(baseOpcode);\r\n        label.put(code, code.length - 1, false);\r\n    }\r\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\r\n    if (currentBasicBlock != null) {\r\n        Label nextBasicBlock = null;\r\n        if (compute == COMPUTE_ALL_FRAMES) {\r\n            currentBasicBlock.frame.execute(baseOpcode, 0, null, null);\r\n            // Record the fact that 'label' is the target of a jump instruction.\r\n            label.getCanonicalInstance().flags |= Label.FLAG_JUMP_TARGET;\r\n            // Add 'label' as a successor of the current basic block.\r\n            addSuccessorToCurrentBasicBlock(Edge.JUMP, label);\r\n            if (baseOpcode != Opcodes.GOTO) {\r\n                // The next instruction starts a new basic block (except for GOTO: by default the code\r\n                // following a goto is unreachable - unless there is an explicit label for it - and we\r\n                // should not compute stack frame types for its instructions).\r\n                nextBasicBlock = new Label();\r\n            }\r\n        } else if (compute == COMPUTE_INSERTED_FRAMES) {\r\n            currentBasicBlock.frame.execute(baseOpcode, 0, null, null);\r\n        } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES) {\r\n            // No need to update maxRelativeStackSize (the stack size delta is always negative).\r\n            relativeStackSize += STACK_SIZE_DELTA[baseOpcode];\r\n        } else {\r\n            if (baseOpcode == Opcodes.JSR) {\r\n                // Record the fact that 'label' designates a subroutine, if not already done.\r\n                if ((label.flags & Label.FLAG_SUBROUTINE_START) == 0) {\r\n                    label.flags |= Label.FLAG_SUBROUTINE_START;\r\n                    hasSubroutines = true;\r\n                }\r\n                currentBasicBlock.flags |= Label.FLAG_SUBROUTINE_CALLER;\r\n                // Note that, by construction in this method, a block which calls a subroutine has at\r\n                // least two successors in the control flow graph: the first one (added below) leads to\r\n                // the instruction after the JSR, while the second one (added here) leads to the JSR\r\n                // target. Note that the first successor is virtual (it does not correspond to a possible\r\n                // execution path): it is only used to compute the successors of the basic blocks ending\r\n                // with a ret, in {@link Label#addSubroutineRetSuccessors}.\r\n                addSuccessorToCurrentBasicBlock(relativeStackSize + 1, label);\r\n                // The instruction after the JSR starts a new basic block.\r\n                nextBasicBlock = new Label();\r\n            } else {\r\n                // No need to update maxRelativeStackSize (the stack size delta is always negative).\r\n                relativeStackSize += STACK_SIZE_DELTA[baseOpcode];\r\n                addSuccessorToCurrentBasicBlock(relativeStackSize, label);\r\n            }\r\n        }\r\n        // If the next instruction starts a new basic block, call visitLabel to add the label of this\r\n        // instruction as a successor of the current block, and to start a new basic block.\r\n        if (nextBasicBlock != null) {\r\n            if (nextInsnIsJumpTarget) {\r\n                nextBasicBlock.flags |= Label.FLAG_JUMP_TARGET;\r\n            }\r\n            visitLabel(nextBasicBlock);\r\n        }\r\n        if (baseOpcode == Opcodes.GOTO) {\r\n            endCurrentBasicBlockWithNoSuccessor();\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMono(Publisher<DataBuffer>,ResolvableType,Consumer<StepVerifier.FirstStep<T>>,MimeType,Map<String,Object>)",
    "entityType": "method",
    "code": "/**\r\n * Test a standard {@link Decoder#decodeToMono decode} scenario. For example:\r\n * <pre class=\"code\">\r\n * byte[] bytes1 = ...\r\n * byte[] bytes2 = ...\r\n * byte[] allBytes = ... // bytes1 + bytes2\r\n *\r\n * Flux&lt;DataBuffer&gt; input = Flux.concat(\r\n *   dataBuffer(bytes1),\r\n *   dataBuffer(bytes2));\r\n *\r\n * testDecodeAll(input, byte[].class, step -&gt; step\r\n *   .consumeNextWith(expectBytes(allBytes))\r\n * \t .verifyComplete());\r\n * </pre>\r\n *\r\n * @param input the input to be provided to the decoder\r\n * @param outputType the desired output type\r\n * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n * @param <T> the output type\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\nprotected <T> void testDecodeToMono(Publisher<DataBuffer> input, ResolvableType outputType, Consumer<StepVerifier.FirstStep<T>> stepConsumer, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    Mono<T> result = (Mono<T>) this.decoder.decodeToMono(input, outputType, mimeType, hints);\r\n    StepVerifier.FirstStep<T> step = StepVerifier.create(result);\r\n    stepConsumer.accept(step);\r\n}",
    "comment": "\n\t * Test a standard {@link Decoder#decodeToMono decode} scenario. For example:\n\t * <pre class=\"code\">\n\t * byte[] bytes1 = ...\n\t * byte[] bytes2 = ...\n\t * byte[] allBytes = ... // bytes1 + bytes2\n\t *\n\t * Flux&lt;DataBuffer&gt; input = Flux.concat(\n\t *   dataBuffer(bytes1),\n\t *   dataBuffer(bytes2));\n\t *\n\t * testDecodeAll(input, byte[].class, step -&gt; step\n\t *   .consumeNextWith(expectBytes(allBytes))\n\t * \t .verifyComplete());\n\t * </pre>\n\t *\n\t * @param input the input to be provided to the decoder\n\t * @param outputType the desired output type\n\t * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t * @param <T> the output type\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoError(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
    "entityType": "method",
    "code": "/**\r\n * Test a {@link Decoder#decodeToMono decode} scenario where the input stream contains an error.\r\n * This test method will feed the first element of the {@code input} stream to the decoder,\r\n * followed by an {@link InputException}.\r\n * The result is expected to contain the error.\r\n *\r\n * @param input the input to be provided to the decoder\r\n * @param outputType the desired output type\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n * @see InputException\r\n */\r\nprotected void testDecodeToMonoError(Publisher<DataBuffer> input, ResolvableType outputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    input = Mono.from(input).concatWith(Flux.error(new InputException()));\r\n    Mono<?> result = this.decoder.decodeToMono(input, outputType, mimeType, hints);\r\n    StepVerifier.create(result).expectError(InputException.class).verify();\r\n}",
    "comment": "\n\t * Test a {@link Decoder#decodeToMono decode} scenario where the input stream contains an error.\n\t * This test method will feed the first element of the {@code input} stream to the decoder,\n\t * followed by an {@link InputException}.\n\t * The result is expected to contain the error.\n\t *\n\t * @param input the input to be provided to the decoder\n\t * @param outputType the desired output type\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t * @see InputException\n\t "
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitLabel(Label)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitLabel(final Label label) {\r\n    // Resolve the forward references to this label, if any.\r\n    hasAsmInstructions |= label.resolve(code.data, stackMapTableEntries, code.length);\r\n    // visitLabel starts a new basic block (except for debug only labels), so we need to update the\r\n    // previous and current block references and list of successors.\r\n    if ((label.flags & Label.FLAG_DEBUG_ONLY) != 0) {\r\n        return;\r\n    }\r\n    if (compute == COMPUTE_ALL_FRAMES) {\r\n        if (currentBasicBlock != null) {\r\n            if (label.bytecodeOffset == currentBasicBlock.bytecodeOffset) {\r\n                // We use {@link Label#getCanonicalInstance} to store the state of a basic block in only\r\n                // one place, but this does not work for labels which have not been visited yet.\r\n                // Therefore, when we detect here two labels having the same bytecode offset, we need to\r\n                // - consolidate the state scattered in these two instances into the canonical instance:\r\n                currentBasicBlock.flags |= (label.flags & Label.FLAG_JUMP_TARGET);\r\n                // - make sure the two instances share the same Frame instance (the implementation of\r\n                // {@link Label#getCanonicalInstance} relies on this property; here label.frame should be\r\n                // null):\r\n                label.frame = currentBasicBlock.frame;\r\n                // - and make sure to NOT assign 'label' into 'currentBasicBlock' or 'lastBasicBlock', so\r\n                // that they still refer to the canonical instance for this bytecode offset.\r\n                return;\r\n            }\r\n            // End the current basic block (with one new successor).\r\n            addSuccessorToCurrentBasicBlock(Edge.JUMP, label);\r\n        }\r\n        // Append 'label' at the end of the basic block list.\r\n        if (lastBasicBlock != null) {\r\n            if (label.bytecodeOffset == lastBasicBlock.bytecodeOffset) {\r\n                // Same comment as above.\r\n                lastBasicBlock.flags |= (label.flags & Label.FLAG_JUMP_TARGET);\r\n                // Here label.frame should be null.\r\n                label.frame = lastBasicBlock.frame;\r\n                currentBasicBlock = lastBasicBlock;\r\n                return;\r\n            }\r\n            lastBasicBlock.nextBasicBlock = label;\r\n        }\r\n        lastBasicBlock = label;\r\n        // Make it the new current basic block.\r\n        currentBasicBlock = label;\r\n        // Here label.frame should be null.\r\n        label.frame = new Frame(label);\r\n    } else if (compute == COMPUTE_INSERTED_FRAMES) {\r\n        if (currentBasicBlock == null) {\r\n            // This case should happen only once, for the visitLabel call in the constructor. Indeed, if\r\n            // compute is equal to COMPUTE_INSERTED_FRAMES, currentBasicBlock stays unchanged.\r\n            currentBasicBlock = label;\r\n        } else {\r\n            // Update the frame owner so that a correct frame offset is computed in Frame.accept().\r\n            currentBasicBlock.frame.owner = label;\r\n        }\r\n    } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) {\r\n        if (currentBasicBlock != null) {\r\n            // End the current basic block (with one new successor).\r\n            currentBasicBlock.outputStackMax = (short) maxRelativeStackSize;\r\n            addSuccessorToCurrentBasicBlock(relativeStackSize, label);\r\n        }\r\n        // Start a new current basic block, and reset the current and maximum relative stack sizes.\r\n        currentBasicBlock = label;\r\n        relativeStackSize = 0;\r\n        maxRelativeStackSize = 0;\r\n        // Append the new basic block at the end of the basic block list.\r\n        if (lastBasicBlock != null) {\r\n            lastBasicBlock.nextBasicBlock = label;\r\n        }\r\n        lastBasicBlock = label;\r\n    } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES && currentBasicBlock == null) {\r\n        // This case should happen only once, for the visitLabel call in the constructor. Indeed, if\r\n        // compute is equal to COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES, currentBasicBlock stays\r\n        // unchanged.\r\n        currentBasicBlock = label;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoCancel(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
    "entityType": "method",
    "code": "/**\r\n * Test a {@link Decoder#decodeToMono decode} scenario where the input stream is canceled.\r\n * This test method will immediately cancel the output stream.\r\n *\r\n * @param input the input to be provided to the decoder\r\n * @param outputType the desired output type\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n */\r\nprotected void testDecodeToMonoCancel(Publisher<DataBuffer> input, ResolvableType outputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    Mono<?> result = this.decoder.decodeToMono(input, outputType, mimeType, hints);\r\n    StepVerifier.create(result).thenCancel().verify();\r\n}",
    "comment": "\n\t * Test a {@link Decoder#decodeToMono decode} scenario where the input stream is canceled.\n\t * This test method will immediately cancel the output stream.\n\t *\n\t * @param input the input to be provided to the decoder\n\t * @param outputType the desired output type\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoEmpty(ResolvableType,MimeType,Map<String,Object>)",
    "entityType": "method",
    "code": "/**\r\n * Test a {@link Decoder#decodeToMono decode} scenario where the input stream is empty.\r\n * The output is expected to be empty as well.\r\n *\r\n * @param outputType the desired output type\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n */\r\nprotected void testDecodeToMonoEmpty(ResolvableType outputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    Mono<?> result = this.decoder.decodeToMono(Flux.empty(), outputType, mimeType, hints);\r\n    StepVerifier.create(result).verifyComplete();\r\n}",
    "comment": "\n\t * Test a {@link Decoder#decodeToMono decode} scenario where the input stream is empty.\n\t * The output is expected to be empty as well.\n\t *\n\t * @param outputType the desired output type\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractDecoderTests#dataBuffer(byte[])",
    "entityType": "method",
    "code": "/**\r\n * Creates a deferred {@link DataBuffer} containing the given bytes.\r\n * @param bytes the bytes that are to be stored in the buffer\r\n * @return the deferred buffer\r\n */\r\nprotected Mono<DataBuffer> dataBuffer(byte[] bytes) {\r\n    return Mono.fromCallable(() -> {\r\n        DataBuffer dataBuffer = this.bufferFactory.allocateBuffer(bytes.length);\r\n        dataBuffer.write(bytes);\r\n        return dataBuffer;\r\n    });\r\n}",
    "comment": "\n\t * Creates a deferred {@link DataBuffer} containing the given bytes.\n\t * @param bytes the bytes that are to be stored in the buffer\n\t * @return the deferred buffer\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.InputException",
    "entityType": "class",
    "code": "",
    "comment": "\n\t * Exception used in {@link #testDecodeError} and {@link #testDecodeToMonoError}\n\t "
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitLdcInsn(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitLdcInsn(final Object value) {\r\n    lastBytecodeOffset = code.length;\r\n    // Add the instruction to the bytecode of the method.\r\n    Symbol constantSymbol = symbolTable.addConstant(value);\r\n    int constantIndex = constantSymbol.index;\r\n    char firstDescriptorChar;\r\n    boolean isLongOrDouble = constantSymbol.tag == Symbol.CONSTANT_LONG_TAG || constantSymbol.tag == Symbol.CONSTANT_DOUBLE_TAG || (constantSymbol.tag == Symbol.CONSTANT_DYNAMIC_TAG && ((firstDescriptorChar = constantSymbol.value.charAt(0)) == 'J' || firstDescriptorChar == 'D'));\r\n    if (isLongOrDouble) {\r\n        code.put12(Constants.LDC2_W, constantIndex);\r\n    } else if (constantIndex >= 256) {\r\n        code.put12(Constants.LDC_W, constantIndex);\r\n    } else {\r\n        code.put11(Opcodes.LDC, constantIndex);\r\n    }\r\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\r\n    if (currentBasicBlock != null) {\r\n        if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\r\n            currentBasicBlock.frame.execute(Opcodes.LDC, 0, constantSymbol, symbolTable);\r\n        } else {\r\n            int size = relativeStackSize + (isLongOrDouble ? 2 : 1);\r\n            if (size > maxRelativeStackSize) {\r\n                maxRelativeStackSize = size;\r\n            }\r\n            relativeStackSize = size;\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitIincInsn(int,int)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitIincInsn(final int varIndex, final int increment) {\r\n    lastBytecodeOffset = code.length;\r\n    // Add the instruction to the bytecode of the method.\r\n    if ((varIndex > 255) || (increment > 127) || (increment < -128)) {\r\n        code.putByte(Constants.WIDE).put12(Opcodes.IINC, varIndex).putShort(increment);\r\n    } else {\r\n        code.putByte(Opcodes.IINC).put11(varIndex, increment);\r\n    }\r\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\r\n    if (currentBasicBlock != null && (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES)) {\r\n        currentBasicBlock.frame.execute(Opcodes.IINC, varIndex, null, null);\r\n    }\r\n    if (compute != COMPUTE_NOTHING) {\r\n        int currentMaxLocals = varIndex + 1;\r\n        if (currentMaxLocals > maxLocals) {\r\n            maxLocals = currentMaxLocals;\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitTableSwitchInsn(int,int,Label,Label)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitTableSwitchInsn(final int min, final int max, final Label dflt, final Label... labels) {\r\n    lastBytecodeOffset = code.length;\r\n    // Add the instruction to the bytecode of the method.\r\n    code.putByte(Opcodes.TABLESWITCH).putByteArray(null, 0, (4 - code.length % 4) % 4);\r\n    dflt.put(code, lastBytecodeOffset, true);\r\n    code.putInt(min).putInt(max);\r\n    for (Label label : labels) {\r\n        label.put(code, lastBytecodeOffset, true);\r\n    }\r\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\r\n    visitSwitchInsn(dflt, labels);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitLookupSwitchInsn(Label,int[],Label[])",
    "entityType": "method",
    "code": "@Override\r\npublic void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {\r\n    lastBytecodeOffset = code.length;\r\n    // Add the instruction to the bytecode of the method.\r\n    code.putByte(Opcodes.LOOKUPSWITCH).putByteArray(null, 0, (4 - code.length % 4) % 4);\r\n    dflt.put(code, lastBytecodeOffset, true);\r\n    code.putInt(labels.length);\r\n    for (int i = 0; i < labels.length; ++i) {\r\n        code.putInt(keys[i]);\r\n        labels[i].put(code, lastBytecodeOffset, true);\r\n    }\r\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\r\n    visitSwitchInsn(dflt, labels);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitSwitchInsn(Label,Label[])",
    "entityType": "method",
    "code": "private void visitSwitchInsn(final Label dflt, final Label[] labels) {\r\n    if (currentBasicBlock != null) {\r\n        if (compute == COMPUTE_ALL_FRAMES) {\r\n            currentBasicBlock.frame.execute(Opcodes.LOOKUPSWITCH, 0, null, null);\r\n            // Add all the labels as successors of the current basic block.\r\n            addSuccessorToCurrentBasicBlock(Edge.JUMP, dflt);\r\n            dflt.getCanonicalInstance().flags |= Label.FLAG_JUMP_TARGET;\r\n            for (Label label : labels) {\r\n                addSuccessorToCurrentBasicBlock(Edge.JUMP, label);\r\n                label.getCanonicalInstance().flags |= Label.FLAG_JUMP_TARGET;\r\n            }\r\n        } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) {\r\n            // No need to update maxRelativeStackSize (the stack size delta is always negative).\r\n            --relativeStackSize;\r\n            // Add all the labels as successors of the current basic block.\r\n            addSuccessorToCurrentBasicBlock(relativeStackSize, dflt);\r\n            for (Label label : labels) {\r\n                addSuccessorToCurrentBasicBlock(relativeStackSize, label);\r\n            }\r\n        }\r\n        // End the current basic block.\r\n        endCurrentBasicBlockWithNoSuccessor();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitMultiANewArrayInsn(String,int)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {\r\n    lastBytecodeOffset = code.length;\r\n    // Add the instruction to the bytecode of the method.\r\n    Symbol descSymbol = symbolTable.addConstantClass(descriptor);\r\n    code.put12(Opcodes.MULTIANEWARRAY, descSymbol.index).putByte(numDimensions);\r\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\r\n    if (currentBasicBlock != null) {\r\n        if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\r\n            currentBasicBlock.frame.execute(Opcodes.MULTIANEWARRAY, numDimensions, descSymbol, symbolTable);\r\n        } else {\r\n            // No need to update maxRelativeStackSize (the stack size delta is always negative).\r\n            relativeStackSize += 1 - numDimensions;\r\n        }\r\n    }\r\n}",
    "comment": ""
  }
]