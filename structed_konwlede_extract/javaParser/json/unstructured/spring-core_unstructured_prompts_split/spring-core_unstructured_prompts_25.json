[
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#ofBytesToBytes()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofBytesToBytes() {\r\n    assertThat(DataSize.ofBytes(1024).toBytes()).isEqualTo(1024);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#ofBytesToKilobytes()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofBytesToKilobytes() {\r\n    assertThat(DataSize.ofBytes(1024).toKilobytes()).isEqualTo(1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#ofKilobytesToKilobytes()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofKilobytesToKilobytes() {\r\n    assertThat(DataSize.ofKilobytes(1024).toKilobytes()).isEqualTo(1024);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#ofKilobytesToMegabytes()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofKilobytesToMegabytes() {\r\n    assertThat(DataSize.ofKilobytes(1024).toMegabytes()).isEqualTo(1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#ofMegabytesToMegabytes()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofMegabytesToMegabytes() {\r\n    assertThat(DataSize.ofMegabytes(1024).toMegabytes()).isEqualTo(1024);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#ofMegabytesToGigabytes()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofMegabytesToGigabytes() {\r\n    assertThat(DataSize.ofMegabytes(2048).toGigabytes()).isEqualTo(2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#ofGigabytesToGigabytes()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofGigabytesToGigabytes() {\r\n    assertThat(DataSize.ofGigabytes(4096).toGigabytes()).isEqualTo(4096);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#ofGigabytesToTerabytes()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofGigabytesToTerabytes() {\r\n    assertThat(DataSize.ofGigabytes(4096).toTerabytes()).isEqualTo(4);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#ofTerabytesToGigabytes()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofTerabytesToGigabytes() {\r\n    assertThat(DataSize.ofTerabytes(1).toGigabytes()).isEqualTo(1024);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#ofWithBytesUnit()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofWithBytesUnit() {\r\n    assertThat(DataSize.of(10, DataUnit.BYTES)).isEqualTo(DataSize.ofBytes(10));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#ofWithKilobytesUnit()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofWithKilobytesUnit() {\r\n    assertThat(DataSize.of(20, DataUnit.KILOBYTES)).isEqualTo(DataSize.ofKilobytes(20));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#ofWithMegabytesUnit()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofWithMegabytesUnit() {\r\n    assertThat(DataSize.of(30, DataUnit.MEGABYTES)).isEqualTo(DataSize.ofMegabytes(30));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#ofWithGigabytesUnit()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofWithGigabytesUnit() {\r\n    assertThat(DataSize.of(40, DataUnit.GIGABYTES)).isEqualTo(DataSize.ofGigabytes(40));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#ofWithTerabytesUnit()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofWithTerabytesUnit() {\r\n    assertThat(DataSize.of(50, DataUnit.TERABYTES)).isEqualTo(DataSize.ofTerabytes(50));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#parseWithDefaultUnitUsesBytes()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseWithDefaultUnitUsesBytes() {\r\n    assertThat(DataSize.parse(\"1024\")).isEqualTo(DataSize.ofKilobytes(1));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#parseNegativeNumberWithDefaultUnitUsesBytes()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseNegativeNumberWithDefaultUnitUsesBytes() {\r\n    assertThat(DataSize.parse(\"-1\")).isEqualTo(DataSize.ofBytes(-1));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#parseWithNullDefaultUnitUsesBytes()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseWithNullDefaultUnitUsesBytes() {\r\n    assertThat(DataSize.parse(\"1024\", null)).isEqualTo(DataSize.ofKilobytes(1));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#parseNegativeNumberWithNullDefaultUnitUsesBytes()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseNegativeNumberWithNullDefaultUnitUsesBytes() {\r\n    assertThat(DataSize.parse(\"-1024\", null)).isEqualTo(DataSize.ofKilobytes(-1));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#parseWithCustomDefaultUnit()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseWithCustomDefaultUnit() {\r\n    assertThat(DataSize.parse(\"1\", DataUnit.KILOBYTES)).isEqualTo(DataSize.ofKilobytes(1));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#parseNegativeNumberWithCustomDefaultUnit()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseNegativeNumberWithCustomDefaultUnit() {\r\n    assertThat(DataSize.parse(\"-1\", DataUnit.KILOBYTES)).isEqualTo(DataSize.ofKilobytes(-1));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#parseWithBytes(CharSequence)",
    "entityType": "method",
    "code": "@ParameterizedTest(name = \"[{index}] text = ''{0}''\")\r\n@ValueSource(strings = { \"1024B\", \"1024 B\", \"1024B   \", \"   1024B\", \" 1024B \", \"\\t1024   B\\t\" })\r\nvoid parseWithBytes(CharSequence text) {\r\n    assertThat(DataSize.parse(text)).isEqualTo(DataSize.ofKilobytes(1));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#parseWithNegativeBytes()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseWithNegativeBytes() {\r\n    assertThat(DataSize.parse(\"-1024B\")).isEqualTo(DataSize.ofKilobytes(-1));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#parseWithPositiveBytes()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseWithPositiveBytes() {\r\n    assertThat(DataSize.parse(\"+1024B\")).isEqualTo(DataSize.ofKilobytes(1));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#parseWithKilobytes()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseWithKilobytes() {\r\n    assertThat(DataSize.parse(\"1KB\")).isEqualTo(DataSize.ofBytes(1024));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#parseWithNegativeKilobytes()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseWithNegativeKilobytes() {\r\n    assertThat(DataSize.parse(\"-1KB\")).isEqualTo(DataSize.ofBytes(-1024));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#parseWithMegabytes()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseWithMegabytes() {\r\n    assertThat(DataSize.parse(\"4MB\")).isEqualTo(DataSize.ofMegabytes(4));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#parseWithNegativeMegabytes()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseWithNegativeMegabytes() {\r\n    assertThat(DataSize.parse(\"-4MB\")).isEqualTo(DataSize.ofMegabytes(-4));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#parseWithGigabytes()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseWithGigabytes() {\r\n    assertThat(DataSize.parse(\"1GB\")).isEqualTo(DataSize.ofMegabytes(1024));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#parseWithNegativeGigabytes()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseWithNegativeGigabytes() {\r\n    assertThat(DataSize.parse(\"-1GB\")).isEqualTo(DataSize.ofMegabytes(-1024));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#parseWithTerabytes()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseWithTerabytes() {\r\n    assertThat(DataSize.parse(\"1TB\")).isEqualTo(DataSize.ofTerabytes(1));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#parseWithNegativeTerabytes()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseWithNegativeTerabytes() {\r\n    assertThat(DataSize.parse(\"-1TB\")).isEqualTo(DataSize.ofTerabytes(-1));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#isNegativeWithPositive()",
    "entityType": "method",
    "code": "@Test\r\nvoid isNegativeWithPositive() {\r\n    assertThat(DataSize.ofBytes(50).isNegative()).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#isNegativeWithZero()",
    "entityType": "method",
    "code": "@Test\r\nvoid isNegativeWithZero() {\r\n    assertThat(DataSize.ofBytes(0).isNegative()).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#isNegativeWithNegative()",
    "entityType": "method",
    "code": "@Test\r\nvoid isNegativeWithNegative() {\r\n    assertThat(DataSize.ofBytes(-1).isNegative()).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#toStringUsesBytes()",
    "entityType": "method",
    "code": "@Test\r\nvoid toStringUsesBytes() {\r\n    assertThat(DataSize.ofKilobytes(1).toString()).isEqualTo(\"1024B\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#toStringWithNegativeBytes()",
    "entityType": "method",
    "code": "@Test\r\nvoid toStringWithNegativeBytes() {\r\n    assertThat(DataSize.ofKilobytes(-1).toString()).isEqualTo(\"-1024B\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests#parseWithUnsupportedUnit()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseWithUnsupportedUnit() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> DataSize.parse(\"3WB\")).withMessage(\"'3WB' is not a valid data size\");\r\n    assertThatIllegalArgumentException().isThrownBy(() -> DataSize.parse(\"3 WB\")).withMessage(\"'3 WB' is not a valid data size\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableMultiValueMapTests",
    "entityType": "class",
    "code": "@Test\r\nvoid delegation() {\r\n    MultiValueMap<String, String> mock = mock();\r\n    UnmodifiableMultiValueMap<String, String> map = new UnmodifiableMultiValueMap<>(mock);\r\n    given(mock.size()).willReturn(1);\r\n    assertThat(map).hasSize(1);\r\n    given(mock.isEmpty()).willReturn(false);\r\n    assertThat(map).isNotEmpty();\r\n    given(mock.containsKey(\"foo\")).willReturn(true);\r\n    assertThat(map.containsKey(\"foo\")).isTrue();\r\n    given(mock.containsValue(List.of(\"bar\"))).willReturn(true);\r\n    assertThat(map.containsValue(List.of(\"bar\"))).isTrue();\r\n    List<String> list = new ArrayList<>();\r\n    list.add(\"bar\");\r\n    given(mock.get(\"foo\")).willReturn(list);\r\n    List<String> result = map.get(\"foo\");\r\n    assertThat(result).containsExactly(\"bar\");\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> result.add(\"baz\"));\r\n    given(mock.getOrDefault(\"foo\", List.of(\"bar\"))).willReturn(List.of(\"baz\"));\r\n    assertThat(map.getOrDefault(\"foo\", List.of(\"bar\"))).containsExactly(\"baz\");\r\n    given(mock.toSingleValueMap()).willReturn(Map.of(\"foo\", \"bar\"));\r\n    assertThat(map.toSingleValueMap()).containsExactly(entry(\"foo\", \"bar\"));\r\n}\n@Test\r\nvoid unsupported() {\r\n    UnmodifiableMultiValueMap<String, String> map = new UnmodifiableMultiValueMap<>(new LinkedMultiValueMap<>());\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.put(\"foo\", List.of(\"bar\")));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.putIfAbsent(\"foo\", List.of(\"bar\")));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.putAll(Map.of(\"foo\", List.of(\"bar\"))));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.remove(\"foo\"));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.add(\"foo\", \"bar\"));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.addAll(\"foo\", List.of(\"bar\")));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.addAll(new LinkedMultiValueMap<>()));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.addIfAbsent(\"foo\", \"baz\"));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.set(\"foo\", \"baz\"));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.setAll(Map.of(\"foo\", \"baz\")));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.replaceAll((s, strings) -> strings));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.remove(\"foo\", List.of(\"bar\")));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.replace(\"foo\", List.of(\"bar\")));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.replace(\"foo\", List.of(\"bar\"), List.of(\"baz\")));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.computeIfAbsent(\"foo\", s -> List.of(\"bar\")));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.computeIfPresent(\"foo\", (s1, s2) -> List.of(\"bar\")));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.compute(\"foo\", (s1, s2) -> List.of(\"bar\")));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.merge(\"foo\", List.of(\"bar\"), (s1, s2) -> s1));\r\n    assertThatUnsupportedOperationException().isThrownBy(map::clear);\r\n}\n@Test\r\n@SuppressWarnings(\"unchecked\")\r\nvoid entrySetDelegation() {\r\n    MultiValueMap<String, String> mockMap = mock();\r\n    Set<Map.Entry<String, List<String>>> mockSet = mock();\r\n    given(mockMap.entrySet()).willReturn(mockSet);\r\n    Set<Map.Entry<String, List<String>>> set = new UnmodifiableMultiValueMap<>(mockMap).entrySet();\r\n    given(mockSet.size()).willReturn(1);\r\n    assertThat(set).hasSize(1);\r\n    given(mockSet.isEmpty()).willReturn(false);\r\n    assertThat(set.isEmpty()).isFalse();\r\n    Map.Entry<String, List<String>> mockedEntry = mock();\r\n    given(mockSet.contains(mockedEntry)).willReturn(true);\r\n    assertThat(set.contains(mockedEntry)).isTrue();\r\n    List<Map.Entry<String, List<String>>> mockEntries = List.of(mock(Map.Entry.class));\r\n    given(mockSet.containsAll(mockEntries)).willReturn(true);\r\n    assertThat(set.containsAll(mockEntries)).isTrue();\r\n    Iterator<Map.Entry<String, List<String>>> mockIterator = mock();\r\n    given(mockSet.iterator()).willReturn(mockIterator);\r\n    given(mockIterator.hasNext()).willReturn(false);\r\n    assertThat(set.iterator()).isExhausted();\r\n}\n@Test\r\n@SuppressWarnings(\"unchecked\")\r\nvoid entrySetUnsupported() {\r\n    Set<Map.Entry<String, List<String>>> set = new UnmodifiableMultiValueMap<String, String>(new LinkedMultiValueMap<>()).entrySet();\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> set.add(mock(Map.Entry.class)));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> set.remove(mock(Map.Entry.class)));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> set.removeIf(e -> true));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> set.addAll(mock(List.class)));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> set.retainAll(mock(List.class)));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> set.removeAll(mock(List.class)));\r\n    assertThatUnsupportedOperationException().isThrownBy(set::clear);\r\n}\n@Test\r\n@SuppressWarnings(\"unchecked\")\r\nvoid valuesDelegation() {\r\n    MultiValueMap<String, String> mockMap = mock();\r\n    Collection<List<String>> mockValues = mock();\r\n    given(mockMap.values()).willReturn(mockValues);\r\n    Collection<List<String>> values = new UnmodifiableMultiValueMap<>(mockMap).values();\r\n    given(mockValues.size()).willReturn(1);\r\n    assertThat(values).hasSize(1);\r\n    given(mockValues.isEmpty()).willReturn(false);\r\n    assertThat(values.isEmpty()).isFalse();\r\n    given(mockValues.contains(List.of(\"foo\"))).willReturn(true);\r\n    assertThat(mockValues.contains(List.of(\"foo\"))).isTrue();\r\n    given(mockValues.containsAll(List.of(List.of(\"foo\")))).willReturn(true);\r\n    assertThat(mockValues.containsAll(List.of(List.of(\"foo\")))).isTrue();\r\n    Iterator<List<String>> mockIterator = mock(Iterator.class);\r\n    given(mockValues.iterator()).willReturn(mockIterator);\r\n    given(mockIterator.hasNext()).willReturn(false);\r\n    assertThat(values.iterator()).isExhausted();\r\n}\n@Test\r\nvoid valuesUnsupported() {\r\n    Collection<List<String>> values = new UnmodifiableMultiValueMap<String, String>(new LinkedMultiValueMap<>()).values();\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> values.add(List.of(\"foo\")));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> values.remove(List.of(\"foo\")));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> values.addAll(List.of(List.of(\"foo\"))));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> values.removeAll(List.of(List.of(\"foo\"))));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> values.retainAll(List.of(List.of(\"foo\"))));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> values.removeIf(s -> true));\r\n    assertThatUnsupportedOperationException().isThrownBy(values::clear);\r\n}\nprivate static ThrowableTypeAssert<UnsupportedOperationException> assertThatUnsupportedOperationException() {\r\n    return assertThatExceptionOfType(UnsupportedOperationException.class);\r\n}",
    "comment": "\n * Tests for {@link UnmodifiableMultiValueMap}.\n *\n * @author Arjen Poutsma\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.util.UnmodifiableMultiValueMapTests#delegation()",
    "entityType": "method",
    "code": "@Test\r\nvoid delegation() {\r\n    MultiValueMap<String, String> mock = mock();\r\n    UnmodifiableMultiValueMap<String, String> map = new UnmodifiableMultiValueMap<>(mock);\r\n    given(mock.size()).willReturn(1);\r\n    assertThat(map).hasSize(1);\r\n    given(mock.isEmpty()).willReturn(false);\r\n    assertThat(map).isNotEmpty();\r\n    given(mock.containsKey(\"foo\")).willReturn(true);\r\n    assertThat(map.containsKey(\"foo\")).isTrue();\r\n    given(mock.containsValue(List.of(\"bar\"))).willReturn(true);\r\n    assertThat(map.containsValue(List.of(\"bar\"))).isTrue();\r\n    List<String> list = new ArrayList<>();\r\n    list.add(\"bar\");\r\n    given(mock.get(\"foo\")).willReturn(list);\r\n    List<String> result = map.get(\"foo\");\r\n    assertThat(result).containsExactly(\"bar\");\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> result.add(\"baz\"));\r\n    given(mock.getOrDefault(\"foo\", List.of(\"bar\"))).willReturn(List.of(\"baz\"));\r\n    assertThat(map.getOrDefault(\"foo\", List.of(\"bar\"))).containsExactly(\"baz\");\r\n    given(mock.toSingleValueMap()).willReturn(Map.of(\"foo\", \"bar\"));\r\n    assertThat(map.toSingleValueMap()).containsExactly(entry(\"foo\", \"bar\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableMultiValueMapTests#unsupported()",
    "entityType": "method",
    "code": "@Test\r\nvoid unsupported() {\r\n    UnmodifiableMultiValueMap<String, String> map = new UnmodifiableMultiValueMap<>(new LinkedMultiValueMap<>());\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.put(\"foo\", List.of(\"bar\")));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.putIfAbsent(\"foo\", List.of(\"bar\")));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.putAll(Map.of(\"foo\", List.of(\"bar\"))));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.remove(\"foo\"));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.add(\"foo\", \"bar\"));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.addAll(\"foo\", List.of(\"bar\")));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.addAll(new LinkedMultiValueMap<>()));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.addIfAbsent(\"foo\", \"baz\"));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.set(\"foo\", \"baz\"));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.setAll(Map.of(\"foo\", \"baz\")));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.replaceAll((s, strings) -> strings));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.remove(\"foo\", List.of(\"bar\")));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.replace(\"foo\", List.of(\"bar\")));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.replace(\"foo\", List.of(\"bar\"), List.of(\"baz\")));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.computeIfAbsent(\"foo\", s -> List.of(\"bar\")));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.computeIfPresent(\"foo\", (s1, s2) -> List.of(\"bar\")));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.compute(\"foo\", (s1, s2) -> List.of(\"bar\")));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> map.merge(\"foo\", List.of(\"bar\"), (s1, s2) -> s1));\r\n    assertThatUnsupportedOperationException().isThrownBy(map::clear);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableMultiValueMapTests#entrySetDelegation()",
    "entityType": "method",
    "code": "@Test\r\n@SuppressWarnings(\"unchecked\")\r\nvoid entrySetDelegation() {\r\n    MultiValueMap<String, String> mockMap = mock();\r\n    Set<Map.Entry<String, List<String>>> mockSet = mock();\r\n    given(mockMap.entrySet()).willReturn(mockSet);\r\n    Set<Map.Entry<String, List<String>>> set = new UnmodifiableMultiValueMap<>(mockMap).entrySet();\r\n    given(mockSet.size()).willReturn(1);\r\n    assertThat(set).hasSize(1);\r\n    given(mockSet.isEmpty()).willReturn(false);\r\n    assertThat(set.isEmpty()).isFalse();\r\n    Map.Entry<String, List<String>> mockedEntry = mock();\r\n    given(mockSet.contains(mockedEntry)).willReturn(true);\r\n    assertThat(set.contains(mockedEntry)).isTrue();\r\n    List<Map.Entry<String, List<String>>> mockEntries = List.of(mock(Map.Entry.class));\r\n    given(mockSet.containsAll(mockEntries)).willReturn(true);\r\n    assertThat(set.containsAll(mockEntries)).isTrue();\r\n    Iterator<Map.Entry<String, List<String>>> mockIterator = mock();\r\n    given(mockSet.iterator()).willReturn(mockIterator);\r\n    given(mockIterator.hasNext()).willReturn(false);\r\n    assertThat(set.iterator()).isExhausted();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableMultiValueMapTests#entrySetUnsupported()",
    "entityType": "method",
    "code": "@Test\r\n@SuppressWarnings(\"unchecked\")\r\nvoid entrySetUnsupported() {\r\n    Set<Map.Entry<String, List<String>>> set = new UnmodifiableMultiValueMap<String, String>(new LinkedMultiValueMap<>()).entrySet();\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> set.add(mock(Map.Entry.class)));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> set.remove(mock(Map.Entry.class)));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> set.removeIf(e -> true));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> set.addAll(mock(List.class)));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> set.retainAll(mock(List.class)));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> set.removeAll(mock(List.class)));\r\n    assertThatUnsupportedOperationException().isThrownBy(set::clear);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableMultiValueMapTests#valuesDelegation()",
    "entityType": "method",
    "code": "@Test\r\n@SuppressWarnings(\"unchecked\")\r\nvoid valuesDelegation() {\r\n    MultiValueMap<String, String> mockMap = mock();\r\n    Collection<List<String>> mockValues = mock();\r\n    given(mockMap.values()).willReturn(mockValues);\r\n    Collection<List<String>> values = new UnmodifiableMultiValueMap<>(mockMap).values();\r\n    given(mockValues.size()).willReturn(1);\r\n    assertThat(values).hasSize(1);\r\n    given(mockValues.isEmpty()).willReturn(false);\r\n    assertThat(values.isEmpty()).isFalse();\r\n    given(mockValues.contains(List.of(\"foo\"))).willReturn(true);\r\n    assertThat(mockValues.contains(List.of(\"foo\"))).isTrue();\r\n    given(mockValues.containsAll(List.of(List.of(\"foo\")))).willReturn(true);\r\n    assertThat(mockValues.containsAll(List.of(List.of(\"foo\")))).isTrue();\r\n    Iterator<List<String>> mockIterator = mock(Iterator.class);\r\n    given(mockValues.iterator()).willReturn(mockIterator);\r\n    given(mockIterator.hasNext()).willReturn(false);\r\n    assertThat(values.iterator()).isExhausted();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableMultiValueMapTests#valuesUnsupported()",
    "entityType": "method",
    "code": "@Test\r\nvoid valuesUnsupported() {\r\n    Collection<List<String>> values = new UnmodifiableMultiValueMap<String, String>(new LinkedMultiValueMap<>()).values();\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> values.add(List.of(\"foo\")));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> values.remove(List.of(\"foo\")));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> values.addAll(List.of(List.of(\"foo\"))));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> values.removeAll(List.of(List.of(\"foo\"))));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> values.retainAll(List.of(List.of(\"foo\"))));\r\n    assertThatUnsupportedOperationException().isThrownBy(() -> values.removeIf(s -> true));\r\n    assertThatUnsupportedOperationException().isThrownBy(values::clear);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableMultiValueMapTests#assertThatUnsupportedOperationException()",
    "entityType": "method",
    "code": "private static ThrowableTypeAssert<UnsupportedOperationException> assertThatUnsupportedOperationException() {\r\n    return assertThatExceptionOfType(UnsupportedOperationException.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ClassWriter",
    "entityType": "class",
    "code": "/**\r\n * A flag to automatically compute the maximum stack size and the maximum number of local\r\n * variables of methods. If this flag is set, then the arguments of the {@link\r\n * MethodVisitor#visitMaxs} method of the {@link MethodVisitor} returned by the {@link\r\n * #visitMethod} method will be ignored, and computed automatically from the signature and the\r\n * bytecode of each method.\r\n *\r\n * <p><b>Note:</b> for classes whose version is {@link Opcodes#V1_7} of more, this option requires\r\n * valid stack map frames. The maximum stack size is then computed from these frames, and from the\r\n * bytecode instructions in between. If stack map frames are not present or must be recomputed,\r\n * used {@link #COMPUTE_FRAMES} instead.\r\n *\r\n * @see #ClassWriter(int)\r\n */\r\npublic static final int COMPUTE_MAXS = 1;\n/**\r\n * A flag to automatically compute the stack map frames of methods from scratch. If this flag is\r\n * set, then the calls to the {@link MethodVisitor#visitFrame} method are ignored, and the stack\r\n * map frames are recomputed from the methods bytecode. The arguments of the {@link\r\n * MethodVisitor#visitMaxs} method are also ignored and recomputed from the bytecode. In other\r\n * words, {@link #COMPUTE_FRAMES} implies {@link #COMPUTE_MAXS}.\r\n *\r\n * @see #ClassWriter(int)\r\n */\r\npublic static final int COMPUTE_FRAMES = 2;\n/**\r\n * The flags passed to the constructor. Must be zero or more of {@link #COMPUTE_MAXS} and {@link\r\n * #COMPUTE_FRAMES}.\r\n */\r\nprivate final int flags;\n// Note: fields are ordered as in the ClassFile structure, and those related to attributes are\r\n// ordered as in Section 4.7 of the JVMS.\r\n/**\r\n * The minor_version and major_version fields of the JVMS ClassFile structure. minor_version is\r\n * stored in the 16 most significant bits, and major_version in the 16 least significant bits.\r\n */\r\nprivate int version;\n/**\r\n * The symbol table for this class (contains the constant_pool and the BootstrapMethods).\r\n */\r\nprivate final SymbolTable symbolTable;\n/**\r\n * The access_flags field of the JVMS ClassFile structure. This field can contain ASM specific\r\n * access flags, such as {@link Opcodes#ACC_DEPRECATED} or {@link Opcodes#ACC_RECORD}, which are\r\n * removed when generating the ClassFile structure.\r\n */\r\nprivate int accessFlags;\n/**\r\n * The this_class field of the JVMS ClassFile structure.\r\n */\r\nprivate int thisClass;\n/**\r\n * The super_class field of the JVMS ClassFile structure.\r\n */\r\nprivate int superClass;\n/**\r\n * The interface_count field of the JVMS ClassFile structure.\r\n */\r\nprivate int interfaceCount;\n/**\r\n * The 'interfaces' array of the JVMS ClassFile structure.\r\n */\r\nprivate int[] interfaces;\n/**\r\n * The fields of this class, stored in a linked list of {@link FieldWriter} linked via their\r\n * {@link FieldWriter#fv} field. This field stores the first element of this list.\r\n */\r\nprivate FieldWriter firstField;\n/**\r\n * The fields of this class, stored in a linked list of {@link FieldWriter} linked via their\r\n * {@link FieldWriter#fv} field. This field stores the last element of this list.\r\n */\r\nprivate FieldWriter lastField;\n/**\r\n * The methods of this class, stored in a linked list of {@link MethodWriter} linked via their\r\n * {@link MethodWriter#mv} field. This field stores the first element of this list.\r\n */\r\nprivate MethodWriter firstMethod;\n/**\r\n * The methods of this class, stored in a linked list of {@link MethodWriter} linked via their\r\n * {@link MethodWriter#mv} field. This field stores the last element of this list.\r\n */\r\nprivate MethodWriter lastMethod;\n/**\r\n * The number_of_classes field of the InnerClasses attribute, or 0.\r\n */\r\nprivate int numberOfInnerClasses;\n/**\r\n * The 'classes' array of the InnerClasses attribute, or {@literal null}.\r\n */\r\nprivate ByteVector innerClasses;\n/**\r\n * The class_index field of the EnclosingMethod attribute, or 0.\r\n */\r\nprivate int enclosingClassIndex;\n/**\r\n * The method_index field of the EnclosingMethod attribute.\r\n */\r\nprivate int enclosingMethodIndex;\n/**\r\n * The signature_index field of the Signature attribute, or 0.\r\n */\r\nprivate int signatureIndex;\n/**\r\n * The source_file_index field of the SourceFile attribute, or 0.\r\n */\r\nprivate int sourceFileIndex;\n/**\r\n * The debug_extension field of the SourceDebugExtension attribute, or {@literal null}.\r\n */\r\nprivate ByteVector debugExtension;\n/**\r\n * The last runtime visible annotation of this class. The previous ones can be accessed with the\r\n * {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\r\n */\r\nprivate AnnotationWriter lastRuntimeVisibleAnnotation;\n/**\r\n * The last runtime invisible annotation of this class. The previous ones can be accessed with the\r\n * {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\r\n */\r\nprivate AnnotationWriter lastRuntimeInvisibleAnnotation;\n/**\r\n * The last runtime visible type annotation of this class. The previous ones can be accessed with\r\n * the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\r\n */\r\nprivate AnnotationWriter lastRuntimeVisibleTypeAnnotation;\n/**\r\n * The last runtime invisible type annotation of this class. The previous ones can be accessed\r\n * with the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\r\n */\r\nprivate AnnotationWriter lastRuntimeInvisibleTypeAnnotation;\n/**\r\n * The Module attribute of this class, or {@literal null}.\r\n */\r\nprivate ModuleWriter moduleWriter;\n/**\r\n * The host_class_index field of the NestHost attribute, or 0.\r\n */\r\nprivate int nestHostClassIndex;\n/**\r\n * The number_of_classes field of the NestMembers attribute, or 0.\r\n */\r\nprivate int numberOfNestMemberClasses;\n/**\r\n * The 'classes' array of the NestMembers attribute, or {@literal null}.\r\n */\r\nprivate ByteVector nestMemberClasses;\n/**\r\n * The number_of_classes field of the PermittedSubclasses attribute, or 0.\r\n */\r\nprivate int numberOfPermittedSubclasses;\n/**\r\n * The 'classes' array of the PermittedSubclasses attribute, or {@literal null}.\r\n */\r\nprivate ByteVector permittedSubclasses;\n/**\r\n * The record components of this class, stored in a linked list of {@link RecordComponentWriter}\r\n * linked via their {@link RecordComponentWriter#delegate} field. This field stores the first\r\n * element of this list.\r\n */\r\nprivate RecordComponentWriter firstRecordComponent;\n/**\r\n * The record components of this class, stored in a linked list of {@link RecordComponentWriter}\r\n * linked via their {@link RecordComponentWriter#delegate} field. This field stores the last\r\n * element of this list.\r\n */\r\nprivate RecordComponentWriter lastRecordComponent;\n/**\r\n * The first non standard attribute of this class. The next ones can be accessed with the {@link\r\n * Attribute#nextAttribute} field. May be {@literal null}.\r\n *\r\n * <p><b>WARNING</b>: this list stores the attributes in the <i>reverse</i> order of their visit.\r\n * firstAttribute is actually the last attribute visited in {@link #visitAttribute}. The {@link\r\n * #toByteArray} method writes the attributes in the order defined by this list, i.e. in the\r\n * reverse order specified by the user.\r\n */\r\nprivate Attribute firstAttribute;\n/**\r\n * Indicates what must be automatically computed in {@link MethodWriter}. Must be one of {@link\r\n * MethodWriter#COMPUTE_NOTHING}, {@link MethodWriter#COMPUTE_MAX_STACK_AND_LOCAL}, {@link\r\n * MethodWriter#COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES}, {@link\r\n * MethodWriter#COMPUTE_INSERTED_FRAMES}, or {@link MethodWriter#COMPUTE_ALL_FRAMES}.\r\n */\r\nprivate int compute;\n// -----------------------------------------------------------------------------------------------\r\n// Constructor\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Constructs a new {@link ClassWriter} object.\r\n *\r\n * @param flags option flags that can be used to modify the default behavior of this class. Must\r\n *     be zero or more of {@link #COMPUTE_MAXS} and {@link #COMPUTE_FRAMES}.\r\n */\r\npublic ClassWriter(final int flags) {\r\n    this(null, flags);\r\n}\n/**\r\n * Constructs a new {@link ClassWriter} object and enables optimizations for \"mostly add\" bytecode\r\n * transformations. These optimizations are the following:\r\n *\r\n * <ul>\r\n *   <li>The constant pool and bootstrap methods from the original class are copied as is in the\r\n *       new class, which saves time. New constant pool entries and new bootstrap methods will be\r\n *       added at the end if necessary, but unused constant pool entries or bootstrap methods\r\n *       <i>won't be removed</i>.\r\n *   <li>Methods that are not transformed are copied as is in the new class, directly from the\r\n *       original class bytecode (i.e. without emitting visit events for all the method\r\n *       instructions), which saves a <i>lot</i> of time. Untransformed methods are detected by\r\n *       the fact that the {@link ClassReader} receives {@link MethodVisitor} objects that come\r\n *       from a {@link ClassWriter} (and not from any other {@link ClassVisitor} instance).\r\n * </ul>\r\n *\r\n * @param classReader the {@link ClassReader} used to read the original class. It will be used to\r\n *     copy the entire constant pool and bootstrap methods from the original class and also to\r\n *     copy other fragments of original bytecode where applicable.\r\n * @param flags option flags that can be used to modify the default behavior of this class. Must\r\n *     be zero or more of {@link #COMPUTE_MAXS} and {@link #COMPUTE_FRAMES}. <i>These option flags\r\n *     do not affect methods that are copied as is in the new class. This means that neither the\r\n *     maximum stack size nor the stack frames will be computed for these methods</i>.\r\n */\r\npublic ClassWriter(final ClassReader classReader, final int flags) {\r\n    super(/* latest api = */\r\n    Opcodes.ASM9);\r\n    this.flags = flags;\r\n    symbolTable = classReader == null ? new SymbolTable(this) : new SymbolTable(this, classReader);\r\n    setFlags(flags);\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Accessors\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns true if all the given flags were passed to the constructor.\r\n *\r\n * @param flags some option flags. Must be zero or more of {@link #COMPUTE_MAXS} and {@link\r\n *     #COMPUTE_FRAMES}.\r\n * @return true if all the given flags, or more, were passed to the constructor.\r\n */\r\npublic boolean hasFlags(final int flags) {\r\n    return (this.flags & flags) == flags;\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Implementation of the ClassVisitor abstract class\r\n// -----------------------------------------------------------------------------------------------\r\n@Override\r\npublic final void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\r\n    this.version = version;\r\n    this.accessFlags = access;\r\n    this.thisClass = symbolTable.setMajorVersionAndClassName(version & 0xFFFF, name);\r\n    if (signature != null) {\r\n        this.signatureIndex = symbolTable.addConstantUtf8(signature);\r\n    }\r\n    this.superClass = superName == null ? 0 : symbolTable.addConstantClass(superName).index;\r\n    if (interfaces != null && interfaces.length > 0) {\r\n        interfaceCount = interfaces.length;\r\n        this.interfaces = new int[interfaceCount];\r\n        for (int i = 0; i < interfaceCount; ++i) {\r\n            this.interfaces[i] = symbolTable.addConstantClass(interfaces[i]).index;\r\n        }\r\n    }\r\n    if (compute == MethodWriter.COMPUTE_MAX_STACK_AND_LOCAL && (version & 0xFFFF) >= Opcodes.V1_7) {\r\n        compute = MethodWriter.COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES;\r\n    }\r\n}\n@Override\r\npublic final void visitSource(final String file, final String debug) {\r\n    if (file != null) {\r\n        sourceFileIndex = symbolTable.addConstantUtf8(file);\r\n    }\r\n    if (debug != null) {\r\n        debugExtension = new ByteVector().encodeUtf8(debug, 0, Integer.MAX_VALUE);\r\n    }\r\n}\n@Override\r\npublic final ModuleVisitor visitModule(final String name, final int access, final String version) {\r\n    return moduleWriter = new ModuleWriter(symbolTable, symbolTable.addConstantModule(name).index, access, version == null ? 0 : symbolTable.addConstantUtf8(version));\r\n}\n@Override\r\npublic final void visitNestHost(final String nestHost) {\r\n    nestHostClassIndex = symbolTable.addConstantClass(nestHost).index;\r\n}\n@Override\r\npublic final void visitOuterClass(final String owner, final String name, final String descriptor) {\r\n    enclosingClassIndex = symbolTable.addConstantClass(owner).index;\r\n    if (name != null && descriptor != null) {\r\n        enclosingMethodIndex = symbolTable.addConstantNameAndType(name, descriptor);\r\n    }\r\n}\n@Override\r\npublic final AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\r\n    if (visible) {\r\n        return lastRuntimeVisibleAnnotation = AnnotationWriter.create(symbolTable, descriptor, lastRuntimeVisibleAnnotation);\r\n    } else {\r\n        return lastRuntimeInvisibleAnnotation = AnnotationWriter.create(symbolTable, descriptor, lastRuntimeInvisibleAnnotation);\r\n    }\r\n}\n@Override\r\npublic final AnnotationVisitor visitTypeAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\r\n    if (visible) {\r\n        return lastRuntimeVisibleTypeAnnotation = AnnotationWriter.create(symbolTable, typeRef, typePath, descriptor, lastRuntimeVisibleTypeAnnotation);\r\n    } else {\r\n        return lastRuntimeInvisibleTypeAnnotation = AnnotationWriter.create(symbolTable, typeRef, typePath, descriptor, lastRuntimeInvisibleTypeAnnotation);\r\n    }\r\n}\n@Override\r\npublic final void visitAttribute(final Attribute attribute) {\r\n    // Store the attributes in the <i>reverse</i> order of their visit by this method.\r\n    attribute.nextAttribute = firstAttribute;\r\n    firstAttribute = attribute;\r\n}\n@Override\r\npublic final void visitNestMember(final String nestMember) {\r\n    if (nestMemberClasses == null) {\r\n        nestMemberClasses = new ByteVector();\r\n    }\r\n    ++numberOfNestMemberClasses;\r\n    nestMemberClasses.putShort(symbolTable.addConstantClass(nestMember).index);\r\n}\n@Override\r\npublic final void visitPermittedSubclass(final String permittedSubclass) {\r\n    if (permittedSubclasses == null) {\r\n        permittedSubclasses = new ByteVector();\r\n    }\r\n    ++numberOfPermittedSubclasses;\r\n    permittedSubclasses.putShort(symbolTable.addConstantClass(permittedSubclass).index);\r\n}\n@Override\r\npublic final void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {\r\n    if (innerClasses == null) {\r\n        innerClasses = new ByteVector();\r\n    }\r\n    // Section 4.7.6 of the JVMS states \"Every CONSTANT_Class_info entry in the constant_pool table\r\n    // which represents a class or interface C that is not a package member must have exactly one\r\n    // corresponding entry in the classes array\". To avoid duplicates we keep track in the info\r\n    // field of the Symbol of each CONSTANT_Class_info entry C whether an inner class entry has\r\n    // already been added for C. If so, we store the index of this inner class entry (plus one) in\r\n    // the info field. This trick allows duplicate detection in O(1) time.\r\n    Symbol nameSymbol = symbolTable.addConstantClass(name);\r\n    if (nameSymbol.info == 0) {\r\n        ++numberOfInnerClasses;\r\n        innerClasses.putShort(nameSymbol.index);\r\n        innerClasses.putShort(outerName == null ? 0 : symbolTable.addConstantClass(outerName).index);\r\n        innerClasses.putShort(innerName == null ? 0 : symbolTable.addConstantUtf8(innerName));\r\n        innerClasses.putShort(access);\r\n        nameSymbol.info = numberOfInnerClasses;\r\n    }\r\n    // Else, compare the inner classes entry nameSymbol.info - 1 with the arguments of this method\r\n    // and throw an exception if there is a difference?\r\n}\n@Override\r\npublic final RecordComponentVisitor visitRecordComponent(final String name, final String descriptor, final String signature) {\r\n    RecordComponentWriter recordComponentWriter = new RecordComponentWriter(symbolTable, name, descriptor, signature);\r\n    if (firstRecordComponent == null) {\r\n        firstRecordComponent = recordComponentWriter;\r\n    } else {\r\n        lastRecordComponent.delegate = recordComponentWriter;\r\n    }\r\n    return lastRecordComponent = recordComponentWriter;\r\n}\n@Override\r\npublic final FieldVisitor visitField(final int access, final String name, final String descriptor, final String signature, final Object value) {\r\n    FieldWriter fieldWriter = new FieldWriter(symbolTable, access, name, descriptor, signature, value);\r\n    if (firstField == null) {\r\n        firstField = fieldWriter;\r\n    } else {\r\n        lastField.fv = fieldWriter;\r\n    }\r\n    return lastField = fieldWriter;\r\n}\n@Override\r\npublic final MethodVisitor visitMethod(final int access, final String name, final String descriptor, final String signature, final String[] exceptions) {\r\n    MethodWriter methodWriter = new MethodWriter(symbolTable, access, name, descriptor, signature, exceptions, compute);\r\n    if (firstMethod == null) {\r\n        firstMethod = methodWriter;\r\n    } else {\r\n        lastMethod.mv = methodWriter;\r\n    }\r\n    return lastMethod = methodWriter;\r\n}\n@Override\r\npublic final void visitEnd() {\r\n    // Nothing to do.\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Other public methods\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the content of the class file that was built by this ClassWriter.\r\n *\r\n * @return the binary content of the JVMS ClassFile structure that was built by this ClassWriter.\r\n * @throws ClassTooLargeException if the constant pool of the class is too large.\r\n * @throws MethodTooLargeException if the Code attribute of a method is too large.\r\n */\r\npublic byte[] toByteArray() {\r\n    // First step: compute the size in bytes of the ClassFile structure.\r\n    // The magic field uses 4 bytes, 10 mandatory fields (minor_version, major_version,\r\n    // constant_pool_count, access_flags, this_class, super_class, interfaces_count, fields_count,\r\n    // methods_count and attributes_count) use 2 bytes each, and each interface uses 2 bytes too.\r\n    int size = 24 + 2 * interfaceCount;\r\n    int fieldsCount = 0;\r\n    FieldWriter fieldWriter = firstField;\r\n    while (fieldWriter != null) {\r\n        ++fieldsCount;\r\n        size += fieldWriter.computeFieldInfoSize();\r\n        fieldWriter = (FieldWriter) fieldWriter.fv;\r\n    }\r\n    int methodsCount = 0;\r\n    MethodWriter methodWriter = firstMethod;\r\n    while (methodWriter != null) {\r\n        ++methodsCount;\r\n        size += methodWriter.computeMethodInfoSize();\r\n        methodWriter = (MethodWriter) methodWriter.mv;\r\n    }\r\n    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\r\n    int attributesCount = 0;\r\n    if (innerClasses != null) {\r\n        ++attributesCount;\r\n        size += 8 + innerClasses.length;\r\n        symbolTable.addConstantUtf8(Constants.INNER_CLASSES);\r\n    }\r\n    if (enclosingClassIndex != 0) {\r\n        ++attributesCount;\r\n        size += 10;\r\n        symbolTable.addConstantUtf8(Constants.ENCLOSING_METHOD);\r\n    }\r\n    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xFFFF) < Opcodes.V1_5) {\r\n        ++attributesCount;\r\n        size += 6;\r\n        symbolTable.addConstantUtf8(Constants.SYNTHETIC);\r\n    }\r\n    if (signatureIndex != 0) {\r\n        ++attributesCount;\r\n        size += 8;\r\n        symbolTable.addConstantUtf8(Constants.SIGNATURE);\r\n    }\r\n    if (sourceFileIndex != 0) {\r\n        ++attributesCount;\r\n        size += 8;\r\n        symbolTable.addConstantUtf8(Constants.SOURCE_FILE);\r\n    }\r\n    if (debugExtension != null) {\r\n        ++attributesCount;\r\n        size += 6 + debugExtension.length;\r\n        symbolTable.addConstantUtf8(Constants.SOURCE_DEBUG_EXTENSION);\r\n    }\r\n    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {\r\n        ++attributesCount;\r\n        size += 6;\r\n        symbolTable.addConstantUtf8(Constants.DEPRECATED);\r\n    }\r\n    if (lastRuntimeVisibleAnnotation != null) {\r\n        ++attributesCount;\r\n        size += lastRuntimeVisibleAnnotation.computeAnnotationsSize(Constants.RUNTIME_VISIBLE_ANNOTATIONS);\r\n    }\r\n    if (lastRuntimeInvisibleAnnotation != null) {\r\n        ++attributesCount;\r\n        size += lastRuntimeInvisibleAnnotation.computeAnnotationsSize(Constants.RUNTIME_INVISIBLE_ANNOTATIONS);\r\n    }\r\n    if (lastRuntimeVisibleTypeAnnotation != null) {\r\n        ++attributesCount;\r\n        size += lastRuntimeVisibleTypeAnnotation.computeAnnotationsSize(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\r\n    }\r\n    if (lastRuntimeInvisibleTypeAnnotation != null) {\r\n        ++attributesCount;\r\n        size += lastRuntimeInvisibleTypeAnnotation.computeAnnotationsSize(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\r\n    }\r\n    if (symbolTable.computeBootstrapMethodsSize() > 0) {\r\n        ++attributesCount;\r\n        size += symbolTable.computeBootstrapMethodsSize();\r\n    }\r\n    if (moduleWriter != null) {\r\n        attributesCount += moduleWriter.getAttributeCount();\r\n        size += moduleWriter.computeAttributesSize();\r\n    }\r\n    if (nestHostClassIndex != 0) {\r\n        ++attributesCount;\r\n        size += 8;\r\n        symbolTable.addConstantUtf8(Constants.NEST_HOST);\r\n    }\r\n    if (nestMemberClasses != null) {\r\n        ++attributesCount;\r\n        size += 8 + nestMemberClasses.length;\r\n        symbolTable.addConstantUtf8(Constants.NEST_MEMBERS);\r\n    }\r\n    if (permittedSubclasses != null) {\r\n        ++attributesCount;\r\n        size += 8 + permittedSubclasses.length;\r\n        symbolTable.addConstantUtf8(Constants.PERMITTED_SUBCLASSES);\r\n    }\r\n    int recordComponentCount = 0;\r\n    int recordSize = 0;\r\n    if ((accessFlags & Opcodes.ACC_RECORD) != 0 || firstRecordComponent != null) {\r\n        RecordComponentWriter recordComponentWriter = firstRecordComponent;\r\n        while (recordComponentWriter != null) {\r\n            ++recordComponentCount;\r\n            recordSize += recordComponentWriter.computeRecordComponentInfoSize();\r\n            recordComponentWriter = (RecordComponentWriter) recordComponentWriter.delegate;\r\n        }\r\n        ++attributesCount;\r\n        size += 8 + recordSize;\r\n        symbolTable.addConstantUtf8(Constants.RECORD);\r\n    }\r\n    if (firstAttribute != null) {\r\n        attributesCount += firstAttribute.getAttributeCount();\r\n        size += firstAttribute.computeAttributesSize(symbolTable);\r\n    }\r\n    // IMPORTANT: this must be the last part of the ClassFile size computation, because the previous\r\n    // statements can add attribute names to the constant pool, thereby changing its size!\r\n    size += symbolTable.getConstantPoolLength();\r\n    int constantPoolCount = symbolTable.getConstantPoolCount();\r\n    if (constantPoolCount > 0xFFFF) {\r\n        throw new ClassTooLargeException(symbolTable.getClassName(), constantPoolCount);\r\n    }\r\n    // Second step: allocate a ByteVector of the correct size (in order to avoid any array copy in\r\n    // dynamic resizes) and fill it with the ClassFile content.\r\n    ByteVector result = new ByteVector(size);\r\n    result.putInt(0xCAFEBABE).putInt(version);\r\n    symbolTable.putConstantPool(result);\r\n    int mask = (version & 0xFFFF) < Opcodes.V1_5 ? Opcodes.ACC_SYNTHETIC : 0;\r\n    result.putShort(accessFlags & ~mask).putShort(thisClass).putShort(superClass);\r\n    result.putShort(interfaceCount);\r\n    for (int i = 0; i < interfaceCount; ++i) {\r\n        result.putShort(interfaces[i]);\r\n    }\r\n    result.putShort(fieldsCount);\r\n    fieldWriter = firstField;\r\n    while (fieldWriter != null) {\r\n        fieldWriter.putFieldInfo(result);\r\n        fieldWriter = (FieldWriter) fieldWriter.fv;\r\n    }\r\n    result.putShort(methodsCount);\r\n    boolean hasFrames = false;\r\n    boolean hasAsmInstructions = false;\r\n    methodWriter = firstMethod;\r\n    while (methodWriter != null) {\r\n        hasFrames |= methodWriter.hasFrames();\r\n        hasAsmInstructions |= methodWriter.hasAsmInstructions();\r\n        methodWriter.putMethodInfo(result);\r\n        methodWriter = (MethodWriter) methodWriter.mv;\r\n    }\r\n    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\r\n    result.putShort(attributesCount);\r\n    if (innerClasses != null) {\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.INNER_CLASSES)).putInt(innerClasses.length + 2).putShort(numberOfInnerClasses).putByteArray(innerClasses.data, 0, innerClasses.length);\r\n    }\r\n    if (enclosingClassIndex != 0) {\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.ENCLOSING_METHOD)).putInt(4).putShort(enclosingClassIndex).putShort(enclosingMethodIndex);\r\n    }\r\n    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xFFFF) < Opcodes.V1_5) {\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.SYNTHETIC)).putInt(0);\r\n    }\r\n    if (signatureIndex != 0) {\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.SIGNATURE)).putInt(2).putShort(signatureIndex);\r\n    }\r\n    if (sourceFileIndex != 0) {\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.SOURCE_FILE)).putInt(2).putShort(sourceFileIndex);\r\n    }\r\n    if (debugExtension != null) {\r\n        int length = debugExtension.length;\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.SOURCE_DEBUG_EXTENSION)).putInt(length).putByteArray(debugExtension.data, 0, length);\r\n    }\r\n    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.DEPRECATED)).putInt(0);\r\n    }\r\n    AnnotationWriter.putAnnotations(symbolTable, lastRuntimeVisibleAnnotation, lastRuntimeInvisibleAnnotation, lastRuntimeVisibleTypeAnnotation, lastRuntimeInvisibleTypeAnnotation, result);\r\n    symbolTable.putBootstrapMethods(result);\r\n    if (moduleWriter != null) {\r\n        moduleWriter.putAttributes(result);\r\n    }\r\n    if (nestHostClassIndex != 0) {\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.NEST_HOST)).putInt(2).putShort(nestHostClassIndex);\r\n    }\r\n    if (nestMemberClasses != null) {\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.NEST_MEMBERS)).putInt(nestMemberClasses.length + 2).putShort(numberOfNestMemberClasses).putByteArray(nestMemberClasses.data, 0, nestMemberClasses.length);\r\n    }\r\n    if (permittedSubclasses != null) {\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.PERMITTED_SUBCLASSES)).putInt(permittedSubclasses.length + 2).putShort(numberOfPermittedSubclasses).putByteArray(permittedSubclasses.data, 0, permittedSubclasses.length);\r\n    }\r\n    if ((accessFlags & Opcodes.ACC_RECORD) != 0 || firstRecordComponent != null) {\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.RECORD)).putInt(recordSize + 2).putShort(recordComponentCount);\r\n        RecordComponentWriter recordComponentWriter = firstRecordComponent;\r\n        while (recordComponentWriter != null) {\r\n            recordComponentWriter.putRecordComponentInfo(result);\r\n            recordComponentWriter = (RecordComponentWriter) recordComponentWriter.delegate;\r\n        }\r\n    }\r\n    if (firstAttribute != null) {\r\n        firstAttribute.putAttributes(symbolTable, result);\r\n    }\r\n    // Third step: replace the ASM specific instructions, if any.\r\n    if (hasAsmInstructions) {\r\n        return replaceAsmInstructions(result.data, hasFrames);\r\n    } else {\r\n        return result.data;\r\n    }\r\n}\n/**\r\n * Returns the equivalent of the given class file, with the ASM specific instructions replaced\r\n * with standard ones. This is done with a ClassReader -&gt; ClassWriter round trip.\r\n *\r\n * @param classFile a class file containing ASM specific instructions, generated by this\r\n *     ClassWriter.\r\n * @param hasFrames whether there is at least one stack map frames in 'classFile'.\r\n * @return an equivalent of 'classFile', with the ASM specific instructions replaced with standard\r\n *     ones.\r\n */\r\nprivate byte[] replaceAsmInstructions(final byte[] classFile, final boolean hasFrames) {\r\n    final Attribute[] attributes = getAttributePrototypes();\r\n    firstField = null;\r\n    lastField = null;\r\n    firstMethod = null;\r\n    lastMethod = null;\r\n    lastRuntimeVisibleAnnotation = null;\r\n    lastRuntimeInvisibleAnnotation = null;\r\n    lastRuntimeVisibleTypeAnnotation = null;\r\n    lastRuntimeInvisibleTypeAnnotation = null;\r\n    moduleWriter = null;\r\n    nestHostClassIndex = 0;\r\n    numberOfNestMemberClasses = 0;\r\n    nestMemberClasses = null;\r\n    numberOfPermittedSubclasses = 0;\r\n    permittedSubclasses = null;\r\n    firstRecordComponent = null;\r\n    lastRecordComponent = null;\r\n    firstAttribute = null;\r\n    compute = hasFrames ? MethodWriter.COMPUTE_INSERTED_FRAMES : MethodWriter.COMPUTE_NOTHING;\r\n    new ClassReader(classFile, 0, /* checkClassVersion= */\r\n    false).accept(this, attributes, (hasFrames ? ClassReader.EXPAND_FRAMES : 0) | ClassReader.EXPAND_ASM_INSNS);\r\n    return toByteArray();\r\n}\n/**\r\n * Returns the prototypes of the attributes used by this class, its fields and its methods.\r\n *\r\n * @return the prototypes of the attributes used by this class, its fields and its methods.\r\n */\r\nprivate Attribute[] getAttributePrototypes() {\r\n    Attribute.Set attributePrototypes = new Attribute.Set();\r\n    attributePrototypes.addAttributes(firstAttribute);\r\n    FieldWriter fieldWriter = firstField;\r\n    while (fieldWriter != null) {\r\n        fieldWriter.collectAttributePrototypes(attributePrototypes);\r\n        fieldWriter = (FieldWriter) fieldWriter.fv;\r\n    }\r\n    MethodWriter methodWriter = firstMethod;\r\n    while (methodWriter != null) {\r\n        methodWriter.collectAttributePrototypes(attributePrototypes);\r\n        methodWriter = (MethodWriter) methodWriter.mv;\r\n    }\r\n    RecordComponentWriter recordComponentWriter = firstRecordComponent;\r\n    while (recordComponentWriter != null) {\r\n        recordComponentWriter.collectAttributePrototypes(attributePrototypes);\r\n        recordComponentWriter = (RecordComponentWriter) recordComponentWriter.delegate;\r\n    }\r\n    return attributePrototypes.toArray();\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Utility methods: constant pool management for Attribute sub classes\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Adds a number or string constant to the constant pool of the class being build. Does nothing if\r\n * the constant pool already contains a similar item. <i>This method is intended for {@link\r\n * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param value the value of the constant to be added to the constant pool. This parameter must be\r\n *     an {@link Integer}, a {@link Float}, a {@link Long}, a {@link Double} or a {@link String}.\r\n * @return the index of a new or already existing constant item with the given value.\r\n */\r\npublic int newConst(final Object value) {\r\n    return symbolTable.addConstant(value).index;\r\n}\n/**\r\n * Adds an UTF8 string to the constant pool of the class being build. Does nothing if the constant\r\n * pool already contains a similar item. <i>This method is intended for {@link Attribute} sub\r\n * classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param value the String value.\r\n * @return the index of a new or already existing UTF8 item.\r\n */\r\n// DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).\r\npublic int newUTF8(final String value) {\r\n    return symbolTable.addConstantUtf8(value);\r\n}\n/**\r\n * Adds a class reference to the constant pool of the class being build. Does nothing if the\r\n * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}\r\n * sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param value the internal name of the class (see {@link Type#getInternalName()}).\r\n * @return the index of a new or already existing class reference item.\r\n */\r\npublic int newClass(final String value) {\r\n    return symbolTable.addConstantClass(value).index;\r\n}\n/**\r\n * Adds a method type reference to the constant pool of the class being build. Does nothing if the\r\n * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}\r\n * sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param methodDescriptor method descriptor of the method type.\r\n * @return the index of a new or already existing method type reference item.\r\n */\r\npublic int newMethodType(final String methodDescriptor) {\r\n    return symbolTable.addConstantMethodType(methodDescriptor).index;\r\n}\n/**\r\n * Adds a module reference to the constant pool of the class being build. Does nothing if the\r\n * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}\r\n * sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param moduleName name of the module.\r\n * @return the index of a new or already existing module reference item.\r\n */\r\npublic int newModule(final String moduleName) {\r\n    return symbolTable.addConstantModule(moduleName).index;\r\n}\n/**\r\n * Adds a package reference to the constant pool of the class being build. Does nothing if the\r\n * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}\r\n * sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param packageName name of the package in its internal form.\r\n * @return the index of a new or already existing module reference item.\r\n */\r\npublic int newPackage(final String packageName) {\r\n    return symbolTable.addConstantPackage(packageName).index;\r\n}\n/**\r\n * Adds a handle to the constant pool of the class being build. Does nothing if the constant pool\r\n * already contains a similar item. <i>This method is intended for {@link Attribute} sub classes,\r\n * and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param tag the kind of this handle. Must be {@link Opcodes#H_GETFIELD}, {@link\r\n *     Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link\r\n *     Opcodes#H_INVOKEVIRTUAL}, {@link Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL},\r\n *     {@link Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\r\n * @param owner the internal name of the field or method owner class (see {@link\r\n *     Type#getInternalName()}).\r\n * @param name the name of the field or method.\r\n * @param descriptor the descriptor of the field or method.\r\n * @return the index of a new or already existing method type reference item.\r\n * @deprecated this method is superseded by {@link #newHandle(int, String, String, String,\r\n *     boolean)}.\r\n */\r\n@Deprecated\r\npublic int newHandle(final int tag, final String owner, final String name, final String descriptor) {\r\n    return newHandle(tag, owner, name, descriptor, tag == Opcodes.H_INVOKEINTERFACE);\r\n}\n/**\r\n * Adds a handle to the constant pool of the class being build. Does nothing if the constant pool\r\n * already contains a similar item. <i>This method is intended for {@link Attribute} sub classes,\r\n * and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param tag the kind of this handle. Must be {@link Opcodes#H_GETFIELD}, {@link\r\n *     Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link\r\n *     Opcodes#H_INVOKEVIRTUAL}, {@link Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL},\r\n *     {@link Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\r\n * @param owner the internal name of the field or method owner class (see {@link\r\n *     Type#getInternalName()}).\r\n * @param name the name of the field or method.\r\n * @param descriptor the descriptor of the field or method.\r\n * @param isInterface true if the owner is an interface.\r\n * @return the index of a new or already existing method type reference item.\r\n */\r\npublic int newHandle(final int tag, final String owner, final String name, final String descriptor, final boolean isInterface) {\r\n    return symbolTable.addConstantMethodHandle(tag, owner, name, descriptor, isInterface).index;\r\n}\n/**\r\n * Adds a dynamic constant reference to the constant pool of the class being build. Does nothing\r\n * if the constant pool already contains a similar item. <i>This method is intended for {@link\r\n * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param name name of the invoked method.\r\n * @param descriptor field descriptor of the constant type.\r\n * @param bootstrapMethodHandle the bootstrap method.\r\n * @param bootstrapMethodArguments the bootstrap method constant arguments.\r\n * @return the index of a new or already existing dynamic constant reference item.\r\n */\r\npublic int newConstantDynamic(final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\r\n    return symbolTable.addConstantDynamic(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments).index;\r\n}\n/**\r\n * Adds an invokedynamic reference to the constant pool of the class being build. Does nothing if\r\n * the constant pool already contains a similar item. <i>This method is intended for {@link\r\n * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param name name of the invoked method.\r\n * @param descriptor descriptor of the invoke method.\r\n * @param bootstrapMethodHandle the bootstrap method.\r\n * @param bootstrapMethodArguments the bootstrap method constant arguments.\r\n * @return the index of a new or already existing invokedynamic reference item.\r\n */\r\npublic int newInvokeDynamic(final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\r\n    return symbolTable.addConstantInvokeDynamic(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments).index;\r\n}\n/**\r\n * Adds a field reference to the constant pool of the class being build. Does nothing if the\r\n * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}\r\n * sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param owner the internal name of the field's owner class (see {@link Type#getInternalName()}).\r\n * @param name the field's name.\r\n * @param descriptor the field's descriptor.\r\n * @return the index of a new or already existing field reference item.\r\n */\r\npublic int newField(final String owner, final String name, final String descriptor) {\r\n    return symbolTable.addConstantFieldref(owner, name, descriptor).index;\r\n}\n/**\r\n * Adds a method reference to the constant pool of the class being build. Does nothing if the\r\n * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}\r\n * sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param owner the internal name of the method's owner class (see {@link\r\n *     Type#getInternalName()}).\r\n * @param name the method's name.\r\n * @param descriptor the method's descriptor.\r\n * @param isInterface {@literal true} if {@code owner} is an interface.\r\n * @return the index of a new or already existing method reference item.\r\n */\r\npublic int newMethod(final String owner, final String name, final String descriptor, final boolean isInterface) {\r\n    return symbolTable.addConstantMethodref(owner, name, descriptor, isInterface).index;\r\n}\n/**\r\n * Adds a name and type to the constant pool of the class being build. Does nothing if the\r\n * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}\r\n * sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param name a name.\r\n * @param descriptor a type descriptor.\r\n * @return the index of a new or already existing name and type item.\r\n */\r\npublic int newNameType(final String name, final String descriptor) {\r\n    return symbolTable.addConstantNameAndType(name, descriptor);\r\n}\n/**\r\n * Changes the computation strategy of method properties like max stack size, max number of local\r\n * variables, and frames.\r\n *\r\n * <p><b>WARNING</b>: {@link #setFlags(int)} method changes the behavior of new method visitors\r\n * returned from {@link #visitMethod(int, String, String, String, String[])}. The behavior will be\r\n * changed only after the next method visitor is returned. All the previously returned method\r\n * visitors keep their previous behavior.\r\n *\r\n * @param flags option flags that can be used to modify the default behavior of this class. Must\r\n *     be zero or more of {@link #COMPUTE_MAXS} and {@link #COMPUTE_FRAMES}.\r\n */\r\npublic final void setFlags(final int flags) {\r\n    if ((flags & ClassWriter.COMPUTE_FRAMES) != 0) {\r\n        compute = MethodWriter.COMPUTE_ALL_FRAMES;\r\n    } else if ((flags & ClassWriter.COMPUTE_MAXS) != 0) {\r\n        compute = MethodWriter.COMPUTE_MAX_STACK_AND_LOCAL;\r\n    } else {\r\n        compute = MethodWriter.COMPUTE_NOTHING;\r\n    }\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Default method to compute common super classes when computing stack map frames\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the common super type of the two given types. The default implementation of this method\r\n * <i>loads</i> the two given classes and uses the java.lang.Class methods to find the common\r\n * super class. It can be overridden to compute this common super type in other ways, in\r\n * particular without actually loading any class, or to take into account the class that is\r\n * currently being generated by this ClassWriter, which can of course not be loaded since it is\r\n * under construction.\r\n *\r\n * @param type1 the internal name of a class (see {@link Type#getInternalName()}).\r\n * @param type2 the internal name of another class (see {@link Type#getInternalName()}).\r\n * @return the internal name of the common super class of the two given classes (see {@link\r\n *     Type#getInternalName()}).\r\n */\r\nprotected String getCommonSuperClass(final String type1, final String type2) {\r\n    ClassLoader classLoader = getClassLoader();\r\n    Class<?> class1;\r\n    try {\r\n        class1 = Class.forName(type1.replace('/', '.'), false, classLoader);\r\n    } catch (ClassNotFoundException e) {\r\n        throw new TypeNotPresentException(type1, e);\r\n    }\r\n    Class<?> class2;\r\n    try {\r\n        class2 = Class.forName(type2.replace('/', '.'), false, classLoader);\r\n    } catch (ClassNotFoundException e) {\r\n        throw new TypeNotPresentException(type2, e);\r\n    }\r\n    if (class1.isAssignableFrom(class2)) {\r\n        return type1;\r\n    }\r\n    if (class2.isAssignableFrom(class1)) {\r\n        return type2;\r\n    }\r\n    if (class1.isInterface() || class2.isInterface()) {\r\n        return \"java/lang/Object\";\r\n    } else {\r\n        do {\r\n            class1 = class1.getSuperclass();\r\n        } while (!class1.isAssignableFrom(class2));\r\n        return class1.getName().replace('.', '/');\r\n    }\r\n}\n/**\r\n * Returns the {@link ClassLoader} to be used by the default implementation of {@link\r\n * #getCommonSuperClass(String, String)}, that of this {@link ClassWriter}'s runtime type by\r\n * default.\r\n *\r\n * @return ClassLoader\r\n */\r\nprotected ClassLoader getClassLoader() {\r\n    // SPRING PATCH: prefer thread context ClassLoader for application classes\r\n    ClassLoader classLoader = null;\r\n    try {\r\n        classLoader = Thread.currentThread().getContextClassLoader();\r\n    } catch (Throwable ex) {\r\n        // Cannot access thread context ClassLoader - falling back...\r\n    }\r\n    return (classLoader != null ? classLoader : getClass().getClassLoader());\r\n}",
    "comment": "\n * A {@link ClassVisitor} that generates a corresponding ClassFile structure, as defined in the Java\n * Virtual Machine Specification (JVMS). It can be used alone, to generate a Java class \"from\n * scratch\", or with one or more {@link ClassReader} and adapter {@link ClassVisitor} to generate a\n * modified class from one or more existing Java classes.\n *\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html\">JVMS 4</a>\n * @author Eric Bruneton\n "
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#hasFlags(int)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Accessors\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns true if all the given flags were passed to the constructor.\r\n *\r\n * @param flags some option flags. Must be zero or more of {@link #COMPUTE_MAXS} and {@link\r\n *     #COMPUTE_FRAMES}.\r\n * @return true if all the given flags, or more, were passed to the constructor.\r\n */\r\npublic boolean hasFlags(final int flags) {\r\n    return (this.flags & flags) == flags;\r\n}",
    "comment": "\n   * Returns true if all the given flags were passed to the constructor.\n   *\n   * @param flags some option flags. Must be zero or more of {@link #COMPUTE_MAXS} and {@link\n   *     #COMPUTE_FRAMES}.\n   * @return true if all the given flags, or more, were passed to the constructor.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#visit(int,int,String,String,String,String[])",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Implementation of the ClassVisitor abstract class\r\n// -----------------------------------------------------------------------------------------------\r\n@Override\r\npublic final void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\r\n    this.version = version;\r\n    this.accessFlags = access;\r\n    this.thisClass = symbolTable.setMajorVersionAndClassName(version & 0xFFFF, name);\r\n    if (signature != null) {\r\n        this.signatureIndex = symbolTable.addConstantUtf8(signature);\r\n    }\r\n    this.superClass = superName == null ? 0 : symbolTable.addConstantClass(superName).index;\r\n    if (interfaces != null && interfaces.length > 0) {\r\n        interfaceCount = interfaces.length;\r\n        this.interfaces = new int[interfaceCount];\r\n        for (int i = 0; i < interfaceCount; ++i) {\r\n            this.interfaces[i] = symbolTable.addConstantClass(interfaces[i]).index;\r\n        }\r\n    }\r\n    if (compute == MethodWriter.COMPUTE_MAX_STACK_AND_LOCAL && (version & 0xFFFF) >= Opcodes.V1_7) {\r\n        compute = MethodWriter.COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#visitSource(String,String)",
    "entityType": "method",
    "code": "@Override\r\npublic final void visitSource(final String file, final String debug) {\r\n    if (file != null) {\r\n        sourceFileIndex = symbolTable.addConstantUtf8(file);\r\n    }\r\n    if (debug != null) {\r\n        debugExtension = new ByteVector().encodeUtf8(debug, 0, Integer.MAX_VALUE);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#visitModule(String,int,String)",
    "entityType": "method",
    "code": "@Override\r\npublic final ModuleVisitor visitModule(final String name, final int access, final String version) {\r\n    return moduleWriter = new ModuleWriter(symbolTable, symbolTable.addConstantModule(name).index, access, version == null ? 0 : symbolTable.addConstantUtf8(version));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#visitNestHost(String)",
    "entityType": "method",
    "code": "@Override\r\npublic final void visitNestHost(final String nestHost) {\r\n    nestHostClassIndex = symbolTable.addConstantClass(nestHost).index;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#visitOuterClass(String,String,String)",
    "entityType": "method",
    "code": "@Override\r\npublic final void visitOuterClass(final String owner, final String name, final String descriptor) {\r\n    enclosingClassIndex = symbolTable.addConstantClass(owner).index;\r\n    if (name != null && descriptor != null) {\r\n        enclosingMethodIndex = symbolTable.addConstantNameAndType(name, descriptor);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#visitAnnotation(String,boolean)",
    "entityType": "method",
    "code": "@Override\r\npublic final AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\r\n    if (visible) {\r\n        return lastRuntimeVisibleAnnotation = AnnotationWriter.create(symbolTable, descriptor, lastRuntimeVisibleAnnotation);\r\n    } else {\r\n        return lastRuntimeInvisibleAnnotation = AnnotationWriter.create(symbolTable, descriptor, lastRuntimeInvisibleAnnotation);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#visitTypeAnnotation(int,TypePath,String,boolean)",
    "entityType": "method",
    "code": "@Override\r\npublic final AnnotationVisitor visitTypeAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\r\n    if (visible) {\r\n        return lastRuntimeVisibleTypeAnnotation = AnnotationWriter.create(symbolTable, typeRef, typePath, descriptor, lastRuntimeVisibleTypeAnnotation);\r\n    } else {\r\n        return lastRuntimeInvisibleTypeAnnotation = AnnotationWriter.create(symbolTable, typeRef, typePath, descriptor, lastRuntimeInvisibleTypeAnnotation);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#visitAttribute(Attribute)",
    "entityType": "method",
    "code": "@Override\r\npublic final void visitAttribute(final Attribute attribute) {\r\n    // Store the attributes in the <i>reverse</i> order of their visit by this method.\r\n    attribute.nextAttribute = firstAttribute;\r\n    firstAttribute = attribute;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#visitNestMember(String)",
    "entityType": "method",
    "code": "@Override\r\npublic final void visitNestMember(final String nestMember) {\r\n    if (nestMemberClasses == null) {\r\n        nestMemberClasses = new ByteVector();\r\n    }\r\n    ++numberOfNestMemberClasses;\r\n    nestMemberClasses.putShort(symbolTable.addConstantClass(nestMember).index);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#visitPermittedSubclass(String)",
    "entityType": "method",
    "code": "@Override\r\npublic final void visitPermittedSubclass(final String permittedSubclass) {\r\n    if (permittedSubclasses == null) {\r\n        permittedSubclasses = new ByteVector();\r\n    }\r\n    ++numberOfPermittedSubclasses;\r\n    permittedSubclasses.putShort(symbolTable.addConstantClass(permittedSubclass).index);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#visitInnerClass(String,String,String,int)",
    "entityType": "method",
    "code": "@Override\r\npublic final void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {\r\n    if (innerClasses == null) {\r\n        innerClasses = new ByteVector();\r\n    }\r\n    // Section 4.7.6 of the JVMS states \"Every CONSTANT_Class_info entry in the constant_pool table\r\n    // which represents a class or interface C that is not a package member must have exactly one\r\n    // corresponding entry in the classes array\". To avoid duplicates we keep track in the info\r\n    // field of the Symbol of each CONSTANT_Class_info entry C whether an inner class entry has\r\n    // already been added for C. If so, we store the index of this inner class entry (plus one) in\r\n    // the info field. This trick allows duplicate detection in O(1) time.\r\n    Symbol nameSymbol = symbolTable.addConstantClass(name);\r\n    if (nameSymbol.info == 0) {\r\n        ++numberOfInnerClasses;\r\n        innerClasses.putShort(nameSymbol.index);\r\n        innerClasses.putShort(outerName == null ? 0 : symbolTable.addConstantClass(outerName).index);\r\n        innerClasses.putShort(innerName == null ? 0 : symbolTable.addConstantUtf8(innerName));\r\n        innerClasses.putShort(access);\r\n        nameSymbol.info = numberOfInnerClasses;\r\n    }\r\n    // Else, compare the inner classes entry nameSymbol.info - 1 with the arguments of this method\r\n    // and throw an exception if there is a difference?\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#visitRecordComponent(String,String,String)",
    "entityType": "method",
    "code": "@Override\r\npublic final RecordComponentVisitor visitRecordComponent(final String name, final String descriptor, final String signature) {\r\n    RecordComponentWriter recordComponentWriter = new RecordComponentWriter(symbolTable, name, descriptor, signature);\r\n    if (firstRecordComponent == null) {\r\n        firstRecordComponent = recordComponentWriter;\r\n    } else {\r\n        lastRecordComponent.delegate = recordComponentWriter;\r\n    }\r\n    return lastRecordComponent = recordComponentWriter;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#visitField(int,String,String,String,Object)",
    "entityType": "method",
    "code": "@Override\r\npublic final FieldVisitor visitField(final int access, final String name, final String descriptor, final String signature, final Object value) {\r\n    FieldWriter fieldWriter = new FieldWriter(symbolTable, access, name, descriptor, signature, value);\r\n    if (firstField == null) {\r\n        firstField = fieldWriter;\r\n    } else {\r\n        lastField.fv = fieldWriter;\r\n    }\r\n    return lastField = fieldWriter;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#visitMethod(int,String,String,String,String[])",
    "entityType": "method",
    "code": "@Override\r\npublic final MethodVisitor visitMethod(final int access, final String name, final String descriptor, final String signature, final String[] exceptions) {\r\n    MethodWriter methodWriter = new MethodWriter(symbolTable, access, name, descriptor, signature, exceptions, compute);\r\n    if (firstMethod == null) {\r\n        firstMethod = methodWriter;\r\n    } else {\r\n        lastMethod.mv = methodWriter;\r\n    }\r\n    return lastMethod = methodWriter;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#visitEnd()",
    "entityType": "method",
    "code": "@Override\r\npublic final void visitEnd() {\r\n    // Nothing to do.\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#toByteArray()",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Other public methods\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the content of the class file that was built by this ClassWriter.\r\n *\r\n * @return the binary content of the JVMS ClassFile structure that was built by this ClassWriter.\r\n * @throws ClassTooLargeException if the constant pool of the class is too large.\r\n * @throws MethodTooLargeException if the Code attribute of a method is too large.\r\n */\r\npublic byte[] toByteArray() {\r\n    // First step: compute the size in bytes of the ClassFile structure.\r\n    // The magic field uses 4 bytes, 10 mandatory fields (minor_version, major_version,\r\n    // constant_pool_count, access_flags, this_class, super_class, interfaces_count, fields_count,\r\n    // methods_count and attributes_count) use 2 bytes each, and each interface uses 2 bytes too.\r\n    int size = 24 + 2 * interfaceCount;\r\n    int fieldsCount = 0;\r\n    FieldWriter fieldWriter = firstField;\r\n    while (fieldWriter != null) {\r\n        ++fieldsCount;\r\n        size += fieldWriter.computeFieldInfoSize();\r\n        fieldWriter = (FieldWriter) fieldWriter.fv;\r\n    }\r\n    int methodsCount = 0;\r\n    MethodWriter methodWriter = firstMethod;\r\n    while (methodWriter != null) {\r\n        ++methodsCount;\r\n        size += methodWriter.computeMethodInfoSize();\r\n        methodWriter = (MethodWriter) methodWriter.mv;\r\n    }\r\n    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\r\n    int attributesCount = 0;\r\n    if (innerClasses != null) {\r\n        ++attributesCount;\r\n        size += 8 + innerClasses.length;\r\n        symbolTable.addConstantUtf8(Constants.INNER_CLASSES);\r\n    }\r\n    if (enclosingClassIndex != 0) {\r\n        ++attributesCount;\r\n        size += 10;\r\n        symbolTable.addConstantUtf8(Constants.ENCLOSING_METHOD);\r\n    }\r\n    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xFFFF) < Opcodes.V1_5) {\r\n        ++attributesCount;\r\n        size += 6;\r\n        symbolTable.addConstantUtf8(Constants.SYNTHETIC);\r\n    }\r\n    if (signatureIndex != 0) {\r\n        ++attributesCount;\r\n        size += 8;\r\n        symbolTable.addConstantUtf8(Constants.SIGNATURE);\r\n    }\r\n    if (sourceFileIndex != 0) {\r\n        ++attributesCount;\r\n        size += 8;\r\n        symbolTable.addConstantUtf8(Constants.SOURCE_FILE);\r\n    }\r\n    if (debugExtension != null) {\r\n        ++attributesCount;\r\n        size += 6 + debugExtension.length;\r\n        symbolTable.addConstantUtf8(Constants.SOURCE_DEBUG_EXTENSION);\r\n    }\r\n    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {\r\n        ++attributesCount;\r\n        size += 6;\r\n        symbolTable.addConstantUtf8(Constants.DEPRECATED);\r\n    }\r\n    if (lastRuntimeVisibleAnnotation != null) {\r\n        ++attributesCount;\r\n        size += lastRuntimeVisibleAnnotation.computeAnnotationsSize(Constants.RUNTIME_VISIBLE_ANNOTATIONS);\r\n    }\r\n    if (lastRuntimeInvisibleAnnotation != null) {\r\n        ++attributesCount;\r\n        size += lastRuntimeInvisibleAnnotation.computeAnnotationsSize(Constants.RUNTIME_INVISIBLE_ANNOTATIONS);\r\n    }\r\n    if (lastRuntimeVisibleTypeAnnotation != null) {\r\n        ++attributesCount;\r\n        size += lastRuntimeVisibleTypeAnnotation.computeAnnotationsSize(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\r\n    }\r\n    if (lastRuntimeInvisibleTypeAnnotation != null) {\r\n        ++attributesCount;\r\n        size += lastRuntimeInvisibleTypeAnnotation.computeAnnotationsSize(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\r\n    }\r\n    if (symbolTable.computeBootstrapMethodsSize() > 0) {\r\n        ++attributesCount;\r\n        size += symbolTable.computeBootstrapMethodsSize();\r\n    }\r\n    if (moduleWriter != null) {\r\n        attributesCount += moduleWriter.getAttributeCount();\r\n        size += moduleWriter.computeAttributesSize();\r\n    }\r\n    if (nestHostClassIndex != 0) {\r\n        ++attributesCount;\r\n        size += 8;\r\n        symbolTable.addConstantUtf8(Constants.NEST_HOST);\r\n    }\r\n    if (nestMemberClasses != null) {\r\n        ++attributesCount;\r\n        size += 8 + nestMemberClasses.length;\r\n        symbolTable.addConstantUtf8(Constants.NEST_MEMBERS);\r\n    }\r\n    if (permittedSubclasses != null) {\r\n        ++attributesCount;\r\n        size += 8 + permittedSubclasses.length;\r\n        symbolTable.addConstantUtf8(Constants.PERMITTED_SUBCLASSES);\r\n    }\r\n    int recordComponentCount = 0;\r\n    int recordSize = 0;\r\n    if ((accessFlags & Opcodes.ACC_RECORD) != 0 || firstRecordComponent != null) {\r\n        RecordComponentWriter recordComponentWriter = firstRecordComponent;\r\n        while (recordComponentWriter != null) {\r\n            ++recordComponentCount;\r\n            recordSize += recordComponentWriter.computeRecordComponentInfoSize();\r\n            recordComponentWriter = (RecordComponentWriter) recordComponentWriter.delegate;\r\n        }\r\n        ++attributesCount;\r\n        size += 8 + recordSize;\r\n        symbolTable.addConstantUtf8(Constants.RECORD);\r\n    }\r\n    if (firstAttribute != null) {\r\n        attributesCount += firstAttribute.getAttributeCount();\r\n        size += firstAttribute.computeAttributesSize(symbolTable);\r\n    }\r\n    // IMPORTANT: this must be the last part of the ClassFile size computation, because the previous\r\n    // statements can add attribute names to the constant pool, thereby changing its size!\r\n    size += symbolTable.getConstantPoolLength();\r\n    int constantPoolCount = symbolTable.getConstantPoolCount();\r\n    if (constantPoolCount > 0xFFFF) {\r\n        throw new ClassTooLargeException(symbolTable.getClassName(), constantPoolCount);\r\n    }\r\n    // Second step: allocate a ByteVector of the correct size (in order to avoid any array copy in\r\n    // dynamic resizes) and fill it with the ClassFile content.\r\n    ByteVector result = new ByteVector(size);\r\n    result.putInt(0xCAFEBABE).putInt(version);\r\n    symbolTable.putConstantPool(result);\r\n    int mask = (version & 0xFFFF) < Opcodes.V1_5 ? Opcodes.ACC_SYNTHETIC : 0;\r\n    result.putShort(accessFlags & ~mask).putShort(thisClass).putShort(superClass);\r\n    result.putShort(interfaceCount);\r\n    for (int i = 0; i < interfaceCount; ++i) {\r\n        result.putShort(interfaces[i]);\r\n    }\r\n    result.putShort(fieldsCount);\r\n    fieldWriter = firstField;\r\n    while (fieldWriter != null) {\r\n        fieldWriter.putFieldInfo(result);\r\n        fieldWriter = (FieldWriter) fieldWriter.fv;\r\n    }\r\n    result.putShort(methodsCount);\r\n    boolean hasFrames = false;\r\n    boolean hasAsmInstructions = false;\r\n    methodWriter = firstMethod;\r\n    while (methodWriter != null) {\r\n        hasFrames |= methodWriter.hasFrames();\r\n        hasAsmInstructions |= methodWriter.hasAsmInstructions();\r\n        methodWriter.putMethodInfo(result);\r\n        methodWriter = (MethodWriter) methodWriter.mv;\r\n    }\r\n    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\r\n    result.putShort(attributesCount);\r\n    if (innerClasses != null) {\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.INNER_CLASSES)).putInt(innerClasses.length + 2).putShort(numberOfInnerClasses).putByteArray(innerClasses.data, 0, innerClasses.length);\r\n    }\r\n    if (enclosingClassIndex != 0) {\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.ENCLOSING_METHOD)).putInt(4).putShort(enclosingClassIndex).putShort(enclosingMethodIndex);\r\n    }\r\n    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xFFFF) < Opcodes.V1_5) {\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.SYNTHETIC)).putInt(0);\r\n    }\r\n    if (signatureIndex != 0) {\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.SIGNATURE)).putInt(2).putShort(signatureIndex);\r\n    }\r\n    if (sourceFileIndex != 0) {\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.SOURCE_FILE)).putInt(2).putShort(sourceFileIndex);\r\n    }\r\n    if (debugExtension != null) {\r\n        int length = debugExtension.length;\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.SOURCE_DEBUG_EXTENSION)).putInt(length).putByteArray(debugExtension.data, 0, length);\r\n    }\r\n    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.DEPRECATED)).putInt(0);\r\n    }\r\n    AnnotationWriter.putAnnotations(symbolTable, lastRuntimeVisibleAnnotation, lastRuntimeInvisibleAnnotation, lastRuntimeVisibleTypeAnnotation, lastRuntimeInvisibleTypeAnnotation, result);\r\n    symbolTable.putBootstrapMethods(result);\r\n    if (moduleWriter != null) {\r\n        moduleWriter.putAttributes(result);\r\n    }\r\n    if (nestHostClassIndex != 0) {\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.NEST_HOST)).putInt(2).putShort(nestHostClassIndex);\r\n    }\r\n    if (nestMemberClasses != null) {\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.NEST_MEMBERS)).putInt(nestMemberClasses.length + 2).putShort(numberOfNestMemberClasses).putByteArray(nestMemberClasses.data, 0, nestMemberClasses.length);\r\n    }\r\n    if (permittedSubclasses != null) {\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.PERMITTED_SUBCLASSES)).putInt(permittedSubclasses.length + 2).putShort(numberOfPermittedSubclasses).putByteArray(permittedSubclasses.data, 0, permittedSubclasses.length);\r\n    }\r\n    if ((accessFlags & Opcodes.ACC_RECORD) != 0 || firstRecordComponent != null) {\r\n        result.putShort(symbolTable.addConstantUtf8(Constants.RECORD)).putInt(recordSize + 2).putShort(recordComponentCount);\r\n        RecordComponentWriter recordComponentWriter = firstRecordComponent;\r\n        while (recordComponentWriter != null) {\r\n            recordComponentWriter.putRecordComponentInfo(result);\r\n            recordComponentWriter = (RecordComponentWriter) recordComponentWriter.delegate;\r\n        }\r\n    }\r\n    if (firstAttribute != null) {\r\n        firstAttribute.putAttributes(symbolTable, result);\r\n    }\r\n    // Third step: replace the ASM specific instructions, if any.\r\n    if (hasAsmInstructions) {\r\n        return replaceAsmInstructions(result.data, hasFrames);\r\n    } else {\r\n        return result.data;\r\n    }\r\n}",
    "comment": "\n   * Returns the content of the class file that was built by this ClassWriter.\n   *\n   * @return the binary content of the JVMS ClassFile structure that was built by this ClassWriter.\n   * @throws ClassTooLargeException if the constant pool of the class is too large.\n   * @throws MethodTooLargeException if the Code attribute of a method is too large.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#replaceAsmInstructions(byte[],boolean)",
    "entityType": "method",
    "code": "/**\r\n * Returns the equivalent of the given class file, with the ASM specific instructions replaced\r\n * with standard ones. This is done with a ClassReader -&gt; ClassWriter round trip.\r\n *\r\n * @param classFile a class file containing ASM specific instructions, generated by this\r\n *     ClassWriter.\r\n * @param hasFrames whether there is at least one stack map frames in 'classFile'.\r\n * @return an equivalent of 'classFile', with the ASM specific instructions replaced with standard\r\n *     ones.\r\n */\r\nprivate byte[] replaceAsmInstructions(final byte[] classFile, final boolean hasFrames) {\r\n    final Attribute[] attributes = getAttributePrototypes();\r\n    firstField = null;\r\n    lastField = null;\r\n    firstMethod = null;\r\n    lastMethod = null;\r\n    lastRuntimeVisibleAnnotation = null;\r\n    lastRuntimeInvisibleAnnotation = null;\r\n    lastRuntimeVisibleTypeAnnotation = null;\r\n    lastRuntimeInvisibleTypeAnnotation = null;\r\n    moduleWriter = null;\r\n    nestHostClassIndex = 0;\r\n    numberOfNestMemberClasses = 0;\r\n    nestMemberClasses = null;\r\n    numberOfPermittedSubclasses = 0;\r\n    permittedSubclasses = null;\r\n    firstRecordComponent = null;\r\n    lastRecordComponent = null;\r\n    firstAttribute = null;\r\n    compute = hasFrames ? MethodWriter.COMPUTE_INSERTED_FRAMES : MethodWriter.COMPUTE_NOTHING;\r\n    new ClassReader(classFile, 0, /* checkClassVersion= */\r\n    false).accept(this, attributes, (hasFrames ? ClassReader.EXPAND_FRAMES : 0) | ClassReader.EXPAND_ASM_INSNS);\r\n    return toByteArray();\r\n}",
    "comment": "\n   * Returns the equivalent of the given class file, with the ASM specific instructions replaced\n   * with standard ones. This is done with a ClassReader -&gt; ClassWriter round trip.\n   *\n   * @param classFile a class file containing ASM specific instructions, generated by this\n   *     ClassWriter.\n   * @param hasFrames whether there is at least one stack map frames in 'classFile'.\n   * @return an equivalent of 'classFile', with the ASM specific instructions replaced with standard\n   *     ones.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#getAttributePrototypes()",
    "entityType": "method",
    "code": "/**\r\n * Returns the prototypes of the attributes used by this class, its fields and its methods.\r\n *\r\n * @return the prototypes of the attributes used by this class, its fields and its methods.\r\n */\r\nprivate Attribute[] getAttributePrototypes() {\r\n    Attribute.Set attributePrototypes = new Attribute.Set();\r\n    attributePrototypes.addAttributes(firstAttribute);\r\n    FieldWriter fieldWriter = firstField;\r\n    while (fieldWriter != null) {\r\n        fieldWriter.collectAttributePrototypes(attributePrototypes);\r\n        fieldWriter = (FieldWriter) fieldWriter.fv;\r\n    }\r\n    MethodWriter methodWriter = firstMethod;\r\n    while (methodWriter != null) {\r\n        methodWriter.collectAttributePrototypes(attributePrototypes);\r\n        methodWriter = (MethodWriter) methodWriter.mv;\r\n    }\r\n    RecordComponentWriter recordComponentWriter = firstRecordComponent;\r\n    while (recordComponentWriter != null) {\r\n        recordComponentWriter.collectAttributePrototypes(attributePrototypes);\r\n        recordComponentWriter = (RecordComponentWriter) recordComponentWriter.delegate;\r\n    }\r\n    return attributePrototypes.toArray();\r\n}",
    "comment": "\n   * Returns the prototypes of the attributes used by this class, its fields and its methods.\n   *\n   * @return the prototypes of the attributes used by this class, its fields and its methods.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#newConst(Object)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Utility methods: constant pool management for Attribute sub classes\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Adds a number or string constant to the constant pool of the class being build. Does nothing if\r\n * the constant pool already contains a similar item. <i>This method is intended for {@link\r\n * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param value the value of the constant to be added to the constant pool. This parameter must be\r\n *     an {@link Integer}, a {@link Float}, a {@link Long}, a {@link Double} or a {@link String}.\r\n * @return the index of a new or already existing constant item with the given value.\r\n */\r\npublic int newConst(final Object value) {\r\n    return symbolTable.addConstant(value).index;\r\n}",
    "comment": "\n   * Adds a number or string constant to the constant pool of the class being build. Does nothing if\n   * the constant pool already contains a similar item. <i>This method is intended for {@link\n   * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param value the value of the constant to be added to the constant pool. This parameter must be\n   *     an {@link Integer}, a {@link Float}, a {@link Long}, a {@link Double} or a {@link String}.\n   * @return the index of a new or already existing constant item with the given value.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#newUTF8(String)",
    "entityType": "method",
    "code": "/**\r\n * Adds an UTF8 string to the constant pool of the class being build. Does nothing if the constant\r\n * pool already contains a similar item. <i>This method is intended for {@link Attribute} sub\r\n * classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param value the String value.\r\n * @return the index of a new or already existing UTF8 item.\r\n */\r\n// DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).\r\npublic int newUTF8(final String value) {\r\n    return symbolTable.addConstantUtf8(value);\r\n}",
    "comment": " DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility)."
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#newClass(String)",
    "entityType": "method",
    "code": "/**\r\n * Adds a class reference to the constant pool of the class being build. Does nothing if the\r\n * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}\r\n * sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param value the internal name of the class (see {@link Type#getInternalName()}).\r\n * @return the index of a new or already existing class reference item.\r\n */\r\npublic int newClass(final String value) {\r\n    return symbolTable.addConstantClass(value).index;\r\n}",
    "comment": "\n   * Adds a class reference to the constant pool of the class being build. Does nothing if the\n   * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}\n   * sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param value the internal name of the class (see {@link Type#getInternalName()}).\n   * @return the index of a new or already existing class reference item.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#newMethodType(String)",
    "entityType": "method",
    "code": "/**\r\n * Adds a method type reference to the constant pool of the class being build. Does nothing if the\r\n * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}\r\n * sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param methodDescriptor method descriptor of the method type.\r\n * @return the index of a new or already existing method type reference item.\r\n */\r\npublic int newMethodType(final String methodDescriptor) {\r\n    return symbolTable.addConstantMethodType(methodDescriptor).index;\r\n}",
    "comment": "\n   * Adds a method type reference to the constant pool of the class being build. Does nothing if the\n   * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}\n   * sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param methodDescriptor method descriptor of the method type.\n   * @return the index of a new or already existing method type reference item.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#newModule(String)",
    "entityType": "method",
    "code": "/**\r\n * Adds a module reference to the constant pool of the class being build. Does nothing if the\r\n * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}\r\n * sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param moduleName name of the module.\r\n * @return the index of a new or already existing module reference item.\r\n */\r\npublic int newModule(final String moduleName) {\r\n    return symbolTable.addConstantModule(moduleName).index;\r\n}",
    "comment": "\n   * Adds a module reference to the constant pool of the class being build. Does nothing if the\n   * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}\n   * sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param moduleName name of the module.\n   * @return the index of a new or already existing module reference item.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#newPackage(String)",
    "entityType": "method",
    "code": "/**\r\n * Adds a package reference to the constant pool of the class being build. Does nothing if the\r\n * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}\r\n * sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param packageName name of the package in its internal form.\r\n * @return the index of a new or already existing module reference item.\r\n */\r\npublic int newPackage(final String packageName) {\r\n    return symbolTable.addConstantPackage(packageName).index;\r\n}",
    "comment": "\n   * Adds a package reference to the constant pool of the class being build. Does nothing if the\n   * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}\n   * sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param packageName name of the package in its internal form.\n   * @return the index of a new or already existing module reference item.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#newHandle(int,String,String,String)",
    "entityType": "method",
    "code": "/**\r\n * Adds a handle to the constant pool of the class being build. Does nothing if the constant pool\r\n * already contains a similar item. <i>This method is intended for {@link Attribute} sub classes,\r\n * and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param tag the kind of this handle. Must be {@link Opcodes#H_GETFIELD}, {@link\r\n *     Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link\r\n *     Opcodes#H_INVOKEVIRTUAL}, {@link Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL},\r\n *     {@link Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\r\n * @param owner the internal name of the field or method owner class (see {@link\r\n *     Type#getInternalName()}).\r\n * @param name the name of the field or method.\r\n * @param descriptor the descriptor of the field or method.\r\n * @return the index of a new or already existing method type reference item.\r\n * @deprecated this method is superseded by {@link #newHandle(int, String, String, String,\r\n *     boolean)}.\r\n */\r\n@Deprecated\r\npublic int newHandle(final int tag, final String owner, final String name, final String descriptor) {\r\n    return newHandle(tag, owner, name, descriptor, tag == Opcodes.H_INVOKEINTERFACE);\r\n}",
    "comment": "\n   * Adds a handle to the constant pool of the class being build. Does nothing if the constant pool\n   * already contains a similar item. <i>This method is intended for {@link Attribute} sub classes,\n   * and is normally not needed by class generators or adapters.</i>\n   *\n   * @param tag the kind of this handle. Must be {@link Opcodes#H_GETFIELD}, {@link\n   *     Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link\n   *     Opcodes#H_INVOKEVIRTUAL}, {@link Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL},\n   *     {@link Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n   * @param owner the internal name of the field or method owner class (see {@link\n   *     Type#getInternalName()}).\n   * @param name the name of the field or method.\n   * @param descriptor the descriptor of the field or method.\n   * @return the index of a new or already existing method type reference item.\n   * @deprecated this method is superseded by {@link #newHandle(int, String, String, String,\n   *     boolean)}.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#newHandle(int,String,String,String,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Adds a handle to the constant pool of the class being build. Does nothing if the constant pool\r\n * already contains a similar item. <i>This method is intended for {@link Attribute} sub classes,\r\n * and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param tag the kind of this handle. Must be {@link Opcodes#H_GETFIELD}, {@link\r\n *     Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link\r\n *     Opcodes#H_INVOKEVIRTUAL}, {@link Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL},\r\n *     {@link Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\r\n * @param owner the internal name of the field or method owner class (see {@link\r\n *     Type#getInternalName()}).\r\n * @param name the name of the field or method.\r\n * @param descriptor the descriptor of the field or method.\r\n * @param isInterface true if the owner is an interface.\r\n * @return the index of a new or already existing method type reference item.\r\n */\r\npublic int newHandle(final int tag, final String owner, final String name, final String descriptor, final boolean isInterface) {\r\n    return symbolTable.addConstantMethodHandle(tag, owner, name, descriptor, isInterface).index;\r\n}",
    "comment": "\n   * Adds a handle to the constant pool of the class being build. Does nothing if the constant pool\n   * already contains a similar item. <i>This method is intended for {@link Attribute} sub classes,\n   * and is normally not needed by class generators or adapters.</i>\n   *\n   * @param tag the kind of this handle. Must be {@link Opcodes#H_GETFIELD}, {@link\n   *     Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link\n   *     Opcodes#H_INVOKEVIRTUAL}, {@link Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL},\n   *     {@link Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n   * @param owner the internal name of the field or method owner class (see {@link\n   *     Type#getInternalName()}).\n   * @param name the name of the field or method.\n   * @param descriptor the descriptor of the field or method.\n   * @param isInterface true if the owner is an interface.\n   * @return the index of a new or already existing method type reference item.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#newConstantDynamic(String,String,Handle,Object)",
    "entityType": "method",
    "code": "/**\r\n * Adds a dynamic constant reference to the constant pool of the class being build. Does nothing\r\n * if the constant pool already contains a similar item. <i>This method is intended for {@link\r\n * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param name name of the invoked method.\r\n * @param descriptor field descriptor of the constant type.\r\n * @param bootstrapMethodHandle the bootstrap method.\r\n * @param bootstrapMethodArguments the bootstrap method constant arguments.\r\n * @return the index of a new or already existing dynamic constant reference item.\r\n */\r\npublic int newConstantDynamic(final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\r\n    return symbolTable.addConstantDynamic(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments).index;\r\n}",
    "comment": "\n   * Adds a dynamic constant reference to the constant pool of the class being build. Does nothing\n   * if the constant pool already contains a similar item. <i>This method is intended for {@link\n   * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param name name of the invoked method.\n   * @param descriptor field descriptor of the constant type.\n   * @param bootstrapMethodHandle the bootstrap method.\n   * @param bootstrapMethodArguments the bootstrap method constant arguments.\n   * @return the index of a new or already existing dynamic constant reference item.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#newInvokeDynamic(String,String,Handle,Object)",
    "entityType": "method",
    "code": "/**\r\n * Adds an invokedynamic reference to the constant pool of the class being build. Does nothing if\r\n * the constant pool already contains a similar item. <i>This method is intended for {@link\r\n * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param name name of the invoked method.\r\n * @param descriptor descriptor of the invoke method.\r\n * @param bootstrapMethodHandle the bootstrap method.\r\n * @param bootstrapMethodArguments the bootstrap method constant arguments.\r\n * @return the index of a new or already existing invokedynamic reference item.\r\n */\r\npublic int newInvokeDynamic(final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\r\n    return symbolTable.addConstantInvokeDynamic(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments).index;\r\n}",
    "comment": "\n   * Adds an invokedynamic reference to the constant pool of the class being build. Does nothing if\n   * the constant pool already contains a similar item. <i>This method is intended for {@link\n   * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param name name of the invoked method.\n   * @param descriptor descriptor of the invoke method.\n   * @param bootstrapMethodHandle the bootstrap method.\n   * @param bootstrapMethodArguments the bootstrap method constant arguments.\n   * @return the index of a new or already existing invokedynamic reference item.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#newField(String,String,String)",
    "entityType": "method",
    "code": "/**\r\n * Adds a field reference to the constant pool of the class being build. Does nothing if the\r\n * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}\r\n * sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param owner the internal name of the field's owner class (see {@link Type#getInternalName()}).\r\n * @param name the field's name.\r\n * @param descriptor the field's descriptor.\r\n * @return the index of a new or already existing field reference item.\r\n */\r\npublic int newField(final String owner, final String name, final String descriptor) {\r\n    return symbolTable.addConstantFieldref(owner, name, descriptor).index;\r\n}",
    "comment": "\n   * Adds a field reference to the constant pool of the class being build. Does nothing if the\n   * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}\n   * sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param owner the internal name of the field's owner class (see {@link Type#getInternalName()}).\n   * @param name the field's name.\n   * @param descriptor the field's descriptor.\n   * @return the index of a new or already existing field reference item.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#newMethod(String,String,String,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Adds a method reference to the constant pool of the class being build. Does nothing if the\r\n * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}\r\n * sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param owner the internal name of the method's owner class (see {@link\r\n *     Type#getInternalName()}).\r\n * @param name the method's name.\r\n * @param descriptor the method's descriptor.\r\n * @param isInterface {@literal true} if {@code owner} is an interface.\r\n * @return the index of a new or already existing method reference item.\r\n */\r\npublic int newMethod(final String owner, final String name, final String descriptor, final boolean isInterface) {\r\n    return symbolTable.addConstantMethodref(owner, name, descriptor, isInterface).index;\r\n}",
    "comment": "\n   * Adds a method reference to the constant pool of the class being build. Does nothing if the\n   * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}\n   * sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param owner the internal name of the method's owner class (see {@link\n   *     Type#getInternalName()}).\n   * @param name the method's name.\n   * @param descriptor the method's descriptor.\n   * @param isInterface {@literal true} if {@code owner} is an interface.\n   * @return the index of a new or already existing method reference item.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#newNameType(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Adds a name and type to the constant pool of the class being build. Does nothing if the\r\n * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}\r\n * sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param name a name.\r\n * @param descriptor a type descriptor.\r\n * @return the index of a new or already existing name and type item.\r\n */\r\npublic int newNameType(final String name, final String descriptor) {\r\n    return symbolTable.addConstantNameAndType(name, descriptor);\r\n}",
    "comment": "\n   * Adds a name and type to the constant pool of the class being build. Does nothing if the\n   * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}\n   * sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param name a name.\n   * @param descriptor a type descriptor.\n   * @return the index of a new or already existing name and type item.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#setFlags(int)",
    "entityType": "method",
    "code": "/**\r\n * Changes the computation strategy of method properties like max stack size, max number of local\r\n * variables, and frames.\r\n *\r\n * <p><b>WARNING</b>: {@link #setFlags(int)} method changes the behavior of new method visitors\r\n * returned from {@link #visitMethod(int, String, String, String, String[])}. The behavior will be\r\n * changed only after the next method visitor is returned. All the previously returned method\r\n * visitors keep their previous behavior.\r\n *\r\n * @param flags option flags that can be used to modify the default behavior of this class. Must\r\n *     be zero or more of {@link #COMPUTE_MAXS} and {@link #COMPUTE_FRAMES}.\r\n */\r\npublic final void setFlags(final int flags) {\r\n    if ((flags & ClassWriter.COMPUTE_FRAMES) != 0) {\r\n        compute = MethodWriter.COMPUTE_ALL_FRAMES;\r\n    } else if ((flags & ClassWriter.COMPUTE_MAXS) != 0) {\r\n        compute = MethodWriter.COMPUTE_MAX_STACK_AND_LOCAL;\r\n    } else {\r\n        compute = MethodWriter.COMPUTE_NOTHING;\r\n    }\r\n}",
    "comment": "\n   * Changes the computation strategy of method properties like max stack size, max number of local\n   * variables, and frames.\n   *\n   * <p><b>WARNING</b>: {@link #setFlags(int)} method changes the behavior of new method visitors\n   * returned from {@link #visitMethod(int, String, String, String, String[])}. The behavior will be\n   * changed only after the next method visitor is returned. All the previously returned method\n   * visitors keep their previous behavior.\n   *\n   * @param flags option flags that can be used to modify the default behavior of this class. Must\n   *     be zero or more of {@link #COMPUTE_MAXS} and {@link #COMPUTE_FRAMES}.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#getCommonSuperClass(String,String)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Default method to compute common super classes when computing stack map frames\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the common super type of the two given types. The default implementation of this method\r\n * <i>loads</i> the two given classes and uses the java.lang.Class methods to find the common\r\n * super class. It can be overridden to compute this common super type in other ways, in\r\n * particular without actually loading any class, or to take into account the class that is\r\n * currently being generated by this ClassWriter, which can of course not be loaded since it is\r\n * under construction.\r\n *\r\n * @param type1 the internal name of a class (see {@link Type#getInternalName()}).\r\n * @param type2 the internal name of another class (see {@link Type#getInternalName()}).\r\n * @return the internal name of the common super class of the two given classes (see {@link\r\n *     Type#getInternalName()}).\r\n */\r\nprotected String getCommonSuperClass(final String type1, final String type2) {\r\n    ClassLoader classLoader = getClassLoader();\r\n    Class<?> class1;\r\n    try {\r\n        class1 = Class.forName(type1.replace('/', '.'), false, classLoader);\r\n    } catch (ClassNotFoundException e) {\r\n        throw new TypeNotPresentException(type1, e);\r\n    }\r\n    Class<?> class2;\r\n    try {\r\n        class2 = Class.forName(type2.replace('/', '.'), false, classLoader);\r\n    } catch (ClassNotFoundException e) {\r\n        throw new TypeNotPresentException(type2, e);\r\n    }\r\n    if (class1.isAssignableFrom(class2)) {\r\n        return type1;\r\n    }\r\n    if (class2.isAssignableFrom(class1)) {\r\n        return type2;\r\n    }\r\n    if (class1.isInterface() || class2.isInterface()) {\r\n        return \"java/lang/Object\";\r\n    } else {\r\n        do {\r\n            class1 = class1.getSuperclass();\r\n        } while (!class1.isAssignableFrom(class2));\r\n        return class1.getName().replace('.', '/');\r\n    }\r\n}",
    "comment": "\n   * Returns the common super type of the two given types. The default implementation of this method\n   * <i>loads</i> the two given classes and uses the java.lang.Class methods to find the common\n   * super class. It can be overridden to compute this common super type in other ways, in\n   * particular without actually loading any class, or to take into account the class that is\n   * currently being generated by this ClassWriter, which can of course not be loaded since it is\n   * under construction.\n   *\n   * @param type1 the internal name of a class (see {@link Type#getInternalName()}).\n   * @param type2 the internal name of another class (see {@link Type#getInternalName()}).\n   * @return the internal name of the common super class of the two given classes (see {@link\n   *     Type#getInternalName()}).\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassWriter#getClassLoader()",
    "entityType": "method",
    "code": "/**\r\n * Returns the {@link ClassLoader} to be used by the default implementation of {@link\r\n * #getCommonSuperClass(String, String)}, that of this {@link ClassWriter}'s runtime type by\r\n * default.\r\n *\r\n * @return ClassLoader\r\n */\r\nprotected ClassLoader getClassLoader() {\r\n    // SPRING PATCH: prefer thread context ClassLoader for application classes\r\n    ClassLoader classLoader = null;\r\n    try {\r\n        classLoader = Thread.currentThread().getContextClassLoader();\r\n    } catch (Throwable ex) {\r\n        // Cannot access thread context ClassLoader - falling back...\r\n    }\r\n    return (classLoader != null ? classLoader : getClass().getClassLoader());\r\n}",
    "comment": "\n   * Returns the {@link ClassLoader} to be used by the default implementation of {@link\n   * #getCommonSuperClass(String, String)}, that of this {@link ClassWriter}'s runtime type by\n   * default.\n   *\n   * @return ClassLoader\n   "
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandlerTests",
    "entityType": "class",
    "code": "private static final String COMPLEX_XML = \"<?xml version='1.0' encoding='UTF-8'?>\" + \"<!DOCTYPE beans PUBLIC \\\"-//SPRING//DTD BEAN 2.0//EN\\\" \\\"https://www.springframework.org/dtd/spring-beans-2.0.dtd\\\">\" + \"<?pi content?><root xmlns='namespace'><prefix:child xmlns:prefix='namespace2' prefix:attr='value'>characters <![CDATA[cdata]]></prefix:child>\" + \"<!-- comment -->\" + \"</root>\";\nprivate static final String SIMPLE_XML = \"<?xml version='1.0' encoding='UTF-8'?>\" + \"<?pi content?><root xmlns='namespace'><prefix:child xmlns:prefix='namespace2' prefix:attr='value'>content</prefix:child>\" + \"</root>\";\nprivate static final Predicate<Node> nodeFilter = (n -> n.getNodeType() != Node.COMMENT_NODE && n.getNodeType() != Node.DOCUMENT_TYPE_NODE && n.getNodeType() != Node.PROCESSING_INSTRUCTION_NODE);\nprivate XMLReader xmlReader;\n@BeforeEach\r\nvoid createXMLReader() throws Exception {\r\n    SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\r\n    saxParserFactory.setNamespaceAware(true);\r\n    SAXParser saxParser = saxParserFactory.newSAXParser();\r\n    xmlReader = saxParser.getXMLReader();\r\n    xmlReader.setEntityResolver((publicId, systemId) -> new InputSource(new StringReader(\"\")));\r\n}\n@Test\r\nvoid noNamespacePrefixes() throws Exception {\r\n    StringWriter stringWriter = new StringWriter();\r\n    AbstractStaxHandler handler = createStaxHandler(new StreamResult(stringWriter));\r\n    xmlReader.setContentHandler(handler);\r\n    xmlReader.setProperty(\"http://xml.org/sax/properties/lexical-handler\", handler);\r\n    xmlReader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\r\n    xmlReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", false);\r\n    xmlReader.parse(new InputSource(new StringReader(COMPLEX_XML)));\r\n    assertThat(XmlContent.from(stringWriter)).isSimilarTo(COMPLEX_XML, nodeFilter);\r\n}\n@Test\r\nvoid namespacePrefixes() throws Exception {\r\n    StringWriter stringWriter = new StringWriter();\r\n    AbstractStaxHandler handler = createStaxHandler(new StreamResult(stringWriter));\r\n    xmlReader.setContentHandler(handler);\r\n    xmlReader.setProperty(\"http://xml.org/sax/properties/lexical-handler\", handler);\r\n    xmlReader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\r\n    xmlReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", true);\r\n    xmlReader.parse(new InputSource(new StringReader(COMPLEX_XML)));\r\n    assertThat(XmlContent.from(stringWriter)).isSimilarTo(COMPLEX_XML, nodeFilter);\r\n}\n@Test\r\nvoid noNamespacePrefixesDom() throws Exception {\r\n    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\r\n    documentBuilderFactory.setNamespaceAware(true);\r\n    DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\r\n    Document expected = documentBuilder.parse(new InputSource(new StringReader(SIMPLE_XML)));\r\n    Document result = documentBuilder.newDocument();\r\n    AbstractStaxHandler handler = createStaxHandler(new DOMResult(result));\r\n    xmlReader.setContentHandler(handler);\r\n    xmlReader.setProperty(\"http://xml.org/sax/properties/lexical-handler\", handler);\r\n    xmlReader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\r\n    xmlReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", false);\r\n    xmlReader.parse(new InputSource(new StringReader(SIMPLE_XML)));\r\n    assertThat(XmlContent.of(result)).isSimilarTo(expected, nodeFilter);\r\n}\n@Test\r\nvoid namespacePrefixesDom() throws Exception {\r\n    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\r\n    documentBuilderFactory.setNamespaceAware(true);\r\n    DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\r\n    Document expected = documentBuilder.parse(new InputSource(new StringReader(SIMPLE_XML)));\r\n    Document result = documentBuilder.newDocument();\r\n    AbstractStaxHandler handler = createStaxHandler(new DOMResult(result));\r\n    xmlReader.setContentHandler(handler);\r\n    xmlReader.setProperty(\"http://xml.org/sax/properties/lexical-handler\", handler);\r\n    xmlReader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\r\n    xmlReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", true);\r\n    xmlReader.parse(new InputSource(new StringReader(SIMPLE_XML)));\r\n    assertThat(XmlContent.of(result)).isSimilarTo(expected, nodeFilter);\r\n}\nprotected abstract AbstractStaxHandler createStaxHandler(Result result) throws XMLStreamException;",
    "comment": "\n * @author Arjen Poutsma\n * @author Sam Brannen\n "
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandlerTests#createXMLReader()",
    "entityType": "method",
    "code": "@BeforeEach\r\nvoid createXMLReader() throws Exception {\r\n    SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\r\n    saxParserFactory.setNamespaceAware(true);\r\n    SAXParser saxParser = saxParserFactory.newSAXParser();\r\n    xmlReader = saxParser.getXMLReader();\r\n    xmlReader.setEntityResolver((publicId, systemId) -> new InputSource(new StringReader(\"\")));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandlerTests#noNamespacePrefixes()",
    "entityType": "method",
    "code": "@Test\r\nvoid noNamespacePrefixes() throws Exception {\r\n    StringWriter stringWriter = new StringWriter();\r\n    AbstractStaxHandler handler = createStaxHandler(new StreamResult(stringWriter));\r\n    xmlReader.setContentHandler(handler);\r\n    xmlReader.setProperty(\"http://xml.org/sax/properties/lexical-handler\", handler);\r\n    xmlReader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\r\n    xmlReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", false);\r\n    xmlReader.parse(new InputSource(new StringReader(COMPLEX_XML)));\r\n    assertThat(XmlContent.from(stringWriter)).isSimilarTo(COMPLEX_XML, nodeFilter);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandlerTests#namespacePrefixes()",
    "entityType": "method",
    "code": "@Test\r\nvoid namespacePrefixes() throws Exception {\r\n    StringWriter stringWriter = new StringWriter();\r\n    AbstractStaxHandler handler = createStaxHandler(new StreamResult(stringWriter));\r\n    xmlReader.setContentHandler(handler);\r\n    xmlReader.setProperty(\"http://xml.org/sax/properties/lexical-handler\", handler);\r\n    xmlReader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\r\n    xmlReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", true);\r\n    xmlReader.parse(new InputSource(new StringReader(COMPLEX_XML)));\r\n    assertThat(XmlContent.from(stringWriter)).isSimilarTo(COMPLEX_XML, nodeFilter);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandlerTests#noNamespacePrefixesDom()",
    "entityType": "method",
    "code": "@Test\r\nvoid noNamespacePrefixesDom() throws Exception {\r\n    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\r\n    documentBuilderFactory.setNamespaceAware(true);\r\n    DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\r\n    Document expected = documentBuilder.parse(new InputSource(new StringReader(SIMPLE_XML)));\r\n    Document result = documentBuilder.newDocument();\r\n    AbstractStaxHandler handler = createStaxHandler(new DOMResult(result));\r\n    xmlReader.setContentHandler(handler);\r\n    xmlReader.setProperty(\"http://xml.org/sax/properties/lexical-handler\", handler);\r\n    xmlReader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\r\n    xmlReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", false);\r\n    xmlReader.parse(new InputSource(new StringReader(SIMPLE_XML)));\r\n    assertThat(XmlContent.of(result)).isSimilarTo(expected, nodeFilter);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandlerTests#namespacePrefixesDom()",
    "entityType": "method",
    "code": "@Test\r\nvoid namespacePrefixesDom() throws Exception {\r\n    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\r\n    documentBuilderFactory.setNamespaceAware(true);\r\n    DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\r\n    Document expected = documentBuilder.parse(new InputSource(new StringReader(SIMPLE_XML)));\r\n    Document result = documentBuilder.newDocument();\r\n    AbstractStaxHandler handler = createStaxHandler(new DOMResult(result));\r\n    xmlReader.setContentHandler(handler);\r\n    xmlReader.setProperty(\"http://xml.org/sax/properties/lexical-handler\", handler);\r\n    xmlReader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\r\n    xmlReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", true);\r\n    xmlReader.parse(new InputSource(new StringReader(SIMPLE_XML)));\r\n    assertThat(XmlContent.of(result)).isSimilarTo(expected, nodeFilter);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandlerTests#createStaxHandler(Result)",
    "entityType": "method",
    "code": "protected abstract AbstractStaxHandler createStaxHandler(Result result) throws XMLStreamException;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ConstantDynamic",
    "entityType": "class",
    "code": "/**\r\n * The constant name (can be arbitrary).\r\n */\r\nprivate final String name;\n/**\r\n * The constant type (must be a field descriptor).\r\n */\r\nprivate final String descriptor;\n/**\r\n * The bootstrap method to use to compute the constant value at runtime.\r\n */\r\nprivate final Handle bootstrapMethod;\n/**\r\n * The arguments to pass to the bootstrap method, in order to compute the constant value at\r\n * runtime.\r\n */\r\nprivate final Object[] bootstrapMethodArguments;\n/**\r\n * Constructs a new {@link ConstantDynamic}.\r\n *\r\n * @param name the constant name (can be arbitrary).\r\n * @param descriptor the constant type (must be a field descriptor).\r\n * @param bootstrapMethod the bootstrap method to use to compute the constant value at runtime.\r\n * @param bootstrapMethodArguments the arguments to pass to the bootstrap method, in order to\r\n *     compute the constant value at runtime.\r\n */\r\npublic ConstantDynamic(final String name, final String descriptor, final Handle bootstrapMethod, final Object... bootstrapMethodArguments) {\r\n    this.name = name;\r\n    this.descriptor = descriptor;\r\n    this.bootstrapMethod = bootstrapMethod;\r\n    this.bootstrapMethodArguments = bootstrapMethodArguments;\r\n}\n/**\r\n * Returns the name of this constant.\r\n *\r\n * @return the name of this constant.\r\n */\r\npublic String getName() {\r\n    return name;\r\n}\n/**\r\n * Returns the type of this constant.\r\n *\r\n * @return the type of this constant, as a field descriptor.\r\n */\r\npublic String getDescriptor() {\r\n    return descriptor;\r\n}\n/**\r\n * Returns the bootstrap method used to compute the value of this constant.\r\n *\r\n * @return the bootstrap method used to compute the value of this constant.\r\n */\r\npublic Handle getBootstrapMethod() {\r\n    return bootstrapMethod;\r\n}\n/**\r\n * Returns the number of arguments passed to the bootstrap method, in order to compute the value\r\n * of this constant.\r\n *\r\n * @return the number of arguments passed to the bootstrap method, in order to compute the value\r\n *     of this constant.\r\n */\r\npublic int getBootstrapMethodArgumentCount() {\r\n    return bootstrapMethodArguments.length;\r\n}\n/**\r\n * Returns an argument passed to the bootstrap method, in order to compute the value of this\r\n * constant.\r\n *\r\n * @param index an argument index, between 0 and {@link #getBootstrapMethodArgumentCount()}\r\n *     (exclusive).\r\n * @return the argument passed to the bootstrap method, with the given index.\r\n */\r\npublic Object getBootstrapMethodArgument(final int index) {\r\n    return bootstrapMethodArguments[index];\r\n}\n/**\r\n * Returns the arguments to pass to the bootstrap method, in order to compute the value of this\r\n * constant. WARNING: this array must not be modified, and must not be returned to the user.\r\n *\r\n * @return the arguments to pass to the bootstrap method, in order to compute the value of this\r\n *     constant.\r\n */\r\nObject[] getBootstrapMethodArgumentsUnsafe() {\r\n    return bootstrapMethodArguments;\r\n}\n/**\r\n * Returns the size of this constant.\r\n *\r\n * @return the size of this constant, i.e., 2 for {@code long} and {@code double}, 1 otherwise.\r\n */\r\npublic int getSize() {\r\n    char firstCharOfDescriptor = descriptor.charAt(0);\r\n    return (firstCharOfDescriptor == 'J' || firstCharOfDescriptor == 'D') ? 2 : 1;\r\n}\n@Override\r\npublic boolean equals(final Object object) {\r\n    if (object == this) {\r\n        return true;\r\n    }\r\n    if (!(object instanceof ConstantDynamic)) {\r\n        return false;\r\n    }\r\n    ConstantDynamic constantDynamic = (ConstantDynamic) object;\r\n    return name.equals(constantDynamic.name) && descriptor.equals(constantDynamic.descriptor) && bootstrapMethod.equals(constantDynamic.bootstrapMethod) && Arrays.equals(bootstrapMethodArguments, constantDynamic.bootstrapMethodArguments);\r\n}\n@Override\r\npublic int hashCode() {\r\n    return name.hashCode() ^ Integer.rotateLeft(descriptor.hashCode(), 8) ^ Integer.rotateLeft(bootstrapMethod.hashCode(), 16) ^ Integer.rotateLeft(Arrays.hashCode(bootstrapMethodArguments), 24);\r\n}\n@Override\r\npublic String toString() {\r\n    return name + \" : \" + descriptor + ' ' + bootstrapMethod + ' ' + Arrays.toString(bootstrapMethodArguments);\r\n}",
    "comment": "\n * A constant whose value is computed at runtime, with a bootstrap method.\n *\n * @author Remi Forax\n "
  },
  {
    "entityId": "org.springframework.asm.ConstantDynamic#getName()",
    "entityType": "method",
    "code": "/**\r\n * Returns the name of this constant.\r\n *\r\n * @return the name of this constant.\r\n */\r\npublic String getName() {\r\n    return name;\r\n}",
    "comment": "\n   * Returns the name of this constant.\n   *\n   * @return the name of this constant.\n   "
  },
  {
    "entityId": "org.springframework.asm.ConstantDynamic#getDescriptor()",
    "entityType": "method",
    "code": "/**\r\n * Returns the type of this constant.\r\n *\r\n * @return the type of this constant, as a field descriptor.\r\n */\r\npublic String getDescriptor() {\r\n    return descriptor;\r\n}",
    "comment": "\n   * Returns the type of this constant.\n   *\n   * @return the type of this constant, as a field descriptor.\n   "
  },
  {
    "entityId": "org.springframework.asm.ConstantDynamic#getBootstrapMethod()",
    "entityType": "method",
    "code": "/**\r\n * Returns the bootstrap method used to compute the value of this constant.\r\n *\r\n * @return the bootstrap method used to compute the value of this constant.\r\n */\r\npublic Handle getBootstrapMethod() {\r\n    return bootstrapMethod;\r\n}",
    "comment": "\n   * Returns the bootstrap method used to compute the value of this constant.\n   *\n   * @return the bootstrap method used to compute the value of this constant.\n   "
  },
  {
    "entityId": "org.springframework.asm.ConstantDynamic#getBootstrapMethodArgumentCount()",
    "entityType": "method",
    "code": "/**\r\n * Returns the number of arguments passed to the bootstrap method, in order to compute the value\r\n * of this constant.\r\n *\r\n * @return the number of arguments passed to the bootstrap method, in order to compute the value\r\n *     of this constant.\r\n */\r\npublic int getBootstrapMethodArgumentCount() {\r\n    return bootstrapMethodArguments.length;\r\n}",
    "comment": "\n   * Returns the number of arguments passed to the bootstrap method, in order to compute the value\n   * of this constant.\n   *\n   * @return the number of arguments passed to the bootstrap method, in order to compute the value\n   *     of this constant.\n   "
  },
  {
    "entityId": "org.springframework.asm.ConstantDynamic#getBootstrapMethodArgument(int)",
    "entityType": "method",
    "code": "/**\r\n * Returns an argument passed to the bootstrap method, in order to compute the value of this\r\n * constant.\r\n *\r\n * @param index an argument index, between 0 and {@link #getBootstrapMethodArgumentCount()}\r\n *     (exclusive).\r\n * @return the argument passed to the bootstrap method, with the given index.\r\n */\r\npublic Object getBootstrapMethodArgument(final int index) {\r\n    return bootstrapMethodArguments[index];\r\n}",
    "comment": "\n   * Returns an argument passed to the bootstrap method, in order to compute the value of this\n   * constant.\n   *\n   * @param index an argument index, between 0 and {@link #getBootstrapMethodArgumentCount()}\n   *     (exclusive).\n   * @return the argument passed to the bootstrap method, with the given index.\n   "
  },
  {
    "entityId": "org.springframework.asm.ConstantDynamic#getBootstrapMethodArgumentsUnsafe()",
    "entityType": "method",
    "code": "/**\r\n * Returns the arguments to pass to the bootstrap method, in order to compute the value of this\r\n * constant. WARNING: this array must not be modified, and must not be returned to the user.\r\n *\r\n * @return the arguments to pass to the bootstrap method, in order to compute the value of this\r\n *     constant.\r\n */\r\nObject[] getBootstrapMethodArgumentsUnsafe() {\r\n    return bootstrapMethodArguments;\r\n}",
    "comment": "\n   * Returns the arguments to pass to the bootstrap method, in order to compute the value of this\n   * constant. WARNING: this array must not be modified, and must not be returned to the user.\n   *\n   * @return the arguments to pass to the bootstrap method, in order to compute the value of this\n   *     constant.\n   "
  },
  {
    "entityId": "org.springframework.asm.ConstantDynamic#getSize()",
    "entityType": "method",
    "code": "/**\r\n * Returns the size of this constant.\r\n *\r\n * @return the size of this constant, i.e., 2 for {@code long} and {@code double}, 1 otherwise.\r\n */\r\npublic int getSize() {\r\n    char firstCharOfDescriptor = descriptor.charAt(0);\r\n    return (firstCharOfDescriptor == 'J' || firstCharOfDescriptor == 'D') ? 2 : 1;\r\n}",
    "comment": "\n   * Returns the size of this constant.\n   *\n   * @return the size of this constant, i.e., 2 for {@code long} and {@code double}, 1 otherwise.\n   "
  },
  {
    "entityId": "org.springframework.asm.ConstantDynamic#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(final Object object) {\r\n    if (object == this) {\r\n        return true;\r\n    }\r\n    if (!(object instanceof ConstantDynamic)) {\r\n        return false;\r\n    }\r\n    ConstantDynamic constantDynamic = (ConstantDynamic) object;\r\n    return name.equals(constantDynamic.name) && descriptor.equals(constantDynamic.descriptor) && bootstrapMethod.equals(constantDynamic.bootstrapMethod) && Arrays.equals(bootstrapMethodArguments, constantDynamic.bootstrapMethodArguments);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ConstantDynamic#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return name.hashCode() ^ Integer.rotateLeft(descriptor.hashCode(), 8) ^ Integer.rotateLeft(bootstrapMethod.hashCode(), 16) ^ Integer.rotateLeft(Arrays.hashCode(bootstrapMethodArguments), 24);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ConstantDynamic#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return name + \" : \" + descriptor + ' ' + bootstrapMethod + ' ' + Arrays.toString(bootstrapMethodArguments);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxXMLReaderTests",
    "entityType": "class",
    "code": "protected static XMLInputFactory inputFactory;\nprivate XMLReader standardReader;\nprivate ContentHandler standardContentHandler;\n@BeforeEach\r\nvoid setUp() throws Exception {\r\n    inputFactory = XMLInputFactory.newInstance();\r\n    SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\r\n    saxParserFactory.setNamespaceAware(true);\r\n    SAXParser saxParser = saxParserFactory.newSAXParser();\r\n    standardReader = saxParser.getXMLReader();\r\n    standardContentHandler = mockContentHandler();\r\n    standardReader.setContentHandler(standardContentHandler);\r\n}\n@Test\r\nvoid contentHandlerNamespacesNoPrefixes() throws Exception {\r\n    standardReader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\r\n    standardReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", false);\r\n    standardReader.parse(new InputSource(createTestInputStream()));\r\n    AbstractStaxXMLReader staxXmlReader = createStaxXmlReader(createTestInputStream());\r\n    ContentHandler contentHandler = mockContentHandler();\r\n    staxXmlReader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\r\n    staxXmlReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", false);\r\n    staxXmlReader.setContentHandler(contentHandler);\r\n    staxXmlReader.parse(new InputSource());\r\n    verifyIdenticalInvocations(standardContentHandler, contentHandler);\r\n}\n@Test\r\nvoid contentHandlerNamespacesPrefixes() throws Exception {\r\n    standardReader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\r\n    standardReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", true);\r\n    standardReader.parse(new InputSource(createTestInputStream()));\r\n    AbstractStaxXMLReader staxXmlReader = createStaxXmlReader(createTestInputStream());\r\n    ContentHandler contentHandler = mockContentHandler();\r\n    staxXmlReader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\r\n    staxXmlReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", true);\r\n    staxXmlReader.setContentHandler(contentHandler);\r\n    staxXmlReader.parse(new InputSource());\r\n    verifyIdenticalInvocations(standardContentHandler, contentHandler);\r\n}\n@Test\r\nvoid contentHandlerNoNamespacesPrefixes() throws Exception {\r\n    standardReader.setFeature(\"http://xml.org/sax/features/namespaces\", false);\r\n    standardReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", true);\r\n    standardReader.parse(new InputSource(createTestInputStream()));\r\n    AbstractStaxXMLReader staxXmlReader = createStaxXmlReader(createTestInputStream());\r\n    ContentHandler contentHandler = mockContentHandler();\r\n    staxXmlReader.setFeature(\"http://xml.org/sax/features/namespaces\", false);\r\n    staxXmlReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", true);\r\n    staxXmlReader.setContentHandler(contentHandler);\r\n    staxXmlReader.parse(new InputSource());\r\n    verifyIdenticalInvocations(standardContentHandler, contentHandler);\r\n}\n@Test\r\nvoid whitespace() throws Exception {\r\n    String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><test><node1> </node1><node2> Some text </node2></test>\";\r\n    Transformer transformer = TransformerFactory.newInstance().newTransformer();\r\n    AbstractStaxXMLReader staxXmlReader = createStaxXmlReader(new ByteArrayInputStream(xml.getBytes(StandardCharsets.UTF_8)));\r\n    SAXSource source = new SAXSource(staxXmlReader, new InputSource());\r\n    DOMResult result = new DOMResult();\r\n    transformer.transform(source, result);\r\n    Node node1 = result.getNode().getFirstChild().getFirstChild();\r\n    assertThat(node1.getTextContent()).isEqualTo(\" \");\r\n    assertThat(node1.getNextSibling().getTextContent()).isEqualTo(\" Some text \");\r\n}\n@Test\r\nvoid lexicalHandler() throws Exception {\r\n    Resource testLexicalHandlerXml = new ClassPathResource(\"testLexicalHandler.xml\", getClass());\r\n    LexicalHandler expectedLexicalHandler = mockLexicalHandler();\r\n    standardReader.setContentHandler(null);\r\n    standardReader.setProperty(\"http://xml.org/sax/properties/lexical-handler\", expectedLexicalHandler);\r\n    standardReader.parse(new InputSource(testLexicalHandlerXml.getInputStream()));\r\n    inputFactory.setProperty(\"javax.xml.stream.isCoalescing\", Boolean.FALSE);\r\n    inputFactory.setProperty(\"http://java.sun.com/xml/stream/properties/report-cdata-event\", Boolean.TRUE);\r\n    inputFactory.setProperty(\"javax.xml.stream.isReplacingEntityReferences\", Boolean.FALSE);\r\n    inputFactory.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", Boolean.FALSE);\r\n    LexicalHandler actualLexicalHandler = mockLexicalHandler();\r\n    willAnswer(invocation -> invocation.getArguments()[0] = \"element\").given(actualLexicalHandler).startDTD(anyString(), anyString(), anyString());\r\n    AbstractStaxXMLReader staxXmlReader = createStaxXmlReader(testLexicalHandlerXml.getInputStream());\r\n    staxXmlReader.setProperty(\"http://xml.org/sax/properties/lexical-handler\", actualLexicalHandler);\r\n    staxXmlReader.parse(new InputSource());\r\n    // TODO: broken comparison since Mockito 2.2 upgrade\r\n    // verifyIdenticalInvocations(expectedLexicalHandler, actualLexicalHandler);\r\n}\nprivate LexicalHandler mockLexicalHandler() throws Exception {\r\n    LexicalHandler lexicalHandler = mock();\r\n    willAnswer(new CopyCharsAnswer()).given(lexicalHandler).comment(any(char[].class), anyInt(), anyInt());\r\n    return lexicalHandler;\r\n}\nprivate InputStream createTestInputStream() {\r\n    return getClass().getResourceAsStream(\"testContentHandler.xml\");\r\n}\nprotected final ContentHandler mockContentHandler() throws Exception {\r\n    ContentHandler contentHandler = mock();\r\n    willAnswer(new CopyCharsAnswer()).given(contentHandler).characters(any(char[].class), anyInt(), anyInt());\r\n    willAnswer(new CopyCharsAnswer()).given(contentHandler).ignorableWhitespace(any(char[].class), anyInt(), anyInt());\r\n    willAnswer(invocation -> {\r\n        invocation.getArguments()[3] = new AttributesImpl((Attributes) invocation.getArguments()[3]);\r\n        return null;\r\n    }).given(contentHandler).startElement(anyString(), anyString(), anyString(), any(Attributes.class));\r\n    return contentHandler;\r\n}\nprotected <T> void verifyIdenticalInvocations(T expected, T actual) {\r\n    MockitoUtils.verifySameInvocations(expected, actual, new SkipLocatorArgumentsAdapter(), new CharArrayToStringAdapter(), new PartialAttributesAdapter());\r\n}\nprotected abstract AbstractStaxXMLReader createStaxXmlReader(InputStream inputStream) throws XMLStreamException;\nprivate static class SkipLocatorArgumentsAdapter implements InvocationArgumentsAdapter {\r\n\r\n    @Override\r\n    public Object[] adaptArguments(Object[] arguments) {\r\n        for (int i = 0; i < arguments.length; i++) {\r\n            if (arguments[i] instanceof Locator) {\r\n                arguments[i] = null;\r\n            }\r\n        }\r\n        return arguments;\r\n    }\r\n}\nprivate static class CharArrayToStringAdapter implements InvocationArgumentsAdapter {\r\n\r\n    @Override\r\n    public Object[] adaptArguments(Object[] arguments) {\r\n        if (arguments.length == 3 && arguments[0] instanceof char[] && arguments[1] instanceof Integer && arguments[2] instanceof Integer) {\r\n            return new Object[] { new String((char[]) arguments[0], (Integer) arguments[1], (Integer) arguments[2]) };\r\n        }\r\n        return arguments;\r\n    }\r\n}\nprivate static class PartialAttributesAdapter implements InvocationArgumentsAdapter {\r\n\r\n    @Override\r\n    public Object[] adaptArguments(Object[] arguments) {\r\n        for (int i = 0; i < arguments.length; i++) {\r\n            if (arguments[i] instanceof Attributes) {\r\n                arguments[i] = new PartialAttributes((Attributes) arguments[i]);\r\n            }\r\n        }\r\n        return arguments;\r\n    }\r\n}\nprivate static class CopyCharsAnswer implements Answer<Object> {\r\n\r\n    @Override\r\n    public Object answer(InvocationOnMock invocation) {\r\n        char[] chars = (char[]) invocation.getArguments()[0];\r\n        char[] copy = new char[chars.length];\r\n        System.arraycopy(chars, 0, copy, 0, chars.length);\r\n        invocation.getArguments()[0] = copy;\r\n        return null;\r\n    }\r\n}\nprivate static class PartialAttributes {\r\n\r\n    private final Attributes attributes;\r\n\r\n    public PartialAttributes(Attributes attributes) {\r\n        this.attributes = attributes;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(@Nullable Object obj) {\r\n        Attributes other = ((PartialAttributes) obj).attributes;\r\n        if (this.attributes.getLength() != other.getLength()) {\r\n            return false;\r\n        }\r\n        for (int i = 0; i < other.getLength(); i++) {\r\n            boolean found = false;\r\n            for (int j = 0; j < attributes.getLength(); j++) {\r\n                if (other.getURI(i).equals(attributes.getURI(j)) && other.getQName(i).equals(attributes.getQName(j)) && other.getType(i).equals(attributes.getType(j)) && other.getValue(i).equals(attributes.getValue(j))) {\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!found) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        return 1;\r\n    }\r\n}",
    "comment": "\n * @author Arjen Poutsma\n "
  }
]