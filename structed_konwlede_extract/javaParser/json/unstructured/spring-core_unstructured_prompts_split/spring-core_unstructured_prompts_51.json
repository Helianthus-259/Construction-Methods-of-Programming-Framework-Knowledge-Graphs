[
  {
    "entityId": "org.springframework.core.codec.NettyByteBufDecoder#canDecode(ResolvableType,MimeType)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType) {\r\n    return (ByteBuf.class.isAssignableFrom(elementType.toClass()) && super.canDecode(elementType, mimeType));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.NettyByteBufDecoder#decode(DataBuffer,ResolvableType,MimeType,Map<String,Object>)",
    "entityType": "method",
    "code": "@Override\r\npublic ByteBuf decode(DataBuffer dataBuffer, ResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(Hints.getLogPrefix(hints) + \"Read \" + dataBuffer.readableByteCount() + \" bytes\");\r\n    }\r\n    if (dataBuffer instanceof NettyDataBuffer nettyDataBuffer) {\r\n        return nettyDataBuffer.getNativeBuffer();\r\n    }\r\n    ByteBuf byteBuf;\r\n    byte[] bytes = new byte[dataBuffer.readableByteCount()];\r\n    dataBuffer.read(bytes);\r\n    byteBuf = Unpooled.wrappedBuffer(bytes);\r\n    DataBufferUtils.release(dataBuffer);\r\n    return byteBuf;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.NettyByteBufEncoder",
    "entityType": "class",
    "code": "public NettyByteBufEncoder() {\r\n    super(MimeTypeUtils.ALL);\r\n}\n@Override\r\npublic boolean canEncode(ResolvableType type, @Nullable MimeType mimeType) {\r\n    Class<?> clazz = type.toClass();\r\n    return super.canEncode(type, mimeType) && ByteBuf.class.isAssignableFrom(clazz);\r\n}\n@Override\r\npublic Flux<DataBuffer> encode(Publisher<? extends ByteBuf> inputStream, DataBufferFactory bufferFactory, ResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    return Flux.from(inputStream).map(byteBuffer -> encodeValue(byteBuffer, bufferFactory, elementType, mimeType, hints));\r\n}\n@Override\r\npublic DataBuffer encodeValue(ByteBuf byteBuf, DataBufferFactory bufferFactory, ResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    if (logger.isDebugEnabled() && !Hints.isLoggingSuppressed(hints)) {\r\n        String logPrefix = Hints.getLogPrefix(hints);\r\n        logger.debug(logPrefix + \"Writing \" + byteBuf.readableBytes() + \" bytes\");\r\n    }\r\n    if (bufferFactory instanceof NettyDataBufferFactory nettyDataBufferFactory) {\r\n        return nettyDataBufferFactory.wrap(byteBuf);\r\n    }\r\n    byte[] bytes = new byte[byteBuf.readableBytes()];\r\n    byteBuf.readBytes(bytes);\r\n    byteBuf.release();\r\n    return bufferFactory.wrap(bytes);\r\n}",
    "comment": "\n * Encoder for {@link ByteBuf ByteBufs}.\n *\n * @author Vladislav Kisel\n * @since 5.3\n "
  },
  {
    "entityId": "org.springframework.core.codec.NettyByteBufEncoder#canEncode(ResolvableType,MimeType)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean canEncode(ResolvableType type, @Nullable MimeType mimeType) {\r\n    Class<?> clazz = type.toClass();\r\n    return super.canEncode(type, mimeType) && ByteBuf.class.isAssignableFrom(clazz);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.NettyByteBufEncoder#encode(Publisher<? extends ByteBuf>,DataBufferFactory,ResolvableType,MimeType,Map<String,Object>)",
    "entityType": "method",
    "code": "@Override\r\npublic Flux<DataBuffer> encode(Publisher<? extends ByteBuf> inputStream, DataBufferFactory bufferFactory, ResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    return Flux.from(inputStream).map(byteBuffer -> encodeValue(byteBuffer, bufferFactory, elementType, mimeType, hints));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.NettyByteBufEncoder#encodeValue(ByteBuf,DataBufferFactory,ResolvableType,MimeType,Map<String,Object>)",
    "entityType": "method",
    "code": "@Override\r\npublic DataBuffer encodeValue(ByteBuf byteBuf, DataBufferFactory bufferFactory, ResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    if (logger.isDebugEnabled() && !Hints.isLoggingSuppressed(hints)) {\r\n        String logPrefix = Hints.getLogPrefix(hints);\r\n        logger.debug(logPrefix + \"Writing \" + byteBuf.readableBytes() + \" bytes\");\r\n    }\r\n    if (bufferFactory instanceof NettyDataBufferFactory nettyDataBufferFactory) {\r\n        return nettyDataBufferFactory.wrap(byteBuf);\r\n    }\r\n    byte[] bytes = new byte[byteBuf.readableBytes()];\r\n    byteBuf.readBytes(bytes);\r\n    byteBuf.release();\r\n    return bufferFactory.wrap(bytes);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.ResourceDecoder",
    "entityType": "class",
    "code": "/**\r\n * Name of hint with a filename for the resource(for example, from \"Content-Disposition\" HTTP header).\r\n */\r\npublic static final String FILENAME_HINT = ResourceDecoder.class.getName() + \".filename\";\npublic ResourceDecoder() {\r\n    super(MimeTypeUtils.ALL);\r\n}\n@Override\r\npublic boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType) {\r\n    return (Resource.class.isAssignableFrom(elementType.toClass()) && super.canDecode(elementType, mimeType));\r\n}\n@Override\r\npublic Flux<Resource> decode(Publisher<DataBuffer> inputStream, ResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    return Flux.from(decodeToMono(inputStream, elementType, mimeType, hints));\r\n}\n@Override\r\npublic Resource decode(DataBuffer dataBuffer, ResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    byte[] bytes = new byte[dataBuffer.readableByteCount()];\r\n    dataBuffer.read(bytes);\r\n    DataBufferUtils.release(dataBuffer);\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(Hints.getLogPrefix(hints) + \"Read \" + bytes.length + \" bytes\");\r\n    }\r\n    Class<?> clazz = elementType.toClass();\r\n    String filename = (hints != null ? (String) hints.get(FILENAME_HINT) : null);\r\n    if (clazz == InputStreamResource.class) {\r\n        return new InputStreamResource(new ByteArrayInputStream(bytes)) {\r\n\r\n            @Override\r\n            @Nullable\r\n            public String getFilename() {\r\n                return filename;\r\n            }\r\n\r\n            @Override\r\n            public long contentLength() {\r\n                return bytes.length;\r\n            }\r\n        };\r\n    } else if (Resource.class.isAssignableFrom(clazz)) {\r\n        return new ByteArrayResource(bytes) {\r\n\r\n            @Override\r\n            @Nullable\r\n            public String getFilename() {\r\n                return filename;\r\n            }\r\n        };\r\n    } else {\r\n        throw new IllegalStateException(\"Unsupported resource class: \" + clazz);\r\n    }\r\n}",
    "comment": "\n * Decoder for {@link Resource Resources}.\n *\n * @author Arjen Poutsma\n * @author Rossen Stoyanchev\n * @since 5.0\n "
  },
  {
    "entityId": "org.springframework.core.codec.ResourceDecoder#canDecode(ResolvableType,MimeType)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType) {\r\n    return (Resource.class.isAssignableFrom(elementType.toClass()) && super.canDecode(elementType, mimeType));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.ResourceDecoder#decode(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
    "entityType": "method",
    "code": "@Override\r\npublic Flux<Resource> decode(Publisher<DataBuffer> inputStream, ResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    return Flux.from(decodeToMono(inputStream, elementType, mimeType, hints));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.ResourceDecoder#decode(DataBuffer,ResolvableType,MimeType,Map<String,Object>)",
    "entityType": "method",
    "code": "@Override\r\npublic Resource decode(DataBuffer dataBuffer, ResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    byte[] bytes = new byte[dataBuffer.readableByteCount()];\r\n    dataBuffer.read(bytes);\r\n    DataBufferUtils.release(dataBuffer);\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(Hints.getLogPrefix(hints) + \"Read \" + bytes.length + \" bytes\");\r\n    }\r\n    Class<?> clazz = elementType.toClass();\r\n    String filename = (hints != null ? (String) hints.get(FILENAME_HINT) : null);\r\n    if (clazz == InputStreamResource.class) {\r\n        return new InputStreamResource(new ByteArrayInputStream(bytes)) {\r\n\r\n            @Override\r\n            @Nullable\r\n            public String getFilename() {\r\n                return filename;\r\n            }\r\n\r\n            @Override\r\n            public long contentLength() {\r\n                return bytes.length;\r\n            }\r\n        };\r\n    } else if (Resource.class.isAssignableFrom(clazz)) {\r\n        return new ByteArrayResource(bytes) {\r\n\r\n            @Override\r\n            @Nullable\r\n            public String getFilename() {\r\n                return filename;\r\n            }\r\n        };\r\n    } else {\r\n        throw new IllegalStateException(\"Unsupported resource class: \" + clazz);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.ResourceEncoder",
    "entityType": "class",
    "code": "/**\r\n * The default buffer size used by the encoder.\r\n */\r\npublic static final int DEFAULT_BUFFER_SIZE = StreamUtils.BUFFER_SIZE;\nprivate final int bufferSize;\npublic ResourceEncoder() {\r\n    this(DEFAULT_BUFFER_SIZE);\r\n}\npublic ResourceEncoder(int bufferSize) {\r\n    super(MimeTypeUtils.APPLICATION_OCTET_STREAM, MimeTypeUtils.ALL);\r\n    Assert.isTrue(bufferSize > 0, \"'bufferSize' must be larger than 0\");\r\n    this.bufferSize = bufferSize;\r\n}\n@Override\r\npublic boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {\r\n    Class<?> clazz = elementType.toClass();\r\n    return (super.canEncode(elementType, mimeType) && Resource.class.isAssignableFrom(clazz));\r\n}\n@Override\r\nprotected Flux<DataBuffer> encode(Resource resource, DataBufferFactory bufferFactory, ResolvableType type, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    if (logger.isDebugEnabled() && !Hints.isLoggingSuppressed(hints)) {\r\n        String logPrefix = Hints.getLogPrefix(hints);\r\n        logger.debug(logPrefix + \"Writing [\" + resource + \"]\");\r\n    }\r\n    return DataBufferUtils.read(resource, bufferFactory, this.bufferSize);\r\n}",
    "comment": "\n * Encoder for {@link Resource Resources}.\n *\n * @author Arjen Poutsma\n * @since 5.0\n "
  },
  {
    "entityId": "org.springframework.core.codec.ResourceEncoder#canEncode(ResolvableType,MimeType)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {\r\n    Class<?> clazz = elementType.toClass();\r\n    return (super.canEncode(elementType, mimeType) && Resource.class.isAssignableFrom(clazz));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.ResourceEncoder#encode(Resource,DataBufferFactory,ResolvableType,MimeType,Map<String,Object>)",
    "entityType": "method",
    "code": "@Override\r\nprotected Flux<DataBuffer> encode(Resource resource, DataBufferFactory bufferFactory, ResolvableType type, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    if (logger.isDebugEnabled() && !Hints.isLoggingSuppressed(hints)) {\r\n        String logPrefix = Hints.getLogPrefix(hints);\r\n        logger.debug(logPrefix + \"Writing [\" + resource + \"]\");\r\n    }\r\n    return DataBufferUtils.read(resource, bufferFactory, this.bufferSize);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.ResourceRegionEncoder",
    "entityType": "class",
    "code": "/**\r\n * The default buffer size used by the encoder.\r\n */\r\npublic static final int DEFAULT_BUFFER_SIZE = StreamUtils.BUFFER_SIZE;\n/**\r\n * The hint key that contains the boundary string.\r\n */\r\npublic static final String BOUNDARY_STRING_HINT = ResourceRegionEncoder.class.getName() + \".boundaryString\";\nprivate final int bufferSize;\npublic ResourceRegionEncoder() {\r\n    this(DEFAULT_BUFFER_SIZE);\r\n}\npublic ResourceRegionEncoder(int bufferSize) {\r\n    super(MimeTypeUtils.APPLICATION_OCTET_STREAM, MimeTypeUtils.ALL);\r\n    Assert.isTrue(bufferSize > 0, \"'bufferSize' must be larger than 0\");\r\n    this.bufferSize = bufferSize;\r\n}\n@Override\r\npublic boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {\r\n    return super.canEncode(elementType, mimeType) && ResourceRegion.class.isAssignableFrom(elementType.toClass());\r\n}\n@Override\r\npublic Flux<DataBuffer> encode(Publisher<? extends ResourceRegion> input, DataBufferFactory bufferFactory, ResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    Assert.notNull(input, \"'inputStream' must not be null\");\r\n    Assert.notNull(bufferFactory, \"'bufferFactory' must not be null\");\r\n    Assert.notNull(elementType, \"'elementType' must not be null\");\r\n    if (input instanceof Mono) {\r\n        return Mono.from(input).flatMapMany(region -> {\r\n            if (!region.getResource().isReadable()) {\r\n                return Flux.error(new EncodingException(\"Resource \" + region.getResource() + \" is not readable\"));\r\n            }\r\n            return writeResourceRegion(region, bufferFactory, hints);\r\n        });\r\n    } else {\r\n        final String boundaryString = Hints.getRequiredHint(hints, BOUNDARY_STRING_HINT);\r\n        byte[] startBoundary = toAsciiBytes(\"\\r\\n--\" + boundaryString + \"\\r\\n\");\r\n        byte[] contentType = mimeType != null ? toAsciiBytes(\"Content-Type: \" + mimeType + \"\\r\\n\") : new byte[0];\r\n        return Flux.from(input).concatMap(region -> {\r\n            if (!region.getResource().isReadable()) {\r\n                return Flux.error(new EncodingException(\"Resource \" + region.getResource() + \" is not readable\"));\r\n            }\r\n            Flux<DataBuffer> prefix = Flux.just(bufferFactory.wrap(startBoundary), bufferFactory.wrap(contentType), // only wrapping, no allocation\r\n            bufferFactory.wrap(getContentRangeHeader(region)));\r\n            return prefix.concatWith(writeResourceRegion(region, bufferFactory, hints));\r\n        }).concatWithValues(getRegionSuffix(bufferFactory, boundaryString));\r\n    }\r\n    // No doOnDiscard (no caching after DataBufferUtils#read)\r\n}\nprivate Flux<DataBuffer> writeResourceRegion(ResourceRegion region, DataBufferFactory bufferFactory, @Nullable Map<String, Object> hints) {\r\n    Resource resource = region.getResource();\r\n    long position = region.getPosition();\r\n    long count = region.getCount();\r\n    if (logger.isDebugEnabled() && !Hints.isLoggingSuppressed(hints)) {\r\n        logger.debug(Hints.getLogPrefix(hints) + \"Writing region \" + position + \"-\" + (position + count) + \" of [\" + resource + \"]\");\r\n    }\r\n    Flux<DataBuffer> in = DataBufferUtils.read(resource, position, bufferFactory, this.bufferSize);\r\n    if (logger.isDebugEnabled()) {\r\n        in = in.doOnNext(buffer -> Hints.touchDataBuffer(buffer, hints, logger));\r\n    }\r\n    return DataBufferUtils.takeUntilByteCount(in, count);\r\n}\nprivate DataBuffer getRegionSuffix(DataBufferFactory bufferFactory, String boundaryString) {\r\n    byte[] endBoundary = toAsciiBytes(\"\\r\\n--\" + boundaryString + \"--\");\r\n    return bufferFactory.wrap(endBoundary);\r\n}\nprivate byte[] toAsciiBytes(String in) {\r\n    return in.getBytes(StandardCharsets.US_ASCII);\r\n}\nprivate byte[] getContentRangeHeader(ResourceRegion region) {\r\n    long start = region.getPosition();\r\n    long end = start + region.getCount() - 1;\r\n    OptionalLong contentLength = contentLength(region.getResource());\r\n    if (contentLength.isPresent()) {\r\n        long length = contentLength.getAsLong();\r\n        return toAsciiBytes(\"Content-Range: bytes \" + start + '-' + end + '/' + length + \"\\r\\n\\r\\n\");\r\n    } else {\r\n        return toAsciiBytes(\"Content-Range: bytes \" + start + '-' + end + \"\\r\\n\\r\\n\");\r\n    }\r\n}\n/**\r\n * Determine, if possible, the contentLength of the given resource without reading it.\r\n * @param resource the resource instance\r\n * @return the contentLength of the resource\r\n */\r\nprivate OptionalLong contentLength(Resource resource) {\r\n    // Don't try to determine contentLength on InputStreamResource - cannot be read afterwards...\r\n    // Note: custom InputStreamResource subclasses could provide a pre-calculated content length!\r\n    if (InputStreamResource.class != resource.getClass()) {\r\n        try {\r\n            return OptionalLong.of(resource.contentLength());\r\n        } catch (IOException ignored) ;\r\n    }\r\n    return OptionalLong.empty();\r\n}",
    "comment": "\n * Encoder for {@link ResourceRegion ResourceRegions}.\n *\n * @author Brian Clozel\n * @since 5.0\n "
  },
  {
    "entityId": "org.springframework.core.codec.ResourceRegionEncoder#canEncode(ResolvableType,MimeType)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {\r\n    return super.canEncode(elementType, mimeType) && ResourceRegion.class.isAssignableFrom(elementType.toClass());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.ResourceRegionEncoder#encode(Publisher<? extends ResourceRegion>,DataBufferFactory,ResolvableType,MimeType,Map<String,Object>)",
    "entityType": "method",
    "code": "@Override\r\npublic Flux<DataBuffer> encode(Publisher<? extends ResourceRegion> input, DataBufferFactory bufferFactory, ResolvableType elementType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    Assert.notNull(input, \"'inputStream' must not be null\");\r\n    Assert.notNull(bufferFactory, \"'bufferFactory' must not be null\");\r\n    Assert.notNull(elementType, \"'elementType' must not be null\");\r\n    if (input instanceof Mono) {\r\n        return Mono.from(input).flatMapMany(region -> {\r\n            if (!region.getResource().isReadable()) {\r\n                return Flux.error(new EncodingException(\"Resource \" + region.getResource() + \" is not readable\"));\r\n            }\r\n            return writeResourceRegion(region, bufferFactory, hints);\r\n        });\r\n    } else {\r\n        final String boundaryString = Hints.getRequiredHint(hints, BOUNDARY_STRING_HINT);\r\n        byte[] startBoundary = toAsciiBytes(\"\\r\\n--\" + boundaryString + \"\\r\\n\");\r\n        byte[] contentType = mimeType != null ? toAsciiBytes(\"Content-Type: \" + mimeType + \"\\r\\n\") : new byte[0];\r\n        return Flux.from(input).concatMap(region -> {\r\n            if (!region.getResource().isReadable()) {\r\n                return Flux.error(new EncodingException(\"Resource \" + region.getResource() + \" is not readable\"));\r\n            }\r\n            Flux<DataBuffer> prefix = Flux.just(bufferFactory.wrap(startBoundary), bufferFactory.wrap(contentType), // only wrapping, no allocation\r\n            bufferFactory.wrap(getContentRangeHeader(region)));\r\n            return prefix.concatWith(writeResourceRegion(region, bufferFactory, hints));\r\n        }).concatWithValues(getRegionSuffix(bufferFactory, boundaryString));\r\n    }\r\n    // No doOnDiscard (no caching after DataBufferUtils#read)\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.ResourceRegionEncoder#writeResourceRegion(ResourceRegion,DataBufferFactory,Map<String,Object>)",
    "entityType": "method",
    "code": "private Flux<DataBuffer> writeResourceRegion(ResourceRegion region, DataBufferFactory bufferFactory, @Nullable Map<String, Object> hints) {\r\n    Resource resource = region.getResource();\r\n    long position = region.getPosition();\r\n    long count = region.getCount();\r\n    if (logger.isDebugEnabled() && !Hints.isLoggingSuppressed(hints)) {\r\n        logger.debug(Hints.getLogPrefix(hints) + \"Writing region \" + position + \"-\" + (position + count) + \" of [\" + resource + \"]\");\r\n    }\r\n    Flux<DataBuffer> in = DataBufferUtils.read(resource, position, bufferFactory, this.bufferSize);\r\n    if (logger.isDebugEnabled()) {\r\n        in = in.doOnNext(buffer -> Hints.touchDataBuffer(buffer, hints, logger));\r\n    }\r\n    return DataBufferUtils.takeUntilByteCount(in, count);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.ResourceRegionEncoder#getRegionSuffix(DataBufferFactory,String)",
    "entityType": "method",
    "code": "private DataBuffer getRegionSuffix(DataBufferFactory bufferFactory, String boundaryString) {\r\n    byte[] endBoundary = toAsciiBytes(\"\\r\\n--\" + boundaryString + \"--\");\r\n    return bufferFactory.wrap(endBoundary);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.ResourceRegionEncoder#toAsciiBytes(String)",
    "entityType": "method",
    "code": "private byte[] toAsciiBytes(String in) {\r\n    return in.getBytes(StandardCharsets.US_ASCII);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.ResourceRegionEncoder#getContentRangeHeader(ResourceRegion)",
    "entityType": "method",
    "code": "private byte[] getContentRangeHeader(ResourceRegion region) {\r\n    long start = region.getPosition();\r\n    long end = start + region.getCount() - 1;\r\n    OptionalLong contentLength = contentLength(region.getResource());\r\n    if (contentLength.isPresent()) {\r\n        long length = contentLength.getAsLong();\r\n        return toAsciiBytes(\"Content-Range: bytes \" + start + '-' + end + '/' + length + \"\\r\\n\\r\\n\");\r\n    } else {\r\n        return toAsciiBytes(\"Content-Range: bytes \" + start + '-' + end + \"\\r\\n\\r\\n\");\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.ResourceRegionEncoder#contentLength(Resource)",
    "entityType": "method",
    "code": "/**\r\n * Determine, if possible, the contentLength of the given resource without reading it.\r\n * @param resource the resource instance\r\n * @return the contentLength of the resource\r\n */\r\nprivate OptionalLong contentLength(Resource resource) {\r\n    // Don't try to determine contentLength on InputStreamResource - cannot be read afterwards...\r\n    // Note: custom InputStreamResource subclasses could provide a pre-calculated content length!\r\n    if (InputStreamResource.class != resource.getClass()) {\r\n        try {\r\n            return OptionalLong.of(resource.contentLength());\r\n        } catch (IOException ignored) ;\r\n    }\r\n    return OptionalLong.empty();\r\n}",
    "comment": "\n\t * Determine, if possible, the contentLength of the given resource without reading it.\n\t * @param resource the resource instance\n\t * @return the contentLength of the resource\n\t "
  },
  {
    "entityId": "org.springframework.core.codec.StringDecoder",
    "entityType": "class",
    "code": "private StringDecoder(List<String> delimiters, boolean stripDelimiter, MimeType... mimeTypes) {\r\n    super(delimiters, stripDelimiter, mimeTypes);\r\n}\n@Override\r\npublic boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType) {\r\n    return (elementType.resolve() == String.class && super.canDecode(elementType, mimeType));\r\n}\n@Override\r\nprotected String decodeInternal(DataBuffer dataBuffer, Charset charset) {\r\n    return dataBuffer.toString(charset);\r\n}\n/**\r\n * Create a {@code StringDecoder} for {@code \"text/plain\"}.\r\n */\r\npublic static StringDecoder textPlainOnly() {\r\n    return textPlainOnly(DEFAULT_DELIMITERS, true);\r\n}\n/**\r\n * Create a {@code StringDecoder} for {@code \"text/plain\"}.\r\n * @param delimiters delimiter strings to use to split the input stream\r\n * @param stripDelimiter whether to remove delimiters from the resulting\r\n * input strings\r\n */\r\npublic static StringDecoder textPlainOnly(List<String> delimiters, boolean stripDelimiter) {\r\n    return new StringDecoder(delimiters, stripDelimiter, new MimeType(\"text\", \"plain\", DEFAULT_CHARSET));\r\n}\n/**\r\n * Create a {@code StringDecoder} that supports all MIME types.\r\n */\r\npublic static StringDecoder allMimeTypes() {\r\n    return allMimeTypes(DEFAULT_DELIMITERS, true);\r\n}\n/**\r\n * Create a {@code StringDecoder} that supports all MIME types.\r\n * @param delimiters delimiter strings to use to split the input stream\r\n * @param stripDelimiter whether to remove delimiters from the resulting\r\n * input strings\r\n */\r\npublic static StringDecoder allMimeTypes(List<String> delimiters, boolean stripDelimiter) {\r\n    return new StringDecoder(delimiters, stripDelimiter, new MimeType(\"text\", \"plain\", DEFAULT_CHARSET), MimeTypeUtils.ALL);\r\n}",
    "comment": "\n * Decode from a data buffer stream to a {@code String} stream, either splitting\n * or aggregating incoming data chunks to realign along newlines delimiters\n * and produce a stream of strings. This is useful for streaming but is also\n * necessary to ensure that multi-byte characters can be decoded correctly,\n * avoiding split-character issues. The default delimiters used by default are\n * {@code \\n} and {@code \\r\\n} but that can be customized.\n *\n * @author Sebastien Deleuze\n * @author Brian Clozel\n * @author Arjen Poutsma\n * @author Mark Paluch\n * @since 5.0\n * @see CharSequenceEncoder\n "
  },
  {
    "entityId": "org.springframework.core.codec.StringDecoder#canDecode(ResolvableType,MimeType)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType) {\r\n    return (elementType.resolve() == String.class && super.canDecode(elementType, mimeType));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.StringDecoder#decodeInternal(DataBuffer,Charset)",
    "entityType": "method",
    "code": "@Override\r\nprotected String decodeInternal(DataBuffer dataBuffer, Charset charset) {\r\n    return dataBuffer.toString(charset);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.codec.StringDecoder#textPlainOnly()",
    "entityType": "method",
    "code": "/**\r\n * Create a {@code StringDecoder} for {@code \"text/plain\"}.\r\n */\r\npublic static StringDecoder textPlainOnly() {\r\n    return textPlainOnly(DEFAULT_DELIMITERS, true);\r\n}",
    "comment": "\n\t * Create a {@code StringDecoder} for {@code \"text/plain\"}.\n\t "
  },
  {
    "entityId": "org.springframework.core.codec.StringDecoder#textPlainOnly(List<String>,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Create a {@code StringDecoder} for {@code \"text/plain\"}.\r\n * @param delimiters delimiter strings to use to split the input stream\r\n * @param stripDelimiter whether to remove delimiters from the resulting\r\n * input strings\r\n */\r\npublic static StringDecoder textPlainOnly(List<String> delimiters, boolean stripDelimiter) {\r\n    return new StringDecoder(delimiters, stripDelimiter, new MimeType(\"text\", \"plain\", DEFAULT_CHARSET));\r\n}",
    "comment": "\n\t * Create a {@code StringDecoder} for {@code \"text/plain\"}.\n\t * @param delimiters delimiter strings to use to split the input stream\n\t * @param stripDelimiter whether to remove delimiters from the resulting\n\t * input strings\n\t "
  },
  {
    "entityId": "org.springframework.core.codec.StringDecoder#allMimeTypes()",
    "entityType": "method",
    "code": "/**\r\n * Create a {@code StringDecoder} that supports all MIME types.\r\n */\r\npublic static StringDecoder allMimeTypes() {\r\n    return allMimeTypes(DEFAULT_DELIMITERS, true);\r\n}",
    "comment": "\n\t * Create a {@code StringDecoder} that supports all MIME types.\n\t "
  },
  {
    "entityId": "org.springframework.core.codec.StringDecoder#allMimeTypes(List<String>,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Create a {@code StringDecoder} that supports all MIME types.\r\n * @param delimiters delimiter strings to use to split the input stream\r\n * @param stripDelimiter whether to remove delimiters from the resulting\r\n * input strings\r\n */\r\npublic static StringDecoder allMimeTypes(List<String> delimiters, boolean stripDelimiter) {\r\n    return new StringDecoder(delimiters, stripDelimiter, new MimeType(\"text\", \"plain\", DEFAULT_CHARSET), MimeTypeUtils.ALL);\r\n}",
    "comment": "\n\t * Create a {@code StringDecoder} that supports all MIME types.\n\t * @param delimiters delimiter strings to use to split the input stream\n\t * @param stripDelimiter whether to remove delimiters from the resulting\n\t * input strings\n\t "
  },
  {
    "entityId": "org.springframework.core.CollectionFactory",
    "entityType": "class",
    "code": "private static final Set<Class<?>> approximableCollectionTypes = Set.of(// Standard collection interfaces\r\nCollection.class, List.class, Set.class, SortedSet.class, NavigableSet.class, // Common concrete collection classes\r\nArrayList.class, LinkedList.class, HashSet.class, LinkedHashSet.class, TreeSet.class, EnumSet.class);\nprivate static final Set<Class<?>> approximableMapTypes = Set.of(// Standard map interfaces\r\nMap.class, MultiValueMap.class, SortedMap.class, NavigableMap.class, // Common concrete map classes\r\nHashMap.class, LinkedHashMap.class, LinkedMultiValueMap.class, TreeMap.class, EnumMap.class);\nprivate CollectionFactory() {\r\n}\n/**\r\n * Determine whether the given collection type is an <em>approximable</em> type,\r\n * i.e. a type that {@link #createApproximateCollection} can approximate.\r\n * @param collectionType the collection type to check\r\n * @return {@code true} if the type is <em>approximable</em>\r\n */\r\npublic static boolean isApproximableCollectionType(@Nullable Class<?> collectionType) {\r\n    return (collectionType != null && (approximableCollectionTypes.contains(collectionType) || collectionType.getName().equals(\"java.util.SequencedSet\") || collectionType.getName().equals(\"java.util.SequencedCollection\")));\r\n}\n/**\r\n * Create the most approximate collection for the given collection.\r\n * <p><strong>Warning</strong>: Since the parameterized type {@code E} is\r\n * not bound to the type of elements contained in the supplied\r\n * {@code collection}, type safety cannot be guaranteed if the supplied\r\n * {@code collection} is an {@link EnumSet}. In such scenarios, the caller\r\n * is responsible for ensuring that the element type for the supplied\r\n * {@code collection} is an enum type matching type {@code E}. As an\r\n * alternative, the caller may wish to treat the return value as a raw\r\n * collection or collection of {@link Object}.\r\n * @param collection the original collection object, potentially {@code null}\r\n * @param capacity the initial capacity\r\n * @return a new, empty collection instance\r\n * @see #isApproximableCollectionType\r\n * @see java.util.LinkedList\r\n * @see java.util.ArrayList\r\n * @see java.util.EnumSet\r\n * @see java.util.TreeSet\r\n * @see java.util.LinkedHashSet\r\n */\r\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\r\npublic static <E> Collection<E> createApproximateCollection(@Nullable Object collection, int capacity) {\r\n    if (collection instanceof EnumSet enumSet) {\r\n        Collection<E> copy = EnumSet.copyOf(enumSet);\r\n        copy.clear();\r\n        return copy;\r\n    } else if (collection instanceof SortedSet sortedSet) {\r\n        return new TreeSet<>(sortedSet.comparator());\r\n    } else if (collection instanceof LinkedList) {\r\n        return new LinkedList<>();\r\n    } else if (collection instanceof List) {\r\n        return new ArrayList<>(capacity);\r\n    } else {\r\n        return new LinkedHashSet<>(capacity);\r\n    }\r\n}\n/**\r\n * Create the most appropriate collection for the given collection type.\r\n * <p>Delegates to {@link #createCollection(Class, Class, int)} with a\r\n * {@code null} element type.\r\n * @param collectionType the desired type of the target collection (never {@code null})\r\n * @param capacity the initial capacity\r\n * @return a new collection instance\r\n * @throws IllegalArgumentException if the supplied {@code collectionType}\r\n * is {@code null} or of type {@link EnumSet}\r\n */\r\npublic static <E> Collection<E> createCollection(Class<?> collectionType, int capacity) {\r\n    return createCollection(collectionType, null, capacity);\r\n}\n/**\r\n * Create the most appropriate collection for the given collection type.\r\n * <p><strong>Warning</strong>: Since the parameterized type {@code E} is\r\n * not bound to the supplied {@code elementType}, type safety cannot be\r\n * guaranteed if the desired {@code collectionType} is {@link EnumSet}.\r\n * In such scenarios, the caller is responsible for ensuring that the\r\n * supplied {@code elementType} is an enum type matching type {@code E}.\r\n * As an alternative, the caller may wish to treat the return value as a\r\n * raw collection or collection of {@link Object}.\r\n * @param collectionType the desired type of the target collection (never {@code null})\r\n * @param elementType the collection's element type, or {@code null} if unknown\r\n * (note: only relevant for {@link EnumSet} creation)\r\n * @param capacity the initial capacity\r\n * @return a new collection instance\r\n * @throws IllegalArgumentException if the supplied {@code collectionType} is\r\n * {@code null}; or if the desired {@code collectionType} is {@link EnumSet} and\r\n * the supplied {@code elementType} is not a subtype of {@link Enum}\r\n * @since 4.1.3\r\n * @see java.util.LinkedHashSet\r\n * @see java.util.ArrayList\r\n * @see java.util.TreeSet\r\n * @see java.util.EnumSet\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic static <E> Collection<E> createCollection(Class<?> collectionType, @Nullable Class<?> elementType, int capacity) {\r\n    Assert.notNull(collectionType, \"Collection type must not be null\");\r\n    if (LinkedHashSet.class == collectionType || Set.class == collectionType || Collection.class == collectionType || collectionType.getName().equals(\"java.util.SequencedSet\") || collectionType.getName().equals(\"java.util.SequencedCollection\")) {\r\n        return new LinkedHashSet<>(capacity);\r\n    } else if (ArrayList.class == collectionType || List.class == collectionType) {\r\n        return new ArrayList<>(capacity);\r\n    } else if (LinkedList.class == collectionType) {\r\n        return new LinkedList<>();\r\n    } else if (TreeSet.class == collectionType || NavigableSet.class == collectionType || SortedSet.class == collectionType) {\r\n        return new TreeSet<>();\r\n    } else if (EnumSet.class.isAssignableFrom(collectionType)) {\r\n        Assert.notNull(elementType, \"Cannot create EnumSet for unknown element type\");\r\n        return EnumSet.noneOf(asEnumType(elementType));\r\n    } else if (HashSet.class == collectionType) {\r\n        return new HashSet<>(capacity);\r\n    } else {\r\n        if (collectionType.isInterface() || !Collection.class.isAssignableFrom(collectionType)) {\r\n            throw new IllegalArgumentException(\"Unsupported Collection type: \" + collectionType.getName());\r\n        }\r\n        try {\r\n            return (Collection<E>) ReflectionUtils.accessibleConstructor(collectionType).newInstance();\r\n        } catch (Throwable ex) {\r\n            throw new IllegalArgumentException(\"Could not instantiate Collection type: \" + collectionType.getName(), ex);\r\n        }\r\n    }\r\n}\n/**\r\n * Determine whether the given map type is an <em>approximable</em> type,\r\n * i.e. a type that {@link #createApproximateMap} can approximate.\r\n * @param mapType the map type to check\r\n * @return {@code true} if the type is <em>approximable</em>\r\n */\r\npublic static boolean isApproximableMapType(@Nullable Class<?> mapType) {\r\n    return (mapType != null && (approximableMapTypes.contains(mapType) || mapType.getName().equals(\"java.util.SequencedMap\")));\r\n}\n/**\r\n * Create the most approximate map for the given map.\r\n * <p><strong>Warning</strong>: Since the parameterized type {@code K} is\r\n * not bound to the type of keys contained in the supplied {@code map},\r\n * type safety cannot be guaranteed if the supplied {@code map} is an\r\n * {@link EnumMap}. In such scenarios, the caller is responsible for\r\n * ensuring that the key type in the supplied {@code map} is an enum type\r\n * matching type {@code K}. As an alternative, the caller may wish to\r\n * treat the return value as a raw map or map keyed by {@link Object}.\r\n * @param map the original map object, potentially {@code null}\r\n * @param capacity the initial capacity\r\n * @return a new, empty map instance\r\n * @see #isApproximableMapType\r\n * @see java.util.EnumMap\r\n * @see java.util.TreeMap\r\n * @see java.util.LinkedHashMap\r\n */\r\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\r\npublic static <K, V> Map<K, V> createApproximateMap(@Nullable Object map, int capacity) {\r\n    if (map instanceof EnumMap enumMap) {\r\n        EnumMap copy = new EnumMap(enumMap);\r\n        copy.clear();\r\n        return copy;\r\n    } else if (map instanceof SortedMap sortedMap) {\r\n        return new TreeMap<>(sortedMap.comparator());\r\n    } else if (map instanceof MultiValueMap) {\r\n        return new LinkedMultiValueMap(capacity);\r\n    } else {\r\n        return new LinkedHashMap<>(capacity);\r\n    }\r\n}\n/**\r\n * Create the most appropriate map for the given map type.\r\n * <p>Delegates to {@link #createMap(Class, Class, int)} with a\r\n * {@code null} key type.\r\n * @param mapType the desired type of the target map\r\n * @param capacity the initial capacity\r\n * @return a new map instance\r\n * @throws IllegalArgumentException if the supplied {@code mapType} is\r\n * {@code null} or of type {@link EnumMap}\r\n */\r\npublic static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity) {\r\n    return createMap(mapType, null, capacity);\r\n}\n/**\r\n * Create the most appropriate map for the given map type.\r\n * <p><strong>Warning</strong>: Since the parameterized type {@code K}\r\n * is not bound to the supplied {@code keyType}, type safety cannot be\r\n * guaranteed if the desired {@code mapType} is {@link EnumMap}. In such\r\n * scenarios, the caller is responsible for ensuring that the {@code keyType}\r\n * is an enum type matching type {@code K}. As an alternative, the caller\r\n * may wish to treat the return value as a raw map or map keyed by\r\n * {@link Object}. Similarly, type safety cannot be enforced if the\r\n * desired {@code mapType} is {@link MultiValueMap}.\r\n * @param mapType the desired type of the target map (never {@code null})\r\n * @param keyType the map's key type, or {@code null} if unknown\r\n * (note: only relevant for {@link EnumMap} creation)\r\n * @param capacity the initial capacity\r\n * @return a new map instance\r\n * @throws IllegalArgumentException if the supplied {@code mapType} is\r\n * {@code null}; or if the desired {@code mapType} is {@link EnumMap} and\r\n * the supplied {@code keyType} is not a subtype of {@link Enum}\r\n * @since 4.1.3\r\n * @see java.util.LinkedHashMap\r\n * @see java.util.TreeMap\r\n * @see org.springframework.util.LinkedMultiValueMap\r\n * @see java.util.EnumMap\r\n */\r\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\r\npublic static <K, V> Map<K, V> createMap(Class<?> mapType, @Nullable Class<?> keyType, int capacity) {\r\n    Assert.notNull(mapType, \"Map type must not be null\");\r\n    if (LinkedHashMap.class == mapType || Map.class == mapType || mapType.getName().equals(\"java.util.SequencedMap\")) {\r\n        return new LinkedHashMap<>(capacity);\r\n    } else if (LinkedMultiValueMap.class == mapType || MultiValueMap.class == mapType) {\r\n        return new LinkedMultiValueMap();\r\n    } else if (TreeMap.class == mapType || SortedMap.class == mapType || NavigableMap.class == mapType) {\r\n        return new TreeMap<>();\r\n    } else if (EnumMap.class == mapType) {\r\n        Assert.notNull(keyType, \"Cannot create EnumMap for unknown key type\");\r\n        return new EnumMap(asEnumType(keyType));\r\n    } else if (HashMap.class == mapType) {\r\n        return new HashMap<>(capacity);\r\n    } else {\r\n        if (mapType.isInterface() || !Map.class.isAssignableFrom(mapType)) {\r\n            throw new IllegalArgumentException(\"Unsupported Map type: \" + mapType.getName());\r\n        }\r\n        try {\r\n            return (Map<K, V>) ReflectionUtils.accessibleConstructor(mapType).newInstance();\r\n        } catch (Throwable ex) {\r\n            throw new IllegalArgumentException(\"Could not instantiate Map type: \" + mapType.getName(), ex);\r\n        }\r\n    }\r\n}\n/**\r\n * Create a variant of {@link java.util.Properties} that automatically adapts\r\n * non-String values to String representations in {@link Properties#getProperty}.\r\n * <p>In addition, the returned {@code Properties} instance sorts properties\r\n * alphanumerically based on their keys.\r\n * @return a new {@code Properties} instance\r\n * @since 4.3.4\r\n * @see #createSortedProperties(boolean)\r\n * @see #createSortedProperties(Properties, boolean)\r\n */\r\n@SuppressWarnings(\"serial\")\r\npublic static Properties createStringAdaptingProperties() {\r\n    return new SortedProperties(false) {\r\n\r\n        @Override\r\n        @Nullable\r\n        public String getProperty(String key) {\r\n            Object value = get(key);\r\n            return (value != null ? value.toString() : null);\r\n        }\r\n    };\r\n}\n/**\r\n * Create a variant of {@link java.util.Properties} that sorts properties\r\n * alphanumerically based on their keys.\r\n * <p>This can be useful when storing the {@link Properties} instance in a\r\n * properties file, since it allows such files to be generated in a repeatable\r\n * manner with consistent ordering of properties. Comments in generated\r\n * properties files can also be optionally omitted.\r\n * @param omitComments {@code true} if comments should be omitted when\r\n * storing properties in a file\r\n * @return a new {@code Properties} instance\r\n * @since 5.2\r\n * @see #createStringAdaptingProperties()\r\n * @see #createSortedProperties(Properties, boolean)\r\n */\r\npublic static Properties createSortedProperties(boolean omitComments) {\r\n    return new SortedProperties(omitComments);\r\n}\n/**\r\n * Create a variant of {@link java.util.Properties} that sorts properties\r\n * alphanumerically based on their keys.\r\n * <p>This can be useful when storing the {@code Properties} instance in a\r\n * properties file, since it allows such files to be generated in a repeatable\r\n * manner with consistent ordering of properties. Comments in generated\r\n * properties files can also be optionally omitted.\r\n * <p>The returned {@code Properties} instance will be populated with\r\n * properties from the supplied {@code properties} object, but default\r\n * properties from the supplied {@code properties} object will not be copied.\r\n * @param properties the {@code Properties} object from which to copy the\r\n * initial properties\r\n * @param omitComments {@code true} if comments should be omitted when\r\n * storing properties in a file\r\n * @return a new {@code Properties} instance\r\n * @since 5.2\r\n * @see #createStringAdaptingProperties()\r\n * @see #createSortedProperties(boolean)\r\n */\r\npublic static Properties createSortedProperties(Properties properties, boolean omitComments) {\r\n    return new SortedProperties(properties, omitComments);\r\n}\n/**\r\n * Cast the given type to a subtype of {@link Enum}.\r\n * @param enumType the enum type, never {@code null}\r\n * @return the given type as subtype of {@link Enum}\r\n * @throws IllegalArgumentException if the given type is not a subtype of {@link Enum}\r\n */\r\n@SuppressWarnings(\"rawtypes\")\r\nprivate static Class<? extends Enum> asEnumType(Class<?> enumType) {\r\n    Assert.notNull(enumType, \"Enum type must not be null\");\r\n    if (!Enum.class.isAssignableFrom(enumType)) {\r\n        throw new IllegalArgumentException(\"Supplied type is not an enum: \" + enumType.getName());\r\n    }\r\n    return enumType.asSubclass(Enum.class);\r\n}",
    "comment": "\n * Factory for collections that is aware of common Java and Spring collection types.\n *\n * <p>Mainly for internal use within the framework.\n *\n * @author Juergen Hoeller\n * @author Arjen Poutsma\n * @author Oliver Gierke\n * @author Sam Brannen\n * @since 1.1.1\n "
  },
  {
    "entityId": "org.springframework.core.CollectionFactory#isApproximableCollectionType(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given collection type is an <em>approximable</em> type,\r\n * i.e. a type that {@link #createApproximateCollection} can approximate.\r\n * @param collectionType the collection type to check\r\n * @return {@code true} if the type is <em>approximable</em>\r\n */\r\npublic static boolean isApproximableCollectionType(@Nullable Class<?> collectionType) {\r\n    return (collectionType != null && (approximableCollectionTypes.contains(collectionType) || collectionType.getName().equals(\"java.util.SequencedSet\") || collectionType.getName().equals(\"java.util.SequencedCollection\")));\r\n}",
    "comment": "\n\t * Determine whether the given collection type is an <em>approximable</em> type,\n\t * i.e. a type that {@link #createApproximateCollection} can approximate.\n\t * @param collectionType the collection type to check\n\t * @return {@code true} if the type is <em>approximable</em>\n\t "
  },
  {
    "entityId": "org.springframework.core.CollectionFactory#createApproximateCollection(Object,int)",
    "entityType": "method",
    "code": "/**\r\n * Create the most approximate collection for the given collection.\r\n * <p><strong>Warning</strong>: Since the parameterized type {@code E} is\r\n * not bound to the type of elements contained in the supplied\r\n * {@code collection}, type safety cannot be guaranteed if the supplied\r\n * {@code collection} is an {@link EnumSet}. In such scenarios, the caller\r\n * is responsible for ensuring that the element type for the supplied\r\n * {@code collection} is an enum type matching type {@code E}. As an\r\n * alternative, the caller may wish to treat the return value as a raw\r\n * collection or collection of {@link Object}.\r\n * @param collection the original collection object, potentially {@code null}\r\n * @param capacity the initial capacity\r\n * @return a new, empty collection instance\r\n * @see #isApproximableCollectionType\r\n * @see java.util.LinkedList\r\n * @see java.util.ArrayList\r\n * @see java.util.EnumSet\r\n * @see java.util.TreeSet\r\n * @see java.util.LinkedHashSet\r\n */\r\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\r\npublic static <E> Collection<E> createApproximateCollection(@Nullable Object collection, int capacity) {\r\n    if (collection instanceof EnumSet enumSet) {\r\n        Collection<E> copy = EnumSet.copyOf(enumSet);\r\n        copy.clear();\r\n        return copy;\r\n    } else if (collection instanceof SortedSet sortedSet) {\r\n        return new TreeSet<>(sortedSet.comparator());\r\n    } else if (collection instanceof LinkedList) {\r\n        return new LinkedList<>();\r\n    } else if (collection instanceof List) {\r\n        return new ArrayList<>(capacity);\r\n    } else {\r\n        return new LinkedHashSet<>(capacity);\r\n    }\r\n}",
    "comment": "\n\t * Create the most approximate collection for the given collection.\n\t * <p><strong>Warning</strong>: Since the parameterized type {@code E} is\n\t * not bound to the type of elements contained in the supplied\n\t * {@code collection}, type safety cannot be guaranteed if the supplied\n\t * {@code collection} is an {@link EnumSet}. In such scenarios, the caller\n\t * is responsible for ensuring that the element type for the supplied\n\t * {@code collection} is an enum type matching type {@code E}. As an\n\t * alternative, the caller may wish to treat the return value as a raw\n\t * collection or collection of {@link Object}.\n\t * @param collection the original collection object, potentially {@code null}\n\t * @param capacity the initial capacity\n\t * @return a new, empty collection instance\n\t * @see #isApproximableCollectionType\n\t * @see java.util.LinkedList\n\t * @see java.util.ArrayList\n\t * @see java.util.EnumSet\n\t * @see java.util.TreeSet\n\t * @see java.util.LinkedHashSet\n\t "
  },
  {
    "entityId": "org.springframework.core.CollectionFactory#createCollection(Class<?>,int)",
    "entityType": "method",
    "code": "/**\r\n * Create the most appropriate collection for the given collection type.\r\n * <p>Delegates to {@link #createCollection(Class, Class, int)} with a\r\n * {@code null} element type.\r\n * @param collectionType the desired type of the target collection (never {@code null})\r\n * @param capacity the initial capacity\r\n * @return a new collection instance\r\n * @throws IllegalArgumentException if the supplied {@code collectionType}\r\n * is {@code null} or of type {@link EnumSet}\r\n */\r\npublic static <E> Collection<E> createCollection(Class<?> collectionType, int capacity) {\r\n    return createCollection(collectionType, null, capacity);\r\n}",
    "comment": "\n\t * Create the most appropriate collection for the given collection type.\n\t * <p>Delegates to {@link #createCollection(Class, Class, int)} with a\n\t * {@code null} element type.\n\t * @param collectionType the desired type of the target collection (never {@code null})\n\t * @param capacity the initial capacity\n\t * @return a new collection instance\n\t * @throws IllegalArgumentException if the supplied {@code collectionType}\n\t * is {@code null} or of type {@link EnumSet}\n\t "
  },
  {
    "entityId": "org.springframework.core.CollectionFactory#createCollection(Class<?>,Class<?>,int)",
    "entityType": "method",
    "code": "/**\r\n * Create the most appropriate collection for the given collection type.\r\n * <p><strong>Warning</strong>: Since the parameterized type {@code E} is\r\n * not bound to the supplied {@code elementType}, type safety cannot be\r\n * guaranteed if the desired {@code collectionType} is {@link EnumSet}.\r\n * In such scenarios, the caller is responsible for ensuring that the\r\n * supplied {@code elementType} is an enum type matching type {@code E}.\r\n * As an alternative, the caller may wish to treat the return value as a\r\n * raw collection or collection of {@link Object}.\r\n * @param collectionType the desired type of the target collection (never {@code null})\r\n * @param elementType the collection's element type, or {@code null} if unknown\r\n * (note: only relevant for {@link EnumSet} creation)\r\n * @param capacity the initial capacity\r\n * @return a new collection instance\r\n * @throws IllegalArgumentException if the supplied {@code collectionType} is\r\n * {@code null}; or if the desired {@code collectionType} is {@link EnumSet} and\r\n * the supplied {@code elementType} is not a subtype of {@link Enum}\r\n * @since 4.1.3\r\n * @see java.util.LinkedHashSet\r\n * @see java.util.ArrayList\r\n * @see java.util.TreeSet\r\n * @see java.util.EnumSet\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic static <E> Collection<E> createCollection(Class<?> collectionType, @Nullable Class<?> elementType, int capacity) {\r\n    Assert.notNull(collectionType, \"Collection type must not be null\");\r\n    if (LinkedHashSet.class == collectionType || Set.class == collectionType || Collection.class == collectionType || collectionType.getName().equals(\"java.util.SequencedSet\") || collectionType.getName().equals(\"java.util.SequencedCollection\")) {\r\n        return new LinkedHashSet<>(capacity);\r\n    } else if (ArrayList.class == collectionType || List.class == collectionType) {\r\n        return new ArrayList<>(capacity);\r\n    } else if (LinkedList.class == collectionType) {\r\n        return new LinkedList<>();\r\n    } else if (TreeSet.class == collectionType || NavigableSet.class == collectionType || SortedSet.class == collectionType) {\r\n        return new TreeSet<>();\r\n    } else if (EnumSet.class.isAssignableFrom(collectionType)) {\r\n        Assert.notNull(elementType, \"Cannot create EnumSet for unknown element type\");\r\n        return EnumSet.noneOf(asEnumType(elementType));\r\n    } else if (HashSet.class == collectionType) {\r\n        return new HashSet<>(capacity);\r\n    } else {\r\n        if (collectionType.isInterface() || !Collection.class.isAssignableFrom(collectionType)) {\r\n            throw new IllegalArgumentException(\"Unsupported Collection type: \" + collectionType.getName());\r\n        }\r\n        try {\r\n            return (Collection<E>) ReflectionUtils.accessibleConstructor(collectionType).newInstance();\r\n        } catch (Throwable ex) {\r\n            throw new IllegalArgumentException(\"Could not instantiate Collection type: \" + collectionType.getName(), ex);\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Create the most appropriate collection for the given collection type.\n\t * <p><strong>Warning</strong>: Since the parameterized type {@code E} is\n\t * not bound to the supplied {@code elementType}, type safety cannot be\n\t * guaranteed if the desired {@code collectionType} is {@link EnumSet}.\n\t * In such scenarios, the caller is responsible for ensuring that the\n\t * supplied {@code elementType} is an enum type matching type {@code E}.\n\t * As an alternative, the caller may wish to treat the return value as a\n\t * raw collection or collection of {@link Object}.\n\t * @param collectionType the desired type of the target collection (never {@code null})\n\t * @param elementType the collection's element type, or {@code null} if unknown\n\t * (note: only relevant for {@link EnumSet} creation)\n\t * @param capacity the initial capacity\n\t * @return a new collection instance\n\t * @throws IllegalArgumentException if the supplied {@code collectionType} is\n\t * {@code null}; or if the desired {@code collectionType} is {@link EnumSet} and\n\t * the supplied {@code elementType} is not a subtype of {@link Enum}\n\t * @since 4.1.3\n\t * @see java.util.LinkedHashSet\n\t * @see java.util.ArrayList\n\t * @see java.util.TreeSet\n\t * @see java.util.EnumSet\n\t "
  },
  {
    "entityId": "org.springframework.core.CollectionFactory#isApproximableMapType(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given map type is an <em>approximable</em> type,\r\n * i.e. a type that {@link #createApproximateMap} can approximate.\r\n * @param mapType the map type to check\r\n * @return {@code true} if the type is <em>approximable</em>\r\n */\r\npublic static boolean isApproximableMapType(@Nullable Class<?> mapType) {\r\n    return (mapType != null && (approximableMapTypes.contains(mapType) || mapType.getName().equals(\"java.util.SequencedMap\")));\r\n}",
    "comment": "\n\t * Determine whether the given map type is an <em>approximable</em> type,\n\t * i.e. a type that {@link #createApproximateMap} can approximate.\n\t * @param mapType the map type to check\n\t * @return {@code true} if the type is <em>approximable</em>\n\t "
  },
  {
    "entityId": "org.springframework.core.CollectionFactory#createApproximateMap(Object,int)",
    "entityType": "method",
    "code": "/**\r\n * Create the most approximate map for the given map.\r\n * <p><strong>Warning</strong>: Since the parameterized type {@code K} is\r\n * not bound to the type of keys contained in the supplied {@code map},\r\n * type safety cannot be guaranteed if the supplied {@code map} is an\r\n * {@link EnumMap}. In such scenarios, the caller is responsible for\r\n * ensuring that the key type in the supplied {@code map} is an enum type\r\n * matching type {@code K}. As an alternative, the caller may wish to\r\n * treat the return value as a raw map or map keyed by {@link Object}.\r\n * @param map the original map object, potentially {@code null}\r\n * @param capacity the initial capacity\r\n * @return a new, empty map instance\r\n * @see #isApproximableMapType\r\n * @see java.util.EnumMap\r\n * @see java.util.TreeMap\r\n * @see java.util.LinkedHashMap\r\n */\r\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\r\npublic static <K, V> Map<K, V> createApproximateMap(@Nullable Object map, int capacity) {\r\n    if (map instanceof EnumMap enumMap) {\r\n        EnumMap copy = new EnumMap(enumMap);\r\n        copy.clear();\r\n        return copy;\r\n    } else if (map instanceof SortedMap sortedMap) {\r\n        return new TreeMap<>(sortedMap.comparator());\r\n    } else if (map instanceof MultiValueMap) {\r\n        return new LinkedMultiValueMap(capacity);\r\n    } else {\r\n        return new LinkedHashMap<>(capacity);\r\n    }\r\n}",
    "comment": "\n\t * Create the most approximate map for the given map.\n\t * <p><strong>Warning</strong>: Since the parameterized type {@code K} is\n\t * not bound to the type of keys contained in the supplied {@code map},\n\t * type safety cannot be guaranteed if the supplied {@code map} is an\n\t * {@link EnumMap}. In such scenarios, the caller is responsible for\n\t * ensuring that the key type in the supplied {@code map} is an enum type\n\t * matching type {@code K}. As an alternative, the caller may wish to\n\t * treat the return value as a raw map or map keyed by {@link Object}.\n\t * @param map the original map object, potentially {@code null}\n\t * @param capacity the initial capacity\n\t * @return a new, empty map instance\n\t * @see #isApproximableMapType\n\t * @see java.util.EnumMap\n\t * @see java.util.TreeMap\n\t * @see java.util.LinkedHashMap\n\t "
  },
  {
    "entityId": "org.springframework.core.CollectionFactory#createMap(Class<?>,int)",
    "entityType": "method",
    "code": "/**\r\n * Create the most appropriate map for the given map type.\r\n * <p>Delegates to {@link #createMap(Class, Class, int)} with a\r\n * {@code null} key type.\r\n * @param mapType the desired type of the target map\r\n * @param capacity the initial capacity\r\n * @return a new map instance\r\n * @throws IllegalArgumentException if the supplied {@code mapType} is\r\n * {@code null} or of type {@link EnumMap}\r\n */\r\npublic static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity) {\r\n    return createMap(mapType, null, capacity);\r\n}",
    "comment": "\n\t * Create the most appropriate map for the given map type.\n\t * <p>Delegates to {@link #createMap(Class, Class, int)} with a\n\t * {@code null} key type.\n\t * @param mapType the desired type of the target map\n\t * @param capacity the initial capacity\n\t * @return a new map instance\n\t * @throws IllegalArgumentException if the supplied {@code mapType} is\n\t * {@code null} or of type {@link EnumMap}\n\t "
  },
  {
    "entityId": "org.springframework.core.CollectionFactory#createMap(Class<?>,Class<?>,int)",
    "entityType": "method",
    "code": "/**\r\n * Create the most appropriate map for the given map type.\r\n * <p><strong>Warning</strong>: Since the parameterized type {@code K}\r\n * is not bound to the supplied {@code keyType}, type safety cannot be\r\n * guaranteed if the desired {@code mapType} is {@link EnumMap}. In such\r\n * scenarios, the caller is responsible for ensuring that the {@code keyType}\r\n * is an enum type matching type {@code K}. As an alternative, the caller\r\n * may wish to treat the return value as a raw map or map keyed by\r\n * {@link Object}. Similarly, type safety cannot be enforced if the\r\n * desired {@code mapType} is {@link MultiValueMap}.\r\n * @param mapType the desired type of the target map (never {@code null})\r\n * @param keyType the map's key type, or {@code null} if unknown\r\n * (note: only relevant for {@link EnumMap} creation)\r\n * @param capacity the initial capacity\r\n * @return a new map instance\r\n * @throws IllegalArgumentException if the supplied {@code mapType} is\r\n * {@code null}; or if the desired {@code mapType} is {@link EnumMap} and\r\n * the supplied {@code keyType} is not a subtype of {@link Enum}\r\n * @since 4.1.3\r\n * @see java.util.LinkedHashMap\r\n * @see java.util.TreeMap\r\n * @see org.springframework.util.LinkedMultiValueMap\r\n * @see java.util.EnumMap\r\n */\r\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\r\npublic static <K, V> Map<K, V> createMap(Class<?> mapType, @Nullable Class<?> keyType, int capacity) {\r\n    Assert.notNull(mapType, \"Map type must not be null\");\r\n    if (LinkedHashMap.class == mapType || Map.class == mapType || mapType.getName().equals(\"java.util.SequencedMap\")) {\r\n        return new LinkedHashMap<>(capacity);\r\n    } else if (LinkedMultiValueMap.class == mapType || MultiValueMap.class == mapType) {\r\n        return new LinkedMultiValueMap();\r\n    } else if (TreeMap.class == mapType || SortedMap.class == mapType || NavigableMap.class == mapType) {\r\n        return new TreeMap<>();\r\n    } else if (EnumMap.class == mapType) {\r\n        Assert.notNull(keyType, \"Cannot create EnumMap for unknown key type\");\r\n        return new EnumMap(asEnumType(keyType));\r\n    } else if (HashMap.class == mapType) {\r\n        return new HashMap<>(capacity);\r\n    } else {\r\n        if (mapType.isInterface() || !Map.class.isAssignableFrom(mapType)) {\r\n            throw new IllegalArgumentException(\"Unsupported Map type: \" + mapType.getName());\r\n        }\r\n        try {\r\n            return (Map<K, V>) ReflectionUtils.accessibleConstructor(mapType).newInstance();\r\n        } catch (Throwable ex) {\r\n            throw new IllegalArgumentException(\"Could not instantiate Map type: \" + mapType.getName(), ex);\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Create the most appropriate map for the given map type.\n\t * <p><strong>Warning</strong>: Since the parameterized type {@code K}\n\t * is not bound to the supplied {@code keyType}, type safety cannot be\n\t * guaranteed if the desired {@code mapType} is {@link EnumMap}. In such\n\t * scenarios, the caller is responsible for ensuring that the {@code keyType}\n\t * is an enum type matching type {@code K}. As an alternative, the caller\n\t * may wish to treat the return value as a raw map or map keyed by\n\t * {@link Object}. Similarly, type safety cannot be enforced if the\n\t * desired {@code mapType} is {@link MultiValueMap}.\n\t * @param mapType the desired type of the target map (never {@code null})\n\t * @param keyType the map's key type, or {@code null} if unknown\n\t * (note: only relevant for {@link EnumMap} creation)\n\t * @param capacity the initial capacity\n\t * @return a new map instance\n\t * @throws IllegalArgumentException if the supplied {@code mapType} is\n\t * {@code null}; or if the desired {@code mapType} is {@link EnumMap} and\n\t * the supplied {@code keyType} is not a subtype of {@link Enum}\n\t * @since 4.1.3\n\t * @see java.util.LinkedHashMap\n\t * @see java.util.TreeMap\n\t * @see org.springframework.util.LinkedMultiValueMap\n\t * @see java.util.EnumMap\n\t "
  },
  {
    "entityId": "org.springframework.core.CollectionFactory#createStringAdaptingProperties()",
    "entityType": "method",
    "code": "/**\r\n * Create a variant of {@link java.util.Properties} that automatically adapts\r\n * non-String values to String representations in {@link Properties#getProperty}.\r\n * <p>In addition, the returned {@code Properties} instance sorts properties\r\n * alphanumerically based on their keys.\r\n * @return a new {@code Properties} instance\r\n * @since 4.3.4\r\n * @see #createSortedProperties(boolean)\r\n * @see #createSortedProperties(Properties, boolean)\r\n */\r\n@SuppressWarnings(\"serial\")\r\npublic static Properties createStringAdaptingProperties() {\r\n    return new SortedProperties(false) {\r\n\r\n        @Override\r\n        @Nullable\r\n        public String getProperty(String key) {\r\n            Object value = get(key);\r\n            return (value != null ? value.toString() : null);\r\n        }\r\n    };\r\n}",
    "comment": "\n\t * Create a variant of {@link java.util.Properties} that automatically adapts\n\t * non-String values to String representations in {@link Properties#getProperty}.\n\t * <p>In addition, the returned {@code Properties} instance sorts properties\n\t * alphanumerically based on their keys.\n\t * @return a new {@code Properties} instance\n\t * @since 4.3.4\n\t * @see #createSortedProperties(boolean)\n\t * @see #createSortedProperties(Properties, boolean)\n\t "
  },
  {
    "entityId": "org.springframework.core.CollectionFactory#createSortedProperties(boolean)",
    "entityType": "method",
    "code": "/**\r\n * Create a variant of {@link java.util.Properties} that sorts properties\r\n * alphanumerically based on their keys.\r\n * <p>This can be useful when storing the {@link Properties} instance in a\r\n * properties file, since it allows such files to be generated in a repeatable\r\n * manner with consistent ordering of properties. Comments in generated\r\n * properties files can also be optionally omitted.\r\n * @param omitComments {@code true} if comments should be omitted when\r\n * storing properties in a file\r\n * @return a new {@code Properties} instance\r\n * @since 5.2\r\n * @see #createStringAdaptingProperties()\r\n * @see #createSortedProperties(Properties, boolean)\r\n */\r\npublic static Properties createSortedProperties(boolean omitComments) {\r\n    return new SortedProperties(omitComments);\r\n}",
    "comment": "\n\t * Create a variant of {@link java.util.Properties} that sorts properties\n\t * alphanumerically based on their keys.\n\t * <p>This can be useful when storing the {@link Properties} instance in a\n\t * properties file, since it allows such files to be generated in a repeatable\n\t * manner with consistent ordering of properties. Comments in generated\n\t * properties files can also be optionally omitted.\n\t * @param omitComments {@code true} if comments should be omitted when\n\t * storing properties in a file\n\t * @return a new {@code Properties} instance\n\t * @since 5.2\n\t * @see #createStringAdaptingProperties()\n\t * @see #createSortedProperties(Properties, boolean)\n\t "
  },
  {
    "entityId": "org.springframework.core.CollectionFactory#createSortedProperties(Properties,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Create a variant of {@link java.util.Properties} that sorts properties\r\n * alphanumerically based on their keys.\r\n * <p>This can be useful when storing the {@code Properties} instance in a\r\n * properties file, since it allows such files to be generated in a repeatable\r\n * manner with consistent ordering of properties. Comments in generated\r\n * properties files can also be optionally omitted.\r\n * <p>The returned {@code Properties} instance will be populated with\r\n * properties from the supplied {@code properties} object, but default\r\n * properties from the supplied {@code properties} object will not be copied.\r\n * @param properties the {@code Properties} object from which to copy the\r\n * initial properties\r\n * @param omitComments {@code true} if comments should be omitted when\r\n * storing properties in a file\r\n * @return a new {@code Properties} instance\r\n * @since 5.2\r\n * @see #createStringAdaptingProperties()\r\n * @see #createSortedProperties(boolean)\r\n */\r\npublic static Properties createSortedProperties(Properties properties, boolean omitComments) {\r\n    return new SortedProperties(properties, omitComments);\r\n}",
    "comment": "\n\t * Create a variant of {@link java.util.Properties} that sorts properties\n\t * alphanumerically based on their keys.\n\t * <p>This can be useful when storing the {@code Properties} instance in a\n\t * properties file, since it allows such files to be generated in a repeatable\n\t * manner with consistent ordering of properties. Comments in generated\n\t * properties files can also be optionally omitted.\n\t * <p>The returned {@code Properties} instance will be populated with\n\t * properties from the supplied {@code properties} object, but default\n\t * properties from the supplied {@code properties} object will not be copied.\n\t * @param properties the {@code Properties} object from which to copy the\n\t * initial properties\n\t * @param omitComments {@code true} if comments should be omitted when\n\t * storing properties in a file\n\t * @return a new {@code Properties} instance\n\t * @since 5.2\n\t * @see #createStringAdaptingProperties()\n\t * @see #createSortedProperties(boolean)\n\t "
  },
  {
    "entityId": "org.springframework.core.CollectionFactory#asEnumType(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Cast the given type to a subtype of {@link Enum}.\r\n * @param enumType the enum type, never {@code null}\r\n * @return the given type as subtype of {@link Enum}\r\n * @throws IllegalArgumentException if the given type is not a subtype of {@link Enum}\r\n */\r\n@SuppressWarnings(\"rawtypes\")\r\nprivate static Class<? extends Enum> asEnumType(Class<?> enumType) {\r\n    Assert.notNull(enumType, \"Enum type must not be null\");\r\n    if (!Enum.class.isAssignableFrom(enumType)) {\r\n        throw new IllegalArgumentException(\"Supplied type is not an enum: \" + enumType.getName());\r\n    }\r\n    return enumType.asSubclass(Enum.class);\r\n}",
    "comment": "\n\t * Cast the given type to a subtype of {@link Enum}.\n\t * @param enumType the enum type, never {@code null}\n\t * @return the given type as subtype of {@link Enum}\n\t * @throws IllegalArgumentException if the given type is not a subtype of {@link Enum}\n\t "
  },
  {
    "entityId": "org.springframework.core.ConfigurableObjectInputStream",
    "entityType": "class",
    "code": "@Nullable\r\nprivate final ClassLoader classLoader;\nprivate final boolean acceptProxyClasses;\n/**\r\n * Create a new ConfigurableObjectInputStream for the given InputStream and ClassLoader.\r\n * @param in the InputStream to read from\r\n * @param classLoader the ClassLoader to use for loading local classes\r\n * @see java.io.ObjectInputStream#ObjectInputStream(java.io.InputStream)\r\n */\r\npublic ConfigurableObjectInputStream(InputStream in, @Nullable ClassLoader classLoader) throws IOException {\r\n    this(in, classLoader, true);\r\n}\n/**\r\n * Create a new ConfigurableObjectInputStream for the given InputStream and ClassLoader.\r\n * @param in the InputStream to read from\r\n * @param classLoader the ClassLoader to use for loading local classes\r\n * @param acceptProxyClasses whether to accept deserialization of proxy classes\r\n * (may be deactivated as a security measure)\r\n * @see java.io.ObjectInputStream#ObjectInputStream(java.io.InputStream)\r\n */\r\npublic ConfigurableObjectInputStream(InputStream in, @Nullable ClassLoader classLoader, boolean acceptProxyClasses) throws IOException {\r\n    super(in);\r\n    this.classLoader = classLoader;\r\n    this.acceptProxyClasses = acceptProxyClasses;\r\n}\n@Override\r\nprotected Class<?> resolveClass(ObjectStreamClass classDesc) throws IOException, ClassNotFoundException {\r\n    try {\r\n        if (this.classLoader != null) {\r\n            // Use the specified ClassLoader to resolve local classes.\r\n            return ClassUtils.forName(classDesc.getName(), this.classLoader);\r\n        } else {\r\n            // Use the default ClassLoader...\r\n            return super.resolveClass(classDesc);\r\n        }\r\n    } catch (ClassNotFoundException ex) {\r\n        return resolveFallbackIfPossible(classDesc.getName(), ex);\r\n    }\r\n}\n@Override\r\nprotected Class<?> resolveProxyClass(String[] interfaces) throws IOException, ClassNotFoundException {\r\n    if (!this.acceptProxyClasses) {\r\n        throw new NotSerializableException(\"Not allowed to accept serialized proxy classes\");\r\n    }\r\n    if (this.classLoader != null) {\r\n        // Use the specified ClassLoader to resolve local proxy classes.\r\n        Class<?>[] resolvedInterfaces = new Class<?>[interfaces.length];\r\n        for (int i = 0; i < interfaces.length; i++) {\r\n            try {\r\n                resolvedInterfaces[i] = ClassUtils.forName(interfaces[i], this.classLoader);\r\n            } catch (ClassNotFoundException ex) {\r\n                resolvedInterfaces[i] = resolveFallbackIfPossible(interfaces[i], ex);\r\n            }\r\n        }\r\n        try {\r\n            return ClassUtils.createCompositeInterface(resolvedInterfaces, this.classLoader);\r\n        } catch (IllegalArgumentException ex) {\r\n            throw new ClassNotFoundException(null, ex);\r\n        }\r\n    } else {\r\n        // Use ObjectInputStream's default ClassLoader...\r\n        try {\r\n            return super.resolveProxyClass(interfaces);\r\n        } catch (ClassNotFoundException ex) {\r\n            Class<?>[] resolvedInterfaces = new Class<?>[interfaces.length];\r\n            for (int i = 0; i < interfaces.length; i++) {\r\n                resolvedInterfaces[i] = resolveFallbackIfPossible(interfaces[i], ex);\r\n            }\r\n            return ClassUtils.createCompositeInterface(resolvedInterfaces, getFallbackClassLoader());\r\n        }\r\n    }\r\n}\n/**\r\n * Resolve the given class name against a fallback class loader.\r\n * <p>The default implementation simply rethrows the original exception,\r\n * since there is no fallback available.\r\n * @param className the class name to resolve\r\n * @param ex the original exception thrown when attempting to load the class\r\n * @return the newly resolved class (never {@code null})\r\n */\r\nprotected Class<?> resolveFallbackIfPossible(String className, ClassNotFoundException ex) throws IOException, ClassNotFoundException {\r\n    throw ex;\r\n}\n/**\r\n * Return the fallback ClassLoader to use when no ClassLoader was specified\r\n * and ObjectInputStream's own default class loader failed.\r\n * <p>The default implementation simply returns {@code null}, indicating\r\n * that no specific fallback is available.\r\n */\r\n@Nullable\r\nprotected ClassLoader getFallbackClassLoader() throws IOException {\r\n    return null;\r\n}",
    "comment": "\n * Special {@link ObjectInputStream} subclass that resolves class names\n * against a specific {@link ClassLoader}.\n *\n * @author Juergen Hoeller\n * @since 2.5.5\n * @see org.springframework.core.serializer.DefaultDeserializer\n "
  },
  {
    "entityId": "org.springframework.core.ConfigurableObjectInputStream#resolveClass(ObjectStreamClass)",
    "entityType": "method",
    "code": "@Override\r\nprotected Class<?> resolveClass(ObjectStreamClass classDesc) throws IOException, ClassNotFoundException {\r\n    try {\r\n        if (this.classLoader != null) {\r\n            // Use the specified ClassLoader to resolve local classes.\r\n            return ClassUtils.forName(classDesc.getName(), this.classLoader);\r\n        } else {\r\n            // Use the default ClassLoader...\r\n            return super.resolveClass(classDesc);\r\n        }\r\n    } catch (ClassNotFoundException ex) {\r\n        return resolveFallbackIfPossible(classDesc.getName(), ex);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ConfigurableObjectInputStream#resolveProxyClass(String[])",
    "entityType": "method",
    "code": "@Override\r\nprotected Class<?> resolveProxyClass(String[] interfaces) throws IOException, ClassNotFoundException {\r\n    if (!this.acceptProxyClasses) {\r\n        throw new NotSerializableException(\"Not allowed to accept serialized proxy classes\");\r\n    }\r\n    if (this.classLoader != null) {\r\n        // Use the specified ClassLoader to resolve local proxy classes.\r\n        Class<?>[] resolvedInterfaces = new Class<?>[interfaces.length];\r\n        for (int i = 0; i < interfaces.length; i++) {\r\n            try {\r\n                resolvedInterfaces[i] = ClassUtils.forName(interfaces[i], this.classLoader);\r\n            } catch (ClassNotFoundException ex) {\r\n                resolvedInterfaces[i] = resolveFallbackIfPossible(interfaces[i], ex);\r\n            }\r\n        }\r\n        try {\r\n            return ClassUtils.createCompositeInterface(resolvedInterfaces, this.classLoader);\r\n        } catch (IllegalArgumentException ex) {\r\n            throw new ClassNotFoundException(null, ex);\r\n        }\r\n    } else {\r\n        // Use ObjectInputStream's default ClassLoader...\r\n        try {\r\n            return super.resolveProxyClass(interfaces);\r\n        } catch (ClassNotFoundException ex) {\r\n            Class<?>[] resolvedInterfaces = new Class<?>[interfaces.length];\r\n            for (int i = 0; i < interfaces.length; i++) {\r\n                resolvedInterfaces[i] = resolveFallbackIfPossible(interfaces[i], ex);\r\n            }\r\n            return ClassUtils.createCompositeInterface(resolvedInterfaces, getFallbackClassLoader());\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ConfigurableObjectInputStream#resolveFallbackIfPossible(String,ClassNotFoundException)",
    "entityType": "method",
    "code": "/**\r\n * Resolve the given class name against a fallback class loader.\r\n * <p>The default implementation simply rethrows the original exception,\r\n * since there is no fallback available.\r\n * @param className the class name to resolve\r\n * @param ex the original exception thrown when attempting to load the class\r\n * @return the newly resolved class (never {@code null})\r\n */\r\nprotected Class<?> resolveFallbackIfPossible(String className, ClassNotFoundException ex) throws IOException, ClassNotFoundException {\r\n    throw ex;\r\n}",
    "comment": "\n\t * Resolve the given class name against a fallback class loader.\n\t * <p>The default implementation simply rethrows the original exception,\n\t * since there is no fallback available.\n\t * @param className the class name to resolve\n\t * @param ex the original exception thrown when attempting to load the class\n\t * @return the newly resolved class (never {@code null})\n\t "
  },
  {
    "entityId": "org.springframework.core.ConfigurableObjectInputStream#getFallbackClassLoader()",
    "entityType": "method",
    "code": "/**\r\n * Return the fallback ClassLoader to use when no ClassLoader was specified\r\n * and ObjectInputStream's own default class loader failed.\r\n * <p>The default implementation simply returns {@code null}, indicating\r\n * that no specific fallback is available.\r\n */\r\n@Nullable\r\nprotected ClassLoader getFallbackClassLoader() throws IOException {\r\n    return null;\r\n}",
    "comment": "\n\t * Return the fallback ClassLoader to use when no ClassLoader was specified\n\t * and ObjectInputStream's own default class loader failed.\n\t * <p>The default implementation simply returns {@code null}, indicating\n\t * that no specific fallback is available.\n\t "
  },
  {
    "entityId": "org.springframework.core.Constants",
    "entityType": "class",
    "code": "/**\r\n * The name of the introspected class.\r\n */\r\nprivate final String className;\n/**\r\n * Map from String field name to object value.\r\n */\r\nprivate final Map<String, Object> fieldCache = new HashMap<>();\n/**\r\n * Create a new Constants converter class wrapping the given class.\r\n * <p>All <b>public</b> static final variables will be exposed, whatever their type.\r\n * @param clazz the class to analyze\r\n * @throws IllegalArgumentException if the supplied {@code clazz} is {@code null}\r\n */\r\npublic Constants(Class<?> clazz) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    this.className = clazz.getName();\r\n    Field[] fields = clazz.getFields();\r\n    for (Field field : fields) {\r\n        if (ReflectionUtils.isPublicStaticFinal(field)) {\r\n            String name = field.getName();\r\n            try {\r\n                Object value = field.get(null);\r\n                this.fieldCache.put(name, value);\r\n            } catch (IllegalAccessException ex) {\r\n                // just leave this field and continue\r\n            }\r\n        }\r\n    }\r\n}\n/**\r\n * Return the name of the analyzed class.\r\n */\r\npublic final String getClassName() {\r\n    return this.className;\r\n}\n/**\r\n * Return the number of constants exposed.\r\n */\r\npublic final int getSize() {\r\n    return this.fieldCache.size();\r\n}\n/**\r\n * Exposes the field cache to subclasses:\r\n * a Map from String field name to object value.\r\n */\r\nprotected final Map<String, Object> getFieldCache() {\r\n    return this.fieldCache;\r\n}\n/**\r\n * Return a constant value cast to a Number.\r\n * @param code the name of the field (never {@code null})\r\n * @return the Number value\r\n * @throws ConstantException if the field name wasn't found\r\n * or if the type wasn't compatible with Number\r\n * @see #asObject\r\n */\r\npublic Number asNumber(String code) throws ConstantException {\r\n    Object obj = asObject(code);\r\n    if (!(obj instanceof Number number)) {\r\n        throw new ConstantException(this.className, code, \"not a Number\");\r\n    }\r\n    return number;\r\n}\n/**\r\n * Return a constant value as a String.\r\n * @param code the name of the field (never {@code null})\r\n * @return the String value\r\n * Works even if it's not a string (invokes {@code toString()}).\r\n * @throws ConstantException if the field name wasn't found\r\n * @see #asObject\r\n */\r\npublic String asString(String code) throws ConstantException {\r\n    return asObject(code).toString();\r\n}\n/**\r\n * Parse the given String (upper or lower case accepted) and return\r\n * the appropriate value if it's the name of a constant field in the\r\n * class that we're analyzing.\r\n * @param code the name of the field (never {@code null})\r\n * @return the Object value\r\n * @throws ConstantException if there's no such field\r\n */\r\npublic Object asObject(String code) throws ConstantException {\r\n    Assert.notNull(code, \"Code must not be null\");\r\n    String codeToUse = code.toUpperCase(Locale.ENGLISH);\r\n    Object val = this.fieldCache.get(codeToUse);\r\n    if (val == null) {\r\n        throw new ConstantException(this.className, codeToUse, \"not found\");\r\n    }\r\n    return val;\r\n}\n/**\r\n * Return all names of the given group of constants.\r\n * <p>Note that this method assumes that constants are named\r\n * in accordance with the standard Java convention for constant\r\n * values (i.e. all uppercase). The supplied {@code namePrefix}\r\n * will be uppercased (in a locale-insensitive fashion) prior to\r\n * the main logic of this method kicking in.\r\n * @param namePrefix prefix of the constant names to search (may be {@code null})\r\n * @return the set of constant names\r\n */\r\npublic Set<String> getNames(@Nullable String namePrefix) {\r\n    String prefixToUse = (namePrefix != null ? namePrefix.trim().toUpperCase(Locale.ENGLISH) : \"\");\r\n    Set<String> names = new HashSet<>();\r\n    for (String code : this.fieldCache.keySet()) {\r\n        if (code.startsWith(prefixToUse)) {\r\n            names.add(code);\r\n        }\r\n    }\r\n    return names;\r\n}\n/**\r\n * Return all names of the group of constants for the\r\n * given bean property name.\r\n * @param propertyName the name of the bean property\r\n * @return the set of values\r\n * @see #propertyToConstantNamePrefix\r\n */\r\npublic Set<String> getNamesForProperty(String propertyName) {\r\n    return getNames(propertyToConstantNamePrefix(propertyName));\r\n}\n/**\r\n * Return all names of the given group of constants.\r\n * <p>Note that this method assumes that constants are named\r\n * in accordance with the standard Java convention for constant\r\n * values (i.e. all uppercase). The supplied {@code nameSuffix}\r\n * will be uppercased (in a locale-insensitive fashion) prior to\r\n * the main logic of this method kicking in.\r\n * @param nameSuffix suffix of the constant names to search (may be {@code null})\r\n * @return the set of constant names\r\n */\r\npublic Set<String> getNamesForSuffix(@Nullable String nameSuffix) {\r\n    String suffixToUse = (nameSuffix != null ? nameSuffix.trim().toUpperCase(Locale.ENGLISH) : \"\");\r\n    Set<String> names = new HashSet<>();\r\n    for (String code : this.fieldCache.keySet()) {\r\n        if (code.endsWith(suffixToUse)) {\r\n            names.add(code);\r\n        }\r\n    }\r\n    return names;\r\n}\n/**\r\n * Return all values of the given group of constants.\r\n * <p>Note that this method assumes that constants are named\r\n * in accordance with the standard Java convention for constant\r\n * values (i.e. all uppercase). The supplied {@code namePrefix}\r\n * will be uppercased (in a locale-insensitive fashion) prior to\r\n * the main logic of this method kicking in.\r\n * @param namePrefix prefix of the constant names to search (may be {@code null})\r\n * @return the set of values\r\n */\r\npublic Set<Object> getValues(@Nullable String namePrefix) {\r\n    String prefixToUse = (namePrefix != null ? namePrefix.trim().toUpperCase(Locale.ENGLISH) : \"\");\r\n    Set<Object> values = new HashSet<>();\r\n    this.fieldCache.forEach((code, value) -> {\r\n        if (code.startsWith(prefixToUse)) {\r\n            values.add(value);\r\n        }\r\n    });\r\n    return values;\r\n}\n/**\r\n * Return all values of the group of constants for the\r\n * given bean property name.\r\n * @param propertyName the name of the bean property\r\n * @return the set of values\r\n * @see #propertyToConstantNamePrefix\r\n */\r\npublic Set<Object> getValuesForProperty(String propertyName) {\r\n    return getValues(propertyToConstantNamePrefix(propertyName));\r\n}\n/**\r\n * Return all values of the given group of constants.\r\n * <p>Note that this method assumes that constants are named\r\n * in accordance with the standard Java convention for constant\r\n * values (i.e. all uppercase). The supplied {@code nameSuffix}\r\n * will be uppercased (in a locale-insensitive fashion) prior to\r\n * the main logic of this method kicking in.\r\n * @param nameSuffix suffix of the constant names to search (may be {@code null})\r\n * @return the set of values\r\n */\r\npublic Set<Object> getValuesForSuffix(@Nullable String nameSuffix) {\r\n    String suffixToUse = (nameSuffix != null ? nameSuffix.trim().toUpperCase(Locale.ENGLISH) : \"\");\r\n    Set<Object> values = new HashSet<>();\r\n    this.fieldCache.forEach((code, value) -> {\r\n        if (code.endsWith(suffixToUse)) {\r\n            values.add(value);\r\n        }\r\n    });\r\n    return values;\r\n}\n/**\r\n * Look up the given value within the given group of constants.\r\n * <p>Will return the first match.\r\n * @param value constant value to look up\r\n * @param namePrefix prefix of the constant names to search (may be {@code null})\r\n * @return the name of the constant field\r\n * @throws ConstantException if the value wasn't found\r\n */\r\npublic String toCode(Object value, @Nullable String namePrefix) throws ConstantException {\r\n    String prefixToUse = (namePrefix != null ? namePrefix.trim().toUpperCase(Locale.ENGLISH) : \"\");\r\n    for (Map.Entry<String, Object> entry : this.fieldCache.entrySet()) {\r\n        if (entry.getKey().startsWith(prefixToUse) && entry.getValue().equals(value)) {\r\n            return entry.getKey();\r\n        }\r\n    }\r\n    throw new ConstantException(this.className, prefixToUse, value);\r\n}\n/**\r\n * Look up the given value within the group of constants for\r\n * the given bean property name. Will return the first match.\r\n * @param value constant value to look up\r\n * @param propertyName the name of the bean property\r\n * @return the name of the constant field\r\n * @throws ConstantException if the value wasn't found\r\n * @see #propertyToConstantNamePrefix\r\n */\r\npublic String toCodeForProperty(Object value, String propertyName) throws ConstantException {\r\n    return toCode(value, propertyToConstantNamePrefix(propertyName));\r\n}\n/**\r\n * Look up the given value within the given group of constants.\r\n * <p>Will return the first match.\r\n * @param value constant value to look up\r\n * @param nameSuffix suffix of the constant names to search (may be {@code null})\r\n * @return the name of the constant field\r\n * @throws ConstantException if the value wasn't found\r\n */\r\npublic String toCodeForSuffix(Object value, @Nullable String nameSuffix) throws ConstantException {\r\n    String suffixToUse = (nameSuffix != null ? nameSuffix.trim().toUpperCase(Locale.ENGLISH) : \"\");\r\n    for (Map.Entry<String, Object> entry : this.fieldCache.entrySet()) {\r\n        if (entry.getKey().endsWith(suffixToUse) && entry.getValue().equals(value)) {\r\n            return entry.getKey();\r\n        }\r\n    }\r\n    throw new ConstantException(this.className, suffixToUse, value);\r\n}\n/**\r\n * Convert the given bean property name to a constant name prefix.\r\n * <p>Uses a common naming idiom: turning all lower case characters to\r\n * upper case, and prepending upper case characters with an underscore.\r\n * <p>Example: \"imageSize\" &rarr; \"IMAGE_SIZE\"<br>\r\n * Example: \"imagesize\" &rarr; \"IMAGESIZE\".<br>\r\n * Example: \"ImageSize\" &rarr; \"_IMAGE_SIZE\".<br>\r\n * Example: \"IMAGESIZE\" &rarr; \"_I_M_A_G_E_S_I_Z_E\"\r\n * @param propertyName the name of the bean property\r\n * @return the corresponding constant name prefix\r\n * @see #getValuesForProperty\r\n * @see #toCodeForProperty\r\n */\r\npublic String propertyToConstantNamePrefix(String propertyName) {\r\n    StringBuilder parsedPrefix = new StringBuilder();\r\n    for (int i = 0; i < propertyName.length(); i++) {\r\n        char c = propertyName.charAt(i);\r\n        if (Character.isUpperCase(c)) {\r\n            parsedPrefix.append('_');\r\n            parsedPrefix.append(c);\r\n        } else {\r\n            parsedPrefix.append(Character.toUpperCase(c));\r\n        }\r\n    }\r\n    return parsedPrefix.toString();\r\n}\n/**\r\n * Exception thrown when the {@link Constants} class is asked for\r\n * an invalid constant name.\r\n */\r\n@SuppressWarnings(\"serial\")\r\npublic static class ConstantException extends IllegalArgumentException {\r\n\r\n    /**\r\n     * Thrown when an invalid constant name is requested.\r\n     * @param className name of the class containing the constant definitions\r\n     * @param field invalid constant name\r\n     * @param message description of the problem\r\n     */\r\n    public ConstantException(String className, String field, String message) {\r\n        super(\"Field '\" + field + \"' \" + message + \" in class [\" + className + \"]\");\r\n    }\r\n\r\n    /**\r\n     * Thrown when an invalid constant value is looked up.\r\n     * @param className name of the class containing the constant definitions\r\n     * @param namePrefix prefix of the searched constant names\r\n     * @param value the looked up constant value\r\n     */\r\n    public ConstantException(String className, String namePrefix, Object value) {\r\n        super(\"No '\" + namePrefix + \"' field with value '\" + value + \"' found in class [\" + className + \"]\");\r\n    }\r\n}",
    "comment": "\n * This class can be used to parse other classes containing constant definitions\n * in public static final members. The {@code asXXXX} methods of this class\n * allow these constant values to be accessed via their string names.\n *\n * <p>Consider class Foo containing {@code public static final int CONSTANT1 = 66;}\n * An instance of this class wrapping {@code Foo.class} will return the constant value\n * of 66 from its {@code asNumber} method given the argument {@code \"CONSTANT1\"}.\n *\n * <p>This class is ideal for use in PropertyEditors, enabling them to\n * recognize the same names as the constants themselves, and freeing them\n * from maintaining their own mapping.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 16.03.2003\n * @deprecated since 6.1 with no replacement; use an enum, map, or similar custom\n * solution instead\n "
  },
  {
    "entityId": "org.springframework.core.Constants#getClassName()",
    "entityType": "method",
    "code": "/**\r\n * Return the name of the analyzed class.\r\n */\r\npublic final String getClassName() {\r\n    return this.className;\r\n}",
    "comment": "\n\t * Return the name of the analyzed class.\n\t "
  },
  {
    "entityId": "org.springframework.core.Constants#getSize()",
    "entityType": "method",
    "code": "/**\r\n * Return the number of constants exposed.\r\n */\r\npublic final int getSize() {\r\n    return this.fieldCache.size();\r\n}",
    "comment": "\n\t * Return the number of constants exposed.\n\t "
  },
  {
    "entityId": "org.springframework.core.Constants#getFieldCache()",
    "entityType": "method",
    "code": "/**\r\n * Exposes the field cache to subclasses:\r\n * a Map from String field name to object value.\r\n */\r\nprotected final Map<String, Object> getFieldCache() {\r\n    return this.fieldCache;\r\n}",
    "comment": "\n\t * Exposes the field cache to subclasses:\n\t * a Map from String field name to object value.\n\t "
  },
  {
    "entityId": "org.springframework.core.Constants#asNumber(String)",
    "entityType": "method",
    "code": "/**\r\n * Return a constant value cast to a Number.\r\n * @param code the name of the field (never {@code null})\r\n * @return the Number value\r\n * @throws ConstantException if the field name wasn't found\r\n * or if the type wasn't compatible with Number\r\n * @see #asObject\r\n */\r\npublic Number asNumber(String code) throws ConstantException {\r\n    Object obj = asObject(code);\r\n    if (!(obj instanceof Number number)) {\r\n        throw new ConstantException(this.className, code, \"not a Number\");\r\n    }\r\n    return number;\r\n}",
    "comment": "\n\t * Return a constant value cast to a Number.\n\t * @param code the name of the field (never {@code null})\n\t * @return the Number value\n\t * @throws ConstantException if the field name wasn't found\n\t * or if the type wasn't compatible with Number\n\t * @see #asObject\n\t "
  },
  {
    "entityId": "org.springframework.core.Constants#asString(String)",
    "entityType": "method",
    "code": "/**\r\n * Return a constant value as a String.\r\n * @param code the name of the field (never {@code null})\r\n * @return the String value\r\n * Works even if it's not a string (invokes {@code toString()}).\r\n * @throws ConstantException if the field name wasn't found\r\n * @see #asObject\r\n */\r\npublic String asString(String code) throws ConstantException {\r\n    return asObject(code).toString();\r\n}",
    "comment": "\n\t * Return a constant value as a String.\n\t * @param code the name of the field (never {@code null})\n\t * @return the String value\n\t * Works even if it's not a string (invokes {@code toString()}).\n\t * @throws ConstantException if the field name wasn't found\n\t * @see #asObject\n\t "
  },
  {
    "entityId": "org.springframework.core.Constants#asObject(String)",
    "entityType": "method",
    "code": "/**\r\n * Parse the given String (upper or lower case accepted) and return\r\n * the appropriate value if it's the name of a constant field in the\r\n * class that we're analyzing.\r\n * @param code the name of the field (never {@code null})\r\n * @return the Object value\r\n * @throws ConstantException if there's no such field\r\n */\r\npublic Object asObject(String code) throws ConstantException {\r\n    Assert.notNull(code, \"Code must not be null\");\r\n    String codeToUse = code.toUpperCase(Locale.ENGLISH);\r\n    Object val = this.fieldCache.get(codeToUse);\r\n    if (val == null) {\r\n        throw new ConstantException(this.className, codeToUse, \"not found\");\r\n    }\r\n    return val;\r\n}",
    "comment": "\n\t * Parse the given String (upper or lower case accepted) and return\n\t * the appropriate value if it's the name of a constant field in the\n\t * class that we're analyzing.\n\t * @param code the name of the field (never {@code null})\n\t * @return the Object value\n\t * @throws ConstantException if there's no such field\n\t "
  },
  {
    "entityId": "org.springframework.core.Constants#getNames(String)",
    "entityType": "method",
    "code": "/**\r\n * Return all names of the given group of constants.\r\n * <p>Note that this method assumes that constants are named\r\n * in accordance with the standard Java convention for constant\r\n * values (i.e. all uppercase). The supplied {@code namePrefix}\r\n * will be uppercased (in a locale-insensitive fashion) prior to\r\n * the main logic of this method kicking in.\r\n * @param namePrefix prefix of the constant names to search (may be {@code null})\r\n * @return the set of constant names\r\n */\r\npublic Set<String> getNames(@Nullable String namePrefix) {\r\n    String prefixToUse = (namePrefix != null ? namePrefix.trim().toUpperCase(Locale.ENGLISH) : \"\");\r\n    Set<String> names = new HashSet<>();\r\n    for (String code : this.fieldCache.keySet()) {\r\n        if (code.startsWith(prefixToUse)) {\r\n            names.add(code);\r\n        }\r\n    }\r\n    return names;\r\n}",
    "comment": "\n\t * Return all names of the given group of constants.\n\t * <p>Note that this method assumes that constants are named\n\t * in accordance with the standard Java convention for constant\n\t * values (i.e. all uppercase). The supplied {@code namePrefix}\n\t * will be uppercased (in a locale-insensitive fashion) prior to\n\t * the main logic of this method kicking in.\n\t * @param namePrefix prefix of the constant names to search (may be {@code null})\n\t * @return the set of constant names\n\t "
  },
  {
    "entityId": "org.springframework.core.Constants#getNamesForProperty(String)",
    "entityType": "method",
    "code": "/**\r\n * Return all names of the group of constants for the\r\n * given bean property name.\r\n * @param propertyName the name of the bean property\r\n * @return the set of values\r\n * @see #propertyToConstantNamePrefix\r\n */\r\npublic Set<String> getNamesForProperty(String propertyName) {\r\n    return getNames(propertyToConstantNamePrefix(propertyName));\r\n}",
    "comment": "\n\t * Return all names of the group of constants for the\n\t * given bean property name.\n\t * @param propertyName the name of the bean property\n\t * @return the set of values\n\t * @see #propertyToConstantNamePrefix\n\t "
  },
  {
    "entityId": "org.springframework.core.Constants#getNamesForSuffix(String)",
    "entityType": "method",
    "code": "/**\r\n * Return all names of the given group of constants.\r\n * <p>Note that this method assumes that constants are named\r\n * in accordance with the standard Java convention for constant\r\n * values (i.e. all uppercase). The supplied {@code nameSuffix}\r\n * will be uppercased (in a locale-insensitive fashion) prior to\r\n * the main logic of this method kicking in.\r\n * @param nameSuffix suffix of the constant names to search (may be {@code null})\r\n * @return the set of constant names\r\n */\r\npublic Set<String> getNamesForSuffix(@Nullable String nameSuffix) {\r\n    String suffixToUse = (nameSuffix != null ? nameSuffix.trim().toUpperCase(Locale.ENGLISH) : \"\");\r\n    Set<String> names = new HashSet<>();\r\n    for (String code : this.fieldCache.keySet()) {\r\n        if (code.endsWith(suffixToUse)) {\r\n            names.add(code);\r\n        }\r\n    }\r\n    return names;\r\n}",
    "comment": "\n\t * Return all names of the given group of constants.\n\t * <p>Note that this method assumes that constants are named\n\t * in accordance with the standard Java convention for constant\n\t * values (i.e. all uppercase). The supplied {@code nameSuffix}\n\t * will be uppercased (in a locale-insensitive fashion) prior to\n\t * the main logic of this method kicking in.\n\t * @param nameSuffix suffix of the constant names to search (may be {@code null})\n\t * @return the set of constant names\n\t "
  },
  {
    "entityId": "org.springframework.core.Constants#getValues(String)",
    "entityType": "method",
    "code": "/**\r\n * Return all values of the given group of constants.\r\n * <p>Note that this method assumes that constants are named\r\n * in accordance with the standard Java convention for constant\r\n * values (i.e. all uppercase). The supplied {@code namePrefix}\r\n * will be uppercased (in a locale-insensitive fashion) prior to\r\n * the main logic of this method kicking in.\r\n * @param namePrefix prefix of the constant names to search (may be {@code null})\r\n * @return the set of values\r\n */\r\npublic Set<Object> getValues(@Nullable String namePrefix) {\r\n    String prefixToUse = (namePrefix != null ? namePrefix.trim().toUpperCase(Locale.ENGLISH) : \"\");\r\n    Set<Object> values = new HashSet<>();\r\n    this.fieldCache.forEach((code, value) -> {\r\n        if (code.startsWith(prefixToUse)) {\r\n            values.add(value);\r\n        }\r\n    });\r\n    return values;\r\n}",
    "comment": "\n\t * Return all values of the given group of constants.\n\t * <p>Note that this method assumes that constants are named\n\t * in accordance with the standard Java convention for constant\n\t * values (i.e. all uppercase). The supplied {@code namePrefix}\n\t * will be uppercased (in a locale-insensitive fashion) prior to\n\t * the main logic of this method kicking in.\n\t * @param namePrefix prefix of the constant names to search (may be {@code null})\n\t * @return the set of values\n\t "
  },
  {
    "entityId": "org.springframework.core.Constants#getValuesForProperty(String)",
    "entityType": "method",
    "code": "/**\r\n * Return all values of the group of constants for the\r\n * given bean property name.\r\n * @param propertyName the name of the bean property\r\n * @return the set of values\r\n * @see #propertyToConstantNamePrefix\r\n */\r\npublic Set<Object> getValuesForProperty(String propertyName) {\r\n    return getValues(propertyToConstantNamePrefix(propertyName));\r\n}",
    "comment": "\n\t * Return all values of the group of constants for the\n\t * given bean property name.\n\t * @param propertyName the name of the bean property\n\t * @return the set of values\n\t * @see #propertyToConstantNamePrefix\n\t "
  },
  {
    "entityId": "org.springframework.core.Constants#getValuesForSuffix(String)",
    "entityType": "method",
    "code": "/**\r\n * Return all values of the given group of constants.\r\n * <p>Note that this method assumes that constants are named\r\n * in accordance with the standard Java convention for constant\r\n * values (i.e. all uppercase). The supplied {@code nameSuffix}\r\n * will be uppercased (in a locale-insensitive fashion) prior to\r\n * the main logic of this method kicking in.\r\n * @param nameSuffix suffix of the constant names to search (may be {@code null})\r\n * @return the set of values\r\n */\r\npublic Set<Object> getValuesForSuffix(@Nullable String nameSuffix) {\r\n    String suffixToUse = (nameSuffix != null ? nameSuffix.trim().toUpperCase(Locale.ENGLISH) : \"\");\r\n    Set<Object> values = new HashSet<>();\r\n    this.fieldCache.forEach((code, value) -> {\r\n        if (code.endsWith(suffixToUse)) {\r\n            values.add(value);\r\n        }\r\n    });\r\n    return values;\r\n}",
    "comment": "\n\t * Return all values of the given group of constants.\n\t * <p>Note that this method assumes that constants are named\n\t * in accordance with the standard Java convention for constant\n\t * values (i.e. all uppercase). The supplied {@code nameSuffix}\n\t * will be uppercased (in a locale-insensitive fashion) prior to\n\t * the main logic of this method kicking in.\n\t * @param nameSuffix suffix of the constant names to search (may be {@code null})\n\t * @return the set of values\n\t "
  },
  {
    "entityId": "org.springframework.core.Constants#toCode(Object,String)",
    "entityType": "method",
    "code": "/**\r\n * Look up the given value within the given group of constants.\r\n * <p>Will return the first match.\r\n * @param value constant value to look up\r\n * @param namePrefix prefix of the constant names to search (may be {@code null})\r\n * @return the name of the constant field\r\n * @throws ConstantException if the value wasn't found\r\n */\r\npublic String toCode(Object value, @Nullable String namePrefix) throws ConstantException {\r\n    String prefixToUse = (namePrefix != null ? namePrefix.trim().toUpperCase(Locale.ENGLISH) : \"\");\r\n    for (Map.Entry<String, Object> entry : this.fieldCache.entrySet()) {\r\n        if (entry.getKey().startsWith(prefixToUse) && entry.getValue().equals(value)) {\r\n            return entry.getKey();\r\n        }\r\n    }\r\n    throw new ConstantException(this.className, prefixToUse, value);\r\n}",
    "comment": "\n\t * Look up the given value within the given group of constants.\n\t * <p>Will return the first match.\n\t * @param value constant value to look up\n\t * @param namePrefix prefix of the constant names to search (may be {@code null})\n\t * @return the name of the constant field\n\t * @throws ConstantException if the value wasn't found\n\t "
  },
  {
    "entityId": "org.springframework.core.Constants#toCodeForProperty(Object,String)",
    "entityType": "method",
    "code": "/**\r\n * Look up the given value within the group of constants for\r\n * the given bean property name. Will return the first match.\r\n * @param value constant value to look up\r\n * @param propertyName the name of the bean property\r\n * @return the name of the constant field\r\n * @throws ConstantException if the value wasn't found\r\n * @see #propertyToConstantNamePrefix\r\n */\r\npublic String toCodeForProperty(Object value, String propertyName) throws ConstantException {\r\n    return toCode(value, propertyToConstantNamePrefix(propertyName));\r\n}",
    "comment": "\n\t * Look up the given value within the group of constants for\n\t * the given bean property name. Will return the first match.\n\t * @param value constant value to look up\n\t * @param propertyName the name of the bean property\n\t * @return the name of the constant field\n\t * @throws ConstantException if the value wasn't found\n\t * @see #propertyToConstantNamePrefix\n\t "
  },
  {
    "entityId": "org.springframework.core.Constants#toCodeForSuffix(Object,String)",
    "entityType": "method",
    "code": "/**\r\n * Look up the given value within the given group of constants.\r\n * <p>Will return the first match.\r\n * @param value constant value to look up\r\n * @param nameSuffix suffix of the constant names to search (may be {@code null})\r\n * @return the name of the constant field\r\n * @throws ConstantException if the value wasn't found\r\n */\r\npublic String toCodeForSuffix(Object value, @Nullable String nameSuffix) throws ConstantException {\r\n    String suffixToUse = (nameSuffix != null ? nameSuffix.trim().toUpperCase(Locale.ENGLISH) : \"\");\r\n    for (Map.Entry<String, Object> entry : this.fieldCache.entrySet()) {\r\n        if (entry.getKey().endsWith(suffixToUse) && entry.getValue().equals(value)) {\r\n            return entry.getKey();\r\n        }\r\n    }\r\n    throw new ConstantException(this.className, suffixToUse, value);\r\n}",
    "comment": "\n\t * Look up the given value within the given group of constants.\n\t * <p>Will return the first match.\n\t * @param value constant value to look up\n\t * @param nameSuffix suffix of the constant names to search (may be {@code null})\n\t * @return the name of the constant field\n\t * @throws ConstantException if the value wasn't found\n\t "
  },
  {
    "entityId": "org.springframework.core.Constants#propertyToConstantNamePrefix(String)",
    "entityType": "method",
    "code": "/**\r\n * Convert the given bean property name to a constant name prefix.\r\n * <p>Uses a common naming idiom: turning all lower case characters to\r\n * upper case, and prepending upper case characters with an underscore.\r\n * <p>Example: \"imageSize\" &rarr; \"IMAGE_SIZE\"<br>\r\n * Example: \"imagesize\" &rarr; \"IMAGESIZE\".<br>\r\n * Example: \"ImageSize\" &rarr; \"_IMAGE_SIZE\".<br>\r\n * Example: \"IMAGESIZE\" &rarr; \"_I_M_A_G_E_S_I_Z_E\"\r\n * @param propertyName the name of the bean property\r\n * @return the corresponding constant name prefix\r\n * @see #getValuesForProperty\r\n * @see #toCodeForProperty\r\n */\r\npublic String propertyToConstantNamePrefix(String propertyName) {\r\n    StringBuilder parsedPrefix = new StringBuilder();\r\n    for (int i = 0; i < propertyName.length(); i++) {\r\n        char c = propertyName.charAt(i);\r\n        if (Character.isUpperCase(c)) {\r\n            parsedPrefix.append('_');\r\n            parsedPrefix.append(c);\r\n        } else {\r\n            parsedPrefix.append(Character.toUpperCase(c));\r\n        }\r\n    }\r\n    return parsedPrefix.toString();\r\n}",
    "comment": "\n\t * Convert the given bean property name to a constant name prefix.\n\t * <p>Uses a common naming idiom: turning all lower case characters to\n\t * upper case, and prepending upper case characters with an underscore.\n\t * <p>Example: \"imageSize\" &rarr; \"IMAGE_SIZE\"<br>\n\t * Example: \"imagesize\" &rarr; \"IMAGESIZE\".<br>\n\t * Example: \"ImageSize\" &rarr; \"_IMAGE_SIZE\".<br>\n\t * Example: \"IMAGESIZE\" &rarr; \"_I_M_A_G_E_S_I_Z_E\"\n\t * @param propertyName the name of the bean property\n\t * @return the corresponding constant name prefix\n\t * @see #getValuesForProperty\n\t * @see #toCodeForProperty\n\t "
  },
  {
    "entityId": "org.springframework.core.ConstantException",
    "entityType": "class",
    "code": "/**\r\n * Thrown when an invalid constant name is requested.\r\n * @param className name of the class containing the constant definitions\r\n * @param field invalid constant name\r\n * @param message description of the problem\r\n */\r\npublic ConstantException(String className, String field, String message) {\r\n    super(\"Field '\" + field + \"' \" + message + \" in class [\" + className + \"]\");\r\n}\n/**\r\n * Thrown when an invalid constant value is looked up.\r\n * @param className name of the class containing the constant definitions\r\n * @param namePrefix prefix of the searched constant names\r\n * @param value the looked up constant value\r\n */\r\npublic ConstantException(String className, String namePrefix, Object value) {\r\n    super(\"No '\" + namePrefix + \"' field with value '\" + value + \"' found in class [\" + className + \"]\");\r\n}",
    "comment": "\n\t * Exception thrown when the {@link Constants} class is asked for\n\t * an invalid constant name.\n\t "
  },
  {
    "entityId": "org.springframework.core.Conventions",
    "entityType": "class",
    "code": "/**\r\n * Suffix added to names when using arrays.\r\n */\r\nprivate static final String PLURAL_SUFFIX = \"List\";\nprivate Conventions() {\r\n}\n/**\r\n * Determine the conventional variable name for the supplied {@code Object}\r\n * based on its concrete type. The convention used is to return the\r\n * un-capitalized short name of the {@code Class}, according to JavaBeans\r\n * property naming rules.\r\n * <p>For example:<br>\r\n * {@code com.myapp.Product} becomes {@code \"product\"}<br>\r\n * {@code com.myapp.MyProduct} becomes {@code \"myProduct\"}<br>\r\n * {@code com.myapp.UKProduct} becomes {@code \"UKProduct\"}<br>\r\n * <p>For arrays the pluralized version of the array component type is used.\r\n * For {@code Collection}s an attempt is made to 'peek ahead' to determine\r\n * the component type and return its pluralized version.\r\n * @param value the value to generate a variable name for\r\n * @return the generated variable name\r\n */\r\npublic static String getVariableName(Object value) {\r\n    Assert.notNull(value, \"Value must not be null\");\r\n    Class<?> valueClass;\r\n    boolean pluralize = false;\r\n    if (value.getClass().isArray()) {\r\n        valueClass = value.getClass().componentType();\r\n        pluralize = true;\r\n    } else if (value instanceof Collection<?> collection) {\r\n        if (collection.isEmpty()) {\r\n            throw new IllegalArgumentException(\"Cannot generate variable name for an empty Collection\");\r\n        }\r\n        Object valueToCheck = peekAhead(collection);\r\n        valueClass = getClassForValue(valueToCheck);\r\n        pluralize = true;\r\n    } else {\r\n        valueClass = getClassForValue(value);\r\n    }\r\n    String name = ClassUtils.getShortNameAsProperty(valueClass);\r\n    return (pluralize ? pluralize(name) : name);\r\n}\n/**\r\n * Determine the conventional variable name for the given parameter taking\r\n * the generic collection type, if any, into account.\r\n * <p>As of 5.0 this method supports reactive types:<br>\r\n * {@code Mono<com.myapp.Product>} becomes {@code \"productMono\"}<br>\r\n * {@code Flux<com.myapp.MyProduct>} becomes {@code \"myProductFlux\"}<br>\r\n * {@code Observable<com.myapp.MyProduct>} becomes {@code \"myProductObservable\"}<br>\r\n * @param parameter the method or constructor parameter\r\n * @return the generated variable name\r\n */\r\npublic static String getVariableNameForParameter(MethodParameter parameter) {\r\n    Assert.notNull(parameter, \"MethodParameter must not be null\");\r\n    Class<?> valueClass;\r\n    boolean pluralize = false;\r\n    String reactiveSuffix = \"\";\r\n    if (parameter.getParameterType().isArray()) {\r\n        valueClass = parameter.getParameterType().componentType();\r\n        pluralize = true;\r\n    } else if (Collection.class.isAssignableFrom(parameter.getParameterType())) {\r\n        valueClass = ResolvableType.forMethodParameter(parameter).asCollection().resolveGeneric();\r\n        if (valueClass == null) {\r\n            throw new IllegalArgumentException(\"Cannot generate variable name for non-typed Collection parameter type\");\r\n        }\r\n        pluralize = true;\r\n    } else {\r\n        valueClass = parameter.getParameterType();\r\n        ReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(valueClass);\r\n        if (adapter != null && !adapter.getDescriptor().isNoValue()) {\r\n            reactiveSuffix = ClassUtils.getShortName(valueClass);\r\n            valueClass = parameter.nested().getNestedParameterType();\r\n        }\r\n    }\r\n    String name = ClassUtils.getShortNameAsProperty(valueClass);\r\n    return (pluralize ? pluralize(name) : name + reactiveSuffix);\r\n}\n/**\r\n * Determine the conventional variable name for the return type of the\r\n * given method, taking the generic collection type, if any, into account.\r\n * @param method the method to generate a variable name for\r\n * @return the generated variable name\r\n */\r\npublic static String getVariableNameForReturnType(Method method) {\r\n    return getVariableNameForReturnType(method, method.getReturnType(), null);\r\n}\n/**\r\n * Determine the conventional variable name for the return type of the given\r\n * method, taking the generic collection type, if any, into account, falling\r\n * back on the given actual return value if the method declaration is not\r\n * specific enough, for example, {@code Object} return type or untyped collection.\r\n * @param method the method to generate a variable name for\r\n * @param value the return value (may be {@code null} if not available)\r\n * @return the generated variable name\r\n */\r\npublic static String getVariableNameForReturnType(Method method, @Nullable Object value) {\r\n    return getVariableNameForReturnType(method, method.getReturnType(), value);\r\n}\n/**\r\n * Determine the conventional variable name for the return type of the given\r\n * method, taking the generic collection type, if any, into account, falling\r\n * back on the given return value if the method declaration is not specific\r\n * enough, for example, {@code Object} return type or untyped collection.\r\n * <p>As of 5.0 this method supports reactive types:<br>\r\n * {@code Mono<com.myapp.Product>} becomes {@code \"productMono\"}<br>\r\n * {@code Flux<com.myapp.MyProduct>} becomes {@code \"myProductFlux\"}<br>\r\n * {@code Observable<com.myapp.MyProduct>} becomes {@code \"myProductObservable\"}<br>\r\n * @param method the method to generate a variable name for\r\n * @param resolvedType the resolved return type of the method\r\n * @param value the return value (may be {@code null} if not available)\r\n * @return the generated variable name\r\n */\r\npublic static String getVariableNameForReturnType(Method method, Class<?> resolvedType, @Nullable Object value) {\r\n    Assert.notNull(method, \"Method must not be null\");\r\n    if (Object.class == resolvedType) {\r\n        Assert.notNull(value, \"Cannot generate variable name for an Object return type with null value\");\r\n        return getVariableName(value);\r\n    }\r\n    Class<?> valueClass;\r\n    boolean pluralize = false;\r\n    String reactiveSuffix = \"\";\r\n    if (resolvedType.isArray()) {\r\n        valueClass = resolvedType.componentType();\r\n        pluralize = true;\r\n    } else if (Collection.class.isAssignableFrom(resolvedType)) {\r\n        valueClass = ResolvableType.forMethodReturnType(method).asCollection().resolveGeneric();\r\n        if (valueClass == null) {\r\n            if (!(value instanceof Collection<?> collection)) {\r\n                throw new IllegalArgumentException(\"Cannot generate variable name \" + \"for non-typed Collection return type and a non-Collection value\");\r\n            }\r\n            if (collection.isEmpty()) {\r\n                throw new IllegalArgumentException(\"Cannot generate variable name \" + \"for non-typed Collection return type and an empty Collection value\");\r\n            }\r\n            Object valueToCheck = peekAhead(collection);\r\n            valueClass = getClassForValue(valueToCheck);\r\n        }\r\n        pluralize = true;\r\n    } else {\r\n        valueClass = resolvedType;\r\n        ReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(valueClass);\r\n        if (adapter != null && !adapter.getDescriptor().isNoValue()) {\r\n            reactiveSuffix = ClassUtils.getShortName(valueClass);\r\n            valueClass = ResolvableType.forMethodReturnType(method).getGeneric().toClass();\r\n        }\r\n    }\r\n    String name = ClassUtils.getShortNameAsProperty(valueClass);\r\n    return (pluralize ? pluralize(name) : name + reactiveSuffix);\r\n}\n/**\r\n * Convert {@code String}s in attribute name format (for example, lowercase, hyphens\r\n * separating words) into property name format (camel-case). For example\r\n * {@code transaction-manager} becomes {@code \"transactionManager\"}.\r\n */\r\npublic static String attributeNameToPropertyName(String attributeName) {\r\n    Assert.notNull(attributeName, \"'attributeName' must not be null\");\r\n    if (!attributeName.contains(\"-\")) {\r\n        return attributeName;\r\n    }\r\n    // not completely accurate but good guess\r\n    char[] result = new char[attributeName.length() - 1];\r\n    int currPos = 0;\r\n    boolean upperCaseNext = false;\r\n    for (int i = 0; i < attributeName.length(); i++) {\r\n        char c = attributeName.charAt(i);\r\n        if (c == '-') {\r\n            upperCaseNext = true;\r\n        } else if (upperCaseNext) {\r\n            result[currPos++] = Character.toUpperCase(c);\r\n            upperCaseNext = false;\r\n        } else {\r\n            result[currPos++] = c;\r\n        }\r\n    }\r\n    return new String(result, 0, currPos);\r\n}\n/**\r\n * Return an attribute name qualified by the given enclosing {@link Class}.\r\n * For example the attribute name '{@code foo}' qualified by {@link Class}\r\n * '{@code com.myapp.SomeClass}' would be '{@code com.myapp.SomeClass.foo}'\r\n */\r\npublic static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName) {\r\n    Assert.notNull(enclosingClass, \"'enclosingClass' must not be null\");\r\n    Assert.notNull(attributeName, \"'attributeName' must not be null\");\r\n    return enclosingClass.getName() + '.' + attributeName;\r\n}\n/**\r\n * Determine the class to use for naming a variable containing the given value.\r\n * <p>Will return the class of the given value, except when encountering a\r\n * JDK proxy, in which case it will determine the 'primary' interface\r\n * implemented by that proxy.\r\n * @param value the value to check\r\n * @return the class to use for naming a variable\r\n */\r\nprivate static Class<?> getClassForValue(Object value) {\r\n    Class<?> valueClass = value.getClass();\r\n    if (Proxy.isProxyClass(valueClass)) {\r\n        Class<?>[] ifcs = valueClass.getInterfaces();\r\n        for (Class<?> ifc : ifcs) {\r\n            if (!ClassUtils.isJavaLanguageInterface(ifc)) {\r\n                return ifc;\r\n            }\r\n        }\r\n    } else if (valueClass.getName().lastIndexOf('$') != -1 && valueClass.getDeclaringClass() == null) {\r\n        // '$' in the class name but no inner class -\r\n        // assuming it's a special subclass (for example, by OpenJPA)\r\n        valueClass = valueClass.getSuperclass();\r\n    }\r\n    return valueClass;\r\n}\n/**\r\n * Pluralize the given name.\r\n */\r\nprivate static String pluralize(String name) {\r\n    return name + PLURAL_SUFFIX;\r\n}\n/**\r\n * Retrieve the {@code Class} of an element in the {@code Collection}.\r\n * The exact element for which the {@code Class} is retrieved will depend\r\n * on the concrete {@code Collection} implementation.\r\n */\r\nprivate static <E> E peekAhead(Collection<E> collection) {\r\n    Iterator<E> it = collection.iterator();\r\n    if (!it.hasNext()) {\r\n        throw new IllegalStateException(\"Unable to peek ahead in non-empty collection - no element found\");\r\n    }\r\n    E value = it.next();\r\n    if (value == null) {\r\n        throw new IllegalStateException(\"Unable to peek ahead in non-empty collection - only null element found\");\r\n    }\r\n    return value;\r\n}",
    "comment": "\n * Provides methods to support various naming and other conventions used\n * throughout the framework. Mainly for internal use within the framework.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @author Rossen Stoyanchev\n * @since 2.0\n "
  },
  {
    "entityId": "org.springframework.core.Conventions#getVariableName(Object)",
    "entityType": "method",
    "code": "/**\r\n * Determine the conventional variable name for the supplied {@code Object}\r\n * based on its concrete type. The convention used is to return the\r\n * un-capitalized short name of the {@code Class}, according to JavaBeans\r\n * property naming rules.\r\n * <p>For example:<br>\r\n * {@code com.myapp.Product} becomes {@code \"product\"}<br>\r\n * {@code com.myapp.MyProduct} becomes {@code \"myProduct\"}<br>\r\n * {@code com.myapp.UKProduct} becomes {@code \"UKProduct\"}<br>\r\n * <p>For arrays the pluralized version of the array component type is used.\r\n * For {@code Collection}s an attempt is made to 'peek ahead' to determine\r\n * the component type and return its pluralized version.\r\n * @param value the value to generate a variable name for\r\n * @return the generated variable name\r\n */\r\npublic static String getVariableName(Object value) {\r\n    Assert.notNull(value, \"Value must not be null\");\r\n    Class<?> valueClass;\r\n    boolean pluralize = false;\r\n    if (value.getClass().isArray()) {\r\n        valueClass = value.getClass().componentType();\r\n        pluralize = true;\r\n    } else if (value instanceof Collection<?> collection) {\r\n        if (collection.isEmpty()) {\r\n            throw new IllegalArgumentException(\"Cannot generate variable name for an empty Collection\");\r\n        }\r\n        Object valueToCheck = peekAhead(collection);\r\n        valueClass = getClassForValue(valueToCheck);\r\n        pluralize = true;\r\n    } else {\r\n        valueClass = getClassForValue(value);\r\n    }\r\n    String name = ClassUtils.getShortNameAsProperty(valueClass);\r\n    return (pluralize ? pluralize(name) : name);\r\n}",
    "comment": "\n\t * Determine the conventional variable name for the supplied {@code Object}\n\t * based on its concrete type. The convention used is to return the\n\t * un-capitalized short name of the {@code Class}, according to JavaBeans\n\t * property naming rules.\n\t * <p>For example:<br>\n\t * {@code com.myapp.Product} becomes {@code \"product\"}<br>\n\t * {@code com.myapp.MyProduct} becomes {@code \"myProduct\"}<br>\n\t * {@code com.myapp.UKProduct} becomes {@code \"UKProduct\"}<br>\n\t * <p>For arrays the pluralized version of the array component type is used.\n\t * For {@code Collection}s an attempt is made to 'peek ahead' to determine\n\t * the component type and return its pluralized version.\n\t * @param value the value to generate a variable name for\n\t * @return the generated variable name\n\t "
  },
  {
    "entityId": "org.springframework.core.Conventions#getVariableNameForParameter(MethodParameter)",
    "entityType": "method",
    "code": "/**\r\n * Determine the conventional variable name for the given parameter taking\r\n * the generic collection type, if any, into account.\r\n * <p>As of 5.0 this method supports reactive types:<br>\r\n * {@code Mono<com.myapp.Product>} becomes {@code \"productMono\"}<br>\r\n * {@code Flux<com.myapp.MyProduct>} becomes {@code \"myProductFlux\"}<br>\r\n * {@code Observable<com.myapp.MyProduct>} becomes {@code \"myProductObservable\"}<br>\r\n * @param parameter the method or constructor parameter\r\n * @return the generated variable name\r\n */\r\npublic static String getVariableNameForParameter(MethodParameter parameter) {\r\n    Assert.notNull(parameter, \"MethodParameter must not be null\");\r\n    Class<?> valueClass;\r\n    boolean pluralize = false;\r\n    String reactiveSuffix = \"\";\r\n    if (parameter.getParameterType().isArray()) {\r\n        valueClass = parameter.getParameterType().componentType();\r\n        pluralize = true;\r\n    } else if (Collection.class.isAssignableFrom(parameter.getParameterType())) {\r\n        valueClass = ResolvableType.forMethodParameter(parameter).asCollection().resolveGeneric();\r\n        if (valueClass == null) {\r\n            throw new IllegalArgumentException(\"Cannot generate variable name for non-typed Collection parameter type\");\r\n        }\r\n        pluralize = true;\r\n    } else {\r\n        valueClass = parameter.getParameterType();\r\n        ReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(valueClass);\r\n        if (adapter != null && !adapter.getDescriptor().isNoValue()) {\r\n            reactiveSuffix = ClassUtils.getShortName(valueClass);\r\n            valueClass = parameter.nested().getNestedParameterType();\r\n        }\r\n    }\r\n    String name = ClassUtils.getShortNameAsProperty(valueClass);\r\n    return (pluralize ? pluralize(name) : name + reactiveSuffix);\r\n}",
    "comment": "\n\t * Determine the conventional variable name for the given parameter taking\n\t * the generic collection type, if any, into account.\n\t * <p>As of 5.0 this method supports reactive types:<br>\n\t * {@code Mono<com.myapp.Product>} becomes {@code \"productMono\"}<br>\n\t * {@code Flux<com.myapp.MyProduct>} becomes {@code \"myProductFlux\"}<br>\n\t * {@code Observable<com.myapp.MyProduct>} becomes {@code \"myProductObservable\"}<br>\n\t * @param parameter the method or constructor parameter\n\t * @return the generated variable name\n\t "
  },
  {
    "entityId": "org.springframework.core.Conventions#getVariableNameForReturnType(Method)",
    "entityType": "method",
    "code": "/**\r\n * Determine the conventional variable name for the return type of the\r\n * given method, taking the generic collection type, if any, into account.\r\n * @param method the method to generate a variable name for\r\n * @return the generated variable name\r\n */\r\npublic static String getVariableNameForReturnType(Method method) {\r\n    return getVariableNameForReturnType(method, method.getReturnType(), null);\r\n}",
    "comment": "\n\t * Determine the conventional variable name for the return type of the\n\t * given method, taking the generic collection type, if any, into account.\n\t * @param method the method to generate a variable name for\n\t * @return the generated variable name\n\t "
  },
  {
    "entityId": "org.springframework.core.Conventions#getVariableNameForReturnType(Method,Object)",
    "entityType": "method",
    "code": "/**\r\n * Determine the conventional variable name for the return type of the given\r\n * method, taking the generic collection type, if any, into account, falling\r\n * back on the given actual return value if the method declaration is not\r\n * specific enough, for example, {@code Object} return type or untyped collection.\r\n * @param method the method to generate a variable name for\r\n * @param value the return value (may be {@code null} if not available)\r\n * @return the generated variable name\r\n */\r\npublic static String getVariableNameForReturnType(Method method, @Nullable Object value) {\r\n    return getVariableNameForReturnType(method, method.getReturnType(), value);\r\n}",
    "comment": "\n\t * Determine the conventional variable name for the return type of the given\n\t * method, taking the generic collection type, if any, into account, falling\n\t * back on the given actual return value if the method declaration is not\n\t * specific enough, for example, {@code Object} return type or untyped collection.\n\t * @param method the method to generate a variable name for\n\t * @param value the return value (may be {@code null} if not available)\n\t * @return the generated variable name\n\t "
  },
  {
    "entityId": "org.springframework.core.Conventions#getVariableNameForReturnType(Method,Class<?>,Object)",
    "entityType": "method",
    "code": "/**\r\n * Determine the conventional variable name for the return type of the given\r\n * method, taking the generic collection type, if any, into account, falling\r\n * back on the given return value if the method declaration is not specific\r\n * enough, for example, {@code Object} return type or untyped collection.\r\n * <p>As of 5.0 this method supports reactive types:<br>\r\n * {@code Mono<com.myapp.Product>} becomes {@code \"productMono\"}<br>\r\n * {@code Flux<com.myapp.MyProduct>} becomes {@code \"myProductFlux\"}<br>\r\n * {@code Observable<com.myapp.MyProduct>} becomes {@code \"myProductObservable\"}<br>\r\n * @param method the method to generate a variable name for\r\n * @param resolvedType the resolved return type of the method\r\n * @param value the return value (may be {@code null} if not available)\r\n * @return the generated variable name\r\n */\r\npublic static String getVariableNameForReturnType(Method method, Class<?> resolvedType, @Nullable Object value) {\r\n    Assert.notNull(method, \"Method must not be null\");\r\n    if (Object.class == resolvedType) {\r\n        Assert.notNull(value, \"Cannot generate variable name for an Object return type with null value\");\r\n        return getVariableName(value);\r\n    }\r\n    Class<?> valueClass;\r\n    boolean pluralize = false;\r\n    String reactiveSuffix = \"\";\r\n    if (resolvedType.isArray()) {\r\n        valueClass = resolvedType.componentType();\r\n        pluralize = true;\r\n    } else if (Collection.class.isAssignableFrom(resolvedType)) {\r\n        valueClass = ResolvableType.forMethodReturnType(method).asCollection().resolveGeneric();\r\n        if (valueClass == null) {\r\n            if (!(value instanceof Collection<?> collection)) {\r\n                throw new IllegalArgumentException(\"Cannot generate variable name \" + \"for non-typed Collection return type and a non-Collection value\");\r\n            }\r\n            if (collection.isEmpty()) {\r\n                throw new IllegalArgumentException(\"Cannot generate variable name \" + \"for non-typed Collection return type and an empty Collection value\");\r\n            }\r\n            Object valueToCheck = peekAhead(collection);\r\n            valueClass = getClassForValue(valueToCheck);\r\n        }\r\n        pluralize = true;\r\n    } else {\r\n        valueClass = resolvedType;\r\n        ReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(valueClass);\r\n        if (adapter != null && !adapter.getDescriptor().isNoValue()) {\r\n            reactiveSuffix = ClassUtils.getShortName(valueClass);\r\n            valueClass = ResolvableType.forMethodReturnType(method).getGeneric().toClass();\r\n        }\r\n    }\r\n    String name = ClassUtils.getShortNameAsProperty(valueClass);\r\n    return (pluralize ? pluralize(name) : name + reactiveSuffix);\r\n}",
    "comment": "\n\t * Determine the conventional variable name for the return type of the given\n\t * method, taking the generic collection type, if any, into account, falling\n\t * back on the given return value if the method declaration is not specific\n\t * enough, for example, {@code Object} return type or untyped collection.\n\t * <p>As of 5.0 this method supports reactive types:<br>\n\t * {@code Mono<com.myapp.Product>} becomes {@code \"productMono\"}<br>\n\t * {@code Flux<com.myapp.MyProduct>} becomes {@code \"myProductFlux\"}<br>\n\t * {@code Observable<com.myapp.MyProduct>} becomes {@code \"myProductObservable\"}<br>\n\t * @param method the method to generate a variable name for\n\t * @param resolvedType the resolved return type of the method\n\t * @param value the return value (may be {@code null} if not available)\n\t * @return the generated variable name\n\t "
  },
  {
    "entityId": "org.springframework.core.Conventions#attributeNameToPropertyName(String)",
    "entityType": "method",
    "code": "/**\r\n * Convert {@code String}s in attribute name format (for example, lowercase, hyphens\r\n * separating words) into property name format (camel-case). For example\r\n * {@code transaction-manager} becomes {@code \"transactionManager\"}.\r\n */\r\npublic static String attributeNameToPropertyName(String attributeName) {\r\n    Assert.notNull(attributeName, \"'attributeName' must not be null\");\r\n    if (!attributeName.contains(\"-\")) {\r\n        return attributeName;\r\n    }\r\n    // not completely accurate but good guess\r\n    char[] result = new char[attributeName.length() - 1];\r\n    int currPos = 0;\r\n    boolean upperCaseNext = false;\r\n    for (int i = 0; i < attributeName.length(); i++) {\r\n        char c = attributeName.charAt(i);\r\n        if (c == '-') {\r\n            upperCaseNext = true;\r\n        } else if (upperCaseNext) {\r\n            result[currPos++] = Character.toUpperCase(c);\r\n            upperCaseNext = false;\r\n        } else {\r\n            result[currPos++] = c;\r\n        }\r\n    }\r\n    return new String(result, 0, currPos);\r\n}",
    "comment": "\n\t * Convert {@code String}s in attribute name format (for example, lowercase, hyphens\n\t * separating words) into property name format (camel-case). For example\n\t * {@code transaction-manager} becomes {@code \"transactionManager\"}.\n\t "
  },
  {
    "entityId": "org.springframework.core.Conventions#getQualifiedAttributeName(Class<?>,String)",
    "entityType": "method",
    "code": "/**\r\n * Return an attribute name qualified by the given enclosing {@link Class}.\r\n * For example the attribute name '{@code foo}' qualified by {@link Class}\r\n * '{@code com.myapp.SomeClass}' would be '{@code com.myapp.SomeClass.foo}'\r\n */\r\npublic static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName) {\r\n    Assert.notNull(enclosingClass, \"'enclosingClass' must not be null\");\r\n    Assert.notNull(attributeName, \"'attributeName' must not be null\");\r\n    return enclosingClass.getName() + '.' + attributeName;\r\n}",
    "comment": "\n\t * Return an attribute name qualified by the given enclosing {@link Class}.\n\t * For example the attribute name '{@code foo}' qualified by {@link Class}\n\t * '{@code com.myapp.SomeClass}' would be '{@code com.myapp.SomeClass.foo}'\n\t "
  },
  {
    "entityId": "org.springframework.core.Conventions#getClassForValue(Object)",
    "entityType": "method",
    "code": "/**\r\n * Determine the class to use for naming a variable containing the given value.\r\n * <p>Will return the class of the given value, except when encountering a\r\n * JDK proxy, in which case it will determine the 'primary' interface\r\n * implemented by that proxy.\r\n * @param value the value to check\r\n * @return the class to use for naming a variable\r\n */\r\nprivate static Class<?> getClassForValue(Object value) {\r\n    Class<?> valueClass = value.getClass();\r\n    if (Proxy.isProxyClass(valueClass)) {\r\n        Class<?>[] ifcs = valueClass.getInterfaces();\r\n        for (Class<?> ifc : ifcs) {\r\n            if (!ClassUtils.isJavaLanguageInterface(ifc)) {\r\n                return ifc;\r\n            }\r\n        }\r\n    } else if (valueClass.getName().lastIndexOf('$') != -1 && valueClass.getDeclaringClass() == null) {\r\n        // '$' in the class name but no inner class -\r\n        // assuming it's a special subclass (for example, by OpenJPA)\r\n        valueClass = valueClass.getSuperclass();\r\n    }\r\n    return valueClass;\r\n}",
    "comment": "\n\t * Determine the class to use for naming a variable containing the given value.\n\t * <p>Will return the class of the given value, except when encountering a\n\t * JDK proxy, in which case it will determine the 'primary' interface\n\t * implemented by that proxy.\n\t * @param value the value to check\n\t * @return the class to use for naming a variable\n\t "
  },
  {
    "entityId": "org.springframework.core.Conventions#pluralize(String)",
    "entityType": "method",
    "code": "/**\r\n * Pluralize the given name.\r\n */\r\nprivate static String pluralize(String name) {\r\n    return name + PLURAL_SUFFIX;\r\n}",
    "comment": "\n\t * Pluralize the given name.\n\t "
  },
  {
    "entityId": "org.springframework.core.Conventions#peekAhead(Collection<E>)",
    "entityType": "method",
    "code": "/**\r\n * Retrieve the {@code Class} of an element in the {@code Collection}.\r\n * The exact element for which the {@code Class} is retrieved will depend\r\n * on the concrete {@code Collection} implementation.\r\n */\r\nprivate static <E> E peekAhead(Collection<E> collection) {\r\n    Iterator<E> it = collection.iterator();\r\n    if (!it.hasNext()) {\r\n        throw new IllegalStateException(\"Unable to peek ahead in non-empty collection - no element found\");\r\n    }\r\n    E value = it.next();\r\n    if (value == null) {\r\n        throw new IllegalStateException(\"Unable to peek ahead in non-empty collection - only null element found\");\r\n    }\r\n    return value;\r\n}",
    "comment": "\n\t * Retrieve the {@code Class} of an element in the {@code Collection}.\n\t * The exact element for which the {@code Class} is retrieved will depend\n\t * on the concrete {@code Collection} implementation.\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.ConversionException",
    "entityType": "class",
    "code": "/**\r\n * Construct a new conversion exception.\r\n * @param message the exception message\r\n */\r\npublic ConversionException(String message) {\r\n    super(message);\r\n}\n/**\r\n * Construct a new conversion exception.\r\n * @param message the exception message\r\n * @param cause the cause\r\n */\r\npublic ConversionException(String message, Throwable cause) {\r\n    super(message, cause);\r\n}",
    "comment": "\n * Base class for exceptions thrown by the conversion system.\n *\n * @author Keith Donald\n * @since 3.0\n "
  },
  {
    "entityId": "org.springframework.core.convert.ConversionFailedException",
    "entityType": "class",
    "code": "@Nullable\r\nprivate final TypeDescriptor sourceType;\nprivate final TypeDescriptor targetType;\n@Nullable\r\nprivate final Object value;\n/**\r\n * Create a new conversion exception.\r\n * @param sourceType the value's original type\r\n * @param targetType the value's target type\r\n * @param value the value we tried to convert\r\n * @param cause the cause of the conversion failure\r\n */\r\npublic ConversionFailedException(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType, @Nullable Object value, Throwable cause) {\r\n    super(\"Failed to convert from type [\" + sourceType + \"] to type [\" + targetType + \"] for value [\" + ObjectUtils.nullSafeConciseToString(value) + \"]\", cause);\r\n    this.sourceType = sourceType;\r\n    this.targetType = targetType;\r\n    this.value = value;\r\n}\n/**\r\n * Return the source type we tried to convert the value from.\r\n */\r\n@Nullable\r\npublic TypeDescriptor getSourceType() {\r\n    return this.sourceType;\r\n}\n/**\r\n * Return the target type we tried to convert the value to.\r\n */\r\npublic TypeDescriptor getTargetType() {\r\n    return this.targetType;\r\n}\n/**\r\n * Return the offending value.\r\n */\r\n@Nullable\r\npublic Object getValue() {\r\n    return this.value;\r\n}",
    "comment": "\n * Exception to be thrown when an actual type conversion attempt fails.\n *\n * @author Keith Donald\n * @author Juergen Hoeller\n * @since 3.0\n "
  },
  {
    "entityId": "org.springframework.core.convert.ConversionFailedException#getSourceType()",
    "entityType": "method",
    "code": "/**\r\n * Return the source type we tried to convert the value from.\r\n */\r\n@Nullable\r\npublic TypeDescriptor getSourceType() {\r\n    return this.sourceType;\r\n}",
    "comment": "\n\t * Return the source type we tried to convert the value from.\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.ConversionFailedException#getTargetType()",
    "entityType": "method",
    "code": "/**\r\n * Return the target type we tried to convert the value to.\r\n */\r\npublic TypeDescriptor getTargetType() {\r\n    return this.targetType;\r\n}",
    "comment": "\n\t * Return the target type we tried to convert the value to.\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.ConversionFailedException#getValue()",
    "entityType": "method",
    "code": "/**\r\n * Return the offending value.\r\n */\r\n@Nullable\r\npublic Object getValue() {\r\n    return this.value;\r\n}",
    "comment": "\n\t * Return the offending value.\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.ConversionService",
    "entityType": "class",
    "code": "/**\r\n * Return {@code true} if objects of {@code sourceType} can be converted to the {@code targetType}.\r\n * <p>If this method returns {@code true}, it means {@link #convert(Object, Class)} is capable\r\n * of converting an instance of {@code sourceType} to {@code targetType}.\r\n * <p>Special note on collections, arrays, and maps types:\r\n * For conversion between collection, array, and map types, this method will return {@code true}\r\n * even though a convert invocation may still generate a {@link ConversionException} if the\r\n * underlying elements are not convertible. Callers are expected to handle this exceptional case\r\n * when working with collections and maps.\r\n * @param sourceType the source type to convert from (may be {@code null} if source is {@code null})\r\n * @param targetType the target type to convert to (required)\r\n * @return {@code true} if a conversion can be performed, {@code false} if not\r\n * @throws IllegalArgumentException if {@code targetType} is {@code null}\r\n */\r\nboolean canConvert(@Nullable Class<?> sourceType, Class<?> targetType);\n/**\r\n * Return {@code true} if objects of {@code sourceType} can be converted to the {@code targetType}.\r\n * The TypeDescriptors provide additional context about the source and target locations\r\n * where conversion would occur, often object fields or property locations.\r\n * <p>If this method returns {@code true}, it means {@link #convert(Object, TypeDescriptor, TypeDescriptor)}\r\n * is capable of converting an instance of {@code sourceType} to {@code targetType}.\r\n * <p>Special note on collections, arrays, and maps types:\r\n * For conversion between collection, array, and map types, this method will return {@code true}\r\n * even though a convert invocation may still generate a {@link ConversionException} if the\r\n * underlying elements are not convertible. Callers are expected to handle this exceptional case\r\n * when working with collections and maps.\r\n * @param sourceType context about the source type to convert from\r\n * (may be {@code null} if source is {@code null})\r\n * @param targetType context about the target type to convert to (required)\r\n * @return {@code true} if a conversion can be performed between the source and target types,\r\n * {@code false} if not\r\n * @throws IllegalArgumentException if {@code targetType} is {@code null}\r\n */\r\nboolean canConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType);\n/**\r\n * Convert the given {@code source} to the specified {@code targetType}.\r\n * @param source the source object to convert (may be {@code null})\r\n * @param targetType the target type to convert to (required)\r\n * @return the converted object, an instance of targetType\r\n * @throws ConversionException if a conversion exception occurred\r\n * @throws IllegalArgumentException if targetType is {@code null}\r\n */\r\n@Nullable\r\n<T> T convert(@Nullable Object source, Class<T> targetType);\n/**\r\n * Convert the given {@code source} to the specified {@code targetType}.\r\n * <p>Delegates to {@link #convert(Object, TypeDescriptor, TypeDescriptor)}\r\n * and encapsulates the construction of the source type descriptor using\r\n * {@link TypeDescriptor#forObject(Object)}.\r\n * @param source the source object\r\n * @param targetType the target type\r\n * @return the converted value\r\n * @throws ConversionException if a conversion exception occurred\r\n * @throws IllegalArgumentException if targetType is {@code null}\r\n * @since 6.1\r\n */\r\n@Nullable\r\ndefault Object convert(@Nullable Object source, TypeDescriptor targetType) {\r\n    return convert(source, TypeDescriptor.forObject(source), targetType);\r\n}\n/**\r\n * Convert the given {@code source} to the specified {@code targetType}.\r\n * The TypeDescriptors provide additional context about the source and target locations\r\n * where conversion will occur, often object fields or property locations.\r\n * @param source the source object to convert (may be {@code null})\r\n * @param sourceType context about the source type to convert from\r\n * (may be {@code null} if source is {@code null})\r\n * @param targetType context about the target type to convert to (required)\r\n * @return the converted object, an instance of {@link TypeDescriptor#getObjectType() targetType}\r\n * @throws ConversionException if a conversion exception occurred\r\n * @throws IllegalArgumentException if targetType is {@code null},\r\n * or {@code sourceType} is {@code null} but source is not {@code null}\r\n */\r\n@Nullable\r\nObject convert(@Nullable Object source, @Nullable TypeDescriptor sourceType, TypeDescriptor targetType);",
    "comment": "\n * A service interface for type conversion. This is the entry point into the convert system.\n * Call {@link #convert(Object, Class)} to perform a thread-safe type conversion using this system.\n *\n * @author Keith Donald\n * @author Phillip Webb\n * @since 3.0\n "
  },
  {
    "entityId": "org.springframework.core.convert.ConversionService#canConvert(Class<?>,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return {@code true} if objects of {@code sourceType} can be converted to the {@code targetType}.\r\n * <p>If this method returns {@code true}, it means {@link #convert(Object, Class)} is capable\r\n * of converting an instance of {@code sourceType} to {@code targetType}.\r\n * <p>Special note on collections, arrays, and maps types:\r\n * For conversion between collection, array, and map types, this method will return {@code true}\r\n * even though a convert invocation may still generate a {@link ConversionException} if the\r\n * underlying elements are not convertible. Callers are expected to handle this exceptional case\r\n * when working with collections and maps.\r\n * @param sourceType the source type to convert from (may be {@code null} if source is {@code null})\r\n * @param targetType the target type to convert to (required)\r\n * @return {@code true} if a conversion can be performed, {@code false} if not\r\n * @throws IllegalArgumentException if {@code targetType} is {@code null}\r\n */\r\nboolean canConvert(@Nullable Class<?> sourceType, Class<?> targetType);",
    "comment": "\n\t * Return {@code true} if objects of {@code sourceType} can be converted to the {@code targetType}.\n\t * <p>If this method returns {@code true}, it means {@link #convert(Object, Class)} is capable\n\t * of converting an instance of {@code sourceType} to {@code targetType}.\n\t * <p>Special note on collections, arrays, and maps types:\n\t * For conversion between collection, array, and map types, this method will return {@code true}\n\t * even though a convert invocation may still generate a {@link ConversionException} if the\n\t * underlying elements are not convertible. Callers are expected to handle this exceptional case\n\t * when working with collections and maps.\n\t * @param sourceType the source type to convert from (may be {@code null} if source is {@code null})\n\t * @param targetType the target type to convert to (required)\n\t * @return {@code true} if a conversion can be performed, {@code false} if not\n\t * @throws IllegalArgumentException if {@code targetType} is {@code null}\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.ConversionService#canConvert(TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "/**\r\n * Return {@code true} if objects of {@code sourceType} can be converted to the {@code targetType}.\r\n * The TypeDescriptors provide additional context about the source and target locations\r\n * where conversion would occur, often object fields or property locations.\r\n * <p>If this method returns {@code true}, it means {@link #convert(Object, TypeDescriptor, TypeDescriptor)}\r\n * is capable of converting an instance of {@code sourceType} to {@code targetType}.\r\n * <p>Special note on collections, arrays, and maps types:\r\n * For conversion between collection, array, and map types, this method will return {@code true}\r\n * even though a convert invocation may still generate a {@link ConversionException} if the\r\n * underlying elements are not convertible. Callers are expected to handle this exceptional case\r\n * when working with collections and maps.\r\n * @param sourceType context about the source type to convert from\r\n * (may be {@code null} if source is {@code null})\r\n * @param targetType context about the target type to convert to (required)\r\n * @return {@code true} if a conversion can be performed between the source and target types,\r\n * {@code false} if not\r\n * @throws IllegalArgumentException if {@code targetType} is {@code null}\r\n */\r\nboolean canConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType);",
    "comment": "\n\t * Return {@code true} if objects of {@code sourceType} can be converted to the {@code targetType}.\n\t * The TypeDescriptors provide additional context about the source and target locations\n\t * where conversion would occur, often object fields or property locations.\n\t * <p>If this method returns {@code true}, it means {@link #convert(Object, TypeDescriptor, TypeDescriptor)}\n\t * is capable of converting an instance of {@code sourceType} to {@code targetType}.\n\t * <p>Special note on collections, arrays, and maps types:\n\t * For conversion between collection, array, and map types, this method will return {@code true}\n\t * even though a convert invocation may still generate a {@link ConversionException} if the\n\t * underlying elements are not convertible. Callers are expected to handle this exceptional case\n\t * when working with collections and maps.\n\t * @param sourceType context about the source type to convert from\n\t * (may be {@code null} if source is {@code null})\n\t * @param targetType context about the target type to convert to (required)\n\t * @return {@code true} if a conversion can be performed between the source and target types,\n\t * {@code false} if not\n\t * @throws IllegalArgumentException if {@code targetType} is {@code null}\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.ConversionService#convert(Object,Class<T>)",
    "entityType": "method",
    "code": "/**\r\n * Convert the given {@code source} to the specified {@code targetType}.\r\n * @param source the source object to convert (may be {@code null})\r\n * @param targetType the target type to convert to (required)\r\n * @return the converted object, an instance of targetType\r\n * @throws ConversionException if a conversion exception occurred\r\n * @throws IllegalArgumentException if targetType is {@code null}\r\n */\r\n@Nullable\r\n<T> T convert(@Nullable Object source, Class<T> targetType);",
    "comment": "\n\t * Convert the given {@code source} to the specified {@code targetType}.\n\t * @param source the source object to convert (may be {@code null})\n\t * @param targetType the target type to convert to (required)\n\t * @return the converted object, an instance of targetType\n\t * @throws ConversionException if a conversion exception occurred\n\t * @throws IllegalArgumentException if targetType is {@code null}\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.ConversionService#convert(Object,TypeDescriptor)",
    "entityType": "method",
    "code": "/**\r\n * Convert the given {@code source} to the specified {@code targetType}.\r\n * <p>Delegates to {@link #convert(Object, TypeDescriptor, TypeDescriptor)}\r\n * and encapsulates the construction of the source type descriptor using\r\n * {@link TypeDescriptor#forObject(Object)}.\r\n * @param source the source object\r\n * @param targetType the target type\r\n * @return the converted value\r\n * @throws ConversionException if a conversion exception occurred\r\n * @throws IllegalArgumentException if targetType is {@code null}\r\n * @since 6.1\r\n */\r\n@Nullable\r\ndefault Object convert(@Nullable Object source, TypeDescriptor targetType) {\r\n    return convert(source, TypeDescriptor.forObject(source), targetType);\r\n}",
    "comment": "\n\t * Convert the given {@code source} to the specified {@code targetType}.\n\t * <p>Delegates to {@link #convert(Object, TypeDescriptor, TypeDescriptor)}\n\t * and encapsulates the construction of the source type descriptor using\n\t * {@link TypeDescriptor#forObject(Object)}.\n\t * @param source the source object\n\t * @param targetType the target type\n\t * @return the converted value\n\t * @throws ConversionException if a conversion exception occurred\n\t * @throws IllegalArgumentException if targetType is {@code null}\n\t * @since 6.1\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.ConversionService#convert(Object,TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "/**\r\n * Convert the given {@code source} to the specified {@code targetType}.\r\n * The TypeDescriptors provide additional context about the source and target locations\r\n * where conversion will occur, often object fields or property locations.\r\n * @param source the source object to convert (may be {@code null})\r\n * @param sourceType context about the source type to convert from\r\n * (may be {@code null} if source is {@code null})\r\n * @param targetType context about the target type to convert to (required)\r\n * @return the converted object, an instance of {@link TypeDescriptor#getObjectType() targetType}\r\n * @throws ConversionException if a conversion exception occurred\r\n * @throws IllegalArgumentException if targetType is {@code null},\r\n * or {@code sourceType} is {@code null} but source is not {@code null}\r\n */\r\n@Nullable\r\nObject convert(@Nullable Object source, @Nullable TypeDescriptor sourceType, TypeDescriptor targetType);",
    "comment": "\n\t * Convert the given {@code source} to the specified {@code targetType}.\n\t * The TypeDescriptors provide additional context about the source and target locations\n\t * where conversion will occur, often object fields or property locations.\n\t * @param source the source object to convert (may be {@code null})\n\t * @param sourceType context about the source type to convert from\n\t * (may be {@code null} if source is {@code null})\n\t * @param targetType context about the target type to convert to (required)\n\t * @return the converted object, an instance of {@link TypeDescriptor#getObjectType() targetType}\n\t * @throws ConversionException if a conversion exception occurred\n\t * @throws IllegalArgumentException if targetType is {@code null},\n\t * or {@code sourceType} is {@code null} but source is not {@code null}\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.converter.ConditionalConverter",
    "entityType": "class",
    "code": "/**\r\n * Should the conversion from {@code sourceType} to {@code targetType} currently under\r\n * consideration be selected?\r\n * @param sourceType the type descriptor of the field we are converting from\r\n * @param targetType the type descriptor of the field we are converting to\r\n * @return true if conversion should be performed, false otherwise\r\n */\r\nboolean matches(TypeDescriptor sourceType, TypeDescriptor targetType);",
    "comment": "\n * Allows a {@link Converter}, {@link GenericConverter} or {@link ConverterFactory} to\n * conditionally execute based on attributes of the {@code source} and {@code target}\n * {@link TypeDescriptor}.\n *\n * <p>Often used to selectively match custom conversion logic based on the presence of a\n * field or class-level characteristic, such as an annotation or method. For example, when\n * converting from a String field to a Date field, an implementation might return\n * {@code true} if the target field has also been annotated with {@code @DateTimeFormat}.\n *\n * <p>As another example, when converting from a String field to an {@code Account} field,\n * an implementation might return {@code true} if the target Account class defines a\n * {@code public static findAccount(String)} method.\n *\n * @author Phillip Webb\n * @author Keith Donald\n * @since 3.2\n * @see Converter\n * @see GenericConverter\n * @see ConverterFactory\n * @see ConditionalGenericConverter\n "
  },
  {
    "entityId": "org.springframework.core.convert.converter.ConditionalConverter#matches(TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "/**\r\n * Should the conversion from {@code sourceType} to {@code targetType} currently under\r\n * consideration be selected?\r\n * @param sourceType the type descriptor of the field we are converting from\r\n * @param targetType the type descriptor of the field we are converting to\r\n * @return true if conversion should be performed, false otherwise\r\n */\r\nboolean matches(TypeDescriptor sourceType, TypeDescriptor targetType);",
    "comment": "\n\t * Should the conversion from {@code sourceType} to {@code targetType} currently under\n\t * consideration be selected?\n\t * @param sourceType the type descriptor of the field we are converting from\n\t * @param targetType the type descriptor of the field we are converting to\n\t * @return true if conversion should be performed, false otherwise\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.converter.ConditionalGenericConverter",
    "entityType": "class",
    "code": "",
    "comment": "\n * A {@link GenericConverter} that may conditionally execute based on attributes\n * of the {@code source} and {@code target} {@link TypeDescriptor}.\n *\n * <p>See {@link ConditionalConverter} for details.\n *\n * @author Keith Donald\n * @author Phillip Webb\n * @since 3.0\n * @see GenericConverter\n * @see ConditionalConverter\n "
  },
  {
    "entityId": "org.springframework.core.convert.converter.Converter",
    "entityType": "class",
    "code": "/**\r\n * Convert the source object of type {@code S} to target type {@code T}.\r\n * @param source the source object to convert, which must be an instance of {@code S} (never {@code null})\r\n * @return the converted object, which must be an instance of {@code T} (potentially {@code null})\r\n * @throws IllegalArgumentException if the source cannot be converted to the desired target type\r\n */\r\n@Nullable\r\nT convert(S source);\n/**\r\n * Construct a composed {@link Converter} that first applies this {@link Converter}\r\n * to its input, and then applies the {@code after} {@link Converter} to the\r\n * result.\r\n * @param after the {@link Converter} to apply after this {@link Converter}\r\n * is applied\r\n * @param <U> the type of output of both the {@code after} {@link Converter}\r\n * and the composed {@link Converter}\r\n * @return a composed {@link Converter} that first applies this {@link Converter}\r\n * and then applies the {@code after} {@link Converter}\r\n * @since 5.3\r\n */\r\ndefault <U> Converter<S, U> andThen(Converter<? super T, ? extends U> after) {\r\n    Assert.notNull(after, \"'after' Converter must not be null\");\r\n    return (S s) -> {\r\n        T initialResult = convert(s);\r\n        return (initialResult != null ? after.convert(initialResult) : null);\r\n    };\r\n}",
    "comment": "\n * A converter converts a source object of type {@code S} to a target of type {@code T}.\n *\n * <p>Implementations of this interface are thread-safe and can be shared.\n *\n * <p>Implementations may additionally implement {@link ConditionalConverter}.\n *\n * @author Keith Donald\n * @author Josh Cummings\n * @since 3.0\n * @param <S> the source type\n * @param <T> the target type\n "
  },
  {
    "entityId": "org.springframework.core.convert.converter.Converter#convert(S)",
    "entityType": "method",
    "code": "/**\r\n * Convert the source object of type {@code S} to target type {@code T}.\r\n * @param source the source object to convert, which must be an instance of {@code S} (never {@code null})\r\n * @return the converted object, which must be an instance of {@code T} (potentially {@code null})\r\n * @throws IllegalArgumentException if the source cannot be converted to the desired target type\r\n */\r\n@Nullable\r\nT convert(S source);",
    "comment": "\n\t * Convert the source object of type {@code S} to target type {@code T}.\n\t * @param source the source object to convert, which must be an instance of {@code S} (never {@code null})\n\t * @return the converted object, which must be an instance of {@code T} (potentially {@code null})\n\t * @throws IllegalArgumentException if the source cannot be converted to the desired target type\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.converter.Converter#andThen(Converter<? super T,? extends U>)",
    "entityType": "method",
    "code": "/**\r\n * Construct a composed {@link Converter} that first applies this {@link Converter}\r\n * to its input, and then applies the {@code after} {@link Converter} to the\r\n * result.\r\n * @param after the {@link Converter} to apply after this {@link Converter}\r\n * is applied\r\n * @param <U> the type of output of both the {@code after} {@link Converter}\r\n * and the composed {@link Converter}\r\n * @return a composed {@link Converter} that first applies this {@link Converter}\r\n * and then applies the {@code after} {@link Converter}\r\n * @since 5.3\r\n */\r\ndefault <U> Converter<S, U> andThen(Converter<? super T, ? extends U> after) {\r\n    Assert.notNull(after, \"'after' Converter must not be null\");\r\n    return (S s) -> {\r\n        T initialResult = convert(s);\r\n        return (initialResult != null ? after.convert(initialResult) : null);\r\n    };\r\n}",
    "comment": "\n\t * Construct a composed {@link Converter} that first applies this {@link Converter}\n\t * to its input, and then applies the {@code after} {@link Converter} to the\n\t * result.\n\t * @param after the {@link Converter} to apply after this {@link Converter}\n\t * is applied\n\t * @param <U> the type of output of both the {@code after} {@link Converter}\n\t * and the composed {@link Converter}\n\t * @return a composed {@link Converter} that first applies this {@link Converter}\n\t * and then applies the {@code after} {@link Converter}\n\t * @since 5.3\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.converter.ConverterFactory",
    "entityType": "class",
    "code": "/**\r\n * Get the converter to convert from S to target type T, where T is also an instance of R.\r\n * @param <T> the target type\r\n * @param targetType the target type to convert to\r\n * @return a converter from S to T\r\n */\r\n<T extends R> Converter<S, T> getConverter(Class<T> targetType);",
    "comment": "\n * A factory for \"ranged\" converters that can convert objects from S to subtypes of R.\n *\n * <p>Implementations may additionally implement {@link ConditionalConverter}.\n *\n * @author Keith Donald\n * @since 3.0\n * @param <S> the source type converters created by this factory can convert from\n * @param <R> the target range (or base) type converters created by this factory can convert to;\n * for example {@link Number} for a set of number subtypes.\n * @see ConditionalConverter\n "
  },
  {
    "entityId": "org.springframework.core.convert.converter.ConverterFactory#getConverter(Class<T>)",
    "entityType": "method",
    "code": "/**\r\n * Get the converter to convert from S to target type T, where T is also an instance of R.\r\n * @param <T> the target type\r\n * @param targetType the target type to convert to\r\n * @return a converter from S to T\r\n */\r\n<T extends R> Converter<S, T> getConverter(Class<T> targetType);",
    "comment": "\n\t * Get the converter to convert from S to target type T, where T is also an instance of R.\n\t * @param <T> the target type\n\t * @param targetType the target type to convert to\n\t * @return a converter from S to T\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.converter.ConverterRegistry",
    "entityType": "class",
    "code": "/**\r\n * Add a plain converter to this registry.\r\n * The convertible source/target type pair is derived from the Converter's parameterized types.\r\n * @throws IllegalArgumentException if the parameterized types could not be resolved\r\n */\r\nvoid addConverter(Converter<?, ?> converter);\n/**\r\n * Add a plain converter to this registry.\r\n * The convertible source/target type pair is specified explicitly.\r\n * <p>Allows for a Converter to be reused for multiple distinct pairs without\r\n * having to create a Converter class for each pair.\r\n * @since 3.1\r\n */\r\n<S, T> void addConverter(Class<S> sourceType, Class<T> targetType, Converter<? super S, ? extends T> converter);\n/**\r\n * Add a generic converter to this registry.\r\n */\r\nvoid addConverter(GenericConverter converter);\n/**\r\n * Add a ranged converter factory to this registry.\r\n * The convertible source/target type pair is derived from the ConverterFactory's parameterized types.\r\n * @throws IllegalArgumentException if the parameterized types could not be resolved\r\n */\r\nvoid addConverterFactory(ConverterFactory<?, ?> factory);\n/**\r\n * Remove any converters from {@code sourceType} to {@code targetType}.\r\n * @param sourceType the source type\r\n * @param targetType the target type\r\n */\r\nvoid removeConvertible(Class<?> sourceType, Class<?> targetType);",
    "comment": "\n * For registering converters with a type conversion system.\n *\n * @author Keith Donald\n * @author Juergen Hoeller\n * @since 3.0\n "
  },
  {
    "entityId": "org.springframework.core.convert.converter.ConverterRegistry#addConverter(Converter<?,?>)",
    "entityType": "method",
    "code": "/**\r\n * Add a plain converter to this registry.\r\n * The convertible source/target type pair is derived from the Converter's parameterized types.\r\n * @throws IllegalArgumentException if the parameterized types could not be resolved\r\n */\r\nvoid addConverter(Converter<?, ?> converter);",
    "comment": "\n\t * Add a plain converter to this registry.\n\t * The convertible source/target type pair is derived from the Converter's parameterized types.\n\t * @throws IllegalArgumentException if the parameterized types could not be resolved\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.converter.ConverterRegistry#addConverter(Class<S>,Class<T>,Converter<? super S,? extends T>)",
    "entityType": "method",
    "code": "/**\r\n * Add a plain converter to this registry.\r\n * The convertible source/target type pair is specified explicitly.\r\n * <p>Allows for a Converter to be reused for multiple distinct pairs without\r\n * having to create a Converter class for each pair.\r\n * @since 3.1\r\n */\r\n<S, T> void addConverter(Class<S> sourceType, Class<T> targetType, Converter<? super S, ? extends T> converter);",
    "comment": "\n\t * Add a plain converter to this registry.\n\t * The convertible source/target type pair is specified explicitly.\n\t * <p>Allows for a Converter to be reused for multiple distinct pairs without\n\t * having to create a Converter class for each pair.\n\t * @since 3.1\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.converter.ConverterRegistry#addConverter(GenericConverter)",
    "entityType": "method",
    "code": "/**\r\n * Add a generic converter to this registry.\r\n */\r\nvoid addConverter(GenericConverter converter);",
    "comment": "\n\t * Add a generic converter to this registry.\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.converter.ConverterRegistry#addConverterFactory(ConverterFactory<?,?>)",
    "entityType": "method",
    "code": "/**\r\n * Add a ranged converter factory to this registry.\r\n * The convertible source/target type pair is derived from the ConverterFactory's parameterized types.\r\n * @throws IllegalArgumentException if the parameterized types could not be resolved\r\n */\r\nvoid addConverterFactory(ConverterFactory<?, ?> factory);",
    "comment": "\n\t * Add a ranged converter factory to this registry.\n\t * The convertible source/target type pair is derived from the ConverterFactory's parameterized types.\n\t * @throws IllegalArgumentException if the parameterized types could not be resolved\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.converter.ConverterRegistry#removeConvertible(Class<?>,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Remove any converters from {@code sourceType} to {@code targetType}.\r\n * @param sourceType the source type\r\n * @param targetType the target type\r\n */\r\nvoid removeConvertible(Class<?> sourceType, Class<?> targetType);",
    "comment": "\n\t * Remove any converters from {@code sourceType} to {@code targetType}.\n\t * @param sourceType the source type\n\t * @param targetType the target type\n\t "
  }
]