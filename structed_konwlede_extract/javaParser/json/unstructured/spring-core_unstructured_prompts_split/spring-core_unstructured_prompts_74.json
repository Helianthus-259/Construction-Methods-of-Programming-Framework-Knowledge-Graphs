[
  {
    "entityId": "org.springframework.core.type.MethodMetadata#getReturnTypeName()",
    "entityType": "method",
    "code": "/**\r\n * Get the fully-qualified name of the underlying method's declared return type.\r\n * @since 4.2\r\n */\r\nString getReturnTypeName();",
    "comment": "\n\t * Get the fully-qualified name of the underlying method's declared return type.\n\t * @since 4.2\n\t "
  },
  {
    "entityId": "org.springframework.core.type.MethodMetadata#isAbstract()",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the underlying method is effectively abstract:\r\n * i.e. marked as abstract in a class or declared as a regular,\r\n * non-default method in an interface.\r\n * @since 4.2\r\n */\r\nboolean isAbstract();",
    "comment": "\n\t * Determine whether the underlying method is effectively abstract:\n\t * i.e. marked as abstract in a class or declared as a regular,\n\t * non-default method in an interface.\n\t * @since 4.2\n\t "
  },
  {
    "entityId": "org.springframework.core.type.MethodMetadata#isStatic()",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the underlying method is declared as 'static'.\r\n */\r\nboolean isStatic();",
    "comment": "\n\t * Determine whether the underlying method is declared as 'static'.\n\t "
  },
  {
    "entityId": "org.springframework.core.type.MethodMetadata#isFinal()",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the underlying method is marked as 'final'.\r\n */\r\nboolean isFinal();",
    "comment": "\n\t * Determine whether the underlying method is marked as 'final'.\n\t "
  },
  {
    "entityId": "org.springframework.core.type.MethodMetadata#isOverridable()",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the underlying method is overridable,\r\n * i.e. not marked as static, final, or private.\r\n */\r\nboolean isOverridable();",
    "comment": "\n\t * Determine whether the underlying method is overridable,\n\t * i.e. not marked as static, final, or private.\n\t "
  },
  {
    "entityId": "org.springframework.core.type.StandardAnnotationMetadata",
    "entityType": "class",
    "code": "private final MergedAnnotations mergedAnnotations;\nprivate final boolean nestedAnnotationsAsMap;\n@Nullable\r\nprivate Set<String> annotationTypes;\n/**\r\n * Create a new {@code StandardAnnotationMetadata} wrapper for the given Class.\r\n * @param introspectedClass the Class to introspect\r\n * @see #StandardAnnotationMetadata(Class, boolean)\r\n * @deprecated since 5.2 in favor of the factory method {@link AnnotationMetadata#introspect(Class)}\r\n */\r\n@Deprecated\r\npublic StandardAnnotationMetadata(Class<?> introspectedClass) {\r\n    this(introspectedClass, false);\r\n}\n/**\r\n * Create a new {@link StandardAnnotationMetadata} wrapper for the given Class,\r\n * providing the option to return any nested annotations or annotation arrays in the\r\n * form of {@link org.springframework.core.annotation.AnnotationAttributes} instead\r\n * of actual {@link Annotation} instances.\r\n * @param introspectedClass the Class to introspect\r\n * @param nestedAnnotationsAsMap return nested annotations and annotation arrays as\r\n * {@link org.springframework.core.annotation.AnnotationAttributes} for compatibility\r\n * with ASM-based {@link AnnotationMetadata} implementations\r\n * @since 3.1.1\r\n * @deprecated since 5.2 in favor of the factory method {@link AnnotationMetadata#introspect(Class)}.\r\n * Use {@link MergedAnnotation#asMap(org.springframework.core.annotation.MergedAnnotation.Adapt...) MergedAnnotation.asMap}\r\n * from {@link #getAnnotations()} rather than {@link #getAnnotationAttributes(String)}\r\n * if {@code nestedAnnotationsAsMap} is {@code false}\r\n */\r\n@Deprecated\r\npublic StandardAnnotationMetadata(Class<?> introspectedClass, boolean nestedAnnotationsAsMap) {\r\n    super(introspectedClass);\r\n    this.mergedAnnotations = MergedAnnotations.from(introspectedClass, SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none());\r\n    this.nestedAnnotationsAsMap = nestedAnnotationsAsMap;\r\n}\n@Override\r\npublic MergedAnnotations getAnnotations() {\r\n    return this.mergedAnnotations;\r\n}\n@Override\r\npublic Set<String> getAnnotationTypes() {\r\n    Set<String> annotationTypes = this.annotationTypes;\r\n    if (annotationTypes == null) {\r\n        annotationTypes = Collections.unmodifiableSet(AnnotationMetadata.super.getAnnotationTypes());\r\n        this.annotationTypes = annotationTypes;\r\n    }\r\n    return annotationTypes;\r\n}\n@Override\r\n@Nullable\r\npublic Map<String, @Nullable Object> getAnnotationAttributes(String annotationName, boolean classValuesAsString) {\r\n    if (this.nestedAnnotationsAsMap) {\r\n        return AnnotationMetadata.super.getAnnotationAttributes(annotationName, classValuesAsString);\r\n    }\r\n    return AnnotatedElementUtils.getMergedAnnotationAttributes(getIntrospectedClass(), annotationName, classValuesAsString, false);\r\n}\n@Override\r\n// Null-safety of Java super method not yet managed\r\n@SuppressWarnings(\"NullAway\")\r\n@Nullable\r\npublic MultiValueMap<String, @Nullable Object> getAllAnnotationAttributes(String annotationName, boolean classValuesAsString) {\r\n    if (this.nestedAnnotationsAsMap) {\r\n        return AnnotationMetadata.super.getAllAnnotationAttributes(annotationName, classValuesAsString);\r\n    }\r\n    return AnnotatedElementUtils.getAllAnnotationAttributes(getIntrospectedClass(), annotationName, classValuesAsString, false);\r\n}\n@Override\r\npublic boolean hasAnnotatedMethods(String annotationName) {\r\n    if (AnnotationUtils.isCandidateClass(getIntrospectedClass(), annotationName)) {\r\n        try {\r\n            Method[] methods = ReflectionUtils.getDeclaredMethods(getIntrospectedClass());\r\n            for (Method method : methods) {\r\n                if (isAnnotatedMethod(method, annotationName)) {\r\n                    return true;\r\n                }\r\n            }\r\n        } catch (Throwable ex) {\r\n            throw new IllegalStateException(\"Failed to introspect annotated methods on \" + getIntrospectedClass(), ex);\r\n        }\r\n    }\r\n    return false;\r\n}\n@Override\r\npublic Set<MethodMetadata> getAnnotatedMethods(String annotationName) {\r\n    Set<MethodMetadata> result = new LinkedHashSet<>(4);\r\n    if (AnnotationUtils.isCandidateClass(getIntrospectedClass(), annotationName)) {\r\n        ReflectionUtils.doWithLocalMethods(getIntrospectedClass(), method -> {\r\n            if (isAnnotatedMethod(method, annotationName)) {\r\n                result.add(new StandardMethodMetadata(method, this.nestedAnnotationsAsMap));\r\n            }\r\n        });\r\n    }\r\n    return result;\r\n}\n@Override\r\npublic Set<MethodMetadata> getDeclaredMethods() {\r\n    Set<MethodMetadata> result = new LinkedHashSet<>(16);\r\n    ReflectionUtils.doWithLocalMethods(getIntrospectedClass(), method -> result.add(new StandardMethodMetadata(method, this.nestedAnnotationsAsMap)));\r\n    return result;\r\n}\nprivate static boolean isAnnotatedMethod(Method method, String annotationName) {\r\n    return !method.isBridge() && method.getAnnotations().length > 0 && AnnotatedElementUtils.isAnnotated(method, annotationName);\r\n}\nstatic AnnotationMetadata from(Class<?> introspectedClass) {\r\n    return new StandardAnnotationMetadata(introspectedClass, true);\r\n}",
    "comment": "\n * {@link AnnotationMetadata} implementation that uses standard reflection\n * to introspect a given {@link Class}.\n *\n * @author Juergen Hoeller\n * @author Mark Fisher\n * @author Chris Beams\n * @author Phillip Webb\n * @author Sam Brannen\n * @since 2.5\n "
  },
  {
    "entityId": "org.springframework.core.type.StandardAnnotationMetadata#getAnnotations()",
    "entityType": "method",
    "code": "@Override\r\npublic MergedAnnotations getAnnotations() {\r\n    return this.mergedAnnotations;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardAnnotationMetadata#getAnnotationTypes()",
    "entityType": "method",
    "code": "@Override\r\npublic Set<String> getAnnotationTypes() {\r\n    Set<String> annotationTypes = this.annotationTypes;\r\n    if (annotationTypes == null) {\r\n        annotationTypes = Collections.unmodifiableSet(AnnotationMetadata.super.getAnnotationTypes());\r\n        this.annotationTypes = annotationTypes;\r\n    }\r\n    return annotationTypes;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardAnnotationMetadata#getAnnotationAttributes(String,boolean)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Map<String, @Nullable Object> getAnnotationAttributes(String annotationName, boolean classValuesAsString) {\r\n    if (this.nestedAnnotationsAsMap) {\r\n        return AnnotationMetadata.super.getAnnotationAttributes(annotationName, classValuesAsString);\r\n    }\r\n    return AnnotatedElementUtils.getMergedAnnotationAttributes(getIntrospectedClass(), annotationName, classValuesAsString, false);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardAnnotationMetadata#getAllAnnotationAttributes(String,boolean)",
    "entityType": "method",
    "code": "@Override\r\n// Null-safety of Java super method not yet managed\r\n@SuppressWarnings(\"NullAway\")\r\n@Nullable\r\npublic MultiValueMap<String, @Nullable Object> getAllAnnotationAttributes(String annotationName, boolean classValuesAsString) {\r\n    if (this.nestedAnnotationsAsMap) {\r\n        return AnnotationMetadata.super.getAllAnnotationAttributes(annotationName, classValuesAsString);\r\n    }\r\n    return AnnotatedElementUtils.getAllAnnotationAttributes(getIntrospectedClass(), annotationName, classValuesAsString, false);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardAnnotationMetadata#hasAnnotatedMethods(String)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean hasAnnotatedMethods(String annotationName) {\r\n    if (AnnotationUtils.isCandidateClass(getIntrospectedClass(), annotationName)) {\r\n        try {\r\n            Method[] methods = ReflectionUtils.getDeclaredMethods(getIntrospectedClass());\r\n            for (Method method : methods) {\r\n                if (isAnnotatedMethod(method, annotationName)) {\r\n                    return true;\r\n                }\r\n            }\r\n        } catch (Throwable ex) {\r\n            throw new IllegalStateException(\"Failed to introspect annotated methods on \" + getIntrospectedClass(), ex);\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardAnnotationMetadata#getAnnotatedMethods(String)",
    "entityType": "method",
    "code": "@Override\r\npublic Set<MethodMetadata> getAnnotatedMethods(String annotationName) {\r\n    Set<MethodMetadata> result = new LinkedHashSet<>(4);\r\n    if (AnnotationUtils.isCandidateClass(getIntrospectedClass(), annotationName)) {\r\n        ReflectionUtils.doWithLocalMethods(getIntrospectedClass(), method -> {\r\n            if (isAnnotatedMethod(method, annotationName)) {\r\n                result.add(new StandardMethodMetadata(method, this.nestedAnnotationsAsMap));\r\n            }\r\n        });\r\n    }\r\n    return result;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardAnnotationMetadata#getDeclaredMethods()",
    "entityType": "method",
    "code": "@Override\r\npublic Set<MethodMetadata> getDeclaredMethods() {\r\n    Set<MethodMetadata> result = new LinkedHashSet<>(16);\r\n    ReflectionUtils.doWithLocalMethods(getIntrospectedClass(), method -> result.add(new StandardMethodMetadata(method, this.nestedAnnotationsAsMap)));\r\n    return result;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardAnnotationMetadata#isAnnotatedMethod(Method,String)",
    "entityType": "method",
    "code": "private static boolean isAnnotatedMethod(Method method, String annotationName) {\r\n    return !method.isBridge() && method.getAnnotations().length > 0 && AnnotatedElementUtils.isAnnotated(method, annotationName);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardAnnotationMetadata#from(Class<?>)",
    "entityType": "method",
    "code": "static AnnotationMetadata from(Class<?> introspectedClass) {\r\n    return new StandardAnnotationMetadata(introspectedClass, true);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardClassMetadata",
    "entityType": "class",
    "code": "private final Class<?> introspectedClass;\n/**\r\n * Create a new StandardClassMetadata wrapper for the given Class.\r\n * @param introspectedClass the Class to introspect\r\n * @deprecated since 5.2 in favor of {@link StandardAnnotationMetadata}\r\n */\r\n@Deprecated\r\npublic StandardClassMetadata(Class<?> introspectedClass) {\r\n    Assert.notNull(introspectedClass, \"Class must not be null\");\r\n    this.introspectedClass = introspectedClass;\r\n}\n/**\r\n * Return the underlying Class.\r\n */\r\npublic final Class<?> getIntrospectedClass() {\r\n    return this.introspectedClass;\r\n}\n@Override\r\npublic String getClassName() {\r\n    return this.introspectedClass.getName();\r\n}\n@Override\r\npublic boolean isInterface() {\r\n    return this.introspectedClass.isInterface();\r\n}\n@Override\r\npublic boolean isAnnotation() {\r\n    return this.introspectedClass.isAnnotation();\r\n}\n@Override\r\npublic boolean isAbstract() {\r\n    return Modifier.isAbstract(this.introspectedClass.getModifiers());\r\n}\n@Override\r\npublic boolean isFinal() {\r\n    return Modifier.isFinal(this.introspectedClass.getModifiers());\r\n}\n@Override\r\npublic boolean isIndependent() {\r\n    return (!hasEnclosingClass() || (this.introspectedClass.getDeclaringClass() != null && Modifier.isStatic(this.introspectedClass.getModifiers())));\r\n}\n@Override\r\n@Nullable\r\npublic String getEnclosingClassName() {\r\n    Class<?> enclosingClass = this.introspectedClass.getEnclosingClass();\r\n    return (enclosingClass != null ? enclosingClass.getName() : null);\r\n}\n@Override\r\n@Nullable\r\npublic String getSuperClassName() {\r\n    Class<?> superClass = this.introspectedClass.getSuperclass();\r\n    return (superClass != null ? superClass.getName() : null);\r\n}\n@Override\r\npublic String[] getInterfaceNames() {\r\n    Class<?>[] ifcs = this.introspectedClass.getInterfaces();\r\n    String[] ifcNames = new String[ifcs.length];\r\n    for (int i = 0; i < ifcs.length; i++) {\r\n        ifcNames[i] = ifcs[i].getName();\r\n    }\r\n    return ifcNames;\r\n}\n@Override\r\npublic String[] getMemberClassNames() {\r\n    LinkedHashSet<String> memberClassNames = new LinkedHashSet<>(4);\r\n    for (Class<?> nestedClass : this.introspectedClass.getDeclaredClasses()) {\r\n        memberClassNames.add(nestedClass.getName());\r\n    }\r\n    return StringUtils.toStringArray(memberClassNames);\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof StandardClassMetadata that && getIntrospectedClass().equals(that.getIntrospectedClass())));\r\n}\n@Override\r\npublic int hashCode() {\r\n    return getIntrospectedClass().hashCode();\r\n}\n@Override\r\npublic String toString() {\r\n    return getClassName();\r\n}",
    "comment": "\n * {@link ClassMetadata} implementation that uses standard reflection\n * to introspect a given {@code Class}.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 2.5\n "
  },
  {
    "entityId": "org.springframework.core.type.StandardClassMetadata#getIntrospectedClass()",
    "entityType": "method",
    "code": "/**\r\n * Return the underlying Class.\r\n */\r\npublic final Class<?> getIntrospectedClass() {\r\n    return this.introspectedClass;\r\n}",
    "comment": "\n\t * Return the underlying Class.\n\t "
  },
  {
    "entityId": "org.springframework.core.type.StandardClassMetadata#getClassName()",
    "entityType": "method",
    "code": "@Override\r\npublic String getClassName() {\r\n    return this.introspectedClass.getName();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardClassMetadata#isInterface()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isInterface() {\r\n    return this.introspectedClass.isInterface();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardClassMetadata#isAnnotation()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isAnnotation() {\r\n    return this.introspectedClass.isAnnotation();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardClassMetadata#isAbstract()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isAbstract() {\r\n    return Modifier.isAbstract(this.introspectedClass.getModifiers());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardClassMetadata#isFinal()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isFinal() {\r\n    return Modifier.isFinal(this.introspectedClass.getModifiers());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardClassMetadata#isIndependent()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isIndependent() {\r\n    return (!hasEnclosingClass() || (this.introspectedClass.getDeclaringClass() != null && Modifier.isStatic(this.introspectedClass.getModifiers())));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardClassMetadata#getEnclosingClassName()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic String getEnclosingClassName() {\r\n    Class<?> enclosingClass = this.introspectedClass.getEnclosingClass();\r\n    return (enclosingClass != null ? enclosingClass.getName() : null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardClassMetadata#getSuperClassName()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic String getSuperClassName() {\r\n    Class<?> superClass = this.introspectedClass.getSuperclass();\r\n    return (superClass != null ? superClass.getName() : null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardClassMetadata#getInterfaceNames()",
    "entityType": "method",
    "code": "@Override\r\npublic String[] getInterfaceNames() {\r\n    Class<?>[] ifcs = this.introspectedClass.getInterfaces();\r\n    String[] ifcNames = new String[ifcs.length];\r\n    for (int i = 0; i < ifcs.length; i++) {\r\n        ifcNames[i] = ifcs[i].getName();\r\n    }\r\n    return ifcNames;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardClassMetadata#getMemberClassNames()",
    "entityType": "method",
    "code": "@Override\r\npublic String[] getMemberClassNames() {\r\n    LinkedHashSet<String> memberClassNames = new LinkedHashSet<>(4);\r\n    for (Class<?> nestedClass : this.introspectedClass.getDeclaredClasses()) {\r\n        memberClassNames.add(nestedClass.getName());\r\n    }\r\n    return StringUtils.toStringArray(memberClassNames);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardClassMetadata#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof StandardClassMetadata that && getIntrospectedClass().equals(that.getIntrospectedClass())));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardClassMetadata#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return getIntrospectedClass().hashCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardClassMetadata#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return getClassName();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardMethodMetadata",
    "entityType": "class",
    "code": "private final Method introspectedMethod;\nprivate final boolean nestedAnnotationsAsMap;\nprivate final MergedAnnotations mergedAnnotations;\n/**\r\n * Create a new StandardMethodMetadata wrapper for the given Method.\r\n * @param introspectedMethod the Method to introspect\r\n * @deprecated since 5.2 in favor of obtaining instances via {@link AnnotationMetadata}\r\n */\r\n@Deprecated\r\npublic StandardMethodMetadata(Method introspectedMethod) {\r\n    this(introspectedMethod, false);\r\n}\n/**\r\n * Create a new StandardMethodMetadata wrapper for the given Method,\r\n * providing the option to return any nested annotations or annotation arrays in the\r\n * form of {@link org.springframework.core.annotation.AnnotationAttributes} instead\r\n * of actual {@link java.lang.annotation.Annotation} instances.\r\n * @param introspectedMethod the Method to introspect\r\n * @param nestedAnnotationsAsMap return nested annotations and annotation arrays as\r\n * {@link org.springframework.core.annotation.AnnotationAttributes} for compatibility\r\n * with ASM-based {@link AnnotationMetadata} implementations\r\n * @since 3.1.1\r\n */\r\nStandardMethodMetadata(Method introspectedMethod, boolean nestedAnnotationsAsMap) {\r\n    Assert.notNull(introspectedMethod, \"Method must not be null\");\r\n    this.introspectedMethod = introspectedMethod;\r\n    this.nestedAnnotationsAsMap = nestedAnnotationsAsMap;\r\n    this.mergedAnnotations = MergedAnnotations.from(introspectedMethod, SearchStrategy.DIRECT, RepeatableContainers.none());\r\n}\n@Override\r\npublic MergedAnnotations getAnnotations() {\r\n    return this.mergedAnnotations;\r\n}\n/**\r\n * Return the underlying Method.\r\n */\r\npublic final Method getIntrospectedMethod() {\r\n    return this.introspectedMethod;\r\n}\n@Override\r\npublic String getMethodName() {\r\n    return this.introspectedMethod.getName();\r\n}\n@Override\r\npublic String getDeclaringClassName() {\r\n    return this.introspectedMethod.getDeclaringClass().getName();\r\n}\n@Override\r\npublic String getReturnTypeName() {\r\n    return this.introspectedMethod.getReturnType().getName();\r\n}\n@Override\r\npublic boolean isAbstract() {\r\n    return Modifier.isAbstract(this.introspectedMethod.getModifiers());\r\n}\n@Override\r\npublic boolean isStatic() {\r\n    return Modifier.isStatic(this.introspectedMethod.getModifiers());\r\n}\n@Override\r\npublic boolean isFinal() {\r\n    return Modifier.isFinal(this.introspectedMethod.getModifiers());\r\n}\n@Override\r\npublic boolean isOverridable() {\r\n    return !isStatic() && !isFinal() && !isPrivate();\r\n}\nprivate boolean isPrivate() {\r\n    return Modifier.isPrivate(this.introspectedMethod.getModifiers());\r\n}\n@Override\r\n@Nullable\r\npublic Map<String, @Nullable Object> getAnnotationAttributes(String annotationName, boolean classValuesAsString) {\r\n    if (this.nestedAnnotationsAsMap) {\r\n        return MethodMetadata.super.getAnnotationAttributes(annotationName, classValuesAsString);\r\n    }\r\n    return AnnotatedElementUtils.getMergedAnnotationAttributes(this.introspectedMethod, annotationName, classValuesAsString, false);\r\n}\n@Override\r\n// Null-safety of Java super method not yet managed\r\n@SuppressWarnings(\"NullAway\")\r\n@Nullable\r\npublic MultiValueMap<String, @Nullable Object> getAllAnnotationAttributes(String annotationName, boolean classValuesAsString) {\r\n    if (this.nestedAnnotationsAsMap) {\r\n        return MethodMetadata.super.getAllAnnotationAttributes(annotationName, classValuesAsString);\r\n    }\r\n    return AnnotatedElementUtils.getAllAnnotationAttributes(this.introspectedMethod, annotationName, classValuesAsString, false);\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof StandardMethodMetadata that && this.introspectedMethod.equals(that.introspectedMethod)));\r\n}\n@Override\r\npublic int hashCode() {\r\n    return this.introspectedMethod.hashCode();\r\n}\n@Override\r\npublic String toString() {\r\n    return this.introspectedMethod.toString();\r\n}",
    "comment": "\n * {@link MethodMetadata} implementation that uses standard reflection\n * to introspect a given {@code Method}.\n *\n * @author Juergen Hoeller\n * @author Mark Pollack\n * @author Chris Beams\n * @author Phillip Webb\n * @author Sam Brannen\n * @since 3.0\n "
  },
  {
    "entityId": "org.springframework.core.type.StandardMethodMetadata#getAnnotations()",
    "entityType": "method",
    "code": "@Override\r\npublic MergedAnnotations getAnnotations() {\r\n    return this.mergedAnnotations;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardMethodMetadata#getIntrospectedMethod()",
    "entityType": "method",
    "code": "/**\r\n * Return the underlying Method.\r\n */\r\npublic final Method getIntrospectedMethod() {\r\n    return this.introspectedMethod;\r\n}",
    "comment": "\n\t * Return the underlying Method.\n\t "
  },
  {
    "entityId": "org.springframework.core.type.StandardMethodMetadata#getMethodName()",
    "entityType": "method",
    "code": "@Override\r\npublic String getMethodName() {\r\n    return this.introspectedMethod.getName();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardMethodMetadata#getDeclaringClassName()",
    "entityType": "method",
    "code": "@Override\r\npublic String getDeclaringClassName() {\r\n    return this.introspectedMethod.getDeclaringClass().getName();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardMethodMetadata#getReturnTypeName()",
    "entityType": "method",
    "code": "@Override\r\npublic String getReturnTypeName() {\r\n    return this.introspectedMethod.getReturnType().getName();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardMethodMetadata#isAbstract()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isAbstract() {\r\n    return Modifier.isAbstract(this.introspectedMethod.getModifiers());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardMethodMetadata#isStatic()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isStatic() {\r\n    return Modifier.isStatic(this.introspectedMethod.getModifiers());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardMethodMetadata#isFinal()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isFinal() {\r\n    return Modifier.isFinal(this.introspectedMethod.getModifiers());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardMethodMetadata#isOverridable()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isOverridable() {\r\n    return !isStatic() && !isFinal() && !isPrivate();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardMethodMetadata#isPrivate()",
    "entityType": "method",
    "code": "private boolean isPrivate() {\r\n    return Modifier.isPrivate(this.introspectedMethod.getModifiers());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardMethodMetadata#getAnnotationAttributes(String,boolean)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Map<String, @Nullable Object> getAnnotationAttributes(String annotationName, boolean classValuesAsString) {\r\n    if (this.nestedAnnotationsAsMap) {\r\n        return MethodMetadata.super.getAnnotationAttributes(annotationName, classValuesAsString);\r\n    }\r\n    return AnnotatedElementUtils.getMergedAnnotationAttributes(this.introspectedMethod, annotationName, classValuesAsString, false);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardMethodMetadata#getAllAnnotationAttributes(String,boolean)",
    "entityType": "method",
    "code": "@Override\r\n// Null-safety of Java super method not yet managed\r\n@SuppressWarnings(\"NullAway\")\r\n@Nullable\r\npublic MultiValueMap<String, @Nullable Object> getAllAnnotationAttributes(String annotationName, boolean classValuesAsString) {\r\n    if (this.nestedAnnotationsAsMap) {\r\n        return MethodMetadata.super.getAllAnnotationAttributes(annotationName, classValuesAsString);\r\n    }\r\n    return AnnotatedElementUtils.getAllAnnotationAttributes(this.introspectedMethod, annotationName, classValuesAsString, false);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardMethodMetadata#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof StandardMethodMetadata that && this.introspectedMethod.equals(that.introspectedMethod)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return this.introspectedMethod.hashCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardMethodMetadata#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return this.introspectedMethod.toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.objenesis.SpringObjenesis",
    "entityType": "class",
    "code": "/**\r\n * System property that instructs Spring to ignore Objenesis, not even attempting\r\n * to use it. Setting this flag to \"true\" is equivalent to letting Spring find\r\n * out that Objenesis isn't working at runtime, triggering the fallback code path\r\n * immediately: Most importantly, this means that all CGLIB AOP proxies will be\r\n * created through regular instantiation via a default constructor.\r\n */\r\npublic static final String IGNORE_OBJENESIS_PROPERTY_NAME = \"spring.objenesis.ignore\";\nprivate final InstantiatorStrategy strategy;\nprivate final ConcurrentReferenceHashMap<Class<?>, ObjectInstantiator<?>> cache = new ConcurrentReferenceHashMap<>();\nprivate volatile Boolean worthTrying;\n/**\r\n * Create a new {@code SpringObjenesis} instance with the\r\n * standard instantiator strategy.\r\n */\r\npublic SpringObjenesis() {\r\n    this(null);\r\n}\n/**\r\n * Create a new {@code SpringObjenesis} instance with the\r\n * given standard instantiator strategy.\r\n * @param strategy the instantiator strategy to use\r\n */\r\npublic SpringObjenesis(InstantiatorStrategy strategy) {\r\n    this.strategy = (strategy != null ? strategy : new StdInstantiatorStrategy());\r\n    // Evaluate the \"spring.objenesis.ignore\" property upfront...\r\n    if (SpringProperties.getFlag(SpringObjenesis.IGNORE_OBJENESIS_PROPERTY_NAME)) {\r\n        this.worthTrying = Boolean.FALSE;\r\n    }\r\n}\n/**\r\n * Return whether this Objenesis instance is worth trying for instance creation,\r\n * i.e. whether it hasn't been used yet or is known to work.\r\n * <p>If the configured Objenesis instantiator strategy has been identified to not\r\n * work on the current JVM at all or if the \"spring.objenesis.ignore\" property has\r\n * been set to \"true\", this method returns {@code false}.\r\n */\r\npublic boolean isWorthTrying() {\r\n    return (this.worthTrying != Boolean.FALSE);\r\n}\n/**\r\n * Create a new instance of the given class via Objenesis.\r\n * @param clazz the class to create an instance of\r\n * @param useCache whether to use the instantiator cache\r\n * (typically {@code true} but can be set to {@code false}\r\n * for example, for reloadable classes)\r\n * @return the new instance (never {@code null})\r\n * @throws ObjenesisException if instance creation failed\r\n */\r\npublic <T> T newInstance(Class<T> clazz, boolean useCache) {\r\n    if (!useCache) {\r\n        return newInstantiatorOf(clazz).newInstance();\r\n    }\r\n    return getInstantiatorOf(clazz).newInstance();\r\n}\n@Override\r\npublic <T> T newInstance(Class<T> clazz) {\r\n    return getInstantiatorOf(clazz).newInstance();\r\n}\n@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic <T> ObjectInstantiator<T> getInstantiatorOf(Class<T> clazz) {\r\n    ObjectInstantiator<?> instantiator = this.cache.get(clazz);\r\n    if (instantiator == null) {\r\n        ObjectInstantiator<T> newInstantiator = newInstantiatorOf(clazz);\r\n        instantiator = this.cache.putIfAbsent(clazz, newInstantiator);\r\n        if (instantiator == null) {\r\n            instantiator = newInstantiator;\r\n        }\r\n    }\r\n    return (ObjectInstantiator<T>) instantiator;\r\n}\nprotected <T> ObjectInstantiator<T> newInstantiatorOf(Class<T> clazz) {\r\n    Boolean currentWorthTrying = this.worthTrying;\r\n    try {\r\n        ObjectInstantiator<T> instantiator = this.strategy.newInstantiatorOf(clazz);\r\n        if (currentWorthTrying == null) {\r\n            this.worthTrying = Boolean.TRUE;\r\n        }\r\n        return instantiator;\r\n    } catch (ObjenesisException ex) {\r\n        if (currentWorthTrying == null) {\r\n            Throwable cause = ex.getCause();\r\n            if (cause instanceof ClassNotFoundException || cause instanceof IllegalAccessException) {\r\n                // Indicates that the chosen instantiation strategy does not work on the given JVM.\r\n                // Typically a failure to initialize the default SunReflectionFactoryInstantiator.\r\n                // Let's assume that any subsequent attempts to use Objenesis will fail as well...\r\n                this.worthTrying = Boolean.FALSE;\r\n            }\r\n        }\r\n        throw ex;\r\n    } catch (NoClassDefFoundError err) {\r\n        // Happening on the production version of Google App Engine, coming out of the\r\n        // restricted \"sun.reflect.ReflectionFactory\" class...\r\n        if (currentWorthTrying == null) {\r\n            this.worthTrying = Boolean.FALSE;\r\n        }\r\n        throw new ObjenesisException(err);\r\n    }\r\n}",
    "comment": "\n * Spring-specific variant of {@link ObjenesisStd} / {@link ObjenesisBase},\n * providing a cache based on {@code Class} keys instead of class names,\n * and allowing for selective use of the cache.\n *\n * @author Juergen Hoeller\n * @since 4.2\n * @see #isWorthTrying()\n * @see #newInstance(Class, boolean)\n "
  },
  {
    "entityId": "org.springframework.objenesis.SpringObjenesis#isWorthTrying()",
    "entityType": "method",
    "code": "/**\r\n * Return whether this Objenesis instance is worth trying for instance creation,\r\n * i.e. whether it hasn't been used yet or is known to work.\r\n * <p>If the configured Objenesis instantiator strategy has been identified to not\r\n * work on the current JVM at all or if the \"spring.objenesis.ignore\" property has\r\n * been set to \"true\", this method returns {@code false}.\r\n */\r\npublic boolean isWorthTrying() {\r\n    return (this.worthTrying != Boolean.FALSE);\r\n}",
    "comment": "\n\t * Return whether this Objenesis instance is worth trying for instance creation,\n\t * i.e. whether it hasn't been used yet or is known to work.\n\t * <p>If the configured Objenesis instantiator strategy has been identified to not\n\t * work on the current JVM at all or if the \"spring.objenesis.ignore\" property has\n\t * been set to \"true\", this method returns {@code false}.\n\t "
  },
  {
    "entityId": "org.springframework.objenesis.SpringObjenesis#newInstance(Class<T>,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Create a new instance of the given class via Objenesis.\r\n * @param clazz the class to create an instance of\r\n * @param useCache whether to use the instantiator cache\r\n * (typically {@code true} but can be set to {@code false}\r\n * for example, for reloadable classes)\r\n * @return the new instance (never {@code null})\r\n * @throws ObjenesisException if instance creation failed\r\n */\r\npublic <T> T newInstance(Class<T> clazz, boolean useCache) {\r\n    if (!useCache) {\r\n        return newInstantiatorOf(clazz).newInstance();\r\n    }\r\n    return getInstantiatorOf(clazz).newInstance();\r\n}",
    "comment": "\n\t * Create a new instance of the given class via Objenesis.\n\t * @param clazz the class to create an instance of\n\t * @param useCache whether to use the instantiator cache\n\t * (typically {@code true} but can be set to {@code false}\n\t * for example, for reloadable classes)\n\t * @return the new instance (never {@code null})\n\t * @throws ObjenesisException if instance creation failed\n\t "
  },
  {
    "entityId": "org.springframework.objenesis.SpringObjenesis#newInstance(Class<T>)",
    "entityType": "method",
    "code": "@Override\r\npublic <T> T newInstance(Class<T> clazz) {\r\n    return getInstantiatorOf(clazz).newInstance();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.objenesis.SpringObjenesis#getInstantiatorOf(Class<T>)",
    "entityType": "method",
    "code": "@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic <T> ObjectInstantiator<T> getInstantiatorOf(Class<T> clazz) {\r\n    ObjectInstantiator<?> instantiator = this.cache.get(clazz);\r\n    if (instantiator == null) {\r\n        ObjectInstantiator<T> newInstantiator = newInstantiatorOf(clazz);\r\n        instantiator = this.cache.putIfAbsent(clazz, newInstantiator);\r\n        if (instantiator == null) {\r\n            instantiator = newInstantiator;\r\n        }\r\n    }\r\n    return (ObjectInstantiator<T>) instantiator;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.objenesis.SpringObjenesis#newInstantiatorOf(Class<T>)",
    "entityType": "method",
    "code": "protected <T> ObjectInstantiator<T> newInstantiatorOf(Class<T> clazz) {\r\n    Boolean currentWorthTrying = this.worthTrying;\r\n    try {\r\n        ObjectInstantiator<T> instantiator = this.strategy.newInstantiatorOf(clazz);\r\n        if (currentWorthTrying == null) {\r\n            this.worthTrying = Boolean.TRUE;\r\n        }\r\n        return instantiator;\r\n    } catch (ObjenesisException ex) {\r\n        if (currentWorthTrying == null) {\r\n            Throwable cause = ex.getCause();\r\n            if (cause instanceof ClassNotFoundException || cause instanceof IllegalAccessException) {\r\n                // Indicates that the chosen instantiation strategy does not work on the given JVM.\r\n                // Typically a failure to initialize the default SunReflectionFactoryInstantiator.\r\n                // Let's assume that any subsequent attempts to use Objenesis will fail as well...\r\n                this.worthTrying = Boolean.FALSE;\r\n            }\r\n        }\r\n        throw ex;\r\n    } catch (NoClassDefFoundError err) {\r\n        // Happening on the production version of Google App Engine, coming out of the\r\n        // restricted \"sun.reflect.ReflectionFactory\" class...\r\n        if (currentWorthTrying == null) {\r\n            this.worthTrying = Boolean.FALSE;\r\n        }\r\n        throw new ObjenesisException(err);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AlternativeJdkIdGenerator",
    "entityType": "class",
    "code": "private final Random random;\npublic AlternativeJdkIdGenerator() {\r\n    SecureRandom secureRandom = new SecureRandom();\r\n    byte[] seed = new byte[8];\r\n    secureRandom.nextBytes(seed);\r\n    this.random = new Random(new BigInteger(seed).longValue());\r\n}\n@Override\r\npublic UUID generateId() {\r\n    byte[] randomBytes = new byte[16];\r\n    this.random.nextBytes(randomBytes);\r\n    long mostSigBits = 0;\r\n    for (int i = 0; i < 8; i++) {\r\n        mostSigBits = (mostSigBits << 8) | (randomBytes[i] & 0xff);\r\n    }\r\n    long leastSigBits = 0;\r\n    for (int i = 8; i < 16; i++) {\r\n        leastSigBits = (leastSigBits << 8) | (randomBytes[i] & 0xff);\r\n    }\r\n    return new UUID(mostSigBits, leastSigBits);\r\n}",
    "comment": "\n * An {@link IdGenerator} that uses {@link SecureRandom} for the initial seed and\n * {@link Random} thereafter, instead of calling {@link UUID#randomUUID()} every\n * time as {@link org.springframework.util.JdkIdGenerator JdkIdGenerator} does.\n * This provides a better balance between securely random ids and performance.\n *\n * @author Rossen Stoyanchev\n * @author Rob Winch\n * @since 4.0\n "
  },
  {
    "entityId": "org.springframework.util.AlternativeJdkIdGenerator#generateId()",
    "entityType": "method",
    "code": "@Override\r\npublic UUID generateId() {\r\n    byte[] randomBytes = new byte[16];\r\n    this.random.nextBytes(randomBytes);\r\n    long mostSigBits = 0;\r\n    for (int i = 0; i < 8; i++) {\r\n        mostSigBits = (mostSigBits << 8) | (randomBytes[i] & 0xff);\r\n    }\r\n    long leastSigBits = 0;\r\n    for (int i = 8; i < 16; i++) {\r\n        leastSigBits = (leastSigBits << 8) | (randomBytes[i] & 0xff);\r\n    }\r\n    return new UUID(mostSigBits, leastSigBits);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AntPathMatcher",
    "entityType": "class",
    "code": "/**\r\n * Default path separator: \"/\".\r\n */\r\npublic static final String DEFAULT_PATH_SEPARATOR = \"/\";\nprivate static final int CACHE_TURNOFF_THRESHOLD = 65536;\nprivate static final Pattern VARIABLE_PATTERN = Pattern.compile(\"\\\\{[^/]+?\\\\}\");\nprivate static final char[] WILDCARD_CHARS = { '*', '?', '{' };\nprivate String pathSeparator;\nprivate PathSeparatorPatternCache pathSeparatorPatternCache;\nprivate boolean caseSensitive = true;\nprivate boolean trimTokens = false;\n@Nullable\r\nprivate volatile Boolean cachePatterns;\nprivate final Map<String, String[]> tokenizedPatternCache = new ConcurrentHashMap<>(256);\nfinal Map<String, AntPathStringMatcher> stringMatcherCache = new ConcurrentHashMap<>(256);\n/**\r\n * Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}.\r\n */\r\npublic AntPathMatcher() {\r\n    this.pathSeparator = DEFAULT_PATH_SEPARATOR;\r\n    this.pathSeparatorPatternCache = new PathSeparatorPatternCache(DEFAULT_PATH_SEPARATOR);\r\n}\n/**\r\n * A convenient, alternative constructor to use with a custom path separator.\r\n * @param pathSeparator the path separator to use, must not be {@code null}.\r\n * @since 4.1\r\n */\r\npublic AntPathMatcher(String pathSeparator) {\r\n    Assert.notNull(pathSeparator, \"'pathSeparator' must not be null\");\r\n    this.pathSeparator = pathSeparator;\r\n    this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator);\r\n}\n/**\r\n * Set the path separator to use for pattern parsing.\r\n * <p>Default is \"/\", as in Ant.\r\n */\r\npublic void setPathSeparator(@Nullable String pathSeparator) {\r\n    this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR);\r\n    this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator);\r\n}\n/**\r\n * Specify whether to perform pattern matching in a case-sensitive fashion.\r\n * <p>Default is {@code true}. Switch this to {@code false} for case-insensitive matching.\r\n * @since 4.2\r\n */\r\npublic void setCaseSensitive(boolean caseSensitive) {\r\n    this.caseSensitive = caseSensitive;\r\n}\n/**\r\n * Specify whether to trim tokenized paths and patterns.\r\n * <p>Default is {@code false}.\r\n */\r\npublic void setTrimTokens(boolean trimTokens) {\r\n    this.trimTokens = trimTokens;\r\n}\n/**\r\n * Specify whether to cache parsed pattern metadata for patterns passed\r\n * into this matcher's {@link #match} method. A value of {@code true}\r\n * activates an unlimited pattern cache; a value of {@code false} turns\r\n * the pattern cache off completely.\r\n * <p>Default is for the cache to be on, but with the variant to automatically\r\n * turn it off when encountering too many patterns to cache at runtime\r\n * (the threshold is 65536), assuming that arbitrary permutations of patterns\r\n * are coming in, with little chance for encountering a recurring pattern.\r\n * @since 4.0.1\r\n * @see #getStringMatcher(String)\r\n */\r\npublic void setCachePatterns(boolean cachePatterns) {\r\n    this.cachePatterns = cachePatterns;\r\n}\nprivate void deactivatePatternCache() {\r\n    this.cachePatterns = false;\r\n    this.tokenizedPatternCache.clear();\r\n    this.stringMatcherCache.clear();\r\n}\n@Override\r\npublic boolean isPattern(@Nullable String path) {\r\n    if (path == null) {\r\n        return false;\r\n    }\r\n    boolean uriVar = false;\r\n    for (int i = 0; i < path.length(); i++) {\r\n        char c = path.charAt(i);\r\n        if (c == '*' || c == '?') {\r\n            return true;\r\n        }\r\n        if (c == '{') {\r\n            uriVar = true;\r\n            continue;\r\n        }\r\n        if (c == '}' && uriVar) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n@Override\r\npublic boolean match(String pattern, String path) {\r\n    return doMatch(pattern, path, true, null);\r\n}\n@Override\r\npublic boolean matchStart(String pattern, String path) {\r\n    return doMatch(pattern, path, false, null);\r\n}\n/**\r\n * Actually match the given {@code path} against the given {@code pattern}.\r\n * @param pattern the pattern to match against\r\n * @param path the path to test\r\n * @param fullMatch whether a full pattern match is required (else a pattern match\r\n * as far as the given base path goes is sufficient)\r\n * @return {@code true} if the supplied {@code path} matched, {@code false} if it didn't\r\n */\r\nprotected boolean doMatch(String pattern, @Nullable String path, boolean fullMatch, @Nullable Map<String, String> uriTemplateVariables) {\r\n    if (path == null || path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {\r\n        return false;\r\n    }\r\n    String[] pattDirs = tokenizePattern(pattern);\r\n    if (fullMatch && this.caseSensitive && !isPotentialMatch(path, pattDirs)) {\r\n        return false;\r\n    }\r\n    String[] pathDirs = tokenizePath(path);\r\n    int pattIdxStart = 0;\r\n    int pattIdxEnd = pattDirs.length - 1;\r\n    int pathIdxStart = 0;\r\n    int pathIdxEnd = pathDirs.length - 1;\r\n    // Match all elements up to the first **\r\n    while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {\r\n        String pattDir = pattDirs[pattIdxStart];\r\n        if (\"**\".equals(pattDir)) {\r\n            break;\r\n        }\r\n        if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {\r\n            return false;\r\n        }\r\n        pattIdxStart++;\r\n        pathIdxStart++;\r\n    }\r\n    if (pathIdxStart > pathIdxEnd) {\r\n        // Path is exhausted, only match if rest of pattern is * or **'s\r\n        if (pattIdxStart > pattIdxEnd) {\r\n            return (pattern.endsWith(this.pathSeparator) == path.endsWith(this.pathSeparator));\r\n        }\r\n        if (!fullMatch) {\r\n            return true;\r\n        }\r\n        if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals(\"*\") && path.endsWith(this.pathSeparator)) {\r\n            return true;\r\n        }\r\n        for (int i = pattIdxStart; i <= pattIdxEnd; i++) {\r\n            if (!pattDirs[i].equals(\"**\")) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    } else if (pattIdxStart > pattIdxEnd) {\r\n        // String not exhausted, but pattern is. Failure.\r\n        return false;\r\n    } else if (!fullMatch && \"**\".equals(pattDirs[pattIdxStart])) {\r\n        // Path start definitely matches due to \"**\" part in pattern.\r\n        return true;\r\n    }\r\n    // up to last '**'\r\n    while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {\r\n        String pattDir = pattDirs[pattIdxEnd];\r\n        if (pattDir.equals(\"**\")) {\r\n            break;\r\n        }\r\n        if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {\r\n            return false;\r\n        }\r\n        if (pattIdxEnd == (pattDirs.length - 1) && pattern.endsWith(this.pathSeparator) != path.endsWith(this.pathSeparator)) {\r\n            return false;\r\n        }\r\n        pattIdxEnd--;\r\n        pathIdxEnd--;\r\n    }\r\n    if (pathIdxStart > pathIdxEnd) {\r\n        // String is exhausted\r\n        for (int i = pattIdxStart; i <= pattIdxEnd; i++) {\r\n            if (!pattDirs[i].equals(\"**\")) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {\r\n        int patIdxTmp = -1;\r\n        for (int i = pattIdxStart + 1; i <= pattIdxEnd; i++) {\r\n            if (pattDirs[i].equals(\"**\")) {\r\n                patIdxTmp = i;\r\n                break;\r\n            }\r\n        }\r\n        if (patIdxTmp == pattIdxStart + 1) {\r\n            // '**/**' situation, so skip one\r\n            pattIdxStart++;\r\n            continue;\r\n        }\r\n        // Find the pattern between padIdxStart & padIdxTmp in str between\r\n        // strIdxStart & strIdxEnd\r\n        int patLength = (patIdxTmp - pattIdxStart - 1);\r\n        int strLength = (pathIdxEnd - pathIdxStart + 1);\r\n        int foundIdx = -1;\r\n        strLoop: for (int i = 0; i <= strLength - patLength; i++) {\r\n            for (int j = 0; j < patLength; j++) {\r\n                String subPat = pattDirs[pattIdxStart + j + 1];\r\n                String subStr = pathDirs[pathIdxStart + i + j];\r\n                if (!matchStrings(subPat, subStr, uriTemplateVariables)) {\r\n                    continue strLoop;\r\n                }\r\n            }\r\n            foundIdx = pathIdxStart + i;\r\n            break;\r\n        }\r\n        if (foundIdx == -1) {\r\n            return false;\r\n        }\r\n        pattIdxStart = patIdxTmp;\r\n        pathIdxStart = foundIdx + patLength;\r\n    }\r\n    for (int i = pattIdxStart; i <= pattIdxEnd; i++) {\r\n        if (!pattDirs[i].equals(\"**\")) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\nprivate boolean isPotentialMatch(String path, String[] pattDirs) {\r\n    if (!this.trimTokens) {\r\n        int pos = 0;\r\n        for (String pattDir : pattDirs) {\r\n            int skipped = skipSeparator(path, pos, this.pathSeparator);\r\n            pos += skipped;\r\n            skipped = skipSegment(path, pos, pattDir);\r\n            if (skipped < pattDir.length()) {\r\n                return (skipped > 0 || (pattDir.length() > 0 && isWildcardChar(pattDir.charAt(0))));\r\n            }\r\n            pos += skipped;\r\n        }\r\n    }\r\n    return true;\r\n}\nprivate int skipSegment(String path, int pos, String prefix) {\r\n    int skipped = 0;\r\n    for (int i = 0; i < prefix.length(); i++) {\r\n        char c = prefix.charAt(i);\r\n        if (isWildcardChar(c)) {\r\n            return skipped;\r\n        }\r\n        int currPos = pos + skipped;\r\n        if (currPos >= path.length()) {\r\n            return 0;\r\n        }\r\n        if (c == path.charAt(currPos)) {\r\n            skipped++;\r\n        }\r\n    }\r\n    return skipped;\r\n}\nprivate int skipSeparator(String path, int pos, String separator) {\r\n    int skipped = 0;\r\n    while (path.startsWith(separator, pos + skipped)) {\r\n        skipped += separator.length();\r\n    }\r\n    return skipped;\r\n}\nprivate boolean isWildcardChar(char c) {\r\n    for (char candidate : WILDCARD_CHARS) {\r\n        if (c == candidate) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n/**\r\n * Tokenize the given path pattern into parts, based on this matcher's settings.\r\n * <p>Performs caching based on {@link #setCachePatterns}, delegating to\r\n * {@link #tokenizePath(String)} for the actual tokenization algorithm.\r\n * @param pattern the pattern to tokenize\r\n * @return the tokenized pattern parts\r\n */\r\nprotected String[] tokenizePattern(String pattern) {\r\n    String[] tokenized = null;\r\n    Boolean cachePatterns = this.cachePatterns;\r\n    if (cachePatterns == null || cachePatterns) {\r\n        tokenized = this.tokenizedPatternCache.get(pattern);\r\n    }\r\n    if (tokenized == null) {\r\n        tokenized = tokenizePath(pattern);\r\n        if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {\r\n            // Try to adapt to the runtime situation that we're encountering:\r\n            // There are obviously too many different patterns coming in here...\r\n            // So let's turn off the cache since the patterns are unlikely to be reoccurring.\r\n            deactivatePatternCache();\r\n            return tokenized;\r\n        }\r\n        if (cachePatterns == null || cachePatterns) {\r\n            this.tokenizedPatternCache.put(pattern, tokenized);\r\n        }\r\n    }\r\n    return tokenized;\r\n}\n/**\r\n * Tokenize the given path into parts, based on this matcher's settings.\r\n * @param path the path to tokenize\r\n * @return the tokenized path parts\r\n */\r\nprotected String[] tokenizePath(String path) {\r\n    return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true);\r\n}\n/**\r\n * Test whether a string matches against a pattern.\r\n * @param pattern the pattern to match against (never {@code null})\r\n * @param str the String which must be matched against the pattern (never {@code null})\r\n * @return {@code true} if the string matches against the pattern, or {@code false} otherwise\r\n */\r\nprivate boolean matchStrings(String pattern, String str, @Nullable Map<String, String> uriTemplateVariables) {\r\n    return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables);\r\n}\n/**\r\n * Build or retrieve an {@link AntPathStringMatcher} for the given pattern.\r\n * <p>The default implementation checks this AntPathMatcher's internal cache\r\n * (see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance\r\n * if no cached copy is found.\r\n * <p>When encountering too many patterns to cache at runtime (the threshold is 65536),\r\n * it turns the default cache off, assuming that arbitrary permutations of patterns\r\n * are coming in, with little chance for encountering a recurring pattern.\r\n * <p>This method may be overridden to implement a custom cache strategy.\r\n * @param pattern the pattern to match against (never {@code null})\r\n * @return a corresponding AntPathStringMatcher (never {@code null})\r\n * @see #setCachePatterns\r\n */\r\nprotected AntPathStringMatcher getStringMatcher(String pattern) {\r\n    AntPathStringMatcher matcher = null;\r\n    Boolean cachePatterns = this.cachePatterns;\r\n    if (cachePatterns == null || cachePatterns) {\r\n        matcher = this.stringMatcherCache.get(pattern);\r\n    }\r\n    if (matcher == null) {\r\n        matcher = new AntPathStringMatcher(pattern, this.pathSeparator, this.caseSensitive);\r\n        if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {\r\n            // Try to adapt to the runtime situation that we're encountering:\r\n            // There are obviously too many different patterns coming in here...\r\n            // So let's turn off the cache since the patterns are unlikely to be reoccurring.\r\n            deactivatePatternCache();\r\n            return matcher;\r\n        }\r\n        if (cachePatterns == null || cachePatterns) {\r\n            this.stringMatcherCache.put(pattern, matcher);\r\n        }\r\n    }\r\n    return matcher;\r\n}\n/**\r\n * Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>\r\n * <li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} &rarr; ''</li>\r\n * <li>'{@code /docs/*}' and '{@code /docs/cvs/commit} &rarr; '{@code cvs/commit}'</li>\r\n * <li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} &rarr; '{@code commit.html}'</li>\r\n * <li>'{@code /docs/**}' and '{@code /docs/cvs/commit} &rarr; '{@code cvs/commit}'</li>\r\n * <li>'{@code /docs/**\\/*.html}' and '{@code /docs/cvs/commit.html} &rarr; '{@code cvs/commit.html}'</li>\r\n * <li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} &rarr; '{@code docs/cvs/commit.html}'</li>\r\n * <li>'{@code *.html}' and '{@code /docs/cvs/commit.html} &rarr; '{@code /docs/cvs/commit.html}'</li>\r\n * <li>'{@code *}' and '{@code /docs/cvs/commit.html} &rarr; '{@code /docs/cvs/commit.html}'</li> </ul>\r\n * <p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but\r\n * does <strong>not</strong> enforce this.\r\n */\r\n@Override\r\npublic String extractPathWithinPattern(String pattern, String path) {\r\n    String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true);\r\n    String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true);\r\n    StringBuilder builder = new StringBuilder();\r\n    boolean pathStarted = false;\r\n    for (int segment = 0; segment < patternParts.length; segment++) {\r\n        String patternPart = patternParts[segment];\r\n        if (patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) {\r\n            for (; segment < pathParts.length; segment++) {\r\n                if (pathStarted || (segment == 0 && !pattern.startsWith(this.pathSeparator))) {\r\n                    builder.append(this.pathSeparator);\r\n                }\r\n                builder.append(pathParts[segment]);\r\n                pathStarted = true;\r\n            }\r\n        }\r\n    }\r\n    return builder.toString();\r\n}\n@Override\r\npublic Map<String, String> extractUriTemplateVariables(String pattern, String path) {\r\n    Map<String, String> variables = new LinkedHashMap<>();\r\n    boolean result = doMatch(pattern, path, true, variables);\r\n    if (!result) {\r\n        throw new IllegalStateException(\"Pattern \\\"\" + pattern + \"\\\" is not a match for \\\"\" + path + \"\\\"\");\r\n    }\r\n    return variables;\r\n}\n/**\r\n * Combine two patterns into a new pattern.\r\n * <p>This implementation simply concatenates the two patterns, unless\r\n * the first pattern contains a file extension match (for example, {@code *.html}).\r\n * In that case, the second pattern will be merged into the first. Otherwise,\r\n * an {@code IllegalArgumentException} will be thrown.\r\n * <h4>Examples</h4>\r\n * <table border=\"1\">\r\n * <tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr>\r\n * <tr><td>{@code null}</td><td>{@code null}</td><td>&nbsp;</td></tr>\r\n * <tr><td>/hotels</td><td>{@code null}</td><td>/hotels</td></tr>\r\n * <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>\r\n * <tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr>\r\n * <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>\r\n * <tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr>\r\n * <tr><td>/hotels/&#42;&#42;</td><td>/bookings</td><td>/hotels/&#42;&#42;/bookings</td></tr>\r\n * <tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>\r\n * <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>\r\n * <tr><td>/hotels/&#42;&#42;</td><td>{hotel}</td><td>/hotels/&#42;&#42;/{hotel}</td></tr>\r\n * <tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr>\r\n * <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>\r\n * <tr><td>/*.html</td><td>/*.txt</td><td>{@code IllegalArgumentException}</td></tr>\r\n * </table>\r\n * @param pattern1 the first pattern\r\n * @param pattern2 the second pattern\r\n * @return the combination of the two patterns\r\n * @throws IllegalArgumentException if the two patterns cannot be combined\r\n */\r\n@Override\r\npublic String combine(String pattern1, String pattern2) {\r\n    if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {\r\n        return \"\";\r\n    }\r\n    if (!StringUtils.hasText(pattern1)) {\r\n        return pattern2;\r\n    }\r\n    if (!StringUtils.hasText(pattern2)) {\r\n        return pattern1;\r\n    }\r\n    boolean pattern1ContainsUriVar = (pattern1.indexOf('{') != -1);\r\n    if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {\r\n        // /* + /hotel -> /hotel ; \"/*.*\" + \"/*.html\" -> /*.html\r\n        // However /user + /user -> /usr/user ; /{foo} + /bar -> /{foo}/bar\r\n        return pattern2;\r\n    }\r\n    // /hotels/* + /booking -> /hotels/booking\r\n    // /hotels/* + booking -> /hotels/booking\r\n    if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {\r\n        return concat(pattern1.substring(0, pattern1.length() - 2), pattern2);\r\n    }\r\n    // /hotels/** + /booking -> /hotels/**/booking\r\n    // /hotels/** + booking -> /hotels/**/booking\r\n    if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {\r\n        return concat(pattern1, pattern2);\r\n    }\r\n    int starDotPos1 = pattern1.indexOf(\"*.\");\r\n    if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(\".\")) {\r\n        // simply concatenate the two patterns\r\n        return concat(pattern1, pattern2);\r\n    }\r\n    String ext1 = pattern1.substring(starDotPos1 + 1);\r\n    int dotPos2 = pattern2.indexOf('.');\r\n    String file2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2));\r\n    String ext2 = (dotPos2 == -1 ? \"\" : pattern2.substring(dotPos2));\r\n    boolean ext1All = (ext1.equals(\".*\") || ext1.isEmpty());\r\n    boolean ext2All = (ext2.equals(\".*\") || ext2.isEmpty());\r\n    if (!ext1All && !ext2All) {\r\n        throw new IllegalArgumentException(\"Cannot combine patterns: \" + pattern1 + \" vs \" + pattern2);\r\n    }\r\n    String ext = (ext1All ? ext2 : ext1);\r\n    return file2 + ext;\r\n}\nprivate String concat(String path1, String path2) {\r\n    boolean path1EndsWithSeparator = path1.endsWith(this.pathSeparator);\r\n    boolean path2StartsWithSeparator = path2.startsWith(this.pathSeparator);\r\n    if (path1EndsWithSeparator && path2StartsWithSeparator) {\r\n        return path1 + path2.substring(1);\r\n    } else if (path1EndsWithSeparator || path2StartsWithSeparator) {\r\n        return path1 + path2;\r\n    } else {\r\n        return path1 + this.pathSeparator + path2;\r\n    }\r\n}\n/**\r\n * Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of\r\n * explicitness.\r\n * <p>This {@code Comparator} will {@linkplain java.util.List#sort(Comparator) sort}\r\n * a list so that more specific patterns (without URI templates or wild cards) come before\r\n * generic patterns. So given a list with the following patterns, the returned comparator\r\n * will sort this list so that the order will be as indicated.\r\n * <ol>\r\n * <li>{@code /hotels/new}</li>\r\n * <li>{@code /hotels/{hotel}}</li>\r\n * <li>{@code /hotels/*}</li>\r\n * </ol>\r\n * <p>The full path given as parameter is used to test for exact matches. So when the given path\r\n * is {@code /hotels/2}, the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}.\r\n * @param path the full path to use for comparison\r\n * @return a comparator capable of sorting patterns in order of explicitness\r\n */\r\n@Override\r\npublic Comparator<String> getPatternComparator(String path) {\r\n    return new AntPatternComparator(path, this.pathSeparator);\r\n}\n/**\r\n * Tests whether a string matches against a pattern via a {@link Pattern}.\r\n * <p>The pattern may contain special characters: '*' means zero or more characters; '?' means one and\r\n * only one character; '{' and '}' indicate a URI template pattern. For example {@code /users/{user}}.\r\n */\r\nprotected static class AntPathStringMatcher {\r\n\r\n    private static final String DEFAULT_VARIABLE_PATTERN = \"((?s).*)\";\r\n\r\n    private final String rawPattern;\r\n\r\n    private final boolean caseSensitive;\r\n\r\n    private final boolean exactMatch;\r\n\r\n    @Nullable\r\n    private final Pattern pattern;\r\n\r\n    private final List<String> variableNames = new ArrayList<>();\r\n\r\n    protected AntPathStringMatcher(String pattern, String pathSeparator, boolean caseSensitive) {\r\n        this.rawPattern = pattern;\r\n        this.caseSensitive = caseSensitive;\r\n        StringBuilder patternBuilder = new StringBuilder();\r\n        Matcher matcher = getGlobPattern(pathSeparator).matcher(pattern);\r\n        int end = 0;\r\n        while (matcher.find()) {\r\n            patternBuilder.append(quote(pattern, end, matcher.start()));\r\n            String match = matcher.group();\r\n            if (\"?\".equals(match)) {\r\n                patternBuilder.append('.');\r\n            } else if (\"*\".equals(match)) {\r\n                patternBuilder.append(\".*\");\r\n            } else if (match.startsWith(\"{\") && match.endsWith(\"}\")) {\r\n                int colonIdx = match.indexOf(':');\r\n                if (colonIdx == -1) {\r\n                    patternBuilder.append(DEFAULT_VARIABLE_PATTERN);\r\n                    this.variableNames.add(matcher.group(1));\r\n                } else {\r\n                    String variablePattern = match.substring(colonIdx + 1, match.length() - 1);\r\n                    patternBuilder.append('(');\r\n                    patternBuilder.append(variablePattern);\r\n                    patternBuilder.append(')');\r\n                    String variableName = match.substring(1, colonIdx);\r\n                    this.variableNames.add(variableName);\r\n                }\r\n            }\r\n            end = matcher.end();\r\n        }\r\n        // No glob pattern was found, this is an exact String match\r\n        if (end == 0) {\r\n            this.exactMatch = true;\r\n            this.pattern = null;\r\n        } else {\r\n            this.exactMatch = false;\r\n            patternBuilder.append(quote(pattern, end, pattern.length()));\r\n            this.pattern = Pattern.compile(patternBuilder.toString(), Pattern.DOTALL | (this.caseSensitive ? 0 : Pattern.CASE_INSENSITIVE));\r\n        }\r\n    }\r\n\r\n    private static Pattern getGlobPattern(String pathSeparator) {\r\n        String pattern = \"\\\\?|\\\\*|\\\\{((?:\\\\{[^\" + pathSeparator + \"]+?\\\\}|[^\" + pathSeparator + \"{}]|\\\\\\\\[{}])+?)\\\\}\";\r\n        return Pattern.compile(pattern);\r\n    }\r\n\r\n    private String quote(String s, int start, int end) {\r\n        if (start == end) {\r\n            return \"\";\r\n        }\r\n        return Pattern.quote(s.substring(start, end));\r\n    }\r\n\r\n    /**\r\n     * Main entry point.\r\n     * @return {@code true} if the string matches against the pattern, or {@code false} otherwise.\r\n     */\r\n    public boolean matchStrings(String str, @Nullable Map<String, String> uriTemplateVariables) {\r\n        if (this.exactMatch) {\r\n            return this.caseSensitive ? this.rawPattern.equals(str) : this.rawPattern.equalsIgnoreCase(str);\r\n        } else if (this.pattern != null) {\r\n            Matcher matcher = this.pattern.matcher(str);\r\n            if (matcher.matches()) {\r\n                if (uriTemplateVariables != null) {\r\n                    if (this.variableNames.size() != matcher.groupCount()) {\r\n                        throw new IllegalArgumentException(\"The number of capturing groups in the pattern segment \" + this.pattern + \" does not match the number of URI template variables it defines, \" + \"which can occur if capturing groups are used in a URI template regex. \" + \"Use non-capturing groups instead.\");\r\n                    }\r\n                    for (int i = 1; i <= matcher.groupCount(); i++) {\r\n                        String name = this.variableNames.get(i - 1);\r\n                        if (name.startsWith(\"*\")) {\r\n                            throw new IllegalArgumentException(\"Capturing patterns (\" + name + \") are not \" + \"supported by the AntPathMatcher. Use the PathPatternParser instead.\");\r\n                        }\r\n                        String value = matcher.group(i);\r\n                        uriTemplateVariables.put(name, value);\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\n/**\r\n * The default {@link Comparator} implementation returned by\r\n * {@link #getPatternComparator(String)}.\r\n * <p>In order, the most \"generic\" pattern is determined by the following:\r\n * <ul>\r\n * <li>if it's null or a capture all pattern (i.e. it is equal to \"/**\")</li>\r\n * <li>if the other pattern is an actual match</li>\r\n * <li>if it's a catch-all pattern (i.e. it ends with \"**\"</li>\r\n * <li>if it's got more \"*\" than the other pattern</li>\r\n * <li>if it's got more \"{foo}\" than the other pattern</li>\r\n * <li>if it's shorter than the other pattern</li>\r\n * </ul>\r\n */\r\nprotected static class AntPatternComparator implements Comparator<String> {\r\n\r\n    private final String path;\r\n\r\n    private final String pathSeparator;\r\n\r\n    public AntPatternComparator(String path) {\r\n        this(path, DEFAULT_PATH_SEPARATOR);\r\n    }\r\n\r\n    public AntPatternComparator(String path, String pathSeparator) {\r\n        this.path = path;\r\n        this.pathSeparator = pathSeparator;\r\n    }\r\n\r\n    /**\r\n     * Compare two patterns to determine which should match first, i.e. which\r\n     * is the most specific regarding the current path.\r\n     * @return a negative integer, zero, or a positive integer as pattern1 is\r\n     * more specific, equally specific, or less specific than pattern2.\r\n     */\r\n    @Override\r\n    public int compare(String pattern1, String pattern2) {\r\n        PatternInfo info1 = new PatternInfo(pattern1, this.pathSeparator);\r\n        PatternInfo info2 = new PatternInfo(pattern2, this.pathSeparator);\r\n        if (info1.isLeastSpecific() && info2.isLeastSpecific()) {\r\n            return 0;\r\n        } else if (info1.isLeastSpecific()) {\r\n            return 1;\r\n        } else if (info2.isLeastSpecific()) {\r\n            return -1;\r\n        }\r\n        boolean pattern1EqualsPath = pattern1.equals(this.path);\r\n        boolean pattern2EqualsPath = pattern2.equals(this.path);\r\n        if (pattern1EqualsPath && pattern2EqualsPath) {\r\n            return 0;\r\n        } else if (pattern1EqualsPath) {\r\n            return -1;\r\n        } else if (pattern2EqualsPath) {\r\n            return 1;\r\n        }\r\n        if (info1.isPrefixPattern() && info2.isPrefixPattern()) {\r\n            return info2.getLength() - info1.getLength();\r\n        } else if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {\r\n            return 1;\r\n        } else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {\r\n            return -1;\r\n        }\r\n        if (info1.getTotalCount() != info2.getTotalCount()) {\r\n            return info1.getTotalCount() - info2.getTotalCount();\r\n        }\r\n        if (info1.getLength() != info2.getLength()) {\r\n            return info2.getLength() - info1.getLength();\r\n        }\r\n        if (info1.getSingleWildcards() < info2.getSingleWildcards()) {\r\n            return -1;\r\n        } else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {\r\n            return 1;\r\n        }\r\n        if (info1.getUriVars() < info2.getUriVars()) {\r\n            return -1;\r\n        } else if (info2.getUriVars() < info1.getUriVars()) {\r\n            return 1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Value class that holds information about the pattern, for example, number of\r\n     * occurrences of \"*\", \"**\", and \"{\" pattern elements.\r\n     */\r\n    private static class PatternInfo {\r\n\r\n        @Nullable\r\n        private final String pattern;\r\n\r\n        private int uriVars;\r\n\r\n        private int singleWildcards;\r\n\r\n        private int doubleWildcards;\r\n\r\n        private boolean catchAllPattern;\r\n\r\n        private boolean prefixPattern;\r\n\r\n        @Nullable\r\n        private Integer length;\r\n\r\n        PatternInfo(@Nullable String pattern, String pathSeparator) {\r\n            this.pattern = pattern;\r\n            if (this.pattern != null) {\r\n                initCounters();\r\n                this.catchAllPattern = this.pattern.equals(pathSeparator + \"**\");\r\n                this.prefixPattern = !this.catchAllPattern && this.pattern.endsWith(pathSeparator + \"**\");\r\n            }\r\n            if (this.uriVars == 0) {\r\n                this.length = (this.pattern != null ? this.pattern.length() : 0);\r\n            }\r\n        }\r\n\r\n        protected void initCounters() {\r\n            int pos = 0;\r\n            if (this.pattern != null) {\r\n                while (pos < this.pattern.length()) {\r\n                    if (this.pattern.charAt(pos) == '{') {\r\n                        this.uriVars++;\r\n                        pos++;\r\n                    } else if (this.pattern.charAt(pos) == '*') {\r\n                        if (pos + 1 < this.pattern.length() && this.pattern.charAt(pos + 1) == '*') {\r\n                            this.doubleWildcards++;\r\n                            pos += 2;\r\n                        } else if (pos > 0 && !this.pattern.substring(pos - 1).equals(\".*\")) {\r\n                            this.singleWildcards++;\r\n                            pos++;\r\n                        } else {\r\n                            pos++;\r\n                        }\r\n                    } else {\r\n                        pos++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        public int getUriVars() {\r\n            return this.uriVars;\r\n        }\r\n\r\n        public int getSingleWildcards() {\r\n            return this.singleWildcards;\r\n        }\r\n\r\n        public int getDoubleWildcards() {\r\n            return this.doubleWildcards;\r\n        }\r\n\r\n        public boolean isLeastSpecific() {\r\n            return (this.pattern == null || this.catchAllPattern);\r\n        }\r\n\r\n        public boolean isPrefixPattern() {\r\n            return this.prefixPattern;\r\n        }\r\n\r\n        public int getTotalCount() {\r\n            return this.uriVars + this.singleWildcards + (2 * this.doubleWildcards);\r\n        }\r\n\r\n        /**\r\n         * Returns the length of the given pattern, where template variables are considered to be 1 long.\r\n         */\r\n        public int getLength() {\r\n            if (this.length == null) {\r\n                this.length = (this.pattern != null ? VARIABLE_PATTERN.matcher(this.pattern).replaceAll(\"#\").length() : 0);\r\n            }\r\n            return this.length;\r\n        }\r\n    }\r\n}\n/**\r\n * A simple cache for patterns that depend on the configured path separator.\r\n */\r\nprivate static class PathSeparatorPatternCache {\r\n\r\n    private final String endsOnWildCard;\r\n\r\n    private final String endsOnDoubleWildCard;\r\n\r\n    public PathSeparatorPatternCache(String pathSeparator) {\r\n        this.endsOnWildCard = pathSeparator + \"*\";\r\n        this.endsOnDoubleWildCard = pathSeparator + \"**\";\r\n    }\r\n\r\n    public String getEndsOnWildCard() {\r\n        return this.endsOnWildCard;\r\n    }\r\n\r\n    public String getEndsOnDoubleWildCard() {\r\n        return this.endsOnDoubleWildCard;\r\n    }\r\n}",
    "comment": "\n * {@link PathMatcher} implementation for Ant-style path patterns.\n *\n * <p>Part of this mapping code has been kindly borrowed from <a href=\"https://ant.apache.org\">Apache Ant</a>.\n *\n * <p>The mapping matches URLs using the following rules:<br>\n * <ul>\n * <li>{@code ?} matches one character</li>\n * <li>{@code *} matches zero or more characters</li>\n * <li>{@code **} matches zero or more <em>directories</em> in a path</li>\n * <li>{@code {spring:[a-z]+}} matches the regexp {@code [a-z]+} as a path variable named \"spring\"</li>\n * </ul>\n *\n * <h3>Examples</h3>\n * <ul>\n * <li>{@code com/t?st.jsp} &mdash; matches {@code com/test.jsp} but also\n * {@code com/tast.jsp} or {@code com/txst.jsp}</li>\n * <li>{@code com/*.jsp} &mdash; matches all {@code .jsp} files in the\n * {@code com} directory</li>\n * <li><code>com/&#42;&#42;/test.jsp</code> &mdash; matches all {@code test.jsp}\n * files underneath the {@code com} path</li>\n * <li><code>org/springframework/&#42;&#42;/*.jsp</code> &mdash; matches all\n * {@code .jsp} files underneath the {@code org/springframework} path</li>\n * <li><code>org/&#42;&#42;/servlet/bla.jsp</code> &mdash; matches\n * {@code org/springframework/servlet/bla.jsp} but also\n * {@code org/springframework/testing/servlet/bla.jsp} and {@code org/servlet/bla.jsp}</li>\n * <li>{@code com/{filename:\\\\w+}.jsp} will match {@code com/test.jsp} and assign the value {@code test}\n * to the {@code filename} variable</li>\n * </ul>\n *\n * <p><strong>Note:</strong> a pattern and a path must both be absolute or must\n * both be relative in order for the two to match. Therefore, it is recommended\n * that users of this implementation to sanitize patterns in order to prefix\n * them with \"/\" as it makes sense in the context in which they're used.\n *\n * @author Alef Arendsen\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Arjen Poutsma\n * @author Rossen Stoyanchev\n * @author Sam Brannen\n * @author Vladislav Kisel\n * @since 16.07.2003\n "
  },
  {
    "entityId": "org.springframework.util.AntPathMatcher#setPathSeparator(String)",
    "entityType": "method",
    "code": "/**\r\n * Set the path separator to use for pattern parsing.\r\n * <p>Default is \"/\", as in Ant.\r\n */\r\npublic void setPathSeparator(@Nullable String pathSeparator) {\r\n    this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR);\r\n    this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator);\r\n}",
    "comment": "\n\t * Set the path separator to use for pattern parsing.\n\t * <p>Default is \"/\", as in Ant.\n\t "
  },
  {
    "entityId": "org.springframework.util.AntPathMatcher#setCaseSensitive(boolean)",
    "entityType": "method",
    "code": "/**\r\n * Specify whether to perform pattern matching in a case-sensitive fashion.\r\n * <p>Default is {@code true}. Switch this to {@code false} for case-insensitive matching.\r\n * @since 4.2\r\n */\r\npublic void setCaseSensitive(boolean caseSensitive) {\r\n    this.caseSensitive = caseSensitive;\r\n}",
    "comment": "\n\t * Specify whether to perform pattern matching in a case-sensitive fashion.\n\t * <p>Default is {@code true}. Switch this to {@code false} for case-insensitive matching.\n\t * @since 4.2\n\t "
  },
  {
    "entityId": "org.springframework.util.AntPathMatcher#setTrimTokens(boolean)",
    "entityType": "method",
    "code": "/**\r\n * Specify whether to trim tokenized paths and patterns.\r\n * <p>Default is {@code false}.\r\n */\r\npublic void setTrimTokens(boolean trimTokens) {\r\n    this.trimTokens = trimTokens;\r\n}",
    "comment": "\n\t * Specify whether to trim tokenized paths and patterns.\n\t * <p>Default is {@code false}.\n\t "
  },
  {
    "entityId": "org.springframework.util.AntPathMatcher#setCachePatterns(boolean)",
    "entityType": "method",
    "code": "/**\r\n * Specify whether to cache parsed pattern metadata for patterns passed\r\n * into this matcher's {@link #match} method. A value of {@code true}\r\n * activates an unlimited pattern cache; a value of {@code false} turns\r\n * the pattern cache off completely.\r\n * <p>Default is for the cache to be on, but with the variant to automatically\r\n * turn it off when encountering too many patterns to cache at runtime\r\n * (the threshold is 65536), assuming that arbitrary permutations of patterns\r\n * are coming in, with little chance for encountering a recurring pattern.\r\n * @since 4.0.1\r\n * @see #getStringMatcher(String)\r\n */\r\npublic void setCachePatterns(boolean cachePatterns) {\r\n    this.cachePatterns = cachePatterns;\r\n}",
    "comment": "\n\t * Specify whether to cache parsed pattern metadata for patterns passed\n\t * into this matcher's {@link #match} method. A value of {@code true}\n\t * activates an unlimited pattern cache; a value of {@code false} turns\n\t * the pattern cache off completely.\n\t * <p>Default is for the cache to be on, but with the variant to automatically\n\t * turn it off when encountering too many patterns to cache at runtime\n\t * (the threshold is 65536), assuming that arbitrary permutations of patterns\n\t * are coming in, with little chance for encountering a recurring pattern.\n\t * @since 4.0.1\n\t * @see #getStringMatcher(String)\n\t "
  },
  {
    "entityId": "org.springframework.util.AntPathMatcher#deactivatePatternCache()",
    "entityType": "method",
    "code": "private void deactivatePatternCache() {\r\n    this.cachePatterns = false;\r\n    this.tokenizedPatternCache.clear();\r\n    this.stringMatcherCache.clear();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AntPathMatcher#isPattern(String)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isPattern(@Nullable String path) {\r\n    if (path == null) {\r\n        return false;\r\n    }\r\n    boolean uriVar = false;\r\n    for (int i = 0; i < path.length(); i++) {\r\n        char c = path.charAt(i);\r\n        if (c == '*' || c == '?') {\r\n            return true;\r\n        }\r\n        if (c == '{') {\r\n            uriVar = true;\r\n            continue;\r\n        }\r\n        if (c == '}' && uriVar) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AntPathMatcher#match(String,String)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean match(String pattern, String path) {\r\n    return doMatch(pattern, path, true, null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AntPathMatcher#matchStart(String,String)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean matchStart(String pattern, String path) {\r\n    return doMatch(pattern, path, false, null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AntPathMatcher#doMatch(String,String,boolean,Map<String,String>)",
    "entityType": "method",
    "code": "/**\r\n * Actually match the given {@code path} against the given {@code pattern}.\r\n * @param pattern the pattern to match against\r\n * @param path the path to test\r\n * @param fullMatch whether a full pattern match is required (else a pattern match\r\n * as far as the given base path goes is sufficient)\r\n * @return {@code true} if the supplied {@code path} matched, {@code false} if it didn't\r\n */\r\nprotected boolean doMatch(String pattern, @Nullable String path, boolean fullMatch, @Nullable Map<String, String> uriTemplateVariables) {\r\n    if (path == null || path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {\r\n        return false;\r\n    }\r\n    String[] pattDirs = tokenizePattern(pattern);\r\n    if (fullMatch && this.caseSensitive && !isPotentialMatch(path, pattDirs)) {\r\n        return false;\r\n    }\r\n    String[] pathDirs = tokenizePath(path);\r\n    int pattIdxStart = 0;\r\n    int pattIdxEnd = pattDirs.length - 1;\r\n    int pathIdxStart = 0;\r\n    int pathIdxEnd = pathDirs.length - 1;\r\n    // Match all elements up to the first **\r\n    while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {\r\n        String pattDir = pattDirs[pattIdxStart];\r\n        if (\"**\".equals(pattDir)) {\r\n            break;\r\n        }\r\n        if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {\r\n            return false;\r\n        }\r\n        pattIdxStart++;\r\n        pathIdxStart++;\r\n    }\r\n    if (pathIdxStart > pathIdxEnd) {\r\n        // Path is exhausted, only match if rest of pattern is * or **'s\r\n        if (pattIdxStart > pattIdxEnd) {\r\n            return (pattern.endsWith(this.pathSeparator) == path.endsWith(this.pathSeparator));\r\n        }\r\n        if (!fullMatch) {\r\n            return true;\r\n        }\r\n        if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals(\"*\") && path.endsWith(this.pathSeparator)) {\r\n            return true;\r\n        }\r\n        for (int i = pattIdxStart; i <= pattIdxEnd; i++) {\r\n            if (!pattDirs[i].equals(\"**\")) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    } else if (pattIdxStart > pattIdxEnd) {\r\n        // String not exhausted, but pattern is. Failure.\r\n        return false;\r\n    } else if (!fullMatch && \"**\".equals(pattDirs[pattIdxStart])) {\r\n        // Path start definitely matches due to \"**\" part in pattern.\r\n        return true;\r\n    }\r\n    // up to last '**'\r\n    while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {\r\n        String pattDir = pattDirs[pattIdxEnd];\r\n        if (pattDir.equals(\"**\")) {\r\n            break;\r\n        }\r\n        if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {\r\n            return false;\r\n        }\r\n        if (pattIdxEnd == (pattDirs.length - 1) && pattern.endsWith(this.pathSeparator) != path.endsWith(this.pathSeparator)) {\r\n            return false;\r\n        }\r\n        pattIdxEnd--;\r\n        pathIdxEnd--;\r\n    }\r\n    if (pathIdxStart > pathIdxEnd) {\r\n        // String is exhausted\r\n        for (int i = pattIdxStart; i <= pattIdxEnd; i++) {\r\n            if (!pattDirs[i].equals(\"**\")) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {\r\n        int patIdxTmp = -1;\r\n        for (int i = pattIdxStart + 1; i <= pattIdxEnd; i++) {\r\n            if (pattDirs[i].equals(\"**\")) {\r\n                patIdxTmp = i;\r\n                break;\r\n            }\r\n        }\r\n        if (patIdxTmp == pattIdxStart + 1) {\r\n            // '**/**' situation, so skip one\r\n            pattIdxStart++;\r\n            continue;\r\n        }\r\n        // Find the pattern between padIdxStart & padIdxTmp in str between\r\n        // strIdxStart & strIdxEnd\r\n        int patLength = (patIdxTmp - pattIdxStart - 1);\r\n        int strLength = (pathIdxEnd - pathIdxStart + 1);\r\n        int foundIdx = -1;\r\n        strLoop: for (int i = 0; i <= strLength - patLength; i++) {\r\n            for (int j = 0; j < patLength; j++) {\r\n                String subPat = pattDirs[pattIdxStart + j + 1];\r\n                String subStr = pathDirs[pathIdxStart + i + j];\r\n                if (!matchStrings(subPat, subStr, uriTemplateVariables)) {\r\n                    continue strLoop;\r\n                }\r\n            }\r\n            foundIdx = pathIdxStart + i;\r\n            break;\r\n        }\r\n        if (foundIdx == -1) {\r\n            return false;\r\n        }\r\n        pattIdxStart = patIdxTmp;\r\n        pathIdxStart = foundIdx + patLength;\r\n    }\r\n    for (int i = pattIdxStart; i <= pattIdxEnd; i++) {\r\n        if (!pattDirs[i].equals(\"**\")) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "comment": "\n\t * Actually match the given {@code path} against the given {@code pattern}.\n\t * @param pattern the pattern to match against\n\t * @param path the path to test\n\t * @param fullMatch whether a full pattern match is required (else a pattern match\n\t * as far as the given base path goes is sufficient)\n\t * @return {@code true} if the supplied {@code path} matched, {@code false} if it didn't\n\t "
  },
  {
    "entityId": "org.springframework.util.AntPathMatcher#isPotentialMatch(String,String[])",
    "entityType": "method",
    "code": "private boolean isPotentialMatch(String path, String[] pattDirs) {\r\n    if (!this.trimTokens) {\r\n        int pos = 0;\r\n        for (String pattDir : pattDirs) {\r\n            int skipped = skipSeparator(path, pos, this.pathSeparator);\r\n            pos += skipped;\r\n            skipped = skipSegment(path, pos, pattDir);\r\n            if (skipped < pattDir.length()) {\r\n                return (skipped > 0 || (pattDir.length() > 0 && isWildcardChar(pattDir.charAt(0))));\r\n            }\r\n            pos += skipped;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AntPathMatcher#skipSegment(String,int,String)",
    "entityType": "method",
    "code": "private int skipSegment(String path, int pos, String prefix) {\r\n    int skipped = 0;\r\n    for (int i = 0; i < prefix.length(); i++) {\r\n        char c = prefix.charAt(i);\r\n        if (isWildcardChar(c)) {\r\n            return skipped;\r\n        }\r\n        int currPos = pos + skipped;\r\n        if (currPos >= path.length()) {\r\n            return 0;\r\n        }\r\n        if (c == path.charAt(currPos)) {\r\n            skipped++;\r\n        }\r\n    }\r\n    return skipped;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AntPathMatcher#skipSeparator(String,int,String)",
    "entityType": "method",
    "code": "private int skipSeparator(String path, int pos, String separator) {\r\n    int skipped = 0;\r\n    while (path.startsWith(separator, pos + skipped)) {\r\n        skipped += separator.length();\r\n    }\r\n    return skipped;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AntPathMatcher#isWildcardChar(char)",
    "entityType": "method",
    "code": "private boolean isWildcardChar(char c) {\r\n    for (char candidate : WILDCARD_CHARS) {\r\n        if (c == candidate) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AntPathMatcher#tokenizePattern(String)",
    "entityType": "method",
    "code": "/**\r\n * Tokenize the given path pattern into parts, based on this matcher's settings.\r\n * <p>Performs caching based on {@link #setCachePatterns}, delegating to\r\n * {@link #tokenizePath(String)} for the actual tokenization algorithm.\r\n * @param pattern the pattern to tokenize\r\n * @return the tokenized pattern parts\r\n */\r\nprotected String[] tokenizePattern(String pattern) {\r\n    String[] tokenized = null;\r\n    Boolean cachePatterns = this.cachePatterns;\r\n    if (cachePatterns == null || cachePatterns) {\r\n        tokenized = this.tokenizedPatternCache.get(pattern);\r\n    }\r\n    if (tokenized == null) {\r\n        tokenized = tokenizePath(pattern);\r\n        if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {\r\n            // Try to adapt to the runtime situation that we're encountering:\r\n            // There are obviously too many different patterns coming in here...\r\n            // So let's turn off the cache since the patterns are unlikely to be reoccurring.\r\n            deactivatePatternCache();\r\n            return tokenized;\r\n        }\r\n        if (cachePatterns == null || cachePatterns) {\r\n            this.tokenizedPatternCache.put(pattern, tokenized);\r\n        }\r\n    }\r\n    return tokenized;\r\n}",
    "comment": "\n\t * Tokenize the given path pattern into parts, based on this matcher's settings.\n\t * <p>Performs caching based on {@link #setCachePatterns}, delegating to\n\t * {@link #tokenizePath(String)} for the actual tokenization algorithm.\n\t * @param pattern the pattern to tokenize\n\t * @return the tokenized pattern parts\n\t "
  },
  {
    "entityId": "org.springframework.util.AntPathMatcher#tokenizePath(String)",
    "entityType": "method",
    "code": "/**\r\n * Tokenize the given path into parts, based on this matcher's settings.\r\n * @param path the path to tokenize\r\n * @return the tokenized path parts\r\n */\r\nprotected String[] tokenizePath(String path) {\r\n    return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true);\r\n}",
    "comment": "\n\t * Tokenize the given path into parts, based on this matcher's settings.\n\t * @param path the path to tokenize\n\t * @return the tokenized path parts\n\t "
  },
  {
    "entityId": "org.springframework.util.AntPathMatcher#matchStrings(String,String,Map<String,String>)",
    "entityType": "method",
    "code": "/**\r\n * Test whether a string matches against a pattern.\r\n * @param pattern the pattern to match against (never {@code null})\r\n * @param str the String which must be matched against the pattern (never {@code null})\r\n * @return {@code true} if the string matches against the pattern, or {@code false} otherwise\r\n */\r\nprivate boolean matchStrings(String pattern, String str, @Nullable Map<String, String> uriTemplateVariables) {\r\n    return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables);\r\n}",
    "comment": "\n\t * Test whether a string matches against a pattern.\n\t * @param pattern the pattern to match against (never {@code null})\n\t * @param str the String which must be matched against the pattern (never {@code null})\n\t * @return {@code true} if the string matches against the pattern, or {@code false} otherwise\n\t "
  },
  {
    "entityId": "org.springframework.util.AntPathMatcher#getStringMatcher(String)",
    "entityType": "method",
    "code": "/**\r\n * Build or retrieve an {@link AntPathStringMatcher} for the given pattern.\r\n * <p>The default implementation checks this AntPathMatcher's internal cache\r\n * (see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance\r\n * if no cached copy is found.\r\n * <p>When encountering too many patterns to cache at runtime (the threshold is 65536),\r\n * it turns the default cache off, assuming that arbitrary permutations of patterns\r\n * are coming in, with little chance for encountering a recurring pattern.\r\n * <p>This method may be overridden to implement a custom cache strategy.\r\n * @param pattern the pattern to match against (never {@code null})\r\n * @return a corresponding AntPathStringMatcher (never {@code null})\r\n * @see #setCachePatterns\r\n */\r\nprotected AntPathStringMatcher getStringMatcher(String pattern) {\r\n    AntPathStringMatcher matcher = null;\r\n    Boolean cachePatterns = this.cachePatterns;\r\n    if (cachePatterns == null || cachePatterns) {\r\n        matcher = this.stringMatcherCache.get(pattern);\r\n    }\r\n    if (matcher == null) {\r\n        matcher = new AntPathStringMatcher(pattern, this.pathSeparator, this.caseSensitive);\r\n        if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {\r\n            // Try to adapt to the runtime situation that we're encountering:\r\n            // There are obviously too many different patterns coming in here...\r\n            // So let's turn off the cache since the patterns are unlikely to be reoccurring.\r\n            deactivatePatternCache();\r\n            return matcher;\r\n        }\r\n        if (cachePatterns == null || cachePatterns) {\r\n            this.stringMatcherCache.put(pattern, matcher);\r\n        }\r\n    }\r\n    return matcher;\r\n}",
    "comment": "\n\t * Build or retrieve an {@link AntPathStringMatcher} for the given pattern.\n\t * <p>The default implementation checks this AntPathMatcher's internal cache\n\t * (see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance\n\t * if no cached copy is found.\n\t * <p>When encountering too many patterns to cache at runtime (the threshold is 65536),\n\t * it turns the default cache off, assuming that arbitrary permutations of patterns\n\t * are coming in, with little chance for encountering a recurring pattern.\n\t * <p>This method may be overridden to implement a custom cache strategy.\n\t * @param pattern the pattern to match against (never {@code null})\n\t * @return a corresponding AntPathStringMatcher (never {@code null})\n\t * @see #setCachePatterns\n\t "
  },
  {
    "entityId": "org.springframework.util.AntPathMatcher#extractPathWithinPattern(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>\r\n * <li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} &rarr; ''</li>\r\n * <li>'{@code /docs/*}' and '{@code /docs/cvs/commit} &rarr; '{@code cvs/commit}'</li>\r\n * <li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} &rarr; '{@code commit.html}'</li>\r\n * <li>'{@code /docs/**}' and '{@code /docs/cvs/commit} &rarr; '{@code cvs/commit}'</li>\r\n * <li>'{@code /docs/**\\/*.html}' and '{@code /docs/cvs/commit.html} &rarr; '{@code cvs/commit.html}'</li>\r\n * <li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} &rarr; '{@code docs/cvs/commit.html}'</li>\r\n * <li>'{@code *.html}' and '{@code /docs/cvs/commit.html} &rarr; '{@code /docs/cvs/commit.html}'</li>\r\n * <li>'{@code *}' and '{@code /docs/cvs/commit.html} &rarr; '{@code /docs/cvs/commit.html}'</li> </ul>\r\n * <p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but\r\n * does <strong>not</strong> enforce this.\r\n */\r\n@Override\r\npublic String extractPathWithinPattern(String pattern, String path) {\r\n    String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true);\r\n    String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true);\r\n    StringBuilder builder = new StringBuilder();\r\n    boolean pathStarted = false;\r\n    for (int segment = 0; segment < patternParts.length; segment++) {\r\n        String patternPart = patternParts[segment];\r\n        if (patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) {\r\n            for (; segment < pathParts.length; segment++) {\r\n                if (pathStarted || (segment == 0 && !pattern.startsWith(this.pathSeparator))) {\r\n                    builder.append(this.pathSeparator);\r\n                }\r\n                builder.append(pathParts[segment]);\r\n                pathStarted = true;\r\n            }\r\n        }\r\n    }\r\n    return builder.toString();\r\n}",
    "comment": "\n\t * Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>\n\t * <li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} &rarr; ''</li>\n\t * <li>'{@code /docs/*}' and '{@code /docs/cvs/commit} &rarr; '{@code cvs/commit}'</li>\n\t * <li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} &rarr; '{@code commit.html}'</li>\n\t * <li>'{@code /docs/**}' and '{@code /docs/cvs/commit} &rarr; '{@code cvs/commit}'</li>\n\t * <li>'{@code /docs/**\\/*.html}' and '{@code /docs/cvs/commit.html} &rarr; '{@code cvs/commit.html}'</li>\n\t * <li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} &rarr; '{@code docs/cvs/commit.html}'</li>\n\t * <li>'{@code *.html}' and '{@code /docs/cvs/commit.html} &rarr; '{@code /docs/cvs/commit.html}'</li>\n\t * <li>'{@code *}' and '{@code /docs/cvs/commit.html} &rarr; '{@code /docs/cvs/commit.html}'</li> </ul>\n\t * <p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but\n\t * does <strong>not</strong> enforce this.\n\t "
  },
  {
    "entityId": "org.springframework.util.AntPathMatcher#extractUriTemplateVariables(String,String)",
    "entityType": "method",
    "code": "@Override\r\npublic Map<String, String> extractUriTemplateVariables(String pattern, String path) {\r\n    Map<String, String> variables = new LinkedHashMap<>();\r\n    boolean result = doMatch(pattern, path, true, variables);\r\n    if (!result) {\r\n        throw new IllegalStateException(\"Pattern \\\"\" + pattern + \"\\\" is not a match for \\\"\" + path + \"\\\"\");\r\n    }\r\n    return variables;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AntPathMatcher#combine(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Combine two patterns into a new pattern.\r\n * <p>This implementation simply concatenates the two patterns, unless\r\n * the first pattern contains a file extension match (for example, {@code *.html}).\r\n * In that case, the second pattern will be merged into the first. Otherwise,\r\n * an {@code IllegalArgumentException} will be thrown.\r\n * <h4>Examples</h4>\r\n * <table border=\"1\">\r\n * <tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr>\r\n * <tr><td>{@code null}</td><td>{@code null}</td><td>&nbsp;</td></tr>\r\n * <tr><td>/hotels</td><td>{@code null}</td><td>/hotels</td></tr>\r\n * <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>\r\n * <tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr>\r\n * <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>\r\n * <tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr>\r\n * <tr><td>/hotels/&#42;&#42;</td><td>/bookings</td><td>/hotels/&#42;&#42;/bookings</td></tr>\r\n * <tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>\r\n * <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>\r\n * <tr><td>/hotels/&#42;&#42;</td><td>{hotel}</td><td>/hotels/&#42;&#42;/{hotel}</td></tr>\r\n * <tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr>\r\n * <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>\r\n * <tr><td>/*.html</td><td>/*.txt</td><td>{@code IllegalArgumentException}</td></tr>\r\n * </table>\r\n * @param pattern1 the first pattern\r\n * @param pattern2 the second pattern\r\n * @return the combination of the two patterns\r\n * @throws IllegalArgumentException if the two patterns cannot be combined\r\n */\r\n@Override\r\npublic String combine(String pattern1, String pattern2) {\r\n    if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {\r\n        return \"\";\r\n    }\r\n    if (!StringUtils.hasText(pattern1)) {\r\n        return pattern2;\r\n    }\r\n    if (!StringUtils.hasText(pattern2)) {\r\n        return pattern1;\r\n    }\r\n    boolean pattern1ContainsUriVar = (pattern1.indexOf('{') != -1);\r\n    if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {\r\n        // /* + /hotel -> /hotel ; \"/*.*\" + \"/*.html\" -> /*.html\r\n        // However /user + /user -> /usr/user ; /{foo} + /bar -> /{foo}/bar\r\n        return pattern2;\r\n    }\r\n    // /hotels/* + /booking -> /hotels/booking\r\n    // /hotels/* + booking -> /hotels/booking\r\n    if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {\r\n        return concat(pattern1.substring(0, pattern1.length() - 2), pattern2);\r\n    }\r\n    // /hotels/** + /booking -> /hotels/**/booking\r\n    // /hotels/** + booking -> /hotels/**/booking\r\n    if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {\r\n        return concat(pattern1, pattern2);\r\n    }\r\n    int starDotPos1 = pattern1.indexOf(\"*.\");\r\n    if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(\".\")) {\r\n        // simply concatenate the two patterns\r\n        return concat(pattern1, pattern2);\r\n    }\r\n    String ext1 = pattern1.substring(starDotPos1 + 1);\r\n    int dotPos2 = pattern2.indexOf('.');\r\n    String file2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2));\r\n    String ext2 = (dotPos2 == -1 ? \"\" : pattern2.substring(dotPos2));\r\n    boolean ext1All = (ext1.equals(\".*\") || ext1.isEmpty());\r\n    boolean ext2All = (ext2.equals(\".*\") || ext2.isEmpty());\r\n    if (!ext1All && !ext2All) {\r\n        throw new IllegalArgumentException(\"Cannot combine patterns: \" + pattern1 + \" vs \" + pattern2);\r\n    }\r\n    String ext = (ext1All ? ext2 : ext1);\r\n    return file2 + ext;\r\n}",
    "comment": "\n\t * Combine two patterns into a new pattern.\n\t * <p>This implementation simply concatenates the two patterns, unless\n\t * the first pattern contains a file extension match (for example, {@code *.html}).\n\t * In that case, the second pattern will be merged into the first. Otherwise,\n\t * an {@code IllegalArgumentException} will be thrown.\n\t * <h4>Examples</h4>\n\t * <table border=\"1\">\n\t * <tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr>\n\t * <tr><td>{@code null}</td><td>{@code null}</td><td>&nbsp;</td></tr>\n\t * <tr><td>/hotels</td><td>{@code null}</td><td>/hotels</td></tr>\n\t * <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>\n\t * <tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr>\n\t * <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>\n\t * <tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr>\n\t * <tr><td>/hotels/&#42;&#42;</td><td>/bookings</td><td>/hotels/&#42;&#42;/bookings</td></tr>\n\t * <tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>\n\t * <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>\n\t * <tr><td>/hotels/&#42;&#42;</td><td>{hotel}</td><td>/hotels/&#42;&#42;/{hotel}</td></tr>\n\t * <tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr>\n\t * <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>\n\t * <tr><td>/*.html</td><td>/*.txt</td><td>{@code IllegalArgumentException}</td></tr>\n\t * </table>\n\t * @param pattern1 the first pattern\n\t * @param pattern2 the second pattern\n\t * @return the combination of the two patterns\n\t * @throws IllegalArgumentException if the two patterns cannot be combined\n\t "
  },
  {
    "entityId": "org.springframework.util.AntPathMatcher#concat(String,String)",
    "entityType": "method",
    "code": "private String concat(String path1, String path2) {\r\n    boolean path1EndsWithSeparator = path1.endsWith(this.pathSeparator);\r\n    boolean path2StartsWithSeparator = path2.startsWith(this.pathSeparator);\r\n    if (path1EndsWithSeparator && path2StartsWithSeparator) {\r\n        return path1 + path2.substring(1);\r\n    } else if (path1EndsWithSeparator || path2StartsWithSeparator) {\r\n        return path1 + path2;\r\n    } else {\r\n        return path1 + this.pathSeparator + path2;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AntPathMatcher#getPatternComparator(String)",
    "entityType": "method",
    "code": "/**\r\n * Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of\r\n * explicitness.\r\n * <p>This {@code Comparator} will {@linkplain java.util.List#sort(Comparator) sort}\r\n * a list so that more specific patterns (without URI templates or wild cards) come before\r\n * generic patterns. So given a list with the following patterns, the returned comparator\r\n * will sort this list so that the order will be as indicated.\r\n * <ol>\r\n * <li>{@code /hotels/new}</li>\r\n * <li>{@code /hotels/{hotel}}</li>\r\n * <li>{@code /hotels/*}</li>\r\n * </ol>\r\n * <p>The full path given as parameter is used to test for exact matches. So when the given path\r\n * is {@code /hotels/2}, the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}.\r\n * @param path the full path to use for comparison\r\n * @return a comparator capable of sorting patterns in order of explicitness\r\n */\r\n@Override\r\npublic Comparator<String> getPatternComparator(String path) {\r\n    return new AntPatternComparator(path, this.pathSeparator);\r\n}",
    "comment": "\n\t * Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of\n\t * explicitness.\n\t * <p>This {@code Comparator} will {@linkplain java.util.List#sort(Comparator) sort}\n\t * a list so that more specific patterns (without URI templates or wild cards) come before\n\t * generic patterns. So given a list with the following patterns, the returned comparator\n\t * will sort this list so that the order will be as indicated.\n\t * <ol>\n\t * <li>{@code /hotels/new}</li>\n\t * <li>{@code /hotels/{hotel}}</li>\n\t * <li>{@code /hotels/*}</li>\n\t * </ol>\n\t * <p>The full path given as parameter is used to test for exact matches. So when the given path\n\t * is {@code /hotels/2}, the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}.\n\t * @param path the full path to use for comparison\n\t * @return a comparator capable of sorting patterns in order of explicitness\n\t "
  },
  {
    "entityId": "org.springframework.util.AntPathStringMatcher",
    "entityType": "class",
    "code": "private static final String DEFAULT_VARIABLE_PATTERN = \"((?s).*)\";\nprivate final String rawPattern;\nprivate final boolean caseSensitive;\nprivate final boolean exactMatch;\n@Nullable\r\nprivate final Pattern pattern;\nprivate final List<String> variableNames = new ArrayList<>();\nprotected AntPathStringMatcher(String pattern, String pathSeparator, boolean caseSensitive) {\r\n    this.rawPattern = pattern;\r\n    this.caseSensitive = caseSensitive;\r\n    StringBuilder patternBuilder = new StringBuilder();\r\n    Matcher matcher = getGlobPattern(pathSeparator).matcher(pattern);\r\n    int end = 0;\r\n    while (matcher.find()) {\r\n        patternBuilder.append(quote(pattern, end, matcher.start()));\r\n        String match = matcher.group();\r\n        if (\"?\".equals(match)) {\r\n            patternBuilder.append('.');\r\n        } else if (\"*\".equals(match)) {\r\n            patternBuilder.append(\".*\");\r\n        } else if (match.startsWith(\"{\") && match.endsWith(\"}\")) {\r\n            int colonIdx = match.indexOf(':');\r\n            if (colonIdx == -1) {\r\n                patternBuilder.append(DEFAULT_VARIABLE_PATTERN);\r\n                this.variableNames.add(matcher.group(1));\r\n            } else {\r\n                String variablePattern = match.substring(colonIdx + 1, match.length() - 1);\r\n                patternBuilder.append('(');\r\n                patternBuilder.append(variablePattern);\r\n                patternBuilder.append(')');\r\n                String variableName = match.substring(1, colonIdx);\r\n                this.variableNames.add(variableName);\r\n            }\r\n        }\r\n        end = matcher.end();\r\n    }\r\n    // No glob pattern was found, this is an exact String match\r\n    if (end == 0) {\r\n        this.exactMatch = true;\r\n        this.pattern = null;\r\n    } else {\r\n        this.exactMatch = false;\r\n        patternBuilder.append(quote(pattern, end, pattern.length()));\r\n        this.pattern = Pattern.compile(patternBuilder.toString(), Pattern.DOTALL | (this.caseSensitive ? 0 : Pattern.CASE_INSENSITIVE));\r\n    }\r\n}\nprivate static Pattern getGlobPattern(String pathSeparator) {\r\n    String pattern = \"\\\\?|\\\\*|\\\\{((?:\\\\{[^\" + pathSeparator + \"]+?\\\\}|[^\" + pathSeparator + \";]|\\\\\\\\[;])+?)\\\\}\";\r\n    return Pattern.compile(pattern);\r\n}\nprivate String quote(String s, int start, int end) {\r\n    if (start == end) {\r\n        return \"\";\r\n    }\r\n    return Pattern.quote(s.substring(start, end));\r\n}\n/**\r\n * Main entry point.\r\n * @return {@code true} if the string matches against the pattern, or {@code false} otherwise.\r\n */\r\npublic boolean matchStrings(String str, @Nullable Map<String, String> uriTemplateVariables) {\r\n    if (this.exactMatch) {\r\n        return this.caseSensitive ? this.rawPattern.equals(str) : this.rawPattern.equalsIgnoreCase(str);\r\n    } else if (this.pattern != null) {\r\n        Matcher matcher = this.pattern.matcher(str);\r\n        if (matcher.matches()) {\r\n            if (uriTemplateVariables != null) {\r\n                if (this.variableNames.size() != matcher.groupCount()) {\r\n                    throw new IllegalArgumentException(\"The number of capturing groups in the pattern segment \" + this.pattern + \" does not match the number of URI template variables it defines, \" + \"which can occur if capturing groups are used in a URI template regex. \" + \"Use non-capturing groups instead.\");\r\n                }\r\n                for (int i = 1; i <= matcher.groupCount(); i++) {\r\n                    String name = this.variableNames.get(i - 1);\r\n                    if (name.startsWith(\"*\")) {\r\n                        throw new IllegalArgumentException(\"Capturing patterns (\" + name + \") are not \" + \"supported by the AntPathMatcher. Use the PathPatternParser instead.\");\r\n                    }\r\n                    String value = matcher.group(i);\r\n                    uriTemplateVariables.put(name, value);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": "\n\t * Tests whether a string matches against a pattern via a {@link Pattern}.\n\t * <p>The pattern may contain special characters: '*' means zero or more characters; '?' means one and\n\t * only one character; '{' and '}' indicate a URI template pattern. For example {@code /users/{user}}.\n\t "
  },
  {
    "entityId": "org.springframework.util.AntPathStringMatcher#getGlobPattern(String)",
    "entityType": "method",
    "code": "private static Pattern getGlobPattern(String pathSeparator) {\r\n    String pattern = \"\\\\?|\\\\*|\\\\{((?:\\\\{[^\" + pathSeparator + \"]+?\\\\}|[^\" + pathSeparator + \";]|\\\\\\\\[;])+?)\\\\}\";\r\n    return Pattern.compile(pattern);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AntPathStringMatcher#quote(String,int,int)",
    "entityType": "method",
    "code": "private String quote(String s, int start, int end) {\r\n    if (start == end) {\r\n        return \"\";\r\n    }\r\n    return Pattern.quote(s.substring(start, end));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AntPathStringMatcher#matchStrings(String,Map<String,String>)",
    "entityType": "method",
    "code": "/**\r\n * Main entry point.\r\n * @return {@code true} if the string matches against the pattern, or {@code false} otherwise.\r\n */\r\npublic boolean matchStrings(String str, @Nullable Map<String, String> uriTemplateVariables) {\r\n    if (this.exactMatch) {\r\n        return this.caseSensitive ? this.rawPattern.equals(str) : this.rawPattern.equalsIgnoreCase(str);\r\n    } else if (this.pattern != null) {\r\n        Matcher matcher = this.pattern.matcher(str);\r\n        if (matcher.matches()) {\r\n            if (uriTemplateVariables != null) {\r\n                if (this.variableNames.size() != matcher.groupCount()) {\r\n                    throw new IllegalArgumentException(\"The number of capturing groups in the pattern segment \" + this.pattern + \" does not match the number of URI template variables it defines, \" + \"which can occur if capturing groups are used in a URI template regex. \" + \"Use non-capturing groups instead.\");\r\n                }\r\n                for (int i = 1; i <= matcher.groupCount(); i++) {\r\n                    String name = this.variableNames.get(i - 1);\r\n                    if (name.startsWith(\"*\")) {\r\n                        throw new IllegalArgumentException(\"Capturing patterns (\" + name + \") are not \" + \"supported by the AntPathMatcher. Use the PathPatternParser instead.\");\r\n                    }\r\n                    String value = matcher.group(i);\r\n                    uriTemplateVariables.put(name, value);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": "\n\t\t * Main entry point.\n\t\t * @return {@code true} if the string matches against the pattern, or {@code false} otherwise.\n\t\t "
  },
  {
    "entityId": "org.springframework.util.AntPatternComparator",
    "entityType": "class",
    "code": "private final String path;\nprivate final String pathSeparator;\npublic AntPatternComparator(String path) {\r\n    this(path, DEFAULT_PATH_SEPARATOR);\r\n}\npublic AntPatternComparator(String path, String pathSeparator) {\r\n    this.path = path;\r\n    this.pathSeparator = pathSeparator;\r\n}\n/**\r\n * Compare two patterns to determine which should match first, i.e. which\r\n * is the most specific regarding the current path.\r\n * @return a negative integer, zero, or a positive integer as pattern1 is\r\n * more specific, equally specific, or less specific than pattern2.\r\n */\r\n@Override\r\npublic int compare(String pattern1, String pattern2) {\r\n    PatternInfo info1 = new PatternInfo(pattern1, this.pathSeparator);\r\n    PatternInfo info2 = new PatternInfo(pattern2, this.pathSeparator);\r\n    if (info1.isLeastSpecific() && info2.isLeastSpecific()) {\r\n        return 0;\r\n    } else if (info1.isLeastSpecific()) {\r\n        return 1;\r\n    } else if (info2.isLeastSpecific()) {\r\n        return -1;\r\n    }\r\n    boolean pattern1EqualsPath = pattern1.equals(this.path);\r\n    boolean pattern2EqualsPath = pattern2.equals(this.path);\r\n    if (pattern1EqualsPath && pattern2EqualsPath) {\r\n        return 0;\r\n    } else if (pattern1EqualsPath) {\r\n        return -1;\r\n    } else if (pattern2EqualsPath) {\r\n        return 1;\r\n    }\r\n    if (info1.isPrefixPattern() && info2.isPrefixPattern()) {\r\n        return info2.getLength() - info1.getLength();\r\n    } else if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {\r\n        return 1;\r\n    } else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {\r\n        return -1;\r\n    }\r\n    if (info1.getTotalCount() != info2.getTotalCount()) {\r\n        return info1.getTotalCount() - info2.getTotalCount();\r\n    }\r\n    if (info1.getLength() != info2.getLength()) {\r\n        return info2.getLength() - info1.getLength();\r\n    }\r\n    if (info1.getSingleWildcards() < info2.getSingleWildcards()) {\r\n        return -1;\r\n    } else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {\r\n        return 1;\r\n    }\r\n    if (info1.getUriVars() < info2.getUriVars()) {\r\n        return -1;\r\n    } else if (info2.getUriVars() < info1.getUriVars()) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\n/**\r\n * Value class that holds information about the pattern, for example, number of\r\n * occurrences of \"*\", \"**\", and \"{\" pattern elements.\r\n */\r\nprivate static class PatternInfo {\r\n\r\n    @Nullable\r\n    private final String pattern;\r\n\r\n    private int uriVars;\r\n\r\n    private int singleWildcards;\r\n\r\n    private int doubleWildcards;\r\n\r\n    private boolean catchAllPattern;\r\n\r\n    private boolean prefixPattern;\r\n\r\n    @Nullable\r\n    private Integer length;\r\n\r\n    PatternInfo(@Nullable String pattern, String pathSeparator) {\r\n        this.pattern = pattern;\r\n        if (this.pattern != null) {\r\n            initCounters();\r\n            this.catchAllPattern = this.pattern.equals(pathSeparator + \"**\");\r\n            this.prefixPattern = !this.catchAllPattern && this.pattern.endsWith(pathSeparator + \"**\");\r\n        }\r\n        if (this.uriVars == 0) {\r\n            this.length = (this.pattern != null ? this.pattern.length() : 0);\r\n        }\r\n    }\r\n\r\n    protected void initCounters() {\r\n        int pos = 0;\r\n        if (this.pattern != null) {\r\n            while (pos < this.pattern.length()) {\r\n                if (this.pattern.charAt(pos) == '{') {\r\n                    this.uriVars++;\r\n                    pos++;\r\n                } else if (this.pattern.charAt(pos) == '*') {\r\n                    if (pos + 1 < this.pattern.length() && this.pattern.charAt(pos + 1) == '*') {\r\n                        this.doubleWildcards++;\r\n                        pos += 2;\r\n                    } else if (pos > 0 && !this.pattern.substring(pos - 1).equals(\".*\")) {\r\n                        this.singleWildcards++;\r\n                        pos++;\r\n                    } else {\r\n                        pos++;\r\n                    }\r\n                } else {\r\n                    pos++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public int getUriVars() {\r\n        return this.uriVars;\r\n    }\r\n\r\n    public int getSingleWildcards() {\r\n        return this.singleWildcards;\r\n    }\r\n\r\n    public int getDoubleWildcards() {\r\n        return this.doubleWildcards;\r\n    }\r\n\r\n    public boolean isLeastSpecific() {\r\n        return (this.pattern == null || this.catchAllPattern);\r\n    }\r\n\r\n    public boolean isPrefixPattern() {\r\n        return this.prefixPattern;\r\n    }\r\n\r\n    public int getTotalCount() {\r\n        return this.uriVars + this.singleWildcards + (2 * this.doubleWildcards);\r\n    }\r\n\r\n    /**\r\n     * Returns the length of the given pattern, where template variables are considered to be 1 long.\r\n     */\r\n    public int getLength() {\r\n        if (this.length == null) {\r\n            this.length = (this.pattern != null ? VARIABLE_PATTERN.matcher(this.pattern).replaceAll(\"#\").length() : 0);\r\n        }\r\n        return this.length;\r\n    }\r\n}",
    "comment": "\n\t * The default {@link Comparator} implementation returned by\n\t * {@link #getPatternComparator(String)}.\n\t * <p>In order, the most \"generic\" pattern is determined by the following:\n\t * <ul>\n\t * <li>if it's null or a capture all pattern (i.e. it is equal to \"/**\")</li>\n\t * <li>if the other pattern is an actual match</li>\n\t * <li>if it's a catch-all pattern (i.e. it ends with \"**\"</li>\n\t * <li>if it's got more \"*\" than the other pattern</li>\n\t * <li>if it's got more \"{foo}\" than the other pattern</li>\n\t * <li>if it's shorter than the other pattern</li>\n\t * </ul>\n\t "
  },
  {
    "entityId": "org.springframework.util.AntPatternComparator#compare(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Compare two patterns to determine which should match first, i.e. which\r\n * is the most specific regarding the current path.\r\n * @return a negative integer, zero, or a positive integer as pattern1 is\r\n * more specific, equally specific, or less specific than pattern2.\r\n */\r\n@Override\r\npublic int compare(String pattern1, String pattern2) {\r\n    PatternInfo info1 = new PatternInfo(pattern1, this.pathSeparator);\r\n    PatternInfo info2 = new PatternInfo(pattern2, this.pathSeparator);\r\n    if (info1.isLeastSpecific() && info2.isLeastSpecific()) {\r\n        return 0;\r\n    } else if (info1.isLeastSpecific()) {\r\n        return 1;\r\n    } else if (info2.isLeastSpecific()) {\r\n        return -1;\r\n    }\r\n    boolean pattern1EqualsPath = pattern1.equals(this.path);\r\n    boolean pattern2EqualsPath = pattern2.equals(this.path);\r\n    if (pattern1EqualsPath && pattern2EqualsPath) {\r\n        return 0;\r\n    } else if (pattern1EqualsPath) {\r\n        return -1;\r\n    } else if (pattern2EqualsPath) {\r\n        return 1;\r\n    }\r\n    if (info1.isPrefixPattern() && info2.isPrefixPattern()) {\r\n        return info2.getLength() - info1.getLength();\r\n    } else if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {\r\n        return 1;\r\n    } else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {\r\n        return -1;\r\n    }\r\n    if (info1.getTotalCount() != info2.getTotalCount()) {\r\n        return info1.getTotalCount() - info2.getTotalCount();\r\n    }\r\n    if (info1.getLength() != info2.getLength()) {\r\n        return info2.getLength() - info1.getLength();\r\n    }\r\n    if (info1.getSingleWildcards() < info2.getSingleWildcards()) {\r\n        return -1;\r\n    } else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {\r\n        return 1;\r\n    }\r\n    if (info1.getUriVars() < info2.getUriVars()) {\r\n        return -1;\r\n    } else if (info2.getUriVars() < info1.getUriVars()) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}",
    "comment": "\n\t\t * Compare two patterns to determine which should match first, i.e. which\n\t\t * is the most specific regarding the current path.\n\t\t * @return a negative integer, zero, or a positive integer as pattern1 is\n\t\t * more specific, equally specific, or less specific than pattern2.\n\t\t "
  },
  {
    "entityId": "org.springframework.util.PatternInfo",
    "entityType": "class",
    "code": "@Nullable\r\nprivate final String pattern;\nprivate int uriVars;\nprivate int singleWildcards;\nprivate int doubleWildcards;\nprivate boolean catchAllPattern;\nprivate boolean prefixPattern;\n@Nullable\r\nprivate Integer length;\nPatternInfo(@Nullable String pattern, String pathSeparator) {\r\n    this.pattern = pattern;\r\n    if (this.pattern != null) {\r\n        initCounters();\r\n        this.catchAllPattern = this.pattern.equals(pathSeparator + \"**\");\r\n        this.prefixPattern = !this.catchAllPattern && this.pattern.endsWith(pathSeparator + \"**\");\r\n    }\r\n    if (this.uriVars == 0) {\r\n        this.length = (this.pattern != null ? this.pattern.length() : 0);\r\n    }\r\n}\nprotected void initCounters() {\r\n    int pos = 0;\r\n    if (this.pattern != null) {\r\n        while (pos < this.pattern.length()) {\r\n            if (this.pattern.charAt(pos) == '{') {\r\n                this.uriVars++;\r\n                pos++;\r\n            } else if (this.pattern.charAt(pos) == '*') {\r\n                if (pos + 1 < this.pattern.length() && this.pattern.charAt(pos + 1) == '*') {\r\n                    this.doubleWildcards++;\r\n                    pos += 2;\r\n                } else if (pos > 0 && !this.pattern.substring(pos - 1).equals(\".*\")) {\r\n                    this.singleWildcards++;\r\n                    pos++;\r\n                } else {\r\n                    pos++;\r\n                }\r\n            } else {\r\n                pos++;\r\n            }\r\n        }\r\n    }\r\n}\npublic int getUriVars() {\r\n    return this.uriVars;\r\n}\npublic int getSingleWildcards() {\r\n    return this.singleWildcards;\r\n}\npublic int getDoubleWildcards() {\r\n    return this.doubleWildcards;\r\n}\npublic boolean isLeastSpecific() {\r\n    return (this.pattern == null || this.catchAllPattern);\r\n}\npublic boolean isPrefixPattern() {\r\n    return this.prefixPattern;\r\n}\npublic int getTotalCount() {\r\n    return this.uriVars + this.singleWildcards + (2 * this.doubleWildcards);\r\n}\n/**\r\n * Returns the length of the given pattern, where template variables are considered to be 1 long.\r\n */\r\npublic int getLength() {\r\n    if (this.length == null) {\r\n        this.length = (this.pattern != null ? VARIABLE_PATTERN.matcher(this.pattern).replaceAll(\"#\").length() : 0);\r\n    }\r\n    return this.length;\r\n}",
    "comment": "\n\t\t * Value class that holds information about the pattern, for example, number of\n\t\t * occurrences of \"*\", \"**\", and \"{\" pattern elements.\n\t\t "
  },
  {
    "entityId": "org.springframework.util.PatternInfo#initCounters()",
    "entityType": "method",
    "code": "protected void initCounters() {\r\n    int pos = 0;\r\n    if (this.pattern != null) {\r\n        while (pos < this.pattern.length()) {\r\n            if (this.pattern.charAt(pos) == '{') {\r\n                this.uriVars++;\r\n                pos++;\r\n            } else if (this.pattern.charAt(pos) == '*') {\r\n                if (pos + 1 < this.pattern.length() && this.pattern.charAt(pos + 1) == '*') {\r\n                    this.doubleWildcards++;\r\n                    pos += 2;\r\n                } else if (pos > 0 && !this.pattern.substring(pos - 1).equals(\".*\")) {\r\n                    this.singleWildcards++;\r\n                    pos++;\r\n                } else {\r\n                    pos++;\r\n                }\r\n            } else {\r\n                pos++;\r\n            }\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PatternInfo#getUriVars()",
    "entityType": "method",
    "code": "public int getUriVars() {\r\n    return this.uriVars;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PatternInfo#getSingleWildcards()",
    "entityType": "method",
    "code": "public int getSingleWildcards() {\r\n    return this.singleWildcards;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PatternInfo#getDoubleWildcards()",
    "entityType": "method",
    "code": "public int getDoubleWildcards() {\r\n    return this.doubleWildcards;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PatternInfo#isLeastSpecific()",
    "entityType": "method",
    "code": "public boolean isLeastSpecific() {\r\n    return (this.pattern == null || this.catchAllPattern);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PatternInfo#isPrefixPattern()",
    "entityType": "method",
    "code": "public boolean isPrefixPattern() {\r\n    return this.prefixPattern;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PatternInfo#getTotalCount()",
    "entityType": "method",
    "code": "public int getTotalCount() {\r\n    return this.uriVars + this.singleWildcards + (2 * this.doubleWildcards);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PatternInfo#getLength()",
    "entityType": "method",
    "code": "/**\r\n * Returns the length of the given pattern, where template variables are considered to be 1 long.\r\n */\r\npublic int getLength() {\r\n    if (this.length == null) {\r\n        this.length = (this.pattern != null ? VARIABLE_PATTERN.matcher(this.pattern).replaceAll(\"#\").length() : 0);\r\n    }\r\n    return this.length;\r\n}",
    "comment": "\n\t\t\t * Returns the length of the given pattern, where template variables are considered to be 1 long.\n\t\t\t "
  },
  {
    "entityId": "org.springframework.util.PathSeparatorPatternCache",
    "entityType": "class",
    "code": "private final String endsOnWildCard;\nprivate final String endsOnDoubleWildCard;\npublic PathSeparatorPatternCache(String pathSeparator) {\r\n    this.endsOnWildCard = pathSeparator + \"*\";\r\n    this.endsOnDoubleWildCard = pathSeparator + \"**\";\r\n}\npublic String getEndsOnWildCard() {\r\n    return this.endsOnWildCard;\r\n}\npublic String getEndsOnDoubleWildCard() {\r\n    return this.endsOnDoubleWildCard;\r\n}",
    "comment": "\n\t * A simple cache for patterns that depend on the configured path separator.\n\t "
  },
  {
    "entityId": "org.springframework.util.PathSeparatorPatternCache#getEndsOnWildCard()",
    "entityType": "method",
    "code": "public String getEndsOnWildCard() {\r\n    return this.endsOnWildCard;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PathSeparatorPatternCache#getEndsOnDoubleWildCard()",
    "entityType": "method",
    "code": "public String getEndsOnDoubleWildCard() {\r\n    return this.endsOnDoubleWildCard;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Assert",
    "entityType": "class",
    "code": "/**\r\n * Assert a boolean expression, throwing an {@code IllegalStateException}\r\n * if the expression evaluates to {@code false}.\r\n * <p>Call {@link #isTrue} if you wish to throw an {@code IllegalArgumentException}\r\n * on an assertion failure.\r\n * <pre class=\"code\">Assert.state(id == null, \"The id property must not already be initialized\");</pre>\r\n * @param expression a boolean expression\r\n * @param message the exception message to use if the assertion fails\r\n * @throws IllegalStateException if {@code expression} is {@code false}\r\n */\r\n@Contract(\"false, _ -> fail\")\r\npublic static void state(boolean expression, String message) {\r\n    if (!expression) {\r\n        throw new IllegalStateException(message);\r\n    }\r\n}\n/**\r\n * Assert a boolean expression, throwing an {@code IllegalStateException}\r\n * if the expression evaluates to {@code false}.\r\n * <p>Call {@link #isTrue} if you wish to throw an {@code IllegalArgumentException}\r\n * on an assertion failure.\r\n * <pre class=\"code\">\r\n * Assert.state(entity.getId() == null,\r\n *     () -&gt; \"ID for entity \" + entity.getName() + \" must not already be initialized\");\r\n * </pre>\r\n * @param expression a boolean expression\r\n * @param messageSupplier a supplier for the exception message to use if the\r\n * assertion fails\r\n * @throws IllegalStateException if {@code expression} is {@code false}\r\n * @since 5.0\r\n */\r\n@Contract(\"false, _ -> fail\")\r\npublic static void state(boolean expression, Supplier<String> messageSupplier) {\r\n    if (!expression) {\r\n        throw new IllegalStateException(nullSafeGet(messageSupplier));\r\n    }\r\n}\n/**\r\n * Assert a boolean expression, throwing an {@code IllegalArgumentException}\r\n * if the expression evaluates to {@code false}.\r\n * <pre class=\"code\">Assert.isTrue(i &gt; 0, \"The value must be greater than zero\");</pre>\r\n * @param expression a boolean expression\r\n * @param message the exception message to use if the assertion fails\r\n * @throws IllegalArgumentException if {@code expression} is {@code false}\r\n */\r\n@Contract(\"false, _ -> fail\")\r\npublic static void isTrue(boolean expression, String message) {\r\n    if (!expression) {\r\n        throw new IllegalArgumentException(message);\r\n    }\r\n}\n/**\r\n * Assert a boolean expression, throwing an {@code IllegalArgumentException}\r\n * if the expression evaluates to {@code false}.\r\n * <pre class=\"code\">\r\n * Assert.isTrue(i &gt; 0, () -&gt; \"The value '\" + i + \"' must be greater than zero\");\r\n * </pre>\r\n * @param expression a boolean expression\r\n * @param messageSupplier a supplier for the exception message to use if the\r\n * assertion fails\r\n * @throws IllegalArgumentException if {@code expression} is {@code false}\r\n * @since 5.0\r\n */\r\n@Contract(\"false, _ -> fail\")\r\npublic static void isTrue(boolean expression, Supplier<String> messageSupplier) {\r\n    if (!expression) {\r\n        throw new IllegalArgumentException(nullSafeGet(messageSupplier));\r\n    }\r\n}\n/**\r\n * Assert that an object is {@code null}.\r\n * <pre class=\"code\">Assert.isNull(value, \"The value must be null\");</pre>\r\n * @param object the object to check\r\n * @param message the exception message to use if the assertion fails\r\n * @throws IllegalArgumentException if the object is not {@code null}\r\n */\r\n@Contract(\"!null, _ -> fail\")\r\npublic static void isNull(@Nullable Object object, String message) {\r\n    if (object != null) {\r\n        throw new IllegalArgumentException(message);\r\n    }\r\n}\n/**\r\n * Assert that an object is {@code null}.\r\n * <pre class=\"code\">\r\n * Assert.isNull(value, () -&gt; \"The value '\" + value + \"' must be null\");\r\n * </pre>\r\n * @param object the object to check\r\n * @param messageSupplier a supplier for the exception message to use if the\r\n * assertion fails\r\n * @throws IllegalArgumentException if the object is not {@code null}\r\n * @since 5.0\r\n */\r\n@Contract(\"!null, _ -> fail\")\r\npublic static void isNull(@Nullable Object object, Supplier<String> messageSupplier) {\r\n    if (object != null) {\r\n        throw new IllegalArgumentException(nullSafeGet(messageSupplier));\r\n    }\r\n}\n/**\r\n * Assert that an object is not {@code null}.\r\n * <pre class=\"code\">Assert.notNull(clazz, \"The class must not be null\");</pre>\r\n * @param object the object to check\r\n * @param message the exception message to use if the assertion fails\r\n * @throws IllegalArgumentException if the object is {@code null}\r\n */\r\n@Contract(\"null, _ -> fail\")\r\npublic static void notNull(@Nullable Object object, String message) {\r\n    if (object == null) {\r\n        throw new IllegalArgumentException(message);\r\n    }\r\n}\n/**\r\n * Assert that an object is not {@code null}.\r\n * <pre class=\"code\">\r\n * Assert.notNull(entity.getId(),\r\n *     () -&gt; \"ID for entity \" + entity.getName() + \" must not be null\");\r\n * </pre>\r\n * @param object the object to check\r\n * @param messageSupplier a supplier for the exception message to use if the\r\n * assertion fails\r\n * @throws IllegalArgumentException if the object is {@code null}\r\n * @since 5.0\r\n */\r\n@Contract(\"null, _ -> fail\")\r\npublic static void notNull(@Nullable Object object, Supplier<String> messageSupplier) {\r\n    if (object == null) {\r\n        throw new IllegalArgumentException(nullSafeGet(messageSupplier));\r\n    }\r\n}\n/**\r\n * Assert that the given String is not empty; that is,\r\n * it must not be {@code null} and not the empty String.\r\n * <pre class=\"code\">Assert.hasLength(name, \"Name must not be empty\");</pre>\r\n * @param text the String to check\r\n * @param message the exception message to use if the assertion fails\r\n * @throws IllegalArgumentException if the text is empty\r\n * @see StringUtils#hasLength\r\n */\r\n@Contract(\"null, _ -> fail\")\r\npublic static void hasLength(@Nullable String text, String message) {\r\n    if (!StringUtils.hasLength(text)) {\r\n        throw new IllegalArgumentException(message);\r\n    }\r\n}\n/**\r\n * Assert that the given String is not empty; that is,\r\n * it must not be {@code null} and not the empty String.\r\n * <pre class=\"code\">\r\n * Assert.hasLength(account.getName(),\r\n *     () -&gt; \"Name for account '\" + account.getId() + \"' must not be empty\");\r\n * </pre>\r\n * @param text the String to check\r\n * @param messageSupplier a supplier for the exception message to use if the\r\n * assertion fails\r\n * @throws IllegalArgumentException if the text is empty\r\n * @since 5.0\r\n * @see StringUtils#hasLength\r\n */\r\n@Contract(\"null, _ -> fail\")\r\npublic static void hasLength(@Nullable String text, Supplier<String> messageSupplier) {\r\n    if (!StringUtils.hasLength(text)) {\r\n        throw new IllegalArgumentException(nullSafeGet(messageSupplier));\r\n    }\r\n}\n/**\r\n * Assert that the given String contains valid text content; that is, it must not\r\n * be {@code null} and must contain at least one non-whitespace character.\r\n * <pre class=\"code\">Assert.hasText(name, \"'name' must not be empty\");</pre>\r\n * @param text the String to check\r\n * @param message the exception message to use if the assertion fails\r\n * @throws IllegalArgumentException if the text does not contain valid text content\r\n * @see StringUtils#hasText\r\n */\r\n@Contract(\"null, _ -> fail\")\r\npublic static void hasText(@Nullable String text, String message) {\r\n    if (!StringUtils.hasText(text)) {\r\n        throw new IllegalArgumentException(message);\r\n    }\r\n}\n/**\r\n * Assert that the given String contains valid text content; that is, it must not\r\n * be {@code null} and must contain at least one non-whitespace character.\r\n * <pre class=\"code\">\r\n * Assert.hasText(account.getName(),\r\n *     () -&gt; \"Name for account '\" + account.getId() + \"' must not be empty\");\r\n * </pre>\r\n * @param text the String to check\r\n * @param messageSupplier a supplier for the exception message to use if the\r\n * assertion fails\r\n * @throws IllegalArgumentException if the text does not contain valid text content\r\n * @since 5.0\r\n * @see StringUtils#hasText\r\n */\r\n@Contract(\"null, _ -> fail\")\r\npublic static void hasText(@Nullable String text, Supplier<String> messageSupplier) {\r\n    if (!StringUtils.hasText(text)) {\r\n        throw new IllegalArgumentException(nullSafeGet(messageSupplier));\r\n    }\r\n}\n/**\r\n * Assert that the given text does not contain the given substring.\r\n * <pre class=\"code\">Assert.doesNotContain(name, \"rod\", \"Name must not contain 'rod'\");</pre>\r\n * @param textToSearch the text to search\r\n * @param substring the substring to find within the text\r\n * @param message the exception message to use if the assertion fails\r\n * @throws IllegalArgumentException if the text contains the substring\r\n */\r\npublic static void doesNotContain(@Nullable String textToSearch, String substring, String message) {\r\n    if (StringUtils.hasLength(textToSearch) && StringUtils.hasLength(substring) && textToSearch.contains(substring)) {\r\n        throw new IllegalArgumentException(message);\r\n    }\r\n}\n/**\r\n * Assert that the given text does not contain the given substring.\r\n * <pre class=\"code\">\r\n * Assert.doesNotContain(name, forbidden, () -&gt; \"Name must not contain '\" + forbidden + \"'\");\r\n * </pre>\r\n * @param textToSearch the text to search\r\n * @param substring the substring to find within the text\r\n * @param messageSupplier a supplier for the exception message to use if the\r\n * assertion fails\r\n * @throws IllegalArgumentException if the text contains the substring\r\n * @since 5.0\r\n */\r\npublic static void doesNotContain(@Nullable String textToSearch, String substring, Supplier<String> messageSupplier) {\r\n    if (StringUtils.hasLength(textToSearch) && StringUtils.hasLength(substring) && textToSearch.contains(substring)) {\r\n        throw new IllegalArgumentException(nullSafeGet(messageSupplier));\r\n    }\r\n}\n/**\r\n * Assert that an array contains elements; that is, it must not be\r\n * {@code null} and must contain at least one element.\r\n * <pre class=\"code\">Assert.notEmpty(array, \"The array must contain elements\");</pre>\r\n * @param array the array to check\r\n * @param message the exception message to use if the assertion fails\r\n * @throws IllegalArgumentException if the object array is {@code null} or contains no elements\r\n */\r\n@Contract(\"null, _ -> fail\")\r\npublic static void notEmpty(@Nullable Object @Nullable [] array, String message) {\r\n    if (ObjectUtils.isEmpty(array)) {\r\n        throw new IllegalArgumentException(message);\r\n    }\r\n}\n/**\r\n * Assert that an array contains elements; that is, it must not be\r\n * {@code null} and must contain at least one element.\r\n * <pre class=\"code\">\r\n * Assert.notEmpty(array, () -&gt; \"The \" + arrayType + \" array must contain elements\");\r\n * </pre>\r\n * @param array the array to check\r\n * @param messageSupplier a supplier for the exception message to use if the\r\n * assertion fails\r\n * @throws IllegalArgumentException if the object array is {@code null} or contains no elements\r\n * @since 5.0\r\n */\r\n@Contract(\"null, _ -> fail\")\r\npublic static void notEmpty(Object @Nullable [] array, Supplier<String> messageSupplier) {\r\n    if (ObjectUtils.isEmpty(array)) {\r\n        throw new IllegalArgumentException(nullSafeGet(messageSupplier));\r\n    }\r\n}\n/**\r\n * Assert that an array contains no {@code null} elements.\r\n * <p>Note: Does not complain if the array is empty!\r\n * <pre class=\"code\">Assert.noNullElements(array, \"The array must contain non-null elements\");</pre>\r\n * @param array the array to check\r\n * @param message the exception message to use if the assertion fails\r\n * @throws IllegalArgumentException if the object array contains a {@code null} element\r\n */\r\npublic static void noNullElements(Object @Nullable [] array, String message) {\r\n    if (array != null) {\r\n        for (Object element : array) {\r\n            if (element == null) {\r\n                throw new IllegalArgumentException(message);\r\n            }\r\n        }\r\n    }\r\n}\n/**\r\n * Assert that an array contains no {@code null} elements.\r\n * <p>Note: Does not complain if the array is empty!\r\n * <pre class=\"code\">\r\n * Assert.noNullElements(array, () -&gt; \"The \" + arrayType + \" array must contain non-null elements\");\r\n * </pre>\r\n * @param array the array to check\r\n * @param messageSupplier a supplier for the exception message to use if the\r\n * assertion fails\r\n * @throws IllegalArgumentException if the object array contains a {@code null} element\r\n * @since 5.0\r\n */\r\npublic static void noNullElements(Object @Nullable [] array, Supplier<String> messageSupplier) {\r\n    if (array != null) {\r\n        for (Object element : array) {\r\n            if (element == null) {\r\n                throw new IllegalArgumentException(nullSafeGet(messageSupplier));\r\n            }\r\n        }\r\n    }\r\n}\n/**\r\n * Assert that a collection contains elements; that is, it must not be\r\n * {@code null} and must contain at least one element.\r\n * <pre class=\"code\">Assert.notEmpty(collection, \"Collection must contain elements\");</pre>\r\n * @param collection the collection to check\r\n * @param message the exception message to use if the assertion fails\r\n * @throws IllegalArgumentException if the collection is {@code null} or\r\n * contains no elements\r\n */\r\n@Contract(\"null, _ -> fail\")\r\npublic static void notEmpty(@Nullable Collection<?> collection, String message) {\r\n    if (CollectionUtils.isEmpty(collection)) {\r\n        throw new IllegalArgumentException(message);\r\n    }\r\n}\n/**\r\n * Assert that a collection contains elements; that is, it must not be\r\n * {@code null} and must contain at least one element.\r\n * <pre class=\"code\">\r\n * Assert.notEmpty(collection, () -&gt; \"The \" + collectionType + \" collection must contain elements\");\r\n * </pre>\r\n * @param collection the collection to check\r\n * @param messageSupplier a supplier for the exception message to use if the\r\n * assertion fails\r\n * @throws IllegalArgumentException if the collection is {@code null} or\r\n * contains no elements\r\n * @since 5.0\r\n */\r\n@Contract(\"null, _ -> fail\")\r\npublic static void notEmpty(@Nullable Collection<?> collection, Supplier<String> messageSupplier) {\r\n    if (CollectionUtils.isEmpty(collection)) {\r\n        throw new IllegalArgumentException(nullSafeGet(messageSupplier));\r\n    }\r\n}\n/**\r\n * Assert that a collection contains no {@code null} elements.\r\n * <p>Note: Does not complain if the collection is empty!\r\n * <pre class=\"code\">Assert.noNullElements(collection, \"Collection must contain non-null elements\");</pre>\r\n * @param collection the collection to check\r\n * @param message the exception message to use if the assertion fails\r\n * @throws IllegalArgumentException if the collection contains a {@code null} element\r\n * @since 5.2\r\n */\r\npublic static void noNullElements(@Nullable Collection<?> collection, String message) {\r\n    if (collection != null) {\r\n        for (Object element : collection) {\r\n            if (element == null) {\r\n                throw new IllegalArgumentException(message);\r\n            }\r\n        }\r\n    }\r\n}\n/**\r\n * Assert that a collection contains no {@code null} elements.\r\n * <p>Note: Does not complain if the collection is empty!\r\n * <pre class=\"code\">\r\n * Assert.noNullElements(collection, () -&gt; \"Collection \" + collectionName + \" must contain non-null elements\");\r\n * </pre>\r\n * @param collection the collection to check\r\n * @param messageSupplier a supplier for the exception message to use if the\r\n * assertion fails\r\n * @throws IllegalArgumentException if the collection contains a {@code null} element\r\n * @since 5.2\r\n */\r\npublic static void noNullElements(@Nullable Collection<?> collection, Supplier<String> messageSupplier) {\r\n    if (collection != null) {\r\n        for (Object element : collection) {\r\n            if (element == null) {\r\n                throw new IllegalArgumentException(nullSafeGet(messageSupplier));\r\n            }\r\n        }\r\n    }\r\n}\n/**\r\n * Assert that a Map contains entries; that is, it must not be {@code null}\r\n * and must contain at least one entry.\r\n * <pre class=\"code\">Assert.notEmpty(map, \"Map must contain entries\");</pre>\r\n * @param map the map to check\r\n * @param message the exception message to use if the assertion fails\r\n * @throws IllegalArgumentException if the map is {@code null} or contains no entries\r\n */\r\n@Contract(\"null, _ -> fail\")\r\npublic static void notEmpty(@Nullable Map<?, ?> map, String message) {\r\n    if (CollectionUtils.isEmpty(map)) {\r\n        throw new IllegalArgumentException(message);\r\n    }\r\n}\n/**\r\n * Assert that a Map contains entries; that is, it must not be {@code null}\r\n * and must contain at least one entry.\r\n * <pre class=\"code\">\r\n * Assert.notEmpty(map, () -&gt; \"The \" + mapType + \" map must contain entries\");\r\n * </pre>\r\n * @param map the map to check\r\n * @param messageSupplier a supplier for the exception message to use if the\r\n * assertion fails\r\n * @throws IllegalArgumentException if the map is {@code null} or contains no entries\r\n * @since 5.0\r\n */\r\n@Contract(\"null, _ -> fail\")\r\npublic static void notEmpty(@Nullable Map<?, ?> map, Supplier<String> messageSupplier) {\r\n    if (CollectionUtils.isEmpty(map)) {\r\n        throw new IllegalArgumentException(nullSafeGet(messageSupplier));\r\n    }\r\n}\n/**\r\n * Assert that the provided object is an instance of the provided class.\r\n * <pre class=\"code\">Assert.instanceOf(Foo.class, foo, \"Foo expected\");</pre>\r\n * @param type the type to check against\r\n * @param obj the object to check\r\n * @param message a message which will be prepended to provide further context.\r\n * If it is empty or ends in \":\" or \";\" or \",\" or \".\", a full exception message\r\n * will be appended. If it ends in a space, the name of the offending object's\r\n * type will be appended. In any other case, a \":\" with a space and the name\r\n * of the offending object's type will be appended.\r\n * @throws IllegalArgumentException if the object is not an instance of type\r\n */\r\n@Contract(\"_, null, _ -> fail\")\r\npublic static void isInstanceOf(Class<?> type, @Nullable Object obj, String message) {\r\n    notNull(type, \"Type to check against must not be null\");\r\n    if (!type.isInstance(obj)) {\r\n        instanceCheckFailed(type, obj, message);\r\n    }\r\n}\n/**\r\n * Assert that the provided object is an instance of the provided class.\r\n * <pre class=\"code\">\r\n * Assert.instanceOf(Foo.class, foo, () -&gt; \"Processing \" + Foo.class.getSimpleName() + \":\");\r\n * </pre>\r\n * @param type the type to check against\r\n * @param obj the object to check\r\n * @param messageSupplier a supplier for the exception message to use if the\r\n * assertion fails. See {@link #isInstanceOf(Class, Object, String)} for details.\r\n * @throws IllegalArgumentException if the object is not an instance of type\r\n * @since 5.0\r\n */\r\n@Contract(\"_, null, _ -> fail\")\r\npublic static void isInstanceOf(Class<?> type, @Nullable Object obj, Supplier<String> messageSupplier) {\r\n    notNull(type, \"Type to check against must not be null\");\r\n    if (!type.isInstance(obj)) {\r\n        instanceCheckFailed(type, obj, nullSafeGet(messageSupplier));\r\n    }\r\n}\n/**\r\n * Assert that the provided object is an instance of the provided class.\r\n * <pre class=\"code\">Assert.instanceOf(Foo.class, foo);</pre>\r\n * @param type the type to check against\r\n * @param obj the object to check\r\n * @throws IllegalArgumentException if the object is not an instance of type\r\n */\r\n@Contract(\"_, null -> fail\")\r\npublic static void isInstanceOf(Class<?> type, @Nullable Object obj) {\r\n    isInstanceOf(type, obj, \"\");\r\n}\n/**\r\n * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}.\r\n * <pre class=\"code\">Assert.isAssignable(Number.class, myClass, \"Number expected\");</pre>\r\n * @param superType the supertype to check against\r\n * @param subType the subtype to check\r\n * @param message a message which will be prepended to provide further context.\r\n * If it is empty or ends in \":\" or \";\" or \",\" or \".\", a full exception message\r\n * will be appended. If it ends in a space, the name of the offending subtype\r\n * will be appended. In any other case, a \":\" with a space and the name of the\r\n * offending subtype will be appended.\r\n * @throws IllegalArgumentException if the classes are not assignable\r\n */\r\n@Contract(\"_, null, _ -> fail\")\r\npublic static void isAssignable(Class<?> superType, @Nullable Class<?> subType, String message) {\r\n    notNull(superType, \"Supertype to check against must not be null\");\r\n    if (subType == null || !superType.isAssignableFrom(subType)) {\r\n        assignableCheckFailed(superType, subType, message);\r\n    }\r\n}\n/**\r\n * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}.\r\n * <pre class=\"code\">\r\n * Assert.isAssignable(Number.class, myClass, () -&gt; \"Processing \" + myAttributeName + \":\");\r\n * </pre>\r\n * @param superType the supertype to check against\r\n * @param subType the subtype to check\r\n * @param messageSupplier a supplier for the exception message to use if the\r\n * assertion fails. See {@link #isAssignable(Class, Class, String)} for details.\r\n * @throws IllegalArgumentException if the classes are not assignable\r\n * @since 5.0\r\n */\r\n@Contract(\"_, null, _ -> fail\")\r\npublic static void isAssignable(Class<?> superType, @Nullable Class<?> subType, Supplier<String> messageSupplier) {\r\n    notNull(superType, \"Supertype to check against must not be null\");\r\n    if (subType == null || !superType.isAssignableFrom(subType)) {\r\n        assignableCheckFailed(superType, subType, nullSafeGet(messageSupplier));\r\n    }\r\n}\n/**\r\n * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}.\r\n * <pre class=\"code\">Assert.isAssignable(Number.class, myClass);</pre>\r\n * @param superType the supertype to check\r\n * @param subType the subtype to check\r\n * @throws IllegalArgumentException if the classes are not assignable\r\n */\r\n@Contract(\"_, null -> fail\")\r\npublic static void isAssignable(Class<?> superType, @Nullable Class<?> subType) {\r\n    isAssignable(superType, subType, \"\");\r\n}\nprivate static void instanceCheckFailed(Class<?> type, @Nullable Object obj, @Nullable String msg) {\r\n    String className = (obj != null ? obj.getClass().getName() : \"null\");\r\n    String result = \"\";\r\n    boolean defaultMessage = true;\r\n    if (StringUtils.hasLength(msg)) {\r\n        if (endsWithSeparator(msg)) {\r\n            result = msg + \" \";\r\n        } else {\r\n            result = messageWithTypeName(msg, className);\r\n            defaultMessage = false;\r\n        }\r\n    }\r\n    if (defaultMessage) {\r\n        result = result + (\"Object of class [\" + className + \"] must be an instance of \" + type);\r\n    }\r\n    throw new IllegalArgumentException(result);\r\n}\nprivate static void assignableCheckFailed(Class<?> superType, @Nullable Class<?> subType, @Nullable String msg) {\r\n    String result = \"\";\r\n    boolean defaultMessage = true;\r\n    if (StringUtils.hasLength(msg)) {\r\n        if (endsWithSeparator(msg)) {\r\n            result = msg + \" \";\r\n        } else {\r\n            result = messageWithTypeName(msg, subType);\r\n            defaultMessage = false;\r\n        }\r\n    }\r\n    if (defaultMessage) {\r\n        result = result + (subType + \" is not assignable to \" + superType);\r\n    }\r\n    throw new IllegalArgumentException(result);\r\n}\nprivate static boolean endsWithSeparator(String msg) {\r\n    return (msg.endsWith(\":\") || msg.endsWith(\";\") || msg.endsWith(\",\") || msg.endsWith(\".\"));\r\n}\nprivate static String messageWithTypeName(String msg, @Nullable Object typeName) {\r\n    return msg + (msg.endsWith(\" \") ? \"\" : \": \") + typeName;\r\n}\n@Nullable\r\nprivate static String nullSafeGet(@Nullable Supplier<String> messageSupplier) {\r\n    return (messageSupplier != null ? messageSupplier.get() : null);\r\n}",
    "comment": "\n * Assertion utility class that assists in validating arguments.\n *\n * <p>Useful for identifying programmer errors early and clearly at runtime.\n *\n * <p>For example, if the contract of a public method states it does not\n * allow {@code null} arguments, {@code Assert} can be used to validate that\n * contract. Doing this clearly indicates a contract violation when it\n * occurs and protects the class's invariants.\n *\n * <p>Typically used to validate method arguments rather than configuration\n * properties, to check for cases that are usually programmer errors rather\n * than configuration errors. In contrast to configuration initialization\n * code, there is usually no point in falling back to defaults in such methods.\n *\n * <p>This class is similar to JUnit's assertion library. If an argument value is\n * deemed invalid, an {@link IllegalArgumentException} is thrown (typically).\n * For example:\n *\n * <pre class=\"code\">\n * Assert.notNull(clazz, \"The class must not be null\");\n * Assert.isTrue(i &gt; 0, \"The value must be greater than zero\");</pre>\n *\n * <p>Mainly for internal use within the framework; for a more comprehensive suite\n * of assertion utilities consider {@code org.apache.commons.lang3.Validate} from\n * <a href=\"https://commons.apache.org/proper/commons-lang/\">Apache Commons Lang</a>,\n * Google Guava's\n * <a href=\"https://github.com/google/guava/wiki/PreconditionsExplained\">Preconditions</a>,\n * or similar third-party libraries.\n *\n * @author Keith Donald\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Colin Sampaleanu\n * @author Rob Harrop\n * @author Sebastien Deleuze\n * @since 1.1.2\n "
  },
  {
    "entityId": "org.springframework.util.Assert#state(boolean,String)",
    "entityType": "method",
    "code": "/**\r\n * Assert a boolean expression, throwing an {@code IllegalStateException}\r\n * if the expression evaluates to {@code false}.\r\n * <p>Call {@link #isTrue} if you wish to throw an {@code IllegalArgumentException}\r\n * on an assertion failure.\r\n * <pre class=\"code\">Assert.state(id == null, \"The id property must not already be initialized\");</pre>\r\n * @param expression a boolean expression\r\n * @param message the exception message to use if the assertion fails\r\n * @throws IllegalStateException if {@code expression} is {@code false}\r\n */\r\n@Contract(\"false, _ -> fail\")\r\npublic static void state(boolean expression, String message) {\r\n    if (!expression) {\r\n        throw new IllegalStateException(message);\r\n    }\r\n}",
    "comment": "\n\t * Assert a boolean expression, throwing an {@code IllegalStateException}\n\t * if the expression evaluates to {@code false}.\n\t * <p>Call {@link #isTrue} if you wish to throw an {@code IllegalArgumentException}\n\t * on an assertion failure.\n\t * <pre class=\"code\">Assert.state(id == null, \"The id property must not already be initialized\");</pre>\n\t * @param expression a boolean expression\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalStateException if {@code expression} is {@code false}\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#state(boolean,Supplier<String>)",
    "entityType": "method",
    "code": "/**\r\n * Assert a boolean expression, throwing an {@code IllegalStateException}\r\n * if the expression evaluates to {@code false}.\r\n * <p>Call {@link #isTrue} if you wish to throw an {@code IllegalArgumentException}\r\n * on an assertion failure.\r\n * <pre class=\"code\">\r\n * Assert.state(entity.getId() == null,\r\n *     () -&gt; \"ID for entity \" + entity.getName() + \" must not already be initialized\");\r\n * </pre>\r\n * @param expression a boolean expression\r\n * @param messageSupplier a supplier for the exception message to use if the\r\n * assertion fails\r\n * @throws IllegalStateException if {@code expression} is {@code false}\r\n * @since 5.0\r\n */\r\n@Contract(\"false, _ -> fail\")\r\npublic static void state(boolean expression, Supplier<String> messageSupplier) {\r\n    if (!expression) {\r\n        throw new IllegalStateException(nullSafeGet(messageSupplier));\r\n    }\r\n}",
    "comment": "\n\t * Assert a boolean expression, throwing an {@code IllegalStateException}\n\t * if the expression evaluates to {@code false}.\n\t * <p>Call {@link #isTrue} if you wish to throw an {@code IllegalArgumentException}\n\t * on an assertion failure.\n\t * <pre class=\"code\">\n\t * Assert.state(entity.getId() == null,\n\t *     () -&gt; \"ID for entity \" + entity.getName() + \" must not already be initialized\");\n\t * </pre>\n\t * @param expression a boolean expression\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalStateException if {@code expression} is {@code false}\n\t * @since 5.0\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#isTrue(boolean,String)",
    "entityType": "method",
    "code": "/**\r\n * Assert a boolean expression, throwing an {@code IllegalArgumentException}\r\n * if the expression evaluates to {@code false}.\r\n * <pre class=\"code\">Assert.isTrue(i &gt; 0, \"The value must be greater than zero\");</pre>\r\n * @param expression a boolean expression\r\n * @param message the exception message to use if the assertion fails\r\n * @throws IllegalArgumentException if {@code expression} is {@code false}\r\n */\r\n@Contract(\"false, _ -> fail\")\r\npublic static void isTrue(boolean expression, String message) {\r\n    if (!expression) {\r\n        throw new IllegalArgumentException(message);\r\n    }\r\n}",
    "comment": "\n\t * Assert a boolean expression, throwing an {@code IllegalArgumentException}\n\t * if the expression evaluates to {@code false}.\n\t * <pre class=\"code\">Assert.isTrue(i &gt; 0, \"The value must be greater than zero\");</pre>\n\t * @param expression a boolean expression\n\t * @param message the exception message to use if the assertion fails\n\t * @throws IllegalArgumentException if {@code expression} is {@code false}\n\t "
  },
  {
    "entityId": "org.springframework.util.Assert#isTrue(boolean,Supplier<String>)",
    "entityType": "method",
    "code": "/**\r\n * Assert a boolean expression, throwing an {@code IllegalArgumentException}\r\n * if the expression evaluates to {@code false}.\r\n * <pre class=\"code\">\r\n * Assert.isTrue(i &gt; 0, () -&gt; \"The value '\" + i + \"' must be greater than zero\");\r\n * </pre>\r\n * @param expression a boolean expression\r\n * @param messageSupplier a supplier for the exception message to use if the\r\n * assertion fails\r\n * @throws IllegalArgumentException if {@code expression} is {@code false}\r\n * @since 5.0\r\n */\r\n@Contract(\"false, _ -> fail\")\r\npublic static void isTrue(boolean expression, Supplier<String> messageSupplier) {\r\n    if (!expression) {\r\n        throw new IllegalArgumentException(nullSafeGet(messageSupplier));\r\n    }\r\n}",
    "comment": "\n\t * Assert a boolean expression, throwing an {@code IllegalArgumentException}\n\t * if the expression evaluates to {@code false}.\n\t * <pre class=\"code\">\n\t * Assert.isTrue(i &gt; 0, () -&gt; \"The value '\" + i + \"' must be greater than zero\");\n\t * </pre>\n\t * @param expression a boolean expression\n\t * @param messageSupplier a supplier for the exception message to use if the\n\t * assertion fails\n\t * @throws IllegalArgumentException if {@code expression} is {@code false}\n\t * @since 5.0\n\t "
  }
]