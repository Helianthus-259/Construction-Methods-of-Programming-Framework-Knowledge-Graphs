[
  {
    "entityId": "org.springframework.util.ClassUtils#isPresent(String,ClassLoader)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the {@link Class} identified by the supplied name is present\r\n * and can be loaded. Will return {@code false} if either the class or\r\n * one of its dependencies is not present or cannot be loaded.\r\n * @param className the name of the class to check\r\n * @param classLoader the class loader to use\r\n * (can be {@code null} which indicates the default class loader)\r\n * @return whether the specified class is present (including all of its\r\n * superclasses and interfaces)\r\n * @throws IllegalStateException if the corresponding class is resolvable but there\r\n * was a readability mismatch in the inheritance hierarchy of the class (typically a\r\n * missing dependency declaration in a Java Module System module definition for a\r\n * superclass or interface implemented by the class to be checked here)\r\n */\r\npublic static boolean isPresent(String className, @Nullable ClassLoader classLoader) {\r\n    try {\r\n        forName(className, classLoader);\r\n        return true;\r\n    } catch (IllegalAccessError err) {\r\n        throw new IllegalStateException(\"Readability mismatch in inheritance hierarchy of class [\" + className + \"]: \" + err.getMessage(), err);\r\n    } catch (Throwable ex) {\r\n        // Typically ClassNotFoundException or NoClassDefFoundError...\r\n        return false;\r\n    }\r\n}",
    "comment": "\n\t * Determine whether the {@link Class} identified by the supplied name is present\n\t * and can be loaded. Will return {@code false} if either the class or\n\t * one of its dependencies is not present or cannot be loaded.\n\t * @param className the name of the class to check\n\t * @param classLoader the class loader to use\n\t * (can be {@code null} which indicates the default class loader)\n\t * @return whether the specified class is present (including all of its\n\t * superclasses and interfaces)\n\t * @throws IllegalStateException if the corresponding class is resolvable but there\n\t * was a readability mismatch in the inheritance hierarchy of the class (typically a\n\t * missing dependency declaration in a Java Module System module definition for a\n\t * superclass or interface implemented by the class to be checked here)\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#isVisible(Class<?>,ClassLoader)",
    "entityType": "method",
    "code": "/**\r\n * Check whether the given class is visible in the given ClassLoader.\r\n * @param clazz the class to check (typically an interface)\r\n * @param classLoader the ClassLoader to check against\r\n * (can be {@code null} in which case this method will always return {@code true})\r\n */\r\npublic static boolean isVisible(Class<?> clazz, @Nullable ClassLoader classLoader) {\r\n    if (classLoader == null) {\r\n        return true;\r\n    }\r\n    try {\r\n        if (clazz.getClassLoader() == classLoader) {\r\n            return true;\r\n        }\r\n    } catch (SecurityException ex) {\r\n        // Fall through to loadable check below\r\n    }\r\n    // Visible if same Class can be loaded from given ClassLoader\r\n    return isLoadable(clazz, classLoader);\r\n}",
    "comment": "\n\t * Check whether the given class is visible in the given ClassLoader.\n\t * @param clazz the class to check (typically an interface)\n\t * @param classLoader the ClassLoader to check against\n\t * (can be {@code null} in which case this method will always return {@code true})\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#isCacheSafe(Class<?>,ClassLoader)",
    "entityType": "method",
    "code": "/**\r\n * Check whether the given class is cache-safe in the given context,\r\n * i.e. whether it is loaded by the given ClassLoader or a parent of it.\r\n * @param clazz the class to analyze\r\n * @param classLoader the ClassLoader to potentially cache metadata in\r\n * (can be {@code null} which indicates the system class loader)\r\n */\r\npublic static boolean isCacheSafe(Class<?> clazz, @Nullable ClassLoader classLoader) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    try {\r\n        ClassLoader target = clazz.getClassLoader();\r\n        // Common cases\r\n        if (target == classLoader || target == null) {\r\n            return true;\r\n        }\r\n        if (classLoader == null) {\r\n            return false;\r\n        }\r\n        // Check for match in ancestors -> positive\r\n        ClassLoader current = classLoader;\r\n        while (current != null) {\r\n            current = current.getParent();\r\n            if (current == target) {\r\n                return true;\r\n            }\r\n        }\r\n        // Check for match in children -> negative\r\n        while (target != null) {\r\n            target = target.getParent();\r\n            if (target == classLoader) {\r\n                return false;\r\n            }\r\n        }\r\n    } catch (SecurityException ex) {\r\n        // Fall through to loadable check below\r\n    }\r\n    // Fallback for ClassLoaders without parent/child relationship:\r\n    // safe if same Class can be loaded from given ClassLoader\r\n    return (classLoader != null && isLoadable(clazz, classLoader));\r\n}",
    "comment": "\n\t * Check whether the given class is cache-safe in the given context,\n\t * i.e. whether it is loaded by the given ClassLoader or a parent of it.\n\t * @param clazz the class to analyze\n\t * @param classLoader the ClassLoader to potentially cache metadata in\n\t * (can be {@code null} which indicates the system class loader)\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#isLoadable(Class<?>,ClassLoader)",
    "entityType": "method",
    "code": "/**\r\n * Check whether the given class is loadable in the given ClassLoader.\r\n * @param clazz the class to check (typically an interface)\r\n * @param classLoader the ClassLoader to check against\r\n * @since 5.0.6\r\n */\r\nprivate static boolean isLoadable(Class<?> clazz, ClassLoader classLoader) {\r\n    try {\r\n        return (clazz == classLoader.loadClass(clazz.getName()));\r\n        // Else: different class with same name found\r\n    } catch (ClassNotFoundException ex) {\r\n        // No corresponding class found at all\r\n        return false;\r\n    }\r\n}",
    "comment": "\n\t * Check whether the given class is loadable in the given ClassLoader.\n\t * @param clazz the class to check (typically an interface)\n\t * @param classLoader the ClassLoader to check against\n\t * @since 5.0.6\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#resolvePrimitiveClassName(String)",
    "entityType": "method",
    "code": "/**\r\n * Resolve the given class name as primitive class, if appropriate,\r\n * according to the JVM's naming rules for primitive classes.\r\n * <p>Also supports the JVM's internal class names for primitive arrays.\r\n * Does <i>not</i> support the \"[]\" suffix notation for primitive arrays;\r\n * this is only supported by {@link #forName(String, ClassLoader)}.\r\n * @param name the name of the potentially primitive class\r\n * @return the primitive class, or {@code null} if the name does not denote\r\n * a primitive class or primitive array class\r\n */\r\n@Nullable\r\npublic static Class<?> resolvePrimitiveClassName(@Nullable String name) {\r\n    Class<?> result = null;\r\n    // Most class names will be quite long, considering that they\r\n    // SHOULD sit in a package, so a length check is worthwhile.\r\n    if (name != null && name.length() <= 7) {\r\n        // Could be a primitive - likely.\r\n        result = primitiveTypeNameMap.get(name);\r\n    }\r\n    return result;\r\n}",
    "comment": "\n\t * Resolve the given class name as primitive class, if appropriate,\n\t * according to the JVM's naming rules for primitive classes.\n\t * <p>Also supports the JVM's internal class names for primitive arrays.\n\t * Does <i>not</i> support the \"[]\" suffix notation for primitive arrays;\n\t * this is only supported by {@link #forName(String, ClassLoader)}.\n\t * @param name the name of the potentially primitive class\n\t * @return the primitive class, or {@code null} if the name does not denote\n\t * a primitive class or primitive array class\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#isPrimitiveWrapper(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Check if the given class represents a primitive wrapper,\r\n * i.e. Boolean, Byte, Character, Short, Integer, Long, Float, Double, or\r\n * Void.\r\n * @param clazz the class to check\r\n * @return whether the given class is a primitive wrapper class\r\n */\r\npublic static boolean isPrimitiveWrapper(Class<?> clazz) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    return primitiveWrapperTypeMap.containsKey(clazz);\r\n}",
    "comment": "\n\t * Check if the given class represents a primitive wrapper,\n\t * i.e. Boolean, Byte, Character, Short, Integer, Long, Float, Double, or\n\t * Void.\n\t * @param clazz the class to check\n\t * @return whether the given class is a primitive wrapper class\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#isPrimitiveOrWrapper(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Check if the given class represents a primitive (i.e. boolean, byte,\r\n * char, short, int, long, float, or double), {@code void}, or a wrapper for\r\n * those types (i.e. Boolean, Byte, Character, Short, Integer, Long, Float,\r\n * Double, or Void).\r\n * @param clazz the class to check\r\n * @return {@code true} if the given class represents a primitive, void, or\r\n * a wrapper class\r\n */\r\npublic static boolean isPrimitiveOrWrapper(Class<?> clazz) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    return (clazz.isPrimitive() || isPrimitiveWrapper(clazz));\r\n}",
    "comment": "\n\t * Check if the given class represents a primitive (i.e. boolean, byte,\n\t * char, short, int, long, float, or double), {@code void}, or a wrapper for\n\t * those types (i.e. Boolean, Byte, Character, Short, Integer, Long, Float,\n\t * Double, or Void).\n\t * @param clazz the class to check\n\t * @return {@code true} if the given class represents a primitive, void, or\n\t * a wrapper class\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#isPrimitiveArray(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Check if the given class represents an array of primitives,\r\n * i.e. boolean, byte, char, short, int, long, float, or double.\r\n * @param clazz the class to check\r\n * @return whether the given class is a primitive array class\r\n */\r\npublic static boolean isPrimitiveArray(Class<?> clazz) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    return (clazz.isArray() && clazz.componentType().isPrimitive());\r\n}",
    "comment": "\n\t * Check if the given class represents an array of primitives,\n\t * i.e. boolean, byte, char, short, int, long, float, or double.\n\t * @param clazz the class to check\n\t * @return whether the given class is a primitive array class\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#isPrimitiveWrapperArray(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Check if the given class represents an array of primitive wrappers,\r\n * i.e. Boolean, Byte, Character, Short, Integer, Long, Float, or Double.\r\n * @param clazz the class to check\r\n * @return whether the given class is a primitive wrapper array class\r\n */\r\npublic static boolean isPrimitiveWrapperArray(Class<?> clazz) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    return (clazz.isArray() && isPrimitiveWrapper(clazz.componentType()));\r\n}",
    "comment": "\n\t * Check if the given class represents an array of primitive wrappers,\n\t * i.e. Boolean, Byte, Character, Short, Integer, Long, Float, or Double.\n\t * @param clazz the class to check\n\t * @return whether the given class is a primitive wrapper array class\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#resolvePrimitiveIfNecessary(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Resolve the given class if it is a primitive class,\r\n * returning the corresponding primitive wrapper type instead.\r\n * @param clazz the class to check\r\n * @return the original class, or a primitive wrapper for the original primitive type\r\n */\r\n// Dataflow analysis limitation\r\n@SuppressWarnings(\"NullAway\")\r\npublic static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    return (clazz.isPrimitive() && clazz != void.class ? primitiveTypeToWrapperMap.get(clazz) : clazz);\r\n}",
    "comment": "\n\t * Resolve the given class if it is a primitive class,\n\t * returning the corresponding primitive wrapper type instead.\n\t * @param clazz the class to check\n\t * @return the original class, or a primitive wrapper for the original primitive type\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#isVoidType(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the given type represents either {@code Void} or {@code void}.\r\n * @param type the type to check\r\n * @return {@code true} if the type represents {@code Void} or {@code void}\r\n * @since 6.1.4\r\n * @see Void\r\n * @see Void#TYPE\r\n */\r\npublic static boolean isVoidType(@Nullable Class<?> type) {\r\n    return (type == void.class || type == Void.class);\r\n}",
    "comment": "\n\t * Determine if the given type represents either {@code Void} or {@code void}.\n\t * @param type the type to check\n\t * @return {@code true} if the type represents {@code Void} or {@code void}\n\t * @since 6.1.4\n\t * @see Void\n\t * @see Void#TYPE\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#isSimpleValueType(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Delegate for {@link org.springframework.beans.BeanUtils#isSimpleValueType}.\r\n * Also used by {@link ObjectUtils#nullSafeConciseToString}.\r\n * <p>Check if the given type represents a common \"simple\" value type:\r\n * primitive or primitive wrapper, {@link Enum}, {@link String} or other\r\n * {@link CharSequence}, {@link Number}, {@link Date}, {@link Temporal},\r\n * {@link ZoneId}, {@link TimeZone}, {@link File}, {@link Path}, {@link URI},\r\n * {@link URL}, {@link InetAddress}, {@link Charset}, {@link Currency},\r\n * {@link Locale}, {@link UUID}, {@link Pattern}, or {@link Class}.\r\n * <p>{@code Void} and {@code void} are not considered simple value types.\r\n * @param type the type to check\r\n * @return whether the given type represents a \"simple\" value type,\r\n * suggesting value-based data binding and {@code toString} output\r\n * @since 6.1\r\n */\r\npublic static boolean isSimpleValueType(Class<?> type) {\r\n    return (!isVoidType(type) && (isPrimitiveOrWrapper(type) || Enum.class.isAssignableFrom(type) || CharSequence.class.isAssignableFrom(type) || Number.class.isAssignableFrom(type) || Date.class.isAssignableFrom(type) || Temporal.class.isAssignableFrom(type) || ZoneId.class.isAssignableFrom(type) || TimeZone.class.isAssignableFrom(type) || File.class.isAssignableFrom(type) || Path.class.isAssignableFrom(type) || Charset.class.isAssignableFrom(type) || Currency.class.isAssignableFrom(type) || InetAddress.class.isAssignableFrom(type) || URI.class == type || URL.class == type || UUID.class == type || Locale.class == type || Pattern.class == type || Class.class == type));\r\n}",
    "comment": "\n\t * Delegate for {@link org.springframework.beans.BeanUtils#isSimpleValueType}.\n\t * Also used by {@link ObjectUtils#nullSafeConciseToString}.\n\t * <p>Check if the given type represents a common \"simple\" value type:\n\t * primitive or primitive wrapper, {@link Enum}, {@link String} or other\n\t * {@link CharSequence}, {@link Number}, {@link Date}, {@link Temporal},\n\t * {@link ZoneId}, {@link TimeZone}, {@link File}, {@link Path}, {@link URI},\n\t * {@link URL}, {@link InetAddress}, {@link Charset}, {@link Currency},\n\t * {@link Locale}, {@link UUID}, {@link Pattern}, or {@link Class}.\n\t * <p>{@code Void} and {@code void} are not considered simple value types.\n\t * @param type the type to check\n\t * @return whether the given type represents a \"simple\" value type,\n\t * suggesting value-based data binding and {@code toString} output\n\t * @since 6.1\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#isAssignable(Class<?>,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Check if the right-hand side type may be assigned to the left-hand side\r\n * type, assuming setting by reflection. Considers primitive wrapper\r\n * classes as assignable to the corresponding primitive types.\r\n * @param lhsType the target type (left-hand side (LHS) type)\r\n * @param rhsType the value type (right-hand side (RHS) type) that should\r\n * be assigned to the target type\r\n * @return {@code true} if {@code rhsType} is assignable to {@code lhsType}\r\n * @see TypeUtils#isAssignable(java.lang.reflect.Type, java.lang.reflect.Type)\r\n */\r\npublic static boolean isAssignable(Class<?> lhsType, Class<?> rhsType) {\r\n    Assert.notNull(lhsType, \"Left-hand side type must not be null\");\r\n    Assert.notNull(rhsType, \"Right-hand side type must not be null\");\r\n    if (lhsType.isAssignableFrom(rhsType)) {\r\n        return true;\r\n    }\r\n    if (lhsType.isPrimitive()) {\r\n        Class<?> resolvedPrimitive = primitiveWrapperTypeMap.get(rhsType);\r\n        return (lhsType == resolvedPrimitive);\r\n    } else {\r\n        Class<?> resolvedWrapper = primitiveTypeToWrapperMap.get(rhsType);\r\n        return (resolvedWrapper != null && lhsType.isAssignableFrom(resolvedWrapper));\r\n    }\r\n}",
    "comment": "\n\t * Check if the right-hand side type may be assigned to the left-hand side\n\t * type, assuming setting by reflection. Considers primitive wrapper\n\t * classes as assignable to the corresponding primitive types.\n\t * @param lhsType the target type (left-hand side (LHS) type)\n\t * @param rhsType the value type (right-hand side (RHS) type) that should\n\t * be assigned to the target type\n\t * @return {@code true} if {@code rhsType} is assignable to {@code lhsType}\n\t * @see TypeUtils#isAssignable(java.lang.reflect.Type, java.lang.reflect.Type)\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#isAssignableValue(Class<?>,Object)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the given type is assignable from the given value,\r\n * assuming setting by reflection. Considers primitive wrapper classes\r\n * as assignable to the corresponding primitive types.\r\n * @param type the target type\r\n * @param value the value that should be assigned to the type\r\n * @return if the type is assignable from the value\r\n */\r\npublic static boolean isAssignableValue(Class<?> type, @Nullable Object value) {\r\n    Assert.notNull(type, \"Type must not be null\");\r\n    return (value != null ? isAssignable(type, value.getClass()) : !type.isPrimitive());\r\n}",
    "comment": "\n\t * Determine if the given type is assignable from the given value,\n\t * assuming setting by reflection. Considers primitive wrapper classes\n\t * as assignable to the corresponding primitive types.\n\t * @param type the target type\n\t * @param value the value that should be assigned to the type\n\t * @return if the type is assignable from the value\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#convertResourcePathToClassName(String)",
    "entityType": "method",
    "code": "/**\r\n * Convert a \"/\"-based resource path to a \".\"-based fully qualified class name.\r\n * @param resourcePath the resource path pointing to a class\r\n * @return the corresponding fully qualified class name\r\n */\r\npublic static String convertResourcePathToClassName(String resourcePath) {\r\n    Assert.notNull(resourcePath, \"Resource path must not be null\");\r\n    return resourcePath.replace(PATH_SEPARATOR, PACKAGE_SEPARATOR);\r\n}",
    "comment": "\n\t * Convert a \"/\"-based resource path to a \".\"-based fully qualified class name.\n\t * @param resourcePath the resource path pointing to a class\n\t * @return the corresponding fully qualified class name\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#convertClassNameToResourcePath(String)",
    "entityType": "method",
    "code": "/**\r\n * Convert a \".\"-based fully qualified class name to a \"/\"-based resource path.\r\n * @param className the fully qualified class name\r\n * @return the corresponding resource path, pointing to the class\r\n */\r\npublic static String convertClassNameToResourcePath(String className) {\r\n    Assert.notNull(className, \"Class name must not be null\");\r\n    return className.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\r\n}",
    "comment": "\n\t * Convert a \".\"-based fully qualified class name to a \"/\"-based resource path.\n\t * @param className the fully qualified class name\n\t * @return the corresponding resource path, pointing to the class\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#addResourcePathToPackagePath(Class<?>,String)",
    "entityType": "method",
    "code": "/**\r\n * Return a path suitable for use with {@code ClassLoader.getResource}\r\n * (also suitable for use with {@code Class.getResource} by prepending a\r\n * slash ('/') to the return value). Built by taking the package of the specified\r\n * class file, converting all dots ('.') to slashes ('/'), adding a trailing slash\r\n * if necessary, and concatenating the specified resource name to this.\r\n * <br/>As such, this function may be used to build a path suitable for\r\n * loading a resource file that is in the same package as a class file,\r\n * although {@link org.springframework.core.io.ClassPathResource} is usually\r\n * even more convenient.\r\n * @param clazz the Class whose package will be used as the base\r\n * @param resourceName the resource name to append. A leading slash is optional.\r\n * @return the built-up resource path\r\n * @see ClassLoader#getResource\r\n * @see Class#getResource\r\n */\r\npublic static String addResourcePathToPackagePath(Class<?> clazz, String resourceName) {\r\n    Assert.notNull(resourceName, \"Resource name must not be null\");\r\n    if (!resourceName.startsWith(\"/\")) {\r\n        return classPackageAsResourcePath(clazz) + PATH_SEPARATOR + resourceName;\r\n    }\r\n    return classPackageAsResourcePath(clazz) + resourceName;\r\n}",
    "comment": "\n\t * Return a path suitable for use with {@code ClassLoader.getResource}\n\t * (also suitable for use with {@code Class.getResource} by prepending a\n\t * slash ('/') to the return value). Built by taking the package of the specified\n\t * class file, converting all dots ('.') to slashes ('/'), adding a trailing slash\n\t * if necessary, and concatenating the specified resource name to this.\n\t * <br/>As such, this function may be used to build a path suitable for\n\t * loading a resource file that is in the same package as a class file,\n\t * although {@link org.springframework.core.io.ClassPathResource} is usually\n\t * even more convenient.\n\t * @param clazz the Class whose package will be used as the base\n\t * @param resourceName the resource name to append. A leading slash is optional.\n\t * @return the built-up resource path\n\t * @see ClassLoader#getResource\n\t * @see Class#getResource\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#classPackageAsResourcePath(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Given an input class object, return a string which consists of the\r\n * class's package name as a pathname, i.e., all dots ('.') are replaced by\r\n * slashes ('/'). Neither a leading nor trailing slash is added. The result\r\n * could be concatenated with a slash and the name of a resource and fed\r\n * directly to {@code ClassLoader.getResource()}. For it to be fed to\r\n * {@code Class.getResource} instead, a leading slash would also have\r\n * to be prepended to the returned value.\r\n * @param clazz the input class. A {@code null} value or the default\r\n * (empty) package will result in an empty string (\"\") being returned.\r\n * @return a path which represents the package name\r\n * @see ClassLoader#getResource\r\n * @see Class#getResource\r\n */\r\npublic static String classPackageAsResourcePath(@Nullable Class<?> clazz) {\r\n    if (clazz == null) {\r\n        return \"\";\r\n    }\r\n    String className = clazz.getName();\r\n    int packageEndIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\r\n    if (packageEndIndex == -1) {\r\n        return \"\";\r\n    }\r\n    String packageName = className.substring(0, packageEndIndex);\r\n    return packageName.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\r\n}",
    "comment": "\n\t * Given an input class object, return a string which consists of the\n\t * class's package name as a pathname, i.e., all dots ('.') are replaced by\n\t * slashes ('/'). Neither a leading nor trailing slash is added. The result\n\t * could be concatenated with a slash and the name of a resource and fed\n\t * directly to {@code ClassLoader.getResource()}. For it to be fed to\n\t * {@code Class.getResource} instead, a leading slash would also have\n\t * to be prepended to the returned value.\n\t * @param clazz the input class. A {@code null} value or the default\n\t * (empty) package will result in an empty string (\"\") being returned.\n\t * @return a path which represents the package name\n\t * @see ClassLoader#getResource\n\t * @see Class#getResource\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#classNamesToString(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Build a String that consists of the names of the classes/interfaces\r\n * in the given array.\r\n * <p>Basically like {@code AbstractCollection.toString()}, but stripping\r\n * the \"class \"/\"interface \" prefix before every class name.\r\n * @param classes an array of Class objects\r\n * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\r\n * @see java.util.AbstractCollection#toString()\r\n */\r\npublic static String classNamesToString(Class<?>... classes) {\r\n    return classNamesToString(Arrays.asList(classes));\r\n}",
    "comment": "\n\t * Build a String that consists of the names of the classes/interfaces\n\t * in the given array.\n\t * <p>Basically like {@code AbstractCollection.toString()}, but stripping\n\t * the \"class \"/\"interface \" prefix before every class name.\n\t * @param classes an array of Class objects\n\t * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n\t * @see java.util.AbstractCollection#toString()\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#classNamesToString(Collection<Class<?>>)",
    "entityType": "method",
    "code": "/**\r\n * Build a String that consists of the names of the classes/interfaces\r\n * in the given collection.\r\n * <p>Basically like {@code AbstractCollection.toString()}, but stripping\r\n * the \"class \"/\"interface \" prefix before every class name.\r\n * @param classes a Collection of Class objects (can be {@code null})\r\n * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\r\n * @see java.util.AbstractCollection#toString()\r\n */\r\npublic static String classNamesToString(@Nullable Collection<Class<?>> classes) {\r\n    if (CollectionUtils.isEmpty(classes)) {\r\n        return \"[]\";\r\n    }\r\n    StringJoiner stringJoiner = new StringJoiner(\", \", \"[\", \"]\");\r\n    for (Class<?> clazz : classes) {\r\n        stringJoiner.add(clazz.getName());\r\n    }\r\n    return stringJoiner.toString();\r\n}",
    "comment": "\n\t * Build a String that consists of the names of the classes/interfaces\n\t * in the given collection.\n\t * <p>Basically like {@code AbstractCollection.toString()}, but stripping\n\t * the \"class \"/\"interface \" prefix before every class name.\n\t * @param classes a Collection of Class objects (can be {@code null})\n\t * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n\t * @see java.util.AbstractCollection#toString()\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#toClassArray(Collection<Class<?>>)",
    "entityType": "method",
    "code": "/**\r\n * Copy the given {@code Collection} into a {@code Class} array.\r\n * <p>The {@code Collection} must contain {@code Class} elements only.\r\n * @param collection the {@code Collection} to copy\r\n * @return the {@code Class} array\r\n * @since 3.1\r\n * @see StringUtils#toStringArray\r\n */\r\npublic static Class<?>[] toClassArray(@Nullable Collection<Class<?>> collection) {\r\n    return (!CollectionUtils.isEmpty(collection) ? collection.toArray(EMPTY_CLASS_ARRAY) : EMPTY_CLASS_ARRAY);\r\n}",
    "comment": "\n\t * Copy the given {@code Collection} into a {@code Class} array.\n\t * <p>The {@code Collection} must contain {@code Class} elements only.\n\t * @param collection the {@code Collection} to copy\n\t * @return the {@code Class} array\n\t * @since 3.1\n\t * @see StringUtils#toStringArray\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getAllInterfaces(Object)",
    "entityType": "method",
    "code": "/**\r\n * Return all interfaces that the given instance implements as an array,\r\n * including ones implemented by superclasses.\r\n * @param instance the instance to analyze for interfaces\r\n * @return all interfaces that the given instance implements as an array\r\n */\r\npublic static Class<?>[] getAllInterfaces(Object instance) {\r\n    Assert.notNull(instance, \"Instance must not be null\");\r\n    return getAllInterfacesForClass(instance.getClass());\r\n}",
    "comment": "\n\t * Return all interfaces that the given instance implements as an array,\n\t * including ones implemented by superclasses.\n\t * @param instance the instance to analyze for interfaces\n\t * @return all interfaces that the given instance implements as an array\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getAllInterfacesForClass(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return all interfaces that the given class implements as an array,\r\n * including ones implemented by superclasses.\r\n * <p>If the class itself is an interface, it gets returned as sole interface.\r\n * @param clazz the class to analyze for interfaces\r\n * @return all interfaces that the given object implements as an array\r\n */\r\npublic static Class<?>[] getAllInterfacesForClass(Class<?> clazz) {\r\n    return getAllInterfacesForClass(clazz, null);\r\n}",
    "comment": "\n\t * Return all interfaces that the given class implements as an array,\n\t * including ones implemented by superclasses.\n\t * <p>If the class itself is an interface, it gets returned as sole interface.\n\t * @param clazz the class to analyze for interfaces\n\t * @return all interfaces that the given object implements as an array\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getAllInterfacesForClass(Class<?>,ClassLoader)",
    "entityType": "method",
    "code": "/**\r\n * Return all interfaces that the given class implements as an array,\r\n * including ones implemented by superclasses.\r\n * <p>If the class itself is an interface, it gets returned as sole interface.\r\n * @param clazz the class to analyze for interfaces\r\n * @param classLoader the ClassLoader that the interfaces need to be visible in\r\n * (can be {@code null} when accepting all declared interfaces)\r\n * @return all interfaces that the given object implements as an array\r\n */\r\npublic static Class<?>[] getAllInterfacesForClass(Class<?> clazz, @Nullable ClassLoader classLoader) {\r\n    return toClassArray(getAllInterfacesForClassAsSet(clazz, classLoader));\r\n}",
    "comment": "\n\t * Return all interfaces that the given class implements as an array,\n\t * including ones implemented by superclasses.\n\t * <p>If the class itself is an interface, it gets returned as sole interface.\n\t * @param clazz the class to analyze for interfaces\n\t * @param classLoader the ClassLoader that the interfaces need to be visible in\n\t * (can be {@code null} when accepting all declared interfaces)\n\t * @return all interfaces that the given object implements as an array\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getAllInterfacesAsSet(Object)",
    "entityType": "method",
    "code": "/**\r\n * Return all interfaces that the given instance implements as a Set,\r\n * including ones implemented by superclasses.\r\n * @param instance the instance to analyze for interfaces\r\n * @return all interfaces that the given instance implements as a Set\r\n */\r\npublic static Set<Class<?>> getAllInterfacesAsSet(Object instance) {\r\n    Assert.notNull(instance, \"Instance must not be null\");\r\n    return getAllInterfacesForClassAsSet(instance.getClass());\r\n}",
    "comment": "\n\t * Return all interfaces that the given instance implements as a Set,\n\t * including ones implemented by superclasses.\n\t * @param instance the instance to analyze for interfaces\n\t * @return all interfaces that the given instance implements as a Set\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getAllInterfacesForClassAsSet(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return all interfaces that the given class implements as a Set,\r\n * including ones implemented by superclasses.\r\n * <p>If the class itself is an interface, it gets returned as sole interface.\r\n * @param clazz the class to analyze for interfaces\r\n * @return all interfaces that the given object implements as a Set\r\n */\r\npublic static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz) {\r\n    return getAllInterfacesForClassAsSet(clazz, null);\r\n}",
    "comment": "\n\t * Return all interfaces that the given class implements as a Set,\n\t * including ones implemented by superclasses.\n\t * <p>If the class itself is an interface, it gets returned as sole interface.\n\t * @param clazz the class to analyze for interfaces\n\t * @return all interfaces that the given object implements as a Set\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getAllInterfacesForClassAsSet(Class<?>,ClassLoader)",
    "entityType": "method",
    "code": "/**\r\n * Return all interfaces that the given class implements as a Set,\r\n * including ones implemented by superclasses.\r\n * <p>If the class itself is an interface, it gets returned as sole interface.\r\n * @param clazz the class to analyze for interfaces\r\n * @param classLoader the ClassLoader that the interfaces need to be visible in\r\n * (can be {@code null} when accepting all declared interfaces)\r\n * @return all interfaces that the given object implements as a Set\r\n */\r\npublic static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, @Nullable ClassLoader classLoader) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    if (clazz.isInterface() && isVisible(clazz, classLoader)) {\r\n        return Collections.singleton(clazz);\r\n    }\r\n    Set<Class<?>> interfaces = new LinkedHashSet<>();\r\n    Class<?> current = clazz;\r\n    while (current != null) {\r\n        Class<?>[] ifcs = current.getInterfaces();\r\n        for (Class<?> ifc : ifcs) {\r\n            if (isVisible(ifc, classLoader)) {\r\n                interfaces.add(ifc);\r\n            }\r\n        }\r\n        current = current.getSuperclass();\r\n    }\r\n    return interfaces;\r\n}",
    "comment": "\n\t * Return all interfaces that the given class implements as a Set,\n\t * including ones implemented by superclasses.\n\t * <p>If the class itself is an interface, it gets returned as sole interface.\n\t * @param clazz the class to analyze for interfaces\n\t * @param classLoader the ClassLoader that the interfaces need to be visible in\n\t * (can be {@code null} when accepting all declared interfaces)\n\t * @return all interfaces that the given object implements as a Set\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#createCompositeInterface(Class<?>[],ClassLoader)",
    "entityType": "method",
    "code": "/**\r\n * Create a composite interface Class for the given interfaces,\r\n * implementing the given interfaces in one single Class.\r\n * <p>This implementation builds a JDK proxy class for the given interfaces.\r\n * @param interfaces the interfaces to merge\r\n * @param classLoader the ClassLoader to create the composite Class in\r\n * @return the merged interface as Class\r\n * @throws IllegalArgumentException if the specified interfaces expose\r\n * conflicting method signatures (or a similar constraint is violated)\r\n * @see java.lang.reflect.Proxy#getProxyClass\r\n */\r\n@SuppressWarnings(\"deprecation\")\r\npublic static Class<?> createCompositeInterface(Class<?>[] interfaces, @Nullable ClassLoader classLoader) {\r\n    Assert.notEmpty(interfaces, \"Interface array must not be empty\");\r\n    return Proxy.getProxyClass(classLoader, interfaces);\r\n}",
    "comment": "\n\t * Create a composite interface Class for the given interfaces,\n\t * implementing the given interfaces in one single Class.\n\t * <p>This implementation builds a JDK proxy class for the given interfaces.\n\t * @param interfaces the interfaces to merge\n\t * @param classLoader the ClassLoader to create the composite Class in\n\t * @return the merged interface as Class\n\t * @throws IllegalArgumentException if the specified interfaces expose\n\t * conflicting method signatures (or a similar constraint is violated)\n\t * @see java.lang.reflect.Proxy#getProxyClass\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#determineCommonAncestor(Class<?>,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Determine the common ancestor of the given classes, if any.\r\n * @param clazz1 the class to introspect\r\n * @param clazz2 the other class to introspect\r\n * @return the common ancestor (i.e. common superclass, one interface\r\n * extending the other), or {@code null} if none found. If any of the\r\n * given classes is {@code null}, the other class will be returned.\r\n * @since 3.2.6\r\n */\r\n@Nullable\r\npublic static Class<?> determineCommonAncestor(@Nullable Class<?> clazz1, @Nullable Class<?> clazz2) {\r\n    if (clazz1 == null) {\r\n        return clazz2;\r\n    }\r\n    if (clazz2 == null) {\r\n        return clazz1;\r\n    }\r\n    if (clazz1.isAssignableFrom(clazz2)) {\r\n        return clazz1;\r\n    }\r\n    if (clazz2.isAssignableFrom(clazz1)) {\r\n        return clazz2;\r\n    }\r\n    Class<?> ancestor = clazz1;\r\n    do {\r\n        ancestor = ancestor.getSuperclass();\r\n        if (ancestor == null || Object.class == ancestor) {\r\n            return null;\r\n        }\r\n    } while (!ancestor.isAssignableFrom(clazz2));\r\n    return ancestor;\r\n}",
    "comment": "\n\t * Determine the common ancestor of the given classes, if any.\n\t * @param clazz1 the class to introspect\n\t * @param clazz2 the other class to introspect\n\t * @return the common ancestor (i.e. common superclass, one interface\n\t * extending the other), or {@code null} if none found. If any of the\n\t * given classes is {@code null}, the other class will be returned.\n\t * @since 3.2.6\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#isJavaLanguageInterface(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given interface is a common Java language interface:\r\n * {@link Serializable}, {@link Externalizable}, {@link Closeable}, {@link AutoCloseable},\r\n * {@link Cloneable}, {@link Comparable} - all of which can be ignored when looking\r\n * for 'primary' user-level interfaces. Common characteristics: no service-level\r\n * operations, no bean property methods, no default methods.\r\n * @param ifc the interface to check\r\n * @since 5.0.3\r\n */\r\npublic static boolean isJavaLanguageInterface(Class<?> ifc) {\r\n    return javaLanguageInterfaces.contains(ifc);\r\n}",
    "comment": "\n\t * Determine whether the given interface is a common Java language interface:\n\t * {@link Serializable}, {@link Externalizable}, {@link Closeable}, {@link AutoCloseable},\n\t * {@link Cloneable}, {@link Comparable} - all of which can be ignored when looking\n\t * for 'primary' user-level interfaces. Common characteristics: no service-level\n\t * operations, no bean property methods, no default methods.\n\t * @param ifc the interface to check\n\t * @since 5.0.3\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#isStaticClass(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the supplied class is a static class.\r\n * @return {@code true} if the supplied class is a static class\r\n * @since 6.0\r\n * @see Modifier#isStatic(int)\r\n * @see #isInnerClass(Class)\r\n */\r\npublic static boolean isStaticClass(Class<?> clazz) {\r\n    return Modifier.isStatic(clazz.getModifiers());\r\n}",
    "comment": "\n\t * Determine if the supplied class is a static class.\n\t * @return {@code true} if the supplied class is a static class\n\t * @since 6.0\n\t * @see Modifier#isStatic(int)\n\t * @see #isInnerClass(Class)\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#isInnerClass(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the supplied class is an <em>inner class</em>,\r\n * i.e. a non-static member of an enclosing class.\r\n * @return {@code true} if the supplied class is an inner class\r\n * @since 5.0.5\r\n * @see Class#isMemberClass()\r\n * @see #isStaticClass(Class)\r\n */\r\npublic static boolean isInnerClass(Class<?> clazz) {\r\n    return (clazz.isMemberClass() && !isStaticClass(clazz));\r\n}",
    "comment": "\n\t * Determine if the supplied class is an <em>inner class</em>,\n\t * i.e. a non-static member of an enclosing class.\n\t * @return {@code true} if the supplied class is an inner class\n\t * @since 5.0.5\n\t * @see Class#isMemberClass()\n\t * @see #isStaticClass(Class)\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#isLambdaClass(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the supplied {@link Class} is a JVM-generated implementation\r\n * class for a lambda expression or method reference.\r\n * <p>This method makes a best-effort attempt at determining this, based on\r\n * checks that work on modern, mainstream JVMs.\r\n * @param clazz the class to check\r\n * @return {@code true} if the class is a lambda implementation class\r\n * @since 5.3.19\r\n */\r\npublic static boolean isLambdaClass(Class<?> clazz) {\r\n    return (clazz.isSynthetic() && (clazz.getSuperclass() == Object.class) && (clazz.getInterfaces().length > 0) && clazz.getName().contains(\"$$Lambda\"));\r\n}",
    "comment": "\n\t * Determine if the supplied {@link Class} is a JVM-generated implementation\n\t * class for a lambda expression or method reference.\n\t * <p>This method makes a best-effort attempt at determining this, based on\n\t * checks that work on modern, mainstream JVMs.\n\t * @param clazz the class to check\n\t * @return {@code true} if the class is a lambda implementation class\n\t * @since 5.3.19\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#isCglibProxy(Object)",
    "entityType": "method",
    "code": "/**\r\n * Check whether the given object is a CGLIB proxy.\r\n * @param object the object to check\r\n * @see org.springframework.aop.support.AopUtils#isCglibProxy(Object)\r\n * @deprecated as of 5.2, in favor of custom (possibly narrower) checks\r\n * such as for a Spring AOP proxy\r\n */\r\n@Deprecated\r\npublic static boolean isCglibProxy(Object object) {\r\n    return isCglibProxyClass(object.getClass());\r\n}",
    "comment": "\n\t * Check whether the given object is a CGLIB proxy.\n\t * @param object the object to check\n\t * @see org.springframework.aop.support.AopUtils#isCglibProxy(Object)\n\t * @deprecated as of 5.2, in favor of custom (possibly narrower) checks\n\t * such as for a Spring AOP proxy\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#isCglibProxyClass(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Check whether the specified class is a CGLIB-generated class.\r\n * @param clazz the class to check\r\n * @see #getUserClass(Class)\r\n * @deprecated as of 5.2, in favor of custom (possibly narrower) checks\r\n * or simply a check for containing {@link #CGLIB_CLASS_SEPARATOR}\r\n */\r\n@Deprecated\r\npublic static boolean isCglibProxyClass(@Nullable Class<?> clazz) {\r\n    return (clazz != null && isCglibProxyClassName(clazz.getName()));\r\n}",
    "comment": "\n\t * Check whether the specified class is a CGLIB-generated class.\n\t * @param clazz the class to check\n\t * @see #getUserClass(Class)\n\t * @deprecated as of 5.2, in favor of custom (possibly narrower) checks\n\t * or simply a check for containing {@link #CGLIB_CLASS_SEPARATOR}\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#isCglibProxyClassName(String)",
    "entityType": "method",
    "code": "/**\r\n * Check whether the specified class name is a CGLIB-generated class.\r\n * @param className the class name to check\r\n * @see #CGLIB_CLASS_SEPARATOR\r\n * @deprecated as of 5.2, in favor of custom (possibly narrower) checks\r\n * or simply a check for containing {@link #CGLIB_CLASS_SEPARATOR}\r\n */\r\n@Deprecated\r\npublic static boolean isCglibProxyClassName(@Nullable String className) {\r\n    return (className != null && className.contains(CGLIB_CLASS_SEPARATOR));\r\n}",
    "comment": "\n\t * Check whether the specified class name is a CGLIB-generated class.\n\t * @param className the class name to check\n\t * @see #CGLIB_CLASS_SEPARATOR\n\t * @deprecated as of 5.2, in favor of custom (possibly narrower) checks\n\t * or simply a check for containing {@link #CGLIB_CLASS_SEPARATOR}\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getUserClass(Object)",
    "entityType": "method",
    "code": "/**\r\n * Return the user-defined class for the given instance: usually simply\r\n * the class of the given instance, but the original class in case of a\r\n * CGLIB-generated subclass.\r\n * @param instance the instance to check\r\n * @return the user-defined class\r\n */\r\npublic static Class<?> getUserClass(Object instance) {\r\n    Assert.notNull(instance, \"Instance must not be null\");\r\n    return getUserClass(instance.getClass());\r\n}",
    "comment": "\n\t * Return the user-defined class for the given instance: usually simply\n\t * the class of the given instance, but the original class in case of a\n\t * CGLIB-generated subclass.\n\t * @param instance the instance to check\n\t * @return the user-defined class\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getUserClass(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return the user-defined class for the given class: usually simply the given\r\n * class, but the original class in case of a CGLIB-generated subclass.\r\n * @param clazz the class to check\r\n * @return the user-defined class\r\n * @see #CGLIB_CLASS_SEPARATOR\r\n */\r\npublic static Class<?> getUserClass(Class<?> clazz) {\r\n    if (clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) {\r\n        Class<?> superclass = clazz.getSuperclass();\r\n        if (superclass != null && superclass != Object.class) {\r\n            return superclass;\r\n        }\r\n    }\r\n    return clazz;\r\n}",
    "comment": "\n\t * Return the user-defined class for the given class: usually simply the given\n\t * class, but the original class in case of a CGLIB-generated subclass.\n\t * @param clazz the class to check\n\t * @return the user-defined class\n\t * @see #CGLIB_CLASS_SEPARATOR\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getDescriptiveType(Object)",
    "entityType": "method",
    "code": "/**\r\n * Return a descriptive name for the given object's type: usually simply\r\n * the class name, but component type class name + \"[]\" for arrays,\r\n * and an appended list of implemented interfaces for JDK proxies.\r\n * @param value the value to introspect\r\n * @return the qualified name of the class\r\n */\r\n@Nullable\r\npublic static String getDescriptiveType(@Nullable Object value) {\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    Class<?> clazz = value.getClass();\r\n    if (Proxy.isProxyClass(clazz)) {\r\n        String prefix = clazz.getTypeName() + \" implementing \";\r\n        StringJoiner result = new StringJoiner(\",\", prefix, \"\");\r\n        for (Class<?> ifc : clazz.getInterfaces()) {\r\n            result.add(ifc.getTypeName());\r\n        }\r\n        return result.toString();\r\n    } else {\r\n        return clazz.getTypeName();\r\n    }\r\n}",
    "comment": "\n\t * Return a descriptive name for the given object's type: usually simply\n\t * the class name, but component type class name + \"[]\" for arrays,\n\t * and an appended list of implemented interfaces for JDK proxies.\n\t * @param value the value to introspect\n\t * @return the qualified name of the class\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#matchesTypeName(Class<?>,String)",
    "entityType": "method",
    "code": "/**\r\n * Check whether the given class matches the user-specified type name.\r\n * @param clazz the class to check\r\n * @param typeName the type name to match\r\n */\r\npublic static boolean matchesTypeName(Class<?> clazz, @Nullable String typeName) {\r\n    return (typeName != null && (typeName.equals(clazz.getTypeName()) || typeName.equals(clazz.getSimpleName())));\r\n}",
    "comment": "\n\t * Check whether the given class matches the user-specified type name.\n\t * @param clazz the class to check\n\t * @param typeName the type name to match\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getShortName(String)",
    "entityType": "method",
    "code": "/**\r\n * Get the class name without the qualified package name.\r\n * @param className the className to get the short name for\r\n * @return the class name of the class without the package name\r\n * @throws IllegalArgumentException if the className is empty\r\n */\r\npublic static String getShortName(String className) {\r\n    Assert.hasLength(className, \"Class name must not be empty\");\r\n    int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\r\n    int nameEndIndex = className.indexOf(CGLIB_CLASS_SEPARATOR);\r\n    if (nameEndIndex == -1) {\r\n        nameEndIndex = className.length();\r\n    }\r\n    String shortName = className.substring(lastDotIndex + 1, nameEndIndex);\r\n    shortName = shortName.replace(NESTED_CLASS_SEPARATOR, PACKAGE_SEPARATOR);\r\n    return shortName;\r\n}",
    "comment": "\n\t * Get the class name without the qualified package name.\n\t * @param className the className to get the short name for\n\t * @return the class name of the class without the package name\n\t * @throws IllegalArgumentException if the className is empty\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getShortName(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Get the class name without the qualified package name.\r\n * @param clazz the class to get the short name for\r\n * @return the class name of the class without the package name\r\n */\r\npublic static String getShortName(Class<?> clazz) {\r\n    return getShortName(getQualifiedName(clazz));\r\n}",
    "comment": "\n\t * Get the class name without the qualified package name.\n\t * @param clazz the class to get the short name for\n\t * @return the class name of the class without the package name\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getShortNameAsProperty(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return the short string name of a Java class in uncapitalized JavaBeans\r\n * property format. Strips the outer class name in case of a nested class.\r\n * @param clazz the class\r\n * @return the short name rendered in a standard JavaBeans property format\r\n * @see StringUtils#uncapitalizeAsProperty(String)\r\n */\r\npublic static String getShortNameAsProperty(Class<?> clazz) {\r\n    String shortName = getShortName(clazz);\r\n    int dotIndex = shortName.lastIndexOf(PACKAGE_SEPARATOR);\r\n    shortName = (dotIndex != -1 ? shortName.substring(dotIndex + 1) : shortName);\r\n    return StringUtils.uncapitalizeAsProperty(shortName);\r\n}",
    "comment": "\n\t * Return the short string name of a Java class in uncapitalized JavaBeans\n\t * property format. Strips the outer class name in case of a nested class.\n\t * @param clazz the class\n\t * @return the short name rendered in a standard JavaBeans property format\n\t * @see StringUtils#uncapitalizeAsProperty(String)\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getClassFileName(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Determine the name of the class file, relative to the containing\r\n * package: for example, \"String.class\".\r\n * @param clazz the class\r\n * @return the file name of the \".class\" file\r\n */\r\npublic static String getClassFileName(Class<?> clazz) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    String className = clazz.getName();\r\n    int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\r\n    return className.substring(lastDotIndex + 1) + CLASS_FILE_SUFFIX;\r\n}",
    "comment": "\n\t * Determine the name of the class file, relative to the containing\n\t * package: for example, \"String.class\".\n\t * @param clazz the class\n\t * @return the file name of the \".class\" file\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getPackageName(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Determine the name of the package of the given class,\r\n * for example, \"java.lang\" for the {@code java.lang.String} class.\r\n * @param clazz the class\r\n * @return the package name, or the empty String if the class\r\n * is defined in the default package\r\n */\r\npublic static String getPackageName(Class<?> clazz) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    return getPackageName(clazz.getName());\r\n}",
    "comment": "\n\t * Determine the name of the package of the given class,\n\t * for example, \"java.lang\" for the {@code java.lang.String} class.\n\t * @param clazz the class\n\t * @return the package name, or the empty String if the class\n\t * is defined in the default package\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getPackageName(String)",
    "entityType": "method",
    "code": "/**\r\n * Determine the name of the package of the given fully-qualified class name,\r\n * for example, \"java.lang\" for the {@code java.lang.String} class name.\r\n * @param fqClassName the fully-qualified class name\r\n * @return the package name, or the empty String if the class\r\n * is defined in the default package\r\n */\r\npublic static String getPackageName(String fqClassName) {\r\n    Assert.notNull(fqClassName, \"Class name must not be null\");\r\n    int lastDotIndex = fqClassName.lastIndexOf(PACKAGE_SEPARATOR);\r\n    return (lastDotIndex != -1 ? fqClassName.substring(0, lastDotIndex) : \"\");\r\n}",
    "comment": "\n\t * Determine the name of the package of the given fully-qualified class name,\n\t * for example, \"java.lang\" for the {@code java.lang.String} class name.\n\t * @param fqClassName the fully-qualified class name\n\t * @return the package name, or the empty String if the class\n\t * is defined in the default package\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getQualifiedName(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return the qualified name of the given class: usually simply\r\n * the class name, but component type class name + \"[]\" for arrays.\r\n * @param clazz the class\r\n * @return the qualified name of the class\r\n */\r\npublic static String getQualifiedName(Class<?> clazz) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    return clazz.getTypeName();\r\n}",
    "comment": "\n\t * Return the qualified name of the given class: usually simply\n\t * the class name, but component type class name + \"[]\" for arrays.\n\t * @param clazz the class\n\t * @return the qualified name of the class\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getQualifiedMethodName(Method)",
    "entityType": "method",
    "code": "/**\r\n * Return the qualified name of the given method, consisting of\r\n * fully qualified interface/class name + \".\" + method name.\r\n * @param method the method\r\n * @return the qualified name of the method\r\n */\r\npublic static String getQualifiedMethodName(Method method) {\r\n    return getQualifiedMethodName(method, null);\r\n}",
    "comment": "\n\t * Return the qualified name of the given method, consisting of\n\t * fully qualified interface/class name + \".\" + method name.\n\t * @param method the method\n\t * @return the qualified name of the method\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getQualifiedMethodName(Method,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return the qualified name of the given method, consisting of\r\n * fully qualified interface/class name + \".\" + method name.\r\n * @param method the method\r\n * @param clazz the clazz that the method is being invoked on\r\n * (can be {@code null} to indicate the method's declaring class)\r\n * @return the qualified name of the method\r\n * @since 4.3.4\r\n */\r\npublic static String getQualifiedMethodName(Method method, @Nullable Class<?> clazz) {\r\n    Assert.notNull(method, \"Method must not be null\");\r\n    return (clazz != null ? clazz : method.getDeclaringClass()).getName() + '.' + method.getName();\r\n}",
    "comment": "\n\t * Return the qualified name of the given method, consisting of\n\t * fully qualified interface/class name + \".\" + method name.\n\t * @param method the method\n\t * @param clazz the clazz that the method is being invoked on\n\t * (can be {@code null} to indicate the method's declaring class)\n\t * @return the qualified name of the method\n\t * @since 4.3.4\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#hasConstructor(Class<?>,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given class has a public constructor with the given signature.\r\n * <p>Essentially translates {@code NoSuchMethodException} to \"false\".\r\n * @param clazz the clazz to analyze\r\n * @param paramTypes the parameter types of the method\r\n * @return whether the class has a corresponding constructor\r\n * @see Class#getConstructor\r\n */\r\npublic static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes) {\r\n    return (getConstructorIfAvailable(clazz, paramTypes) != null);\r\n}",
    "comment": "\n\t * Determine whether the given class has a public constructor with the given signature.\n\t * <p>Essentially translates {@code NoSuchMethodException} to \"false\".\n\t * @param clazz the clazz to analyze\n\t * @param paramTypes the parameter types of the method\n\t * @return whether the class has a corresponding constructor\n\t * @see Class#getConstructor\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getConstructorIfAvailable(Class<T>,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given class has a public constructor with the given signature,\r\n * and return it if available (else return {@code null}).\r\n * <p>Essentially translates {@code NoSuchMethodException} to {@code null}.\r\n * @param clazz the clazz to analyze\r\n * @param paramTypes the parameter types of the method\r\n * @return the constructor, or {@code null} if not found\r\n * @see Class#getConstructor\r\n */\r\n@Nullable\r\npublic static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    try {\r\n        return clazz.getConstructor(paramTypes);\r\n    } catch (NoSuchMethodException ex) {\r\n        return null;\r\n    }\r\n}",
    "comment": "\n\t * Determine whether the given class has a public constructor with the given signature,\n\t * and return it if available (else return {@code null}).\n\t * <p>Essentially translates {@code NoSuchMethodException} to {@code null}.\n\t * @param clazz the clazz to analyze\n\t * @param paramTypes the parameter types of the method\n\t * @return the constructor, or {@code null} if not found\n\t * @see Class#getConstructor\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#hasMethod(Class<?>,Method)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given class has a public method with the given signature.\r\n * @param clazz the clazz to analyze\r\n * @param method the method to look for\r\n * @return whether the class has a corresponding method\r\n * @since 5.2.3\r\n */\r\npublic static boolean hasMethod(Class<?> clazz, Method method) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    Assert.notNull(method, \"Method must not be null\");\r\n    if (clazz == method.getDeclaringClass()) {\r\n        return true;\r\n    }\r\n    String methodName = method.getName();\r\n    Class<?>[] paramTypes = method.getParameterTypes();\r\n    return getMethodOrNull(clazz, methodName, paramTypes) != null;\r\n}",
    "comment": "\n\t * Determine whether the given class has a public method with the given signature.\n\t * @param clazz the clazz to analyze\n\t * @param method the method to look for\n\t * @return whether the class has a corresponding method\n\t * @since 5.2.3\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#hasMethod(Class<?>,String,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given class has a public method with the given signature.\r\n * <p>Essentially translates {@code NoSuchMethodException} to \"false\".\r\n * @param clazz the clazz to analyze\r\n * @param methodName the name of the method\r\n * @param paramTypes the parameter types of the method\r\n * @return whether the class has a corresponding method\r\n * @see Class#getMethod\r\n */\r\npublic static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\r\n    return (getMethodIfAvailable(clazz, methodName, paramTypes) != null);\r\n}",
    "comment": "\n\t * Determine whether the given class has a public method with the given signature.\n\t * <p>Essentially translates {@code NoSuchMethodException} to \"false\".\n\t * @param clazz the clazz to analyze\n\t * @param methodName the name of the method\n\t * @param paramTypes the parameter types of the method\n\t * @return whether the class has a corresponding method\n\t * @see Class#getMethod\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getMethod(Class<?>,String,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given class has a public method with the given signature,\r\n * and return it if available (else throws an {@code IllegalStateException}).\r\n * <p>In case of any signature specified, only returns the method if there is a\r\n * unique candidate, i.e. a single public method with the specified name.\r\n * <p>Essentially translates {@code NoSuchMethodException} to {@code IllegalStateException}.\r\n * @param clazz the clazz to analyze\r\n * @param methodName the name of the method\r\n * @param paramTypes the parameter types of the method\r\n * (can be {@code null} to indicate any signature)\r\n * @return the method (never {@code null})\r\n * @throws IllegalStateException if the method has not been found\r\n * @see Class#getMethod\r\n */\r\npublic static Method getMethod(Class<?> clazz, String methodName, @Nullable Class<?>... paramTypes) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    Assert.notNull(methodName, \"Method name must not be null\");\r\n    if (paramTypes != null) {\r\n        try {\r\n            return clazz.getMethod(methodName, paramTypes);\r\n        } catch (NoSuchMethodException ex) {\r\n            throw new IllegalStateException(\"Expected method not found: \" + ex);\r\n        }\r\n    } else {\r\n        Set<Method> candidates = findMethodCandidatesByName(clazz, methodName);\r\n        if (candidates.size() == 1) {\r\n            return candidates.iterator().next();\r\n        } else if (candidates.isEmpty()) {\r\n            throw new IllegalStateException(\"Expected method not found: \" + clazz.getName() + '.' + methodName);\r\n        } else {\r\n            throw new IllegalStateException(\"No unique method found: \" + clazz.getName() + '.' + methodName);\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Determine whether the given class has a public method with the given signature,\n\t * and return it if available (else throws an {@code IllegalStateException}).\n\t * <p>In case of any signature specified, only returns the method if there is a\n\t * unique candidate, i.e. a single public method with the specified name.\n\t * <p>Essentially translates {@code NoSuchMethodException} to {@code IllegalStateException}.\n\t * @param clazz the clazz to analyze\n\t * @param methodName the name of the method\n\t * @param paramTypes the parameter types of the method\n\t * (can be {@code null} to indicate any signature)\n\t * @return the method (never {@code null})\n\t * @throws IllegalStateException if the method has not been found\n\t * @see Class#getMethod\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getMethodIfAvailable(Class<?>,String,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given class has a public method with the given signature,\r\n * and return it if available (else return {@code null}).\r\n * <p>In case of any signature specified, only returns the method if there is a\r\n * unique candidate, i.e. a single public method with the specified name.\r\n * <p>Essentially translates {@code NoSuchMethodException} to {@code null}.\r\n * @param clazz the clazz to analyze\r\n * @param methodName the name of the method\r\n * @param paramTypes the parameter types of the method\r\n * (can be {@code null} to indicate any signature)\r\n * @return the method, or {@code null} if not found\r\n * @see Class#getMethod\r\n */\r\n@Nullable\r\npublic static Method getMethodIfAvailable(Class<?> clazz, String methodName, @Nullable Class<?>@Nullable ... paramTypes) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    Assert.notNull(methodName, \"Method name must not be null\");\r\n    if (paramTypes != null) {\r\n        return getMethodOrNull(clazz, methodName, paramTypes);\r\n    } else {\r\n        Set<Method> candidates = findMethodCandidatesByName(clazz, methodName);\r\n        if (candidates.size() == 1) {\r\n            return candidates.iterator().next();\r\n        }\r\n        return null;\r\n    }\r\n}",
    "comment": "\n\t * Determine whether the given class has a public method with the given signature,\n\t * and return it if available (else return {@code null}).\n\t * <p>In case of any signature specified, only returns the method if there is a\n\t * unique candidate, i.e. a single public method with the specified name.\n\t * <p>Essentially translates {@code NoSuchMethodException} to {@code null}.\n\t * @param clazz the clazz to analyze\n\t * @param methodName the name of the method\n\t * @param paramTypes the parameter types of the method\n\t * (can be {@code null} to indicate any signature)\n\t * @return the method, or {@code null} if not found\n\t * @see Class#getMethod\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getMethodCountForName(Class<?>,String)",
    "entityType": "method",
    "code": "/**\r\n * Return the number of methods with a given name (with any argument types),\r\n * for the given class and/or its superclasses. Includes non-public methods.\r\n * @param clazz\tthe clazz to check\r\n * @param methodName the name of the method\r\n * @return the number of methods with the given name\r\n */\r\npublic static int getMethodCountForName(Class<?> clazz, String methodName) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    Assert.notNull(methodName, \"Method name must not be null\");\r\n    int count = 0;\r\n    Method[] declaredMethods = clazz.getDeclaredMethods();\r\n    for (Method method : declaredMethods) {\r\n        if (methodName.equals(method.getName())) {\r\n            count++;\r\n        }\r\n    }\r\n    Class<?>[] ifcs = clazz.getInterfaces();\r\n    for (Class<?> ifc : ifcs) {\r\n        count += getMethodCountForName(ifc, methodName);\r\n    }\r\n    if (clazz.getSuperclass() != null) {\r\n        count += getMethodCountForName(clazz.getSuperclass(), methodName);\r\n    }\r\n    return count;\r\n}",
    "comment": "\n\t * Return the number of methods with a given name (with any argument types),\n\t * for the given class and/or its superclasses. Includes non-public methods.\n\t * @param clazz\tthe clazz to check\n\t * @param methodName the name of the method\n\t * @return the number of methods with the given name\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#hasAtLeastOneMethodWithName(Class<?>,String)",
    "entityType": "method",
    "code": "/**\r\n * Does the given class or one of its superclasses at least have one or more\r\n * methods with the supplied name (with any argument types)?\r\n * Includes non-public methods.\r\n * @param clazz\tthe clazz to check\r\n * @param methodName the name of the method\r\n * @return whether there is at least one method with the given name\r\n */\r\npublic static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    Assert.notNull(methodName, \"Method name must not be null\");\r\n    Method[] declaredMethods = clazz.getDeclaredMethods();\r\n    for (Method method : declaredMethods) {\r\n        if (method.getName().equals(methodName)) {\r\n            return true;\r\n        }\r\n    }\r\n    Class<?>[] ifcs = clazz.getInterfaces();\r\n    for (Class<?> ifc : ifcs) {\r\n        if (hasAtLeastOneMethodWithName(ifc, methodName)) {\r\n            return true;\r\n        }\r\n    }\r\n    return (clazz.getSuperclass() != null && hasAtLeastOneMethodWithName(clazz.getSuperclass(), methodName));\r\n}",
    "comment": "\n\t * Does the given class or one of its superclasses at least have one or more\n\t * methods with the supplied name (with any argument types)?\n\t * Includes non-public methods.\n\t * @param clazz\tthe clazz to check\n\t * @param methodName the name of the method\n\t * @return whether there is at least one method with the given name\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getMostSpecificMethod(Method,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Given a method, which may come from an interface, and a target class used\r\n * in the current reflective invocation, find the corresponding target method\r\n * if there is one &mdash; for example, the method may be {@code IFoo.bar()},\r\n * and the target class may be {@code DefaultFoo}. In this case, the method may be\r\n * {@code DefaultFoo.bar()}. This enables attributes on that method to be found.\r\n * <p><b>NOTE:</b> In contrast to {@link org.springframework.aop.support.AopUtils#getMostSpecificMethod},\r\n * this method does <i>not</i> resolve bridge methods automatically.\r\n * Call {@link org.springframework.core.BridgeMethodResolver#findBridgedMethod}\r\n * if bridge method resolution is desirable &mdash; for example, to obtain\r\n * metadata from the original method definition.\r\n * <p><b>NOTE:</b> If Java security settings disallow reflective access &mdash;\r\n * for example, calls to {@code Class#getDeclaredMethods}, etc. &mdash; this\r\n * implementation will fall back to returning the originally provided method.\r\n * @param method the method to be invoked, which may come from an interface\r\n * @param targetClass the target class for the current invocation\r\n * (can be {@code null} or may not even implement the method)\r\n * @return the specific target method, or the original method if the\r\n * {@code targetClass} does not implement it\r\n * @see #getInterfaceMethodIfPossible(Method, Class)\r\n */\r\npublic static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass) {\r\n    if (targetClass != null && targetClass != method.getDeclaringClass() && (isOverridable(method, targetClass) || !method.getDeclaringClass().isAssignableFrom(targetClass))) {\r\n        try {\r\n            if (Modifier.isPublic(method.getModifiers())) {\r\n                try {\r\n                    return targetClass.getMethod(method.getName(), method.getParameterTypes());\r\n                } catch (NoSuchMethodException ex) {\r\n                    return method;\r\n                }\r\n            } else {\r\n                Method specificMethod = ReflectionUtils.findMethod(targetClass, method.getName(), method.getParameterTypes());\r\n                return (specificMethod != null ? specificMethod : method);\r\n            }\r\n        } catch (SecurityException ex) {\r\n            // Security settings are disallowing reflective access; fall back to 'method' below.\r\n        }\r\n    }\r\n    return method;\r\n}",
    "comment": "\n\t * Given a method, which may come from an interface, and a target class used\n\t * in the current reflective invocation, find the corresponding target method\n\t * if there is one &mdash; for example, the method may be {@code IFoo.bar()},\n\t * and the target class may be {@code DefaultFoo}. In this case, the method may be\n\t * {@code DefaultFoo.bar()}. This enables attributes on that method to be found.\n\t * <p><b>NOTE:</b> In contrast to {@link org.springframework.aop.support.AopUtils#getMostSpecificMethod},\n\t * this method does <i>not</i> resolve bridge methods automatically.\n\t * Call {@link org.springframework.core.BridgeMethodResolver#findBridgedMethod}\n\t * if bridge method resolution is desirable &mdash; for example, to obtain\n\t * metadata from the original method definition.\n\t * <p><b>NOTE:</b> If Java security settings disallow reflective access &mdash;\n\t * for example, calls to {@code Class#getDeclaredMethods}, etc. &mdash; this\n\t * implementation will fall back to returning the originally provided method.\n\t * @param method the method to be invoked, which may come from an interface\n\t * @param targetClass the target class for the current invocation\n\t * (can be {@code null} or may not even implement the method)\n\t * @return the specific target method, or the original method if the\n\t * {@code targetClass} does not implement it\n\t * @see #getInterfaceMethodIfPossible(Method, Class)\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getInterfaceMethodIfPossible(Method)",
    "entityType": "method",
    "code": "/**\r\n * Determine a corresponding interface method for the given method handle, if possible.\r\n * <p>This is particularly useful for arriving at a public exported type on the Java\r\n * Module System which allows the method to be invoked via reflection without an illegal\r\n * access warning.\r\n * @param method the method to be invoked, potentially from an implementation class\r\n * @return the corresponding interface method, or the original method if none found\r\n * @since 5.1\r\n * @see #getPubliclyAccessibleMethodIfPossible(Method, Class)\r\n * @deprecated in favor of {@link #getInterfaceMethodIfPossible(Method, Class)}\r\n */\r\n@Deprecated\r\npublic static Method getInterfaceMethodIfPossible(Method method) {\r\n    return getInterfaceMethodIfPossible(method, null);\r\n}",
    "comment": "\n\t * Determine a corresponding interface method for the given method handle, if possible.\n\t * <p>This is particularly useful for arriving at a public exported type on the Java\n\t * Module System which allows the method to be invoked via reflection without an illegal\n\t * access warning.\n\t * @param method the method to be invoked, potentially from an implementation class\n\t * @return the corresponding interface method, or the original method if none found\n\t * @since 5.1\n\t * @see #getPubliclyAccessibleMethodIfPossible(Method, Class)\n\t * @deprecated in favor of {@link #getInterfaceMethodIfPossible(Method, Class)}\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getInterfaceMethodIfPossible(Method,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Determine a corresponding interface method for the given method handle, if possible.\r\n * <p>This is particularly useful for arriving at a public exported type on the Java\r\n * Module System which allows the method to be invoked via reflection without an illegal\r\n * access warning.\r\n * @param method the method to be invoked, potentially from an implementation class\r\n * @param targetClass the target class to invoke the method on, or {@code null} if unknown\r\n * @return the corresponding interface method, or the original method if none found\r\n * @since 5.3.16\r\n * @see #getPubliclyAccessibleMethodIfPossible(Method, Class)\r\n * @see #getMostSpecificMethod\r\n */\r\npublic static Method getInterfaceMethodIfPossible(Method method, @Nullable Class<?> targetClass) {\r\n    return getInterfaceMethodIfPossible(method, targetClass, false);\r\n}",
    "comment": "\n\t * Determine a corresponding interface method for the given method handle, if possible.\n\t * <p>This is particularly useful for arriving at a public exported type on the Java\n\t * Module System which allows the method to be invoked via reflection without an illegal\n\t * access warning.\n\t * @param method the method to be invoked, potentially from an implementation class\n\t * @param targetClass the target class to invoke the method on, or {@code null} if unknown\n\t * @return the corresponding interface method, or the original method if none found\n\t * @since 5.3.16\n\t * @see #getPubliclyAccessibleMethodIfPossible(Method, Class)\n\t * @see #getMostSpecificMethod\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getInterfaceMethodIfPossible(Method,Class<?>,boolean)",
    "entityType": "method",
    "code": "private static Method getInterfaceMethodIfPossible(Method method, @Nullable Class<?> targetClass, boolean requirePublicInterface) {\r\n    Class<?> declaringClass = method.getDeclaringClass();\r\n    if (!Modifier.isPublic(method.getModifiers()) || (declaringClass.isInterface() && (!requirePublicInterface || Modifier.isPublic(declaringClass.getModifiers())))) {\r\n        return method;\r\n    }\r\n    String methodName = method.getName();\r\n    Class<?>[] parameterTypes = method.getParameterTypes();\r\n    Map<Method, Method> methodCache = (requirePublicInterface ? publicInterfaceMethodCache : interfaceMethodCache);\r\n    // Try cached version of method in its declaring class\r\n    Method result = methodCache.computeIfAbsent(method, key -> findInterfaceMethodIfPossible(methodName, parameterTypes, declaringClass, Object.class, requirePublicInterface));\r\n    if (result == null && targetClass != null) {\r\n        // No interface method found yet -> try given target class (possibly a subclass of the\r\n        // declaring class, late-binding a base class method to a subclass-declared interface:\r\n        // see, for example, HashMap.HashIterator.hasNext)\r\n        result = findInterfaceMethodIfPossible(methodName, parameterTypes, targetClass, declaringClass, requirePublicInterface);\r\n    }\r\n    return (result != null ? result : method);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtils#findInterfaceMethodIfPossible(String,Class<?>[],Class<?>,Class<?>,boolean)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static Method findInterfaceMethodIfPossible(String methodName, Class<?>[] parameterTypes, Class<?> startClass, Class<?> endClass, boolean requirePublicInterface) {\r\n    Class<?> current = startClass;\r\n    while (current != null && current != endClass) {\r\n        for (Class<?> ifc : current.getInterfaces()) {\r\n            try {\r\n                if (!requirePublicInterface || Modifier.isPublic(ifc.getModifiers())) {\r\n                    return ifc.getMethod(methodName, parameterTypes);\r\n                }\r\n            } catch (NoSuchMethodException ex) {\r\n                // ignore\r\n            }\r\n        }\r\n        current = current.getSuperclass();\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getPubliclyAccessibleMethodIfPossible(Method,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Get the first publicly accessible method in the supplied method's type hierarchy that\r\n * has a method signature equivalent to the supplied method, if possible.\r\n * <p>If the supplied method is {@code public} and declared in a {@code public} type,\r\n * the supplied method will be returned.\r\n * <p>Otherwise, this method recursively searches the class hierarchy and implemented\r\n * interfaces for an equivalent method that is {@code public} and declared in a\r\n * {@code public} type.\r\n * <p>If a publicly accessible equivalent method cannot be found, the supplied method\r\n * will be returned, indicating that no such equivalent method exists. Consequently,\r\n * callers of this method must manually validate the accessibility of the returned method\r\n * if public access is a requirement.\r\n * <p>This is particularly useful for arriving at a public exported type on the Java\r\n * Module System which allows the method to be invoked via reflection without an illegal\r\n * access warning. This is also useful for invoking methods via a public API in bytecode\r\n * &mdash; for example, for use with the Spring Expression Language (SpEL) compiler.\r\n * For example, if a non-public class overrides {@code toString()}, this method will\r\n * traverse up the type hierarchy to find the first public type that declares the method\r\n * (if there is one). For {@code toString()}, it may traverse as far as {@link Object}.\r\n * @param method the method to be invoked, potentially from an implementation class\r\n * @param targetClass the target class to invoke the method on, or {@code null} if unknown\r\n * @return the corresponding publicly accessible method, or the original method if none found\r\n * @since 6.2\r\n * @see #getInterfaceMethodIfPossible(Method, Class)\r\n * @see #getMostSpecificMethod(Method, Class)\r\n */\r\npublic static Method getPubliclyAccessibleMethodIfPossible(Method method, @Nullable Class<?> targetClass) {\r\n    Class<?> declaringClass = method.getDeclaringClass();\r\n    // If the method is not public, we can abort the search immediately; or if the method's\r\n    // declaring class is public, the method is already publicly accessible.\r\n    if (!Modifier.isPublic(method.getModifiers()) || Modifier.isPublic(declaringClass.getModifiers())) {\r\n        return method;\r\n    }\r\n    Method interfaceMethod = getInterfaceMethodIfPossible(method, targetClass, true);\r\n    // If we found a method in a public interface, return the interface method.\r\n    if (!interfaceMethod.equals(method)) {\r\n        return interfaceMethod;\r\n    }\r\n    Method result = publiclyAccessibleMethodCache.computeIfAbsent(method, key -> findPubliclyAccessibleMethodIfPossible(key.getName(), key.getParameterTypes(), declaringClass));\r\n    return (result != null ? result : method);\r\n}",
    "comment": "\n\t * Get the first publicly accessible method in the supplied method's type hierarchy that\n\t * has a method signature equivalent to the supplied method, if possible.\n\t * <p>If the supplied method is {@code public} and declared in a {@code public} type,\n\t * the supplied method will be returned.\n\t * <p>Otherwise, this method recursively searches the class hierarchy and implemented\n\t * interfaces for an equivalent method that is {@code public} and declared in a\n\t * {@code public} type.\n\t * <p>If a publicly accessible equivalent method cannot be found, the supplied method\n\t * will be returned, indicating that no such equivalent method exists. Consequently,\n\t * callers of this method must manually validate the accessibility of the returned method\n\t * if public access is a requirement.\n\t * <p>This is particularly useful for arriving at a public exported type on the Java\n\t * Module System which allows the method to be invoked via reflection without an illegal\n\t * access warning. This is also useful for invoking methods via a public API in bytecode\n\t * &mdash; for example, for use with the Spring Expression Language (SpEL) compiler.\n\t * For example, if a non-public class overrides {@code toString()}, this method will\n\t * traverse up the type hierarchy to find the first public type that declares the method\n\t * (if there is one). For {@code toString()}, it may traverse as far as {@link Object}.\n\t * @param method the method to be invoked, potentially from an implementation class\n\t * @param targetClass the target class to invoke the method on, or {@code null} if unknown\n\t * @return the corresponding publicly accessible method, or the original method if none found\n\t * @since 6.2\n\t * @see #getInterfaceMethodIfPossible(Method, Class)\n\t * @see #getMostSpecificMethod(Method, Class)\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#findPubliclyAccessibleMethodIfPossible(String,Class<?>[],Class<?>)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static Method findPubliclyAccessibleMethodIfPossible(String methodName, Class<?>[] parameterTypes, Class<?> declaringClass) {\r\n    Class<?> current = declaringClass.getSuperclass();\r\n    while (current != null) {\r\n        if (Modifier.isPublic(current.getModifiers())) {\r\n            try {\r\n                return current.getDeclaredMethod(methodName, parameterTypes);\r\n            } catch (NoSuchMethodException ex) {\r\n                // ignore\r\n            }\r\n        }\r\n        current = current.getSuperclass();\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtils#isUserLevelMethod(Method)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given method is declared by the user or at least pointing to\r\n * a user-declared method.\r\n * <p>Checks {@link Method#isSynthetic()} (for implementation methods) as well as the\r\n * {@code GroovyObject} interface (for interface methods; on an implementation class,\r\n * implementations of the {@code GroovyObject} methods will be marked as synthetic anyway).\r\n * Note that, despite being synthetic, bridge methods ({@link Method#isBridge()}) are considered\r\n * as user-level methods since they are eventually pointing to a user-declared generic method.\r\n * @param method the method to check\r\n * @return {@code true} if the method can be considered as user-declared; {@code false} otherwise\r\n */\r\npublic static boolean isUserLevelMethod(Method method) {\r\n    Assert.notNull(method, \"Method must not be null\");\r\n    return (method.isBridge() || (!method.isSynthetic() && !isGroovyObjectMethod(method)));\r\n}",
    "comment": "\n\t * Determine whether the given method is declared by the user or at least pointing to\n\t * a user-declared method.\n\t * <p>Checks {@link Method#isSynthetic()} (for implementation methods) as well as the\n\t * {@code GroovyObject} interface (for interface methods; on an implementation class,\n\t * implementations of the {@code GroovyObject} methods will be marked as synthetic anyway).\n\t * Note that, despite being synthetic, bridge methods ({@link Method#isBridge()}) are considered\n\t * as user-level methods since they are eventually pointing to a user-declared generic method.\n\t * @param method the method to check\n\t * @return {@code true} if the method can be considered as user-declared; {@code false} otherwise\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#isGroovyObjectMethod(Method)",
    "entityType": "method",
    "code": "private static boolean isGroovyObjectMethod(Method method) {\r\n    return method.getDeclaringClass().getName().equals(\"groovy.lang.GroovyObject\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtils#isOverridable(Method,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given method is overridable in the given target class.\r\n * @param method the method to check\r\n * @param targetClass the target class to check against\r\n */\r\nprivate static boolean isOverridable(Method method, @Nullable Class<?> targetClass) {\r\n    if ((method.getModifiers() & NON_OVERRIDABLE_MODIFIER) != 0) {\r\n        return false;\r\n    }\r\n    if ((method.getModifiers() & OVERRIDABLE_MODIFIER) != 0) {\r\n        return true;\r\n    }\r\n    return (targetClass == null || getPackageName(method.getDeclaringClass()).equals(getPackageName(targetClass)));\r\n}",
    "comment": "\n\t * Determine whether the given method is overridable in the given target class.\n\t * @param method the method to check\n\t * @param targetClass the target class to check against\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getStaticMethod(Class<?>,String,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return a public static method of a class.\r\n * @param clazz the class which defines the method\r\n * @param methodName the static method name\r\n * @param args the parameter types to the method\r\n * @return the static method, or {@code null} if no static method was found\r\n * @throws IllegalArgumentException if the method name is blank or the clazz is null\r\n */\r\n@Nullable\r\npublic static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    Assert.notNull(methodName, \"Method name must not be null\");\r\n    try {\r\n        Method method = clazz.getMethod(methodName, args);\r\n        return (Modifier.isStatic(method.getModifiers()) ? method : null);\r\n    } catch (NoSuchMethodException ex) {\r\n        return null;\r\n    }\r\n}",
    "comment": "\n\t * Return a public static method of a class.\n\t * @param clazz the class which defines the method\n\t * @param methodName the static method name\n\t * @param args the parameter types to the method\n\t * @return the static method, or {@code null} if no static method was found\n\t * @throws IllegalArgumentException if the method name is blank or the clazz is null\n\t "
  },
  {
    "entityId": "org.springframework.util.ClassUtils#getMethodOrNull(Class<?>,String,Class<?>[])",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static Method getMethodOrNull(Class<?> clazz, String methodName, @Nullable Class<?> @Nullable [] paramTypes) {\r\n    try {\r\n        return clazz.getMethod(methodName, paramTypes);\r\n    } catch (NoSuchMethodException ex) {\r\n        return null;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ClassUtils#findMethodCandidatesByName(Class<?>,String)",
    "entityType": "method",
    "code": "private static Set<Method> findMethodCandidatesByName(Class<?> clazz, String methodName) {\r\n    Set<Method> candidates = new HashSet<>(1);\r\n    Method[] methods = clazz.getMethods();\r\n    for (Method method : methods) {\r\n        if (methodName.equals(method.getName())) {\r\n            candidates.add(method);\r\n        }\r\n    }\r\n    return candidates;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CollectionUtils",
    "entityType": "class",
    "code": "/**\r\n * Default load factor for {@link HashMap}/{@link LinkedHashMap} variants.\r\n * @see #newHashMap(int)\r\n * @see #newLinkedHashMap(int)\r\n */\r\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n/**\r\n * Return {@code true} if the supplied Collection is {@code null} or empty.\r\n * Otherwise, return {@code false}.\r\n * @param collection the Collection to check\r\n * @return whether the given Collection is empty\r\n */\r\n@Contract(\"null -> true\")\r\npublic static boolean isEmpty(@Nullable Collection<? extends @Nullable Object> collection) {\r\n    return (collection == null || collection.isEmpty());\r\n}\n/**\r\n * Return {@code true} if the supplied Map is {@code null} or empty.\r\n * Otherwise, return {@code false}.\r\n * @param map the Map to check\r\n * @return whether the given Map is empty\r\n */\r\n@Contract(\"null -> true\")\r\npublic static boolean isEmpty(@Nullable Map<?, ? extends @Nullable Object> map) {\r\n    return (map == null || map.isEmpty());\r\n}\n/**\r\n * Instantiate a new {@link HashMap} with an initial capacity\r\n * that can accommodate the specified number of elements without\r\n * any immediate resize/rehash operations to be expected.\r\n * <p>This differs from the regular {@link HashMap} constructor\r\n * which takes an initial capacity relative to a load factor\r\n * but is effectively aligned with the JDK's\r\n * {@link java.util.concurrent.ConcurrentHashMap#ConcurrentHashMap(int)}.\r\n * @param expectedSize the expected number of elements (with a corresponding\r\n * capacity to be derived so that no resize/rehash operations are needed)\r\n * @since 5.3\r\n * @see #newLinkedHashMap(int)\r\n */\r\npublic static <K, V> HashMap<K, V> newHashMap(int expectedSize) {\r\n    return new HashMap<>(computeInitialCapacity(expectedSize), DEFAULT_LOAD_FACTOR);\r\n}\n/**\r\n * Instantiate a new {@link LinkedHashMap} with an initial capacity\r\n * that can accommodate the specified number of elements without\r\n * any immediate resize/rehash operations to be expected.\r\n * <p>This differs from the regular {@link LinkedHashMap} constructor\r\n * which takes an initial capacity relative to a load factor but is\r\n * aligned with Spring's own {@link LinkedCaseInsensitiveMap} and\r\n * {@link LinkedMultiValueMap} constructor semantics as of 5.3.\r\n * @param expectedSize the expected number of elements (with a corresponding\r\n * capacity to be derived so that no resize/rehash operations are needed)\r\n * @since 5.3\r\n * @see #newHashMap(int)\r\n */\r\npublic static <K, V> LinkedHashMap<K, V> newLinkedHashMap(int expectedSize) {\r\n    return new LinkedHashMap<>(computeInitialCapacity(expectedSize), DEFAULT_LOAD_FACTOR);\r\n}\n/**\r\n * Instantiate a new {@link HashSet} with an initial capacity that can\r\n * accommodate the specified number of elements without any immediate\r\n * resize/rehash operations to be expected.\r\n * @param expectedSize the expected number of elements (with a corresponding\r\n * capacity to be derived so that no resize/rehash operations are needed)\r\n * @since 6.2\r\n * @see #newLinkedHashSet(int)\r\n */\r\npublic static <E> HashSet<E> newHashSet(int expectedSize) {\r\n    return new HashSet<>(computeInitialCapacity(expectedSize), DEFAULT_LOAD_FACTOR);\r\n}\n/**\r\n * Instantiate a new {@link LinkedHashSet} with an initial capacity that can\r\n * accommodate the specified number of elements without any immediate\r\n * resize/rehash operations to be expected.\r\n * @param expectedSize the expected number of elements (with a corresponding\r\n * capacity to be derived so that no resize/rehash operations are needed)\r\n * @since 6.2\r\n * @see #newHashSet(int)\r\n */\r\npublic static <E> LinkedHashSet<E> newLinkedHashSet(int expectedSize) {\r\n    return new LinkedHashSet<>(computeInitialCapacity(expectedSize), DEFAULT_LOAD_FACTOR);\r\n}\nprivate static int computeInitialCapacity(int expectedSize) {\r\n    return (int) Math.ceil(expectedSize / (double) DEFAULT_LOAD_FACTOR);\r\n}\n/**\r\n * Convert the supplied array into a List. A primitive array gets converted\r\n * into a List of the appropriate wrapper type.\r\n * <p><b>NOTE:</b> Generally prefer the standard {@link Arrays#asList} method.\r\n * This {@code arrayToList} method is just meant to deal with an incoming Object\r\n * value that might be an {@code Object[]} or a primitive array at runtime.\r\n * <p>A {@code null} source value will be converted to an empty List.\r\n * @param source the (potentially primitive) array\r\n * @return the converted List result\r\n * @see ObjectUtils#toObjectArray(Object)\r\n * @see Arrays#asList(Object[])\r\n */\r\npublic static List<?> arrayToList(@Nullable Object source) {\r\n    return Arrays.asList(ObjectUtils.toObjectArray(source));\r\n}\n/**\r\n * Merge the given array into the given Collection.\r\n * @param array the array to merge (may be {@code null})\r\n * @param collection the target Collection to merge the array into\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic static <E> void mergeArrayIntoCollection(@Nullable Object array, Collection<E> collection) {\r\n    Object[] arr = ObjectUtils.toObjectArray(array);\r\n    Collections.addAll(collection, (E[]) arr);\r\n}\n/**\r\n * Merge the given Properties instance into the given Map,\r\n * copying all properties (key-value pairs) over.\r\n * <p>Uses {@code Properties.propertyNames()} to even catch\r\n * default properties linked into the original Properties instance.\r\n * @param props the Properties instance to merge (may be {@code null})\r\n * @param map the target Map to merge the properties into\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic static <K, V> void mergePropertiesIntoMap(@Nullable Properties props, Map<K, V> map) {\r\n    if (props != null) {\r\n        for (Enumeration<?> en = props.propertyNames(); en.hasMoreElements(); ) {\r\n            String key = (String) en.nextElement();\r\n            Object value = props.get(key);\r\n            if (value == null) {\r\n                // Allow for defaults fallback or potentially overridden accessor...\r\n                value = props.getProperty(key);\r\n            }\r\n            map.put((K) key, (V) value);\r\n        }\r\n    }\r\n}\n/**\r\n * Check whether the given Iterator contains the given element.\r\n * @param iterator the Iterator to check\r\n * @param element the element to look for\r\n * @return {@code true} if found, {@code false} otherwise\r\n */\r\npublic static boolean contains(@Nullable Iterator<?> iterator, Object element) {\r\n    if (iterator != null) {\r\n        while (iterator.hasNext()) {\r\n            Object candidate = iterator.next();\r\n            if (ObjectUtils.nullSafeEquals(candidate, element)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\n/**\r\n * Check whether the given Enumeration contains the given element.\r\n * @param enumeration the Enumeration to check\r\n * @param element the element to look for\r\n * @return {@code true} if found, {@code false} otherwise\r\n */\r\npublic static boolean contains(@Nullable Enumeration<?> enumeration, Object element) {\r\n    if (enumeration != null) {\r\n        while (enumeration.hasMoreElements()) {\r\n            Object candidate = enumeration.nextElement();\r\n            if (ObjectUtils.nullSafeEquals(candidate, element)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\n/**\r\n * Check whether the given Collection contains the given element instance.\r\n * <p>Enforces the given instance to be present, rather than returning\r\n * {@code true} for an equal element as well.\r\n * @param collection the Collection to check\r\n * @param element the element to look for\r\n * @return {@code true} if found, {@code false} otherwise\r\n */\r\npublic static boolean containsInstance(@Nullable Collection<?> collection, Object element) {\r\n    if (collection != null) {\r\n        for (Object candidate : collection) {\r\n            if (candidate == element) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\n/**\r\n * Return {@code true} if any element in '{@code candidates}' is\r\n * contained in '{@code source}'; otherwise returns {@code false}.\r\n * @param source the source Collection\r\n * @param candidates the candidates to search for\r\n * @return whether any of the candidates has been found\r\n */\r\npublic static boolean containsAny(Collection<?> source, Collection<?> candidates) {\r\n    return findFirstMatch(source, candidates) != null;\r\n}\n/**\r\n * Return the first element in '{@code candidates}' that is contained in\r\n * '{@code source}'. If no element in '{@code candidates}' is present in\r\n * '{@code source}' returns {@code null}. Iteration order is\r\n * {@link Collection} implementation specific.\r\n * @param source the source Collection\r\n * @param candidates the candidates to search for\r\n * @return the first present object, or {@code null} if not found\r\n */\r\n@Nullable\r\npublic static <E> E findFirstMatch(Collection<?> source, Collection<E> candidates) {\r\n    if (isEmpty(source) || isEmpty(candidates)) {\r\n        return null;\r\n    }\r\n    for (E candidate : candidates) {\r\n        if (source.contains(candidate)) {\r\n            return candidate;\r\n        }\r\n    }\r\n    return null;\r\n}\n/**\r\n * Find a single value of the given type in the given Collection.\r\n * @param collection the Collection to search\r\n * @param type the type to look for\r\n * @return a value of the given type found if there is a clear match,\r\n * or {@code null} if none or more than one such value found\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\npublic static <T> T findValueOfType(@Nullable Collection<?> collection, @Nullable Class<T> type) {\r\n    if (isEmpty(collection)) {\r\n        return null;\r\n    }\r\n    T value = null;\r\n    for (Object element : collection) {\r\n        if (type == null || type.isInstance(element)) {\r\n            if (value != null) {\r\n                // More than one value found... no clear single value.\r\n                return null;\r\n            }\r\n            value = (T) element;\r\n        }\r\n    }\r\n    return value;\r\n}\n/**\r\n * Find a single value of one of the given types in the given Collection:\r\n * searching the Collection for a value of the first type, then\r\n * searching for a value of the second type, etc.\r\n * @param collection the collection to search\r\n * @param types the types to look for, in prioritized order\r\n * @return a value of one of the given types found if there is a clear match,\r\n * or {@code null} if none or more than one such value found\r\n */\r\n@Nullable\r\npublic static Object findValueOfType(Collection<?> collection, Class<?>[] types) {\r\n    if (isEmpty(collection) || ObjectUtils.isEmpty(types)) {\r\n        return null;\r\n    }\r\n    for (Class<?> type : types) {\r\n        Object value = findValueOfType(collection, type);\r\n        if (value != null) {\r\n            return value;\r\n        }\r\n    }\r\n    return null;\r\n}\n/**\r\n * Determine whether the given Collection only contains a single unique object.\r\n * @param collection the Collection to check\r\n * @return {@code true} if the collection contains a single reference or\r\n * multiple references to the same instance, {@code false} otherwise\r\n */\r\npublic static boolean hasUniqueObject(Collection<?> collection) {\r\n    if (isEmpty(collection)) {\r\n        return false;\r\n    }\r\n    boolean hasCandidate = false;\r\n    Object candidate = null;\r\n    for (Object elem : collection) {\r\n        if (!hasCandidate) {\r\n            hasCandidate = true;\r\n            candidate = elem;\r\n        } else if (candidate != elem) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\n/**\r\n * Find the common element type of the given Collection, if any.\r\n * @param collection the Collection to check\r\n * @return the common element type, or {@code null} if no clear\r\n * common type has been found (or the collection was empty)\r\n */\r\n@Nullable\r\npublic static Class<?> findCommonElementType(Collection<?> collection) {\r\n    if (isEmpty(collection)) {\r\n        return null;\r\n    }\r\n    Class<?> candidate = null;\r\n    for (Object val : collection) {\r\n        if (val != null) {\r\n            if (candidate == null) {\r\n                candidate = val.getClass();\r\n            } else if (candidate != val.getClass()) {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    return candidate;\r\n}\n/**\r\n * Retrieve the first element of the given Set, using {@link SortedSet#first()}\r\n * or otherwise using the iterator.\r\n * @param set the Set to check (may be {@code null} or empty)\r\n * @return the first element, or {@code null} if none\r\n * @since 5.2.3\r\n * @see SortedSet\r\n * @see LinkedHashMap#keySet()\r\n * @see java.util.LinkedHashSet\r\n */\r\n@Nullable\r\npublic static <T> T firstElement(@Nullable Set<T> set) {\r\n    if (isEmpty(set)) {\r\n        return null;\r\n    }\r\n    if (set instanceof SortedSet<T> sortedSet) {\r\n        return sortedSet.first();\r\n    }\r\n    Iterator<T> it = set.iterator();\r\n    T first = null;\r\n    if (it.hasNext()) {\r\n        first = it.next();\r\n    }\r\n    return first;\r\n}\n/**\r\n * Retrieve the first element of the given List, accessing the zero index.\r\n * @param list the List to check (may be {@code null} or empty)\r\n * @return the first element, or {@code null} if none\r\n * @since 5.2.3\r\n */\r\n@Nullable\r\npublic static <T> T firstElement(@Nullable List<T> list) {\r\n    if (isEmpty(list)) {\r\n        return null;\r\n    }\r\n    return list.get(0);\r\n}\n/**\r\n * Retrieve the last element of the given Set, using {@link SortedSet#last()}\r\n * or otherwise iterating over all elements (assuming a linked set).\r\n * @param set the Set to check (may be {@code null} or empty)\r\n * @return the last element, or {@code null} if none\r\n * @since 5.0.3\r\n * @see SortedSet\r\n * @see LinkedHashMap#keySet()\r\n * @see java.util.LinkedHashSet\r\n */\r\n@Nullable\r\npublic static <T> T lastElement(@Nullable Set<T> set) {\r\n    if (isEmpty(set)) {\r\n        return null;\r\n    }\r\n    if (set instanceof SortedSet<T> sortedSet) {\r\n        return sortedSet.last();\r\n    }\r\n    // Full iteration necessary...\r\n    Iterator<T> it = set.iterator();\r\n    T last = null;\r\n    while (it.hasNext()) {\r\n        last = it.next();\r\n    }\r\n    return last;\r\n}\n/**\r\n * Retrieve the last element of the given List, accessing the highest index.\r\n * @param list the List to check (may be {@code null} or empty)\r\n * @return the last element, or {@code null} if none\r\n * @since 5.0.3\r\n */\r\n@Nullable\r\npublic static <T> T lastElement(@Nullable List<T> list) {\r\n    if (isEmpty(list)) {\r\n        return null;\r\n    }\r\n    return list.get(list.size() - 1);\r\n}\n/**\r\n * Marshal the elements from the given enumeration into an array of the given type.\r\n * Enumeration elements must be assignable to the type of the given array. The array\r\n * returned will be a different instance than the array given.\r\n */\r\npublic static <A, E extends A> A[] toArray(Enumeration<E> enumeration, A[] array) {\r\n    ArrayList<A> elements = new ArrayList<>();\r\n    while (enumeration.hasMoreElements()) {\r\n        elements.add(enumeration.nextElement());\r\n    }\r\n    return elements.toArray(array);\r\n}\n/**\r\n * Adapt an {@link Enumeration} to an {@link Iterator}.\r\n * @param enumeration the original {@code Enumeration}\r\n * @return the adapted {@code Iterator}\r\n */\r\npublic static <E> Iterator<E> toIterator(@Nullable Enumeration<E> enumeration) {\r\n    return (enumeration != null ? enumeration.asIterator() : Collections.emptyIterator());\r\n}\n/**\r\n * Adapt a {@code Map<K, List<V>>} to an {@code MultiValueMap<K, V>}.\r\n * @param targetMap the original map\r\n * @return the adapted multi-value map (wrapping the original map)\r\n * @since 3.1\r\n */\r\npublic static <K, V> MultiValueMap<K, V> toMultiValueMap(Map<K, List<V>> targetMap) {\r\n    return new MultiValueMapAdapter<>(targetMap);\r\n}\n/**\r\n * Return an unmodifiable view of the specified multi-value map.\r\n * @param targetMap the map for which an unmodifiable view is to be returned.\r\n * @return an unmodifiable view of the specified multi-value map\r\n * @since 3.1\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic static <K, V> MultiValueMap<K, V> unmodifiableMultiValueMap(MultiValueMap<? extends K, ? extends V> targetMap) {\r\n    Assert.notNull(targetMap, \"'targetMap' must not be null\");\r\n    if (targetMap instanceof UnmodifiableMultiValueMap) {\r\n        return (MultiValueMap<K, V>) targetMap;\r\n    }\r\n    return new UnmodifiableMultiValueMap<>(targetMap);\r\n}\n/**\r\n * Return a (partially unmodifiable) map that combines the provided two\r\n * maps. Invoking {@link Map#put(Object, Object)} or {@link Map#putAll(Map)}\r\n * on the returned map results in an {@link UnsupportedOperationException}.\r\n * <p>In the case of a key collision, {@code first} takes precedence over\r\n * {@code second}. In other words, entries in {@code second} with a key\r\n * that is also mapped by {@code first} are effectively ignored.\r\n * @param first the first map to compose\r\n * @param second the second map to compose\r\n * @return a new map that composes the given two maps\r\n * @since 6.2\r\n */\r\npublic static <K, V> Map<K, V> compositeMap(Map<K, V> first, Map<K, V> second) {\r\n    return new CompositeMap<>(first, second);\r\n}\n/**\r\n * Return a map that combines the provided maps. Invoking\r\n * {@link Map#put(Object, Object)} on the returned map will apply\r\n * {@code putFunction}, or will throw an\r\n * {@link UnsupportedOperationException} {@code putFunction} is\r\n * {@code null}. The same applies to {@link Map#putAll(Map)} and\r\n * {@code putAllFunction}.\r\n * <p>In the case of a key collision, {@code first} takes precedence over\r\n * {@code second}. In other words, entries in {@code second} with a key\r\n * that is also mapped by {@code first} are effectively ignored.\r\n * @param first the first map to compose\r\n * @param second the second map to compose\r\n * @param putFunction applied when {@code Map::put} is invoked. If\r\n * {@code null}, {@code Map::put} throws an\r\n * {@code UnsupportedOperationException}.\r\n * @param putAllFunction applied when {@code Map::putAll} is invoked. If\r\n * {@code null}, {@code Map::putAll} throws an\r\n * {@code UnsupportedOperationException}.\r\n * @return a new map that composes the give maps\r\n * @since 6.2\r\n */\r\npublic static <K, V> Map<K, V> compositeMap(Map<K, V> first, Map<K, V> second, @Nullable BiFunction<K, V, V> putFunction, @Nullable Consumer<Map<K, V>> putAllFunction) {\r\n    return new CompositeMap<>(first, second, putFunction, putAllFunction);\r\n}",
    "comment": "\n * Miscellaneous collection utility methods.\n * Mainly for internal use within the framework.\n *\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Arjen Poutsma\n * @since 1.1.3\n "
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#isEmpty(Collection<? extends Object>)",
    "entityType": "method",
    "code": "/**\r\n * Return {@code true} if the supplied Collection is {@code null} or empty.\r\n * Otherwise, return {@code false}.\r\n * @param collection the Collection to check\r\n * @return whether the given Collection is empty\r\n */\r\n@Contract(\"null -> true\")\r\npublic static boolean isEmpty(@Nullable Collection<? extends @Nullable Object> collection) {\r\n    return (collection == null || collection.isEmpty());\r\n}",
    "comment": "\n\t * Return {@code true} if the supplied Collection is {@code null} or empty.\n\t * Otherwise, return {@code false}.\n\t * @param collection the Collection to check\n\t * @return whether the given Collection is empty\n\t "
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#isEmpty(Map<?,? extends Object>)",
    "entityType": "method",
    "code": "/**\r\n * Return {@code true} if the supplied Map is {@code null} or empty.\r\n * Otherwise, return {@code false}.\r\n * @param map the Map to check\r\n * @return whether the given Map is empty\r\n */\r\n@Contract(\"null -> true\")\r\npublic static boolean isEmpty(@Nullable Map<?, ? extends @Nullable Object> map) {\r\n    return (map == null || map.isEmpty());\r\n}",
    "comment": "\n\t * Return {@code true} if the supplied Map is {@code null} or empty.\n\t * Otherwise, return {@code false}.\n\t * @param map the Map to check\n\t * @return whether the given Map is empty\n\t "
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#newHashMap(int)",
    "entityType": "method",
    "code": "/**\r\n * Instantiate a new {@link HashMap} with an initial capacity\r\n * that can accommodate the specified number of elements without\r\n * any immediate resize/rehash operations to be expected.\r\n * <p>This differs from the regular {@link HashMap} constructor\r\n * which takes an initial capacity relative to a load factor\r\n * but is effectively aligned with the JDK's\r\n * {@link java.util.concurrent.ConcurrentHashMap#ConcurrentHashMap(int)}.\r\n * @param expectedSize the expected number of elements (with a corresponding\r\n * capacity to be derived so that no resize/rehash operations are needed)\r\n * @since 5.3\r\n * @see #newLinkedHashMap(int)\r\n */\r\npublic static <K, V> HashMap<K, V> newHashMap(int expectedSize) {\r\n    return new HashMap<>(computeInitialCapacity(expectedSize), DEFAULT_LOAD_FACTOR);\r\n}",
    "comment": "\n\t * Instantiate a new {@link HashMap} with an initial capacity\n\t * that can accommodate the specified number of elements without\n\t * any immediate resize/rehash operations to be expected.\n\t * <p>This differs from the regular {@link HashMap} constructor\n\t * which takes an initial capacity relative to a load factor\n\t * but is effectively aligned with the JDK's\n\t * {@link java.util.concurrent.ConcurrentHashMap#ConcurrentHashMap(int)}.\n\t * @param expectedSize the expected number of elements (with a corresponding\n\t * capacity to be derived so that no resize/rehash operations are needed)\n\t * @since 5.3\n\t * @see #newLinkedHashMap(int)\n\t "
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#newLinkedHashMap(int)",
    "entityType": "method",
    "code": "/**\r\n * Instantiate a new {@link LinkedHashMap} with an initial capacity\r\n * that can accommodate the specified number of elements without\r\n * any immediate resize/rehash operations to be expected.\r\n * <p>This differs from the regular {@link LinkedHashMap} constructor\r\n * which takes an initial capacity relative to a load factor but is\r\n * aligned with Spring's own {@link LinkedCaseInsensitiveMap} and\r\n * {@link LinkedMultiValueMap} constructor semantics as of 5.3.\r\n * @param expectedSize the expected number of elements (with a corresponding\r\n * capacity to be derived so that no resize/rehash operations are needed)\r\n * @since 5.3\r\n * @see #newHashMap(int)\r\n */\r\npublic static <K, V> LinkedHashMap<K, V> newLinkedHashMap(int expectedSize) {\r\n    return new LinkedHashMap<>(computeInitialCapacity(expectedSize), DEFAULT_LOAD_FACTOR);\r\n}",
    "comment": "\n\t * Instantiate a new {@link LinkedHashMap} with an initial capacity\n\t * that can accommodate the specified number of elements without\n\t * any immediate resize/rehash operations to be expected.\n\t * <p>This differs from the regular {@link LinkedHashMap} constructor\n\t * which takes an initial capacity relative to a load factor but is\n\t * aligned with Spring's own {@link LinkedCaseInsensitiveMap} and\n\t * {@link LinkedMultiValueMap} constructor semantics as of 5.3.\n\t * @param expectedSize the expected number of elements (with a corresponding\n\t * capacity to be derived so that no resize/rehash operations are needed)\n\t * @since 5.3\n\t * @see #newHashMap(int)\n\t "
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#newHashSet(int)",
    "entityType": "method",
    "code": "/**\r\n * Instantiate a new {@link HashSet} with an initial capacity that can\r\n * accommodate the specified number of elements without any immediate\r\n * resize/rehash operations to be expected.\r\n * @param expectedSize the expected number of elements (with a corresponding\r\n * capacity to be derived so that no resize/rehash operations are needed)\r\n * @since 6.2\r\n * @see #newLinkedHashSet(int)\r\n */\r\npublic static <E> HashSet<E> newHashSet(int expectedSize) {\r\n    return new HashSet<>(computeInitialCapacity(expectedSize), DEFAULT_LOAD_FACTOR);\r\n}",
    "comment": "\n\t * Instantiate a new {@link HashSet} with an initial capacity that can\n\t * accommodate the specified number of elements without any immediate\n\t * resize/rehash operations to be expected.\n\t * @param expectedSize the expected number of elements (with a corresponding\n\t * capacity to be derived so that no resize/rehash operations are needed)\n\t * @since 6.2\n\t * @see #newLinkedHashSet(int)\n\t "
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#newLinkedHashSet(int)",
    "entityType": "method",
    "code": "/**\r\n * Instantiate a new {@link LinkedHashSet} with an initial capacity that can\r\n * accommodate the specified number of elements without any immediate\r\n * resize/rehash operations to be expected.\r\n * @param expectedSize the expected number of elements (with a corresponding\r\n * capacity to be derived so that no resize/rehash operations are needed)\r\n * @since 6.2\r\n * @see #newHashSet(int)\r\n */\r\npublic static <E> LinkedHashSet<E> newLinkedHashSet(int expectedSize) {\r\n    return new LinkedHashSet<>(computeInitialCapacity(expectedSize), DEFAULT_LOAD_FACTOR);\r\n}",
    "comment": "\n\t * Instantiate a new {@link LinkedHashSet} with an initial capacity that can\n\t * accommodate the specified number of elements without any immediate\n\t * resize/rehash operations to be expected.\n\t * @param expectedSize the expected number of elements (with a corresponding\n\t * capacity to be derived so that no resize/rehash operations are needed)\n\t * @since 6.2\n\t * @see #newHashSet(int)\n\t "
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#computeInitialCapacity(int)",
    "entityType": "method",
    "code": "private static int computeInitialCapacity(int expectedSize) {\r\n    return (int) Math.ceil(expectedSize / (double) DEFAULT_LOAD_FACTOR);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#arrayToList(Object)",
    "entityType": "method",
    "code": "/**\r\n * Convert the supplied array into a List. A primitive array gets converted\r\n * into a List of the appropriate wrapper type.\r\n * <p><b>NOTE:</b> Generally prefer the standard {@link Arrays#asList} method.\r\n * This {@code arrayToList} method is just meant to deal with an incoming Object\r\n * value that might be an {@code Object[]} or a primitive array at runtime.\r\n * <p>A {@code null} source value will be converted to an empty List.\r\n * @param source the (potentially primitive) array\r\n * @return the converted List result\r\n * @see ObjectUtils#toObjectArray(Object)\r\n * @see Arrays#asList(Object[])\r\n */\r\npublic static List<?> arrayToList(@Nullable Object source) {\r\n    return Arrays.asList(ObjectUtils.toObjectArray(source));\r\n}",
    "comment": "\n\t * Convert the supplied array into a List. A primitive array gets converted\n\t * into a List of the appropriate wrapper type.\n\t * <p><b>NOTE:</b> Generally prefer the standard {@link Arrays#asList} method.\n\t * This {@code arrayToList} method is just meant to deal with an incoming Object\n\t * value that might be an {@code Object[]} or a primitive array at runtime.\n\t * <p>A {@code null} source value will be converted to an empty List.\n\t * @param source the (potentially primitive) array\n\t * @return the converted List result\n\t * @see ObjectUtils#toObjectArray(Object)\n\t * @see Arrays#asList(Object[])\n\t "
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#mergeArrayIntoCollection(Object,Collection<E>)",
    "entityType": "method",
    "code": "/**\r\n * Merge the given array into the given Collection.\r\n * @param array the array to merge (may be {@code null})\r\n * @param collection the target Collection to merge the array into\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic static <E> void mergeArrayIntoCollection(@Nullable Object array, Collection<E> collection) {\r\n    Object[] arr = ObjectUtils.toObjectArray(array);\r\n    Collections.addAll(collection, (E[]) arr);\r\n}",
    "comment": "\n\t * Merge the given array into the given Collection.\n\t * @param array the array to merge (may be {@code null})\n\t * @param collection the target Collection to merge the array into\n\t "
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#mergePropertiesIntoMap(Properties,Map<K,V>)",
    "entityType": "method",
    "code": "/**\r\n * Merge the given Properties instance into the given Map,\r\n * copying all properties (key-value pairs) over.\r\n * <p>Uses {@code Properties.propertyNames()} to even catch\r\n * default properties linked into the original Properties instance.\r\n * @param props the Properties instance to merge (may be {@code null})\r\n * @param map the target Map to merge the properties into\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic static <K, V> void mergePropertiesIntoMap(@Nullable Properties props, Map<K, V> map) {\r\n    if (props != null) {\r\n        for (Enumeration<?> en = props.propertyNames(); en.hasMoreElements(); ) {\r\n            String key = (String) en.nextElement();\r\n            Object value = props.get(key);\r\n            if (value == null) {\r\n                // Allow for defaults fallback or potentially overridden accessor...\r\n                value = props.getProperty(key);\r\n            }\r\n            map.put((K) key, (V) value);\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Merge the given Properties instance into the given Map,\n\t * copying all properties (key-value pairs) over.\n\t * <p>Uses {@code Properties.propertyNames()} to even catch\n\t * default properties linked into the original Properties instance.\n\t * @param props the Properties instance to merge (may be {@code null})\n\t * @param map the target Map to merge the properties into\n\t "
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#contains(Iterator<?>,Object)",
    "entityType": "method",
    "code": "/**\r\n * Check whether the given Iterator contains the given element.\r\n * @param iterator the Iterator to check\r\n * @param element the element to look for\r\n * @return {@code true} if found, {@code false} otherwise\r\n */\r\npublic static boolean contains(@Nullable Iterator<?> iterator, Object element) {\r\n    if (iterator != null) {\r\n        while (iterator.hasNext()) {\r\n            Object candidate = iterator.next();\r\n            if (ObjectUtils.nullSafeEquals(candidate, element)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": "\n\t * Check whether the given Iterator contains the given element.\n\t * @param iterator the Iterator to check\n\t * @param element the element to look for\n\t * @return {@code true} if found, {@code false} otherwise\n\t "
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#contains(Enumeration<?>,Object)",
    "entityType": "method",
    "code": "/**\r\n * Check whether the given Enumeration contains the given element.\r\n * @param enumeration the Enumeration to check\r\n * @param element the element to look for\r\n * @return {@code true} if found, {@code false} otherwise\r\n */\r\npublic static boolean contains(@Nullable Enumeration<?> enumeration, Object element) {\r\n    if (enumeration != null) {\r\n        while (enumeration.hasMoreElements()) {\r\n            Object candidate = enumeration.nextElement();\r\n            if (ObjectUtils.nullSafeEquals(candidate, element)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": "\n\t * Check whether the given Enumeration contains the given element.\n\t * @param enumeration the Enumeration to check\n\t * @param element the element to look for\n\t * @return {@code true} if found, {@code false} otherwise\n\t "
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#containsInstance(Collection<?>,Object)",
    "entityType": "method",
    "code": "/**\r\n * Check whether the given Collection contains the given element instance.\r\n * <p>Enforces the given instance to be present, rather than returning\r\n * {@code true} for an equal element as well.\r\n * @param collection the Collection to check\r\n * @param element the element to look for\r\n * @return {@code true} if found, {@code false} otherwise\r\n */\r\npublic static boolean containsInstance(@Nullable Collection<?> collection, Object element) {\r\n    if (collection != null) {\r\n        for (Object candidate : collection) {\r\n            if (candidate == element) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": "\n\t * Check whether the given Collection contains the given element instance.\n\t * <p>Enforces the given instance to be present, rather than returning\n\t * {@code true} for an equal element as well.\n\t * @param collection the Collection to check\n\t * @param element the element to look for\n\t * @return {@code true} if found, {@code false} otherwise\n\t "
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#containsAny(Collection<?>,Collection<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return {@code true} if any element in '{@code candidates}' is\r\n * contained in '{@code source}'; otherwise returns {@code false}.\r\n * @param source the source Collection\r\n * @param candidates the candidates to search for\r\n * @return whether any of the candidates has been found\r\n */\r\npublic static boolean containsAny(Collection<?> source, Collection<?> candidates) {\r\n    return findFirstMatch(source, candidates) != null;\r\n}",
    "comment": "\n\t * Return {@code true} if any element in '{@code candidates}' is\n\t * contained in '{@code source}'; otherwise returns {@code false}.\n\t * @param source the source Collection\n\t * @param candidates the candidates to search for\n\t * @return whether any of the candidates has been found\n\t "
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#findFirstMatch(Collection<?>,Collection<E>)",
    "entityType": "method",
    "code": "/**\r\n * Return the first element in '{@code candidates}' that is contained in\r\n * '{@code source}'. If no element in '{@code candidates}' is present in\r\n * '{@code source}' returns {@code null}. Iteration order is\r\n * {@link Collection} implementation specific.\r\n * @param source the source Collection\r\n * @param candidates the candidates to search for\r\n * @return the first present object, or {@code null} if not found\r\n */\r\n@Nullable\r\npublic static <E> E findFirstMatch(Collection<?> source, Collection<E> candidates) {\r\n    if (isEmpty(source) || isEmpty(candidates)) {\r\n        return null;\r\n    }\r\n    for (E candidate : candidates) {\r\n        if (source.contains(candidate)) {\r\n            return candidate;\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": "\n\t * Return the first element in '{@code candidates}' that is contained in\n\t * '{@code source}'. If no element in '{@code candidates}' is present in\n\t * '{@code source}' returns {@code null}. Iteration order is\n\t * {@link Collection} implementation specific.\n\t * @param source the source Collection\n\t * @param candidates the candidates to search for\n\t * @return the first present object, or {@code null} if not found\n\t "
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#findValueOfType(Collection<?>,Class<T>)",
    "entityType": "method",
    "code": "/**\r\n * Find a single value of the given type in the given Collection.\r\n * @param collection the Collection to search\r\n * @param type the type to look for\r\n * @return a value of the given type found if there is a clear match,\r\n * or {@code null} if none or more than one such value found\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\npublic static <T> T findValueOfType(@Nullable Collection<?> collection, @Nullable Class<T> type) {\r\n    if (isEmpty(collection)) {\r\n        return null;\r\n    }\r\n    T value = null;\r\n    for (Object element : collection) {\r\n        if (type == null || type.isInstance(element)) {\r\n            if (value != null) {\r\n                // More than one value found... no clear single value.\r\n                return null;\r\n            }\r\n            value = (T) element;\r\n        }\r\n    }\r\n    return value;\r\n}",
    "comment": "\n\t * Find a single value of the given type in the given Collection.\n\t * @param collection the Collection to search\n\t * @param type the type to look for\n\t * @return a value of the given type found if there is a clear match,\n\t * or {@code null} if none or more than one such value found\n\t "
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#findValueOfType(Collection<?>,Class<?>[])",
    "entityType": "method",
    "code": "/**\r\n * Find a single value of one of the given types in the given Collection:\r\n * searching the Collection for a value of the first type, then\r\n * searching for a value of the second type, etc.\r\n * @param collection the collection to search\r\n * @param types the types to look for, in prioritized order\r\n * @return a value of one of the given types found if there is a clear match,\r\n * or {@code null} if none or more than one such value found\r\n */\r\n@Nullable\r\npublic static Object findValueOfType(Collection<?> collection, Class<?>[] types) {\r\n    if (isEmpty(collection) || ObjectUtils.isEmpty(types)) {\r\n        return null;\r\n    }\r\n    for (Class<?> type : types) {\r\n        Object value = findValueOfType(collection, type);\r\n        if (value != null) {\r\n            return value;\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": "\n\t * Find a single value of one of the given types in the given Collection:\n\t * searching the Collection for a value of the first type, then\n\t * searching for a value of the second type, etc.\n\t * @param collection the collection to search\n\t * @param types the types to look for, in prioritized order\n\t * @return a value of one of the given types found if there is a clear match,\n\t * or {@code null} if none or more than one such value found\n\t "
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#hasUniqueObject(Collection<?>)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given Collection only contains a single unique object.\r\n * @param collection the Collection to check\r\n * @return {@code true} if the collection contains a single reference or\r\n * multiple references to the same instance, {@code false} otherwise\r\n */\r\npublic static boolean hasUniqueObject(Collection<?> collection) {\r\n    if (isEmpty(collection)) {\r\n        return false;\r\n    }\r\n    boolean hasCandidate = false;\r\n    Object candidate = null;\r\n    for (Object elem : collection) {\r\n        if (!hasCandidate) {\r\n            hasCandidate = true;\r\n            candidate = elem;\r\n        } else if (candidate != elem) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "comment": "\n\t * Determine whether the given Collection only contains a single unique object.\n\t * @param collection the Collection to check\n\t * @return {@code true} if the collection contains a single reference or\n\t * multiple references to the same instance, {@code false} otherwise\n\t "
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#findCommonElementType(Collection<?>)",
    "entityType": "method",
    "code": "/**\r\n * Find the common element type of the given Collection, if any.\r\n * @param collection the Collection to check\r\n * @return the common element type, or {@code null} if no clear\r\n * common type has been found (or the collection was empty)\r\n */\r\n@Nullable\r\npublic static Class<?> findCommonElementType(Collection<?> collection) {\r\n    if (isEmpty(collection)) {\r\n        return null;\r\n    }\r\n    Class<?> candidate = null;\r\n    for (Object val : collection) {\r\n        if (val != null) {\r\n            if (candidate == null) {\r\n                candidate = val.getClass();\r\n            } else if (candidate != val.getClass()) {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    return candidate;\r\n}",
    "comment": "\n\t * Find the common element type of the given Collection, if any.\n\t * @param collection the Collection to check\n\t * @return the common element type, or {@code null} if no clear\n\t * common type has been found (or the collection was empty)\n\t "
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#firstElement(Set<T>)",
    "entityType": "method",
    "code": "/**\r\n * Retrieve the first element of the given Set, using {@link SortedSet#first()}\r\n * or otherwise using the iterator.\r\n * @param set the Set to check (may be {@code null} or empty)\r\n * @return the first element, or {@code null} if none\r\n * @since 5.2.3\r\n * @see SortedSet\r\n * @see LinkedHashMap#keySet()\r\n * @see java.util.LinkedHashSet\r\n */\r\n@Nullable\r\npublic static <T> T firstElement(@Nullable Set<T> set) {\r\n    if (isEmpty(set)) {\r\n        return null;\r\n    }\r\n    if (set instanceof SortedSet<T> sortedSet) {\r\n        return sortedSet.first();\r\n    }\r\n    Iterator<T> it = set.iterator();\r\n    T first = null;\r\n    if (it.hasNext()) {\r\n        first = it.next();\r\n    }\r\n    return first;\r\n}",
    "comment": "\n\t * Retrieve the first element of the given Set, using {@link SortedSet#first()}\n\t * or otherwise using the iterator.\n\t * @param set the Set to check (may be {@code null} or empty)\n\t * @return the first element, or {@code null} if none\n\t * @since 5.2.3\n\t * @see SortedSet\n\t * @see LinkedHashMap#keySet()\n\t * @see java.util.LinkedHashSet\n\t "
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#firstElement(List<T>)",
    "entityType": "method",
    "code": "/**\r\n * Retrieve the first element of the given List, accessing the zero index.\r\n * @param list the List to check (may be {@code null} or empty)\r\n * @return the first element, or {@code null} if none\r\n * @since 5.2.3\r\n */\r\n@Nullable\r\npublic static <T> T firstElement(@Nullable List<T> list) {\r\n    if (isEmpty(list)) {\r\n        return null;\r\n    }\r\n    return list.get(0);\r\n}",
    "comment": "\n\t * Retrieve the first element of the given List, accessing the zero index.\n\t * @param list the List to check (may be {@code null} or empty)\n\t * @return the first element, or {@code null} if none\n\t * @since 5.2.3\n\t "
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#lastElement(Set<T>)",
    "entityType": "method",
    "code": "/**\r\n * Retrieve the last element of the given Set, using {@link SortedSet#last()}\r\n * or otherwise iterating over all elements (assuming a linked set).\r\n * @param set the Set to check (may be {@code null} or empty)\r\n * @return the last element, or {@code null} if none\r\n * @since 5.0.3\r\n * @see SortedSet\r\n * @see LinkedHashMap#keySet()\r\n * @see java.util.LinkedHashSet\r\n */\r\n@Nullable\r\npublic static <T> T lastElement(@Nullable Set<T> set) {\r\n    if (isEmpty(set)) {\r\n        return null;\r\n    }\r\n    if (set instanceof SortedSet<T> sortedSet) {\r\n        return sortedSet.last();\r\n    }\r\n    // Full iteration necessary...\r\n    Iterator<T> it = set.iterator();\r\n    T last = null;\r\n    while (it.hasNext()) {\r\n        last = it.next();\r\n    }\r\n    return last;\r\n}",
    "comment": "\n\t * Retrieve the last element of the given Set, using {@link SortedSet#last()}\n\t * or otherwise iterating over all elements (assuming a linked set).\n\t * @param set the Set to check (may be {@code null} or empty)\n\t * @return the last element, or {@code null} if none\n\t * @since 5.0.3\n\t * @see SortedSet\n\t * @see LinkedHashMap#keySet()\n\t * @see java.util.LinkedHashSet\n\t "
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#lastElement(List<T>)",
    "entityType": "method",
    "code": "/**\r\n * Retrieve the last element of the given List, accessing the highest index.\r\n * @param list the List to check (may be {@code null} or empty)\r\n * @return the last element, or {@code null} if none\r\n * @since 5.0.3\r\n */\r\n@Nullable\r\npublic static <T> T lastElement(@Nullable List<T> list) {\r\n    if (isEmpty(list)) {\r\n        return null;\r\n    }\r\n    return list.get(list.size() - 1);\r\n}",
    "comment": "\n\t * Retrieve the last element of the given List, accessing the highest index.\n\t * @param list the List to check (may be {@code null} or empty)\n\t * @return the last element, or {@code null} if none\n\t * @since 5.0.3\n\t "
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#toArray(Enumeration<E>,A[])",
    "entityType": "method",
    "code": "/**\r\n * Marshal the elements from the given enumeration into an array of the given type.\r\n * Enumeration elements must be assignable to the type of the given array. The array\r\n * returned will be a different instance than the array given.\r\n */\r\npublic static <A, E extends A> A[] toArray(Enumeration<E> enumeration, A[] array) {\r\n    ArrayList<A> elements = new ArrayList<>();\r\n    while (enumeration.hasMoreElements()) {\r\n        elements.add(enumeration.nextElement());\r\n    }\r\n    return elements.toArray(array);\r\n}",
    "comment": "\n\t * Marshal the elements from the given enumeration into an array of the given type.\n\t * Enumeration elements must be assignable to the type of the given array. The array\n\t * returned will be a different instance than the array given.\n\t "
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#toIterator(Enumeration<E>)",
    "entityType": "method",
    "code": "/**\r\n * Adapt an {@link Enumeration} to an {@link Iterator}.\r\n * @param enumeration the original {@code Enumeration}\r\n * @return the adapted {@code Iterator}\r\n */\r\npublic static <E> Iterator<E> toIterator(@Nullable Enumeration<E> enumeration) {\r\n    return (enumeration != null ? enumeration.asIterator() : Collections.emptyIterator());\r\n}",
    "comment": "\n\t * Adapt an {@link Enumeration} to an {@link Iterator}.\n\t * @param enumeration the original {@code Enumeration}\n\t * @return the adapted {@code Iterator}\n\t "
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#toMultiValueMap(Map<K,List<V>>)",
    "entityType": "method",
    "code": "/**\r\n * Adapt a {@code Map<K, List<V>>} to an {@code MultiValueMap<K, V>}.\r\n * @param targetMap the original map\r\n * @return the adapted multi-value map (wrapping the original map)\r\n * @since 3.1\r\n */\r\npublic static <K, V> MultiValueMap<K, V> toMultiValueMap(Map<K, List<V>> targetMap) {\r\n    return new MultiValueMapAdapter<>(targetMap);\r\n}",
    "comment": "\n\t * Adapt a {@code Map<K, List<V>>} to an {@code MultiValueMap<K, V>}.\n\t * @param targetMap the original map\n\t * @return the adapted multi-value map (wrapping the original map)\n\t * @since 3.1\n\t "
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#unmodifiableMultiValueMap(MultiValueMap<? extends K,? extends V>)",
    "entityType": "method",
    "code": "/**\r\n * Return an unmodifiable view of the specified multi-value map.\r\n * @param targetMap the map for which an unmodifiable view is to be returned.\r\n * @return an unmodifiable view of the specified multi-value map\r\n * @since 3.1\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic static <K, V> MultiValueMap<K, V> unmodifiableMultiValueMap(MultiValueMap<? extends K, ? extends V> targetMap) {\r\n    Assert.notNull(targetMap, \"'targetMap' must not be null\");\r\n    if (targetMap instanceof UnmodifiableMultiValueMap) {\r\n        return (MultiValueMap<K, V>) targetMap;\r\n    }\r\n    return new UnmodifiableMultiValueMap<>(targetMap);\r\n}",
    "comment": "\n\t * Return an unmodifiable view of the specified multi-value map.\n\t * @param targetMap the map for which an unmodifiable view is to be returned.\n\t * @return an unmodifiable view of the specified multi-value map\n\t * @since 3.1\n\t "
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#compositeMap(Map<K,V>,Map<K,V>)",
    "entityType": "method",
    "code": "/**\r\n * Return a (partially unmodifiable) map that combines the provided two\r\n * maps. Invoking {@link Map#put(Object, Object)} or {@link Map#putAll(Map)}\r\n * on the returned map results in an {@link UnsupportedOperationException}.\r\n * <p>In the case of a key collision, {@code first} takes precedence over\r\n * {@code second}. In other words, entries in {@code second} with a key\r\n * that is also mapped by {@code first} are effectively ignored.\r\n * @param first the first map to compose\r\n * @param second the second map to compose\r\n * @return a new map that composes the given two maps\r\n * @since 6.2\r\n */\r\npublic static <K, V> Map<K, V> compositeMap(Map<K, V> first, Map<K, V> second) {\r\n    return new CompositeMap<>(first, second);\r\n}",
    "comment": "\n\t * Return a (partially unmodifiable) map that combines the provided two\n\t * maps. Invoking {@link Map#put(Object, Object)} or {@link Map#putAll(Map)}\n\t * on the returned map results in an {@link UnsupportedOperationException}.\n\t * <p>In the case of a key collision, {@code first} takes precedence over\n\t * {@code second}. In other words, entries in {@code second} with a key\n\t * that is also mapped by {@code first} are effectively ignored.\n\t * @param first the first map to compose\n\t * @param second the second map to compose\n\t * @return a new map that composes the given two maps\n\t * @since 6.2\n\t "
  },
  {
    "entityId": "org.springframework.util.CollectionUtils#compositeMap(Map<K,V>,Map<K,V>,BiFunction<K,V,V>,Consumer<Map<K,V>>)",
    "entityType": "method",
    "code": "/**\r\n * Return a map that combines the provided maps. Invoking\r\n * {@link Map#put(Object, Object)} on the returned map will apply\r\n * {@code putFunction}, or will throw an\r\n * {@link UnsupportedOperationException} {@code putFunction} is\r\n * {@code null}. The same applies to {@link Map#putAll(Map)} and\r\n * {@code putAllFunction}.\r\n * <p>In the case of a key collision, {@code first} takes precedence over\r\n * {@code second}. In other words, entries in {@code second} with a key\r\n * that is also mapped by {@code first} are effectively ignored.\r\n * @param first the first map to compose\r\n * @param second the second map to compose\r\n * @param putFunction applied when {@code Map::put} is invoked. If\r\n * {@code null}, {@code Map::put} throws an\r\n * {@code UnsupportedOperationException}.\r\n * @param putAllFunction applied when {@code Map::putAll} is invoked. If\r\n * {@code null}, {@code Map::putAll} throws an\r\n * {@code UnsupportedOperationException}.\r\n * @return a new map that composes the give maps\r\n * @since 6.2\r\n */\r\npublic static <K, V> Map<K, V> compositeMap(Map<K, V> first, Map<K, V> second, @Nullable BiFunction<K, V, V> putFunction, @Nullable Consumer<Map<K, V>> putAllFunction) {\r\n    return new CompositeMap<>(first, second, putFunction, putAllFunction);\r\n}",
    "comment": "\n\t * Return a map that combines the provided maps. Invoking\n\t * {@link Map#put(Object, Object)} on the returned map will apply\n\t * {@code putFunction}, or will throw an\n\t * {@link UnsupportedOperationException} {@code putFunction} is\n\t * {@code null}. The same applies to {@link Map#putAll(Map)} and\n\t * {@code putAllFunction}.\n\t * <p>In the case of a key collision, {@code first} takes precedence over\n\t * {@code second}. In other words, entries in {@code second} with a key\n\t * that is also mapped by {@code first} are effectively ignored.\n\t * @param first the first map to compose\n\t * @param second the second map to compose\n\t * @param putFunction applied when {@code Map::put} is invoked. If\n\t * {@code null}, {@code Map::put} throws an\n\t * {@code UnsupportedOperationException}.\n\t * @param putAllFunction applied when {@code Map::putAll} is invoked. If\n\t * {@code null}, {@code Map::putAll} throws an\n\t * {@code UnsupportedOperationException}.\n\t * @return a new map that composes the give maps\n\t * @since 6.2\n\t "
  }
]